<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="bfd728c1d0c504dbec492943ca8e74e081796110" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition&quot;&gt;https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition&lt;/a&gt; defines &quot;safe&quot; as used by this package.</source>
          <target state="translated">&lt;a href=&quot;https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition&quot;&gt;https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition&lt;/a&gt; 은이 패키지에서 사용되는 &quot;안전&quot;을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c919ab787e33855057ab4da89511287a977f3f0b" translate="yes" xml:space="preserve">
          <source>A &quot;p&quot; or &quot;P&quot; exponent indicates a base 2 (rather then base 10) exponent; for instance, &quot;0x1.fffffffffffffp1023&quot; (using base 0) represents the maximum float64 value. For hexadecimal mantissae, the exponent character must be one of 'p' or 'P', if present (an &quot;e&quot; or &quot;E&quot; exponent indicator cannot be distinguished from a mantissa digit).</source>
          <target state="translated">&quot;p&quot;또는 &quot;P&quot;지수는 기수 2 (기수 10이 아닌) 지수를 나타내고; 예를 들어 &quot;0x1.fffffffffffffp1023&quot;(기본 0 사용)은 최대 float64 값을 나타냅니다. 16 진 가수의 경우 지수 문자는 존재하는 경우 'p'또는 'P'중 하나 여야합니다 ( &quot;e&quot;또는 &quot;E&quot;지수 표시기는 가수 숫자와 구별 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="1123f6aad96443b92187d542899cc95b9bb2fe32" translate="yes" xml:space="preserve">
          <source>A BadDecl node is a placeholder for declarations containing syntax errors for which no correct declaration nodes can be created.</source>
          <target state="translated">BadDecl 노드는 올바른 선언 노드를 만들 수없는 구문 오류가 포함 된 선언의 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="dcfeb402a68dc1a9b5372f3908c42874cd09a220" translate="yes" xml:space="preserve">
          <source>A BadExpr node is a placeholder for expressions containing syntax errors for which no correct expression nodes can be created.</source>
          <target state="translated">BadExpr 노드는 올바른 표현식 노드를 만들 수없는 구문 오류가 포함 된 표현식의 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="7eb045abea7688d577a2f4aa68d42b63d688f628" translate="yes" xml:space="preserve">
          <source>A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created.</source>
          <target state="translated">BadStmt 노드는 올바른 명령문 노드를 작성할 수없는 구문 오류가 포함 된 명령문의 플레이스 홀더입니다.</target>
        </trans-unit>
        <trans-unit id="a09691e16560521f59b5e41dfa68af0b91ddf921" translate="yes" xml:space="preserve">
          <source>A Basic represents a basic type.</source>
          <target state="translated">기본은 기본 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4e96e9fa6016f0735848cb5e83d084a95898493d" translate="yes" xml:space="preserve">
          <source>A BasicLit node represents a literal of basic type.</source>
          <target state="translated">BasicLit 노드는 기본 유형의 리터럴을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f0d28c34a4273c4c205bdbd169e7a24e79d3af70" translate="yes" xml:space="preserve">
          <source>A BasicType holds fields common to all basic types.</source>
          <target state="translated">BasicType은 모든 기본 유형에 공통 인 필드를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="4aaf562bb9c344cab2878d8a67694cab58f267fe" translate="yes" xml:space="preserve">
          <source>A BinaryExpr node represents a binary expression.</source>
          <target state="translated">BinaryExpr 노드는 이진 식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c75800e242cb7940cab3ce54f7f2ee89e873c3a1" translate="yes" xml:space="preserve">
          <source>A Block represents a PEM encoded structure.</source>
          <target state="translated">블록은 PEM으로 인코딩 된 구조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6eb1e62ee558fbb06e309b0a1474fe5590194eb9" translate="yes" xml:space="preserve">
          <source>A Block represents an implementation of block cipher using a given key. It provides the capability to encrypt or decrypt individual blocks. The mode implementations extend that capability to streams of blocks.</source>
          <target state="translated">블록은 주어진 키를 사용하여 블록 암호의 구현을 나타냅니다. 개별 블록을 암호화 또는 해독하는 기능을 제공합니다. 모드 구현은이 기능을 블록 스트림으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="b09c35891b54fa0138a8d1707cf64366451f1193" translate="yes" xml:space="preserve">
          <source>A BlockMode represents a block cipher running in a block-based mode (CBC, ECB etc).</source>
          <target state="translated">BlockMode는 블록 기반 모드 (CBC, ECB 등)에서 실행되는 블록 암호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8dfe588d503302439640a67e38197d5d027bab2f" translate="yes" xml:space="preserve">
          <source>A BlockStmt node represents a braced statement list.</source>
          <target state="translated">BlockStmt 노드는 괄호 명령문 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a6596c287920a60f833a744c8df6d962e72ea7d5" translate="yes" xml:space="preserve">
          <source>A BoolType represents a boolean type.</source>
          <target state="translated">BoolType은 부울 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f359d441ebb4d88e77ab94131c369de596c1ee19" translate="yes" xml:space="preserve">
          <source>A BranchStmt node represents a break, continue, goto, or fallthrough statement.</source>
          <target state="translated">BranchStmt 노드는 break, continue, goto 또는 fallthrough 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3fb505f6912b6b4ddfb95346dfcc6a9c7667dc18" translate="yes" xml:space="preserve">
          <source>A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use.</source>
          <target state="translated">버퍼는 읽기 및 쓰기 방법을 사용하는 가변 크기의 바이트 버퍼입니다. 버퍼의 0 값은 사용 가능한 빈 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="1461605a0709414441624bd277a7be479b6f6011" translate="yes" xml:space="preserve">
          <source>A BufferPool is an interface for getting and returning temporary byte slices for use by io.CopyBuffer.</source>
          <target state="translated">BufferPool은 io.CopyBuffer에서 사용할 임시 바이트 슬라이스를 가져오고 리턴하기위한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b6d17c51ac02141341d0a91f23ea17ed19e01909" translate="yes" xml:space="preserve">
          <source>A Builder is used to efficiently build a string using Write methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder.</source>
          <target state="translated">Builder는 Write 메서드를 사용하여 문자열을 효율적으로 작성하는 데 사용됩니다. 메모리 복사를 최소화합니다. 0 값을 사용할 준비가되었습니다. 0이 아닌 빌더를 복사하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="037cb25e954c2c0cb7d3dbedf060bc007d0e89cd" translate="yes" xml:space="preserve">
          <source>A Builtin represents a built-in function. Builtins don't have a valid type.</source>
          <target state="translated">내장은 내장 기능을 나타냅니다. 내장에는 유효한 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="892968a868a7e4a907bd63b74cc7f80a6a88354c" translate="yes" xml:space="preserve">
          <source>A ByteOrder specifies how to convert byte sequences into 16-, 32-, or 64-bit unsigned integers.</source>
          <target state="translated">ByteOrder는 바이트 시퀀스를 16, 32 또는 64 비트 부호없는 정수로 변환하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6e655396894e089ec7bd8b95669d2a7e9ddcfcd0" translate="yes" xml:space="preserve">
          <source>A CallExpr node represents an expression followed by an argument list.</source>
          <target state="translated">CallExpr 노드는 표현식과 인수 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="64a8f488b495e864ba78bb0d182f77c49a17af80" translate="yes" xml:space="preserve">
          <source>A CancelFunc tells an operation to abandon its work. A CancelFunc does not wait for the work to stop. A CancelFunc may be called by multiple goroutines simultaneously. After the first call, subsequent calls to a CancelFunc do nothing.</source>
          <target state="translated">CancelFunc는 작업을 포기하도록 작업을 지시합니다. CancelFunc는 작업이 중지 될 때까지 기다리지 않습니다. 여러 고 루틴이 동시에 CancelFunc를 호출 할 수 있습니다. 첫 번째 호출 후 CancelFunc에 대한 후속 호출은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b10cf9ceb81b6bc3b8dcabe10017a6a967fe252" translate="yes" xml:space="preserve">
          <source>A CaseClause represents a case of an expression or type switch statement.</source>
          <target state="translated">CaseClause는 표현식 또는 유형 스위치 문의 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3df0336a740616143abfbd052730d859e0747a00" translate="yes" xml:space="preserve">
          <source>A Certificate is a chain of one or more certificates, leaf first.</source>
          <target state="translated">인증서는 먼저 하나 이상의 인증서 체인입니다.</target>
        </trans-unit>
        <trans-unit id="6ce79efd48b66ecd681a102ece34c5f01f30b6bb" translate="yes" xml:space="preserve">
          <source>A Certificate represents an X.509 certificate.</source>
          <target state="translated">인증서는 X.509 인증서를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dacc044ff83252e8da8b7c83ac652df96b4a7263" translate="yes" xml:space="preserve">
          <source>A Chan represents a channel type.</source>
          <target state="translated">Chan은 채널 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="489cc0d6b95ec8b9ebbf24e11966fa69854f5cb9" translate="yes" xml:space="preserve">
          <source>A ChanDir value indicates a channel direction.</source>
          <target state="translated">ChanDir 값은 채널 방향을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="070a85a0a8fd173d8b11a96f53495cdee7edbae6" translate="yes" xml:space="preserve">
          <source>A ChanType node represents a channel type.</source>
          <target state="translated">ChanType 노드는 채널 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2aad134ce320508a2ed662401c3a35abf0301e47" translate="yes" xml:space="preserve">
          <source>A CharData represents XML character data (raw text), in which XML escape sequences have been replaced by the characters they represent.</source>
          <target state="translated">CharData는 XML 이스케이프 시퀀스가 ​​나타내는 문자로 대체 된 XML 문자 데이터 (원시 텍스트)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cc58af40e127ae636ebfd4b1dab058b1f5ba3059" translate="yes" xml:space="preserve">
          <source>A CharType represents a signed character type.</source>
          <target state="translated">CharType은 부호있는 문자 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7571ca3899875977a8c2e856f154d99ef71130b0" translate="yes" xml:space="preserve">
          <source>A CheckEqualError is the result CheckEqual finding an error.</source>
          <target state="translated">CheckEqualError는 CheckEqual이 오류를 찾는 결과입니다.</target>
        </trans-unit>
        <trans-unit id="e5e6d49e7769874182960864050ac2745252cf02" translate="yes" xml:space="preserve">
          <source>A CheckError is the result of Check finding an error.</source>
          <target state="translated">CheckError는 Check에서 오류를 찾은 결과입니다.</target>
        </trans-unit>
        <trans-unit id="e40b1d8be51a7ea43b64ef548b13353308a4f9f7" translate="yes" xml:space="preserve">
          <source>A Checker maintains the state of the type checker. It must be created with NewChecker.</source>
          <target state="translated">Checker는 유형 검사기의 상태를 유지합니다. NewChecker로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f430ceb71dc6fb2459e64f75abc35fb2c2dcc962" translate="yes" xml:space="preserve">
          <source>A Cipher is an instance of RC4 using a particular key.</source>
          <target state="translated">암호는 특정 키를 사용하는 RC4 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="cebfde1712e5a042e0276018aed63bffa5b48954" translate="yes" xml:space="preserve">
          <source>A Class is the DWARF 4 class of an attribute value.</source>
          <target state="translated">클래스는 속성 값의 DWARF 4 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fe94b934cba52a3f0f37c36e65520044cdec12c3" translate="yes" xml:space="preserve">
          <source>A Client is an HTTP client. Its zero value (DefaultClient) is a usable client that uses DefaultTransport.</source>
          <target state="translated">클라이언트는 HTTP 클라이언트입니다. 제로 값 (DefaultClient)은 DefaultTransport를 사용하는 사용 가능한 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="dff10f0c9a02b3533a2c5ff6f1aa4ea18efc93c0" translate="yes" xml:space="preserve">
          <source>A Client is higher-level than a RoundTripper (such as Transport) and additionally handles HTTP details such as cookies and redirects.</source>
          <target state="translated">클라이언트는 RoundTripper (예 : 전송)보다 상위 수준이며 쿠키 및 리디렉션과 같은 HTTP 세부 정보를 추가로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7476021d61e8a0df9fbc63c7ca0b91cd642f328e" translate="yes" xml:space="preserve">
          <source>A Client represents a client connection to an SMTP server.</source>
          <target state="translated">클라이언트는 SMTP 서버에 대한 클라이언트 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b71630fa521f0999628fd58f1a5f36c35682c154" translate="yes" xml:space="preserve">
          <source>A ClientCodec implements writing of RPC requests and reading of RPC responses for the client side of an RPC session. The client calls WriteRequest to write a request to the connection and calls ReadResponseHeader and ReadResponseBody in pairs to read responses. The client calls Close when finished with the connection. ReadResponseBody may be called with a nil argument to force the body of the response to be read and then discarded. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ClientCodec은 RPC 세션의 클라이언트 측에 대한 RPC 요청 쓰기 및 RPC 응답 읽기를 구현합니다. 클라이언트는 WriteRequest를 호출하여 연결에 요청을 작성하고 ReadResponseHeader와 ReadResponseBody를 쌍으로 호출하여 응답을 읽습니다. 연결이 끝나면 클라이언트는 Close를 호출합니다. ReadResponseBody는 nil 인수로 호출되어 응답 본문을 읽은 다음 버립니다. 동시 액세스에 대한 정보는 NewClient의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="360c604b631953905f3f4216c2aa9c0493f9a5c4" translate="yes" xml:space="preserve">
          <source>A Cmd cannot be reused after calling its Run, Output or CombinedOutput methods.</source>
          <target state="translated">Cmd는 Run, Output 또는 CombinedOutput 메소드를 호출 한 후에 재사용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f9b0eb470afbfa84ac3e6bd695f6f7547e25e63" translate="yes" xml:space="preserve">
          <source>A CommClause node represents a case of a select statement.</source>
          <target state="translated">CommClause 노드는 select 문의 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="126d1d49a2d0aecea067ab9d4f53c05821460337" translate="yes" xml:space="preserve">
          <source>A Comment node represents a single //-style or /*-style comment.</source>
          <target state="translated">주석 노드는 단일 // 스타일 또는 / * 스타일 주석을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="102b0aae1b692037597357ab6c34e305a5d50abf" translate="yes" xml:space="preserve">
          <source>A Comment represents an XML comment of the form &amp;lt;!--comment--&amp;gt;. The bytes do not include the &amp;lt;!-- and --&amp;gt; comment markers.</source>
          <target state="translated">주석은 &amp;lt;!-comment-&amp;gt; 형식의 XML 주석을 나타냅니다. 바이트는 &amp;lt;!-및-&amp;gt; 주석 마커를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f01ed0a912eea13962aa863979815ef144c0e12e" translate="yes" xml:space="preserve">
          <source>A CommentGroup represents a sequence of comments with no other tokens and no empty lines between.</source>
          <target state="translated">CommentGroup은 다른 토큰이없고 빈 줄이없는 일련의 주석을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6618446c717172eb2ba87e09ce048aad816582b5" translate="yes" xml:space="preserve">
          <source>A CommentMap maps an AST node to a list of comment groups associated with it. See NewCommentMap for a description of the association.</source>
          <target state="translated">CommentMap은 AST 노드를 이와 관련된 주석 그룹 목록에 매핑합니다. 연관에 대한 설명은 NewCommentMap을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4541544833c16b1a72e733c00fdf848bd8e1ec5a" translate="yes" xml:space="preserve">
          <source>A CommentedNode bundles an AST node and corresponding comments. It may be provided as argument to any of the Fprint functions.</source>
          <target state="translated">CommentedNode는 AST 노드와 해당 주석을 묶습니다. Fprint 함수에 대한 인수로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b25bec4a4f00e250f1372003588c09e5587d686b" translate="yes" xml:space="preserve">
          <source>A CommonType holds fields common to multiple types. If a field is not known or not applicable for a given type, the zero value is used.</source>
          <target state="translated">CommonType은 여러 유형에 공통 인 필드를 보유합니다. 필드를 알 수 없거나 지정된 유형에 적용 할 수없는 경우 0 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aff877fa9d1c634f1772007c128f36f1bc62e322" translate="yes" xml:space="preserve">
          <source>A ComplexType represents a complex floating point type.</source>
          <target state="translated">ComplexType은 복합 부동 소수점 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c1232fe7484bfb4ee0095518475648ab13064a76" translate="yes" xml:space="preserve">
          <source>A CompositeLit node represents a composite literal.</source>
          <target state="translated">CompositeLit 노드는 복합 리터럴을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0f70c579d931c29aa9cde9de4f1cce6833035c9f" translate="yes" xml:space="preserve">
          <source>A Compressor returns a new compressing writer, writing to w. The WriteCloser's Close method must be used to flush pending data to w. The Compressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned writer will be used only by one goroutine at a time.</source>
          <target state="translated">압축기는 w에 쓰는 새로운 압축 라이터를 반환합니다. 보류중인 데이터를 w로 플러시하려면 WriteCloser의 Close 메소드를 사용해야합니다. 압축기 자체는 여러 고 루틴을 동시에 호출하는 것이 안전해야하지만 각 반환 작가는 한 번에 하나의 고 루틴 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d87124c080041826540d92b145f7667559b16d7f" translate="yes" xml:space="preserve">
          <source>A Cond must not be copied after first use.</source>
          <target state="translated">처음 사용한 후에는 Cond를 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="74cea2d83b96c716a3176b36089838f2190c82b3" translate="yes" xml:space="preserve">
          <source>A Config node controls the output of Fprint.</source>
          <target state="translated">구성 노드는 Fprint의 출력을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="3c229591d56e4195e752fc2d9b259e9760a5c33b" translate="yes" xml:space="preserve">
          <source>A Config specifies the configuration for type checking. The zero value for Config is a ready-to-use default configuration.</source>
          <target state="translated">구성은 유형 확인을위한 구성을 지정합니다. Config의 제로 값은 바로 사용 가능한 기본 구성입니다.</target>
        </trans-unit>
        <trans-unit id="c0f1b53b3d403749973328df58e12a575ec9a7b0" translate="yes" xml:space="preserve">
          <source>A Config structure contains options for running a test.</source>
          <target state="translated">구성 구조에는 테스트를 실행하기위한 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c121cae17514d3fa4cae135216ea38cbdf6bbce1" translate="yes" xml:space="preserve">
          <source>A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it.</source>
          <target state="translated">구성 구조는 TLS 클라이언트 또는 서버를 구성하는 데 사용됩니다. TLS 함수에 전달 된 후에는 수정해서는 안됩니다. 구성을 재사용 할 수 있습니다. tls 패키지도 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3a452893d512c39ccf07d91afb2d3c4d36420f8" translate="yes" xml:space="preserve">
          <source>A Conn must call Close to return the connection to the database pool and may do so concurrently with a running query.</source>
          <target state="translated">Conn은 Close를 호출하여 데이터베이스 풀에 대한 연결을 리턴해야하며 실행중인 조회와 동시에이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7232532e891cd146be604b1b6ed41fa6024cd94" translate="yes" xml:space="preserve">
          <source>A Conn represents a secured connection. It implements the net.Conn interface.</source>
          <target state="translated">Conn은 보안 연결을 나타냅니다. net.Conn 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8a98021e4777c07cc886aaaaaab3e86d5dd758f8" translate="yes" xml:space="preserve">
          <source>A Conn represents a textual network protocol connection. It consists of a Reader and Writer to manage I/O and a Pipeline to sequence concurrent requests on the connection. These embedded types carry methods with them; see the documentation of those types for details.</source>
          <target state="translated">Conn은 텍스트 네트워크 프로토콜 연결을 나타냅니다. I / O를 관리하는 Reader와 Writer와 연결에서 동시 요청을 시퀀싱하는 파이프 라인으로 구성됩니다. 이 임베디드 유형에는 메소드가 있습니다. 자세한 내용은 해당 유형의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c4b224256a6ca255a6fb91fd1197343ba6039ae2" translate="yes" xml:space="preserve">
          <source>A ConnState represents the state of a client connection to a server. It's used by the optional Server.ConnState hook.</source>
          <target state="translated">ConnState는 서버에 대한 클라이언트 연결 상태를 나타냅니다. 선택적 Server.ConnState 후크에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e31df198984a84556e29056f951a830f56b070b2" translate="yes" xml:space="preserve">
          <source>A Connector can be passed to sql.OpenDB, to allow drivers to implement their own sql.DB constructors, or returned by DriverContext's OpenConnector method, to allow drivers access to context and to avoid repeated parsing of driver configuration.</source>
          <target state="translated">커넥터가 sql.OpenDB에 전달되어 드라이버가 자체 sql.DB 생성자를 구현하거나 DriverContext의 OpenConnector 메소드에 의해 리턴되어 드라이버가 컨텍스트에 액세스하고 드라이버 구성의 반복 구문 분석을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="044be90e3e3147d4e037da6309a7d2e940ba3c36" translate="yes" xml:space="preserve">
          <source>A Connector represents a driver in a fixed configuration and can create any number of equivalent Conns for use by multiple goroutines.</source>
          <target state="translated">커넥터는 고정 구성의 드라이버를 나타내며 여러 고 루틴에서 사용할 동등한 수의 Conn을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da4a343554925a1ddbea469e235e1555605d99a5" translate="yes" xml:space="preserve">
          <source>A Const represents a declared constant.</source>
          <target state="translated">Const는 선언 된 상수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4500800489d0c022304032a2e4a5cc3ccd1e4757" translate="yes" xml:space="preserve">
          <source>A Context carries a deadline, a cancellation signal, and other values across API boundaries.</source>
          <target state="translated">컨텍스트는 마감일, 취소 신호 및 기타 API 경계 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ad739093c7c2952b6f8d06103b8320cc9d3d6ee6" translate="yes" xml:space="preserve">
          <source>A Context specifies the supporting context for a build.</source>
          <target state="translated">컨텍스트는 빌드에 대한 지원 컨텍스트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="345b60f4218aab4a9e89ba61ffe19ba47293618c" translate="yes" xml:space="preserve">
          <source>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request.</source>
          <target state="translated">쿠키는 HTTP 응답의 Set-Cookie 헤더 또는 HTTP 요청의 Cookie 헤더에 전송 된 HTTP 쿠키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="439511987886b735bcc48bb82e45d11fb45c8e80" translate="yes" xml:space="preserve">
          <source>A CookieJar manages storage and use of cookies in HTTP requests.</source>
          <target state="translated">CookieJar는 HTTP 요청에서 쿠키의 저장 및 사용을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="9dbc27b974673707e8a2f913fec96abcb0bae1ca" translate="yes" xml:space="preserve">
          <source>A CorruptInputError reports the presence of corrupt input at a given offset.</source>
          <target state="translated">CorruptInputError는 지정된 오프셋에 손상된 입력이 있음을보고합니다.</target>
        </trans-unit>
        <trans-unit id="2a774110c2f1a711b8627926a4c791b50d477e36" translate="yes" xml:space="preserve">
          <source>A Cpu is a Mach-O cpu type.</source>
          <target state="translated">Cpu는 Mach-O CPU 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bf8833559ac0ea08bb6631d4af289d3312b520f0" translate="yes" xml:space="preserve">
          <source>A Curve represents a short-form Weierstrass curve with a=-3. See &lt;a href=&quot;https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html&quot;&gt;https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html&lt;/a&gt;</source>
          <target state="translated">곡선은 a = -3 인 짧은 형태의 Weierstrass 곡선을 나타냅니다. 참조 &lt;a href=&quot;https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html&quot;&gt;https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d334a921cf08b96ed08ebbd1348bd4502b8cbff" translate="yes" xml:space="preserve">
          <source>A DeclStmt node represents a declaration in a statement list.</source>
          <target state="translated">DeclStmt 노드는 명령문 목록의 선언을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7fc0e178afca45507a82048502fc3190729e7a51" translate="yes" xml:space="preserve">
          <source>A Decoder manages the receipt of type and data information read from the remote side of a connection. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">디코더는 연결의 원격 쪽에서 읽은 유형 및 데이터 정보의 수신을 관리합니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aaa935f1cb5a55ee24b563854564808c1c7b94ab" translate="yes" xml:space="preserve">
          <source>A Decoder reads and decodes JSON values from an input stream.</source>
          <target state="translated">디코더는 입력 스트림에서 JSON 값을 읽고 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="6a0ff998ca32c8d66166ff01613dc1c8be7bbffd" translate="yes" xml:space="preserve">
          <source>A Decoder represents an XML parser reading a particular input stream. The parser assumes that its input is encoded in UTF-8.</source>
          <target state="translated">디코더는 특정 입력 스트림을 읽는 XML 파서를 나타냅니다. 파서는 입력이 UTF-8로 인코딩 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fa6eac4594c2e9110158777fdd5ccd573d3725c4" translate="yes" xml:space="preserve">
          <source>A Decompressor returns a new decompressing reader, reading from r. The ReadCloser's Close method must be used to release associated resources. The Decompressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned reader will be used only by one goroutine at a time.</source>
          <target state="translated">압축 해제 기는 r에서 읽은 새로운 압축 해제 리더를 반환합니다. 관련 리소스를 해제하려면 ReadCloser의 Close 메서드를 사용해야합니다. 압축 해제 기 자체는 여러 고 루틴을 동시에 호출하는 것이 안전해야하지만 각 반환 된 리더는 한 번에 하나의 고 루틴 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3177b45a687e697befcd3f3f2594b30a3ecf0c86" translate="yes" xml:space="preserve">
          <source>A DeferStmt node represents a defer statement.</source>
          <target state="translated">DeferStmt 노드는 연기 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b67d05f625ac987a07f0eb01489bee222c70495e" translate="yes" xml:space="preserve">
          <source>A Delim is a JSON array or object delimiter, one of [ ] { or }.</source>
          <target state="translated">Delim은 JSON 배열 또는 객체 분리 문자이며 [] {또는} 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3528f7cabfe02dad4395c36da0f26da2899865f1" translate="yes" xml:space="preserve">
          <source>A Dialer contains options for connecting to an address.</source>
          <target state="translated">다이얼러에는 주소에 연결하기위한 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6408d9ab2f66c0a4e6e86f5a54d85c61373257b3" translate="yes" xml:space="preserve">
          <source>A Dir implements FileSystem using the native file system restricted to a specific directory tree.</source>
          <target state="translated">Dir은 특정 디렉토리 트리로 제한된 기본 파일 시스템을 사용하여 FileSystem을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f86e22f5699c7e88fdb174b30fabf27d65d245e3" translate="yes" xml:space="preserve">
          <source>A Directive represents an XML directive of the form &amp;lt;!text&amp;gt;. The bytes do not include the &amp;lt;! and &amp;gt; markers.</source>
          <target state="translated">지시문은 &amp;lt;! text&amp;gt; 형식의 XML 지시문을 나타냅니다. 바이트는 &amp;lt;! 및&amp;gt; 마커.</target>
        </trans-unit>
        <trans-unit id="f0be171834370163d199abe38b806da6288a68ad" translate="yes" xml:space="preserve">
          <source>A DotDotDotType represents the variadic ... function parameter.</source>
          <target state="translated">DotDotDotType은 variadic ... 함수 매개 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6384d5f5a370c8e493c8712f20d49ae8b99cc150" translate="yes" xml:space="preserve">
          <source>A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.</source>
          <target state="translated">Duration은 두 순간 사이의 경과 시간을 int64 나노초 카운트로 나타냅니다. 이 표현은 표현 가능한 최대 기간을 약 290 년으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="5ecdfd7bc84be9f2d17a162b33d49b58be95285e" translate="yes" xml:space="preserve">
          <source>A Dylib represents a Mach-O load dynamic library command.</source>
          <target state="translated">Dylib는 Mach-O로드 동적 라이브러리 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0acd35cd81a153e22929826effaf5c42378d0fea" translate="yes" xml:space="preserve">
          <source>A DylibCmd is a Mach-O load dynamic library command.</source>
          <target state="translated">DylibCmd는 Mach-O로드 동적 라이브러리 명령입니다.</target>
        </trans-unit>
        <trans-unit id="2bb7617e0174a9893ba90aa3aabb8948c586903b" translate="yes" xml:space="preserve">
          <source>A Dysymtab represents a Mach-O dynamic symbol table command.</source>
          <target state="translated">Dysymtab은 Mach-O 동적 기호 테이블 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a3d7d413601467bbc9c94994480cf4597efe0894" translate="yes" xml:space="preserve">
          <source>A DysymtabCmd is a Mach-O dynamic symbol table command.</source>
          <target state="translated">DysymtabCmd는 Mach-O 동적 기호 테이블 명령입니다.</target>
        </trans-unit>
        <trans-unit id="0df08f2b1aaf090c6e60a692d9f1a3e5e77aad17" translate="yes" xml:space="preserve">
          <source>A FatArch is a Mach-O File inside a FatFile.</source>
          <target state="translated">FatArch는 FatFile 내부의 Mach-O 파일입니다.</target>
        </trans-unit>
        <trans-unit id="feab8100790b52cb094e5b75b69875ccd9ff711e" translate="yes" xml:space="preserve">
          <source>A FatArchHeader represents a fat header for a specific image architecture.</source>
          <target state="translated">FatArchHeader는 특정 이미지 아키텍처에 대한 fat 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b79b4d3682257c685c1bf7a92b274c21d4a76b36" translate="yes" xml:space="preserve">
          <source>A FatFile is a Mach-O universal binary that contains at least one architecture.</source>
          <target state="translated">FatFile은 하나 이상의 아키텍처를 포함하는 Mach-O 범용 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="39a6737a2fd79f471ed1f017391abd2beae09609" translate="yes" xml:space="preserve">
          <source>A Field is a single attribute/value pair in an Entry.</source>
          <target state="translated">필드는 항목의 단일 속성 / 값 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="45548081441583b2b52c076e664e8a1b9b5bfb95" translate="yes" xml:space="preserve">
          <source>A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. Field.Names is nil for unnamed parameters (parameter lists which only contain types) and embedded struct fields. In the latter case, the field name is the type name.</source>
          <target state="translated">Field는 구조체 형식의 필드 선언 목록, 인터페이스 형식의 메서드 목록 또는 서명의 매개 변수 / 결과 선언을 나타냅니다. 명명되지 않은 매개 변수 (유형 만 포함하는 매개 변수 목록) 및 포함 된 구조체 필드에는 Field.Names가 0입니다. 후자의 경우 필드 이름은 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6dd0ed32ad3016ad5f04a116fae45f9934e70025" translate="yes" xml:space="preserve">
          <source>A FieldFilter may be provided to Fprint to control the output.</source>
          <target state="translated">출력을 제어하기 위해 Fprint에 FieldFilter가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c9353c6215676d705e43fd5de613dde8e8e192" translate="yes" xml:space="preserve">
          <source>A FieldList represents a list of Fields, enclosed by parentheses or braces.</source>
          <target state="translated">FieldList는 괄호 또는 중괄호로 묶인 필드 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c37cc883e1e912226df4c951571e7fa7ce2829b4" translate="yes" xml:space="preserve">
          <source>A File is a handle for a file belonging to a FileSet. A File has a name, size, and line offset table.</source>
          <target state="translated">File은 FileSet에 속하는 파일에 대한 핸들입니다. 파일에는 이름, 크기 및 행 오프셋 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="724a9870762bd470aa21565f1e367e985eaadbc5" translate="yes" xml:space="preserve">
          <source>A File is returned by a FileSystem's Open method and can be served by the FileServer implementation.</source>
          <target state="translated">File은 FileSystem의 Open 메소드에 의해 리턴되며 FileServer 구현에 의해 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933657418db475690f900fc0cb038c8ec20fa23f" translate="yes" xml:space="preserve">
          <source>A File node represents a Go source file.</source>
          <target state="translated">파일 노드는 Go 소스 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88092327b3f39b704b7d9dafd634ca25e188e4c7" translate="yes" xml:space="preserve">
          <source>A File represents an open ELF file.</source>
          <target state="translated">파일은 열린 ELF 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="65e617a52a2a3202382d475d890e7de2c4e15f40" translate="yes" xml:space="preserve">
          <source>A File represents an open Mach-O file.</source>
          <target state="translated">파일은 열린 Mach-O 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="705c0d822b227bbdfb608bdb5b0dd5b1341bcaf4" translate="yes" xml:space="preserve">
          <source>A File represents an open PE file.</source>
          <target state="translated">파일은 열린 PE 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8041758a835e2e671f1edd9a36a5c0717c227b6" translate="yes" xml:space="preserve">
          <source>A File represents an open Plan 9 a.out file.</source>
          <target state="translated">파일은 열린 Plan 9 a.out 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b02261788cea23a7e13cd4df1998baba9a3f063" translate="yes" xml:space="preserve">
          <source>A FileHeader describes a file part of a multipart request.</source>
          <target state="translated">FileHeader는 멀티 파트 요청의 파일 부분을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3e9ebbcbf6bf5d2e7a5168723d1cd92457a28d9c" translate="yes" xml:space="preserve">
          <source>A FileHeader represents a Mach-O file header.</source>
          <target state="translated">FileHeader는 Mach-O 파일 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c464dfa1166cb87240fc924ea37de926c8387ff0" translate="yes" xml:space="preserve">
          <source>A FileHeader represents a Plan 9 a.out file header.</source>
          <target state="translated">FileHeader는 Plan 9 a.out 파일 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44f8b75b12734f33f611a1d8eac4363a03be63e4" translate="yes" xml:space="preserve">
          <source>A FileHeader represents an ELF file header.</source>
          <target state="translated">FileHeader는 ELF 파일 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="de6784d1f1cbed04559df2db8caf5220c3d40a51" translate="yes" xml:space="preserve">
          <source>A FileInfo describes a file and is returned by Stat and Lstat.</source>
          <target state="translated">FileInfo는 파일을 설명하고 Stat 및 Lstat에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="256e3c3b330f9698a158d9ebc412d515e72f62ef" translate="yes" xml:space="preserve">
          <source>A FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories.</source>
          <target state="translated">FileMode는 파일의 모드 및 권한 비트를 나타냅니다. 비트는 모든 시스템에서 동일한 정의를 가지므로 파일에 대한 정보를 한 시스템에서 다른 시스템으로 이동할 수 있습니다. 모든 비트가 모든 시스템에 적용되는 것은 아닙니다. 디렉토리에 필요한 유일한 비트는 ModeDir입니다.</target>
        </trans-unit>
        <trans-unit id="071474a5e59c2cbe4022eddafca1945a74b7de9b" translate="yes" xml:space="preserve">
          <source>A FileSet represents a set of source files. Methods of file sets are synchronized; multiple goroutines may invoke them concurrently.</source>
          <target state="translated">FileSet은 소스 파일 세트를 나타냅니다. 파일 세트의 메소드가 동기화됩니다. 여러 고 루틴이 동시에 그들을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b2dd840727f49f9eba8be4237966f01f435fad4" translate="yes" xml:space="preserve">
          <source>A FileSystem implements access to a collection of named files. The elements in a file path are separated by slash ('/', U+002F) characters, regardless of host operating system convention.</source>
          <target state="translated">FileSystem은 명명 된 파일 모음에 대한 액세스를 구현합니다. 파일 경로의 요소는 호스트 운영 체제 규칙에 관계없이 슬래시 ( '/', U + 002F) 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="78a9e5c4832223d5a011e8dddc53aa5d75c7f4d4" translate="yes" xml:space="preserve">
          <source>A Flag accepts any data and is set to true if present.</source>
          <target state="translated">플래그는 모든 데이터를 허용하며 존재하는 경우 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9fa93680f639a304c47bdf98c8a62274d8186d35" translate="yes" xml:space="preserve">
          <source>A Flag represents the state of a flag.</source>
          <target state="translated">플래그는 플래그의 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="234f76bb20d5f9eec0d53dcc77b2a13d82eadf61" translate="yes" xml:space="preserve">
          <source>A FlagSet represents a set of defined flags. The zero value of a FlagSet has no name and has ContinueOnError error handling.</source>
          <target state="translated">FlagSet은 정의 된 플래그 세트를 나타냅니다. FlagSet의 0 값은 이름이 없으며 ContinueOnError 오류 처리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5288f46811dffeaa7ea61e19365d12c9632b9778" translate="yes" xml:space="preserve">
          <source>A FloatType represents a floating point type.</source>
          <target state="translated">FloatType은 부동 소수점 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0b1e4bc4cb382e2c275611b3238464917e62a22d" translate="yes" xml:space="preserve">
          <source>A ForStmt represents a for statement.</source>
          <target state="translated">ForStmt는 for 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0c2fc1a03e93ae8b537c5962f0b0b7762e61aaf4" translate="yes" xml:space="preserve">
          <source>A FormatError reports that the input is not a valid JPEG.</source>
          <target state="translated">FormatError는 입력이 유효한 JPEG가 아니라고보고합니다.</target>
        </trans-unit>
        <trans-unit id="6fad07f1b5a1dbeefd78d7d2f7d158225dd26546" translate="yes" xml:space="preserve">
          <source>A FormatError reports that the input is not a valid PNG.</source>
          <target state="translated">FormatError는 입력이 유효한 PNG가 아니라고보고합니다.</target>
        </trans-unit>
        <trans-unit id="dc9cb9f874380cdd581f85bc7cca4178b91bf7ca" translate="yes" xml:space="preserve">
          <source>A Func collects information about a single function.</source>
          <target state="translated">Func은 단일 기능에 대한 정보를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="49cb9decf874b456f0efef0977636083343d1115" translate="yes" xml:space="preserve">
          <source>A Func represents a Go function in the running binary.</source>
          <target state="translated">Func은 실행중인 바이너리에서 Go 함수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11647ec5e44e1c0de00d02c89c294903e5e1dff5" translate="yes" xml:space="preserve">
          <source>A Func represents a declared function, concrete method, or abstract (interface) method. Its Type() is always a *Signature. An abstract method may belong to many interfaces due to embedding.</source>
          <target state="translated">Func은 선언 된 함수, 구체적 메소드 또는 추상 (인터페이스) 메소드를 나타냅니다. Type ()은 항상 * 서명입니다. 내장으로 인해 추상 메소드가 많은 인터페이스에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e94aa8231cb387fe4a10412ff3ac134dd8f4c188" translate="yes" xml:space="preserve">
          <source>A FuncDecl node represents a function declaration.</source>
          <target state="translated">FuncDecl 노드는 함수 선언을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="94e066c3ac487a79d47768c2220a49644d0bf184" translate="yes" xml:space="preserve">
          <source>A FuncLit node represents a function literal.</source>
          <target state="translated">FuncLit 노드는 함수 리터럴을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="09e2235228768330e677d304af97960b02fdd8c5" translate="yes" xml:space="preserve">
          <source>A FuncType node represents a function type.</source>
          <target state="translated">FuncType 노드는 함수 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dec14bd2e595d84c173c9bf0c1df71b1223eddb0" translate="yes" xml:space="preserve">
          <source>A FuncType represents a function type.</source>
          <target state="translated">FuncType은 함수 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="987651ff41c347596f94cc565b5f05d25059c2c5" translate="yes" xml:space="preserve">
          <source>A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.IsValid()) indicates a parenthesized declaration.</source>
          <target state="translated">GenDecl 노드 (일반 선언 노드)는 가져 오기, 상수, 유형 또는 변수 선언을 나타냅니다. 유효한 Lparen 위치 (Lparen.IsValid ())는 괄호로 묶은 선언을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ebbcb57a5319bb37519fc330de793ad98efdcc2" translate="yes" xml:space="preserve">
          <source>A Generator can generate random values of its own type.</source>
          <target state="translated">생성기는 자체 유형의 임의 값을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b5be6dbdc273931973aa00fee70bb05d983c538" translate="yes" xml:space="preserve">
          <source>A GoStmt node represents a go statement.</source>
          <target state="translated">GoStmt 노드는 go 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ead9a9b0d839e98932b0f6df6d7a5bcac06a117e" translate="yes" xml:space="preserve">
          <source>A Handler responds to an HTTP request.</source>
          <target state="translated">핸들러는 HTTP 요청에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="1137ce84e7b2173907b2beb75a048008a6d1a1fd" translate="yes" xml:space="preserve">
          <source>A HardwareAddr represents a physical hardware address.</source>
          <target state="translated">HardwareAddr은 실제 하드웨어 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="66aa09d50694e8606590bbd853e20a5cf82fa277" translate="yes" xml:space="preserve">
          <source>A Header represents a single header in a tar archive. Some fields may not be populated.</source>
          <target state="translated">헤더는 tar 아카이브의 단일 헤더를 나타냅니다. 일부 필드는 채워지지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a628db49b644e43a3caa5d22dfaed6a4347d3671" translate="yes" xml:space="preserve">
          <source>A Header represents the key-value pairs in a mail message header.</source>
          <target state="translated">헤더는 메일 메시지 헤더의 키-값 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="80136957adb9f160575a77527ac0cff8fd0f4621" translate="yes" xml:space="preserve">
          <source>A Header represents the key-value pairs in an HTTP header.</source>
          <target state="translated">헤더는 HTTP 헤더의 키-값 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5c29d59b81052100c179f70c4a67ff5067616d1b" translate="yes" xml:space="preserve">
          <source>A KeyValueExpr node represents (key : value) pairs in composite literals.</source>
          <target state="translated">KeyValueExpr 노드는 복합 리터럴로 (key : value) 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8df5878bb0e127b0ade93df9aeeb99a31d76beb" translate="yes" xml:space="preserve">
          <source>A Kind represents the specific kind of type that a Type represents. The zero Kind is not a valid kind.</source>
          <target state="translated">종류는 유형이 나타내는 특정 유형의 유형을 나타냅니다. 제로 종류는 유효한 종류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="17ad9a62d94b60c7b9f57fee9752262c3aabb885" translate="yes" xml:space="preserve">
          <source>A Label represents a declared label. Labels don't have a type.</source>
          <target state="translated">레이블은 선언 된 레이블을 나타냅니다. 라벨에는 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c46c66dc93e06bd07a9972be686c8a8ccb6cbaf" translate="yes" xml:space="preserve">
          <source>A LabeledStmt node represents a labeled statement.</source>
          <target state="translated">LabeledStmt 노드는 레이블이 지정된 명령문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fd993e336f0b681922292ae796d58612702dde0c" translate="yes" xml:space="preserve">
          <source>A LimitedReader reads from R but limits the amount of data returned to just N bytes. Each call to Read updates N to reflect the new amount remaining. Read returns EOF when N &amp;lt;= 0 or when the underlying R returns EOF.</source>
          <target state="translated">LimitedReader는 R에서 읽지 만 리턴되는 데이터의 양을 N 바이트로 제한합니다. Read를 호출 할 때마다 남은 새 금액을 반영하기 위해 N이 업데이트됩니다. N &amp;lt;= 0이거나 기본 R이 EOF를 반환하면 읽기는 EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae901c0f03f89889b69882a9a6cb3cf314dfa370" translate="yes" xml:space="preserve">
          <source>A LineEntry is a row in a DWARF line table.</source>
          <target state="translated">LineEntry는 DWARF 선 테이블의 행입니다.</target>
        </trans-unit>
        <trans-unit id="8b5b21c9cee22599568846d4db957ad7b4308aac" translate="yes" xml:space="preserve">
          <source>A LineFile is a source file referenced by a DWARF line table entry.</source>
          <target state="translated">LineFile은 DWARF 라인 테이블 항목에서 참조하는 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="67c775091aa03ac7f074c1f43b66b9020494df47" translate="yes" xml:space="preserve">
          <source>A LineReader reads a sequence of LineEntry structures from a DWARF &quot;line&quot; section for a single compilation unit. LineEntries occur in order of increasing PC and each LineEntry gives metadata for the instructions from that LineEntry's PC to just before the next LineEntry's PC. The last entry will have its EndSequence field set.</source>
          <target state="translated">LineReader는 단일 컴파일 단위에 대해 DWARF &quot;라인&quot;섹션에서 일련의 LineEntry 구조를 읽습니다. LineEntries는 PC를 늘리는 순서대로 발생하며 각 LineEntry는 해당 LineEntry의 PC에서 다음 LineEntry의 PC 직전에 지시에 대한 메타 데이터를 제공합니다. 마지막 항목에는 EndSequence 필드가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="732f9020aab568e65bf527050a453f3db3f95343" translate="yes" xml:space="preserve">
          <source>A LineReaderPos represents a position in a line table.</source>
          <target state="translated">LineReaderPos는 라인 테이블의 위치를 ​​나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c1eec29b34e8edeb556d192a830487d8f9953c5" translate="yes" xml:space="preserve">
          <source>A LineTable is a data structure mapping program counters to line numbers.</source>
          <target state="translated">LineTable은 행 번호에 대응하는 데이터 구조 맵핑 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="660bb86f96243fdd09f53c12cec51a542f1df102" translate="yes" xml:space="preserve">
          <source>A Listener is a generic network listener for stream-oriented protocols.</source>
          <target state="translated">리스너는 스트림 지향 프로토콜에 대한 일반적인 네트워크 리스너입니다.</target>
        </trans-unit>
        <trans-unit id="4249368f5406670bcb59c0da03a6cead7099cb8f" translate="yes" xml:space="preserve">
          <source>A Load represents any Mach-O load command.</source>
          <target state="translated">로드는 모든 Mach-O로드 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a677c9d8c8b2e116341c7310869a6eddad18fb38" translate="yes" xml:space="preserve">
          <source>A LoadBytes is the uninterpreted bytes of a Mach-O load command.</source>
          <target state="translated">LoadBytes는 해석되지 않은 Mach-O로드 명령의 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="e4e8327c6dd261427fb252f08dc735a316819bd2" translate="yes" xml:space="preserve">
          <source>A LoadCmd is a Mach-O load command.</source>
          <target state="translated">LoadCmd는 Mach-O로드 명령입니다.</target>
        </trans-unit>
        <trans-unit id="de22bbb1e6bed3a2831a2b27a98bb521911db92a" translate="yes" xml:space="preserve">
          <source>A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area, such as CEST and CET for central Europe.</source>
          <target state="translated">위치는 시간 순간을 해당 시간에 사용중인 영역에 매핑합니다. 일반적으로 위치는 중부 유럽의 CEST 및 CET와 같은 지리적 영역에서 사용중인 시간 오프셋 모음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9e29abdad9487b902fd4f90738f02f8576cb3d7e" translate="yes" xml:space="preserve">
          <source>A Locker represents an object that can be locked and unlocked.</source>
          <target state="translated">로커는 잠 그거나 잠금을 해제 할 수있는 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9dcd5e9754f765ea5f5fe27dc49c6d83fe4fae5b" translate="yes" xml:space="preserve">
          <source>A Logger represents an active logging object that generates lines of output to an io.Writer. Each logging operation makes a single call to the Writer's Write method. A Logger can be used simultaneously from multiple goroutines; it guarantees to serialize access to the Writer.</source>
          <target state="translated">로거는 io.Writer에 출력 라인을 생성하는 활성 로깅 개체를 나타냅니다. 각 로깅 작업은 Writer의 Write 메서드를 한 번 호출합니다. 여러 고 루틴에서 동시에 로거를 사용할 수 있습니다. Writer에 대한 액세스를 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="487666de9e9a85c5d9356cc5cf81a3f898319e56" translate="yes" xml:space="preserve">
          <source>A Lookup function returns a reader to access package data for a given import path, or an error if no matching package is found.</source>
          <target state="translated">Lookup 함수는 지정된 가져 오기 경로에 대한 패키지 데이터에 액세스하기 위해 리더를 반환하거나 일치하는 패키지가 없으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0c2fe60534ab38b9f6eff1d8a7f8316ae318de2" translate="yes" xml:space="preserve">
          <source>A MIMEHeader represents a MIME-style header mapping keys to sets of values.</source>
          <target state="translated">MIMEHeader는 값 집합에 대한 MIME 스타일 헤더 매핑 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="622676ae57a63cdd4f63cf5d044541da87280d44" translate="yes" xml:space="preserve">
          <source>A Map represents a map type.</source>
          <target state="translated">지도는지도 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7049fcfd9e1c276e6fb9a68c8637a2f14ff913c1" translate="yes" xml:space="preserve">
          <source>A MapIter is an iterator for ranging over a map. See Value.MapRange.</source>
          <target state="translated">MapIter는지도의 범위를 정하기위한 반복자입니다. Value.MapRange를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3993e367e0709848b06c8418048cd1fd43363eb0" translate="yes" xml:space="preserve">
          <source>A MapType node represents a map type.</source>
          <target state="translated">MapType 노드는지도 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="79cb9a3cdf800543257c71ff431c6c3132c71d91" translate="yes" xml:space="preserve">
          <source>A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.</source>
          <target state="translated">MarshalerError는 MarshalJSON 또는 MarshalText 메서드를 호출 할 때 발생하는 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50fe2f21d711b0be55d76651cc008c7c5ed77cab" translate="yes" xml:space="preserve">
          <source>A MemProfileRecord describes the live objects allocated by a particular call sequence (stack trace).</source>
          <target state="translated">MemProfileRecord는 특정 호출 시퀀스 (스택 추적)에 의해 할당 된 라이브 객체를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="38f79d159c830caf08bfe0d93506b8d5225e9aeb" translate="yes" xml:space="preserve">
          <source>A MemStats records statistics about the memory allocator.</source>
          <target state="translated">MemStats는 메모리 할당 자에 대한 통계를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c5a8857d4132dff66ceaae33ce8008ebbeba4c4f" translate="yes" xml:space="preserve">
          <source>A Message represents a parsed mail message.</source>
          <target state="translated">메시지는 파싱 된 메일 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b2aa75f290a4b618dbec620b1977caee89888e1" translate="yes" xml:space="preserve">
          <source>A MethodSet is an ordered set of concrete or abstract (interface) methods; a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method set.</source>
          <target state="translated">MethodSet은 순서가 지정된 구체적 또는 추상 (인터페이스) 메소드 세트입니다. 메소드는 MethodVal 선택이며 m.Obj (). Id () 오름차순으로 정렬됩니다. MethodSet의 0 값은 즉시 사용 가능한 빈 메소드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="e93d6d78eddbae4e7fad7a6a0ca260a0ccf86c67" translate="yes" xml:space="preserve">
          <source>A Mode value is a set of flags (or 0). They control printing.</source>
          <target state="translated">모드 값은 플래그 세트 (또는 0)입니다. 인쇄를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="909b6ff9f9762f14bdb401dcb300258f57bf1c0e" translate="yes" xml:space="preserve">
          <source>A Mode value is a set of flags (or 0). They control the amount of source code parsed and other optional parser functionality.</source>
          <target state="translated">모드 값은 플래그 세트 (또는 0)입니다. 파싱 ​​된 소스 코드의 양과 기타 선택적 파서 기능을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="acbe3072fb44246dc2f2f9161a57bc0fa3f9ebfd" translate="yes" xml:space="preserve">
          <source>A Month specifies a month of the year (January = 1, ...).</source>
          <target state="translated">월은 한 달의 월을 지정합니다 (1 월 = 1, ...).</target>
        </trans-unit>
        <trans-unit id="2d2089df68698ac7feab420a1c41c5fc327b3dac" translate="yes" xml:space="preserve">
          <source>A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.</source>
          <target state="translated">뮤텍스는 상호 배제 잠금입니다. 뮤텍스의 0 값은 잠금 해제 된 뮤텍스입니다.</target>
        </trans-unit>
        <trans-unit id="7ea74f6825074782367f3065384e5f974abea778" translate="yes" xml:space="preserve">
          <source>A Mutex must not be copied after first use.</source>
          <target state="translated">처음 사용 후 뮤텍스를 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5d293e79fd0c88cc0ff4965a2c2b6a9bcc2c6ddd" translate="yes" xml:space="preserve">
          <source>A Name represents an XML name (Local) annotated with a name space identifier (Space). In tokens returned by Decoder.Token, the Space identifier is given as a canonical URL, not the short prefix used in the document being parsed.</source>
          <target state="translated">Name은 네임 스페이스 식별자 (Space)로 주석이 달린 XML 이름 (Local)을 나타냅니다. Decoder.Token에서 반환 한 토큰에서 공간 식별자는 구문 분석중인 문서에 사용 된 짧은 접두사가 아닌 표준 URL로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a35c8ef18f02eb6678ba34eacf3ba11a633953" translate="yes" xml:space="preserve">
          <source>A Named represents a named type.</source>
          <target state="translated">Named는 명명 된 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bad92076aa525c820eebcc24b8c3805b37fbfbe9" translate="yes" xml:space="preserve">
          <source>A NamedArg is a named argument. NamedArg values may be used as arguments to Query or Exec and bind to the corresponding named parameter in the SQL statement.</source>
          <target state="translated">NamedArg는 명명 된 인수입니다. NamedArg 값은 Query 또는 Exec에 대한 인수로 사용되어 SQL 문에서 해당하는 이름 지정된 매개 변수에 바인드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b11131cc805ed1ab6e3f58bee92b0fe2c5fa87f5" translate="yes" xml:space="preserve">
          <source>A Node is an element in the parse tree. The interface is trivial. The interface contains an unexported method so that only types local to this package can satisfy it.</source>
          <target state="translated">노드는 구문 분석 트리의 요소입니다. 인터페이스는 사소합니다. 인터페이스에는 내 보내지 않은 메소드가 포함되어 있으므로이 패키지의 로컬 유형 만 만족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a72472f993ff8c5c76aed9654461ad595b3054" translate="yes" xml:space="preserve">
          <source>A Note represents a marked comment starting with &quot;MARKER(uid): note body&quot;. Any note with a marker of 2 or more upper case [A-Z] letters and a uid of at least one character is recognized. The &quot;:&quot; following the uid is optional. Notes are collected in the Package.Notes map indexed by the notes marker.</source>
          <target state="translated">메모는 &quot;MARKER (uid) : note body&quot;로 시작하는 표시된 주석을 나타냅니다. 대문자 [AZ] 이상의 마커와 하나 이상의 문자의 uid가있는 메모가 인식됩니다. uid 다음에 나오는 &quot;:&quot;는 선택 사항입니다. 노트는 패키지에 수집됩니다. 노트는 노트 마커로 색인이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b87cef5499b5faeaad54c5a5f5e0e7973e06869e" translate="yes" xml:space="preserve">
          <source>A NumError records a failed conversion.</source>
          <target state="translated">NumError는 실패한 변환을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="11a76b8e336e5f32dd052064b8407eb081806fc1" translate="yes" xml:space="preserve">
          <source>A Number represents a JSON number literal.</source>
          <target state="translated">숫자는 JSON 숫자 리터럴을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6df70dd442167e536bbc2f2719a1ff6771d9746a" translate="yes" xml:space="preserve">
          <source>A PB is used by RunParallel for running parallel benchmarks.</source>
          <target state="translated">병렬 벤치 마크를 실행하기 위해 RunParallel에서 PB를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="28cce0d7447d20a26f79cc7de8f2ffb5f6cea243" translate="yes" xml:space="preserve">
          <source>A Package describes a Go package.</source>
          <target state="translated">패키지는 Go 패키지를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="02c5b186c0d9829ef0b314c7d197a99b06cc08aa" translate="yes" xml:space="preserve">
          <source>A Package describes the Go package found in a directory.</source>
          <target state="translated">패키지는 디렉토리에있는 Go 패키지를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f7c6a2c88c2a925b1bb13b3770480bc4b1e2f8ba" translate="yes" xml:space="preserve">
          <source>A Package node represents a set of source files collectively building a Go package.</source>
          <target state="translated">패키지 노드는 Go 패키지를 집합 적으로 빌드하는 소스 파일 세트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b80c490a82963253ea198d8237d2b88bfeb3fb8f" translate="yes" xml:space="preserve">
          <source>A ParenExpr node represents a parenthesized expression.</source>
          <target state="translated">ParenExpr 노드는 괄호로 묶은 표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32dd285c0ed7aac470e40a0806903efe3cbc3142" translate="yes" xml:space="preserve">
          <source>A ParseError is returned for parsing errors. Line numbers are 1-indexed and columns are 0-indexed.</source>
          <target state="translated">구문 분석 오류에 대해 ParseError가 반환됩니다. 줄 번호는 1 인덱싱되고 열은 0 인덱싱됩니다.</target>
        </trans-unit>
        <trans-unit id="48c4f65b46772ce507deaf319632461e9a6e8fdd" translate="yes" xml:space="preserve">
          <source>A ParseError is the error type of literal network address parsers.</source>
          <target state="translated">ParseError는 리터럴 네트워크 주소 파서의 오류 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1d6824c6cf712cde9f9af9dccccc1da24901cb92" translate="yes" xml:space="preserve">
          <source>A Part represents a single part in a multipart body.</source>
          <target state="translated">부품은 다중 부품 바디의 단일 부품을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dfbcc0e114727389cb8279668c19d2287bd264b1" translate="yes" xml:space="preserve">
          <source>A PipeReader is the read half of a pipe.</source>
          <target state="translated">PipeReader는 파이프의 절반을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9a19697f20ff89cf7a057258dbab42f40577989a" translate="yes" xml:space="preserve">
          <source>A PipeWriter is the write half of a pipe.</source>
          <target state="translated">PipeWriter는 파이프의 쓰기 절반입니다.</target>
        </trans-unit>
        <trans-unit id="acf94f04062b96beb777e42fe455475a158fb691" translate="yes" xml:space="preserve">
          <source>A Pipeline manages a pipelined in-order request/response sequence.</source>
          <target state="translated">파이프 라인은 파이프 라인 순서대로 요청 / 응답 시퀀스를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="f6f05dedc14eb801e2b7f04687804ef382acb51d" translate="yes" xml:space="preserve">
          <source>A PkgName represents an imported Go package. PkgNames don't have a type.</source>
          <target state="translated">PkgName은 가져온 Go 패키지를 나타냅니다. PkgName에는 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="607046c718991e5cb3d6ed4816dc42aea8d71afc" translate="yes" xml:space="preserve">
          <source>A Point is an X, Y coordinate pair. The axes increase right and down.</source>
          <target state="translated">점은 X, Y 좌표 쌍입니다. 축이 오른쪽 아래로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="768a88aa5e8bc4257378b5f3eb8e284db1c2866f" translate="yes" xml:space="preserve">
          <source>A Pointer represents a pointer type.</source>
          <target state="translated">포인터는 포인터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7ed4f38838cc5e5bef3db6e4277a894844db4ea3" translate="yes" xml:space="preserve">
          <source>A Pool is a set of temporary objects that may be individually saved and retrieved.</source>
          <target state="translated">풀은 개별적으로 저장하고 검색 할 수있는 임시 개체 집합입니다.</target>
        </trans-unit>
        <trans-unit id="9590c606b3343da60b471a73764edc1f4d765202" translate="yes" xml:space="preserve">
          <source>A Pool is safe for use by multiple goroutines simultaneously.</source>
          <target state="translated">수영장은 여러 고 루틴이 동시에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5b2599ed95be6202d4666b2852d55218a76b0d8a" translate="yes" xml:space="preserve">
          <source>A Pool must not be copied after first use.</source>
          <target state="translated">처음 사용 후 풀을 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d8fd9c4a12bc6fc10b6879d22ea87ecc71842c25" translate="yes" xml:space="preserve">
          <source>A PrivateKey represents an RSA key</source>
          <target state="translated">PrivateKey는 RSA 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f7e88b0c38cbd0d62f840c3829e6e5bc2b140c6" translate="yes" xml:space="preserve">
          <source>A ProcInst represents an XML processing instruction of the form &amp;lt;?target inst?&amp;gt;</source>
          <target state="translated">ProcInst는 &amp;lt;? target inst?&amp;gt; 형식의 XML 처리 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="edd41d0f8525a0b5ab2821d1add949d3f2b61e7c" translate="yes" xml:space="preserve">
          <source>A Profile is a collection of stack traces showing the call sequences that led to instances of a particular event, such as allocation. Packages can create and maintain their own profiles; the most common use is for tracking resources that must be explicitly closed, such as files or network connections.</source>
          <target state="translated">프로파일은 할당과 같은 특정 이벤트의 인스턴스로 이어진 호출 시퀀스를 보여주는 스택 추적 모음입니다. 패키지는 자체 프로파일을 작성하고 유지 보수 할 수 있습니다. 가장 일반적인 용도는 파일 또는 네트워크 연결과 같이 명시 적으로 닫아야하는 리소스를 추적하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7ad9992477be411f2a70474056f365c9cf6755d" translate="yes" xml:space="preserve">
          <source>A Profile's methods can be called from multiple goroutines simultaneously.</source>
          <target state="translated">여러 고 루틴에서 동시에 Profile의 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36aae9f1173dd65c1ae807cca4a4b207b2c93026" translate="yes" xml:space="preserve">
          <source>A Prog is a compiled regular expression program.</source>
          <target state="translated">Prog는 컴파일 된 정규식 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="77c6b957fd156c74c873357c407dbfd5609bc6a5" translate="yes" xml:space="preserve">
          <source>A Prog represents a single ELF program header in an ELF binary.</source>
          <target state="translated">Prog는 ELF 바이너리에서 단일 ELF 프로그램 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d3afa7d31fec2d457dace7f415ebe339b6173396" translate="yes" xml:space="preserve">
          <source>A ProgHeader represents a single ELF program header.</source>
          <target state="translated">ProgHeader는 단일 ELF 프로그램 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a668757fb0cd173dc1eca56fe18304f67be91ed0" translate="yes" xml:space="preserve">
          <source>A ProtocolError describes a protocol violation such as an invalid response or a hung-up connection.</source>
          <target state="translated">ProtocolError는 유효하지 않은 응답 또는 끊어진 연결과 같은 프로토콜 위반을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f6b39dc81130cc794cc964502f8f09dded02f3b0" translate="yes" xml:space="preserve">
          <source>A PtrType represents a pointer type.</source>
          <target state="translated">PtrType은 포인터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dcb21686aafe13c9342b5eb4d71053646debb6a6" translate="yes" xml:space="preserve">
          <source>A PublicKey represents the public part of an RSA key.</source>
          <target state="translated">PublicKey는 RSA 키의 공개 부분을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6f4e8d1859ff0d3e7c1427e6e64066e900cad3cb" translate="yes" xml:space="preserve">
          <source>A QualType represents a type that has the C/C++ &quot;const&quot;, &quot;restrict&quot;, or &quot;volatile&quot; qualifier.</source>
          <target state="translated">QualType은 C / C ++ &quot;const&quot;, &quot;restrict&quot;또는 &quot;volatile&quot;한정자를 가진 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ebdeaadb141050dca0205834e1f70052f8794133" translate="yes" xml:space="preserve">
          <source>A Qualifier controls how named package-level objects are printed in calls to TypeString, ObjectString, and SelectionString.</source>
          <target state="translated">한정자는 TypeString, ObjectString 및 SelectionString에 대한 호출에서 명명 된 패키지 수준 개체를 인쇄하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="9938b28874a070149d52e6d6227a0422577f7a32" translate="yes" xml:space="preserve">
          <source>A RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. The zero value for a RWMutex is an unlocked mutex.</source>
          <target state="translated">RWMutex는 리더 / 라이터 상호 배제 잠금입니다. 잠금은 임의의 수의 독자 또는 단일 작성자가 보유 할 수 있습니다. RWMutex의 0 값은 잠금 해제 된 뮤텍스입니다.</target>
        </trans-unit>
        <trans-unit id="293a28f976ca91641319ee6ab2cb3a59843417d8" translate="yes" xml:space="preserve">
          <source>A RWMutex must not be copied after first use.</source>
          <target state="translated">RWMutex는 처음 사용한 후 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4a44a812184753ee800df2d3024080a1d07ae0b6" translate="yes" xml:space="preserve">
          <source>A Rand is a source of random numbers.</source>
          <target state="translated">랜드는 난수의 원천입니다.</target>
        </trans-unit>
        <trans-unit id="a6beab053e966a50e6a7d98a758b86f986af4670" translate="yes" xml:space="preserve">
          <source>A RangeStmt represents a for statement with a range clause.</source>
          <target state="translated">RangeStmt는 range 절이있는 for 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5fca0333648aed85f5f684d09865e5a2e91742f5" translate="yes" xml:space="preserve">
          <source>A Rat represents a quotient a/b of arbitrary precision. The zero value for a Rat represents the value 0.</source>
          <target state="translated">쥐는 임의의 정밀도의 몫 a / b를 나타냅니다. Rat의 0 값은 0 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="315d29aa160f5e0113bda9fb7a05adf019e99e29" translate="yes" xml:space="preserve">
          <source>A RawConn is a raw network connection.</source>
          <target state="translated">RawConn은 원시 네트워크 연결입니다.</target>
        </trans-unit>
        <trans-unit id="1eecc4b388581b7f5af4d0ab92eb3236267e13d7" translate="yes" xml:space="preserve">
          <source>A RawValue represents an undecoded ASN.1 object.</source>
          <target state="translated">RawValue는 디코딩되지 않은 ASN.1 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1fe251d5b99328d7ccb132b5e39275c6ea7e2859" translate="yes" xml:space="preserve">
          <source>A ReadError reports an error encountered while reading input.</source>
          <target state="translated">ReadError는 입력을 읽는 동안 발생한 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ce0546f89447c6257999da2fc59e1b4d0147b988" translate="yes" xml:space="preserve">
          <source>A Reader allows reading Entry structures from a DWARF &amp;ldquo;info&amp;rdquo; section. The Entry structures are arranged in a tree. The Reader's Next function return successive entries from a pre-order traversal of the tree. If an entry has children, its Children field will be true, and the children follow, terminated by an Entry with Tag 0.</source>
          <target state="translated">리더를 사용하면 DWARF &quot;정보&quot;섹션에서 입력 구조를 읽을 수 있습니다. 엔트리 구조는 트리로 배열됩니다. Reader 's Next 함수는 트리의 선주문 순서에서 연속적인 항목을 반환합니다. 항목에 자식이 있으면 해당 자식 필드는 true가되고 자식은 태그 0의 항목으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e809231f8a76ae01fe2ed56c6d3370831ff40ccc" translate="yes" xml:space="preserve">
          <source>A Reader implements convenience methods for reading requests or responses from a text protocol network connection.</source>
          <target state="translated">리더는 텍스트 프로토콜 네트워크 연결에서 요청 또는 응답을 읽는 편리한 방법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1a71eb177c7cde85aefa079833b1150b094f2eaa" translate="yes" xml:space="preserve">
          <source>A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner, and io.RuneScanner interfaces by reading from a string. The zero value for Reader operates like a Reader of an empty string.</source>
          <target state="translated">Reader는 문자열을 읽어 io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner 및 io.RuneScanner 인터페이스를 구현합니다. Reader의 0 값은 빈 문자열의 Reader처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b153ea88d2a4e327aa4d80158226897a894e3c2a" translate="yes" xml:space="preserve">
          <source>A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker, io.ByteScanner, and io.RuneScanner interfaces by reading from a byte slice. Unlike a Buffer, a Reader is read-only and supports seeking. The zero value for Reader operates like a Reader of an empty slice.</source>
          <target state="translated">Reader는 바이트 슬라이스에서 읽음으로써 io.Reader, io.ReaderAt, io.WriterTo, io.Seeker, io.ByteScanner 및 io.RuneScanner 인터페이스를 구현합니다. 버퍼와 달리 리더는 읽기 전용이며 검색을 지원합니다. Reader의 0 값은 빈 슬라이스의 Reader처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b70395118bec2588dcb78aa1e8af11b79076bd1c" translate="yes" xml:space="preserve">
          <source>A Reader is an io.Reader that can be read to retrieve uncompressed data from a gzip-format compressed file.</source>
          <target state="translated">Reader는 gzip 형식 압축 파일에서 압축되지 않은 데이터를 검색하기 위해 읽을 수있는 io.Reader입니다.</target>
        </trans-unit>
        <trans-unit id="6574274b38b0f064ff925e7d46ed95bf437111cb" translate="yes" xml:space="preserve">
          <source>A Reader reads records from a CSV-encoded file.</source>
          <target state="translated">리더는 CSV 인코딩 파일에서 레코드를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="08a6e31825ec2c6300d4782fb0ecf058c691b2e5" translate="yes" xml:space="preserve">
          <source>A Rectangle contains the points with Min.X &amp;lt;= X &amp;lt; Max.X, Min.Y &amp;lt;= Y &amp;lt; Max.Y. It is well-formed if Min.X &amp;lt;= Max.X and likewise for Y. Points are always well-formed. A rectangle's methods always return well-formed outputs for well-formed inputs.</source>
          <target state="translated">사각형에는 Min.X &amp;lt;= X &amp;lt;Max.X, Min.Y &amp;lt;= Y &amp;lt;Max.Y 인 점이 포함됩니다. Min.X &amp;lt;= Max.X이면 Y도 동일하게 구성됩니다. 포인트는 항상 올바르게 구성됩니다. 사각형의 메소드는 항상 올바른 형식의 입력에 대해 올바른 형식의 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="962040a6acd2d013b3cda593f3034f3a6e474cf7" translate="yes" xml:space="preserve">
          <source>A Rectangle is also an Image whose bounds are the rectangle itself. At returns color.Opaque for points in the rectangle and color.Transparent otherwise.</source>
          <target state="translated">사각형은 경계가 사각형 자체 인 이미지이기도합니다. At는 색상을 반환합니다. 사각형과 색상의 점에 대해서는 불투명합니다. 그렇지 않으면 투명합니다.</target>
        </trans-unit>
        <trans-unit id="2b5c4eab8e85410a86bdda5dd0182e066f957435" translate="yes" xml:space="preserve">
          <source>A Regexp is a node in a regular expression syntax tree.</source>
          <target state="translated">정규 표현식은 정규 표현식 구문 트리의 노드입니다.</target>
        </trans-unit>
        <trans-unit id="7ab3983fd4df5bd9eb6fbef83870bc471fcc712a" translate="yes" xml:space="preserve">
          <source>A Reloc represents a Mach-O relocation.</source>
          <target state="translated">재배치는 Mach-O 재배치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="067dded24908e2b71937b6360c614e63e5a89809" translate="yes" xml:space="preserve">
          <source>A Request represents an HTTP request received by a server or to be sent by a client.</source>
          <target state="translated">요청은 서버가 수신하거나 클라이언트가 전송 한 HTTP 요청을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9e19cc3384dc7e2b431205075ec657c82d42a386" translate="yes" xml:space="preserve">
          <source>A Resolver looks up names and numbers.</source>
          <target state="translated">Resolver가 이름과 숫자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7410206ba9c0a6090136ffb7158eee5593d03484" translate="yes" xml:space="preserve">
          <source>A ResponseWriter interface is used by an HTTP handler to construct an HTTP response.</source>
          <target state="translated">HTTP 처리기는 ResponseWriter 인터페이스를 사용하여 HTTP 응답을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ace923e0c585e748ba7f88a0368066757a465f2f" translate="yes" xml:space="preserve">
          <source>A ResponseWriter may not be used after the Handler.ServeHTTP method has returned.</source>
          <target state="translated">Handler.ServeHTTP 메서드가 반환 된 후 ResponseWriter를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ac628cf85fa1a2f24b07d813066e77d55459bb7" translate="yes" xml:space="preserve">
          <source>A Result summarizes an executed SQL command.</source>
          <target state="translated">결과는 실행 된 SQL 명령을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="c7bc644e767da0cf2307a7193ba0f77e968aacb8" translate="yes" xml:space="preserve">
          <source>A ReturnStmt node represents a return statement.</source>
          <target state="translated">ReturnStmt 노드는 return 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ae584cddb6e2177562bbac06546bb6633cf3019c" translate="yes" xml:space="preserve">
          <source>A Ring is an element of a circular list, or ring. Rings do not have a beginning or end; a pointer to any ring element serves as reference to the entire ring. Empty rings are represented as nil Ring pointers. The zero value for a Ring is a one-element ring with a nil Value.</source>
          <target state="translated">링은 순환 목록 또는 링의 요소입니다. 반지는 시작이나 끝이 없습니다. 모든 링 요소에 대한 포인터는 전체 링에 대한 참조로 사용됩니다. 빈 링은 nil 링 포인터로 표시됩니다. 링의 0 값은 nil 값을 갖는 단일 요소 링입니다.</target>
        </trans-unit>
        <trans-unit id="a6d02af23b0348ce707674db889668b02af5f81f" translate="yes" xml:space="preserve">
          <source>A RoundTripper must be safe for concurrent use by multiple goroutines.</source>
          <target state="translated">RoundTripper는 여러 고 루틴이 동시에 사용할 수 있도록 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="45bdd1ec7ab84bc9a9dd66a47c77c47f5715b87c" translate="yes" xml:space="preserve">
          <source>A Rpath represents a Mach-O rpath command.</source>
          <target state="translated">Rpath는 Mach-O rpath 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="15e64f8a4c2bf9029f12ea9d5e18a15877b7259c" translate="yes" xml:space="preserve">
          <source>A RpathCmd is a Mach-O rpath command.</source>
          <target state="translated">RpathCmd는 Mach-O rpath 명령입니다.</target>
        </trans-unit>
        <trans-unit id="595b91253eb5007d2507eef2c21f6da710950881" translate="yes" xml:space="preserve">
          <source>A Scanner holds the scanner's internal state while processing a given text. It can be allocated as part of another data structure but must be initialized via Init before use.</source>
          <target state="translated">스캐너는 지정된 텍스트를 처리하는 동안 스캐너의 내부 상태를 유지합니다. 다른 데이터 구조의 일부로 할당 할 수 있지만 사용하기 전에 Init를 통해 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c32b624023b90bc977bdef0e2337de1ae290d39" translate="yes" xml:space="preserve">
          <source>A Scanner implements reading of Unicode characters and tokens from an io.Reader.</source>
          <target state="translated">스캐너는 io.Reader에서 유니 코드 문자 및 토큰 읽기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c61b7eab5a0a8103327245dad118019da84e7373" translate="yes" xml:space="preserve">
          <source>A Scope maintains a set of objects and links to its containing (parent) and contained (children) scopes. Objects may be inserted and looked up by name. The zero value for Scope is a ready-to-use empty scope.</source>
          <target state="translated">범위는 일련의 개체와 그 포함 (부모) 및 포함 (자식) 범위에 대한 링크를 유지 관리합니다. 이름으로 개체를 삽입하고 조회 할 수 있습니다. 범위의 0 값은 바로 사용할 수있는 빈 범위입니다.</target>
        </trans-unit>
        <trans-unit id="5dea048da594f1517d32f220dcf473582500285f" translate="yes" xml:space="preserve">
          <source>A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope.</source>
          <target state="translated">범위는 해당 범위에 선언 된 명명 된 언어 엔터티 집합과 바로 주변 (외부) 범위에 대한 링크를 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="183af69f58c3ed305371155a329e5a16e682146d" translate="yes" xml:space="preserve">
          <source>A Section represents a single section in a Plan 9 a.out file.</source>
          <target state="translated">섹션은 Plan 9 a.out 파일의 단일 섹션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="48d020e310b3bb2149d4b253ff0bb1536d07bfa4" translate="yes" xml:space="preserve">
          <source>A Section represents a single section in an ELF file.</source>
          <target state="translated">섹션은 ELF 파일의 단일 섹션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3fa1bd710855f38346943cd85be2ea9687a123fb" translate="yes" xml:space="preserve">
          <source>A Section32 is a 32-bit Mach-O section header.</source>
          <target state="translated">Section32는 32 비트 Mach-O 섹션 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="471e980a91ca2daa3de25530d4f089577d149d78" translate="yes" xml:space="preserve">
          <source>A Section64 is a 64-bit Mach-O section header.</source>
          <target state="translated">Section64는 64 비트 Mach-O 섹션 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="781b43f0370a047bcf6b158f7205d75f7f66770a" translate="yes" xml:space="preserve">
          <source>A SectionHeader represents a single ELF section header.</source>
          <target state="translated">SectionHeader는 단일 ELF 섹션 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="07693bb5a841d984aad8deaaf713cc85716d2183" translate="yes" xml:space="preserve">
          <source>A SectionHeader represents a single Plan 9 a.out section header. This structure doesn't exist on-disk, but eases navigation through the object file.</source>
          <target state="translated">SectionHeader는 단일 Plan 9 a.out 섹션 헤더를 나타냅니다. 이 구조는 디스크에는 없지만 개체 파일을 쉽게 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd1c503cb0621b37172392fa6c3e6e663892bdb9" translate="yes" xml:space="preserve">
          <source>A Segment represents a Mach-O 32-bit or 64-bit load segment command.</source>
          <target state="translated">세그먼트는 Mach-O 32 비트 또는 64 비트로드 세그먼트 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="18f470aa3a2494edbc8228ed690b8ca00e2cd060" translate="yes" xml:space="preserve">
          <source>A Segment32 is a 32-bit Mach-O segment load command.</source>
          <target state="translated">Segment32는 32 비트 Mach-O 세그먼트로드 명령입니다.</target>
        </trans-unit>
        <trans-unit id="b49f656e7f0d6c4de103c56d20f5a3e5d46474b4" translate="yes" xml:space="preserve">
          <source>A Segment64 is a 64-bit Mach-O segment load command.</source>
          <target state="translated">Segment64는 64 비트 Mach-O 세그먼트로드 명령입니다.</target>
        </trans-unit>
        <trans-unit id="8c1bca7547e5328a2c0e7d510860150c5b02204d" translate="yes" xml:space="preserve">
          <source>A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command.</source>
          <target state="translated">SegmentHeader는 Mach-O 32 비트 또는 64 비트로드 세그먼트 명령의 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="4d907e1938e53c3566dbf156d7cc0eaeb9f4968d" translate="yes" xml:space="preserve">
          <source>A SelectCase describes a single case in a select operation. The kind of case depends on Dir, the communication direction.</source>
          <target state="translated">SelectCase는 선택 작업에서 단일 사례를 설명합니다. 통신 종류 인 Dir에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a5415c574177ffe2984e71be71022c8ec6f1d638" translate="yes" xml:space="preserve">
          <source>A SelectDir describes the communication direction of a select case.</source>
          <target state="translated">SelectDir은 선택 사례의 통신 방향을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7cbf8ec346b8e7b76dd78b3b87697c7317615faf" translate="yes" xml:space="preserve">
          <source>A Selection describes a selector expression x.f. For the declarations:</source>
          <target state="translated">선택은 선택자 표현식 xf를 설명합니다. 선언의 경우 :</target>
        </trans-unit>
        <trans-unit id="35b647fb865db0783355629fb40dee0621ff1bfa" translate="yes" xml:space="preserve">
          <source>A SelectorExpr node represents an expression followed by a selector.</source>
          <target state="translated">SelectorExpr 노드는 표현식 다음에 선택기가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="639e64492ddcf47a6e3a3dbf49f424478ccc6fd1" translate="yes" xml:space="preserve">
          <source>A SendStmt node represents a send statement.</source>
          <target state="translated">SendStmt 노드는 send 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0a812544b1079cbac724176753c97cbdce588634" translate="yes" xml:space="preserve">
          <source>A Server defines parameters for running an HTTP server. The zero value for Server is a valid configuration.</source>
          <target state="translated">서버는 HTTP 서버를 실행하기위한 매개 변수를 정의합니다. 서버의 0 값은 유효한 구성입니다.</target>
        </trans-unit>
        <trans-unit id="8bbd12c651b1aff76a953db8334d88ca84465ea1" translate="yes" xml:space="preserve">
          <source>A Server is an HTTP server listening on a system-chosen port on the local loopback interface, for use in end-to-end HTTP tests.</source>
          <target state="translated">서버는 엔드 투 엔드 HTTP 테스트에 사용하기 위해 로컬 루프백 인터페이스에서 시스템이 선택한 포트를 수신하는 HTTP 서버입니다.</target>
        </trans-unit>
        <trans-unit id="aaf263fed591626847e1114341fce50da6dde5fb" translate="yes" xml:space="preserve">
          <source>A ServerCodec implements reading of RPC requests and writing of RPC responses for the server side of an RPC session. The server calls ReadRequestHeader and ReadRequestBody in pairs to read requests from the connection, and it calls WriteResponse to write a response back. The server calls Close when finished with the connection. ReadRequestBody may be called with a nil argument to force the body of the request to be read and discarded. See NewClient's comment for information about concurrent access.</source>
          <target state="translated">ServerCodec은 RPC 세션의 서버쪽에 대한 RPC 요청 읽기 및 RPC 응답 쓰기를 구현합니다. 서버는 ReadRequestHeader와 ReadRequestBody를 쌍으로 호출하여 연결의 요청을 읽고 WriteResponse를 호출하여 응답을 다시 씁니다. 연결이 끝나면 서버는 Close를 호출합니다. ReadRequestBody는 nil 인수로 호출되어 요청 본문을 읽고 버릴 수 있습니다. 동시 액세스에 대한 정보는 NewClient의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38c132ba907f3f5c1ee1b2d34f64a031db7fb85b" translate="yes" xml:space="preserve">
          <source>A SetupError is the result of an error in the way that check is being used, independent of the functions being tested.</source>
          <target state="translated">SetupError는 테스트중인 기능에 관계없이 검사가 사용되는 방식의 오류의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0aaa1aa571361e67fd65645ce946b3e93ab82465" translate="yes" xml:space="preserve">
          <source>A Signal is a number describing a process signal. It implements the os.Signal interface.</source>
          <target state="translated">신호는 프로세스 신호를 설명하는 숫자입니다. os.Signal 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="04aa060d55406e6823576f5f8a2fed5ce02d26bc" translate="yes" xml:space="preserve">
          <source>A Signal represents an operating system signal. The usual underlying implementation is operating system-dependent: on Unix it is syscall.Signal.</source>
          <target state="translated">신호는 운영 체제 신호를 나타냅니다. 일반적인 기본 구현은 운영 체제에 따라 다릅니다. Unix에서는 syscall.Signal입니다.</target>
        </trans-unit>
        <trans-unit id="e443d13756dc18de92ff330dd034a22130131309" translate="yes" xml:space="preserve">
          <source>A Signature represents a (non-builtin) function or method type. The receiver is ignored when comparing signatures for identity.</source>
          <target state="translated">서명은 (내장되지 않은) 함수 또는 메소드 유형을 나타냅니다. 신원에 대한 서명을 비교할 때는 수신자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4dded7ba2e7f9fa90c63253a6511fa6ac894ca85" translate="yes" xml:space="preserve">
          <source>A Slice represents a slice type.</source>
          <target state="translated">슬라이스는 슬라이스 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8c662a701f4e4fc76cf429b1959cb955efb9d925" translate="yes" xml:space="preserve">
          <source>A Source represents a source of uniformly-distributed pseudo-random int64 values in the range [0, 1&amp;lt;&amp;lt;63).</source>
          <target state="translated">소스는 [0, 1 &amp;lt;&amp;lt; 63) 범위의 균일하게 분포 된 의사 랜덤 int64 값의 소스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf9e74a9757b6a7e7e07d6bcbab6c27faa8392c2" translate="yes" xml:space="preserve">
          <source>A Source64 is a Source that can also generate uniformly-distributed pseudo-random uint64 values in the range [0, 1&amp;lt;&amp;lt;64) directly. If a Rand r's underlying Source s implements Source64, then r.Uint64 returns the result of one call to s.Uint64 instead of making two calls to s.Int63.</source>
          <target state="translated">Source64는 [0, 1 &amp;lt;&amp;lt; 64) 범위에서 균일하게 분포 된 의사 랜덤 uint64 값을 직접 생성 할 수도있는 소스입니다. Rand r의 기본 Source가 Source64를 구현하는 경우 r.Uint64는 s.Int63을 두 번 호출하는 대신 s.Uint64를 한 번 호출 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd32d7d89b2a30a05c1bb5eebdbd13fc02c7ae72" translate="yes" xml:space="preserve">
          <source>A StackRecord describes a single execution stack.</source>
          <target state="translated">StackRecord는 단일 실행 스택을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b0008c9536d181c46b815624f062ebf9594778bc" translate="yes" xml:space="preserve">
          <source>A StarExpr node represents an expression of the form &quot;*&quot; Expression. Semantically it could be a unary &quot;*&quot; expression, or a pointer type.</source>
          <target state="translated">StarExpr 노드는 &quot;*&quot;표현식 형식의 표현식을 나타냅니다. 의미 상 이는 단항 &quot;*&quot;표현식 또는 포인터 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c32c7cbdc0d7be886e97676c71afe750a62dcc10" translate="yes" xml:space="preserve">
          <source>A StartElement represents an XML start element.</source>
          <target state="translated">StartElement는 XML 시작 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ea14341705e92c45b1e240d763674f51e6d52411" translate="yes" xml:space="preserve">
          <source>A Stream represents a stream cipher.</source>
          <target state="translated">스트림은 스트림 암호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b669677d01d549cc1c73f158a189264271f5702" translate="yes" xml:space="preserve">
          <source>A Struct represents a struct type.</source>
          <target state="translated">구조체는 구조체 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28e97007759f43396752d2c0cba6cdef18c34c87" translate="yes" xml:space="preserve">
          <source>A StructField describes a single field in a struct.</source>
          <target state="translated">StructField는 구조체의 단일 필드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ead7ec43f94a3a8ab253c977717cf4787ddce82" translate="yes" xml:space="preserve">
          <source>A StructField represents a field in a struct, union, or C++ class type.</source>
          <target state="translated">StructField는 구조체, 공용체 또는 C ++ 클래스 유형의 필드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e939c47706fd4781a8efbe363efe9716fe2daf90" translate="yes" xml:space="preserve">
          <source>A StructTag is the tag string in a struct field.</source>
          <target state="translated">StructTag는 구조체 필드의 태그 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8da8d40653f50508ed698ba3d6f35b64ae2e53e8" translate="yes" xml:space="preserve">
          <source>A StructType node represents a struct type.</source>
          <target state="translated">StructType 노드는 구조체 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fea2245244b33d39ec55d7990a22c73eb242ee3a" translate="yes" xml:space="preserve">
          <source>A StructType represents a struct, union, or C++ class type.</source>
          <target state="translated">StructType은 구조체, 공용체 또는 C ++ 클래스 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29e34b1f6b5269b0f812703eca0e45a915de37c5" translate="yes" xml:space="preserve">
          <source>A StructuralError is returned when the bzip2 data is found to be syntactically invalid.</source>
          <target state="translated">bzip2 데이터가 구문 상 유효하지 않은 것으로 발견되면 StructuralError가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="67e45ed1c74af0e85d151af6cd24db62c07cd291" translate="yes" xml:space="preserve">
          <source>A StructuralError suggests that the ASN.1 data is valid, but the Go type which is receiving it doesn't match.</source>
          <target state="translated">StructuralError는 ASN.1 데이터가 유효하지만 데이터를 수신하는 Go 유형이 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3db304c4567f1e28ed11e586a2eabe4ea9391a66" translate="yes" xml:space="preserve">
          <source>A SwitchStmt node represents an expression switch statement.</source>
          <target state="translated">SwitchStmt 노드는 식 스위치 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1015b6c5506bb94ff4d458f55084fdca10ca635b" translate="yes" xml:space="preserve">
          <source>A Sym represents a single symbol table entry.</source>
          <target state="translated">Sym은 단일 기호 테이블 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="98cd40470d9a8f6a0f6bdd00fde0756e94d9ebd2" translate="yes" xml:space="preserve">
          <source>A Symbol is a Mach-O 32-bit or 64-bit symbol table entry.</source>
          <target state="translated">기호는 Mach-O 32 비트 또는 64 비트 기호 테이블 항목입니다.</target>
        </trans-unit>
        <trans-unit id="a671a2dbcf33c7f008c2e71b0630c5384653e90b" translate="yes" xml:space="preserve">
          <source>A Symbol is a pointer to a variable or function.</source>
          <target state="translated">기호는 변수 또는 함수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="789708f9c12833d6c1014d903e31cb12724b33b8" translate="yes" xml:space="preserve">
          <source>A Symbol represents an entry in a Plan 9 a.out symbol table section.</source>
          <target state="translated">기호는 Plan 9 a.out 기호 테이블 섹션의 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95c21f4091681c4ef2bad327d6377640dd105e88" translate="yes" xml:space="preserve">
          <source>A Symbol represents an entry in an ELF symbol table section.</source>
          <target state="translated">기호는 ELF 기호 테이블 섹션의 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bd868f6dc8223d50a3f572a145afcdd64d4e3ae6" translate="yes" xml:space="preserve">
          <source>A Symtab represents a Mach-O symbol table command.</source>
          <target state="translated">Symtab은 Mach-O 기호 테이블 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0fd4f1bb011d721fb420bad06209aa869812c00d" translate="yes" xml:space="preserve">
          <source>A SymtabCmd is a Mach-O symbol table command.</source>
          <target state="translated">SymtabCmd는 Mach-O 기호 테이블 명령입니다.</target>
        </trans-unit>
        <trans-unit id="ef2a77a6f406a105103b5a2c79bd38d08956b562" translate="yes" xml:space="preserve">
          <source>A SyntaxError is a description of a JSON syntax error.</source>
          <target state="translated">SyntaxError는 JSON 구문 오류에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="7ce23a19325afbda7b493c3ee485c5402ddf0cba" translate="yes" xml:space="preserve">
          <source>A SyntaxError represents a syntax error in the XML input stream.</source>
          <target state="translated">SyntaxError는 XML 입력 스트림의 구문 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d6563aa54653e994476c1c43bdfb9b8d0eb52cc1" translate="yes" xml:space="preserve">
          <source>A SyntaxError suggests that the ASN.1 data is invalid.</source>
          <target state="translated">SyntaxError는 ASN.1 데이터가 잘못되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="94dc0c91ffcffa6687bf49f7b86aa6e830c1c493" translate="yes" xml:space="preserve">
          <source>A Tag is the classification (the type) of an Entry.</source>
          <target state="translated">태그는 항목의 분류 (유형)입니다.</target>
        </trans-unit>
        <trans-unit id="ef54809c1f809bbc81d739791141ba6bfe3195c9" translate="yes" xml:space="preserve">
          <source>A TagPathError represents an error in the unmarshaling process caused by the use of field tags with conflicting paths.</source>
          <target state="translated">TagPathError는 경로가 충돌하는 필드 태그를 사용하여 발생하는 비 정렬 화 프로세스의 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cfb867f01ef9d999c5c50506e719de9fc48804c0" translate="yes" xml:space="preserve">
          <source>A Thread is a Mach-O thread state command.</source>
          <target state="translated">스레드는 Mach-O 스레드 상태 명령입니다.</target>
        </trans-unit>
        <trans-unit id="3dbde58d5e793d50fa510fe7375c9fb3e32dfb16" translate="yes" xml:space="preserve">
          <source>A Ticker holds a channel that delivers `ticks' of a clock at intervals.</source>
          <target state="translated">티커는 일정한 간격으로 클럭의 틱을 전달하는 채널을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="7f209a91b1ce9aba11e7fca4188986d7bf919dd4" translate="yes" xml:space="preserve">
          <source>A Time represents an instant in time with nanosecond precision.</source>
          <target state="translated">시간은 나노초 정밀도의 순간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b9cb2430925b635deca781b19b6624315647aa5" translate="yes" xml:space="preserve">
          <source>A Time value can be used by multiple goroutines simultaneously except that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and UnmarshalText are not concurrency-safe.</source>
          <target state="translated">GobDecode, UnmarshalBinary, UnmarshalJSON 및 UnmarshalText 메소드가 동시성으로 안전하지 않다는 점을 제외하고 여러 고 루틴에서 동시에 시간 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc605aba7b8cec3ee2c08a379778b18a8f897da" translate="yes" xml:space="preserve">
          <source>A Token holds a value of one of these types:</source>
          <target state="translated">토큰에는 다음 유형 중 하나의 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2538ba1b9edad5eed06dfc85f6e5a8fed234c97" translate="yes" xml:space="preserve">
          <source>A Token is an interface holding one of the token types: StartElement, EndElement, CharData, Comment, ProcInst, or Directive.</source>
          <target state="translated">토큰은 StartElement, EndElement, CharData, Comment, ProcInst 또는 Directive와 같은 토큰 유형 중 하나를 보유하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="75ea4973f3f3069985d057a27a7af063dfd40223" translate="yes" xml:space="preserve">
          <source>A TokenReader is anything that can decode a stream of XML tokens, including a Decoder.</source>
          <target state="translated">TokenReader는 디코더를 포함하여 XML 토큰 스트림을 디코딩 할 수있는 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef695f4304becb34a738bb8be42552a70be630fa" translate="yes" xml:space="preserve">
          <source>A Transport is a low-level primitive for making HTTP and HTTPS requests. For high-level functionality, such as cookies and redirects, see Client.</source>
          <target state="translated">전송은 HTTP 및 HTTPS 요청을위한 하위 레벨 기본 요소입니다. 쿠키 및 리디렉션과 같은 고급 기능에 대해서는 클라이언트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="205d177ec942d6309a89adfffdf8a8e4074a7f7b" translate="yes" xml:space="preserve">
          <source>A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple. Tuples are used as components of signatures and to represent the type of multiple assignments; they are not first class types of Go.</source>
          <target state="translated">튜플은 순서가 지정된 변수 목록을 나타냅니다. nil * 튜플은 유효한 (빈) 튜플입니다. 튜플은 시그니처의 구성 요소로 사용되며 다중 지정 유형을 나타냅니다. 그들은 일류의 바둑이 아니다.</target>
        </trans-unit>
        <trans-unit id="14a29b6908dc38e24f0ef8e838d5a62da69e0160" translate="yes" xml:space="preserve">
          <source>A Type conventionally represents a pointer to any of the specific Type structures (CharType, StructType, etc.).</source>
          <target state="translated">일반적으로 Type은 특정 Type 구조 (CharType, StructType 등)에 대한 포인터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd759fa17460fa844a3ecf99a0899b837ea8810c" translate="yes" xml:space="preserve">
          <source>A Type is the Mach-O file type, e.g. an object file, executable, or dynamic library.</source>
          <target state="translated">유형은 객체 파일, 실행 파일 또는 동적 라이브러리와 같은 Mach-O 파일 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7532bdeeed1f2b0e0e0f4a6bd401f739887f16a6" translate="yes" xml:space="preserve">
          <source>A Type represents a type of Go. All types implement the Type interface.</source>
          <target state="translated">Type은 Go의 유형을 나타냅니다. 모든 유형은 유형 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7719074f08defb90cf90e8a5c8093d6476b4e065" translate="yes" xml:space="preserve">
          <source>A TypeAssertExpr node represents an expression followed by a type assertion.</source>
          <target state="translated">TypeAssertExpr 노드는 식과 형식 어설 션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d7ee401043d765de08c455c9883bfd1233d24461" translate="yes" xml:space="preserve">
          <source>A TypeAssertionError explains a failed type assertion.</source>
          <target state="translated">TypeAssertionError는 실패한 형식 어설 션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bae8ad7f1e3b4dc01bc94d3eb7567f3b017542b9" translate="yes" xml:space="preserve">
          <source>A TypeName represents a name for a (defined or alias) type.</source>
          <target state="translated">TypeName은 (정의 또는 별칭) 유형의 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d9b19b626ba29ca522df11faf9d4d8dfae59037" translate="yes" xml:space="preserve">
          <source>A TypeSpec node represents a type declaration (TypeSpec production).</source>
          <target state="translated">TypeSpec 노드는 형식 선언 (TypeSpec 프로덕션)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d788b79782d20ca5644b516cf51099212dd89634" translate="yes" xml:space="preserve">
          <source>A TypedefType represents a named type.</source>
          <target state="translated">TypedefType은 명명 된 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a7264b7221a5f1d236f683a66cc15a2dd787040" translate="yes" xml:space="preserve">
          <source>A URL represents a parsed URL (technically, a URI reference).</source>
          <target state="translated">URL은 구문 분석 된 URL (기술적으로 URI 참조)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ad174328a1ff4a8b79959dd713d7b3d469c42e43" translate="yes" xml:space="preserve">
          <source>A UcharType represents an unsigned character type.</source>
          <target state="translated">UcharType은 부호없는 문자 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4e89dd3d467f282d2875f2c6ed05833cce1e25ec" translate="yes" xml:space="preserve">
          <source>A UintType represents an unsigned integer type.</source>
          <target state="translated">UintType은 부호없는 정수 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b1738f8b111b46e92286205e5eb8213ffeca4422" translate="yes" xml:space="preserve">
          <source>A UnaryExpr node represents a unary expression. Unary &quot;*&quot; expressions are represented via StarExpr nodes.</source>
          <target state="translated">UnaryExpr 노드는 단항 표현식을 나타냅니다. 단항 &quot;*&quot;표현식은 StarExpr 노드를 통해 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="3bbaa096ad1d0fa36610df8d2e4300b924364ad4" translate="yes" xml:space="preserve">
          <source>A Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations.</source>
          <target state="translated">기본 Go 값을 동등한 직접 작업에 동시에 사용할 수있는 경우 여러 고 루틴이 동시에 Value를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c45c278af71e2d7167507a12e5fa02bf92962a49" translate="yes" xml:space="preserve">
          <source>A Value must not be copied after first use.</source>
          <target state="translated">처음 사용한 후에는 값을 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="518c031b906d8366c9070eedabcd5d99e9858715" translate="yes" xml:space="preserve">
          <source>A Value provides an atomic load and store of a consistently typed value. The zero value for a Value returns nil from Load. Once Store has been called, a Value must not be copied.</source>
          <target state="translated">값은 일관된 유형의 값을 원자로드하고 저장합니다. 값의 0 값은로드에서 nil을 반환합니다. Store가 호출되면 값을 복사하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="704872c27dd11d1ea76e6e4ee6bb7625a22ead66" translate="yes" xml:space="preserve">
          <source>A Value represents the value of a Go constant.</source>
          <target state="translated">값은 Go 상수의 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35a6c26e4d0d39784db5b414382430945210b01d" translate="yes" xml:space="preserve">
          <source>A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method.</source>
          <target state="translated">ValueError는 지원하지 않는 Value에 대해 Value 메서드가 호출 될 때 발생합니다. 이러한 경우는 각 방법의 설명에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="211fb5033eea94f990c18370408afc6e4744bebf" translate="yes" xml:space="preserve">
          <source>A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production).</source>
          <target state="translated">ValueSpec 노드는 상수 또는 변수 선언 (ConstSpec 또는 VarSpec 생산)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6f61d7e37b3871edd50ca3a74b20b5673f75481c" translate="yes" xml:space="preserve">
          <source>A Variable represents a declared variable (including function parameters and results, and struct fields).</source>
          <target state="translated">변수는 선언 된 변수 (함수 매개 변수 및 결과 및 구조체 필드 포함)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cc9292dda86c62967d8590b7f8274a4d6182bbac" translate="yes" xml:space="preserve">
          <source>A Visitor's Visit method is invoked for each node encountered by Walk. If the result visitor w is not nil, Walk visits each of the children of node with the visitor w, followed by a call of w.Visit(nil).</source>
          <target state="translated">방문자가 방문한 각 노드에 대해 방문자의 방문 방법이 호출됩니다. 결과 방문자 w가 nil이 아닌 경우, Walk는 방문자 w를 가진 각 노드의 자식을 방문한 다음 w.Visit (nil)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="076ae0767034cf704db98525420b8ce59d22a34b" translate="yes" xml:space="preserve">
          <source>A VoidType represents the C void type.</source>
          <target state="translated">VoidType은 C void 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="85b56369886ad646746df4d1fecb50f680892b5f" translate="yes" xml:space="preserve">
          <source>A WaitGroup must not be copied after first use.</source>
          <target state="translated">WaitGroup은 처음 사용한 후에 복사해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5a86443f6e4c40a98aca5444ee468b15ace4abb9" translate="yes" xml:space="preserve">
          <source>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</source>
          <target state="translated">WaitGroup은 고 루틴 수집이 완료 될 때까지 기다립니다. 기본 고 루틴은 추가를 호출하여 대기 할 고 루틴 수를 설정합니다. 그런 다음 각 고 루틴이 실행되고 완료되면 완료를 호출합니다. 동시에 모든 고 루틴이 완료 될 때까지 대기를 사용하여 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ca4582ad63d50714d5b43b34c6ab0dd13e67819" translate="yes" xml:space="preserve">
          <source>A Weekday specifies a day of the week (Sunday = 0, ...).</source>
          <target state="translated">요일은 요일을 지정합니다 (일요일 = 0, ...).</target>
        </trans-unit>
        <trans-unit id="d03ea25e0944467c9c41cc98d93b797a4d51dd5d" translate="yes" xml:space="preserve">
          <source>A Word represents a single digit of a multi-precision unsigned integer.</source>
          <target state="translated">Word는 단 정밀도 부호없는 정수의 한 자리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="62446931282b9ac19aa0593be90e15a541acfc8a" translate="yes" xml:space="preserve">
          <source>A WordDecoder decodes MIME headers containing RFC 2047 encoded-words.</source>
          <target state="translated">WordDecoder는 RFC 2047 인코딩 단어를 포함하는 MIME 헤더를 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="3473f163231f1c313bb3aa97735626a5a618dbb5" translate="yes" xml:space="preserve">
          <source>A WordEncoder is an RFC 2047 encoded-word encoder.</source>
          <target state="translated">WordEncoder는 RFC 2047 인코딩 된 단어 인코더입니다.</target>
        </trans-unit>
        <trans-unit id="fe9276a229c981418c6948f78d1275b1c9fd2413" translate="yes" xml:space="preserve">
          <source>A WriteError reports an error encountered while writing output.</source>
          <target state="translated">WriteError는 출력을 쓰는 동안 발생한 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="921437c78574f3763c875d8ad66a7a5155e90433" translate="yes" xml:space="preserve">
          <source>A Writer generates multipart messages.</source>
          <target state="translated">기록기는 여러 부분으로 된 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8b5e497607507a45b86dfd8d4d2fb980d92c3ad6" translate="yes" xml:space="preserve">
          <source>A Writer implements convenience methods for writing requests or responses to a text protocol network connection.</source>
          <target state="translated">Writer는 텍스트 프로토콜 네트워크 연결에 대한 요청 또는 응답을 작성하기위한 편리한 방법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="dee10f306a0eaf4b16b88e2100cc5d77b7c0bc69" translate="yes" xml:space="preserve">
          <source>A Writer is a connection to a syslog server.</source>
          <target state="translated">라이터는 syslog 서버에 대한 연결입니다.</target>
        </trans-unit>
        <trans-unit id="4363ba1b66a07da1208c09d9517f251ba73b90f3" translate="yes" xml:space="preserve">
          <source>A Writer is a filter that inserts padding around tab-delimited columns in its input to align them in the output.</source>
          <target state="translated">라이터는 입력에서 탭으로 구분 된 열 주위에 패딩을 삽입하여 출력에 정렬하는 필터입니다.</target>
        </trans-unit>
        <trans-unit id="16a9d12a37b527fe37685b62e1a1f5da51add8c1" translate="yes" xml:space="preserve">
          <source>A Writer is a quoted-printable writer that implements io.WriteCloser.</source>
          <target state="translated">라이터는 io.WriteCloser를 구현하는 인용 가능한 인쇄 가능한 라이터입니다.</target>
        </trans-unit>
        <trans-unit id="0b5fc9bd20310af4833aa25ebe029221c38240f6" translate="yes" xml:space="preserve">
          <source>A Writer is an io.WriteCloser. Writes to a Writer are compressed and written to w.</source>
          <target state="translated">작가는 io.WriteCloser입니다. 라이터에 대한 쓰기는 압축되어 w에 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="03cec7474cfa008a6959e6f93e904ad74a1674d1" translate="yes" xml:space="preserve">
          <source>A Writer must be initialized with a call to Init. The first parameter (output) specifies the filter output. The remaining parameters control the formatting:</source>
          <target state="translated">라이터는 Init를 호출하여 초기화해야합니다. 첫 번째 매개 변수 (output)는 필터 출력을 지정합니다. 나머지 매개 변수는 형식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5465ae3ddfd70d1be5f5967ba8de154a01cefd5b" translate="yes" xml:space="preserve">
          <source>A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see NewWriter).</source>
          <target state="translated">기록기는 기록 된 데이터를 가져 와서 압축 된 형태의 데이터를 기본 기록기에 기록합니다 (NewWriter 참조).</target>
        </trans-unit>
        <trans-unit id="410a82fcce98e6fc886559574359b0fbe2e5eb6f" translate="yes" xml:space="preserve">
          <source>A Writer writes records using CSV encoding.</source>
          <target state="translated">기록기는 CSV 인코딩을 사용하여 레코드를 씁니다.</target>
        </trans-unit>
        <trans-unit id="48e7df2a646f4525d607dc7a30a82a5f83098c9f" translate="yes" xml:space="preserve">
          <source>A Zipf generates Zipf distributed variates.</source>
          <target state="translated">Zipf는 Zipf 분포 변수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0760dc9daa80e90d6d4229331a1af0e6683b9072" translate="yes" xml:space="preserve">
          <source>A benchmark ends when its Benchmark function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called only from the goroutine running the Benchmark function. The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines.</source>
          <target state="translated">벤치 마크 함수가 FailNow, Fatal, Fatalf, SkipNow, Skip 또는 Skipf 메서드를 반환하거나 호출하면 벤치 마크가 종료됩니다. 이러한 메소드는 벤치 마크 기능을 실행하는 고 루틴에서만 호출해야합니다. Log 및 Error의 변형과 같은 다른보고 방법은 여러 고 루틴에서 동시에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb7ac8d55d19c14bff60fcd03e9b73b76f2c42e" translate="yes" xml:space="preserve">
          <source>A boolean is encoded within an unsigned integer: 0 for false, 1 for true.</source>
          <target state="translated">부울은 부호없는 정수로 인코딩됩니다. 0은 false, 1은 true입니다.</target>
        </trans-unit>
        <trans-unit id="f01fce8b92a9885648984ba16014b68a79d5e744" translate="yes" xml:space="preserve">
          <source>A build constraint is evaluated as the OR of space-separated options. Each option evaluates as the AND of its comma-separated terms. Each term consists of letters, digits, underscores, and dots. A term may be negated with a preceding !. For example, the build constraint:</source>
          <target state="translated">빌드 제약 조건은 공백으로 구분 된 옵션의 OR로 평가됩니다. 각 옵션은 쉼표로 구분 된 용어의 AND로 평가됩니다. 각 용어는 문자, 숫자, 밑줄 및 점으로 구성됩니다. 용어는 앞에!로 부정 될 수 있습니다. 예를 들어, 빌드 제약 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65b5e15b8c1208e1ebae02236d460f4be7aeb5f2" translate="yes" xml:space="preserve">
          <source>A build constraint, also known as a build tag, is a line comment that begins</source>
          <target state="translated">빌드 태그라고도하는 빌드 제약 조건은 시작되는 줄 설명입니다.</target>
        </trans-unit>
        <trans-unit id="b9e79cabff6c03ded7ab173d941b59e4c2fcc202" translate="yes" xml:space="preserve">
          <source>A call to ValueOf returns a Value representing the run-time data. Zero takes a Type and returns a Value representing a zero value for that type.</source>
          <target state="translated">ValueOf를 호출하면 런타임 데이터를 나타내는 Value가 반환됩니다. Zero는 Type을 가져와 해당 형식의 0 값을 나타내는 Value를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36fdba5c705a01b336f31fab629a866bbfaa8f78" translate="yes" xml:space="preserve">
          <source>A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS &quot;CNAME&quot; records, as long as host resolves to address records.</source>
          <target state="translated">표준 이름은 0 개 이상의 CNAME 레코드 다음에 나오는 최종 이름입니다. 호스트가 레코드 레코드를 해결하는 한 호스트에 DNS &quot;CNAME&quot;레코드가 포함되지 않은 경우 LookupCNAME은 오류를 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7fc23252b8a8444204611f4f0f8eaee345d5cd3" translate="yes" xml:space="preserve">
          <source>A client wishing to use the service establishes a connection and then invokes NewClient on the connection. The convenience function Dial (DialHTTP) performs both steps for a raw network connection (an HTTP connection). The resulting Client object has two methods, Call and Go, that specify the service and method to call, a pointer containing the arguments, and a pointer to receive the result parameters.</source>
          <target state="translated">서비스를 사용하려는 클라이언트는 연결을 설정 한 다음 연결에서 NewClient를 호출합니다. 편의 기능 다이얼 (DialHTTP)은 원시 네트워크 연결 (HTTP 연결)에 대해 두 단계를 모두 수행합니다. 결과 Client 객체에는 호출 할 서비스 및 메소드, 인수를 포함하는 포인터 및 결과 매개 변수를 수신하는 포인터를 지정하는 Call 및 Go의 두 가지 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="260ac7a6348d4616a04fa117e8bbf40248a2aac8" translate="yes" xml:space="preserve">
          <source>A comment group g is associated with a node n if:</source>
          <target state="translated">다음과 같은 경우 주석 그룹 g는 노드 n과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="6201e2e8d36ed27d9f67af4f5dbcdce26a23ab67" translate="yes" xml:space="preserve">
          <source>A common idiom is to merge the check for nil return with the check that the value has the expected dynamic type, as in:</source>
          <target state="translated">일반적인 관용구는 다음과 같이 nil 리턴 확인과 값이 예상 동적 유형을 갖는 확인과 병합하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba5d21f25f75193bb1322654b338552fadea1382" translate="yes" xml:space="preserve">
          <source>A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered.</source>
          <target state="translated">검색의 일반적인 용도는 배열 또는 슬라이스와 같이 정렬 가능한 색인 가능한 데이터 구조에서 값 x의 색인 i를 찾는 것입니다. 이 경우 인수 f (일반적으로 클로저)는 검색 할 값과 데이터 구조의 색인 및 순서를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="33d3c617a7ed73a514301da6251e17e5ab959ed1" translate="yes" xml:space="preserve">
          <source>A csv file contains zero or more records of one or more fields per record. Each record is separated by the newline character. The final record may optionally be followed by a newline character.</source>
          <target state="translated">csv 파일에는 레코드 당 하나 이상의 필드에 대한 0 개 이상의 레코드가 포함됩니다. 각 레코드는 개행 문자로 구분됩니다. 최종 레코드 뒤에 선택적으로 개행 문자가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7caa085f191233dadd6ec8fb642202edd158870" translate="yes" xml:space="preserve">
          <source>A daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which.</source>
          <target state="translated">일광 절약 시간제 전환은 시간을 건너 뛰거나 반복합니다. 예를 들어, 미국에서는 2011 년 3 월 13 일 오전 2시 15 분이 발생하지 않았으며 2011 년 11 월 6 일 오전 1시 15 분이 두 번 발생했습니다. 이러한 경우 시간대 선택, 따라서 시간이 잘 정의되어 있지 않습니다. 날짜는 전환과 관련된 두 영역 중 하나에서 정확한 시간을 반환하지만 어느 것을 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="57af6fb36a3adf8a96b4592de464282206245987" translate="yes" xml:space="preserve">
          <source>A deadline is an absolute time after which I/O operations fail with an error instead of blocking. The deadline applies to all future and pending I/O, not just the immediately following call to Read or Write. After a deadline has been exceeded, the connection can be refreshed by setting a deadline in the future.</source>
          <target state="translated">최종 기한은 차단 대신 오류로 I / O 작업이 실패한 이후의 절대 시간입니다. 최종 기한은 읽기 또는 쓰기에 대한 바로 다음 호출뿐만 아니라 모든 미래 및 보류중인 I / O에 적용됩니다. 기한을 초과 한 후에는 기한을 설정하여 연결을 새로 고칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b53aa31dad4e2a94a06aac6f9f3bda2dcb94ebf7" translate="yes" xml:space="preserve">
          <source>A decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. When parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case a decimal point followed by a maximal series of digits is parsed as a fractional second.</source>
          <target state="translated">소수점 다음에 하나 이상의 0이 오는 경우 소수 자릿수 초를 나타내며 주어진 소수 자릿수로 인쇄됩니다. 소수점 이하 하나 이상의 9는 소수점 이하 자릿수를 나타내며 소수점 이하 자릿수로 인쇄되며 후행 0이 제거됩니다. 구문 분석 (만) 할 경우 레이아웃에 존재하지 않는 경우에도 입력에 초 필드 바로 뒤에 소수 초 필드가 포함될 수 있습니다. 이 경우 소수점 뒤에 최대 일련의 자릿수가 소수 초로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb1aaf5c04383e503526b587e3b53b0e3115f2d" translate="yes" xml:space="preserve">
          <source>A different subset of the mode bits are used, depending on the operating system.</source>
          <target state="translated">운영 체제에 따라 모드 비트의 다른 하위 집합이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8aee15dc1cb6f51da0900bf8773758523f3cab92" translate="yes" xml:space="preserve">
          <source>A file may have multiple build constraints. The overall constraint is the AND of the individual constraints. That is, the build constraints:</source>
          <target state="translated">파일에는 여러 빌드 제약 조건이있을 수 있습니다. 전체 제약 조건은 개별 제약 조건의 AND입니다. 즉, 빌드 제약 조건 :</target>
        </trans-unit>
        <trans-unit id="e5aebd71375f9513b2e98191249a7900f2298da7" translate="yes" xml:space="preserve">
          <source>A finalizer may run as soon as an object becomes unreachable. In order to use finalizers correctly, the program must ensure that the object is reachable until it is no longer required. Objects stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. For other objects, pass the object to a call of the KeepAlive function to mark the last point in the function where the object must be reachable.</source>
          <target state="translated">객체에 도달 할 수없는 즉시 종료자가 실행될 수 있습니다. 종료자를 올바르게 사용하려면 프로그램은 더 이상 필요하지 않을 때까지 오브젝트에 도달 할 수 있는지 확인해야합니다. 전역 변수에 저장되거나 전역 변수의 포인터를 추적하여 찾을 수있는 객체에 도달 할 수 있습니다. 다른 객체의 경우 객체를 KeepAlive 함수 호출에 전달하여 객체에 도달 할 수있는 함수의 마지막 지점을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="da1a6a99a449a5ea3376991cc3b251fd40ae595a" translate="yes" xml:space="preserve">
          <source>A fractional second is represented by adding a period and zeros to the end of the seconds section of layout string, as in &quot;15:04:05.000&quot; to format a time stamp with millisecond precision.</source>
          <target state="translated">&quot;15 : 04 : 05.000&quot;에서와 같이 밀리 초 정밀도로 타임 스탬프를 형식화하기 위해 레이아웃 문자열의 초 섹션 끝에 마침표와 0을 추가하여 분수 초를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e965d0f5f3f1435750b42e46c8ff14170f8ed15c" translate="yes" xml:space="preserve">
          <source>A fuller picture</source>
          <target state="translated">더 큰 그림</target>
        </trans-unit>
        <trans-unit id="2437bd04b669e4858c568d7a7b556cfc526d919f" translate="yes" xml:space="preserve">
          <source>A goroutine should call LockOSThread before calling OS services or non-Go library functions that depend on per-thread state.</source>
          <target state="translated">스레드 별 상태에 따라 OS 서비스 또는 비 Go 라이브러리 기능을 호출하기 전에 고 루틴이 LockOSThread를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4dcdf2a31c8cc2a191ea807a386fd6fa6b19641b" translate="yes" xml:space="preserve">
          <source>A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source.</source>
          <target state="translated">힙은 우선 순위 큐를 구현하는 일반적인 방법입니다. 우선 순위 대기열을 작성하려면 Less 메소드의 순서로 (음수) 우선 순위를 가진 힙 인터페이스를 구현하십시오. 따라서 Pop은 큐에서 우선 순위가 가장 높은 항목을 제거하는 동안 Push는 항목을 추가합니다. 실시 예는 그러한 구현을 포함한다; example_pq_test.go 파일에는 완전한 소스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16ad196fde70693ff0f37d80fffc0b333fedfdf" translate="yes" xml:space="preserve">
          <source>A line consisting of only white space is never continued.</source>
          <target state="translated">공백만으로 구성된 줄은 계속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afc9f8d3242f5eaf04e2e9b3c363b4deec607569" translate="yes" xml:space="preserve">
          <source>A list of cipher suite IDs that are, or have been, implemented by this package.</source>
          <target state="translated">이 패키지에서 구현되었거나 구현 된 암호 제품군 ID 목록.</target>
        </trans-unit>
        <trans-unit id="dd3ef60e1f91534e9d091bd4d798b2f024b79ceb" translate="yes" xml:space="preserve">
          <source>A literal IPv6 address in hostport must be enclosed in square brackets, as in &quot;[::1]:80&quot;, &quot;[::1%lo0]:80&quot;.</source>
          <target state="translated">호스트 포트의 리터럴 IPv6 주소는 &quot;[:: 1] : 80&quot;, &quot;[:: 1 % lo0] : 80&quot;과 같이 대괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="5dc7cfeeb708df0f962816ce176c0c581f7f3bc1" translate="yes" xml:space="preserve">
          <source>A locked Mutex is not associated with a particular goroutine. It is allowed for one goroutine to lock a Mutex and then arrange for another goroutine to unlock it.</source>
          <target state="translated">잠긴 뮤텍스는 특정 고 루틴과 관련이 없습니다. 하나의 고 루틴이 Mutex를 잠그고 다른 고 루틴이 잠금을 해제하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac3d8ec28edd54aa88cf818d84291bb78f42ac35" translate="yes" xml:space="preserve">
          <source>A lookup function must be provided for correct module-aware operation. Deprecated: If lookup is nil, for backwards-compatibility, the importer will attempt to resolve imports in the $GOPATH workspace.</source>
          <target state="translated">올바른 모듈 인식 작동을 위해서는 조회 기능이 제공되어야합니다. 더 이상 사용되지 않음 : 이전 버전과의 호환성을 위해 조회가 nil 인 경우 임포터는 $ GOPATH 작업 공간에서 가져 오기를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4af7a8e5ef9812183582f7353a58a98b1bf43580" translate="yes" xml:space="preserve">
          <source>A missing element or empty attribute value will be unmarshaled as a zero value. If the field is a slice, a zero value will be appended to the field. Otherwise, the field will be set to its zero value.</source>
          <target state="translated">누락 된 요소 또는 빈 속성 값은 0 값으로 비 정렬 화됩니다. 필드가 슬라이스 인 경우 필드에 0 값이 추가됩니다. 그렇지 않으면 필드가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="facf040ac7eba8fb44518815fa41c78439754caa" translate="yes" xml:space="preserve">
          <source>A mode value is a set of flags (or 0). They control scanner behavior.</source>
          <target state="translated">모드 값은 플래그 세트 (또는 0)입니다. 스캐너 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="25cf3a2ce55598fd47c06f8dc8fba0d37cd2cc75" translate="yes" xml:space="preserve">
          <source>A nil *Resolver is equivalent to a zero Resolver.</source>
          <target state="translated">nil * Resolver는 제로 Resolver와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9f2c7f03c9badde39c7a80393c1376e7c03c61a" translate="yes" xml:space="preserve">
          <source>A nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO_PROXY.</source>
          <target state="translated">환경에 프록시가 정의되어 있지 않거나 NO_PROXY에 의해 정의 된대로 지정된 요청에 프록시를 사용하지 않으면 nil URL 및 nil 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eab5d59cf31afe135bcedd98e1fb7a9d4aa7fe2b" translate="yes" xml:space="preserve">
          <source>A non-nil FieldFilter f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. Unexported struct fields are never printed.</source>
          <target state="translated">비-닐 FieldFilter f는 출력을 제어하기 위해 제공 될 수있다 : f (fieldname, fieldvalue)가 참인 구조체 필드가 ​​인쇄되고; 다른 모든 것은 출력에서 ​​필터링됩니다. 내 보내지 않은 구조체 필드는 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dad360f25cca4579e42ac746bdde335602ae158f" translate="yes" xml:space="preserve">
          <source>A nonzero finite Float represents a multi-precision floating point number</source>
          <target state="translated">0이 아닌 유한 플로트는 다중 정밀도 부동 소수점 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="67f20c1e684209c8ed072b03f5dbc6b88dfcdb75" translate="yes" xml:space="preserve">
          <source>A note about ZIP64:</source>
          <target state="translated">ZIP64에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="567bb53b185e88e525e4138c042b8ddb8af9e0fd" translate="yes" xml:space="preserve">
          <source>A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1.</source>
          <target state="translated">GODEBUG = netdns = 1에서와 같이 숫자 netdns 설정은 결정자가 결정에 대한 디버깅 정보를 인쇄하게합니다. 디버깅 정보를 인쇄하는 동안 특정 리졸버를 강제 실행하려면 GODEBUG = netdns = go + 1에서와 같이 더하기 부호로 두 설정을 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="a1e9d7b7caa6b6f7b48c88742eade61d0fb9b1a3" translate="yes" xml:space="preserve">
          <source>A package is complete if its scope contains (at least) all exported objects; otherwise it is incomplete.</source>
          <target state="translated">패키지의 범위에 (내 보낸) 모든 내 보낸 객체가 있으면 패키지가 완료됩니다. 그렇지 않으면 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="e2eb8ed0def3b86fafe13f7d6fcbec9f7035334a" translate="yes" xml:space="preserve">
          <source>A pipeline inside an action may initialize a variable to capture the result. The initialization has syntax</source>
          <target state="translated">작업 내부의 파이프 라인은 결과를 캡처하기 위해 변수를 초기화 할 수 있습니다. 초기화에는 구문이 있습니다</target>
        </trans-unit>
        <trans-unit id="159568cd8af281aa06ef8c37825fa46265e15546" translate="yes" xml:space="preserve">
          <source>A pipeline is a possibly chained sequence of &quot;commands&quot;. A command is a simple value (argument) or a function or method call, possibly with multiple arguments:</source>
          <target state="translated">파이프 라인은 체인화 된 &quot;명령&quot;시퀀스입니다. 명령은 간단한 값 (인수) 또는 함수 또는 메서드 호출이며 여러 인수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a982db72ea1fb9ba66b22f1af9be32523e2a43" translate="yes" xml:space="preserve">
          <source>A pipeline may be &quot;chained&quot; by separating a sequence of commands with pipeline characters '|'. In a chained pipeline, the result of each command is passed as the last argument of the following command. The output of the final command in the pipeline is the value of the pipeline.</source>
          <target state="translated">파이프 라인 문자는 파이프 라인 문자 '|'로 일련의 명령을 분리하여 &quot;체인&quot;될 수 있습니다. 연결 파이프 라인에서 각 명령의 결과는 다음 명령의 마지막 인수로 전달됩니다. 파이프 라인의 최종 명령 출력은 파이프 라인의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e435d830501b57692560d08004b34491160b2337" translate="yes" xml:space="preserve">
          <source>A pipelined server can use the same calls to ensure that responses computed in parallel are written in the correct order.</source>
          <target state="translated">파이프 라인 서버는 동일한 호출을 사용하여 병렬로 계산 된 응답이 올바른 순서로 작성되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c49361545d95418f04cbcdcf2b2ab41b7a40c811" translate="yes" xml:space="preserve">
          <source>A plugin is a Go main package with exported functions and variables that has been built with:</source>
          <target state="translated">플러그인은 다음과 같이 빌드 된 함수 및 변수를 내 보낸 Go 기본 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="81f9a7dada15598723e182d4050df9eb32499489" translate="yes" xml:space="preserve">
          <source>A preset dictionary can be used to improve the compression ratio. The downside to using a dictionary is that the compressor and decompressor must agree in advance what dictionary to use.</source>
          <target state="translated">사전 설정 사전을 사용하여 압축 비율을 향상시킬 수 있습니다. 사전 사용의 단점은 압축기와 압축 해제 기가 어떤 사전을 사용해야하는지 미리 동의해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="947f86e05fc12ea1145d41f40f9588a79a2d1df5" translate="yes" xml:space="preserve">
          <source>A public suffix list implementation is in the package golang.org/x/net/publicsuffix.</source>
          <target state="translated">공개 접미사 목록 구현은 golang.org/x/net/publicsuffix 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a4f3b805b19490b13c81014b70583343cfccf0" translate="yes" xml:space="preserve">
          <source>A region is for logging a time interval during a goroutine's execution. By definition, a region starts and ends in the same goroutine. Regions can be nested to represent subintervals. For example, the following code records four regions in the execution trace to trace the durations of sequential steps in a cappuccino making operation.</source>
          <target state="translated">region은 goroutine 실행 중 시간 간격을 기록하기위한 것입니다. 정의에 따라 영역은 동일한 고 루틴에서 시작하고 끝납니다. 하위 간격을 나타 내기 위해 영역을 중첩 할 수 있습니다. 예를 들어, 다음 코드는 카푸치노 제조 작업에서 순차적 단계의 지속 시간을 추적하기 위해 실행 추적에 4 개의 영역을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="19e9496f5feeba3316d5f9c892e638126465f862" translate="yes" xml:space="preserve">
          <source>A sample benchmark function looks like this:</source>
          <target state="translated">샘플 벤치 마크 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64d7f2b7d8c639b9703cb9c512522716406ca71c" translate="yes" xml:space="preserve">
          <source>A segment of text may be escaped by bracketing it with Escape characters. The tabwriter passes escaped text segments through unchanged. In particular, it does not interpret any tabs or line breaks within the segment. If the StripEscape flag is set, the Escape characters are stripped from the output; otherwise they are passed through as well. For the purpose of formatting, the width of the escaped text is always computed excluding the Escape characters.</source>
          <target state="translated">이스케이프 문자로 묶어 텍스트 세그먼트를 이스케이프 처리 할 수 ​​있습니다. tabwriter는 이스케이프 된 텍스트 세그먼트를 변경없이 통과시킵니다. 특히 세그먼트 내의 탭이나 줄 바꿈을 해석하지 않습니다. StripEscape 플래그가 설정되면 출력에서 ​​이스케이프 문자가 제거됩니다. 그렇지 않으면 그것들도 통과됩니다. 서식을 지정하기 위해 이스케이프 문자를 제외하고 이스케이프 된 텍스트의 너비는 항상 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="cbf67455e625a319934ff3db6f4e7765c384f850" translate="yes" xml:space="preserve">
          <source>A server implementation will often provide a simple, type-safe wrapper for the client.</source>
          <target state="translated">서버 구현은 종종 클라이언트에게 단순하고 안전한 형식의 래퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5fe1bd315f5a675d22edfe1287dcef7a18f2ebf5" translate="yes" xml:space="preserve">
          <source>A set of constants for precedence-based expression parsing. Non-operators have lowest precedence, followed by operators starting with precedence 1 up to unary operators. The highest precedence serves as &quot;catch-all&quot; precedence for selector, indexing, and other operator and delimiter tokens.</source>
          <target state="translated">우선 순위 기반 식 구문 분석을위한 상수 집합입니다. 비 연산자가 우선 순위가 가장 낮고 우선 순위 1부터 시작하여 단항 연산자까지 연산자가 뒤 따릅니다. 가장 높은 우선 순위는 선택기, 인덱싱 및 기타 연산자 및 구분 기호 토큰에 대한 &quot;캐치 전체&quot;우선 순위로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f475688772a3727780325202b67ed9bcfba627" translate="yes" xml:space="preserve">
          <source>A signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1 upward contain the value; bit 0 says whether they should be complemented upon receipt. The encode algorithm looks like this:</source>
          <target state="translated">부호있는 정수 i는 부호없는 정수 u 내에 인코딩됩니다. u 내에서 비트 1은 값을 포함합니다. 비트 0은 수신시 보완해야하는지 여부를 나타냅니다. 인코딩 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c6185e40ebf683daf5fbd59be060f229f28d552" translate="yes" xml:space="preserve">
          <source>A simple implementation of TestMain is:</source>
          <target state="translated">TestMain의 간단한 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afdf12aec718dd4999cbe7ecda6d1bb5b3e50e14" translate="yes" xml:space="preserve">
          <source>A simple test function looks like this:</source>
          <target state="translated">간단한 테스트 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92ea7ad194070845bcee235ee4cd7d7c3a7afe32" translate="yes" xml:space="preserve">
          <source>A simple way to create wrapped errors is to call fmt.Errorf and apply the %w verb to the error argument:</source>
          <target state="translated">랩핑 된 오류를 작성하는 간단한 방법은 fmt.Errorf를 호출하고 % w 동사를 오류 인수에 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="69d7e4afbc359dbfa554c3437471beab838e64ea" translate="yes" xml:space="preserve">
          <source>A single goroutine runs all finalizers for a program, sequentially. If a finalizer must run for a long time, it should do so by starting a new goroutine.</source>
          <target state="translated">단일 goroutine은 프로그램의 모든 종료자를 순차적으로 실행합니다. 종료자가 오랫동안 실행되어야하는 경우 새 고 루틴을 시작하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="998765c2e36e31f6015a02a4149186686a19882c" translate="yes" xml:space="preserve">
          <source>A source position is represented by a Position value. A position is valid if Line &amp;gt; 0.</source>
          <target state="translated">소스 위치는 위치 값으로 표시됩니다. 라인&amp;gt; 0 인 경우 위치가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="bf46d56633e189cdf4290bc8e9e419edaafcd303" translate="yes" xml:space="preserve">
          <source>A span of indented lines is converted into a &amp;lt;pre&amp;gt; block, with the common indent prefix removed.</source>
          <target state="translated">들여 쓰기 된 줄 범위는 &amp;lt;pre&amp;gt; 블록으로 변환되며 공통 들여 쓰기 접두사가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="23ed42dff836502e8a3c882497b88d19de475752" translate="yes" xml:space="preserve">
          <source>A special Unknown value may be used when a value is unknown due to an error. Operations on unknown values produce unknown values unless specified otherwise.</source>
          <target state="translated">오류로 인해 값을 알 수없는 경우 특수한 알 수없는 값을 사용할 수 있습니다. 알 수없는 값에 대한 작업은 달리 지정하지 않는 한 알 수없는 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="39c3619132ff27692be31f7370bad818ba2f7ae2" translate="yes" xml:space="preserve">
          <source>A stream of gobs is self-describing. Each data item in the stream is preceded by a specification of its type, expressed in terms of a small set of predefined types. Pointers are not transmitted, but the things they point to are transmitted; that is, the values are flattened. Nil pointers are not permitted, as they have no value. Recursive types work fine, but recursive values (data with cycles) are problematic. This may change.</source>
          <target state="translated">덩어리의 흐름은 자기 서술 적입니다. 스트림의 각 데이터 항목 앞에는 사전 정의 된 작은 유형의 세트로 표시되는 해당 유형의 스펙이옵니다. 포인터는 전송되지 않지만 그들이 가리키는 것은 전송됩니다. 즉, 값이 평평 해집니다. 유효하지 않은 포인터는 값이 없으므로 허용되지 않습니다. 재귀 유형은 잘 작동하지만 재귀 값 (사이클이있는 데이터)에는 문제가 있습니다. 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71de669748bcf101bd8bd68f5e95383f0e17c03d" translate="yes" xml:space="preserve">
          <source>A subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1.</source>
          <target state="translated">하위 벤치 마크는 다른 벤치 마크와 같습니다. Run을 한 번 이상 호출하는 벤치 마크는 자체적으로 측정되지 않으며 N = 1로 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c8c5a16c89f340d07d186a6221473d049ea1a6" translate="yes" xml:space="preserve">
          <source>A successful Copy returns err == nil, not err == EOF. Because Copy is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.</source>
          <target state="translated">성공적인 복사는 err == EOF가 아니라 err == nil을 리턴합니다. Copy는 EOF까지 src에서 읽도록 정의되므로 Read의 EOF를보고 할 오류로 취급하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b2067ff10a529e4ca642d4b746a82a3c56ab2f4" translate="yes" xml:space="preserve">
          <source>A task is a higher-level component that aids tracing of logical operations such as an RPC request, an HTTP request, or an interesting local operation which may require multiple goroutines working together. Since tasks can involve multiple goroutines, they are tracked via a context.Context object. NewTask creates a new task and embeds it in the returned context.Context object. Log messages and regions are attached to the task, if any, in the Context passed to Log and WithRegion.</source>
          <target state="translated">작업은 RPC 요청, HTTP 요청 또는 여러 개의 고 루틴이 함께 작업해야하는 흥미로운 로컬 작업과 같은 논리적 작업을 추적하는 데 도움이되는 상위 수준의 구성 요소입니다. 작업에는 여러 고 루틴이 포함될 수 있으므로 context.Context 객체를 통해 추적됩니다. NewTask는 새 작업을 만들어 반환 된 context.Context 객체에 포함시킵니다. 로그 메시지 및 리전은 컨텍스트가있는 경우 Log and WithRegion으로 전달 된 작업에서 작업에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="1ee23ed297d8a4efee537f23283818e2de1f476f" translate="yes" xml:space="preserve">
          <source>A template may be executed directly or through ExecuteTemplate, which executes an associated template identified by name. To invoke our example above, we might write,</source>
          <target state="translated">템플릿은 직접 또는 ExecuteTemplate을 통해 실행될 수 있으며, 이름으로 식별 된 관련 템플릿을 실행합니다. 위의 예를 불러 보려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee08d9d80bebe4fc53065d91023da1f3f13f8ce" translate="yes" xml:space="preserve">
          <source>A template may use a template invocation to instantiate another associated template; see the explanation of the &quot;template&quot; action above. The name must be that of a template associated with the template that contains the invocation.</source>
          <target state="translated">템플릿은 템플릿 호출을 사용하여 다른 관련 템플릿을 인스턴스화 할 수 있습니다. 위의 &quot;템플릿&quot;작업에 대한 설명을 참조하십시오. 이름은 호출을 포함하는 템플리트와 연관된 템플리트의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="efdc8c7bbd155802920fdf599596729921196f95" translate="yes" xml:space="preserve">
          <source>A test ends when its Test function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as the Parallel method, must be called only from the goroutine running the Test function.</source>
          <target state="translated">Test 함수는 FailNow, Fatal, Fatalf, SkipNow, Skip 또는 Skipf 메소드를 반환하거나 호출하면 테스트가 종료됩니다. Parallel 메소드뿐만 아니라 이러한 메소드는 Test 함수를 실행하는 goroutine에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8d282a7f8e7544e2aa2bcaa602cc973c7e5c659" translate="yes" xml:space="preserve">
          <source>A transaction must end with a call to Commit or Rollback.</source>
          <target state="translated">트랜잭션은 커밋 또는 롤백 호출로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="3320956e1450f29dc681f22efeb9962f889d2fa1" translate="yes" xml:space="preserve">
          <source>A type, typically a collection, that satisfies sort.Interface can be sorted by the routines in this package. The methods require that the elements of the collection be enumerated by an integer index.</source>
          <target state="translated">sort.Interface를 충족하는 형식 (일반적으로 컬렉션)은 인터페이스를이 패키지의 루틴으로 정렬 할 수 있습니다. 이 방법을 사용하려면 컬렉션의 요소를 정수 인덱스로 열거해야합니다.</target>
        </trans-unit>
        <trans-unit id="a26264b4c327dfcbc3830f08e7c5eca9935077d1" translate="yes" xml:space="preserve">
          <source>A uintptr is an integer, not a reference. Converting a Pointer to a uintptr creates an integer value with no pointer semantics. Even if a uintptr holds the address of some object, the garbage collector will not update that uintptr's value if the object moves, nor will that uintptr keep the object from being reclaimed.</source>
          <target state="translated">uintptr은 정수가 아닌 참조입니다. 포인터를 uintptr로 변환하면 포인터 의미가없는 정수 값이 작성됩니다. uintptr이 일부 오브젝트의 주소를 보유하더라도, 가비지 콜렉터는 오브젝트가 이동해도 uintptr의 값을 업데이트하지 않으며 uintptr이 오브젝트를 회수하지 못하게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6357f4b1d95e0ce37eebd11835deedd5ee68808" translate="yes" xml:space="preserve">
          <source>A value can be one of several &quot;attribute classes&quot; defined by DWARF. The Go types corresponding to each class are:</source>
          <target state="translated">값은 DWARF에 의해 정의 된 여러 &quot;속성 클래스&quot;중 하나 일 수 있습니다. 각 클래스에 해당하는 Go 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ca0e97732ee145c6b13c705a240bbab4a01b83c" translate="yes" xml:space="preserve">
          <source>A variable's scope extends to the &quot;end&quot; action of the control structure (&quot;if&quot;, &quot;with&quot;, or &quot;range&quot;) in which it is declared, or to the end of the template if there is no such control structure. A template invocation does not inherit variables from the point of its invocation.</source>
          <target state="translated">변수의 범위는 변수가 선언 된 제어 구조의 &quot;종료&quot;동작 ( &quot;if&quot;, &quot;with&quot;또는 &quot;range&quot;)으로 확장되거나 제어 구조가없는 경우 템플리트의 끝까지 확장됩니다. 템플릿 호출은 호출 시점에서 변수를 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="277f2ef6de143a1e0bb8964486b9103bd5a3dfcf" translate="yes" xml:space="preserve">
          <source>A very simplified example showing where KeepAlive is required:</source>
          <target state="translated">KeepAlive가 필요한 곳을 보여주는 매우 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="eebb7aaedcbbc7945cea32525b4cdf890bdf1fc6" translate="yes" xml:space="preserve">
          <source>A wrapped function triggered during a call from Go to JavaScript gets executed on the same goroutine. A wrapped function triggered by JavaScript's event loop gets executed on an extra goroutine. Blocking operations in the wrapped function will block the event loop. As a consequence, if one wrapped function blocks, other wrapped funcs will not be processed. A blocking function should therefore explicitly start a new goroutine.</source>
          <target state="translated">Go to JavaScript에서 호출하는 동안 트리거 된 랩핑 된 함수는 동일한 goroutine에서 실행됩니다. JavaScript의 이벤트 루프에 의해 트리거 된 랩핑 된 함수는 추가 고 루틴에서 실행됩니다. 랩핑 된 함수의 차단 조작은 이벤트 루프를 차단합니다. 결과적으로 하나의 랩핑 된 기능이 차단되면 다른 랩핑 된 기능은 처리되지 않습니다. 따라서 차단 기능은 새로운 고 루틴을 명시 적으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e11b9a7861656f839cf023235f454d8751a6b44" translate="yes" xml:space="preserve">
          <source>A zero value for t means I/O operations will not time out.</source>
          <target state="translated">t 값이 0이면 I / O 작업이 시간 초과되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49015c1a0e4eec28a8e64a69c22aab5605a9ed24" translate="yes" xml:space="preserve">
          <source>AEAD is a cipher mode providing authenticated encryption with associated data. For a description of the methodology, see</source>
          <target state="translated">AEAD는 관련 데이터로 인증 된 암호화를 제공하는 암호 모드입니다. 방법론에 대한 설명은</target>
        </trans-unit>
        <trans-unit id="6386009a221e1f55418b7cdc3ea6e0081e79ebfc" translate="yes" xml:space="preserve">
          <source>AIX requires a larger stack for syscalls.</source>
          <target state="translated">AIX에는 syscall을 위해 더 큰 스택이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a103500548f73a0f49e73232e6ab381788940bd2" translate="yes" xml:space="preserve">
          <source>AOffset returns the index of the first element of A that corresponds to the pixel at (x, y).</source>
          <target state="translated">AOffset은 (x, y)의 픽셀에 해당하는 A의 첫 번째 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a3a55e32c78ce3caeb7ecef53c05aa71e685921c" translate="yes" xml:space="preserve">
          <source>ASCII character classes:</source>
          <target state="translated">ASCII 문자 클래스 :</target>
        </trans-unit>
        <trans-unit id="dfa0d565701c5ffd212df5f6c41e07c13104217e" translate="yes" xml:space="preserve">
          <source>ASN.1 class types represent the namespace of the tag.</source>
          <target state="translated">ASN.1 클래스 유형은 태그의 네임 스페이스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="94a132b5e73edb52effd7e957ed89df7719d6948" translate="yes" xml:space="preserve">
          <source>ASN.1 tags represent the type of the following object.</source>
          <target state="translated">ASN.1 태그는 다음 객체의 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fafb344d4664552bfbe22ad591e49b7c95b5c8a5" translate="yes" xml:space="preserve">
          <source>Abs</source>
          <target state="translated">Abs</target>
        </trans-unit>
        <trans-unit id="19946b96a18fb5a61fbdcba6ee58a2bae2a9f4fd" translate="yes" xml:space="preserve">
          <source>Abs returns an absolute representation of path. If the path is not absolute it will be joined with the current working directory to turn it into an absolute path. The absolute path name for a given file is not guaranteed to be unique. Abs calls Clean on the result.</source>
          <target state="translated">Abs는 경로의 절대 표현을 반환합니다. 경로가 절대 경로가 아닌 경우 현재 작업 디렉토리와 결합되어 절대 경로로 바뀝니다. 주어진 파일의 절대 경로 이름이 고유하지는 않습니다. Abs는 결과에 대해 Clean을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="98c1dba71e48002668b64c9af03e2c7ed77c3775" translate="yes" xml:space="preserve">
          <source>Abs returns the absolute value (also called the modulus) of x.</source>
          <target state="translated">Abs는 x의 절대 값 (모듈러스라고도 함)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea6f0b4dac884978efb8a2a3ce802681b993d2d8" translate="yes" xml:space="preserve">
          <source>Abs returns the absolute value of x.</source>
          <target state="translated">Abs는 x의 절대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="852b904fc647c005799087d9e0034bfb32f26290" translate="yes" xml:space="preserve">
          <source>Abs sets z to the (possibly rounded) value |x| (the absolute value of x) and returns z.</source>
          <target state="translated">Abs는 z를 (둥근 반올림) 값 | x |로 설정합니다. (x의 절대 값)을 반환하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3ca403f8d39ff7d494165748328771f2b7bbdb5" translate="yes" xml:space="preserve">
          <source>Abs sets z to |x| (the absolute value of x) and returns z.</source>
          <target state="translated">Abs는 z를 | x |로 설정합니다. (x의 절대 값)을 반환하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae77eeba4d31564d88f515ff5369514989cb2f2d" translate="yes" xml:space="preserve">
          <source>Acc returns the accuracy of x produced by the most recent operation.</source>
          <target state="translated">Acc는 가장 최근 작업에서 생성 된 x의 정확도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0362299cc7e336214cb347eec2f94f2bdb92e7da" translate="yes" xml:space="preserve">
          <source>Accept accepts connections on the listener and serves requests for each incoming connection. Accept blocks until the listener returns a non-nil error. The caller typically invokes Accept in a go statement.</source>
          <target state="translated">Accept는 리스너에서 연결을 수락하고 들어오는 각 연결에 대한 요청을 처리합니다. 리스너가 non-nil 오류를 리턴 할 때까지 블록을 승인하십시오. 호출자는 일반적으로 go 문에서 Accept를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="57eaa16ddc7c7646a44dc64075488d9952239919" translate="yes" xml:space="preserve">
          <source>Accept accepts connections on the listener and serves requests to DefaultServer for each incoming connection. Accept blocks; the caller typically invokes it in a go statement.</source>
          <target state="translated">Accept는 리스너에서 연결을 수락하고 들어오는 각 연결에 대해 DefaultServer에 요청을 제공합니다. 블록을 수락; 호출자는 일반적으로 go 문에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="423f068caff20db5aabcaa680f972ba550429b79" translate="yes" xml:space="preserve">
          <source>Accept implements the Accept method in the Listener interface. Returned connections will be of type *UnixConn.</source>
          <target state="translated">Accept는 리스너 인터페이스에서 Accept 메소드를 구현합니다. 리턴 된 연결은 * UnixConn 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7e027066959a798df007c741aaa3722942174acb" translate="yes" xml:space="preserve">
          <source>Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn.</source>
          <target state="translated">Accept는 Listener 인터페이스에서 Accept 메소드를 구현합니다. 다음 호출을 기다렸다가 일반 Conn을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f0dc51c4dcc23b2474ab41ecb5ead25a053962d" translate="yes" xml:space="preserve">
          <source>AcceptTCP accepts the next incoming call and returns the new connection.</source>
          <target state="translated">AcceptTCP는 다음 수신 전화를 받고 새 연결을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afbe83d1557a2732b88156a14bcd7fec9705a897" translate="yes" xml:space="preserve">
          <source>AcceptUnix accepts the next incoming call and returns the new connection.</source>
          <target state="translated">AcceptUnix는 다음 수신 전화를 받고 새 연결을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1204f16b1e7a74c87931ad0f07bf33ea0b083d5" translate="yes" xml:space="preserve">
          <source>Accuracy describes the rounding error produced by the most recent operation that generated a Float value, relative to the exact value.</source>
          <target state="translated">정확도는 정확한 값을 기준으로 Float 값을 생성 한 가장 최근 작업에서 발생한 반올림 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a3a86c10c26f951f6f2f070ab18bc1cb2a65e440" translate="yes" xml:space="preserve">
          <source>Acos</source>
          <target state="translated">Acos</target>
        </trans-unit>
        <trans-unit id="9ec162a3f0eb0d539229eaef831d34b303a9dc5e" translate="yes" xml:space="preserve">
          <source>Acos returns the arccosine, in radians, of x.</source>
          <target state="translated">Acos는 x의 아크 코사인을 라디안으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a975a4c783d13717e86d77c53ecde8ac7934025" translate="yes" xml:space="preserve">
          <source>Acos returns the inverse cosine of x.</source>
          <target state="translated">Acos는 x의 역 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cf25bedca9a3b72e65c01ff90e81f6a09baa5d69" translate="yes" xml:space="preserve">
          <source>Acosh</source>
          <target state="translated">Acosh</target>
        </trans-unit>
        <trans-unit id="473dc4a14e53c4e4b4da1925bd0307c4f77ea728" translate="yes" xml:space="preserve">
          <source>Acosh returns the inverse hyperbolic cosine of x.</source>
          <target state="translated">Acosh는 x의 역 쌍곡 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34ab3eeafa84c841f51a4ab029c76137c950219d" translate="yes" xml:space="preserve">
          <source>ActionNode holds an action (something bounded by delimiters). Control actions have their own nodes; ActionNode represents simple ones such as field evaluations and parenthesized pipelines.</source>
          <target state="translated">ActionNode는 조치 (구분 기호로 묶인 것)를 보유합니다. 제어 조치에는 자체 노드가 있습니다. ActionNode는 필드 평가 및 괄호로 묶은 파이프 라인과 같은 간단한 노드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="e10171b115b80f0812f3bc6096a1b7a8d483bee0" translate="yes" xml:space="preserve">
          <source>Add adds an Error with given position and error message to an ErrorList.</source>
          <target state="translated">추가는 주어진 위치와 오류 메시지가있는 Error를 ErrorList에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fc94957ebb8a3766a3ddd6d8708dd83346338038" translate="yes" xml:space="preserve">
          <source>Add adds delta to the *Int value stored under the given map key.</source>
          <target state="translated">추가는 주어진 맵 키 아래에 저장된 * Int 값에 델타를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="15b0f7deabf48f6522decffbdc31da06a1ce200f" translate="yes" xml:space="preserve">
          <source>Add adds delta to v.</source>
          <target state="translated">추가 v에 델타를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="00d98d0fbeab0413ea8bf940cbb8eed92cb4cf17" translate="yes" xml:space="preserve">
          <source>Add adds delta, which may be negative, to the WaitGroup counter. If the counter becomes zero, all goroutines blocked on Wait are released. If the counter goes negative, Add panics.</source>
          <target state="translated">추가는 음수 일 수있는 델타를 WaitGroup 카운터에 추가합니다. 카운터가 0이되면 대기에서 차단 된 모든 고 루틴이 해제됩니다. 카운터가 음수이면 패닉을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="06d67ceb15cbe764f4e2559821764917fc9be46e" translate="yes" xml:space="preserve">
          <source>Add adds the current execution stack to the profile, associated with value. Add stores value in an internal map, so value must be suitable for use as a map key and will not be garbage collected until the corresponding call to Remove. Add panics if the profile already contains a stack for value.</source>
          <target state="translated">추가는 현재 실행 스택을 값과 연관된 프로파일에 추가합니다. 내부 맵에 상점 값을 추가하므로 값은 맵 키로 사용하기에 적합해야하며 Remove를 호출 할 때까지 가비지 수집되지 않습니다. 프로파일에 값 스택이 이미 포함 된 경우 패닉을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a7fe05fac6821303f4013d3a0551fa7da8da7b91" translate="yes" xml:space="preserve">
          <source>Add adds the key, value pair to the header. It appends to any existing values associated with key.</source>
          <target state="translated">추가는 키, 값 쌍을 헤더에 추가합니다. 키와 관련된 기존 값에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5f1b2275acb843bf0e477760c4f63abe02e338d9" translate="yes" xml:space="preserve">
          <source>Add adds the key, value pair to the header. It appends to any existing values associated with key. The key is case insensitive; it is canonicalized by CanonicalHeaderKey.</source>
          <target state="translated">추가는 키, 값 쌍을 헤더에 추가합니다. 키와 관련된 기존 값에 추가됩니다. 키는 대소 문자를 구분하지 않습니다. CanonicalHeaderKey에 의해 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="0faf3a11d8aff451702ae67094983396accac447" translate="yes" xml:space="preserve">
          <source>Add adds the named field (which should start with a period) to the end of the chain.</source>
          <target state="translated">추가는 체인의 끝에 이름이 지정된 필드 (마침표로 시작해야 함)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="278b0456faaade1119bfe47b6df98c28eccf61ea" translate="yes" xml:space="preserve">
          <source>Add adds the value to key. It appends to any existing values associated with key.</source>
          <target state="translated">추가는 키에 값을 추가합니다. 키와 관련된 기존 값에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f60549ee0cfc5f32434c271b42c44b06989961" translate="yes" xml:space="preserve">
          <source>Add returns the rectangle r translated by p.</source>
          <target state="translated">추가는 p로 변환 된 사각형 r을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="585629a6740dccaf70f625ce04affb8226c66b7f" translate="yes" xml:space="preserve">
          <source>Add returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">더하기는 캐리의 x, y 및 캐리 합계를 반환합니다 : sum = x + y + carry. 캐리 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. carryOut 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="0afa824f30d215458f4a419b67e46124f7493469" translate="yes" xml:space="preserve">
          <source>Add returns the time t+d.</source>
          <target state="translated">추가 시간 t + d를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c95f0248051392a11a12a05cf81cce547a8b8244" translate="yes" xml:space="preserve">
          <source>Add returns the vector p+q.</source>
          <target state="translated">추가는 벡터 p + q를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba245a71af4ccdd1f591263ac6536305db2bed13" translate="yes" xml:space="preserve">
          <source>Add sets z to the rounded sum x+y and returns z. If z's precision is 0, it is changed to the larger of x's or y's precision before the operation. Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. Add panics with ErrNaN if x and y are infinities with opposite signs. The value of z is undefined in that case.</source>
          <target state="translated">z를 반올림 합계 x + y로 설정하고 z를 반환합니다. z의 정밀도가 0이면 연산 전에 x 또는 y의 정밀도보다 크게 변경됩니다. 반올림은 z의 정밀도 및 반올림 모드에 따라 수행됩니다. z의 정확도는 정확한 (반올림되지 않은) 결과에 대한 결과 오류를보고합니다. x와 y가 반대 부호를 가진 무한대이면 ErrNaN으로 패닉을 추가하십시오. 이 경우 z 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00590074ebcc2f548e280599ea5c32c80f81328b" translate="yes" xml:space="preserve">
          <source>Add sets z to the sum x+y and returns z.</source>
          <target state="translated">더하기 z를 합계 x + y로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="19b629dca8e7cec87881e6e14e8d485f3a76d996" translate="yes" xml:space="preserve">
          <source>Add32 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Add32는 x, y 및 carry 캐리의 합계를 반환합니다 : sum = x + y + carry. 캐리 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. carryOut 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4e45028b02f584b4a95d4b8950f85261cbe854" translate="yes" xml:space="preserve">
          <source>Add64 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.</source>
          <target state="translated">Add64는 x, y 및 carry 캐리의 합계를 반환합니다 : sum = x + y + carry. 캐리 입력은 0 또는 1이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다. carryOut 출력은 0 또는 1로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="6c9c92bcc797de932d07b084cf008348cb858dd9" translate="yes" xml:space="preserve">
          <source>AddCert adds a certificate to a pool.</source>
          <target state="translated">AddCert는 풀에 인증서를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0a9b8624a8f1758a2161fd22c09c59c0e306d4b0" translate="yes" xml:space="preserve">
          <source>AddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. That means all cookies, if any, are written into the same line, separated by semicolon.</source>
          <target state="translated">AddCookie는 요청에 쿠키를 추가합니다. RFC 6265 섹션 5.4에 따라 AddCookie는 둘 이상의 쿠키 헤더 필드를 첨부하지 않습니다. 즉, 모든 쿠키 (있는 경우)는 세미콜론으로 구분되어 같은 줄에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e189525dfaea0418dd309a6cb7ebfcae4199a62e" translate="yes" xml:space="preserve">
          <source>AddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31.</source>
          <target state="translated">AddDate는 Date와 동일한 방식으로 결과를 정규화하므로, 예를 들어 10 월 31 일에 한 달을 추가하면 11 월 31 일의 정규화 된 양식 인 12 월 1 일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ea940d1bbc1f192f224ace60353e0b1750927e23" translate="yes" xml:space="preserve">
          <source>AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010.</source>
          <target state="translated">AddDate는 주어진 연도, 월 및 일 수를 t에 더한 시간을 반환합니다. 예를 들어 2011 년 1 월 1 일에 적용된 AddDate (-1, 2, 3)는 2010 년 3 월 4 일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="de1dbc1a1a38094582ff758395d64a9379927734" translate="yes" xml:space="preserve">
          <source>AddExtensionType sets the MIME type associated with the extension ext to typ. The extension should begin with a leading dot, as in &quot;.html&quot;.</source>
          <target state="translated">AddExtensionType은 확장자 ext와 연관된 MIME 유형을 typ로 설정합니다. 확장자는 &quot;.html&quot;에서와 같이 맨 앞의 점으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="f552f87900c0ec0fe5963b96881b2772f3c33e1f" translate="yes" xml:space="preserve">
          <source>AddFile adds a new file with a given filename, base offset, and file size to the file set s and returns the file. Multiple files may have the same name. The base offset must not be smaller than the FileSet's Base(), and size must not be negative. As a special case, if a negative base is provided, the current value of the FileSet's Base() is used instead.</source>
          <target state="translated">AddFile은 주어진 파일 이름, 기본 오프셋 및 파일 크기를 가진 새 파일을 파일 세트에 추가하고 파일을 반환합니다. 여러 파일의 이름이 동일 할 수 있습니다. 기본 오프셋은 FileSet의 Base ()보다 작아서는 안되며 크기는 음수가 아니어야합니다. 특별한 경우로, 음의 밑이 제공되면 FileSet의 Base ()의 현재 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fedd35de06c52dffbb471fbdba27aee8feba58b" translate="yes" xml:space="preserve">
          <source>AddFloat adds delta to the *Float value stored under the given map key.</source>
          <target state="translated">AddFloat는 주어진 맵 키 아래에 저장된 * Float 값에 델타를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5858ca5305a5b0fe80c5593ab2bd856981293e79" translate="yes" xml:space="preserve">
          <source>AddInt32 atomically adds delta to *addr and returns the new value.</source>
          <target state="translated">AddInt32는 * addr에 델타를 원자 적으로 추가하고 새 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9c4f53ee7feeae5d257b849acc7471b425441121" translate="yes" xml:space="preserve">
          <source>AddInt64 atomically adds delta to *addr and returns the new value.</source>
          <target state="translated">AddInt64는 * addr에 델타를 원자 적으로 추가하고 새 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="36840a2c5d6044dbaa823fcba841f49af7e9d928" translate="yes" xml:space="preserve">
          <source>AddLine adds the line offset for a new line. The line offset must be larger than the offset for the previous line and smaller than the file size; otherwise the line offset is ignored.</source>
          <target state="translated">AddLine은 새로운 라인에 대한 라인 오프셋을 추가합니다. 행 오프셋은 이전 행의 오프셋보다 크고 파일 크기보다 작아야합니다. 그렇지 않으면 라인 오프셋이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c0567d75e1a38f2b988111fee478d46f4c2f3ebb" translate="yes" xml:space="preserve">
          <source>AddLineColumnInfo adds alternative file, line, and column number information for a given file offset. The offset must be larger than the offset for the previously added alternative line info and smaller than the file size; otherwise the information is ignored.</source>
          <target state="translated">AddLineColumnInfo는 주어진 파일 오프셋에 대한 대체 파일, 행 및 열 번호 정보를 추가합니다. 오프셋은 이전에 추가 된 대체 행 정보의 오프셋보다 크고 파일 크기보다 작아야합니다. 그렇지 않으면 정보가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ac4fdb78ce37a0820e1c7d77936fa4f818920bc5" translate="yes" xml:space="preserve">
          <source>AddLineColumnInfo is typically used to register alternative position information for line directives such as //line filename:line:column.</source>
          <target state="translated">AddLineColumnInfo는 일반적으로 // line filename : line : column과 같은 줄 지시문에 대한 대체 위치 정보를 등록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ffb7d16d246eb3ce399562af53b609c59c5c46e3" translate="yes" xml:space="preserve">
          <source>AddLineInfo is like AddLineColumnInfo with a column = 1 argument. It is here for backward-compatibility for code prior to Go 1.11.</source>
          <target state="translated">AddLineInfo는 열 = 1 인수를 갖는 AddLineColumnInfo와 같습니다. Go 1.11 이전의 코드에 대한 하위 호환성을 위해 여기 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab9c2ef1f35d0ef6c0161dd82448b4d74b1c9558" translate="yes" xml:space="preserve">
          <source>AddMethod adds method m unless it is already in the method list.</source>
          <target state="translated">AddMethod는 메소드 m이 메소드 목록에없는 경우 메소드 m을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="44f221eb4e24f17d42e5bea8d5c27e1378d7d1cc" translate="yes" xml:space="preserve">
          <source>AddParseTree adds parse tree for template with given name and associates it with t. If the template does not already exist, it will create a new one. If the template does exist, it will be replaced.</source>
          <target state="translated">AddParseTree는 주어진 이름의 템플릿에 대한 구문 분석 트리를 추가하고 t와 연관시킵니다. 템플릿이 없으면 새 템플릿이 만들어집니다. 템플릿이 존재하면 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="b2afd490c78d79c03722b8ea7f5bce321e908078" translate="yes" xml:space="preserve">
          <source>AddParseTree creates a new template with the name and parse tree and associates it with t.</source>
          <target state="translated">AddParseTree는 이름 및 구문 분석 트리를 사용하여 새 템플리트를 작성하고이를 t와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="7233a75408cb93190ed8d7f01c6ae4749187bad2" translate="yes" xml:space="preserve">
          <source>AddTypes will add one .debug_types section to the DWARF data. A typical object with DWARF version 4 debug info will have multiple .debug_types sections. The name is used for error reporting only, and serves to distinguish one .debug_types section from another.</source>
          <target state="translated">AddTypes는 하나의 .debug_types 섹션을 DWARF 데이터에 추가합니다. DWARF 버전 4 디버그 정보가있는 일반적인 객체에는 여러 .debug_types 섹션이 있습니다. 이 이름은 오류보고에만 사용되며 .debug_types 섹션을 다른 섹션과 구분하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7731b23781c2390384d6e6975bfd5e70c3626d3b" translate="yes" xml:space="preserve">
          <source>AddUint32 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(&amp;amp;x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(&amp;amp;x, ^uint32(0)).</source>
          <target state="translated">AddUint32는 * addr에 델타를 원자 적으로 추가하고 새 값을 리턴합니다. x에서 부호있는 양의 상수 c를 빼려면 AddUint32 (&amp;amp; x, ^ uint32 (c-1))를 수행하십시오. 특히 x를 줄이려면 AddUint32 (&amp;amp; x, ^ uint32 (0))를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d25bd4fd8252711152a39b3307b6d0eea26273a5" translate="yes" xml:space="preserve">
          <source>AddUint64 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(&amp;amp;x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(&amp;amp;x, ^uint64(0)).</source>
          <target state="translated">AddUint64는 * addr에 델타를 원자 적으로 추가하고 새 값을 리턴합니다. x에서 부호있는 양의 상수 c를 빼려면 AddUint64 (&amp;amp; x, ^ uint64 (c-1))를 수행하십시오. 특히 x를 줄이려면 AddUint64 (&amp;amp; x, ^ uint64 (0))를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="190af1abbf968aed5f57b4bc0b0e928d872bce0e" translate="yes" xml:space="preserve">
          <source>AddUintptr atomically adds delta to *addr and returns the new value.</source>
          <target state="translated">AddUintptr은 * addr에 델타를 원자 적으로 추가하고 새 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c0e76ffa9ef9504f9f128ec85ee5c8a4cf06c03b" translate="yes" xml:space="preserve">
          <source>Adding the file will set the file set's Base() value to base + size + 1 as the minimum base value for the next file. The following relationship exists between a Pos value p for a given file offset offs:</source>
          <target state="translated">파일을 추가하면 파일 세트의 Base () 값이 다음 파일의 최소 기본 값으로 base + size + 1로 설정됩니다. 주어진 파일 오프셋에 대한 Pos 값 p 사이에는 다음과 같은 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="df900036bb7195309dce533c4d0b19c0a6bb6aa8" translate="yes" xml:space="preserve">
          <source>Additional extensions may be handled by clients.</source>
          <target state="translated">클라이언트가 추가 확장을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="286cb9fdf0d392fc50790805d404a305f0ef765d" translate="yes" xml:space="preserve">
          <source>Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">또한 서버에 대한 인증서 및 일치하는 개인 키를 포함하는 파일이 제공되어야합니다. 인증 기관이 인증서에 서명 한 경우 certFile은 서버 인증서, 중간체 및 CA 인증서를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="239d133a84587b1f7b4e745e2f11b398b53b3f15" translate="yes" xml:space="preserve">
          <source>Addr represents a network end point address.</source>
          <target state="translated">주소는 네트워크 끝점 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="607466f9e7067a542b3e6feb6ba15f2a6069324c" translate="yes" xml:space="preserve">
          <source>Addr returns a pointer value representing the address of v. It panics if CanAddr() returns false. Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver.</source>
          <target state="translated">Addr은 v의 주소를 나타내는 포인터 값을 반환합니다. CanAddr ()이 false를 반환하면 패닉이 발생합니다. Addr은 일반적으로 포인터 수신자가 필요한 메소드를 호출하기 위해 구조체 필드 또는 슬라이스 요소에 대한 포인터를 얻는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8172f3ce94b65e80356707d217486354f76500a8" translate="yes" xml:space="preserve">
          <source>Addr returns the listener's network address, a *TCPAddr. The Addr returned is shared by all invocations of Addr, so do not modify it.</source>
          <target state="translated">Addr은 리스너의 네트워크 주소 * TCPAddr을 리턴합니다. 리턴 된 Addr은 Addr의 모든 호출에서 공유되므로 수정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d5668cd5de55531b485b11a427f6aafc99df086b" translate="yes" xml:space="preserve">
          <source>Addr returns the listener's network address. The Addr returned is shared by all invocations of Addr, so do not modify it.</source>
          <target state="translated">Addr은 리스너의 네트워크 주소를 반환합니다. 리턴 된 Addr은 Addr의 모든 호출에서 공유되므로 수정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bd1232cd9a9fc08fd91a563f464ef4974a2c19c0" translate="yes" xml:space="preserve">
          <source>Address represents a single mail address. An address such as &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot; is represented as Address{Name: &quot;Barry Gibbs&quot;, Address: &quot;bg@example.com&quot;}.</source>
          <target state="translated">주소는 단일 메일 주소를 나타냅니다. &quot;Barry Gibbs &amp;lt;bg@example.com&amp;gt;&quot;과 같은 주소는 Address {Name : &quot;Barry Gibbs&quot;, Address : &quot;bg@example.com&quot;}으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="31092091ef6169e771115e3f9fb45fb917a09f6a" translate="yes" xml:space="preserve">
          <source>AddressList parses the named header field as a list of addresses.</source>
          <target state="translated">AddressList는 명명 된 헤더 필드를 주소 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="1428b03f1babcfa0815c042e31c28898d265ee15" translate="yes" xml:space="preserve">
          <source>AddressSize returns the size in bytes of addresses in the current compilation unit.</source>
          <target state="translated">AddressSize는 현재 컴파일 단위의 주소 크기를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f60869ac80093a039f471c4424eaf534fefaa9db" translate="yes" xml:space="preserve">
          <source>Addressable reports whether the corresponding expression is addressable (&lt;a href=&quot;https://golang.org/ref/spec#Address_operators&quot;&gt;https://golang.org/ref/spec#Address_operators&lt;/a&gt;).</source>
          <target state="translated">주소 지정 가능은 해당 표현식의 주소 지정 가능 여부를보고합니다 ( &lt;a href=&quot;https://golang.org/ref/spec#Address_operators&quot;&gt;https://golang.org/ref/spec#Address_operators&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2390852967aa96229ea563fa30b9c73a89cdae59" translate="yes" xml:space="preserve">
          <source>Addrs returns a list of unicast interface addresses for a specific interface.</source>
          <target state="translated">Addrs는 특정 인터페이스에 대한 유니 캐스트 인터페이스 주소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="51266c52e2ef76298b0634e50f0e5ca518d1596f" translate="yes" xml:space="preserve">
          <source>After a call to Close, all operations on the connection fail with ErrConnDone.</source>
          <target state="translated">Close 호출 후 ErrConnDone으로 연결의 모든 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4e242d525b986cfee6163e2d5e94dae6540d54c0" translate="yes" xml:space="preserve">
          <source>After a call to Commit or Rollback, all operations on the transaction fail with ErrTxDone.</source>
          <target state="translated">커밋 또는 롤백을 호출 한 후 트랜잭션의 모든 작업이 ErrTxDone으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9b7cc0b202b5a6cf175ea12cda51cc3b5c865a50" translate="yes" xml:space="preserve">
          <source>After all flags are defined, call</source>
          <target state="translated">모든 플래그가 정의 된 후</target>
        </trans-unit>
        <trans-unit id="b11552cc3a06865b41f4c91326ff7e31f9e7baf0" translate="yes" xml:space="preserve">
          <source>After calling NextResultSet, the Next method should always be called before scanning. If there are further result sets they may not have rows in the result set.</source>
          <target state="translated">NextResultSet를 호출 한 후에는 스캔하기 전에 항상 Next 메서드를 호출해야합니다. 추가 결과 집합이 있으면 결과 집합에 행이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc109254d6837e645dfea4e00b401bd7b8f10009" translate="yes" xml:space="preserve">
          <source>After changing its configuration, the caller should call Start or StartTLS.</source>
          <target state="translated">구성을 변경 한 후 호출자는 Start 또는 StartTLS를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="902382debcdaed0b05dacf789c63d2774e1d7805" translate="yes" xml:space="preserve">
          <source>After parsing, the arguments following the flags are available as the slice flag.Args() or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg()-1.</source>
          <target state="translated">구문 분석 후 플래그 뒤에 오는 인수는 슬라이스 flag.Args () 또는 개별적으로 flag.Arg (i)로 사용할 수 있습니다. 인수는 0에서 flag.NArg ()-1까지 색인됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1b011e660c77ea973c7163c2f73dcca65df333" translate="yes" xml:space="preserve">
          <source>After reports whether the time instant t is after u.</source>
          <target state="translated">After 시간 순간 t가 u 이후인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="8e172e56ebdd816679ce623111d437357fa222a7" translate="yes" xml:space="preserve">
          <source>After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.</source>
          <target state="translated">이후 지속 시간이 경과 한 후 리턴 된 채널에서 현재 시간을 보냅니다. NewTimer (d) .C와 같습니다. 기본 타이머는 타이머가 실행될 때까지 가비지 수집기에 의해 복구되지 않습니다. 효율성이 문제가되는 경우 대신 NewTimer를 사용하고 Timer를 호출하십시오. 타이머가 더 이상 필요하지 않으면 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="e4c3a4e3ecbfcb3d8ebe9bb146b442a17039a6e4" translate="yes" xml:space="preserve">
          <source>AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method.</source>
          <target state="translated">AfterFunc는 시간이 경과 할 때까지 기다린 다음 자체 고 루틴에서 f를 호출합니다. Stop 메서드를 사용하여 호출을 취소하는 데 사용할 수있는 타이머를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52203fa166bcb814e34b7bfd717ce5e34da01f93" translate="yes" xml:space="preserve">
          <source>Alert logs a message with severity LOG_ALERT, ignoring the severity passed to New.</source>
          <target state="translated">Alert는 심각도가 LOG_ALERT 인 메시지를 기록하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="cf50c6d0c4f08187d0f0ca8d3062d2660efd4a9b" translate="yes" xml:space="preserve">
          <source>AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC 5280, section 4.1.1.2.</source>
          <target state="translated">AlgorithmIdentifier는 동일한 이름의 ASN.1 구조를 나타냅니다. RFC 5280 섹션 4.1.1.2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a2ca48b60bd6b1a14d6a2ac1a6041efe4ba7a9d" translate="yes" xml:space="preserve">
          <source>Alignof takes an expression x of any type and returns the required alignment of a hypothetical variable v as if v was declared via var v = x. It is the largest value m such that the address of v is always zero mod m. It is the same as the value returned by reflect.TypeOf(x).Align(). As a special case, if a variable s is of struct type and f is a field within that struct, then Alignof(s.f) will return the required alignment of a field of that type within a struct. This case is the same as the value returned by reflect.TypeOf(s.f).FieldAlign(). The return value of Alignof is a Go constant.</source>
          <target state="translated">Alignof는 모든 유형의 표현식 x를 취하고 마치 v가 var v = x를 통해 선언 된 것처럼 가상 변수 v의 필요한 정렬을 반환합니다. v의 주소가 항상 0 mod m이되도록하는 가장 큰 값 m입니다. reflect.TypeOf (x) .Align ()에 의해 리턴 된 값과 동일합니다. 특별한 경우에 변수 s가 구조체 유형이고 f가 해당 구조체 내의 필드 인 경우 Alignof (sf)는 구조체 내에서 해당 유형의 필드에 필요한 정렬을 반환합니다. 이 경우는 reflect.TypeOf (sf) .FieldAlign ()에서 반환 된 값과 같습니다. Alignof의 반환 값은 Go 상수입니다.</target>
        </trans-unit>
        <trans-unit id="b2b76a535f3a824bc0e7af6e39f77b353583e557" translate="yes" xml:space="preserve">
          <source>All arguments to be scanned must be either pointers to basic types or implementations of the Scanner interface.</source>
          <target state="translated">스캔 할 모든 인수는 기본 유형에 대한 포인터이거나 스캐너 인터페이스의 구현이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3efe4c6fa30457a9aff5de61e746ace1b26467a8" translate="yes" xml:space="preserve">
          <source>All characters are UTF-8-encoded code points.</source>
          <target state="translated">모든 문자는 UTF-8로 인코딩 된 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="2314ab5383e8c5b7223fc5076bd94c65406b693b" translate="yes" xml:space="preserve">
          <source>All declaration nodes implement the Decl interface.</source>
          <target state="translated">모든 선언 노드는 Decl 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f71fdc2653fada1accdfeb2fa2bec4f375c3fa23" translate="yes" xml:space="preserve">
          <source>All errors begin with the string &quot;%!&quot; followed sometimes by a single character (the verb) and end with a parenthesized description.</source>
          <target state="translated">모든 오류는 문자열 &quot;%!&quot;로 시작합니다. 때로는 단일 문자 (동사)가 뒤 따르고 괄호로 묶인 설명으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="dea399ca9139a5569fa2c17121e21527d0f13e27" translate="yes" xml:space="preserve">
          <source>All expression nodes implement the Expr interface.</source>
          <target state="translated">모든 표현식 노드는 Expr 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="439bb2dad8a28e5fb2b434cb4e6612e2a16c7b96" translate="yes" xml:space="preserve">
          <source>All init functions are run on the startup thread. Calling LockOSThread from an init function will cause the main function to be invoked on that thread.</source>
          <target state="translated">모든 초기화 기능은 시작 스레드에서 실행됩니다. init 함수에서 LockOSThread를 호출하면 해당 스레드에서 기본 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="97c6b4dd788d20932f24c2193fdad47d4daae398" translate="yes" xml:space="preserve">
          <source>All node types implement the Node interface.</source>
          <target state="translated">모든 노드 유형은 노드 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6f0c09894c725d3c9e77a6a63f1453b76eef2346" translate="yes" xml:space="preserve">
          <source>All other slices and arrays are sent as an unsigned count followed by that many elements using the standard gob encoding for their type, recursively.</source>
          <target state="translated">다른 모든 슬라이스 및 배열은 부호없는 카운트로 전송 된 다음 해당 유형에 표준 gob 인코딩을 사용하는 많은 요소가 재귀 적으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e9146cc320b30397d729a875d3b4f8e2bc63e8c3" translate="yes" xml:space="preserve">
          <source>All statement nodes implement the Stmt interface.</source>
          <target state="translated">모든 명령문 노드는 Stmt 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="65ae9abe1fa8712f97e1beed2b48172fff49a778" translate="yes" xml:space="preserve">
          <source>All the hash.Hash implementations returned by this package also implement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">이 패키지에 의해 돌려 주어진 모든 해시. 해시 구현도 해시의 내부 상태를 마샬링 및 비 정렬 화하기위한 encoding.BinaryMarshaler 및 encoding.BinaryUnmarshaler를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ee4b09053ce6dc1a057246d17d4fec0360be7d1c" translate="yes" xml:space="preserve">
          <source>AllocedBytesPerOp returns the &quot;B/op&quot; metric, which is calculated as r.MemBytes / r.N.</source>
          <target state="translated">AllocedBytesPerOp는 &quot;B / op&quot;메트릭을 반환하며 r.MemBytes / rN으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="12b2fa12ce7cf5b9e4f9ed48969a1983e0d1d5d2" translate="yes" xml:space="preserve">
          <source>AllocsPerOp returns the &quot;allocs/op&quot; metric, which is calculated as r.MemAllocs / r.N.</source>
          <target state="translated">AllocsPerOp는 &quot;allocs / op&quot;메트릭을 반환하며 r.MemAllocs / rN으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="badcac1ab432ee1a8a56581e11ba0e5ab9790707" translate="yes" xml:space="preserve">
          <source>AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value.</source>
          <target state="translated">AllocsPerRun은 f를 호출하는 동안 평균 할당 수를 반환합니다. 반환 값의 유형은 float64이지만 항상 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="69f8869e42decf1676089266f7f518cee77fd0af" translate="yes" xml:space="preserve">
          <source>AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore it before returning.</source>
          <target state="translated">AllocsPerRun은 측정 중에 GOMAXPROCS를 1로 설정하고 리턴하기 전에이를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="2b842b60e3487e1d9cdc7af135ff6ba6435574c8" translate="yes" xml:space="preserve">
          <source>Alpha is an in-memory image whose At method returns color.Alpha values.</source>
          <target state="translated">알파는 At 메서드가 color.Alpha 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="1d6556da37edadf737283b435a625d47b77b00a4" translate="yes" xml:space="preserve">
          <source>Alpha represents an 8-bit alpha color.</source>
          <target state="translated">알파는 8 비트 알파 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eb7ce30976aff039c4b314b9299fbf3b51bf4b5f" translate="yes" xml:space="preserve">
          <source>Alpha16 is an in-memory image whose At method returns color.Alpha16 values.</source>
          <target state="translated">Alpha16은 At 메서드가 color.Alpha16 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="17f51a9d20c648e3a8adb401d7734bd7422b79ee" translate="yes" xml:space="preserve">
          <source>Alpha16 represents a 16-bit alpha color.</source>
          <target state="translated">Alpha16은 16 비트 알파 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fb30b27f413d64a9fb0cbb842f0d9c65ea0f6942" translate="yes" xml:space="preserve">
          <source>Alternatively, new values can be allocated and initialized with factory functions of the form:</source>
          <target state="translated">또는 다음과 같은 형식의 팩토리 기능을 사용하여 새 값을 할당하고 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e05fd011282817682b1c22d0d70a09154585c4c3" translate="yes" xml:space="preserve">
          <source>Although the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions.</source>
          <target state="translated">패키지는 저수준 네트워킹 프리미티브에 대한 액세스를 제공하지만 대부분의 클라이언트는 다이얼, 청취 및 수락 기능과 관련 Conn 및 리스너 인터페이스가 제공하는 기본 인터페이스 만 필요합니다. crypto / tls 패키지는 동일한 인터페이스와 유사한 다이얼 및 청취 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4aa6f271ecce01c74386f5cab4917b581ae9b6f4" translate="yes" xml:space="preserve">
          <source>An ASN.1 BIT STRING can be written to a BitString.</source>
          <target state="translated">ASN.1 BIT STRING은 BitString에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b05462a8e3ed73d565469132de236aba1a72def" translate="yes" xml:space="preserve">
          <source>An ASN.1 ENUMERATED can be written to an Enumerated.</source>
          <target state="translated">ASN.1 ENUMERATED는 Enumerated에 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="260b18862b10ae0e74a033b94545c3cf7cd4c55e" translate="yes" xml:space="preserve">
          <source>An ASN.1 INTEGER can be written to an int, int32, int64, or *big.Int (from the math/big package). If the encoded value does not fit in the Go type, Unmarshal returns a parse error.</source>
          <target state="translated">ASN.1 INTEGER는 int, int32, int64 또는 * big.Int (math / big 패키지에서)에 쓸 수 있습니다. 인코딩 된 값이 Go 유형에 맞지 않으면 Unmarshal은 구문 분석 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="869b61cb05b1b3e5bee725f577f97c0c1cafb3d4" translate="yes" xml:space="preserve">
          <source>An ASN.1 OBJECT IDENTIFIER can be written to an ObjectIdentifier.</source>
          <target state="translated">ASN.1 객체 식별자는 ObjectIdentifier에 기록 될 수있다.</target>
        </trans-unit>
        <trans-unit id="8230571aad1a64236469fadfb2ef0cabb863fbcb" translate="yes" xml:space="preserve">
          <source>An ASN.1 OCTET STRING can be written to a []byte.</source>
          <target state="translated">ASN.1 OCTET STRING은 [] 바이트에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf2bca6ff0b4d0bb1c60638a2ca6cf2e275df6be" translate="yes" xml:space="preserve">
          <source>An ASN.1 PrintableString, IA5String, or NumericString can be written to a string.</source>
          <target state="translated">ASN.1 PrintableString, IA5String 또는 NumericString을 문자열에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e49fd50438627ac23f6a9e8691fbef9762a320b" translate="yes" xml:space="preserve">
          <source>An ASN.1 SEQUENCE OF x or SET OF x can be written to a slice if an x can be written to the slice's element type.</source>
          <target state="translated">x를 슬라이스의 요소 유형에 쓸 수 있으면 ASN.1 SEQUENCE OF x 또는 SET OF x를 슬라이스에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa0a794464c52980812f881a6f05ec60e65cbab" translate="yes" xml:space="preserve">
          <source>An ASN.1 SEQUENCE or SET can be written to a struct if each of the elements in the sequence can be written to the corresponding element in the struct.</source>
          <target state="translated">시퀀스의 각 요소를 구조체의 해당 요소에 쓸 수 있으면 ASN.1 SEQUENCE 또는 SET을 구조체에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad20aa7b03987bad2cf797451b15b47646f20ae5" translate="yes" xml:space="preserve">
          <source>An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.</source>
          <target state="translated">ASN.1 UTCTIME 또는 GENERALIZEDTIME은 time.Time에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36aadf8f5498a5d6a7f99a8402775cb348c8f6b5" translate="yes" xml:space="preserve">
          <source>An AddrType represents a machine address type.</source>
          <target state="translated">AddrType은 컴퓨터 주소 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8d75f2635e147e42345dfd716713a80c0faf359b" translate="yes" xml:space="preserve">
          <source>An AddressParser is an RFC 5322 address parser.</source>
          <target state="translated">AddressParser는 RFC 5322 주소 파서입니다.</target>
        </trans-unit>
        <trans-unit id="751b64ea00145591b831c86aeec73c9cd6e3f193" translate="yes" xml:space="preserve">
          <source>An Array represents an array type.</source>
          <target state="translated">배열은 배열 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e83f825cc4b7a3b11c3d536847a9172d88cd97a4" translate="yes" xml:space="preserve">
          <source>An ArrayType node represents an array or slice type.</source>
          <target state="translated">ArrayType 노드는 배열 또는 슬라이스 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8ac61edaef43e2f85c83e7b3205dbe82f5419012" translate="yes" xml:space="preserve">
          <source>An ArrayType represents a fixed size array type.</source>
          <target state="translated">ArrayType은 고정 크기 배열 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="857c276d40ff85b22398af4e95f15e17dfc3761e" translate="yes" xml:space="preserve">
          <source>An AssignStmt node represents an assignment or a short variable declaration.</source>
          <target state="translated">AssignStmt 노드는 할당 또는 짧은 변수 선언을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8de9651bc85b5cadec1c2186fcfc45df4325dc7" translate="yes" xml:space="preserve">
          <source>An Attr identifies the attribute type in a DWARF Entry's Field.</source>
          <target state="translated">속성은 DWARF 항목의 필드에서 속성 유형을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="a039b716fe768e4a98f3c47ea1a43617424d2cb0" translate="yes" xml:space="preserve">
          <source>An Attr represents an attribute in an XML element (Name=Value).</source>
          <target state="translated">Attr은 XML 요소의 특성을 나타냅니다 (Name = Value).</target>
        </trans-unit>
        <trans-unit id="1b862e215532b08f8993adb353e29f24b113d0d2" translate="yes" xml:space="preserve">
          <source>An Ellipsis node stands for the &quot;...&quot; type in a parameter list or the &quot;...&quot; length in an array type.</source>
          <target state="translated">줄임표 노드는 매개 변수 목록의 &quot;...&quot;유형 또는 배열 유형의 &quot;...&quot;길이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="206e1d6d2930e4b55272a8c2ace302d5bebb4d6b" translate="yes" xml:space="preserve">
          <source>An EmptyOp specifies a kind or mixture of zero-width assertions.</source>
          <target state="translated">EmptyOp는 폭이 0 인 어설 션의 종류 또는 혼합을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="79b1e78fcc680965fe6e575d14194a8c78459d1e" translate="yes" xml:space="preserve">
          <source>An EmptyStmt node represents an empty statement. The &quot;position&quot; of the empty statement is the position of the immediately following (explicit or implicit) semicolon.</source>
          <target state="translated">EmptyStmt 노드는 빈 명령문을 나타냅니다. 빈 명령문의 &quot;위치&quot;는 바로 다음 (명시 적 또는 암시 적) 세미콜론의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="cc21548a00526537378e03c232e946ddafc77006" translate="yes" xml:space="preserve">
          <source>An Encoder manages the transmission of type and data information to the other side of a connection. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">인코더는 유형 및 데이터 정보를 연결의 다른쪽으로 전송하는 것을 관리합니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="7ec5724a97180ce1fa9f610646dede20f58de73b" translate="yes" xml:space="preserve">
          <source>An Encoder writes JSON values to an output stream.</source>
          <target state="translated">인코더는 JSON 값을 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="44a80ad51642ec26186393b48e82a0a974e794a4" translate="yes" xml:space="preserve">
          <source>An Encoder writes XML data to an output stream.</source>
          <target state="translated">인코더는 XML 데이터를 출력 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="cd93c235f0bd9a74ea8b32e43f217fd3a3bd805a" translate="yes" xml:space="preserve">
          <source>An Encoding is a radix 32 encoding/decoding scheme, defined by a 32-character alphabet. The most common is the &quot;base32&quot; encoding introduced for SASL GSSAPI and standardized in RFC 4648. The alternate &quot;base32hex&quot; encoding is used in DNSSEC.</source>
          <target state="translated">인코딩은 32 문자 알파벳으로 정의 된 기수 32 인코딩 / 디코딩 체계입니다. 가장 일반적인 것은 SASL GSSAPI에 도입되어 RFC 4648에서 표준화 된 &quot;base32&quot;인코딩입니다. 대체 &quot;base32hex&quot;인코딩은 DNSSEC에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c6f72e4757281a321975587e037d0edc0910a0b" translate="yes" xml:space="preserve">
          <source>An Encoding is a radix 64 encoding/decoding scheme, defined by a 64-character alphabet. The most common encoding is the &quot;base64&quot; encoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM (RFC 1421). RFC 4648 also defines an alternate encoding, which is the standard encoding with - and _ substituted for + and /.</source>
          <target state="translated">인코딩은 64 문자 알파벳으로 정의 된 기수 64 인코딩 / 디코딩 체계입니다. 가장 일반적인 인코딩은 RFC 4648에 정의되고 MIME (RFC 2045) 및 PEM (RFC 1421)에 사용되는 &quot;base64&quot;인코딩입니다. RFC 4648은 대체 인코딩을 정의하는데, 이는 + 및 / 대신-및 _로 대체 된 표준 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="f9fc159c5bbba125ca80971575038639e4c30e15" translate="yes" xml:space="preserve">
          <source>An EndElement represents an XML end element.</source>
          <target state="translated">EndElement는 XML 끝 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c2933f1f28cbba0bc7344ba80287c65dff0bc30f" translate="yes" xml:space="preserve">
          <source>An EnumType represents an enumerated type. The only indication of its native integer type is its ByteSize (inside CommonType).</source>
          <target state="translated">EnumType은 열거 형을 나타냅니다. 고유 정수 유형의 유일한 표시는 ByteSize (CommonType 내부)입니다.</target>
        </trans-unit>
        <trans-unit id="b79e9324c93170d0ebbe1508dc6c4fcc8e187b01" translate="yes" xml:space="preserve">
          <source>An EnumValue represents a single enumeration value.</source>
          <target state="translated">EnumValue는 단일 열거 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ec3768c8ebcfbb9ce9b3c7a117577939cc3fb5a" translate="yes" xml:space="preserve">
          <source>An Enumerated is represented as a plain int.</source>
          <target state="translated">Enumerated는 일반 int로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f06294438639908dac8d5e188fdee9a4acee8b91" translate="yes" xml:space="preserve">
          <source>An ErrNaN panic is raised by a Float operation that would lead to a NaN under IEEE-754 rules. An ErrNaN implements the error interface.</source>
          <target state="translated">IEEE-754 규칙에 따라 NaN으로 연결되는 Float 작업으로 ErrNaN 패닉이 발생합니다. ErrNaN은 오류 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f54d7aa37ca74152ff50d53a4a9eb371bd8fc6f6" translate="yes" xml:space="preserve">
          <source>An Errno is an unsigned number describing an error condition. It implements the error interface. The zero Errno is by convention a non-error, so code to convert from Errno to error should use:</source>
          <target state="translated">Errno는 오류 조건을 설명하는 부호없는 숫자입니다. 오류 인터페이스를 구현합니다. 제로 Errno는 일반적으로 오류가 아니므로 Errno에서 오류로 변환하는 코드는 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="512d38ad90ecdbb223905a3c98396bc761092f77" translate="yes" xml:space="preserve">
          <source>An Error describes a failure to parse a regular expression and gives the offending expression.</source>
          <target state="translated">오류는 정규 표현식을 구문 분석하지 못한 것으로 설명하고 문제가되는 표현식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1c853d687301eacbdc70fc7b2069d367a181575f" translate="yes" xml:space="preserve">
          <source>An Error describes a type-checking error; it implements the error interface. A &quot;soft&quot; error is an error that still permits a valid interpretation of a package (such as &quot;unused variable&quot;); &quot;hard&quot; errors may lead to unpredictable behavior if ignored.</source>
          <target state="translated">오류는 유형 검사 오류를 나타냅니다. 오류 인터페이스를 구현합니다. &quot;소프트&quot;오류는 여전히 패키지의 유효한 해석 (예 : &quot;사용하지 않은 변수&quot;)을 허용하는 오류입니다. 무시하면 &quot;하드&quot;오류로 인해 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d28234f48490b0ef3b8db38b651b8397ba38df3" translate="yes" xml:space="preserve">
          <source>An Error represents a network error.</source>
          <target state="translated">오류는 네트워크 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f652324f5503064eba1ee715c7833fbf6d566dc0" translate="yes" xml:space="preserve">
          <source>An Error represents a numeric error response from a server.</source>
          <target state="translated">오류는 서버의 숫자 오류 응답을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3769e7ac9e5605d81e8490caf08cd40057870dac" translate="yes" xml:space="preserve">
          <source>An ErrorCode describes a failure to parse a regular expression.</source>
          <target state="translated">ErrorCode는 정규 표현식을 구문 분석하지 못하는 것을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="54a91464923f2af9618f528d284b1f1da0c9208c" translate="yes" xml:space="preserve">
          <source>An ErrorHandler may be provided to Scanner.Init. If a syntax error is encountered and a handler was installed, the handler is called with a position and an error message. The position points to the beginning of the offending token.</source>
          <target state="translated">ErrorHandler는 Scanner.Init에 제공 될 수 있습니다. 구문 오류가 발생하고 핸들러가 설치된 경우 위치 및 오류 메시지와 함께 핸들러가 호출됩니다. 위치는 문제가되는 토큰의 시작을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="24a7817e69ae447e63261c2dd340c4bdb534b1ae" translate="yes" xml:space="preserve">
          <source>An ErrorList implements the error interface.</source>
          <target state="translated">ErrorList는 오류 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8386dd5696de787382b0b9b9bedbc5b15351fb0b" translate="yes" xml:space="preserve">
          <source>An Example represents an example function found in a source files.</source>
          <target state="translated">예제는 소스 파일에서 찾은 예제 함수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="215350db86b77b9a2e2e1f96152b7e43551b80ea" translate="yes" xml:space="preserve">
          <source>An ExitError reports an unsuccessful exit by a command.</source>
          <target state="translated">ExitError는 명령에 의한 실패한 종료를보고합니다.</target>
        </trans-unit>
        <trans-unit id="05bc8f57d6f82bf73794821b6ff5dd43d87bda94" translate="yes" xml:space="preserve">
          <source>An ExprStmt node represents a (stand-alone) expression in a statement list.</source>
          <target state="translated">ExprStmt 노드는 명령문 목록에서 (독립형) 표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8b1088189e4db6e193143ddf5d3de9c7c46bc88d" translate="yes" xml:space="preserve">
          <source>An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input.</source>
          <target state="translated">IP는 단일 IP 주소, 한 조각의 바이트입니다. 이 패키지의 함수는 4 바이트 (IPv4) 또는 16 바이트 (IPv6) 슬라이스를 입력으로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5ee413fb49e920eaeb667d475d84bffedb2967a4" translate="yes" xml:space="preserve">
          <source>An IP mask is an IP address.</source>
          <target state="translated">IP 마스크는 IP 주소입니다.</target>
        </trans-unit>
        <trans-unit id="f236b320eae23c3c4580d036703570dfc8db5aef" translate="yes" xml:space="preserve">
          <source>An IPNet represents an IP network.</source>
          <target state="translated">IPNet은 IP 네트워크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="07af42d11561f0b970bb0742d7b092bd5695998a" translate="yes" xml:space="preserve">
          <source>An Ident node represents an identifier.</source>
          <target state="translated">식별자 노드는 식별자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c2482695edf6a726d25800b1f5cb476bfe9e0a58" translate="yes" xml:space="preserve">
          <source>An IfStmt node represents an if statement.</source>
          <target state="translated">IfStmt 노드는 if 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7d5dd87613417535deb3ae897d0824e60e9bcea" translate="yes" xml:space="preserve">
          <source>An ImportMode controls the behavior of the Import method.</source>
          <target state="translated">ImportMode는 Import 메서드의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a4e20307642879f4fdb91b301c0d6f19a4723e93" translate="yes" xml:space="preserve">
          <source>An ImportSpec node represents a single package import.</source>
          <target state="translated">ImportSpec 노드는 단일 패키지 가져 오기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ccedf83855a15222c8ed0224e1f53221340331a4" translate="yes" xml:space="preserve">
          <source>An Importer resolves import paths to Packages.</source>
          <target state="translated">임포터는 패키지로의 임포트 경로를 분석합니다.</target>
        </trans-unit>
        <trans-unit id="b2a2d275c65b3d0e5e8ceb4d48a4fa4fe4798662" translate="yes" xml:space="preserve">
          <source>An Importer resolves import paths to package Objects. The imports map records the packages already imported, indexed by package id (canonical import path). An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. If so, the Importer can return the map entry. Otherwise, the Importer should load the package data for the given path into a new *Object (pkg), record pkg in the imports map, and then return pkg.</source>
          <target state="translated">임포터는 패키지 오브젝트의 임포트 경로를 분석합니다. 가져 오기 맵은 이미 가져온 패키지를 패키지 ID (정식 가져 오기 경로)로 색인화하여 기록합니다. 임포터는 정식 임포트 경로를 판별하고 맵이 임포트 맵에 이미 있는지 확인해야합니다. 그렇다면 가져 오기 프로그램이 맵 항목을 리턴 할 수 있습니다. 그렇지 않으면 임포터는 지정된 경로에 대한 패키지 데이터를 새 * Object (pkg)에로드하고 가져 오기 맵에 pkg를 기록한 다음 pkg를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb537684eda993b55ae12814f6e808e9b7a235b7" translate="yes" xml:space="preserve">
          <source>An ImporterFrom resolves import paths to packages; it supports vendoring per &lt;a href=&quot;https://golang.org/s/go15vendor&quot;&gt;https://golang.org/s/go15vendor&lt;/a&gt;. Use go/importer to obtain an ImporterFrom implementation.</source>
          <target state="translated">ImporterFrom은 패키지의 가져 오기 경로를 분석합니다. &lt;a href=&quot;https://golang.org/s/go15vendor&quot;&gt;https://golang.org/s/go15vendor에&lt;/a&gt; 따라 공급 업체를 지원합니다 . go / importer를 사용하여 ImporterFrom 구현을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="931853ab43b1b36b6477762f5b19f92fa830addc" translate="yes" xml:space="preserve">
          <source>An IncDecStmt node represents an increment or decrement statement.</source>
          <target state="translated">IncDecStmt 노드는 증가 또는 감소 명령문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35521006ace24c0ca8c1e6cad86fda47cb06ccbf" translate="yes" xml:space="preserve">
          <source>An IndexExpr node represents an expression followed by an index.</source>
          <target state="translated">IndexExpr 노드는 표현식과 색인이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="57b3f9d24fd3aa52a3788875d37b03e4f951d8ca" translate="yes" xml:space="preserve">
          <source>An Initializer describes a package-level variable, or a list of variables in case of a multi-valued initialization expression, and the corresponding initialization expression.</source>
          <target state="translated">이니셜 라이저는 패키지 수준 변수 또는 다중 값 초기화 식의 경우 변수 목록과 해당 초기화 식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c2a741c70d22c89f47e118e4368257a7e0a43877" translate="yes" xml:space="preserve">
          <source>An InsecureAlgorithmError</source>
          <target state="translated">안전하지 않은 알고리즘 오류</target>
        </trans-unit>
        <trans-unit id="027885a33bbe913fc2ba3f477aabca3489b887a5" translate="yes" xml:space="preserve">
          <source>An Inst is a single instruction in a regular expression program.</source>
          <target state="translated">Inst는 정규 표현식 프로그램에서 단일 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="fbb1591cae4924ecbe2d034ef239f8d53abbc342" translate="yes" xml:space="preserve">
          <source>An InstOp is an instruction opcode.</source>
          <target state="translated">InstOp는 명령어 opcode입니다.</target>
        </trans-unit>
        <trans-unit id="4c1f11a6f7984a33db3a30b990c76a548954c071" translate="yes" xml:space="preserve">
          <source>An Int represents a signed multi-precision integer. The zero value for an Int represents the value 0.</source>
          <target state="translated">Int는 부호있는 다중 정밀도 정수를 나타냅니다. Int의 0 값은 값 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e81c158b5c560f087dc1cc6acd0467ac2c1656b5" translate="yes" xml:space="preserve">
          <source>An IntType represents a signed integer type.</source>
          <target state="translated">IntType은 부호있는 정수 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1a7d36f9197d92f53c3f8f9081d074e38f25eb00" translate="yes" xml:space="preserve">
          <source>An Interface represents an interface type.</source>
          <target state="translated">인터페이스는 인터페이스 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eec19b90e5f6546bd2083657d09b42c2c1c31024" translate="yes" xml:space="preserve">
          <source>An InterfaceType node represents an interface type.</source>
          <target state="translated">InterfaceType 노드는 인터페이스 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="576712f6b5e2f51d02da2f20787f20734e4aa8fb" translate="yes" xml:space="preserve">
          <source>An InternalError reports an error in the flate code itself.</source>
          <target state="translated">InternalError는 플랫 코드 자체에 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="d632bf503e0a72f63034068d3a35848739d860dd" translate="yes" xml:space="preserve">
          <source>An InvalidUnmarshalError describes an invalid argument passed to Unmarshal. (The argument to Unmarshal must be a non-nil pointer.)</source>
          <target state="translated">InvalidUnmarshalError는 Unmarshal에 전달 된 잘못된 인수를 설명합니다. (비 정렬 화에 대한 인수는 비논리적 포인터 여야합니다.)</target>
        </trans-unit>
        <trans-unit id="355520c16460a4d672b0833e1be85108ccb16b48" translate="yes" xml:space="preserve">
          <source>An MX represents a single DNS MX record.</source>
          <target state="translated">MX는 단일 DNS MX 레코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7737461dc6a0486b2bcc5cd7ba812b4baec53c6" translate="yes" xml:space="preserve">
          <source>An NS represents a single DNS NS record.</source>
          <target state="translated">NS는 단일 DNS NS 레코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fc31b1339a10ac6c5590f7699997d397c8058593" translate="yes" xml:space="preserve">
          <source>An Nlist32 is a Mach-O 32-bit symbol table entry.</source>
          <target state="translated">Nlist32는 Mach-O 32 비트 기호 테이블 항목입니다.</target>
        </trans-unit>
        <trans-unit id="ddae24f43b24e969e52011bccfbf41b821e176a8" translate="yes" xml:space="preserve">
          <source>An Nlist64 is a Mach-O 64-bit symbol table entry.</source>
          <target state="translated">Nlist64는 Mach-O 64 비트 기호 테이블 항목입니다.</target>
        </trans-unit>
        <trans-unit id="5c07e8659a0b25b73eae3edf1d2bd807dad03f31" translate="yes" xml:space="preserve">
          <source>An Obj represents a collection of functions in a symbol table.</source>
          <target state="translated">Obj는 심볼 테이블의 함수 모음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1805e3ce80f418cf89c636249f4d5a84033d5060" translate="yes" xml:space="preserve">
          <source>An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label.</source>
          <target state="translated">객체는 패키지, 상수, 유형, 변수, 함수 (메소드 포함) 또는 레이블과 같은 명명 된 언어 엔터티를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ebcf6a2cb490f823e627d6f4f840a47671387779" translate="yes" xml:space="preserve">
          <source>An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. All objects implement the Object interface.</source>
          <target state="translated">객체는 패키지, 상수, 유형, 변수, 함수 (메소드 포함) 또는 레이블과 같은 명명 된 언어 엔터티를 설명합니다. 모든 객체는 객체 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c2a6feda5d42e0f3ed1aa8a3be809a70c3599d2b" translate="yes" xml:space="preserve">
          <source>An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">ObjectIdentifier는 ASN.1 OBJECT IDENTIFIER를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="25a8b4525236ef00b360d07cb19827944df7a067" translate="yes" xml:space="preserve">
          <source>An Offset represents the location of an Entry within the DWARF info. (See Reader.Seek.)</source>
          <target state="translated">오프셋은 DWARF 정보 내에서 항목의 위치를 ​​나타냅니다. (Reader.Seek 참조)</target>
        </trans-unit>
        <trans-unit id="ac3f6fd5c5f4020fe745e9df601334d103e434f6" translate="yes" xml:space="preserve">
          <source>An Op is a single regular expression operator.</source>
          <target state="translated">Op는 단일 정규식 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="0314a12979f35374da5a5f6df2c7d8b530e55186" translate="yes" xml:space="preserve">
          <source>An SRV represents a single DNS SRV record.</source>
          <target state="translated">SRV는 단일 DNS SRV 레코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2409c4611787fa12fc74e051bb517f08b144ce6f" translate="yes" xml:space="preserve">
          <source>An SelectStmt node represents a select statement.</source>
          <target state="translated">SelectStmt 노드는 select 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="41596e8b76edc639db644d1e3dc2c1dd81459d07" translate="yes" xml:space="preserve">
          <source>An SliceExpr node represents an expression followed by slice indices.</source>
          <target state="translated">SliceExpr 노드는 식 다음에 슬라이스 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed46c8e20af1ec33b3449cc621457b646d93171d" translate="yes" xml:space="preserve">
          <source>An TypeSwitchStmt node represents a type switch statement.</source>
          <target state="translated">TypeSwitchStmt 노드는 유형 스위치 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e3ece4dfd5d5307131c8573c8e34ed46191a7bf" translate="yes" xml:space="preserve">
          <source>An UnmarshalError represents an error in the unmarshaling process.</source>
          <target state="translated">UnmarshalError는 비 정렬 화 프로세스의 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="868232dcab51d8cfeb408a9b9149e92c12b71d90" translate="yes" xml:space="preserve">
          <source>An UnmarshalFieldError describes a JSON object key that led to an unexported (and therefore unwritable) struct field.</source>
          <target state="translated">UnmarshalFieldError는 익스포트되지 않은 (따라서 쓸 수없는) 구조체 필드로 이어진 JSON 객체 키를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="737b56eeaf44e2dc73cc5f508d01fd01025fa4b2" translate="yes" xml:space="preserve">
          <source>An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type.</source>
          <target state="translated">UnmarshalTypeError는 특정 Go 유형의 값에 적합하지 않은 JSON 값을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dbb12df0d8594699910ded263bdda73074faccc3" translate="yes" xml:space="preserve">
          <source>An UnspecifiedType represents an implicit, unknown, ambiguous or nonexistent type.</source>
          <target state="translated">UnspecifiedType은 암시 적이거나 알 수 없거나 모호하거나 존재하지 않는 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="127495d0dcb94690f6b42f4443962cedbb7bc317" translate="yes" xml:space="preserve">
          <source>An UnsupportedError reports that the input uses a valid but unimplemented JPEG feature.</source>
          <target state="translated">UnsupportedError는 입력이 유효하지만 구현되지 않은 JPEG 기능을 사용한다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="b6cface443329dd52d1ffaa72664f6e7fd32f48b" translate="yes" xml:space="preserve">
          <source>An UnsupportedError reports that the input uses a valid but unimplemented PNG feature.</source>
          <target state="translated">UnsupportedError는 입력이 유효하지만 구현되지 않은 PNG 기능을 사용한다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="50c033636c681ef23f5703353e7b6b548ee31e57" translate="yes" xml:space="preserve">
          <source>An UnsupportedType is a placeholder returned in situations where we encounter a type that isn't supported.</source>
          <target state="translated">UnsupportedType은 지원되지 않는 유형이있는 상황에서 반환되는 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="9f010dd73bd76eac970f2fad6de4d1d072e049eb" translate="yes" xml:space="preserve">
          <source>An UnsupportedTypeError is returned by Marshal when attempting to encode an unsupported value type.</source>
          <target state="translated">지원되지 않는 값 형식을 인코딩하려고 할 때 Marshal은 UnsupportedTypeError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55cf6dbd651aa1fc24dab4ed83f94d2cc501a8bb" translate="yes" xml:space="preserve">
          <source>An alpha-premultiplied color component C has been scaled by alpha (A), so has valid values 0 &amp;lt;= C &amp;lt;= A.</source>
          <target state="translated">알파 미리 곱셈 된 색상 구성 요소 C는 알파 (A)로 크기가 조정되었으므로 유효한 값은 0 &amp;lt;= C &amp;lt;= A입니다.</target>
        </trans-unit>
        <trans-unit id="96f36f26c07cd97ba2148d75c909d9ff85455a78" translate="yes" xml:space="preserve">
          <source>An analogous set of functions scans formatted text to yield values. Scan, Scanf and Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified io.Reader; Sscan, Sscanf and Sscanln read from an argument string.</source>
          <target state="translated">유사한 기능 세트는 형식화 된 텍스트를 스캔하여 값을 생성합니다. os.Stdin에서 읽은 Scan, Scanf 및 Scanln; Fscan, Fscanf 및 Fscanln은 지정된 io.Reader에서 읽습니다. Sscan, Sscanf 및 Sscanln은 인수 문자열에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="dd590ec64bdbd07328cd1648202f3c4d0652fcaa" translate="yes" xml:space="preserve">
          <source>An appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to amortize allocation overhead across many clients.</source>
          <target state="translated">풀의 적절한 사용은 패키지의 동시 독립 클라이언트가 자동 공유하고 잠재적으로 재사용 할 수있는 임시 항목 그룹을 관리하는 것입니다. 풀은 많은 클라이언트에서 할당 오버 헤드를 상각 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e7a6c66066c63a7b13fb3633463450779dc83697" translate="yes" xml:space="preserve">
          <source>An argument is a simple value, denoted by one of the following.</source>
          <target state="translated">인수는 다음 중 하나로 표시되는 간단한 값입니다.</target>
        </trans-unit>
        <trans-unit id="f9834be44e753f9b0833b74dd8442f2593d02903" translate="yes" xml:space="preserve">
          <source>An empty Dir is treated as &quot;.&quot;.</source>
          <target state="translated">빈 Dir은 &quot;.&quot;로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3c1d4dbd141f152659ded0ed62d6fc32f149bd0b" translate="yes" xml:space="preserve">
          <source>An empty method means &quot;GET&quot;.</source>
          <target state="translated">빈 메소드는 &quot;GET&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cd4d28837904807a903cbe5476bdc10de0744eb7" translate="yes" xml:space="preserve">
          <source>An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed.</source>
          <target state="translated">UTF-8이 올바르지 않거나 범위를 벗어난 룬을 인코딩하거나 값에 대해 가능한 가장 짧은 UTF-8 인코딩이 아닌 경우 인코딩이 유효하지 않습니다. 다른 유효성 검사는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97559fea881eb99df8b5b805bce6db58884baa12" translate="yes" xml:space="preserve">
          <source>An entry is a sequence of attribute/value pairs.</source>
          <target state="translated">항목은 일련의 속성 / 값 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="70ec8bed891e692083a35e67a8a08047708ac061" translate="yes" xml:space="preserve">
          <source>An error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.</source>
          <target state="translated">대상이 대상과 같거나 Is (error) bool 메소드를 구현하여 Is (target)이 true를 리턴하는 경우 대상과 일치하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b1a208abffd28eb07ba78aa217f3028c63ddac28" translate="yes" xml:space="preserve">
          <source>An error is returned if caused by client policy (such as CheckRedirect), or failure to speak HTTP (such as a network connectivity problem). A non-2xx status code doesn't cause an error.</source>
          <target state="translated">클라이언트 정책 (예 : CheckRedirect) 또는 HTTP 말하기 실패 (예 : 네트워크 연결 문제)로 인해 오류가 리턴됩니다. 2xx가 아닌 상태 코드는 오류를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="486bd0cc019a78e61c1e7988575a296022dde327" translate="yes" xml:space="preserve">
          <source>An error is returned if pos is not within the package or if the node cannot be type-checked.</source>
          <target state="translated">pos가 패키지 내에 없거나 노드를 유형 검사 할 수없는 경우 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="33f2fbaf6070ae69f9aa39421d7912bcc2d2cb21" translate="yes" xml:space="preserve">
          <source>An error is returned if the Client's CheckRedirect function fails or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type *url.Error. The url.Error value's Timeout method will report true if request timed out or was canceled.</source>
          <target state="translated">클라이언트의 CheckRedirect 기능이 실패하거나 HTTP 프로토콜 오류가있는 경우 오류가 리턴됩니다. 2xx가 아닌 응답으로 오류가 발생하지 않습니다. 리턴 된 오류는 * url.Error 유형입니다. 요청 시간이 초과되거나 취소 된 경우 url.Error 값의 Timeout 메서드는 true를보고합니다.</target>
        </trans-unit>
        <trans-unit id="29559e83fd57f697a87f8f6c23a1408199321367" translate="yes" xml:space="preserve">
          <source>An error is returned if there were too many redirects or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type *url.Error. The url.Error value's Timeout method will report true if request timed out or was canceled.</source>
          <target state="translated">리디렉션이 너무 많거나 HTTP 프로토콜 오류가 있으면 오류가 반환됩니다. 2xx가 아닌 응답으로 오류가 발생하지 않습니다. 리턴 된 오류는 * url.Error 유형입니다. 요청 시간이 초과되거나 취소 된 경우 url.Error 값의 Timeout 메서드는 true를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ca4e973640c5414c2d9178d60dc8605a5b8a5d60" translate="yes" xml:space="preserve">
          <source>An error matches target if the error's concrete value is assignable to the value pointed to by target, or if the error has a method As(interface{}) bool such that As(target) returns true. In the latter case, the As method is responsible for setting target.</source>
          <target state="translated">오류의 구체적인 값을 대상이 가리키는 값에 할당 할 수 있거나 오류에 As (target)이 true를 반환하는 As (interface {}) bool 메소드가있는 경우 오류가 대상과 일치합니다. 후자의 경우 As 메소드는 대상 설정을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="2ec1daa84976e0d0488f1ebd412c66b0f689386a" translate="yes" xml:space="preserve">
          <source>An error returned after a timeout fails will implement the Timeout method, and calling the Timeout method will return true. The PathError and SyscallError types implement the Timeout method. In general, call IsTimeout to test whether an error indicates a timeout.</source>
          <target state="translated">시간 초과에 실패한 후 반환 된 오류는 Timeout 메서드를 구현하며 Timeout 메서드를 호출하면 true가 반환됩니다. PathError 및 SyscallError 유형은 Timeout 메서드를 구현합니다. 일반적으로 오류가 시간 초과를 나타내는 지 여부를 테스트하려면 IsTimeout을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d8b785d2e40c6b05c4a7dedaf9a7985d62dd9c0c" translate="yes" xml:space="preserve">
          <source>An example of good use of a Pool is in the fmt package, which maintains a dynamically-sized store of temporary output buffers. The store scales under load (when many goroutines are actively printing) and shrinks when quiescent.</source>
          <target state="translated">풀을 잘 사용하는 예는 fmt 패키지에 있으며, 임시 출력 버퍼의 동적 크기 저장소를 유지합니다. 매장은 적재 상태에서 확장되고 (많은 고 루틴이 활발하게 인쇄 할 때) 정지 상태 일 때 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="5d1ac1bff5d82335919eca7792226149f6974601" translate="yes" xml:space="preserve">
          <source>An expectCode &amp;lt;= 0 disables the check of the status code.</source>
          <target state="translated">expectCode &amp;lt;= 0은 상태 코드 확인을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b885b02299d18da02728c260e15d739888aa2a45" translate="yes" xml:space="preserve">
          <source>An idle timeout can be implemented by repeatedly extending the deadline after successful Read or Write calls.</source>
          <target state="translated">성공적인 읽기 또는 쓰기 호출 후 최종 기한을 반복하여 유휴 시간 초과를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c30b3b786ad798c3290738b4c4b125b52d06a251" translate="yes" xml:space="preserve">
          <source>An implementation that always returns &quot;&quot; is valid and may be useful for testing but it is not secure: it means that the HTTP server for foo.com can set a cookie for bar.com.</source>
          <target state="translated">항상 &quot;&quot;를 반환하는 구현은 유효하며 테스트에 유용하지만 안전하지는 않습니다. 이는 foo.com의 HTTP 서버가 bar.com의 쿠키를 설정할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="47c9f3a025dffe9123fd4bfd7373fe411e63cc3f" translate="yes" xml:space="preserve">
          <source>An internal function but exported because it is cross-package; part of the implementation of the &quot;go test&quot; command.</source>
          <target state="translated">내부 패키지이지만 교차 패키지이므로 내 보냅니다. &quot;go test&quot;명령 구현의 일부.</target>
        </trans-unit>
        <trans-unit id="036afd05688102f6ee86356229e3c79c56ec575a" translate="yes" xml:space="preserve">
          <source>An internal type but exported because it is cross-package; part of the implementation of the &quot;go test&quot; command.</source>
          <target state="translated">내부 유형이지만 교차 패키지이기 때문에 내 보냅니다. &quot;go test&quot;명령 구현의 일부.</target>
        </trans-unit>
        <trans-unit id="442649c59c72ffcf9dd32a6c63fcf97e0bbbf3e5" translate="yes" xml:space="preserve">
          <source>An unsigned integer is sent one of two ways. If it is less than 128, it is sent as a byte with that value. Otherwise it is sent as a minimal-length big-endian (high byte first) byte stream holding the value, preceded by one byte holding the byte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and 256 is transmitted as (FE 01 00).</source>
          <target state="translated">부호없는 정수는 두 가지 방법 중 하나로 전송됩니다. 128보다 작 으면 해당 값을 가진 바이트로 전송됩니다. 그렇지 않으면, 바이트 카운트를 보유한 1 바이트 앞에 값을 보유한 최소 길이의 빅 엔디안 (하이 바이트 우선) 바이트 스트림으로 전송됩니다. 따라서 0은 (00)으로 전송되고 7은 (07)로 전송되고 256은 (FE 01 00)로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="7a76817319296468bf39d1d78d770edaaa1f1d0b" translate="yes" xml:space="preserve">
          <source>And sets z = x &amp;amp; y and returns z.</source>
          <target state="translated">그리고 z = x &amp;amp; y를 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fe7a64501f902a2a15dc8d7ef88b7a3c8758b53" translate="yes" xml:space="preserve">
          <source>AndNot sets z = x &amp;amp;^ y and returns z.</source>
          <target state="translated">AndNot은 z = x &amp;amp; ^ y를 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="104eadd84d40efc537cbdaed98695f14d3c410ae" translate="yes" xml:space="preserve">
          <source>Anonymous reports whether the variable is an embedded field. Same as Embedded; only present for backward-compatibility.</source>
          <target state="translated">익명은 변수가 포함 된 필드인지보고합니다. 임베디드와 동일; 이전 버전과의 호환성을 위해서만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b34123eb0681a84b4e38ef46e880e0d9d4e93ff2" translate="yes" xml:space="preserve">
          <source>Anonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.</source>
          <target state="translated">익명의 구조체 필드는 일반적으로 내 보낸 필드가 외부 구조체의 필드 인 것처럼 마샬링되며 다음 단락에 설명 된대로 수정 된 일반적인 Go 가시성 규칙이 적용됩니다. JSON 태그에 이름이 지정된 익명 구조체 필드는 익명이 아니라 해당 이름을 가진 것으로 취급됩니다. 인터페이스 유형의 익명 구조체 필드는 익명이 아닌 해당 유형을 이름으로 사용하는 것과 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="afb9e365ac6bc69254b413683db8417c15044c6f" translate="yes" xml:space="preserve">
          <source>Any item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated.</source>
          <target state="translated">풀에 저장된 모든 항목은 언제라도 통지없이 자동으로 제거 될 수 있습니다. 이 경우 풀이 유일한 참조를 보유하면 항목이 할당 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b643cc8e0850db50e55740276d22f185017d81" translate="yes" xml:space="preserve">
          <source>Any mutations to the returned pool are not written to disk and do not affect any other pool returned by SystemCertPool.</source>
          <target state="translated">리턴 된 풀에 대한 돌연변이는 디스크에 기록되지 않으며 SystemCertPool에서 리턴 한 다른 풀에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="224f9d3dc95f39b31b4695465f7bb92d23f66b43" translate="yes" xml:space="preserve">
          <source>Any of the above ASN.1 values can be written to an interface{}. The value stored in the interface has the corresponding Go type. For integers, that type is int64.</source>
          <target state="translated">위의 ASN.1 값을 인터페이스 {}에 쓸 수 있습니다. 인터페이스에 저장된 값은 해당 Go 유형을 갖습니다. 정수의 경우 해당 유형은 int64입니다.</target>
        </trans-unit>
        <trans-unit id="791f38485d078e4250fe65d69d579ce6058e5ed8" translate="yes" xml:space="preserve">
          <source>Any returned error will be of type *url.Error. The url.Error value's Timeout method will report true if request timed out or was canceled.</source>
          <target state="translated">리턴 된 오류는 * url.Error 유형입니다. 요청 시간이 초과되거나 취소 된 경우 url.Error 값의 Timeout 메서드는 true를보고합니다.</target>
        </trans-unit>
        <trans-unit id="12810041e8799641fa0564b3d08f00a640e526e5" translate="yes" xml:space="preserve">
          <source>Append appends the string representation of x, as generated by x.Text(base), to buf and returns the extended buffer.</source>
          <target state="translated">Append는 x.Text (base)에 의해 생성 된 x의 문자열 표현을 buf에 추가하고 확장 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="991b56073f752ea70afd5d3245c19ae4ca5aea47" translate="yes" xml:space="preserve">
          <source>Append appends the values x to a slice s and returns the resulting slice. As in Go, each x's value must be assignable to the slice's element type.</source>
          <target state="translated">Append는 x 값을 slice에 추가하고 결과 slice를 반환합니다. Go에서와 같이 각 x의 값은 슬라이스의 요소 유형에 지정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a6738f1f149fb1b688951727ba8a4eb62d6e849" translate="yes" xml:space="preserve">
          <source>Append appends to buf the string form of the floating-point number x, as generated by x.Text, and returns the extended buffer.</source>
          <target state="translated">Append는 x.Text에 의해 생성 된 부동 소수점 숫자 x의 문자열 형식을 buf에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dc7406a7e262f6f8144c95e8a9ab9e772e4587d4" translate="yes" xml:space="preserve">
          <source>AppendBool</source>
          <target state="translated">AppendBool</target>
        </trans-unit>
        <trans-unit id="8e6c1bde028847a8f50865559cf63e4d8dcb8db9" translate="yes" xml:space="preserve">
          <source>AppendBool appends &quot;true&quot; or &quot;false&quot;, according to the value of b, to dst and returns the extended buffer.</source>
          <target state="translated">AppendBool은 b 값에 ​​따라 &quot;true&quot;또는 &quot;false&quot;를 dst에 추가하고 확장 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="014e6c46b60f6356c8ae4eb44946bcc39c683ed5" translate="yes" xml:space="preserve">
          <source>AppendBool, AppendFloat, AppendInt, and AppendUint are similar but append the formatted value to a destination slice.</source>
          <target state="translated">AppendBool, AppendFloat, AppendInt 및 AppendUint는 비슷하지만 형식이 지정된 값을 대상 슬라이스에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cbf71c71617cb5b06bbe72a027a40a50e99d7ac7" translate="yes" xml:space="preserve">
          <source>AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It appends any certificates found to s and reports whether any certificates were successfully parsed.</source>
          <target state="translated">AppendCertsFromPEM은 일련의 PEM 인코딩 된 인증서를 구문 분석하려고 시도합니다. 발견 된 모든 인증서를 추가하고 인증서가 성공적으로 구문 분석되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ef209b42fc5cf6c80a711f0e8fdac2c151f89421" translate="yes" xml:space="preserve">
          <source>AppendFloat</source>
          <target state="translated">AppendFloat</target>
        </trans-unit>
        <trans-unit id="1e82a7a839e480035dfa637aa1bc5055d24e100b" translate="yes" xml:space="preserve">
          <source>AppendFloat appends the string form of the floating-point number f, as generated by FormatFloat, to dst and returns the extended buffer.</source>
          <target state="translated">AppendFloat는 FormatFloat에 의해 생성 된 부동 소수점 숫자 f의 문자열 형식을 dst에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b06ef363cdc72d800a1b0e2f4d789a51ed28e9cc" translate="yes" xml:space="preserve">
          <source>AppendFormat is like Format but appends the textual representation to b and returns the extended buffer.</source>
          <target state="translated">AppendFormat은 Format과 유사하지만 텍스트 표현을 b에 추가하고 확장 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa7c3675c344d224694cdd3e00f46904a1a198c2" translate="yes" xml:space="preserve">
          <source>AppendInt</source>
          <target state="translated">AppendInt</target>
        </trans-unit>
        <trans-unit id="d2b187db6c308fc1702924e2f1e633509db15a41" translate="yes" xml:space="preserve">
          <source>AppendInt appends the string form of the integer i, as generated by FormatInt, to dst and returns the extended buffer.</source>
          <target state="translated">AppendInt는 FormatInt에 의해 생성 된 정수 i의 문자열 형식을 dst에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1ec9b89a50366169935f696b1a52bab9ad93ce11" translate="yes" xml:space="preserve">
          <source>AppendQuote</source>
          <target state="translated">AppendQuote</target>
        </trans-unit>
        <trans-unit id="cf8e7dfc01c8eb2ae61af0decdd8abe4db2493e3" translate="yes" xml:space="preserve">
          <source>AppendQuote appends a double-quoted Go string literal representing s, as generated by Quote, to dst and returns the extended buffer.</source>
          <target state="translated">AppendQuote는 Quote로 생성 된 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 dst에 추가하고 확장 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aac9680f9b8d54a2e691b9fc4814576b43aa1597" translate="yes" xml:space="preserve">
          <source>AppendQuoteRune</source>
          <target state="translated">AppendQuoteRune</target>
        </trans-unit>
        <trans-unit id="4affe2726aa0af79866bcac727b0aa02165283e7" translate="yes" xml:space="preserve">
          <source>AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by QuoteRune, to dst and returns the extended buffer.</source>
          <target state="translated">AppendQuoteRune는 QuoteRune에 의해 생성 된 룬을 나타내는 작은 따옴표로 묶인 Go 문자 리터럴을 dst에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5cc72aa0b6d1a3e6331f053030965add24d59d99" translate="yes" xml:space="preserve">
          <source>AppendQuoteRuneToASCII</source>
          <target state="translated">AppendQuoteRuneToASCII</target>
        </trans-unit>
        <trans-unit id="d3afb68811f96e790a1e9d00f7edaa6a56c7ecf3" translate="yes" xml:space="preserve">
          <source>AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToASCII, to dst and returns the extended buffer.</source>
          <target state="translated">AppendQuoteRuneToASCII는 QuoteRuneToASCII에 의해 생성 된 룬을 나타내는 작은 따옴표로 묶인 Go 문자 리터럴을 dst에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="63575dcb5767538ce900b5ecffc6e375340ae2db" translate="yes" xml:space="preserve">
          <source>AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.</source>
          <target state="translated">AppendQuoteRuneToGraphic은 QuoteRuneToGraphic에 의해 생성 된 룬을 나타내는 작은 따옴표로 묶인 Go 문자 리터럴을 dst에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e4edf5c0ada10bc45e0e1cd667a7f4ca233f2d8a" translate="yes" xml:space="preserve">
          <source>AppendQuoteToASCII</source>
          <target state="translated">AppendQuoteToASCII</target>
        </trans-unit>
        <trans-unit id="4af83e8c6f92cae36f17c055e1dad65cafe24a88" translate="yes" xml:space="preserve">
          <source>AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by QuoteToASCII, to dst and returns the extended buffer.</source>
          <target state="translated">AppendQuoteToASCII는 QuoteToASCII에 의해 생성 된 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 dst에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0614344e66308abc1fa3774e3b165f0a5a6ba86e" translate="yes" xml:space="preserve">
          <source>AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by QuoteToGraphic, to dst and returns the extended buffer.</source>
          <target state="translated">AppendQuoteToGraphic은 QuoteToGraphic에 의해 생성 된 s를 나타내는 큰 따옴표로 묶인 Go 문자열 리터럴을 dst에 추가하고 확장 버퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4293b6e547f1114c134ce72872c3d683ab6de3b4" translate="yes" xml:space="preserve">
          <source>AppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type.</source>
          <target state="translated">AppendSlice는 슬라이스 t를 슬라이스 s에 추가하고 결과 슬라이스를 반환합니다. 슬라이스 s와 t는 동일한 요소 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="b94bccf4bd646055e30b89dcc1a6bb69c63264a1" translate="yes" xml:space="preserve">
          <source>AppendUint</source>
          <target state="translated">AppendUint</target>
        </trans-unit>
        <trans-unit id="1a848ce1ccb2943fb03b2a97a183e1e001204d7f" translate="yes" xml:space="preserve">
          <source>AppendUint appends the string form of the unsigned integer i, as generated by FormatUint, to dst and returns the extended buffer.</source>
          <target state="translated">AppendUint는 FormatUint에 의해 생성 된 부호없는 정수 i의 문자열 형식을 dst에 추가하고 확장 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ceb03c6f5e7370ed7befcfaa3e743fb64b5ef4c" translate="yes" xml:space="preserve">
          <source>ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression.</source>
          <target state="translated">ArbitraryType은 문서화 목적으로 만 사용되며 실제로 안전하지 않은 패키지의 일부는 아닙니다. 임의의 Go 표현식 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5f584feba6cf3361b02c7c81dcebd1e32a75415e" translate="yes" xml:space="preserve">
          <source>ArchChar returns &quot;?&quot; and an error. In earlier versions of Go, the returned string was used to derive the compiler and linker tool names, the default object file suffix, and the default linker output name. As of Go 1.5, those strings no longer vary by architecture; they are compile, link, .o, and a.out, respectively.</source>
          <target state="translated">ArchChar는 &quot;?&quot;를 반환합니다. 그리고 오류. 이전 버전의 Go에서 반환 된 문자열은 컴파일러 및 링커 도구 이름, 기본 개체 파일 접미사 및 기본 링커 출력 이름을 도출하는 데 사용되었습니다. Go 1.5부터는 해당 문자열이 더 이상 아키텍처에 따라 달라지지 않습니다. 이들은 각각 컴파일, 링크, .o 및 a.out입니다.</target>
        </trans-unit>
        <trans-unit id="7fd33dbad703e2baacd65220f1dee6594a39c3e1" translate="yes" xml:space="preserve">
          <source>Arg returns the i'th argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist.</source>
          <target state="translated">Arg는 i 번째 인수를 반환합니다. Arg (0)은 플래그가 처리 된 후 남은 첫 번째 인수입니다. 요청 된 요소가 존재하지 않으면 Arg는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e87e53727801bfc878272fae45c5972e2148db1" translate="yes" xml:space="preserve">
          <source>Arg returns the i'th command-line argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist.</source>
          <target state="translated">Arg는 i 번째 명령 줄 인수를 반환합니다. Arg (0)은 플래그가 처리 된 후 남은 첫 번째 인수입니다. 요청 된 요소가 존재하지 않으면 Arg는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f057c07f8a3d2900b501ed0ba97a2c798c10c131" translate="yes" xml:space="preserve">
          <source>Args hold the command-line arguments, starting with the program name.</source>
          <target state="translated">Args는 프로그램 이름으로 시작하여 명령 행 인수를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="5d6577266006e170c0a00f0095a742e5ff6a8b83" translate="yes" xml:space="preserve">
          <source>Args returns the non-flag arguments.</source>
          <target state="translated">Args는 플래그가 아닌 인수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d50601b6e19d9bb6ca5607eb536c9755a196001" translate="yes" xml:space="preserve">
          <source>Args returns the non-flag command-line arguments.</source>
          <target state="translated">Args는 플래그가 아닌 명령 줄 인수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="dcac9467b61958dfc8fb2a284d9809101d3387e5" translate="yes" xml:space="preserve">
          <source>Arguments may evaluate to any type; if they are pointers the implementation automatically indirects to the base type when required. If an evaluation yields a function value, such as a function-valued field of a struct, the function is not invoked automatically, but it can be used as a truth value for an if action and the like. To invoke it, use the call function, defined below.</source>
          <target state="translated">인수는 모든 유형으로 평가 될 수 있습니다. 이들이 포인터 인 경우, 구현은 필요할 때 자동으로 기본 유형에 간접적으로 지시합니다. 평가에서 구조체의 함수 값 필드와 같은 함수 값이 생성되면 함수가 자동으로 호출되지 않지만 if 조치 등에 대한 실제 값으로 사용될 수 있습니다. 이를 호출하려면 아래 정의 된 호출 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="03cb1ef1a4caa26d25a6105558ad623367ea6a38" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions are typically written as a sequence of individual method calls, with each call corresponding to an operation. The receiver denotes the result and the method arguments are the operation's operands. For instance, given three *Int values a, b and c, the invocation</source>
          <target state="translated">산술 표현식은 일반적으로 일련의 개별 메소드 호출로 작성되며 각 호출은 조작에 해당합니다. 수신자는 결과를 나타내고 메소드 인수는 오퍼레이션의 피연산자입니다. 예를 들어, 3 개의 * Int 값 a, b 및 c가 주어지면 호출</target>
        </trans-unit>
        <trans-unit id="918a4da47d7ebb48a08cab34e3e485f64e61c032" translate="yes" xml:space="preserve">
          <source>Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.</source>
          <target state="translated">배열 및 슬라이스 값은 [] 바이트가 base64로 인코딩 된 문자열로 인코딩되고 nil 슬라이스는 null JSON 값으로 인코딩되는 것을 제외하고 JSON 배열로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="a680524eecee442cefa352a7c38f566b7e119c31" translate="yes" xml:space="preserve">
          <source>Array values are deeply equal when their corresponding elements are deeply equal.</source>
          <target state="translated">배열 값은 해당 요소가 매우 같을 때 깊이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="66b6d7c835c7970d9fefaada6f3b7756c4c96afd" translate="yes" xml:space="preserve">
          <source>ArrayOf returns the array type with the given count and element type. For example, if t represents int, ArrayOf(5, t) represents [5]int.</source>
          <target state="translated">ArrayOf는 주어진 개수와 요소 유형을 가진 배열 유형을 반환합니다. 예를 들어, t가 int를 나타내는 경우 ArrayOf (5, t)는 [5] int를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="77b9a4ab5fb6f3aa2a4543e5c9523108a1e28b09" translate="yes" xml:space="preserve">
          <source>As DeepEqual traverses the data values it may find a cycle. The second and subsequent times that DeepEqual compares two pointer values that have been compared before, it treats the values as equal rather than examining the values to which they point. This ensures that DeepEqual terminates.</source>
          <target state="translated">DeepEqual은 데이터 값을 통과 할 때주기를 찾을 수 있습니다. DeepEqual이 두 번째 및 그 이후에 이전에 비교 한 두 개의 포인터 값을 비교하면 해당 값을 가리키는 값을 검사하는 대신 값을 동일하게 처리합니다. 이렇게하면 DeepEqual이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4b56f8d462bf82502c735c3c1eade6e22b30a7c4" translate="yes" xml:space="preserve">
          <source>As a more whimsical example, this program guesses your number:</source>
          <target state="translated">좀 더 기발한 예로써,이 프로그램은 당신의 숫자를 추측합니다 :</target>
        </trans-unit>
        <trans-unit id="bff88475604e0dd205ad66a54a59842b94885110" translate="yes" xml:space="preserve">
          <source>As a precaution, ServeFile will reject requests where r.URL.Path contains a &quot;..&quot; path element; this protects against callers who might unsafely use filepath.Join on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument.</source>
          <target state="translated">예방 조치로 ServeFile은 r.URL.Path에 &quot;..&quot;경로 요소가 포함 된 요청을 거부합니다. 이렇게하면 r.URL.Path에서 안전하지 않은 filepath.Join을 사용하지 않고 호출 할 수있는 발신자를 방지 할 수 있습니다. 그런 다음 해당 filepath.Join 결과를 이름 인수로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f39e7711059649948e083fed172dc43cfc73eaaf" translate="yes" xml:space="preserve">
          <source>As a special case, if req.URL.Host is &quot;localhost&quot; (with or without a port number), then a nil URL and nil error will be returned.</source>
          <target state="translated">특별한 경우, req.URL.Host가 &quot;localhost&quot;(포트 번호의 유무에 관계없이)이면 nil URL 및 nil 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ae690189964440e45359a1c6c51db6559b11980b" translate="yes" xml:space="preserve">
          <source>As a special case, if the field tag is &quot;-&quot;, the field is always omitted. Note that a field with name &quot;-&quot; can still be generated using the tag &quot;-,&quot;.</source>
          <target state="translated">특별한 경우로, 필드 태그가 &quot;-&quot;이면 필드는 항상 생략됩니다. &quot;-,&quot;태그를 사용하여 이름이 &quot;-&quot;인 필드를 계속 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e60c59152c193360fae3f60276c9948866292a43" translate="yes" xml:space="preserve">
          <source>As a special case, it is legal to append a string to a byte slice, like this:</source>
          <target state="translated">특별한 경우, 다음과 같이 바이트 슬라이스에 문자열을 추가하는 것이 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="564379e4b2f47f0c0856088856fe399c4a7ce7d9" translate="yes" xml:space="preserve">
          <source>As a special case, src can have kind String if the element type of dst is kind Uint8.</source>
          <target state="translated">특별한 경우, dst의 요소 유형이 Uint8 인 경우 src는 String 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c66ee4ab43b3719db19be5d1e8b263afc3c332" translate="yes" xml:space="preserve">
          <source>As a special case, the returned file server redirects any request ending in &quot;/index.html&quot; to the same path, without the final &quot;index.html&quot;.</source>
          <target state="translated">특별한 경우, 리턴 된 파일 서버는 &quot;/index.html&quot;로 끝나는 모든 요청을 최종 &quot;index.html&quot;없이 동일한 경로로 경로 재 지정합니다.</target>
        </trans-unit>
        <trans-unit id="69cd9de94cfb605c56ea7c7a305ef94aa8e800ad" translate="yes" xml:space="preserve">
          <source>As another special case, ServeFile redirects any request where r.URL.Path ends in &quot;/index.html&quot; to the same path, without the final &quot;index.html&quot;. To avoid such redirects either modify the path or use ServeContent.</source>
          <target state="translated">또 다른 특별한 경우로 ServeFile은 r.URL.Path가 &quot;/index.html&quot;로 끝나는 모든 요청을 최종 &quot;index.html&quot;없이 동일한 경로로 리디렉션합니다. 이러한 리디렉션을 피하려면 경로를 수정하거나 ServeContent를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c22915584feea30271ccd5462bc99d8717677963" translate="yes" xml:space="preserve">
          <source>As finds the first error in err's chain that matches target, and if so, sets target to that error value and returns true.</source>
          <target state="translated">err의 체인에서 target과 일치하는 첫 번째 오류를 찾으면 target을 해당 오류 값으로 설정하고 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4dc527904b5762369a3f475f72b0dc996cabb70c" translate="yes" xml:space="preserve">
          <source>As in the cases above, it is invalid to store the result before the conversion:</source>
          <target state="translated">위의 경우와 같이 변환 전에 결과를 저장하는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaf43f02c8be260818b1d2cfc8d762dc44ca7c4c" translate="yes" xml:space="preserve">
          <source>As in the previous case, the reflect data structures SliceHeader and StringHeader declare the field Data as a uintptr to keep callers from changing the result to an arbitrary type without first importing &quot;unsafe&quot;. However, this means that SliceHeader and StringHeader are only valid when interpreting the content of an actual slice or string value.</source>
          <target state="translated">이전의 경우와 같이 리플렉션 데이터 구조 SliceHeader 및 StringHeader는 Data 필드를 uintptr로 선언하여 호출자가 먼저 &quot;안전하지 않은&quot;가져 오기없이 결과를 임의의 유형으로 변경하지 못하게합니다. 그러나 이는 SliceHeader 및 StringHeader가 실제 슬라이스 또는 문자열 값의 내용을 해석 할 때만 유효 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1c27858b3442fc0bee7882f1bb69b22f67a266cb" translate="yes" xml:space="preserve">
          <source>As of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW test. Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests, and ProbablyPrime(0) panicked.</source>
          <target state="translated">Go 1.8부터 ProbablyPrime (0)이 허용되며 Baillie-PSW 테스트 만 적용됩니다. 1.8 이전에 ProbablyPrime은 Miller-Rabin 테스트 만 적용했으며 ProbablyPrime (0)은 당황했습니다.</target>
        </trans-unit>
        <trans-unit id="2dd4351c985c8d810139dead9123e042560e4b66" translate="yes" xml:space="preserve">
          <source>As returned by NewReader, a Reader expects input conforming to RFC 4180. The exported fields can be changed to customize the details before the first call to Read or ReadAll.</source>
          <target state="translated">NewReader에서 반환 한대로 Reader는 RFC 4180을 준수하는 입력을 예상합니다. 내 보낸 필드를 변경하여 Read 또는 ReadAll을 처음 호출하기 전에 세부 정보를 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e146a063bece1e3d2e6bbe0b5fda136eb3a8802" translate="yes" xml:space="preserve">
          <source>As returned by NewWriter, a Writer writes records terminated by a newline and uses ',' as the field delimiter. The exported fields can be changed to customize the details before the first call to Write or WriteAll.</source>
          <target state="translated">NewWriter가 반환 한대로 Writer는 줄 바꿈으로 끝나는 레코드를 쓰고 필드 구분 기호로 ','를 사용합니다. 내 보낸 필드는 Write 또는 WriteAll에 대한 첫 번째 호출 전에 세부 사항을 사용자 정의하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7df27550c12511e83c255cdee5cd115de36801a" translate="yes" xml:space="preserve">
          <source>As this uses the math/rand package, it must not be used for security-sensitive work. Use crypto/rand.Int instead.</source>
          <target state="translated">이것은 math / rand 패키지를 사용하므로 보안에 민감한 작업에는 사용하지 않아야합니다. 대신 crypto / rand.Int를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2cd259da2c4b6fea04004fe9f9885ac522790abc" translate="yes" xml:space="preserve">
          <source>As unwraps its first argument sequentially looking for an error that can be assigned to its second argument, which must be a pointer. If it succeeds, it performs the assignment and returns true. Otherwise, it returns false. The form</source>
          <target state="translated">첫 번째 인수를 순차적으로 풀어서 두 번째 인수에 할당 할 수있는 오류를 찾습니다 (포인터 여야 함). 성공하면 할당을 수행하고 true를 반환합니다. 그렇지 않으면 false를 반환합니다. 형태</target>
        </trans-unit>
        <trans-unit id="8374f63c4cc91790e10a17540248859e2c43749e" translate="yes" xml:space="preserve">
          <source>As will panic if target is not a non-nil pointer to either a type that implements error, or to any interface type. As returns false if err is nil.</source>
          <target state="translated">target이 오류를 구현하는 유형 또는 인터페이스 유형에 대한 non-nil 포인터가 아닌 경우 패닉이 발생합니다. err이 nil이면 As은 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e12a672c4a03c1f366a655654dd82547f4c192b6" translate="yes" xml:space="preserve">
          <source>As with Mutexes, a locked RWMutex is not associated with a particular goroutine. One goroutine may RLock (Lock) a RWMutex and then arrange for another goroutine to RUnlock (Unlock) it.</source>
          <target state="translated">Mutexes와 마찬가지로 잠긴 RWMutex는 특정 고 루틴과 관련이 없습니다. 한 고 루틴은 RWMutex를 RLock (잠금) 한 다음 다른 고 루틴을 RUnlock (잠금 해제) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f21579b78a9211097bade1507cf7d1061aef2af" translate="yes" xml:space="preserve">
          <source>Asin</source>
          <target state="translated">Asin</target>
        </trans-unit>
        <trans-unit id="5bad1e47810824babb31078e94077c5944ed414b" translate="yes" xml:space="preserve">
          <source>Asin returns the arcsine, in radians, of x.</source>
          <target state="translated">Asin은 x의 아크 사인을 라디안으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42f92a72e30529e672dc5d2bdb4e52a1e80b51ed" translate="yes" xml:space="preserve">
          <source>Asin returns the inverse sine of x.</source>
          <target state="translated">Asin은 x의 역 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad5ced2b521e057f06b0f8b74356c5357ee0c1b5" translate="yes" xml:space="preserve">
          <source>Asinh</source>
          <target state="translated">Asinh</target>
        </trans-unit>
        <trans-unit id="6b958528f6028414e36bacd2591d4b6be481f7b4" translate="yes" xml:space="preserve">
          <source>Asinh returns the inverse hyperbolic sine of x.</source>
          <target state="translated">Asinh는 x의 역 쌍곡 사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="88ff212e4044fa4ecfe39d2c2662e15ee5065576" translate="yes" xml:space="preserve">
          <source>AssertableTo reports whether a value of type V can be asserted to have type T.</source>
          <target state="translated">AssertableTo는 V 유형의 값이 T 유형을 갖도록 주장 할 수 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="b7e50e603d8ca37cb77d5d576d4a7b54854bdbbc" translate="yes" xml:space="preserve">
          <source>AssignNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.</source>
          <target state="translated">AssignNode는 변수 필드 목록을 보유하며 가능하면 체인 필드 액세스가 가능합니다. 달러 기호는 (이름) 이름의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="ec3e8c371a10dbed4fea0329ff6a11ce3cbd6f29" translate="yes" xml:space="preserve">
          <source>Assignable reports whether the corresponding expression is assignable to (provided a value of the right type).</source>
          <target state="translated">대입 식은 해당 식을 대입 할 수 있는지 여부를보고합니다 (올바른 유형의 값 제공).</target>
        </trans-unit>
        <trans-unit id="bd5a07eeed4108b05189ea3b918384a565a62707" translate="yes" xml:space="preserve">
          <source>AssignableTo reports whether a value of type V is assignable to a variable of type T.</source>
          <target state="translated">AssignableTo는 V 유형의 값이 T 유형의 변수에 지정 가능한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="073f06f859d560b94308665c74b394553a4cb550" translate="yes" xml:space="preserve">
          <source>Associated templates</source>
          <target state="translated">관련 템플릿</target>
        </trans-unit>
        <trans-unit id="121e4049fd559093314fa7baa93a29ee9ee41472" translate="yes" xml:space="preserve">
          <source>Assuming {{.}} is `O'Reilly: How are &amp;lt;i&amp;gt;you&amp;lt;/i&amp;gt;?`, the table below shows how {{.}} appears when used in the context to the left.</source>
          <target state="translated">{{.}}이`O'Reilly : &amp;lt;i&amp;gt; you &amp;lt;/ i&amp;gt;? '라고 가정하면 아래 표는 왼쪽 문맥에서 {{.}}이 사용되는 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="746de06dfc27875c233a16bc538c38c9e6d17830" translate="yes" xml:space="preserve">
          <source>At implements the Image interface.</source>
          <target state="translated">에서 이미지 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a60dd7bc9b32af28f00b9d0d9bb8fa49524604ad" translate="yes" xml:space="preserve">
          <source>At parse time each {{.}} is overwritten to add escaping functions as necessary. In this case it becomes</source>
          <target state="translated">구문 분석시 필요에 따라 이스케이프 기능을 추가하기 위해 각 {{.}}을 (를) 덮어 씁니다. 이 경우에는</target>
        </trans-unit>
        <trans-unit id="1a0afca5b2f066f8034ea0fbbfa4603da7e5cc29" translate="yes" xml:space="preserve">
          <source>At returns the bit at the given index. If the index is out of range it returns false.</source>
          <target state="translated">At는 주어진 인덱스의 비트를 반환합니다. 인덱스가 범위를 벗어나면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42341bc94e9e432ac7ed1df54f5e5cefe525e01c" translate="yes" xml:space="preserve">
          <source>At returns the i'th method in s for 0 &amp;lt;= i &amp;lt; s.Len().</source>
          <target state="translated">At는 0 &amp;lt;= i &amp;lt;s.Len ()에 대해 s로 i 번째 메소드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="77c9122bd7d1bb2ad8f2ac38d7b8b3292183a2ac" translate="yes" xml:space="preserve">
          <source>At returns the i'th variable of tuple t.</source>
          <target state="translated">At는 튜플 t의 i 번째 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b17e31210b8e43c3d1e1c222717ddf79de31d1e" translate="yes" xml:space="preserve">
          <source>At this point, clients can see a service &quot;Arith&quot; with methods &quot;Arith.Multiply&quot; and &quot;Arith.Divide&quot;. To invoke one, a client first dials the server:</source>
          <target state="translated">이 시점에서 클라이언트는 &quot;Arith.Multiply&quot;및 &quot;Arith.Divide&quot;메소드를 사용하여 &quot;Arith&quot;서비스를 볼 수 있습니다. 하나를 호출하기 위해 클라이언트는 먼저 서버에 전화를 겁니다.</target>
        </trans-unit>
        <trans-unit id="629848d109abb16cacec52ea5ca0dc3eddfe0f61" translate="yes" xml:space="preserve">
          <source>Atan</source>
          <target state="translated">Atan</target>
        </trans-unit>
        <trans-unit id="c50e85584d7681c5aba445dde84464172eb36a4c" translate="yes" xml:space="preserve">
          <source>Atan returns the arctangent, in radians, of x.</source>
          <target state="translated">Atan은 x의 아크 탄젠트를 라디안으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0c11076c24ca507422c2e7e78169bc402e507472" translate="yes" xml:space="preserve">
          <source>Atan returns the inverse tangent of x.</source>
          <target state="translated">Atan은 x의 역 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="90c852f25296e9373d22d6d648bd28708c31cbec" translate="yes" xml:space="preserve">
          <source>Atan2</source>
          <target state="translated">Atan2</target>
        </trans-unit>
        <trans-unit id="63a222caf5c6142da57e1b301f3487b179288ab4" translate="yes" xml:space="preserve">
          <source>Atan2 returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value.</source>
          <target state="translated">Atan2는 리턴 값의 사분면을 결정하기 위해 두 부호를 사용하여 y / x의 아크 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ce5901b2d008f90c0bf7e89db8b95255eacee6a" translate="yes" xml:space="preserve">
          <source>Atanh</source>
          <target state="translated">Atanh</target>
        </trans-unit>
        <trans-unit id="8f20e96a43909d1a86e1589070972405040e354c" translate="yes" xml:space="preserve">
          <source>Atanh returns the inverse hyperbolic tangent of x.</source>
          <target state="translated">Atanh는 x의 역 쌍곡 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3c51e7a1c54b1f53de6e7c0fd3b84cdb88ba42e1" translate="yes" xml:space="preserve">
          <source>Atoi</source>
          <target state="translated">Atoi</target>
        </trans-unit>
        <trans-unit id="a117e4e38bf32f2974a89f461d6056635052cfb0" translate="yes" xml:space="preserve">
          <source>Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.</source>
          <target state="translated">Atoi는 ParseInt (s, 10, 0)와 동일하며 int 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9126f09b1713910b4d3a69d102dd9587b4610486" translate="yes" xml:space="preserve">
          <source>Attempting to receive into these types will draw a decode error:</source>
          <target state="translated">이러한 유형으로 수신을 시도하면 디코딩 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5152403a7269d216ae8f4ea3b4b7a658797c9d36" translate="yes" xml:space="preserve">
          <source>AttrField returns the Field associated with attribute Attr in Entry, or nil if there is no such attribute.</source>
          <target state="translated">AttrField는 항목의 속성 Attr과 관련된 필드를 반환하거나 해당 속성이 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ae0f439833163a3ddeedb35a68c62f7f5934a05" translate="yes" xml:space="preserve">
          <source>AttributeTypeAndValue mirrors the ASN.1 structure of the same name in RFC 5280, Section 4.1.2.4.</source>
          <target state="translated">AttributeTypeAndValue는 RFC 5280, 섹션 4.1.2.4에서 동일한 이름의 ASN.1 구조를 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="2ec0ad7b2c80ec04692a3797f2bbc0ec3042876b" translate="yes" xml:space="preserve">
          <source>AttributeTypeAndValueSET represents a set of ASN.1 sequences of AttributeTypeAndValue sequences from RFC 2986 (PKCS #10).</source>
          <target state="translated">AttributeTypeAndValueSET은 RFC 2986 (PKCS # 10)의 AttributeTypeAndValue 시퀀스의 ASN.1 시퀀스 집합을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7dace1e8c248d4f2663a3146820d6fa8f0645716" translate="yes" xml:space="preserve">
          <source>Auth authenticates a client using the provided authentication mechanism. A failed authentication closes the connection. Only servers that advertise the AUTH extension support this function.</source>
          <target state="translated">인증은 제공된 인증 메커니즘을 사용하여 클라이언트를 인증합니다. 인증에 실패하면 연결이 닫힙니다. AUTH 확장을 알리는 서버 만이 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="76ecb9e901daf9a93bba425a3a690af96a11bc07" translate="yes" xml:space="preserve">
          <source>Auth is implemented by an SMTP authentication mechanism.</source>
          <target state="translated">인증은 SMTP 인증 메커니즘으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="bf0ed01eae13fda7bf984cbae649794a647f7d90" translate="yes" xml:space="preserve">
          <source>Available reports whether the given hash function is linked into the binary.</source>
          <target state="translated">사용 가능한 해시 함수가 바이너리에 연결되어 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="9a9ecdcb8faf4f6fafd06e9771061d704142a340" translate="yes" xml:space="preserve">
          <source>Available returns how many bytes are unused in the buffer.</source>
          <target state="translated">사용 가능은 버퍼에서 사용되지 않은 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ee148636f87031dd785d5275b1cbdf15a231b5a3" translate="yes" xml:space="preserve">
          <source>B is a type passed to Benchmark functions to manage benchmark timing and to specify the number of iterations to run.</source>
          <target state="translated">B는 벤치 마크 타이밍을 관리하고 실행할 반복 횟수를 지정하기 위해 벤치 마크 함수에 전달되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="281039689fe09086452a06fde13b577021f53925" translate="yes" xml:space="preserve">
          <source>B.ReportMetric</source>
          <target state="translated">B.ReportMetric</target>
        </trans-unit>
        <trans-unit id="9735fb9f071a76bf96e03bb1c83afc5962a297bd" translate="yes" xml:space="preserve">
          <source>B.RunParallel</source>
          <target state="translated">B.RunParallel</target>
        </trans-unit>
        <trans-unit id="b352c33a80325aa5fb2ae226450e350d636f2327" translate="yes" xml:space="preserve">
          <source>BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.</source>
          <target state="translated">BUG (rsc) : 제목이 단어 경계에 사용하는 규칙은 유니 코드 문장 부호를 올바르게 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4b82c251d3f9879cefc981c46207be3e496ae01" translate="yes" xml:space="preserve">
          <source>Back returns the last element of list l or nil if the list is empty.</source>
          <target state="translated">Back은 목록 l의 마지막 요소를 반환하거나 목록이 비어 있으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db678d849360d59ad5f56340bc8559ccb08f51dd" translate="yes" xml:space="preserve">
          <source>Background returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests.</source>
          <target state="translated">백그라운드는 비어 있지 않은 빈 컨텍스트를 반환합니다. 취소되지 않으며 값이 없으며 마감일이 없습니다. 일반적으로 기본 기능, 초기화 및 테스트에서 수신 요청에 대한 최상위 컨텍스트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="0885011e0986be0085d2d4d1e06d03585dc94622" translate="yes" xml:space="preserve">
          <source>Base returns the base offset of file f as registered with AddFile.</source>
          <target state="translated">Base는 AddFile에 등록 된 파일 f의 기본 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72eb5d9f9166fd131965cf967a0725b84747d8a2" translate="yes" xml:space="preserve">
          <source>Base returns the last element of path. Trailing path separators are removed before extracting the last element. If the path is empty, Base returns &quot;.&quot;. If the path consists entirely of separators, Base returns a single separator.</source>
          <target state="translated">Base는 경로의 마지막 요소를 반환합니다. 마지막 요소를 추출하기 전에 후행 경로 구분 기호가 제거됩니다. 경로가 비어 있으면 Base는 &quot;.&quot;를 반환합니다. 경로가 완전히 구분자로 구성된 경우 Base는 단일 구분자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="730ef2dc0cbbd72e56b0f126a32b827069f4b3d9" translate="yes" xml:space="preserve">
          <source>Base returns the last element of path. Trailing slashes are removed before extracting the last element. If the path is empty, Base returns &quot;.&quot;. If the path consists entirely of slashes, Base returns &quot;/&quot;.</source>
          <target state="translated">Base는 경로의 마지막 요소를 반환합니다. 마지막 요소를 추출하기 전에 후행 슬래시가 제거됩니다. 경로가 비어 있으면 Base는 &quot;.&quot;를 반환합니다. 경로가 슬래시로만 구성된 경우 Base는 &quot;/&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6e297784364859b17a6c3c7c606bb16913b7cdc" translate="yes" xml:space="preserve">
          <source>Base returns the minimum base offset that must be provided to AddFile when adding the next file.</source>
          <target state="translated">Base는 다음 파일을 추가 할 때 AddFile에 제공해야하는 최소 기본 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99eb4008013599132cd3e27c5fb83407d85919a5" translate="yes" xml:space="preserve">
          <source>BaseName returns the symbol name without the package or receiver name.</source>
          <target state="translated">BaseName은 패키지 또는 수신자 이름없이 심볼 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e43eaab116942fbe79dd46a07719c75b728c8d47" translate="yes" xml:space="preserve">
          <source>BasicAuth returns the username and password provided in the request's Authorization header, if the request uses HTTP Basic Authentication. See RFC 2617, Section 2.</source>
          <target state="translated">요청이 HTTP 기본 인증을 사용하는 경우 BasicAuth는 요청의 Authorization 헤더에 제공된 사용자 이름과 비밀번호를 리턴합니다. RFC 2617, 섹션 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="366b21a60efe866654ff1d4abe0a6348b62eb4bd" translate="yes" xml:space="preserve">
          <source>BasicInfo is a set of flags describing properties of a basic type.</source>
          <target state="translated">BasicInfo는 기본 유형의 속성을 설명하는 플래그 집합입니다.</target>
        </trans-unit>
        <trans-unit id="de3ed59db1b7a02aa019b4d63cd7924f0ff03037" translate="yes" xml:space="preserve">
          <source>BasicKind describes the kind of basic type.</source>
          <target state="translated">BasicKind는 기본 유형의 종류를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="a559837e1ca8160c6adbcc9d6e61ffb4253f8979" translate="yes" xml:space="preserve">
          <source>Be aware that calling Sign with an attacker-controlled PrivateKey may require an arbitrary amount of CPU.</source>
          <target state="translated">공격자가 제어하는 ​​PrivateKey로 Sign을 호출하려면 임의의 양의 CPU가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a579e80e86d1e7d0159d880e6b8fbe6e97090888" translate="yes" xml:space="preserve">
          <source>Because Unmarshal uses the reflect package, it can only assign to exported (upper case) fields. Unmarshal uses a case-sensitive comparison to match XML element names to tag values and struct field names.</source>
          <target state="translated">Unmarshal은 reflect 패키지를 사용하므로 내 보낸 (대문자) 필드에만 할당 할 수 있습니다. 비 정렬 화는 대소 문자 구분 비교를 사용하여 XML 요소 이름을 태그 값 및 구조 필드 이름과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="523d61a0fa00dd823c410985160019d3fd2694f7" translate="yes" xml:space="preserve">
          <source>Because associated templates share underlying data, template construction cannot be done safely in parallel. Once the templates are constructed, they can be executed in parallel.</source>
          <target state="translated">연관된 템플릿은 기본 데이터를 공유하므로 템플릿 구성을 안전하게 병렬로 수행 할 수 없습니다. 템플릿이 구성되면 병렬로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48bfaadf8cd2cdc8bb489f610161c315416f443" translate="yes" xml:space="preserve">
          <source>Because c.L is not locked when Wait first resumes, the caller typically cannot assume that the condition is true when Wait returns. Instead, the caller should Wait in a loop:</source>
          <target state="translated">대기가 처음 재개 될 때 cL이 잠기지 않기 때문에 호출자는 일반적으로 대기가 리턴 될 때 조건이 참이라고 가정 할 수 없습니다. 대신, 호출자는 루프에서 대기해야합니다.</target>
        </trans-unit>
        <trans-unit id="c54914271c00fc66938747e3c3b7008bdc4689f3" translate="yes" xml:space="preserve">
          <source>Because compilation units can describe multiple regions of the executable, in the worst case SeekPC must search through all the ranges in all the compilation units. Each call to SeekPC starts the search at the compilation unit of the last call, so in general looking up a series of PCs will be faster if they are sorted. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index using the Ranges method.</source>
          <target state="translated">컴파일 단위는 실행 파일의 여러 영역을 설명 할 수 있으므로 최악의 경우 SeekPC는 모든 컴파일 단위의 모든 범위를 검색해야합니다. SeekPC에 대한 각 호출은 마지막 호출의 컴파일 단위에서 검색을 시작하므로 일반적으로 정렬 된 일련의 PC를 찾는 것이 더 빠릅니다. 발신자가 빠른 PC 검색을 반복하려면 Ranges 메서드를 사용하여 적절한 색인을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f624f6937df7b930caaacba36f0e003303314362" translate="yes" xml:space="preserve">
          <source>Because no call to Do returns until the one call to f returns, if f causes Do to be called, it will deadlock.</source>
          <target state="translated">f에 대한 한 번의 호출이 리턴 될 때까지 Do에 대한 호출이 리턴되지 않으므로 f가 Do를 호출하면 교착 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="10e6b41f775d08ce6bc91138d6c2ffbef503d1d6" translate="yes" xml:space="preserve">
          <source>Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.</source>
          <target state="translated">단조로운 시계 판독은 현재 프로세스 외부에서는 의미가 없으므로 t.GobEncode, t.MarshalBinary, t.MarshalJSON 및 t.MarshalText에 의해 생성 된 직렬화 된 양식은 단조로운 시계 판독을 생략하고 t.Format은 형식을 제공하지 않습니다. 마찬가지로 생성자 time.Date, time.Parse, time.ParseInLocation 및 time.Unix와 비 정렬 화자 t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON 및 t.UnmarshalText는 항상 단조로운 시계 판독없이 시간을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2931b27564afddbb3dd2ae5bab9920e7ef6ed41b" translate="yes" xml:space="preserve">
          <source>Because these interfaces and primitives wrap lower-level operations with various implementations, unless otherwise informed clients should not assume they are safe for parallel execution.</source>
          <target state="translated">이러한 인터페이스와 프리미티브는 다양한 구현으로 하위 수준 작업을 래핑하기 때문에 별도의 정보가없는 한 클라이언트는 병렬 실행에 안전하다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="35fcba4a31cbe45a039eaa4f4cccf00b01bffed2" translate="yes" xml:space="preserve">
          <source>Before Go 1.2, an InvalidUTF8Error was returned by Marshal when attempting to encode a string value with invalid UTF-8 sequences. As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by replacing invalid bytes with the Unicode replacement rune U+FFFD.</source>
          <target state="translated">Go 1.2 이전에는 유효하지 않은 UTF-8 시퀀스로 문자열 값을 인코딩하려고 할 때 Marshal이 InvalidUTF8Error를 반환했습니다. Go 1.2부터 Marshal은 대신 유효하지 않은 바이트를 유니 코드 대체 룬 U + FFFD로 대체하여 문자열을 유효한 UTF-8로 강제 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c73598333463e9f5f45d82a86c218e8031e1759c" translate="yes" xml:space="preserve">
          <source>Before calling UnlockOSThread, the caller must ensure that the OS thread is suitable for running other goroutines. If the caller made any permanent changes to the state of the thread that would affect other goroutines, it should not call this function and thus leave the goroutine locked to the OS thread until the goroutine (and hence the thread) exits.</source>
          <target state="translated">UnlockOSThread를 호출하기 전에 호출자는 OS 스레드가 다른 고 루틴을 실행하기에 적합한 지 확인해야합니다. 호출자가 다른 고 루틴에 영향을 미치는 스레드 상태를 영구적으로 변경 한 경우이 기능을 호출해서는 안되며 고 루틴 (및 스레드)이 종료 될 때까지 고 루틴을 OS 스레드에 고정시켜 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="c8e6ffc3c30540fb4fc792e9d4357fe97560a188" translate="yes" xml:space="preserve">
          <source>Before reports whether the time instant t is before u.</source>
          <target state="translated">Before는 시각 t가 u 이전인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="606149b36fd31d7cdbc22b8147b6e250b63644a8" translate="yes" xml:space="preserve">
          <source>Begin starts a transaction. The default isolation level is dependent on the driver.</source>
          <target state="translated">거래 시작 기본 격리 수준은 드라이버에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7cd63441add5782709d8f334b556a5c9fa7bdc37" translate="yes" xml:space="preserve">
          <source>BeginTx starts a transaction.</source>
          <target state="translated">BeginTx는 거래를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3207514bf6d3821c848dd10bdfa8d78bb40dcea3" translate="yes" xml:space="preserve">
          <source>Benchmark benchmarks a single function. It is useful for creating custom benchmarks that do not use the &quot;go test&quot; command.</source>
          <target state="translated">벤치 마크는 단일 기능을 벤치마킹합니다. &quot;go test&quot;명령을 사용하지 않는 사용자 정의 벤치 마크를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4f46ac72b3634f96c6860b1ed26d9d4cd71d21aa" translate="yes" xml:space="preserve">
          <source>Benchmarks</source>
          <target state="translated">Benchmarks</target>
        </trans-unit>
        <trans-unit id="595a85b5dfe37bb8ea10dd65bbf5df54240ef01f" translate="yes" xml:space="preserve">
          <source>BigEndian is the big-endian implementation of ByteOrder.</source>
          <target state="translated">BigEndian은 ByteOrder의 빅 엔디안 구현입니다.</target>
        </trans-unit>
        <trans-unit id="1a8e46c0c273a4b21db3dc88b0bc1fa8455576e3" translate="yes" xml:space="preserve">
          <source>Binary-Only Packages</source>
          <target state="translated">이진 전용 패키지</target>
        </trans-unit>
        <trans-unit id="cb0f451964a92b1951caeba948c48201789ad9ee" translate="yes" xml:space="preserve">
          <source>BinaryMarshaler is the interface implemented by an object that can marshal itself into a binary form.</source>
          <target state="translated">BinaryMarshaler는 바이너리 형식으로 마샬링 할 수있는 개체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8d76f4817cb16f671ca5aee534556905d021cc99" translate="yes" xml:space="preserve">
          <source>BinaryOp</source>
          <target state="translated">BinaryOp</target>
        </trans-unit>
        <trans-unit id="921645dac207c4f83f06bce30493a71396088bbe" translate="yes" xml:space="preserve">
          <source>BinaryOp returns the result of the binary expression x op y. The operation must be defined for the operands. If one of the operands is Unknown, the result is Unknown. BinaryOp doesn't handle comparisons or shifts; use Compare or Shift instead.</source>
          <target state="translated">BinaryOp는 이진 표현식 x op y의 결과를 반환합니다. 피연산자에 대한 작업을 정의해야합니다. 피연산자 중 하나가 알 수없는 경우 결과는 알 수 없습니다. BinaryOp는 비교 또는 이동을 처리하지 않습니다. 대신 비교 또는 Shift를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aadd7b0b0b5fb55d09fc3d06572f282dff2441a6" translate="yes" xml:space="preserve">
          <source>BinaryUnmarshaler is the interface implemented by an object that can unmarshal a binary representation of itself.</source>
          <target state="translated">BinaryUnmarshaler는 이진 표현 자체를 언 마샬링 할 수있는 객체로 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bbc8be299a236737ac4bcd6e0b8a8942dcf2d6e6" translate="yes" xml:space="preserve">
          <source>BindToDevice binds the socket associated with fd to device.</source>
          <target state="translated">BindToDevice는 fd와 관련된 소켓을 장치에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="16d18c58d40584999fc8105b9b042e87422089ab" translate="yes" xml:space="preserve">
          <source>Binomial sets z to the binomial coefficient of (n, k) and returns z.</source>
          <target state="translated">이항은 z를 이항 계수 (n, k)로 설정하고 z를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ddd24fa4c794f9b329dfacec18d2187e2964355" translate="yes" xml:space="preserve">
          <source>Bit returns the value of the i'th bit of x. That is, it returns (x&amp;gt;&amp;gt;i)&amp;amp;1. The bit index i must be &amp;gt;= 0.</source>
          <target state="translated">비트는 x의 i 번째 비트 값을 반환합니다. 즉, (x &amp;gt;&amp;gt; i) &amp;amp; 1을 반환합니다. 비트 인덱스 i는&amp;gt; = 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6bc8c103293d835982059015b02530a9dce7c7fe" translate="yes" xml:space="preserve">
          <source>BitLen returns the length of the absolute value of x in bits. The bit length of 0 is 0.</source>
          <target state="translated">BitLen은 x의 절대 값의 길이를 비트 단위로 반환합니다. 비트 길이 0은 0입니다.</target>
        </trans-unit>
        <trans-unit id="249f28fd5304db8d7893c5941b0e5c6d36dcae80" translate="yes" xml:space="preserve">
          <source>BitLen returns the number of bits required to represent the absolute value x in binary representation; x must be an Int or an Unknown. If x is Unknown, the result is 0.</source>
          <target state="translated">BitLen은 이진 표현으로 절대 값 x를 나타내는 데 필요한 비트 수를 반환합니다. x는 Int 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ecd1fdf628a58ae78c5a7dd496f33ee72ff11255" translate="yes" xml:space="preserve">
          <source>BitString is the structure to use when you want an ASN.1 BIT STRING type. A bit string is padded up to the nearest byte in memory and the number of valid bits is recorded. Padding bits will be zero.</source>
          <target state="translated">BitString은 ASN.1 BIT STRING 유형을 원할 때 사용할 구조입니다. 비트 문자열은 메모리에서 가장 가까운 바이트까지 채워지며 유효한 비트 수가 기록됩니다. 패딩 비트는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="9b86ce6cb2c2b41799ca1c79001b25b6a71ae1d0" translate="yes" xml:space="preserve">
          <source>Bits provides raw (unchecked but fast) access to x by returning its absolute value as a little-endian Word slice. The result and x share the same underlying array. Bits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.</source>
          <target state="translated">비트는 리틀 엔디안 워드 슬라이스로 절대 값을 반환하여 x에 대한 원시 (확인되지 ​​않았지만 빠른) 액세스를 제공합니다. 결과와 x는 동일한 기본 배열을 공유합니다. 비트는이 패키지 외부에서 누락 된 저수준 Int 기능의 구현을 지원하기위한 것입니다. 그렇지 않으면 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="8785e8d0d70df9ef411a1a99b4e2008220100ed8" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored. A line with only whitespace characters (excluding the ending newline character) is not considered a blank line.</source>
          <target state="translated">빈 줄은 무시됩니다. 공백 문자 만있는 행 (끝 줄 바꿈 문자 제외)은 빈 행으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab40b9553b86d8db879c49ff4725f0be1d518336" translate="yes" xml:space="preserve">
          <source>BlockProfile returns n, the number of records in the current blocking profile. If len(p) &amp;gt;= n, BlockProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, BlockProfile does not change p and returns n, false.</source>
          <target state="translated">BlockProfile은 현재 차단 프로필의 레코드 수인 n을 반환합니다. len (p)&amp;gt; = n 인 경우 BlockProfile은 프로파일을 p에 복사하고 n, true를 반환합니다. len (p) &amp;lt;n이면 BlockProfile은 p를 변경하지 않고 n을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ae50f5c12fe5e00104f9ffadf5daeabfcf4ed33" translate="yes" xml:space="preserve">
          <source>BlockProfileRecord describes blocking events originated at a particular call sequence (stack trace).</source>
          <target state="translated">BlockProfileRecord는 특정 호출 시퀀스 (스택 추적)에서 시작된 블로킹 이벤트를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="85ef7e3c2654f8573a1d7a67091280baf14e7241" translate="yes" xml:space="preserve">
          <source>Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag.</source>
          <target state="translated">Bool은 지정된 이름, 기본값 및 사용 문자열로 bool 플래그를 정의합니다. 반환 값은 플래그 값을 저장하는 부울 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="7e6896885d6315609679d245d2070ffe8fed4e1b" translate="yes" xml:space="preserve">
          <source>Bool is a ValueConverter that converts input values to bools.</source>
          <target state="translated">Bool은 입력 값을 bool로 변환하는 ValueConverter입니다.</target>
        </trans-unit>
        <trans-unit id="0fb9432e73dd047df304b2009b6c3b825667d954" translate="yes" xml:space="preserve">
          <source>Bool returns the value v as a bool. It panics if v is not a JavaScript boolean.</source>
          <target state="translated">Bool은 v 값을 bool로 반환합니다. v가 JavaScript 부울이 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="10b302964452c62c167d20c7d6a6eb54f65b9ba5" translate="yes" xml:space="preserve">
          <source>Bool returns v's underlying value. It panics if v's kind is not Bool.</source>
          <target state="translated">Bool은 v의 기본 값을 반환합니다. v의 종류가 Bool이 아닌 경우 공황 상태입니다.</target>
        </trans-unit>
        <trans-unit id="b37fb77c4eb8b7e67beea7dd6aa3c0cab362ce86" translate="yes" xml:space="preserve">
          <source>BoolNode holds a boolean constant.</source>
          <target state="translated">BoolNode는 부울 상수를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f8e8a6bce6cf09d8bab71de479256430c4f50e55" translate="yes" xml:space="preserve">
          <source>BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown. If x is Unknown, the result is false.</source>
          <target state="translated">BoolVal은 x의 Go 부울 값을 반환합니다. x는 Bool 또는 Unknown이어야합니다. x가 알 수없는 경우 결과는 false입니다.</target>
        </trans-unit>
        <trans-unit id="499f2e8136043fcef09799424f98d1389a945e55" translate="yes" xml:space="preserve">
          <source>BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.</source>
          <target state="translated">BoolVar는 지정된 이름, 기본값 및 사용 문자열로 bool 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 부울 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4b0e763b67dea569e511a23d06447d965f06236f" translate="yes" xml:space="preserve">
          <source>Boolean values encode as JSON booleans.</source>
          <target state="translated">부울 값은 JSON 부울로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9fa2ad669da3999136da1456c5f3ffdf720ead" translate="yes" xml:space="preserve">
          <source>Boolean:</source>
          <target state="translated">Boolean:</target>
        </trans-unit>
        <trans-unit id="ad90391bd80e58d8341d23f6811679989eed45ac" translate="yes" xml:space="preserve">
          <source>Boundary returns the Writer's boundary.</source>
          <target state="translated">경계는 작가의 경계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5dc9bacd4c58f9399b9dc87bc63dfb5fb7a6e59e" translate="yes" xml:space="preserve">
          <source>Bounds implements the Image interface.</source>
          <target state="translated">경계는 이미지 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="069d396f187de1e68cab3317f5cd2814eb7568af" translate="yes" xml:space="preserve">
          <source>BranchNode is the common representation of if, range, and with.</source>
          <target state="translated">BranchNode는 if, range 및 with의 일반적인 표현입니다.</target>
        </trans-unit>
        <trans-unit id="615bed871d5779af80e4a6136fa4239d3c7ccc9b" translate="yes" xml:space="preserve">
          <source>Breakpoint executes a breakpoint trap.</source>
          <target state="translated">중단 점은 중단 점 트랩을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="37081c9403a25124ca889860df85a0ae7029759e" translate="yes" xml:space="preserve">
          <source>Broadcast wakes all goroutines waiting on c.</source>
          <target state="translated">방송은 모든 고 루틴들을 기다리고있다 c.</target>
        </trans-unit>
        <trans-unit id="0abe955e9259954b391f714f51cf3c32c1931de6" translate="yes" xml:space="preserve">
          <source>Bswap32 returns its input with byte order reversed 0x01020304 -&amp;gt; 0x04030201</source>
          <target state="translated">Bswap32는 바이트 순서가 0x01020304-&amp;gt; 0x04030201로 반전 된 입력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71a400796b8b7bbe45d37b744a62ead19991004e" translate="yes" xml:space="preserve">
          <source>Bswap64 returns its input with byte order reversed 0x0102030405060708 -&amp;gt; 0x0807060504030201</source>
          <target state="translated">Bswap64는 바이트 순서가 0x0102030405060708-&amp;gt; 0x0807060504030201 인 바이트 순서로 입력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9309adffb005748ce6e64dc6b8674515cf4efae" translate="yes" xml:space="preserve">
          <source>Buf is where the traceback information should be stored. It should be PC values, such that Buf[0] is the PC of the caller, Buf[1] is the PC of that function's caller, and so on. Max is the maximum number of entries to store. The function should store a zero to indicate the top of the stack, or that the caller is on a different stack, presumably a Go stack.</source>
          <target state="translated">Buf는 역 추적 정보가 저장되는 곳입니다. Buf [0]은 호출자의 PC, Buf [1]은 해당 기능 호출자의 PC 등의 PC 값이어야합니다. Max는 저장할 최대 항목 수입니다. 이 함수는 스택의 상단을 나타내거나 호출자가 다른 스택, 아마도 Go 스택에 있음을 나타 내기 위해 0을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="448f56ed42119d7161dde9d81e02ab567a38fe41" translate="yes" xml:space="preserve">
          <source>Buffer (Reader)</source>
          <target state="translated">버퍼 (리더)</target>
        </trans-unit>
        <trans-unit id="cd5168b55c7b32a8963df048d61974c2aede7b92" translate="yes" xml:space="preserve">
          <source>Buffer panics if it is called after scanning has started.</source>
          <target state="translated">스캔이 시작된 후 호출되면 버퍼 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="551e1ba8b3e746ffe206860acb967584c81dae61" translate="yes" xml:space="preserve">
          <source>Buffer sets the initial buffer to use when scanning and the maximum size of buffer that may be allocated during scanning. The maximum token size is the larger of max and cap(buf). If max &amp;lt;= cap(buf), Scan will use this buffer only and do no allocation.</source>
          <target state="translated">버퍼는 스캔시 사용할 초기 버퍼 및 스캔 중에 할당 될 수있는 최대 버퍼 크기를 설정합니다. 최대 토큰 크기는 max 및 cap (buf)보다 큽니다. max &amp;lt;= cap (buf) 인 경우 Scan은이 버퍼 만 사용하며 할당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7fbc5efb24a4bec1ee1e0286f6eb89f2f88ad86" translate="yes" xml:space="preserve">
          <source>Buffer.Grow</source>
          <target state="translated">Buffer.Grow</target>
        </trans-unit>
        <trans-unit id="13e05f0025f22f2c210feebd6f6764eb9ab9107a" translate="yes" xml:space="preserve">
          <source>Buffer.Len</source>
          <target state="translated">Buffer.Len</target>
        </trans-unit>
        <trans-unit id="4d131002dacad1f34909e2d34d9e19d16cc5e060" translate="yes" xml:space="preserve">
          <source>Buffered returns a reader of the data remaining in the Decoder's buffer. The reader is valid until the next call to Decode.</source>
          <target state="translated">버퍼링은 디코더 버퍼에 남아있는 데이터의 리더를 반환합니다. 리더는 다음에 Decode를 호출 할 때까지 유효합니다.</target>
        </trans-unit>
        <trans-unit id="0067b3c63a56af4074505acb91d2a3cc9575fef4" translate="yes" xml:space="preserve">
          <source>Buffered returns the number of bytes that can be read from the current buffer.</source>
          <target state="translated">버퍼링은 현재 버퍼에서 읽을 수있는 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f08b0ea50ae1356e6e8d51780445d990cb02038" translate="yes" xml:space="preserve">
          <source>Buffered returns the number of bytes that have been written into the current buffer.</source>
          <target state="translated">버퍼링은 현재 버퍼에 기록 된 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f85a434187712878deb28e6a10ca19a4cff6a753" translate="yes" xml:space="preserve">
          <source>Buffers contains zero or more runs of bytes to write.</source>
          <target state="translated">버퍼에는 쓸 바이트가 0 개 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="921fab9f51565e1aa75ad1caac472a9aa9f26a82" translate="yes" xml:space="preserve">
          <source>Build Constraints</source>
          <target state="translated">구속 조건 구축</target>
        </trans-unit>
        <trans-unit id="29b9ebcad59c3ff5523927bf009e975e46078fb3" translate="yes" xml:space="preserve">
          <source>BuildInfo represents the build information read from the running binary.</source>
          <target state="translated">BuildInfo는 실행중인 바이너리에서 읽은 빌드 정보를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5041b9275852b56eabc2a8bc89d216f576ca59f5" translate="yes" xml:space="preserve">
          <source>BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates.</source>
          <target state="translated">BuildNameToCertificate 구문 분석 c. 각 리프 인증서의 CommonName 및 SubjectAlternateName 필드에서 c.Certificates 및 c.NameToCertificate를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="2d8e35a2ed18813e75b6cfe5be6d3b153d2c5046" translate="yes" xml:space="preserve">
          <source>By construction, a template may reside in only one association. If it's necessary to have a template addressable from multiple associations, the template definition must be parsed multiple times to create distinct *Template values, or must be copied with the Clone or AddParseTree method.</source>
          <target state="translated">구성에 따라 템플릿은 하나의 연결에만 상주 할 수 있습니다. 여러 연관에서 주소를 지정할 수있는 템플리트가 필요한 경우, 템플리트 정의를 여러 번 구문 분석하여 고유 한 * Template 값을 작성하거나 Clone 또는 AddParseTree 메소드로 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="480c13549e7a8a185af82bf79efe8d7146c55441" translate="yes" xml:space="preserve">
          <source>By convention, tag strings are a concatenation of optionally space-separated key:&quot;value&quot; pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 ' '), quote (U+0022 '&quot;'), and colon (U+003A ':'). Each value is quoted using U+0022 '&quot;' characters and Go string literal syntax.</source>
          <target state="translated">일반적으로 태그 문자열은 선택적으로 공백으로 구분 된 키 : &quot;값&quot;쌍으로 연결됩니다. 각 키는 공백 (U + 0020 ''), 따옴표 (U + 0022 ' &quot;') 및 콜론 (U + 003A ':') 이외의 비 제어 문자로 구성된 비어 있지 않은 문자열입니다. U + 0022 ' &quot;'문자 및 Go 문자열 리터럴 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6b96101ed175ff51ef271a9ec4e297e0ae19c127" translate="yes" xml:space="preserve">
          <source>By convention, to approximate the behavior of Unmarshal itself, Unmarshalers implement UnmarshalJSON([]byte(&quot;null&quot;)) as a no-op.</source>
          <target state="translated">원칙적으로 언 마샬 자체의 동작을 근사하기 위해 언 마셜 러는 UnmarshalJSON ([] byte ( &quot;null&quot;))을 no-op로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d97f2e29718cda70f3fb7a0b844b75e9e2a001df" translate="yes" xml:space="preserve">
          <source>By default the pure Go resolver is used, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement, and when the name being looked up ends in .local or is an mDNS name.</source>
          <target state="translated">차단 된 DNS 요청은 고 루틴 만 사용하고 차단 된 C 호출은 운영 체제 스레드를 사용하기 때문에 기본적으로 순수 Go 해결 프로그램이 사용됩니다. cgo를 사용할 수있는 경우 LOCALDOMAIN 환경 변수가 존재하는 경우 (비어 있더라도) 프로그램이 직접 DNS 요청 (OS X)을 수행 할 수없는 시스템에서 cgo 기반 리졸버는 다양한 조건에서 대신 사용됩니다. RES_OPTIONS 또는 HOSTALIASES 환경 변수가 비어 있지 않은 경우, ASR_CONFIG 환경 변수가 비어 있지 않은 경우 (OpenBSD에만 해당), /etc/resolv.conf 또는 /etc/nsswitch.conf가 Go 분석기가 구현하지 않는 기능의 사용을 지정할 때 , 검색중인 이름이 .local로 끝나거나 mDNS 이름 인 경우</target>
        </trans-unit>
        <trans-unit id="4d31c346123b01cd36d6f923e13afdff5da97023" translate="yes" xml:space="preserve">
          <source>By default, Scan uses an internal buffer and sets the maximum token size to MaxScanTokenSize.</source>
          <target state="translated">기본적으로 Scan은 내부 버퍼를 사용하고 최대 토큰 크기를 MaxScanTokenSize로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1bb42d4b5aeee71b81262969484c8ff70b4517be" translate="yes" xml:space="preserve">
          <source>By default, Transport caches connections for future re-use. This may leave many open connections when accessing many hosts. This behavior can be managed using Transport's CloseIdleConnections method and the MaxIdleConnsPerHost and DisableKeepAlives fields.</source>
          <target state="translated">기본적으로 전송은 나중에 재사용 할 수 있도록 연결을 캐시합니다. 많은 호스트에 액세스 할 때 열린 연결이 많이 남아있을 수 있습니다. 이 동작은 Transport의 CloseIdleConnections 메소드와 MaxIdleConnsPerHost 및 DisableKeepAlives 필드를 사용하여 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e73ecd4c55ac4f2532efca2acf286d276bfcb67b" translate="yes" xml:space="preserve">
          <source>By default, a Scanner skips white space and Go comments and recognizes all literals as defined by the Go language specification. It may be customized to recognize only a subset of those literals and to recognize different identifier and white space characters.</source>
          <target state="translated">기본적으로 스캐너는 공백과 Go 주석을 건너 뛰고 Go 언어 사양에 정의 된대로 모든 리터럴을 인식합니다. 이러한 리터럴의 일부만 인식하고 다른 식별자 및 공백 문자를 인식하도록 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c26436cbce7bb3819d63370d7d78fcf207cd25" translate="yes" xml:space="preserve">
          <source>By default, a synchronous signal is converted into a run-time panic. A SIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control). The SIGPROF signal is handled directly by the Go runtime to implement runtime.CPUProfile. Other signals will be caught but no action will be taken.</source>
          <target state="translated">기본적으로 동기 신호는 런타임 패닉으로 변환됩니다. SIGHUP, SIGINT 또는 SIGTERM 신호는 프로그램을 종료시킵니다. SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT 또는 SIGSYS 신호로 인해 프로그램이 스택 덤프와 함께 종료됩니다. SIGTSTP, SIGTTIN 또는 SIGTTOU 신호는 시스템 기본 동작을 얻습니다 (이러한 신호는 작업 제어를 위해 쉘에서 사용됨). SIGPROF 신호는 Go 런타임에서 직접 처리하여 runtime.CPUProfile을 구현합니다. 다른 신호는 포착되지만 조치는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3d4b30d09f1fdb49352c0d58298888cf0ca8985" translate="yes" xml:space="preserve">
          <source>By default, all text between actions is copied verbatim when the template is executed. For example, the string &quot; items are made of &quot; in the example above appears on standard output when the program is run.</source>
          <target state="translated">기본적으로 템플릿이 실행될 때 작업 사이의 모든 텍스트가 그대로 복사됩니다. 예를 들어, 위의 예에서 문자열 &quot;items are made&quot;는 프로그램이 실행될 때 표준 출력에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="350622d95bd495e5b9d5b12d5be7f36acd283530" translate="yes" xml:space="preserve">
          <source>By default, this package assumes that all pipelines produce a plain text string. It adds escaping pipeline stages necessary to correctly and safely embed that plain text string in the appropriate context.</source>
          <target state="translated">기본적으로이 패키지는 모든 파이프 라인이 일반 텍스트 문자열을 생성한다고 가정합니다. 일반 텍스트 문자열을 적절한 컨텍스트에 올 바르고 안전하게 포함시키는 데 필요한 탈출 파이프 라인 단계를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ac30c5fd81481adcf5dfadb9cc0286bdab9dd4d8" translate="yes" xml:space="preserve">
          <source>By setting the desired precision to 24 or 53 and using matching rounding mode (typically ToNearestEven), Float operations produce the same results as the corresponding float32 or float64 IEEE-754 arithmetic for operands that correspond to normal (i.e., not denormal) float32 or float64 numbers. Exponent underflow and overflow lead to a 0 or an Infinity for different values than IEEE-754 because Float exponents have a much larger range.</source>
          <target state="translated">원하는 정밀도를 24 또는 53으로 설정하고 일치하는 반올림 모드 (일반적으로 ToNearestEven)를 사용하여 Float 연산은 일반 (즉, 비정규 적이 지 않은) float32 또는 float64에 해당하는 피연산자에 해당하는 float32 또는 float64 IEEE-754 산술과 동일한 결과를 생성합니다. 번호. Float 지수의 범위가 훨씬 크기 때문에 지수 언더 플로 및 오버플로는 IEEE-754와 다른 값에 대해 0 또는 무한대로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="cae68a7a4d62320e833f932a1adb88cc3fca0834" translate="yes" xml:space="preserve">
          <source>ByteOrder (Get)</source>
          <target state="translated">바이트 순서 (가져 오기)</target>
        </trans-unit>
        <trans-unit id="14c268801cac113cc21be5f1d8e9a681909d9ffd" translate="yes" xml:space="preserve">
          <source>ByteOrder (Put)</source>
          <target state="translated">바이트 순서 (Put)</target>
        </trans-unit>
        <trans-unit id="47172c77b57631e39af011e8368ac1a798bc3c15" translate="yes" xml:space="preserve">
          <source>BytePtrFromString returns a pointer to a NUL-terminated array of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL).</source>
          <target state="translated">BytePtrFromString은 s의 텍스트를 포함하는 NUL 종료 바이트 배열에 대한 포인터를 리턴합니다. s가 임의의 위치에 NUL 바이트를 포함하면 (nil, EINVAL)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b67766bbc487c36c668f7c4b2ebbdd282b5f29af" translate="yes" xml:space="preserve">
          <source>ByteReader is the interface that wraps the ReadByte method.</source>
          <target state="translated">ByteReader는 ReadByte 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="cc79f8a24d7eacc319e8472097e4835f03446874" translate="yes" xml:space="preserve">
          <source>ByteScanner is the interface that adds the UnreadByte method to the basic ReadByte method.</source>
          <target state="translated">ByteScanner는 UnreadByte 메서드를 기본 ReadByte 메서드에 추가하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="cd18721ac61a79ca35c5cda1743e288f9c274dde" translate="yes" xml:space="preserve">
          <source>ByteSliceFromString returns a NUL-terminated slice of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL).</source>
          <target state="translated">ByteSliceFromString은 s의 텍스트를 포함하는 NUL로 끝나는 바이트 조각을 반환합니다. s가 임의의 위치에 NUL 바이트를 포함하면 (nil, EINVAL)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bff819ab0f5b5e1aa7cf8d780e4bca25b8ab6fb3" translate="yes" xml:space="preserve">
          <source>ByteWriter is the interface that wraps the WriteByte method.</source>
          <target state="translated">ByteWriter는 WriteByte 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8a463d6abf5a87eee5bdfdbd6797570bddff6553" translate="yes" xml:space="preserve">
          <source>Bytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like Read, Write, Reset, or Truncate). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads.</source>
          <target state="translated">바이트는 버퍼의 읽지 않은 부분을 보유하는 길이 b.Len ()의 슬라이스를 반환합니다. 슬라이스는 다음 버퍼 수정까지 (즉, 다음에 Read, Write, Reset 또는 Truncate와 같은 메서드를 호출 할 때까지)에만 사용할 수 있습니다. 슬라이스는 최소한 다음 버퍼 수정까지 버퍼 내용의 별칭을 지정하므로 슬라이스를 즉시 변경하면 향후 읽기 결과에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="2e50dca4afc19f02f1781881fca1454838a8fe54" translate="yes" xml:space="preserve">
          <source>Bytes returns the absolute value of x as a big-endian byte slice.</source>
          <target state="translated">바이트는 x의 절대 값을 빅 엔디안 바이트 슬라이스로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd81aa008eaca297f56d5d20be64044f3fd3dd37" translate="yes" xml:space="preserve">
          <source>Bytes returns the bytes for the absolute value of x in little- endian binary representation; x must be an Int.</source>
          <target state="translated">바이트는 리틀 엔디안 이진 표현으로 x의 절대 값에 대한 바이트를 반환합니다. x는 Int 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a4b934536111abb43c8416065329859723d67ab4" translate="yes" xml:space="preserve">
          <source>Bytes returns the data over which the index was created. It must not be modified.</source>
          <target state="translated">바이트는 인덱스가 생성 된 데이터를 반환합니다. 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1e205da73fdd6063e2f53de480b8d595a155bfc5" translate="yes" xml:space="preserve">
          <source>Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.</source>
          <target state="translated">바이트는 스캔 호출에 의해 생성 된 최신 토큰을 반환합니다. 기본 배열은 이후에 Scan을 호출하여 덮어 쓸 데이터를 가리킬 수 있습니다. 할당이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f37978f623b402dc557529380e27a17d5aab9e0" translate="yes" xml:space="preserve">
          <source>Bytes returns v's underlying value. It panics if v's underlying value is not a slice of bytes.</source>
          <target state="translated">바이트는 v의 기본 값을 반환합니다. v의 기본 값이 바이트 슬라이스가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf3cdb80980c06d234ad15ac8d6c7d4b17eb1c21" translate="yes" xml:space="preserve">
          <source>CAUTION: This interface does not support the import of locally vendored packages. See &lt;a href=&quot;https://golang.org/s/go15vendor&quot;&gt;https://golang.org/s/go15vendor&lt;/a&gt;. If possible, external implementations should implement ImporterFrom.</source>
          <target state="translated">주의 :이 인터페이스는 로컬로 공급 된 패키지 가져 오기를 지원하지 않습니다. &lt;a href=&quot;https://golang.org/s/go15vendor&quot;&gt;https://golang.org/s/go15vendor를&lt;/a&gt; 참조 하십시오 . 가능하면 외부 구현은 ImporterFrom을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab235f8b07aea6e23756b09920385103a680e3aa" translate="yes" xml:space="preserve">
          <source>CIDRMask</source>
          <target state="translated">CIDRMask</target>
        </trans-unit>
        <trans-unit id="610fd2d199248e3ae5def13e3d6ea752b04347c3" translate="yes" xml:space="preserve">
          <source>CIDRMask returns an IPMask consisting of `ones' 1 bits followed by 0s up to a total length of `bits' bits. For a mask of this form, CIDRMask is the inverse of IPMask.Size.</source>
          <target state="translated">CIDRMask는`1 '1 비트로 구성된 IPMask와`비트'비트의 총 길이까지 0을 리턴합니다. 이 형식의 마스크의 경우 CIDRMask는 IPMask.Size의 역입니다.</target>
        </trans-unit>
        <trans-unit id="977330e1b93f52c949bfe749d1c4a8ac402ce621" translate="yes" xml:space="preserve">
          <source>CMYK is an in-memory image whose At method returns color.CMYK values.</source>
          <target state="translated">CMYK는 At 메서드가 color.CMYK 값을 반환하는 메모리 내 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="5577b77166da8b8f97d578666c387cbb318d2199" translate="yes" xml:space="preserve">
          <source>CMYK represents a fully opaque CMYK color, having 8 bits for each of cyan, magenta, yellow and black.</source>
          <target state="translated">CMYK는 청록색, 자홍색, 노랑색 및 검은 색 각각에 대해 8 비트를 갖는 완전히 불투명 한 CMYK 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2f107458edf70d5d8784cc485af494c3ddf26bca" translate="yes" xml:space="preserve">
          <source>CMYKModel is the Model for CMYK colors.</source>
          <target state="translated">CMYKModel은 CMYK 색상의 모델입니다.</target>
        </trans-unit>
        <trans-unit id="1dcfe8b3871bde23c33a86fd34caf4ceb3d81b9c" translate="yes" xml:space="preserve">
          <source>CMYKToRGB converts a CMYK quadruple to an RGB triple.</source>
          <target state="translated">CMYKToRGB는 CMYK 쿼드 러플을 RGB 트리플로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cb4b09ded8668017a3d6bbb16fc8b707e98152f5" translate="yes" xml:space="preserve">
          <source>COFFSymbol represents single COFF symbol table record.</source>
          <target state="translated">COFFSymbol은 단일 COFF 기호 테이블 레코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3148d8e04fc6cddb8324aab7b41baaecb660939b" translate="yes" xml:space="preserve">
          <source>COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y).</source>
          <target state="translated">COffset은 (x, y)의 픽셀에 해당하는 Cb 또는 Cr의 첫 번째 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8c27dd514d68b447ad3ae459b747e2fe4297abc0" translate="yes" xml:space="preserve">
          <source>CPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed.</source>
          <target state="translated">CPU 프로파일 패닉. 이전에는 런타임에 의해 생성 된 pprof 형식 프로파일 청크에 대한 원시 액세스를 제공했습니다. 해당 형식 생성에 대한 세부 사항이 변경되었으므로이 기능이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="d070e9c40d008404324ad69f68a104813b438177" translate="yes" xml:space="preserve">
          <source>CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication mechanism as defined in RFC 2195. The returned Auth uses the given username and secret to authenticate to the server using the challenge-response mechanism.</source>
          <target state="translated">CRAMMD5Auth는 RFC 2195에 정의 된대로 CRAM-MD5 인증 메커니즘을 구현하는 Auth를 반환합니다. 반환 된 Auth는 지정된 사용자 이름과 비밀을 사용하여 챌린지 응답 메커니즘을 사용하여 서버를 인증합니다.</target>
        </trans-unit>
        <trans-unit id="745027bc41472d45980cddb096773a4f84ccc98d" translate="yes" xml:space="preserve">
          <source>CRTValue contains the precomputed Chinese remainder theorem values.</source>
          <target state="translated">CRTValue는 사전 계산 된 중국 나머지 정리 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f1fb1514db7c9527b7daa27065c1ccc1f41d7c4b" translate="yes" xml:space="preserve">
          <source>CSS encapsulates known safe content that matches any of:</source>
          <target state="translated">CSS는 다음 중 하나와 일치하는 알려진 안전한 콘텐츠를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="f92f25bf90673d8d059ee8d957be5d5aaa212a63" translate="yes" xml:space="preserve">
          <source>Call Next to advance the iterator, and Key/Value to access each entry. Next returns false when the iterator is exhausted. MapRange follows the same iteration semantics as a range statement.</source>
          <target state="translated">반복기를 진행하려면 다음을, 각 항목에 액세스하려면 키 / 값을 호출하십시오. 반복자가 소진되면 다음은 false를 반환합니다. MapRange는 range 문과 동일한 반복 시맨틱을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="118156dfe47c64304a43b6fe1ecd5f7d303a7bb3" translate="yes" xml:space="preserve">
          <source>Call calls the function v with the input arguments in. For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call panics if v's Kind is not Func. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values.</source>
          <target state="translated">호출은 입력 인수를 입력하여 함수 v를 호출합니다. 예를 들어, len (in) == 3 인 경우 v.Call (in)은 Go 호출 v (in [0], in [1], in [2])를 나타냅니다. . v 's Kind가 Func가 아닌 경우 패닉을 호출하십시오. 출력 결과를 값으로 리턴합니다. Go에서와 같이 각 입력 인수는 함수의 해당 입력 매개 변수 유형에 지정 가능해야합니다. v가 variadic 함수 인 경우 Call은 해당 값으로 복사하여 variadic slice 매개 변수 자체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6710d59342e8f6e8d403ac622a838f3bc147d96d" translate="yes" xml:space="preserve">
          <source>Call does a JavaScript call to the method m of value v with the given arguments. It panics if v has no method m. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">호출은 주어진 인수를 사용하여 값 v의 메소드 m에 대한 JavaScript 호출을 수행합니다. v에 메소드 m이 없으면 패닉이 발생합니다. 인수는 ValueOf 함수에 따라 JavaScript 값에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="565e55a0c32cf7eff3af3e89a785aa6c9178e700" translate="yes" xml:space="preserve">
          <source>Call invokes the named function, waits for it to complete, and returns its error status.</source>
          <target state="translated">호출은 명명 된 함수를 호출하고 완료 될 때까지 기다렸다가 오류 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53b636c9f40f5a663ef2162f73a7b02c6ae8df7a" translate="yes" xml:space="preserve">
          <source>Call represents an active RPC.</source>
          <target state="translated">호출은 활성 RPC를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="42512af352e3a9143ab5a1551cc60bc2ee819eb1" translate="yes" xml:space="preserve">
          <source>CallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)-1] to v's final variadic argument. For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...). CallSlice panics if v's Kind is not Func or if v is not variadic. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter.</source>
          <target state="translated">CallSlice는 입력 인수가있는 variadic 함수 v를 호출하여 슬라이스 in [len (in) -1]을 v의 최종 가변 변수 인수에 할당합니다. 예를 들어 len (in) == 3 인 경우 v.CallSlice (in)는 Go 호출 v (in [0], in [1], in [2] ...)를 나타냅니다. v의 종류가 Func가 아니거나 v가 가변적이지 않은 경우 CallSlice 패닉이 발생합니다. 출력 결과를 값으로 리턴합니다. Go에서와 같이 각 입력 인수는 함수의 해당 입력 매개 변수 유형에 지정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ccfaaae6e5365f5a9c5349e604bae17caa0cd30" translate="yes" xml:space="preserve">
          <source>Caller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller. (For historical reasons the meaning of skip differs between Caller and Callers.) The return values report the program counter, file name, and line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information.</source>
          <target state="translated">호출자는 호출 goroutine의 스택에서 함수 호출에 대한 파일 및 행 번호 정보를보고합니다. 인수 skip은 오름차순으로 스택 프레임 수이며 0은 호출자의 호출자를 식별합니다. 기록적인 이유로 건너 뛰기의 의미는 발신자와 발신자간에 다릅니다. 반환 값은 해당 호출의 파일 내에서 프로그램 카운터, 파일 이름 및 줄 번호를보고합니다. 정보를 복구 할 수없는 경우 부울 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="02ae9a5027491acdc64509b68ea3793e2a002174" translate="yes" xml:space="preserve">
          <source>Caller should close resp.Body when done reading from it.</source>
          <target state="translated">호출자는 읽은 후 resp.Body를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="03be0dfee4d9e39d0d117a1225a797fe3d2aa3a2" translate="yes" xml:space="preserve">
          <source>Callers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc.</source>
          <target state="translated">호출자는 호출 goroutine의 스택에서 함수 호출의 리턴 프로그램 카운터로 slice pc를 채 웁니다. 인수 skip은 pc에 기록하기 전에 건너 뛸 스택 프레임 수이며 0은 호출자 자신의 프레임을 식별하고 1은 호출자의 호출자를 식별합니다. pc에 기록 된 항목 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a4b4218d3232d882f79940537de8c89b5fd061d" translate="yes" xml:space="preserve">
          <source>Callers should always process the n &amp;gt; 0 bytes returned before considering the error err. Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors.</source>
          <target state="translated">호출자는 오류 err을 고려하기 전에 항상 리턴 된 n&amp;gt; 0 바이트를 처리해야합니다. 그렇게하면 일부 바이트와 허용 된 EOF 동작을 모두 읽은 후 발생하는 I / O 오류를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5500489165f32b46a8cb2a14a955f9a8a8615079" translate="yes" xml:space="preserve">
          <source>Callers that wish to set the fields in Writer.Header must do so before the first call to Write, Flush, or Close.</source>
          <target state="translated">Writer.Header에서 필드를 설정하려는 호출자는 Write, Flush 또는 Close를 처음 호출하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b857a35e7ef780b3bca39a750115fc4863a61aa5" translate="yes" xml:space="preserve">
          <source>CallersFrames takes a slice of PC values returned by Callers and prepares to return function/file/line information. Do not change the slice until you are done with the Frames.</source>
          <target state="translated">CallersFrames는 호출자가 반환 한 PC 값 조각을 가져와 함수 / 파일 / 라인 정보를 반환하도록 준비합니다. 프레임이 완성 될 때까지 슬라이스를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a84e46e9c20e9e9bc4eb917cab523be97fdefd53" translate="yes" xml:space="preserve">
          <source>Calling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutines. If all other goroutines exit, the program crashes.</source>
          <target state="translated">메인 goroutine에서 Goexit를 호출하면 func main return없이 해당 goroutine을 종료합니다. func main이 리턴되지 않았으므로 프로그램은 다른 goroutines의 실행을 계속합니다. 다른 모든 고 루틴이 종료되면 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="dc5490ba97b9e986ad10d279577e4999816c63b0" translate="yes" xml:space="preserve">
          <source>Calling Multistream(false) disables this behavior; disabling the behavior can be useful when reading file formats that distinguish individual gzip data streams or mix gzip data streams with other data streams. In this mode, when the Reader reaches the end of the data stream, Read returns io.EOF. The underlying reader must implement io.ByteReader in order to be left positioned just after the gzip stream. To start the next stream, call z.Reset(r) followed by z.Multistream(false). If there is no next stream, z.Reset(r) will return io.EOF.</source>
          <target state="translated">Multistream (false)을 호출하면이 동작이 비활성화됩니다. 이 동작을 비활성화하면 개별 gzip 데이터 스트림을 구별하거나 gzip 데이터 스트림을 다른 데이터 스트림과 혼합하는 파일 형식을 읽을 때 유용 할 수 있습니다. 이 모드에서 Reader가 데이터 스트림의 끝에 도달하면 Read는 io.EOF를 반환합니다. 기본 Zip은 gzip 스트림 바로 뒤에 배치되도록 io.ByteReader를 구현해야합니다. 다음 스트림을 시작하려면 z.Reset (r) 다음에 z.Multistream (false)을 호출하십시오. 다음 스트림이 없으면 z.Reset (r)은 io.EOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4710fe1acfac37179ab4f289d05ef3abb75eaede" translate="yes" xml:space="preserve">
          <source>Calling Peek prevents a UnreadByte or UnreadRune call from succeeding until the next read operation.</source>
          <target state="translated">Peek 호출은 다음 읽기 작업까지 UnreadByte 또는 UnreadRune 호출이 성공하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="fdec16c5797808f1fc79d6af2ca8ac766041238a" translate="yes" xml:space="preserve">
          <source>Calling Read on special types like TypeLink, TypeSymlink, TypeChar, TypeBlock, TypeDir, and TypeFifo returns (0, io.EOF) regardless of what the Header.Size claims.</source>
          <target state="translated">TypeLink, TypeSymlink, TypeChar, TypeBlock, TypeDir 및 TypeFifo와 같은 특수 유형에 대한 읽기는 Header.Size 주장에 관계없이 (0, io.EOF)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b56745d4818c01d2eb9c7bc08a036418118904a0" translate="yes" xml:space="preserve">
          <source>Calling Write on special types like TypeLink, TypeSymlink, TypeChar, TypeBlock, TypeDir, and TypeFifo returns (0, ErrWriteTooLong) regardless of what the Header.Size claims.</source>
          <target state="translated">TypeLink, TypeSymlink, TypeChar, TypeBlock, TypeDir 및 TypeFifo와 같은 특수 유형에 대한 쓰기 호출은 Header.Size 주장에 관계없이 (0, ErrWriteTooLong)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f4fdb7a85ec6970a8fd4027def05274bf398ff4" translate="yes" xml:space="preserve">
          <source>Calls to Scan will invoke the error handler err if they encounter a syntax error and err is not nil. Also, for each error encountered, the Scanner field ErrorCount is incremented by one. The mode parameter determines how comments are handled.</source>
          <target state="translated">스캔 호출은 구문 오류가 발생하고 오류가 nil이 아닌 경우 오류 핸들러 오류를 호출합니다. 또한 발생한 각 오류에 대해 스캐너 필드 ErrorCount는 1 씩 증가합니다. mode 매개 변수는 주석 처리 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9520d1b14d042e07c9d98804cc798cd3d2a5e80a" translate="yes" xml:space="preserve">
          <source>CanAddr reports whether the value's address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.</source>
          <target state="translated">CanAddr은 Addr로 값의 주소를 얻을 수 있는지보고합니다. 이러한 값을 주소 지정 가능이라고합니다. 슬라이스의 요소, 주소 지정 가능한 배열의 요소, 주소 지정 가능한 구조체의 필드 또는 포인터 역 참조 결과 인 경우 값을 지정할 수 있습니다. CanAddr이 false를 반환하면 Addr을 호출하면 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="a9e93f69f0267b95bffc55cf6d2bce8ffc82c90c" translate="yes" xml:space="preserve">
          <source>CanBackquote</source>
          <target state="translated">CanBackquote</target>
        </trans-unit>
        <trans-unit id="4e3695d8bbea64e7cfee0c2febc4baffda231b85" translate="yes" xml:space="preserve">
          <source>CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab.</source>
          <target state="translated">CanBackquote는 문자열 이외의 문자열을 탭 이외의 제어 문자없이 한 줄의 역 따옴표 문자열로 표시 할 수 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="78221e784584f0078bc92b5760d985ffb9359714" translate="yes" xml:space="preserve">
          <source>CanInterface reports whether Interface can be used without panicking.</source>
          <target state="translated">CanInterface는 당황하지 않고 인터페이스를 사용할 수 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a4cf39f0aa0cf531b70a8777365e8930d66ae49b" translate="yes" xml:space="preserve">
          <source>CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic.</source>
          <target state="translated">CanSet은 v 값을 변경할 수 있는지 여부를보고합니다. 값은 주소 지정 가능하고 내 보내지 않은 구조체 필드를 사용하여 얻지 못한 경우에만 변경할 수 있습니다. CanSet이 false를 반환하면 Set 또는 모든 유형별 setter (예 : SetBool, SetInt)를 호출하면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="24a49319ca493616d5fa4fa87e1716f05207717f" translate="yes" xml:space="preserve">
          <source>CancelRequest cancels an in-flight request by closing its connection. CancelRequest should only be called after RoundTrip has returned.</source>
          <target state="translated">CancelRequest는 연결을 닫아 기내 요청을 취소합니다. CancelRequest는 RoundTrip이 반환 된 후에 만 ​​호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="d04bdcea13bcd3bdd6348c2940648b9b6511c540" translate="yes" xml:space="preserve">
          <source>Canceled is the error returned by Context.Err when the context is canceled.</source>
          <target state="translated">취소는 컨텍스트가 취소 될 때 Context.Err에 의해 리턴 된 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1e7f338b3f2968bf411cdc0aae8bcbdbfc36af1f" translate="yes" xml:space="preserve">
          <source>Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete.</source>
          <target state="translated">이 컨텍스트를 취소하면 이와 관련된 리소스가 해제되므로이 컨텍스트에서 실행중인 작업이 완료되는 즉시 코드에서 cancel을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2af769757a430f4dad8d1af9ff5c57b16b4ebdd" translate="yes" xml:space="preserve">
          <source>Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this Context complete:</source>
          <target state="translated">이 컨텍스트를 취소하면 이와 관련된 리소스가 해제되므로이 컨텍스트에서 실행중인 작업이 완료되는 즉시 코드에서 cancel을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="076b17958a05cb472fa64e406ea55e8b9d2a4270" translate="yes" xml:space="preserve">
          <source>Canon returns the canonical version of r. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.</source>
          <target state="translated">Canon은 정식 버전의 r을 반환합니다. 반환 된 사각형에는 필요한 경우 올바른 최소값과 최대 좌표가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="955b396a548b98a7408f3e25b749827717df449d" translate="yes" xml:space="preserve">
          <source>CanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for &quot;accept-encoding&quot; is &quot;Accept-Encoding&quot;. If s contains a space or invalid header field bytes, it is returned without modifications.</source>
          <target state="translated">CanonicalHeaderKey는 헤더 키의 표준 형식을 반환합니다. 정규화는 첫 번째 문자와 하이픈 뒤의 모든 문자를 대문자로 변환합니다. 나머지는 소문자로 변환됩니다. 예를 들어, &quot;accept-encoding&quot;에 대한 표준 키는 &quot;Accept-Encoding&quot;입니다. s에 공백 또는 유효하지 않은 헤더 필드 바이트가 포함되어 있으면 수정없이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2b23fb17a1a69fd7b73a76bb40a7097d29243e47" translate="yes" xml:space="preserve">
          <source>CanonicalMIMEHeaderKey returns the canonical format of the MIME header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for &quot;accept-encoding&quot; is &quot;Accept-Encoding&quot;. MIME header keys are assumed to be ASCII only. If s contains a space or invalid header field bytes, it is returned without modifications.</source>
          <target state="translated">CanonicalMIMEHeaderKey는 MIME 헤더 키의 표준 형식을 반환합니다. 정규화는 첫 번째 문자와 하이픈 뒤의 모든 문자를 대문자로 변환합니다. 나머지는 소문자로 변환됩니다. 예를 들어, &quot;accept-encoding&quot;에 대한 표준 키는 &quot;Accept-Encoding&quot;입니다. MIME 헤더 키는 ASCII로만 가정됩니다. s에 공백 또는 유효하지 않은 헤더 필드 바이트가 포함되어 있으면 수정없이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed0ee546d9c8e677c59e62830ae730eb46232fdc" translate="yes" xml:space="preserve">
          <source>Cap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data.</source>
          <target state="translated">Cap은 버퍼의 기본 바이트 슬라이스 용량, 즉 버퍼 데이터에 할당 된 총 공간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bbc6d32f023dd61bfc5cebe3046b61c0f76810e0" translate="yes" xml:space="preserve">
          <source>Cap returns the capacity of the builder's underlying byte slice. It is the total space allocated for the string being built and includes any bytes already written.</source>
          <target state="translated">Cap은 빌더의 기본 바이트 슬라이스 용량을 리턴합니다. 빌드중인 문자열에 할당 된 총 공간이며 이미 작성된 바이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ee5354b348838f7a1d94dcdaae1e7a7ecd556f4c" translate="yes" xml:space="preserve">
          <source>Cap returns v's capacity. It panics if v's Kind is not Array, Chan, or Slice.</source>
          <target state="translated">Cap은 v의 용량을 반환합니다. v의 Kind가 Array, Chan 또는 Slice가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6a561977254ff2870059baae45cac89214e315f" translate="yes" xml:space="preserve">
          <source>CapNames walks the regexp to find the names of capturing groups.</source>
          <target state="translated">CapNames는 정규 표현식을 따라 캡처 그룹의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6f9517c836ce60929e990358e7eb6e0b2e9fdc68" translate="yes" xml:space="preserve">
          <source>Carriage returns before newline characters are silently removed.</source>
          <target state="translated">줄 바꿈 문자가 자동으로 제거되기 전에 캐리지가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="be2bf5b72a47b7c7e2283e70ea0cf31afd8bde9b" translate="yes" xml:space="preserve">
          <source>CaseRange represents a range of Unicode code points for simple (one code point to one code point) case conversion. The range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas are the number to add to the code point to reach the code point for a different case for that character. They may be negative. If zero, it means the character is in the corresponding case. There is a special case representing sequences of alternating corresponding Upper and Lower pairs. It appears with a fixed Delta of</source>
          <target state="translated">CaseRange는 간단한 (1 코드 포인트에서 1 코드 포인트로) 사례 변환을위한 유니 코드 코드 포인트 범위를 나타냅니다. 범위는 고정 보폭이 1 인 Lo부터 Hi까지입니다. 델타는 해당 문자의 다른 경우에 대해 코드 포인트에 도달하기 위해 코드 포인트에 추가 할 숫자입니다. 부정적 일 수 있습니다. 0이면 문자가 해당하는 경우임을 의미합니다. 상응하는 상위 및 하위 쌍의 시퀀스를 나타내는 특별한 경우가 있습니다. 고정 델타가</target>
        </trans-unit>
        <trans-unit id="0242bb8f76d24fc855f5fd331326f647ebd09abb" translate="yes" xml:space="preserve">
          <source>CaseRanges is the table describing case mappings for all letters with non-self mappings.</source>
          <target state="translated">CaseRanges는 자체 매핑이 아닌 모든 문자의 사례 매핑을 설명하는 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="3b206a07c1e9d49addcc7990e688904da778cacb" translate="yes" xml:space="preserve">
          <source>Categories is the set of Unicode category tables.</source>
          <target state="translated">Categories는 유니 코드 범주 테이블 집합입니다.</target>
        </trans-unit>
        <trans-unit id="e587577dc59bfafa8f316d5453515821dcbce5ea" translate="yes" xml:space="preserve">
          <source>Cbrt returns the cube root of x.</source>
          <target state="translated">Cbrt는 x의 세제곱근을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2432d530c0145aab3bfa5662975e8d421e122d9e" translate="yes" xml:space="preserve">
          <source>Ceil</source>
          <target state="translated">Ceil</target>
        </trans-unit>
        <trans-unit id="46536626864b36557258c2a5e53e6d4465979040" translate="yes" xml:space="preserve">
          <source>Ceil returns the least integer value greater than or equal to x.</source>
          <target state="translated">Ceil은 x보다 크거나 같은 최소 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67d301941e6984f09b404c3b5e5d0192a1b67ac6" translate="yes" xml:space="preserve">
          <source>CertPool is a set of certificates.</source>
          <target state="translated">CertPool은 일련의 인증서입니다.</target>
        </trans-unit>
        <trans-unit id="2ede2f55f16b28db355480b3a24e5f428305766b" translate="yes" xml:space="preserve">
          <source>Certificate returns the certificate used by the server, or nil if the server doesn't use TLS.</source>
          <target state="translated">인증서는 서버에서 사용 된 인증서를 반환하거나 서버가 TLS를 사용하지 않으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed0353f9bd9f8fff93bbda397f0df68cf8c98c19" translate="yes" xml:space="preserve">
          <source>Certificate.Verify</source>
          <target state="translated">Certificate.Verify</target>
        </trans-unit>
        <trans-unit id="b24b78d8382125c2a275a4ff2231b6b38a8636ed" translate="yes" xml:space="preserve">
          <source>CertificateInvalidError results when an odd error occurs. Users of this library probably want to handle all these errors uniformly.</source>
          <target state="translated">홀수 오류가 발생하면 CertificateInvalidError가 발생합니다. 이 라이브러리의 사용자는 이러한 모든 오류를 균일하게 처리하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4be4f43abf6e2f39e81e91b60f959656ba9b756e" translate="yes" xml:space="preserve">
          <source>CertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the signature.</source>
          <target state="translated">CertificateList는 같은 이름의 ASN.1 구조를 나타냅니다. RFC 5280, 섹션 5.1을 참조하십시오. Certificate.CheckCRLSignature를 사용하여 서명을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a288f637c3c9d1d271c3c19c56590c8c85a0eb17" translate="yes" xml:space="preserve">
          <source>CertificateRequest represents a PKCS #10, certificate signature request.</source>
          <target state="translated">CertificateRequest는 PKCS # 10, 인증서 서명 요청을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2950fae6302110dd8a52ed33e4c5f6542549cb2f" translate="yes" xml:space="preserve">
          <source>CertificateRequestInfo contains information from a server's CertificateRequest message, which is used to demand a certificate and proof of control from a client.</source>
          <target state="translated">CertificateRequestInfo에는 서버의 CertificateRequest 메시지 정보가 포함되어 있는데,이 정보는 인증서와 클라이언트의 제어 증명을 요구하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec50387142af3be963c7121f78293d51ce51206a" translate="yes" xml:space="preserve">
          <source>ChainNode holds a term followed by a chain of field accesses (identifier starting with '.'). The names may be chained ('.x.y'). The periods are dropped from each ident.</source>
          <target state="translated">ChainNode에는 용어 뒤에 필드 체인 액세스 ( '.'로 시작하는 식별자)가 있습니다. 이름은 연결될 수 있습니다 ( '.x.y'). 각 ID에서 기간이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="41142232bdd3270941be56093eead521d6e00ed0" translate="yes" xml:space="preserve">
          <source>ChanDir represents a channel type's direction.</source>
          <target state="translated">ChanDir은 채널 유형의 방향을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d71e228872d9403c9b6594fd69625436645be6ba" translate="yes" xml:space="preserve">
          <source>ChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents &amp;lt;-chan int.</source>
          <target state="translated">ChanOf는 주어진 방향과 요소 유형을 가진 채널 유형을 반환합니다. 예를 들어, t가 int를 나타내는 경우 ChanOf (RecvDir, t)는 &amp;lt;-chan int를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b34ef43c1dc118fd5f3dd2ddc7f7e9e87461df60" translate="yes" xml:space="preserve">
          <source>Changing the behavior of signals in Go programs</source>
          <target state="translated">Go 프로그램에서 신호 동작 변경</target>
        </trans-unit>
        <trans-unit id="b5d17f750ce0c90b1d8f2246a376b4e9bb0451a7" translate="yes" xml:space="preserve">
          <source>Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError.</source>
          <target state="translated">채널, 복합 및 함수 값은 JSON으로 인코딩 할 수 없습니다. 이러한 값을 인코딩하려고하면 Marshal이 UnsupportedTypeError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d81d4ef28354031a16bbd07dbbe84ad7e58f4aef" translate="yes" xml:space="preserve">
          <source>Character class elements:</source>
          <target state="translated">캐릭터 클래스 요소 :</target>
        </trans-unit>
        <trans-unit id="9253fc85685075e92fb2c2cb576e68b41cb8633e" translate="yes" xml:space="preserve">
          <source>Chdir changes the current working directory to the file, which must be a directory. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Chdir은 현재 작업 디렉토리를 파일로 변경합니다.이 파일은 디렉토리 여야합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b9f7b1c8f8ac2861de3e2acab3384aee64fee3f5" translate="yes" xml:space="preserve">
          <source>Chdir changes the current working directory to the named directory. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Chdir은 현재 작업 디렉토리를 명명 된 디렉토리로 변경합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="dcb27e63c2fbdba64841ab2910051fa4a2c3f8f9" translate="yes" xml:space="preserve">
          <source>Check looks for an input to f, any function that returns bool, such that f returns false. It calls f repeatedly, with arbitrary values for each argument. If f returns false on a given input, Check returns that input as a *CheckError. For example:</source>
          <target state="translated">Check는 f에 대한 입력을 찾습니다. f를 false로 반환하는 bool을 반환하는 함수입니다. 각 인수에 대해 임의의 값을 사용하여 f를 반복적으로 호출합니다. 주어진 입력에서 f가 false를 반환하면 Check는 해당 입력을 * CheckError로 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a85aadfcc5e9ea6b8907d6a9f8e98f8accc3fc5" translate="yes" xml:space="preserve">
          <source>Check type-checks a package and returns the resulting package object and the first error if any. Additionally, if info != nil, Check populates each of the non-nil maps in the Info struct.</source>
          <target state="translated">검사는 패키지를 검사하고 결과 패키지 개체와 첫 번째 오류 (있는 경우)를 반환합니다. 또한 info! = nil 인 경우 Check는 Info 구조체에서 각각의 넌이 아닌 맵을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="6d67e1187d47640f702b28a10cc6f53a307ae234" translate="yes" xml:space="preserve">
          <source>CheckCRLSignature checks that the signature in crl is from c.</source>
          <target state="translated">CheckCRLSignature는 crl의 서명이 c의 서명인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f93ce303d817100b6d50ba51e9c0c4c774a0a092" translate="yes" xml:space="preserve">
          <source>CheckEqual looks for an input on which f and g return different results. It calls f and g repeatedly with arbitrary values for each argument. If f and g return different answers, CheckEqual returns a *CheckEqualError describing the input and the outputs.</source>
          <target state="translated">CheckEqual은 f와 g가 다른 결과를 반환하는 입력을 찾습니다. 각 인수에 대해 임의의 값으로 f와 g를 반복해서 호출합니다. f와 g가 다른 응답을 반환하면 CheckEqual은 입력과 출력을 설명하는 * CheckEqualError를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56c96020e004e0f968e6f808827a8f0ef9a0f959" translate="yes" xml:space="preserve">
          <source>CheckExpr type checks the expression expr as if it had appeared at position pos of package pkg. Type information about the expression is recorded in info.</source>
          <target state="translated">CheckExpr 유형은 표현식 expr이 패키지 pkg의 위치 pos에 나타난 것처럼 확인합니다. 식에 대한 유형 정보는 info에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="3afa858fd88c383b05b45b059da6d700c31f62d0" translate="yes" xml:space="preserve">
          <source>CheckSignature reports whether the signature on c is valid.</source>
          <target state="translated">CheckSignature는 c의 서명이 유효한지보고합니다.</target>
        </trans-unit>
        <trans-unit id="b028d2f26cf8934255900c683e9051aaedadc107" translate="yes" xml:space="preserve">
          <source>CheckSignature verifies that signature is a valid signature over signed from c's public key.</source>
          <target state="translated">CheckSignature는 서명이 c의 공개 키에서 서명 된 유효한 서명인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5f1469e6f7aeb717fe6fd2a8ee3f4b0eb8bea924" translate="yes" xml:space="preserve">
          <source>CheckSignatureFrom verifies that the signature on c is a valid signature from parent.</source>
          <target state="translated">CheckSignatureFrom은 c의 서명이 부모의 유효한 서명인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cf0a25d9a79670b543c8f6d54e561382ee2327c8" translate="yes" xml:space="preserve">
          <source>Checksum returns the Adler-32 checksum of data.</source>
          <target state="translated">체크섬은 Adler-32 데이터 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77add3d3bab3db380a97be8fd992a744496e9205" translate="yes" xml:space="preserve">
          <source>Checksum returns the CRC-32 checksum of data using the polynomial represented by the Table.</source>
          <target state="translated">체크섬은 표로 표시된 다항식을 사용하여 데이터의 CRC-32 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="35a88a5d5ae4a4db8d25e096b438fe712928f70b" translate="yes" xml:space="preserve">
          <source>Checksum returns the CRC-64 checksum of data using the polynomial represented by the Table.</source>
          <target state="translated">체크섬은 표로 표시된 다항식을 사용하여 데이터의 CRC-64 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cefd992ce8689aa4a5e8a938343def9a5adb2161" translate="yes" xml:space="preserve">
          <source>ChecksumIEEE returns the CRC-32 checksum of data using the IEEE polynomial.</source>
          <target state="translated">ChecksumIEEE는 IEEE 다항식을 사용하여 데이터의 CRC-32 체크섬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2274ec5f679712a687a101a1f53de838aacd04a3" translate="yes" xml:space="preserve">
          <source>Child returns the i'th child scope for 0 &amp;lt;= i &amp;lt; NumChildren().</source>
          <target state="translated">Child는 0 &amp;lt;= i &amp;lt;NumChildren ()에 대한 i 번째 하위 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72a2cf7fd19dd78efb6d310d1146546965c630cd" translate="yes" xml:space="preserve">
          <source>Chmod</source>
          <target state="translated">Chmod</target>
        </trans-unit>
        <trans-unit id="54381b37df415f17ee19fa61fb2c262ae4bffd97" translate="yes" xml:space="preserve">
          <source>Chmod changes the mode of the file to mode. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Chmod는 파일 모드를 mode로 변경합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ae20e5d14b6f7b19f0570009a48263e1096ec5dd" translate="yes" xml:space="preserve">
          <source>Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Chmod는 명명 된 파일의 모드를 mode로 변경합니다. 파일이 심볼릭 링크 인 경우 링크 대상 모드가 변경됩니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c345fc1bf8f6407d62f187432fbbc92a5cd52616" translate="yes" xml:space="preserve">
          <source>Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Chown은 명명 된 파일의 숫자 uid와 gid를 변경합니다. 파일이 심볼릭 링크 인 경우 링크 대상의 uid 및 gid가 변경됩니다. uid 또는 gid -1은 해당 값을 변경하지 않음을 의미합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d15192f283b6552c623863f471ea76b78149f1dd" translate="yes" xml:space="preserve">
          <source>Chown changes the numeric uid and gid of the named file. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Chown은 명명 된 파일의 숫자 uid와 gid를 변경합니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3501f50820f444e076a0c8ebd0137aa20f349607" translate="yes" xml:space="preserve">
          <source>Chtimes</source>
          <target state="translated">Chtimes</target>
        </trans-unit>
        <trans-unit id="74fad201512b306ebb341d1f65416d99588ec73b" translate="yes" xml:space="preserve">
          <source>Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions.</source>
          <target state="translated">Chtimes는 Unix utime () 또는 utimes () 함수와 유사하게 명명 된 파일의 액세스 및 수정 시간을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d1b2218514bfbf9d096fe76cc6d68997cdfcde1d" translate="yes" xml:space="preserve">
          <source>Class is found in Header.Ident[EI_CLASS] and Header.Class.</source>
          <target state="translated">클래스는 Header.Ident [EI_CLASS] 및 Header.Class에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa893d87e1fa0a69c7942dd1e65f3bd1932e53d1" translate="yes" xml:space="preserve">
          <source>Clean</source>
          <target state="translated">Clean</target>
        </trans-unit>
        <trans-unit id="c505b06ae1e4508892a4d23e86b20501c6b00af4" translate="yes" xml:space="preserve">
          <source>Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:</source>
          <target state="translated">Clean은 순수 어휘 처리를 통해 경로와 동등한 최단 경로 이름을 반환합니다. 추가 처리를 수행 할 수 없을 때까지 다음 규칙을 반복해서 적용합니다.</target>
        </trans-unit>
        <trans-unit id="15d1092fa425ad399701105f3ee2808a7d89faf5" translate="yes" xml:space="preserve">
          <source>Clearenv deletes all environment variables.</source>
          <target state="translated">Clearenv는 모든 환경 변수를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="1b3b0b991a98add944cc0471a5856e4b7e7dfe62" translate="yes" xml:space="preserve">
          <source>Client represents an RPC Client. There may be multiple outstanding Calls associated with a single Client, and a Client may be used by multiple goroutines simultaneously.</source>
          <target state="translated">클라이언트는 RPC 클라이언트를 나타냅니다. 단일 고객과 관련된 미결제 통화가 여러 개있을 수 있으며 여러 고 루틴이 동시에 클라이언트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50cd2d3f91314c6d5d9767c58d2189bde9c3a214" translate="yes" xml:space="preserve">
          <source>Client returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config.</source>
          <target state="translated">클라이언트는 conn을 기본 전송으로 사용하여 새 TLS 클라이언트 측 연결을 반환합니다. 구성은 nil 일 수 없습니다. 사용자는 구성에서 ServerName 또는 InsecureSkipVerify를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1829d60c1d2d2fa9fd020c834b748c41d1074494" translate="yes" xml:space="preserve">
          <source>Client returns an HTTP client configured for making requests to the server. It is configured to trust the server's TLS test certificate and will close its idle connections on Server.Close.</source>
          <target state="translated">클라이언트는 서버에 요청하도록 구성된 HTTP 클라이언트를 리턴합니다. 서버의 TLS 테스트 인증서를 신뢰하도록 구성되었으며 Server.Close에서 유휴 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e4498f52d7e616076230ca8a01a4098528505216" translate="yes" xml:space="preserve">
          <source>ClientAuthType declares the policy the server will follow for TLS Client Authentication.</source>
          <target state="translated">ClientAuthType은 서버가 TLS 클라이언트 인증을 위해 따르는 정책을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="3619c3780ec5f3cb596f3b3c80136fe6cc01cadb" translate="yes" xml:space="preserve">
          <source>ClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">ClientConn은 Go의 초기 HTTP 구현의 인공물입니다. Go의 현재 HTTP 스택에서 저수준이며 오래되었으며 사용되지 않습니다. Go 1 전에 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="20d2d94a50bd23a9f13836749a81ece303a954e6" translate="yes" xml:space="preserve">
          <source>ClientHelloInfo contains information from a ClientHello message in order to guide certificate selection in the GetCertificate callback.</source>
          <target state="translated">ClientHelloInfo는 GetCertificate 콜백에서 인증서 선택을 안내하기 위해 ClientHello 메시지의 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cd79b5b7a4be54c9b22aebd238e09a232cbd8025" translate="yes" xml:space="preserve">
          <source>ClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which are supported via this interface.</source>
          <target state="translated">ClientSessionCache는 클라이언트가 주어진 서버와의 TLS 세션을 재개하는 데 사용할 수있는 ClientSessionState 객체의 캐시입니다. ClientSessionCache 구현은 다른 고 루틴에서 동시에 호출되어야합니다. TLS 1.2까지는 SessionID 기반 재개가 아닌 티켓 기반 재개 만 지원됩니다. TLS 1.3에서는이 인터페이스를 통해 지원되는 PSK 모드로 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="4261cd72e26b8a6f4e1ee1c0b615bda2af7c152e" translate="yes" xml:space="preserve">
          <source>ClientSessionState contains the state needed by clients to resume TLS sessions.</source>
          <target state="translated">ClientSessionState는 클라이언트가 TLS 세션을 재개하는 데 필요한 상태를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7b8568bd00779243f275b569a827fb1a4ee4d798" translate="yes" xml:space="preserve">
          <source>ClientTrace currently traces a single HTTP request &amp;amp; response during a single round trip and has no hooks that span a series of redirected requests.</source>
          <target state="translated">ClientTrace는 현재 단일 왕복 동안 단일 HTTP 요청 및 응답을 추적하며 일련의 리디렉션 된 요청에 걸쳐있는 후크가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2c0d131f45dce2b6840cda576beab00d7f77dc6" translate="yes" xml:space="preserve">
          <source>ClientTrace is a set of hooks to run at various stages of an outgoing HTTP request. Any particular hook may be nil. Functions may be called concurrently from different goroutines and some may be called after the request has completed or failed.</source>
          <target state="translated">ClientTrace는 발신 HTTP 요청의 다양한 단계에서 실행되는 일련의 후크입니다. 특정 후크는 0이 될 수 있습니다. 기능은 다른 고 루틴에서 동시에 호출 될 수 있으며 일부는 요청이 완료되거나 실패한 후에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f78c7958600ab8163b169a5392c03ab112bc9818" translate="yes" xml:space="preserve">
          <source>Clients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re-used.</source>
          <target state="translated">클라이언트와 전송은 여러 고 루틴이 동시에 사용하기에 안전하며 효율성은 한 번만 생성하여 재사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cf2cc8bbf640eaf7f640276f5d3bedeec8ec3e6" translate="yes" xml:space="preserve">
          <source>Clients of ReadAt can execute parallel ReadAt calls on the same input source.</source>
          <target state="translated">ReadAt 클라이언트는 동일한 입력 소스에서 병렬 ReadAt 호출을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a400bb26da184d79eb5b2958194d8a32b13bc955" translate="yes" xml:space="preserve">
          <source>Clients of WriteAt can execute parallel WriteAt calls on the same destination if the ranges do not overlap.</source>
          <target state="translated">범위가 겹치지 않으면 WriteAt 클라이언트는 동일한 대상에서 병렬 WriteAt 호출을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fec7b0e20e9b1f7f723676dab3a1767767a84b57" translate="yes" xml:space="preserve">
          <source>Clock returns the hour, minute, and second within the day specified by t.</source>
          <target state="translated">Clock은 t로 지정된 날짜 내에서시, 분 및 초를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a51aa154240abaf7f49170efa4282e63e6b0af7c" translate="yes" xml:space="preserve">
          <source>Clone returns a copy of h or nil if h is nil.</source>
          <target state="translated">h가 nil이면 Clone은 h 또는 nil의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d0c309a73cbbbf8259510e09413f8159d0e1432" translate="yes" xml:space="preserve">
          <source>Clone returns a deep copy of r with its context changed to ctx. The provided ctx must be non-nil.</source>
          <target state="translated">복제는 컨텍스트가 ctx로 변경된 r의 깊은 사본을 리턴합니다. 제공된 ctx는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="d40a70840ac8a8b0e1068c9c26e4552921cb6234" translate="yes" xml:space="preserve">
          <source>Clone returns a deep copy of t's exported fields.</source>
          <target state="translated">클론은 t의 내 보낸 필드의 깊은 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7d21868e4f3fbff70ffe77108b1ebd0c6e3dad8" translate="yes" xml:space="preserve">
          <source>Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to Parse in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made.</source>
          <target state="translated">복제는 모든 관련 템플릿을 포함하여 템플릿의 복제본을 반환합니다. 실제 표현은 복사되지 않지만 연관된 템플리트의 네임 스페이스는 복사되므로 사본에서 구문 분석을 추가로 호출하면 사본이 아닌 사본에 템플리트가 추가됩니다. 복제본은 복제 된 후 변형을 추가하여 공통 템플릿을 준비하고 다른 템플릿에 대한 변형 정의와 함께 사용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f9f61d9b08e615a156dcfb06e61048e8e52ecb" translate="yes" xml:space="preserve">
          <source>Clone returns a shallow clone of c. It is safe to clone a Config that is being used concurrently by a TLS client or server.</source>
          <target state="translated">클론은 c의 얕은 클론을 반환합니다. TLS 클라이언트 또는 서버에서 동시에 사용중인 구성을 복제하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8453ed0e61fef3b985c7beb9516a6f372a19b47a" translate="yes" xml:space="preserve">
          <source>Close calls Hijack and then also closes the underlying connection.</source>
          <target state="translated">Close는 Hijack을 호출 한 다음 기본 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="52273c6bb0b067f25179883936e89e4ec6820203" translate="yes" xml:space="preserve">
          <source>Close calls the underlying codec's Close method. If the connection is already shutting down, ErrShutdown is returned.</source>
          <target state="translated">Close는 기본 코덱의 Close 메서드를 호출합니다. 연결이 이미 종료 된 경우 ErrShutdown이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c13ba2fc343eab1245b8fef1e7cc062cd2a1602" translate="yes" xml:space="preserve">
          <source>Close closes a connection to the syslog daemon.</source>
          <target state="translated">Close는 syslog 데몬에 대한 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="eeb4b4090ffa478f7d84bcfa0c7d691724864926" translate="yes" xml:space="preserve">
          <source>Close closes the File, rendering it unusable for I/O. On files that support SetDeadline, any pending I/O operations will be canceled and return immediately with an error. Close will return an error if it has already been called.</source>
          <target state="translated">닫기는 파일을 닫아서 I / O에 사용할 수 없게합니다. SetDeadline을 지원하는 파일에서 보류중인 모든 I / O 작업이 취소되고 오류와 함께 즉시 반환됩니다. Close는 이미 호출 된 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d45ca0df5edf4ea7611729ef661a62fd651286e3" translate="yes" xml:space="preserve">
          <source>Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect.</source>
          <target state="translated">닫기는 파일을 닫습니다. Open 대신 NewFile을 사용하여 파일을 직접 만든 경우에는 닫기가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88e02dffb069cff4304f88a87d5f3eebaaf4bd7a" translate="yes" xml:space="preserve">
          <source>Close closes the Reader. It does not close the underlying io.Reader. In order for the GZIP checksum to be verified, the reader must be fully consumed until the io.EOF.</source>
          <target state="translated">닫기는 리더를 닫습니다. 기본 io.Reader를 닫지 않습니다. GZIP 체크섬을 확인하려면 io.EOF까지 리더를 완전히 소비해야합니다.</target>
        </trans-unit>
        <trans-unit id="0001566c562646043d2cfebeb74f3e43dd5b2e61" translate="yes" xml:space="preserve">
          <source>Close closes the Rows, preventing further enumeration. If Next is called and returns false and there are no further result sets, the Rows are closed automatically and it will suffice to check the result of Err. Close is idempotent and does not affect the result of Err.</source>
          <target state="translated">닫기는 행을 닫아서 추가 열거를 방지합니다. Next가 호출되고 false를 반환하고 추가 결과 집합이 없으면 행이 자동으로 닫히고 Err의 결과를 확인하기에 충분합니다. 닫기는 dem 등원이며 Err의 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3d80a35eb8198958ef52ff7593c60df2ce5c5fe" translate="yes" xml:space="preserve">
          <source>Close closes the Writer by flushing any unwritten data to the underlying io.Writer and writing the GZIP footer. It does not close the underlying io.Writer.</source>
          <target state="translated">Close는 쓰지 않은 데이터를 기본 io.Writer로 플러시하고 GZIP 바닥 글을 작성하여 Writer를 닫습니다. 기본 io.Writer를 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffc4ad566ba30635a22eb5157801170e5d89ec5c" translate="yes" xml:space="preserve">
          <source>Close closes the Writer, flushing any unwritten data to the underlying io.Writer, but does not close the underlying io.Writer.</source>
          <target state="translated">Close는 기록되지 않은 데이터를 기본 io.Writer로 플러시하면서 Writer를 닫지 만 기본 io.Writer는 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcb888cd0e9b17f68ae4a9ca892eb5a899c7a8d9" translate="yes" xml:space="preserve">
          <source>Close closes the Zip file, rendering it unusable for I/O.</source>
          <target state="translated">Close는 Zip 파일을 닫아 I / O에 사용할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="170e39e4cfe5f423996aef0511a13fa738d82767" translate="yes" xml:space="preserve">
          <source>Close closes the channel v. It panics if v's Kind is not Chan.</source>
          <target state="translated">닫기는 채널 v를 닫습니다. v의 종류가 Chan이 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4e72aa781c9fdcf98527fd4aefce87b04e14f2dd" translate="yes" xml:space="preserve">
          <source>Close closes the connection.</source>
          <target state="translated">닫기는 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="f0afd5857186a670ed9831e4c77eff40bb3fcd33" translate="yes" xml:space="preserve">
          <source>Close closes the database and prevents new queries from starting. Close then waits for all queries that have started processing on the server to finish.</source>
          <target state="translated">닫기는 데이터베이스를 닫고 새 쿼리가 시작되지 않도록합니다. 그런 다음 닫기는 서버에서 처리를 시작한 모든 쿼리가 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="a7394665dc5b3d21e6abc1566eec56cbff266f10" translate="yes" xml:space="preserve">
          <source>Close closes the reader; subsequent writes to the write half of the pipe will return the error ErrClosedPipe.</source>
          <target state="translated">닫기는 독자를 닫습니다. 파이프의 쓰기 절반에 대한 후속 쓰기는 오류 ErrClosedPipe를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4bdc20107bf4231f79596e877811964979986697" translate="yes" xml:space="preserve">
          <source>Close closes the statement.</source>
          <target state="translated">닫기는 문을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="106e9814bb640efe24e830aa126c2c54c6dc95c2" translate="yes" xml:space="preserve">
          <source>Close closes the tar archive by flushing the padding, and writing the footer. If the current file (from a prior call to WriteHeader) is not fully written, then this returns an error.</source>
          <target state="translated">닫기는 패딩을 비우고 바닥 글을 작성하여 tar 아카이브를 닫습니다. 이전 파일에서 WriteHeader 로의 현재 파일이 완전히 기록되지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="352516c54e1182715d16a990d5c36e2341135718" translate="yes" xml:space="preserve">
          <source>Close closes the underlying Writer and returns its Close return value, if the Writer is also an io.Closer. Otherwise it returns nil.</source>
          <target state="translated">Close는 기본 Writer를 닫고 Writer가 io.Closer 인 경우 Close 반환 값을 반환합니다. 그렇지 않으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52ed6590b2322e36c0e5bf1047b994dc45204fd3" translate="yes" xml:space="preserve">
          <source>Close closes the writer; subsequent reads from the read half of the pipe will return no bytes and EOF.</source>
          <target state="translated">닫기는 작가를 닫습니다. 파이프의 읽기 절반에서 후속 읽기는 바이트 및 EOF를 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="200b8523cd103f0c8cfd18d1f36d3268f60a35d8" translate="yes" xml:space="preserve">
          <source>Close does not attempt to close (and does not even know about) any hijacked connections, such as WebSockets.</source>
          <target state="translated">Close는 WebSocket과 같은 하이재킹 된 연결을 닫으려고 시도하지 않으며 심지어 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="6c8f276efb10d5e03a4e7e0b4c3a39470cd47092" translate="yes" xml:space="preserve">
          <source>Close finishes the multipart message and writes the trailing boundary end line to the output.</source>
          <target state="translated">닫기는 여러 부분으로 된 메시지를 끝내고 후행 경계 끝 줄을 출력에 씁니다.</target>
        </trans-unit>
        <trans-unit id="4729b3f8428d27fe7962c988912499dee821e961" translate="yes" xml:space="preserve">
          <source>Close finishes writing the zip file by writing the central directory. It does not close the underlying writer.</source>
          <target state="translated">닫기는 중앙 디렉토리를 작성하여 zip 파일 작성을 완료합니다. 기본 작성자를 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8c5f7e41ae46e45fdb752f5060f8f1c692afd60" translate="yes" xml:space="preserve">
          <source>Close flushes and closes the writer.</source>
          <target state="translated">닫기는 기록기를 플러시하고 닫습니다.</target>
        </trans-unit>
        <trans-unit id="a176e6e0b76092540fa57054871f1d181440c357" translate="yes" xml:space="preserve">
          <source>Close immediately closes all active net.Listeners and any connections in state StateNew, StateActive, or StateIdle. For a graceful shutdown, use Shutdown.</source>
          <target state="translated">닫기는 StateNew, StateActive 또는 StateIdle 상태의 모든 활성 net.Listener와 모든 연결을 즉시 닫습니다. 정상적으로 종료하려면 종료를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe447e0ee4298c5937baf1a06d93345aa464fbd5" translate="yes" xml:space="preserve">
          <source>Close returns any error returned from closing the Server's underlying Listener(s).</source>
          <target state="translated">Close는 서버의 기본 리스너를 닫으면 반환 된 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ebef25a1a35880c50df3b65075b191c54c634f29" translate="yes" xml:space="preserve">
          <source>Close returns the connection to the connection pool. All operations after a Close will return with ErrConnDone. Close is safe to call concurrently with other operations and will block until all other operations finish. It may be useful to first cancel any used context and then call close directly after.</source>
          <target state="translated">닫기는 연결 풀에 대한 연결을 반환합니다. 닫기 이후의 모든 작업은 ErrConnDone과 함께 반환됩니다. 닫기는 다른 작업과 동시에 호출해도 안전하며 다른 모든 작업이 완료 될 때까지 차단됩니다. 사용 된 컨텍스트를 먼저 취소 한 후 바로 닫기를 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="37eb62a0940cfdcee1af7061b837f9799f402796" translate="yes" xml:space="preserve">
          <source>Close shuts down the server and blocks until all outstanding requests on this server have completed.</source>
          <target state="translated">닫기는 서버를 종료하고이 서버의 모든 미해결 요청이 완료 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="f8fbcf4b32e3ff8e88655f1d0a5b7d15a237aeb7" translate="yes" xml:space="preserve">
          <source>Close stops listening on the TCP address. Already Accepted connections are not closed.</source>
          <target state="translated">닫기는 TCP 주소에서 수신을 중지합니다. 이미 허용 된 연결이 닫히지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d08ec13311a2751b4b2525f7b1f553c0ef38c594" translate="yes" xml:space="preserve">
          <source>Close stops listening on the Unix address. Already accepted connections are not closed.</source>
          <target state="translated">닫기는 유닉스 주소에서 수신을 멈 춥니 다. 이미 수락 된 연결이 닫히지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="389d20cf359b73e0e7980ec6fac9aa975d57569a" translate="yes" xml:space="preserve">
          <source>CloseClientConnections closes any open HTTP connections to the test Server.</source>
          <target state="translated">CloseClientConnections는 테스트 서버에 열려있는 모든 HTTP 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="261f4fda459d0516a122cc5d4396c6dc486f9e9c" translate="yes" xml:space="preserve">
          <source>CloseIdleConnections closes any connections on its Transport which were previously connected from previous requests but are now sitting idle in a &quot;keep-alive&quot; state. It does not interrupt any connections currently in use.</source>
          <target state="translated">CloseIdleConnections는 이전 요청에서 이전에 연결되었지만 현재 &quot;keep-alive&quot;상태로 유휴 상태 인 전송에서 모든 연결을 닫습니다. 현재 사용중인 연결을 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98cdec9e3ed766ae575089db46108dde804402bf" translate="yes" xml:space="preserve">
          <source>CloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle in a &quot;keep-alive&quot; state. It does not interrupt any connections currently in use.</source>
          <target state="translated">CloseIdleConnections는 이전 요청에서 이전에 연결되었지만 &quot;keep-alive&quot;상태에서 유휴 상태 인 모든 연결을 닫습니다. 현재 사용중인 연결을 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd124a0e692a348dba461a3358554e58e81ecbd1" translate="yes" xml:space="preserve">
          <source>CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close.</source>
          <target state="translated">CloseRead는 TCP 연결의 읽기 쪽을 종료합니다. 대부분의 발신자는 닫기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="44bd7cea9ee27035c3ae1c56d08cfc3f4f5d4af4" translate="yes" xml:space="preserve">
          <source>CloseRead shuts down the reading side of the Unix domain connection. Most callers should just use Close.</source>
          <target state="translated">CloseRead는 Unix 도메인 연결의 읽기 쪽을 종료합니다. 대부분의 발신자는 닫기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c99ee46f4965c6ae12155ff0c3acac929ea2d2ba" translate="yes" xml:space="preserve">
          <source>CloseWithError always returns nil.</source>
          <target state="translated">CloseWithError는 항상 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cb57262be19b34a83137a915ff126b817e8cd84" translate="yes" xml:space="preserve">
          <source>CloseWithError closes the reader; subsequent writes to the write half of the pipe will return the error err.</source>
          <target state="translated">CloseWithError는 리더를 닫습니다. 파이프의 쓰기 절반에 대한 후속 쓰기는 오류 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="323f38f99d402fc8898abc494103623650f844e1" translate="yes" xml:space="preserve">
          <source>CloseWithError closes the writer; subsequent reads from the read half of the pipe will return no bytes and the error err, or EOF if err is nil.</source>
          <target state="translated">CloseWithError는 기록기를 닫습니다. 파이프의 읽기 절반에서 후속 읽기는 바이트 없음 및 오류 err를 리턴하거나 err이 nil 인 경우 EOF를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="62cb9bc4e7dc627b7e88dd6fc70819d95287b7de" translate="yes" xml:space="preserve">
          <source>CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close.</source>
          <target state="translated">CloseWrite는 TCP 연결의 쓰기 쪽을 종료합니다. 대부분의 발신자는 닫기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b5fa14df50780ec1f98f4b1599b904896412a44" translate="yes" xml:space="preserve">
          <source>CloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use Close.</source>
          <target state="translated">CloseWrite는 Unix 도메인 연결의 쓰기 쪽을 종료합니다. 대부분의 발신자는 닫기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="12c02b4b8ced685856a49bdd3fa95819cddecdb4" translate="yes" xml:space="preserve">
          <source>CloseWrite shuts down the writing side of the connection. It should only be called once the handshake has completed and does not call CloseWrite on the underlying connection. Most callers should just use Close.</source>
          <target state="translated">CloseWrite는 연결의 쓰기 쪽을 종료합니다. 핸드 셰이크가 완료된 후에 만 ​​호출해야하며 기본 연결에서 CloseWrite를 호출하지 않습니다. 대부분의 발신자는 닫기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="025c9e3cff2e6d4f799242ed81fe111ea5df8d42" translate="yes" xml:space="preserve">
          <source>Closer is the interface that wraps the basic Close method.</source>
          <target state="translated">Closer는 기본 Close 메서드를 래핑하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bf86a4428400033e41e83adaf8fcd42c758c9a66" translate="yes" xml:space="preserve">
          <source>Cmd is a convenience method that sends a command after waiting its turn in the pipeline. The command text is the result of formatting format with args and appending \r\n. Cmd returns the id of the command, for use with StartResponse and EndResponse.</source>
          <target state="translated">Cmd는 파이프 라인에서 회전을 기다린 후 명령을 보내는 편리한 방법입니다. 명령 텍스트는 args로 형식을 지정하고 \ r \ n을 추가 한 결과입니다. Cmd는 StartResponse 및 EndResponse와 함께 사용하기 위해 명령의 id를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4df69b916cd12f7de468263676e94c5c75d74be" translate="yes" xml:space="preserve">
          <source>Cmd represents an external command being prepared or run.</source>
          <target state="translated">Cmd는 준비 또는 실행중인 외부 명령을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8341f2d7cc5348428398c452871f044231d072b1" translate="yes" xml:space="preserve">
          <source>Cmd.CombinedOutput</source>
          <target state="translated">Cmd.CombinedOutput</target>
        </trans-unit>
        <trans-unit id="b49f432e04db8bb6f0ff26554d0c04cd2474b188" translate="yes" xml:space="preserve">
          <source>Cmd.Output</source>
          <target state="translated">Cmd.Output</target>
        </trans-unit>
        <trans-unit id="0d9082730686869c07fbf083f9d88bceb2781e29" translate="yes" xml:space="preserve">
          <source>Cmd.Run</source>
          <target state="translated">Cmd.Run</target>
        </trans-unit>
        <trans-unit id="58d8e5abab254c9f803a0fbf81ec5a80f295d3f6" translate="yes" xml:space="preserve">
          <source>Cmd.Start</source>
          <target state="translated">Cmd.Start</target>
        </trans-unit>
        <trans-unit id="7d1c537c3fedeb55a89bcf9247fbaee7db539a47" translate="yes" xml:space="preserve">
          <source>Cmd.StderrPipe</source>
          <target state="translated">Cmd.StderrPipe</target>
        </trans-unit>
        <trans-unit id="e1e9157b17d06c02c7b6351858c7dc306f264ffa" translate="yes" xml:space="preserve">
          <source>Cmd.StdinPipe</source>
          <target state="translated">Cmd.StdinPipe</target>
        </trans-unit>
        <trans-unit id="426cc9ae5b0f1bc8c33ffa706427366531644c95" translate="yes" xml:space="preserve">
          <source>Cmd.StdoutPipe</source>
          <target state="translated">Cmd.StdoutPipe</target>
        </trans-unit>
        <trans-unit id="7da7ae25e3ce7a764681c94e7a21a14faa2a048f" translate="yes" xml:space="preserve">
          <source>Cmdline responds with the running program's command line, with arguments separated by NUL bytes. The package initialization registers it as /debug/pprof/cmdline.</source>
          <target state="translated">Cmdline은 NUL 바이트로 구분 된 인수를 사용하여 실행중인 프로그램의 명령 줄에 응답합니다. 패키지 초기화는 패키지를 / debug / pprof / cmdline으로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="e499091b6f0f3957334468fbd916d761cc79bbf6" translate="yes" xml:space="preserve">
          <source>Cmp compares x and y and returns:</source>
          <target state="translated">Cmp는 x와 y를 비교하고 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8bfa3d3867edbba78ae419fddd813026c9ccc33" translate="yes" xml:space="preserve">
          <source>CmpAbs compares the absolute values of x and y and returns:</source>
          <target state="translated">CmpAbs는 x와 y의 절대 값을 비교하고 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57049c5e8c996230fc39d709b36268d07f37c357" translate="yes" xml:space="preserve">
          <source>CmsgLen returns the value to store in the Len field of the Cmsghdr structure, taking into account any necessary alignment.</source>
          <target state="translated">CmsgLen은 필요한 정렬을 고려하여 Cmsghdr 구조의 Len 필드에 저장할 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ab8b85fb5b07863e8d88db990fae36dc884bec8" translate="yes" xml:space="preserve">
          <source>CmsgSpace returns the number of bytes an ancillary element with payload of the passed data length occupies.</source>
          <target state="translated">CmsgSpace는 전달 된 데이터 길이의 페이로드가있는 보조 요소가 바이트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="48325d7b0e0596e2c4e51ec147f486ed8c008263" translate="yes" xml:space="preserve">
          <source>Code Effect Property: &quot;... only code specified by the template author should run as a result of injecting the template output into a page and all code specified by the template author should run as a result of the same.&quot;</source>
          <target state="translated">코드 효과 속성 : &quot;... 페이지에 템플릿 출력을 삽입 한 결과 템플릿 작성자가 지정한 코드 만 실행되고 템플릿 작성자가 지정한 모든 코드는 동일한 결과로 실행됩니다.&quot;</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="6b14d7cd0be2bfa55cd088eb8efaed3cb2199731" translate="yes" xml:space="preserve">
          <source>Color can convert itself to alpha-premultiplied 16-bits per channel RGBA. The conversion may be lossy.</source>
          <target state="translated">채널 RGBA 당 알파 미리 곱셈 된 16 비트로 색상을 변환 할 수 있습니다. 변환이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd162f1f3146515349a168ad0c0bee532290150" translate="yes" xml:space="preserve">
          <source>ColorModel implements the Image interface.</source>
          <target state="translated">ColorModel은 Image 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="98107aade8283409c4e0728cc2278d75e786fabe" translate="yes" xml:space="preserve">
          <source>ColumnConverter may be optionally implemented by Stmt if the statement is aware of its own columns' types and can convert from any type to a driver Value.</source>
          <target state="translated">명령문이 고유 한 열 유형을 인식하고 모든 유형에서 드라이버 Value로 변환 할 수있는 경우 Stmt에서 ColumnConverter를 선택적으로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c3da66a9ea9f5f89916fe885dde7b78b155333" translate="yes" xml:space="preserve">
          <source>ColumnType contains the name and type of a column.</source>
          <target state="translated">ColumnType에는 열의 이름과 유형이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f1efdea11843f07d3a2895f7ecdd3254afb2b05f" translate="yes" xml:space="preserve">
          <source>ColumnTypes returns column information such as column type, length, and nullable. Some information may not be available from some drivers.</source>
          <target state="translated">ColumnTypes는 열 유형, 길이 및 널 입력 가능과 같은 열 정보를 리턴합니다. 일부 드라이버에서 일부 정보를 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b0a72c46f57d4aaacd8fb638f17124f271db49" translate="yes" xml:space="preserve">
          <source>Columns returns the column names. Columns returns an error if the rows are closed.</source>
          <target state="translated">열은 열 이름을 반환합니다. 행이 닫히면 열이 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef0c9247ce98d2d969ab4480bf85645f18a4849a" translate="yes" xml:space="preserve">
          <source>Combination of fork and exec, careful to be thread safe.</source>
          <target state="translated">포크와 exec의 조합, 스레드 안전에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="7490336ab129f1a9b38c44a15f2efc1193a790bb" translate="yes" xml:space="preserve">
          <source>CombinedOutput runs the command and returns its combined standard output and standard error.</source>
          <target state="translated">CombinedOutput은 명령을 실행하고 결합 된 표준 출력 및 표준 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba546d35dfd34c127cd8bc57f35ce0b69f3c2efb" translate="yes" xml:space="preserve">
          <source>Comma is the field delimiter.</source>
          <target state="translated">쉼표는 필드 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="8901895fb1b1d4c4ea2fec368c25176bf73e2f7e" translate="yes" xml:space="preserve">
          <source>Command</source>
          <target state="translated">Command</target>
        </trans-unit>
        <trans-unit id="9331e1a8ab2aef9b980540768d06019630abf1c7" translate="yes" xml:space="preserve">
          <source>Command (Environment)</source>
          <target state="translated">지휘 (환경)</target>
        </trans-unit>
        <trans-unit id="c2efc4b10527a5dc4a84c585a3102ee37add55b4" translate="yes" xml:space="preserve">
          <source>Command line flag syntax</source>
          <target state="translated">명령 행 플래그 구문</target>
        </trans-unit>
        <trans-unit id="63fa526b0ed74d3db6d8290c146d52ec2eac85fb" translate="yes" xml:space="preserve">
          <source>Command returns the Cmd struct to execute the named program with the given arguments.</source>
          <target state="translated">Command는 주어진 인수로 명명 된 프로그램을 실행하도록 Cmd 구조체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3abae9e919fccff46e1815da877737ecf731b82f" translate="yes" xml:space="preserve">
          <source>CommandContext</source>
          <target state="translated">CommandContext</target>
        </trans-unit>
        <trans-unit id="e0905d26f91536a32a803b5ba92c26b9a1cc54f0" translate="yes" xml:space="preserve">
          <source>CommandContext is like Command but includes a context.</source>
          <target state="translated">CommandContext는 Command와 유사하지만 컨텍스트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4fe0d3f2a541495d49598b4c3afabfa5ee1e04f4" translate="yes" xml:space="preserve">
          <source>CommandLine is the default set of command-line flags, parsed from os.Args. The top-level functions such as BoolVar, Arg, and so on are wrappers for the methods of CommandLine.</source>
          <target state="translated">CommandLine은 os.Args에서 구문 분석 된 기본 명령 행 플래그 세트입니다. BoolVar, Arg 등과 같은 최상위 기능은 CommandLine의 메서드 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="b87781df7cecba61ce8de025314ef45104db43ee" translate="yes" xml:space="preserve">
          <source>CommandNode holds a command (a pipeline inside an evaluating action).</source>
          <target state="translated">CommandNode는 명령 (평가 작업 내의 파이프 라인)을 보유합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
