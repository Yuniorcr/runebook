<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="72ffbd722c89aeb2c836acf3f0c44afff50be407" translate="yes" xml:space="preserve">
          <source>CommentMap</source>
          <target state="translated">CommentMap</target>
        </trans-unit>
        <trans-unit id="a75531c33f09b6698d805430cabdb3a738714d38" translate="yes" xml:space="preserve">
          <source>Comments returns the list of comment groups in the comment map. The result is sorted in source order.</source>
          <target state="translated">주석은 주석 맵에서 주석 그룹 목록을 반환합니다. 결과는 소스 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="75dbcaa738947f57e870bbe9a0b593ed1429157b" translate="yes" xml:space="preserve">
          <source>Commit commits the transaction.</source>
          <target state="translated">커밋은 트랜잭션을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="ead23952f81edf09bb71f62ad1b348959ed375c9" translate="yes" xml:space="preserve">
          <source>Common HTTP methods.</source>
          <target state="translated">일반적인 HTTP 메소드</target>
        </trans-unit>
        <trans-unit id="88d67b2df02a2b0f12c80994d6833df71942c623" translate="yes" xml:space="preserve">
          <source>Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions.</source>
          <target state="translated">일반적인 기간. 일광 절약 시간대 변경에 따른 혼동을 피하기 위해 Day 단위 이상의 정의는 없습니다.</target>
        </trans-unit>
        <trans-unit id="184f39007c639489786070aa25bca08ce4764bc0" translate="yes" xml:space="preserve">
          <source>CommonType holds elements of all types. It is a historical artifact, kept for binary compatibility and exported only for the benefit of the package's encoding of type descriptors. It is not intended for direct use by clients.</source>
          <target state="translated">CommonType은 모든 유형의 요소를 보유합니다. 이진 호환성을 위해 유지되고 패키지의 형식 설명자 인코딩의 이점을 위해서만 내 보낸 역사적 아티팩트입니다. 클라이언트가 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfd58ee3a270f3a931009900e1008d549bbd7453" translate="yes" xml:space="preserve">
          <source>Community</source>
          <target state="translated">Community</target>
        </trans-unit>
        <trans-unit id="d41102eb4b9de6b7bae3f5e306780351400ba6cc" translate="yes" xml:space="preserve">
          <source>Compact appends to dst the JSON-encoded src with insignificant space characters elided.</source>
          <target state="translated">공백이 거의없는 JSON 인코딩 src에 dst를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4b1b7e3488c6acd7e9ce9eb7f6b22d083ee3ad86" translate="yes" xml:space="preserve">
          <source>Comparable reports whether values of type T are comparable.</source>
          <target state="translated">비교 가능은 T 유형의 값이 비교 가능한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="translated">Compare</target>
        </trans-unit>
        <trans-unit id="a87372512a9a5360900cc7c5a33b6e3e93e823d3" translate="yes" xml:space="preserve">
          <source>Compare (Search)</source>
          <target state="translated">비교 (검색)</target>
        </trans-unit>
        <trans-unit id="ad63be5eee8e54dee7704f35acb0ba003f3c69ff" translate="yes" xml:space="preserve">
          <source>Compare is included only for symmetry with package bytes. It is usually clearer and always faster to use the built-in string comparison operators ==, &amp;lt;, &amp;gt;, and so on.</source>
          <target state="translated">비교는 패키지 바이트와의 대칭에 대해서만 포함됩니다. 내장 문자열 비교 연산자 ==, &amp;lt;,&amp;gt; 등을 사용하는 것이 일반적으로 더 명확하고 항상 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="80addebf328bcb3bd2c3c1645d4d89e7132d58cd" translate="yes" xml:space="preserve">
          <source>Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a==b, -1 if a &amp;lt; b, and +1 if a &amp;gt; b. A nil argument is equivalent to an empty slice.</source>
          <target state="translated">비교는 사 전적으로 두 바이트 슬라이스를 비교하는 정수를 리턴합니다. a == b이면 결과는 0, a &amp;lt;b이면 -1, a&amp;gt; b이면 +1이됩니다. nil 인수는 빈 슬라이스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5df35de4203e8da0393ad78d4e9938f7d7d27e38" translate="yes" xml:space="preserve">
          <source>Compare returns an integer comparing two strings lexicographically. The result will be 0 if a==b, -1 if a &amp;lt; b, and +1 if a &amp;gt; b.</source>
          <target state="translated">비교는 두 문자열을 사전 식으로 비교하는 정수를 반환합니다. a == b이면 결과는 0, a &amp;lt;b이면 -1, a&amp;gt; b이면 +1이됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e32b8f4321d2754d7b192fb3758e3b419a9f9c" translate="yes" xml:space="preserve">
          <source>Compare returns the result of the comparison x op y. The comparison must be defined for the operands. If one of the operands is Unknown, the result is false.</source>
          <target state="translated">비교는 비교 x op y의 결과를 반환합니다. 피연산자에 대한 비교를 정의해야합니다. 피연산자 중 하나가 알 수없는 경우 결과는 false입니다.</target>
        </trans-unit>
        <trans-unit id="910ec23407bde52c30ee4b60de00ef973b43f80f" translate="yes" xml:space="preserve">
          <source>CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.</source>
          <target state="translated">CompareAndSwapInt32는 int32 값에 대해 비교 및 ​​스왑 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="45d6c43b2c49df7ae06cb50a00c7e8b8915268cf" translate="yes" xml:space="preserve">
          <source>CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.</source>
          <target state="translated">CompareAndSwapInt64는 int64 값에 대해 비교 및 ​​스왑 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="80d6539a495248c2ad93b44c9b160da516bc7385" translate="yes" xml:space="preserve">
          <source>CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.</source>
          <target state="translated">CompareAndSwapPointer는 안전하지 않은 Pointer 값에 대해 비교 및 ​​스왑 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="08b11a167dff4b888f467bc21d9300ca565d08f6" translate="yes" xml:space="preserve">
          <source>CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.</source>
          <target state="translated">CompareAndSwapUint32는 uint32 값에 대해 비교 및 ​​스왑 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e65fd9c97eea0a869d816095871991bfeac0d5f9" translate="yes" xml:space="preserve">
          <source>CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.</source>
          <target state="translated">CompareAndSwapUint64는 uint64 값에 대해 비교 및 ​​스왑 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fd8ad0ca49f8af09303cdda4c902f6a9b14029ce" translate="yes" xml:space="preserve">
          <source>CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.</source>
          <target state="translated">CompareAndSwapUintptr은 uintptr 값에 대해 비교 및 ​​스왑 조작을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e46ab4b32fa2f629f5362ccdb0c33a816b4b7aef" translate="yes" xml:space="preserve">
          <source>Compatibility: Any future changes to hash or crypto packages will endeavor to maintain compatibility with state encoded using previous versions. That is, any released versions of the packages should be able to decode data written with any previously released version, subject to issues such as security fixes. See the Go compatibility document for background: &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;https://golang.org/doc/go1compat&lt;/a&gt;</source>
          <target state="translated">호환성 : 해시 또는 암호화 패키지에 대한 향후 변경 사항은 이전 버전을 사용하여 인코딩 된 상태와의 호환성을 유지하기 위해 노력할 것입니다. 즉, 릴리스 된 모든 버전의 패키지는 보안 수정과 같은 문제에 따라 이전에 출시 된 버전으로 작성된 데이터를 디코딩 할 수 있어야합니다. 배경은 Go 호환성 문서를 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;https://golang.org/doc/go1compat&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="954806623263eec83965435d4b03d56697b9e46d" translate="yes" xml:space="preserve">
          <source>Compatibility: Any future changes to the package will endeavor to maintain compatibility with streams encoded using previous versions. That is, any released version of this package should be able to decode data written with any previously released version, subject to issues such as security fixes. See the Go compatibility document for background: &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;https://golang.org/doc/go1compat&lt;/a&gt;</source>
          <target state="translated">호환성 : 향후 패키지 변경 사항은 이전 버전을 사용하여 인코딩 된 스트림과의 호환성을 유지하기 위해 노력할 것입니다. 즉,이 패키지의 모든 릴리스 버전은 보안 수정과 같은 문제에 따라 이전에 릴리스 된 버전으로 작성된 데이터를 디코딩 할 수 있어야합니다. 배경은 Go 호환성 문서를 참조하십시오 : &lt;a href=&quot;https://golang.org/doc/go1compat&quot;&gt;https://golang.org/doc/go1compat&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0baebc95c01171c0c52e34f8d0b193a89bd2a16d" translate="yes" xml:space="preserve">
          <source>Compile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify).</source>
          <target state="translated">컴파일은 정규 표현식을 실행할 프로그램으로 컴파일합니다. 정규 표현식은 이미 단순화되어 있어야합니다 (재 시뮬레이션에서 반환).</target>
        </trans-unit>
        <trans-unit id="5ebbdcb3f12368feddbe44f5bdd110e3044ea9e4" translate="yes" xml:space="preserve">
          <source>Compile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text.</source>
          <target state="translated">컴파일은 정규 표현식을 구문 분석하고 성공하면 텍스트와 일치하는 데 사용할 수있는 Regexp 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cee12e4c020c15df0e0265d183f5996a7256de50" translate="yes" xml:space="preserve">
          <source>CompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest.</source>
          <target state="translated">CompilePOSIX는 컴파일과 유사하지만 정규식을 POSIX ERE (egrep) 구문으로 제한하고 일치 시맨틱을 가장 왼쪽으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5e03d68306e0c19856edf7366f977bbbed7ddfc9" translate="yes" xml:space="preserve">
          <source>Compiler is the name of the compiler toolchain that built the running binary. Known toolchains are:</source>
          <target state="translated">컴파일러는 실행중인 바이너리를 빌드 한 컴파일러 툴체인의 이름입니다. 알려진 툴체인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e22f98d93ae817ec1259f4d4b7bb21830ff51f40" translate="yes" xml:space="preserve">
          <source>Complete computes the interface's method set. It must be called by users of NewInterfaceType and NewInterface after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. Complete returns the receiver.</source>
          <target state="translated">Complete는 인터페이스의 메소드 세트를 계산합니다. 인터페이스의 임베드 된 유형이 완전히 정의 된 후 인터페이스 유형을 사용하기 전에 다른 유형을 형성하기 전에 NewInterfaceType 및 NewInterface 사용자가 호출해야합니다. 완료는 수신자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="01f7244e495625b4cee683d43e3d4155851069d0" translate="yes" xml:space="preserve">
          <source>Complex returns v's underlying value, as a complex128. It panics if v's Kind is not Complex64 or Complex128</source>
          <target state="translated">Complex는 v의 기본 값을 complex128로 반환합니다. v의 종류가 Complex64 또는 Complex128이 아닌 경우 패닉</target>
        </trans-unit>
        <trans-unit id="1e5c0a1accf821336b517c8f9a6d139c6eec6f93" translate="yes" xml:space="preserve">
          <source>ComplexType is here for the purposes of documentation only. It is a stand-in for either complex type: complex64 or complex128.</source>
          <target state="translated">ComplexType은 문서 목적으로 만 사용됩니다. complex64 또는 complex128의 복합 유형에 대한 독립형입니다.</target>
        </trans-unit>
        <trans-unit id="0393f2fc81c87a0dafffd5b2077e514e08d44e60" translate="yes" xml:space="preserve">
          <source>Composites:</source>
          <target state="translated">Composites:</target>
        </trans-unit>
        <trans-unit id="6330cf629c30461620e73f64161faf03c4f6bc05" translate="yes" xml:space="preserve">
          <source>Compression methods.</source>
          <target state="translated">압축 방법.</target>
        </trans-unit>
        <trans-unit id="dd07f0f2be8ef65d73e0d3b0811ef58ea8daca19" translate="yes" xml:space="preserve">
          <source>Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event.</source>
          <target state="translated">Cond는 goroutines가 이벤트의 발생을 기다리거나 알리기위한 랑데부 지점 인 조건 변수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b8d15477b0af65c5951b32f8d79c3115615594d0" translate="yes" xml:space="preserve">
          <source>Config (KeyLogWriter)</source>
          <target state="translated">구성 (KeyLogWriter)</target>
        </trans-unit>
        <trans-unit id="7e807e5a6200a3f39396feeb57c8d54139d104a3" translate="yes" xml:space="preserve">
          <source>Config holds an image's color model and dimensions.</source>
          <target state="translated">구성에는 이미지의 색상 모델과 치수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b74bd988d5a3ea14e1b3df314b2481dce7147bf" translate="yes" xml:space="preserve">
          <source>Conj returns the complex conjugate of x.</source>
          <target state="translated">Conj는 x의 켤레 복소수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9aeb439eaab9aac64aeb1a4cefd295f624e1753" translate="yes" xml:space="preserve">
          <source>Conn is a connection to a database. It is not used concurrently by multiple goroutines.</source>
          <target state="translated">Conn은 데이터베이스에 대한 연결입니다. 여러 고 루틴이 동시에 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b1029621a91138c59ede0769c17c76de3d476a1" translate="yes" xml:space="preserve">
          <source>Conn is a generic stream-oriented network connection.</source>
          <target state="translated">Conn은 일반적인 스트림 지향 네트워크 연결입니다.</target>
        </trans-unit>
        <trans-unit id="0742e4736e59fa33890eb7f9409476b2970b8342" translate="yes" xml:space="preserve">
          <source>Conn is assumed to be stateful.</source>
          <target state="translated">Conn은 Stateful 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="19cb8b53c681806d63b63016497ea6a71f949b9d" translate="yes" xml:space="preserve">
          <source>Conn is implemented by some types in the net and os packages to provide access to the underlying file descriptor or handle.</source>
          <target state="translated">Conn은 기본 파일 설명자 또는 핸들에 대한 액세스를 제공하기 위해 net 및 os 패키지의 일부 유형으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e466ea632370cac21d90b7f4f09fae73dc2ed1" translate="yes" xml:space="preserve">
          <source>Conn represents a single database connection rather than a pool of database connections. Prefer running queries from DB unless there is a specific need for a continuous single database connection.</source>
          <target state="translated">Conn은 데이터베이스 연결 풀이 아닌 단일 데이터베이스 연결을 나타냅니다. 지속적인 단일 데이터베이스 연결이 필요한 경우가 아니면 DB에서 쿼리를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="08d452c612a33917a07ea957a4e2e63fa7d35e0f" translate="yes" xml:space="preserve">
          <source>Conn returns a single connection by either opening a new connection or returning an existing connection from the connection pool. Conn will block until either a connection is returned or ctx is canceled. Queries run on the same Conn will be run in the same database session.</source>
          <target state="translated">Conn은 새 연결을 열거 나 연결 풀에서 기존 연결을 반환하여 단일 연결을 반환합니다. 연결이 반환되거나 ctx가 취소 될 때까지 Conn은 차단됩니다. 동일한 Conn에서 실행되는 쿼리는 동일한 데이터베이스 세션에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6c492eb2dd2d9a3974d02d68dfa500550dd3dd" translate="yes" xml:space="preserve">
          <source>Conn, a convenient packaging of Reader, Writer, and Pipeline for use with a single network connection.</source>
          <target state="translated">Conn, 단일 네트워크 연결과 함께 사용하기위한 Reader, Writer 및 Pipeline의 편리한 패키징.</target>
        </trans-unit>
        <trans-unit id="85591a22c37013bf743fa31976eceaaa6316c3f2" translate="yes" xml:space="preserve">
          <source>Conn.BeginTx</source>
          <target state="translated">Conn.BeginTx</target>
        </trans-unit>
        <trans-unit id="5cf5eb76abc574b7772bf9ab1e8c6d4fea476438" translate="yes" xml:space="preserve">
          <source>Conn.ExecContext</source>
          <target state="translated">Conn.ExecContext</target>
        </trans-unit>
        <trans-unit id="c158ecf9ec2479e6846915d8cb9fe6d3cbd4ca47" translate="yes" xml:space="preserve">
          <source>ConnBeginTx enhances the Conn interface with context and TxOptions.</source>
          <target state="translated">ConnBeginTx는 컨텍스트 및 TxOptions로 Conn 인터페이스를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="cc1ce7b126fb8c452695e0fb899404e6512c196b" translate="yes" xml:space="preserve">
          <source>ConnPrepareContext enhances the Conn interface with context.</source>
          <target state="translated">ConnPrepareContext는 컨텍스트로 Conn 인터페이스를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="dd0a434e24a3e815d5fcde63b2103c735bf86e75" translate="yes" xml:space="preserve">
          <source>ConnectionState records basic TLS details about the connection.</source>
          <target state="translated">ConnectionState는 연결에 대한 기본 TLS 세부 사항을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="ec4590fa3842e170ce672f8a3f9663ce18f220b4" translate="yes" xml:space="preserve">
          <source>ConnectionState returns basic TLS details about the connection.</source>
          <target state="translated">ConnectionState는 연결에 대한 기본 TLS 세부 사항을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3382413c31457bfa590d655f61e74261287ccc28" translate="yes" xml:space="preserve">
          <source>Constant folding computes the exact constant value (constant.Value) for every expression (ast.Expr) that is a compile-time constant. Use Info.Types[expr].Value for the results of constant folding.</source>
          <target state="translated">상수 폴딩은 컴파일 타임 상수 인 모든 표현식 (ast.Expr)에 대한 정확한 상수 값 (상수 값)을 계산합니다. 상수 폴딩 결과에 Info.Types [expr] .Value를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="834dc3729f5137013cad26135140ed953b36f94d" translate="yes" xml:space="preserve">
          <source>ConstantTimeByteEq returns 1 if x == y and 0 otherwise.</source>
          <target state="translated">ConstantTimeByteEq는 x == y이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3558d9d7a00f451a48ef2972f41f8686803a0e24" translate="yes" xml:space="preserve">
          <source>ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents and 0 otherwise. The time taken is a function of the length of the slices and is independent of the contents.</source>
          <target state="translated">ConstantTimeCompare는 두 슬라이스 x와 y의 내용이 같으면 1을 반환하고 그렇지 않으면 0을 반환합니다. 소요 시간은 슬라이스 길이의 함수이며 내용과 무관합니다.</target>
        </trans-unit>
        <trans-unit id="88c252edbf2eca3cb91bb29e951cb5ca95bae6aa" translate="yes" xml:space="preserve">
          <source>ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value.</source>
          <target state="translated">ConstantTimeCopy는 v == 1 인 경우 y의 내용을 x (같은 길이의 슬라이스)에 복사합니다. v == 0 인 경우 x는 변경되지 않습니다. v에 다른 값이 있으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff7a225b92c492d7dc1f43d3aec5a53c49890771" translate="yes" xml:space="preserve">
          <source>ConstantTimeEq returns 1 if x == y and 0 otherwise.</source>
          <target state="translated">ConstantTimeEq는 x == y이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e6cda7519c219248a0508d2822b6c702c671a99" translate="yes" xml:space="preserve">
          <source>ConstantTimeLessOrEq returns 1 if x &amp;lt;= y and 0 otherwise. Its behavior is undefined if x or y are negative or &amp;gt; 2**31 - 1.</source>
          <target state="translated">ConstantTimeLessOrEq는 x &amp;lt;= y이면 1을, 그렇지 않으면 0을 반환합니다. x 또는 y가 음수이거나&amp;gt; 2 ** 31-1이면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8097a05c2ae8e15642a918a2dfd5de0ec4d3229d" translate="yes" xml:space="preserve">
          <source>ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is undefined if v takes any other value.</source>
          <target state="translated">ConstantTimeSelect는 v == 1이면 x를, v == 0이면 y를 반환합니다. v에 다른 값이 있으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="2fcb5061de485a74f3977289cc41179ec8ab431f" translate="yes" xml:space="preserve">
          <source>Constants describing the Accuracy of a Float.</source>
          <target state="translated">Float의 정확성을 설명하는 상수.</target>
        </trans-unit>
        <trans-unit id="046dff50bc71ac1e0509d7f6f6e5ffad1fc87642" translate="yes" xml:space="preserve">
          <source>Constants to identify various tar formats.</source>
          <target state="translated">다양한 tar 형식을 식별하기위한 상수입니다.</target>
        </trans-unit>
        <trans-unit id="555424611e16923e575afc6f5fc122e1c2a19159" translate="yes" xml:space="preserve">
          <source>ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn't a certificate signing key.</source>
          <target state="translated">ConstraintViolationError는 인증서에 의해 요청 된 사용이 허용되지 않을 때 발생합니다. 예 : 공개 키가 인증서 서명 키가 아닌 경우 서명 확인</target>
        </trans-unit>
        <trans-unit id="33e15d008d511f3101566a2e25203ef2a3f605a0" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Contains</target>
        </trans-unit>
        <trans-unit id="7e044f963947fee78187d2c8a9c3fc9f40ab582e" translate="yes" xml:space="preserve">
          <source>Contains reports whether pos is within the scope's extent. The result is guaranteed to be valid only if the type-checked AST has complete position information.</source>
          <target state="translated">pos가 범위의 범위 내에 있는지 여부를보고합니다. 형식 확인 AST에 위치 정보가 완전한 경우에만 결과가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c2b64d04b858878f66705aa586f7fa9e41fa1f23" translate="yes" xml:space="preserve">
          <source>Contains reports whether subslice is within b.</source>
          <target state="translated">하위 슬라이스가 b 내에 있는지 여부에 대한 보고서를 포함합니다. b.</target>
        </trans-unit>
        <trans-unit id="5e18f046f19b6a654d4cf4ca8d98e9f26e42d9b0" translate="yes" xml:space="preserve">
          <source>Contains reports whether substr is within s.</source>
          <target state="translated">substr이 s 내에 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6abdd6add896a729ee1aad307b9af57bdd6cad51" translate="yes" xml:space="preserve">
          <source>Contains reports whether the network includes ip.</source>
          <target state="translated">네트워크에 IP가 포함되어 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="f7cae610cac616dec3e9ae05c0c03197e4d666b4" translate="yes" xml:space="preserve">
          <source>ContainsAny</source>
          <target state="translated">ContainsAny</target>
        </trans-unit>
        <trans-unit id="877abb973dc781a3c8fa066aa0b824607b6f8b34" translate="yes" xml:space="preserve">
          <source>ContainsAny reports whether any Unicode code points in chars are within s.</source>
          <target state="translated">ContainsAny는 문자의 유니 코드 코드 포인트가 s 내에 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6caee33a35e9d91f330ffd6a91207ad4b9338f0d" translate="yes" xml:space="preserve">
          <source>ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.</source>
          <target state="translated">ContainsAny는 char에서 UTF-8로 인코딩 된 코드 포인트가 b 내에 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="7b7debe6ccf4ad9133e2542cad231bda0c85355b" translate="yes" xml:space="preserve">
          <source>ContainsRune</source>
          <target state="translated">ContainsRune</target>
        </trans-unit>
        <trans-unit id="81a6dc8ca3b6d8a1950b7ae7f379f764b29d9034" translate="yes" xml:space="preserve">
          <source>ContainsRune reports whether the Unicode code point r is within s.</source>
          <target state="translated">ContainsRune은 유니 코드 코드 포인트 r이 s 내에 있는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="dc1ff477a4e2194cf3761b5cdca699f501e9f919" translate="yes" xml:space="preserve">
          <source>ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.</source>
          <target state="translated">ContainsRune은 룬이 UTF-8로 인코딩 된 바이트 슬라이스에 포함되어 있는지 여부를보고합니다. b.</target>
        </trans-unit>
        <trans-unit id="d08542aeb2bfc8fbad4f388086aa29696fcb3614" translate="yes" xml:space="preserve">
          <source>Context returns the request's context. To change the context, use WithContext.</source>
          <target state="translated">컨텍스트는 요청의 컨텍스트를 반환합니다. 컨텍스트를 변경하려면 WithContext를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ca89f9f2a2036011eb5b4d2c57c4771153bb83e" translate="yes" xml:space="preserve">
          <source>Context's methods may be called by multiple goroutines simultaneously.</source>
          <target state="translated">컨텍스트의 메소드는 여러 고 루틴에 의해 동시에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c161cba0ca1d50bd8851cc88a3794c809cbe6fbe" translate="yes" xml:space="preserve">
          <source>ContextClientTrace returns the ClientTrace associated with the provided context. If none, it returns nil.</source>
          <target state="translated">ContextClientTrace는 제공된 컨텍스트와 연관된 ClientTrace를 리턴합니다. 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="049c25129edc0e21a3c2b9240307623c8b16b3e6" translate="yes" xml:space="preserve">
          <source>Contexts</source>
          <target state="translated">Contexts</target>
        </trans-unit>
        <trans-unit id="cfb055ddaa6fd827855b9a19519a485e47403121" translate="yes" xml:space="preserve">
          <source>Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly different formulae for converting between the two. This package follows the JFIF specification at &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/jfif3.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/jfif3.pdf&lt;/a&gt;.</source>
          <target state="translated">RGB와 Y'CbCr 간의 변환은 손실이 있으며 둘 사이에서 변환하기위한 약간 다른 수식이 여러 개 있습니다. 이 패키지는 &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/jfif3.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/jfif3.pdf&lt;/a&gt; 의 JFIF 사양을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="1b24506d2330c3e5aaf3eed9ee049df2b2edfc2e" translate="yes" xml:space="preserve">
          <source>Conversion of a uintptr back to Pointer is not valid in general.</source>
          <target state="translated">uintptr을 포인터로 다시 변환하는 것은 일반적으로 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b30242b973b465aec017dbe20811af00636e0e2" translate="yes" xml:space="preserve">
          <source>Convert returns the palette color closest to c in Euclidean R,G,B space.</source>
          <target state="translated">변환은 유클리드 R, G, B 공간에서 c에 가장 가까운 팔레트 색상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c65e78e2cfee0137de5015d96d98123ad8d7b4a" translate="yes" xml:space="preserve">
          <source>Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics.</source>
          <target state="translated">변환은 유형 v로 변환 된 값 v를 리턴합니다. 일반적인 Go 변환 규칙에서 v 값을 t로 변환 할 수없는 경우 패닉을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e60c6764e20f1ce7accef0e79715fc6de73a21bc" translate="yes" xml:space="preserve">
          <source>ConvertibleTo reports whether a value of type V is convertible to a value of type T.</source>
          <target state="translated">ConvertibleTo는 V 유형의 값이 T 유형의 값으로 변환 가능한지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="483087e44afa8d5285f534d77323c3706428debe" translate="yes" xml:space="preserve">
          <source>Converting a Pointer to a uintptr produces the memory address of the value pointed at, as an integer. The usual use for such a uintptr is to print it.</source>
          <target state="translated">포인터를 uintptr로 변환하면 지정된 값의 메모리 주소가 정수로 생성됩니다. 이러한 uintptr의 일반적인 용도는 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0018fef4e5fd6fb8ccad98bd3a6b012fe3ed5ae1" translate="yes" xml:space="preserve">
          <source>Cookie returns the named cookie provided in the request or ErrNoCookie if not found. If multiple cookies match the given name, only one cookie will be returned.</source>
          <target state="translated">쿠키는 요청에 제공된 이름이 지정된 쿠키를 반환하거나 찾지 못한 경우 ErrNoCookie를 반환합니다. 여러 쿠키가 지정된 이름과 일치하면 하나의 쿠키 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6444e3dab3b536b14d051c8ddab84942f9d59bd8" translate="yes" xml:space="preserve">
          <source>Cookies implements the Cookies method of the http.CookieJar interface.</source>
          <target state="translated">쿠키는 http.CookieJar 인터페이스의 쿠키 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="26998c84ce084428cbc2c95f6c5034ef7327f4b6" translate="yes" xml:space="preserve">
          <source>Cookies parses and returns the HTTP cookies sent with the request.</source>
          <target state="translated">쿠키는 요청과 함께 전송 된 HTTP 쿠키를 구문 분석하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4ee61025f9549bad8b3c189b6b5351e6c5ca43e" translate="yes" xml:space="preserve">
          <source>Cookies parses and returns the cookies set in the Set-Cookie headers.</source>
          <target state="translated">쿠키는 Set-Cookie 헤더에 설정된 쿠키를 구문 분석하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af74f7c5362aaee985bf8cda3dd75fc80751ce51" translate="yes" xml:space="preserve">
          <source>Copy</source>
          <target state="translated">Copy</target>
        </trans-unit>
        <trans-unit id="beb7d87db9d906cbb94fdddddfd16ebd8200101e" translate="yes" xml:space="preserve">
          <source>Copy copies from src to dst until either EOF is reached on src or an error occurs. It returns the number of bytes copied and the first error encountered while copying, if any.</source>
          <target state="translated">src에서 EOF에 도달하거나 오류가 발생할 때까지 src에서 dst로 사본을 복사하십시오. 복사 된 바이트 수와 복사하는 동안 발생한 첫 번째 오류 (있는 경우)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0205f10e265d450db71d0231c94dcdd7ee2bcc22" translate="yes" xml:space="preserve">
          <source>Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind Slice or Array, and dst and src must have the same element type.</source>
          <target state="translated">Copy는 dst가 채워지거나 src가 소진 될 때까지 src의 내용을 dst로 복사합니다. 복사 된 요소 수를 반환합니다. Dst와 src는 각각 종류 Slice 또는 Array를 가져야하고 dst와 src는 동일한 요소 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="c25087d7936e391bf0bd9a9677daefa0a23fe1f1" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of CharData.</source>
          <target state="translated">Copy는 CharData의 새 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7d2399aedb628cc2f8d794a248d5f004528fd643" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of Comment.</source>
          <target state="translated">Copy는 새로운 Comment의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5521199a98d40388c239495432fdbee20e2c5e5a" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of Directive.</source>
          <target state="translated">복사 명령의 새 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="214634d191d287336b71314070bded70f76703ef" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of ProcInst.</source>
          <target state="translated">Copy는 ProcInst의 새 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bac561e70b5c6132e566c02dab0a7d6e620b7ddf" translate="yes" xml:space="preserve">
          <source>Copy creates a new copy of StartElement.</source>
          <target state="translated">Copy는 StartElement의 새 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="348b21aa3d99a8eb531490f0d789fa2d48407193" translate="yes" xml:space="preserve">
          <source>Copy returns a copy of the Tree. Any parsing state is discarded.</source>
          <target state="translated">복사는 트리의 복사본을 반환합니다. 모든 파싱 상태는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b348613df7330d48a6b69a341a32bc0c4d80dfdd" translate="yes" xml:space="preserve">
          <source>Copy returns a new Regexp object copied from re. Calling Longest on one copy does not affect another.</source>
          <target state="translated">Copy는 re에서 복사 된 새로운 Regexp 객체를 반환합니다. 한 사본에서 가장 긴 전화는 다른 사본에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af6ad9f4b7202c4d4aa702fa0d11e6e42c64f298" translate="yes" xml:space="preserve">
          <source>Copy sets z to x, with the same precision, rounding mode, and accuracy as x, and returns z. x is not changed even if z and x are the same.</source>
          <target state="translated">복사는 z와 동일한 정밀도, 반올림 모드 및 정확도를 사용하여 z를 x로 설정하고 z를 반환합니다. z와 x가 동일하더라도 x는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5c9b724b033d22904dbdaaf4685127002553b21" translate="yes" xml:space="preserve">
          <source>CopyBuffer</source>
          <target state="translated">CopyBuffer</target>
        </trans-unit>
        <trans-unit id="c080972ed295a6ebb4d7b3256e9d876139134f56" translate="yes" xml:space="preserve">
          <source>CopyBuffer is identical to Copy except that it stages through the provided buffer (if one is required) rather than allocating a temporary one. If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer panics.</source>
          <target state="translated">CopyBuffer는 임시 버퍼를 할당하는 대신 제공된 버퍼 (필요한 경우)를 통해 스테이징한다는 점을 제외하면 Copy와 동일합니다. buf가 nil이면 하나가 할당됩니다. 그렇지 않으면 길이가 0이면 CopyBuffer 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85a2ca5d029e1c6970f41b82af47bb9334769ec9" translate="yes" xml:space="preserve">
          <source>CopyBytesToGo copies bytes from the Uint8Array src to dst. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst. CopyBytesToGo panics if src is not an Uint8Array.</source>
          <target state="translated">CopyBytesToGo는 Uint8Array src에서 dst로 바이트를 복사합니다. 복사 된 바이트 수를 리턴합니다. 이는 src 및 dst 길이의 최소값입니다. src가 Uint8Array가 아닌 경우 CopyBytesToGo 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="573547021c7d36d69889e15a8a5f480e4cd25fc9" translate="yes" xml:space="preserve">
          <source>CopyBytesToJS copies bytes from src to the Uint8Array dst. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst. CopyBytesToJS panics if dst is not an Uint8Array.</source>
          <target state="translated">CopyBytesToJS는 src에서 Uint8Array dst로 바이트를 복사합니다. 복사 된 바이트 수를 리턴합니다. 이는 src 및 dst 길이의 최소값입니다. dst가 Uint8Array가 아닌 경우 CopyBytesToJS 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39f366d8412f678e42a26af03a84764a3832b915" translate="yes" xml:space="preserve">
          <source>CopyN</source>
          <target state="translated">CopyN</target>
        </trans-unit>
        <trans-unit id="13eabe7df064bd68331ec1a12076fce45e9a8949" translate="yes" xml:space="preserve">
          <source>CopyN copies n bytes (or until an error) from src to dst. It returns the number of bytes copied and the earliest error encountered while copying. On return, written == n if and only if err == nil.</source>
          <target state="translated">CopyN은 n 바이트 (또는 오류까지)를 src에서 dst로 복사합니다. 복사 된 바이트 수와 복사하는 동안 발생한 가장 빠른 오류를 반환합니다. 리턴시, err == nil 인 경우에만 == n을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="4ea8264f41296a8535f3b62b02085fb7501b655e" translate="yes" xml:space="preserve">
          <source>CopyToken returns a copy of a Token.</source>
          <target state="translated">CopyToken은 토큰 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e28ad46ee857280975524037035d0acdc5ccadd" translate="yes" xml:space="preserve">
          <source>Copysign returns a value with the magnitude of x and the sign of y.</source>
          <target state="translated">Copysign은 x의 크기와 y의 부호를 가진 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95b49c2102dc476ebba131d7df167779ccb26544" translate="yes" xml:space="preserve">
          <source>Cos</source>
          <target state="translated">Cos</target>
        </trans-unit>
        <trans-unit id="b17b655c0904cccb87f841850df53a8ab3c54287" translate="yes" xml:space="preserve">
          <source>Cos returns the cosine of the radian argument x.</source>
          <target state="translated">Cos는 라디안 인수 x의 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a29bcf5033d335ce37060453688404db858a88c0" translate="yes" xml:space="preserve">
          <source>Cos returns the cosine of x.</source>
          <target state="translated">Cos는 x의 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b5b1efaa30aed45f32d083d3a9f4d02f9581898" translate="yes" xml:space="preserve">
          <source>Cosh</source>
          <target state="translated">Cosh</target>
        </trans-unit>
        <trans-unit id="7aea87b623bfac6726a31f524f1570268bf8bb6a" translate="yes" xml:space="preserve">
          <source>Cosh returns the hyperbolic cosine of x.</source>
          <target state="translated">Cosh는 x의 쌍곡 코사인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3751692394bf977f68d6c8a2af76f83b39dcbe23" translate="yes" xml:space="preserve">
          <source>Cot returns the cotangent of x.</source>
          <target state="translated">Cot는 x의 코탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="1edea34aa8c9a40389f9082a08e14e29cd4eba14" translate="yes" xml:space="preserve">
          <source>Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.</source>
          <target state="translated">Count는 s에서 sep의 겹치지 않는 인스턴스 수를 계산합니다. sep가 빈 슬라이스 인 경우 Count는 1 + UTF-8로 인코딩 된 코드 포인트 수를 s로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c7abecb94f08682b3b62e7992cd7849a1d85d24" translate="yes" xml:space="preserve">
          <source>Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s.</source>
          <target state="translated">Count는 s에서 substr의 겹치지 않는 인스턴스 수를 계산합니다. substr이 빈 문자열 인 경우 Count는 1 + s의 유니 코드 코드 포인트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41ab0173ab585bf8ee18604bba14b3111d20d350" translate="yes" xml:space="preserve">
          <source>Count returns the number of execution stacks currently in the profile.</source>
          <target state="translated">Count는 현재 프로필에있는 실행 스택 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="58c837e82670670080ba36b5dc5750591cb43079" translate="yes" xml:space="preserve">
          <source>Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="translated">커버는 테스트 커버리지 검사에 대한 정보를 기록합니다. 참고 :이 구조는 테스트 인프라 내부에 있으며 변경 될 수 있습니다. Go 1 호환성 가이드 라인은 아직 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be3f9c856b47a0e2f143dc72ed2fd31648da50af" translate="yes" xml:space="preserve">
          <source>CoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.</source>
          <target state="translated">CoverBlock은 단일 기본 블록에 대한 적용 범위 데이터를 기록합니다. 편집기에서와 같이 필드는 1- 인덱싱됩니다. 예를 들어 파일의 여는 줄은 1입니다. 열은 바이트 단위로 측정됩니다. 참고 :이 구조는 테스트 인프라 내부에 있으며 변경 될 수 있습니다. Go 1 호환성 가이드 라인은 아직 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d8612ba9657742f096cb1c88efe53acf35604d3" translate="yes" xml:space="preserve">
          <source>CoverMode reports what the test coverage mode is set to. The values are &quot;set&quot;, &quot;count&quot;, or &quot;atomic&quot;. The return value will be empty if test coverage is not enabled.</source>
          <target state="translated">CoverMode는 테스트 범위 모드가 설정된 것을보고합니다. 값은 &quot;set&quot;, &quot;count&quot;또는 &quot;atomic&quot;입니다. 테스트 범위가 활성화되지 않은 경우 반환 값이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b80d4e5292251354aefa94b883cdce6faedc160" translate="yes" xml:space="preserve">
          <source>Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0.</source>
          <target state="translated">적용 범위는 현재 코드 적용 범위를 [0, 1] 범위의 분수로보고합니다. 적용 범위가 활성화되지 않은 경우 적용 범위는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5be357b2b552293d3974bb945edcdd3d1f19d288" translate="yes" xml:space="preserve">
          <source>Create adds a file to the zip file using the provided name. It returns a Writer to which the file contents should be written. The file contents will be compressed using the Deflate method. The name must be a relative path: it must not start with a drive letter (e.g. C:) or leading slash, and only forward slashes are allowed. To create a directory instead of a file, add a trailing slash to the name. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.</source>
          <target state="translated">작성은 제공된 이름을 사용하여 파일을 zip 파일에 추가합니다. 파일 내용을 기록해야 할 라이터를 반환합니다. 파일 내용은 Deflate 방법을 사용하여 압축됩니다. 이름은 상대 경로 여야합니다. 드라이브 문자 (예 : C :) 나 슬래시로 시작해서는 안되며 슬래시 만 사용할 수 있습니다. 파일 대신 디렉토리를 작성하려면 이름에 후행 슬래시를 추가하십시오. 다음에 Create, CreateHeader 또는 Close를 호출하기 전에 파일 내용을 io.Writer에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9ad0c9c5822dfd8e33287f85e0053746b9a1d8c" translate="yes" xml:space="preserve">
          <source>Create creates or truncates the named file. If the file already exists, it is truncated. If the file does not exist, it is created with mode 0666 (before umask). If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR. If there is an error, it will be of type *PathError.</source>
          <target state="translated">작성은 이름 지정된 파일을 작성하거나 자릅니다. 파일이 이미 존재하면 잘립니다. 파일이 존재하지 않으면 모드 0666 (umask 이전)으로 작성됩니다. 성공하면 리턴 된 File의 메소드를 I / O에 사용할 수 있습니다. 연관된 파일 디스크립터에는 O_RDWR 모드가 있습니다. 오류가 있으면 * PathError 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1b465234e2012ae44b3245299f320c50140d6940" translate="yes" xml:space="preserve">
          <source>CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates.</source>
          <target state="translated">CreateCRL은이 인증서로 서명 된 DER로 인코딩 된 CRL을 반환합니다.이 CRL에는 지정된 해지 된 인증서 목록이 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8628c9b06db422c5fa609b650cab7ab2c9d7d80" translate="yes" xml:space="preserve">
          <source>CreateCertificate creates a new X.509v3 certificate based on a template. The following members of template are used:</source>
          <target state="translated">CreateCertificate는 템플릿을 기반으로 새 X.509v3 인증서를 만듭니다. 다음과 같은 템플릿 멤버가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73c01ccfb480001ffa3c411d49610d7de6487d44" translate="yes" xml:space="preserve">
          <source>CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used:</source>
          <target state="translated">CreateCertificateRequest는 템플릿을 기반으로 새 인증서 요청을 만듭니다. 다음과 같은 템플릿 멤버가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c10d1e701a1ded06204ed87d7c168c5ecc136a8" translate="yes" xml:space="preserve">
          <source>CreateFormField calls CreatePart with a header using the given field name.</source>
          <target state="translated">CreateFormField는 주어진 필드 이름을 사용하여 헤더와 함께 CreatePart를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="53037004a6a76e3b70492980878a44bda2d363cb" translate="yes" xml:space="preserve">
          <source>CreateFormFile is a convenience wrapper around CreatePart. It creates a new form-data header with the provided field name and file name.</source>
          <target state="translated">CreateFormFile은 CreatePart를 둘러싼 편리한 래퍼입니다. 제공된 필드 이름과 파일 이름으로 새 양식 데이터 헤더를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9d1649722dbb1b219b1b7b37cdfc28c7f3c99574" translate="yes" xml:space="preserve">
          <source>CreateHeader adds a file to the zip archive using the provided FileHeader for the file metadata. Writer takes ownership of fh and may mutate its fields. The caller must not modify fh after calling CreateHeader.</source>
          <target state="translated">CreateHeader는 파일 메타 데이터에 제공된 FileHeader를 사용하여 zip 아카이브에 파일을 추가합니다. 작가는 fh의 소유권을 가지며 필드를 변경시킬 수 있습니다. 호출자는 CreateHeader를 호출 한 후 fh를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3285ffa2e28574fc6f309813b4ff68aff6bdde1e" translate="yes" xml:space="preserve">
          <source>CreatePart creates a new multipart section with the provided header. The body of the part should be written to the returned Writer. After calling CreatePart, any previous part may no longer be written to.</source>
          <target state="translated">CreatePart는 제공된 헤더를 사용하여 새 멀티 파트 섹션을 작성합니다. 부품의 본문은 반환 된 Writer에 작성해야합니다. CreatePart를 호출 한 후에는 이전 파트를 더 이상 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="14a50bbc334f201429fba3c65d621a9109ba53dd" translate="yes" xml:space="preserve">
          <source>Credential holds user and group identities to be assumed by a child process started by StartProcess.</source>
          <target state="translated">자격 증명에는 StartProcess에 의해 시작된 자식 프로세스에서 가정 할 사용자 및 그룹 ID가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2387616d5263d298421004495f585b27c0b5f292" translate="yes" xml:space="preserve">
          <source>Crit logs a message with severity LOG_CRIT, ignoring the severity passed to New.</source>
          <target state="translated">Crit는 심각도가 LOG_CRIT 인 메시지를 기록하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b00b9e8f709739fdb419a61ad788ae6cd5c543db" translate="yes" xml:space="preserve">
          <source>Ctz32 counts trailing (low-order) zeroes, and if all are zero, then 32.</source>
          <target state="translated">Ctz32는 후행 (하위) 0을 계산하고 모두 0이면 32를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="93b80f5eb281e63bbdd5e4cb006c6e407851c617" translate="yes" xml:space="preserve">
          <source>Ctz64 counts trailing (low-order) zeroes, and if all are zero, then 64.</source>
          <target state="translated">Ctz64는 후행 (낮은 순서) 0을 계산하고 모두 0이면 64를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f360a645e3031852f77e3ee38c6b9e9ae5132853" translate="yes" xml:space="preserve">
          <source>Ctz8 returns the number of trailing zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">Ctz8은 x의 후행 0 비트 수를 반환합니다. 결과는 x == 0에 대해 8입니다.</target>
        </trans-unit>
        <trans-unit id="186a4ac4b5e83e7a09290593db86c1ac147b44e3" translate="yes" xml:space="preserve">
          <source>Current returns the current user.</source>
          <target state="translated">현재는 현재 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="046f17348f9f906b4db2ced159222fabbc9be2e8" translate="yes" xml:space="preserve">
          <source>Currently only the responder role is supported.</source>
          <target state="translated">현재 응답자 역할 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ddc0402f7a41556c97834c86c42fb8d452886c5f" translate="yes" xml:space="preserve">
          <source>Currently plugins are only supported on Linux and macOS. Please report any issues.</source>
          <target state="translated">현재 플러그인은 Linux 및 macOS에서만 지원됩니다. 문제를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="5ba7859fdac5d2aff950209f094dd563445b9cf8" translate="yes" xml:space="preserve">
          <source>CurveID is the type of a TLS identifier for an elliptic curve. See &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8&lt;/a&gt;.</source>
          <target state="translated">CurveID는 타원 곡선의 TLS 식별자 유형입니다. &lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8&quot;&gt;https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="446785414e4504abe5ec1c9315a5bfdfeeaa65b9" translate="yes" xml:space="preserve">
          <source>CurveParams contains the parameters of an elliptic curve and also provides a generic, non-constant time implementation of Curve.</source>
          <target state="translated">CurveParams는 타원 곡선의 매개 변수를 포함하며 곡선의 일정하고 일정하지 않은 시간 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="854ee953a12f6750d2f08f38118ba7df90d83bdc" translate="yes" xml:space="preserve">
          <source>DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines.</source>
          <target state="translated">DB는 0 개 이상의 기본 연결 풀을 나타내는 데이터베이스 핸들입니다. 여러 고 루틴이 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="3438f449cf114423437931b85b59a20310743baa" translate="yes" xml:space="preserve">
          <source>DB.ExecContext</source>
          <target state="translated">DB.ExecContext</target>
        </trans-unit>
        <trans-unit id="4aef1f529992ef7bd420a755b7f2a4dc07114a5a" translate="yes" xml:space="preserve">
          <source>DB.PingContext</source>
          <target state="translated">DB.PingContext</target>
        </trans-unit>
        <trans-unit id="014f16301351fe7114ed2958ee3525ac47050c48" translate="yes" xml:space="preserve">
          <source>DB.Prepare</source>
          <target state="translated">DB.Prepare</target>
        </trans-unit>
        <trans-unit id="e1974d7b34d29bc8a688d9f9e7d5ec7d48b32785" translate="yes" xml:space="preserve">
          <source>DB.Query (MultipleResultSets)</source>
          <target state="translated">DB.Query (여러 결과 집합)</target>
        </trans-unit>
        <trans-unit id="3fac6432252b873f3e946e93a10e5043368270d0" translate="yes" xml:space="preserve">
          <source>DB.QueryContext</source>
          <target state="translated">DB.QueryContext</target>
        </trans-unit>
        <trans-unit id="c09ea214d64b802519f42c1121ca2d585ae10183" translate="yes" xml:space="preserve">
          <source>DB.QueryRowContext</source>
          <target state="translated">DB.QueryRowContext</target>
        </trans-unit>
        <trans-unit id="062f2d0e3b266bc2766487d180f93108c3093e01" translate="yes" xml:space="preserve">
          <source>DBStats contains database statistics.</source>
          <target state="translated">DBStats에는 데이터베이스 통계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b22c78e263cb9da0783e024b9041b95e30c3fd7e" translate="yes" xml:space="preserve">
          <source>DEFLATE is suitable for transmitting compressed data across the network.</source>
          <target state="translated">DEFLATE는 네트워크를 통해 압축 된 데이터를 전송하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="6af7313c68e1a507942c8bee4f518b61d590aa88" translate="yes" xml:space="preserve">
          <source>DES is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">DES는 암호화 방식으로 손상되어 보안 응용 프로그램에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a7c0828ff50d909531c4a019b63724f3f819cb6e" translate="yes" xml:space="preserve">
          <source>DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.)</source>
          <target state="translated">DNSConfigError는 시스템의 DNS 구성을 읽는 중 오류를 나타냅니다. (더 이상 사용되지 않으며 호환성을 위해 유지됩니다.)</target>
        </trans-unit>
        <trans-unit id="0df21b6b932ef4553f314a2223c92a1fd8610f2a" translate="yes" xml:space="preserve">
          <source>DNSDoneInfo contains information about the results of a DNS lookup.</source>
          <target state="translated">DNSDoneInfo는 DNS 조회 결과에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bc71ea6ab70a230a454b764448619c3ce8a1b674" translate="yes" xml:space="preserve">
          <source>DNSError represents a DNS lookup error.</source>
          <target state="translated">DNSError는 DNS 조회 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e565458ee90bae74c1103c0b4dba206d05e11b0c" translate="yes" xml:space="preserve">
          <source>DNSStartInfo contains information about a DNS request.</source>
          <target state="translated">DNSStartInfo는 DNS 요청에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bd1616e9afd3f1b8cb1bc3466e944671742326c0" translate="yes" xml:space="preserve">
          <source>DT_FLAGS values.</source>
          <target state="translated">DT_FLAGS 값.</target>
        </trans-unit>
        <trans-unit id="eb9fd8102c5656418aee4dc0dab53238b17f6eec" translate="yes" xml:space="preserve">
          <source>DWARF returns the DWARF debug information for the Mach-O file.</source>
          <target state="translated">DWARF는 Mach-O 파일에 대한 DWARF 디버그 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44e21ef2fb7f3aeea7da384ee4026d7b21cfb109" translate="yes" xml:space="preserve">
          <source>DWARF version 4 distinguishes attribute value classes more finely than previous versions of DWARF. The reader will disambiguate coarser classes from earlier versions of DWARF into the appropriate DWARF 4 class. For example, DWARF 2 uses &quot;constant&quot; for constants as well as all types of section offsets, but the reader will canonicalize attributes in DWARF 2 files that refer to section offsets to one of the Class*Ptr classes, even though these classes were only defined in DWARF 3.</source>
          <target state="translated">DWARF 버전 4는 속성 값 클래스를 이전 버전의 DWARF보다 세밀하게 구분합니다. 독자는 이전 버전의 DWARF에서 더 거친 클래스를 적절한 DWARF 4 클래스로 명확하게 설명합니다. 예를 들어, DWARF 2는 모든 유형의 섹션 오프셋뿐만 아니라 상수에 &quot;상수&quot;를 사용하지만 독자는 이러한 클래스 만 해당하더라도 Class * Ptr 클래스 중 하나에 대한 섹션 오프셋을 참조하는 DWARF 2 파일의 속성을 정규화 할 수 있습니다. DWARF 3에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1c6592f23da912c4adb4e08b65b073609bb89a" translate="yes" xml:space="preserve">
          <source>Data is found in Header.Ident[EI_DATA] and Header.Data.</source>
          <target state="translated">데이터는 Header.Ident [EI_DATA] 및 Header.Data에 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ca24289e70a941b8b696bdff0abf87b99534a8" translate="yes" xml:space="preserve">
          <source>Data issues a DATA command to the server and returns a writer that can be used to write the mail headers and body. The caller should close the writer before calling any more methods on c. A call to Data must be preceded by one or more calls to Rcpt.</source>
          <target state="translated">데이터는 서버에 DATA 명령을 발행하고 메일 헤더 및 본문을 작성하는 데 사용할 수있는 기록기를 리턴합니다. 호출자는 c에서 더 이상의 메소드를 호출하기 전에 작성기를 닫아야합니다. Data에 대한 호출 앞에는 Rcpt에 대한 호출이 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c93ed1b3e1e4d4276c13585e691d22da36a26d7d" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the ELF section. Even if the section is stored compressed in the ELF file, Data returns uncompressed data.</source>
          <target state="translated">데이터는 ELF 섹션의 내용을 읽고 반환합니다. 섹션이 ELF 파일로 압축 저장되어 있어도 Data는 압축되지 않은 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb762c577e910ca34f7f6a619fca3236b8e65a78" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the Mach-O section.</source>
          <target state="translated">데이터는 Mach-O 섹션의 내용을 읽고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44cd1191853d4999e06b3841282ce1e62b05ad52" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the PE section s.</source>
          <target state="translated">데이터는 PE 섹션의 내용을 읽고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d131a5630dfb89ad0914d47cac99e85517e0f18" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the Plan 9 a.out section.</source>
          <target state="translated">데이터는 Plan 9 a.out 섹션의 내용을 읽고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4e4adf3b85e43c16f7986aa10f34f35072f6eea1" translate="yes" xml:space="preserve">
          <source>Data reads and returns the contents of the segment.</source>
          <target state="translated">데이터는 세그먼트의 내용을 읽고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f79ddac999330fab22c9a79fd22e8012029e050" translate="yes" xml:space="preserve">
          <source>Data represents the DWARF debugging information loaded from an executable file (for example, an ELF or Mach-O executable).</source>
          <target state="translated">데이터는 실행 파일 (예 : ELF 또는 Mach-O 실행 파일)에서로드 된 DWARF 디버깅 정보를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c6bc8adab78b04c6b3688d1e1ff626160d863530" translate="yes" xml:space="preserve">
          <source>DataErrReader changes the way errors are handled by a Reader. Normally, a Reader returns an error (typically EOF) from the first Read call after the last piece of data is read. DataErrReader wraps a Reader and changes its behavior so the final error is returned along with the final data, instead of in the first call after the final data.</source>
          <target state="translated">DataErrReader는 리더가 오류를 처리하는 방식을 변경합니다. 일반적으로 Reader는 마지막 데이터 조각을 읽은 후 첫 번째 읽기 호출에서 오류 (일반적으로 EOF)를 반환합니다. DataErrReader는 Reader를 랩핑하고 동작을 변경하여 최종 데이터 이후의 첫 번째 호출이 아니라 최종 데이터와 함께 최종 오류가 리턴되도록합니다.</target>
        </trans-unit>
        <trans-unit id="5eb9616bdfbeffc11e87fe7230443e52f6bea614" translate="yes" xml:space="preserve">
          <source>DataOffset returns the offset of the file's possibly-compressed data, relative to the beginning of the zip file.</source>
          <target state="translated">DataOffset은 zip 파일의 시작 부분을 기준으로 파일의 압축 가능한 데이터의 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e09d2f8039589d9ae6e6561e5dcd42da64f6928d" translate="yes" xml:space="preserve">
          <source>Database drivers may implement DriverContext for access to contexts and to parse the name only once for a pool of connections, instead of once per connection.</source>
          <target state="translated">데이터베이스 드라이버는 컨텍스트에 액세스하고 연결 당 한 번이 아니라 연결 풀에 대해 한 번만 이름을 구문 분석하기 위해 DriverContext를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73570fc5828e9254e320eeb24fbd8b1ead4beb2e" translate="yes" xml:space="preserve">
          <source>DatabaseTypeName returns the database system name of the column type. If an empty string is returned the driver type name is not supported. Consult your driver documentation for a list of driver data types. Length specifiers are not included. Common type include &quot;VARCHAR&quot;, &quot;TEXT&quot;, &quot;NVARCHAR&quot;, &quot;DECIMAL&quot;, &quot;BOOL&quot;, &quot;INT&quot;, &quot;BIGINT&quot;.</source>
          <target state="translated">DatabaseTypeName은 열 유형의 데이터베이스 시스템 이름을 리턴합니다. 빈 문자열이 반환되면 드라이버 유형 이름이 지원되지 않습니다. 드라이버 데이터 유형 목록은 드라이버 설명서를 참조하십시오. 길이 지정자는 포함되지 않습니다. 일반적인 유형에는 &quot;VARCHAR&quot;, &quot;TEXT&quot;, &quot;NVARCHAR&quot;, &quot;DECIMAL&quot;, &quot;BOOL&quot;, &quot;INT&quot;, &quot;BIGINT&quot;가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="159c09d3aeadb72b1f5514f38a813eb4c5b0683a" translate="yes" xml:space="preserve">
          <source>Date panics if loc is nil.</source>
          <target state="translated">loc이 nil이면 날짜 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b8ae8791f875e5c0659aa843bd5208912c32d54d" translate="yes" xml:space="preserve">
          <source>Date parses the Date header field.</source>
          <target state="translated">날짜는 날짜 헤더 필드를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="7d0982177e2a17b0a887ab4e3c2bcc10514bc3a0" translate="yes" xml:space="preserve">
          <source>Date returns the Time corresponding to</source>
          <target state="translated">날짜는 해당 시간을 반환합니다</target>
        </trans-unit>
        <trans-unit id="19811d3575925e21d39da4f63d5d36e7f8d5e6a6" translate="yes" xml:space="preserve">
          <source>Date returns the year, month, and day in which t occurs.</source>
          <target state="translated">Date는 t가 발생한 연도, 월 및 일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="51777aaad416543ccd0b64993945fa0970cfeed2" translate="yes" xml:space="preserve">
          <source>Day returns the day of the month specified by t.</source>
          <target state="translated">Day는 t로 지정된 달의 날짜를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0b4ce5abf04cac4f6b56fb7b5ca2f32ee8f6950" translate="yes" xml:space="preserve">
          <source>DeadlineExceeded is the error returned by Context.Err when the context's deadline passes.</source>
          <target state="translated">DeadlineExceeded는 컨텍스트의 최종 기한이 지났을 때 Context.Err에 의해 반환 된 오류입니다.</target>
        </trans-unit>
        <trans-unit id="00dbeaa14d4aaefd27f0b729c8572efea591c54d" translate="yes" xml:space="preserve">
          <source>Debug logs a message with severity LOG_DEBUG, ignoring the severity passed to New.</source>
          <target state="translated">디버그는 심각도가 LOG_DEBUG 인 메시지를 기록하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fcbfaca68a329233bc04528ed643e96af823c8d1" translate="yes" xml:space="preserve">
          <source>Debugging support</source>
          <target state="translated">디버깅 지원</target>
        </trans-unit>
        <trans-unit id="290f9cdf409ce3485bc3ebf61922e97b96ab6dba" translate="yes" xml:space="preserve">
          <source>DecimalSize returns the scale and precision of a decimal type. If not applicable or if not supported ok is false.</source>
          <target state="translated">DecimalSize는 소수 유형의 스케일과 정밀도를 반환합니다. 해당되지 않거나 지원되지 않는 경우 ok는 false입니다.</target>
        </trans-unit>
        <trans-unit id="df50d3b937b66b95438db0baeefd22f2c1fa73b6" translate="yes" xml:space="preserve">
          <source>Decode</source>
          <target state="translated">Decode</target>
        </trans-unit>
        <trans-unit id="2191bd1edaed1f948c446e5e5051b352674263c5" translate="yes" xml:space="preserve">
          <source>Decode decodes an RFC 2047 encoded-word.</source>
          <target state="translated">디코딩은 RFC 2047 인코딩 된 단어를 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="c663a98c9ac4bdfaf7570d06109ce1220330af72" translate="yes" xml:space="preserve">
          <source>Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package.</source>
          <target state="translated">디코딩은 등록 된 형식으로 인코딩 된 이미지를 디코딩합니다. 반환 된 문자열은 형식 등록 중에 사용 된 형식 이름입니다. 형식 등록은 일반적으로 코덱 별 패키지의 init 함수에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="be2862aea68bddc3797cc61a25b04a065153d058" translate="yes" xml:space="preserve">
          <source>Decode decodes src into DecodedLen(len(src)) bytes, returning the actual number of bytes written to dst.</source>
          <target state="translated">디코드는 src를 DecodedLen (len (src)) 바이트로 디코딩하여 dst에 기록 된 실제 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9459e2df37f9d7b79d9c22b47888407d5cae69bd" translate="yes" xml:space="preserve">
          <source>Decode decodes src into dst, returning both the number of bytes written to dst and the number consumed from src. If src contains invalid ascii85 data, Decode will return the number of bytes successfully written and a CorruptInputError. Decode ignores space and control characters in src. Often, ascii85-encoded data is wrapped in &amp;lt;~ and ~&amp;gt; symbols. Decode expects these to have been stripped by the caller.</source>
          <target state="translated">디코드는 src를 dst로 디코딩하여 dst에 기록 된 바이트 수와 src에서 소비 된 수를 모두 반환합니다. src에 유효하지 않은 ascii85 데이터가 포함되어 있으면 Decode는 성공적으로 작성된 바이트 수와 CorruptInputError를 반환합니다. 디코딩은 src에서 공백과 제어 문자를 무시합니다. 종종 ascii85로 인코딩 된 데이터는 &amp;lt;~ 및 ~&amp;gt; 기호로 래핑됩니다. 디코드는 호출자가이를 제거 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="f4e08a18b5e0596336160230bc4fa0088423d426" translate="yes" xml:space="preserve">
          <source>Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base32 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\r and \n) are ignored.</source>
          <target state="translated">디코딩은 인코딩 enc를 사용하여 src를 디코딩합니다. 최대 DecodedLen (len (src)) 바이트를 dst에 기록하고 쓴 바이트 수를 반환합니다. src에 유효하지 않은 base32 데이터가 있으면 성공적으로 쓴 바이트 수와 CorruptInputError를 리턴합니다. 줄 바꾸기 문자 (\ r 및 \ n)는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="49467dca1e0d0001bc71fa1ac5e9147e30acd4c0" translate="yes" xml:space="preserve">
          <source>Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base64 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\r and \n) are ignored.</source>
          <target state="translated">디코딩은 인코딩 enc를 사용하여 src를 디코딩합니다. 최대 DecodedLen (len (src)) 바이트를 dst에 기록하고 쓴 바이트 수를 반환합니다. src에 유효하지 않은 base64 데이터가 있으면 성공적으로 작성된 바이트 수와 CorruptInputError를 리턴합니다. 줄 바꾸기 문자 (\ r 및 \ n)는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f1335189afa4a7c6f3ae9a3d92e18b92bfef1e8" translate="yes" xml:space="preserve">
          <source>Decode expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, Decode returns the number of bytes decoded before the error.</source>
          <target state="translated">Decode는 src에 16 진 문자 만 포함하고 src의 길이는 짝수 여야합니다. 입력이 잘못되면 Decode는 오류 전에 디코딩 된 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="800876565052483ae20792dbb4cd593c7c3b8846" translate="yes" xml:space="preserve">
          <source>Decode reads a GIF image from r and returns the first embedded image as an image.Image.</source>
          <target state="translated">디코딩은 r에서 GIF 이미지를 읽고 첫 번째 포함 된 이미지를 이미지로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbac39d9a826fbc5afe7154ac34bd2df498566b4" translate="yes" xml:space="preserve">
          <source>Decode reads a JPEG image from r and returns it as an image.Image.</source>
          <target state="translated">디코딩은 r에서 JPEG 이미지를 읽어 이미지로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e54593218bc1af392b920a78974a97581bf2c1c" translate="yes" xml:space="preserve">
          <source>Decode reads a PNG image from r and returns it as an image.Image. The type of Image returned depends on the PNG contents.</source>
          <target state="translated">디코딩은 r에서 PNG 이미지를 읽고 이미지로 반환합니다. 반환되는 이미지 유형은 PNG 내용에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fd5abcbefea9089a4ce5a4a52a242638dfec04e7" translate="yes" xml:space="preserve">
          <source>Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.</source>
          <target state="translated">디코드는 입력에서 다음 JSON 인코딩 값을 읽고 v가 가리키는 값에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9d1df86160a0f777c4ef84d3e5e05362d86ed78c" translate="yes" xml:space="preserve">
          <source>Decode reads the next value from the input stream and stores it in the data represented by the empty interface value. If e is nil, the value will be discarded. Otherwise, the value underlying e must be a pointer to the correct type for the next data item received. If the input is at EOF, Decode returns io.EOF and does not modify e.</source>
          <target state="translated">디코드는 입력 스트림에서 다음 값을 읽고 빈 인터페이스 값으로 표시되는 데이터에 저장합니다. e가 nil이면 값이 삭제됩니다. 그렇지 않으면 e의 기본 값은 수신 된 다음 데이터 항목의 올바른 유형에 대한 포인터 여야합니다. 입력이 EOF이면 Decode는 io.EOF를 반환하고 e를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24fe9f25ab1a2483c4e260dc7fcba6455fbea3ba" translate="yes" xml:space="preserve">
          <source>Decode returns the Unicode code point sequence represented by the UTF-16 encoding s.</source>
          <target state="translated">디코드는 UTF-16 인코딩으로 표시되는 유니 코드 코드 포인트 시퀀스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f00520e26a1f23f03c003d00547bb432a3a235dc" translate="yes" xml:space="preserve">
          <source>Decode will find the next PEM formatted block (certificate, private key etc) in the input. It returns that block and the remainder of the input. If no PEM data is found, p is nil and the whole of the input is returned in rest.</source>
          <target state="translated">디코드는 입력에서 다음 PEM 형식 블록 (인증서, 개인 키 등)을 찾습니다. 해당 블록과 나머지 입력을 반환합니다. PEM 데이터가 없으면 p는 nil이며 입력 전체가 정지 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b302987dc20b61b9749892b479e69a5e336abe4" translate="yes" xml:space="preserve">
          <source>Decode works like Unmarshal, except it reads the decoder stream to find the start element.</source>
          <target state="translated">디코드는 시작 요소를 찾기 위해 디코더 스트림을 읽는다는 점을 제외하고 비 정렬 화처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="30e37be960ab676eab0d765515fe1771dae55149" translate="yes" xml:space="preserve">
          <source>DecodeAll reads a GIF image from r and returns the sequential frames and timing information.</source>
          <target state="translated">DecodeAll은 r에서 GIF 이미지를 읽고 순차적 인 프레임과 타이밍 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4e7173f24924751aa452948d7c6dfbb2edeac9e" translate="yes" xml:space="preserve">
          <source>DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package.</source>
          <target state="translated">DecodeConfig는 등록 된 형식으로 인코딩 된 이미지의 색상 모델과 치수를 디코딩합니다. 반환 된 문자열은 형식 등록 중에 사용 된 형식 이름입니다. 형식 등록은 일반적으로 코덱 별 패키지의 init 함수에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b9adb0fd972eb06c032b93d684f65d570cdcabda" translate="yes" xml:space="preserve">
          <source>DecodeConfig returns the color model and dimensions of a JPEG image without decoding the entire image.</source>
          <target state="translated">DecodeConfig는 전체 이미지를 디코딩하지 않고 JPEG 이미지의 색상 모델과 치수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3a5c1fae5c349d3734ae4489d6aecc2426c5ac7" translate="yes" xml:space="preserve">
          <source>DecodeConfig returns the color model and dimensions of a PNG image without decoding the entire image.</source>
          <target state="translated">DecodeConfig는 전체 이미지를 디코딩하지 않고 PNG 이미지의 색상 모델과 치수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbf91fca372aef697adf69e21434c0270fdba345" translate="yes" xml:space="preserve">
          <source>DecodeConfig returns the global color model and dimensions of a GIF image without decoding the entire image.</source>
          <target state="translated">DecodeConfig는 전체 이미지를 디코딩하지 않고 GIF 이미지의 전체 색상 모델과 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1eb5cc06614fd4437a26a4a1653271c12295a5e" translate="yes" xml:space="preserve">
          <source>DecodeElement works like Unmarshal except that it takes a pointer to the start XML element to decode into v. It is useful when a client reads some raw XML tokens itself but also wants to defer to Unmarshal for some elements.</source>
          <target state="translated">DecodeElement는 v로 디코딩하기 위해 시작 XML 요소에 대한 포인터가 필요하다는 점을 제외하고 Unmarshal과 유사하게 작동합니다. 클라이언트가 일부 원시 XML 토큰 자체를 읽지 만 일부 요소에 대해 Unmarshal을 연기하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="16713e78705fc06f8e05be74c5067eb69b310b90" translate="yes" xml:space="preserve">
          <source>DecodeHeader decodes all encoded-words of the given string. It returns an error if and only if CharsetReader of d returns an error.</source>
          <target state="translated">DecodeHeader는 주어진 문자열의 모든 인코딩 된 단어를 디코딩합니다. d의 CharsetReader가 오류를 반환하는 경우에만 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8e172ef50e9276e57b5335bf4faa51bee2741d8" translate="yes" xml:space="preserve">
          <source>DecodeLastRune</source>
          <target state="translated">DecodeLastRune</target>
        </trans-unit>
        <trans-unit id="3ae3ba953157b1585814d3fce39e0a50852e7948" translate="yes" xml:space="preserve">
          <source>DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="translated">DecodeLastRune는 p에서 마지막 UTF-8 인코딩을 풀고 룬과 너비를 바이트 단위로 리턴합니다. p가 비어 있으면 (RuneError, 0)을 반환합니다. 그렇지 않으면 인코딩이 유효하지 않으면 (RuneError, 1)을 반환합니다. 비어 있지 않은 올바른 UTF-8에 대해서는 둘 다 불가능한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="5bc57e376dc0f134c4bfab7438a8b69c1e50c7e0" translate="yes" xml:space="preserve">
          <source>DecodeLastRuneInString</source>
          <target state="translated">DecodeLastRuneInString</target>
        </trans-unit>
        <trans-unit id="a8a8169059d7047067fb3a3b04fe37855654bbaa" translate="yes" xml:space="preserve">
          <source>DecodeLastRuneInString is like DecodeLastRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="translated">DecodeLastRuneInString은 DecodeLastRune과 비슷하지만 입력은 문자열입니다. s가 비어 있으면 (RuneError, 0)을 반환합니다. 그렇지 않으면 인코딩이 유효하지 않으면 (RuneError, 1)을 반환합니다. 비어 있지 않은 올바른 UTF-8에 대해서는 둘 다 불가능한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0c840a2944c7b78051c2f4d24c001bb3db7586d2" translate="yes" xml:space="preserve">
          <source>DecodeRune</source>
          <target state="translated">DecodeRune</target>
        </trans-unit>
        <trans-unit id="ebe1a4295199ea56faf52e25cbf7c1b995fb5581" translate="yes" xml:space="preserve">
          <source>DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode replacement code point U+FFFD.</source>
          <target state="translated">DecodeRune은 서로 게이트 쌍의 UTF-16 디코딩을 반환합니다. 쌍이 유효한 UTF-16 서로 게이트 쌍이 아닌 경우 DecodeRune은 유니 코드 대체 코드 포인트 U + FFFD를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1cf3960cee32acc9ec4f47da069c9ab188d23f22" translate="yes" xml:space="preserve">
          <source>DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="translated">DecodeRune은 p에서 첫 번째 UTF-8 인코딩을 풀고 룬과 너비를 바이트 단위로 반환합니다. p가 비어 있으면 (RuneError, 0)을 반환합니다. 그렇지 않으면 인코딩이 유효하지 않으면 (RuneError, 1)을 반환합니다. 비어 있지 않은 올바른 UTF-8에 대해서는 둘 다 불가능한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="88cfb2ee82f7d9405832cfa50700196812107d51" translate="yes" xml:space="preserve">
          <source>DecodeRuneInString</source>
          <target state="translated">DecodeRuneInString</target>
        </trans-unit>
        <trans-unit id="4d4647dc4c9636993df78e7b7af6c3ed7bc1b87f" translate="yes" xml:space="preserve">
          <source>DecodeRuneInString is like DecodeRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.</source>
          <target state="translated">DecodeRuneInString은 DecodeRune과 비슷하지만 입력은 문자열입니다. s가 비어 있으면 (RuneError, 0)을 반환합니다. 그렇지 않으면 인코딩이 유효하지 않으면 (RuneError, 1)을 반환합니다. 비어 있지 않은 올바른 UTF-8에 대해서는 둘 다 불가능한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="745e8eb6ad128aef996ff9d7b991cd3156884887" translate="yes" xml:space="preserve">
          <source>DecodeString</source>
          <target state="translated">DecodeString</target>
        </trans-unit>
        <trans-unit id="a2995ec38a1c149f49a43c3725e4ad8ab6ccd917" translate="yes" xml:space="preserve">
          <source>DecodeString expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, DecodeString returns the bytes decoded before the error.</source>
          <target state="translated">DecodeString은 src에 16 진 문자 만 포함하고 src의 길이는 짝수 여야합니다. 입력이 잘못되면 DecodeString은 오류 전에 디코딩 된 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28b43cb23d14fc7963d139c1d5ae99c19fcc2059" translate="yes" xml:space="preserve">
          <source>DecodeString returns the bytes represented by the base32 string s.</source>
          <target state="translated">DecodeString은 base32 문자열로 표시되는 바이트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bf0c084f0da6a7f9bfbaeea805ea061f148fa74e" translate="yes" xml:space="preserve">
          <source>DecodeString returns the bytes represented by the base64 string s.</source>
          <target state="translated">DecodeString은 base64 문자열로 표시되는 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56ca5d4a132d23d7b5bfe286e9414cf1733e1fd7" translate="yes" xml:space="preserve">
          <source>DecodeString returns the bytes represented by the hexadecimal string s.</source>
          <target state="translated">DecodeString은 16 진 문자열 s로 표시되는 바이트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="673f927f28506c494b47dc9326f68e21fe962028" translate="yes" xml:space="preserve">
          <source>DecodeValue reads the next value from the input stream. If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value. Otherwise, it stores the value into v. In that case, v must represent a non-nil pointer to data or be an assignable reflect.Value (v.CanSet()) If the input is at EOF, DecodeValue returns io.EOF and does not modify v.</source>
          <target state="translated">DecodeValue는 입력 스트림에서 다음 값을 읽습니다. v가 0 인 reflect.Value (v.Kind () == Invalid) 인 경우 DecodeValue는 값을 삭제합니다. 그렇지 않으면, 값을 v에 저장합니다.이 경우, v는 데이터에 대한 0이 아닌 포인터를 나타내거나 지정 가능한 반영이어야합니다. 값 (v.CanSet ()) 입력이 EOF이면 DecodeValue는 io.EOF를 리턴합니다. v를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ee37cdba307bd5c5065d5683f7caa610723e58f" translate="yes" xml:space="preserve">
          <source>DecodedLen returns the length of a decoding of x source bytes. Specifically, it returns x / 2.</source>
          <target state="translated">DecodedLen은 x 소스 바이트의 디코딩 길이를 반환합니다. 특히 x / 2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be5f0b99888068a2482a86b50382454ef22b14f5" translate="yes" xml:space="preserve">
          <source>DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base32-encoded data.</source>
          <target state="translated">DecodedLen은 n 바이트의 base32 인코딩 데이터에 해당하는 디코딩 된 데이터의 최대 길이를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6813385272ace1ce0fb064215644848699dad2c" translate="yes" xml:space="preserve">
          <source>DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base64-encoded data.</source>
          <target state="translated">DecodedLen은 n 바이트의 base64 인코딩 데이터에 해당하는 디코딩 된 데이터의 최대 길이를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7be2f0f143224d91c1d79bb0d11cb4d0a2c69cde" translate="yes" xml:space="preserve">
          <source>Decoder</source>
          <target state="translated">Decoder</target>
        </trans-unit>
        <trans-unit id="996bd0771aab35e5131c87bd200dc9468eb01de6" translate="yes" xml:space="preserve">
          <source>Decoder.Decode (Stream)</source>
          <target state="translated">디코더. 디코딩 (스트림)</target>
        </trans-unit>
        <trans-unit id="faf9a389ba774205e867958c9afe08f731ca89bb" translate="yes" xml:space="preserve">
          <source>Decoder.Token</source>
          <target state="translated">Decoder.Token</target>
        </trans-unit>
        <trans-unit id="db7ab43dcdcfcb47bfa27b64166db401a89736c7" translate="yes" xml:space="preserve">
          <source>DecodingError represents an error during the decoding of the symbol table.</source>
          <target state="translated">DecodingError는 심볼 테이블의 디코딩 중 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="48dcf05d5aa284e84069d30f83d263bbffd81d4e" translate="yes" xml:space="preserve">
          <source>Decrypt decrypts ciphertext with priv. If opts is nil or of type *PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise opts must have type *OAEPOptions and OAEP decryption is done.</source>
          <target state="translated">암호 해독은 암호문을 개인 암호로 해독합니다. opts가 nil이거나 * PKCS1v15DecryptOptions 유형 인 경우 PKCS # 1 v1.5 암호 해독이 수행됩니다. 그렇지 않으면 opts에 * OAEPOptions 유형이 있어야하며 OAEP 암호 해독이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c8fb78d92446f4f89c55adea7b4c51873a0fe712" translate="yes" xml:space="preserve">
          <source>DecryptOAEP</source>
          <target state="translated">DecryptOAEP</target>
        </trans-unit>
        <trans-unit id="0cd489336e048225cfa022050936a5c58e2960d4" translate="yes" xml:space="preserve">
          <source>DecryptOAEP decrypts ciphertext using RSA-OAEP.</source>
          <target state="translated">DecryptOAEP는 RSA-OAEP를 사용하여 암호문을 해독합니다.</target>
        </trans-unit>
        <trans-unit id="32272700b3ba6f69208e5dfe18a0bcc77bf36bf3" translate="yes" xml:space="preserve">
          <source>DecryptPEMBlock takes a password encrypted PEM block and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an IncorrectPasswordError is returned. Because of deficiencies in the encrypted-PEM format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise.</source>
          <target state="translated">DecryptPEMBlock은 암호로 암호화 된 PEM 블록과이를 암호화하는 데 사용되는 암호를 사용하여 암호 해독 된 DER 인코딩 된 바이트 조각을 반환합니다. DEK-Info 헤더를 검사하여 암호 해독에 사용되는 알고리즘을 결정합니다. DEK-Info 헤더가 없으면 오류가 반환됩니다. 잘못된 비밀번호가 발견되면 IncorrectPasswordError가 리턴됩니다. 암호화 된 PEM 형식의 결함으로 인해 항상 잘못된 비밀번호를 감지 할 수있는 것은 아닙니다. 이 경우 오류가 반환되지 않지만 해독 된 DER 바이트는 임의 노이즈입니다.</target>
        </trans-unit>
        <trans-unit id="78ec5d72084471d9fb9aaf2dccd71a7a1ffbaa60" translate="yes" xml:space="preserve">
          <source>DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.</source>
          <target state="translated">PKCS1v15는 RSA 및 PKCS # 1 v1.5의 패딩 체계를 사용하여 일반 텍스트를 해독합니다. rand! = nil 인 경우 RSA 블라 인 딩을 사용하여 사이드 채널 공격 타이밍을 피합니다.</target>
        </trans-unit>
        <trans-unit id="1723fb53bff3596074c056ebc7f6bdfb8a16cfcd" translate="yes" xml:space="preserve">
          <source>DecryptPKCS1v15SessionKey</source>
          <target state="translated">DecryptPKCS1v15SessionKey</target>
        </trans-unit>
        <trans-unit id="5034a4dbba2441d68b5bba30749025b8a62d6758" translate="yes" xml:space="preserve">
          <source>DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks. It returns an error if the ciphertext is the wrong length or if the ciphertext is greater than the public modulus. Otherwise, no error is returned. If the padding is valid, the resulting plaintext message is copied into key. Otherwise, key is unchanged. These alternatives occur in constant time. It is intended that the user of this function generate a random session key beforehand and continue the protocol with the resulting value. This will remove any possibility that an attacker can learn any information about the plaintext. See &amp;ldquo;Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1&amp;rdquo;, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98).</source>
          <target state="translated">DecryptPKCS1v15SessionKey는 PKCS # 1 v1.5에서 RSA 및 패딩 체계를 사용하여 세션 키를 해독합니다. rand! = nil 인 경우 RSA 블라 인 딩을 사용하여 사이드 채널 공격 타이밍을 피합니다. 암호문의 길이가 잘못되었거나 암호문이 공용 계수보다 큰 경우 오류를 리턴합니다. 그렇지 않으면 오류가 반환되지 않습니다. 패딩이 유효하면 결과 일반 텍스트 메시지가 키에 복사됩니다. 그렇지 않으면 키가 변경되지 않습니다. 이러한 대안은 일정한 시간에 발생합니다. 이 기능의 사용자는 미리 임의의 세션 키를 생성하고 결과 값으로 프로토콜을 계속 진행합니다. 이렇게하면 공격자가 일반 텍스트에 대한 정보를 배울 수있는 가능성이 사라집니다. Daniel Rleichenbacher,&amp;ldquo;RSA 암호화 표준 PKCS # 1 기반 프로토콜에 대한 암호 텍스트 공격 선택&amp;rdquo;,암호학의 발전 (Crypto '98).</target>
        </trans-unit>
        <trans-unit id="42a6dfe4c2e189c8de29f15cddcf7cf9dba25238" translate="yes" xml:space="preserve">
          <source>Decrypter is an interface for an opaque private key that can be used for asymmetric decryption operations. An example would be an RSA key kept in a hardware module.</source>
          <target state="translated">암호 해독기는 비대칭 암호 해독 작업에 사용할 수있는 불투명 개인 키용 인터페이스입니다. 하드웨어 모듈에 보관 된 RSA 키를 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ae957644bea42b7ff65d51f99ce49cb83fd388" translate="yes" xml:space="preserve">
          <source>DeepEqual reports whether x and y are &amp;ldquo;deeply equal,&amp;rdquo; defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal.</source>
          <target state="translated">DeepEqual은 x와 y가 &quot;깊게 같은지&quot;보고하며 다음과 같이 정의됩니다. 다음 경우 중 하나에 해당하는 경우 동일한 유형의 두 값이 완전히 동일합니다. 고유 한 유형의 값은 절대로 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d88594116663c9d491607d208f07eaf0d91b8568" translate="yes" xml:space="preserve">
          <source>DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only.</source>
          <target state="translated">DefPredeclaredTestFuncs는 어설트 및 추적 내장 기능을 정의합니다. 이러한 내장 기능은이 패키지의 디버깅 및 테스트 전용입니다.</target>
        </trans-unit>
        <trans-unit id="a034168ac1ac48bea6ed331fcaa43cff83c78c4c" translate="yes" xml:space="preserve">
          <source>Default behavior of signals in Go programs</source>
          <target state="translated">Go 프로그램에서 신호의 기본 동작</target>
        </trans-unit>
        <trans-unit id="5a5930ff9b687f979b109248d33bd87544c6441a" translate="yes" xml:space="preserve">
          <source>Default is the default Context for builds. It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables if set, or else the compiled code's GOARCH, GOOS, and GOROOT.</source>
          <target state="translated">기본값은 빌드의 기본 컨텍스트입니다. 설정된 경우 GOARCH, GOOS, GOROOT 및 GOPATH 환경 변수 또는 컴파일 된 코드의 GOARCH, GOOS 및 GOROOT를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="72e5e6d9fc404c78f1caf70dbc4a96064e7c0a25" translate="yes" xml:space="preserve">
          <source>Default returns an Importer for the compiler that built the running binary. If available, the result implements types.ImporterFrom.</source>
          <target state="translated">기본값은 실행중인 바이너리를 빌드 한 컴파일러의 임포터를 반환합니다. 사용 가능한 경우 결과는 유형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ec9d9531a88729b86031d49234703db1873e5fde" translate="yes" xml:space="preserve">
          <source>Default returns the default &quot;typed&quot; type for an &quot;untyped&quot; type; it returns the incoming type for all other types. The default type for untyped nil is untyped nil.</source>
          <target state="translated">기본값은 &quot;유형화되지 않은&quot;유형에 대한 기본 &quot;유형화 된&quot;유형을 리턴합니다. 다른 모든 유형의 수신 유형을 리턴합니다. 형식화되지 않은 nil의 기본 유형은 형식화되지 않은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="a32a9ab63a855b6d134feb2b19c4b8ed98d5511f" translate="yes" xml:space="preserve">
          <source>DefaultClient is the default Client and is used by Get, Head, and Post.</source>
          <target state="translated">DefaultClient는 기본 클라이언트이며 Get, Head 및 Post에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa23924b211ce5cb27ec1d2387da0f7a6637db67" translate="yes" xml:space="preserve">
          <source>DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address.</source>
          <target state="translated">DefaultMask는 IP 주소 ip에 대한 기본 IP 마스크를 반환합니다. IPv4 주소에만 기본 마스크가 있습니다. ip가 유효한 IPv4 주소가 아닌 경우 DefaultMask는 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e06a50030e5f43ee5b24b6931b868b3e071ca071" translate="yes" xml:space="preserve">
          <source>DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. This can be overridden by setting Server.MaxHeaderBytes.</source>
          <target state="translated">DefaultMaxHeaderBytes는 HTTP 요청에서 허용되는 최대 헤더 크기입니다. Server.MaxHeaderBytes를 설정하여이를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="636a0952f2f8473680d4e7cc7eb53279b90ac029" translate="yes" xml:space="preserve">
          <source>DefaultMaxIdleConnsPerHost is the default value of Transport's MaxIdleConnsPerHost.</source>
          <target state="translated">DefaultMaxIdleConnsPerHost는 Transport의 MaxIdleConnsPerHost의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0b44788c36bdae15408049002f004c79915e5e4d" translate="yes" xml:space="preserve">
          <source>DefaultParameterConverter is the default implementation of ValueConverter that's used when a Stmt doesn't implement ColumnConverter.</source>
          <target state="translated">DefaultParameterConverter는 Stmt가 ColumnConverter를 구현하지 않을 때 사용되는 ValueConverter의 기본 구현입니다.</target>
        </trans-unit>
        <trans-unit id="2eacc041065f99c81cc8f5fd899b6fc82a35c5b3" translate="yes" xml:space="preserve">
          <source>DefaultParameterConverter returns its argument directly if IsValue(arg). Otherwise, if the argument implements Valuer, its Value method is used to return a Value. As a fallback, the provided argument's underlying type is used to convert it to a Value: underlying integer types are converted to int64, floats to float64, bool, string, and []byte to themselves. If the argument is a nil pointer, ConvertValue returns a nil Value. If the argument is a non-nil pointer, it is dereferenced and ConvertValue is called recursively. Other types are an error.</source>
          <target state="translated">DefaultParameterConverter는 IsValue (arg) 인 경우 인수를 직접 반환합니다. 그렇지 않으면 인수가 Valuer를 구현하는 경우 Value 메소드를 사용하여 Value를 리턴합니다. 폴백으로 제공된 인수의 기본 유형은 값으로 변환하는 데 사용됩니다. 기본 정수 유형은 int64로 변환되고 float64, bool, 문자열 및 [] 바이트로 변환됩니다. 인수가 nil 포인터이면 ConvertValue는 nil 값을 반환합니다. 인수가 0이 아닌 포인터 인 경우에는 역 참조되고 ConvertValue가 재귀 적으로 호출됩니다. 다른 유형은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="5f213734fb7e3669ea6cde1adb844c4352398832" translate="yes" xml:space="preserve">
          <source>DefaultQuality is the default quality encoding parameter.</source>
          <target state="translated">DefaultQuality는 기본 품질 인코딩 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="38d9675d6a9519fefbcc46ae56e43608c28aa568" translate="yes" xml:space="preserve">
          <source>DefaultRemoteAddr is the default remote address to return in RemoteAddr if an explicit DefaultRemoteAddr isn't set on ResponseRecorder.</source>
          <target state="translated">DefaultRemoteAddr은 ResponseRecorder에 명시 적 DefaultRemoteAddr이 설정되지 않은 경우 RemoteAddr에서 리턴 할 기본 원격 주소입니다.</target>
        </trans-unit>
        <trans-unit id="6ee5c05653051c51f271a77afcb53f5d1e6c059a" translate="yes" xml:space="preserve">
          <source>DefaultResolver is the resolver used by the package-level Lookup functions and by Dialers without a specified Resolver.</source>
          <target state="translated">DefaultResolver는 패키지 수준 조회 기능과 지정된 Resolver가없는 다이얼러에서 사용되는 리졸버입니다.</target>
        </trans-unit>
        <trans-unit id="d5ebe0e1b713e364b784eb80c7a317d8d294f9a0" translate="yes" xml:space="preserve">
          <source>DefaultServeMux is the default ServeMux used by Serve.</source>
          <target state="translated">DefaultServeMux는 Serve에서 사용하는 기본 ServeMux입니다.</target>
        </trans-unit>
        <trans-unit id="e263e8bc5cd83dd3c4b95718e56ae0981b0cc5d2" translate="yes" xml:space="preserve">
          <source>DefaultServer is the default instance of *Server.</source>
          <target state="translated">DefaultServer는 * Server의 기본 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="372f5d0502fa7b598a3ec0b732f37219d19fac76" translate="yes" xml:space="preserve">
          <source>DefaultTransport is the default implementation of Transport and is used by DefaultClient. It establishes network connections as needed and caches them for reuse by subsequent calls. It uses HTTP proxies as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy) environment variables.</source>
          <target state="translated">DefaultTransport는 Transport의 기본 구현이며 DefaultClient에서 사용됩니다. 필요에 따라 네트워크 연결을 설정하고 후속 호출에서 재사용 할 수 있도록이를 캐시합니다. $ HTTP_PROXY 및 $ NO_PROXY (또는 $ http_proxy 및 $ no_proxy) 환경 변수의 지시에 따라 HTTP 프록시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="afd8250a6d786e6fc36b7943762248db8114871c" translate="yes" xml:space="preserve">
          <source>Define flags using flag.String(), Bool(), Int(), etc.</source>
          <target state="translated">flag.String (), Bool (), Int () 등을 사용하여 플래그를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="59702ad1f8b86127487509bba28cce815f45cb43" translate="yes" xml:space="preserve">
          <source>DefinedTemplates returns a string listing the defined templates, prefixed by the string &quot;; defined templates are: &quot;. If there are none, it returns the empty string. For generating an error message here and in html/template.</source>
          <target state="translated">DefinedTemplates는 앞에 &quot;&quot;라는 문자열이 앞에 정의 된 템플릿을 나열하는 문자열을 반환합니다. 정의 된 템플릿은 &quot;입니다. 없는 경우 빈 문자열을 반환합니다. 여기 및 html / template에서 오류 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ef9206feec84a2fab3e1d763ed437ba19bc8059" translate="yes" xml:space="preserve">
          <source>DefinedTemplates returns a string listing the defined templates, prefixed by the string &quot;; defined templates are: &quot;. If there are none, it returns the empty string. Used to generate an error message.</source>
          <target state="translated">DefinedTemplates는 앞에 &quot;&quot;라는 문자열이 앞에 정의 된 템플릿을 나열하는 문자열을 반환합니다. 정의 된 템플릿은 &quot;입니다. 없는 경우 빈 문자열을 반환합니다. 오류 메시지를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb57645975348dea1039fb97dc2b2b89c0be776d" translate="yes" xml:space="preserve">
          <source>Del deletes the values associated with key.</source>
          <target state="translated">Del은 키와 관련된 값을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="857c30a3f9faee13278e31d18a439b577b3f1737" translate="yes" xml:space="preserve">
          <source>Del deletes the values associated with key. The key is case insensitive; it is canonicalized by CanonicalHeaderKey.</source>
          <target state="translated">Del은 키와 관련된 값을 삭제합니다. 키는 대소 문자를 구분하지 않습니다. CanonicalHeaderKey에 의해 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="344d7532f4d066a3be32162f19300bafca7e706e" translate="yes" xml:space="preserve">
          <source>Delete deletes the given key from the map.</source>
          <target state="translated">삭제는 주어진 키를 맵에서 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="0084056bfddcb6daf1843876f6cd9d7b3ea00fa3" translate="yes" xml:space="preserve">
          <source>Delete deletes the value for a key.</source>
          <target state="translated">삭제는 키 값을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d5efbe5b092d83811fac07a9464c08df78f1c725" translate="yes" xml:space="preserve">
          <source>Delims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained.</source>
          <target state="translated">Delims는 동작 구분 기호를 지정된 문자열로 설정하여 이후 Parse, ParseFiles 또는 ParseGlob 호출에 사용됩니다. 중첩 템플릿 정의는 설정을 상속합니다. 빈 구분 기호는 해당 기본값 인 {{또는}}을 나타냅니다. 반환 값은 템플릿이므로 호출을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d0d4298e3ba9dd9990445a4ef4e8a6cd12c5f4f" translate="yes" xml:space="preserve">
          <source>Denom returns the denominator of x; it is always &amp;gt; 0. The result is a reference to x's denominator; it may change if a new value is assigned to x, and vice versa.</source>
          <target state="translated">Denom은 x의 분모를 반환합니다. 항상&amp;gt; 0입니다. 결과는 x의 분모에 대한 참조입니다. x에 새로운 값이 할당되면 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8eeb4cd02c6a77b7f55a05d7bd3c8acc59c71d" translate="yes" xml:space="preserve">
          <source>Denom returns the denominator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int &amp;gt;= 1.</source>
          <target state="translated">Denom은 x의 분모를 반환합니다. x는 Int, Float 또는 Unknown이어야합니다. x가 알 수없는 경우 또는 분수로 나타내기에는 너무 크거나 작은 경우 결과는 알 수 없습니다. 그렇지 않으면 결과는 Int&amp;gt; = 1입니다.</target>
        </trans-unit>
        <trans-unit id="02dfda4f203755036a797366a5e270c14beadf5b" translate="yes" xml:space="preserve">
          <source>Depending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the Request.Body after writing to the ResponseWriter. Cautious handlers should read the Request.Body first, and then reply.</source>
          <target state="translated">HTTP 클라이언트 소프트웨어, HTTP 프로토콜 버전 및 클라이언트와 Go 서버 사이의 중개자에 따라 ResponseWriter에 쓴 후 Request.Body에서 읽을 수 없습니다. 신중한 처리기는 Request.Body를 먼저 읽고 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="51ff8b9c366b37de75e0a219f6054e295296daec" translate="yes" xml:space="preserve">
          <source>Deprecated: Drivers should implement ExecerContext instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 드라이버가 대신 ExecerContext를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4d3a3d65ddeed121ddbee894f4a71e4f38ef5f4" translate="yes" xml:space="preserve">
          <source>Deprecated: Drivers should implement NamedValueChecker.</source>
          <target state="translated">더 이상 사용되지 않음 : 드라이버는 NamedValueChecker를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c65d9b0a5c2499f69091385e530d0488f264354" translate="yes" xml:space="preserve">
          <source>Deprecated: Drivers should implement QueryerContext instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 드라이버가 대신 QueryerContext를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd55ed21fcef6e8036c179ed17978a5eb1bc511c" translate="yes" xml:space="preserve">
          <source>Deprecated: HasPrefix does not respect path boundaries and does not ignore case when required.</source>
          <target state="translated">더 이상 사용되지 않음 : HasPrefix는 경로 경계를 고려하지 않으며 필요한 경우 대소 문자를 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b6314119e2a70e822325ecc07d6f3bcf87fad5a" translate="yes" xml:space="preserve">
          <source>Deprecated: In earlier releases, when using a Regexp in multiple goroutines, giving each goroutine its own copy helped to avoid lock contention. As of Go 1.12, using Copy is no longer necessary to avoid lock contention. Copy may still be appropriate if the reason for its use is to make two copies with different Longest settings.</source>
          <target state="translated">더 이상 사용되지 않음 : 이전 릴리즈에서는 여러 고 루틴에서 Regexp를 사용할 때 각 고 루틴에 고유 한 사본을 제공하여 잠금 경합을 피하는 데 도움이되었습니다. Go 1.12부터 잠금 경합을 피하기 위해 더 이상 복사를 사용할 필요가 없습니다. 가장 긴 설정으로 다른 사본을 두 개 만드는 것이 목적인 경우에도 여전히 사본이 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9637414855ddbc727fc7477deb59945461f257c8" translate="yes" xml:space="preserve">
          <source>Deprecated: No longer returned.</source>
          <target state="translated">더 이상 사용되지 않음 : 더 이상 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fd839aca1062d0406d212ed9c29a708a99c5ae4" translate="yes" xml:space="preserve">
          <source>Deprecated: No longer used; kept for compatibility.</source>
          <target state="translated">더 이상 사용되지 않음 : 더 이상 사용되지 않습니다. 호환성을 유지했습니다.</target>
        </trans-unit>
        <trans-unit id="3c3790917f28a2ba29e0716702d6e5bf036726c8" translate="yes" xml:space="preserve">
          <source>Deprecated: Not all errors in the http package related to protocol errors are of type ProtocolError.</source>
          <target state="translated">더 이상 사용되지 않음 : 프로토콜 오류와 관련된 http 패키지의 모든 오류가 ProtocolError 유형 인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="490458aa5011ab7b075523616154746f03267643" translate="yes" xml:space="preserve">
          <source>Deprecated: Reader is not used by the image/jpeg package and should not be used by others. It is kept for compatibility.</source>
          <target state="translated">더 이상 사용되지 않음 : image / jpeg 패키지에서 Reader를 사용하지 않으며 다른 사람이 사용해서는 안됩니다. 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="58781567b2fb92c443f90638b4d662c4329af403" translate="yes" xml:space="preserve">
          <source>Deprecated: Reset can't guarantee that the key will be entirely removed from the process's memory.</source>
          <target state="translated">더 이상 사용되지 않음 : 재설정은 키가 프로세스 메모리에서 완전히 제거된다고 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43ac2e35f199dfb76444834868effa77e8fa4427" translate="yes" xml:space="preserve">
          <source>Deprecated: Use BytePtrFromString instead.</source>
          <target state="translated">더 이상 사용되지 않음 : BytePtrFromString을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="51efd02191b9f71984ba76cbf148870f02e1d8c6" translate="yes" xml:space="preserve">
          <source>Deprecated: Use ByteSliceFromString instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 ByteSliceFromString을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd4b3efcc65217311972673c02ffe9a5cb88dfaf" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Client or Transport in package net/http instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 net / http 패키지에서 클라이언트 또는 전송을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6270f7239a09518438a88d37dad394b15480fb8" translate="yes" xml:space="preserve">
          <source>Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.</source>
          <target state="translated">더 이상 사용되지 않음 : 정의 된 (* Named) 유형으로 제한되지 않는 EmbeddedType을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7bc19f31fefb5069bf157150b156e0dbda6a5cff" translate="yes" xml:space="preserve">
          <source>Deprecated: Use ForCompiler, which populates a FileSet with the positions of objects created by the importer.</source>
          <target state="translated">더 이상 사용되지 않음 : 가져 오기 프로그램에서 생성 한 객체의 위치로 FileSet을 채우는 ForCompiler를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dea355e8883ce226aad79e4df0b17269bf068a57" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Modified instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 수정됨을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dd51e4444ff9f93d6d490f4c8fbbe80d17a8f7ed" translate="yes" xml:space="preserve">
          <source>Deprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types to be embedded. This is necessary for interfaces that embed alias type names referring to non-defined (literal) interface types.</source>
          <target state="translated">더 이상 사용되지 않음 : 정의되지 않은 인터페이스 유형을 포함 할 수있는 NewInterfaceType을 대신 사용하십시오. 정의되지 않은 (리터럴) 인터페이스 유형을 참조하는 별칭 유형 이름을 포함하는 인터페이스에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="86a0a87c06d3b24ae7ba083e47038c07c1ec8a45" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Request.WithContext to create a request with a cancelable context instead. CancelRequest cannot cancel HTTP/2 requests.</source>
          <target state="translated">더 이상 사용되지 않음 : Request.WithContext를 사용하여 대신 취소 가능한 컨텍스트로 요청을 작성하십시오. CancelRequest는 HTTP / 2 요청을 취소 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5afbed661568f02f17be5136af0d00c63dacdf0f" translate="yes" xml:space="preserve">
          <source>Deprecated: Use SlicePtrFromStrings instead.</source>
          <target state="translated">더 이상 사용되지 않음 : SlicePtrFromStrings를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9307fd6cc4683ebcdd10ed61846d3a8429d1b79d" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Table's LineToPC method instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 Table의 LineToPC 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4b5050bfb6e04ec77adc6d71cc882c7de1e14526" translate="yes" xml:space="preserve">
          <source>Deprecated: Use Table's PCToLine method instead.</source>
          <target state="translated">더 이상 사용되지 않음 : Table의 PCToLine 메서드를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="77cf9f471d6e42edcc6f260a374bb70bfa7adebe" translate="yes" xml:space="preserve">
          <source>Deprecated: Use a literal image.Point{} instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 리터럴 이미지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b7397111f5533c968cd65f5e2523d33d9faff03a" translate="yes" xml:space="preserve">
          <source>Deprecated: Use a literal image.Rectangle{} instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 리터럴 이미지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9937088a55d8dc88ef8ad92ad476b97d1a2fb40f" translate="yes" xml:space="preserve">
          <source>Deprecated: Use golang.org/x/net/bpf instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 golang.org/x/net/bpf를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="010b83223f03b61cbd0b1c78b7f4b00afcddc45f" translate="yes" xml:space="preserve">
          <source>Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</source>
          <target state="translated">더 이상 사용되지 않음 : io.SeekStart, io.SeekCurrent 및 io.SeekEnd를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0648b8785f1680a3e97220e8e055c5d37df0480e" translate="yes" xml:space="preserve">
          <source>Deprecated: Use the Client or Transport in package net/http instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 net / http 패키지의 클라이언트 또는 전송을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d53617ac7890494a0c834838f0476b520d4862ac" translate="yes" xml:space="preserve">
          <source>Deprecated: Use the Server in package net/http instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 net / http 패키지의 서버를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="987c7abf6daadd7b7fb6e6f3bb5e77607927d16a" translate="yes" xml:space="preserve">
          <source>Deprecated: Use the runtime/pprof package, or the handlers in the net/http/pprof package, or the testing package's -test.cpuprofile flag instead.</source>
          <target state="translated">더 이상 사용되지 않음 : runtime / pprof 패키지 또는 net / http / pprof 패키지의 핸들러 또는 테스트 패키지의 -test.cpuprofile 플래그를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5826c738c43e68ce8820a4cf4d6fa1df350e65a6" translate="yes" xml:space="preserve">
          <source>Deprecated: the CloseNotifier interface predates Go's context package. New code should use Request.Context instead.</source>
          <target state="translated">더 이상 사용되지 않음 : CloseNotifier 인터페이스는 Go의 컨텍스트 패키지보다 우선합니다. 새 코드는 Request.Context를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb2a5b2d0ed3d2503d1117d6b88d116db1a5c733" translate="yes" xml:space="preserve">
          <source>Deprecated: this package is locked down. Callers should use the corresponding package in the golang.org/x/sys repository instead. That is also where updates required by new systems or versions should be applied. See &lt;a href=&quot;https://golang.org/s/go1.4-syscall&quot;&gt;https://golang.org/s/go1.4-syscall&lt;/a&gt; for more information.</source>
          <target state="translated">더 이상 사용되지 않음 :이 패키지가 잠겨 있습니다. 호출자는 golang.org/x/sys 저장소에서 해당 패키지를 대신 사용해야합니다. 새로운 시스템이나 버전에 필요한 업데이트도 적용해야합니다. 자세한 내용은 &lt;a href=&quot;https://golang.org/s/go1.4-syscall&quot;&gt;https://golang.org/s/go1.4-syscall&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11f97aa680aa5a60014104f440129ac907153497" translate="yes" xml:space="preserve">
          <source>DetectContentType implements the algorithm described at &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;https://mimesniff.spec.whatwg.org/&lt;/a&gt; to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns &quot;application/octet-stream&quot;.</source>
          <target state="translated">DetectContentType은 &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;https://mimesniff.spec.whatwg.org/&lt;/a&gt; 에 설명 된 알고리즘을 구현하여 지정된 데이터의 Content-Type을 결정합니다. 최대 512 바이트의 데이터를 고려합니다. DetectContentType은 항상 유효한 MIME 형식을 반환합니다.보다 구체적인 형식을 결정할 수 없으면 &quot;application / octet-stream&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="367a791e4c8a0aab798febfdd40fb481c8e6a937" translate="yes" xml:space="preserve">
          <source>DevNull is the name of the operating system's &amp;ldquo;null device.&amp;rdquo; On Unix-like systems, it is &quot;/dev/null&quot;; on Windows, &quot;NUL&quot;.</source>
          <target state="translated">DevNull은 운영 체제의 &quot;널 장치&quot;의 이름입니다. 유닉스 계열 시스템에서는 &quot;/ dev / null&quot;입니다. Windows에서는 &quot;NUL&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="646a9a5d7a2127190c66269d0c3f2e8f50421ce8" translate="yes" xml:space="preserve">
          <source>Dial</source>
          <target state="translated">Dial</target>
        </trans-unit>
        <trans-unit id="3245bf7894677b66fa0f65579149d4be55a013bd" translate="yes" xml:space="preserve">
          <source>Dial connects to a JSON-RPC server at the specified network address.</source>
          <target state="translated">다이얼은 지정된 네트워크 주소에서 JSON-RPC 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f3c54da882e49624393be65dcafa09fa8930a181" translate="yes" xml:space="preserve">
          <source>Dial connects to an RPC server at the specified network address.</source>
          <target state="translated">다이얼은 지정된 네트워크 주소에서 RPC 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="8126f72193c0616ba2ad5a2d20b0d0af08ee30f4" translate="yes" xml:space="preserve">
          <source>Dial connects to the address on the named network.</source>
          <target state="translated">다이얼은 명명 된 네트워크의 주소에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="501b84f9fa1edcd3533366e2dba0373c80935d15" translate="yes" xml:space="preserve">
          <source>Dial connects to the given address on the given network using net.Dial and then returns a new Conn for the connection.</source>
          <target state="translated">다이얼은 net.Dial을 사용하여 지정된 네트워크의 지정된 주소에 연결 한 다음 연결에 대한 새 연결을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23287419cc64eb396429ad69a3f427b7d7d40ed6" translate="yes" xml:space="preserve">
          <source>Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults.</source>
          <target state="translated">다이얼은 net.Dial을 사용하여 지정된 네트워크 주소에 연결 한 다음 TLS 핸드 셰이크를 시작하여 결과 TLS 연결을 반환합니다. Dial은 nil 구성을 0 구성과 동등한 것으로 해석합니다. 기본값은 구성 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="555b7c0fb1e8bb60be8d6c97d4ce69eaf35fb532" translate="yes" xml:space="preserve">
          <source>Dial establishes a connection to a log daemon by connecting to address raddr on the specified network. Each write to the returned writer sends a log message with the facility and severity (from priority) and tag. If tag is empty, the os.Args[0] is used. If network is empty, Dial will connect to the local syslog server. Otherwise, see the documentation for net.Dial for valid values of network and raddr.</source>
          <target state="translated">Dial은 지정된 네트워크의 raddr 주소에 연결하여 로그 데몬에 연결합니다. 리턴 된 기록기에 대한 각 쓰기는 기능 및 심각도 (우선 순위의) 및 태그가 포함 된 로그 메시지를 보냅니다. 태그가 비어 있으면 os.Args [0]이 사용됩니다. 네트워크가 비어 있으면 다이얼은 로컬 syslog 서버에 연결됩니다. 그렇지 않으면 유효한 network 및 raddr 값에 대해서는 net.Dial 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="916c7b288099112169b38ebc1753110c3b18e4dd" translate="yes" xml:space="preserve">
          <source>Dial returns a new Client connected to an SMTP server at addr. The addr must include a port, as in &quot;mail.example.com:smtp&quot;.</source>
          <target state="translated">Dial은 addr에서 SMTP 서버에 연결된 새 클라이언트를 반환합니다. 주소는 &quot;mail.example.com:smtp&quot;와 같이 포트를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="c336c24a8e7cb3e6692055b20290d453c602efca" translate="yes" xml:space="preserve">
          <source>DialContext connects to the address on the named network using the provided context.</source>
          <target state="translated">DialContext는 제공된 컨텍스트를 사용하여 명명 된 네트워크의 주소에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="51fc387cd20218ed3d2f01c35c59633f45a5f29c" translate="yes" xml:space="preserve">
          <source>DialHTTP connects to an HTTP RPC server at the specified network address listening on the default HTTP RPC path.</source>
          <target state="translated">DialHTTP는 기본 HTTP RPC 경로에서 수신 대기하는 지정된 네트워크 주소로 HTTP RPC 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="166f35fbbfb2abc139813e788b55c8bb3893b155" translate="yes" xml:space="preserve">
          <source>DialHTTPPath connects to an HTTP RPC server at the specified network address and path.</source>
          <target state="translated">DialHTTPPath는 지정된 네트워크 주소 및 경로에서 HTTP RPC 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="054234eb6c33ff43797ebf07806d1abf2116d2cd" translate="yes" xml:space="preserve">
          <source>DialIP acts like Dial for IP networks.</source>
          <target state="translated">DialIP는 IP 네트워크 용 다이얼처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="60f40280b1c83bdee5b7b3218861565670c7b947" translate="yes" xml:space="preserve">
          <source>DialTCP acts like Dial for TCP networks.</source>
          <target state="translated">DialTCP는 TCP 네트워크 용 다이얼처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c77aaf097ede2da3e55ab000126fc5ce2b944418" translate="yes" xml:space="preserve">
          <source>DialTimeout acts like Dial but takes a timeout.</source>
          <target state="translated">DialTimeout은 Dial처럼 작동하지만 시간이 초과됩니다.</target>
        </trans-unit>
        <trans-unit id="723db5642572fd8814d20074653b8583436a95be" translate="yes" xml:space="preserve">
          <source>DialUDP acts like Dial for UDP networks.</source>
          <target state="translated">DialUDP는 UDP 네트워크 용 다이얼처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b1188516daa0242a5dee9e07a8ce04b8dfddd6c9" translate="yes" xml:space="preserve">
          <source>DialUnix acts like Dial for Unix networks.</source>
          <target state="translated">DialUnix는 Unix 네트워크 용 다이얼처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9d97dd8e372e50745923f0e793e9a1ea3377bd43" translate="yes" xml:space="preserve">
          <source>DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole.</source>
          <target state="translated">DialWithDialer는 다이얼러를 사용하여 지정된 네트워크 주소에 연결합니다. 다이얼러에 지정된 시간 초과 또는 마감 시간은 전체적으로 연결 및 TLS 핸드 셰이크에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="04d0c73b173305efd4d7c731d37276a56782e447" translate="yes" xml:space="preserve">
          <source>DialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults.</source>
          <target state="translated">DialWithDialer는 nil 구성을 0 구성과 동등한 것으로 해석합니다. 기본값은 구성 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5180c70f6c14847253e8a19f2d62329e26995c8f" translate="yes" xml:space="preserve">
          <source>Dim returns the maximum of x-y or 0.</source>
          <target state="translated">Dim은 최대 xy 또는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84c6b9acefa0f4f9e57b58581d5a75e315eb3f2d" translate="yes" xml:space="preserve">
          <source>Dir</source>
          <target state="translated">Dir</target>
        </trans-unit>
        <trans-unit id="2f3878a27be08b90f79ff7ead675653eced9d5fc" translate="yes" xml:space="preserve">
          <source>Dir returns all but the last element of path, typically the path's directory. After dropping the final element using Split, the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns &quot;.&quot;. If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash.</source>
          <target state="translated">Dir은 경로의 마지막 요소, 일반적으로 경로의 디렉토리를 제외한 모든 요소를 ​​반환합니다. Split을 사용하여 최종 요소를 삭제하면 경로가 정리되고 후행 슬래시가 제거됩니다. 경로가 비어 있으면 Dir은 &quot;.&quot;를 반환합니다. 경로가 슬래시와 슬래시가 아닌 바이트로만 구성된 경우 Dir은 단일 슬래시를 반환합니다. 다른 경우에는 리턴 된 경로가 슬래시로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd0f5615772352273bc79d68b22a60277288ae87" translate="yes" xml:space="preserve">
          <source>Dir returns all but the last element of path, typically the path's directory. After dropping the final element, Dir calls Clean on the path and trailing slashes are removed. If the path is empty, Dir returns &quot;.&quot;. If the path consists entirely of separators, Dir returns a single separator. The returned path does not end in a separator unless it is the root directory.</source>
          <target state="translated">Dir은 경로의 마지막 요소, 일반적으로 경로의 디렉토리를 제외한 모든 요소를 ​​반환합니다. 마지막 요소를 삭제 한 후 Dir은 경로에서 Clean을 호출하고 후행 슬래시가 제거됩니다. 경로가 비어 있으면 Dir은 &quot;.&quot;를 반환합니다. 경로가 완전히 구분자로 구성되어 있으면 Dir은 단일 구분자를 반환합니다. 리턴 된 경로는 루트 디렉토리가 아닌 경우 구분 기호로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a478722b7b31bb4fb26d02a9daa9b39abbff8e70" translate="yes" xml:space="preserve">
          <source>Dir returns the direction of channel c.</source>
          <target state="translated">Dir은 채널 c의 방향을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15a5a91e72d8cd7ecd875b2fde5f18520f1865d0" translate="yes" xml:space="preserve">
          <source>DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains object keys which do not match any non-ignored, exported fields in the destination.</source>
          <target state="translated">DisallowUnknownFields는 대상이 구조체이고 입력에 대상에서 무시되지 않은 내 보낸 필드와 일치하지 않는 개체 키가 포함 된 경우 디코더에서 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a9e638c9210f5f7c0d1bf542f9e88607a9db164" translate="yes" xml:space="preserve">
          <source>Discard is an io.Writer on which all Write calls succeed without doing anything.</source>
          <target state="translated">버리기 (Discard)는 io.Writer로 모든 쓰기 호출이 아무런 작업을하지 않고 성공합니다.</target>
        </trans-unit>
        <trans-unit id="3151e5b42c76f7786c34b10ee6b91843bc323edd" translate="yes" xml:space="preserve">
          <source>Discard skips the next n bytes, returning the number of bytes discarded.</source>
          <target state="translated">삭제는 다음 n 바이트를 건너 뛰고 버려진 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6ce0f4b9310f95ee6e03e8cc37d8051d56938ac" translate="yes" xml:space="preserve">
          <source>Discussion:</source>
          <target state="translated">Discussion:</target>
        </trans-unit>
        <trans-unit id="1fc629db1dfea7dd1d7478cd49f0d67c695a2f09" translate="yes" xml:space="preserve">
          <source>Disposal Methods.</source>
          <target state="translated">폐기 방법.</target>
        </trans-unit>
        <trans-unit id="5ec7907f27bd994c3fb8583301b913b0b6813a3a" translate="yes" xml:space="preserve">
          <source>Div returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div panics for y == 0 (division by zero) or y &amp;lt;= hi (quotient overflow).</source>
          <target state="translated">Div는 (hi, lo)의 몫과 나머지를 y로 나눈 값을 반환합니다 : quo = (hi, lo) / y, rem = (hi, lo) % y 파라미터 lo. y == 0 (0으로 나누기) 또는 y &amp;lt;= hi (몫 오버 플로우)에 대한 분할 패닉.</target>
        </trans-unit>
        <trans-unit id="4fc57c9c02ed421c232712ba11343274d994963e" translate="yes" xml:space="preserve">
          <source>Div returns the vector p/k.</source>
          <target state="translated">Div는 벡터 p / k를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="426cf990e0000e9ee258d2aab672481be1e61f9f" translate="yes" xml:space="preserve">
          <source>Div sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Div implements Euclidean division (unlike Go); see DivMod for more details.</source>
          <target state="translated">Div는 y! = 0에 대해 z를 몫 x / y로 설정하고 z를 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다. Div는 Go와 달리 유클리드 부서를 구현합니다. 자세한 내용은 DivMod를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6969f247b499f527d10065936434631c47245711" translate="yes" xml:space="preserve">
          <source>Div32 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div32 panics for y == 0 (division by zero) or y &amp;lt;= hi (quotient overflow).</source>
          <target state="translated">Div32는 (hi, lo)의 몫과 나머지를 y로 나눈 값을 반환합니다 : quo = (hi, lo) / y, rem = (hi, lo) % y 파라미터 lo. y == 0 (0으로 나눗셈) 또는 y &amp;lt;= hi (quota overflow)에 대한 Div32 패닉.</target>
        </trans-unit>
        <trans-unit id="64a140393f99aaa8275c3c523c2f0109eb59db32" translate="yes" xml:space="preserve">
          <source>Div64 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div64 panics for y == 0 (division by zero) or y &amp;lt;= hi (quotient overflow).</source>
          <target state="translated">Div64는 (hi, lo)의 몫과 나머지를 y로 나눈 값을 반환합니다 : quo = (hi, lo) / y, rem = (hi, lo) % y 파라미터 lo. y == 0 (0으로 나누기) 또는 y &amp;lt;= hi (몫 오버 플로우)에 대한 Div64 패닉.</target>
        </trans-unit>
        <trans-unit id="73ee7e85e1219c9b6dd08a952c5d23488d8e580c" translate="yes" xml:space="preserve">
          <source>DivMod implements Euclidean division and modulus (unlike Go):</source>
          <target state="translated">DivMod는 Gocli와는 달리 유클리드 디비전과 모듈러스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2b680c8f7a354b5f639fb527648d9d63d8ccda98" translate="yes" xml:space="preserve">
          <source>DivMod sets z to the quotient x div y and m to the modulus x mod y and returns the pair (z, m) for y != 0. If y == 0, a division-by-zero run-time panic occurs.</source>
          <target state="translated">DivMod는 z를 몫 x div y로, m을 모듈러스 x mod y로 설정하고 y! = 0에 대한 쌍 (z, m)을 반환합니다. y == 0이면 0으로 나누기 런타임 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="421c2fc2a2b84517678db9c2f442e9b0eb047ffd" translate="yes" xml:space="preserve">
          <source>Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated.</source>
          <target state="translated">맵의 각 항목에 대해 f를 호출하십시오. 반복 중에 맵이 잠기지 만 기존 항목이 동시에 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344fdccb01551fd2cf446ded60ac44948ea45c54" translate="yes" xml:space="preserve">
          <source>Do calls f for each exported variable. The global variable map is locked during the iteration, but existing entries may be concurrently updated.</source>
          <target state="translated">내 보낸 각 변수에 대해 f를 호출하십시오. 글로벌 변수 맵은 반복 중에 잠겨 있지만 기존 항목은 동시에 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73df66c109e56751b22dc4bded18343160cef6a4" translate="yes" xml:space="preserve">
          <source>Do calls f with a copy of the parent context with the given labels added to the parent's label map. Goroutines spawned while executing f will inherit the augmented label-set. Each key/value pair in labels is inserted into the label map in the order provided, overriding any previous value for the same key. The augmented label map will be set for the duration of the call to f and restored once f returns.</source>
          <target state="translated">주어진 레이블이 부모의 레이블 맵에 추가 된 부모 컨텍스트의 사본으로 f를 호출하십시오. f를 실행하는 동안 생성 된 고 루틴은 보강 된 레이블 세트를 상속합니다. 레이블의 각 키 / 값 쌍은 제공된 순서대로 레이블 맵에 삽입되어 동일한 키의 이전 값을 대체합니다. 기능 보강 레이블 맵은 f에 대한 호출 기간 동안 설정되며 f가 반환되면 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="d59f412ffbd80005134f93bcc238950f4b573d7d" translate="yes" xml:space="preserve">
          <source>Do calls function f on each element of the ring, in forward order. The behavior of Do is undefined if f changes *r.</source>
          <target state="translated">링의 각 요소에서 함수 f를 순서대로 호출합니다. f가 * r을 변경하면 Do의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4aae39793ad1559304a62b480983270ecdafd252" translate="yes" xml:space="preserve">
          <source>Do calls the function f if and only if Do is being called for the first time for this instance of Once. In other words, given</source>
          <target state="translated">이 한 번 인스턴스에 대해 처음으로 Do가 호출되는 경우에만 함수 f를 호출합니다. 다시 말해, 주어진</target>
        </trans-unit>
        <trans-unit id="8fc83ea5ac46597554232c0c42033d14a7416d33" translate="yes" xml:space="preserve">
          <source>Do is convenience method that writes a request and reads a response.</source>
          <target state="translated">요청을 작성하고 응답을 읽는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="83ae63c0144eed839424d121a195436a02591450" translate="yes" xml:space="preserve">
          <source>Do is intended for initialization that must be run exactly once. Since f is niladic, it may be necessary to use a function literal to capture the arguments to a function to be invoked by Do:</source>
          <target state="translated">Do는 정확히 한 번 실행해야하는 초기화 용입니다. f는 음절이므로 Do에서 호출 할 함수의 인수를 캡처하려면 함수 리터럴을 사용해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="171db7265264382a4470c716c800cfeaf865b910" translate="yes" xml:space="preserve">
          <source>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</source>
          <target state="translated">함수가 허용하더라도 nil 컨텍스트를 전달하지 마십시오. 사용할 컨텍스트가 확실하지 않으면 context.TODO를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="403473243ae753314d3e7c6e5efb971fec3919ed" translate="yes" xml:space="preserve">
          <source>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx:</source>
          <target state="translated">구조체 타입 안에 컨텍스트를 저장하지 마십시오; 대신, 필요한 각 함수에 컨텍스트를 명시 적으로 전달하십시오. 컨텍스트는 일반적으로 ctx라는 첫 번째 매개 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d7779aca2e90b3ef06e0e59e88b36b9294187c5a" translate="yes" xml:space="preserve">
          <source>Do sends an HTTP request and returns an HTTP response, following policy (such as redirects, cookies, auth) as configured on the client.</source>
          <target state="translated">Do는 HTTP 요청을 보내고 클라이언트에 구성된대로 정책 (예 : 리디렉션, 쿠키, 인증)에 따라 HTTP 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53a040ce848c0973a1eaf2705fea9e3c16c10f29" translate="yes" xml:space="preserve">
          <source>Done decrements the WaitGroup counter by one.</source>
          <target state="translated">완료는 WaitGroup 카운터를 1 씩 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="5d8a8a3c5fe2e401e493c36ab14b008c0145b4a3" translate="yes" xml:space="preserve">
          <source>Dot encoding is a common framing used for data blocks in text protocols such as SMTP. The data consists of a sequence of lines, each of which ends in &quot;\r\n&quot;. The sequence itself ends at a line containing just a dot: &quot;.\r\n&quot;. Lines beginning with a dot are escaped with an additional dot to avoid looking like the end of the sequence.</source>
          <target state="translated">도트 인코딩은 SMTP와 같은 텍스트 프로토콜의 데이터 블록에 사용되는 일반적인 프레임입니다. 데이터는 일련의 줄로 구성되며 각 줄은 &quot;\ r \ n&quot;으로 끝납니다. 시퀀스 자체는 점 &quot;. \ r \ n&quot;을 포함하는 줄에서 끝납니다. 점으로 시작하는 줄은 시퀀스의 끝처럼 보이지 않도록 추가 점으로 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa5cb276f9495e5d4c9e33568c4e7fe494cb1c1" translate="yes" xml:space="preserve">
          <source>DotNode holds the special identifier '.'.</source>
          <target state="translated">DotNode에는 특수 식별자 '.'가 있습니다.</target>
        </trans-unit>
        <trans-unit id="45d81c0de8e57188c73733729e426e2cc8e21bc9" translate="yes" xml:space="preserve">
          <source>DotReader returns a new Reader that satisfies Reads using the decoded text of a dot-encoded block read from r. The returned Reader is only valid until the next call to a method on r.</source>
          <target state="translated">DotReader는 r에서 읽은 도트 인코딩 블록의 디코딩 된 텍스트를 사용하여 읽기를 만족하는 새로운 리더를 반환합니다. 리턴 된 Reader는 다음에 r에서 메소드를 호출 할 때까지만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="5f12978969ba09aae6377b8a8b1e656b9e301cf7" translate="yes" xml:space="preserve">
          <source>DotWriter returns a writer that can be used to write a dot-encoding to w. It takes care of inserting leading dots when necessary, translating line-ending \n into \r\n, and adding the final .\r\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w.</source>
          <target state="translated">DotWriter는 도트 인코딩을 w에 쓰는 데 사용할 수있는 기록기를 반환합니다. 필요한 경우 선행 점을 삽입하고 줄 끝 \ n을 \ r \ n으로 번역하고 DotWriter가 닫힐 때 마지막. \ r \ n 줄을 추가합니다. 호출자는 w의 메소드를 다음에 호출하기 전에 DotWriter를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="34df04156d8c13982c47017e9978f653e9f12cc7" translate="yes" xml:space="preserve">
          <source>Draw calls DrawMask with a nil mask.</source>
          <target state="translated">Draw 마스크는 무 마스크로 DrawMask를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4b5e532be0920a0453cdc54d04b9169084ccdf0e" translate="yes" xml:space="preserve">
          <source>Draw implements the Drawer interface by calling the Draw function with this Op.</source>
          <target state="translated">Draw는이 Op로 Draw 함수를 호출하여 Drawer 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="095366335bb273e4a2ea61cb6fd7f32f8d19f685" translate="yes" xml:space="preserve">
          <source>DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.</source>
          <target state="translated">DrawMask는 dst의 r.Min을 src의 sp와 마스크의 mp와 정렬 한 다음 dst의 사각형 r을 Porter-Duff 컴포지션의 결과로 바꿉니다. 무 마스크는 불투명으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="69353508254d7fc67f1bc0d561821973e8541c4b" translate="yes" xml:space="preserve">
          <source>Drawer (FloydSteinberg)</source>
          <target state="translated">서랍 (FloydSteinberg)</target>
        </trans-unit>
        <trans-unit id="8253364d6d713de9b550787176c132b382c33930" translate="yes" xml:space="preserve">
          <source>Drawer contains the Draw method.</source>
          <target state="translated">서랍에는 Draw 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca04bd4da9fe0c03ee57c4703ae1e82be8d6e722" translate="yes" xml:space="preserve">
          <source>Driver is the interface that must be implemented by a database driver.</source>
          <target state="translated">드라이버는 데이터베이스 드라이버로 구현해야하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9f645d42b5568aea825206b8e697ea66dab57c60" translate="yes" xml:space="preserve">
          <source>Driver returns the database's underlying driver.</source>
          <target state="translated">드라이버는 데이터베이스의 기본 드라이버를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a00d50aef5aea9e2710b9f36a21127df22306c7" translate="yes" xml:space="preserve">
          <source>Drivers returns a sorted list of the names of the registered drivers.</source>
          <target state="translated">드라이버는 등록 된 드라이버 이름의 정렬 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2abae0c55704de2aa26c34322b4e8c275aa1bc7c" translate="yes" xml:space="preserve">
          <source>Drivers that do not support context cancellation will not return until after the query is completed.</source>
          <target state="translated">컨텍스트 취소를 지원하지 않는 드라이버는 쿼리가 완료 될 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8d218c02974bb1de20e1d664e3a90526498d120" translate="yes" xml:space="preserve">
          <source>Dump</source>
          <target state="translated">Dump</target>
        </trans-unit>
        <trans-unit id="1efe71a094bc514414a290528c9e86553e7520b4" translate="yes" xml:space="preserve">
          <source>Dump returns a string that contains a hex dump of the given data. The format of the hex dump matches the output of `hexdump -C` on the command line.</source>
          <target state="translated">덤프는 주어진 데이터의 16 진 덤프가 포함 된 문자열을 리턴합니다. 16 진 덤프의 형식은 명령 행의`hexdump -C` 출력과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a3b283785980f70b0d4303b4bc4c441375213c3f" translate="yes" xml:space="preserve">
          <source>DumpRequest</source>
          <target state="translated">DumpRequest</target>
        </trans-unit>
        <trans-unit id="3de7dbfc307f5235c1d6b683c171950e7f1ffd23" translate="yes" xml:space="preserve">
          <source>DumpRequest returns the given request in its HTTP/1.x wire representation. It should only be used by servers to debug client requests. The returned representation is an approximation only; some details of the initial request are lost while parsing it into an http.Request. In particular, the order and case of header field names are lost. The order of values in multi-valued headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their original binary representations.</source>
          <target state="translated">DumpRequest는 지정된 요청을 해당 HTTP / 1.x 와이어 표현으로 반환합니다. 클라이언트 요청을 디버그하기 위해 서버에서만 사용해야합니다. 반환 된 표현은 근사치 일뿐입니다. 초기 요청의 일부 세부 사항은 http.Request로 구문 분석하는 동안 유실됩니다. 특히 헤더 필드 이름의 순서와 대소 문자가 손실됩니다. 다중 값 헤더의 값 순서는 그대로 유지됩니다. HTTP / 2 요청은 원래 이진 표현이 아닌 HTTP / 1.x 형식으로 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="8617a69fd95544d86b25db256370774190ace264" translate="yes" xml:space="preserve">
          <source>DumpRequestOut</source>
          <target state="translated">DumpRequestOut</target>
        </trans-unit>
        <trans-unit id="76f5ce4e85d9829f54cc4eca908b5ee3db848cc0" translate="yes" xml:space="preserve">
          <source>DumpRequestOut is like DumpRequest but for outgoing client requests. It includes any headers that the standard http.Transport adds, such as User-Agent.</source>
          <target state="translated">DumpRequestOut은 DumpRequest와 유사하지만 발신 클라이언트 요청에 사용됩니다. User-Agent와 같은 표준 http.Transport가 추가하는 모든 헤더를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="fab002c74edbf53a695bff854b73691ee5ff49db" translate="yes" xml:space="preserve">
          <source>DumpResponse</source>
          <target state="translated">DumpResponse</target>
        </trans-unit>
        <trans-unit id="b5cb2fa3b185da1849224df819e33e22048bed0a" translate="yes" xml:space="preserve">
          <source>DumpResponse is like DumpRequest but dumps a response.</source>
          <target state="translated">DumpResponse는 DumpRequest와 유사하지만 응답을 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="ca6f5764b6bb205859885185dfc165c84ecff79a" translate="yes" xml:space="preserve">
          <source>Dumper</source>
          <target state="translated">Dumper</target>
        </trans-unit>
        <trans-unit id="2d77075aac1401c0e2be5db28c0ababd2d200f0f" translate="yes" xml:space="preserve">
          <source>Dumper returns a WriteCloser that writes a hex dump of all written data to w. The format of the dump matches the output of `hexdump -C` on the command line.</source>
          <target state="translated">덤퍼는 모든 기록 된 데이터의 16 진 덤프를 w에 쓰는 WriteCloser를 리턴합니다. 덤프 형식은 명령 행의`hexdump -C` 출력과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1370004da76fa4f3b7a5180fd5436065ef4c7d5b" translate="yes" xml:space="preserve">
          <source>Duration</source>
          <target state="translated">Duration</target>
        </trans-unit>
        <trans-unit id="d39bc61f4df92670a47d7dbb0340a26919244359" translate="yes" xml:space="preserve">
          <source>Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration.</source>
          <target state="translated">Duration은 지정된 이름, 기본값 및 사용 문자열을 사용하여 time.Duration 플래그를 정의합니다. 반환 값은 플래그의 값을 저장하는 time.Duration 변수의 주소입니다. 플래그는 time.ParseDuration에 허용되는 값을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="5195f3e65af1376bff8d2aff52391b3e64e72714" translate="yes" xml:space="preserve">
          <source>Duration flags accept any input valid for time.ParseDuration.</source>
          <target state="translated">기간 플래그는 time.ParseDuration에 유효한 모든 입력을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1e5d634713acf3a5ece781c540b83969479fdedd" translate="yes" xml:space="preserve">
          <source>Duration.Hours</source>
          <target state="translated">Duration.Hours</target>
        </trans-unit>
        <trans-unit id="767678f246489f2d369059f5a4e433ba83f27dc4" translate="yes" xml:space="preserve">
          <source>Duration.Minutes</source>
          <target state="translated">Duration.Minutes</target>
        </trans-unit>
        <trans-unit id="15796e7613718dc9316e8a9259c9d1872dc9d2c5" translate="yes" xml:space="preserve">
          <source>Duration.Nanoseconds</source>
          <target state="translated">Duration.Nanoseconds</target>
        </trans-unit>
        <trans-unit id="1621f40b95946ff6207b9c656512e487ad66ce32" translate="yes" xml:space="preserve">
          <source>Duration.Round</source>
          <target state="translated">Duration.Round</target>
        </trans-unit>
        <trans-unit id="6557fa3a9db485bd65efba25bd2fc6fec3d0de9b" translate="yes" xml:space="preserve">
          <source>Duration.Seconds</source>
          <target state="translated">Duration.Seconds</target>
        </trans-unit>
        <trans-unit id="c5f06d8a52e2242c2cad632dade4de2fcd473e3a" translate="yes" xml:space="preserve">
          <source>Duration.String</source>
          <target state="translated">Duration.String</target>
        </trans-unit>
        <trans-unit id="565c13e1bc7186cba22a3e856369e0913d16cff5" translate="yes" xml:space="preserve">
          <source>Duration.Truncate</source>
          <target state="translated">Duration.Truncate</target>
        </trans-unit>
        <trans-unit id="53a5653f95d5c0243363897afbc01308538ab04d" translate="yes" xml:space="preserve">
          <source>DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration.</source>
          <target state="translated">DurationVar는 지정된 이름, 기본값 및 사용 문자열로 time.Duration 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 time.Duration 변수를 가리 킵니다. 플래그는 time.ParseDuration에 허용되는 값을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="96fcaca56da697a54efbf68b6f544825c513abfd" translate="yes" xml:space="preserve">
          <source>During a particular build, the following words are satisfied:</source>
          <target state="translated">특정 빌드 중에 다음 단어가 만족됩니다.</target>
        </trans-unit>
        <trans-unit id="6bfb7cfcb687419a46176f2be1f3191cd5d7b4b4" translate="yes" xml:space="preserve">
          <source>During execution functions are found in two function maps: first in the template, then in the global function map. By default, no functions are defined in the template but the Funcs method can be used to add them.</source>
          <target state="translated">실행하는 동안 함수는 두 개의 함수 맵에서 찾을 수 있습니다. 먼저 템플릿에서 전역 함수 맵에서 찾으십시오. 기본적으로 템플릿에는 함수가 정의되어 있지 않지만 Funcs 메서드를 사용하여 함수를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df0b06929972c9b30315986c52f79ebdf35f7e8" translate="yes" xml:space="preserve">
          <source>Dx returns r's width.</source>
          <target state="translated">Dx는 r의 너비를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f41c6da4d6741acc126c0422196933be598f6153" translate="yes" xml:space="preserve">
          <source>Dy returns r's height.</source>
          <target state="translated">Dy는 r의 높이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32b6bc7918b98bfd40dd37e996810216132462b9" translate="yes" xml:space="preserve">
          <source>Dyn.Tag</source>
          <target state="translated">Dyn.Tag</target>
        </trans-unit>
        <trans-unit id="5222f10256a08491c36be3639e64bc2ebff12623" translate="yes" xml:space="preserve">
          <source>DynString returns the strings listed for the given tag in the file's dynamic section.</source>
          <target state="translated">DynString은 파일의 동적 섹션에서 주어진 태그에 대해 나열된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db202bdad98e296b9a3563abcfa107dc6f7dc00b" translate="yes" xml:space="preserve">
          <source>DynamicSymbols returns the dynamic symbol table for f. The symbols will be listed in the order they appear in f.</source>
          <target state="translated">DynamicSymbols는 f에 대한 동적 심볼 테이블을 반환합니다. 기호는 f에 표시된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="4c378c0dd0f7970369ff718ef4a5dbb0ea2f5ff7" translate="yes" xml:space="preserve">
          <source>ELF32 Compression header.</source>
          <target state="translated">ELF32 압축 헤더.</target>
        </trans-unit>
        <trans-unit id="d9805c8c21043a51a02b54b3aeec72a98f35ab90" translate="yes" xml:space="preserve">
          <source>ELF32 Dynamic structure. The &quot;.dynamic&quot; section contains an array of them.</source>
          <target state="translated">ELF32 동적 구조. &quot;.dynamic&quot;섹션은 이들의 배열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="01cfc9c73c1836df918dbdb1ff394e536b5e750e" translate="yes" xml:space="preserve">
          <source>ELF32 File header.</source>
          <target state="translated">ELF32 파일 헤더.</target>
        </trans-unit>
        <trans-unit id="a95b78b9e8d26713e54bc7d6dbf4a94c300ad3cc" translate="yes" xml:space="preserve">
          <source>ELF32 Program header.</source>
          <target state="translated">ELF32 프로그램 헤더.</target>
        </trans-unit>
        <trans-unit id="2562dbbf0dcee0f2e54eb9f48338f7def8b4bbc4" translate="yes" xml:space="preserve">
          <source>ELF32 Relocations that don't need an addend field.</source>
          <target state="translated">추가 필드가 필요없는 ELF32 재배치.</target>
        </trans-unit>
        <trans-unit id="794563b14439e28188bc640bdadb9bb63d680d95" translate="yes" xml:space="preserve">
          <source>ELF32 Relocations that need an addend field.</source>
          <target state="translated">추가 필드가 필요한 ELF32 재배치.</target>
        </trans-unit>
        <trans-unit id="cd616263209dd900d196fadf9047398dfd2521b2" translate="yes" xml:space="preserve">
          <source>ELF32 Section header.</source>
          <target state="translated">ELF32 섹션 헤더.</target>
        </trans-unit>
        <trans-unit id="3e8a6d1fbb884fcd546a737b6627f180033dfe18" translate="yes" xml:space="preserve">
          <source>ELF32 Symbol.</source>
          <target state="translated">ELF32 기호.</target>
        </trans-unit>
        <trans-unit id="95e34cade68c612b8b31a15c7b0be30ee7d2c449" translate="yes" xml:space="preserve">
          <source>ELF64 Compression header.</source>
          <target state="translated">ELF64 압축 헤더.</target>
        </trans-unit>
        <trans-unit id="8bff0b09a1d753cf9e7269a9f278d58013217bfa" translate="yes" xml:space="preserve">
          <source>ELF64 Dynamic structure. The &quot;.dynamic&quot; section contains an array of them.</source>
          <target state="translated">ELF64 동적 구조. &quot;.dynamic&quot;섹션은 이들의 배열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c53643c180d85eb5f05c20f66f7443ee9f9d2d90" translate="yes" xml:space="preserve">
          <source>ELF64 Program header.</source>
          <target state="translated">ELF64 프로그램 헤더.</target>
        </trans-unit>
        <trans-unit id="d53dc77020d82faf2a8fb56ce571eac7a4c406fd" translate="yes" xml:space="preserve">
          <source>ELF64 Section header.</source>
          <target state="translated">ELF64 섹션 헤더.</target>
        </trans-unit>
        <trans-unit id="8b38ac0b54bc34aaae042028741c36e4940cce07" translate="yes" xml:space="preserve">
          <source>ELF64 file header.</source>
          <target state="translated">ELF64 파일 헤더</target>
        </trans-unit>
        <trans-unit id="429907c0b3e6b47962dd713a0f45efbc999d98d2" translate="yes" xml:space="preserve">
          <source>ELF64 relocations that don't need an addend field.</source>
          <target state="translated">추가 필드가 필요없는 ELF64 재배치.</target>
        </trans-unit>
        <trans-unit id="0c6ddbd3dc62aa9dd229b61e1dbcf4930eb356c0" translate="yes" xml:space="preserve">
          <source>ELF64 relocations that need an addend field.</source>
          <target state="translated">추가 필드가 필요한 ELF64 재배치.</target>
        </trans-unit>
        <trans-unit id="8185d8c0b42b58b3e2cb27fd3b6a714d1ecb3d6b" translate="yes" xml:space="preserve">
          <source>ELF64 symbol table entries.</source>
          <target state="translated">ELF64 기호 테이블 항목</target>
        </trans-unit>
        <trans-unit id="c1ef067c48898a4eb1b2ec281361b9d7232d849b" translate="yes" xml:space="preserve">
          <source>EOF is the error returned by Read when no more input is available. Functions should return EOF only to signal a graceful end of input. If the EOF occurs unexpectedly in a structured data stream, the appropriate error is either ErrUnexpectedEOF or some other error giving more detail.</source>
          <target state="translated">EOF는 더 이상 입력이 없을 때 Read에 의해 반환 된 오류입니다. 함수는 입력의 정상 종료를 알리기 위해 EOF 만 반환해야합니다. 구조화 된 데이터 스트림에서 EOF가 예기치 않게 발생하는 경우 적절한 오류는 ErrUnexpectedEOF이거나 자세한 내용을 제공하는 다른 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b9b211da674bf7d5d2d22532b4017302669c9ac7" translate="yes" xml:space="preserve">
          <source>Each Cond has an associated Locker L (often a *Mutex or *RWMutex), which must be held when changing the condition and when calling the Wait method.</source>
          <target state="translated">각 Cond에는 연관된 Locker L (보통 * Mutex 또는 * RWMutex)이 있으며 조건을 변경하고 Wait 메소드를 호출 할 때 보유해야합니다.</target>
        </trans-unit>
        <trans-unit id="53ce2a7553dfc359fede4c116e264e25c2fea211" translate="yes" xml:space="preserve">
          <source>Each Float value also has a precision, rounding mode, and accuracy. The precision is the maximum number of mantissa bits available to represent the value. The rounding mode specifies how a result should be rounded to fit into the mantissa bits, and accuracy describes the rounding error with respect to the exact result.</source>
          <target state="translated">각 Float 값에는 정밀도, 반올림 모드 및 정확도가 있습니다. 정밀도는 값을 나타내는 데 사용할 수있는 최대 가수 비트 수입니다. 반올림 모드는 가수 비트에 맞게 결과를 반올림하는 방법을 지정하며 정확도는 정확한 결과와 관련하여 반올림 오류를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c22b6da18b15dfcb152711437d1c5b6b668025fa" translate="yes" xml:space="preserve">
          <source>Each Profile has a unique name. A few profiles are predefined:</source>
          <target state="translated">각 프로파일에는 고유 한 이름이 있습니다. 몇 가지 프로파일이 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d27822f6c94a0fc0349a0c96e70c540078b10e05" translate="yes" xml:space="preserve">
          <source>Each Time has associated with it a Location, consulted when computing the presentation form of the time, such as in the Format, Hour, and Year methods. The methods Local, UTC, and In return a Time with a specific location. Changing the location in this way changes only the presentation; it does not change the instant in time being denoted and therefore does not affect the computations described in earlier paragraphs.</source>
          <target state="translated">각 시간은 위치와 연관되어 있으며 형식, 시간 및 연도 방법과 같이 시간의 프리젠 테이션 양식을 계산할 때 참조됩니다. Local, UTC 및 In 메서드는 특정 위치의 시간을 반환합니다. 이런 식으로 위치를 변경하면 프리젠 테이션 만 변경됩니다. 표시되는 시간을 변경하지 않으므로 이전 단락에서 설명한 계산에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b4e64eee2924ca83b54ba5d82d34968349afb6" translate="yes" xml:space="preserve">
          <source>Each directory listed in the Go path must have a prescribed structure:</source>
          <target state="translated">이동 경로에 나열된 각 디렉토리는 규정 된 구조를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="11a47e0b159e036354bb03ab8fec410aa5efbc37" translate="yes" xml:space="preserve">
          <source>Each span of unindented non-blank lines is converted into a single paragraph. There is one exception to the rule: a span that consists of a single line, is followed by another paragraph span, begins with a capital letter, and contains no punctuation other than parentheses and commas is formatted as a heading.</source>
          <target state="translated">들여 쓰기되지 않은 비 공백 줄의 각 범위는 단일 단락으로 변환됩니다. 규칙에는 한 가지 예외가 있습니다. 한 줄로 구성되고 다른 단락 범위가 뒤 따르고 대문자로 시작하며 괄호 이외의 구두점을 포함하지 않으며 쉼표는 제목으로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="64b283319794ff9f90a2b889c357e1eadff02062" translate="yes" xml:space="preserve">
          <source>Each subtest and sub-benchmark has a unique name: the combination of the name of the top-level test and the sequence of names passed to Run, separated by slashes, with an optional trailing sequence number for disambiguation.</source>
          <target state="translated">각 하위 테스트 및 하위 벤치 마크에는 고유 한 이름이 있습니다. 최상위 테스트 이름과 실행에 전달 된 이름 시퀀스가 ​​슬래시로 구분되어 있으며 명확성을 위해 선택적인 후행 시퀀스 번호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f64692308609e7cd9aa6b965c0976bf09ca797d9" translate="yes" xml:space="preserve">
          <source>Each template is named by a string specified when it is created. Also, each template is associated with zero or more other templates that it may invoke by name; such associations are transitive and form a name space of templates.</source>
          <target state="translated">각 템플릿은 생성 될 때 지정된 문자열로 이름이 지정됩니다. 또한 각 템플릿은 이름으로 호출 할 수있는 0 개 이상의 다른 템플릿과 연결됩니다. 이러한 연관은 전 이적이며 템플릿의 네임 스페이스를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="dfe068281c7912e37aff13438f1165b9cae6281c" translate="yes" xml:space="preserve">
          <source>Each write is written to each listed writer, one at a time. If a listed writer returns an error, that overall write operation stops and returns the error; it does not continue down the list.</source>
          <target state="translated">각 쓰기는 각 나열된 작성자에게 한 번에 하나씩 작성됩니다. 나열된 기록기가 오류를 반환하면 해당 전체 쓰기 작업이 중지되고 오류가 반환됩니다. 목록 아래로 계속 진행되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fea9dce2cfc1e5514afba8c4f79122c1f6660c7" translate="yes" xml:space="preserve">
          <source>Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for Split.</source>
          <target state="translated">s 및 sep에 대한 엣지 케이스 (예 : 빈 문자열)는 Split의 설명서에 설명 된대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e37e08f3d79b0b879d0cbc05f9e597346cc0a476" translate="yes" xml:space="preserve">
          <source>Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for SplitAfter.</source>
          <target state="translated">s 및 sep에 대한 엣지 케이스 (예 : 빈 문자열)는 SplitAfter의 설명서에 설명 된대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="62b526e2f1b563d78f9affc599c0f080c53c3770" translate="yes" xml:space="preserve">
          <source>Elem returns element type of array a.</source>
          <target state="translated">Elem은 배열 a의 요소 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c8688004f9a6c08c6f8b553e5f27b9522194baf" translate="yes" xml:space="preserve">
          <source>Elem returns the element type for the given pointer p.</source>
          <target state="translated">Elem은 주어진 포인터 p에 대한 요소 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d8af3898701d186c1b2aa25d7c01ba7a6c647ba" translate="yes" xml:space="preserve">
          <source>Elem returns the element type of channel c.</source>
          <target state="translated">Elem은 채널 c의 요소 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06df7045855a339d28ddf7bceaed3a18eca395ea" translate="yes" xml:space="preserve">
          <source>Elem returns the element type of map m.</source>
          <target state="translated">Elem은지도 m의 요소 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d9476b48442b612f54821e3019f01f37bd352c7" translate="yes" xml:space="preserve">
          <source>Elem returns the element type of slice s.</source>
          <target state="translated">Elem은 slice의 요소 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b3b30426371820daeb94800f4f247d67b378492" translate="yes" xml:space="preserve">
          <source>Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Ptr. It returns the zero Value if v is nil.</source>
          <target state="translated">Elem은 인터페이스 v에 포함되거나 포인터 v가 가리키는 값을 반환합니다. v의 종류가 인터페이스 또는 Ptr이 아닌 경우 패닉이 발생합니다. v가 nil이면 0 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="362386365af358238b7934a96826d937830ebf3a" translate="yes" xml:space="preserve">
          <source>Element is an element of a linked list.</source>
          <target state="translated">요소는 연결된 목록의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="3d304236b20204aaee01a3be7e8fa030c924f00d" translate="yes" xml:space="preserve">
          <source>Elements omitted from the value are assumed to be zero or, when zero is impossible, one, so parsing &quot;3:04pm&quot; returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored.</source>
          <target state="translated">값에서 생략 된 요소는 0으로 간주되거나 0이 불가능한 경우 1로 가정되므로 &quot;3:04 pm&quot;구문 분석은 1 월 1 일 0, 15:04:00 UTC에 해당하는 시간을 리턴합니다 (연도는 0,이 시간은 0 시간 이전입니다). 연도는 0000..9999 범위에 있어야합니다. 요일은 구문을 검사하지만 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="714dc931f98b9f53a323ada665f744f785f104e3" translate="yes" xml:space="preserve">
          <source>Embedded reports whether the variable is an embedded field.</source>
          <target state="translated">포함은 변수가 포함 된 필드인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="1a91fd75faca93aa3f92e6209ae4a04b05729483" translate="yes" xml:space="preserve">
          <source>Embedded returns the i'th embedded defined (*Named) type of interface t for 0 &amp;lt;= i &amp;lt; t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type.</source>
          <target state="translated">Embedded는 0 &amp;lt;= i &amp;lt;t.NumEmbeddeds ()에 대해 i 번째 임베디드 정의 (* Named) 유형의 인터페이스 t를 리턴합니다. i 번째 임베디드 유형이 정의 된 유형이 아닌 경우 결과는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2ad1755ca44b573afbc8198d2b54e334f6a6b246" translate="yes" xml:space="preserve">
          <source>EmbeddedType returns the i'th embedded type of interface t for 0 &amp;lt;= i &amp;lt; t.NumEmbeddeds().</source>
          <target state="translated">EmbeddedType은 0 &amp;lt;= i &amp;lt;t.NumEmbeddeds ()에 대해 i 번째 임베디드 유형의 인터페이스 t를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fbca94fd7fa6bc879ff012dca165d33cc17634f8" translate="yes" xml:space="preserve">
          <source>Emerg logs a message with severity LOG_EMERG, ignoring the severity passed to New.</source>
          <target state="translated">Emerg는 심각도가 LOG_EMERG 인 메시지를 로깅하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="208dc8efabe1038228cedca52f60b871bf5c8251" translate="yes" xml:space="preserve">
          <source>Empty reports whether t is the empty interface.</source>
          <target state="translated">Empty는 t가 빈 인터페이스인지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6164cdafbad9c2d77fab44868057e1a865dab256" translate="yes" xml:space="preserve">
          <source>Empty reports whether the rectangle contains no points.</source>
          <target state="translated">비어 있으면 사각형에 점이 없는지 여부가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1a82640541370ae1891158035802a1ac918358" translate="yes" xml:space="preserve">
          <source>Empty strings:</source>
          <target state="translated">빈 문자열 :</target>
        </trans-unit>
        <trans-unit id="1e0a04a02a4b36d462dfbd7a50f1ba95ab97db02" translate="yes" xml:space="preserve">
          <source>EmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text.</source>
          <target state="translated">EmptyOpContext는 룬 r1과 r2 사이의 위치에서 충족 된 폭이 0 인 어설 션을 반환합니다. r1 == -1을 전달하면 위치가 텍스트의 시작 부분에 있음을 나타냅니다. r2 == -1을 전달하면 위치가 텍스트의 끝에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="782e817cf07d938d62f7f0517e130f19ec6b4cf1" translate="yes" xml:space="preserve">
          <source>Encode</source>
          <target state="translated">Encode</target>
        </trans-unit>
        <trans-unit id="28107c7a586749b6433a5733b287757fb842042a" translate="yes" xml:space="preserve">
          <source>Encode calls Flush before returning.</source>
          <target state="translated">인코딩하기 전에 Flush를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="8075b5e09ea3f63f78c89a2ddc490859d0c31bf8" translate="yes" xml:space="preserve">
          <source>Encode encodes src into EncodedLen(len(src)) bytes of dst. As a convenience, it returns the number of bytes written to dst, but this value is always EncodedLen(len(src)). Encode implements hexadecimal encoding.</source>
          <target state="translated">인코딩은 src를 dst의 EncodedLen (len (src)) 바이트로 인코딩합니다. 편의상 dst에 쓴 바이트 수를 반환하지만이 값은 항상 EncodedLen (len (src))입니다. 인코딩은 16 진 인코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bad1f060c6238760ff000a670071a44f8806160b" translate="yes" xml:space="preserve">
          <source>Encode encodes src into at most MaxEncodedLen(len(src)) bytes of dst, returning the actual number of bytes written.</source>
          <target state="translated">Encode는 src를 dst의 최대 MaxEncodedLen (len (src)) 바이트로 인코딩하여 기록 된 실제 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb047c3c3d4f31e4290959040afdbcc1d45c6483" translate="yes" xml:space="preserve">
          <source>Encode encodes src using the encoding enc, writing EncodedLen(len(src)) bytes to dst.</source>
          <target state="translated">EncodedLen (len (src)) 바이트를 dst에 쓰는 인코딩 enc를 사용하여 src를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="37cb8fb5926768be9ba7db2b847e6b4f7e61df93" translate="yes" xml:space="preserve">
          <source>Encode encodes the values into &amp;ldquo;URL encoded&amp;rdquo; form (&quot;bar=baz&amp;amp;foo=quux&quot;) sorted by key.</source>
          <target state="translated">인코딩은 값을 키별로 정렬하여 &quot;URL 인코딩&quot;형식 ( &quot;bar = baz &amp;amp; foo = quux&quot;)으로 값을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="3cacdbbc19179ef246a49e3b221538113b7b2aea" translate="yes" xml:space="preserve">
          <source>Encode returns the UTF-16 encoding of the Unicode code point sequence s.</source>
          <target state="translated">인코딩은 유니 코드 코드 포인트 시퀀스의 UTF-16 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e733c09d68cd91421a4d1814d8e874c9b899a79" translate="yes" xml:space="preserve">
          <source>Encode returns the encoded-word form of s. If s is ASCII without special characters, it is returned unchanged. The provided charset is the IANA charset name of s. It is case insensitive.</source>
          <target state="translated">인코딩은 인코딩 된 단어 형태의 s를 반환합니다. s가 특수 문자가없는 ASCII이면 변경되지 않은 상태로 반환됩니다. 제공된 문자 세트는 s의 IANA 문자 세트 이름입니다. 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb435f969670ff1e290f4a330dd20e7ada06128c" translate="yes" xml:space="preserve">
          <source>Encode transmits the data item represented by the empty interface value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to Encoder will panic, as they cannot be transmitted by gob.</source>
          <target state="translated">Encode는 빈 인터페이스 값으로 표시되는 데이터 항목을 전송하여 필요한 모든 유형 정보가 먼저 전송되도록합니다. 인코더에 nil 포인터를 전달하지 않으면 gob으로 전송할 수 없으므로 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="82052ebc621525b1a00e64a785a78506cb678614" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in GIF format.</source>
          <target state="translated">Encode는 Image m을 GIF 형식으로 w에 씁니다.</target>
        </trans-unit>
        <trans-unit id="37c9bfb263c03b8e0db64db584d5ef43161f60ee" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given options. Default parameters are used if a nil *Options is passed.</source>
          <target state="translated">인코딩은 주어진 옵션을 사용하여 이미지 m을 w에 JPEG 4 : 2 : 0 기본 형식으로 씁니다. nil * Options가 전달되면 기본 매개 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b163cff27e48e422e82d5a5f5dd2edfa89cd1991" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in PNG format.</source>
          <target state="translated">인코딩은 이미지 m을 w로 PNG 형식으로 씁니다.</target>
        </trans-unit>
        <trans-unit id="a5cbca07b15679a333d2f3c1093e760dc8fed50b" translate="yes" xml:space="preserve">
          <source>Encode writes the Image m to w in PNG format. Any Image may be encoded, but images that are not image.NRGBA might be encoded lossily.</source>
          <target state="translated">인코딩은 이미지 m을 w로 PNG 형식으로 씁니다. 모든 이미지가 인코딩 될 수 있지만 이미지가 아닌 이미지 NRGBA는 손실로 인코딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8d80de5513517293c9312bce84a60a51e18c30" translate="yes" xml:space="preserve">
          <source>Encode writes the JSON encoding of v to the stream, followed by a newline character.</source>
          <target state="translated">인코딩은 v의 JSON 인코딩을 스트림에 쓴 다음 줄 바꿈 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="3431bd1ddef07774c0075a0d8cf7cdb745dd66d0" translate="yes" xml:space="preserve">
          <source>Encode writes the PEM encoding of b to out.</source>
          <target state="translated">인코딩은 b의 PEM 인코딩을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="fc285ed2b0a9eba61cc91978b1228dfe4899cae1" translate="yes" xml:space="preserve">
          <source>Encode writes the XML encoding of v to the stream.</source>
          <target state="translated">인코딩은 v의 XML 인코딩을 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="1290fb5a5c4f28124f4f2167306908f4b7e3cd0b" translate="yes" xml:space="preserve">
          <source>EncodeAll writes the images in g to w in GIF format with the given loop count and delay between frames.</source>
          <target state="translated">EncodeAll은 주어진 루프 수와 프레임 사이의 지연으로 이미지를 g에서 w로 GIF 형식으로 씁니다.</target>
        </trans-unit>
        <trans-unit id="ff1901b308e73262ddff5a1580f7534a541e698b" translate="yes" xml:space="preserve">
          <source>EncodeElement calls Flush before returning.</source>
          <target state="translated">EncodeElement는 반환하기 전에 Flush를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c581857a42291416b5012a1bfc65819fabcce520" translate="yes" xml:space="preserve">
          <source>EncodeElement writes the XML encoding of v to the stream, using start as the outermost tag in the encoding.</source>
          <target state="translated">EncodeElement는 인코딩에서 가장 바깥 쪽 태그로 start를 사용하여 v의 XML 인코딩을 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ab51517ca16e7a4e5eb7b8d3ac937d2b26f7b298" translate="yes" xml:space="preserve">
          <source>EncodeRune</source>
          <target state="translated">EncodeRune</target>
        </trans-unit>
        <trans-unit id="4f528704d795134046c2e2331ad94b8db1da56a1" translate="yes" xml:space="preserve">
          <source>EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If the rune is not a valid Unicode code point or does not need encoding, EncodeRune returns U+FFFD, U+FFFD.</source>
          <target state="translated">EncodeRune은 주어진 룬에 대해 UTF-16 서로 게이트 쌍 r1, r2를 반환합니다. 룬이 유효한 유니 코드 코드 포인트가 아니거나 인코딩이 필요없는 경우 EncodeRune은 U + FFFD, U + FFFD를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8221ae44d390e63454c4282bd9104822f9a4df9" translate="yes" xml:space="preserve">
          <source>EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune. It returns the number of bytes written.</source>
          <target state="translated">EncodeRune은 룬의 UTF-8 인코딩을 p (충분히 커야 함)에 씁니다. 쓴 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea5fe709be23ce3bc5ba98960e96ced13416a04d" translate="yes" xml:space="preserve">
          <source>EncodeToMemory returns the PEM encoding of b.</source>
          <target state="translated">EncodeToMemory는 b의 PEM 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="324c8a3fb19979327232b44bb8a31c381b37697d" translate="yes" xml:space="preserve">
          <source>EncodeToString</source>
          <target state="translated">EncodeToString</target>
        </trans-unit>
        <trans-unit id="3dfcea8813ae6722c184e6e06a17982d9d632f08" translate="yes" xml:space="preserve">
          <source>EncodeToString returns the base32 encoding of src.</source>
          <target state="translated">EncodeToString은 src의 base32 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3bc135cc3be76ce5df9e8fd7f905545938abd518" translate="yes" xml:space="preserve">
          <source>EncodeToString returns the base64 encoding of src.</source>
          <target state="translated">EncodeToString은 src의 base64 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3843839ed2a2f00b8aef2ea4e6ecf9c9ab4e04b" translate="yes" xml:space="preserve">
          <source>EncodeToString returns the hexadecimal encoding of src.</source>
          <target state="translated">EncodeToString은 src의 16 진 인코딩을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="19fcb6484006494d394978f1704e4ed9b4f5539f" translate="yes" xml:space="preserve">
          <source>EncodeToken allows writing a ProcInst with Target set to &quot;xml&quot; only as the first token in the stream.</source>
          <target state="translated">EncodeToken을 사용하면 스트림에서 첫 번째 토큰으로 만 Target이 &quot;xml&quot;로 설정된 ProcInst를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c85b7ab7de6f179653955c1c25494b973fd6239" translate="yes" xml:space="preserve">
          <source>EncodeToken does not call Flush, because usually it is part of a larger operation such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked during those), and those will call Flush when finished. Callers that create an Encoder and then invoke EncodeToken directly, without using Encode or EncodeElement, need to call Flush when finished to ensure that the XML is written to the underlying writer.</source>
          <target state="translated">EncodeToken은 일반적으로 Encode 또는 EncodeElement (또는 그 동안 호출 된 사용자 지정 Marshaler의 MarshalXML)와 같은 더 큰 작업의 일부이기 때문에 Flush를 호출하지 않으며 완료되면 Flush를 호출합니다. Encoder를 작성한 다음 Encode 또는 EncodeElement를 사용하지 않고 EncodeToken을 직접 호출하는 호출자는 XML이 기본 작성기에 작성되도록하려면 Flush를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="05059e24e38c8fd05c7837bf618707c5627060c0" translate="yes" xml:space="preserve">
          <source>EncodeToken writes the given XML token to the stream. It returns an error if StartElement and EndElement tokens are not properly matched.</source>
          <target state="translated">EncodeToken은 주어진 XML 토큰을 스트림에 씁니다. StartElement 및 EndElement 토큰이 올바르게 일치하지 않으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0947a3c8c9b8bcd8c44bdd10335e323cd1ea461b" translate="yes" xml:space="preserve">
          <source>EncodeValue transmits the data item represented by the reflection value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to EncodeValue will panic, as they cannot be transmitted by gob.</source>
          <target state="translated">EncodeValue는 반사 값으로 표시되는 데이터 항목을 전송하여 필요한 모든 유형 정보가 먼저 전송되도록합니다. EncodeValue에 nil 포인터를 전달하면 gob로는 전송할 수 없으므로 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="854b241316ad3d39a8ee266c3a44ddee623c1784" translate="yes" xml:space="preserve">
          <source>EncodedLen returns the length in bytes of the base32 encoding of an input buffer of length n.</source>
          <target state="translated">EncodedLen은 길이 n의 입력 버퍼에 대한 base32 인코딩의 길이를 바이트 단위로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a4f417b33e58db9c0c31f29eff4ddd8669f0b97" translate="yes" xml:space="preserve">
          <source>EncodedLen returns the length in bytes of the base64 encoding of an input buffer of length n.</source>
          <target state="translated">EncodedLen은 길이 n의 입력 버퍼에 대한 base64 인코딩의 길이를 바이트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="485a353fee0c882183777b5b5993044af3a1bc75" translate="yes" xml:space="preserve">
          <source>EncodedLen returns the length of an encoding of n source bytes. Specifically, it returns n * 2.</source>
          <target state="translated">EncodedLen은 n 소스 바이트의 인코딩 길이를 반환합니다. 특히 n * 2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7dca2524a7e133f2714375c509deec12458fd552" translate="yes" xml:space="preserve">
          <source>Encoder</source>
          <target state="translated">Encoder</target>
        </trans-unit>
        <trans-unit id="2b7ddfe809165179e7cd2edadb5a1ced8b769f0f" translate="yes" xml:space="preserve">
          <source>Encoder configures encoding PNG images.</source>
          <target state="translated">인코더는 PNG 이미지 인코딩을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ea245bab86e7e7cf2fd8d813fc2e95cb74506589" translate="yes" xml:space="preserve">
          <source>EncoderBuffer holds the buffers used for encoding PNG images.</source>
          <target state="translated">EncoderBuffer는 PNG 이미지 인코딩에 사용 된 버퍼를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="0fc95babeebbbdab367284399ffa521502bf0828" translate="yes" xml:space="preserve">
          <source>EncoderBufferPool is an interface for getting and returning temporary instances of the EncoderBuffer struct. This can be used to reuse buffers when encoding multiple images.</source>
          <target state="translated">EncoderBufferPool은 EncoderBuffer 구조체의 임시 인스턴스를 가져오고 반환하기위한 인터페이스입니다. 여러 이미지를 인코딩 할 때 버퍼를 재사용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2226a4e1fe15dc87148f967dace15e6586e72c4" translate="yes" xml:space="preserve">
          <source>Encoding Details</source>
          <target state="translated">인코딩 세부 사항</target>
        </trans-unit>
        <trans-unit id="8ca66aaccc75b682fb570d9fde3184c72d629e9c" translate="yes" xml:space="preserve">
          <source>Encoding.DecodeString</source>
          <target state="translated">Encoding.DecodeString</target>
        </trans-unit>
        <trans-unit id="614b34c455deb2c2a0b4963d69801751d69a4b89" translate="yes" xml:space="preserve">
          <source>Encoding.EncodeToString</source>
          <target state="translated">Encoding.EncodeToString</target>
        </trans-unit>
        <trans-unit id="321539e50d8c1a12cfc511582d9e7c710284774f" translate="yes" xml:space="preserve">
          <source>EncryptOAEP</source>
          <target state="translated">EncryptOAEP</target>
        </trans-unit>
        <trans-unit id="0bf129deb5a96b559ca75907380b4d67e23a7c95" translate="yes" xml:space="preserve">
          <source>EncryptOAEP encrypts the given message with RSA-OAEP.</source>
          <target state="translated">EncryptOAEP는 RSA-OAEP로 지정된 메시지를 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="6b690d741feab568e68ed01d4029afb22005c9ca" translate="yes" xml:space="preserve">
          <source>EncryptPEMBlock returns a PEM block of the specified type holding the given DER-encoded data encrypted with the specified algorithm and password.</source>
          <target state="translated">EncryptPEMBlock은 지정된 알고리즘 및 암호로 암호화 된 지정된 DER 인코딩 데이터를 보유하는 지정된 유형의 PEM 블록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e11b5091381ca592414c841e33cc24a6a12dbfc" translate="yes" xml:space="preserve">
          <source>EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5. The message must be no longer than the length of the public modulus minus 11 bytes.</source>
          <target state="translated">EncryptPKCS1v15는 RSA 및 PKCS # 1 v1.5의 패딩 체계를 사용하여 지정된 메시지를 암호화합니다. 메시지는 더 이상 공개 모듈 길이에서 11 바이트를 뺀 길이를 초과해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="67f8660b6ee6f64ee979595238eebbe3f14e32b1" translate="yes" xml:space="preserve">
          <source>End marks the end of the operation represented by the Task.</source>
          <target state="translated">종료는 작업이 나타내는 작업의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0eb51238ae16cda9710b593b0fe1c30e79e170be" translate="yes" xml:space="preserve">
          <source>End marks the end of the traced code region.</source>
          <target state="translated">End는 추적 된 코드 영역의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fd4f40a6a53acbe4c60d207d7edd5710b46ca090" translate="yes" xml:space="preserve">
          <source>End returns the corresponding XML end element.</source>
          <target state="translated">End는 해당 XML 끝 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1740f46ed43f406a6103daf9f32866a26a80d41" translate="yes" xml:space="preserve">
          <source>EndRequest notifies p that the request with the given id has been sent (or, if this is a server, received).</source>
          <target state="translated">EndRequest는 주어진 ID를 가진 요청이 전송되었음을 (또는 이것이 서버 인 경우) 수신했음을 p에 알립니다.</target>
        </trans-unit>
        <trans-unit id="6e2e995a27065f521aa0378954a6196f51dbb39f" translate="yes" xml:space="preserve">
          <source>EndResponse notifies p that the response with the given id has been received (or, if this is a server, sent).</source>
          <target state="translated">EndResponse는 주어진 ID를 가진 응답이 수신되었다는 것을 p에게 알립니다 (또는 이것이 서버 인 경우 전송 됨).</target>
        </trans-unit>
        <trans-unit id="90fffc0a3145721a08d65aaabc9b277262428177" translate="yes" xml:space="preserve">
          <source>Entry returns the entry address of the function.</source>
          <target state="translated">엔트리는 함수의 엔트리 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f68f172a7016b7818d2dab5107eab4fa604b31d7" translate="yes" xml:space="preserve">
          <source>Environ returns a copy of strings representing the environment, in the form &quot;key=value&quot;.</source>
          <target state="translated">환경은 환경을 나타내는 문자열의 사본을 &quot;key = value&quot;형식으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="045f71994ee68b9a868e51f44a880e8642e83557" translate="yes" xml:space="preserve">
          <source>Eq reports whether p and q are equal.</source>
          <target state="translated">Eq는 p와 q가 같은지보고합니다.</target>
        </trans-unit>
        <trans-unit id="d543b9a23b302f4f4fb69164e3e63071f6ee7f20" translate="yes" xml:space="preserve">
          <source>Eq reports whether r and s contain the same set of points. All empty rectangles are considered equal.</source>
          <target state="translated">Eq는 r과 s에 동일한 점 세트가 있는지 여부를보고합니다. 빈 사각형은 모두 같은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a472ce8d19d10484177dabb05deb4ee299058a0c" translate="yes" xml:space="preserve">
          <source>Equal</source>
          <target state="translated">Equal</target>
        </trans-unit>
        <trans-unit id="d008b976622977894ad1256a169eda07f451f5cf" translate="yes" xml:space="preserve">
          <source>Equal compares two MACs for equality without leaking timing information.</source>
          <target state="translated">같음은 타이밍 정보를 누설하지 않고 두 개의 MAC이 동일한 지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="26406bd3b947d0c8a8751c20420b77c92f9cfb01" translate="yes" xml:space="preserve">
          <source>Equal reports whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice.</source>
          <target state="translated">같음 a와 b가 같은 길이이고 같은 바이트를 포함하는지보고합니다. nil 인수는 빈 슬라이스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9338a726f14837219e3f0b5160e801035363d7a6" translate="yes" xml:space="preserve">
          <source>Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal.</source>
          <target state="translated">같음은 ip와 x가 동일한 IP 주소인지 여부를보고합니다. IPv4 주소와 IPv6 형식의 동일한 주소는 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e236086365a108f382942e0e763834a0bce968eb" translate="yes" xml:space="preserve">
          <source>Equal reports whether oi and other represent the same identifier.</source>
          <target state="translated">같음과 oi가 다른 식별자를 나타내는 지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="ef1871b89edc21087f0c972b71d0af0383183bbc" translate="yes" xml:space="preserve">
          <source>Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 CEST and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead.</source>
          <target state="translated">같음 t와 u가 같은 시간 순간을 나타내는 지보고합니다. 서로 다른 위치에 있더라도 두 번 동일 할 수 있습니다. 예를 들어, 6:00 +0200 CEST와 4:00 UTC는 같습니다. = 값을 시간 값과 함께 사용하는 함정에 대해서는 시간 유형에 대한 문서를 참조하십시오. 대부분의 코드는 대신 Equal을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="901b20b6e47f8875259f27573f49fab5bbd14942" translate="yes" xml:space="preserve">
          <source>Equal reports whether x and y have identical structure.</source>
          <target state="translated">같음은 x와 y의 구조가 같은지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="2acbd072fc0cea3dbceb299edaa5f0267951a317" translate="yes" xml:space="preserve">
          <source>EqualFold</source>
          <target state="translated">EqualFold</target>
        </trans-unit>
        <trans-unit id="2f3cf184644e462de0ae310758745d4172f640f1" translate="yes" xml:space="preserve">
          <source>EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding.</source>
          <target state="translated">EqualFold는 UTF-8 문자열로 해석되는 s와 t가 유니 코드 대 / 소문자 구분에서 동일한 지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a45c873903030f443476751c44e9df07e6be3d31" translate="yes" xml:space="preserve">
          <source>Erf returns the error function of x.</source>
          <target state="translated">Erf는 x의 오류 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee0699badf2b941a080ee739ed6ea1875f351847" translate="yes" xml:space="preserve">
          <source>Erfc returns the complementary error function of x.</source>
          <target state="translated">Erfc는 x의 상보 오차 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18bdc77cc7ccf01894d60882c01638586652a838" translate="yes" xml:space="preserve">
          <source>Erfcinv returns the inverse of Erfc(x).</source>
          <target state="translated">Erfcinv는 Erfc (x)의 역수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb7f9017bf886c8e3d8bef46625d5e9ffc1f9661" translate="yes" xml:space="preserve">
          <source>Erfinv returns the inverse error function of x.</source>
          <target state="translated">Erfinv는 x의 역 오차 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd9ef49ac603b471db58d8995717ed1a3762d907" translate="yes" xml:space="preserve">
          <source>Err logs a message with severity LOG_ERR, ignoring the severity passed to New.</source>
          <target state="translated">Err은 심각도가 LOG_ERR 인 메시지를 기록하며 심각도는 New로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5578cd7bcdf826276ecb1f2f28645e2bbb50359e" translate="yes" xml:space="preserve">
          <source>Err returns an error equivalent to this error list. If the list is empty, Err returns nil.</source>
          <target state="translated">Err은이 오류 목록에 해당하는 오류를 반환합니다. 목록이 비어 있으면 Err은 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="832f241be017d872e00d3180f6d33f40fd5570e6" translate="yes" xml:space="preserve">
          <source>Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit Close.</source>
          <target state="translated">Err은 반복 중에 발생한 오류 (있는 경우)를 반환합니다. Err은 명시 적 또는 암시 적 닫기 후에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4df7d7cbdf62192ee825ad1260a51e02a37a319" translate="yes" xml:space="preserve">
          <source>Err returns the first non-EOF error that was encountered by the Scanner.</source>
          <target state="translated">Err은 검사기에서 발생한 첫 번째 EOF 이외 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7c28ecb0558af18edf16f6cdb309e8e1c3a8d97" translate="yes" xml:space="preserve">
          <source>ErrAbortHandler is a sentinel panic value to abort a handler. While any panic from ServeHTTP aborts the response to the client, panicking with ErrAbortHandler also suppresses logging of a stack trace to the server's error log.</source>
          <target state="translated">ErrAbortHandler는 핸들러를 중단하기위한 센티넬 패닉 값입니다. ServeHTTP의 패닉이 클라이언트에 대한 응답을 중단하는 동안 ErrAbortHandler를 사용하여 패닉하면 서버의 오류 로그에 스택 추적이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c93b5da38ab3884dabe8401ec5789cf9954b24e" translate="yes" xml:space="preserve">
          <source>ErrBadConn should be returned by a driver to signal to the sql package that a driver.Conn is in a bad state (such as the server having earlier closed the connection) and the sql package should retry on a new connection.</source>
          <target state="translated">ErrBadConn은 드라이버가 SQL 패키지에 드라이버를 알리기 위해 드라이버에 의해 반환되어야합니다. Driver.Conn이 잘못된 상태 (예 : 서버가 연결을 종료 한 상태)에 있고 SQL 패키지는 새 연결을 다시 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3b44f0681b8df29aaf90b891286d09878a539aa" translate="yes" xml:space="preserve">
          <source>ErrBadPattern indicates a pattern was malformed.</source>
          <target state="translated">ErrBadPattern은 패턴이 잘못되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3ee1109d6fff6aa1a95dd2ace67b7df2a7334ba3" translate="yes" xml:space="preserve">
          <source>ErrBodyReadAfterClose is returned when reading a Request or Response Body after the body has been closed. This typically happens when the body is read after an HTTP Handler calls WriteHeader or Write on its ResponseWriter.</source>
          <target state="translated">본문이 닫힌 후 요청 또는 응답 본문을 읽을 때 ErrBodyReadAfterClose가 리턴됩니다. 이는 일반적으로 HTTP 처리기가 WriteHeader 또는 ResponseWriter에서 Write를 호출 한 후 본문을 읽을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="162a55fce73b60c104f7cc8f11a8072e1ddfd29f" translate="yes" xml:space="preserve">
          <source>ErrClosedPipe is the error used for read or write operations on a closed pipe.</source>
          <target state="translated">ErrClosedPipe는 닫힌 파이프에서 읽기 또는 쓰기 작업에 사용되는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a4639f7f94b9cb5f412fc7548161f523a7e7f666" translate="yes" xml:space="preserve">
          <source>ErrConnClosed is returned by Read when a handler attempts to read the body of a request after the connection to the web server has been closed.</source>
          <target state="translated">웹 서버에 대한 연결이 닫힌 후 처리기가 요청 본문을 읽으려고하면 ErrConnClosed가 Read에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="221637ad516409a2ecb2517d32f79d74a258bc09" translate="yes" xml:space="preserve">
          <source>ErrConnDone is returned by any operation that is performed on a connection that has already been returned to the connection pool.</source>
          <target state="translated">이미 연결 풀로 반환 된 연결에서 수행 된 작업이 ErrConnDone을 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="46bfe6cb80875e0ea2a181d7f7d549f4d0d82aed" translate="yes" xml:space="preserve">
          <source>ErrDecryption represents a failure to decrypt a message. It is deliberately vague to avoid adaptive attacks.</source>
          <target state="translated">ErrDecryption은 메시지를 해독하지 못했음을 나타냅니다. 적응 형 공격을 피하는 것은 의도적으로 모호합니다.</target>
        </trans-unit>
        <trans-unit id="467746adad5f690d7f559fbcf7439e5e4f657411" translate="yes" xml:space="preserve">
          <source>ErrFinalToken is a special sentinel error value. It is intended to be returned by a Split function to indicate that the token being delivered with the error is the last token and scanning should stop after this one. After ErrFinalToken is received by Scan, scanning stops with no error. The value is useful to stop processing early or when it is necessary to deliver a final empty token. One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value.</source>
          <target state="translated">ErrFinalToken은 특수한 센티넬 오류 값입니다. 오류와 함께 전달 된 토큰이 마지막 토큰이며이 토큰 이후에 스캔을 중지해야 함을 나타 내기 위해 Split 함수에 의해 리턴됩니다. Scan이 ErrFinalToken을 수신하면 오류없이 스캔이 중지됩니다. 이 값은 처리를 일찍 중지하거나 최종 빈 토큰을 제공해야 할 때 유용합니다. 사용자 정의 오류 값으로 동일한 동작을 수행 할 수 있지만 여기에 값을 제공하는 것이 더 깔끔합니다. 이 값을 사용하려면 emptyFinalToken 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="35aae77fc96792e0a9dd68b7fe9b4104a92752c1" translate="yes" xml:space="preserve">
          <source>ErrFormat indicates that decoding encountered an unknown format.</source>
          <target state="translated">ErrFormat은 디코딩에 알 수없는 형식이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6a8939df51dea8dd69540b21d1442b1df7f644f5" translate="yes" xml:space="preserve">
          <source>ErrHandlerTimeout is returned on ResponseWriter Write calls in handlers which have timed out.</source>
          <target state="translated">시간이 초과 된 핸들러의 ResponseWriter Write 호출에서 ErrHandlerTimeout이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1683829261143c7257662e5011cf7aaa6a67fd8d" translate="yes" xml:space="preserve">
          <source>ErrHelp is the error returned if the -help or -h flag is invoked but no such flag is defined.</source>
          <target state="translated">ErrHelp는 -help 또는 -h 플래그가 호출되었지만 이러한 플래그가 정의되지 않은 경우 리턴되는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="477f520a57de43c26991dd9257c5ef86e299cbab" translate="yes" xml:space="preserve">
          <source>ErrInvalidMediaParameter is returned by ParseMediaType if the media type value was found but there was an error parsing the optional parameters</source>
          <target state="translated">매체 유형 값을 찾았지만 선택적 매개 변수를 구문 분석하는 중에 오류가 발생하면 ParseMediaType이 ErrInvalidMediaParameter를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7ccacb88c4d1c0e333f4ecd81bc1d3d9c559f2b7" translate="yes" xml:space="preserve">
          <source>ErrInvalidPublicKey results when a public key is not usable by this code. FIPS is quite strict about the format of DSA keys, but other code may be less so. Thus, when using keys which may have been generated by other code, this error must be handled.</source>
          <target state="translated">이 코드에서 공개 키를 사용할 수없는 경우 ErrInvalidPublicKey가 발생합니다. FIPS는 DSA 키 형식에 대해 매우 엄격하지만 다른 코드는 그렇지 않을 수 있습니다. 따라서 다른 코드에서 생성 된 키를 사용할 때이 오류를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="d88a127fa27de6b24dcaf66add63be95ef25d2bc" translate="yes" xml:space="preserve">
          <source>ErrLength reports an attempt to decode an odd-length input using Decode or DecodeString. The stream-based Decoder returns io.ErrUnexpectedEOF instead of ErrLength.</source>
          <target state="translated">ErrLength는 Decode 또는 DecodeString을 사용하여 홀수 길이의 입력을 디코딩하려는 시도를보고합니다. 스트림 기반 디코더는 ErrLength 대신 io.ErrUnexpectedEOF를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3c0b0fa96d60cc99b6dbc86bf7d89c3ad78d6c6" translate="yes" xml:space="preserve">
          <source>ErrLineTooLong is returned when reading malformed chunked data with lines that are too long.</source>
          <target state="translated">너무 긴 행이있는 잘못된 형식의 청크 데이터를 읽을 때 ErrLineTooLong이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dcde473ed62f7785c3bf6c7d17ee1b065b625a36" translate="yes" xml:space="preserve">
          <source>ErrLineTooLong is returned when reading request or response bodies with malformed chunked encoding.</source>
          <target state="translated">잘못된 형식의 청크 인코딩으로 요청 또는 응답 본문을 읽을 때 ErrLineTooLong이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="970c2996a4a5c886310565be53697c5b45faa359" translate="yes" xml:space="preserve">
          <source>ErrMessageTooLarge is returned by ReadForm if the message form data is too large to be processed.</source>
          <target state="translated">메시지 양식 데이터가 너무 커서 처리 할 수없는 경우 ErrMessageTooLarge가 ReadForm에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0ebd73e79cdedfe1cacf57c19778bb47d85fc59f" translate="yes" xml:space="preserve">
          <source>ErrMessageTooLong is returned when attempting to encrypt a message which is too large for the size of the public key.</source>
          <target state="translated">공개 키 크기에 비해 너무 큰 메시지를 암호화하려고하면 ErrMessageTooLong이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5f19c673f1a254310103a3c25dcfcd25e3b0451a" translate="yes" xml:space="preserve">
          <source>ErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field.</source>
          <target state="translated">제공된 파일 필드 이름이 요청에 없거나 파일 필드가 아닌 경우 FormFile이 ErrMissingFile을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="879d59d2bd412781a3e7f8ffb1ed3e0a6f25ef0a" translate="yes" xml:space="preserve">
          <source>ErrNoCookie is returned by Request's Cookie method when a cookie is not found.</source>
          <target state="translated">쿠키를 찾을 수 없으면 ErrNoCookie가 요청의 쿠키 메소드에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="69a1cf815e40b87d0d5f8fcbbe42eafeab4e1e2f" translate="yes" xml:space="preserve">
          <source>ErrNoLocation is returned by Response's Location method when no Location header is present.</source>
          <target state="translated">Location 헤더가 없으면 Response의 Location 메서드에서 ErrNoLocation을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6beea860c8a1449ccac135d4acb1d55a17d0f093" translate="yes" xml:space="preserve">
          <source>ErrNoProgress is returned by some clients of an io.Reader when many calls to Read have failed to return any data or error, usually the sign of a broken io.Reader implementation.</source>
          <target state="translated">읽기에 대한 많은 호출이 데이터 또는 오류를 리턴하지 못한 경우 (일반적으로 손상된 io.Reader 구현의 표시) ErrNoProgress는 io.Reader의 일부 클라이언트에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="392e43865d190f068ab972465b9d359af1b64f08" translate="yes" xml:space="preserve">
          <source>ErrNoRows is returned by Scan when QueryRow doesn't return a row. In such a case, QueryRow returns a placeholder *Row value that defers this error until a Scan.</source>
          <target state="translated">QueryRow가 행을 반환하지 않으면 Scan이 ErrNoRows를 반환합니다. 이러한 경우, QueryRow는 Scan까지이 오류를 지연시키는 자리 표시 자 * Row 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="488229e1ec35b45cf4ccfde5a62d823f94c24690" translate="yes" xml:space="preserve">
          <source>ErrNoSymbols is returned by File.Symbols and File.DynamicSymbols if there is no such section in the File.</source>
          <target state="translated">File에 해당 섹션이없는 경우 ErrNoSymbols는 File.Symbols 및 File.DynamicSymbols에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7533ee8d0b68fb55e112826d6a1c2915f2123d1c" translate="yes" xml:space="preserve">
          <source>ErrNotFat is returned from NewFatFile or OpenFat when the file is not a universal binary but may be a thin binary, based on its magic number.</source>
          <target state="translated">ErrNotFat는 파일이 범용 이진은 아니지만 매직 번호에 따라 얇은 이진일 수있는 경우 NewFatFile 또는 OpenFat에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aa8869522b92bbf57b0f1c062434e0c2d23cc0b5" translate="yes" xml:space="preserve">
          <source>ErrNotFound is the error resulting if a path search failed to find an executable file.</source>
          <target state="translated">ErrNotFound는 경로 검색이 실행 파일을 찾지 못한 경우 발생하는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="f6a111d069dccbba2d2a3a237c054d532919f96c" translate="yes" xml:space="preserve">
          <source>ErrRange indicates that a value is out of range for the target type.</source>
          <target state="translated">ErrRange는 값이 대상 유형의 범위를 벗어 났음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="12fcce22c0e1998899b62846f27fda0ba160dd35" translate="yes" xml:space="preserve">
          <source>ErrRemoveArgument may be returned from NamedValueChecker to instruct the sql package to not pass the argument to the driver query interface. Return when accepting query specific options or structures that aren't SQL query arguments.</source>
          <target state="translated">SQL 패키지가 인수를 드라이버 쿼리 인터페이스에 전달하지 않도록 지시하기 위해 NamedValueChecker에서 ErrRemoveArgument가 리턴 될 수 있습니다. SQL 쿼리 인수가 아닌 쿼리 특정 옵션 또는 구조를 수락하면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="037e83f30e9892945c577cf7fa14541b33afb5a6" translate="yes" xml:space="preserve">
          <source>ErrRequestAborted is returned by Read when a handler attempts to read the body of a request that has been aborted by the web server.</source>
          <target state="translated">핸들러가 웹 서버에 의해 중단 된 요청의 본문을 읽으려고하면 ErrRequestAborted가 Read에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c70ae4f2182147bf876f436b7f75c0552f6c6b60" translate="yes" xml:space="preserve">
          <source>ErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe, and ListenAndServeTLS methods after a call to Shutdown or Close.</source>
          <target state="translated">ErrServerClosed는 시스템 종료 또는 닫기 호출 후 서버의 Serve, ServeTLS, ListenAndServe 및 ListenAndServeTLS 메소드에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7ebe2c84541d847b1195492aec2d9b2f7a4c010e" translate="yes" xml:space="preserve">
          <source>ErrShortBuffer means that a read required a longer buffer than was provided.</source>
          <target state="translated">ErrShortBuffer는 읽기에 제공된 것보다 긴 버퍼가 필요함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="982fdbcbb882e9752207ac23622fa80a8e4ff13c" translate="yes" xml:space="preserve">
          <source>ErrShortWrite means that a write accepted fewer bytes than requested but failed to return an explicit error.</source>
          <target state="translated">ErrShortWrite는 쓰기가 요청 된 것보다 적은 바이트를 허용했지만 명시적인 오류를 반환하지 못했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e693fa44dc23f2e964c4c957cddff0c6c414e4de" translate="yes" xml:space="preserve">
          <source>ErrSkip may be returned by some optional interfaces' methods to indicate at runtime that the fast path is unavailable and the sql package should continue as if the optional interface was not implemented. ErrSkip is only supported where explicitly documented.</source>
          <target state="translated">ErrSkip는 일부 선택적 인터페이스의 메소드에 의해 리턴되어 빠른 경로를 사용할 수없고 SQL 패키지가 선택적 인터페이스가 구현되지 않은 것처럼 계속해야 함을 표시합니다. ErrSkip은 명시 적으로 문서화 된 경우에만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="da9be2949ec46b11aafe4f6565a64184a6259c6a" translate="yes" xml:space="preserve">
          <source>ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.</source>
          <target state="translated">ErrSkipAltProtocol은 Transport.RegisterProtocol에 의해 정의 된 센티넬 오류 값입니다.</target>
        </trans-unit>
        <trans-unit id="0984c259498693b4323da793215e73f865780771" translate="yes" xml:space="preserve">
          <source>ErrSyntax indicates that a value does not have the right syntax for the target type.</source>
          <target state="translated">ErrSyntax는 값에 대상 유형에 대한 올바른 구문이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="72e2bf17148743cd6ab904b3de93ecbe65b459aa" translate="yes" xml:space="preserve">
          <source>ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.</source>
          <target state="translated">버퍼에 데이터를 저장하기 위해 메모리를 할당 할 수없는 경우 ErrTooLarge가 패닉으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="568c0d2bb32eccd175defcb03344b9a16c508bab" translate="yes" xml:space="preserve">
          <source>ErrTxDone is returned by any operation that is performed on a transaction that has already been committed or rolled back.</source>
          <target state="translated">ErrTxDone은 이미 커밋되거나 롤백 된 트랜잭션에서 수행 된 작업에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1f229a1dfc7838f7986b848144af2ffc585c4245" translate="yes" xml:space="preserve">
          <source>ErrUnexpectedEOF means that EOF was encountered in the middle of reading a fixed-size block or data structure.</source>
          <target state="translated">ErrUnexpectedEOF는 고정 크기 블록 또는 데이터 구조를 읽는 도중 EOF가 발생했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bfe4f94706eef4c62e93268b91a8df4ee481c805" translate="yes" xml:space="preserve">
          <source>ErrUnknownPC is the error returned by LineReader.ScanPC when the seek PC is not covered by any entry in the line table.</source>
          <target state="translated">ErrUnknownPC는 찾기 PC가 행 테이블의 항목으로 처리되지 않을 때 LineReader.ScanPC에 의해 리턴되는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="f3ccd127227d246ff29c38b3be735853002e0e90" translate="yes" xml:space="preserve">
          <source>ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented.</source>
          <target state="translated">ErrUnsupportedAlgorithm은 현재 구현되지 않은 알고리즘과 관련된 작업을 수행하려고 시도한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="7cda7d2974e4a55a6e31e7b06730353820c8cd09" translate="yes" xml:space="preserve">
          <source>ErrUseLastResponse can be returned by Client.CheckRedirect hooks to control how redirects are processed. If returned, the next request is not sent and the most recent response is returned with its body unclosed.</source>
          <target state="translated">ErrUseLastResponse는 Client.CheckRedirect 후크에 의해 반환되어 리디렉션 처리 방법을 제어 할 수 있습니다. 반환 된 경우 다음 요청이 전송되지 않고 본문이 닫히지 않은 상태에서 가장 최근의 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="71263e34d33b79a9329c92364062be99c3eee17e" translate="yes" xml:space="preserve">
          <source>ErrVerification represents a failure to verify a signature. It is deliberately vague to avoid adaptive attacks.</source>
          <target state="translated">ErrVerification은 서명을 확인하지 못했음을 나타냅니다. 적응 형 공격을 피하는 것은 의도적으로 모호합니다.</target>
        </trans-unit>
        <trans-unit id="ad8d01914ee372bf834727e843061ee1afe40a5a" translate="yes" xml:space="preserve">
          <source>Error describes a problem encountered during template Escaping.</source>
          <target state="translated">템플릿 탈출 중에 발생한 문제를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1e74398cca4fe010a9f1160a55d2897886f3d1e9" translate="yes" xml:space="preserve">
          <source>Error implements the error interface.</source>
          <target state="translated">오류는 오류 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="90eef0a8fff1769f0f058ec32118067d335eaa54" translate="yes" xml:space="preserve">
          <source>Error is equivalent to Log followed by Fail.</source>
          <target state="translated">오류는 로그 다음에 실패와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7f32ee8831e87a9144a1603a0333481dce77381" translate="yes" xml:space="preserve">
          <source>Error is returned by LookPath when it fails to classify a file as an executable.</source>
          <target state="translated">파일을 실행 파일로 분류하지 못하면 LookPath에서 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db662ec10d72905a869274d663c6b1180e4b7f54" translate="yes" xml:space="preserve">
          <source>Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text.</source>
          <target state="translated">오류는 지정된 오류 메시지와 HTTP 코드를 사용하여 요청에 응답합니다. 그렇지 않으면 요청을 종료하지 않습니다. 호출자는 w에 대한 추가 쓰기가 수행되지 않도록해야합니다. 오류 메시지는 일반 텍스트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a20fb2871b74c1de6e727401f6fd828785f1c240" translate="yes" xml:space="preserve">
          <source>Error reports an error and the operation and URL that caused it.</source>
          <target state="translated">오류는 오류와 그 원인이 된 작업 및 URL을보고합니다.</target>
        </trans-unit>
        <trans-unit id="830c2e692ebb0efc91ade52379d7380987d0d567" translate="yes" xml:space="preserve">
          <source>Error reports any error that has occurred during a previous Write or Flush.</source>
          <target state="translated">오류는 이전 쓰기 또는 플러시 중에 발생한 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="dde0e5cd72639f435d3e7e7fe156ee2ed9879da4" translate="yes" xml:space="preserve">
          <source>Error returns an error string formatted as follows: filename:line:column: message</source>
          <target state="translated">Error는 다음과 같은 형식의 오류 문자열을 반환합니다. filename : line : column : message</target>
        </trans-unit>
        <trans-unit id="3cfee321593df904c4289a896a7927d4777c6a34" translate="yes" xml:space="preserve">
          <source>Error returns the string representation of a ParseError.</source>
          <target state="translated">Error는 ParseError의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4df304fede26c34b36b8acbaaecd004589ae2b8" translate="yes" xml:space="preserve">
          <source>Error wraps a JavaScript error.</source>
          <target state="translated">오류는 JavaScript 오류를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="c17edc5bbb79fd1e93107557c864f6c73e9e1224" translate="yes" xml:space="preserve">
          <source>Error, which represents a numeric error response from a server.</source>
          <target state="translated">서버의 숫자 오류 응답을 나타내는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="f872a6e0e103dae88045f618b47fc615ea682e89" translate="yes" xml:space="preserve">
          <source>ErrorCode is a code for a kind of error.</source>
          <target state="translated">ErrorCode는 일종의 오류에 대한 코드입니다.</target>
        </trans-unit>
        <trans-unit id="3bfa44b797d3ade2b7a4edbc0e05cd336b90f6a5" translate="yes" xml:space="preserve">
          <source>ErrorContext returns a textual representation of the location of the node in the input text. The receiver is only used when the node does not have a pointer to the tree inside, which can occur in old code.</source>
          <target state="translated">ErrorContext는 입력 텍스트에서 노드 위치의 텍스트 표현을 반환합니다. 수신자는 노드에 트리에 대한 포인터가없는 경우에만 사용되며, 이는 이전 코드에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01a6e986d714bdcbd3255e42cd49913ead495f07" translate="yes" xml:space="preserve">
          <source>ErrorHandling defines how FlagSet.Parse behaves if the parse fails.</source>
          <target state="translated">ErrorHandling은 구문 분석이 실패 할 경우 FlagSet.Parse의 동작 방식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c0a58bb2b918c9b5569f8008794279639061de21" translate="yes" xml:space="preserve">
          <source>ErrorHandling returns the error handling behavior of the flag set.</source>
          <target state="translated">ErrorHandling은 플래그 세트의 오류 처리 동작을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4c21e41d45c9255229a7163ff53874920a784296" translate="yes" xml:space="preserve">
          <source>ErrorList implements the sort Interface.</source>
          <target state="translated">ErrorList는 정렬 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bf56558c66e9c3ca353563d687f7c3cd65731f27" translate="yes" xml:space="preserve">
          <source>ErrorList is a list of *Errors. The zero value for an ErrorList is an empty ErrorList ready to use.</source>
          <target state="translated">ErrorList는 * 오류 목록입니다. ErrorList의 0 값은 사용 가능한 빈 ErrorList입니다.</target>
        </trans-unit>
        <trans-unit id="ce0231916da28ea14cfedf1872fc204b2ae63815" translate="yes" xml:space="preserve">
          <source>Errorf</source>
          <target state="translated">Errorf</target>
        </trans-unit>
        <trans-unit id="fdd0d6f0778f1bf5d95080356d64d20bdae12d81" translate="yes" xml:space="preserve">
          <source>Errorf formats according to a format specifier and returns the string as a value that satisfies error.</source>
          <target state="translated">Errorf는 형식 지정자에 따라 형식을 지정하고 문자열을 오류를 만족시키는 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7da546253e843f1211156126fe7b9153417337c" translate="yes" xml:space="preserve">
          <source>Errorf is equivalent to Logf followed by Fail.</source>
          <target state="translated">Errorf는 Logf 다음에 Fail과 같습니다.</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="c7b5ebe0a47f4e9da35a4772302352a81e9e531f" translate="yes" xml:space="preserve">
          <source>Errors returned by Scanner.</source>
          <target state="translated">스캐너가 오류를 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="bc4101c3209c725e09b7f9a752ff1e460a3f708b" translate="yes" xml:space="preserve">
          <source>Errors returned from this package may be tested against these errors with errors.Is.</source>
          <target state="translated">이 패키지에서 반환 된 오류는 오류와 함께 이러한 오류에 대해 테스트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a52e06ca8bcf58f3e4f4015d46888503fa4edb2" translate="yes" xml:space="preserve">
          <source>Errors used by the HTTP server.</source>
          <target state="translated">HTTP 서버가 사용하는 오류.</target>
        </trans-unit>
        <trans-unit id="b113dd3f232b8b88d2860ca5e8f37a70242825e5" translate="yes" xml:space="preserve">
          <source>Escape is like EscapeText but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use EscapeText.</source>
          <target state="translated">이스케이프는 EscapeText와 비슷하지만 오류 반환 값을 생략합니다. Go 1.0과의 호환성을 위해 제공됩니다. Go 1.1 이상의 코드 타겟팅에서는 EscapeText를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="72b96ac1177bd0ab8e6a9ffb4c48e44560500452" translate="yes" xml:space="preserve">
          <source>Escape sequences:</source>
          <target state="translated">이스케이프 시퀀스 :</target>
        </trans-unit>
        <trans-unit id="7232262c5c0c1b2288a34e3da1ce712bfb760b49" translate="yes" xml:space="preserve">
          <source>EscapeString</source>
          <target state="translated">EscapeString</target>
        </trans-unit>
        <trans-unit id="3a32d6d4d267bdae71baa4ebb4864da534840bc0" translate="yes" xml:space="preserve">
          <source>EscapeString escapes special characters like &quot;&amp;lt;&quot; to become &quot;&amp;amp;lt;&quot;. It escapes only five such characters: &amp;lt;, &amp;gt;, &amp;amp;, ' and &quot;. UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.</source>
          <target state="translated">EscapeString은 &quot;&amp;lt;&quot;와 같은 특수 문자를 이스케이프하여 &quot;&amp;amp; lt;&quot;가됩니다. &amp;lt;,&amp;gt;, &amp;amp;, '및 &quot;와 같은 5 개 문자 만 이스케이프합니다. UnescapeString (EscapeString (s)) ==는 항상 유지되지만 대화가 항상 참인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2d03f838319f2b58cce7d4023faf3595f32ebc4a" translate="yes" xml:space="preserve">
          <source>EscapeText writes to w the properly escaped XML equivalent of the plain text data s.</source>
          <target state="translated">EscapeText는 일반 텍스트 데이터와 동등한 이스케이프 된 XML을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d16488cf3f3e8d2bcd7180af8373e57e18ef4565" translate="yes" xml:space="preserve">
          <source>EscapedPath returns the escaped form of u.Path. In general there are multiple possible escaped forms of any path. EscapedPath returns u.RawPath when it is a valid escaping of u.Path. Otherwise EscapedPath ignores u.RawPath and computes an escaped form on its own. The String and RequestURI methods use EscapedPath to construct their results. In general, code should call EscapedPath instead of reading u.RawPath directly.</source>
          <target state="translated">EscapedPath는 이스케이프 된 u.Path 형식을 반환합니다. 일반적으로 여러 가지 이스케이프 된 형식의 경로가 있습니다. EscapedPath는 u.Path를 이스케이프하면 u.RawPath를 반환합니다. 그렇지 않으면 EscapedPath는 u.RawPath를 무시하고 이스케이프 된 양식을 자체적으로 계산합니다. String 및 RequestURI 메소드는 EscapedPath를 사용하여 결과를 구성합니다. 일반적으로 코드는 u.RawPath를 직접 읽는 대신 EscapedPath를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6f139cba9287a2764afe8ce53317ff229147fba" translate="yes" xml:space="preserve">
          <source>Eval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set.</source>
          <target state="translated">Eval은 패키지 pkg의 위치 pos에서 평가 된 표현식 expr의 유형과 상수 인 경우 제공된 파일 세트에 대한 완전한 위치 정보로 AST의 유형 검사에서 파생 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87826c86d178d2561f85e648340af0f4ea8c5e2c" translate="yes" xml:space="preserve">
          <source>EvalSymlinks returns the path name after the evaluation of any symbolic links. If path is relative the result will be relative to the current directory, unless one of the components is an absolute symbolic link. EvalSymlinks calls Clean on the result.</source>
          <target state="translated">EvalSymlinks는 심볼릭 링크를 평가 한 후 경로 이름을 반환합니다. path가 상대적이면 구성 요소 중 하나가 절대 기호 링크가 아닌 한 결과는 현재 디렉토리를 기준으로합니다. EvalSymlinks는 결과에서 Clean을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e74e7ce3c8abf4b80ec56864d1aae4c5480b2b01" translate="yes" xml:space="preserve">
          <source>Even if ReadAt returns n &amp;lt; len(p), it may use all of p as scratch space during the call. If some data is available but not len(p) bytes, ReadAt blocks until either all the data is available or an error occurs. In this respect ReadAt is different from Read.</source>
          <target state="translated">ReadAt가 n &amp;lt;len (p)를 반환하더라도 호출 중에 모든 p를 스크래치 공간으로 사용할 수 있습니다. 일부 데이터는 사용 가능하지만 len (p) 바이트는 사용할 수없는 경우 ReadAt는 모든 데이터가 사용 가능하거나 오류가 발생할 때까지 차단합니다. 이와 관련하여 ReadAt는 Read와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="53a0efcd9116915108429249f6aa89cdbb04bf0f" translate="yes" xml:space="preserve">
          <source>Even when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS.</source>
          <target state="translated">활성화 된 경우에도 서버는 핸드 셰이크간에 ID를 변경하지 않을 수 있습니다 (예 : 리프 인증서가 동일해야 함). 또한 동시 핸드 셰이크 및 응용 프로그램 데이터 흐름이 허용되지 않으므로 재협상은 재협상과 동기화 된 프로토콜 (예 : HTTPS)에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d5018b93eece7f2c1a96b6ceca3400cc6e309bc" translate="yes" xml:space="preserve">
          <source>Every Conn must be returned to the database pool after use by calling Conn.Close.</source>
          <target state="translated">사용 후 Conn.Close를 호출하여 모든 Conn을 데이터베이스 풀로 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c28d71b80a20b83e9ae50e1509e418c92187dbf4" translate="yes" xml:space="preserve">
          <source>Every call to Scan, even the first one, must be preceded by a call to Next.</source>
          <target state="translated">스캔에 대한 모든 호출, 심지어 첫 번째 호출에도 다음에 대한 호출이 선행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="f5af771da8b361a4e20bdb4283e0ac7caf8c0814" translate="yes" xml:space="preserve">
          <source>Example (AllSignals)</source>
          <target state="translated">예 (모든 신호)</target>
        </trans-unit>
        <trans-unit id="6806ae76e866d9ef5bbaa313ab8f14edf232f6fa" translate="yes" xml:space="preserve">
          <source>Example (Append)</source>
          <target state="translated">예 (첨부)</target>
        </trans-unit>
        <trans-unit id="2e52ba657e1b1589c7457e9586b538cbfb8d8c4e" translate="yes" xml:space="preserve">
          <source>Example (Autoescaping)</source>
          <target state="translated">예 (자동 이스케이프)</target>
        </trans-unit>
        <trans-unit id="7bda2f591e5fdf06e6bb949dbf8645e95567d697" translate="yes" xml:space="preserve">
          <source>Example (Basic)</source>
          <target state="translated">예 (기본)</target>
        </trans-unit>
        <trans-unit id="18996c4947f797f81043a2613612654fc43160d3" translate="yes" xml:space="preserve">
          <source>Example (BinaryMarshaler)</source>
          <target state="translated">예 (BinaryMarshaler)</target>
        </trans-unit>
        <trans-unit id="b4b588f9f28576812b88bb06ca68e301889fa949" translate="yes" xml:space="preserve">
          <source>Example (Block)</source>
          <target state="translated">예 (블록)</target>
        </trans-unit>
        <trans-unit id="486a8544d68d11f1bed88d4bb0fdc87e371d41c9" translate="yes" xml:space="preserve">
          <source>Example (ComplexNumbers)</source>
          <target state="translated">예 (복합 수)</target>
        </trans-unit>
        <trans-unit id="433e8e80995b40ab0d35f03a174da56c17e5e244" translate="yes" xml:space="preserve">
          <source>Example (Config)</source>
          <target state="translated">예 (구성)</target>
        </trans-unit>
        <trans-unit id="d37ffa9f063e6d5deddd48321eb1adc9ceaf4696" translate="yes" xml:space="preserve">
          <source>Example (Custom)</source>
          <target state="translated">예 (사용자 정의)</target>
        </trans-unit>
        <trans-unit id="7dd768f1c2d0eb858e6c8e62318f88b0d2a37a94" translate="yes" xml:space="preserve">
          <source>Example (CustomMarshalJSON)</source>
          <target state="translated">예 (CustomMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="ecd803477953d919a56abf6a7054c61d8b4903e9" translate="yes" xml:space="preserve">
          <source>Example (CustomMarshalXML)</source>
          <target state="translated">예 (CustomMarshalXML)</target>
        </trans-unit>
        <trans-unit id="eb7e7661a541a8aedff29b426a0dd8cee77d6d26" translate="yes" xml:space="preserve">
          <source>Example (DecodeConfig)</source>
          <target state="translated">예 (DecodeConfig)</target>
        </trans-unit>
        <trans-unit id="5285988ca0c88d03cdaaaa1c0ed6f2b7317d2b93" translate="yes" xml:space="preserve">
          <source>Example (Decrypt)</source>
          <target state="translated">예 (암호 해독)</target>
        </trans-unit>
        <trans-unit id="8fab16bc38953ce26f6b67557a190e125af0e87e" translate="yes" xml:space="preserve">
          <source>Example (DescendingOrder)</source>
          <target state="translated">예 (내림차순)</target>
        </trans-unit>
        <trans-unit id="6aecf1f00d18e968d03c6704bef266c1e4be5098" translate="yes" xml:space="preserve">
          <source>Example (Dictionary)</source>
          <target state="translated">예 (사전)</target>
        </trans-unit>
        <trans-unit id="fae255c02ba68cd1a00c21d5947bde15712ef6e0" translate="yes" xml:space="preserve">
          <source>Example (DotFileHiding)</source>
          <target state="translated">예 (DotFileHiding)</target>
        </trans-unit>
        <trans-unit id="2e9d6fa89cbf924c21d5a93c189431a8cd1dde68" translate="yes" xml:space="preserve">
          <source>Example (EConvergents)</source>
          <target state="translated">예 (EConvergents)</target>
        </trans-unit>
        <trans-unit id="c4faca1b381d29b5f4b6ce88f79758aa6cf95bb8" translate="yes" xml:space="preserve">
          <source>Example (Elastic)</source>
          <target state="translated">예 (탄성)</target>
        </trans-unit>
        <trans-unit id="2232d3397afd70f4f6faa419a87bb103725a6b36" translate="yes" xml:space="preserve">
          <source>Example (EmptyFinalToken)</source>
          <target state="translated">예 (EmptyFinalToken)</target>
        </trans-unit>
        <trans-unit id="51b210ff3c89e11d54a69e7bd9044e45171fa6c7" translate="yes" xml:space="preserve">
          <source>Example (EncodeDecode)</source>
          <target state="translated">예 (EncodeDecode)</target>
        </trans-unit>
        <trans-unit id="10f49227bc5c8828198ffe23c70506a5f6a14a6c" translate="yes" xml:space="preserve">
          <source>Example (Encrypt)</source>
          <target state="translated">예 (암호화)</target>
        </trans-unit>
        <trans-unit id="b1b7ef7af49d199e71d1b9a202304c0e1dd03579" translate="yes" xml:space="preserve">
          <source>Example (Environment)</source>
          <target state="translated">예 (환경)</target>
        </trans-unit>
        <trans-unit id="76e13d7110768fb2adda2eab178cd24782e70e9f" translate="yes" xml:space="preserve">
          <source>Example (Errorf)</source>
          <target state="translated">예 (오류)</target>
        </trans-unit>
        <trans-unit id="dda6c202ca36dceb2b8b1d371c82caea78806bb1" translate="yes" xml:space="preserve">
          <source>Example (Escape)</source>
          <target state="translated">예 (탈출)</target>
        </trans-unit>
        <trans-unit id="d5078acaa6d91c20f1a5940604b3be21cb88297f" translate="yes" xml:space="preserve">
          <source>Example (Fibonacci)</source>
          <target state="translated">예 (피보나치)</target>
        </trans-unit>
        <trans-unit id="82dc50226403d5da3e74bc047330883ad45a5d00" translate="yes" xml:space="preserve">
          <source>Example (File)</source>
          <target state="translated">예 (파일)</target>
        </trans-unit>
        <trans-unit id="f3933078451957ce04020c47152b2a4ae30e2df1" translate="yes" xml:space="preserve">
          <source>Example (FloydSteinberg)</source>
          <target state="translated">예 (FloydSteinberg)</target>
        </trans-unit>
        <trans-unit id="81d329cbb08482151d8388b6f96dc57574cc5a00" translate="yes" xml:space="preserve">
          <source>Example (Formats)</source>
          <target state="translated">예 (형식)</target>
        </trans-unit>
        <trans-unit id="48e4af16c19b828060331cd71f3957538f43c01d" translate="yes" xml:space="preserve">
          <source>Example (Func)</source>
          <target state="translated">예 (Func)</target>
        </trans-unit>
        <trans-unit id="e1803da930d85a7a40a33aabbb44bda9fd29a3f1" translate="yes" xml:space="preserve">
          <source>Example (Get)</source>
          <target state="translated">예 (가져 오기)</target>
        </trans-unit>
        <trans-unit id="efa53360ab365a081c7d8e5c13b9d92b709140dc" translate="yes" xml:space="preserve">
          <source>Example (Glob)</source>
          <target state="translated">예 (글로벌)</target>
        </trans-unit>
        <trans-unit id="a0927fdc649164da429d59c70828557b2f212892" translate="yes" xml:space="preserve">
          <source>Example (Helpers)</source>
          <target state="translated">예 (도움말)</target>
        </trans-unit>
        <trans-unit id="e1cb4393a3dce67d491085d8c93e591a037aa410" translate="yes" xml:space="preserve">
          <source>Example (HttpServer)</source>
          <target state="translated">예 (HttpServer)</target>
        </trans-unit>
        <trans-unit id="bc877cc87aa7e57c6e4d6bac364478fe54fd7edc" translate="yes" xml:space="preserve">
          <source>Example (IntHeap)</source>
          <target state="translated">예 (IntHeap)</target>
        </trans-unit>
        <trans-unit id="15ea46b6e1ae2d0c7afa15e89076c2e1ef33cfa9" translate="yes" xml:space="preserve">
          <source>Example (Interface)</source>
          <target state="translated">예 (인터페이스)</target>
        </trans-unit>
        <trans-unit id="d0d4f4103b1fb18ad85139309cb4da67e48bc81b" translate="yes" xml:space="preserve">
          <source>Example (Is)</source>
          <target state="translated">예 (들)</target>
        </trans-unit>
        <trans-unit id="fafb22a01b61327379ae19ec71339a55898fd95a" translate="yes" xml:space="preserve">
          <source>Example (IsIdentRune)</source>
          <target state="translated">예 (IsIdentRune)</target>
        </trans-unit>
        <trans-unit id="6c67c38b6ae2ba0542052e51c7fa5202c83f63ad" translate="yes" xml:space="preserve">
          <source>Example (KeyLogWriter)</source>
          <target state="translated">예 (KeyLogWriter)</target>
        </trans-unit>
        <trans-unit id="998c85b7ec2d08d9dc6fbaeea75396700152f3e2" translate="yes" xml:space="preserve">
          <source>Example (Lines)</source>
          <target state="translated">예 (줄)</target>
        </trans-unit>
        <trans-unit id="90c6690a74615337a8d95f6ad9e2df85db4dc8aa" translate="yes" xml:space="preserve">
          <source>Example (Marshal)</source>
          <target state="translated">예 (마셜)</target>
        </trans-unit>
        <trans-unit id="b7987a90c2edd7b9efbeddd99750be769396ba11" translate="yes" xml:space="preserve">
          <source>Example (Minimal)</source>
          <target state="translated">예 (최소)</target>
        </trans-unit>
        <trans-unit id="220dbd2f9c761374b94c2985ffb67973ec244f5e" translate="yes" xml:space="preserve">
          <source>Example (Mode)</source>
          <target state="translated">예 (모드)</target>
        </trans-unit>
        <trans-unit id="71eaa954d5eaf1e8a901ae6af51e6ef38075023b" translate="yes" xml:space="preserve">
          <source>Example (Multi)</source>
          <target state="translated">예 (멀티)</target>
        </trans-unit>
        <trans-unit id="29d3242dd03f86b89326a2d3af5d45c9e4b8df60" translate="yes" xml:space="preserve">
          <source>Example (MultipleResultSets)</source>
          <target state="translated">예 (여러 결과 집합)</target>
        </trans-unit>
        <trans-unit id="d67ff39099c16f9727841f2b1d55d6a7d937ca63" translate="yes" xml:space="preserve">
          <source>Example (OpenDBCLI)</source>
          <target state="translated">예 (OpenDBCLI)</target>
        </trans-unit>
        <trans-unit id="6649fceda9c8f47bc7fd24801bfc5e3a67a4b690" translate="yes" xml:space="preserve">
          <source>Example (OpenDBService)</source>
          <target state="translated">예 (OpenDBService)</target>
        </trans-unit>
        <trans-unit id="c804c1a3dde5f5d5992fdc8708de4fc1ac6587eb" translate="yes" xml:space="preserve">
          <source>Example (Options)</source>
          <target state="translated">예 (옵션)</target>
        </trans-unit>
        <trans-unit id="4bcf50c51e83b6b841682aca36a2d5adaab448fa" translate="yes" xml:space="preserve">
          <source>Example (Parsefiles)</source>
          <target state="translated">예 (구문 파일)</target>
        </trans-unit>
        <trans-unit id="f31a14315872f7d5ad4b31b0b814af75bcd37346" translate="yes" xml:space="preserve">
          <source>Example (Printers)</source>
          <target state="translated">예 (프린터)</target>
        </trans-unit>
        <trans-unit id="76286390b82f9465aa1db504336b58a0882e7789" translate="yes" xml:space="preserve">
          <source>Example (PriorityQueue)</source>
          <target state="translated">예 (PriorityQueue)</target>
        </trans-unit>
        <trans-unit id="64c31a2d546e425660696075602e9c55ede932f9" translate="yes" xml:space="preserve">
          <source>Example (Put)</source>
          <target state="translated">예 (Put)</target>
        </trans-unit>
        <trans-unit id="d9b68d9bdb509763e088e0d350491fe1ff9bf03c" translate="yes" xml:space="preserve">
          <source>Example (Rand)</source>
          <target state="translated">예 (토지)</target>
        </trans-unit>
        <trans-unit id="fd2979c4537d222cfc623fbc541e78e448137665" translate="yes" xml:space="preserve">
          <source>Example (ReadMostly)</source>
          <target state="translated">예 (대부분 읽기)</target>
        </trans-unit>
        <trans-unit id="b3e59e19171ce2c63c7a8904bd2f9921fb22a142" translate="yes" xml:space="preserve">
          <source>Example (Reader)</source>
          <target state="translated">예 (리더)</target>
        </trans-unit>
        <trans-unit id="39d966a83ff5b0a8a61283590badb1a431bd7d77" translate="yes" xml:space="preserve">
          <source>Example (Reset)</source>
          <target state="translated">예 (리셋)</target>
        </trans-unit>
        <trans-unit id="f7b91d630287948e0bfeba35eefba5c01f1107af" translate="yes" xml:space="preserve">
          <source>Example (RetrievePositionInfo)</source>
          <target state="translated">예 (RetrievePositionInfo)</target>
        </trans-unit>
        <trans-unit id="6d421c1f51583522754be7b57506ff4663194c40" translate="yes" xml:space="preserve">
          <source>Example (Roundtrip)</source>
          <target state="translated">예 (왕복)</target>
        </trans-unit>
        <trans-unit id="997ee2d41b2c768a3ff8dd1b07a7450ed4680d2e" translate="yes" xml:space="preserve">
          <source>Example (Search)</source>
          <target state="translated">예 (검색)</target>
        </trans-unit>
        <trans-unit id="26c8d95221bd62d1c6dd0e843baad8cbebaa0442" translate="yes" xml:space="preserve">
          <source>Example (Share)</source>
          <target state="translated">예 (공유)</target>
        </trans-unit>
        <trans-unit id="3abb8dfd074ee9afbe60f6cdd246feccb1d11c79" translate="yes" xml:space="preserve">
          <source>Example (Shift)</source>
          <target state="translated">예 (Shift)</target>
        </trans-unit>
        <trans-unit id="f4341e44bdeed6e7db74742550dcb962bdc52498" translate="yes" xml:space="preserve">
          <source>Example (SlicesInUnison)</source>
          <target state="translated">예 (SlicesInUnison)</target>
        </trans-unit>
        <trans-unit id="09b2fe12f7c6e61ddb30325458425fd3d42ba3e7" translate="yes" xml:space="preserve">
          <source>Example (SortKeys)</source>
          <target state="translated">예 (SortKeys)</target>
        </trans-unit>
        <trans-unit id="a161b3dcacaf6f0af657412f43ec2e2697b4a566" translate="yes" xml:space="preserve">
          <source>Example (SortMultiKeys)</source>
          <target state="translated">예 (SortMultiKeys)</target>
        </trans-unit>
        <trans-unit id="c700c72cd356078aa83dc80aa5da8bd42f5ee825" translate="yes" xml:space="preserve">
          <source>Example (SortWrapper)</source>
          <target state="translated">예 (SortWrapper)</target>
        </trans-unit>
        <trans-unit id="a8bfb7061aa11f61ba7f0066df210a3c29777f98" translate="yes" xml:space="preserve">
          <source>Example (Sqrt2)</source>
          <target state="translated">예 (Sqrt2)</target>
        </trans-unit>
        <trans-unit id="ebe403bbbdd2c63efdc5a9bb1601bc9f45a978c6" translate="yes" xml:space="preserve">
          <source>Example (Stream)</source>
          <target state="translated">예 (스트림)</target>
        </trans-unit>
        <trans-unit id="abbe3138d0178ab55ff211013783fb8af592cb7d" translate="yes" xml:space="preserve">
          <source>Example (StripPrefix)</source>
          <target state="translated">예 (StripPrefix)</target>
        </trans-unit>
        <trans-unit id="6c16b94480edd0345910083abc5a6c549ce236af" translate="yes" xml:space="preserve">
          <source>Example (Suffix)</source>
          <target state="translated">예 (접미사)</target>
        </trans-unit>
        <trans-unit id="d15caef05f8ff9c74dc0547060823c024dc99f58" translate="yes" xml:space="preserve">
          <source>Example (Synchronization)</source>
          <target state="translated">예 (동기화)</target>
        </trans-unit>
        <trans-unit id="a62f50ab20b1bf896520eb1f4cc5a1db4ed324b5" translate="yes" xml:space="preserve">
          <source>Example (TextMarshalJSON)</source>
          <target state="translated">예 (TextMarshalJSON)</target>
        </trans-unit>
        <trans-unit id="fbd08593ac14b413e0da05c752b1367b5127acc2" translate="yes" xml:space="preserve">
          <source>Example (TextMarshalXML)</source>
          <target state="translated">예 (TextMarshalXML)</target>
        </trans-unit>
        <trans-unit id="8e5dd403c2a724dfe512bb193bca762b97020dce" translate="yes" xml:space="preserve">
          <source>Example (Trailers)</source>
          <target state="translated">예 (예고편)</target>
        </trans-unit>
        <trans-unit id="748d838b8683a8f8d192b01d4d7d3a81f783d636" translate="yes" xml:space="preserve">
          <source>Example (TrailingTab)</source>
          <target state="translated">예 (TrailingTab)</target>
        </trans-unit>
        <trans-unit id="c00eeea2ab162f08ebf0ba7ecdde22954780f472" translate="yes" xml:space="preserve">
          <source>Example (Unmarshal)</source>
          <target state="translated">예 (비 정렬)</target>
        </trans-unit>
        <trans-unit id="4abde4525b91ff7ce0bef5c781d4706ee97ee0b8" translate="yes" xml:space="preserve">
          <source>Example (Whitespace)</source>
          <target state="translated">예 (공백)</target>
        </trans-unit>
        <trans-unit id="bbda3fcec0c984c4deccac6441b82d6551be8728" translate="yes" xml:space="preserve">
          <source>Example (Words)</source>
          <target state="translated">예 (워드)</target>
        </trans-unit>
        <trans-unit id="d5cf5e438485427250b065bf74fba906e865dd71" translate="yes" xml:space="preserve">
          <source>Example (WriterReader)</source>
          <target state="translated">예 (WriterReader)</target>
        </trans-unit>
        <trans-unit id="d30cd049e881e721a3e90310e35fd42bd393ca0d" translate="yes" xml:space="preserve">
          <source>Example demonstrates the use of the trace package to trace the execution of a Go program. The trace output will be written to the file trace.out</source>
          <target state="translated">예는 추적 프로그램을 사용하여 Go 프로그램 실행을 추적하는 방법을 보여줍니다. 추적 출력은 파일 trace.out에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f2573490205ec3fa3c52174ceabc13d098ee040e" translate="yes" xml:space="preserve">
          <source>Example functions without output comments are compiled but not executed.</source>
          <target state="translated">출력 주석이없는 예제 함수는 컴파일되지만 실행되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="23f9d603e16f8ef16b61cb7dd71733745d6dc774" translate="yes" xml:space="preserve">
          <source>Example use:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="f4f8f48cf4d5e9a2b5fdf509e391d114af54249a" translate="yes" xml:space="preserve">
          <source>ExampleExp computes Euler's identity.</source>
          <target state="translated">ExampleExp는 오일러의 아이덴티티를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e6ef84e4017d4e3a3b6e6f5fb063732f932d208e" translate="yes" xml:space="preserve">
          <source>ExampleInfo prints various facts recorded by the type checker in a types.Info struct: definitions of and references to each named object, and the type, value, and mode of every expression in the package.</source>
          <target state="translated">ExampleInfo는 형식 검사기에 의해 기록 된 다양한 팩트를 형식으로 인쇄합니다 .Info 구조체 : 각 명명 된 개체의 정의 및 참조, 패키지에있는 모든 식의 형식, 값 및 모드.</target>
        </trans-unit>
        <trans-unit id="cb4bbe727d61b7f53c2e2ee56f081e85812a2931" translate="yes" xml:space="preserve">
          <source>ExampleMethodSet prints the method sets of various types.</source>
          <target state="translated">ExampleMethodSet은 다양한 유형의 메소드 세트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="46027e906ab7b86a83cef5107b917049326109ed" translate="yes" xml:space="preserve">
          <source>ExampleMultiKeys demonstrates a technique for sorting a struct type using different sets of multiple fields in the comparison. We chain together &quot;Less&quot; functions, each of which compares a single field.</source>
          <target state="translated">ExampleMultiKeys는 비교에서 서로 다른 여러 필드 집합을 사용하여 구조체 유형을 정렬하는 기술을 보여줍니다. &quot;Less&quot;기능을 하나로 묶습니다. 각 기능은 단일 필드를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="193e8ade5e79f30df0f3c6123d817327cd4b8cce" translate="yes" xml:space="preserve">
          <source>ExampleScope prints the tree of Scopes of a package created from a set of parsed files.</source>
          <target state="translated">ExampleScope는 구문 분석 된 파일 집합에서 생성 된 패키지의 범위 트리를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8c65e0caab54f4a2e226c019adde6010c7ba6016" translate="yes" xml:space="preserve">
          <source>ExampleSortKeys demonstrates a technique for sorting a struct type using programmable sort criteria.</source>
          <target state="translated">ExampleSortKeys는 프로그램 가능 정렬 기준을 사용하여 구조체 유형을 정렬하는 기술을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="14f8a2b98443a4dd938fd26ea0bb96b2061a1486" translate="yes" xml:space="preserve">
          <source>Examples of struct field tags and their meanings:</source>
          <target state="translated">구조체 필드 태그와 그 의미의 예 :</target>
        </trans-unit>
        <trans-unit id="3868550c47675aee1b65322c0a530356bac93476" translate="yes" xml:space="preserve">
          <source>Examples returns the examples found in the files, sorted by Name field. The Order fields record the order in which the examples were encountered.</source>
          <target state="translated">예제는 파일에서 찾은 예제를 이름 필드별로 정렬하여 반환합니다. 주문 필드는 예제가 발생한 순서를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2139b5f270ff75a838ef994f1a7c0702593e500d" translate="yes" xml:space="preserve">
          <source>Except for reading the body, handlers should not modify the provided Request.</source>
          <target state="translated">본문을 제외하고 핸들러는 제공된 요청을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d972e775d3ec8bbf70216136812cfc2aa6c6c1f2" translate="yes" xml:space="preserve">
          <source>Except when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:</source>
          <target state="translated">동사 % T 및 % p를 사용하여 인쇄하는 경우를 제외하고 특정 인터페이스를 구현하는 피연산자에 대해 특수한 형식 고려 사항이 적용됩니다. 신청 순서 :</target>
        </trans-unit>
        <trans-unit id="663fbbe8a5ab797134d5a3e798a619fc2b622e8a" translate="yes" xml:space="preserve">
          <source>Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.</source>
          <target state="translated">Exec은 주어진 인수로 준비된 명령문을 실행하고 명령문의 효과를 요약 한 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b2e416ff8481c94b506d5f1d3e462de40111511e" translate="yes" xml:space="preserve">
          <source>Exec executes a query that doesn't return rows. For example: an INSERT and UPDATE.</source>
          <target state="translated">Exec은 행을 반환하지 않는 쿼리를 실행합니다. 예를 들어 : INSERT 및 UPDATE.</target>
        </trans-unit>
        <trans-unit id="f3c42d65910e9f7b2f5399cc46977eb6b49601aa" translate="yes" xml:space="preserve">
          <source>Exec executes a query without returning any rows. The args are for any placeholder parameters in the query.</source>
          <target state="translated">Exec은 행을 반환하지 않고 쿼리를 실행합니다. 인수는 쿼리의 자리 표시 자 매개 변수에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="68b4576f203991257daca46f8ba57ce5bc9b1e71" translate="yes" xml:space="preserve">
          <source>Exec invokes the execve(2) system call.</source>
          <target state="translated">Exec은 execve (2) 시스템 호출을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f74f4301002ea9d1c1563f1fa536de299c417471" translate="yes" xml:space="preserve">
          <source>Exec may return ErrSkip.</source>
          <target state="translated">Exec은 ErrSkip을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b927a0c4f27f7c2245dd620e36187bf80c3d0e50" translate="yes" xml:space="preserve">
          <source>ExecContext executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.</source>
          <target state="translated">ExecContext는 주어진 인수로 준비된 명령문을 실행하고 명령문의 효과를 요약 한 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9d0bd4f3ae9832eb93898d324b87a29a1346fa77" translate="yes" xml:space="preserve">
          <source>ExecContext executes a query that doesn't return rows. For example: an INSERT and UPDATE.</source>
          <target state="translated">ExecContext는 행을 반환하지 않는 쿼리를 실행합니다. 예를 들어 : INSERT 및 UPDATE.</target>
        </trans-unit>
        <trans-unit id="fcecac057ade8a549a93af9d19f63ed3d3a1e5e8" translate="yes" xml:space="preserve">
          <source>ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query.</source>
          <target state="translated">ExecContext는 행을 반환하지 않고 쿼리를 실행합니다. 인수는 쿼리의 자리 표시 자 매개 변수에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="28385547a6dc992edbb21722af7149817bf1e882" translate="yes" xml:space="preserve">
          <source>ExecError is the custom error type returned when Execute has an error evaluating its template. (If a write error occurs, the actual error is returned; it will not be of type ExecError.)</source>
          <target state="translated">ExecError는 Execute에 템플릿 평가 오류가있을 때 반환되는 사용자 지정 오류 유형입니다. (쓰기 오류가 발생하면 실제 오류가 반환되며 ExecError 유형이 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="f8cd14bc64afac06caa8a1276637b7f9488463ea" translate="yes" xml:space="preserve">
          <source>Execer is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">Execer는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5c1ff5cf4051fbd8da0a29e75b0f05215a476e06" translate="yes" xml:space="preserve">
          <source>ExecerContext is an optional interface that may be implemented by a Conn.</source>
          <target state="translated">ExecerContext는 Conn에 의해 구현 될 수있는 선택적 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4a3be90db73ae31f1fa874b8e8b95f6320af4ec1" translate="yes" xml:space="preserve">
          <source>ExecerContext may return ErrSkip.</source>
          <target state="translated">ExecerContext는 ErrSkip을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="116fbe2364a9d887fc69eaade708bc7fe63a456c" translate="yes" xml:space="preserve">
          <source>ExecerContext must honor the context timeout and return when the context is canceled.</source>
          <target state="translated">ExecerContext는 컨텍스트 제한 시간을 준수하고 컨텍스트가 취소되면 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b13379f2972a85ae6473933a27341217bb8895b" translate="yes" xml:space="preserve">
          <source>Executable is not supported on nacl.</source>
          <target state="translated">nacl에서는 실행 파일이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9ae4cbb34da99d02173a7dcb28dd93c5dce7f5d" translate="yes" xml:space="preserve">
          <source>Executable returns an absolute path unless an error occurred.</source>
          <target state="translated">실행 파일은 오류가 발생하지 않는 한 절대 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="adec63f8f562d73a545ecff88acb5d043aea120d" translate="yes" xml:space="preserve">
          <source>Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path/filepath.EvalSymlinks might help.</source>
          <target state="translated">실행 파일은 현재 프로세스를 시작한 실행 파일의 경로 이름을 반환합니다. 경로가 여전히 올바른 실행 파일을 가리키고 있다는 보장은 없습니다. 운영 체제에 따라 symlink를 사용하여 프로세스를 시작한 경우 결과는 symlink 또는 지정된 경로 일 수 있습니다. 안정적인 결과가 필요한 경우 path / filepath.EvalSymlinks가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7294a8cb458c8e65f536967bf6b4d79b8c096c55" translate="yes" xml:space="preserve">
          <source>Execute applies a parsed template to the specified data object, and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="translated">실행은 구문 분석 된 템플리트를 지정된 데이터 오브젝트에 적용하고 출력을 wr에 씁니다. 템플릿을 실행하거나 출력을 작성하는 동안 오류가 발생하면 실행이 중지되지만 부분 결과는 이미 출력 기록기에 기록되었을 수 있습니다. 병렬 실행이 라이터를 공유하는 경우 출력이 인터리브 될 수 있지만 템플릿은 안전하게 병렬로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ab91b77ffead5cde7f6f24acf146ee0201982a" translate="yes" xml:space="preserve">
          <source>Execute applies a parsed template to the specified data object, writing the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="translated">실행은 구문 분석 된 템플리트를 지정된 데이터 오브젝트에 적용하여 출력을 wr에 기록합니다. 템플릿을 실행하거나 출력을 작성하는 동안 오류가 발생하면 실행이 중지되지만 부분 결과는 이미 출력 기록기에 기록되었을 수 있습니다. 병렬 실행이 라이터를 공유하는 경우 출력이 인터리브 될 수 있지만 템플릿은 안전하게 병렬로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa7fd65efa38167472fbe062e9cd8ed9345685c" translate="yes" xml:space="preserve">
          <source>ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="translated">ExecuteTemplate은 지정된 이름을 가진 t와 연관된 템플리트를 지정된 데이터 오브젝트에 적용하고 출력을 wr에 기록합니다. 템플릿을 실행하거나 출력을 작성하는 동안 오류가 발생하면 실행이 중지되지만 부분 결과는 이미 출력 기록기에 기록되었을 수 있습니다. 병렬 실행이 라이터를 공유하는 경우 출력이 인터리브 될 수 있지만 템플릿은 안전하게 병렬로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5e15a34c9961f0a802784591faae9d82e65ab11" translate="yes" xml:space="preserve">
          <source>Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run.</source>
          <target state="translated">Exit는 현재 프로그램이 주어진 상태 코드로 종료되도록합니다. 일반적으로 코드 0은 성공을 나타내며 0이 아닌 오류입니다. 프로그램이 즉시 종료됩니다. 지연된 기능이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="323cb868fc9882809ab8fcf5b777ebf834c84081" translate="yes" xml:space="preserve">
          <source>ExitCode returns the exit code of the exited process, or -1 if the process hasn't exited or was terminated by a signal.</source>
          <target state="translated">ExitCode는 종료 된 프로세스의 종료 코드를 반환하거나 프로세스가 종료되지 않았거나 신호에 의해 종료 된 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bca7074b049716c77d327197e75adfe965e8630d" translate="yes" xml:space="preserve">
          <source>Exited reports whether the program has exited.</source>
          <target state="translated">종료는 프로그램이 종료되었는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="translated">Exp</target>
        </trans-unit>
        <trans-unit id="510ebbd48ca70ddfb27143ea5c2bad2d44f10597" translate="yes" xml:space="preserve">
          <source>Exp returns e**x, the base-e exponential of x.</source>
          <target state="translated">Exp는 x의 기본 e 지수 인 e ** x를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95aa110ed338c85b885ee58002691284514da3af" translate="yes" xml:space="preserve">
          <source>Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z. If m == nil or m == 0, z = x**y unless y &amp;lt;= 0 then z = 1. If m &amp;gt; 0, y &amp;lt; 0, and x and n are not relatively prime, z is unchanged and nil is returned.</source>
          <target state="translated">Exp 세트 z = x ** y mod | m | (즉, m의 부호는 무시 됨) z를 반환합니다. m == nil 또는 m == 0, y &amp;lt;= 0, z = 1이 아닌 한 z = x ** y 인 경우 m&amp;gt; 0, y &amp;lt;0 및 x와 n이 상대적으로 소수가 아닌 경우 z는 변경되지 않고 nil 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1f0ddfdecd3517aad8d1a91705ef531de70942" translate="yes" xml:space="preserve">
          <source>Exp2 returns 2**x, the base-2 exponential of x.</source>
          <target state="translated">Exp2는 x의 기본 2 지수 인 2 ** x를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="862a985d8f0da4e95960d25b159f9e9e124d15f5" translate="yes" xml:space="preserve">
          <source>ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To produce a distribution with a different rate parameter, callers can adjust the output using:</source>
          <target state="translated">ExpFloat64는 비율 매개 변수 (lambda)가 1이고 평균이 기본 소스에서 1 / lambda (1) 인 지수 분포와 함께 범위 (0, + math.MaxFloat64]의 지수 분포 float64를 반환합니다. 다른 요율 매개 변수, 발신자는 다음을 사용하여 출력을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da4e3aea659a15d7397bad8de4e0bdaee5767774" translate="yes" xml:space="preserve">
          <source>ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using:</source>
          <target state="translated">ExpFloat64는 비율 모수 (lambda)가 1이고 평균이 1 / lambda (1) 인 지수 분포와 함께 범위 (0, + math.MaxFloat64]의 지수 분포 float64를 반환합니다. 발신자는 다음을 사용하여 출력을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="translated">Expand</target>
        </trans-unit>
        <trans-unit id="e8b52c66c070329e5def2fa05af7b37abc20b0c6" translate="yes" xml:space="preserve">
          <source>Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex.</source>
          <target state="translated">Expand 템플릿을 dst에 추가하고 결과를 반환합니다. 추가하는 동안 Expand는 템플릿의 변수를 src에서 가져온 해당 일치 항목으로 바꿉니다. 일치 슬라이스는 FindSubmatchIndex에 의해 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ea00d9e907ef2f65f476a8e5a1f543fd9142d2a2" translate="yes" xml:space="preserve">
          <source>Expand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).</source>
          <target state="translated">확장은 맵핑 기능에 따라 문자열에서 $ {var} 또는 $ var을 대체합니다. 예를 들어, os.ExpandEnv (s)는 os.Expand (s, os.Getenv)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="61b36934002dfcd75585031913256f6e1ddb79f5" translate="yes" xml:space="preserve">
          <source>ExpandEnv</source>
          <target state="translated">ExpandEnv</target>
        </trans-unit>
        <trans-unit id="6389ca0cb471c7cb629f85955e0325ee99607a54" translate="yes" xml:space="preserve">
          <source>ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.</source>
          <target state="translated">ExpandEnv는 현재 환경 변수의 값에 따라 문자열에서 $ {var} 또는 $ var을 대체합니다. 정의되지 않은 변수에 대한 참조는 빈 문자열로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="92843cc46bc54c2861399f972b67d13993534275" translate="yes" xml:space="preserve">
          <source>ExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation.</source>
          <target state="translated">ExpandString은 Expand와 비슷하지만 템플릿과 소스는 문자열입니다. 호출 코드에 할당을 제어하기 위해 바이트 슬라이스를 추가하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="251a582ce62bfefda6c673fcd37e8d59e05a2922" translate="yes" xml:space="preserve">
          <source>Expired connections may be closed lazily before reuse.</source>
          <target state="translated">만료 된 연결은 재사용하기 전에 느리게 닫힐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481e2978ff7b371bd03a0ef6010a75e8c6fd03e9" translate="yes" xml:space="preserve">
          <source>Explicit argument indexes:</source>
          <target state="translated">명시 적 인수 색인 :</target>
        </trans-unit>
        <trans-unit id="a560a4789cca42ae8b0ecb7e313e3dc7fdad381d" translate="yes" xml:space="preserve">
          <source>ExplicitMethod returns the i'th explicitly declared method of interface t for 0 &amp;lt;= i &amp;lt; t.NumExplicitMethods(). The methods are ordered by their unique Id.</source>
          <target state="translated">ExplicitMethod는 0 &amp;lt;= i &amp;lt;t.NumExplicitMethods ()에 대해 인터페이스 t의 i 번째로 명시 적으로 선언 된 메서드를 반환합니다. 방법은 고유 한 ID로 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="210f18d7d2dca82962d73d77b3cb6405a7e3ec3b" translate="yes" xml:space="preserve">
          <source>Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than Exp(x) - 1 when x is near zero.</source>
          <target state="translated">Expm1은 x-1의 기본 e 지수 인 e ** x-1을 반환합니다. x가 0에 가까워지면 Exp (x)-1보다 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="8fbca60a155d19143993926486ce4e88d6422189" translate="yes" xml:space="preserve">
          <source>Exponent and precision limits.</source>
          <target state="translated">지수 및 정밀 한계.</target>
        </trans-unit>
        <trans-unit id="4480a118f418f1021763f928c23e7ee08b91b4bb" translate="yes" xml:space="preserve">
          <source>ExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in RFC 5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, this function will return an error.</source>
          <target state="translated">ExportKeyingMaterial은 RFC 5705에 정의 된대로 새 슬라이스에서 내 보낸 키 자료의 길이 바이트를 리턴합니다. 컨텍스트가 nil이면 시드의 일부로 사용되지 않습니다. 연결이 Config.Renegotiation을 통한 재협상을 허용하도록 설정된 경우이 함수는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5548a6e6a833cb04c8f11cf10934171fef992a89" translate="yes" xml:space="preserve">
          <source>Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.</source>
          <target state="translated">내보내기 개체를 내보낼 지 여부를보고합니다 (대문자로 시작). 객체가 로컬 (기능) 범위에 있는지 여부는 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c95f3a80a2e18bac3dc7cc110e89646c904993c" translate="yes" xml:space="preserve">
          <source>ExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.</source>
          <target state="translated">ExprString은 x에 대한 (짧게 단축 된) 문자열 표현을 반환합니다. 단축 표현은 사용자 인터페이스에 적합하지만 반드시 Go 구문을 따르지는 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74653975deaee88d4b0d4bc9bd71866d307248ad" translate="yes" xml:space="preserve">
          <source>Ext</source>
          <target state="translated">Ext</target>
        </trans-unit>
        <trans-unit id="fa3fed82b4272b5f7259531edfdcd5e9f6c21ba8" translate="yes" xml:space="preserve">
          <source>Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final element of path; it is empty if there is no dot.</source>
          <target state="translated">Ext는 경로에 사용 된 파일 이름 확장자를 반환합니다. 확장자는 경로의 마지막 요소에서 마지막 점에서 시작하는 접미사입니다. 점이 없으면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="50a89f2dbf1cde287eb428e1ff050f98aebee55f" translate="yes" xml:space="preserve">
          <source>Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot.</source>
          <target state="translated">Ext는 경로에 사용 된 파일 이름 확장자를 반환합니다. 확장은 슬래시로 구분 된 최종 경로 요소의 마지막 점에서 시작하는 접미사입니다. 점이 없으면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c784f4a2ddacb355b9ec53f45e6f9e5b26f8ef62" translate="yes" xml:space="preserve">
          <source>ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage* constants define a unique action.</source>
          <target state="translated">ExtKeyUsage는 주어진 키에 유효한 확장 된 동작 집합을 나타냅니다. 각 ExtKeyUsage * 상수는 고유 한 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="caf85fd048e02a11c54f8e5a543cc54c32a75ac8" translate="yes" xml:space="preserve">
          <source>Extended Key Usage values are enforced down a chain, so an intermediate or root that enumerates EKUs prevents a leaf from asserting an EKU not in that list.</source>
          <target state="translated">확장 키 사용 값은 체인에 적용되므로 EKU를 열거하는 중간 또는 루트는 리프가 해당 목록에없는 EKU를 주장하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="9d231fb333d7ce02bca636a53ff3662ee9b31d0e" translate="yes" xml:space="preserve">
          <source>Extension reports whether an extension is support by the server. The extension name is case-insensitive. If the extension is supported, Extension also returns a string that contains any parameters the server specifies for the extension.</source>
          <target state="translated">확장은 서버가 확장을 지원하는지 여부를보고합니다. 확장명은 대소 문자를 구분하지 않습니다. 확장이 지원되는 경우 Extension은 서버가 확장에 대해 지정한 매개 변수가 포함 된 문자열도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ace6ecb8af6a3359dd0ee95e26152ccb34af5460" translate="yes" xml:space="preserve">
          <source>Extension represents the ASN.1 structure of the same name. See RFC 5280, section 4.2.</source>
          <target state="translated">확장자는 동일한 이름의 ASN.1 구조를 나타냅니다. RFC 5280, 섹션 4.2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31959200e26a22be03bc0bb47ef68bbf9b24bab3" translate="yes" xml:space="preserve">
          <source>Extensions are looked up first case-sensitively, then case-insensitively.</source>
          <target state="translated">확장은 대소 문자를 구분하여 찾은 다음 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cbba6001e28100d482f6a6299792705c6215e5a" translate="yes" xml:space="preserve">
          <source>ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in &quot;.html&quot;. When typ has no associated extensions, ExtensionsByType returns an nil slice.</source>
          <target state="translated">ExtensionsByType은 MIME 유형 typ와 연관된 것으로 알려진 확장자를 리턴합니다. 반환 된 확장자는 &quot;.html&quot;과 같이 각각 점으로 시작합니다. typ에 연결된 확장이 없으면 ExtensionsByType은 nil 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42f92bb33922145bd437972bd7334d66d54fc74c" translate="yes" xml:space="preserve">
          <source>Fail marks the function as having failed but continues execution.</source>
          <target state="translated">실패는 함수가 실패한 것으로 표시하지만 실행은 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c96da18b07e966a06683f2215098b994edf8d8a8" translate="yes" xml:space="preserve">
          <source>FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines.</source>
          <target state="translated">FailNow는 함수가 실패한 것으로 표시하고 runtime.Goexit (현재 고 루틴에서 모든 지연된 호출을 실행)를 호출하여 실행을 중지합니다. 다음 테스트 또는 벤치 마크에서 실행이 계속됩니다. FailNow는 테스트 중에 생성 된 다른 고 루틴이 아니라 테스트 또는 벤치 마크 기능을 실행하는 고 루틴에서 호출해야합니다. FailNow를 호출해도 다른 고 루틴은 멈추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01a2572255742baf72eacb416d97e18b48d912c5" translate="yes" xml:space="preserve">
          <source>Failed reports whether the function has failed.</source>
          <target state="translated">실패는 기능이 실패했는지 여부를보고합니다.</target>
        </trans-unit>
        <trans-unit id="158e2280504673822ca1dd07952532cc4d1da5a7" translate="yes" xml:space="preserve">
          <source>Fatal is equivalent to Log followed by FailNow.</source>
          <target state="translated">치명적은 Log 다음에 FailNow와 같습니다.</target>
        </trans-unit>
        <trans-unit id="59eb8d095a56a5d642425c97f87d097bf1a29e0c" translate="yes" xml:space="preserve">
          <source>Fatal is equivalent to Print() followed by a call to os.Exit(1).</source>
          <target state="translated">치명적은 Print ()와 동일하며 os.Exit (1)을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1b648a69f1114f39bd45b11c4cb17246fbb28c1b" translate="yes" xml:space="preserve">
          <source>Fatal is equivalent to l.Print() followed by a call to os.Exit(1).</source>
          <target state="translated">치명적은 l.Print ()와 os.Exit (1) 호출에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="821293c77a8a8bf8b0fca5f95004d9fc65b67208" translate="yes" xml:space="preserve">
          <source>Fatalf is equivalent to Logf followed by FailNow.</source>
          <target state="translated">Fatalf는 Logf 다음에 FailNow와 같습니다.</target>
        </trans-unit>
        <trans-unit id="83255ac37e112e05058d8a28ec8b155f3e9d2e47" translate="yes" xml:space="preserve">
          <source>Fatalf is equivalent to Printf() followed by a call to os.Exit(1).</source>
          <target state="translated">Fatalf는 Printf ()와 동일하며 os.Exit (1)을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8571875ef68d4b9deea013c46be5e95e7550519a" translate="yes" xml:space="preserve">
          <source>Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).</source>
          <target state="translated">Fatalf는 l.Printf ()와 os.Exit (1) 호출에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e48e9dcadd0241869c65df99078d16d774bed84d" translate="yes" xml:space="preserve">
          <source>Fatalln is equivalent to Println() followed by a call to os.Exit(1).</source>
          <target state="translated">Fatalln은 Println ()과 동일하며 os.Exit (1)을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7df0d59b5e282da60574bc47edaa9526f95c3b6d" translate="yes" xml:space="preserve">
          <source>Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).</source>
          <target state="translated">Fatalln은 l.Println () 다음에 os.Exit (1)을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cb27ee0cfbf9af89a40e300698ac1dde2642f55" translate="yes" xml:space="preserve">
          <source>FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.</source>
          <target state="translated">FcntlFlock은 F_GETLK, F_SETLK 또는 F_SETLKW 명령에 대해 fcntl syscall을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cb72a865b5feb1394b8952b8f15d42e68aa3981b" translate="yes" xml:space="preserve">
          <source>Fd returns the integer Unix file descriptor referencing the open file. The file descriptor is valid only until f.Close is called or f is garbage collected. On Unix systems this will cause the SetDeadline methods to stop working.</source>
          <target state="translated">Fd는 열린 파일을 참조하는 정수 Unix 파일 디스크립터를 리턴합니다. 파일 디스크립터는 f.Close가 호출되거나 f가 가비지 수집 될 때까지만 유효합니다. Unix 시스템에서는 SetDeadline 메소드가 작동을 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="d61d809eab07312ae05f8f709b84547398d2efdf" translate="yes" xml:space="preserve">
          <source>Field returns the i'th field for 0 &amp;lt;= i &amp;lt; NumFields().</source>
          <target state="translated">Field는 0 &amp;lt;= i &amp;lt;NumFields ()에 대한 i 번째 필드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="261d167c68d467f10d820edc6286e66bbb21759b" translate="yes" xml:space="preserve">
          <source>Field returns the i'th field of the struct v. It panics if v's Kind is not Struct or i is out of range.</source>
          <target state="translated">Field는 구조체 v의 i 번째 필드를 반환합니다. v의 Kind가 Struct가 아니거나 i가 범위를 벗어나면 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c791e0a7e5bd33b119b2f78289ee593a7501c42" translate="yes" xml:space="preserve">
          <source>FieldByIndex returns the nested field corresponding to index. It panics if v's Kind is not struct.</source>
          <target state="translated">FieldByIndex는 인덱스에 해당하는 중첩 필드를 반환합니다. v 's Kind가 구조체가 아니면 패닉 상태입니다.</target>
        </trans-unit>
        <trans-unit id="8183a55fec39ebd325b9f393dccbc786cb50e104" translate="yes" xml:space="preserve">
          <source>FieldByName and related functions consider struct field names to be equal if the names are equal, even if they are unexported names originating in different packages. The practical effect of this is that the result of t.FieldByName(&quot;x&quot;) is not well defined if the struct type t contains multiple fields named x (embedded from different packages). FieldByName may return one of the fields named x or may report that there are none. See &lt;a href=&quot;https://golang.org/issue/4876&quot;&gt;https://golang.org/issue/4876&lt;/a&gt; for more details.</source>
          <target state="translated">FieldByName 및 관련 함수는 이름이 동일한 경우 (패키지 이름이 다른 패키지에서 유래 한 경우에도) struct 필드 이름이 동일한 것으로 간주합니다. 이것의 실제 효과는 struct type t에 x (여러 패키지에 포함)라는 여러 필드가 포함되어 있으면 t.FieldByName ( &quot;x&quot;)의 결과가 제대로 정의되지 않은 것입니다. FieldByName은 x라는 필드 중 하나를 리턴하거나 존재하지 않는다고보고 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://golang.org/issue/4876&quot;&gt;https://golang.org/issue/4876&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64a2508218e09b64bdd0d9e7f24c36121018ee1f" translate="yes" xml:space="preserve">
          <source>FieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v's Kind is not struct.</source>
          <target state="translated">FieldByName은 주어진 이름을 가진 구조체 필드를 반환합니다. 필드가 없으면 0 값을 리턴합니다. v 's Kind가 구조체가 아니면 패닉 상태입니다.</target>
        </trans-unit>
        <trans-unit id="d05b4005e71684b698845fc4189a49e33cd3e7f3" translate="yes" xml:space="preserve">
          <source>FieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v's Kind is not struct. It returns the zero Value if no field was found.</source>
          <target state="translated">FieldByNameFunc는 일치 함수를 만족시키는 이름을 가진 구조체 필드를 반환합니다. v 's Kind가 구조체가 아니면 패닉 상태입니다. 필드가 없으면 0 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7c99e9b1642562e3e1353bb454e3388fb902c996" translate="yes" xml:space="preserve">
          <source>FieldNode holds a field (identifier starting with '.'). The names may be chained ('.x.y'). The period is dropped from each ident.</source>
          <target state="translated">FieldNode에는 필드 ( '.'로 시작하는 식별자)가 있습니다. 이름은 연결될 수 있습니다 ( '.x.y'). 각 ID에서 기간이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="b282c4f43da573ed9235e6d31c0129363fbd6a56" translate="yes" xml:space="preserve">
          <source>Fields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an empty slice if s contains only white space.</source>
          <target state="translated">필드는 s를 일련의 UTF-8 인코딩 코드 포인트로 해석합니다. unicode.IsSpace에 의해 정의 된대로 슬라이스를 하나 이상의 연속 공백 문자의 각 인스턴스 주위로 분할하여 s의 하위 슬라이스 슬라이스 또는 공백이 포함 된 경우 빈 슬라이스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11942ab8089728dea08ce9ed92990aab227d9b83" translate="yes" xml:space="preserve">
          <source>Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an empty slice if s contains only white space.</source>
          <target state="translated">필드는 unicode.IsSpace에 의해 정의 된대로 하나 이상의 연속 공백 문자의 각 인스턴스 주위에서 문자열을 분할합니다. 공백이 포함 된 경우 s의 하위 문자열 조각 또는 빈 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1cddbffb0a4099caf5fcbfd9135dbe9cc1348312" translate="yes" xml:space="preserve">
          <source>Fields which start and stop with the quote character &quot; are called quoted-fields. The beginning and ending quote are not part of the field.</source>
          <target state="translated">인용 부호 &quot;로 시작하고 끝나는 필드를 인용 필드라고합니다. 시작 및 끝 인용 부호는 필드의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ed084c27b5c1cc1510b75a6eea5cceac8dc8568" translate="yes" xml:space="preserve">
          <source>FieldsFunc</source>
          <target state="translated">FieldsFunc</target>
        </trans-unit>
        <trans-unit id="1198e81508f52e5775684dce71da3bd307817aaf" translate="yes" xml:space="preserve">
          <source>FieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.</source>
          <target state="translated">FieldsFunc는 s를 일련의 UTF-8 인코딩 코드 포인트로 해석합니다. f (c)를 만족하는 각 코드 포인트 c에서 슬라이스 s를 분할하고 s의 서브 슬라이스 슬라이스를 반환합니다. s의 모든 코드 포인트가 f (c) 또는 len (s) == 0을 만족하면 빈 슬라이스가 반환됩니다. FieldsFunc는 f (c)를 호출하는 순서를 보증하지 않습니다. f가 주어진 c에 대해 일관된 결과를 반환하지 않으면 FieldsFunc가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93fef0b1adf312085c03264cc3bf92c0ae08947f" translate="yes" xml:space="preserve">
          <source>FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.</source>
          <target state="translated">FieldsFunc는 f (c)를 만족하는 각 유니 코드 코드 포인트 c에서 문자열 s를 분할하고 s 슬라이스 배열을 리턴합니다. s의 모든 코드 포인트가 f (c)를 만족하거나 문자열이 비어 있으면 빈 슬라이스가 반환됩니다. FieldsFunc는 f (c)를 호출하는 순서를 보증하지 않습니다. f가 주어진 c에 대해 일관된 결과를 반환하지 않으면 FieldsFunc가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84f4c98b71a6a2f1e7b377a8676e629c9740fd5f" translate="yes" xml:space="preserve">
          <source>File is an interface to access the file part of a multipart message. Its contents may be either stored in memory or on disk. If stored on disk, the File's underlying concrete type will be an *os.File.</source>
          <target state="translated">파일은 멀티 파트 메시지의 파일 부분에 액세스하기위한 인터페이스입니다. 내용은 메모리 나 디스크에 저장 될 수 있습니다. 디스크에 저장된 경우 파일의 기본 콘크리트 유형은 * os.File입니다.</target>
        </trans-unit>
        <trans-unit id="3b7e7234ecd572c448fdc94c6036d0727036b79d" translate="yes" xml:space="preserve">
          <source>File represents an open file descriptor.</source>
          <target state="translated">파일은 열린 파일 설명자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="73835fd64cea7fb721059e67256305a0d198b5ab" translate="yes" xml:space="preserve">
          <source>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.</source>
          <target state="translated">File은 기본 os.File의 사본을 리턴합니다. 완료되면 f를 닫는 것은 호출자의 책임입니다. c를 닫으면 f에 영향을 미치지 않으며 f를 닫으면 c에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cfa002fa0ca7b105692672f60881822088c5ccd" translate="yes" xml:space="preserve">
          <source>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.</source>
          <target state="translated">File은 기본 os.File의 사본을 리턴합니다. 완료되면 f를 닫는 것은 호출자의 책임입니다. l을 닫으면 f에 영향을 미치지 않으며 f를 닫으면 l에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a964559e347c1b7accfdbfdb5331a705f9a38368" translate="yes" xml:space="preserve">
          <source>File returns the file that contains the position p. If no such file is found (for instance for p == NoPos), the result is nil.</source>
          <target state="translated">파일은 위치 p를 포함하는 파일을 리턴합니다. 이러한 파일이 없으면 (예 : p == NoPos의 경우) 결과는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="8455c6bba2e3b76773e19fb487214e00c0eda43e" translate="yes" xml:space="preserve">
          <source>FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.</source>
          <target state="translated">FileConn은 열린 파일 f에 해당하는 네트워크 연결 복사본을 반환합니다. 완료되면 f를 닫는 것은 호출자의 책임입니다. c를 닫으면 f에 영향을 미치지 않으며 f를 닫으면 c에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a22e3976fc002f08d409b21bc3b2057de6ee7bb5" translate="yes" xml:space="preserve">
          <source>FileExports reports whether there are exported declarations.</source>
          <target state="translated">FileExports는 내 보낸 선언이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="3ddddfe5effd9cc3d49c7434638dbf7088ae876d" translate="yes" xml:space="preserve">
          <source>FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The File.Comments list is not changed.</source>
          <target state="translated">FileExports는 내 보낸 노드 만 유지되도록 Go 소스 파일에 대한 AST를 트리밍합니다. 내 보내지 않은 모든 최상위 식별자 : 내 보내지 않은 모든 최상위 식별자와 관련 정보 (예 : 유형, 초기 값 또는 함수 본문)가 제거됩니다. 내 보내지 않은 필드와 내 보낸 유형의 메서드가 제거됩니다. File.Comments 목록은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30db9abebdd92f5b7518cf1f5bbb9879a131845c" translate="yes" xml:space="preserve">
          <source>FileHeader describes a file within a zip file. See the zip spec for details.</source>
          <target state="translated">FileHeader는 zip 파일 내의 파일을 설명합니다. 자세한 내용은 zip 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d421452fb7f6f8f21ef4ba78426b17cbfd53ec7" translate="yes" xml:space="preserve">
          <source>FileInfo returns an os.FileInfo for the FileHeader.</source>
          <target state="translated">FileInfo는 FileHeader에 대한 os.FileInfo를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df3ff5122dc6f633a02486f869c65c492c72e91a" translate="yes" xml:space="preserve">
          <source>FileInfo returns an os.FileInfo for the Header.</source>
          <target state="translated">FileInfo는 헤더에 대한 os.FileInfo를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10f4523b7a78ead3725e69f92cdfe5b5d0be7c78" translate="yes" xml:space="preserve">
          <source>FileInfoHeader creates a partially-populated FileHeader from an os.FileInfo. Because os.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. If compression is desired, callers should set the FileHeader.Method field; it is unset by default.</source>
          <target state="translated">FileInfoHeader는 os.FileInfo에서 부분적으로 채워진 FileHeader를 만듭니다. os.FileInfo의 Name 메소드는 설명하는 파일의 기본 이름 만 리턴하므로 파일의 전체 경로 이름을 제공하기 위해 리턴 된 헤더의 이름 필드를 수정해야 할 수도 있습니다. 압축이 필요한 경우 호출자는 FileHeader.Method 필드를 설정해야합니다. 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bade8efb0bdf22a697f4860acaff901dcdf7cd40" translate="yes" xml:space="preserve">
          <source>FileInfoHeader creates a partially-populated Header from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name.</source>
          <target state="translated">FileInfoHeader는 fi에서 부분적으로 채워진 헤더를 만듭니다. fi가 심볼릭 링크를 설명하면 FileInfoHeader는 링크를 링크 대상으로 기록합니다. fi가 디렉토리를 설명하면 이름에 슬래시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e337ae6931880d7e580a328902c201076b51624" translate="yes" xml:space="preserve">
          <source>FileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f.</source>
          <target state="translated">FileLine은 프로그램 카운터 pc에 해당하는 소스 코드의 파일 이름과 줄 번호를 반환합니다. pc가 f 내의 프로그램 카운터가 아닌 경우 결과가 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82b2edf71f3991c324095b35a106fb747b15b499" translate="yes" xml:space="preserve">
          <source>FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln.</source>
          <target state="translated">FileListener는 열린 파일에 해당하는 네트워크 리스너의 사본을 반환합니다. f. 완료되면 ln을 닫는 것은 호출자의 책임입니다. ln 닫기는 f에 영향을 미치지 않으며 f 닫기는 ln에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="translated">FileMode</target>
        </trans-unit>
        <trans-unit id="aa6abe93ec8b861e41dbb5d680eb1abac76bc118" translate="yes" xml:space="preserve">
          <source>FileName returns the filename parameter of the Part's Content-Disposition header.</source>
          <target state="translated">FileName은 Part의 Content-Disposition 헤더의 파일 이름 매개 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ab442735e84d773b25b014f5d105c04cedc7c9de" translate="yes" xml:space="preserve">
          <source>FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.</source>
          <target state="translated">FilePacketConn은 열린 파일 f에 해당하는 패킷 네트워크 연결의 복사본을 반환합니다. 완료되면 f를 닫는 것은 호출자의 책임입니다. c를 닫으면 f에 영향을 미치지 않으며 f를 닫으면 c에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93afd50ecd9277958b5e979e54d840040f44f617" translate="yes" xml:space="preserve">
          <source>FileServer</source>
          <target state="translated">FileServer</target>
        </trans-unit>
        <trans-unit id="6b1c6f5fe976e57e9903b48c0ae3364dd14af1bf" translate="yes" xml:space="preserve">
          <source>FileServer (DotFileHiding)</source>
          <target state="translated">파일 서버 (DotFileHiding)</target>
        </trans-unit>
        <trans-unit id="4d2a840c48e0d07f28c7b78564c1dff9913edbe7" translate="yes" xml:space="preserve">
          <source>FileServer (StripPrefix)</source>
          <target state="translated">파일 서버 (StripPrefix)</target>
        </trans-unit>
        <trans-unit id="d2e3e689f0d74cd94b082adc56551c527c3d7331" translate="yes" xml:space="preserve">
          <source>FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root.</source>
          <target state="translated">FileServer는 루트에 기반을 둔 파일 시스템의 내용으로 HTTP 요청을 처리하는 핸들러를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b05ffc1d15462ca6f99d23dad5504fcb24e01652" translate="yes" xml:space="preserve">
          <source>Filenames containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">서버의 TLSConfig.Certificates 또는 TLSConfig.GetCertificate가 채워지지 않은 경우 서버에 대한 인증서 및 일치하는 개인 키를 포함하는 파일 이름을 제공해야합니다. 인증 기관이 인증서에 서명 한 경우 certFile은 서버 인증서, 중간체 및 CA 인증서를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="73595851a6091a7492042c8776979e91c6d3c91f" translate="yes" xml:space="preserve">
          <source>Files checks the provided files as part of the checker's package.</source>
          <target state="translated">파일은 제공된 파일을 검사기 패키지의 일부로 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f2677f06472fc0feb492ada82a2c4649c4e1df36" translate="yes" xml:space="preserve">
          <source>Files containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">서버의 TLSConfig.Certificates 또는 TLSConfig.GetCertificate가 채워지지 않은 경우 서버에 대한 인증서 및 일치하는 개인 키를 포함하는 파일을 제공해야합니다. 인증 기관이 인증서에 서명 한 경우 certFile은 서버 인증서, 중간체 및 CA 인증서를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c30ef34cd44738f2300a9d1c8d2644305bfe659" translate="yes" xml:space="preserve">
          <source>Filter eliminates documentation for names that don't pass through the filter f. TODO(gri): Recognize &quot;Type.Method&quot; as a name.</source>
          <target state="translated">필터는 필터를 통과하지 않는 이름에 대한 문서를 제거합니다. f. TODO (gri) : &quot;Type.Method&quot;를 이름으로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="8fe9542ddb9636eaf7f6d18a2a5c93cd3e032943" translate="yes" xml:space="preserve">
          <source>Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node.</source>
          <target state="translated">필터는 해당 노드가 노드에서 지정한 AST에 존재하는 cmap 항목만으로 구성된 새 주석 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99334f5ff24d09e0e43146c7ab17eed8e9e83ed8" translate="yes" xml:space="preserve">
          <source>FilterDecl reports whether there are any declared names left after filtering.</source>
          <target state="translated">FilterDecl은 필터링 후 남아있는 선언 된 이름이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="a98ad9f1ce33b85f6650faa2d18060284cd00443" translate="yes" xml:space="preserve">
          <source>FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f.</source>
          <target state="translated">FilterDecl은 필터를 통과하지 않는 모든 이름 (구조 필드 및 인터페이스 메소드 이름은 포함하지만 매개 변수 목록은 제외)을 제거하여 Go 선언에 대한 AST를 잘라냅니다. f.</target>
        </trans-unit>
        <trans-unit id="c1ed367ffc6ba55dd5b60bff81664a2c439a8484" translate="yes" xml:space="preserve">
          <source>FilterFile reports whether there are any top-level declarations left after filtering.</source>
          <target state="translated">FilterFile은 필터링 후 남아있는 최상위 선언이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="7a9fa766ec80d5d59f245ed962a927a61c070075" translate="yes" xml:space="preserve">
          <source>FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The File.Comments list is not changed.</source>
          <target state="translated">FilterFile은 필터를 통과하지 않는 최상위 레벨 선언 (구조 필드 및 인터페이스 메소드 이름을 포함하지만 매개 변수 목록이 아닌)에서 모든 이름을 제거하여 Go 파일에 대한 AST를 잘라냅니다. f. 이후에 선언이 비어 있으면 선언이 AST에서 제거됩니다. 가져 오기 선언은 항상 제거됩니다. File.Comments 목록은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="616d0d4a74fcef85e72d4edac004eabd14b32293" translate="yes" xml:space="preserve">
          <source>FilterPackage reports whether there are any top-level declarations left after filtering.</source>
          <target state="translated">FilterPackage는 필터링 후 남아있는 최상위 선언이 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="cc812cc8b170b6479d3dcdf5fdfae2947c9e732a" translate="yes" xml:space="preserve">
          <source>FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.</source>
          <target state="translated">FilterPackage는 필터를 통과하지 않는 최상위 수준 선언 (구조 필드 및 인터페이스 메서드 이름은 포함하지만 매개 변수 목록은 포함하지 않음)에서 모든 이름을 제거하여 Go 패키지에 대한 AST를 정리합니다. f. 이후에 선언이 비어 있으면 선언이 AST에서 제거됩니다. pkg.Files 목록은 변경되지 않으므로 파일 이름과 최상위 패키지 주석이 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64167db3c8ee867d45eebbc9c53b064e2bb836d4" translate="yes" xml:space="preserve">
          <source>Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies.</source>
          <target state="translated">종료자는 종속성 순서로 실행됩니다. A가 B 지점에있는 경우 둘 다 종료자가 있고 도달 할 수없는 경우 A의 종료자가 실행됩니다. A가 해제되면 B의 종료자가 실행될 수 있습니다. 순환 구조에 종료자가 포함 된 블록이 포함 된 경우 해당주기는 가비지 수집이 보장되지 않으며 종속을 존중하는 순서가 없기 때문에 종료자가 실행되도록 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04c286b7e901d165a790bb4d85625ee624e6c5de" translate="yes" xml:space="preserve">
          <source>Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface for scanning and (except for *Rat) the Formatter interface for formatted printing.</source>
          <target state="translated">마지막으로 * Int, * Rat 및 * Float는 스캔을위한 fmt 패키지의 스캐너 인터페이스와 형식화 된 인쇄를위한 Formatter 인터페이스 (* Rat 제외)를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="26ec87dd2b9f83faa210cf241d5b474c8a62da6b" translate="yes" xml:space="preserve">
          <source>Finally, any occurrences of slash are replaced by Separator.</source>
          <target state="translated">마지막으로 슬래시가 있으면 구분 기호로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="2e283acb4f254ad8296a8a754d3d7b44acc43a52" translate="yes" xml:space="preserve">
          <source>Finally, each message created by a call to Encode is preceded by an encoded unsigned integer count of the number of bytes remaining in the message. After the initial type name, interface values are wrapped the same way; in effect, the interface value acts like a recursive invocation of Encode.</source>
          <target state="translated">마지막으로, Encode 호출에 의해 생성 된 각 메시지는 메시지에 남아있는 바이트 수의 부호없는 부호없는 정수 카운트가 앞에옵니다. 초기 유형 이름 뒤에는 인터페이스 값이 같은 방식으로 줄 바꿈됩니다. 사실상, 인터페이스 값은 Encode의 재귀 호출처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="26fb85ce34e42f69c76353a6f2b051f404c7f2c9" translate="yes" xml:space="preserve">
          <source>Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match.</source>
          <target state="translated">찾기는 정규식의 b에서 가장 왼쪽 일치하는 텍스트가 들어있는 슬라이스를 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3939b43a8656fedf8c713b119be8032947dc3ecd" translate="yes" xml:space="preserve">
          <source>FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAll은 찾기의 '전체'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36cb8b2ff6a76516bc1c892450ee61ae3139b098" translate="yes" xml:space="preserve">
          <source>FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllIndex는 FindIndex의 '전체'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5f37301641ba46ce0b020d50232dcdae9f0dad0" translate="yes" xml:space="preserve">
          <source>FindAllIndex returns a sorted list of non-overlapping matches of the regular expression r, where a match is a pair of indices specifying the matched slice of x.Bytes(). If n &amp;lt; 0, all matches are returned in successive order. Otherwise, at most n matches are returned and they may not be successive. The result is nil if there are no matches, or if n == 0.</source>
          <target state="translated">FindAllIndex는 정규 표현식 r의 겹치지 않는 일치 항목의 정렬 된 목록을 반환합니다. 여기서 일치는 x.Bytes ()의 일치 슬라이스를 지정하는 인덱스 쌍입니다. n &amp;lt;0이면 모든 일치 항목이 연속적인 순서로 반환됩니다. 그렇지 않으면 최대 n 개의 일치 항목이 반환되고 연속되지 않을 수 있습니다. 일치하는 항목이 없거나 n == 0 인 경우 결과는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="9de88adfecc3f20e0c2ffdbb0f036f7a79d80f3b" translate="yes" xml:space="preserve">
          <source>FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllString은 FindString의 '전체'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="50f5df0a72b99ef5ef4ba48205043bd703872dd1" translate="yes" xml:space="preserve">
          <source>FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringIndex는 FindStringIndex의 '전체'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fd030004e8ba710e67858c9136cb59800b720d8e" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringSubmatch는 FindStringSubmatch의 'All'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="866672036e7565c5590c34ec3cdc6d2f77a921c5" translate="yes" xml:space="preserve">
          <source>FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllStringSubmatchIndex는 FindStringSubmatchIndex의 '전체'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3be6622b78b7a355447dee918503ed5111144cd3" translate="yes" xml:space="preserve">
          <source>FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllSubmatch는 FindSubmatch의 '전체'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c52ee6c792ee96296da432c07ce6bac841f99f98" translate="yes" xml:space="preserve">
          <source>FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindAllSubmatchIndex는 FindSubmatchIndex의 '전체'버전입니다. 패키지 주석의 'All'설명에 정의 된대로 식과 일치하는 모든 일치하는 조각을 반환합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="42e5b0dfb84ada5e535dcd7bb2807e917d046ce8" translate="yes" xml:space="preserve">
          <source>FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="translated">FindIndex는 정규 표현식의 b에서 가장 왼쪽 일치하는 위치를 정의하는 두 요소의 정수 슬라이스를 반환합니다. 일치 자체는 b [loc [0] : loc [1]]에 있습니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e8a7de41165a099a274921bab815b24b2852407" translate="yes" xml:space="preserve">
          <source>FindProcess looks for a running process by its pid.</source>
          <target state="translated">FindProcess는 pid로 실행중인 프로세스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4911a1ccdd694282d198f0794f5539db98ac7df1" translate="yes" xml:space="preserve">
          <source>FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match.</source>
          <target state="translated">FindReaderIndex는 RuneReader에서 읽은 텍스트에서 정규식의 가장 왼쪽 일치 위치를 정의하는 두 요소의 정수 슬라이스를 반환합니다. 일치 텍스트는 바이트 오프셋 loc [0]에서 loc [1] -1의 입력 스트림에서 발견되었습니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d35aea7e01a3055400cfb5abc273aa2a48d9a9f" translate="yes" xml:space="preserve">
          <source>FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindReaderSubmatchIndex는 패키지 주석의 'Submatch'및 'Index'설명에 정의 된대로 RuneReader가 읽은 텍스트의 정규 표현식과 하위 표현식의 일치 (있는 경우)의 가장 왼쪽 일치를 식별하는 인덱스 쌍을 보유하는 슬라이스를 리턴합니다. . nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e9a327cf77fbaf9bbe1a604d4bcf583f4d07fb1a" translate="yes" xml:space="preserve">
          <source>FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases.</source>
          <target state="translated">FindString은 정규식에서 s 가장 왼쪽 일치하는 텍스트를 보유한 문자열을 리턴합니다. 일치하는 것이 없으면 반환 값은 빈 문자열이지만 정규식이 빈 문자열과 성공적으로 일치하면 비어 있습니다. 이러한 경우를 구별해야하는 경우 FindStringIndex 또는 FindStringSubmatch를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="531bff01dd38db5d072dffaff07b7a369f4e48aa" translate="yes" xml:space="preserve">
          <source>FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.</source>
          <target state="translated">FindStringIndex는 정규 표현식의 s에서 가장 왼쪽 일치 위치를 정의하는 두 요소의 정수 슬라이스를 리턴합니다. 일치 자체는 s [loc [0] : loc [1]]에 있습니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a789ded76b89d56fcfc993f95abd7a8461164bf2" translate="yes" xml:space="preserve">
          <source>FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindStringSubmatch는 패키지 주석의 'Submatch'설명에 정의 된대로 s에서 정규 표현식의 가장 왼쪽 일치 텍스트와 하위 표현식의 일치 (있는 경우)를 보유하는 문자열 슬라이스를 리턴합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="716a3ff38a9d712fef426438e6f03f83ab81e7b5" translate="yes" xml:space="preserve">
          <source>FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindStringSubmatchIndex는 패키지 주석의 'Submatch'및 'Index'설명에 정의 된대로 s에서 정규 표현식의 가장 왼쪽 일치 항목과 하위 표현식의 일치 항목을 식별하는 색인 ​​쌍을 보유하는 슬라이스를 리턴합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ffa69da36fb7ee45dba39b18243a0f710f826bb2" translate="yes" xml:space="preserve">
          <source>FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindSubmatch는 패키지 주석의 'Submatch'설명에 정의 된대로 b에서 정규 표현식의 가장 왼쪽 일치 텍스트와 하위 표현식의 일치 (있는 경우)를 보유하는 슬라이스 슬라이스를 리턴합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7965df00e3cbe474d92d31bb0bd5221f067573f7" translate="yes" xml:space="preserve">
          <source>FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.</source>
          <target state="translated">FindSubmatchIndex는 패키지 주석의 'Submatch'및 'Index'설명에 정의 된대로 b에서 정규 표현식의 가장 왼쪽 일치와 하위 표현식의 일치를 식별하는 인덱스 쌍을 보유하는 슬라이스를 리턴합니다. nil의 반환 값은 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="316c8fcfd0429ed17b8857dd6ccdd403f5640491" translate="yes" xml:space="preserve">
          <source>Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value. The complexity is O(log n) where n = h.Len().</source>
          <target state="translated">수정은 인덱스 i의 요소가 값을 변경 한 후 힙 순서를 다시 설정합니다. 인덱스 i에서 요소의 값을 변경 한 다음 Fix를 호출하는 것은 Remove (h, i)를 호출하고 새 값을 푸시하는 것보다 비용이 적게 듭니다. 복잡도는 O (log n)이며 여기서 n = h.Len ()입니다.</target>
        </trans-unit>
        <trans-unit id="3d7cfcda1db5ca5e3bcb0a9677bf0dd4d80ac6e4" translate="yes" xml:space="preserve">
          <source>FixedZone</source>
          <target state="translated">FixedZone</target>
        </trans-unit>
        <trans-unit id="d8dd9f2c3ea7d8b26856edf904ee0771c7d5fc47" translate="yes" xml:space="preserve">
          <source>FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).</source>
          <target state="translated">FixedZone은 항상 주어진 영역 이름과 오프셋을 사용하는 위치를 반환합니다 (UTC 동쪽).</target>
        </trans-unit>
        <trans-unit id="2c7a643e1bb2320ed4f231588740bf7ac2e291cd" translate="yes" xml:space="preserve">
          <source>Flag parsing stops just before the first non-flag argument (&quot;-&quot; is a non-flag argument) or after the terminator &quot;--&quot;.</source>
          <target state="translated">플래그 구문 분석은 첫 번째 플래그가 아닌 인수 ( &quot;-&quot;는 플래그가 아닌 인수) 직전에 또는 종결 자 &quot;-&quot;뒤에 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="6fdd311ef8e9ef566cf48b8fece102302ba2cc48" translate="yes" xml:space="preserve">
          <source>Flags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.</source>
          <target state="translated">플래그는 예상하지 않은 동사에 의해 무시됩니다. 예를 들어 대체 10 진수 형식이 없으므로 % # d와 % d는 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="af3386ff8f43c1696f153b0da6ee0a837cb1976a" translate="yes" xml:space="preserve">
          <source>Flags control the behavior of the parser and record information about regexp context.</source>
          <target state="translated">플래그는 파서의 동작을 제어하고 정규 표현식 컨텍스트에 대한 정보를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="16c488a94448ea7f6f8bcea47a1cbbb9b2216fc9" translate="yes" xml:space="preserve">
          <source>Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.</source>
          <target state="translated">그런 다음 플래그를 직접 사용할 수 있습니다. 플래그 자체를 사용하는 경우 모두 포인터입니다. 변수에 바인딩하면 값입니다.</target>
        </trans-unit>
        <trans-unit id="8b5f3f5f47f0c72df0bc10a5003e3c8534841d99" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the logger.</source>
          <target state="translated">플래그는 로거의 출력 플래그를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ab784ad102a2c124d297f0684145d0588e53e2ce" translate="yes" xml:space="preserve">
          <source>Flags returns the output flags for the standard logger.</source>
          <target state="translated">플래그는 표준 로거의 출력 플래그를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="49886552d225c91289351966a030fb2ce1479645" translate="yes" xml:space="preserve">
          <source>Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system.</source>
          <target state="translated">기본 시스템의 것들을 감싸는 OpenFile에 플래그. 특정 시스템에서 모든 플래그를 구현할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e4dce7c8ab9c22a7b9475e937cb3027b98a99140" translate="yes" xml:space="preserve">
          <source>Float (Shift)</source>
          <target state="translated">플로트 (시프트)</target>
        </trans-unit>
        <trans-unit id="44e98719e5ce5b2d4401b4abb5dc0f8819be8a88" translate="yes" xml:space="preserve">
          <source>Float is a 64-bit float variable that satisfies the Var interface.</source>
          <target state="translated">Float는 Var 인터페이스를 만족시키는 64 비트 float 변수입니다.</target>
        </trans-unit>
        <trans-unit id="10efe1f5142078fa491d28fd6eb4b8558bc300d7" translate="yes" xml:space="preserve">
          <source>Float returns the value v as a float64. It panics if v is not a JavaScript number.</source>
          <target state="translated">Float는 값 v를 float64로 반환합니다. v가 JavaScript 번호가 아닌 경우 패닉이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ce5b8413e70edd589cd645e2e4c3403f1aae941" translate="yes" xml:space="preserve">
          <source>Float returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64</source>
          <target state="translated">Float는 v의 기본 값을 float64로 반환합니다. v의 종류가 Float32 또는 Float64가 아닌 경우 패닉</target>
        </trans-unit>
        <trans-unit id="eeec2beb5f657aee9f544ee180ec6e738a4d2d1a" translate="yes" xml:space="preserve">
          <source>Float.Add</source>
          <target state="translated">Float.Add</target>
        </trans-unit>
        <trans-unit id="ad02b5997c5669d53745f3d1c236de0ca407890e" translate="yes" xml:space="preserve">
          <source>Float.Cmp</source>
          <target state="translated">Float.Cmp</target>
        </trans-unit>
        <trans-unit id="fec48acd5df26f0383b2951f8c9e9ae9c4ff8998" translate="yes" xml:space="preserve">
          <source>Float.Scan</source>
          <target state="translated">Float.Scan</target>
        </trans-unit>
        <trans-unit id="b29933c6b53142cadd8d7b922f23fae52793b020" translate="yes" xml:space="preserve">
          <source>Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| &amp;lt; math.SmallestNonzeroFloat32), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| &amp;gt; math.MaxFloat32), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="translated">Float32는 x에 가장 가까운 float32 값을 반환합니다. x가 너무 작아서 float32 (| x | &amp;lt;math.SmallestNonzeroFloat32)로 표시 할 수없는 경우 x의 부호에 따라 결과는 각각 (0, 아래) 또는 (-0, 위)입니다. x가 너무 커서 float32 (| x |&amp;gt; math.MaxFloat32)로 표현하기 어려운 경우 x의 부호에 따라 결과는 (+ Inf, Above) 또는 (-Inf, Below)입니다.</target>
        </trans-unit>
        <trans-unit id="f0d283c114b964a75d4c408e464182f402cb0b18" translate="yes" xml:space="preserve">
          <source>Float32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="translated">Float32는 x에 대해 가장 가까운 float32 값과 f가 x를 정확하게 나타내는 지 여부를 나타내는 bool을 반환합니다. x의 크기가 너무 커서 float32로 표현할 수없는 경우 f는 무한대이고 정확한 값은 false입니다. f == 0 인 경우에도 f의 부호는 항상 x의 부호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="eb048248df2600ce9ef5e83d147f9a17ca26adc9" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="translated">Float32는 기본 소스에서 [0.0,1.0)의 의사 난수를 float32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="119557e6710e4b086bbd4a2b0b1939505b2ba07f" translate="yes" xml:space="preserve">
          <source>Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).</source>
          <target state="translated">Float32는 [0.0,1.0)의 의사 난수를 float32로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b84b66f83430db58763aa54b8b6d03936e54bbe" translate="yes" xml:space="preserve">
          <source>Float32Val is like Float64Val but for float32 instead of float64.</source>
          <target state="translated">Float32Val은 Float64Val과 비슷하지만 float64 대신 float32입니다.</target>
        </trans-unit>
        <trans-unit id="105737d03460ae3ded6de0ef2ecd36f638e30d1b" translate="yes" xml:space="preserve">
          <source>Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) == x.</source>
          <target state="translated">Float32bits는 f의 부호 비트와 동일한 비트 위치에있는 IEEE 754 이진 표현 f를 반환합니다. Float32bits (Float32frombits (x)) == x.</target>
        </trans-unit>
        <trans-unit id="7a6760b22e35a08f8123f6341f83087ea51bc753" translate="yes" xml:space="preserve">
          <source>Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) == x.</source>
          <target state="translated">Float32frombits는 IEEE 754 이진 표현 b에 해당하는 부동 소수점 숫자를 부호 비트 b와 동일한 비트 위치로 반환합니다. Float32frombits (Float32bits (x)) == x입니다.</target>
        </trans-unit>
        <trans-unit id="e33f8d6b4fe7a74df8d041793f6b8728167aa373" translate="yes" xml:space="preserve">
          <source>Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.</source>
          <target state="translated">Float64는 지정된 이름, 기본값 및 사용 문자열로 float64 플래그를 정의합니다. 리턴 값은 플래그 값을 저장하는 float64 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="932e539e33ca068476000955a48af619cccb5721" translate="yes" xml:space="preserve">
          <source>Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| &amp;lt; math.SmallestNonzeroFloat64), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| &amp;gt; math.MaxFloat64), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.</source>
          <target state="translated">Float64는 x에 가장 가까운 float64 값을 반환합니다. x가 너무 작아 float64 (| x | &amp;lt;math.SmallestNonzeroFloat64)로 표현하기 어려운 경우 x의 부호에 따라 결과는 각각 (0, 아래) 또는 (-0, 위)입니다. x가 너무 커서 float64 (| x |&amp;gt; math.MaxFloat64)로 표현할 수없는 경우 x의 부호에 따라 결과는 (+ Inf, Above) 또는 (-Inf, Below)입니다.</target>
        </trans-unit>
        <trans-unit id="9246cdfb5427d2669759af0d644a975a43bcf09a" translate="yes" xml:space="preserve">
          <source>Float64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.</source>
          <target state="translated">Float64는 x에 가장 가까운 float64 값과 f가 x를 정확하게 나타내는 지 여부를 나타내는 bool을 반환합니다. x의 크기가 float64로 표현하기에 너무 큰 경우 f는 무한대이고 정확한 값은 false입니다. f == 0 인 경우에도 f의 부호는 항상 x의 부호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fb72db19ea2b309695153285bf2c38294276e222" translate="yes" xml:space="preserve">
          <source>Float64 returns the number as a float64.</source>
          <target state="translated">Float64는 숫자를 float64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20e645bfba6b519f6d6f9f504b9c2a836ed66b68" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0) from the default Source.</source>
          <target state="translated">Float64는 기본 소스에서 [0.0,1.0)의 의사 난수를 float64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39abd5b0f47630ce640acfdfa7a56a26bd48772c" translate="yes" xml:space="preserve">
          <source>Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).</source>
          <target state="translated">Float64는 [0.0,1.0)의 의사 난수를 float64로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="653daf75fab3a49fdd7213b2a24c9eb000e8f80b" translate="yes" xml:space="preserve">
          <source>Float64Slice attaches the methods of Interface to []float64, sorting in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64Slice는 [] float64에 인터페이스 방법을 연결하여 오름차순으로 정렬합니다 (숫자가 아닌 값은 다른 값보다 작음).</target>
        </trans-unit>
        <trans-unit id="6d5aaf48b420a680701da91064c2099910f7a459" translate="yes" xml:space="preserve">
          <source>Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an Unknown, but not Complex. For values too small (too close to 0) to represent as float64, Float64Val silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is Unknown, the result is (0, false).</source>
          <target state="translated">Float64Val은 x의 가장 가까운 Go float64 값과 결과가 정확한지 여부를 반환합니다. x는 숫자이거나 알 수 없지만 복잡하지 않아야합니다. float64로 표현하기에 너무 작은 (0에 너무 가까운) 값의 경우 Float64Val은 자동으로 0으로 언더 플로됩니다. 결과 부호는 항상 0의 부호와도 일치합니다. x가 알 수없는 경우 결과는 (0, 거짓)입니다.</target>
        </trans-unit>
        <trans-unit id="f480bc564117c47157609272dad009564b4f9701" translate="yes" xml:space="preserve">
          <source>Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.</source>
          <target state="translated">Float64Var는 지정된 이름, 기본값 및 사용 문자열로 float64 플래그를 정의합니다. 인수 p는 플래그 값을 저장할 float64 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="5b76d09c27fdfd38a6732c012baed4272833ca08" translate="yes" xml:space="preserve">
          <source>Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) == x.</source>
          <target state="translated">Float64bits는 f의 부호 비트와 동일한 비트 위치의 결과와 함께 Float64bits (Float64frombits (x)) == x와 함께 f의 IEEE 754 이진 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13821cdc42fa2ea9b35bbae95ee0c4f0016322fc" translate="yes" xml:space="preserve">
          <source>Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) == x.</source>
          <target state="translated">Float64frombits는 IEEE 754 이진 표현 b에 해당하는 부동 소수점 숫자를 부호 비트 b와 동일한 비트 위치로 반환합니다. Float64frombits (Float64bits (x)) == x입니다.</target>
        </trans-unit>
        <trans-unit id="9528abfae7394b5c9ba7f685b93bd097bf04d6fb" translate="yes" xml:space="preserve">
          <source>Float64s</source>
          <target state="translated">Float64s</target>
        </trans-unit>
        <trans-unit id="6d807816d1f16d759e0177078b58ba0a3f78cc89" translate="yes" xml:space="preserve">
          <source>Float64s sorts a slice of float64s in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64s는 float64 조각을 오름차순으로 정렬합니다 (숫자가 아닌 값은 다른 값보다 작은 것으로 취급 됨).</target>
        </trans-unit>
        <trans-unit id="423599a7986fad94bdc1d6990e093d25432d1712" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted</source>
          <target state="translated">Float64sAreSorted</target>
        </trans-unit>
        <trans-unit id="4b88d9ca0f421f91022935615e41cacbe0162795" translate="yes" xml:space="preserve">
          <source>Float64sAreSorted tests whether a slice of float64s is sorted in increasing order (not-a-number values are treated as less than other values).</source>
          <target state="translated">Float64sAreSorted는 float64 조각이 오름차순으로 정렬되는지 테스트합니다 (숫자가 아닌 값은 다른 값보다 작은 것으로 취급 됨).</target>
        </trans-unit>
        <trans-unit id="2d47ae20529c410d30f8acaae289ca9d51484938" translate="yes" xml:space="preserve">
          <source>FloatString returns a string representation of x in decimal form with prec digits of precision after the radix point. The last digit is rounded to nearest, with halves rounded away from zero.</source>
          <target state="translated">FloatString은 기수 뒤의 정확한 정밀도로 x의 문자열 표현을 10 진수 형식으로 반환합니다. 마지막 숫자는 가장 가까운 숫자로 반올림되고 반은 0에서 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="05a1f94d542ff10ae04a25aa8e277a76154c76d0" translate="yes" xml:space="preserve">
          <source>FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64.</source>
          <target state="translated">FloatType은 문서 목적으로 만 사용됩니다. float 유형 인 float32 또는 float64의 독립형입니다.</target>
        </trans-unit>
        <trans-unit id="062cea8bd0e8167673b6851fa82870b7db8d7c76" translate="yes" xml:space="preserve">
          <source>Floating point, integer, and Number values encode as JSON numbers.</source>
          <target state="translated">부동 소수점, 정수 및 숫자 값은 JSON 숫자로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d6ee865f2a29fd1629088910ea491c9698ff5c" translate="yes" xml:space="preserve">
          <source>Floating-point and complex constituents:</source>
          <target state="translated">부동 소수점 및 복잡한 구성 요소 :</target>
        </trans-unit>
        <trans-unit id="b844d202032ef470ba06e9916c2c520ac0ae8998" translate="yes" xml:space="preserve">
          <source>Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type.</source>
          <target state="translated">부동 소수점 한계 값. Max는 유형으로 표현할 수있는 가장 큰 유한 값입니다. SmallestNonzero는 유형으로 표시 할 수있는 가장 작은 양의 0이 아닌 값입니다.</target>
        </trans-unit>
        <trans-unit id="58315571a008eb8b389dc1e86460decd0968399f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are always sent as a representation of a float64 value. That value is converted to a uint64 using math.Float64bits. The uint64 is then byte-reversed and sent as a regular unsigned integer. The byte-reversal means the exponent and high-precision part of the mantissa go first. Since the low bits are often zero, this can save encoding bytes. For instance, 17.0 is encoded in only three bytes (FE 31 40).</source>
          <target state="translated">부동 소수점 숫자는 항상 float64 값의 표현으로 전송됩니다. 이 값은 math.Float64bits를 사용하여 uint64로 변환됩니다. 그런 다음 uint64는 바이트 반전되고 일반 부호없는 정수로 전송됩니다. 바이트 리버설은 가수의 지수 및 고정밀 부분이 먼저 진행됨을 의미합니다. 하위 비트는 종종 0이므로 인코딩 바이트를 절약 할 수 있습니다. 예를 들어 17.0은 3 바이트로 인코딩됩니다 (FE 31 40).</target>
        </trans-unit>
        <trans-unit id="7db82f74092fc3160e6bc0d9e9bd4849c5c06c0f" translate="yes" xml:space="preserve">
          <source>Floor</source>
          <target state="translated">Floor</target>
        </trans-unit>
        <trans-unit id="ecdffd0cc36f2aad9aef8da98d7fbdd7cd3a98c8" translate="yes" xml:space="preserve">
          <source>Floor returns the greatest integer value less than or equal to x.</source>
          <target state="translated">Floor는 x보다 작거나 같은 가장 큰 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="563e65b909d8ae6e49711cd799a32c5eb753dc00" translate="yes" xml:space="preserve">
          <source>FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error diffusion.</source>
          <target state="translated">FloydSteinberg는 Floyd-Steinberg 오류 확산이있는 Src Op 인 드로어입니다.</target>
        </trans-unit>
        <trans-unit id="589b0d2e5704bd529f61be95ef5544d324be7a14" translate="yes" xml:space="preserve">
          <source>Flush finishes writing the current file's block padding. The current file must be fully written before Flush can be called.</source>
          <target state="translated">플러시는 현재 파일의 블록 패딩 쓰기를 완료합니다. Flush를 호출하기 전에 현재 파일을 완전히 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="843ff9ecc07dad8fd240920fbaff659c8bd3b2af" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered XML to the underlying writer. See the EncodeToken documentation for details about when it is necessary.</source>
          <target state="translated">Flush는 버퍼링 된 XML을 기본 작성기로 플러시합니다. 필요한시기에 대한 자세한 내용은 EncodeToken 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7757e81dddaaa31ce1e5de4d9b235a8f3a0853cd" translate="yes" xml:space="preserve">
          <source>Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient.</source>
          <target state="translated">플러시는 버퍼링 된 데이터를 기본 작성기로 플러시합니다. 플러시 호출은 일반적으로 필요하지 않습니다. 닫기를 호출하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="96dda344b5d691957686f7fdb72b5295f5fa20bb" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending compressed data to the underlying writer.</source>
          <target state="translated">플러시 보류중인 압축 데이터를 기본 작성기로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="3d5ed753caad4196a8e88cd94331064662192c20" translate="yes" xml:space="preserve">
          <source>Flush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the Writer to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error.</source>
          <target state="translated">플러시 보류중인 데이터를 기본 작성기로 플러시합니다. 원격 리더에 패킷을 재구성하기에 충분한 데이터가 있는지 확인하는 데 주로 압축 네트워크 프로토콜에 유용합니다. 데이터가 기록 될 때까지 플러시가 반환되지 않습니다. 보류중인 데이터가없는 경우 Flush를 호출하면 기록기는 여전히 최소 4 바이트의 동기화 마커를 생성합니다. 기본 작성기가 오류를 반환하면 Flush가 해당 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18258ea43eb9026bfa3ba6a07c0a3a31739171f2" translate="yes" xml:space="preserve">
          <source>Flush flushes the Writer to its underlying io.Writer.</source>
          <target state="translated">Flush는 Writer를 기본 io.Writer로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="729311d07e8c1334af4a5f862a0dd14b0dd93238" translate="yes" xml:space="preserve">
          <source>Flush implements http.Flusher. To test whether Flush was called, see rw.Flushed.</source>
          <target state="translated">플러시는 http.Flusher를 구현합니다. Flush가 호출되었는지 테스트하려면 rw.Flushed를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d24f3ea0b3c10e2043b05ee2cd79df1306cedcb" translate="yes" xml:space="preserve">
          <source>Flush should be called after the last call to Write to ensure that any data buffered in the Writer is written to output. Any incomplete escape sequence at the end is considered complete for formatting purposes.</source>
          <target state="translated">기록기에 버퍼링 된 모든 데이터가 출력에 기록되도록하려면 마지막으로 Write를 호출 한 후에 Flush를 호출해야합니다. 마지막에 불완전한 이스케이프 시퀀스는 형식화 목적으로 완료된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ea94514228dc595c44d2b25610d0fa2d54b246e4" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer.</source>
          <target state="translated">Flush는 버퍼링 된 데이터를 기본 io.Writer에 씁니다.</target>
        </trans-unit>
        <trans-unit id="ae89e3b744d5bf8ef751ee2c788427617846f85a" translate="yes" xml:space="preserve">
          <source>Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error.</source>
          <target state="translated">Flush는 버퍼링 된 데이터를 기본 io.Writer에 씁니다. 플러시 중 오류가 발생했는지 확인하려면 오류를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="9f472a0c2c904654bddc286404214aebce731987" translate="yes" xml:space="preserve">
          <source>FlushAfterChunkWriter signals from the caller of NewChunkedWriter that each chunk should be followed by a flush. It is used by the http.Transport code to keep the buffering behavior for headers and trailers, but flush out chunks aggressively in the middle for request bodies which may be generated slowly. See Issue 6574.</source>
          <target state="translated">FlushAfterChunkWriter는 NewChunkedWriter의 호출자로부터 각 청크 다음에 플러시를해야한다는 신호를 보냅니다. http.Transport 코드에서 사용되어 헤더와 트레일러의 버퍼링 동작을 유지하지만 느리게 생성 될 수있는 요청 본문을 위해 중간에 청크를 적극적으로 플러시합니다. 문제 6574를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="772a9c77dc26ab2b684cccb97da47b2e2cdf95ac" translate="yes" xml:space="preserve">
          <source>FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. If there is no entry for a category name, there are no such points.</source>
          <target state="translated">FoldCategory는 범주 이름을 범주 외부의 코드 포인트 테이블에 매핑합니다. 간단한 경우에는 범주 내부의 코드 포인트에 해당합니다. 카테고리 이름에 대한 항목이 없으면 해당 지점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3df43e93d81327f2c6837f681b29802a81ed9d8c" translate="yes" xml:space="preserve">
          <source>FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. If there is no entry for a script name, there are no such points.</source>
          <target state="translated">FoldScript는 스크립트 이름을 스크립트 외부의 코드 포인트 테이블에 매핑하며, 간단한 경우에는 스크립트 내부의 코드 포인트로 접습니다. 스크립트 이름에 대한 항목이 없으면 그러한 지점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a306a62652b9cfbec638f004e0203911d315836" translate="yes" xml:space="preserve">
          <source>For IP networks, the network must be &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot; followed by a colon and a literal protocol number or a protocol name, and the address has the form &quot;host&quot;. The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as &quot;0&quot; or &quot;255&quot;.</source>
          <target state="translated">IP 네트워크의 경우 네트워크는 &quot;ip&quot;, &quot;ip4&quot;또는 &quot;ip6&quot;다음에 콜론과 리터럴 프로토콜 번호 또는 프로토콜 이름이 있어야하며 주소는 &quot;host&quot;형식입니다. 호스트는 리터럴 IP 주소이거나 영역이있는 리터럴 IPv6 주소 여야합니다. &quot;0&quot;또는 &quot;255&quot;와 같이 잘 알려지지 않은 프로토콜 번호로 운영 체제가 작동하는 방식은 각 운영 체제에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a986939ec86bd91233d7b82449d187d316efcfcb" translate="yes" xml:space="preserve">
          <source>For POST, PUT, and PATCH requests, it also parses the request body as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form.</source>
          <target state="translated">POST, PUT 및 PATCH 요청의 경우 요청 본문을 양식으로 구문 분석하고 결과를 r.PostForm 및 r.Form에 모두 넣습니다. 요청 본문 매개 변수는 r.Form의 URL 쿼리 문자열 값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="961435f4e8342868021020dbf9e49c6cd0fb855a" translate="yes" xml:space="preserve">
          <source>For TCP and UDP networks, the address has the form &quot;host:port&quot;. The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in &quot;[2001:db8::1]:80&quot; or &quot;[fe80::1%zone]:80&quot;. The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions JoinHostPort and SplitHostPort manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds.</source>
          <target state="translated">TCP 및 UDP 네트워크의 경우 주소는 &quot;host : port&quot;형식입니다. 호스트는 리터럴 IP 주소이거나 IP 주소로 확인할 수있는 호스트 이름이어야합니다. 포트는 리터럴 포트 번호 또는 서비스 이름이어야합니다. 호스트가 리터럴 IPv6 주소 인 경우 &quot;[2001 : db8 :: 1] : 80&quot;또는 &quot;[fe80 :: 1 % zone] : 80&quot;과 같이 대괄호로 묶어야합니다. 영역은 RFC 4007에 정의 된 리터럴 IPv6 주소의 범위를 지정합니다. JoinHostPort 및 SplitHostPort 기능은이 형식으로 호스트 및 포트 쌍을 조작합니다. TCP를 사용하고 호스트가 여러 IP 주소로 확인되면 Dial은 성공할 때까지 각 IP 주소를 순서대로 시도합니다.</target>
        </trans-unit>
        <trans-unit id="03c81916838d3414948e1c22f701e5ce4a3a4855" translate="yes" xml:space="preserve">
          <source>For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network &quot;tcp4&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port.</source>
          <target state="translated">TCP 네트워크의 경우, 주소 매개 변수의 호스트가 비어 있거나 리터럴 지정되지 않은 IP 주소 인 경우, 청취는 로컬 시스템의 사용 가능한 모든 유니 캐스트 및 애니 캐스트 IP 주소에서 청취합니다. IPv4 만 사용하려면 네트워크 &quot;tcp4&quot;를 사용하십시오. 주소는 호스트 이름을 사용할 수 있지만 호스트의 IP 주소 중 최대 하나에 대한 리스너를 생성하므로 권장하지 않습니다. &quot;127.0.0.1 :&quot;또는 &quot;[:: 1] : 0&quot;과 같이 주소 매개 변수의 포트가 비어 있거나 &quot;0&quot;이면 포트 번호가 자동으로 선택됩니다. 리스너의 Addr 메소드를 사용하여 선택한 포트를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc11a7bec3f66f8d391db1eaf65bf359662c3096" translate="yes" xml:space="preserve">
          <source>For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in &quot;:80&quot;, &quot;0.0.0.0:80&quot; or &quot;[::]:80&quot; for TCP and UDP, &quot;&quot;, &quot;0.0.0.0&quot; or &quot;::&quot; for IP, the local system is assumed.</source>
          <target state="translated">TCP, UDP 및 IP 네트워크의 경우 호스트가 비어 있거나 TCP 및 UDP의 경우 &quot;: 80&quot;, &quot;0.0.0.0:80&quot;또는 &quot;[::] : 80&quot;과 같이 문자가 지정되지 않은 IP 주소 인 경우 &quot;&quot; , &quot;0.0.0.0&quot;또는 &quot;::&quot;IP의 경우 로컬 시스템이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ddf19f5cd72f2d3b549235c60d91767535d03b" translate="yes" xml:space="preserve">
          <source>For UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network &quot;udp4&quot; or &quot;ip4:proto&quot;. The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or &quot;0&quot;, as in &quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen. The LocalAddr method of PacketConn can be used to discover the chosen port.</source>
          <target state="translated">UDP 및 IP 네트워크의 경우 address 매개 변수의 호스트가 비어 있거나 문자로 지정되지 않은 IP 주소 인 경우 ListenPacket은 멀티 캐스트 IP 주소를 제외하고 로컬 시스템의 사용 가능한 모든 IP 주소를 수신합니다. IPv4 만 사용하려면 네트워크 &quot;udp4&quot;또는 &quot;ip4 : proto&quot;를 사용하십시오. 주소는 호스트 이름을 사용할 수 있지만 호스트의 IP 주소 중 최대 하나에 대한 리스너를 생성하므로 권장하지 않습니다. &quot;127.0.0.1 :&quot;또는 &quot;[:: 1] : 0&quot;과 같이 주소 매개 변수의 포트가 비어 있거나 &quot;0&quot;이면 포트 번호가 자동으로 선택됩니다. PacketConn의 LocalAddr 메소드를 사용하여 선택한 포트를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aa2c0bd0a7ad04b8f9986a2d00cc56ef314d18a" translate="yes" xml:space="preserve">
          <source>For Unix networks, the address must be a file system path.</source>
          <target state="translated">Unix 네트워크의 경우 주소는 파일 시스템 경로 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6cd90d9b68fe83f1b691af955f9ccbfffd46f969" translate="yes" xml:space="preserve">
          <source>For a description of the testing flags, see &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Testing_flags&quot;&gt;https://golang.org/cmd/go/#hdr-Testing_flags&lt;/a&gt;</source>
          <target state="translated">테스트 플래그에 대한 설명은 &lt;a href=&quot;https://golang.org/cmd/go/#hdr-Testing_flags&quot;&gt;https://golang.org/cmd/go/#hdr-Testing_flags를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="73db7630962b7d9bfe80901d992afe02ab8d444e" translate="yes" xml:space="preserve">
          <source>For a more concise way to create NamedArg values, see the Named function.</source>
          <target state="translated">NamedArg 값을 작성하는보다 간결한 방법은 Named 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e93a7b63c6c1c22251cdfa7d2125bbcb4c1d807" translate="yes" xml:space="preserve">
          <source>For a study of the facility in action, visit</source>
          <target state="translated">실제 시설에 대한 연구는 다음을 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="ea8b0e15d8c10094163cd876f62393b64628d456" translate="yes" xml:space="preserve">
          <source>For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.</source>
          <target state="translated">AfterFunc (d, f)로 생성 된 타이머의 경우, t.Stop이 false를 반환하면 타이머가 이미 만료되고 함수 f가 자체 고 루틴에서 시작된 것입니다. Stop은 f가 완료되기를 기다렸다가 돌아갑니다. 호출자가 f가 완료되었는지 여부를 알아야하는 경우 명시 적으로 f와 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="adbed43366f7734c782e1358f999b46beb1e3fca" translate="yes" xml:space="preserve">
          <source>For a tutorial, see &lt;a href=&quot;https://golang.org/s/types-tutorial&quot;&gt;https://golang.org/s/types-tutorial&lt;/a&gt;.</source>
          <target state="translated">튜토리얼은 &lt;a href=&quot;https://golang.org/s/types-tutorial&quot;&gt;https://golang.org/s/types-tutorial을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e18ade19ed4a3115a9d9e3c880c80a5a49514530" translate="yes" xml:space="preserve">
          <source>For all requests, ParseForm parses the raw query from the URL and updates r.Form.</source>
          <target state="translated">모든 요청에 ​​대해 ParseForm은 URL에서 원시 쿼리를 구문 분석하고 r.Form을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="a78bb4acd6502d15dc3957871fac3c0be9d9b00b" translate="yes" xml:space="preserve">
          <source>For an abstract method, Recv returns the enclosing interface either as a *Named or an *Interface. Due to embedding, an interface may contain methods whose receiver type is a different interface.</source>
          <target state="translated">추상 메소드의 경우 Recv는 둘러싸는 인터페이스를 * Named 또는 * Interface로 리턴합니다. 임베딩으로 인해 인터페이스에 수신자 유형이 다른 메소드가 포함 된 인터페이스가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e330719ad337b4c9602641929cab60cae09925d" translate="yes" xml:space="preserve">
          <source>For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="translated">발신 클라이언트 요청의 경우 컨텍스트는 요청의 전체 수명과 응답을 제어합니다. 연결 확보, 요청 전송 및 응답 헤더 및 본문 읽기.</target>
        </trans-unit>
        <trans-unit id="d8c341cebb2371fc4554d9fb0c6e54c2c5900936" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit.</source>
          <target state="translated">밑줄 0의 경우 밑줄 문자&amp;ldquo;_&amp;rdquo;는 밑말과 인접 숫자 사이 및 연속 숫자 사이에 나타날 수 있습니다. 이러한 밑줄은 숫자 값 또는 반환 된 숫자 수를 변경하지 않습니다. 다른 오류가없는 경우 밑줄을 잘못 배치하면 오류로보고됩니다. base! = 0이면 밑줄이 인식되지 않으므로 유효한 기수 포인트 또는 숫자가 아닌 다른 문자처럼 스캔을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="e5942b37cf590ae4aabd1b760f075ef90fd1c294" translate="yes" xml:space="preserve">
          <source>For base 0, an underscore character &amp;ldquo;_&amp;rdquo; may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and act like any other character that is not a valid digit.</source>
          <target state="translated">밑줄 0의 경우 밑줄 문자&amp;ldquo;_&amp;rdquo;는 밑말과 인접 숫자 사이 및 연속 숫자 사이에 나타날 수 있습니다. 이러한 밑줄은 숫자 값을 변경하지 않습니다. 다른 오류가없는 경우 밑줄을 잘못 배치하면 오류로보고됩니다. base! = 0이면 밑줄이 인식되지 않으며 유효한 숫자가 아닌 다른 문자처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5f1ac8df1f8e77c9fdc27bc0637f8b872484b6a1" translate="yes" xml:space="preserve">
          <source>For base 0, the number prefix determines the actual base: A prefix of &amp;ldquo;0b&amp;rdquo; or &amp;ldquo;0B&amp;rdquo; selects base 2, &amp;ldquo;0o&amp;rdquo; or &amp;ldquo;0O&amp;rdquo; selects base 8, and &amp;ldquo;0x&amp;rdquo; or &amp;ldquo;0X&amp;rdquo; selects base 16. Otherwise, the actual base is 10 and no prefix is accepted. The octal prefix &quot;0&quot; is not supported (a leading &quot;0&quot; is simply considered a &quot;0&quot;).</source>
          <target state="translated">기수 0의 경우, 숫자 접두사는 실제 밑을 결정합니다. &quot;0b&quot;또는 &quot;0B&quot;의 접두사는 기수 2를 선택하고, &quot;0o&quot;또는 &quot;0O&quot;는 기수 8을 선택하고 &quot;0x&quot;또는 &quot;0X&quot;는 기저 16을 선택합니다. 실제 기준은 10이며 접두사는 허용되지 않습니다. 8 진 접두사 &quot;0&quot;은 지원되지 않습니다 (앞의 &quot;0&quot;은 단순히 &quot;0&quot;으로 간주 됨).</target>
        </trans-unit>
        <trans-unit id="8da96f7777bef60314c708eb513a45527fc86e1a" translate="yes" xml:space="preserve">
          <source>For bases &amp;lt;= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases &amp;gt; 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61.</source>
          <target state="translated">밑줄 &amp;lt;= 36의 경우 소문자와 대문자는 동일한 것으로 간주됩니다. 문자 'a'~ 'z'및 'A'~ 'Z'는 숫자 값 10 ~ 35를 나타냅니다. 밑줄&amp;gt; 36의 경우 대문자 ' A '내지'Z '는 숫자 값 36 내지 61을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="1cda30f1e34e7fc3ab26bca0abe9bc827de94de0" translate="yes" xml:space="preserve">
          <source>For calls ForCompiler with a new FileSet.</source>
          <target state="translated">새로운 FileSet으로 ForCompiler를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7777ccd24b8bd654eee8980ccc52774364f6122b" translate="yes" xml:space="preserve">
          <source>For compatibility with Go 1.0, Symbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="translated">Go 1.0과의 호환성을 위해 Symbols는 인덱스 0에서 널 기호를 생략합니다. 기호를 symtab으로 검색 한 후 외부에서 제공되는 인덱스 x는 symtab [x]가 아니라 symtab [x-1]에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="bd3f39afacd60fc39b35ccda1637af8ff2e8c205" translate="yes" xml:space="preserve">
          <source>For compatibility with Symbols, DynamicSymbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x].</source>
          <target state="translated">기호와의 호환성을 위해 DynamicSymbols는 인덱스 0에서 널 기호를 생략합니다. 기호를 symtab으로 검색 한 후 외부에서 제공되는 인덱스 x는 symtab [x]가 아닌 symtab [x-1]에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ceff07027a0562aae7bcfc8fafd438b3054bb3ea" translate="yes" xml:space="preserve">
          <source>For complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).</source>
          <target state="translated">복소수의 경우 너비와 정밀도가 두 구성 요소에 독립적으로 적용되고 결과는 괄호로 묶어 1.2 + 3.4i에 적용되는 % f는 (1.200000 + 3.400000i)를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9b540b6ad368c9fd7ce41d2cd5a4983671593e81" translate="yes" xml:space="preserve">
          <source>For compound objects, the elements are printed using these rules, recursively, laid out like this:</source>
          <target state="translated">복합 객체의 경우 요소는 다음과 같은 규칙으로 재귀 적으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="33fb692c25f138c6447e3086029bcccc81bc7da5" translate="yes" xml:space="preserve">
          <source>For compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.</source>
          <target state="translated">슬라이스 및 구조체와 같은 복합 피연산자의 경우 형식은 피연산자 전체가 아닌 재귀 적으로 각 피연산자의 요소에 적용됩니다. 따라서 % q는 문자열 조각의 각 요소를 인용하고 % 6.2f는 부동 소수점 배열의 각 요소에 대한 서식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5cab5826d638fdbcb2ad7a5200731c473b3d7274" translate="yes" xml:space="preserve">
          <source>For control over HTTP client headers, redirect policy, and other settings, create a Client:</source>
          <target state="translated">HTTP 클라이언트 헤더, 리디렉션 정책 및 기타 설정을 제어하려면 클라이언트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d0c2ce00eb37f48324b8088e1562b15a52ee733a" translate="yes" xml:space="preserve">
          <source>For control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport:</source>
          <target state="translated">프록시, TLS 구성, 연결 유지, 압축 및 기타 설정을 제어하려면 전송을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="993c8adfef972ba1b068a5731b030b2c3e0c3fdb" translate="yes" xml:space="preserve">
          <source>For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the File.Comments list) or moved accordingly (by updating their positions). A CommentMap may be used to facilitate some of these operations.</source>
          <target state="translated">주석이 포함 된 소스 코드를 올바르게 인쇄하려면 (패키지 go / format 및 go / printer 사용) 파일의 구문 트리가 수정 될 때 주석을 업데이트 할 때 특히주의해야합니다. 인쇄시 주석은 위치에 따라 토큰 사이에 산재됩니다. 구문 트리 노드가 제거되거나 이동되면 근처에있는 관련 주석도 제거하거나 (File.Comments 목록에서) 위치를 업데이트하여 적절히 이동해야합니다. 이러한 작업 중 일부를 용이하게하기 위해 CommentMap을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="483fb4b25526c306ca9ffc7060d999d1af757359" translate="yes" xml:space="preserve">
          <source>For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().</source>
          <target state="translated">디버깅을 위해 t.String의 결과에는 단조로운 시계 판독 값이 포함됩니다. 단조로운 시계 판독 값으로 인해 t! = u이면 t.String () 및 u.String ()을 인쇄 할 때 해당 차이가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c8abfac368bfa911449148a175097af24838350b" translate="yes" xml:space="preserve">
          <source>For each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand. Another variant Println inserts blanks between operands and appends a newline.</source>
          <target state="translated">각 Printf와 같은 함수에는 형식을 취하지 않고 모든 피연산자에 대해 % v를 말하는 것과 동일한 Print 함수도 있습니다. 또 다른 변형 인 Println은 피연산자 사이에 공백을 삽입하고 개행을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="0691fc88626f896c5b4d0c9d21eb150c4440f732" translate="yes" xml:space="preserve">
          <source>For example, a client might run a HELP command that returns a dot-body by using:</source>
          <target state="translated">예를 들어, 클라이언트는 다음을 사용하여 도트 바디를 반환하는 HELP 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2c85d01a63eaf87fca388b5018e0aae0a907e1f" translate="yes" xml:space="preserve">
          <source>For example, a plugin defined as</source>
          <target state="translated">예를 들어 플러그인은</target>
        </trans-unit>
        <trans-unit id="b604de3a3134fd6e14b1dedf12ca2289afcd00f8" translate="yes" xml:space="preserve">
          <source>For example, assume that we decided to froth milk, extract coffee, and mix milk and coffee in separate goroutines. With a task, the trace tool can identify the goroutines involved in a specific cappuccino order.</source>
          <target state="translated">예를 들어, 우유 거품을 내고 커피를 추출하고 우유와 커피를 별도의 고 루틴으로 혼합하기로 결정했다고 가정합니다. 작업을 통해 추적 도구는 특정 카푸치노 순서와 관련된 고 루틴을 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb2f502c06edd8d48f9eb402147b9d0d02234fdf" translate="yes" xml:space="preserve">
          <source>For example, consider this input:</source>
          <target state="translated">예를 들어 다음 입력을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4c08416096093138a9f21f98db3e35296861799a" translate="yes" xml:space="preserve">
          <source>For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</source>
          <target state="translated">예를 들어, p가 파일 디스크립터 d를 포함하는 구조체를 가리키고 p에 해당 파일 디스크립터를 닫는 종료자가 있고 함수에서 p를 마지막으로 사용한 것이 syscall.Write (pd, buf, size) 인 경우 )이면 프로그램이 syscall.Write에 들어가 자마자 p에 도달 할 수 없습니다. 종료자는 그 시점에서 pd를 닫아 syscall.Write가 닫힌 파일 설명자 (또는 다른 goroutine에 의해 열린 완전히 다른 파일 설명자에 쓰기 때문에)에 실패하여 실행될 수 있습니다. 이 문제를 피하려면 syscall.Write를 호출 한 후 runtime.KeepAlive (p)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="648df35862f0618dac59c24e1f3c2197d967fa5c" translate="yes" xml:space="preserve">
          <source>For example, pre-submit checks that use this package directly would behave differently depending on what Go version each developer uses, causing the check to be inherently fragile.</source>
          <target state="translated">예를 들어,이 패키지를 직접 사용하는 사전 제출 검사는 각 개발자가 사용하는 Go 버전에 따라 다르게 작동하여 검사가 본질적으로 취약합니다.</target>
        </trans-unit>
        <trans-unit id="b70afa30fe71b5984e96c509da8feab3dc9a6c66" translate="yes" xml:space="preserve">
          <source>For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:</source>
          <target state="translated">예를 들어,이 코드는 작업 시간이 초과되는 동안 벽시계가 변경 되더라도 항상 약 20 밀리 초의 양의 경과 시간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b900be25452bfa919448d61bc68d11256350e2d5" translate="yes" xml:space="preserve">
          <source>For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.</source>
          <target state="translated">부동 소수점 값의 경우 너비는 필드의 최소 너비를 설정하고 정밀도는 소수점 이하 자릿수를 설정합니다 (해당되는 경우). % g / % G 정밀도의 경우 최대 유효 자릿수를 설정합니다 (트레일 링 0 제거). . 예를 들어, 12.345가 지정되면 % 6.3f 형식은 12.345를 인쇄하고 % .3g는 12.3을 인쇄합니다. % e, % f 및 % # g의 기본 정밀도는 6입니다. % g의 경우 값을 고유하게 식별하는 데 필요한 최소 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="8acb9c872d25848ac32729a8857f27d0fe460ece" translate="yes" xml:space="preserve">
          <source>For forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving.</source>
          <target state="translated">호환성을 위해 Reader.Next에서 헤더를 검색하는 사용자는 몇 가지 방법으로 헤더를 변경 한 다음 Writer로 다시 전달합니다 .WriteHeader는 새 헤더를 만들고 보존하려는 필드를 복사하여이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4409a51b04b7b882dd788481aa8d78b52daf5f6" translate="yes" xml:space="preserve">
          <source>For higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type.</source>
          <target state="translated">쿠키 및 리디렉션 처리와 같은 높은 수준의 HTTP 클라이언트 지원은 Get, Post 및 Client 유형을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ccf573cb88fa50261bc0cb844250e5c546113d3a" translate="yes" xml:space="preserve">
          <source>For incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns.</source>
          <target state="translated">들어오는 서버 요청의 경우 클라이언트의 연결이 닫히거나 요청이 취소되거나 (HTTP / 2 사용) 또는 ServeHTTP 메서드가 반환 될 때 컨텍스트가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc897ff158a8e45243f9b229fc5329d56c63ca4" translate="yes" xml:space="preserve">
          <source>For information about UTF-8 strings in Go, see &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings&lt;/a&gt;.</source>
          <target state="translated">Go의 UTF-8 문자열에 대한 정보는 &lt;a href=&quot;https://blog.golang.org/strings&quot;&gt;https://blog.golang.org/strings를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="63fe9b03e1c707dfe354f7496b7b0ea1047361fe" translate="yes" xml:space="preserve">
          <source>For instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:</source>
          <target state="translated">예를 들어, NewInt (x)는 int64 인수 x의 값으로 * Int 세트를 리턴하고 NewRat (a, b)는 a / b의 분수 a / b로 * Rat 세트를 리턴합니다. 여기서 a와 b는 int64 값이며 NewFloat (f )는 float64 인수 f로 초기화 된 * Float를 리턴합니다. 예를 들어 다음과 같은 명시 적 설정기로 더 많은 유연성이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ef36fa9bc6685ceb9dbf97a5a5da2cffd6025d4b" translate="yes" xml:space="preserve">
          <source>For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] &amp;gt;= 23 }) returns the smallest index i such that data[i] &amp;gt;= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately.</source>
          <target state="translated">예를 들어, 오름차순으로 정렬 된 슬라이스 데이터가 주어지면 Search (len (data), func (i int) bool {return data [i]&amp;gt; = 23}) 호출은 data [i]&amp;gt; = 23. 호출자가 23이 슬라이스에 있는지 여부를 찾으려면 데이터 [i] == 23을 별도로 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7dfa4cd456b849ced74b774ac752b76885a540c" translate="yes" xml:space="preserve">
          <source>For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:</source>
          <target state="translated">예를 들어, (* Int) .Add에 대한 인수는 x와 y로 이름이 지정되며 수신자는 결과 대상을 지정하므로 z라고합니다.</target>
        </trans-unit>
        <trans-unit id="8f07f1d3d8e7f6b87f995e34e12a6b2b7256d6aa" translate="yes" xml:space="preserve">
          <source>For instance, when executing the template whose source is</source>
          <target state="translated">예를 들어 소스가</target>
        </trans-unit>
        <trans-unit id="6018681f8b36b5a67b809b220861a7e3eea4cf91" translate="yes" xml:space="preserve">
          <source>For more information about pprof, see &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md&lt;/a&gt;.</source>
          <target state="translated">pprof에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/google/pprof/blob/master/doc/README.md&quot;&gt;https://github.com/google/pprof/blob/master/doc/README.md를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d996431a64b6bd8bf9d3bd0300d40b96d810b5b1" translate="yes" xml:space="preserve">
          <source>For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed.</source>
          <target state="translated">더 관대 한 구문 분석을 위해 구문 오류가 발생하더라도 스캔은 가능한 경우 유효한 토큰을 반환합니다. 따라서 결과 토큰 시퀀스에 잘못된 토큰이 포함되어 있지 않더라도 클라이언트는 오류가 발생하지 않았다고 가정하지 않을 수 있습니다. 대신 스캐너의 ErrorCount 또는 오류 처리기 호출 횟수 (설치된 경우)를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee92c8f279c1f6e92caa92b507d20eceb3f7bf2a" translate="yes" xml:space="preserve">
          <source>For most Unix systems, this package has two internal implementations of resolving user and group ids to names. One is written in pure Go and parses /etc/passwd and /etc/group. The other is cgo-based and relies on the standard C library (libc) routines such as getpwuid_r and getgrnam_r.</source>
          <target state="translated">대부분의 Unix 시스템의 경우이 패키지에는 사용자 및 그룹 ID를 이름으로 해석하는 두 가지 내부 구현이 있습니다. 하나는 순수 Go로 작성되고 / etc / passwd 및 / etc / group을 구문 분석합니다. 다른 하나는 cgo 기반이며 getpwuid_r 및 getgrnam_r과 같은 표준 C 라이브러리 (libc) 루틴에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="c4cdb94c601192f951b8e3c2e58421475088397d" translate="yes" xml:space="preserve">
          <source>For most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.</source>
          <target state="translated">대부분의 값에서 너비는 출력 할 최소 룬 수이며, 필요한 경우 서식이 지정된 양식을 공백으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="515255bc358ef4ff5aa5412e1b66dcc8c403a8d9" translate="yes" xml:space="preserve">
          <source>For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V).</source>
          <target state="translated">비 인터페이스 유형 V의 경우 또는 정적이 설정된 경우 V의 모든 메소드가 V에 있으면 V가 T를 구현합니다. 그렇지 않으면 (V는 인터페이스이고 정적이 설정되지 않은 경우) MissingMethod는 존재하는 T의 메소드 만 검사합니다. V에서 일치하는 유형을 갖는다 (예를 들어, x가 인터페이스 유형 인 유형 주장 x. (T)의 경우).</target>
        </trans-unit>
        <trans-unit id="b71be130422309f072d39771550fbade7a681c88" translate="yes" xml:space="preserve">
          <source>For other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value.</source>
          <target state="translated">다른 HTTP 메소드의 경우 또는 Content-Type이 application / x-www-form-urlencoded가 아닌 경우 요청 본문을 읽지 않고 r.PostForm이 0이 아닌 빈 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="90fd7feae6eaa72525957265644b35d2d7178aab" translate="yes" xml:space="preserve">
          <source>For outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body.</source>
          <target state="translated">나가는 클라이언트 요청의 경우 컨텍스트는 요청의 전체 수명과 응답을 제어합니다. 연결 확보, 요청 전송 및 응답 헤더 및 본문 읽기.</target>
        </trans-unit>
        <trans-unit id="d9dd41b387dea5f2e387ef2638e22692d5781ada" translate="yes" xml:space="preserve">
          <source>For outgoing client requests, the context controls cancellation.</source>
          <target state="translated">발신 클라이언트 요청의 경우 컨텍스트는 취소를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a001fc47d27546732ba34a6c50953e3947ee9592" translate="yes" xml:space="preserve">
          <source>For parsing this time format, see ParseTime.</source>
          <target state="translated">이 시간 형식을 구문 분석하려면 ParseTime을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f71ccb724292b936b826fde518652933240dfacc" translate="yes" xml:space="preserve">
          <source>For portability, the status code should be in the range [0, 125].</source>
          <target state="translated">이식성을 위해 상태 코드는 [0, 125] 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf654bcdb4217ef6a979d8f651f736b1fbda2ae7" translate="yes" xml:space="preserve">
          <source>For random numbers suitable for security-sensitive work, see the crypto/rand package.</source>
          <target state="translated">보안에 민감한 작업에 적합한 난수는 crypto / rand 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8dac1d0bb1e2323543dc0dee447715c7804fe438" translate="yes" xml:space="preserve">
          <source>For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by strconv.ParseBool.</source>
          <target state="translated">* bool로 스캔하는 경우 소스는 true, false, 1, 0 또는 strconv.ParseBool로 구문 분석 가능한 문자열 입력일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22a8f63617a1059c9b07e1b34be114b05733ec0f" translate="yes" xml:space="preserve">
          <source>For simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect</source>
          <target state="translated">보다 간단한 다자간 동등성 검정의 경우 eq (만)는 두 개 이상의 인수를 허용하고 두 번째 인수와 첫 번째 인수를 비교하여 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0a480a0eda63e237a87664c806578f92d694410" translate="yes" xml:space="preserve">
          <source>For simplicity in setup, the connection is defined to understand these types a priori, as well as the basic gob types int, uint, etc. Their ids are:</source>
          <target state="translated">간단하게 설정하기 위해 기본 gob 유형 int, uint 등 이러한 유형을 우선적으로 이해하도록 연결이 정의됩니다. 해당 ID는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a1206bb6c7f79687004103bffb38cbee66ebc60" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">단순 배열 표현식과 같은 일부 인수의 경우 결과는 일정 할 수 있습니다. 자세한 내용은 Go 언어 사양의 &quot;길이 및 용량&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b73ee93bdb118cfdcf76b1431924d083213a9b9c" translate="yes" xml:space="preserve">
          <source>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification's &quot;Length and capacity&quot; section for details.</source>
          <target state="translated">문자열 리터럴 또는 간단한 배열 표현식과 같은 일부 인수의 경우 결과는 상수 일 수 있습니다. 자세한 내용은 Go 언어 사양의 &quot;길이 및 용량&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6fd5303b38861cc1f75ea4005c27f0d0e4bc73ba" translate="yes" xml:space="preserve">
          <source>For strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.</source>
          <target state="translated">그러나 문자열, 바이트 슬라이스 및 바이트 배열의 경우 정밀도는 입력의 길이 (출력의 크기가 아님)를 제한하여 필요한 경우 잘립니다. 일반적으로 룬 단위로 측정되지만 % x 또는 % X 형식으로 형식화 될 때 이러한 유형의 경우 바이트 단위로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="751d670356e91a449ec7c80c4156cc58a03922ea" translate="yes" xml:space="preserve">
          <source>For such flags, the default value is just the initial value of the variable.</source>
          <target state="translated">이러한 플래그의 경우 기본값은 변수의 초기 값입니다.</target>
        </trans-unit>
        <trans-unit id="fe319d30e4ff1d3bb9c9679e1d41b020cb9fc422" translate="yes" xml:space="preserve">
          <source>For testing: clients can set this flag to force creation of IPv6 sockets to return EAFNOSUPPORT.</source>
          <target state="translated">테스트 : 클라이언트는이 플래그를 설정하여 IPv6 소켓을 작성하여 EAFNOSUPPORT를 리턴하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0e9615cbad5d104943c88a1e426bb41d0d3626" translate="yes" xml:space="preserve">
          <source>For the compiler to recognize this pattern, the conversion must appear in the argument list:</source>
          <target state="translated">컴파일러가이 패턴을 인식하려면 변환이 인수 목록에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="13732a80c7c6067fbd8ddcc6a6ec2963b831f009" translate="yes" xml:space="preserve">
          <source>For the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on Table instead.</source>
          <target state="translated">대부분의 경우 LineTable의 메소드는 패키지의 내부 세부 사항으로 취급되어야합니다. 호출자는 대신 Table의 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="82aa2e5faa1102c849b424650d24e3f7def76f8e" translate="yes" xml:space="preserve">
          <source>For the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences:</source>
          <target state="translated">대부분이 패키지는 RFC 5322에 의해 지정되고 RFC 6532에 의해 확장 된 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9dbc53494237ff152fc67f06045073fe509d54b4" translate="yes" xml:space="preserve">
          <source>For the power-of-two exponent formats, the mantissa is printed in normalized form:</source>
          <target state="translated">2의 지수 형식의 경우 가수는 정규화 된 형식으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f64016515259f77234a6cb253ce7855821350f37" translate="yes" xml:space="preserve">
          <source>For the synchronous signals and SIGPIPE, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler.</source>
          <target state="translated">동기 신호 및 SIGPIPE의 경우 Go 런타임은 신호 처리기를 설치합니다. 기존 신호 처리기를 저장합니다. 비 Go 코드를 실행하는 동안 동기 신호가 도착하면 Go 런타임은 Go 신호 처리기 대신 기존 신호 처리기를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="cee851057097c0db5b5b8a9c0d45d60cedf064a6" translate="yes" xml:space="preserve">
          <source>For these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string.</source>
          <target state="translated">이러한 내부 이스케이프 함수의 경우 작업 파이프 라인이 nil 인터페이스 값으로 평가되면 마치 빈 문자열 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="94cdbab58de221c0845a1f0bccdc6ab6b9dfee7c" translate="yes" xml:space="preserve">
          <source>For this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline.</source>
          <target state="translated">이 트리밍의 경우 공백 문자 정의는 이동 : 공백, 가로 탭, 캐리지 리턴 및 줄 바꾸기와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c4dda3b24b75ceb8fb66edf8e6d50d204c1750ea" translate="yes" xml:space="preserve">
          <source>For unrecognized or vendor-defined attributes, Class may be ClassUnknown.</source>
          <target state="translated">인식 할 수 없거나 공급 업체 정의 속성의 경우 Class는 ClassUnknown 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c58c0bacd7ac1887ab982a2597ef55f18dc028" translate="yes" xml:space="preserve">
          <source>For usage examples, see the wiki page at &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt;.</source>
          <target state="translated">사용 예는 &lt;a href=&quot;https://golang.org/s/sqlwiki&quot;&gt;https://golang.org/s/sqlwiki&lt;/a&gt; 의 위키 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="988918abc4e75847a40cae9d31b2ff0b26774a56" translate="yes" xml:space="preserve">
          <source>ForCompiler returns an Importer for importing from installed packages for the compilers &quot;gc&quot; and &quot;gccgo&quot;, or for importing directly from the source if the compiler argument is &quot;source&quot;. In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).</source>
          <target state="translated">ForCompiler는 컴파일러 &quot;gc&quot;및 &quot;gccgo&quot;에 대해 설치된 패키지에서 가져 오거나 컴파일러 인수가 &quot;source&quot;인 경우 소스에서 직접 가져 오기 위해 임포터를 리턴합니다. 후자의 경우, 내 보낸 API가 순수 Go 소스 코드로 완전히 정의되지 않은 상황에서 가져 오기에 실패 할 수 있습니다 (패키지 API가 cgo 정의 엔티티에 의존하는 경우 유형 검사기는 해당 소스에 액세스 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="133285841cd925c282a101cb331b225c1c71812e" translate="yes" xml:space="preserve">
          <source>ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early.</source>
          <target state="translated">ForLabels는 컨텍스트에 설정된 각 레이블로 f를 호출합니다. 함수 f는 반복을 계속하려면 true를, 반복을 조기에 중지하려면 false를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="353aeb4085eb053c5afffba4c97380c4860aca38" translate="yes" xml:space="preserve">
          <source>Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name.</source>
          <target state="translated">양식은 구문 분석 된 다중 파트 양식입니다. 파일 부분은 메모리 나 디스크에 저장되며 * FileHeader의 Open 메소드를 통해 액세스 할 수 있습니다. 값 부분은 문자열로 저장됩니다. 둘 다 필드 이름으로 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="eccde56e16564dc7c7df2c5cc1796440a15f9401" translate="yes" xml:space="preserve">
          <source>FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary.</source>
          <target state="translated">FormDataContentType은이 Writer의 경계와 함께 HTTP multipart / form-data의 Content-Type을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a49e5a35587aa21155c47ca684122af3589d1687" translate="yes" xml:space="preserve">
          <source>FormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary.</source>
          <target state="translated">FormFile은 제공된 양식 키의 첫 번째 파일을 리턴합니다. 필요한 경우 FormFile은 ParseMultipartForm 및 ParseForm을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5d5c015330e69759a40946c508bd098ecc8416e4" translate="yes" xml:space="preserve">
          <source>FormName returns the name parameter if p has a Content-Disposition of type &quot;form-data&quot;. Otherwise it returns the empty string.</source>
          <target state="translated">p에 &quot;form-data&quot;유형의 Content-Disposition이있는 경우 FormName은 name 매개 변수를 리턴합니다. 그렇지 않으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="445b64c2c00e9bf0c6abebdbd962d04b7f9f105c" translate="yes" xml:space="preserve">
          <source>FormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly.</source>
          <target state="translated">FormValue는 쿼리의 명명 된 구성 요소에 대한 첫 번째 값을 반환합니다. POST 및 PUT 본문 매개 변수는 URL 쿼리 문자열 값보다 우선합니다. 필요한 경우 FormValue는 ParseMultipartForm 및 ParseForm을 호출하고 이러한 함수에서 리턴 된 오류를 무시합니다. 키가 없으면 FormValue는 빈 문자열을 반환합니다. 동일한 키의 여러 값에 액세스하려면 ParseForm을 호출 한 다음 Request.Form을 직접 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="b90d813e4920205a13e7a3e3ea46b1033f09615e" translate="yes" xml:space="preserve">
          <source>Format errors:</source>
          <target state="translated">형식 오류 :</target>
        </trans-unit>
        <trans-unit id="bd81fbee8cc623aef03682c00bd263e80dddfcaa" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details.</source>
          <target state="translated">형식은 fmt.Formatter를 구현합니다. 부동 소수점 숫자 ( 'b', 'e', ​​'E', 'f', 'F', 'g', 'G', 'x') 및 'p'에 대한 모든 일반 형식을 허용합니다. 그리고 'v'. 'p'의 해석에 대해서는 (* Float) .Text를 참조하십시오. 'v'형식은 'g'와 같이 처리됩니다. 형식은 숫자의 최소 정밀도, 출력 필드 너비, 부호 제어를위한 형식 플래그 '+'및 '', 공백 또는 제로 패딩을위한 '0'및 왼쪽 또는 오른쪽 자리 맞추기를위한 '-'지정을 지원합니다. . 자세한 내용은 fmt 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ddca00e8215628107f30d61b04b8094c67090fc1" translate="yes" xml:space="preserve">
          <source>Format implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading &quot;0x&quot; or &quot;0X&quot; for &quot;%#x&quot; and &quot;%#X&quot; respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification.</source>
          <target state="translated">형식은 fmt.Formatter를 구현합니다. 'b'(바이너리), 'o'(0 접두사가있는 8 진수), 'O'(0o 접두사가있는 8 진수), 'd'(십진법), 'x'(소문자 16 진법) 및 'X'형식을 허용합니다. (대문자 16 진). 부호 제어를위한 '+'및 '', 8 진수로 0을 시작하는 '#', 16 진수를 위해 '#', &quot;%에 대한 선행&quot;0x &quot;또는&quot;0X &quot;를 포함하여 정수 유형에 대한 전체 패키지 fmt의 형식 플래그 제품군도 지원됩니다. #x &quot;및&quot;% # X &quot;, 최소 자릿수 정밀도, 출력 필드 너비, 공백 또는 영 (0) 패딩 및 왼쪽 또는 오른쪽 자리 맞추기를위한 '-'지정.</target>
        </trans-unit>
        <trans-unit id="81a5476108fadb465e67c178e260599d04ddc2e8" translate="yes" xml:space="preserve">
          <source>Format represents the tar archive format.</source>
          <target state="translated">형식은 tar 아카이브 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8d4885fbdac6d0d14accf79b985b4ce78e6bdd62" translate="yes" xml:space="preserve">
          <source>Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be</source>
          <target state="translated">형식은 레이아웃에 따라 형식이 지정된 시간 값의 텍스트 표현을 반환합니다.이 값은 참조 시간이 정의 된 방식을 보여줌으로써 형식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b3ee515426820c27b536513d4c839dfeda89b51d" translate="yes" xml:space="preserve">
          <source>FormatBool</source>
          <target state="translated">FormatBool</target>
        </trans-unit>
        <trans-unit id="1b75ed131650db00babc41765f3ab4d40a495482" translate="yes" xml:space="preserve">
          <source>FormatBool returns &quot;true&quot; or &quot;false&quot; according to the value of b.</source>
          <target state="translated">FormatBool은 b 값에 ​​따라 &quot;true&quot;또는 &quot;false&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6afd52cbbbdc2288edb941b965e52c2fc0f3f529" translate="yes" xml:space="preserve">
          <source>FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</source>
          <target state="translated">FormatBool, FormatFloat, FormatInt 및 FormatUint는 값을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cf02981ef6c41fa3e9a421259a94865e8c2df157" translate="yes" xml:space="preserve">
          <source>FormatError is returned by some operations if the data does not have the correct format for an object file.</source>
          <target state="translated">데이터에 오브젝트 파일에 대한 올바른 형식이없는 경우 일부 조작에서 FormatError가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9be4c97132e0f61e257dba73681e0455cf421f26" translate="yes" xml:space="preserve">
          <source>FormatError is unused. The type is retained for compatibility.</source>
          <target state="translated">FormatError는 사용되지 않습니다. 호환성을 위해 유형이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="66155c8335bf85f47e7201829386a88e599875d5" translate="yes" xml:space="preserve">
          <source>FormatFloat</source>
          <target state="translated">FormatFloat</target>
        </trans-unit>
        <trans-unit id="8ab806a123a3e3bc36a09fdd9698930a4aafbfb9" translate="yes" xml:space="preserve">
          <source>FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).</source>
          <target state="translated">FormatFloat는 fmt 및 정밀도 prec 형식에 따라 부동 소수점 숫자 f를 문자열로 변환합니다. 원본이 bitSize 비트의 부동 소수점 값 (float32의 경우 32, float64의 경우 64)에서 얻은 것으로 가정하여 결과를 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="54acac612d12c84fbb587187170a9d2f5002e9e1" translate="yes" xml:space="preserve">
          <source>FormatInt</source>
          <target state="translated">FormatInt</target>
        </trans-unit>
        <trans-unit id="ac942d8c471010cc2511b6465b29a4a4eaf7e487" translate="yes" xml:space="preserve">
          <source>FormatInt returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatInt는 2 &amp;lt;= base &amp;lt;= 36에 대해 주어진 밑에서 i의 문자열 표현을 리턴합니다. 결과는 숫자 값&amp;gt; = 10에 대해 소문자 'a'에서 'z'를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7ffe85b478b1a8a795e300c5a2b13589a4aacd1b" translate="yes" xml:space="preserve">
          <source>FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.</source>
          <target state="translated">FormatMediaType은 미디어 유형 t와 매개 변수 param을 RFC 2045 및 RFC 2616을 따르는 미디어 유형으로 직렬화합니다. 유형 및 매개 변수 이름은 소문자로 작성됩니다. 인수 중 하나라도 표준 위반이 발생하면 FormatMediaType은 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="457b9a9d61506e909562e056e83daf32584b6e03" translate="yes" xml:space="preserve">
          <source>FormatUint</source>
          <target state="translated">FormatUint</target>
        </trans-unit>
        <trans-unit id="29e428f2dcc8699c0417730387a64fac7ddd1961" translate="yes" xml:space="preserve">
          <source>FormatUint returns the string representation of i in the given base, for 2 &amp;lt;= base &amp;lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &amp;gt;= 10.</source>
          <target state="translated">FormatUint는 2 &amp;lt;= base &amp;lt;= 36에 대해 주어진 밑에서 i의 문자열 표현을 리턴합니다. 결과는 숫자 값&amp;gt; = 10에 대해 소문자 'a'에서 'z'를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="74de65e787a3b1e89f96cc3e3b260c1d5a19f78c" translate="yes" xml:space="preserve">
          <source>Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output.</source>
          <target state="translated">포맷터는 사용자 정의 포맷터를 사용하여 값으로 구현되는 인터페이스입니다. Format의 구현은 Sprint (f) 또는 Fprint (f) 등을 호출하여 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a818c703590da441ab8fb9d8bac8b6144c0764" translate="yes" xml:space="preserve">
          <source>Formatting can be controlled with these flags.</source>
          <target state="translated">이 플래그를 사용하여 형식을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a6bd1d5df471e18e5ef09488e671afbb943a27" translate="yes" xml:space="preserve">
          <source>Fprint</source>
          <target state="translated">Fprint</target>
        </trans-unit>
        <trans-unit id="8c8522f1e4d59e7911ef9e37ddbccae99dbf77c6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.</source>
          <target state="translated">Fprint는 지정된 구성 cfg에 대해 출력하기 위해 AST 노드를 &quot;pretty-prints&quot;합니다. 위치 정보는 파일 세트 fset을 기준으로 해석됩니다. 노드 유형은 * ast.File, * CommentedNode, [] ast.Decl, [] ast.Stmt이거나 ast.Expr, ast.Decl, ast.Spec 또는 ast.Stmt와 지정 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8a539386d013173d33a590058d75eefbdb15fa6" translate="yes" xml:space="preserve">
          <source>Fprint &quot;pretty-prints&quot; an AST node to output. It calls Config.Fprint with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt.</source>
          <target state="translated">Fprint는 출력 할 AST 노드를 &quot;예쁜 인쇄&quot;합니다. 기본 설정으로 Config.Fprint를 호출합니다. gofmt는 들여 쓰기에는 탭을 사용하지만 정렬에는 공백을 사용합니다. gofmt와 일치하는 출력에 format.Node (패키지 go / format)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="104c28c9f2550f07e8ce3bfa8162280f3f8c80ca" translate="yes" xml:space="preserve">
          <source>Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">피연산자에 대한 기본 형식을 사용하여 Fprint 형식을 지정하고 w에 씁니다. 문자열이 아닌 경우 피연산자 사이에 공백이 추가됩니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a536bd9e7bf91ae60cda20d0ea5db515bbd6c7b" translate="yes" xml:space="preserve">
          <source>Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).</source>
          <target state="translated">Fprint는 AST 노드 x에서 w로 시작하는 (하위) 트리를 인쇄합니다. fset! = nil 인 경우 위치 정보는 해당 파일 세트를 기준으로 해석됩니다. 그렇지 않으면 위치는 정수 값으로 인쇄됩니다 (파일 세트 특정 오프셋).</target>
        </trans-unit>
        <trans-unit id="d20e1fe41e4983b3d1227303d39b1a75b7115f30" translate="yes" xml:space="preserve">
          <source>Fprintf</source>
          <target state="translated">Fprintf</target>
        </trans-unit>
        <trans-unit id="a13c0d787117a7941cdce4981a12d040db7f0953" translate="yes" xml:space="preserve">
          <source>Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">Fprintf는 형식 지정자에 따라 형식을 지정하고 w에 씁니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46197102442051b0256d5e8d44d3fa71b3e0ca3a" translate="yes" xml:space="preserve">
          <source>Fprintln</source>
          <target state="translated">Fprintln</target>
        </trans-unit>
        <trans-unit id="b390d66055f3fb09a9893ca4c02d4466e93e9f7e" translate="yes" xml:space="preserve">
          <source>Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</source>
          <target state="translated">피연산자에 대한 기본 형식을 사용하여 Fprintln 형식을 지정하고 w에 씁니다. 피연산자 사이에 공백이 항상 추가되고 줄 바꾸기가 추가됩니다. 쓴 바이트 수와 발생한 쓰기 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c52284236b3cbc2d437f96673b062717eea95c7a" translate="yes" xml:space="preserve">
          <source>Frame is the information returned by Frames for each call frame.</source>
          <target state="translated">프레임은 각 호출 프레임에 대해 프레임이 반환하는 정보입니다.</target>
        </trans-unit>
        <trans-unit id="e3e7a3833d19706ebf33b2c3baf8e05deeed7bca" translate="yes" xml:space="preserve">
          <source>Frames</source>
          <target state="translated">Frames</target>
        </trans-unit>
        <trans-unit id="6a32e149e9d6773e4f6967f48bf708bb90588f99" translate="yes" xml:space="preserve">
          <source>Frames may be used to get function/file/line information for a slice of PC values returned by Callers.</source>
          <target state="translated">프레임은 호출자가 리턴 한 PC 값 조각에 대한 기능 / 파일 / 라인 정보를 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="971e42ae8bcc68c1d3c0b0b0f45fd394dc7d0afe" translate="yes" xml:space="preserve">
          <source>FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)</source>
          <target state="translated">FreeOSMemory는 가비지 콜렉션을 강제 실행 한 후 가능한 많은 양의 메모리를 운영 체제에 리턴하려고 시도합니다. (이것이 호출되지 않더라도 런타임은 백그라운드 작업에서 점차적으로 메모리를 운영 체제에 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="2d6c189d92419208a8893cd5a97e05687d681927" translate="yes" xml:space="preserve">
          <source>Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac &amp;times; 2**exp, with the absolute value of frac in the interval [&amp;frac12;, 1).</source>
          <target state="translated">Frexp는 f를 정규화 된 분수와 2의 적분으로 나눕니다. 간격 [&amp;frac12;, 1)에서 frac의 절대 값과 함께 f == frac &amp;times; 2 ** exp를 만족하는 frac 및 exp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa23c274e14dd5cc1e7fa9a8a9b29bf34200b44f" translate="yes" xml:space="preserve">
          <source>FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.</source>
          <target state="translated">FromSlash는 경로의 각 슬래시 ( '/') 문자를 구분 문자로 바꾼 결과를 리턴합니다. 여러 개의 슬래시는 여러 구분 기호로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="164e0e9caa51bad7048b8f096c49d9b2c2ab5e89" translate="yes" xml:space="preserve">
          <source>Front returns the first element of list l or nil if the list is empty.</source>
          <target state="translated">Front는 목록 l의 첫 번째 요소를 반환하거나 목록이 비어 있으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52c1852fe9f31cf9deb2025a2022f1fc079a5aee" translate="yes" xml:space="preserve">
          <source>Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.</source>
          <target state="translated">Fscan은 r에서 읽은 텍스트를 스캔하여 연속 공백으로 구분 된 값을 연속 인수에 저장합니다. 줄 바꿈은 공백으로 계산됩니다. 성공적으로 스캔 한 항목 수를 반환합니다. 그것이 인수의 수보다 적 으면, err가 이유를보고합니다.</target>
        </trans-unit>
        <trans-unit id="554810832552956da9a7da2eee0a73593dca23e7" translate="yes" xml:space="preserve">
          <source>Fscanf</source>
          <target state="translated">Fscanf</target>
        </trans-unit>
        <trans-unit id="8bd3b6e023a616305dbe6b056ba1a191e7adb603" translate="yes" xml:space="preserve">
          <source>Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.</source>
          <target state="translated">Fscanf는 r에서 읽은 텍스트를 스캔하여 형식에 의해 결정된대로 연속 공백으로 구분 된 값을 연속 인수로 저장합니다. 성공적으로 구문 분석 된 항목 수를 반환합니다. 입력의 개행은 형식의 개행과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="24ce0d47eda270ec1be1d5faf6933fc84f496fc9" translate="yes" xml:space="preserve">
          <source>Fscanln</source>
          <target state="translated">Fscanln</target>
        </trans-unit>
        <trans-unit id="6ba607f7da03e13291dee0bc0511128cd6a13033" translate="yes" xml:space="preserve">
          <source>Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF.</source>
          <target state="translated">Fscanln은 Fscan과 비슷하지만 줄 바꿈에서 스캔을 중지하며 마지막 항목 뒤에 줄 바꿈 또는 EOF가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="18339496bb65d9199e22c7756d8d353de7e08bb1" translate="yes" xml:space="preserve">
          <source>FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead.</source>
          <target state="translated">FullName은 기호 sym의 실제 이름을 찾습니다. 일반적으로 name은 sym.Name에 저장되지만 8자를 초과하면 COFF 문자열 테이블 st에 대신 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7902524eb980d3f158a430d41566b78e54c0f4a8" translate="yes" xml:space="preserve">
          <source>FullName returns the package- or receiver-type-qualified name of function or method obj.</source>
          <target state="translated">FullName은 패키지 또는 수신자 유형의 규정 된 함수 또는 메소드 obj 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b3483c701e937232d5e060b21f7fb965b230aa71" translate="yes" xml:space="preserve">
          <source>FullRune</source>
          <target state="translated">FullRune</target>
        </trans-unit>
        <trans-unit id="81aa0878662ea86cc86d82ed1ab7992029d672d9" translate="yes" xml:space="preserve">
          <source>FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.</source>
          <target state="translated">FullRune은 p의 바이트가 룬의 전체 UTF-8 인코딩으로 시작하는지 여부를보고합니다. 너비가 1 인 오류 룬으로 변환되므로 유효하지 않은 인코딩은 전체 룬으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e05115514df90c085c4af490f89158b561b0d92c" translate="yes" xml:space="preserve">
          <source>FullRuneInString</source>
          <target state="translated">FullRuneInString</target>
        </trans-unit>
        <trans-unit id="95812f07b4917317402c5d2167338a188da0ce79" translate="yes" xml:space="preserve">
          <source>FullRuneInString is like FullRune but its input is a string.</source>
          <target state="translated">FullRuneInString은 FullRune과 유사하지만 입력은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="279955fd7d680432dfab90fbe069c9bfd8dc8495" translate="yes" xml:space="preserve">
          <source>Func implements Var by calling the function and formatting the returned value using JSON.</source>
          <target state="translated">Func는 함수를 호출하고 JSON을 사용하여 반환 된 값의 형식을 지정하여 Var을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="524a0d206f4cbf19e946f5d4ed3f42690d7a8676" translate="yes" xml:space="preserve">
          <source>Func is a wrapped Go function to be called by JavaScript.</source>
          <target state="translated">Func는 JavaScript에 의해 호출되는 래핑 된 Go 함수입니다.</target>
        </trans-unit>
        <trans-unit id="9f43fd9d5faa1fad98bda7488e8199738c579a5f" translate="yes" xml:space="preserve">
          <source>Func is the documentation for a func declaration.</source>
          <target state="translated">Func는 func 선언에 대한 문서입니다.</target>
        </trans-unit>
        <trans-unit id="1428a5974ab9a5d9bb8050c81e92e9a085606a0b" translate="yes" xml:space="preserve">
          <source>Func values are deeply equal if both are nil; otherwise they are not deeply equal.</source>
          <target state="translated">둘 다 0이 아닌 경우 함수 값은 매우 같습니다. 그렇지 않으면 그들은 깊이 평등하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b4c67efe336d8800eb50760aa412d1cd7318a96" translate="yes" xml:space="preserve">
          <source>Func.Release must be called to free up resources when the function will not be used any more.</source>
          <target state="translated">함수가 더 이상 사용되지 않을 때 자원을 확보하려면 Func.Release를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="79c0844aa92a7c85df75b63db88d3ac85acf1947" translate="yes" xml:space="preserve">
          <source>FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil.</source>
          <target state="translated">FuncForPC는 주어진 프로그램 카운터 주소 또는 nil을 포함하는 함수를 설명하는 * Func를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f873cfa96e723fb817cda8756e298acee836d4d" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) argument evaluates to non-nil during execution, execution terminates and Execute returns that error. FuncMap has the same base type as FuncMap in &quot;text/template&quot;, copied here so clients need not import &quot;text/template&quot;.</source>
          <target state="translated">FuncMap은 이름에서 함수로의 맵핑을 정의하는 맵 유형입니다. 각 함수에는 단일 반환 값이 있거나 두 번째 반환 값에 두 번째 반환 유형이 있습니다. 이 경우 실행 중 두 번째 (오류) 인수가 0이 아닌 값으로 평가되면 실행이 종료되고 Execute가 해당 오류를 반환합니다. FuncMap은 &quot;text / template&quot;의 FuncMap과 동일한 기본 유형을 가지며 여기에 복사되므로 클라이언트는 &quot;text / template&quot;을 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c663a8fdf1b0c07a4b3a9bf988b2301d91e56916" translate="yes" xml:space="preserve">
          <source>FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.</source>
          <target state="translated">FuncMap은 이름에서 함수로의 맵핑을 정의하는 맵 유형입니다. 각 함수에는 단일 반환 값이 있거나 두 번째 반환 값에 두 번째 반환 유형이 있습니다. 이 경우 실행 중 두 번째 (오류) 반환 값이 0이 아닌 값으로 평가되면 실행이 종료되고 Execute가 해당 오류를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
