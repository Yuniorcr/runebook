<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="6194c95c25393c1533f24ca690885ddce3de29a4" translate="yes" xml:space="preserve">
          <source>If you want a map with only the selected fields to be returned. For more information, read the docs for &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt;&lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.query.api#map/2&quot;&gt;&lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택한 필드 만있는 맵을 반환하려는 경우. 자세한 정보는 &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt; &lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ecto.query.api#map/2&quot;&gt; &lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt; &lt;/a&gt; 문서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b56c7f334ac00fd6eb86d51a4d425fe63a22845f" translate="yes" xml:space="preserve">
          <source>If you want the boolean attribute to be sent as is, you can explicitly convert it to a string before.</source>
          <target state="translated">부울 속성을 그대로 보내려면이를 명시 적으로 문자열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71958648bc2ee1d3c516f077771f912b56470ab5" translate="yes" xml:space="preserve">
          <source>If you want to configure the years range:</source>
          <target state="translated">연도 범위를 구성하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="3267ec97b69bd134a5f100a8b20b7af9c4d6bdb9" translate="yes" xml:space="preserve">
          <source>If you want to have functions that manipulate the connection without fully implementing the controller, you can import both modules directly instead of &lt;code&gt;use Phoenix.Controller&lt;/code&gt;.</source>
          <target state="translated">컨트롤러를 완전히 구현하지 않고 연결을 조작하는 기능을 &lt;code&gt;use Phoenix.Controller&lt;/code&gt; 대신 두 모듈을 직접 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e505240a0d781b16ebb52afdcfed3cf74a91017d" translate="yes" xml:space="preserve">
          <source>If you want to include the seconds field (hidden by default), pass &lt;code&gt;second: []&lt;/code&gt;:</source>
          <target state="translated">초 필드를 포함하려면 (기본적으로 숨겨 짐) 초를 전달하십시오 &lt;code&gt;second: []&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ebd7ac9e06dec198b102f467e0d5a2146add7ac" translate="yes" xml:space="preserve">
          <source>If you want to instrument a piece of code, but the endpoint that should instrument it (the one that contains the &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro you want to use) is not known at compile time, only at runtime, you can use the &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt;&lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt;&lt;/a&gt; macro. Refer to its documentation for more information.</source>
          <target state="translated">코드를 계측하려고하지만이를 계측해야하는 엔드 포인트 ( 사용하려는 &lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt; 매크로 가 포함 된 엔드 포인트 )를 컴파일 타임에 알 수없는 경우 런타임에만 &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt; &lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다. .instrument / 4 매크로. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec5f40c77fd66ea84bc6ba36f0c2a7c3fe56b0a" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application.</source>
          <target state="translated">Ecto를 사용하여 샘플 애플리케이션을 빠르게 확인하려면 &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;시작 안내서&lt;/a&gt; 및 함께 제공되는 샘플 애플리케이션을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="78c050fecd9ef681ce1f0f4d13cfe35bf4a562b4" translate="yes" xml:space="preserve">
          <source>If you want to select an option that comes from the database, such as a manager for a given project, you may write:</source>
          <target state="translated">주어진 프로젝트의 관리자와 같이 데이터베이스에서 제공되는 옵션을 선택하려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6906d4bf644df48b3f0c419b3abf27f44bf197a2" translate="yes" xml:space="preserve">
          <source>If you would prefer to simply merge two multis together, see &lt;a href=&quot;#append/2&quot;&gt;&lt;code&gt;append/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#prepend/2&quot;&gt;&lt;code&gt;prepend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단순히 두 개의 멀티를 합치려면 &lt;a href=&quot;#append/2&quot;&gt; &lt;code&gt;append/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#prepend/2&quot;&gt; &lt;code&gt;prepend/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffa6a80acbf97635e0ac507b93d5063cd5b0d16a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you will need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-proto&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">Plug 응용 프로그램이 HTTPS를 처리하는 프록시 뒤에있는 경우 &lt;code&gt;x-forwarded-proto&lt;/code&gt; 헤더 에서 적절한 프로토콜을 구문 분석하도록 Plug에 지시해야합니다 . &lt;code&gt;:rewrite_on&lt;/code&gt; 옵션을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e64da7625aab0af6dfae19c9bbd8cef653814d79" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;code&gt;mix new&lt;/code&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application&amp;rsquo;s supervisor:</source>
          <target state="translated">응용 프로그램이 수퍼바이저로 생성 된 경우 ( &lt;code&gt;--sup&lt;/code&gt; 을 &lt;code&gt;mix new&lt;/code&gt; 로 혼합 하여 전달 ) 수퍼바이저를 정의하고 시작하는 응용 프로그램 시작 콜백이 포함 된 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 파일이 있습니다. 응용 프로그램의 수퍼바이저에서 repo를 수퍼바이저로 시작 하려면 &lt;code&gt;start/2&lt;/code&gt; 기능 만 편집하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="9963b98e0a632c06b03f38938368cd7af1095618" translate="yes" xml:space="preserve">
          <source>If your data layer supports embedding or nested associations, you can use &lt;code&gt;inputs_for&lt;/code&gt; to attach nested data to the form.</source>
          <target state="translated">데이터 계층에서 임베드 또는 중첩 연관을 지원하는 경우 &lt;code&gt;inputs_for&lt;/code&gt; 를 사용 하여 중첩 된 데이터를 양식에 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3f651a489e53e22ef5bfd5ad5ccb20a85f41ce" translate="yes" xml:space="preserve">
          <source>If your primary key is not named &amp;ldquo;id&amp;rdquo; (e.g. if you are working with a legacy database), you can use the &lt;code&gt;@primary_key&lt;/code&gt; attribute to configure your key name using the &lt;code&gt;source&lt;/code&gt; option. For example, the following attribute defines an integer primary key named &lt;code&gt;legacy_id&lt;/code&gt; which is automatically incremented by the database:</source>
          <target state="translated">기본 키의 이름이 &quot;id&quot;가 아닌 경우 (예 : 레거시 데이터베이스를 사용하는 경우) &lt;code&gt;@primary_key&lt;/code&gt; 속성을 사용하여 &lt;code&gt;source&lt;/code&gt; 옵션을 사용하여 키 이름을 구성 할 수 있습니다 . 예를 들어 다음 속성은 데이터베이스에 의해 자동으로 증가하는 &lt;code&gt;legacy_id&lt;/code&gt; 라는 정수 기본 키를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="0a69fedcf99422ab483c859e4efba05a441aa355" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unecessarily complex. Let&amp;rsquo;s see an example.</source>
          <target state="translated">Post에 많은 주석이 있고 기존 게시물에 새 주석을 추가하려는 관계를 상상해보십시오. 이를 위해 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용할 수는 있지만 불필요하게 복잡합니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="a9a80fa7e20b6ec638558d87fd5e8f1b2c820f57" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;handle_in/3&lt;/code&gt; inside a channel:</source>
          <target state="translated">채널 내부에 다음 &lt;code&gt;handle_in/3&lt;/code&gt; 을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="d7eaef0786d3c2d56724df9325bdf3c6d03a3696" translate="yes" xml:space="preserve">
          <source>Imagine the following Ecto schemas:</source>
          <target state="translated">다음 Ecto 스키마를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="69ed1238c0e40ec582e839a9be87906ea6d1bb56" translate="yes" xml:space="preserve">
          <source>Imagine the following plug:</source>
          <target state="translated">다음 플러그를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="6ca34da07d3e254b51321106a99af217f3cef8f8" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let&amp;rsquo;s imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">게시물에 연결하려는 태그 세트를 수신한다고 가정하십시오. 이러한 태그가 선결제로 존재하며 모두 데이터베이스에 유지된다고 가정 해 봅시다. 이 형식으로 데이터를 얻는다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="37ae5ef9b11c014505c58d928130e9d937a57895" translate="yes" xml:space="preserve">
          <source>Imagine you have an schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">&lt;code&gt;has_many :comments&lt;/code&gt; 연관 이있는 스키마 &lt;code&gt;Post&lt;/code&gt; 가 있고 다음 쿼리를 실행 한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="911d5cbc4bd74830db2cf2e8c805fa896d8b4ab3" translate="yes" xml:space="preserve">
          <source>Imagine you have the following action in your controller:</source>
          <target state="translated">컨트롤러에 다음과 같은 동작이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="15e74fb2e9144b4fc1c6e2f7edb9692fba7939fe" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn&amp;rsquo;t an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">URL 단축 서비스에서 스키마의 일부로 URI 구조체를 저장한다고 가정합니다. 런타임시 해당 값을 지원하기위한 Ecto 필드 유형이 없으므로 사용자 정의 유형이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dd83f3829baa0b9a2d40da3d590f7c9d0db3a5ca" translate="yes" xml:space="preserve">
          <source>Implementing a Tracker</source>
          <target state="translated">트래커 구현</target>
        </trans-unit>
        <trans-unit id="3d6c2a38d322d3d763e854f7651b3495dd090632" translate="yes" xml:space="preserve">
          <source>Implementing the transport behaviour</source>
          <target state="translated">전송 동작 구현</target>
        </trans-unit>
        <trans-unit id="058fd7ed1c45697b86ef3cd0718d7bbfbe7580e9" translate="yes" xml:space="preserve">
          <source>Implementing your own adapter</source>
          <target state="translated">자신의 어댑터 구현</target>
        </trans-unit>
        <trans-unit id="b0c929d75f4d94fd8fe1c260cbfd2b081155e7fe" translate="yes" xml:space="preserve">
          <source>In Ecto, we have three ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</source>
          <target state="translated">Ecto에서는이 문제를 해결하는 세 가지 방법이 있습니다. 가장 간단한 방법은 주석 스키마에서 각 연관마다 하나씩 여러 필드를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="382006685c4bc65202ab7101130f82fd90eb1bb5" translate="yes" xml:space="preserve">
          <source>In SQL, COALESCE takes any number of arguments, but in ecto it only takes two, so it must be chained to achieve the same effect.</source>
          <target state="translated">SQL에서 COALESCE는 여러 인수를 사용하지만 ecto에서는 두 개만 사용하므로 동일한 효과를 얻으려면 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9ac9085e5b012c8583c70779624f050d5eb103a2" translate="yes" xml:space="preserve">
          <source>In addition to pushing messages out when you receive a &lt;code&gt;handle_in&lt;/code&gt; event, you can also reply directly to a client event for request/response style messaging. This is useful when a client must know the result of an operation or to simply ack messages.</source>
          <target state="translated">&lt;code&gt;handle_in&lt;/code&gt; 이벤트 를 수신 할 때 메시지를 푸시하는 것 외에도 요청 / 응답 스타일 메시징을 위해 클라이언트 이벤트에 직접 응답 할 수도 있습니다. 이것은 클라이언트가 작업 결과를 알아야하거나 단순히 메시지를 확인해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a42c2c570e4795fcc36b32e73f177e0d5b29e6e2" translate="yes" xml:space="preserve">
          <source>In addition to selecting a group of ciphers, selecting a cipher suite will also disable client renegotiation and force the client to honor the server specified cipher order.</source>
          <target state="translated">암호 그룹을 선택하는 것 외에도 암호 그룹을 선택하면 클라이언트 재협상이 비활성화되고 클라이언트가 서버가 지정한 암호 순서를 따르도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="e048396b52227039210be32cd7f7739a9bd6e4a9" translate="yes" xml:space="preserve">
          <source>In all examples so far we have used the &lt;strong&gt;keywords query syntax&lt;/strong&gt; to create a query:</source>
          <target state="translated">지금까지 모든 예제에서 &lt;strong&gt;키워드 query 구문&lt;/strong&gt; 을 사용하여 쿼리를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="39c6142f3ef45ee877e9c272f4bb4ce3244f2b98" translate="yes" xml:space="preserve">
          <source>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</source>
          <target state="translated">어쨌든 스키마의 제공 여부에 관계없이 Ecto 쿼리는 바인딩 시스템 덕분에 항상 컴포지션 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d5f38f557b90ac2d42e6a751598f4d8bbba9025c" translate="yes" xml:space="preserve">
          <source>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the &lt;code&gt;:id&lt;/code&gt; type with &lt;code&gt;:autogenerate&lt;/code&gt;, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</source>
          <target state="translated">두 경우 모두, 두 유형 모두 기본 어댑터 / 데이터베이스에 의해 지정된 의미를 갖습니다. 당신이 사용하는 경우 &lt;code&gt;:id&lt;/code&gt; 와 유형 &lt;code&gt;:autogenerate&lt;/code&gt; , 데이터베이스가 ID의 자동 생성에 대한 책임을 의미합니다. 자동 증분되는 관계형 데이터베이스의 기본 키의 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="82af51d52f0d5e198a5e7d698f02d79e495b27b9" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &amp;ldquo;callback&amp;rdquo;, but may be configured with the callback option.</source>
          <target state="translated">JSON 응답이 반환되는 경우 콜백 필드가 쿼리 문자열에있는 한 JSONP로 변환됩니다. 콜백 필드 자체의 기본값은 &quot;콜백&quot;이지만 콜백 옵션으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce9be04157216a7cdb190a3b918523e8aca6731" translate="yes" xml:space="preserve">
          <source>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.</source>
          <target state="translated">변경 세트가 제공되는 경우 변경 세트의 변경 사항이 구조체 필드와 병합되고 모든 변경 사항이 데이터베이스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e804f9ad9af0ffc381cba4d6aa6307ec8f5528fa" translate="yes" xml:space="preserve">
          <source>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</source>
          <target state="translated">구조체가 제공되는 경우 구조체는 변경이 아닌 모든 필드를 변경 세트의 일부로 변경 세트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="24b15538982d59e2053fe7e9d8eaeadd4eb2e39f" translate="yes" xml:space="preserve">
          <source>In case an attribute contains a boolean value, its key is repeated when it is true, as expected in HTML, or the attribute is completely removed if it is false:</source>
          <target state="translated">속성에 부울 값이 포함 된 경우 HTML에서 예상 한대로 키가 true 일 때 키가 반복되거나 false 인 경우 속성이 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8e575af2759774fa079f44025ceaa854182a1885" translate="yes" xml:space="preserve">
          <source>In case something goes wrong in a request, the router by default will crash, without returning any response to the client. This behaviour can be configured in two ways, by using two different modules:</source>
          <target state="translated">요청에서 문제가 발생하면 클라이언트에 대한 응답을 반환하지 않고 라우터가 기본적으로 중단됩니다. 이 동작은 두 가지 다른 모듈을 사용하여 두 가지 방법으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df0afcd7e029ed4180d102a2ae98dc593f2ffcd" translate="yes" xml:space="preserve">
          <source>In case the URL needs to be dynamically configured, for example by reading a system environment variable, such can be done via the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; repository callback:</source>
          <target state="translated">예를 들어 시스템 환경 변수를 읽어 URL을 동적으로 구성해야하는 경우 &lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; 저장소 콜백을 통해 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30bf9e264bce9cb321b7053883e7d31f611e7f05" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection.</source>
          <target state="translated">어댑터가 풀을 제공하는 경우, 지정된 &lt;code&gt;fun&lt;/code&gt; 내의 모든 코드 가 동일한 연결에 대해 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ff857d8a1955260dd298b9e239a24e36bf3592fa" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won&amp;rsquo;t attempt to reload it.</source>
          <target state="translated">연결이 이미로드 된 경우 사전로드는 다시로드를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="606100f3e421118140c48c97a79e6b2bfcdaf803" translate="yes" xml:space="preserve">
          <source>In case there is no callback or the response is not encoded in JSON format, it is a no-op.</source>
          <target state="translated">콜백이 없거나 응답이 JSON 형식으로 인코딩되지 않은 경우에는 응답이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a4c0d85054f4f0cfaba6ef317dc6eb61be6e95d" translate="yes" xml:space="preserve">
          <source>In case there&amp;rsquo;s at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">오류가 하나 이상있는 경우 변경 목록의 &lt;code&gt;:errors&lt;/code&gt; 필드와 &lt;code&gt;:valid?&lt;/code&gt; 에 오류 목록이 추가됩니다 . 플래그는 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e55c4e4ce95987e0fe79dc9dcc20ddcd0ebdbe7f" translate="yes" xml:space="preserve">
          <source>In cases like above, when you want to work only on a single entry, it is much easier to simply work on the associated directly. For example, we could instead set the &lt;code&gt;post&lt;/code&gt; association in the comment:</source>
          <target state="translated">위와 같은 경우 단일 항목에 대해서만 작업하려면 관련 작업을 직접 수행하는 것이 훨씬 쉽습니다. 예를 들어 주석에서 &lt;code&gt;post&lt;/code&gt; 연결을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a433a57ec454997093ca88ba782e60cd40611d5" translate="yes" xml:space="preserve">
          <source>In channel tests, we interact with channels via process communication, sending and receiving messages. It is also common to subscribe to the same topic the channel subscribes to, allowing us to assert if a given message was broadcast or not.</source>
          <target state="translated">채널 테스트에서는 프로세스 통신, 메시지 송수신을 통해 채널과 상호 작용합니다. 또한 채널이 구독하는 것과 동일한 주제를 구독하여 특정 메시지가 브로드 캐스트되었는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77c8d6fd181489a2dd77e9ab68ac22f7bd4b22c2" translate="yes" xml:space="preserve">
          <source>In fact, given &lt;code&gt;:through&lt;/code&gt; associations are read-only, &lt;strong&gt;using the &lt;a href=&quot;ecto#assoc/2&quot;&gt;&lt;code&gt;Ecto.assoc/2&lt;/code&gt;&lt;/a&gt; format is the preferred mechanism for working with through associations&lt;/strong&gt;. Use the schema-based one only if you need to store the through data alongside of the parent struct, in specific cases such as preloading.</source>
          <target state="translated">실제로, 주어진 &lt;code&gt;:through&lt;/code&gt; 연결 읽기 전용, &lt;strong&gt;은 USING &lt;a href=&quot;ecto#assoc/2&quot;&gt; &lt;code&gt;Ecto.assoc/2&lt;/code&gt; &lt;/a&gt; 포맷은 연결을 통해 사용하기위한 바람직한기구이다&lt;/strong&gt; . 프리로드와 같은 특정 경우에 스루 데이터를 부모 구조체와 함께 저장해야하는 경우에만 스키마 기반 스키마를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e209e8446b46f8896bce3d2476eaddc91e35939f" translate="yes" xml:space="preserve">
          <source>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</source>
          <target state="translated">실제로이 매크로를 호출하면 외래 키 이름을 가진 필드가 스키마에 자동으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c7989d85bf0c7a46c11c45022e7b193d7c4745ef" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;camelize&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;underscore&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">일반적으로 &lt;code&gt;camelize&lt;/code&gt; 는 &lt;code&gt;underscore&lt;/code&gt; 의 반대라고 생각할 수 있지만 경우에 따라 형식이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc684728adbd2c911a4a018ef11d85bc94e422b3" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the template format to be set dynamically based on the request. To do so, you can pass the template name as an atom (without the extension):</source>
          <target state="translated">대부분의 경우 요청에 따라 템플릿 형식을 동적으로 설정하고자 할 수 있습니다. 이렇게하려면 템플릿 이름을 아톰으로 확장명을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e42e4abc355dbe4c074a8c669e3ce458db628eaf" translate="yes" xml:space="preserve">
          <source>In order for the example above to work, we need to do content negotiation with the accepts plug before rendering. You can do so by adding the following to your pipeline (in the router):</source>
          <target state="translated">위의 예제가 작동하려면 렌더링 전에 accepts 플러그를 사용하여 콘텐츠 협상을 수행해야합니다. 파이프 라인 (라우터)에 다음을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="12a19ac64c369cd3aa389e69a402bc23919589b6" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes&amp;rsquo; names and values as the first element in the tag&amp;rsquo;s attributes keyword list:</source>
          <target state="translated">사용자 정의 데이터 속성을 추가하려면 : data atom 및 태그의 속성 키워드 목록에서 첫 번째 요소로 데이터 속성의 이름과 값이 포함 된 키워드 목록이 포함 된 튜플을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4270d5af79d57d387989112f1ca66b128244614" translate="yes" xml:space="preserve">
          <source>In order to customize the parameter for any struct, one can simply implement this protocol.</source>
          <target state="translated">모든 구조체의 매개 변수를 사용자 정의하기 위해이 프로토콜을 간단히 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fb086d6d7d0263ec8c536ef5b195313198d32a9" translate="yes" xml:space="preserve">
          <source>In order to promote HTML safety, Phoenix templates do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt; to convert data types to strings in templates. Instead, Phoenix uses this protocol which must be implemented by data structures and guarantee that a HTML safe representation is returned.</source>
          <target state="translated">HTML 안전성을 높이기 위해 Phoenix 템플릿은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt; 을 사용 하여 데이터 형식을 템플릿의 문자열로 변환 하지 않습니다 . 대신 Phoenix는이 프로토콜을 사용하여 데이터 구조로 구현해야하며 HTML 안전 표현이 반환되도록합니다.</target>
        </trans-unit>
        <trans-unit id="a9ca8acf13c91e783afefe3396f6e1d2849afbe0" translate="yes" xml:space="preserve">
          <source>In order to provide better security, this function also enables &lt;code&gt;:reuse_sessions&lt;/code&gt; and &lt;code&gt;:secure_renegotiate&lt;/code&gt; by default, to instruct clients to reuse sessions and enforce secure renegotiation according to RFC 5746 respectively</source>
          <target state="translated">더 나은 보안을 제공하기 위해이 기능은 기본적으로 &lt;code&gt;:reuse_sessions&lt;/code&gt; 및 &lt;code&gt;:secure_renegotiate&lt;/code&gt; 를 활성화 하여 RFC 5746에 따라 클라이언트가 세션을 재사용하고 보안 재협상을 시행하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2acba69363e13d3b2d19cde17064bc6e54ca91a5" translate="yes" xml:space="preserve">
          <source>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</source>
          <target state="translated">MongoDB와 같은 문자열 기반 쿼리가없는 데이터베이스를 지원하기 위해 조각을 사용하여 키워드를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="62935c8ccc784ab4effb4cd884f492638a038713" translate="yes" xml:space="preserve">
          <source>In order to support links where &lt;code&gt;:method&lt;/code&gt; is not &lt;code&gt;:get&lt;/code&gt; or use the above data attributes, &lt;a href=&quot;phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; relies on JavaScript. You can load &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; into your build tool.</source>
          <target state="translated">&lt;code&gt;:method&lt;/code&gt; 가 &lt;code&gt;:get&lt;/code&gt; 이 아닌 위의 데이터 속성을 사용하는 링크를 지원하기 위해 &lt;a href=&quot;phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 은 JavaScript를 사용합니다. &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; 를 빌드 도구에 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cfbb9e0b757e4a7c387f1a89548e61c769c0468" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MySQL and MSSQL, on the other hand, do not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">맵을 지원하기 위해, 다른 데이터베이스는 다른 기술을 사용할 수 있습니다. 예를 들어 PostgreSQL은 해당 값을 jsonb 필드에 저장하여 일부만 쿼리 할 수 ​​있습니다. 반면에 MySQL 및 MSSQL은 아직 JSON 유형을 제공하지 않으므로 값이 텍스트 필드에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="631c78b05b032bf7a4bc9563b17081acddc1f9da" translate="yes" xml:space="preserve">
          <source>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</source>
          <target state="translated">외래 키 제약 조건을 사용하려면 첫 번째 단계는 마이그레이션에서 외래 키를 정의하는 것입니다. 이것은 종종 참조로 수행됩니다. 예를 들어 게시물에 속하는 주석 테이블을 작성한다고 가정하십시오. 하나는 :</target>
        </trans-unit>
        <trans-unit id="b25785fbeb7db9f5fe5792dc95bd9802bce1df6e" translate="yes" xml:space="preserve">
          <source>In order to use the uniqueness constraint, the first step is to define the unique index in a migration:</source>
          <target state="translated">고유성 제한 조건을 사용하려면 첫 번째 단계는 마이그레이션에서 고유 색인을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d32962e066707989deb6579a1bef99dfb02fd652" translate="yes" xml:space="preserve">
          <source>In order to, for instance, support slower clients you can tune the &lt;code&gt;:read_length&lt;/code&gt; and &lt;code&gt;:read_timeout&lt;/code&gt; options. These specify how much time should be allowed to pass for each read from the underlying socket.</source>
          <target state="translated">예를 들어 느린 클라이언트를 지원하기 위해 &lt;code&gt;:read_length&lt;/code&gt; 및 &lt;code&gt;:read_timeout&lt;/code&gt; 옵션을 조정할 수 있습니다. 이것들은 기본 소켓에서 읽을 때마다 통과해야하는 시간을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0ee12c14d9ca00e6cf48da215974e95f0c7e5650" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;...&lt;/code&gt; will include all the binding between the first and the last, which may be no binding at all, one or many.</source>
          <target state="translated">다시 말해, &lt;code&gt;...&lt;/code&gt; 는 첫 번째와 마지막 사이의 모든 바인딩을 포함하며, 하나 또는 여러 개의 바인딩이 전혀 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d505d82f389daac5da4c66b35201ad586113ff0" translate="yes" xml:space="preserve">
          <source>In other words, when you find yourself wanting to work only with a subset of the data, then using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is most likely unnecessary. Instead, you want to work on the other side of the association.</source>
          <target state="translated">다시 말해, 자신이 데이터의 하위 집합으로 만 작업하기를 원할 경우 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 불필요 할 가능성이 높습니다. 대신, 당신은 협회의 다른 쪽에서 일하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="41ab6ab1980a050c36b66959ba9f3fe938f26932" translate="yes" xml:space="preserve">
          <source>In our example, a User has and belongs to many Organizations</source>
          <target state="translated">이 예에서 사용자는 많은 조직을 보유하고 있으며</target>
        </trans-unit>
        <trans-unit id="24a1a86627169c9301c553095fe386a37b9ae377" translate="yes" xml:space="preserve">
          <source>In practice, we recommend you to create your own helper with your default builder:</source>
          <target state="translated">실제로 기본 빌더를 사용하여 자체 헬퍼를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="993fe331f8eff395e53c329f899a97ba23a0a92b" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to boostrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">경우에 따라 컨텍스트 모듈 및 테스트를 강화하고 컨텍스트 및 스키마의 내부 구현을 자신에게 맡기고 싶을 수도 있습니다. 이를 수행 하려면 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ade3a11fcd46e0424822bf48a04573731b62fbef" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap JSON views, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">경우에 따라 JSON보기, 컨트롤러 및 컨트롤러 테스트를 부트 스트랩하고 컨텍스트 또는 스키마의 내부 구현을 자신에게 맡길 수 있습니다. 파일 생성 제어를 위해 &lt;code&gt;--no-context&lt;/code&gt; 및 &lt;code&gt;--no-schema&lt;/code&gt; 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24c4866aacf268fba081667d7687cebfe5f62ff4" translate="yes" xml:space="preserve">
          <source>In some cases, you might need to render based on the template. For these cases, &lt;code&gt;@view_template&lt;/code&gt; can pair with &lt;a href=&quot;#render_existing/3&quot;&gt;&lt;code&gt;render_existing/3&lt;/code&gt;&lt;/a&gt; for per-template based content, ie:</source>
          <target state="translated">경우에 따라 템플릿을 기반으로 렌더링해야 할 수도 있습니다. 이러한 경우 &lt;code&gt;@view_template&lt;/code&gt; 은 템플릿 기반 콘텐츠에 대해 &lt;a href=&quot;#render_existing/3&quot;&gt; &lt;code&gt;render_existing/3&lt;/code&gt; &lt;/a&gt; 과 쌍을 이룰 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b384998377753d90d4408512efaa31439cf25f8" translate="yes" xml:space="preserve">
          <source>In some cases, you will want to broadcast messages without the context of a &lt;code&gt;socket&lt;/code&gt;. This could be for broadcasting from within your channel to an external topic, or broadcasting from elsewhere in your application like a controller or another process. Such can be done via your endpoint:</source>
          <target state="translated">경우에 따라 &lt;code&gt;socket&lt;/code&gt; 컨텍스트없이 메시지를 브로드 캐스트하려는 경우가 있습니다 . 이는 채널 내에서 외부 주제로 브로드 캐스트하거나 애플리케이션의 다른 곳에서 컨트롤러 또는 다른 프로세스와 같은 브로드 캐스트를위한 것일 수 있습니다. 엔드 포인트를 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="556542b6153a0a9877d7ad7e8e95684ac07433c4" translate="yes" xml:space="preserve">
          <source>In some cases, you&amp;rsquo;ll need to generate a request&amp;rsquo;s URL, but using a different scheme, different host, etc. This can be accomplished by concatentating the request path with a custom built URL from your Router helpers, another Endpoint, mix config, or a hand-built string.</source>
          <target state="translated">경우에 따라 요청의 URL을 생성해야하지만 다른 체계, 다른 호스트 등을 사용해야합니다. 이는 라우터 도우미, 다른 엔드 포인트, 혼합 구성, 사용자 정의 빌드 URL로 요청 경로를 연결하여 수행 할 수 있습니다. 또는 손으로 만든 끈.</target>
        </trans-unit>
        <trans-unit id="68280495d51817872c43fe92d60a5737a8f25c18" translate="yes" xml:space="preserve">
          <source>In that example we have a user&amp;rsquo;s id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">이 예에서는 사용자의 ID가 있으며 토큰을 생성하고 주어진 &lt;code&gt;endpoint&lt;/code&gt; 구성된 비밀 키베이스를 사용하여 토큰을 확인 합니다 . 최대 연령 (권장)을 설정하여 토큰이 하루 동안 만 유효 함을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="fd49de9316bf15faaf745aa97193e59f4c5ce77a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;changeset/2&lt;/code&gt; function above, we define three validations. They check that &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</source>
          <target state="translated">위의 &lt;code&gt;changeset/2&lt;/code&gt; 함수에서는 세 가지 유효성 검사를 정의합니다. &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;email&lt;/code&gt; 필드가 변경 세트에 있는지 , 전자 메일이 지정된 형식이며, 전자 메일 필드의 고유 한 제한 조건과 함께 전자 메일이 18에서 100 사이인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5795255717d6356ac87649a6472e670f2673298a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these datastructures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">위의 예에서 &lt;code&gt;with&lt;/code&gt; 는 성공적인 포스트 페치에만 일치하고 현재 사용자에 대한 유효한 권한 부여와 일치하는 데 사용됩니다. 중 이들의 경우, 일치 실패 &lt;code&gt;with&lt;/code&gt; 블록을 렌더링 대신 타의 추종을 불허하는 값을 반환하지 않습니다 호출합니다. 이 경우 &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; 가 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 리턴 하거나 &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; 가 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 리턴 했다고 가정하십시오 . 이러한 데이터 구조가 도메인의 여러 경계에서 반환 값으로 사용되는 경우 단일 폴백 모듈을 사용하여 값을 유효한 응답으로 변환 할 수 있습니다. 예를 들어 위의 값을 처리하기 위해 다음 폴백 컨트롤러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1b0c0a37a5ad734fd8c9a63cf167f822b9d6d7" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 응답되는 한 전송되는 데이터에 대해서는 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="687f064f0b397a245fd7efdac2c169e020ea3fe3" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">위의 주장에서 우리는 무언가가 전송되는 한 전송되는 데이터에 대해서는 특별히 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6084cacdb41ec7942b3031f9f8713fcd0287545b" translate="yes" xml:space="preserve">
          <source>In the changeset examples so far, we have always used changesets to validate and cast data contained in a struct defined by an Ecto schema, such as the &lt;code&gt;%User{}&lt;/code&gt; struct defined by the &lt;code&gt;User&lt;/code&gt; module.</source>
          <target state="translated">지금까지 변경 세트 예제에서, 변경 세트를 사용 하여 &lt;code&gt;User&lt;/code&gt; 모듈에 의해 정의 된 &lt;code&gt;%User{}&lt;/code&gt; 구조체 와 같이 Ecto 스키마에 의해 정의 된 구조체에 포함 된 데이터의 유효성을 검증하고 캐스트했습니다 .</target>
        </trans-unit>
        <trans-unit id="c05024d1d5f114eed84c10173ddb5b0423ed6df3" translate="yes" xml:space="preserve">
          <source>In the example above we relied on our schema but queries can also be made directly against a table by giving the table name as a string. In such cases, the data to be fetched must be explicitly outlined:</source>
          <target state="translated">위의 예에서는 스키마를 사용했지만 테이블 이름을 문자열로 지정하여 테이블에 대해 직접 쿼리를 수행 할 수도 있습니다. 이러한 경우 가져올 데이터를 명시 적으로 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="6980dcf932f4756073eec7951985832bf4ffdbc2" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;ecto#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;ecto#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12b582e24c785d7e528d91beeaeb2094948f8201" translate="yes" xml:space="preserve">
          <source>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, &lt;a href=&quot;ecto.query.casterror&quot;&gt;&lt;code&gt;Ecto.Query.CastError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">위의 예에서 Ecto는 나이를 정수 유형으로 캐스팅합니다. 값을 캐스트 할 수 없으면 &lt;a href=&quot;ecto.query.casterror&quot;&gt; &lt;code&gt;Ecto.Query.CastError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a6032006ee3190bfba008183ef22c7724958741" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &amp;ldquo;/hello&amp;rdquo;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 요청은 &lt;code&gt;GET&lt;/code&gt; 요청이고 경로가 &quot;/ hello&quot;인 경우에만 일치 합니다. 지원되는 HTTP 메소드는 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbb4d85bfa68b487dba755bf14be4d94f034f1c7" translate="yes" xml:space="preserve">
          <source>In the example above, both &lt;code&gt;at_least_four(:doors)&lt;/code&gt; and &lt;code&gt;at_least_four(:tires)&lt;/code&gt; would be valid calls as the field is dynamically generated.</source>
          <target state="translated">위의 예에서 &lt;code&gt;at_least_four(:doors)&lt;/code&gt; 및 &lt;code&gt;at_least_four(:tires)&lt;/code&gt; 는 필드가 동적으로 생성되므로 유효한 호출입니다.</target>
        </trans-unit>
        <trans-unit id="f151d0619adc353362eafc28e0ed90d66415139d" translate="yes" xml:space="preserve">
          <source>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query and then do a separate pass associating each comment to its parent post. Therefore, instead of returning &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; results, like a &lt;code&gt;join&lt;/code&gt; would, it returns only posts with the &lt;code&gt;comments&lt;/code&gt; fields properly filled in.</source>
          <target state="translated">위의 예에서 주석을 가져 오기 위해 별도의 쿼리를 발행하는 대신 Ecto는 단일 쿼리에서 게시물과 주석을 가져오고 각 주석을 상위 게시물에 연결하는 별도의 패스를 수행합니다. 따라서 &lt;code&gt;join&lt;/code&gt; 처럼 &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; 결과 를 반환하는 대신 &lt;code&gt;comments&lt;/code&gt; 필드가 올바르게 채워진 게시물 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4efbfdb8b81848fa5c5be65d29714905c426ad1" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket&amp;rsquo;s topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel&amp;rsquo;s process as a presence for the socket&amp;rsquo;s user ID, with a map of metadata.</source>
          <target state="translated">위의 예에서 소켓 주제에 대한 현재 상태 정보는 &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; 이벤트 로 클라이언트에 푸시됩니다 . 다음으로 &lt;code&gt;Presence.track&lt;/code&gt; 은이 채널의 프로세스를 메타 데이터 맵과 함께 소켓 사용자 ID의 존재로 등록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c5fb7697f09cc5ff0d4a520eb43540e86b99510" translate="yes" xml:space="preserve">
          <source>In the example above, the query is built little by little by merging into a final map. If both conditions above are true, the final query would be equivalent to:</source>
          <target state="translated">위의 예에서 쿼리는 최종 맵에 병합하여 조금씩 작성됩니다. 위의 두 조건이 모두 해당되는 경우 최종 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="925feb16ac76c5d3be11e92f48d4338c9def7879" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &amp;ldquo;users&amp;rdquo; table from the database.</source>
          <target state="translated">위의 예에서는 데이터베이스에서 &quot;users&quot;테이블을 직접 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="0bdcc56455db35f7ec8e6aad2349adff0d37f04a" translate="yes" xml:space="preserve">
          <source>In the example above, we are using the lower procedure in the database to downcase the title column.</source>
          <target state="translated">위의 예에서 데이터베이스의 하위 프로 시저를 사용하여 제목 열을 다운 케이스합니다.</target>
        </trans-unit>
        <trans-unit id="6d69428195f2828f8a6f3b10d5d7bcaad49a7a54" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;a href=&quot;#avg/1&quot;&gt;&lt;code&gt;avg/1&lt;/code&gt;&lt;/a&gt; is the window function.</source>
          <target state="translated">위의 예에서 부서 당 평균 급여를받습니다. &lt;code&gt;:department&lt;/code&gt; 는 &lt;code&gt;e.depname&lt;/code&gt; 으로 분할 된 창 이름 이고 &lt;a href=&quot;#avg/1&quot;&gt; &lt;code&gt;avg/1&lt;/code&gt; &lt;/a&gt; 은 창 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e6d3d727bce6283546ba164b37335f9c8037c441" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;code&gt;avg/1&lt;/code&gt; is the window function. For more information on windows functions, see &lt;a href=&quot;ecto.query.windowapi&quot;&gt;&lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위의 예에서 부서 당 평균 급여를받습니다. &lt;code&gt;:department&lt;/code&gt; 는 &lt;code&gt;e.depname&lt;/code&gt; 으로 분할 된 창 이름 이고 &lt;code&gt;avg/1&lt;/code&gt; 은 창 함수입니다. windows 함수에 대한 자세한 정보는 &lt;a href=&quot;ecto.query.windowapi&quot;&gt; &lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b237c8ca61ef3e508aa687be188e40ca4adf22f" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a &lt;code&gt;has_many :through&lt;/code&gt; association named &lt;code&gt;:comments_authors&lt;/code&gt;. A &lt;code&gt;:through&lt;/code&gt; association always expects a list and the first element of the list must be a previously defined association in the current module. For example, &lt;code&gt;:comments_authors&lt;/code&gt; first points to &lt;code&gt;:comments&lt;/code&gt; in the same module (Post), which then points to &lt;code&gt;:author&lt;/code&gt; in the next schema, &lt;code&gt;Comment&lt;/code&gt;.</source>
          <target state="translated">위의 예에서는 &lt;code&gt;:comments_authors&lt;/code&gt; 라는 &lt;code&gt;has_many :through&lt;/code&gt; 연관을 정의했습니다 . A는 &lt;code&gt;:through&lt;/code&gt; 연관 항상리스트와리스트의 첫 번째 요소는 현재 모듈에서 사전에 정의 된 연관 있어야 기대한다. 예를 들어 &lt;code&gt;:comments_authors&lt;/code&gt; 는 먼저 동일한 모듈 (Post)에서 &lt;code&gt;:comments&lt;/code&gt; 를 가리키고 다음 스키마 인 &lt;code&gt;Comment&lt;/code&gt; 에서 &lt;code&gt;:author&lt;/code&gt; 를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="85ec2ea6c6ded12b6166febab5316f612414d722" translate="yes" xml:space="preserve">
          <source>In the example above, we used &lt;a href=&quot;#datetime_add/3&quot;&gt;&lt;code&gt;datetime_add/3&lt;/code&gt;&lt;/a&gt; to subtract one month from the current datetime and compared it with the &lt;code&gt;p.published_at&lt;/code&gt;. If you want to perform operations on date, &lt;a href=&quot;#date_add/3&quot;&gt;&lt;code&gt;date_add/3&lt;/code&gt;&lt;/a&gt; could be used.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;#datetime_add/3&quot;&gt; &lt;code&gt;datetime_add/3&lt;/code&gt; &lt;/a&gt; 을 사용 하여 현재 날짜 시간에서 한 달을 빼고 &lt;code&gt;p.published_at&lt;/code&gt; 과 비교했습니다 . 날짜에 작업을 수행하려는 경우 &lt;a href=&quot;#date_add/3&quot;&gt; &lt;code&gt;date_add/3&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a77b1f6b12d8b7d6c0db0b804a8d03a2387d7fc2" translate="yes" xml:space="preserve">
          <source>In the example above, we were able to build the query expressions bit by bit, using different bindings, and later interpolate it all at once inside the query.</source>
          <target state="translated">위의 예에서 우리는 서로 다른 바인딩을 사용하여 쿼리 식을 비트 단위로 빌드 한 다음 쿼리 내부에서 한 번에 보간 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="b3cc98d911ffe36e25f191353a2c3e1efd5e9454" translate="yes" xml:space="preserve">
          <source>In the example below, we get all comments associated to the given post:</source>
          <target state="translated">아래 예에서는 지정된 게시물과 관련된 모든 의견을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="113fef9616300cb9b03a9842f0b9a69b0c3665e7" translate="yes" xml:space="preserve">
          <source>In the examples above, even though it returned &lt;code&gt;:ok&lt;/code&gt;, we do not know if we inserted new data or if we updated only the &lt;code&gt;:on_conflict&lt;/code&gt; fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as &lt;code&gt;inserted_at&lt;/code&gt; will point to now rather than the time the struct was actually inserted.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;:ok&lt;/code&gt; 반환했지만 새 데이터를 삽입했는지 또는 &lt;code&gt;:on_conflict&lt;/code&gt; 필드 만 업데이트했는지는 알 수 없습니다 . 업데이트가 발생하면 구조체의 데이터가 데이터베이스의 데이터와 일치하지 않을 가능성이 높습니다. 예를 들어, 같은 자동 생성 필드 &lt;code&gt;inserted_at&lt;/code&gt; 은 오히려 구조체가 실제로 삽입 된 시간보다 지금 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="2f37c0e9a5a67e4ea92ceac140f3ed765f58b555" translate="yes" xml:space="preserve">
          <source>In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</source>
          <target state="translated">다음 섹션에서는 이러한 구성 요소에 대한 개요와 구성 요소 간의 상호 작용 방법을 제공합니다. 보다 구체적인 예, 옵션 및 구성에 대해서는 해당 모듈 설명서에 자유롭게 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="05a430899144f4642991576f8481a69501d20d42" translate="yes" xml:space="preserve">
          <source>In the form, you now can:</source>
          <target state="translated">양식에서 이제 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94cd064e93fa734125c2fd704a901c1c0fcb707" translate="yes" xml:space="preserve">
          <source>In the keyword query syntax, those options must be given immediately after the join. In the expression syntax, the options are given as the fifth argument.</source>
          <target state="translated">키워드 쿼리 구문에서 이러한 옵션은 조인 직후에 제공되어야합니다. 표현식 구문에서 옵션은 다섯 번째 인수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="925384cf40775541bef0fdb371ddd4f6902ee2ec" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here&amp;rsquo;s a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">이전 섹션에서는 엔드 포인트에서 자동으로 생성 된 &lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; 기능을 사용했습니다 . 다음은 엔드 포인트에서 자동으로 정의 된 모든 기능의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c678eccca5ec57c1ed60e620ac17c9a5a18d705b" translate="yes" xml:space="preserve">
          <source>In this case, we haven&amp;rsquo;t checked the unique constraint in the e-mail field because the data did not validate. Let&amp;rsquo;s fix the age and assume, however, that the e-mail already exists in the database:</source>
          <target state="translated">이 경우 데이터의 유효성이 검사되지 않았기 때문에 전자 메일 필드에서 고유 제약 조건을 확인하지 않았습니다. 그러나 연령을 수정하고 전자 메일이 데이터베이스에 이미 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f94f214e683bc0e00a7e39c7767a3430885c51b2" translate="yes" xml:space="preserve">
          <source>In this example, the phoenix.js client will send the token in the &lt;code&gt;connect&lt;/code&gt; command which is then validated by the server.</source>
          <target state="translated">이 예제에서 phoenix.js 클라이언트는 &lt;code&gt;connect&lt;/code&gt; 명령으로 토큰을 전송 한 다음 서버에서 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b1c87280301ac2f9d889847d9370825348892494" translate="yes" xml:space="preserve">
          <source>In this example, we know the client sent a valid token because &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; returned a tuple of type &lt;code&gt;{:ok, user_id}&lt;/code&gt;. The server can now proceed with the request.</source>
          <target state="translated">이 예에서 &lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;{:ok, user_id}&lt;/code&gt; 유형의 튜플을 반환 했기 때문에 클라이언트가 유효한 토큰을 보냈습니다 . 서버는 이제 요청을 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71e6a35d1eff7b2aab276040bac56ef6b66ab6ad" translate="yes" xml:space="preserve">
          <source>In this example, we prepend the new comment to the list of existing comments. Ecto will diff the list of comments currently in &lt;code&gt;post&lt;/code&gt; with the list of comments given, and correctly insert the new comment to the database. Note, however, Ecto is doing a lot of work just to figure out something we knew since the beginning, which is that there is only one new comment.</source>
          <target state="translated">이 예에서는 기존 주석 목록 앞에 새 주석을 추가합니다. Ecto는 현재 &lt;code&gt;post&lt;/code&gt; 주석 목록을 제공된 주석 목록과 비교하여 새 주석을 데이터베이스에 올바르게 삽입합니다. 그러나 Ecto는 처음부터 우리가 알고있는 것을 알아 내기 위해 많은 노력을 기울이고 있습니다. 즉, 새로운 의견은 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="094b03b8c08ae8f0aca1e1b64e1f6fdead91e39c" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. (See &lt;a href=&quot;phoenix.token#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.)</source>
          <target state="translated">이 시나리오에서는 토큰을 생성하고 서명 한 다음 클라이언트 응용 프로그램에 제공합니다. 그러면 클라이언트는이 토큰을 사용하여 서버의 리소스 요청을 인증합니다. 토큰 생성에 대한 자세한 내용은 &lt;a href=&quot;phoenix.token#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt; 요약을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="534f0da6f14534e0120bbc0f42df3e9cafe2ef69" translate="yes" xml:space="preserve">
          <source>In your posts and tasks:</source>
          <target state="translated">게시물과 작업에서 :</target>
        </trans-unit>
        <trans-unit id="c3b933e481b11d1bde53fbfb5da0612030cd36c5" translate="yes" xml:space="preserve">
          <source>In your test, you can assert that the close happened by:</source>
          <target state="translated">테스트에서 다음과 같이 종료가 발생했다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2145377aa10484f7a6a7e6838ef07513b94b08f3" translate="yes" xml:space="preserve">
          <source>Inclusion operator: &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">포함 연산자 : &lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fb63493844a1ddd4abed4ae031ad06a61ed43a" translate="yes" xml:space="preserve">
          <source>Incoming Events</source>
          <target state="translated">들어오는 이벤트</target>
        </trans-unit>
        <trans-unit id="f330c4ccc52c7952a156d5b90f9e2cb96c8ebbb4" translate="yes" xml:space="preserve">
          <source>Incoming messages</source>
          <target state="translated">수신 메시지</target>
        </trans-unit>
        <trans-unit id="615a09426a8930c611cc2c8dba4ed06391710162" translate="yes" xml:space="preserve">
          <source>Incoming messages are encoded in whatever way the transport chooses. Those messages must be decoded in the transport into a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; before being forwarded to a channel.</source>
          <target state="translated">들어오는 메시지는 전송자가 선택하는 방식에 따라 인코딩됩니다. 이러한 메시지는 채널로 전달되기 전에 전송에서 &lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt; 로 디코딩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2668d897f3e5655c92b0200386d6b654d95aaf3e" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema</source>
          <target state="translated">다른 스키마와 다 대다 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6aedb251e3f9159172c6827ec8ede269c15554c5" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema.</source>
          <target state="translated">다른 스키마와의 다 대다 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="135ecd7103630379591db4bff96d8d8045c40ee5" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema</source>
          <target state="translated">다른 스키마와 일대 다 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13d6cb61c10dc318568f2defc7bea984f223dba4" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema.</source>
          <target state="translated">다른 스키마와 일대 다 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1708cc604ed2771df21bc2d718401a60ab2cc1f0" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema</source>
          <target state="translated">다른 스키마와 일대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ae09be75f38bd6a2f7c1a338f1fea359b869e83" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema.</source>
          <target state="translated">다른 스키마와 일대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c438499b0af025a1043798095c70140d1dfd657" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema</source>
          <target state="translated">다른 스키마와 일대일 또는 다 대일 연관을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3745614dbe3129d4f977d563860dba9c8231878f" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema.</source>
          <target state="translated">다른 스키마와 일대일 또는 다 대일 연결을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aba2438ae1e81b9920197c224065413b7671c158" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema</source>
          <target state="translated">스키마 임베딩을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b12568554ff04c1842f8599807aa79f64173a10b" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema.</source>
          <target state="translated">스키마의 포함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0754ccd3beda4c7eb864f57ffbfc33fd61e455d7" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas</source>
          <target state="translated">많은 스키마를 포함 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99fc922b999b45aabf4ebb20cd1ef3dfc6c0a01f" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas.</source>
          <target state="translated">많은 스키마를 포함 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d6143e57414f523ba3e39d5fe528429bec73741" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration</source>
          <target state="translated">엔드 포인트 구성 초기화</target>
        </trans-unit>
        <trans-unit id="5feacf6897a98bceba39f5f4a774ab74aa83f3be" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration.</source>
          <target state="translated">엔드 포인트 구성을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="3397476eb797456dd549685d4d13875789ff5bea" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata</source>
          <target state="translated">하위 및 어댑터 메타 데이터를 리턴하여 어댑터 감독 트리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c798c674e519bc2029ac452c4e9259668434c74d" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata.</source>
          <target state="translated">하위 및 어댑터 메타 데이터를 리턴하여 어댑터 감독 트리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2a5ae207d4c7ad36e0e12a08bb38366c31c50683" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents</source>
          <target state="translated">주어진 내용으로 세션을 초기화합니다</target>
        </trans-unit>
        <trans-unit id="3e313d7032fb8b49aa12e688ee30e31dff8431ca" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents.</source>
          <target state="translated">주어진 내용으로 세션을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="fc723255ce4cbc0ec464d52fcc972a1cff32563d" translate="yes" xml:space="preserve">
          <source>Initializes the store</source>
          <target state="translated">상점을 초기화합니다</target>
        </trans-unit>
        <trans-unit id="1948daa5ef81efb1f6ec1462ab9c9c66bafc872e" translate="yes" xml:space="preserve">
          <source>Initializes the store.</source>
          <target state="translated">상점을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0a32892f65c6f195d4bdaf7f60b3ed037aaaf563" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler</source>
          <target state="translated">소켓 핸들러에 대한 전송 연결을 시작합니다</target>
        </trans-unit>
        <trans-unit id="aa4d0a4055c28858395d1bfeafcca50d2acb136f" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler.</source>
          <target state="translated">소켓 핸들러에 대한 전송 연결을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="da5d892e49eb5ac8b64c4d52c39e57d5d2b08b77" translate="yes" xml:space="preserve">
          <source>Inline embedded schema</source>
          <target state="translated">인라인 임베디드 스키마</target>
        </trans-unit>
        <trans-unit id="569dafe164ae502c9b87c69bc2eeb16d3ac20cb7" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store</source>
          <target state="translated">데이터 저장소에 하나의 새로운 구조체를 삽입합니다</target>
        </trans-unit>
        <trans-unit id="3a1317498687c5894a20801ea9661a9689ed2d87" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store.</source>
          <target state="translated">데이터 저장소에 단일 새 구조체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="86c1d2240ae2916c99327d1f3c4590ec880385b2" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset</source>
          <target state="translated">&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 또는 변경 세트 를 통해 정의 된 구조체를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a079a1b2f8984d465d9779ce849f02a429912d56" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset.</source>
          <target state="translated">&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 또는 변경 세트 를 통해 정의 된 구조체를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="2181d458ad9deb4e6f83faf70ff675628bae0f26" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository</source>
          <target state="translated">모든 항목을 저장소에 삽입</target>
        </trans-unit>
        <trans-unit id="bc00e3feeb02479984623c1097211a4ee34ffd3d" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository.</source>
          <target state="translated">모든 항목을 저장소에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="9a37ef1a0e51e4ac96d292248e7c141eccd65b5f" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store</source>
          <target state="translated">데이터 저장소에 여러 항목을 삽입합니다</target>
        </trans-unit>
        <trans-unit id="45c0d55451df6034857c16938433e2842f295184" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store.</source>
          <target state="translated">데이터 저장소에 여러 항목을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a7003a167a94b7bd8fae5279ac09697a6145d12e" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not</source>
          <target state="translated">변경 세트가 지속되었는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="dcd7179acaea39cd9930239b8c9b516c75b3f0b6" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not.</source>
          <target state="translated">변경 세트가 지속되었는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9eeac09af2f2cedab574e42a13a327495bc47759" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not</source>
          <target state="translated">구조체가 유지되는지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="518a7ab088e5ce8ed019df775d78816d42febbe1" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not.</source>
          <target state="translated">구조체의 유지 여부에 따라 변경 세트를 삽입하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c6d1a59fa5a20ec26ebff17adad30561c03cb5fa" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;select&lt;/code&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; can also be used to cast fragments:</source>
          <target state="translated">내부 &lt;code&gt;select&lt;/code&gt; , &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; 또한 주조 조각에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bd5d902a671eb6810031f5357cbe6027ed13c2f5" translate="yes" xml:space="preserve">
          <source>Inside select: &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#merge/2&quot;&gt;&lt;code&gt;merge/2&lt;/code&gt;&lt;/a&gt; and literals (map, tuples, lists, etc)</source>
          <target state="translated">내부 선택 : &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#merge/2&quot;&gt; &lt;code&gt;merge/2&lt;/code&gt; &lt;/a&gt; 및 리터럴 (지도, 튜플, 목록 등)</target>
        </trans-unit>
        <trans-unit id="5017ef1ca24c2a0d39b26c970ff7ebac50e027e8" translate="yes" xml:space="preserve">
          <source>Instead do this:</source>
          <target state="translated">대신 이것을하십시오 :</target>
        </trans-unit>
        <trans-unit id="53f49b4a03d02b3492955bbf412c1bec4c46145a" translate="yes" xml:space="preserve">
          <source>Instead of setting the action manually, you may use &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; that emulates operations such as &lt;code&gt;Repo.insert&lt;/code&gt;. &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;{:ok, changes}&lt;/code&gt; if the changeset is valid or &lt;code&gt;{:error, changeset}&lt;/code&gt;, with the given &lt;code&gt;action&lt;/code&gt; set in the changeset in case of errors.</source>
          <target state="translated">대신 수동으로 작업을 설정, 당신은 사용할 수 있습니다 &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt; 그와 같은 에뮬레이션 작업 &lt;code&gt;Repo.insert&lt;/code&gt; 가 . 변경 세트가 유효한 경우 &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;{:ok, changes}&lt;/code&gt; 또는 &lt;code&gt;{:error, changeset}&lt;/code&gt; 를 리턴 하며, 오류가 발생하면 변경 세트에 지정된 &lt;code&gt;action&lt;/code&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4ab4eded4494d51c420236d3c9dde1cb217c024c" translate="yes" xml:space="preserve">
          <source>Instead, you can see the valid options for ciphers in the Erlang SSL documentation: http://erlang.org/doc/man/ssl.html</source>
          <target state="translated">대신 Erlang SSL 문서에서 유효한 암호 옵션을 확인할 수 있습니다. http://erlang.org/doc/man/ssl.html</target>
        </trans-unit>
        <trans-unit id="cb49b30bf89c4f1a8a29b63caa0a66ed1c9abce4" translate="yes" xml:space="preserve">
          <source>Instrumentation</source>
          <target state="translated">Instrumentation</target>
        </trans-unit>
        <trans-unit id="e963ac54f9b90e504ad8b5131dedaa40800f87bf" translate="yes" xml:space="preserve">
          <source>Instrumenter to handle logging of various instrumentation events.</source>
          <target state="translated">다양한 계측 이벤트의 로깅을 처리하는 계측기</target>
        </trans-unit>
        <trans-unit id="0a977fa7c155d5db26b9805f1ed5ecb306366925" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint</source>
          <target state="translated">주어진 엔드 포인트가 제공하는 계측을 사용하여 주어진 기능을 계측</target>
        </trans-unit>
        <trans-unit id="040ea1fc514e828951fb8bd3d4e6583bf2dab63c" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint.</source>
          <target state="translated">주어진 엔드 포인트에서 제공하는 계측을 사용하여 지정된 기능을 계측합니다.</target>
        </trans-unit>
        <trans-unit id="a4c71d7db6768276e995bf083955f4cf532a2661" translate="yes" xml:space="preserve">
          <source>Integers: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;</source>
          <target state="translated">정수 : &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199cf4a624177d7b6a2189975011d8cf1553a6ea" translate="yes" xml:space="preserve">
          <source>Intercepting Outgoing Events</source>
          <target state="translated">발신 이벤트 차단</target>
        </trans-unit>
        <trans-unit id="352256d32ca814a08dd6fb42ea6e24113694d807" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas</source>
          <target state="translated">연관을 스키마에 통합하기위한 내부 함수</target>
        </trans-unit>
        <trans-unit id="eb704a4d49662206b6263bee9e3a6a682a47856e" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas.</source>
          <target state="translated">연관을 스키마에 통합하기위한 내부 함수</target>
        </trans-unit>
        <trans-unit id="2cd342be42586a26dea11e10d4f2f734d1e7b515" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 동작을 구현합니다. 즉, &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;call/2&lt;/code&gt; 함수가 모두 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="9e19e8e52d010a3380d2cbbab62c90af63b8d211" translate="yes" xml:space="preserve">
          <source>Interpolation and casting</source>
          <target state="translated">보간 및 주조</target>
        </trans-unit>
        <trans-unit id="28f682fd32feb69dea4dd4ff7adfaeaa1d1cf34e" translate="yes" xml:space="preserve">
          <source>Intersect expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to take the intersection of multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#intersect_all/2&quot;&gt;&lt;code&gt;intersect_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">교차 표현식은 각 쿼리가 고유 한 결과를 반환 한 것처럼 고유 한 행만 반환합니다. 성능이 저하 될 수 있습니다. 중복 행을 제거하지 않고 여러 결과 세트를 교차해야하는 경우 &lt;a href=&quot;#intersect_all/2&quot;&gt; &lt;code&gt;intersect_all/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5ee41c074ac477895b057c2f41a57f16a778949" translate="yes" xml:space="preserve">
          <source>Invoke this function for each possible value you want to be sent to the server.</source>
          <target state="translated">서버로 보내려는 각 가능한 값에 대해이 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="619c9c50996959b8e8f2beefe6dce08a85ac4c47" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;</source>
          <target state="translated">주어진 기간 &lt;code&gt;term&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 아래에 저장된 값에 액세스하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cf9b446c97f792217c895b34619fd73d2391b8" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 아래의 값에 액세스 하고 동시에 업데이트 하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733a4970520b6a464600ddd46a5ea64dba2a7375" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure</source>
          <target state="translated">주어진 데이터 구조 에서 &lt;code&gt;key&lt;/code&gt; 아래의 값을 &quot;팝&quot;하도록 호출</target>
        </trans-unit>
        <trans-unit id="742607736cb1addcde99f49aeedd51a191858b29" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">주어진 데이터 구조 에서 &lt;code&gt;key&lt;/code&gt; 아래의 값을 &quot;팝&quot;하기 위해 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="61f50a5fe51f51ed7bfe665e624200109386cacc" translate="yes" xml:space="preserve">
          <source>Invoked when the endpoint supervisor starts, allows dynamically configuring the endpoint from system environment or other runtime sources.</source>
          <target state="translated">엔드 포인트 수퍼바이저가 시작될 때 호출되며 시스템 환경 또는 기타 런타임 소스에서 엔드 포인트를 동적으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dadda151ad04d6534ebf813dc99705a1a1d25aa9" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="fe65c1df5bce54718f5a6ea6e98b5d9c1a779a60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0516c7f6572d24052272cc4f229ec6f77d29e2" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;code&gt;start_link/3&lt;/code&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="092a9376001bb69648a2c2cf84aeeda23d64be60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;code&gt;start_link/3&lt;/code&gt; 또는 &lt;code&gt;start/3&lt;/code&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="0c22586bb54f63849624411c842f2723bc94a4ec" translate="yes" xml:space="preserve">
          <source>It accepts an expression representing the path and many options allowing the match to be configured.</source>
          <target state="translated">경로를 나타내는 표현식과 일치를 구성 할 수있는 많은 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e9e7a6e5fc7e8d490f61f816d70fa682574386e8" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#read_body/2&quot;&gt;&lt;code&gt;read_body/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#read_body/2&quot;&gt; &lt;code&gt;read_body/2&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="09ea74617913e32e5cdeb3c90a896c1320876968" translate="yes" xml:space="preserve">
          <source>It also supports custom adapter configuration:</source>
          <target state="translated">또한 사용자 정의 어댑터 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="726bf51434f75d8acf5e951711360513b2a0f6e9" translate="yes" xml:space="preserve">
          <source>It builds a new &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, invokes the handler &lt;code&gt;connect/2&lt;/code&gt; callback and returns the result.</source>
          <target state="translated">새 &lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; 을&lt;/a&gt; 빌드 하고 핸들러 &lt;code&gt;connect/2&lt;/code&gt; 콜백을 호출하고 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c8b86f00ae4f81180f207fb516f99df0d0c9b931" translate="yes" xml:space="preserve">
          <source>It can be used to derive a number of keys for various purposes from a given secret. This lets applications have a single secure secret, but avoid reusing that key in multiple incompatible contexts.</source>
          <target state="translated">주어진 비밀에서 다양한 목적으로 여러 키를 파생시키는 데 사용될 수 있습니다. 이를 통해 응용 프로그램은 단일 보안 암호를 가질 수 있지만 호환되지 않는 여러 컨텍스트에서 해당 키를 재사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="23758d8b77b97b076e10f03ba6b30fb6fdbbbd09" translate="yes" xml:space="preserve">
          <source>It can either be a keyword query or a query expression.</source>
          <target state="translated">키워드 쿼리 또는 쿼리 식일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186c38e14a6722baf34f425fa70665e109fc23a0" translate="yes" xml:space="preserve">
          <source>It can reset many fields except the query source (&lt;code&gt;from&lt;/code&gt;). When excluding a &lt;code&gt;:join&lt;/code&gt;, it will remove &lt;em&gt;all&lt;/em&gt; types of joins. If you prefer to remove a single type of join, please see paragraph below.</source>
          <target state="translated">쿼리 소스 ( &lt;code&gt;from&lt;/code&gt; )를 제외한 많은 필드를 재설정 할 수 있습니다 . &lt;code&gt;:join&lt;/code&gt; 을 제외하면 &lt;em&gt;모든&lt;/em&gt; 유형의 조인 이 제거 &lt;em&gt;됩니다&lt;/em&gt; . 단일 유형의 조인을 제거하려면 아래 단락을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="452abe794374c8a4220fd3958f7c982cbc75a77b" translate="yes" xml:space="preserve">
          <source>It expects &lt;code&gt;{:safe, body}&lt;/code&gt; as a safe response or body as a string which will be HTML escaped.</source>
          <target state="translated">그것은 예상 &lt;code&gt;{:safe, body}&lt;/code&gt; HTML 이스케이프됩니다 문자열로 안전 응답이나 신체 등을.</target>
        </trans-unit>
        <trans-unit id="8540fa79ebeeb04321b6937468baa86cf4bdc0a6" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 나중에 상태를 &lt;code&gt;:chunked&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="acabec8dab50a30917f688b209245a29971cc577" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise, raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;. After &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt; is called, chunks can be sent to the client via the &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 되지 않은 연결을 예상하고 나중에 상태를 &lt;code&gt;:chunked&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. &lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt; 함수 를 통해 청크를 클라이언트로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90c8ac9c1aa8ddc9982ee763c945c57e9b9465d7" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:file&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 &lt;code&gt;:sent&lt;/code&gt; 않은 연결을 예상하고 그 후에 상태를 &lt;code&gt;:file&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1fe68caa8735b3dcb8f4a5c0b34b1b868f77311e" translate="yes" xml:space="preserve">
          <source>It expects a connection with state &lt;code&gt;:chunked&lt;/code&gt; as set by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;. It returns &lt;code&gt;{:ok, conn}&lt;/code&gt; in case of success, otherwise &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; 에&lt;/a&gt; 의해 설정된 상태 &lt;code&gt;:chunked&lt;/code&gt; 와의 연결이 필요 합니다. 그것은 반환 &lt;code&gt;{:ok, conn}&lt;/code&gt; 그렇지 않으면 성공의 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a89874718d53663a7182056d1005a29e9ce37ec6" translate="yes" xml:space="preserve">
          <source>It expects a name or a PID representing a repo.</source>
          <target state="translated">리포를 나타내는 이름 또는 PID가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="acb7e336ed29d294c4566b6d952ca3d23d9cfb62" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.</source>
          <target state="translated">첫 번째 인수로 스키마 모듈 ( &lt;code&gt;MyApp.User&lt;/code&gt; ) 또는 소스 ( &lt;code&gt;&quot;users&quot;&lt;/code&gt; ) 또는 둘 다 ( &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; )가 필요합니다. 두 번째 인수는 키워드 목록 또는 맵으로 삽입 할 항목 목록입니다.</target>
        </trans-unit>
        <trans-unit id="833cf1288bb8a29f6137f917618b60a72a57a732" translate="yes" xml:space="preserve">
          <source>It expects the connection state to be &lt;code&gt;:set&lt;/code&gt;, otherwise raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; for &lt;code&gt;:unset&lt;/code&gt; connections or a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; for already &lt;code&gt;:sent&lt;/code&gt; connections.</source>
          <target state="translated">연결 상태가 &lt;code&gt;:set&lt;/code&gt; 일 것으로 예상합니다 . 그렇지 않으면 &lt;code&gt;:unset&lt;/code&gt; 연결에 대해 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생 하거나 이미 &lt;code&gt;:sent&lt;/code&gt; 연결에 대해 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="66c2fa1bb2a3b72c645dc3842e1b860a47918db6" translate="yes" xml:space="preserve">
          <source>It expects the view module, the template as a string, and a set of assigns.</source>
          <target state="translated">뷰 모듈, 문자열로 된 템플릿 및 할당 세트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7f16d994b67422cffaafcda9f7a4a44b5dac9b6a" translate="yes" xml:space="preserve">
          <source>It has to return a supervisor child specification.</source>
          <target state="translated">감독자 자식 사양을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b418dc1717675b2c364bf1025422ff35a375736" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;a href=&quot;#child_spec/3&quot;&gt;&lt;code&gt;child_spec/3&lt;/code&gt;&lt;/a&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="translated">필요한 &lt;a href=&quot;#child_spec/3&quot;&gt; &lt;code&gt;child_spec/3&lt;/code&gt; &lt;/a&gt; 함수와 WebSocket 전송 핸들러를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="078983c5e35a9c8a686a6ae53ccec194f56ab546" translate="yes" xml:space="preserve">
          <source>It invokes the &lt;code&gt;validator&lt;/code&gt; function to perform the validation only if a change for the given &lt;code&gt;field&lt;/code&gt; exists and the change value is not &lt;code&gt;nil&lt;/code&gt;. The function must return a list of errors (with an empty list meaning no errors).</source>
          <target state="translated">주어진 &lt;code&gt;field&lt;/code&gt; 대한 변경이 존재하고 변경 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 유효성 검증을 수행하기 위해 &lt;code&gt;validator&lt;/code&gt; 함수를 호출합니다 . 함수는 오류 목록을 리턴해야합니다 (빈 목록은 오류가 없음을 의미 함).</target>
        </trans-unit>
        <trans-unit id="b32bb8330646b67711708edabee82d77ea1330ee" translate="yes" xml:space="preserve">
          <source>It is advised to do as little work as possible when handling errors and avoid accessing data like parameters and session, as the parsing of those is what could have led the error to trigger in the first place.</source>
          <target state="translated">오류를 처리 할 때는 가능한 한 적은 작업을 수행하고 매개 변수 및 세션과 같은 데이터에 액세스하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c2327b2734d4abd79bc9e71baaac2419dacff235" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;phoenix.controller#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">&lt;a href=&quot;phoenix.controller#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt; 를 혼동하지 않는 것도 중요 합니다. 전자는 연결을 기대하고 콘텐츠 협상에 의존하지만 후자는 연결에 구애받지 않고 일반적으로 사용자의 관점에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6a635280fb829c46f3ffad5a5d1753b1e733763d" translate="yes" xml:space="preserve">
          <source>It is also important to specify your handlers first, otherwise Phoenix will intercept the requests before they get to your handler.</source>
          <target state="translated">처리기를 먼저 지정하는 것도 중요합니다. 그렇지 않으면 Phoenix는 처리기가 처리기에 도달하기 전에 요청을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="30055e2131468401399af6d6f093161c25f60030" translate="yes" xml:space="preserve">
          <source>It is also not possible to use &lt;code&gt;insert_all&lt;/code&gt; to insert across multiple tables, therefore associations are not supported.</source>
          <target state="translated">&lt;code&gt;insert_all&lt;/code&gt; 을 사용 하여 여러 테이블에 삽입 할 수도 없으므로 연관이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8b8d8d53d8d8d7bd2e2cb61ea0c656280b0dd19" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate an Ecto query on the right side of &lt;code&gt;in&lt;/code&gt;. For example, the query above can also be written as:</source>
          <target state="translated">그것의 오른쪽 측의 체외 쿼리를 보간하는 것도 가능하다 &lt;code&gt;in&lt;/code&gt; . 예를 들어 위의 쿼리는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21ad6a95ad909158ac71de812586e3b7701491a" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</source>
          <target state="translated">전체 키워드 목록을 보간하여 소스를 동적으로 필터링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d5529f115beed361dd6ff5307741dbc9a975d8d" translate="yes" xml:space="preserve">
          <source>It is also possible to say the type must match the same of a column:</source>
          <target state="translated">유형이 동일한 열과 일치해야한다고 말할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="731c24ca319f444e53ad6c345b4820aa7c05979b" translate="yes" xml:space="preserve">
          <source>It is also possible to select a struct and limit the returned fields at the same time:</source>
          <target state="translated">구조체를 선택하고 반환 된 필드를 동시에 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70a7d66c051591aae4846e19708e277358bb5702" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; directly or even run your own pubsub backends outside of an Endpoint.</source>
          <target state="translated">&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; 를&lt;/a&gt; 직접 사용 하거나 엔드 포인트 외부에서 고유 한 pubsub 백엔드를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a719d875929b73a5f638e46b11bc306d0aaee72" translate="yes" xml:space="preserve">
          <source>It is compiled to:</source>
          <target state="translated">다음과 같이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="5f416c91fdafe72dbbea13ab378ff98cfdfba3e1" translate="yes" xml:space="preserve">
          <source>It is composed of the following fields:</source>
          <target state="translated">다음과 같은 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="92a07cde7a7c28b24072256a01215dba443d5ba7" translate="yes" xml:space="preserve">
          <source>It is important that &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; is placed before the &lt;code&gt;:dispatch&lt;/code&gt; plug in the pipeline, otherwise the matched clause route will not receive the parsed body in its &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; argument when dispatched.</source>
          <target state="translated">&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt; 는 파이프 라인에서 &lt;code&gt;:dispatch&lt;/code&gt; 플러그 앞에 배치 하는 것이 중요 합니다 . 그렇지 않으면 일치하는 절 경로가 디스패치 될 때 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 인수 에서 구문 분석 된 본문을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d959bc56d3f9eacdf442d02254dff9bed2d3a24c" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &amp;ldquo;html&amp;rdquo; format whenever:</source>
          <target state="translated">브라우저는 역사적으로 잘못된 수락 헤더를 보냈습니다. 이러한 이유로이 기능은 다음과 같은 경우 항상 &quot;html&quot;형식으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8df7a21de3fad9373d1e80d0a68fb9c2af463623" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;plug.ssl#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and wants to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">HSTS는 포트가 SSL에 대해 443이 될 것으로 예상하므로 &lt;a href=&quot;plug.ssl#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt; 에서 포트를 직접 구성 할 수 없습니다 . HSTS를 사용하지 않고 다른 포트에서 HTTPS로 경로 재 지정하려는 경우 호스트와 함께 몰래 이동할 수 있습니다 (예 : &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb866ba422c5f8373a8e029337285f653ad8d5ad" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto&amp;rsquo;s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">Ecto의 쿼리 구문을 사용하여 가능한 모든 데이터베이스 쿼리를 나타내는 것은 불가능합니다. 필요한 경우 조각을 사용하여 데이터베이스에 표현식을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f6c0d9ff724f7de2dd203438fa29365111d1aa" translate="yes" xml:space="preserve">
          <source>It is possible to add custom media types to your Phoenix application. The first step is to teach Plug about those new media types in your &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">Phoenix 애플리케이션에 사용자 정의 미디어 유형을 추가 할 수 있습니다. 첫 번째 단계는 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 새로운 미디어 유형에 대해 플러그를 가르치는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="2e2d8626fbe4ef6e2589dce4fc2dd6762fe2a1b8" translate="yes" xml:space="preserve">
          <source>It is possible to make use of PostgreSQL&amp;rsquo;s JSON/JSONB data type with fragments, as well:</source>
          <target state="translated">PostgreSQL의 JSON / JSONB 데이터 유형을 조각과 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef6e9ed5dbdf5b36ce6e79f0b64c7e18c4f11c1" translate="yes" xml:space="preserve">
          <source>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</source>
          <target state="translated">쿼리의 접두사를 설정할 수 있습니다. Postgres 사용자의 경우 테이블이있는 스키마를 지정하고 MySQL 사용자의 경우 테이블이있는 데이터베이스를 지정합니다. 접두사가 설정되지 않으면 Postgres 쿼리는 퍼블릭 스키마에있는 것으로 가정하고 MySQL 쿼리는 리포지토리의 구성에 설정된 데이터베이스에있는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="700c0f421fd3cd0dfcac1f7b125e6e262daac824" translate="yes" xml:space="preserve">
          <source>It is possible to set:</source>
          <target state="translated">다음을 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="29ec728a65755ba3d79cf56f0945ca98b6fece30" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lower-case, to avoid sending duplicate keys in a request. As a convenience, this is validated during testing which raises a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt; if the header key is not lowercase.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 사용하는 것이 좋습니다. 편의상, 이것은 헤더 키가 소문자가 아닌 경우 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를&lt;/a&gt; 발생시키는 테스트 중에 검증 됩니다.</target>
        </trans-unit>
        <trans-unit id="40511b3383ca8f06336921afea27344c64c63c88" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren&amp;rsquo;t lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청에서 중복 키를 보내지 않도록 헤더 키를 소문자로 사용하는 것이 좋습니다. 편의상 &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; 어댑터를 사용할 때 소문자가 아닌 헤더는 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e835d630e658a66295e09f0cfb72bb2ca5635f8b" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; and a default of &lt;code&gt;&quot;[]&quot;&lt;/code&gt; (although Ecto will also automatically translate &lt;code&gt;nil&lt;/code&gt; values from the database into empty lists).</source>
          <target state="translated">형식 &lt;code&gt;:map&lt;/code&gt; 및 기본값 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt; 필드 를 선언하는 것이 좋습니다 (Ecto는 데이터베이스의 &lt;code&gt;nil&lt;/code&gt; 값을 빈 목록 으로 자동 변환하지만 ).</target>
        </trans-unit>
        <trans-unit id="9795c1abaf982033b2c0ed19994a9b57e226ca48" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &amp;lsquo;dhparam.pem&amp;rsquo; file:</source>
          <target state="translated">DHE 키 교환에 사용될 Diffie Hellman 매개 변수의 사용자 정의 세트를 생성하는 것이 좋습니다. 'dhparam.pem'파일을 작성하려면 다음 OpenSSL CLI 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed21c543268df4242ce9c821e6a091cd15a3cd4" translate="yes" xml:space="preserve">
          <source>It is recommended to include this metadata configuration in your production configuration file.</source>
          <target state="translated">프로덕션 구성 파일에이 메타 데이터 구성을 포함하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3ce90e2d8912f1f2f7b4ea1417a8fb3575961cda" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#media_type/1&quot;&gt;&lt;code&gt;media_type/1&lt;/code&gt;&lt;/a&gt; except wildcards are not accepted in the type nor in the subtype.</source>
          <target state="translated">와일드 카드가 유형이나 하위 유형으로 허용되지 않는다는 점을 제외하면 &lt;a href=&quot;#media_type/1&quot;&gt; &lt;code&gt;media_type/1&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="7d8b235293c3fd441987efade8483fcf5a50bbd4" translate="yes" xml:space="preserve">
          <source>It is very common in Phoenix applications to namespace all of your routes under the application scope:</source>
          <target state="translated">응용 프로그램 범위에서 모든 경로를 네임 스페이스로 만드는 것은 Phoenix 응용 프로그램에서 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="511755381ec8f835711d51bfe3c71d347d8afc8e" translate="yes" xml:space="preserve">
          <source>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; function to give Ecto some hints:</source>
          <target state="translated">Ecto는 프래그먼트를 사용할 때 위에서 설명한 유형 캐스팅을 수행 할 수 없다는 점을 명심해야합니다. 그러나 &lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Ecto에 힌트를 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f8bd155fb3b264871458601bfe98b34947ef8af" translate="yes" xml:space="preserve">
          <source>It must be a map and Ecto itself will always inject two keys into the meta:</source>
          <target state="translated">맵이어야하며 Ecto 자체는 항상 메타에 두 개의 키를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="6c7bf550d2dd91e3eb7f4d8ba8c5d8e72098cb71" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be &lt;code&gt;nil&lt;/code&gt; if a particular operation does not support them.</source>
          <target state="translated">항목 수와 결과 집합이 포함 된 튜플을 목록 목록으로 반환해야합니다. 특정 작업에서 지원하지 않는 경우 결과 집합이 &lt;code&gt;nil&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f49388dc41541c5a93c112295bb0bf75921390c9" translate="yes" xml:space="preserve">
          <source>It provides a set of macros to generate routes. For example:</source>
          <target state="translated">라우트를 생성하는 매크로 세트를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aeb6380d88e1271819dcb40ba83ee9babe0b5d5c" translate="yes" xml:space="preserve">
          <source>It receives a connection, a list of formats that the server is capable of rendering and then proceeds to perform content negotiation based on the request information. If the client accepts any of the given formats, the request proceeds.</source>
          <target state="translated">서버가 렌더링 할 수있는 형식 목록 인 연결을 수신 한 후 요청 정보를 기반으로 컨텐츠 협상을 진행합니다. 클라이언트가 주어진 형식 중 하나를 승인하면 요청이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="a632a124b740ee3ecfe4c66cfbe50a9b8a5330c6" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</source>
          <target state="translated">프리미티브 유형과 Ecto 유형 (프리미티브 일 수도 있음)을받습니다. 일반적으로 처음에 주어진 유형의 덤퍼 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c5336dd4112321d4cfb426214c2399ecd75a7e8c" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</source>
          <target state="translated">프리미티브 유형과 Ecto 유형 (프리미티브 일 수도 있음)을받습니다. 일반적으로 끝에 주어진 유형의 로더 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="eead6f123b731bd151755a8d6351651f60a5cb89" translate="yes" xml:space="preserve">
          <source>It requires the given form to be configured with &lt;code&gt;multipart: true&lt;/code&gt; when invoking &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt;, otherwise it fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 주어진 양식을 &lt;code&gt;multipart: true&lt;/code&gt; 로 구성 해야합니다 . 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 로&lt;/a&gt; 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="b444a758782f3e5a243723f32117b04bcd1193d7" translate="yes" xml:space="preserve">
          <source>It requires two options:</source>
          <target state="translated">두 가지 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c368117d80fc577cffd447c6b5a5ef62cbb74d54" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, headers, conn}&lt;/code&gt; with the headers or &lt;code&gt;{:done, conn}&lt;/code&gt; if there are no more parts.</source>
          <target state="translated">&lt;code&gt;{:ok, headers, conn}&lt;/code&gt; 와 함께 {: ok, headers, conn} 을 반환 하거나 더 이상 부품이 없으면 &lt;code&gt;{:done, conn}&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="625a8c24b534dfa374e922372c9b8979bedc267b" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; or &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:ok, reply, socket}&lt;/code&gt; 또는 &lt;code&gt;{:error, reply}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="056c105e63679c152071fae62b19b0a4e30832f1" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully deleted or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 삭제 된 경우 또는 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="662e3be55825a0906e817964327528ec203f0e24" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully inserted or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 삽입되거나 한 경우 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="ebff193a925e1e6c88a5aaae59a0f61ddce1cce8" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, struct}&lt;/code&gt; if the struct has been successfully updated or &lt;code&gt;{:error, changeset}&lt;/code&gt; if there was a validation or a known constraint error.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, struct}&lt;/code&gt; 구조체가 성공적으로 업데이트하거나 한 경우 &lt;code&gt;{:error, changeset}&lt;/code&gt; 검증하거나 검증 된 제약 에러가 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="0de4905b00b9de98c7609ccd5172409bb3e98d86" translate="yes" xml:space="preserve">
          <source>It returns a stream of values.</source>
          <target state="translated">값의 스트림을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d945823e21b496648aba33471fce7ac539af8894" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. 데이터베이스가 INSERT 문에서 RETURNING을 지원하지 않거나 리턴 결과가 선택되지 않은 경우 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2de945d39c2f6ebed7d1277d00db21d0a2293afd" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the update query. Note, however, not all databases support returning data from DELETEs.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. &lt;code&gt;select&lt;/code&gt; 이 업데이트 쿼리에 제공 되지 않으면 기본적으로 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 DELETE에서 데이터 리턴을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd503f783ffe50789a63b679ddc9eae334819de3" translate="yes" xml:space="preserve">
          <source>It returns a tuple containing the number of entries and any returned result as second element. The second element is &lt;code&gt;nil&lt;/code&gt; by default unless a &lt;code&gt;select&lt;/code&gt; is supplied in the update query. Note, however, not all databases support returning data from UPDATEs.</source>
          <target state="translated">항목 수와 두 번째 요소로 리턴 된 결과를 포함하는 튜플을 리턴합니다. &lt;code&gt;select&lt;/code&gt; 이 업데이트 쿼리에 제공 되지 않으면 기본적으로 두 번째 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다. 그러나 모든 데이터베이스가 UPDATE에서 데이터 리턴을 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5cb46c1b2cfe83bb261f99a63434e88b8c939760" translate="yes" xml:space="preserve">
          <source>It returns the result of the function. This is useful when you need to perform multiple operations against the repository in a row and you want to avoid checking out the connection multiple times.</source>
          <target state="translated">함수의 결과를 반환합니다. 이는 저장소에 대해 여러 작업을 연속으로 수행해야하고 연결을 여러 번 체크 아웃하지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="617f00d23c5d3066a19c5e3ce78c044821a23f5a" translate="yes" xml:space="preserve">
          <source>It sets the connection state to &lt;code&gt;:set&lt;/code&gt; (if not already &lt;code&gt;:set&lt;/code&gt;) and raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; if it was already &lt;code&gt;:sent&lt;/code&gt;.</source>
          <target state="translated">그것은 연결에 대한 상태를 설정 &lt;code&gt;:set&lt;/code&gt; (그렇지 않으면 이미 &lt;code&gt;:set&lt;/code&gt; )과 인상을 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt; 그것은 이미 한 경우 &lt;code&gt;:sent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c36c6b7e91751f2ec48df7d4ea27f4e7e31732" translate="yes" xml:space="preserve">
          <source>It sets the following headers:</source>
          <target state="translated">다음과 같은 헤더를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c088e2a507a2a5e02f9225879e207b1cc9d659c3" translate="yes" xml:space="preserve">
          <source>It uses the configured &lt;code&gt;:format_encoders&lt;/code&gt; under the &lt;code&gt;:phoenix&lt;/code&gt; application for &lt;code&gt;:json&lt;/code&gt; to pick up the encoder module.</source>
          <target state="translated">그것은 구성된 사용 &lt;code&gt;:format_encoders&lt;/code&gt; 언더 &lt;code&gt;:phoenix&lt;/code&gt; 신청 &lt;code&gt;:json&lt;/code&gt; 인코더 모듈을 데리러.</target>
        </trans-unit>
        <trans-unit id="02cb0c375004c2445f7a4b48bb5c6b5a1e02d0ca" translate="yes" xml:space="preserve">
          <source>It will print &lt;code&gt;[custom: :options]&lt;/code&gt; as the builder options were passed to the inner plug.</source>
          <target state="translated">빌더 옵션이 내부 플러그로 전달되면 &lt;code&gt;[custom: :options]&lt;/code&gt; 가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="e932cc853633259a073e9bc817ae714d9a39c458" translate="yes" xml:space="preserve">
          <source>It works exactly as the keyword query version of &lt;a href=&quot;#order_by/3&quot;&gt;&lt;code&gt;order_by/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#order_by/3&quot;&gt; &lt;code&gt;order_by/3&lt;/code&gt; &lt;/a&gt; 의 키워드 쿼리 버전과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e45e5922ce914746230466b94c7fd740acd1fec9" translate="yes" xml:space="preserve">
          <source>It would make no difference to Ecto. This is important because it allows developers to compose queries without caring about the bindings used in the initial query.</source>
          <target state="translated">Ecto와는 아무런 차이가 없습니다. 개발자가 초기 쿼리에 사용 된 바인딩을 신경 쓰지 않고 쿼리를 작성할 수 있기 때문에 이것은 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f998c41fbf62a9340e17dee0bf437b58bc29010a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to force garbage collection in the transport process after processing large messages.</source>
          <target state="translated">대용량 메시지를 처리 ​​한 후 전송 프로세스에서 가비지 콜렉션을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8591bde56739aa5275d5d85d6a798e00bc371f2c" translate="yes" xml:space="preserve">
          <source>JSON arrays are parsed into a &lt;code&gt;&quot;_json&quot;&lt;/code&gt; key to allow proper param merging.</source>
          <target state="translated">JSON 배열은 &lt;code&gt;&quot;_json&quot;&lt;/code&gt; 키로 구문 분석되어 적절한 매개 변수 병합이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="10d5f74dbf369576734a6ac682a4a030a54c7295" translate="yes" xml:space="preserve">
          <source>JavaScript dependency</source>
          <target state="translated">자바 스크립트 의존성</target>
        </trans-unit>
        <trans-unit id="2487b95e85c7fe6d18646545ea40fb331697431c" translate="yes" xml:space="preserve">
          <source>Join Schema Example</source>
          <target state="translated">조인 스키마 예</target>
        </trans-unit>
        <trans-unit id="669d3f3b74c1d931ea3e5af907f9c949381661d4" translate="yes" xml:space="preserve">
          <source>Joining with fragments</source>
          <target state="translated">조각으로 결합</target>
        </trans-unit>
        <trans-unit id="5207cd0b1b61b86c4ade218e352d2c11be05f56f" translate="yes" xml:space="preserve">
          <source>Joins the channel under the given topic and payload</source>
          <target state="translated">주어진 주제와 페이로드에서 채널에 참여</target>
        </trans-unit>
        <trans-unit id="27105bb472e95e58a185d9b6f056c464b00b8238" translate="yes" xml:space="preserve">
          <source>Joins the channel under the given topic and payload.</source>
          <target state="translated">주어진 주제와 페이로드에서 채널에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="47359e7039cce9b20721fbf73895d042b4baa139" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;:reloadable_compilers&lt;/code&gt; must be a subset of the &lt;code&gt;:compilers&lt;/code&gt; specified in &lt;code&gt;project/0&lt;/code&gt; in your &lt;code&gt;mix.exs&lt;/code&gt;.</source>
          <target state="translated">명심하십시오 &lt;code&gt;:reloadable_compilers&lt;/code&gt; 이 의 하위 집합이어야합니다 &lt;code&gt;:compilers&lt;/code&gt; 에 지정된 &lt;code&gt;project/0&lt;/code&gt; 당신에 &lt;code&gt;mix.exs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621e4edd3a1dcb97c56ea183a37744b57bb45b43" translate="yes" xml:space="preserve">
          <source>Keep in mind Phoenix will automatically recycle the connection between dispatches. This usually works out well most times, but it may discard information if you are modifying the connection before the next dispatch:</source>
          <target state="translated">Phoenix는 발송 사이의 연결을 자동으로 재활용합니다. 일반적으로 대부분 잘 작동하지만 다음 디스패치 전에 연결을 수정하면 정보가 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="331125190d2a2354adf50058bea5b635af515279" translate="yes" xml:space="preserve">
          <source>Keep in mind that we advise the map keys to be strings or integers instead of atoms. Atoms may be accepted depending on how maps are serialized but the database will always convert atom keys to strings due to security reasons.</source>
          <target state="translated">지도 키는 원자 대신 문자열 또는 정수로 사용하는 것이 좋습니다. 맵이 직렬화되는 방식에 따라 원자가 승인 될 수 있지만 데이터베이스는 보안상의 이유로 항상 원자 키를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2b5e3cabe364eb4be494f179754ad9a13637213c" translate="yes" xml:space="preserve">
          <source>Keep in mind this &lt;code&gt;update_all&lt;/code&gt; will not update autogenerated fields like the &lt;code&gt;updated_at&lt;/code&gt; columns.</source>
          <target state="translated">이 &lt;code&gt;update_all&lt;/code&gt; 은 &lt;code&gt;updated_at&lt;/code&gt; 열과 같은 자동 생성 필드를 업데이트하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="299a4b98174cae36a3bded071df303aca8d08070" translate="yes" xml:space="preserve">
          <source>Keep in mind you want to use hints rarely, so don&amp;rsquo;t forget to read the database disclaimers about such functionality.</source>
          <target state="translated">힌트를 거의 사용하지 않으려면 이러한 기능에 대한 데이터베이스 고지 사항을 반드시 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="9a94cfc7b2fedabc45202f752518e42387b1479f" translate="yes" xml:space="preserve">
          <source>Keeps track of presences in a single shard</source>
          <target state="translated">단일 샤드에서 현재 상태를 추적합니다</target>
        </trans-unit>
        <trans-unit id="07a8182406eb3604641127149a583b03956a7aec" translate="yes" xml:space="preserve">
          <source>Keys are case insensitive and downcased, invalid key-value pairs are discarded.</source>
          <target state="translated">키는 대소 문자를 구분하지 않으며 소문자이며 유효하지 않은 키-값 쌍은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f646918bb09aa52636f453f3bef43322294ab327" translate="yes" xml:space="preserve">
          <source>Keyword fragments</source>
          <target state="translated">키워드 조각</target>
        </trans-unit>
        <trans-unit id="d6f5b95bb6336d1b9972cc37a8893e22ef3605ff" translate="yes" xml:space="preserve">
          <source>Keywords can also be given or interpolated as part of &lt;code&gt;on&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 의 일부로 키워드를 제공하거나 보간 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2723e28604ac818370f58695dbeb251d15a692e0" translate="yes" xml:space="preserve">
          <source>Keywords example</source>
          <target state="translated">키워드 예</target>
        </trans-unit>
        <trans-unit id="8527969b5917b99377eaa45d7f9a2ada9dc3bfd2" translate="yes" xml:space="preserve">
          <source>Keywords examples</source>
          <target state="translated">키워드 예</target>
        </trans-unit>
        <trans-unit id="4bbd4701bb11bdf8cb772e866b8507d8365cf806" translate="yes" xml:space="preserve">
          <source>Known status codes</source>
          <target state="translated">알려진 상태 코드</target>
        </trans-unit>
        <trans-unit id="0b12a998982672c9c6ed53b2d324f6daa513af06" translate="yes" xml:space="preserve">
          <source>Last but not least, Ecto allows you to write queries in Elixir and send them to the repository, which translates them to the underlying database. Let&amp;rsquo;s see an example:</source>
          <target state="translated">마지막으로, Ecto를 사용하면 Elixir에서 쿼리를 작성하고 리포지토리로 보내서 기본 데이터베이스로 변환 할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="28e6f54e33a1151bfd4c7cc4affd14df3525f2db" translate="yes" xml:space="preserve">
          <source>Layouts</source>
          <target state="translated">Layouts</target>
        </trans-unit>
        <trans-unit id="3d156c82e277315dd675804808caa48f6121a42e" translate="yes" xml:space="preserve">
          <source>Leave and close</source>
          <target state="translated">떠나고 닫으십시오</target>
        </trans-unit>
        <trans-unit id="48cbd714362b332f46af7c0449a1162f10ad14a7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example definition and usage. The use case we&amp;rsquo;ll be looking into is resetting a password. We need to update the account with proper information, log the request and remove all current sessions:</source>
          <target state="translated">정의 및 사용법의 예를 살펴 보겠습니다. 우리가 살펴볼 유스 케이스는 비밀번호를 재설정하는 것입니다. 적절한 정보로 계정을 업데이트하고 요청을 기록한 다음 모든 현재 세션을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="631c60aa60bc16b1bf740a990139dd79086a4394" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see a sample query:</source>
          <target state="translated">샘플 쿼리를 보자.</target>
        </trans-unit>
        <trans-unit id="eee9f4926b9b562d7d7d24617f54066feabfd955" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see an example where using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is a good fit.</source>
          <target state="translated">&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋은 예를 보자 .</target>
        </trans-unit>
        <trans-unit id="496ebc27fbab27f3e6746ffd987c96f94e9a702c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see an example:</source>
          <target state="translated">예를 보자.</target>
        </trans-unit>
        <trans-unit id="bc3d553ca52816cf4129cd63c38245f87b3da82f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see some examples. To see the query prefix globally, the simplest mechanism is to pass an option to the repository operation:</source>
          <target state="translated">몇 가지 예를 봅시다. 쿼리 접두사를 전체적으로 보려면 가장 간단한 방법은 리포지토리 작업에 옵션을 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7e2fcaa4bcf585ecc64057fde915c3a9de78479" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s suppose the e-mail is given but the age is invalid. The changeset would have the following errors:</source>
          <target state="translated">이메일이 제공되었지만 나이가 유효하지 않다고 가정 해 봅시다. 변경 세트에는 다음 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="dcdf1f3f20d25750eec18cb3946ae2be25cb8eaa" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;assert_broadcast&lt;/code&gt;, the event and payload are patterns.</source>
          <target state="translated">&lt;code&gt;assert_broadcast&lt;/code&gt; 와 마찬가지로 이벤트와 페이로드는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="d486907f4d390d5bb6c5c2f6b978b91b0d62fc4e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;assert_push&lt;/code&gt;, the event and payload are patterns.</source>
          <target state="translated">&lt;code&gt;assert_push&lt;/code&gt; 와 마찬가지로 이벤트와 페이로드는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="c1e5c3ab8c6ae38a073f8acc6293e0c0a2698284" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;assert_reply&lt;/code&gt;, the event and payload are patterns.</source>
          <target state="translated">&lt;code&gt;assert_reply&lt;/code&gt; 와 마찬가지로 이벤트와 페이로드는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="28a791b4db77913904c38cfe58adaaf487678aff" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;having&lt;/code&gt; but combines with the previous expression by using &lt;code&gt;OR&lt;/code&gt;. &lt;code&gt;or_having&lt;/code&gt; behaves for &lt;code&gt;having&lt;/code&gt; the same way &lt;code&gt;or_where&lt;/code&gt; behaves for &lt;code&gt;where&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;having&lt;/code&gt; 있지만 사용하여 이전의 표현과 결합 &lt;code&gt;OR&lt;/code&gt; . &lt;code&gt;or_having&lt;/code&gt; 에 대한 동작합니다을 &lt;code&gt;having&lt;/code&gt; 같은 방식으로 &lt;code&gt;or_where&lt;/code&gt; 에 대한 동작합니다 . &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c49abb0983070a22d29b7273189d0776225eabc5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; filters rows from the schema, but after the grouping is performed giving it the same semantics as &lt;code&gt;select&lt;/code&gt; for a grouped query (see &lt;a href=&quot;#group_by/3&quot;&gt;&lt;code&gt;group_by/3&lt;/code&gt;&lt;/a&gt;). &lt;code&gt;having&lt;/code&gt; groups the query even if the query has no &lt;code&gt;group_by&lt;/code&gt; expression.</source>
          <target state="translated">마찬가지로 &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;having&lt;/code&gt; 스키마에서 필터 행했지만 그룹핑 후의으로 동일한 의미를주는 수행되는 &lt;code&gt;select&lt;/code&gt; 그룹화 쿼리 (참조 &lt;a href=&quot;#group_by/3&quot;&gt; &lt;code&gt;group_by/3&lt;/code&gt; &lt;/a&gt; ). 쿼리에 &lt;code&gt;group_by&lt;/code&gt; 표현식 이없는 경우에도 쿼리 &lt;code&gt;having&lt;/code&gt; 그룹화합니다 .</target>
        </trans-unit>
        <trans-unit id="03eaa0d73103e80b4696a385480906421628b2d0" translate="yes" xml:space="preserve">
          <source>Like all functions in this module, the &lt;code&gt;conn&lt;/code&gt; returned by &lt;code&gt;read_body&lt;/code&gt; must be passed to the next stage of your pipeline and should not be ignored.</source>
          <target state="translated">이 모듈의 모든 함수와 마찬가지로 &lt;code&gt;read_body&lt;/code&gt; 에 의해 반환 된 &lt;code&gt;conn&lt;/code&gt; 은 파이프 라인의 다음 단계로 전달되어야하며 무시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5397e1c8fe3990864e664661bb79fede1d642082" translate="yes" xml:space="preserve">
          <source>Like routers, controllers are plugs, but they are wired to dispatch to a particular function which is called an action.</source>
          <target state="translated">라우터와 마찬가지로 컨트롤러는 플러그이지만 동작이라고하는 특정 기능으로 디스패치되도록 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4808633a2ab2296b7932aebce8b1e52933d4ac4e" translate="yes" xml:space="preserve">
          <source>Limits the number of rows returned from the result. Can be any expression but has to evaluate to an integer value and it can&amp;rsquo;t include any field.</source>
          <target state="translated">결과에서 반환되는 행 수를 제한합니다. 모든 표현식이 될 수 있지만 정수 값으로 평가되어야하며 필드를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef1386ae50a4573cddb5393b59e23b0d14285c49" translate="yes" xml:space="preserve">
          <source>Links to the text editor</source>
          <target state="translated">텍스트 편집기로 연결</target>
        </trans-unit>
        <trans-unit id="3daed10a79c7363f6ca411964fab08bbb45dd2d8" translate="yes" xml:space="preserve">
          <source>Lists all functions allowed in the query API.</source>
          <target state="translated">쿼리 API에서 허용되는 모든 함수를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="815704335e99997946fd7e2eb4b7a04f3a3b2307" translate="yes" xml:space="preserve">
          <source>Lists all presences tracked under a given topic</source>
          <target state="translated">특정 주제에서 추적 된 모든 현재 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="bae3a2425aba950d370a4070fef8ada60ba48039" translate="yes" xml:space="preserve">
          <source>Lists all presences tracked under a given topic.</source>
          <target state="translated">주어진 주제에서 추적 된 모든 현재 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4bdaba18f84a5a60e20f166eb2402f70f6f23d34" translate="yes" xml:space="preserve">
          <source>Lists all windows functions.</source>
          <target state="translated">모든 창 기능을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="86f0d2ee14ec0f4ca6ecca72abf2e2fcc658b115" translate="yes" xml:space="preserve">
          <source>Lists are created with &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">리스트는 &lt;code&gt;[]&lt;/code&gt; 로 생성됩니다 :</target>
        </trans-unit>
        <trans-unit id="5157f161ff9924001000e57a45ac9c5313681de2" translate="yes" xml:space="preserve">
          <source>Literal syntax in query</source>
          <target state="translated">쿼리의 리터럴 구문</target>
        </trans-unit>
        <trans-unit id="e9a9640e18b7869d8f7e2ceddccf74aef091b653" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;data&lt;/code&gt; into a struct or a map</source>
          <target state="translated">구조체 나 맵에 &lt;code&gt;data&lt;/code&gt; 를 로드</target>
        </trans-unit>
        <trans-unit id="fb2e98e74e82eb7e2474cb754cd6b9096a3f6741" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;data&lt;/code&gt; into a struct or a map.</source>
          <target state="translated">구조체 또는 맵에 &lt;code&gt;data&lt;/code&gt; 를 로드 합니다 .</target>
        </trans-unit>
        <trans-unit id="82aff2203375dcddd99030298fa0fd4111ff9e20" translate="yes" xml:space="preserve">
          <source>Loads a value with the given type</source>
          <target state="translated">주어진 타입으로 값을로드</target>
        </trans-unit>
        <trans-unit id="a18c618fa4df41a3d4e0a01c037f434dac2896d7" translate="yes" xml:space="preserve">
          <source>Loads a value with the given type.</source>
          <target state="translated">주어진 유형으로 값을로드합니다.</target>
        </trans-unit>
        <trans-unit id="b269f8fe0c26ed86332fe55318e12ba6ca8edd78" translate="yes" xml:space="preserve">
          <source>Loads the given term into a custom type</source>
          <target state="translated">주어진 용어를 사용자 정의 유형으로로드</target>
        </trans-unit>
        <trans-unit id="3fe85d96329792635d8589e2b28d8c7d163b68a5" translate="yes" xml:space="preserve">
          <source>Loads the given term into a custom type.</source>
          <target state="translated">주어진 용어를 사용자 정의 유형으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="4ec296012bb3dc5612ab1f74bd74837d8c5bd816" translate="yes" xml:space="preserve">
          <source>Local PubSub server supervisor.</source>
          <target state="translated">로컬 PubSub 서버 관리자.</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="aea106bc34b23b21819e5f4e10f742e1cd442e25" translate="yes" xml:space="preserve">
          <source>Logs the given entry in the given level</source>
          <target state="translated">주어진 레벨에 주어진 항목을 기록</target>
        </trans-unit>
        <trans-unit id="008ad5939b30b44a5a3f7467494f7bfda37f2c86" translate="yes" xml:space="preserve">
          <source>Logs the given entry in the given level.</source>
          <target state="translated">주어진 레벨에서 주어진 항목을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="f943d416e2ada7a0922291d06f813a919e5f4338" translate="yes" xml:space="preserve">
          <source>Logs the transport request</source>
          <target state="translated">전송 요청을 기록합니다</target>
        </trans-unit>
        <trans-unit id="a4d314c6f2abcc14a73e4df67793b447704d1088" translate="yes" xml:space="preserve">
          <source>Logs the transport request.</source>
          <target state="translated">전송 요청을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="4c44d1a0d8628a1cd966123bf0558926c82708fe" translate="yes" xml:space="preserve">
          <source>Macro API</source>
          <target state="translated">매크로 API</target>
        </trans-unit>
        <trans-unit id="1abed56a50038fd3d93f973f0467ce40a2147338" translate="yes" xml:space="preserve">
          <source>Main API to define routes</source>
          <target state="translated">경로를 정의하는 기본 API</target>
        </trans-unit>
        <trans-unit id="39960b7f5715ba45e19e351b393e17e2cfdadb17" translate="yes" xml:space="preserve">
          <source>Main API to define routes.</source>
          <target state="translated">경로를 정의하는 기본 API</target>
        </trans-unit>
        <trans-unit id="99a0f320b2fb537dd42a7812df48f82897713b9d" translate="yes" xml:space="preserve">
          <source>Managing channel exits</source>
          <target state="translated">채널 이탈 관리</target>
        </trans-unit>
        <trans-unit id="3ad3d529b12f4fc16303c879aff5c55cedcb3d8b" translate="yes" xml:space="preserve">
          <source>Managing channels</source>
          <target state="translated">채널 관리</target>
        </trans-unit>
        <trans-unit id="f79b5db13b12d3811bad65573044bfefb5c0c943" translate="yes" xml:space="preserve">
          <source>Manual Cipher Configuration</source>
          <target state="translated">수동 암호 구성</target>
        </trans-unit>
        <trans-unit id="05bfe4c2872329a4aea7503289ab18b4416bd983" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok,
value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 많은 기능은 내부적으로이 기능을 호출합니다. 이 함수는 대괄호 액세스 구문 ( &lt;code&gt;structure[key]&lt;/code&gt; )이 사용될 때도 사용됩니다. &lt;code&gt;structure&lt;/code&gt; 구조체 를 정의하는 모듈에 의해 구현 된 &lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; &lt;/a&gt; 콜백 이 호출되고 &lt;code&gt;{:ok, value}&lt;/code&gt; 를 리턴하면 &lt;code&gt;value&lt;/code&gt; 는 반환되거나, &lt;code&gt;:error&lt;/code&gt; 를 반환하면 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0622625664d77a22b6a2176664f5f9d1fb2bb591" translate="yes" xml:space="preserve">
          <source>Many times, the data given on cast needs to be further pruned, specially regarding empty values. For example, if you are gathering data to be cast from the command line or through an HTML form or any other text-based format, it is likely those means cannot express nil values. For those reasons, changesets include the concept of empty values, which are values that will be automatically converted to the field&amp;rsquo;s default value on &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Those values are stored in the changeset &lt;code&gt;empty_values&lt;/code&gt; field and default to &lt;code&gt;[&quot;&quot;]&lt;/code&gt;.</source>
          <target state="translated">캐스트에 제공된 데이터는 특히 빈 값과 관련하여 추가로 정리해야합니다. 예를 들어, 명령 행에서 또는 HTML 양식 또는 기타 텍스트 기반 형식으로 캐스트 할 데이터를 수집하는 경우 이러한 방법으로 nil 값을 표현할 수 없습니다. 이러한 이유로 변경 세트에는 빈 값의 개념이 포함되며, 이는 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 의 필드 기본값으로 자동 변환되는 값입니다 . 이러한 값은 changeset &lt;code&gt;empty_values&lt;/code&gt; 필드에 저장되며 기본값은 &lt;code&gt;[&quot;&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e03bc8f9ea572e8bb58396508ed7400daec8e4f" translate="yes" xml:space="preserve">
          <source>Maps can be encoded:</source>
          <target state="translated">지도를 인코딩 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c0b2e757f9c2b7f54b059bdc66921ad7db9abcda" translate="yes" xml:space="preserve">
          <source>Marks a replica as down in the set and returns left users</source>
          <target state="translated">세트에서 복제본을 다운으로 표시하고 왼쪽 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f6ecb4b64f782c1574eeade5e3a5e6c7d5499e1" translate="yes" xml:space="preserve">
          <source>Marks a replica as down in the set and returns left users.</source>
          <target state="translated">세트에서 복제본을 다운으로 표시하고 왼쪽 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cac75985ecff81fbaa9d6395fc501bef58477065" translate="yes" xml:space="preserve">
          <source>Marks a replica as up in the set and returns rejoined users</source>
          <target state="translated">세트에서 복제본을 마크 업으로 표시하고 재결합 된 사용자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4a0f7b96b57238ae8a59d72d6764bfd2f16087e3" translate="yes" xml:space="preserve">
          <source>Marks a replica as up in the set and returns rejoined users.</source>
          <target state="translated">세트에서 복제본을 마크 업으로 표시하고 재결합 된 사용자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e05b3b197d8b8e77c17df65ec7660a891ba833fe" translate="yes" xml:space="preserve">
          <source>May raise &lt;a href=&quot;ecto.queryerror&quot;&gt;&lt;code&gt;Ecto.QueryError&lt;/code&gt;&lt;/a&gt; if query validation fails.</source>
          <target state="translated">제기 할 수 &lt;a href=&quot;ecto.queryerror&quot;&gt; &lt;code&gt;Ecto.QueryError&lt;/code&gt; 를&lt;/a&gt; 쿼리 유효성 검사가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b74c072bb7013187872af44544af0e8b5d38f913" translate="yes" xml:space="preserve">
          <source>Mergeable select query expression</source>
          <target state="translated">병합 가능한 선택 쿼리 식</target>
        </trans-unit>
        <trans-unit id="e0602da34e956cfe4ccf39291af6bbf743972760" translate="yes" xml:space="preserve">
          <source>Mergeable select query expression.</source>
          <target state="translated">병합 가능한 선택 쿼리 식</target>
        </trans-unit>
        <trans-unit id="a9a97d779516c6c12de75d8a51f3e4535af915a5" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by an anonymous function</source>
          <target state="translated">익명 함수에 의해 동적으로 반환 된 멀티를 병합</target>
        </trans-unit>
        <trans-unit id="7539ec95f69d1d6b4a4634b33a0a8590c79d83ad" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by an anonymous function.</source>
          <target state="translated">익명 함수에 의해 동적으로 반환 된 멀티를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="502de2d879d943b97d0456728f32d2c986101961" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by calling &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 를 사용 하여 &lt;code&gt;module&lt;/code&gt; 과 &lt;code&gt;function&lt;/code&gt; 를 호출하여 동적으로 반환 된 멀티를 병합</target>
        </trans-unit>
        <trans-unit id="29a2e7237d9dee4cc5a360feac545f1d1971bad4" translate="yes" xml:space="preserve">
          <source>Merges a multi returned dynamically by calling &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 를 사용 하여 &lt;code&gt;module&lt;/code&gt; 및 &lt;code&gt;function&lt;/code&gt; 을 호출하여 동적으로 반환 된 멀티를 병합합니다 .</target>
        </trans-unit>
        <trans-unit id="57958d33f03b60f05d8a34f941485854b9bf467d" translate="yes" xml:space="preserve">
          <source>Merges a series of response headers into the connection</source>
          <target state="translated">일련의 응답 헤더를 연결에 병합</target>
        </trans-unit>
        <trans-unit id="ce5152c17c059a57bc8e11b5c5b0541b8e4778a9" translate="yes" xml:space="preserve">
          <source>Merges a series of response headers into the connection.</source>
          <target state="translated">일련의 응답 헤더를 연결에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="941f60e1885ad38ab5cd520fe6ac6723852ffc96" translate="yes" xml:space="preserve">
          <source>Merges the map on the right over the map on the left</source>
          <target state="translated">오른쪽의지도를 왼쪽의지도 위에 병합</target>
        </trans-unit>
        <trans-unit id="2e8960db43dcc2c7152168ec7ddbeaa64641007c" translate="yes" xml:space="preserve">
          <source>Merges the map on the right over the map on the left.</source>
          <target state="translated">오른쪽의 맵을 왼쪽의 맵 위에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="02b5244c8d4b9e3c41b4940e22fc1dfb9c417c42" translate="yes" xml:space="preserve">
          <source>Merges two changesets</source>
          <target state="translated">두 개의 변경 세트를 병합</target>
        </trans-unit>
        <trans-unit id="531ed93b3b84f718e731466faa80ec118f9e0df8" translate="yes" xml:space="preserve">
          <source>Merges two changesets.</source>
          <target state="translated">두 개의 변경 세트를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="a3915b79f92d6a448ae5c8fabd6eee46571b15e0" translate="yes" xml:space="preserve">
          <source>Merges two sets, or a delta into a set</source>
          <target state="translated">두 세트 또는 델타를 세트로 병합</target>
        </trans-unit>
        <trans-unit id="122840ff6ee2d32e7c4455601ee79ffe39542536" translate="yes" xml:space="preserve">
          <source>Merges two sets, or a delta into a set.</source>
          <target state="translated">두 세트 또는 델타를 세트로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="6e458173eef4a800366eeb68965cf8f147c4756b" translate="yes" xml:space="preserve">
          <source>Migration</source>
          <target state="translated">Migration</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="3c9bf7c6de3ecb74ac52b84e399f4368727e2a2b" translate="yes" xml:space="preserve">
          <source>Mix tasks and generators</source>
          <target state="translated">혼합 작업 및 생성기</target>
        </trans-unit>
        <trans-unit id="82ea088f9a1123debf0e7aa3ef3f18ae150571d5" translate="yes" xml:space="preserve">
          <source>Mix.Ecto</source>
          <target state="translated">Mix.Ecto</target>
        </trans-unit>
        <trans-unit id="a5bacc2154fe35adde562356475fbcb75af8d43b" translate="yes" xml:space="preserve">
          <source>Module plugs</source>
          <target state="translated">모듈 플러그</target>
        </trans-unit>
        <trans-unit id="023d267e1867d5eff92406f80cc111867c1210f6" translate="yes" xml:space="preserve">
          <source>More information on the migration for creating such a schema is shown below.</source>
          <target state="translated">이러한 스키마 작성을위한 마이그레이션에 대한 자세한 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a4254e79e985b1798114b8612784970b94d85d5" translate="yes" xml:space="preserve">
          <source>Most HTTP/1.1 clients do not properly support informational responses but some proxies require it to support server push for HTTP/2. You can call &lt;a href=&quot;#get_http_protocol/1&quot;&gt;&lt;code&gt;get_http_protocol/1&lt;/code&gt;&lt;/a&gt; to retrieve the protocol and version.</source>
          <target state="translated">대부분의 HTTP / 1.1 클라이언트는 정보 응답을 제대로 지원하지 않지만 일부 프록시는 HTTP / 2에 대한 서버 푸시를 지원해야합니다. &lt;a href=&quot;#get_http_protocol/1&quot;&gt; &lt;code&gt;get_http_protocol/1&lt;/code&gt; &lt;/a&gt; 을 호출 하여 프로토콜 및 버전을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb09ee4b294fbfea38eb275e1237d7d1466082d6" translate="yes" xml:space="preserve">
          <source>Most of the configuration that goes into the &lt;code&gt;config&lt;/code&gt; is specific to the adapter, so check &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; documentation for more information. However, some configuration is shared across all adapters, they are:</source>
          <target state="translated">에 들어가는 대부분의 구성 &lt;code&gt;config&lt;/code&gt; 그래서 확인, 어댑터에 고유 &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; 에 대한 자세한 내용은 문서를. 그러나 일부 구성은 모든 어댑터에서 공유되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c145af550dde5f46b9e4696ddd1212973954998" translate="yes" xml:space="preserve">
          <source>Most of the times, Ecto is able to proper cast interpolated values due to its type checking mechanism. In some situations though, you may want to tell Ecto that a parameter has some particular type:</source>
          <target state="translated">대부분의 경우 Ecto는 유형 검사 메커니즘으로 인해 적절한 보간 값을 캐스팅 할 수 있습니다. 그러나 어떤 상황에서는 Ecto에 매개 변수에 특정 유형이 있다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68f134ad078fea264b6de84ed9f31c5503c7679c" translate="yes" xml:space="preserve">
          <source>Most of those messages are user messages except:</source>
          <target state="translated">이러한 메시지는 대부분 다음을 제외하고 사용자 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="e4817e037eb35285aec42c91897d990919177151" translate="yes" xml:space="preserve">
          <source>Moves cookies from a connection into a new connection for subsequent requests</source>
          <target state="translated">후속 요청을 위해 쿠키를 연결에서 새 연결로 이동</target>
        </trans-unit>
        <trans-unit id="01c37f68ea24f1c8881a0bb14ffdf08a1ed447b9" translate="yes" xml:space="preserve">
          <source>Moves cookies from a connection into a new connection for subsequent requests.</source>
          <target state="translated">후속 요청을 위해 쿠키를 연결에서 새 연결로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="833bffc08d3a9c875fbb22617882f0e1a5923f92" translate="yes" xml:space="preserve">
          <source>Multi allows you to run arbitrary functions as part of your transaction via &lt;a href=&quot;#run/3&quot;&gt;&lt;code&gt;run/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#run/5&quot;&gt;&lt;code&gt;run/5&lt;/code&gt;&lt;/a&gt;. This is especially useful when an operation depends on the value of a previous operation. For this reason, the function given as a callback to &lt;a href=&quot;#run/3&quot;&gt;&lt;code&gt;run/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#run/5&quot;&gt;&lt;code&gt;run/5&lt;/code&gt;&lt;/a&gt; will receive the repo as the first argument, and all changes performed by the multi so far as a map for the second argument.</source>
          <target state="translated">Multi를 사용하면 &lt;a href=&quot;#run/3&quot;&gt; &lt;code&gt;run/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#run/5&quot;&gt; &lt;code&gt;run/5&lt;/code&gt; &lt;/a&gt; 통해 트랜잭션의 일부로 임의의 기능을 실행할 수 있습니다 . 이것은 조작이 이전 조작의 값에 의존 할 때 특히 유용합니다. 이러한 이유로 &lt;a href=&quot;#run/3&quot;&gt; &lt;code&gt;run/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#run/5&quot;&gt; &lt;code&gt;run/5&lt;/code&gt; 에&lt;/a&gt; 대한 콜백으로 제공된 함수 는 첫 번째 인수로 repo를 수신하고 두 번째 인수에 대한 맵까지 멀티에 의해 수행 된 모든 변경 사항을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="762b531feb7f88155017a3d9112eac22dd92c8cc" translate="yes" xml:space="preserve">
          <source>Multiple plugs can be defined with the &lt;a href=&quot;#plug/2&quot;&gt;&lt;code&gt;plug/2&lt;/code&gt;&lt;/a&gt; macro, forming a pipeline. The plugs in the pipeline will be executed in the order they&amp;rsquo;ve been added through the &lt;a href=&quot;#plug/2&quot;&gt;&lt;code&gt;plug/2&lt;/code&gt;&lt;/a&gt; macro. In the example above, &lt;a href=&quot;plug.logger&quot;&gt;&lt;code&gt;Plug.Logger&lt;/code&gt;&lt;/a&gt; will be called first and then the &lt;code&gt;:hello&lt;/code&gt; function plug will be called on the resulting connection.</source>
          <target state="translated">&lt;a href=&quot;#plug/2&quot;&gt; &lt;code&gt;plug/2&lt;/code&gt; &lt;/a&gt; 매크로로 여러 개의 플러그를 정의 하여 파이프 라인을 형성 할 수 있습니다 . 파이프 라인의 &lt;a href=&quot;#plug/2&quot;&gt; &lt;code&gt;plug/2&lt;/code&gt; &lt;/a&gt; 는 플러그 / 2 매크로를 통해 추가 된 순서대로 실행됩니다 . 위의 예제에서 &lt;a href=&quot;plug.logger&quot;&gt; &lt;code&gt;Plug.Logger&lt;/code&gt; &lt;/a&gt; 가 먼저 호출 된 다음 결과 연결 에서 &lt;code&gt;:hello&lt;/code&gt; 함수 플러그가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="13989bd1dc00ffbc980d6c94b69810e4ef0e3b83" translate="yes" xml:space="preserve">
          <source>NOTE: Ecto does not lazy load associations. While lazily loading associations may sound convenient at first, in the long run it becomes a source of confusion and performance issues.</source>
          <target state="translated">참고 : Ecto는로드 연관을 지연시키지 않습니다. 처음에는 느리게로드되는 연결이 편리하게 들리지만 장기적으로 혼란과 성능 문제의 원인이됩니다.</target>
        </trans-unit>
        <trans-unit id="e14cb300ba8325c2102c73a68cebde93c1baf4c8" translate="yes" xml:space="preserve">
          <source>NOTE: by using &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;, an &lt;code&gt;:id&lt;/code&gt; field with type &lt;code&gt;:id&lt;/code&gt; (:id means :integer) is generated by default, which is the primary key of the Schema. If you want to use a different primary key, you can declare custom &lt;code&gt;@primary_key&lt;/code&gt; before the &lt;code&gt;schema/2&lt;/code&gt; call. Consult the &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="translated">참고 : &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 를 사용 하면 기본적으로 스키마의 기본 키인 유형 &lt;code&gt;:id&lt;/code&gt; (: id는 : integer) 인 &lt;code&gt;:id&lt;/code&gt; 필드 가 생성됩니다. 다른 기본 키를 사용 하려면 &lt;code&gt;schema/2&lt;/code&gt; 호출 전에 사용자 정의 &lt;code&gt;@primary_key&lt;/code&gt; 를 선언 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75759c54c05dc9ac9a57424fb90dc1564b6105c9" translate="yes" xml:space="preserve">
          <source>NaN and infinite decimals are not supported, use custom types instead.</source>
          <target state="translated">NaN 및 무한 소수는 지원되지 않습니다. 대신 사용자 정의 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ecd8adfc3b9778f59e1149aee2d219e827012b80" translate="yes" xml:space="preserve">
          <source>Named bindings</source>
          <target state="translated">명명 된 바인딩</target>
        </trans-unit>
        <trans-unit id="4c7e5d8bec4aa7b812c5c3499a3c6e87a4eec62c" translate="yes" xml:space="preserve">
          <source>Namespaced resources</source>
          <target state="translated">네임 스페이스 자원</target>
        </trans-unit>
        <trans-unit id="248022a870eb27897fa53e16452caafdbdabcf57" translate="yes" xml:space="preserve">
          <source>Nested Resources</source>
          <target state="translated">중첩 된 리소스</target>
        </trans-unit>
        <trans-unit id="8d4b12f8d7f11ef23bb408604336a8dfe441bbe1" translate="yes" xml:space="preserve">
          <source>Nested associations can also be preloaded in both formats:</source>
          <target state="translated">중첩 된 연결은 두 가지 형식으로 미리로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7afad4dc0eae2b12d5e245c5b82007fd11a1998" translate="yes" xml:space="preserve">
          <source>Nested inputs</source>
          <target state="translated">중첩 된 입력</target>
        </trans-unit>
        <trans-unit id="f1d65dcc9d3d6ca80db0b892b3aa00c0e363499b" translate="yes" xml:space="preserve">
          <source>Nested structures can be created via &lt;code&gt;[key]&lt;/code&gt;:</source>
          <target state="translated">중첩 된 구조는 &lt;code&gt;[key]&lt;/code&gt; 를 통해 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbbac91ec652a8972f156f3f69a1e666fdd052c6" translate="yes" xml:space="preserve">
          <source>New lines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6708d8752a556a739a123bb27ff07615eadfaa47" translate="yes" xml:space="preserve">
          <source>Next, add the new supervisor to your supervision tree in &lt;code&gt;lib/my_app.ex&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;lib/my_app.ex&lt;/code&gt; 의 감독 트리에 새 감독자를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab7dcbb2ba96d66fd695eab8bf3ec5b603dd1b78" translate="yes" xml:space="preserve">
          <source>Next, implement &lt;code&gt;MyTracker&lt;/code&gt; with support for the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour callbacks. An example of a minimal tracker could include:</source>
          <target state="translated">다음으로 &lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt; 비헤이비어 콜백 을 지원 하는 &lt;code&gt;MyTracker&lt;/code&gt; 를 구현 하십시오 . 최소 추적기의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a896dc9ba46abff759ffb400c77bfa27b77903fa" translate="yes" xml:space="preserve">
          <source>Nil values cannot be converted to param.</source>
          <target state="translated">유효하지 않은 값은 param으로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa4730d226177989e4496055890c0f818ebc7f74" translate="yes" xml:space="preserve">
          <source>Note &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; is automatically invoked when dispatching to the endpoint, unless the connection has already been recycled.</source>
          <target state="translated">참고 연결이 이미 재활용되지 않은 경우 엔드 포인트로 디스패치 할 때 &lt;a href=&quot;#recycle/1&quot;&gt; &lt;code&gt;recycle/1&lt;/code&gt; &lt;/a&gt; 이 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b112956c6e65a83bd10629287ef0dbca5ebebde7" translate="yes" xml:space="preserve">
          <source>Note developers are allowed to explicitly set the &lt;code&gt;:action&lt;/code&gt; field of a changeset to instruct Ecto how to act in certain situations. Let&amp;rsquo;s suppose that, if one of the associations has only empty fields, you want to ignore the entry altogether instead of showing an error. The changeset function could be written like this:</source>
          <target state="translated">참고 개발자는 특정 상황에서 행동하는 방법을 Ecto에 지시하기 위해 변경 세트의 &lt;code&gt;:action&lt;/code&gt; 필드 를 명시 적으로 설정할 수 있습니다. 연관 중 하나에 빈 필드 만있는 경우 오류를 표시하는 대신 항목을 모두 무시하려고한다고 가정하십시오. 변경 세트 기능은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72ef185830422b27144c6a55b55256bcde6d8d7a" translate="yes" xml:space="preserve">
          <source>Note only &lt;a href=&quot;#broadcast_from/3&quot;&gt;&lt;code&gt;broadcast_from/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#broadcast_from!/3&quot;&gt;&lt;code&gt;broadcast_from!/3&lt;/code&gt;&lt;/a&gt; are available in tests to avoid broadcast messages to be resent to the test process.</source>
          <target state="translated">참고 만 &lt;a href=&quot;#broadcast_from/3&quot;&gt; &lt;code&gt;broadcast_from/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#broadcast_from!/3&quot;&gt; &lt;code&gt;broadcast_from!/3&lt;/code&gt; 는&lt;/a&gt; 테스트 프로세스에 재전송 될 않도록 브로드 캐스트 메시지에 테스트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97965ab861bc886a42f97e1bc2e7904773682063" translate="yes" xml:space="preserve">
          <source>Note request headers are normalized to lowercase and response headers are expected to have lower-case keys.</source>
          <target state="translated">요청 헤더는 소문자로 정규화되며 응답 헤더에는 소문자 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4111c64111b17828ae49d5ad8fca97b7202cf233" translate="yes" xml:space="preserve">
          <source>Note request headers are normalized to lowercase and response headers are expected to have lowercase keys.</source>
          <target state="translated">요청 헤더는 소문자로 정규화되며 응답 헤더에는 소문자 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e09af1e7d2d9b5542e8d0620bc99a22794415214" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; validates the types in the &lt;code&gt;params&lt;/code&gt;, but not in the given &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt; 의 유효성을 검사에게의 유형 &lt;code&gt;params&lt;/code&gt; 주어진에 있지만 &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb865cd2bc7ad462289cb66fa61be39f36364e79" translate="yes" xml:space="preserve">
          <source>Note that certain browsers (such as Google Chrome) will not accept a pushed resource if your certificate is not trusted. In the case of Chrome this means a valid cert with a SAN. See https://www.chromestatus.com/feature/4981025180483584</source>
          <target state="translated">인증서를 신뢰할 수없는 경우 특정 브라우저 (예 : Chrome)는 푸시 된 리소스를 허용하지 않습니다. Chrome의 경우 이는 SAN이있는 유효한 인증서를 의미합니다. https://www.chromestatus.com/feature/4981025180483584 참조</target>
        </trans-unit>
        <trans-unit id="e3ad91ed34e7d6fb813fd7e54efb1b493704c193" translate="yes" xml:space="preserve">
          <source>Note that if the confirmation field is nil or missing, by default this does not add a validation error. You can specify that the confirmation field is required in the options (see below). Note &amp;ldquo;email_confirmation&amp;rdquo; does not need to be added as a virtual field in your schema.</source>
          <target state="translated">확인 필드가 nil이거나 누락 된 경우 기본적으로 유효성 검사 오류가 추가되지 않습니다. 옵션에 확인 필드가 필요하도록 지정할 수 있습니다 (아래 참조). 참고&amp;ldquo;email_confirmation&amp;rdquo;은 스키마에서 가상 필드로 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f9ca5a11268558f4efa29c8efef8203870c05fd" translate="yes" xml:space="preserve">
          <source>Note that it is recommended to enable CSRFProtection whenever a session is used, even for JSON requests. For example, Chrome had a bug that allowed POST requests to be triggered with arbitrary content-type, making JSON exploitable. More info: https://bugs.chromium.org/p/chromium/issues/detail?id=490015</source>
          <target state="translated">JSON 요청의 경우에도 세션이 사용될 때마다 CSRFProtection을 활성화하는 것이 좋습니다. 예를 들어 Chrome에는 POST 요청을 임의의 콘텐츠 유형으로 트리거하여 JSON을 활용할 수있는 버그가있었습니다. 자세한 정보 : https://bugs.chromium.org/p/chromium/issues/detail?id=490015</target>
        </trans-unit>
        <trans-unit id="865a623fddda8eeed1c887e0dc9637971ab24a2f" translate="yes" xml:space="preserve">
          <source>Note that nil can be cast to all primitive types as data stores allow nil to be set on any column.</source>
          <target state="translated">데이터 저장소에서 모든 열에 nil을 설정할 수 있으므로 nil은 모든 기본 유형으로 캐스트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8c6eb8d869ea49ffa84ebf25ae6c14dd441958f" translate="yes" xml:space="preserve">
          <source>Note that router pipelines are only invoked after a route is found. No plug is invoked in case no matches were found.</source>
          <target state="translated">라우터 파이프 라인은 경로를 찾은 후에 만 ​​호출됩니다. 일치하는 항목이없는 경우 플러그가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89c55fa6e3ecad499021fb85db24111d255d93a1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;join&lt;/code&gt; does not automatically wrap the fragment in parentheses, since some expressions require parens and others require no parens. Therefore, in cases such as common table expressions, you will have to explicitly wrap the fragment content in parens.</source>
          <target state="translated">일부 표현식에는 괄호가 필요하고 다른 표현식에는 괄호가 필요하지 않기 때문에 &lt;code&gt;join&lt;/code&gt; 은 조각을 괄호로 자동 랩핑하지 않습니다. 따라서 공통 테이블 표현식과 같은 경우 조각 컨텐츠를 명시 적으로 랩 단위로 랩핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="102fb3069ea42c376728f7d160b27d82ce7dccc5" translate="yes" xml:space="preserve">
          <source>Note that the length of a string is counted in graphemes. If using this validation to match a character limit of a database backend, it&amp;rsquo;s likely that the limit ignores graphemes and limits the number of unicode characters. Then consider using the &lt;code&gt;:count&lt;/code&gt; option to limit the number of codepoints.</source>
          <target state="translated">문자열의 길이는 그래프로 계산됩니다. 이 유효성 검증을 사용하여 데이터베이스 백엔드의 문자 한계와 일치하는 경우 한계가 grapheme을 무시하고 유니 코드 문자 수를 제한 할 수 있습니다. 그런 다음 &lt;code&gt;:count&lt;/code&gt; 옵션을 사용하여 코드 포인트 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="5281d498d35200887f768cde6b913e0a30c4898a" translate="yes" xml:space="preserve">
          <source>Note that the name of the database table does not need to correlate to your module name. For example, if you are working with a legacy database, you can reference the table name when you define your schema:</source>
          <target state="translated">데이터베이스 테이블의 이름은 모듈 이름과 상관 될 필요가 없습니다. 예를 들어 레거시 데이터베이스를 사용하는 경우 스키마를 정의 할 때 테이블 이름을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e62db11ff5777fc8aaf6203f89bf84679fe8df" translate="yes" xml:space="preserve">
          <source>Note that the operations &lt;code&gt;order_by&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; of the current &lt;code&gt;query&lt;/code&gt; apply to the result of the set difference.</source>
          <target state="translated">현재 &lt;code&gt;query&lt;/code&gt; 의 &lt;code&gt;order_by&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 작업 이 설정된 차이의 결과에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e4be7313e1b3bfa4d99f77ae0697f5c5f0a3cbe" translate="yes" xml:space="preserve">
          <source>Note that the operations &lt;code&gt;order_by&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; of the current &lt;code&gt;query&lt;/code&gt; apply to the result of the union.</source>
          <target state="translated">현재 &lt;code&gt;query&lt;/code&gt; 의 &lt;code&gt;order_by&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 작업 은 공용체의 결과에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a1db4174eadd17542b35c50d0fb4d9e6203b4bb9" translate="yes" xml:space="preserve">
          <source>Note that this function does not halt the connection, so if subsequent plugs try to send another response, it will error out. Use &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;halt/1&lt;/code&gt;&lt;/a&gt; after this function if you want to halt the plug pipeline.</source>
          <target state="translated">이 기능은 연결을 중단하지 않으므로 후속 플러그가 다른 응답을 보내려고하면 오류가 발생합니다. 플러그 파이프 라인을 정지 시키려면이 기능 뒤에 &lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;halt/1&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1aa34ade3db4517e37b549bb5b9fe2c30cba6eb" translate="yes" xml:space="preserve">
          <source>Note that this function expects a reversed pipeline (with the last plug that has to be called coming first in the pipeline).</source>
          <target state="translated">이 함수는 파이프 라인에서 역으로 진행되는 파이프 라인 (마지막으로 호출해야하는 플러그)을 예상합니다.</target>
        </trans-unit>
        <trans-unit id="22d6138cf86c2b7e8e7ca90beb6e039c9b8c93fa" translate="yes" xml:space="preserve">
          <source>Note that this function must be invoked using window function syntax.</source>
          <target state="translated">이 함수는 창 함수 구문을 사용하여 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2aa7afcfb46e1de53ed7d8c39faeed9fcd5793f" translate="yes" xml:space="preserve">
          <source>Note that, even if &lt;a href=&quot;#clear_session/1&quot;&gt;&lt;code&gt;clear_session/1&lt;/code&gt;&lt;/a&gt; is used, the session is still sent to the client. If the session should be effectively &lt;em&gt;dropped&lt;/em&gt;, &lt;a href=&quot;#configure_session/2&quot;&gt;&lt;code&gt;configure_session/2&lt;/code&gt;&lt;/a&gt; should be used with the &lt;code&gt;:drop&lt;/code&gt; option set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우에도, 그 주 &lt;a href=&quot;#clear_session/1&quot;&gt; &lt;code&gt;clear_session/1&lt;/code&gt; &lt;/a&gt; 사용되며, 세션이 여전히 클라이언트로 전송됩니다. 세션이 효율적으로 할 필요가있는 경우 &lt;em&gt;하락&lt;/em&gt; , &lt;a href=&quot;#configure_session/2&quot;&gt; &lt;code&gt;configure_session/2&lt;/code&gt; 는&lt;/a&gt; 함께 사용되어야 &lt;code&gt;:drop&lt;/code&gt; 에 대한 옵션을 설정 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f569f104132819e886ef5eb4d4340fa57f9b610" translate="yes" xml:space="preserve">
          <source>Note the examples in this module use &lt;code&gt;safe_to_string/1&lt;/code&gt; imported from &lt;a href=&quot;phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; for readability.</source>
          <target state="translated">이 모듈 사용의 예를 참고 &lt;code&gt;safe_to_string/1&lt;/code&gt; 에서 수입 &lt;a href=&quot;phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt; 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="fc58a84961ba4cd50b3fb3ae2c631ed8261f2490" translate="yes" xml:space="preserve">
          <source>Note the functions in this module exist for documentation purposes and one should never need to invoke them directly. Furthermore, it is possible to define your own macros and use them in Ecto queries (see docs for &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈의 기능은 문서화 목적으로 존재하며 직접 호출 할 필요는 없습니다. 또한 자체 매크로를 정의하고 Ecto 쿼리에서 사용할 수 있습니다 ( &lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; 에&lt;/a&gt; 대한 문서 참조 ).</target>
        </trans-unit>
        <trans-unit id="b228dbd46b006a98f7e46a9644e89c371685f474" translate="yes" xml:space="preserve">
          <source>Note the variables &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt; can be named whatever you like as they have no importance in the query sent to the database.</source>
          <target state="translated">변수 &lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;o&lt;/code&gt; 는 데이터베이스로 전송 된 쿼리에서 중요하지 않기 때문에 원하는대로 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40e3f4e9761b3a3423b7214331185e6ab2fd1d53" translate="yes" xml:space="preserve">
          <source>Note this function is not required to return Ecto primitive types, the type is only required to be known by the adapter.</source>
          <target state="translated">이 함수는 Ecto 기본 유형을 리턴하는 데 필요하지 않으며, 유형은 어댑터 만 알면됩니다.</target>
        </trans-unit>
        <trans-unit id="44d0d702486d95344749a5a28edcb2d5287109a7" translate="yes" xml:space="preserve">
          <source>Note though it doesn&amp;rsquo;t happen with &lt;code&gt;belongs_to&lt;/code&gt; cases, as the key is often the primary key and such is usually generated dynamically:</source>
          <target state="translated">키가 기본 키이고 일반적으로 동적으로 생성되기 때문에 &lt;code&gt;belongs_to&lt;/code&gt; 경우에는 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a0c8012cf69a9aa8fd08e9cac331449c4edc0e4d" translate="yes" xml:space="preserve">
          <source>Note you only pass &lt;code&gt;builder_opts()&lt;/code&gt; to &lt;strong&gt;function plugs&lt;/strong&gt;. You cannot use &lt;code&gt;builder_opts()&lt;/code&gt; with module plugs because their options are evaluated at compile time. If you need to pass &lt;code&gt;builder_opts()&lt;/code&gt; to a module plug, you can wrap the module plug in function. To be precise, do not do this:</source>
          <target state="translated">&lt;strong&gt;함수 plugs&lt;/strong&gt; 에만 &lt;code&gt;builder_opts()&lt;/code&gt; 를 전달하십시오 . 옵션은 컴파일시 평가되므로 모듈 플러그와 함께 &lt;code&gt;builder_opts()&lt;/code&gt; 를 사용할 수 없습니다 . &lt;code&gt;builder_opts()&lt;/code&gt; 를 모듈 플러그 에 전달해야하는 경우 모듈 플러그인 함수를 랩핑 할 수 있습니다. 정확하게하기 위해, 이렇게하지 마십시오 :&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d156d5fce0cbfece1b0207b4a0759bbeeede9c04" translate="yes" xml:space="preserve">
          <source>Note, however, that &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; always expects all data currently associated to be given. In both examples above, if the changeset has any other comment besides the comment with &lt;code&gt;id&lt;/code&gt; equal to 1, all of them will be considered as replaced, invoking the relevant &lt;code&gt;:on_replace&lt;/code&gt; callback which may potentially remove the data. In other words, if only a comment with a id equal to 1 is given, it will be the only one kept. Therefore, &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; always works with the whole data, which may be undesired in some cases. Let&amp;rsquo;s see an example.</source>
          <target state="translated">그러나 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; 는&lt;/a&gt; 항상 현재 연결된 모든 데이터가 제공 될 것으로 예상합니다. 위의 두 예에서 변경 세트에 &lt;code&gt;id&lt;/code&gt; 가 1 인 주석 외에 다른 주석이있는 경우 , 모든 데이터는 대체 된 것으로 간주되어 데이터를 제거 할 수있는 관련 &lt;code&gt;:on_replace&lt;/code&gt; 콜백을 호출합니다 . 다시 말해, id가 1 인 주석 만 주면 유일하게 유지됩니다. 따라서 &lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; 는&lt;/a&gt; 항상 전체 데이터와 함께 작동하며 경우에 따라 원하지 않는 경우도 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="03326181e9e6469d6fde59fa5ae844a24dd2b08d" translate="yes" xml:space="preserve">
          <source>Note, however, that we don&amp;rsquo;t advise forwarding to another endpoint. The reason is that plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</source>
          <target state="translated">그러나 다른 엔드 포인트로 전달하는 것은 권장하지 않습니다. 앱과 전달 된 엔드 포인트에서 정의한 플러그가 두 번 호출되어 오류가 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="84edd7926f36fd307fbe5444a18859614c0a29c3" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#insert_or_update/4&quot;&gt;&lt;code&gt;insert_or_update/4&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt; variants that accept a function are not performing such checks since the functions are executed after the transaction has started.</source>
          <target state="translated">참고 : 함수를 승인하는 &lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#insert_or_update/4&quot;&gt; &lt;code&gt;insert_or_update/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; &lt;/a&gt; 변형은 트랜잭션이 시작된 후에 함수가 실행되므로 이러한 검사를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8fb0f81785b06a4c4492cb88879c8170b3b1cfb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;nil&lt;/code&gt; values are always bypassed and cannot be handled by custom types.</source>
          <target state="translated">참고 : &lt;code&gt;nil&lt;/code&gt; 값은 항상 무시되며 사용자 정의 유형으로 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="92f584b5b3b5e0f483d9372fb5980926abc58fe1" translate="yes" xml:space="preserve">
          <source>Note: To connect from a native app be sure to either have the native app set an origin or allow any origin via &lt;code&gt;check_origin: false&lt;/code&gt;</source>
          <target state="translated">참고 : 기본 앱에서 연결하려면 기본 앱이 오리진을 설정하거나 &lt;code&gt;check_origin: false&lt;/code&gt; 통해 오리진을 허용해야합니다 . false</target>
        </trans-unit>
        <trans-unit id="f6a39504b62b134ed4740ba710ed8c01492d9839" translate="yes" xml:space="preserve">
          <source>Note: building the association does not consider the query filters. For example, if the given query requires the active field of the associated records to be true, building such association won&amp;rsquo;t automatically set the active field to true.</source>
          <target state="translated">참고 : 연결을 구축 할 때는 쿼리 필터가 고려되지 않습니다. 예를 들어, 주어진 쿼리에서 연관된 레코드의 활성 필드가 true 여야하는 경우 이러한 연관을 빌드하면 활성 필드가 자동으로 true로 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96479eb762012bbd4afde3ac81bb6af80f36572a" translate="yes" xml:space="preserve">
          <source>Note: keep in mind operations like limit and offset in the preload query will affect the whole result set and not each association. For example, the query below:</source>
          <target state="translated">참고 : 사전로드 조회의 한계 및 오프셋과 같은 조작은 각 연관이 아니라 전체 결과 세트에 영향을 미칩니다. 예를 들어 아래 쿼리는</target>
        </trans-unit>
        <trans-unit id="76294b367946455fb32e1d4f7027b048f95d6b60" translate="yes" xml:space="preserve">
          <source>Note: the caller must be responsible for preventing duplicate subscriptions. After calling &lt;code&gt;subscribe/1&lt;/code&gt; from your endpoint, the same flow applies to handling regular Elixir messages within your channel. Most often, you&amp;rsquo;ll simply relay the &lt;code&gt;%Phoenix.Socket.Broadcast{}&lt;/code&gt; event and payload:</source>
          <target state="translated">참고 : 호출자는 중복 구독을 방지해야합니다. 엔드 포인트에서 &lt;code&gt;subscribe/1&lt;/code&gt; 을 호출 한 후 동일한 플로우가 채널 내 일반 Elixir 메시지 처리에 적용됩니다. 대부분의 경우 &lt;code&gt;%Phoenix.Socket.Broadcast{}&lt;/code&gt; 이벤트 및 페이로드를 간단히 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="c4b9538483539a5364e06b2c7a530ca3c54f9268" translate="yes" xml:space="preserve">
          <source>Notice &lt;a href=&quot;#leave/1&quot;&gt;&lt;code&gt;leave/1&lt;/code&gt;&lt;/a&gt; is async, so it will also return a reference which you can use to check for a reply:</source>
          <target state="translated">&lt;a href=&quot;#leave/1&quot;&gt; &lt;code&gt;leave/1&lt;/code&gt; &lt;/a&gt; 은 비동기이므로 통지 를 확인하는 데 사용할 수있는 참조도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98084f9098a6d8c6cb716517ef19fc373e412f0f" translate="yes" xml:space="preserve">
          <source>Notice &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;&lt;em&gt;does not&lt;/em&gt; catch errors, as errors should still propagate so that the Elixir process finishes with the proper reason. This module does not perform any logging either, as all logging is done by the web server handler.</source>
          <target state="translated">주의 사항 Elixir 프로세스가 적절한 이유로 완료되도록 오류가 계속 전파되므로 &lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 는&lt;/em&gt; 오류를 포착 &lt;em&gt;하지 않습니다&lt;/em&gt; . 웹 서버 핸들러가 모든 로깅을 수행하므로이 모듈은 로깅을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5eb5ae0d39953702ed3cb571e939efbbe0729ac9" translate="yes" xml:space="preserve">
          <source>Notice all times are stored in native unit. You must convert them to the proper unit by using &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; before logging.</source>
          <target state="translated">모든 시간은 기본 단위로 저장됩니다. 로깅하기 전에 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 을 사용하여 적절한 단위로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fe0e069c522cae7859b146daed2272539487a97" translate="yes" xml:space="preserve">
          <source>Notice event and payload are patterns. This means one can write:</source>
          <target state="translated">공지 이벤트 및 페이로드는 패턴입니다. 이것은 다음과 같이 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bb3714a1aa3f5a3dbd4b393e762b28464d76ce1a" translate="yes" xml:space="preserve">
          <source>Notice how the storage (repository) and the data are decoupled. This provides two main benefits:</source>
          <target state="translated">스토리지 (리포지토리)와 데이터가 어떻게 분리되어 있는지 확인합니다. 이것은 두 가지 주요 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f3467fef009ee169e97de38cc7f6d36db63b68c" translate="yes" xml:space="preserve">
          <source>Notice status and payload are patterns. This means one can write:</source>
          <target state="translated">통지 상태 및 페이로드는 패턴입니다. 이것은 다음과 같이 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="30ca448ada7803d59a47b42236252fa82c814916" translate="yes" xml:space="preserve">
          <source>Notice that in order to render JSON data, we don&amp;rsquo;t need to explicitly return a JSON string! Instead, we just return data that is encodable to JSON.</source>
          <target state="translated">JSON 데이터를 렌더링하기 위해 명시 적으로 JSON 문자열을 반환 할 필요는 없습니다. 대신 JSON으로 인코딩 할 수있는 데이터 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0db40361209b6bb85131412727c6434f6320058c" translate="yes" xml:space="preserve">
          <source>Notice that the first param is just one of the unique index fields, this will be used as the error key to the changeset errors keyword list. For example, the above &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; would generate something like:</source>
          <target state="translated">첫 번째 매개 변수는 고유 색인 필드 중 하나이며, 변경 세트 오류 키워드 목록의 오류 키로 사용됩니다. 예를 들어 위의 &lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; &lt;/a&gt; 는 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="705a210e2f967e9b27fbc85f4436d1298ca94d8c" translate="yes" xml:space="preserve">
          <source>Notice the generated textarea includes a new line after the opening tag. This is because the HTML spec says new lines after tags must be ignored and all major browser implementations do that.</source>
          <target state="translated">생성 된 텍스트 영역에는 여는 태그 다음에 줄 바꿈이 포함되어 있습니다. HTML 사양에 따르면 태그 뒤의 줄 바꿈을 무시해야하며 모든 주요 브라우저 구현에서 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bd1eb7bdbf1493fe7fff0dfec020edf248af81f" translate="yes" xml:space="preserve">
          <source>Notice the router contains a plug pipeline and by default it requires two plugs: &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt;. &lt;code&gt;match&lt;/code&gt; is responsible for finding a matching route which is then forwarded to &lt;code&gt;dispatch&lt;/code&gt;. This means users can easily hook into the router mechanism and add behaviour before match, before dispatch or after both.</source>
          <target state="translated">라우터에는 플러그 파이프 라인이 있으며 기본적으로 &lt;code&gt;match&lt;/code&gt; 및 &lt;code&gt;dispatch&lt;/code&gt; 두 개의 플러그가 필요합니다 . &lt;code&gt;match&lt;/code&gt; 는 일치하는 경로를 찾은 다음 &lt;code&gt;dispatch&lt;/code&gt; 로 전달됩니다 . 즉, 사용자는 라우터 메커니즘에 쉽게 연결하여 일치 전, 디스패치 전 또는 후에 동작을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="338f1f90a543cc885f674d5b51bb680bb881e354" translate="yes" xml:space="preserve">
          <source>Notice this function returns the inner representation of a template. If you want the encoded template as a result, use &lt;a href=&quot;#render_to_iodata/3&quot;&gt;&lt;code&gt;render_to_iodata/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 템플릿의 내부 표현을 반환합니다. 인코딩 된 템플릿을 원하는 경우 &lt;a href=&quot;#render_to_iodata/3&quot;&gt; &lt;code&gt;render_to_iodata/3&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e74265a82393d957428ce63aae8cdb0f63ce60" translate="yes" xml:space="preserve">
          <source>Notice we have changed the table name to &amp;ldquo;abstract table: comments&amp;rdquo;. You can choose whatever name you want, the point here is that this particular table will never exist.</source>
          <target state="translated">테이블 이름을 &quot;추상 테이블 : 주석&quot;으로 변경했습니다. 원하는 이름을 선택할 수 있습니다. 여기서 요점은이 특정 테이블이 존재하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c1b3f3f8d9ec0b4f783bd20005a72f78660278b" translate="yes" xml:space="preserve">
          <source>Notice we have created a &lt;code&gt;p&lt;/code&gt; variable to reference the query&amp;rsquo;s original data source. This assumes that the original query only had one source. When the given query has more than one source, a variable must be given for each in the order they were bound:</source>
          <target state="translated">쿼리의 원래 데이터 소스를 참조하기 위해 &lt;code&gt;p&lt;/code&gt; 변수를 만들었습니다 . 이는 원래 쿼리에 소스가 하나만 있다고 가정합니다. 주어진 쿼리에 둘 이상의 소스가있는 경우 각각에 대해 바인딩 된 순서대로 변수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fb002e44e6ece76c8ea66f1e6240f01d34b08fb" translate="yes" xml:space="preserve">
          <source>Now a &lt;code&gt;@changeset&lt;/code&gt; assign is available in views which we can pass to the form:</source>
          <target state="translated">이제 &lt;code&gt;@changeset&lt;/code&gt; assign을 뷰에서 사용할 수 있으며 양식에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df59147f1da82103dabce460393f6c1465729899" translate="yes" xml:space="preserve">
          <source>Now each association uses its own specific table, &amp;ldquo;posts_comments&amp;rdquo; and &amp;ldquo;tasks_comments&amp;rdquo;, which must be created on migrations. The advantage of this approach is that we never store unrelated data together, also ensuring we keep database references fast and correct.</source>
          <target state="translated">이제 각 연관은 고유 한 테이블&amp;ldquo;posts_comments&amp;rdquo;및&amp;ldquo;tasks_comments&amp;rdquo;를 사용하며,이 테이블은 마이그레이션시 작성해야합니다. 이 방법의 장점은 관련없는 데이터를 함께 저장하지 않고 데이터베이스 참조를 빠르고 정확하게 유지할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7892eaebe9d69b3ed993b29b5209261c6832b7a2" translate="yes" xml:space="preserve">
          <source>Now in your Post and Task schemas:</source>
          <target state="translated">이제 Post 및 Task 스키마에서 :</target>
        </trans-unit>
        <trans-unit id="5f22e70ebe5aae1ac6efa98983a3696a51e1fba6" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s take optimistic locking for a spin:</source>
          <target state="translated">이제 스핀에 대해 낙관적 잠금을 수행하겠습니다.</target>
        </trans-unit>
        <trans-unit id="13c250e39b476294ce3dfa10f4ae7b19afb05096" translate="yes" xml:space="preserve">
          <source>Now that a constraint exists, when creating comments, we could annotate the changeset with foreign key constraint so Ecto knows how to convert it into an error message:</source>
          <target state="translated">주석을 작성할 때 제약 조건이 있으므로 외래 키 제약 조건으로 변경 세트에 주석을 달 수 있으므로 Ecto는이를 오류 메시지로 변환하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0798fc5c299098a56234fedea57c40bd7fcfcd36" translate="yes" xml:space="preserve">
          <source>Now that a constraint exists, when modifying users, we could annotate the changeset with unique constraint so Ecto knows how to convert it into an error message:</source>
          <target state="translated">이제 제약 조건이 존재하므로 사용자를 수정할 때 고유 한 제약 조건으로 변경 세트에 주석을 달 수 있으므로 Ecto는이를 오류 메시지로 변환하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8146d2b685b41a346d939acfce081d0b50f0ea" translate="yes" xml:space="preserve">
          <source>Now we can insert with the same title but do nothing on conflicts:</source>
          <target state="translated">이제 같은 제목으로 삽입 할 수 있지만 충돌에 대해서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba86d9c862b711f84037498dddfa0769d16c6930" translate="yes" xml:space="preserve">
          <source>Now we can match on event and payload as patterns:</source>
          <target state="translated">이제 이벤트와 페이로드를 패턴으로 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f293a74f0c6acbd493f7be5d1b1da8ff98570181" translate="yes" xml:space="preserve">
          <source>Now we can use our new field type above in our schemas:</source>
          <target state="translated">이제 스키마에서 위의 새 필드 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8173424368e14547f313929000b0087bed3ce719" translate="yes" xml:space="preserve">
          <source>Now, in the same way the channel has a socket representing communication it will push to the client. Our test has a socket representing communication to be pushed to the server.</source>
          <target state="translated">동일한 방식으로 채널에는 통신을 나타내는 소켓이 있으며 클라이언트로 푸시됩니다. 테스트에는 서버로 푸시되는 통신을 나타내는 소켓이 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e0a1e0cfc6b366660737615984d2e99a0dd933" translate="yes" xml:space="preserve">
          <source>Now, since the tags already exist, we will bring all of them from the database and put them directly in the post:</source>
          <target state="translated">이제 태그가 이미 존재하므로 데이터베이스에서 모든 태그를 가져 와서 포스트에 직접 넣습니다.</target>
        </trans-unit>
        <trans-unit id="2c2f8561ea64f704daa54d16a3cce1aabe4b4fc2" translate="yes" xml:space="preserve">
          <source>Now, when deleting the post, it is possible to forbid any post to be deleted if they still have comments attached to it:</source>
          <target state="translated">이제 게시물을 삭제할 때 여전히 주석이 첨부되어있는 게시물은 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f6353f6cdd020e0676b8bc3ecb0210f83694d66" translate="yes" xml:space="preserve">
          <source>Now, when inserting a comment, it is possible to forbid any comment to be added if the associated post does not exist:</source>
          <target state="translated">이제 주석을 삽입 할 때 연관된 게시물이 존재하지 않는 경우 주석이 추가되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb3c08053ad9023afdd5bd4d957472bc6369f4e" translate="yes" xml:space="preserve">
          <source>Now, when invoking &lt;code&gt;Repo.insert/2&lt;/code&gt; or &lt;code&gt;Repo.update/2&lt;/code&gt;, if the associated post does not exist, it will be converted into an error and &lt;code&gt;{:error, changeset}&lt;/code&gt; returned by the repository.</source>
          <target state="translated">이제 &lt;code&gt;Repo.insert/2&lt;/code&gt; 또는 &lt;code&gt;Repo.update/2&lt;/code&gt; 를 호출 할 때 연관된 게시물이 존재하지 않으면 저장소에 의해 오류 및 &lt;code&gt;{:error, changeset}&lt;/code&gt; 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="68a2adda5c42710e68a1cc01422f0e86a8968174" translate="yes" xml:space="preserve">
          <source>Now, when invoking &lt;code&gt;Repo.insert/2&lt;/code&gt; or &lt;code&gt;Repo.update/2&lt;/code&gt;, if the email already exists, it will be converted into an error and &lt;code&gt;{:error, changeset}&lt;/code&gt; returned by the repository. Note that the error will occur only after hitting the database so it will not be visible until all other validations pass.</source>
          <target state="translated">이제 &lt;code&gt;Repo.insert/2&lt;/code&gt; 또는 &lt;code&gt;Repo.update/2&lt;/code&gt; 를 호출 할 때 전자 우편이 이미 존재하는 경우, 전자 우편이 오류로 변환되고 &lt;code&gt;{:error, changeset}&lt;/code&gt; 가 저장소에 의해 리턴됩니다. 데이터베이스에 도달 한 후에 만 ​​오류가 발생하므로 다른 모든 유효성 검사가 통과 될 때까지 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d5fdb98909059197f8adf8277903d735dc527ef" translate="yes" xml:space="preserve">
          <source>Null check functions: &lt;a href=&quot;#is_nil/1&quot;&gt;&lt;code&gt;is_nil/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">널 점검 기능 : &lt;a href=&quot;#is_nil/1&quot;&gt; &lt;code&gt;is_nil/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1169045ff4783e5d8401da833eccb418f745b0e" translate="yes" xml:space="preserve">
          <source>Offloading work to clients via MFA response</source>
          <target state="translated">MFA 응답을 통해 클라이언트로 작업을 오프로드</target>
        </trans-unit>
        <trans-unit id="e8c2f62e74e6e2e3c2e935bb6f427f5a5a8b6ff0" translate="yes" xml:space="preserve">
          <source>Offsets the number of rows selected from the result. Can be any expression but it must evaluate to an integer value and it can&amp;rsquo;t include any field.</source>
          <target state="translated">결과에서 선택한 행 수를 오프셋합니다. 모든 표현식이 될 수 있지만 정수 값으로 평가되어야하며 필드를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3268d5059217b0540f5f6fe6f9e84eff2fec3291" translate="yes" xml:space="preserve">
          <source>Often one may want to do side-effects inside channels, like writing to the database, and verify those side-effects during their tests.</source>
          <target state="translated">종종 데이터베이스에 쓰는 것과 같이 채널 내부에서 부작용을 수행하고 테스트 중에 이러한 부작용을 확인하고자 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57042716b8ebfeb22e5ac3fd9d2e4b69afeeae1c" translate="yes" xml:space="preserve">
          <source>Often times, you may want posts and comments to be selected and filtered in the same query. For such cases, you can explicitly tell an existing join to be preloaded into the result set:</source>
          <target state="translated">종종 같은 쿼리에서 게시물과 댓글을 선택하고 필터링 할 수 있습니다. 이러한 경우 기존 조인을 결과 집합에 미리로드하도록 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f141b9556ffaa940bdd55ed667d6fe7df0636fe1" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;init/1&lt;/code&gt;, you will define the supervision tree and use the given &lt;code&gt;name&lt;/code&gt; to register the main pubsub process locally. This process must be able to handle the following GenServer calls:</source>
          <target state="translated">에 &lt;code&gt;init/1&lt;/code&gt; , 당신은 감독 트리를 정의하고 주어진 사용할 &lt;code&gt;name&lt;/code&gt; 로컬 주요 pubsub 과정을 등록 할 수 있습니다. 이 프로세스는 다음 GenServer 호출을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5e84a0f737366ca3cfdac4eb66f40bb0d94b8528" translate="yes" xml:space="preserve">
          <source>On a slow machine (e.g. a cheap VPS) this may take several hours. You may want to run the command on a strong machine and copy the file over: the file does not need to be kept secret.</source>
          <target state="translated">느린 컴퓨터 (예 : 저렴한 VPS)에서는 몇 시간이 걸릴 수 있습니다. 강력한 시스템에서 명령을 실행하고 파일을 복사 할 수 있습니다. 파일을 비밀로 유지할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="967d69f7b0e95ad35ee7b7bf3862fba54aff0f83" translate="yes" xml:space="preserve">
          <source>On termination, the channel callback &lt;code&gt;terminate/2&lt;/code&gt; will be invoked with the error reason and the socket.</source>
          <target state="translated">종료시, 채널 콜백 &lt;code&gt;terminate/2&lt;/code&gt; 는 오류 이유 및 소켓과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="62ac2bb5b94cbb1a583addb2cd6e29190cd32943" translate="yes" xml:space="preserve">
          <source>On the left side of &lt;code&gt;in&lt;/code&gt; we specify the query bindings. This is done inside from and join clauses. In the query below &lt;code&gt;u&lt;/code&gt; is a binding and &lt;code&gt;u.age&lt;/code&gt; is a field access using this binding.</source>
          <target state="translated">왼쪽에서 &lt;code&gt;in&lt;/code&gt; 우리는 쿼리 바인딩을 지정합니다. 이것은 from 및 join 절 내부에서 수행됩니다. 아래 쿼리에서 &lt;code&gt;u&lt;/code&gt; 는 바인딩이고 &lt;code&gt;u.age&lt;/code&gt; 는이 바인딩을 사용하는 필드 액세스입니다.</target>
        </trans-unit>
        <trans-unit id="cbdd917a58dadedc012b8760e8dfaa3abf4a7649" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt; is used for defining schemas that are embedded in other schemas or only exist in-memory. For example, you can use such schemas to receive data from a command line interface and validate it, without ever persisting it elsewhere. Such structs do not contain a &lt;code&gt;__meta__&lt;/code&gt; field, as they are never persisted.</source>
          <target state="translated">반면에 &lt;a href=&quot;#embedded_schema/1&quot;&gt; &lt;code&gt;embedded_schema/1&lt;/code&gt; &lt;/a&gt; 은 다른 스키마에 포함되거나 메모리에만 존재하는 스키마를 정의하는 데 사용됩니다. 예를 들어, 이러한 스키마를 사용하여 다른 곳에서 데이터를 유지하지 않고도 명령 행 인터페이스에서 데이터를 수신하고 유효성을 검증 할 수 있습니다. 이러한 구조체 는 결코 유지 되지 않으므로 &lt;code&gt;__meta__&lt;/code&gt; 필드를 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d2b84b8ce38d79f388a7e3e997a08736c117d64b" translate="yes" xml:space="preserve">
          <source>On the other hand, close is always sync and it will return only after the channel process is guaranteed to have been terminated:</source>
          <target state="translated">반면에 close는 항상 동기화되며 채널 프로세스가 종료 된 후에 만 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="65d55c3da40fba47f1217fe10066ca2995c32a7c" translate="yes" xml:space="preserve">
          <source>On the other hand, constraints rely on the database and are always safe. As a consequence, validations are always checked before constraints. Constraints won&amp;rsquo;t even be checked in case validations failed.</source>
          <target state="translated">반면 제약 조건은 데이터베이스에 의존하며 항상 안전합니다. 결과적으로 유효성 검사는 항상 제약 조건보다 먼저 확인됩니다. 유효성 검사에 실패한 경우에도 제약 조건을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12b1ec2a89194fbb026941ac12fa16630e06149b" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; is called, Ecto will compare each parameter with the user&amp;rsquo;s already preloaded addresses and act as follows:</source>
          <target state="translated">일단 &lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt; 이라고 다음과 같이 체외은 사용자가 이미 주소를 미리로드있어 각 매개 변수를 비교하고 역할을합니다 :</target>
        </trans-unit>
        <trans-unit id="e51b66d6cc36fe276b7702ba45c881391d7a1233" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is invoked, a developer may call &lt;a href=&quot;#read_part_body/2&quot;&gt;&lt;code&gt;read_part_body/2&lt;/code&gt;&lt;/a&gt; to read the body associated to the headers. If &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is called instead, the body is automatically skipped until the next part headers.</source>
          <target state="translated">일단 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; &lt;/a&gt; 호출, 개발자는 호출 할 수 있습니다 &lt;a href=&quot;#read_part_body/2&quot;&gt; &lt;code&gt;read_part_body/2&lt;/code&gt; &lt;/a&gt; 헤더에 관련된 몸을 읽을 수 있습니다. 경우 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; 가&lt;/a&gt; 대신 호출, 몸은 자동으로 다음 부분 헤더까지 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="4bffed96518285486f70feaaf4548f09e696472f" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is invoked, you may call &lt;a href=&quot;#read_part_body/2&quot;&gt;&lt;code&gt;read_part_body/2&lt;/code&gt;&lt;/a&gt; to read the body associated to the headers. If &lt;a href=&quot;#read_part_headers/2&quot;&gt;&lt;code&gt;read_part_headers/2&lt;/code&gt;&lt;/a&gt; is called instead, the body is automatically skipped until the next part headers.</source>
          <target state="translated">일단 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; &lt;/a&gt; 호출하면 호출 할 수 &lt;a href=&quot;#read_part_body/2&quot;&gt; &lt;code&gt;read_part_body/2&lt;/code&gt; &lt;/a&gt; 헤더에 관련된 몸을 읽을 수 있습니다. 경우 &lt;a href=&quot;#read_part_headers/2&quot;&gt; &lt;code&gt;read_part_headers/2&lt;/code&gt; 가&lt;/a&gt; 대신 호출, 몸은 자동으로 다음 부분 헤더까지 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fdd21797e7e0035bfde10bfb17f93be00ebf4192" translate="yes" xml:space="preserve">
          <source>Once a changeset is built, it can be given to functions like &lt;code&gt;insert&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in the repository that will return an &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; tuple:</source>
          <target state="translated">변경 세트가 빌드되면 &lt;code&gt;:ok&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 튜플을 리턴하는 리포지토리의 &lt;code&gt;insert&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 와 같은 함수에 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3857ceb3c71bdbca7ddefc73f5a6c10ad83890f0" translate="yes" xml:space="preserve">
          <source>Once a connection goes through this plug, it will have &lt;code&gt;:body_params&lt;/code&gt; set to the map of params parsed by one of the parsers listed in &lt;code&gt;:parsers&lt;/code&gt; and &lt;code&gt;:params&lt;/code&gt; set to the result of merging the &lt;code&gt;:body_params&lt;/code&gt; and &lt;code&gt;:query_params&lt;/code&gt;.</source>
          <target state="translated">연결이이 플러그를 통과하면 &lt;code&gt;:body_params&lt;/code&gt; 가 &lt;code&gt;:parsers&lt;/code&gt; 및 &lt;code&gt;:params&lt;/code&gt; 에 나열된 구문 분석기 중 하나에 의해 구문 분석 된 매개 변수 맵으로 설정됩니다 &lt;code&gt;:body_params&lt;/code&gt; 및 &lt;code&gt;:query_params&lt;/code&gt; 를 병합 한 결과로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="380a226dd346505a271148d3d4c1216ac127f8f6" translate="yes" xml:space="preserve">
          <source>Once a connection is established, the transport is responsible for invoking the &lt;code&gt;Phoenix.Socket.connect/2&lt;/code&gt; callback and acting accordingly. Once connected, the transport should request the &lt;code&gt;Phoenix.Socket.id/1&lt;/code&gt; and subscribe to the topic if one exists. On subscribed, the transport must be able to handle &amp;ldquo;disconnect&amp;rdquo; broadcasts on the given id topic.</source>
          <target state="translated">연결이 설정되면 전송은 &lt;code&gt;Phoenix.Socket.connect/2&lt;/code&gt; 콜백을 호출하고 그에 따라 작동합니다. 연결되면 전송에서 &lt;code&gt;Phoenix.Socket.id/1&lt;/code&gt; 을 요청 하고 주제가 있으면 주제를 구독해야합니다. 구독하면 전송에서 지정된 ID 주제에 대한 &quot;연결 끊기&quot;브로드 캐스트를 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5552d73347a712fe9add3a0267c3bc2c17cb0911" translate="yes" xml:space="preserve">
          <source>Once a request arrives at the Phoenix router, it performs a series of transformations through pipelines until the request is dispatched to a desired end-point.</source>
          <target state="translated">요청이 Phoenix 라우터에 도착하면 요청이 원하는 엔드 포인트로 디스패치 될 때까지 파이프 라인을 통해 일련의 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="386c702d0645d812c90c3528534c818926a832a3" translate="yes" xml:space="preserve">
          <source>Once a token is generated, it is cached in the process dictionary. The CSRF token is usually generated inside forms which may be isolated from &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;. Storing them in the process dictionary allows them to be generated as a side-effect only when necessary, becoming one of those rare situations where using the process dictionary is useful.</source>
          <target state="translated">토큰이 생성되면 프로세스 사전에 캐시됩니다. CSRF 토큰은 일반적으로 &lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt; 에서 분리 될 수있는 양식 내부에서 생성됩니다 . 프로세스 딕셔너리에 저장하면 필요할 때만 부작용으로 생성되어 프로세스 딕셔너리를 사용하는 것이 유용한 드문 상황 중 하나가됩니다.</target>
        </trans-unit>
        <trans-unit id="ae3d9c7003e516c340b1917822b5e1bf0526bd08" translate="yes" xml:space="preserve">
          <source>Once a token is signed, we can send it to the client in multiple ways.</source>
          <target state="translated">토큰에 서명하면 여러 가지 방법으로 고객에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2216e933bee085262590e69dd46199fab1ffd90" translate="yes" xml:space="preserve">
          <source>Once added, presences can be tracked in your channel after joining:</source>
          <target state="translated">추가 한 후에는 참여 후 채널에서 현재 상태를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d073a02aa6e87328220e8b4cba068be36062c496" translate="yes" xml:space="preserve">
          <source>Once called, &lt;a href=&quot;#subscribe_and_join/4&quot;&gt;&lt;code&gt;subscribe_and_join/4&lt;/code&gt;&lt;/a&gt; will subscribe the current test process to the &amp;ldquo;room:lobby&amp;rdquo; topic and start a channel in another process. It returns &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; or &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#subscribe_and_join/4&quot;&gt; &lt;code&gt;subscribe_and_join/4&lt;/code&gt; &lt;/a&gt; 가 호출되면 현재 테스트 프로세스를 &quot;room : lobby&quot;주제에 구독하고 다른 프로세스에서 채널을 시작합니다. &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; 또는 &lt;code&gt;{:error, reply}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="54126b811e54eb300f9e22e496c59c2167f298f5" translate="yes" xml:space="preserve">
          <source>Once connected to a socket, incoming and outgoing events are routed to channels. The incoming client data is routed to channels via transports. It is the responsibility of the socket to tie transports and channels together.</source>
          <target state="translated">소켓에 연결되면 들어오고 나가는 이벤트가 채널로 라우팅됩니다. 수신 클라이언트 데이터는 전송을 통해 채널로 라우팅됩니다. 운송과 채널을 함께 묶는 것은 소켓의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="133d0debedf679c0dc98a9cb8c0152a081388bbe" translate="yes" xml:space="preserve">
          <source>Once the template is rendered, the template format is set as the response content type (for example, an HTML template will set &amp;ldquo;text/html&amp;rdquo; as response content type) and the data is sent to the client with default status of 200.</source>
          <target state="translated">템플리트가 렌더링되면 템플리트 형식이 응답 컨텐츠 유형으로 설정되고 (예 : HTML 템플리트가 &quot;text / html&quot;을 응답 컨텐츠 유형으로 설정 함) 데이터는 기본 상태 인 200으로 클라이언트에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5b49bac9f5d4f9ebe24ac16c036df55f5e8ddeff" translate="yes" xml:space="preserve">
          <source>Once the token is sent, the client may now send it back to the server as an authentication mechanism. For example, we can use it to authenticate a user on a Phoenix channel:</source>
          <target state="translated">토큰이 전송되면 클라이언트는 이제 인증 메커니즘으로 서버에 다시 전송할 수 있습니다. 예를 들어, 피닉스 채널에서 사용자를 인증하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f64aff5d8ac3595981631d929f8c1ff6b09fb49" translate="yes" xml:space="preserve">
          <source>Once this module is used, a callback named &lt;code&gt;handle_errors/2&lt;/code&gt; should be defined in your plug. This callback should accept a connection and a map containing:</source>
          <target state="translated">이 모듈을 사용한 후에는 &lt;code&gt;handle_errors/2&lt;/code&gt; 라는 콜백을 플러그에 정의해야합니다. 이 콜백은 연결 및 다음을 포함하는 맵을 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="333c7cb99825e7a02250628ce47b4b7143a91019" translate="yes" xml:space="preserve">
          <source>One advantage of bindingless queries is that they are data-driven and therefore useful for dynamically building queries. For example, the query above could also be written as:</source>
          <target state="translated">바인딩없는 쿼리의 장점 중 하나는 데이터 기반 쿼리이므로 쿼리를 동적으로 작성하는 데 유용하다는 것입니다. 예를 들어 위의 쿼리는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9279410a27789475cbdf33cb95f3977eb9b02dec" translate="yes" xml:space="preserve">
          <source>One can also pass a router explicitly as an argument to the task:</source>
          <target state="translated">또한 작업에 대한 인수로 라우터를 명시 적으로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="209832054f55ad7e3cbd8d483474917b7a556e03" translate="yes" xml:space="preserve">
          <source>One common use case for belongs to associations is to handle polymorphism. For example, imagine you have defined a Comment schema and you wish to use it for commenting on both tasks and posts.</source>
          <target state="translated">연관에 속하는 일반적인 사용 사례는 다형성을 처리하는 것입니다. 예를 들어, 주석 스키마를 정의했으며이를 태스크 및 게시물에 주석을 달 때 사용한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="dc415f8c0b228e077fb6b05a0d5169debe03fd55" translate="yes" xml:space="preserve">
          <source>One is via the meta tag:</source>
          <target state="translated">하나는 메타 태그를 통하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7136382653ef50edfc5079509c9b673392c096e2" translate="yes" xml:space="preserve">
          <source>One of the main features provided by controllers is the ability to perform content negotiation and render templates based on information sent by the client. Read &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt; to learn more.</source>
          <target state="translated">컨트롤러가 제공하는 주요 기능 중 하나는 클라이언트가 보낸 정보를 기반으로 컨텐츠 협상을 수행하고 템플릿을 렌더링하는 기능입니다. 자세한 내용은 &lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="5d78b7cfb9e0146d7a197e88da4f8c83b813bf17" translate="yes" xml:space="preserve">
          <source>One of the most common ways to use Ecto is to interact with databases, such as Postgres and MySQL via &lt;a href=&quot;http://hexdocs.pm/ecto_sql&quot;&gt;&lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt; provides many conveniences for working with SQL databases, including support for database migrations.</source>
          <target state="translated">Ecto를 사용하는 가장 일반적인 방법 중 하나는 &lt;a href=&quot;http://hexdocs.pm/ecto_sql&quot;&gt; &lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt; 을&lt;/a&gt; 통해 Postgres 및 MySQL과 같은 데이터베이스와 상호 작용하는 것 입니다. &lt;code&gt;Ecto.Adapters.SQL&lt;/code&gt; 은 데이터베이스 마이그레이션 지원을 포함하여 SQL 데이터베이스 작업에 많은 편의를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b35e8fc21fa33cd847c62b0b0e85a41a068aa1ce" translate="yes" xml:space="preserve">
          <source>Only alphanumeric characters and underscore are allowed in the callback name. Otherwise an exception is raised.</source>
          <target state="translated">콜백 이름에는 영숫자와 밑줄 만 사용할 수 있습니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="278bf6027e6334f85a23d913599b54e56b4fdc3d" translate="yes" xml:space="preserve">
          <source>Only atoms are accepted for binding names. Named binding references are expected to be placed in the tail position of the bindings list.</source>
          <target state="translated">바인딩 이름에는 원자 만 허용됩니다. 명명 된 바인딩 참조는 바인딩 목록의 꼬리 위치에 배치 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="fbfbca5c3277af03dfa1f15af228fe47e6cd94af" translate="yes" xml:space="preserve">
          <source>Only simple queries with &lt;code&gt;where&lt;/code&gt; expressions can be interpolated in join.</source>
          <target state="translated">조인 &lt;code&gt;where&lt;/code&gt; 식을 보간 할 수있는 간단한 쿼리 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f0f4128705a1e23fa1b3f0949f80eee715909ee" translate="yes" xml:space="preserve">
          <source>Only the first value of the header &lt;code&gt;key&lt;/code&gt; is updated if present.</source>
          <target state="translated">존재하는 경우 헤더 &lt;code&gt;key&lt;/code&gt; 의 첫 번째 값만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="7fa3faab6d6720fe110ace73960265700520cff2" translate="yes" xml:space="preserve">
          <source>Operations within &lt;code&gt;handle_diff/2&lt;/code&gt; happen &lt;em&gt;in the tracker server&amp;rsquo;s context&lt;/em&gt;. Therefore, blocking operations should be avoided when possible, and offloaded to a supervised task when required. Also, a crash in the &lt;code&gt;handle_diff/2&lt;/code&gt; will crash the tracker server, so operations that may crash the server should be offloaded with a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; spawned process.</source>
          <target state="translated">&lt;code&gt;handle_diff/2&lt;/code&gt; 내의 작업 &lt;em&gt;은 추적 서버의 컨텍스트에서&lt;/em&gt; 발생 &lt;em&gt;합니다&lt;/em&gt; . 따라서 가능하면 차단 작업을 피하고 필요할 경우 감독 작업에 오프로드해야합니다. 또한 &lt;code&gt;handle_diff/2&lt;/code&gt; 의 충돌로 인해 추적 서버가 충돌하므로 서버를 충돌시킬 수있는 작업은 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 생성 프로세스 로 오프로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f69ad7b4644db4047001e046a926515928efb72f" translate="yes" xml:space="preserve">
          <source>Operations within &lt;code&gt;handle_diff/2&lt;/code&gt; happen &lt;em&gt;in the tracker server&amp;rsquo;s context&lt;/em&gt;. Therefore, blocking operations should be avoided when possible, and offloaded to a supervised task when required. Also, a crash in the &lt;code&gt;handle_diff/2&lt;/code&gt; will crash the tracker server, so operations that may crash the server should be offloaded with a &lt;code&gt;Task.Supervisor&lt;/code&gt; spawned process.</source>
          <target state="translated">&lt;code&gt;handle_diff/2&lt;/code&gt; 내의 작업 &lt;em&gt;은 추적 서버의 컨텍스트에서&lt;/em&gt; 발생 &lt;em&gt;합니다&lt;/em&gt; . 따라서 가능하면 차단 작업을 피하고 필요할 경우 감독 작업에 오프로드해야합니다. 또한 &lt;code&gt;handle_diff/2&lt;/code&gt; 의 충돌로 인해 추적 서버가 충돌하므로 서버를 충돌시킬 수있는 작업은 &lt;code&gt;Task.Supervisor&lt;/code&gt; 생성 프로세스 로 오프로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="832d17728f477b6af233a37ce757a299695d6661" translate="yes" xml:space="preserve">
          <source>Opposite to casting, dumping requires the returned value to be a valid Ecto type, as it will be sent to the underlying data store.</source>
          <target state="translated">캐스팅과 반대로 덤프는 반환 된 값이 기본 데이터 저장소로 전송되므로 유효한 Ecto 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="465829d5307e0ace671c108d4b60686a9e377efc" translate="yes" xml:space="preserve">
          <source>Optgroups</source>
          <target state="translated">Optgroups</target>
        </trans-unit>
        <trans-unit id="7703fdb524069df80a1e25bcd374d8ad6110df6d" translate="yes" xml:space="preserve">
          <source>Optimistic locking also works with delete operations. Just call the &lt;a href=&quot;#optimistic_lock/3&quot;&gt;&lt;code&gt;optimistic_lock/3&lt;/code&gt;&lt;/a&gt; function with the data before delete:</source>
          <target state="translated">낙관적 잠금은 삭제 작업에서도 작동합니다. 삭제하기 전에 데이터로 &lt;a href=&quot;#optimistic_lock/3&quot;&gt; &lt;code&gt;optimistic_lock/3&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a9d530cb8c562cac44d93379e9a5d57513ac6e9" translate="yes" xml:space="preserve">
          <source>Optimistic locking works by keeping a &amp;ldquo;version&amp;rdquo; counter for each record; this counter gets incremented each time a modification is made to a record. Hence, in order to use optimistic locking, a field must exist in your schema for versioning purpose. Such field is usually an integer but other types are supported.</source>
          <target state="translated">낙관적 잠금은 각 레코드에 대해 &quot;버전&quot;카운터를 유지함으로써 작동합니다. 이 카운터는 레코드를 수정할 때마다 증가합니다. 따라서 낙관적 잠금을 사용하려면 버전 관리를 위해 스키마에 필드가 있어야합니다. 이러한 필드는 일반적으로 정수이지만 다른 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6080dd3f6316b79c1e99b9219c5e9c4e943bd5fb" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;pool_opts&lt;/code&gt;:</source>
          <target state="translated">선택적 &lt;code&gt;pool_opts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1e352cc634bcbd875f9a3d76f49b8b7b037fb1d9" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;server_opts&lt;/code&gt;:</source>
          <target state="translated">선택적 &lt;code&gt;server_opts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="252b17be73d7596d917bab75758c48cd96bad3fa" translate="yes" xml:space="preserve">
          <source>Optionally function can accept three arguments: &lt;code&gt;changeset&lt;/code&gt;, &lt;code&gt;field&lt;/code&gt; and error tuple &lt;code&gt;{msg, opts}&lt;/code&gt;. It is useful whenever you want to extract validations rules from &lt;code&gt;changeset.validations&lt;/code&gt; to build detailed error description.</source>
          <target state="translated">선택적으로 함수는 &lt;code&gt;changeset&lt;/code&gt; , &lt;code&gt;field&lt;/code&gt; 및 error tuple &lt;code&gt;{msg, opts}&lt;/code&gt; 세 가지 인수를 사용할 수 있습니다 . &lt;code&gt;changeset.validations&lt;/code&gt; 에서 유효성 검사 규칙을 추출 하여 자세한 오류 설명을 작성할 때마다 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="6011f39be2f926fbdab3c480bd16a247893c32f1" translate="yes" xml:space="preserve">
          <source>Options should be passed before the &lt;code&gt;do&lt;/code&gt; block like this:</source>
          <target state="translated">다음 과 같이 &lt;code&gt;do&lt;/code&gt; 블록 앞에 옵션을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="16064f1b4545ef550fcb61614eaca19e1afda642" translate="yes" xml:space="preserve">
          <source>Or all comments in a given table:</source>
          <target state="translated">또는 주어진 표의 모든 의견 :</target>
        </trans-unit>
        <trans-unit id="d1a50ae16efbaca88cc2228114460371a17c9c17" translate="yes" xml:space="preserve">
          <source>Or an endpoint that returns it:</source>
          <target state="translated">또는 그것을 반환하는 끝점 :</target>
        </trans-unit>
        <trans-unit id="23c60aaacf0e71b59a7197b091439347ab628cef" translate="yes" xml:space="preserve">
          <source>Or creating a changeset from a simple map with types:</source>
          <target state="translated">또는 유형이있는 간단한 맵에서 변경 세트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ab68c6440b65a81745c8da96a580e0571274dd1d" translate="yes" xml:space="preserve">
          <source>Or even assert something was broadcast into pubsub:</source>
          <target state="translated">또는 무언가가 pubsub에 방송되었다고 주장하기도합니다.</target>
        </trans-unit>
        <trans-unit id="1d003458b7bc5539864c0a23e25a6fa8ac04297d" translate="yes" xml:space="preserve">
          <source>Or even dynamically:</source>
          <target state="translated">또는 동적으로 :</target>
        </trans-unit>
        <trans-unit id="712f44bbae8ee984dfa9d49047b6bc225ad6e612" translate="yes" xml:space="preserve">
          <source>Or even say the right side is of the same type as &lt;code&gt;p.title&lt;/code&gt;:</source>
          <target state="translated">또는 오른쪽이 &lt;code&gt;p.title&lt;/code&gt; 과 동일한 유형이라고 말하십시오 .</target>
        </trans-unit>
        <trans-unit id="d33c077786749f9e9de6fab195958ab7831aea1d" translate="yes" xml:space="preserve">
          <source>Or if using MySQL:</source>
          <target state="translated">또는 MySQL을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="ff0dcc57ed98ff60cf6f15da1aa9afd43a8a3840" translate="yes" xml:space="preserve">
          <source>Or maybe you have a subdomain based URL for different organizations:</source>
          <target state="translated">또는 여러 조직에 대한 하위 도메인 기반 URL이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d2db8c0dea9cfa12e2dc31cd92ed981b86c925" translate="yes" xml:space="preserve">
          <source>Or only invoke the Endpoint&amp;rsquo;s plugs:</source>
          <target state="translated">또는 엔드 포인트의 플러그 만 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="0a0eff2f301b498afea7c7d959e2160fd790226d" translate="yes" xml:space="preserve">
          <source>Or to type aggregation results:</source>
          <target state="translated">또는 집계 결과를 입력하려면</target>
        </trans-unit>
        <trans-unit id="ac0551f45123b16a0b4e730672b87a1036336a05" translate="yes" xml:space="preserve">
          <source>Or to type fields from schemaless queries:</source>
          <target state="translated">또는 스키마없는 쿼리에서 필드를 입력하려면</target>
        </trans-unit>
        <trans-unit id="db83fd402c11cf8159d1e10f0e61b02924ea765b" translate="yes" xml:space="preserve">
          <source>Or we can simply set the post_id in the comment itself:</source>
          <target state="translated">또는 단순히 주석 자체에서 post_id를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb25deca5f5b67aa36a9aca437ad824b5dab3b0c" translate="yes" xml:space="preserve">
          <source>Or when preloading:</source>
          <target state="translated">또는 사전로드시 :</target>
        </trans-unit>
        <trans-unit id="4768bd40f3882dca8a91264190d40d76952f751b" translate="yes" xml:space="preserve">
          <source>Or you could attach your own custom behavior.</source>
          <target state="translated">또는 자신 만의 사용자 지정 동작을 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79aa5e012d340daabf02aa4645be1ac4c8831a14" translate="yes" xml:space="preserve">
          <source>Orders the fields based on one or more fields. It accepts a single field or a list of fields. The default direction is ascending (&lt;code&gt;:asc&lt;/code&gt;) and can be customized in a keyword list as one of the following:</source>
          <target state="translated">하나 이상의 필드를 기준으로 필드를 정렬합니다. 단일 필드 또는 필드 목록을 허용합니다. 기본 방향은 오름차순 ( &lt;code&gt;:asc&lt;/code&gt; )이며 키워드 목록에서 다음 중 하나로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cecef7b4b9031469617c3480b016645bf039da43" translate="yes" xml:space="preserve">
          <source>Other options will be passed as html attributes. ie, &lt;code&gt;class: &quot;foo&quot;, id: &quot;bar&quot;&lt;/code&gt;</source>
          <target state="translated">다른 옵션은 html 속성으로 전달됩니다. 즉, &lt;code&gt;class: &quot;foo&quot;, id: &quot;bar&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7c4b57295a40e5f3e757610ef1f4a955b58ae43" translate="yes" xml:space="preserve">
          <source>Other topics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a210eca2b390795c62e881581895a0e75cf0b6a" translate="yes" xml:space="preserve">
          <source>Otherwise a 403 Forbidden response will be sent and the connection halted. It is a noop if the connection has been halted.</source>
          <target state="translated">그렇지 않으면 403 Forbidden 응답이 전송되고 연결이 중지됩니다. 연결이 중단 된 경우 이는 noop입니다.</target>
        </trans-unit>
        <trans-unit id="2b4a0bc39a6815eb69b677161d53d542e530f9f8" translate="yes" xml:space="preserve">
          <source>Otherwise, the request will be redirected to a corresponding location with the &lt;code&gt;https&lt;/code&gt; scheme by setting the &lt;code&gt;location&lt;/code&gt; header of the response. The status code will be 301 if the method of &lt;code&gt;conn&lt;/code&gt; is &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;, or 307 in other situations.</source>
          <target state="translated">그렇지 않으면 응답 의 &lt;code&gt;location&lt;/code&gt; 헤더를 설정 하여 요청이 &lt;code&gt;https&lt;/code&gt; 체계 를 사용하여 해당 위치로 리디렉션됩니다 . &lt;code&gt;conn&lt;/code&gt; 의 메소드 가 &lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 인 경우 상태 코드는 301 이거나 다른 상황에서는 307입니다.</target>
        </trans-unit>
        <trans-unit id="addeb7742f87f3b1575bcea550d015ebadb259c8" translate="yes" xml:space="preserve">
          <source>Otherwise, use &lt;a href=&quot;#socket/2&quot;&gt;&lt;code&gt;socket/2&lt;/code&gt;&lt;/a&gt; if you want to build a socket with id and assigns.</source>
          <target state="translated">그렇지 않으면 id와 assign으로 소켓을 빌드 하려면 &lt;a href=&quot;#socket/2&quot;&gt; &lt;code&gt;socket/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d8972b6dba015c1daf133c9edf1cee72a9b5d92" translate="yes" xml:space="preserve">
          <source>Outgoing messages</source>
          <target state="translated">발신 메시지</target>
        </trans-unit>
        <trans-unit id="84cb499e9d8f2b1a971bcb1ebcff17a6e1eb8b67" translate="yes" xml:space="preserve">
          <source>Overall, an endpoint has three responsibilities:</source>
          <target state="translated">전반적으로 엔드 포인트에는 세 가지 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f8b79088a96e524e81ddc616fb358f5f139825" translate="yes" xml:space="preserve">
          <source>Overall, here is the prefix lookup precedence:</source>
          <target state="translated">전반적으로 접두사 조회 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fcd60e01af70e78edbf181b1214f759e3a283fb" translate="yes" xml:space="preserve">
          <source>Overall, this generator will add the following files to &lt;code&gt;lib/&lt;/code&gt;:</source>
          <target state="translated">전체적으로이 생성기는 다음 파일을 &lt;code&gt;lib/&lt;/code&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ec88af88a4c0ef32ab8fb8dc8407ea440260105d" translate="yes" xml:space="preserve">
          <source>Overall, this generator will add the following files to lib/your_app:</source>
          <target state="translated">전체적으로이 생성기는 다음 파일을 lib / your_app에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="956e1158a7f55f29402094f48543f47fda3b3cf0" translate="yes" xml:space="preserve">
          <source>Overriding &lt;code&gt;action/2&lt;/code&gt; for custom arguments</source>
          <target state="translated">맞춤 인수에 대한 &lt;code&gt;action/2&lt;/code&gt; 재정의</target>
        </trans-unit>
        <trans-unit id="0fe592ea3722f7a45e73af399dbc7308e1cb79b2" translate="yes" xml:space="preserve">
          <source>Overriding the default Plug API functions</source>
          <target state="translated">기본 Plug API 함수 재정의</target>
        </trans-unit>
        <trans-unit id="9475f5f883622c29630c91241f765fa4e8a2d1e6" translate="yes" xml:space="preserve">
          <source>Overriding the default confirm behaviour</source>
          <target state="translated">기본 확인 동작 재정의</target>
        </trans-unit>
        <trans-unit id="021d2cddbf4abaf710484feba4bf51af8bac6435" translate="yes" xml:space="preserve">
          <source>Parameter Parsing</source>
          <target state="translated">파라미터 파싱</target>
        </trans-unit>
        <trans-unit id="540251aeff537e785f0090e4cc24f62d368a649b" translate="yes" xml:space="preserve">
          <source>Parameter filtering</source>
          <target state="translated">파라미터 필터링</target>
        </trans-unit>
        <trans-unit id="5eb03398aca0d53fd13adbb88570ba9bce20d46f" translate="yes" xml:space="preserve">
          <source>Parameter filtering on join</source>
          <target state="translated">결합시 매개 변수 필터링</target>
        </trans-unit>
        <trans-unit id="b62573538900d52f69421fef6d67c0a5eaca90d4" translate="yes" xml:space="preserve">
          <source>Parameter lists are added to the accumulator in reverse order, so be sure to pass the parameters in reverse order.</source>
          <target state="translated">매개 변수 목록은 누적기에 역순으로 추가되므로 매개 변수를 역순으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="9bd05340d4075cf1f86308b962f75f4753adec47" translate="yes" xml:space="preserve">
          <source>Parameters and body</source>
          <target state="translated">매개 변수 및 본문</target>
        </trans-unit>
        <trans-unit id="0cae913f273763644fc1ea065cefbe7c81c8a50c" translate="yes" xml:space="preserve">
          <source>Params are decoded as &amp;ldquo;x-www-form-urlencoded&amp;rdquo; in which key/value pairs are separated by &lt;code&gt;&amp;amp;&lt;/code&gt; and keys are separated from values by &lt;code&gt;=&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &quot;x-www-form-urlencoded&quot;로 디코딩되며 여기서 키 / 값 쌍은 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 구분되고 키는 &lt;code&gt;=&lt;/code&gt; 로 값과 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="84ce6a25f9333e1074169cfa4096ad3c1ac96944" translate="yes" xml:space="preserve">
          <source>Params are decoded as &lt;code&gt;&quot;x-www-form-urlencoded&quot;&lt;/code&gt; in which key/value pairs are separated by &lt;code&gt;&amp;amp;&lt;/code&gt; and keys are separated from values by &lt;code&gt;=&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &lt;code&gt;&quot;x-www-form-urlencoded&quot;&lt;/code&gt; 로 디코딩되며 여기서 키 / 값 쌍은 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 구분되고 키는 &lt;code&gt;=&lt;/code&gt; 로 값과 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8bc818adf9596d6f8e72d5ebb319e14d2d8ad77" translate="yes" xml:space="preserve">
          <source>Parsers may raise a &lt;a href=&quot;plug.parsers.parseerror&quot;&gt;&lt;code&gt;Plug.Parsers.ParseError&lt;/code&gt;&lt;/a&gt; if the request has a malformed body.</source>
          <target state="translated">요청에 잘못된 본문이있는 경우 파서에서 &lt;a href=&quot;plug.parsers.parseerror&quot;&gt; &lt;code&gt;Plug.Parsers.ParseError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cccc957fe078af75253bf9b2e6e8e9e63f87426f" translate="yes" xml:space="preserve">
          <source>Parses JSON request body.</source>
          <target state="translated">JSON 요청 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="febd101e37af95c11999e9624c83f04d4097ab35" translate="yes" xml:space="preserve">
          <source>Parses a comma-separated list of header values</source>
          <target state="translated">쉼표로 구분 된 헤더 값 목록을 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="7abfebddba3c610641e8f882717e35b43ed7edb4" translate="yes" xml:space="preserve">
          <source>Parses a comma-separated list of header values.</source>
          <target state="translated">쉼표로 구분 된 헤더 값 목록을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="eeffd6812fd1c41bf966facf09d2730c17eef5d8" translate="yes" xml:space="preserve">
          <source>Parses a value as defined in &lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341에&lt;/a&gt; 정의 된 대로 값을 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="b5f5bc9fbe8ea215a0c5e0cc30ca46bd75d8ab73" translate="yes" xml:space="preserve">
          <source>Parses a value as defined in &lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc1341/4_Content-Type.html&quot;&gt;RFC-1341에&lt;/a&gt; 정의 된 대로 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="2185e747720b7d0fb465dbcfa35c76689b67ddf1" translate="yes" xml:space="preserve">
          <source>Parses content type (without wildcards)</source>
          <target state="translated">컨텐츠 유형 구문 분석 (와일드 카드 없음)</target>
        </trans-unit>
        <trans-unit id="2ad2310b834d234619722ce81d4e14f7d4ae3f92" translate="yes" xml:space="preserve">
          <source>Parses content type (without wildcards).</source>
          <target state="translated">컨텐츠 유형을 구문 분석합니다 (와일드 카드 없음).</target>
        </trans-unit>
        <trans-unit id="edcb288b34b94e9a7b0b19595aeaef526084fa11" translate="yes" xml:space="preserve">
          <source>Parses headers parameters</source>
          <target state="translated">헤더 매개 변수 구문 분석</target>
        </trans-unit>
        <trans-unit id="c7285730fc5c73222e859f0e3e7c3e02b2c17514" translate="yes" xml:space="preserve">
          <source>Parses headers parameters.</source>
          <target state="translated">헤더 매개 변수를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="5a1d617a7f9d1c524d3e04146f32d517b9afce1c" translate="yes" xml:space="preserve">
          <source>Parses media types (with wildcards)</source>
          <target state="translated">미디어 유형 구문 분석 (와일드 카드 사용)</target>
        </trans-unit>
        <trans-unit id="b2b6e960a35b0125c6525a5e4b92a2ee49c9f2bd" translate="yes" xml:space="preserve">
          <source>Parses media types (with wildcards).</source>
          <target state="translated">미디어 유형을 구문 분석합니다 (와일드 카드 사용).</target>
        </trans-unit>
        <trans-unit id="75d8c6d477b6e3f69af2ae67553366717edbc36a" translate="yes" xml:space="preserve">
          <source>Parses multipart request body.</source>
          <target state="translated">멀티 파트 요청 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="e21c68fcb0d3e3b32206991f6e19f3811948aaee" translate="yes" xml:space="preserve">
          <source>Parses the given cookie</source>
          <target state="translated">주어진 쿠키를 파싱</target>
        </trans-unit>
        <trans-unit id="944dfd390be7ae48712dfb31bfdccb0d6eb083fe" translate="yes" xml:space="preserve">
          <source>Parses the given cookie.</source>
          <target state="translated">주어진 쿠키를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="2b2aef79cbfc6edb73d8c0a8df4a18152f4ef7c8" translate="yes" xml:space="preserve">
          <source>Parses the repository option from the given command line args list</source>
          <target state="translated">제공된 명령 행 인수 목록에서 저장소 옵션을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="4d056c3c1990172ff2a799b5561c4cf7758262df" translate="yes" xml:space="preserve">
          <source>Parses the repository option from the given command line args list.</source>
          <target state="translated">제공된 명령 행 인수 목록에서 저장소 옵션을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="e6b5a511e222d1fd33ba56da0250000bdd6269d4" translate="yes" xml:space="preserve">
          <source>Parses urlencoded request body.</source>
          <target state="translated">urlencoded 요청 본문을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="93e976db30d2d1e659c6681d80cc8c7ab0dbd542" translate="yes" xml:space="preserve">
          <source>Partial changes for many-style associations</source>
          <target state="translated">여러 스타일 연관에 대한 부분 변경</target>
        </trans-unit>
        <trans-unit id="bcf58232ce830f75c9e16a9c414175781444e8ed" translate="yes" xml:space="preserve">
          <source>Passing a changeset as the first argument:</source>
          <target state="translated">변경 세트를 첫 번째 인수로 전달 :</target>
        </trans-unit>
        <trans-unit id="2004f66fdb8c8bf73b24a2cbf645ba2ba722074e" translate="yes" xml:space="preserve">
          <source>Per longpoll transport:</source>
          <target state="translated">롱폴 운송 당 :</target>
        </trans-unit>
        <trans-unit id="0e44a1edfc6cd4e153baf2b65bf53238ca82e2c7" translate="yes" xml:space="preserve">
          <source>Per websocket transport:</source>
          <target state="translated">웹 소켓 전송 당 :</target>
        </trans-unit>
        <trans-unit id="a85e0697988afaaff9ffbaf7e05d3bd427288bd5" translate="yes" xml:space="preserve">
          <source>Performs content negotiation based on the available formats</source>
          <target state="translated">사용 가능한 형식을 기반으로 컨텐츠 협상을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="581159b1cc630249addc79676d97814121177054" translate="yes" xml:space="preserve">
          <source>Performs content negotiation based on the available formats.</source>
          <target state="translated">사용 가능한 형식을 기반으로 컨텐츠 협상을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="66350424b6ec15141e12bc5e1d0630433dc753e2" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked elements in the topic</source>
          <target state="translated">주제에서 추적 된 요소에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d75048af6986e27dc9129029c719e8a150810076" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked elements in the topic.</source>
          <target state="translated">주제에서 추적 된 요소에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9fd3b5cac74a6c816e64725647fb0e077b321ead" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked key in the topic</source>
          <target state="translated">주제에서 추적 된 키에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="65edcafb6a8455f62879eb04988b9447a89e87d0" translate="yes" xml:space="preserve">
          <source>Performs table lookup for tracked key in the topic.</source>
          <target state="translated">주제에서 추적 된 키에 대한 테이블 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e1db222cfb5f428ee6ea20828b82ac315cf7a189" translate="yes" xml:space="preserve">
          <source>Performs the repository change on the association</source>
          <target state="translated">연관에서 저장소 변경을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a30cfc42d0635d83408f75d1c0aa49bd2fa09bee" translate="yes" xml:space="preserve">
          <source>Performs the repository change on the association.</source>
          <target state="translated">연관에서 저장소 변경을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d7f4ad0c4187ab879c3f2d5cbdf9d2c789a5d959" translate="yes" xml:space="preserve">
          <source>Persists a value in flash</source>
          <target state="translated">플래시 값 유지</target>
        </trans-unit>
        <trans-unit id="2ae9ec55da158cde328d17e822f68f763d0e88f6" translate="yes" xml:space="preserve">
          <source>Persists a value in flash.</source>
          <target state="translated">플래시 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="3e978fbf8aad93b7520fcec25f666a8823b47615" translate="yes" xml:space="preserve">
          <source>Phoenix</source>
          <target state="translated">Phoenix</target>
        </trans-unit>
        <trans-unit id="8e407dce91f4a35a357a057dc8cd197d689f75ed" translate="yes" xml:space="preserve">
          <source>Phoenix PubSub adapter based on &lt;a href=&quot;http://erlang.org/doc/man/pg2.html&quot;&gt;PG2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://erlang.org/doc/man/pg2.html&quot;&gt;PG2&lt;/a&gt; 기반의 Phoenix PubSub 어댑터 .</target>
        </trans-unit>
        <trans-unit id="563cf9047af9d0a38a9f21a81eb58f780532cb3a" translate="yes" xml:space="preserve">
          <source>Phoenix also provides a &lt;a href=&quot;#resources/4&quot;&gt;&lt;code&gt;resources/4&lt;/code&gt;&lt;/a&gt; macro that allows developers to generate &amp;ldquo;RESTful&amp;rdquo; routes to a given resource:</source>
          <target state="translated">또한 Phoenix 는 개발자가 주어진 리소스에 대한 &quot;RESTful&quot;경로를 생성 할 수 있도록 &lt;a href=&quot;#resources/4&quot;&gt; &lt;code&gt;resources/4&lt;/code&gt; &lt;/a&gt; 매크로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72235a2da760fdd627bf34a66005e7ad134e9e16" translate="yes" xml:space="preserve">
          <source>Phoenix automatically generates a module &lt;code&gt;Helpers&lt;/code&gt; inside your router which contains named helpers to help developers generate and keep their routes up to date.</source>
          <target state="translated">Phoenix는 라우터 내부에 모듈 &lt;code&gt;Helpers&lt;/code&gt; 자동으로 생성하는데, 여기에는 개발자가 경로를 생성하고 최신 상태로 유지할 수 있도록 명명 된 헬퍼가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55671bef02efae40eff055a656f5c94f8ff1d22d" translate="yes" xml:space="preserve">
          <source>Phoenix can filter all parameters by default and selectively keep parameters. This can be configured like so:</source>
          <target state="translated">Phoenix는 기본적으로 모든 매개 변수를 필터링하고 선택적으로 매개 변수를 유지할 수 있습니다. 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681383e103822b1a0593bf4b68cda68085e72301" translate="yes" xml:space="preserve">
          <source>Phoenix default events</source>
          <target state="translated">피닉스 기본 이벤트</target>
        </trans-unit>
        <trans-unit id="b7a0c1b121ac14fd3a53cd23959e43b33c97063f" translate="yes" xml:space="preserve">
          <source>Phoenix defines the view template at &lt;code&gt;lib/web/web.ex&lt;/code&gt;:</source>
          <target state="translated">Phoenix는 &lt;code&gt;lib/web/web.ex&lt;/code&gt; 에서 뷰 템플릿을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d1e2992f72ece22d106950f407c7d2f47005cb" translate="yes" xml:space="preserve">
          <source>Phoenix includes a JavaScript client for WebSocket and Longpolling support using JSON encodings.</source>
          <target state="translated">Phoenix에는 JSON 인코딩을 사용하는 WebSocket 및 Longpolling 지원을위한 JavaScript 클라이언트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd1a122e2d3db7e6977ee15d5854014e7c483daf" translate="yes" xml:space="preserve">
          <source>Phoenix injects an &lt;code&gt;action/2&lt;/code&gt; plug in your controller which calls the function matched from the router. By default, it passes the conn and params. In some cases, overriding the &lt;code&gt;action/2&lt;/code&gt; plug in your controller is a useful way to inject arguments into your actions that you would otherwise need to fetch of the connection repeatedly. For example, imagine if you stored a &lt;code&gt;conn.assigns.current_user&lt;/code&gt; in the connection and wanted quick access to the user for every action in your controller:</source>
          <target state="translated">Phoenix 는 라우터에 일치하는 기능을 호출 하는 &lt;code&gt;action/2&lt;/code&gt; 플러그를 컨트롤러에 삽입 합니다. 기본적으로 conn 및 params를 전달합니다. 경우 에 따라 컨트롤러에서 &lt;code&gt;action/2&lt;/code&gt; 플러그를 재정의하는 것이 연결에 반복적으로 가져와야하는 인수를 조치에 삽입하는 유용한 방법입니다. 예를 들어, 연결에 &lt;code&gt;conn.assigns.current_user&lt;/code&gt; 를 저장하고 컨트롤러의 모든 작업에 대해 사용자에게 빠르게 액세스하려는 경우를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="2c678b44209f0fadf67e60a99e2b49b722fd392a" translate="yes" xml:space="preserve">
          <source>Phoenix knows how to extract the &lt;code&gt;:id&lt;/code&gt; from &lt;code&gt;@user&lt;/code&gt; thanks to this protocol.</source>
          <target state="translated">피닉스는 추출하는 방법을 알고 &lt;code&gt;:id&lt;/code&gt; 에서 &lt;code&gt;@user&lt;/code&gt; 의 이 프로토콜에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="7b2cd29ce0f61c525ebbf5b9fbe66435aa87ab5b" translate="yes" xml:space="preserve">
          <source>Phoenix pubsub was designed to be flexible and support multiple backends. We currently ship with two backends:</source>
          <target state="translated">Phoenix pubsub는 유연하게 설계되었으며 여러 백엔드를 지원합니다. 현재 두 개의 백엔드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="50c2a8172e777a948fbb454fccb02b365c2af72b" translate="yes" xml:space="preserve">
          <source>Phoenix ships with some template engines and format encoders, which can be further configured in the Phoenix application. You can read more about format encoders in &lt;a href=&quot;phoenix.template&quot;&gt;&lt;code&gt;Phoenix.Template&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">Phoenix는 일부 템플릿 엔진 및 형식 인코더와 함께 제공되며 Phoenix 애플리케이션에서 추가로 구성 할 수 있습니다. 포맷 인코더에 대한 자세한 내용은 &lt;a href=&quot;phoenix.template&quot;&gt; &lt;code&gt;Phoenix.Template&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc3a831c178dd184156bc4d1affde9ff805af580" translate="yes" xml:space="preserve">
          <source>Phoenix supports instrumentation through an extensible API. Each endpoint defines an &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro that both users and Phoenix internals can call to instrument generic events. This macro is responsible for measuring the time it takes for the event to be processed and for notifying a list of interested instrumenter modules of this measurement.</source>
          <target state="translated">Phoenix는 확장 가능한 API를 통한 계측을 지원합니다. 각 엔드 포인트는 사용자와 Phoenix 내부에서 일반 이벤트를 계측하기 위해 호출 할 수 있는 &lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt; 매크로를 정의 합니다. 이 매크로는 이벤트를 처리하는 데 걸리는 시간을 측정하고이 측정에 관심있는 계측기 모듈 목록을 알리는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="ce5aad93c959c8da3f30d2164ea56e1348ca5c84" translate="yes" xml:space="preserve">
          <source>Phoenix&amp;rsquo;s default is &lt;code&gt;[&quot;password&quot;]&lt;/code&gt;.</source>
          <target state="translated">Phoenix의 기본값은 &lt;code&gt;[&quot;password&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0cd67f6f884429e9186f9da35ac87f7fba18cba" translate="yes" xml:space="preserve">
          <source>Phoenix&amp;rsquo;s router is extremely efficient, as it relies on Elixir pattern matching for matching routes and serving requests.</source>
          <target state="translated">Phoenix의 라우터는 경로 일치 및 요청 처리에 Elixir 패턴 일치를 사용하므로 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f3f724bed5c1dd367d7a6792b9791c2b2e7f4b61" translate="yes" xml:space="preserve">
          <source>Phoenix.ActionClauseError</source>
          <target state="translated">Phoenix.ActionClauseError</target>
        </trans-unit>
        <trans-unit id="a3c9625a75baea112564459d484e0749d11f46dd" translate="yes" xml:space="preserve">
          <source>Phoenix.ActionClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.ActionClauseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dc55ed0afe31dd55493b9cffeda4e4fc9d18de96" translate="yes" xml:space="preserve">
          <source>Phoenix.Channel</source>
          <target state="translated">Phoenix.Channel</target>
        </trans-unit>
        <trans-unit id="7f0eb0fd8d0504f17307a6fe51df4933f98dd78b" translate="yes" xml:space="preserve">
          <source>Phoenix.Channel &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Channel &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="194067696901b5ee61c86e4a34c8412e29d8a729" translate="yes" xml:space="preserve">
          <source>Phoenix.ChannelTest</source>
          <target state="translated">Phoenix.ChannelTest</target>
        </trans-unit>
        <trans-unit id="7f47822f13327710ff7c52a6086ea2369d9864f1" translate="yes" xml:space="preserve">
          <source>Phoenix.CodeReloader</source>
          <target state="translated">Phoenix.CodeReloader</target>
        </trans-unit>
        <trans-unit id="71ff35769fb1ba5e7fe215dacfb07c1a016a409a" translate="yes" xml:space="preserve">
          <source>Phoenix.ConnTest</source>
          <target state="translated">Phoenix.ConnTest</target>
        </trans-unit>
        <trans-unit id="f1bb9bd32ed6a31867d5e3f4baaeb4cd54e0d456" translate="yes" xml:space="preserve">
          <source>Phoenix.Controller</source>
          <target state="translated">Phoenix.Controller</target>
        </trans-unit>
        <trans-unit id="b083ff21b48dc5fc860fe03533f81abf7ff48a0b" translate="yes" xml:space="preserve">
          <source>Phoenix.Digester</source>
          <target state="translated">Phoenix.Digester</target>
        </trans-unit>
        <trans-unit id="4596b9f544e92d211c61bfff6ce5c45323d19998" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint</source>
          <target state="translated">Phoenix.Endpoint</target>
        </trans-unit>
        <trans-unit id="e92cb5f483d3e8b468601886c85c01459044b604" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Endpoint &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9e2a4123df59e55691aadc23751b530eea4294d1" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.CowboyHandler</source>
          <target state="translated">Phoenix.Endpoint.CowboyHandler</target>
        </trans-unit>
        <trans-unit id="89b27ed63f4f756c1f00eabc7cc517d3aa354251" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.Handler</source>
          <target state="translated">Phoenix.Endpoint.Handler</target>
        </trans-unit>
        <trans-unit id="250b8ddbb84121b634ab3349e0f36898b6f54154" translate="yes" xml:space="preserve">
          <source>Phoenix.Endpoint.Handler &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Endpoint.Handler &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6987f796feee2221ad338ab71afc5d2c71509a7b" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Engine</source>
          <target state="translated">Phoenix.HTML.Engine</target>
        </trans-unit>
        <trans-unit id="3b67791df012124d0e4b2454857515f310c79756" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Form</source>
          <target state="translated">Phoenix.HTML.Form</target>
        </trans-unit>
        <trans-unit id="999475b0cb80ba68d5a56924e78e15906ac978b9" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData</source>
          <target state="translated">Phoenix.HTML.FormData</target>
        </trans-unit>
        <trans-unit id="04a8bfdcef89a105f09fe88aa2835a8c1ce4c4be" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">Phoenix.HTML.FormData &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="da04dc0f2d6b8acebef1fb005064e5a04b2ff3a0" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.input_type (3)</source>
          <target state="translated">Phoenix.HTML.FormData.input_type (3)</target>
        </trans-unit>
        <trans-unit id="3c5a41144956d8684f02352faac91bb53520389c" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.input_validations (3)</source>
          <target state="translated">Phoenix.HTML.FormData.input_validations (3)</target>
        </trans-unit>
        <trans-unit id="87c641775daf60819a26236f4e55fb074a6a99cc" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.input_value (3)</source>
          <target state="translated">Phoenix.HTML.FormData.input_value (3)</target>
        </trans-unit>
        <trans-unit id="8f602b3c4b4fd5b433a895b76de2afacbc126fdc" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.t (0)</source>
          <target state="translated">Phoenix.HTML.FormData.t (0)</target>
        </trans-unit>
        <trans-unit id="f7da9b9ca7ed512a02f17037b9fdbd9c9f60ebc7" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.to_form (2)</source>
          <target state="translated">Phoenix.HTML.FormData.to_form (2)</target>
        </trans-unit>
        <trans-unit id="5ccae6cd22b0a64bb0f4555803e5210d7d16c1d2" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.FormData.to_form (4)</source>
          <target state="translated">Phoenix.HTML.FormData.to_form (4)</target>
        </trans-unit>
        <trans-unit id="daf81ce2175003e5551acec3f22e912d6f354abb" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Format</source>
          <target state="translated">Phoenix.HTML.Format</target>
        </trans-unit>
        <trans-unit id="040e2511b94e8cd75bd6ecf44cc8a5d637238b81" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Link</source>
          <target state="translated">Phoenix.HTML.Link</target>
        </trans-unit>
        <trans-unit id="6932ff744b89afc815c5b8542af4342ea56a3340" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe</source>
          <target state="translated">Phoenix.HTML.Safe</target>
        </trans-unit>
        <trans-unit id="266d7c161ec8bc2e9c0e2d9960f206f4e4e9f771" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">Phoenix.HTML.Safe &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8224dbe21b25ec1c7a480134db55859fcaf6d339" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe.t (0)</source>
          <target state="translated">Phoenix.HTML.Safe.t (0)</target>
        </trans-unit>
        <trans-unit id="662e3232a3f3aa1d971e6a4dbf827fc2ef052645" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Safe.to_iodata (1)</source>
          <target state="translated">Phoenix.HTML.Safe.to_iodata (1)</target>
        </trans-unit>
        <trans-unit id="a88a5675b06fa29c744c634664506ce144b08e0c" translate="yes" xml:space="preserve">
          <source>Phoenix.HTML.Tag</source>
          <target state="translated">Phoenix.HTML.Tag</target>
        </trans-unit>
        <trans-unit id="18ed4339cd679ede709262e5c7ca6dbb72bf11f9" translate="yes" xml:space="preserve">
          <source>Phoenix.Logger</source>
          <target state="translated">Phoenix.Logger</target>
        </trans-unit>
        <trans-unit id="18f54395c35b9ed069f39004e2697c661fbad386" translate="yes" xml:space="preserve">
          <source>Phoenix.MissingParamError</source>
          <target state="translated">Phoenix.MissingParamError</target>
        </trans-unit>
        <trans-unit id="7e80cad23896baef4ff1811bc9766d2b89732862" translate="yes" xml:space="preserve">
          <source>Phoenix.MissingParamError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.MissingParamError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="af6e7971d9c75329ee2d5a112ce07dd63719b84c" translate="yes" xml:space="preserve">
          <source>Phoenix.Naming</source>
          <target state="translated">Phoenix.Naming</target>
        </trans-unit>
        <trans-unit id="77242a4c29eb130cfa68c2e99e1810423e07dcfb" translate="yes" xml:space="preserve">
          <source>Phoenix.NotAcceptableError</source>
          <target state="translated">Phoenix.NotAcceptableError</target>
        </trans-unit>
        <trans-unit id="8fc4c919fa9143f47d0d26d1af22cd3a40258486" translate="yes" xml:space="preserve">
          <source>Phoenix.NotAcceptableError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.NotAcceptableError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="78bc07bb7a9125c02ecf85d4c004e9bb157c2826" translate="yes" xml:space="preserve">
          <source>Phoenix.Param</source>
          <target state="translated">Phoenix.Param</target>
        </trans-unit>
        <trans-unit id="bb1d6188b5400f302d27eef68360a665984a8f62" translate="yes" xml:space="preserve">
          <source>Phoenix.Param &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">Phoenix.Param &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dd8ca2142234d167b5390c3462f591825869a497" translate="yes" xml:space="preserve">
          <source>Phoenix.Param.t (0)</source>
          <target state="translated">피닉스 파라 메 (0)</target>
        </trans-unit>
        <trans-unit id="c4b9da22cc6b8bc9499b0aa80a5680cf66ee196a" translate="yes" xml:space="preserve">
          <source>Phoenix.Param.to_param (1)</source>
          <target state="translated">Phoenix.Param.to_param (1)</target>
        </trans-unit>
        <trans-unit id="eeda5210386aed3128867da645c85a2274d2c0ff" translate="yes" xml:space="preserve">
          <source>Phoenix.Presence</source>
          <target state="translated">Phoenix.Presence</target>
        </trans-unit>
        <trans-unit id="1c6cee5a13060e94bd272116ce04a11edb0fb3ed" translate="yes" xml:space="preserve">
          <source>Phoenix.Presence &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">피닉스. 존재 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1771d26988e43bc483b78a4a7956bc399d115727" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub</source>
          <target state="translated">Phoenix.PubSub</target>
        </trans-unit>
        <trans-unit id="e088adf91de21851153d82558f1b5b94e4fee9be" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.BroadcastError</source>
          <target state="translated">Phoenix.PubSub.BroadcastError</target>
        </trans-unit>
        <trans-unit id="c21b0fafbb5e8d03a8c3c6ae17dca1136b1dc3b5" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.BroadcastError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.PubSub.BroadcastError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="16d6a73345201c65a7626dd501d627ab27dfc9de" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.GC</source>
          <target state="translated">Phoenix.PubSub.GC</target>
        </trans-unit>
        <trans-unit id="7694b062d6fc42fc848d17abfab7ee653935a9ce" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.Local</source>
          <target state="translated">Phoenix.PubSub.Local</target>
        </trans-unit>
        <trans-unit id="941fb28aafbbb815dd5c95a534c319ae3d36c36c" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.LocalSupervisor</source>
          <target state="translated">Phoenix.PubSub.LocalSupervisor</target>
        </trans-unit>
        <trans-unit id="7d910cadf0a19ada4a43c712efd81d787b209afe" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.PG2</source>
          <target state="translated">Phoenix.PubSub.PG2</target>
        </trans-unit>
        <trans-unit id="a68a8acd108d213f9a93e6df2b052eb4a81b5c20" translate="yes" xml:space="preserve">
          <source>Phoenix.PubSub.Supervisor</source>
          <target state="translated">Phoenix.PubSub.Supervisor</target>
        </trans-unit>
        <trans-unit id="30e9a959dc51235994d199ae35f8ecf6e3aafb98" translate="yes" xml:space="preserve">
          <source>Phoenix.Router</source>
          <target state="translated">Phoenix.Router</target>
        </trans-unit>
        <trans-unit id="a0fa225c88930ec3a4a05c9b434cd9ccfae83464" translate="yes" xml:space="preserve">
          <source>Phoenix.Router.NoRouteError</source>
          <target state="translated">Phoenix.Router.NoRouteError</target>
        </trans-unit>
        <trans-unit id="21a0480959213f5dafde91b500efd2b48392f822" translate="yes" xml:space="preserve">
          <source>Phoenix.Router.NoRouteError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.Router.NoRouteError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="15c8b8a4eab6b63ce74836a0047c01c5d613caea" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket</source>
          <target state="translated">Phoenix.Socket</target>
        </trans-unit>
        <trans-unit id="5f4eb1aa819a708cc071efa9545599afd328835b" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">피닉스 소켓 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dec13932c8027eda323afb9aa03ee6266c07c5f1" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Broadcast</source>
          <target state="translated">Phoenix.Socket.Broadcast</target>
        </trans-unit>
        <trans-unit id="e6b39e263c2f93b46a5e61347b46e247bb3ea74a" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.InvalidMessageError</source>
          <target state="translated">Phoenix.Socket.InvalidMessageError</target>
        </trans-unit>
        <trans-unit id="6eabb3d1eca5d0468cd5c297c1d0d6e9b273dfc2" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.InvalidMessageError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.Socket.InvalidMessageError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cc1215c6ff861301db6a6265e25b4296d73eb2bb" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Message</source>
          <target state="translated">Phoenix.Socket.Message</target>
        </trans-unit>
        <trans-unit id="536df0a73a189404cc538ce4401d0b55e578ae8e" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Reply</source>
          <target state="translated">Phoenix.Socket.Reply</target>
        </trans-unit>
        <trans-unit id="975a6a8cb29b023db1536efe366a0246b8f8f73f" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Transport</source>
          <target state="translated">Phoenix.Socket.Transport</target>
        </trans-unit>
        <trans-unit id="7100002fc16c82bbe7ff3fb56a65c5478a47d59c" translate="yes" xml:space="preserve">
          <source>Phoenix.Socket.Transport &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Socket.Transport &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8ae4b158e8dce3b5d2defd5c648cfa621670fcff" translate="yes" xml:space="preserve">
          <source>Phoenix.Template</source>
          <target state="translated">Phoenix.Template</target>
        </trans-unit>
        <trans-unit id="3116ab3ec2d51d6a59cc0b58a78dcf0c1705d6a4" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.EExEngine</source>
          <target state="translated">Phoenix.Template.EExEngine</target>
        </trans-unit>
        <trans-unit id="0a01340729120640cbc0f60d173d14a93cd917a3" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.Engine</source>
          <target state="translated">Phoenix.Template.Engine</target>
        </trans-unit>
        <trans-unit id="1ad27c23cf4f858125bea91c2e7c75356d89a714" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.Engine &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Template.Engine &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="234d6d4a6b93dd62f2590b3842d1a7d46378d167" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.ExsEngine</source>
          <target state="translated">Phoenix.Template.ExsEngine</target>
        </trans-unit>
        <trans-unit id="2a322c29f1da50c5ce310b3c32a380db55975eb6" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.HTML</source>
          <target state="translated">Phoenix.Template.HTML</target>
        </trans-unit>
        <trans-unit id="45ce2441c1e0bca5729eef8b018bba81e9a40cf8" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.UndefinedError</source>
          <target state="translated">Phoenix.Template.UndefinedError</target>
        </trans-unit>
        <trans-unit id="b717ca75c096168f81cb863370a119961f1e124a" translate="yes" xml:space="preserve">
          <source>Phoenix.Template.UndefinedError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Phoenix.Template.UndefinedError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4100edf3175789316497437c6450655389771ed7" translate="yes" xml:space="preserve">
          <source>Phoenix.Token</source>
          <target state="translated">Phoenix.Token</target>
        </trans-unit>
        <trans-unit id="617049e3dee7e40fb8b99dfc1f2e1b4b83118d7a" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker</source>
          <target state="translated">Phoenix.Tracker</target>
        </trans-unit>
        <trans-unit id="04f9c2ab9d80b402057013e3c8dbe36d1656374a" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Tracker &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c21af06db2da4ef620e3dc022eb3c8ecfc7364d4" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker.Shard</source>
          <target state="translated">Phoenix.Tracker.Shard</target>
        </trans-unit>
        <trans-unit id="542ae29baa6557b6ae9b127e5619f2f2d2353b4c" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker.Shard &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Tracker.Shard &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="789ba99bf73efbcedc95f1b2f2b5ff382b8db713" translate="yes" xml:space="preserve">
          <source>Phoenix.Tracker.State</source>
          <target state="translated">Phoenix.Tracker.State</target>
        </trans-unit>
        <trans-unit id="d92e8bf63e6d221807acdde4e7dab43bdab64274" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.LongPoll</source>
          <target state="translated">Phoenix.Transports.LongPoll</target>
        </trans-unit>
        <trans-unit id="c0495d5fc1db092780a2235609f5cf672dc23581" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.Serializer</source>
          <target state="translated">Phoenix.Transports.Serializer</target>
        </trans-unit>
        <trans-unit id="50339ae5aa447a89cb481302464a30dc2d96b2b7" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.Serializer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Phoenix.Transports.Serializer &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="74d4a8b3f14220f0f7e61bf4984dc37d4c5be450" translate="yes" xml:space="preserve">
          <source>Phoenix.Transports.WebSocket</source>
          <target state="translated">Phoenix.Transports.WebSocket</target>
        </trans-unit>
        <trans-unit id="9a429996206e9b73a474596f699b2eda6333bd55" translate="yes" xml:space="preserve">
          <source>Phoenix.View</source>
          <target state="translated">Phoenix.View</target>
        </trans-unit>
        <trans-unit id="f48c581069059c13328af0b2e2818126b82fd34a" translate="yes" xml:space="preserve">
          <source>Pipelines and plugs</source>
          <target state="translated">파이프 라인 및 플러그</target>
        </trans-unit>
        <trans-unit id="1d4481e68159859f03e70cf9a77f061d044faa36" translate="yes" xml:space="preserve">
          <source>Pipelines are defined at the router root and can be used from any scope.</source>
          <target state="translated">파이프 라인은 라우터 루트에서 정의되며 모든 범위에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6919c5e978569b7c38dd5e903c954441364fed" translate="yes" xml:space="preserve">
          <source>Plans a query using the given adapter</source>
          <target state="translated">주어진 어댑터를 사용하여 쿼리 계획</target>
        </trans-unit>
        <trans-unit id="1060e726672f4517cb496b202d24b08618a977cc" translate="yes" xml:space="preserve">
          <source>Plans a query using the given adapter.</source>
          <target state="translated">주어진 어댑터를 사용하여 쿼리를 계획합니다.</target>
        </trans-unit>
        <trans-unit id="23441c76f8f0fea9cebdad7024ae9d43267ca0fd" translate="yes" xml:space="preserve">
          <source>Plans and prepares a query for the given repo, leveraging its query cache</source>
          <target state="translated">쿼리 캐시를 활용하여 지정된 리포지토리에 대한 쿼리 계획 및 준비</target>
        </trans-unit>
        <trans-unit id="1e55e74adc560a8ce58ea242927a6a7d15ecd946" translate="yes" xml:space="preserve">
          <source>Plans and prepares a query for the given repo, leveraging its query cache.</source>
          <target state="translated">쿼리 캐시를 활용하여 지정된 리포지토리에 대한 쿼리를 계획하고 준비합니다.</target>
        </trans-unit>
        <trans-unit id="4e9efbf61297042078f0e61a851e7de6288b9450" translate="yes" xml:space="preserve">
          <source>Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won&amp;rsquo;t work:</source>
          <target state="translated">이것이 작동하려면 데이터베이스에서 기존 구조체를로드해야합니다. 따라서 구조체가 존재하더라도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7fbb8a6dd50cf08d9f76c5cf9b730d1437190c9" translate="yes" xml:space="preserve">
          <source>Please note that specifying a cipher as a binary string is not valid and would silently fail in the past. This was problematic because the result would be for Erlang to use the default list of ciphers. To prevent this Plug will now throw an error to ensure you&amp;rsquo;re aware of this.</source>
          <target state="translated">암호를 이진 문자열로 지정하는 것은 유효하지 않으며 과거에는 자동으로 실패합니다. 결과는 Erlang이 기본 암호 목록을 사용하기 때문에 문제가되었습니다. 이 플러그를 방지하려면 이제이를 인식 할 수 있도록 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91e1335792877d04ea770f392aee951ccaf83e70" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;ecto.schema.metadata&quot;&gt;&lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt;&lt;/a&gt; module for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;ecto.schema.metadata&quot;&gt; &lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dce109d49823084600b80720242d87140dd6592f" translate="yes" xml:space="preserve">
          <source>Plug</source>
          <target state="translated">Plug</target>
        </trans-unit>
        <trans-unit id="7c7e4fdd3cdc2dff539b9f180562230cfc46d2c5" translate="yes" xml:space="preserve">
          <source>Plug &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="12732fc8131e6b226a95926ba5de3ef015ce7c61" translate="yes" xml:space="preserve">
          <source>Plug Options</source>
          <target state="translated">플러그 옵션</target>
        </trans-unit>
        <trans-unit id="15c8311c78620445d44f639385af88e3c6c0f460" translate="yes" xml:space="preserve">
          <source>Plug allows a developer to build query strings that map to Elixir structures in order to make manipulation of such structures easier on the server side. Here are some examples:</source>
          <target state="translated">플러그를 사용하면 개발자가 서버 측에서 이러한 구조를보다 쉽게 ​​조작 할 수 있도록 Elixir 구조에 매핑되는 쿼리 문자열을 작성할 수 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="c0116ba430886361e4c51fe8937ae9b7eec35f8e" translate="yes" xml:space="preserve">
          <source>Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the &lt;code&gt;:plug&lt;/code&gt; application. For example, to override the existing 404 reason phrase for the 404 status code (&amp;ldquo;Not Found&amp;rdquo; by default) and add a new 451 status code, the following config can be specified:</source>
          <target state="translated">플러그를 사용하면 플러그 나 해당 어댑터에서 직접 지정하지 않은 새 코드를 허용하기 위해 상태 코드를 재정의하거나 추가 할 수 있습니다. 상태 코드 추가 또는 재정의는 &lt;code&gt;:plug&lt;/code&gt; 애플리케이션 의 혼합 구성을 통해 수행됩니다 . 예를 들어, 404 상태 코드의 기존 404 이유 구문을 무시하고 (기본적으로 &quot;찾을 수 없음&quot;) 새로운 451 상태 코드를 추가하려면 다음 구성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc79b11ec870c9eae9ae7413b1d48d08eaf38429" translate="yes" xml:space="preserve">
          <source>Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the &lt;code&gt;:plug&lt;/code&gt; application. For example, to override the existing 404 reason phrase for the 404 status code (&amp;ldquo;Not Found&amp;rdquo; by default) and add a new 998 status code, the following config can be specified:</source>
          <target state="translated">플러그를 사용하면 플러그 나 해당 어댑터에서 직접 지정하지 않은 새 코드를 허용하기 위해 상태 코드를 재정의하거나 추가 할 수 있습니다. 상태 코드 추가 또는 재정의는 &lt;code&gt;:plug&lt;/code&gt; 애플리케이션 의 혼합 구성을 통해 수행됩니다 . 예를 들어, 404 상태 코드의 기존 404 이유 문구를 무시하고 (기본적으로 &quot;찾을 수 없음&quot;) 새로운 998 상태 코드를 추가하려면 다음 구성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18c657519b38c3613274954c2cdf6a713c33b59" translate="yes" xml:space="preserve">
          <source>Plug behaviour</source>
          <target state="translated">플러그 동작</target>
        </trans-unit>
        <trans-unit id="a40628d1ac1f915c79a5953f6c04a1c8de88e590" translate="yes" xml:space="preserve">
          <source>Plug initialization callback</source>
          <target state="translated">플러그 초기화 콜백</target>
        </trans-unit>
        <trans-unit id="5106d525f5ec5116b03e8d92705c063c0ee06ab9" translate="yes" xml:space="preserve">
          <source>Plug initialization callback.</source>
          <target state="translated">초기화 콜백을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="e910974c1e028c594bce3d68cef33fd5394e7df8" translate="yes" xml:space="preserve">
          <source>Plug pipeline</source>
          <target state="translated">플러그 파이프 라인</target>
        </trans-unit>
        <trans-unit id="fc8dd83ae44bb059cc7802314fed9a543d1c702f" translate="yes" xml:space="preserve">
          <source>Plug pipeline callback</source>
          <target state="translated">플러그 파이프 라인 콜백</target>
        </trans-unit>
        <trans-unit id="38b80698245f8c4f0b9bb325123b02f8db8735b7" translate="yes" xml:space="preserve">
          <source>Plug pipeline callback.</source>
          <target state="translated">파이프 라인 콜백을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="5b8d7df3246be1fd76c07e99f8e23e2c642d34a3" translate="yes" xml:space="preserve">
          <source>Plug ships with the following parsers:</source>
          <target state="translated">다음과 같은 파서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="64750cb1a06f5010538b48f3144265324fda1dac" translate="yes" xml:space="preserve">
          <source>Plug ships with the following session stores:</source>
          <target state="translated">플러그는 다음 세션 저장소와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="88e430fe4000c7309065c41f50017a5014756368" translate="yes" xml:space="preserve">
          <source>Plug to protect from cross-site request forgery.</source>
          <target state="translated">사이트 간 요청 위조로부터 보호하기위한 플러그입니다.</target>
        </trans-unit>
        <trans-unit id="5090d5e35ab4a0e3c9892e222f65ca37cc39f4d8" translate="yes" xml:space="preserve">
          <source>Plug.Adapters.Cowboy</source>
          <target state="translated">Plug.Adapters.Cowboy</target>
        </trans-unit>
        <trans-unit id="03e978ece5c71b0b11092b3e53a7b5c35b21b895" translate="yes" xml:space="preserve">
          <source>Plug.Adapters.Cowboy2</source>
          <target state="translated">Plug.Adapters.Cowboy2</target>
        </trans-unit>
        <trans-unit id="1f02f113800b0cf10c9ab32938948463ae8051be" translate="yes" xml:space="preserve">
          <source>Plug.BadRequestError</source>
          <target state="translated">Plug.BadRequestError</target>
        </trans-unit>
        <trans-unit id="62f108c33076c27169358f8ecd89e35a38697289" translate="yes" xml:space="preserve">
          <source>Plug.BadRequestError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.BadRequestError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f8aa731ebba0d5376c075f74c1c69f7628d45c49" translate="yes" xml:space="preserve">
          <source>Plug.Builder</source>
          <target state="translated">Plug.Builder</target>
        </trans-unit>
        <trans-unit id="3724cc2f092149d8ded98361fbf5df7e0282b2b8" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection</source>
          <target state="translated">Plug.CSRFProtection</target>
        </trans-unit>
        <trans-unit id="b1c348e6fedac292667c5449e7e31b6111c64863" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCSRFTokenError</source>
          <target state="translated">Plug.CSRFProtection.InvalidCSRFTokenError</target>
        </trans-unit>
        <trans-unit id="097dd5324eeaac24afcb1a5c24a608dc76f3dca4" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCSRFTokenError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.CSRFProtection.InvalidCSRFTokenError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d2a2e7efa35695745f63a5dc0d1d7fb5475eb72a" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCrossOriginRequestError</source>
          <target state="translated">Plug.CSRFProtection.InvalidCrossOriginRequestError</target>
        </trans-unit>
        <trans-unit id="a33fafd111d45648b8b5e9f6dc1392feabbea6d8" translate="yes" xml:space="preserve">
          <source>Plug.CSRFProtection.InvalidCrossOriginRequestError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.CSRFProtection.InvalidCrossOriginRequestError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="40cce800a5c3149b46d4f3c35a5189042a167861" translate="yes" xml:space="preserve">
          <source>Plug.Conn</source>
          <target state="translated">Plug.Conn</target>
        </trans-unit>
        <trans-unit id="b574632d3cdd4e84e014f0a2f6cfb904422686f2" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Adapter &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 연결 어댑터 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="21747133d0bfbba57a64eaa43478a6f881fb3f3d" translate="yes" xml:space="preserve">
          <source>Plug.Conn.AlreadySentError</source>
          <target state="translated">Plug.Conn.AlreadySentError</target>
        </trans-unit>
        <trans-unit id="8b34f269cef9b38f4bc80cd1ea87510fa961e0f3" translate="yes" xml:space="preserve">
          <source>Plug.Conn.AlreadySentError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.AlreadySentError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3a21400c358e3bbe2ec0b0db6c914de64499de5b" translate="yes" xml:space="preserve">
          <source>Plug.Conn.CookieOverflowError</source>
          <target state="translated">Plug.Conn.CookieOverflowError</target>
        </trans-unit>
        <trans-unit id="bc996d1c97e7362b9076b9e286d3612430f2c073" translate="yes" xml:space="preserve">
          <source>Plug.Conn.CookieOverflowError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.CookieOverflowError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bb86f659414f21859b56e588dfc82241895d0095" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Cookies</source>
          <target state="translated">Plug.Conn.Cookies</target>
        </trans-unit>
        <trans-unit id="da591d1d7cccd223cfb43581f16c408d4a2cacce" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidHeaderError</source>
          <target state="translated">Plug.Conn.InvalidHeaderError</target>
        </trans-unit>
        <trans-unit id="4b8c631413aee6b7519be91a5b52f0885e00f535" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidHeaderError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.InvalidHeaderError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6084b6ee3204533a4e0ee26ce3e9fced7e012fc6" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidQueryError</source>
          <target state="translated">Plug.Conn.InvalidQueryError</target>
        </trans-unit>
        <trans-unit id="4b06f1704e9fd1f811248b8b1fd13f98567d4081" translate="yes" xml:space="preserve">
          <source>Plug.Conn.InvalidQueryError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.InvalidQueryError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3fd422bf6d8a706b9088311ea1d7b3b6fcc2e41d" translate="yes" xml:space="preserve">
          <source>Plug.Conn.NotSentError</source>
          <target state="translated">Plug.Conn.NotSentError</target>
        </trans-unit>
        <trans-unit id="5e701691f17997fa509597535b633f539e6f6c4c" translate="yes" xml:space="preserve">
          <source>Plug.Conn.NotSentError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.NotSentError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e24ef7997c87cf0d8ce006d67ec035cbd96bc7df" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Query</source>
          <target state="translated">Plug.Conn.Query</target>
        </trans-unit>
        <trans-unit id="6dd8c22a9766d4d4e60af03e7e9bbabc455f0d8b" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Status</source>
          <target state="translated">Plug.Conn.Status</target>
        </trans-unit>
        <trans-unit id="5f2737d23cbee85ece48e300b66a00d869c9c59d" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Unfetched</source>
          <target state="translated">Plug.Conn.Unfetched</target>
        </trans-unit>
        <trans-unit id="f227231e634d98406467ac2e60b3a784848a0bf9" translate="yes" xml:space="preserve">
          <source>Plug.Conn.Utils</source>
          <target state="translated">Plug.Conn.Utils</target>
        </trans-unit>
        <trans-unit id="75d6bfa4228ea10ed3fae55b45519d715f536789" translate="yes" xml:space="preserve">
          <source>Plug.Conn.WrapperError</source>
          <target state="translated">Plug.Conn.WrapperError</target>
        </trans-unit>
        <trans-unit id="916f1c91b3d6db7431dd35c4802b03978cc32827" translate="yes" xml:space="preserve">
          <source>Plug.Conn.WrapperError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Conn.WrapperError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="90e881fa81ef7e1a364897f8bfee5f69522eb5fe" translate="yes" xml:space="preserve">
          <source>Plug.Crypto.KeyGenerator</source>
          <target state="translated">Plug.Crypto.KeyGenerator</target>
        </trans-unit>
        <trans-unit id="9ebe5fdf96d10885c53378f87f6d73689c67c247" translate="yes" xml:space="preserve">
          <source>Plug.Debugger</source>
          <target state="translated">Plug.Debugger</target>
        </trans-unit>
        <trans-unit id="809456b3866bd5506e874b687e4cdf3fd432d440" translate="yes" xml:space="preserve">
          <source>Plug.ErrorHandler</source>
          <target state="translated">Plug.ErrorHandler</target>
        </trans-unit>
        <trans-unit id="ff4257149d3299183c285078a2489a915774bbea" translate="yes" xml:space="preserve">
          <source>Plug.Exception</source>
          <target state="translated">Plug.Exception</target>
        </trans-unit>
        <trans-unit id="0504b1ef3bee2522df1fdfeecf35f72aecebc259" translate="yes" xml:space="preserve">
          <source>Plug.Exception &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">플러그 예외 &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2998037144bd1f54ad2f8e422b89e12a3d119d7a" translate="yes" xml:space="preserve">
          <source>Plug.Exception.status (1)</source>
          <target state="translated">플러그 예외 상태 (1)</target>
        </trans-unit>
        <trans-unit id="8af4ca46e5e70e0e9795051b8460287f7eaa2f8d" translate="yes" xml:space="preserve">
          <source>Plug.Exception.t (0)</source>
          <target state="translated">Plug.Exception.t (0)</target>
        </trans-unit>
        <trans-unit id="4a7d66791479787bc515114a800979b54a9b7757" translate="yes" xml:space="preserve">
          <source>Plug.HTML</source>
          <target state="translated">Plug.HTML</target>
        </trans-unit>
        <trans-unit id="3a840b7b9c77d348c2b126f57c2069444d3d1fdc" translate="yes" xml:space="preserve">
          <source>Plug.Head</source>
          <target state="translated">Plug.Head</target>
        </trans-unit>
        <trans-unit id="86a6b3d2f49a74c2002106a79162c6c46bf3a7c2" translate="yes" xml:space="preserve">
          <source>Plug.Logger</source>
          <target state="translated">Plug.Logger</target>
        </trans-unit>
        <trans-unit id="3da20dbeffc9bfc2bb63ffc107d51974f1874ddd" translate="yes" xml:space="preserve">
          <source>Plug.MethodOverride</source>
          <target state="translated">Plug.MethodOverride</target>
        </trans-unit>
        <trans-unit id="52bbcba025427fab650fee21f34d2921068f4144" translate="yes" xml:space="preserve">
          <source>Plug.Parsers &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 파서 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7360a1de6131ce36267daffb90d2574809710fb6" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.BadEncodingError</source>
          <target state="translated">Plug.Parsers.BadEncodingError</target>
        </trans-unit>
        <trans-unit id="f6d5837a2fbd93e1b540a45b655fa943932d1c08" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.BadEncodingError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.BadEncodingError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="855ca5aa37685f9246e0a3d8228826b72b78092e" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.JSON</source>
          <target state="translated">Plug.Parsers.JSON</target>
        </trans-unit>
        <trans-unit id="024a759252607a0ac59a432047a2bc74c33af7e9" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.MULTIPART</source>
          <target state="translated">Plug.Parsers.MULTIPART</target>
        </trans-unit>
        <trans-unit id="76a4d5762584a4b7f59159357c1bd7895dd5e8ce" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.ParseError</source>
          <target state="translated">Plug.Parsers.ParseError</target>
        </trans-unit>
        <trans-unit id="88cae26afd90e4bc5abf7fe34771f3ba5368c901" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.ParseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="65505ee433f3dbdb794c60edfd34a579c212a0d0" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.RequestTooLargeError</source>
          <target state="translated">Plug.Parsers.RequestTooLargeError</target>
        </trans-unit>
        <trans-unit id="361328f684541740489e610c866019abc75dded5" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.RequestTooLargeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.RequestTooLargeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="957831edf9da6029c93cb308770bb29228a089d6" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.URLENCODED</source>
          <target state="translated">Plug.Parsers.URLENCODED</target>
        </trans-unit>
        <trans-unit id="143b275d9257366e6d82561d78bd2421da66cb30" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.UnsupportedMediaTypeError</source>
          <target state="translated">Plug.Parsers.UnsupportedMediaTypeError</target>
        </trans-unit>
        <trans-unit id="79420b94d6b1a53eb948ca3af6e128d4cc7f44ca" translate="yes" xml:space="preserve">
          <source>Plug.Parsers.UnsupportedMediaTypeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Parsers.UnsupportedMediaTypeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="06bf7d7b55e12b27fb50cc99fe83ea30b9346e15" translate="yes" xml:space="preserve">
          <source>Plug.RequestId</source>
          <target state="translated">Plug.RequestId</target>
        </trans-unit>
        <trans-unit id="49161d756392f8ec1392dde7491564dc0215c712" translate="yes" xml:space="preserve">
          <source>Plug.Router</source>
          <target state="translated">Plug.Router</target>
        </trans-unit>
        <trans-unit id="ebd8ca539d2898fa6f492bc221cd9e791fca1e81" translate="yes" xml:space="preserve">
          <source>Plug.Router.InvalidSpecError</source>
          <target state="translated">Plug.Router.InvalidSpecError</target>
        </trans-unit>
        <trans-unit id="7cdb4b390957aa3b87fe6177cef5151bc4977d77" translate="yes" xml:space="preserve">
          <source>Plug.Router.InvalidSpecError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Router.InvalidSpecError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e7ce22e4d4207804b1374c8cb497427d07f3c012" translate="yes" xml:space="preserve">
          <source>Plug.SSL</source>
          <target state="translated">Plug.SSL</target>
        </trans-unit>
        <trans-unit id="f9642818ecfbe9b8db3eab15f59172c99b7aece4" translate="yes" xml:space="preserve">
          <source>Plug.Session</source>
          <target state="translated">Plug.Session</target>
        </trans-unit>
        <trans-unit id="1bfe72ba72028781f0595aaf9082533f79601722" translate="yes" xml:space="preserve">
          <source>Plug.Session.COOKIE</source>
          <target state="translated">Plug.Session.COOKIE</target>
        </trans-unit>
        <trans-unit id="24e9adee8c5223a3e2b35470c0f1dee004a2be00" translate="yes" xml:space="preserve">
          <source>Plug.Session.ETS</source>
          <target state="translated">Plug.Session.ETS</target>
        </trans-unit>
        <trans-unit id="8c191a111bd1ca8943c3102027f68110273163d4" translate="yes" xml:space="preserve">
          <source>Plug.Session.Store &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">플러그 세션 세션 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e63cee1c407f2c1f3c562da1c78a36b81b4bcfbf" translate="yes" xml:space="preserve">
          <source>Plug.Static</source>
          <target state="translated">Plug.Static</target>
        </trans-unit>
        <trans-unit id="fe95991608b633b478b7f474acc041afec3bea64" translate="yes" xml:space="preserve">
          <source>Plug.Static will be unable to serve assets if you build releases or if you change the current directory. Instead do:</source>
          <target state="translated">릴리스를 빌드하거나 현재 디렉토리를 변경하면 Plug.Static이 자산을 제공 할 수 없습니다. 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d72df0cbd6329f7e5d3edfcbfc7744bbaaa0351c" translate="yes" xml:space="preserve">
          <source>Plug.Static.InvalidPathError</source>
          <target state="translated">Plug.Static.InvalidPathError</target>
        </trans-unit>
        <trans-unit id="33732960284e22902e1286c6ddbb3f27a366dee0" translate="yes" xml:space="preserve">
          <source>Plug.Static.InvalidPathError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.Static.InvalidPathError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8a95623d184b4a606beb18e0ffe9ceab5b1dfc41" translate="yes" xml:space="preserve">
          <source>Plug.Test</source>
          <target state="translated">Plug.Test</target>
        </trans-unit>
        <trans-unit id="f0f104d7c8ff4f8bf0d638ab38f4177ce4dba122" translate="yes" xml:space="preserve">
          <source>Plug.TimeoutError</source>
          <target state="translated">Plug.TimeoutError</target>
        </trans-unit>
        <trans-unit id="d001ebce35384c272e36b2fcd0073ce401d87d19" translate="yes" xml:space="preserve">
          <source>Plug.TimeoutError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.TimeoutError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bebfb71e1da02cb5ce594139b71e5dd8e2145faf" translate="yes" xml:space="preserve">
          <source>Plug.Upload</source>
          <target state="translated">Plug.Upload</target>
        </trans-unit>
        <trans-unit id="35a35df1cacf3bebd2793aae156668ed4d1d84e6" translate="yes" xml:space="preserve">
          <source>Plug.UploadError</source>
          <target state="translated">Plug.UploadError</target>
        </trans-unit>
        <trans-unit id="43131ab6badbba7b97b5b90ab7649a8ea2a80322" translate="yes" xml:space="preserve">
          <source>Plug.UploadError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Plug.UploadError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3043ffa369068e896903e8a4971fde40dabfdd42" translate="yes" xml:space="preserve">
          <source>Polymorphic associations</source>
          <target state="translated">다형성 연관</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="8f22e24a0f14141c0a07471831a995b431c4d4a9" translate="yes" xml:space="preserve">
          <source>Positional bindings</source>
          <target state="translated">위치 바인딩</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="ca26cf04dc10c40abe8bd5b4d429603695f19c64" translate="yes" xml:space="preserve">
          <source>Preload also allows functions to be given. In such cases, the function receives the IDs of the parent association and it must return the associated data. Ecto then will map this data and sort it by the relationship key:</source>
          <target state="translated">예압은 또한 기능을 부여 할 수 있습니다. 이러한 경우, 함수는 상위 연관의 ID를 수신하며 연관된 데이터를 리턴해야합니다. 그런 다음 Ecto는이 데이터를 매핑하고 관계 키를 기준으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="ff7140ac657faf56b763438de02e7461c0a93db8" translate="yes" xml:space="preserve">
          <source>Preload also allows queries to be given, allowing you to filter or customize how the preloads are fetched:</source>
          <target state="translated">또한 사전로드를 통해 쿼리를 제공하여 사전로드를 가져 오는 방법을 필터링하거나 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9110f27182acc231f413041578614fd22b8eb1f" translate="yes" xml:space="preserve">
          <source>Preload functions</source>
          <target state="translated">예압 기능</target>
        </trans-unit>
        <trans-unit id="2d581adaa509265aa0b4253352fab86b0836da76" translate="yes" xml:space="preserve">
          <source>Preload queries</source>
          <target state="translated">사전로드 쿼리</target>
        </trans-unit>
        <trans-unit id="304623a6b5434594bc695a82d3d75f58820f512f" translate="yes" xml:space="preserve">
          <source>Preloading can also be done with a pre-defined join value:</source>
          <target state="translated">사전 정의 된 결합 값으로 사전로드를 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="449fcc848afdf91c2d970b121f64f50471d49049" translate="yes" xml:space="preserve">
          <source>Preloads all associations on the given struct or structs</source>
          <target state="translated">주어진 구조체 또는 구조체에 대한 모든 연결을 미리로드합니다</target>
        </trans-unit>
        <trans-unit id="8ff284b72518fce2743861685658f4b586be1af9" translate="yes" xml:space="preserve">
          <source>Preloads all associations on the given struct or structs.</source>
          <target state="translated">주어진 구조체 또는 구조체에 대한 모든 연결을 미리로드합니다.</target>
        </trans-unit>
        <trans-unit id="ed8bc6be23a4152960a0dd5f09b747712848aa2c" translate="yes" xml:space="preserve">
          <source>Preloads the associations into the result set</source>
          <target state="translated">결과 집합에 연결을 미리로드</target>
        </trans-unit>
        <trans-unit id="6e1fba265bbc07b1018f3daff40a29e8807cf715" translate="yes" xml:space="preserve">
          <source>Preloads the associations into the result set.</source>
          <target state="translated">연결을 결과 집합에 미리로드합니다.</target>
        </trans-unit>
        <trans-unit id="e712bebf7898f5514cba7310bf2e423398e6a8f4" translate="yes" xml:space="preserve">
          <source>Prepends the list of headers to the connection response headers</source>
          <target state="translated">헤더 목록을 연결 응답 헤더 앞에 추가</target>
        </trans-unit>
        <trans-unit id="c8238eff0c74999befc9cd4bffa90cdc7f34ffd6" translate="yes" xml:space="preserve">
          <source>Prepends the list of headers to the connection response headers.</source>
          <target state="translated">헤더 목록을 연결 응답 헤더 앞에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1eaa5c07101c4c96d10c35b7c91b844b4826eb41" translate="yes" xml:space="preserve">
          <source>Prepends the second multi to the first one</source>
          <target state="translated">두 번째 멀티를 첫 번째 멀티 앞에 추가</target>
        </trans-unit>
        <trans-unit id="5f56bddd7cd54b857167ed79f490fa02ef38fcf8" translate="yes" xml:space="preserve">
          <source>Prepends the second multi to the first one.</source>
          <target state="translated">두 번째 멀티를 첫 번째 멀티 앞에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1bf230814fff81dd8a0b32cf0b2e76e4135a707d" translate="yes" xml:space="preserve">
          <source>Presence datastructure</source>
          <target state="translated">존재 데이터 구조</target>
        </trans-unit>
        <trans-unit id="5d08b2e5f9de0676df3a449fc17978467cbe92c4" translate="yes" xml:space="preserve">
          <source>Presence metadata should be minimized and used to store small, ephemeral state, such as a user&amp;rsquo;s &amp;ldquo;online&amp;rdquo; or &amp;ldquo;away&amp;rdquo; status. More detailed information, such as user details that need to be fetched from the database, can be achieved by overriding the &lt;code&gt;fetch/2&lt;/code&gt; function. The &lt;code&gt;fetch/2&lt;/code&gt; callback is triggered when using &lt;code&gt;list/1&lt;/code&gt; and serves as a mechanism to fetch presence information a single time, before broadcasting the information to all channel subscribers. This prevents N query problems and gives you a single place to group isolated data fetching to extend presence metadata. The function must return a map of data matching the outlined Presence datastructure, including the &lt;code&gt;:metas&lt;/code&gt; key, but can extend the map of information to include any additional information. For example:</source>
          <target state="translated">현재 상태 메타 데이터는 최소화되어야하며 사용자의 &quot;온라인&quot;또는 &quot;자리 비움&quot;상태와 같은 작은 임시 상태를 저장하는 데 사용해야합니다. 데이터베이스에서 페치해야하는 사용자 세부 사항과 같은보다 자세한 정보는 &lt;code&gt;fetch/2&lt;/code&gt; 기능 을 대체하여 얻을 수 있습니다 . &lt;code&gt;fetch/2&lt;/code&gt; 사용시 콜백 트리거 &lt;code&gt;list/1&lt;/code&gt; 모든 채널 가입자에게 정보를 방송하기 전에, 현재 상태 정보는 단일 시간 인출하는기구로서 기능한다. 이를 통해 N 쿼리 문제를 방지하고 격리 된 데이터 가져 오기를 그룹화하여 현재 상태 메타 데이터를 확장 할 수 있습니다. 이 함수는 &lt;code&gt;:metas&lt;/code&gt; 를 포함하여 설명 된 현재 상태 데이터 구조와 일치하는 데이터 맵을 리턴해야합니다 .추가 정보를 포함하도록 정보 맵을 확장 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e517ee5fd3782b5ee136558aa5e08fab77ad1688" translate="yes" xml:space="preserve">
          <source>Primary keys</source>
          <target state="translated">기본 키</target>
        </trans-unit>
        <trans-unit id="2588c16289f8812a6ecec3a161121af067dfc0c2" translate="yes" xml:space="preserve">
          <source>Primitive Ecto types (handled by Ecto)</source>
          <target state="translated">기본 Ecto 유형 (Ecto에서 처리)</target>
        </trans-unit>
        <trans-unit id="0093cbed38843f68b6f366917fe909fd8402e40f" translate="yes" xml:space="preserve">
          <source>Primitive Ecto types (handled by Ecto).</source>
          <target state="translated">원시 Ecto 유형 (Ecto에서 처리).</target>
        </trans-unit>
        <trans-unit id="c7969f1f2306323d21ee870b267eca96e3a3e899" translate="yes" xml:space="preserve">
          <source>Primitive types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="fe98f070edfbab910ee3be5d3d76bad2f467ce4f" translate="yes" xml:space="preserve">
          <source>Prints Ecto tasks and their information.</source>
          <target state="translated">Ecto 작업 및 해당 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4a298469066076ddb91007494cd88022b0f4cf3e" translate="yes" xml:space="preserve">
          <source>Prints all routes for the default or a given router.</source>
          <target state="translated">기본 라우터 또는 지정된 라우터의 모든 경로를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="82aec652f1c3e836ec44cf83ec9501b88e6be4c4" translate="yes" xml:space="preserve">
          <source>Private fields</source>
          <target state="translated">개인 분야</target>
        </trans-unit>
        <trans-unit id="00d7bff394707ff8ca7c92bbbd9cdf113ae8278b" translate="yes" xml:space="preserve">
          <source>Protocol Versioning</source>
          <target state="translated">프로토콜 버전 관리</target>
        </trans-unit>
        <trans-unit id="2a6e3082f7bd2a56b001fbb1624e361e5599002d" translate="yes" xml:space="preserve">
          <source>Protocols</source>
          <target state="translated">Protocols</target>
        </trans-unit>
        <trans-unit id="998f97af64a3938f5709a872c30f27a4b5e7a966" translate="yes" xml:space="preserve">
          <source>Provides Presence tracking to processes and channels.</source>
          <target state="translated">프로세스 및 채널에 현재 상태 추적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d34511baecbee2b647331ac6eec3703d31533067" translate="yes" xml:space="preserve">
          <source>Provides a function to run before emitting changes to the repository</source>
          <target state="translated">리포지토리에 변경 사항을 보내기 전에 실행할 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="51994184213ec7cfcec62e33c13c2bc71ab7f50d" translate="yes" xml:space="preserve">
          <source>Provides a function to run before emitting changes to the repository.</source>
          <target state="translated">저장소에 변경 사항을 생성하기 전에 실행할 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9b979a1bb30192f6df28ff86089f8880a0ed2d5f" translate="yes" xml:space="preserve">
          <source>Provides a keyword list of default configuration for socket transports</source>
          <target state="translated">소켓 전송을위한 기본 구성의 키워드 목록을 제공합니다</target>
        </trans-unit>
        <trans-unit id="f1c971eb806de2d6bb68ff53036312dadf3d1f30" translate="yes" xml:space="preserve">
          <source>Provides a keyword list of default configuration for socket transports.</source>
          <target state="translated">소켓 전송에 대한 기본 구성 키워드 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d55f86792e5cf44aad6965f41554bd9b735d6b9" translate="yes" xml:space="preserve">
          <source>Provides a server child specification to be started under the endpoint</source>
          <target state="translated">엔드 포인트에서 시작될 서버 하위 스펙을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8682306f1ef165bae5c2cd28457fc3f9eb9169dd" translate="yes" xml:space="preserve">
          <source>Provides a server child specification to be started under the endpoint.</source>
          <target state="translated">엔드 포인트에서 시작될 서버 하위 스펙을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ba8a0eb4a37b52358e3cb2fe1dbb14623bdab7c7" translate="yes" xml:space="preserve">
          <source>Provides an ORSWOT CRDT.</source>
          <target state="translated">ORSWOT CRDT를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="73232c78dcef985cdff9857c0fd2512dd7d0853b" translate="yes" xml:space="preserve">
          <source>Provides distributed Presence tracking to processes.</source>
          <target state="translated">프로세스에 분산 된 프레즌스 추적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="44be9870ae1bd5112e9210a7645bdf4a6faceafb" translate="yes" xml:space="preserve">
          <source>Provides support for row-level pessimistic locking using &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; or other, database-specific, locking clauses. &lt;code&gt;expr&lt;/code&gt; can be any expression but has to evaluate to a boolean value or to a string and it can&amp;rsquo;t include any fields.</source>
          <target state="translated">&lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 또는 기타 데이터베이스 별 잠금 절을 사용하여 행 수준 비관적 잠금을 지원합니다 . &lt;code&gt;expr&lt;/code&gt; 은 모든 표현식이 될 수 있지만 부울 값 또는 문자열로 평가되어야하며 필드를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5eb2c4db6daf7a18463ffbaa31d480a7a2ee937" translate="yes" xml:space="preserve">
          <source>Provides the Query DSL.</source>
          <target state="translated">쿼리 DSL을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5cc490a5d56473eaf126a919ed9e5f3d868ce250" translate="yes" xml:space="preserve">
          <source>Providing secure defaults</source>
          <target state="translated">안전한 기본값 제공</target>
        </trans-unit>
        <trans-unit id="1276f3b4f4dd53c6f5d22c75ea5ee23f93c6dfb6" translate="yes" xml:space="preserve">
          <source>Proxy type to the adapter meta</source>
          <target state="translated">어댑터 메타에 대한 프록시 유형</target>
        </trans-unit>
        <trans-unit id="5a34389b39c3b88f292ed74ab2d16c7cacfb3495" translate="yes" xml:space="preserve">
          <source>PubSub adapters run inside their own supervision tree. If you are interested in providing your own adapter, let&amp;rsquo;s call it &lt;code&gt;Phoenix.PubSub.MyQueue&lt;/code&gt;, the first step is to provide a supervisor module that receives the server name and a bunch of options on &lt;code&gt;start_link/2&lt;/code&gt;:</source>
          <target state="translated">PubSub 어댑터는 자체 감독 트리 내에서 실행됩니다. 자신의 어댑터를 제공하고 싶다면 &lt;code&gt;Phoenix.PubSub.MyQueue&lt;/code&gt; 라고 부르십시오 . 첫 번째 단계는 &lt;code&gt;start_link/2&lt;/code&gt; 에서 서버 이름과 여러 옵션을받는 수퍼바이저 모듈을 제공하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="5d2a845d92daf366b87a96034042e6b435a1c537" translate="yes" xml:space="preserve">
          <source>PubSub implementation for handling local-node process groups.</source>
          <target state="translated">로컬 노드 프로세스 그룹을 처리하기위한 PubSub 구현</target>
        </trans-unit>
        <trans-unit id="99cf009c36ce68265bfb1764fc3797590279cfc3" translate="yes" xml:space="preserve">
          <source>Pubsub adapters are often configured in your endpoint:</source>
          <target state="translated">Pubsub 어댑터는 종종 엔드 포인트에서 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fa8f337c4243b77ae52e53077d7b3e39bafed62" translate="yes" xml:space="preserve">
          <source>Push a resource to the client</source>
          <target state="translated">클라이언트에게 리소스를 푸시</target>
        </trans-unit>
        <trans-unit id="8dae6f573e91623ac373ec20142b10e46bff8ca9" translate="yes" xml:space="preserve">
          <source>Push a resource to the client.</source>
          <target state="translated">클라이언트에게 리소스를 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="fe640326b9ef3ba06df8495f92545c8251203dc4" translate="yes" xml:space="preserve">
          <source>Pushes a message into the channel</source>
          <target state="translated">메시지를 채널로 푸시</target>
        </trans-unit>
        <trans-unit id="ef300f5e659260d3eb4a7737cf01f710d20c2491" translate="yes" xml:space="preserve">
          <source>Pushes a message into the channel.</source>
          <target state="translated">메시지를 채널로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="2aafdd29732bf6232c51fa8dff6c97cf039ad580" translate="yes" xml:space="preserve">
          <source>Pushes a resource to the client</source>
          <target state="translated">클라이언트에게 리소스를 푸시</target>
        </trans-unit>
        <trans-unit id="343e743a2165ed61ae48116989c279025c3d5d91" translate="yes" xml:space="preserve">
          <source>Pushes a resource to the client but raises if the adapter does not support server push</source>
          <target state="translated">클라이언트에 자원을 푸시하지만 어댑터가 서버 푸시를 지원하지 않으면 발생</target>
        </trans-unit>
        <trans-unit id="20fdcb6dfd8955f2c899e01fce1ff1d46da03169" translate="yes" xml:space="preserve">
          <source>Pushes a resource to the client but raises if the adapter does not support server push.</source>
          <target state="translated">클라이언트에 자원을 푸시하지만 어댑터가 서버 푸시를 지원하지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0e508bf2a11488e99e666f2bfe6e99c4276f338" translate="yes" xml:space="preserve">
          <source>Pushes a resource to the client.</source>
          <target state="translated">클라이언트에 리소스를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="3a67f3d149b84ceeec029ab012171057049c841e" translate="yes" xml:space="preserve">
          <source>Put headers that improve browser security</source>
          <target state="translated">브라우저 보안을 향상시키는 헤더 넣기</target>
        </trans-unit>
        <trans-unit id="f4a913b2f483af15d2f9e83b6901a9de1f588a0d" translate="yes" xml:space="preserve">
          <source>Put headers that improve browser security.</source>
          <target state="translated">브라우저 보안을 향상시키는 헤더를 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="8ee443cfc894074df3d4ec386ad8ca2b64de4375" translate="yes" xml:space="preserve">
          <source>Puts a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 으로 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="00a4f82a5c5b18560d1aacba1550b6c83f1fa5b3" translate="yes" xml:space="preserve">
          <source>Puts a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 로 변경 합니다 .</target>
        </trans-unit>
        <trans-unit id="741fd025d65f46f242fb5bd6a467fa59b5895077" translate="yes" xml:space="preserve">
          <source>Puts a request cookie</source>
          <target state="translated">요청 쿠키를 넣습니다</target>
        </trans-unit>
        <trans-unit id="7be5afb720006adb8876e294e39a4168d5efa70f" translate="yes" xml:space="preserve">
          <source>Puts a request cookie.</source>
          <target state="translated">요청 쿠키를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="4a6873e4434775312bde6568b519ae9caa4da55f" translate="yes" xml:space="preserve">
          <source>Puts a response cookie</source>
          <target state="translated">응답 쿠키를 넣습니다</target>
        </trans-unit>
        <trans-unit id="b6834445ae0b44b5bf121eaaab9f7de7f803ecb9" translate="yes" xml:space="preserve">
          <source>Puts a response cookie in the connection</source>
          <target state="translated">연결에 응답 쿠키를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="eae2e2953d992e259527f70922816fdaa79edb2b" translate="yes" xml:space="preserve">
          <source>Puts a response cookie in the connection.</source>
          <target state="translated">연결에 응답 쿠키를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7c14521e098d7e0db356324b05045f4d7ed52bdb" translate="yes" xml:space="preserve">
          <source>Puts a response cookie.</source>
          <target state="translated">응답 쿠키를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="815a50a2068711e3951e905471b283fd46344a7d" translate="yes" xml:space="preserve">
          <source>Puts the format in the connection</source>
          <target state="translated">연결에 형식을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7d2d574ef257cfc83db02346e4caf116a2146dcc" translate="yes" xml:space="preserve">
          <source>Puts the format in the connection.</source>
          <target state="translated">연결에 형식을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="fc09e81b5f5ad87cea799616c6d979c26d068caa" translate="yes" xml:space="preserve">
          <source>Puts the given association entry or entries as a change in the changeset</source>
          <target state="translated">주어진 연관 항목을 변경 세트의 변경 사항으로 넣습니다.</target>
        </trans-unit>
        <trans-unit id="54cd5c18dcae6efd2695b356d96271d86bdacd7a" translate="yes" xml:space="preserve">
          <source>Puts the given association entry or entries as a change in the changeset.</source>
          <target state="translated">지정된 연관 항목을 변경 세트의 변경 사항으로 둡니다.</target>
        </trans-unit>
        <trans-unit id="3d482cdc0094a992a33fd5968b2ef4bd5d6e9cf5" translate="yes" xml:space="preserve">
          <source>Puts the given embed entry or entries as a change in the changeset</source>
          <target state="translated">주어진 삽입 항목을 변경 세트의 변경 사항으로 넣습니다.</target>
        </trans-unit>
        <trans-unit id="d3fa1dbd91937b35d7af93ba24edaf83b40c842f" translate="yes" xml:space="preserve">
          <source>Puts the given embed entry or entries as a change in the changeset.</source>
          <target state="translated">지정된 포함 항목을 변경 세트의 변경 사항으로 넣습니다.</target>
        </trans-unit>
        <trans-unit id="8019e9293126a2bd7055b604b3b1f0d984ed00ee" translate="yes" xml:space="preserve">
          <source>Puts the given value under key in the flash storage</source>
          <target state="translated">플래시 스토리지의 키 아래에 주어진 값을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="c2c33be180ad022ed8c9916ce7573ec126324a75" translate="yes" xml:space="preserve">
          <source>Puts the given value under key in the flash storage.</source>
          <target state="translated">플래시 스토리지에서 지정된 값을 키 아래에 둡니다.</target>
        </trans-unit>
        <trans-unit id="37c4f691ad78c67a6b79da1230c90f39bb3ee3ef" translate="yes" xml:space="preserve">
          <source>Puts the http protocol</source>
          <target state="translated">http 프로토콜을 넣습니다</target>
        </trans-unit>
        <trans-unit id="804d6529e64cb57585b1483683755688784089b3" translate="yes" xml:space="preserve">
          <source>Puts the http protocol.</source>
          <target state="translated">http 프로토콜을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="55b710537ff243eb1a32ec97e8a8ef433da7a8e8" translate="yes" xml:space="preserve">
          <source>Puts the peer data</source>
          <target state="translated">피어 데이터를 넣습니다</target>
        </trans-unit>
        <trans-unit id="03bbdbff15d183654a7ba17044452221ba7178e5" translate="yes" xml:space="preserve">
          <source>Puts the peer data.</source>
          <target state="translated">피어 데이터를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="9dcf19c9d246dc16927f6649753724b24e760346" translate="yes" xml:space="preserve">
          <source>Puts the specified &lt;code&gt;value&lt;/code&gt; in the session for the given &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; 대해 지정된 &lt;code&gt;value&lt;/code&gt; 을 세션에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="6d6ac7ef4b3b44a8c56a6e0c8f2e56c460c8e52e" translate="yes" xml:space="preserve">
          <source>Puts the specified &lt;code&gt;value&lt;/code&gt; in the session for the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;key&lt;/code&gt; 대해 지정된 &lt;code&gt;value&lt;/code&gt; 을 세션에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="62d10c2aa8bacdd16162d644d77b4ee04bb0e190" translate="yes" xml:space="preserve">
          <source>Queries are defined and extended with the &lt;code&gt;from&lt;/code&gt; macro. The supported keywords are:</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 매크로를 사용하여 쿼리를 정의하고 확장합니다 . 지원되는 키워드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05c5af64d3e911887b9ce2bd58137225eabf7ce3" translate="yes" xml:space="preserve">
          <source>Queries are used to retrieve and manipulate data from a repository (see &lt;a href=&quot;ecto.repo&quot;&gt;&lt;code&gt;Ecto.Repo&lt;/code&gt;&lt;/a&gt;). Ecto queries come in two flavors: keyword-based and macro-based. Most examples will use the keyword-based syntax, the macro one will be explored in later sections.</source>
          <target state="translated">쿼리는 리포지토리에서 데이터를 검색하고 조작하는 데 사용됩니다 ( &lt;a href=&quot;ecto.repo&quot;&gt; &lt;code&gt;Ecto.Repo&lt;/code&gt; &lt;/a&gt; 참조 ). Ecto 쿼리는 키워드 기반과 매크로 기반의 두 가지 형태로 제공됩니다. 대부분의 예제는 키워드 기반 구문을 사용하며 매크로는 이후 섹션에서 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="de8a1e1690d8b96ebb6d223c027cb63261ce097c" translate="yes" xml:space="preserve">
          <source>Query Prefix</source>
          <target state="translated">쿼리 접두사</target>
        </trans-unit>
        <trans-unit id="5a0c44c7fb8e785d997aa2361b47b3f7d57e2ac5" translate="yes" xml:space="preserve">
          <source>Query expressions</source>
          <target state="translated">쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="e2b202096304737747a8e9856e1cf9ad13fa032f" translate="yes" xml:space="preserve">
          <source>Raised at compilation time when the query cannot be compiled.</source>
          <target state="translated">쿼리를 컴파일 할 수없는 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4a893f6e9499b7a91b676a282a54c00522815c56" translate="yes" xml:space="preserve">
          <source>Raised at runtime when a subquery is invalid.</source>
          <target state="translated">하위 쿼리가 유효하지 않은 런타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0a75a685071ded5093063f2c839160c503f347d" translate="yes" xml:space="preserve">
          <source>Raised at runtime when a value cannot be cast.</source>
          <target state="translated">값을 캐스트 할 수없는 런타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="039805dc5f4fed9b5afea803e51808e617e43ca3" translate="yes" xml:space="preserve">
          <source>Raised at runtime when an operation that requires a primary key is invoked with a schema missing value for its primary key</source>
          <target state="translated">기본 키가 필요한 오퍼레이션이 기본 키에 대한 스키마 결 측값으로 호출되면 런타임시 발생</target>
        </trans-unit>
        <trans-unit id="afa673fd6977e244af2ea9dc91a6d8a824062c2a" translate="yes" xml:space="preserve">
          <source>Raised at runtime when an operation that requires a primary key is invoked with a schema that does not define a primary key by using &lt;code&gt;@primary_key false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@primary_key false&lt;/code&gt; 를 사용하여 기본 키를 정의하지 않는 스키마로 기본 키가 필요한 작업을 호출하면 런타임에 발생합니다. false</target>
        </trans-unit>
        <trans-unit id="bcbb0dc762ca0143ba465c1a0d2d32138bda79be" translate="yes" xml:space="preserve">
          <source>Raised at runtime when the query is invalid.</source>
          <target state="translated">쿼리가 유효하지 않은 런타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="118f69c0714f7c01f9e9cdb531cfaa10b0d03ee9" translate="yes" xml:space="preserve">
          <source>Raised when a changeset can&amp;rsquo;t cast a value.</source>
          <target state="translated">변경 세트가 값을 전송할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a11dc0fa5c2256817b23669b7156b10e560879e" translate="yes" xml:space="preserve">
          <source>Raised when a key is expected to be present in the request parameters, but is not.</source>
          <target state="translated">요청 매개 변수에 키가있을 것으로 예상되지만 그렇지 않은 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="42cab9ec6b573ff081054ff4fc6a8a2e4aaec900" translate="yes" xml:space="preserve">
          <source>Raised when one of the &lt;code&gt;accept*&lt;/code&gt; headers is not accepted by the server.</source>
          <target state="translated">&lt;code&gt;accept*&lt;/code&gt; 헤더 중 하나가 서버에서 승인되지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b97f65fe7b14617aed938b2f2242977964dc12e0" translate="yes" xml:space="preserve">
          <source>Raised when the request body contains bad encoding.</source>
          <target state="translated">요청 본문에 잘못된 인코딩이 포함되어있을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d60569db9a3f0465a27300ec7b01dce02ec93b6" translate="yes" xml:space="preserve">
          <source>Raised when the request string is malformed, for example:</source>
          <target state="translated">요청 문자열이 잘못된 경우 발생합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="3cdcabdb93d143702babf6930f6c426fb8aa2f08" translate="yes" xml:space="preserve">
          <source>Raised when the socket message is invalid.</source>
          <target state="translated">소켓 메시지가 유효하지 않을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fea87b6163109a5bc634acb0e1d816c9a91f8d08" translate="yes" xml:space="preserve">
          <source>Raised when we cannot perform an action because the changeset is invalid.</source>
          <target state="translated">변경 세트가 유효하지 않아 조치를 수행 할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="475ae2411b103f83d884dab316d4d332ad5264a5" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;../plug/1.5.1/plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; if the conn was already sent.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;../plug/1.5.1/plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; 을&lt;/a&gt; CONN가 이미 전송 된 경우.</target>
        </trans-unit>
        <trans-unit id="f6b2ab76d66ab83609669089c37b6026dde4116b" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; if the schema has no primary key field.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; 를&lt;/a&gt; 스키마가 기본 키 필드가없는 경우.</target>
        </trans-unit>
        <trans-unit id="bcc5af49f7595bafb364615a87e41ed41850519d" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;phoenix.pubsub.broadcasterror&quot;&gt;&lt;code&gt;Phoenix.PubSub.BroadcastError&lt;/code&gt;&lt;/a&gt; if broadcast fails. See &lt;a href=&quot;phoenix.pubsub#broadcast/3&quot;&gt;&lt;code&gt;Phoenix.PubSub.broadcast/3&lt;/code&gt;&lt;/a&gt; for usage details.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;phoenix.pubsub.broadcasterror&quot;&gt; &lt;code&gt;Phoenix.PubSub.BroadcastError&lt;/code&gt; 는&lt;/a&gt; 방송이 실패 할 경우. 자세한 사용법 은 &lt;a href=&quot;phoenix.pubsub#broadcast/3&quot;&gt; &lt;code&gt;Phoenix.PubSub.broadcast/3&lt;/code&gt; &lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6c339d06aca80d10b93ed2ba5e58b88415158abe" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;phoenix.socket.invalidmessageerror&quot;&gt;&lt;code&gt;Phoenix.Socket.InvalidMessageError&lt;/code&gt;&lt;/a&gt; if not valid.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;phoenix.socket.invalidmessageerror&quot;&gt; &lt;code&gt;Phoenix.Socket.InvalidMessageError&lt;/code&gt; 는&lt;/a&gt; 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="4b8b11d47003ec5caaaf54545edd2877c3adf06e" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; if the connection has already been &lt;code&gt;:sent&lt;/code&gt; or &lt;code&gt;:chunked&lt;/code&gt;.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; 를&lt;/a&gt; 연결이 이미되어있는 경우 &lt;code&gt;:sent&lt;/code&gt; 나 &lt;code&gt;:chunked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cfe7b7afc826f1392f773e233d0cdd1378710a5" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt; if the header value contains control feed (&lt;code&gt;\r&lt;/code&gt;) or newline (&lt;code&gt;\n&lt;/code&gt;) characters.</source>
          <target state="translated">제기 &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt; 헤더 값은 제어 피드 (포함 된 경우 &lt;code&gt;\r&lt;/code&gt; ) 또는 개행 ( &lt;code&gt;\n&lt;/code&gt; ) 문자.</target>
        </trans-unit>
        <trans-unit id="bee73cc34282fce055899543de5c4645a7a37220" translate="yes" xml:space="preserve">
          <source>Raises if more than one entry.</source>
          <target state="translated">둘 이상의 항목이 있으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2982a9548290320e963ec17174cbd3754d9d580" translate="yes" xml:space="preserve">
          <source>Raises if the response does not match the redirect status code (defaults to 302).</source>
          <target state="translated">응답이 경로 재 지정 상태 코드와 일치하지 않으면 발생합니다 (기본값은 302).</target>
        </trans-unit>
        <trans-unit id="76c0c35fa8f5e4f8eba486d8f7aced55594e8cd0" translate="yes" xml:space="preserve">
          <source>Raises in case of failures.</source>
          <target state="translated">실패시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54897ac5b409ee4fbad6ca98e668447e3b4b2917" translate="yes" xml:space="preserve">
          <source>Raises on umbrella application.</source>
          <target state="translated">우산 응용 프로그램에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb2f7f1f24dbf8a9dc3b54234330c0d6d566463c" translate="yes" xml:space="preserve">
          <source>Read more about instrumentation in the &amp;ldquo;Instrumentation&amp;rdquo; section.</source>
          <target state="translated">&quot;계측&quot;섹션에서 계측에 대한 자세한 내용을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="cf81a76808387c613661473f19847c76f95810b7" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;ecto.type&quot;&gt;&lt;code&gt;Ecto.Type&lt;/code&gt;&lt;/a&gt; documentation for more information on implementing your own types.</source>
          <target state="translated">자체 유형 구현에 대한 자세한 내용 은 &lt;a href=&quot;ecto.type&quot;&gt; &lt;code&gt;Ecto.Type&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1dbbabd4aa48aa268311ff06dc85e1f5fb62633c" translate="yes" xml:space="preserve">
          <source>Read the docs in &lt;a href=&quot;plug.conn#read_body/2&quot;&gt;&lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt;&lt;/a&gt; for the supported options and expected behaviour.</source>
          <target state="translated">지원되는 옵션 및 예상되는 동작 에 &lt;a href=&quot;plug.conn#read_body/2&quot;&gt; &lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt; &lt;/a&gt; 의 문서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="cf9fbfe89ff9ebd0f2ce45986970e210b156155a" translate="yes" xml:space="preserve">
          <source>Read the documentation for &lt;code&gt;phx.gen.schema&lt;/code&gt; for more information on attributes.</source>
          <target state="translated">속성에 대한 자세한 내용 은 &lt;code&gt;phx.gen.schema&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4302f670076b3c8c049c3fe4414fb76ece2b07cd" translate="yes" xml:space="preserve">
          <source>Reads the body of a multipart request</source>
          <target state="translated">멀티 파트 요청의 본문을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="26c9e691a853c0a0d01f4f0830b192105639965c" translate="yes" xml:space="preserve">
          <source>Reads the body of a multipart request.</source>
          <target state="translated">멀티 파트 요청의 본문을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="34a37224cf0ecbffc7c6c717b57d3e8ad32be014" translate="yes" xml:space="preserve">
          <source>Reads the headers of a multipart request</source>
          <target state="translated">멀티 파트 요청의 헤더를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="08cd121077af574953c117de80dcab7e4da635b4" translate="yes" xml:space="preserve">
          <source>Reads the headers of a multipart request.</source>
          <target state="translated">멀티 파트 요청의 헤더를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1279e6d0c4c4164e055e507973ca6dd7b2e2afa0" translate="yes" xml:space="preserve">
          <source>Reads the request body</source>
          <target state="translated">요청 본문을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="70e202d76afed3c97c207c8aed5eaa3b1f7107df" translate="yes" xml:space="preserve">
          <source>Reads the request body.</source>
          <target state="translated">요청 본문을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="eabf5939f2bab37b43db33a656a82689c20d3d80" translate="yes" xml:space="preserve">
          <source>Receives a keyword list where keys are names of the windows and values are a keyword list with window expressions.</source>
          <target state="translated">키가 창의 이름이고 값이 창 표현식이있는 키워드 목록 인 키워드 목록을받습니다.</target>
        </trans-unit>
        <trans-unit id="c77a8f354103b07fe0b3cd31353909c942d259b1" translate="yes" xml:space="preserve">
          <source>Receives a source that is to be joined to the query and a condition for the join. The join condition can be any expression that evaluates to a boolean value. The join is by default an inner join, the qualifier can be changed by giving the atoms: &lt;code&gt;:inner&lt;/code&gt;, &lt;code&gt;:left&lt;/code&gt;, &lt;code&gt;:right&lt;/code&gt;, &lt;code&gt;:cross&lt;/code&gt;, &lt;code&gt;:full&lt;/code&gt;, &lt;code&gt;:inner_lateral&lt;/code&gt; or &lt;code&gt;:left_lateral&lt;/code&gt;. For a keyword query the &lt;code&gt;:join&lt;/code&gt; keyword can be changed to: &lt;code&gt;:inner_join&lt;/code&gt;, &lt;code&gt;:left_join&lt;/code&gt;, &lt;code&gt;:right_join&lt;/code&gt;, &lt;code&gt;:cross_join&lt;/code&gt;, &lt;code&gt;:full_join&lt;/code&gt;, &lt;code&gt;:inner_lateral_join&lt;/code&gt; or &lt;code&gt;:left_lateral_join&lt;/code&gt;.</source>
          <target state="translated">쿼리에 조인 할 소스와 조인 조건을받습니다. 결합 조건은 부울 값으로 평가되는 모든 표현식 일 수 있습니다. 조인은 기본적으로 내부 조인이며 한정자는 원자를 제공하여 변경할 수 있습니다 : &lt;code&gt;:inner&lt;/code&gt; , &lt;code&gt;:left&lt;/code&gt; , &lt;code&gt;:right&lt;/code&gt; , &lt;code&gt;:cross&lt;/code&gt; , &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:inner_lateral&lt;/code&gt; 또는 &lt;code&gt;:left_lateral&lt;/code&gt; . 키워드 쿼리의 경우 &lt;code&gt;:join&lt;/code&gt; 키워드를 &lt;code&gt;:inner_join&lt;/code&gt; , &lt;code&gt;:left_join&lt;/code&gt; , &lt;code&gt;:right_join&lt;/code&gt; , &lt;code&gt;:cross_join&lt;/code&gt; , &lt;code&gt;:full_join&lt;/code&gt; , &lt;code&gt;:inner_lateral_join&lt;/code&gt; 또는 &lt;code&gt;:left_lateral_join&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e5a65d84cc1617c8656889419c3e1afff0f97ff" translate="yes" xml:space="preserve">
          <source>Receives an exception and returns its HTTP status code</source>
          <target state="translated">예외를 수신하고 해당 HTTP 상태 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1e0b05512f97f8ced79071f6934b97336f5bfc8e" translate="yes" xml:space="preserve">
          <source>Receives an exception and returns its HTTP status code.</source>
          <target state="translated">예외를 수신하고 해당 HTTP 상태 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8d512f74447ab57d70e943b026fec4ed4ff7e386" translate="yes" xml:space="preserve">
          <source>Receives the given field and returns its input type (:text_input, :select, etc). Returns &lt;code&gt;nil&lt;/code&gt; if the type is unknown</source>
          <target state="translated">주어진 필드를 받아서 입력 유형 (: text_input, : select 등)을 반환합니다. 형식을 알 수 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b856625e980892122be13a03d8007488d047e9b7" translate="yes" xml:space="preserve">
          <source>Receives the given field and returns its input type (:text_input, :select, etc). Returns &lt;code&gt;nil&lt;/code&gt; if the type is unknown.</source>
          <target state="translated">주어진 필드를 받아서 입력 유형 (: text_input, : select 등)을 반환합니다. 형식을 알 수 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e1bc3d58618ebe92738a6425e44a7dc192725bca" translate="yes" xml:space="preserve">
          <source>Receives the parent changeset, the current changesets and the repository action options. Must return the persisted struct (or nil) or the changeset error.</source>
          <target state="translated">부모 변경 집합, 현재 변경 집합 및 리포지토리 작업 옵션을받습니다. 지속 된 구조체 (또는 nil) 또는 변경 세트 오류를 ​​반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf377c38819dc945c101acff3a1528c7baf6998f" translate="yes" xml:space="preserve">
          <source>Receives the socket params and authenticates the connection</source>
          <target state="translated">소켓 매개 변수를 수신하고 연결을 인증합니다</target>
        </trans-unit>
        <trans-unit id="eb2301c5911b40f9913b9b6d1946674d84780896" translate="yes" xml:space="preserve">
          <source>Receives the socket params and authenticates the connection.</source>
          <target state="translated">소켓 매개 변수를 수신하고 연결을 인증합니다.</target>
        </trans-unit>
        <trans-unit id="6222bf4be21bb14034989750b2e140649fe2281b" translate="yes" xml:space="preserve">
          <source>Recycles the connection</source>
          <target state="translated">연결을 재활용</target>
        </trans-unit>
        <trans-unit id="657382112567654b7fe0e6918fc09747dad27f39" translate="yes" xml:space="preserve">
          <source>Recycles the connection.</source>
          <target state="translated">연결을 재활용합니다.</target>
        </trans-unit>
        <trans-unit id="170881344897f672ebed562b0d42c4dfc0416658" translate="yes" xml:space="preserve">
          <source>Recycling</source>
          <target state="translated">Recycling</target>
        </trans-unit>
        <trans-unit id="9838943fcaf9ab1eeab6ab7a01aebd973e7bbc80" translate="yes" xml:space="preserve">
          <source>Recycling also recycles the &amp;ldquo;accept&amp;rdquo; header.</source>
          <target state="translated">재활용은 또한 &quot;수락&quot;헤더를 재활용합니다.</target>
        </trans-unit>
        <trans-unit id="e72a653a457ec9342c852678afbf8100165e8415" translate="yes" xml:space="preserve">
          <source>Recycling receives a connection and returns a new connection, containing cookies and relevant information from the given one.</source>
          <target state="translated">재활용은 연결을 수신하고 쿠키 및 관련 정보가 포함 된 새 연결을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="f936baf01aa3ae9646dadaf9f5a4745fe2b7c907" translate="yes" xml:space="preserve">
          <source>Registers a callback to be invoked before the response is sent</source>
          <target state="translated">응답을 보내기 전에 호출 할 콜백을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="5244ec845fd9bf105d107be1519b099f79debf7a" translate="yes" xml:space="preserve">
          <source>Registers a callback to be invoked before the response is sent.</source>
          <target state="translated">응답을 보내기 전에 호출 할 콜백을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="08ce0fff58d051cd9c134a71c658ce212cc6660d" translate="yes" xml:space="preserve">
          <source>Registers the plug to call as a fallback to the controller action</source>
          <target state="translated">컨트롤러 동작에 대한 폴백으로 호출 할 플러그를 등록합니다</target>
        </trans-unit>
        <trans-unit id="40b67813f6d17a852ee36adfafd9be57608ee05e" translate="yes" xml:space="preserve">
          <source>Registers the plug to call as a fallback to the controller action.</source>
          <target state="translated">컨트롤러 동작에 대한 폴백으로 호출 할 플러그를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="9636957d5f6983c4ee722cfec9c80348d0b8ae7a" translate="yes" xml:space="preserve">
          <source>Reload the endpoint configuration on application upgrades</source>
          <target state="translated">애플리케이션 업그레이드시 엔드 포인트 구성을 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="52294d825cdd8c5e8ba2a8c2240864605c1a4510" translate="yes" xml:space="preserve">
          <source>Reload the endpoint configuration on application upgrades.</source>
          <target state="translated">애플리케이션 업그레이드시 엔드 포인트 구성을 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="47e7c5465e5bbbf3cbdd1686cff7ea6c53743993" translate="yes" xml:space="preserve">
          <source>Reloads code for the current Mix project by invoking the &lt;code&gt;:reloadable_compilers&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:reloadable_compilers&lt;/code&gt; 를 호출하여 현재 믹스 프로젝트의 코드를 다시로드합니다 .</target>
        </trans-unit>
        <trans-unit id="817332bb13bf37a0a2275b54b00ef58fac94d844" translate="yes" xml:space="preserve">
          <source>Reloads code for the current Mix project by invoking the &lt;code&gt;:reloadable_compilers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:reloadable_compilers&lt;/code&gt; 를 호출하여 현재 믹스 프로젝트의 코드를 다시로드합니다 .</target>
        </trans-unit>
        <trans-unit id="766003dec9e1c1e02c51395fa2a565331aa2a7a0" translate="yes" xml:space="preserve">
          <source>Remote Client</source>
          <target state="translated">원격 클라이언트</target>
        </trans-unit>
        <trans-unit id="15325870375964566c0db153077605ee4d6ba5ef" translate="yes" xml:space="preserve">
          <source>Removes all elements for replicas that are permanently gone</source>
          <target state="translated">영구적으로 사라진 복제본의 모든 요소를 ​​제거합니다.</target>
        </trans-unit>
        <trans-unit id="de3c06260f245217fdccbebbeee618023b313316" translate="yes" xml:space="preserve">
          <source>Removes all elements for replicas that are permanently gone.</source>
          <target state="translated">영구적으로 사라진 복제본의 모든 요소를 ​​제거합니다.</target>
        </trans-unit>
        <trans-unit id="21ec5b5bc2425ec115c86a31d53e6303bc5e980d" translate="yes" xml:space="preserve">
          <source>Removes all elements from the set for the given pid</source>
          <target state="translated">주어진 pid에 대한 세트에서 모든 요소를 ​​제거합니다</target>
        </trans-unit>
        <trans-unit id="0baf5856ed740984940b6e3308ee165dfe19d975" translate="yes" xml:space="preserve">
          <source>Removes all elements from the set for the given pid.</source>
          <target state="translated">주어진 pid에 대한 세트에서 모든 요소를 ​​제거합니다.</target>
        </trans-unit>
        <trans-unit id="1cf882d0a99560f03a1cb1e5de642281ff708392" translate="yes" xml:space="preserve">
          <source>Removes an element from the set</source>
          <target state="translated">세트에서 요소를 제거합니다</target>
        </trans-unit>
        <trans-unit id="c52942e1f145b4031f59fd77a106a658cbf1ddeb" translate="yes" xml:space="preserve">
          <source>Removes an element from the set.</source>
          <target state="translated">세트에서 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="89a6ce134f77be0034d61842e6e4d6d5a96aa083" translate="yes" xml:space="preserve">
          <source>Removes old versions of compiled assets.</source>
          <target state="translated">컴파일 된 자산의 이전 버전을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="55ecb2c45ca7355e4abbce2db09e3b327c8c343c" translate="yes" xml:space="preserve">
          <source>Removes the given suffix from the name if it exists</source>
          <target state="translated">지정된 접미사가 있으면 이름에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1655bc2149cd6a146e2ac53ec4bc2dcfb14e9c25" translate="yes" xml:space="preserve">
          <source>Removes the given suffix from the name if it exists.</source>
          <target state="translated">지정된 접미사가 있으면 이름에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="08bbc0d9b4409e6f56f323f27880d90461c9435e" translate="yes" xml:space="preserve">
          <source>Removes the session associated with given session id from the store</source>
          <target state="translated">주어진 세션 ID와 연관된 세션을 상점에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="fb1f51dff10756f68903a361d28310a54d8a0da2" translate="yes" xml:space="preserve">
          <source>Removes the session associated with given session id from the store.</source>
          <target state="translated">주어진 세션 ID와 연관된 세션을 상점에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8e6c88a6d94aea67d9ed896c21fdd6eac008a3ba" translate="yes" xml:space="preserve">
          <source>Removing data</source>
          <target state="translated">데이터 제거</target>
        </trans-unit>
        <trans-unit id="529068386c7cf05f5b82c26b7ed494cf8f387f7a" translate="yes" xml:space="preserve">
          <source>Render the given template or the default template specified by the current action with the given assigns</source>
          <target state="translated">주어진 템플릿을 사용하여 현재 작업에 의해 지정된 템플릿 또는 기본 템플릿을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="10d799fe80c9c6cca9382808c5587a9f098b3385" translate="yes" xml:space="preserve">
          <source>Render the given template or the default template specified by the current action with the given assigns.</source>
          <target state="translated">지정된 템플릿을 사용하여 현재 작업에 의해 지정된 기본 템플릿 또는 기본 템플릿을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="679cb6713a426896fc72064370dad2fa4b9eabc4" translate="yes" xml:space="preserve">
          <source>Rendering and layouts</source>
          <target state="translated">렌더링 및 레이아웃</target>
        </trans-unit>
        <trans-unit id="875711d921f3bd103b9ac284647ab930488f4540" translate="yes" xml:space="preserve">
          <source>Rendering based on controller template</source>
          <target state="translated">컨트롤러 템플릿을 기반으로 렌더링</target>
        </trans-unit>
        <trans-unit id="b3559380bd456e4c2804094a9b29890e9c270f0a" translate="yes" xml:space="preserve">
          <source>Renders a collection</source>
          <target state="translated">컬렉션을 렌더링</target>
        </trans-unit>
        <trans-unit id="9549acaeff8fac716c468a0d8a646735aca0f520" translate="yes" xml:space="preserve">
          <source>Renders a collection.</source>
          <target state="translated">컬렉션을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="c05bb9af91e397c4329814d85a1daeb75b55c3dd" translate="yes" xml:space="preserve">
          <source>Renders a single item if not nil</source>
          <target state="translated">nil이 아닌 경우 단일 항목을 렌더링합니다</target>
        </trans-unit>
        <trans-unit id="5465a6020b101c71ea348e5dc16bceebfd3baa89" translate="yes" xml:space="preserve">
          <source>Renders a single item if not nil.</source>
          <target state="translated">nil이 아닌 경우 단일 항목을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="9af1e71744395a0c63fc6dde9d976827f2510835" translate="yes" xml:space="preserve">
          <source>Renders a template</source>
          <target state="translated">템플릿을 렌더링</target>
        </trans-unit>
        <trans-unit id="010c2f432938fdf78caf8cd600b018d715e4801f" translate="yes" xml:space="preserve">
          <source>Renders a template only if it exists</source>
          <target state="translated">템플릿이 존재하는 경우에만 렌더링합니다</target>
        </trans-unit>
        <trans-unit id="992076890c75e1ddadd6b55a2fce08858516d55a" translate="yes" xml:space="preserve">
          <source>Renders a template only if it exists.</source>
          <target state="translated">존재하는 경우에만 템플릿을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="8cedaf1b5b8cacfe220622e987d31a771f2a1e2b" translate="yes" xml:space="preserve">
          <source>Renders a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d44d832aae95fc0e71c4568a8c54f911980516" translate="yes" xml:space="preserve">
          <source>Renders the given &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;assigns&lt;/code&gt; based on the &lt;code&gt;conn&lt;/code&gt; information</source>
          <target state="translated">주어진 렌더 &lt;code&gt;template&lt;/code&gt; 및 &lt;code&gt;assigns&lt;/code&gt; 에 기초 &lt;code&gt;conn&lt;/code&gt; 정보</target>
        </trans-unit>
        <trans-unit id="9e96a8eeaa46194b322dde6e45fda5119e3e7d34" translate="yes" xml:space="preserve">
          <source>Renders the given &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;assigns&lt;/code&gt; based on the &lt;code&gt;conn&lt;/code&gt; information.</source>
          <target state="translated">주어진 렌더링 &lt;code&gt;template&lt;/code&gt; 및 &lt;code&gt;assigns&lt;/code&gt; 에 기초 &lt;code&gt;conn&lt;/code&gt; 정보를.</target>
        </trans-unit>
        <trans-unit id="01e5ae376eb2e27afc27bece5699c6c4c43832e4" translate="yes" xml:space="preserve">
          <source>Renders the template and returns a string</source>
          <target state="translated">템플릿을 렌더링하고 문자열을 반환</target>
        </trans-unit>
        <trans-unit id="482145d251e35fbac232d56594041c1658159f2a" translate="yes" xml:space="preserve">
          <source>Renders the template and returns a string.</source>
          <target state="translated">템플릿을 렌더링하고 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ba8fe15fe6efc84ae418d19c35a6f2a62868124" translate="yes" xml:space="preserve">
          <source>Renders the template and returns iodata</source>
          <target state="translated">템플릿을 렌더링하고 iodata를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="258156edae9cfadf191684d2a711700a37bfd521" translate="yes" xml:space="preserve">
          <source>Renders the template and returns iodata.</source>
          <target state="translated">템플릿을 렌더링하고 iodata를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8a103c73005ccd029f388a9b7336a994cad85ba" translate="yes" xml:space="preserve">
          <source>Replies</source>
          <target state="translated">Replies</target>
        </trans-unit>
        <trans-unit id="c6c7283edc1b89ebc241780e13dc46d48b4e8e25" translate="yes" xml:space="preserve">
          <source>Replies asynchronously to a socket push</source>
          <target state="translated">소켓 푸시에 비동기 적으로 응답</target>
        </trans-unit>
        <trans-unit id="4c5aff3395c1a416fa552f4f8ba9dfa3f96a78d8" translate="yes" xml:space="preserve">
          <source>Replies asynchronously to a socket push.</source>
          <target state="translated">소켓 푸시에 비동기 적으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="91808ed37a0fb8608b1c734a889058462fc6e90c" translate="yes" xml:space="preserve">
          <source>Repo resolution</source>
          <target state="translated">리포 해상도</target>
        </trans-unit>
        <trans-unit id="c91e6e6a538a5087a64a99718ae975966b761c1e" translate="yes" xml:space="preserve">
          <source>Repositories</source>
          <target state="translated">Repositories</target>
        </trans-unit>
        <trans-unit id="5a04a4b8c1f1c230bb0f4cd5a050787aaa087d8c" translate="yes" xml:space="preserve">
          <source>Repositories by default support URLs. For example, the configuration above could be rewritten to:</source>
          <target state="translated">기본적으로 리포지토리는 URL을 지원합니다. 예를 들어, 위의 구성을 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f046cc0117a29a6869d58d3d1cbd183012cd7a7" translate="yes" xml:space="preserve">
          <source>Request fields</source>
          <target state="translated">요청 필드</target>
        </trans-unit>
        <trans-unit id="16346fdb36f9e7a7b03ee60d349e058748773ff3" translate="yes" xml:space="preserve">
          <source>Requests a random file to be created in the upload directory with the given prefix</source>
          <target state="translated">주어진 접두사를 사용하여 업로드 디렉토리에 임의의 파일을 작성하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="f771003acf808c23aa297fe7a02d6ba85cba28a5" translate="yes" xml:space="preserve">
          <source>Requests a random file to be created in the upload directory with the given prefix.</source>
          <target state="translated">주어진 접두사를 사용하여 업로드 디렉토리에 임의의 파일을 작성하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="3b65aa51aac1696dfac54eb844bd22189d1c6c20" translate="yes" xml:space="preserve">
          <source>Requests a random file to be created in the upload directory with the given prefix. Raises on failure</source>
          <target state="translated">주어진 접두사를 사용하여 업로드 디렉토리에 임의의 파일을 작성하도록 요청합니다. 실패 발생</target>
        </trans-unit>
        <trans-unit id="2ab73756308332af029c8c4ca625955161607b3d" translate="yes" xml:space="preserve">
          <source>Requests a random file to be created in the upload directory with the given prefix. Raises on failure.</source>
          <target state="translated">주어진 접두사를 사용하여 업로드 디렉토리에 임의의 파일을 작성하도록 요청합니다. 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa7cc45a2f0b2c6e0f547254eb2a6537f51086e8" translate="yes" xml:space="preserve">
          <source>Required &lt;code&gt;pool_opts&lt;/code&gt;:</source>
          <target state="translated">필요한 &lt;code&gt;pool_opts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3cb2ffed5bdda27fe0da4adfbf1afb494a74f72" translate="yes" xml:space="preserve">
          <source>Required &lt;code&gt;server_opts&lt;/code&gt;:</source>
          <target state="translated">필수 &lt;code&gt;server_opts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42c4c07337fd0b34244f71fc37173ddfa010fbce" translate="yes" xml:space="preserve">
          <source>Reraises an error or a wrapped one</source>
          <target state="translated">오류 또는 포장 된 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b94d48b0d0a1e117c90995e12d265bb52a3ce3dd" translate="yes" xml:space="preserve">
          <source>Reraises an error or a wrapped one.</source>
          <target state="translated">오류 또는 랩핑 된 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="cc9695ab8a0663ef8e4cdd91ed033dd93ef16b13" translate="yes" xml:space="preserve">
          <source>Resets a previously set field on a query</source>
          <target state="translated">쿼리에서 이전에 설정 한 필드를 재설정합니다</target>
        </trans-unit>
        <trans-unit id="cc1e5f63666771c6b295e03fcf89503d1e853b07" translate="yes" xml:space="preserve">
          <source>Resets a previously set field on a query.</source>
          <target state="translated">쿼리에서 이전에 설정 한 필드를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="4396d18ac6dfda8d326a50c720338a338ee1ce15" translate="yes" xml:space="preserve">
          <source>Resets the set&amp;rsquo;s delta</source>
          <target state="translated">세트의 델타를 재설정합니다</target>
        </trans-unit>
        <trans-unit id="49092afde09229f5643c56a7897ea603a13d3477" translate="yes" xml:space="preserve">
          <source>Resets the set&amp;rsquo;s delta.</source>
          <target state="translated">세트의 델타를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="cfdb8eac562178cecca6be0acf0b9946ca8aa0a1" translate="yes" xml:space="preserve">
          <source>Resources can be namespaced, for such, it is just necessary to namespace the first argument of the generator:</source>
          <target state="translated">리소스는 네임 스페이스가 될 수 있으므로 생성기의 첫 번째 인수를 네임 스페이스로 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c3fe9cc0330fb297336ec5adbab30db233008ca1" translate="yes" xml:space="preserve">
          <source>Response fields</source>
          <target state="translated">응답 필드</target>
        </trans-unit>
        <trans-unit id="9a8579fe199c1bd99b47dbe8b26a3074a6b7775b" translate="yes" xml:space="preserve">
          <source>Restricts the query to return the first result ordered by primary key</source>
          <target state="translated">기본 키로 정렬 된 첫 번째 결과를 반환하도록 쿼리를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="1be5679f0d024487571e90253a8ab8bb6a3e035d" translate="yes" xml:space="preserve">
          <source>Restricts the query to return the first result ordered by primary key.</source>
          <target state="translated">기본 키로 정렬 된 첫 번째 결과를 반환하도록 쿼리를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="7640144b5f59ee8fcfc21eba87bc4737035dbfe3" translate="yes" xml:space="preserve">
          <source>Restricts the query to return the last result ordered by primary key</source>
          <target state="translated">기본 키로 정렬 된 마지막 결과를 반환하도록 쿼리를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="84f17f7e72e012fa8ecb25425c8d772c52b93041" translate="yes" xml:space="preserve">
          <source>Restricts the query to return the last result ordered by primary key.</source>
          <target state="translated">기본 키로 정렬 된 마지막 결과를 반환하도록 쿼리를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="11245c1fc733e0c008fb66ce6a0748f0e5fb8e42" translate="yes" xml:space="preserve">
          <source>Retrieves current layout formats</source>
          <target state="translated">현재 레이아웃 형식을 검색합니다</target>
        </trans-unit>
        <trans-unit id="d1477fcc02b66876278353a61847e3a0adbf780b" translate="yes" xml:space="preserve">
          <source>Retrieves current layout formats.</source>
          <target state="translated">현재 레이아웃 형식을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="8cb31ca469458aaced9cd91b90af5fd5469a8ad3" translate="yes" xml:space="preserve">
          <source>Retrieves the current layout</source>
          <target state="translated">현재 레이아웃을 검색합니다</target>
        </trans-unit>
        <trans-unit id="7d8b89095847125b428e7d401d0d88cc8e7fc256" translate="yes" xml:space="preserve">
          <source>Retrieves the current layout.</source>
          <target state="translated">현재 레이아웃을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="de4e7e7f9ddfa130ffdaf5cdefb5744bc005d9c7" translate="yes" xml:space="preserve">
          <source>Retrieves the current view</source>
          <target state="translated">현재보기를 검색합니다</target>
        </trans-unit>
        <trans-unit id="fb4232316a5314aa554d2d39877bfc3bcce354c7" translate="yes" xml:space="preserve">
          <source>Retrieves the current view.</source>
          <target state="translated">현재보기를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="4bddf417a7de2f2c1bbe4dc8d6ee57105e612f2c" translate="yes" xml:space="preserve">
          <source>Retrieves the underlying schema type for the given, possibly custom, type</source>
          <target state="translated">주어진, 아마도 커스텀 타입에 대한 기본 스키마 타입을 검색</target>
        </trans-unit>
        <trans-unit id="5961cf468e4e2aa3afe98203f5b5c22bd0d77054" translate="yes" xml:space="preserve">
          <source>Retrieves the underlying schema type for the given, possibly custom, type.</source>
          <target state="translated">지정된 가능한 사용자 정의 유형에 대한 기본 스키마 유형을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="ee1295c185bc34ef3a9c058cebfaa8b9fdbf9290" translate="yes" xml:space="preserve">
          <source>Return the assets that have been pushed</source>
          <target state="translated">푸시 된 자산 반환</target>
        </trans-unit>
        <trans-unit id="43c95fc10ae46b19b5ba89cee4d152f0acef55a8" translate="yes" xml:space="preserve">
          <source>Return the assets that have been pushed.</source>
          <target state="translated">푸시 된 자산을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8b5c0d8b119dcf904ba88b367260c00c3ef9780" translate="yes" xml:space="preserve">
          <source>Return the informational requests that have been sent</source>
          <target state="translated">전송 된 정보 요청을 반환</target>
        </trans-unit>
        <trans-unit id="4fb34f4377ca6c1a70a8356ec50da9bcbcc53b11" translate="yes" xml:space="preserve">
          <source>Return the informational requests that have been sent.</source>
          <target state="translated">전송 된 정보 요청을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9d42e2f739c476b4724ed40443cd1bdc8b0b0c31" translate="yes" xml:space="preserve">
          <source>Return values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d85682eefe81ef7b0bc4a48c1801bc1226f1365" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;code&gt;c:terminate/2&lt;/code&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">반환 &lt;code&gt;:ignore&lt;/code&gt; 하게됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;:ignore&lt;/code&gt; 하고 프로세스가 루프를 입력하거나 호출하지 않고 정상적으로 종료됩니다 &lt;code&gt;c:terminate/2&lt;/code&gt; . 감독 트리의 일부로 사용될 때 부모 감독자는 시작하지 못하거나 즉시 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 다시 시작하려고 시도하지 않습니다 . 나머지 감시 트리가 시작되므로 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 다른 프로세스에 필요하지 않습니다. 하위 스펙이 상위 감독자에 저장되므로 나중에 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 로 시작할 수 있습니다 . 이에 대한 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00a41a817313be26ad6bd03d4d8bb8d0ef9b40ce" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;code&gt;start_link/3&lt;/code&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;code&gt;c:terminate/2&lt;/code&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be (re)started and so the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">반환 &lt;code&gt;:ignore&lt;/code&gt; 하게됩니다 &lt;code&gt;start_link/3&lt;/code&gt; 반환 &lt;code&gt;:ignore&lt;/code&gt; 하고 프로세스가 루프를 입력하거나 호출하지 않고 정상적으로 종료됩니다 &lt;code&gt;c:terminate/2&lt;/code&gt; . 감독 트리의 일부로 사용될 때 부모 감독자는 시작하지 못하거나 즉시 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 다시 시작하려고 시도하지 않습니다 . 나머지 감시 트리는 (재) 시작되므로 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 다른 프로세스에 필요하지 않습니다. 하위 스펙이 상위 감독자에 저장되므로 나중에 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 로 시작할 수 있습니다 . 이에 대한 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ff73e37511f28874066a51701c02984a9625ba4" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;code&gt;start_link/3&lt;/code&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;code&gt;c:terminate/2&lt;/code&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">반환 &lt;code&gt;:ignore&lt;/code&gt; 하게됩니다 &lt;code&gt;start_link/3&lt;/code&gt; 반환 &lt;code&gt;:ignore&lt;/code&gt; 하고 프로세스가 루프를 입력하거나 호출하지 않고 정상적으로 종료됩니다 &lt;code&gt;c:terminate/2&lt;/code&gt; . 감독 트리의 일부로 사용될 때 부모 감독자는 시작하지 못하거나 즉시 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 다시 시작하려고 시도하지 않습니다 . 나머지 감시 트리가 시작되므로 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 다른 프로세스에 필요하지 않습니다. 하위 스펙이 상위 감독자에 저장되므로 나중에 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 로 시작할 수 있습니다 . 이에 대한 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bff6cc29ca5bd8a34c473249c3c63fc7d76e68c" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;nil&lt;/code&gt; makes this socket anonymous.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 을 반환 하면이 소켓이 익명이됩니다.</target>
        </trans-unit>
        <trans-unit id="9072c59f2221595d98be6bb52b91c6b0c3b06c0b" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except the process is hibernated before entering the loop. See &lt;code&gt;c:handle_call/3&lt;/code&gt; for more information on hibernation.</source>
          <target state="translated">&lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; 반환 하는 것은 루프에 들어가기 전에 프로세스가 최대 절전 모드 인 것을 제외하고는 &lt;code&gt;{:ok, state}&lt;/code&gt; 와 비슷합니다 . 최대 절전 모드에 대한 자세한 내용 은 &lt;code&gt;c:handle_call/3&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de90d70d60e20f4781d6329e3d49fc470b32ed7c" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except &lt;code&gt;handle_info(:timeout, state)&lt;/code&gt; will be called after &lt;code&gt;timeout&lt;/code&gt; milliseconds if no messages are received within the timeout.</source>
          <target state="translated">&lt;code&gt;{:ok, state, timeout}&lt;/code&gt; 반환하는 것은 {: ok, state} 와 비슷합니다 &lt;code&gt;{:ok, state}&lt;/code&gt; 단 , 타임 아웃 내에 메시지가 수신되지 않으면 &lt;code&gt;handle_info(:timeout, state)&lt;/code&gt; 는 &lt;code&gt;timeout&lt;/code&gt; 밀리 초 후에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c5290df2c6b52f28b4e772545847564eeac993d" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except that immediately after entering the loop the &lt;code&gt;c:handle_continue/2&lt;/code&gt; callback will be invoked with &lt;code&gt;Continue&lt;/code&gt; as first argument.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; 와 유사하다 &lt;code&gt;{:ok, state}&lt;/code&gt; 것을 제외하고 즉시 루프에게 입력 한 후 &lt;code&gt;c:handle_continue/2&lt;/code&gt; 콜백이 호출됩니다 &lt;code&gt;Continue&lt;/code&gt; 첫 번째 인수로.</target>
        </trans-unit>
        <trans-unit id="5e266ed35f5a07eeef5d08bc7de00ba6d44480f2" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except that immediately after entering the loop the &lt;code&gt;c:handle_continue/2&lt;/code&gt; callback will be invoked with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; 비슷 &lt;code&gt;{:ok, state}&lt;/code&gt; 것 이외에는 즉시 루프에게 입력 한 후 &lt;code&gt;c:handle_continue/2&lt;/code&gt; 콜백 값으로 호출된다는 &lt;code&gt;continue&lt;/code&gt; 제 인수로한다.</target>
        </trans-unit>
        <trans-unit id="4e7d4ebacb2fe086ff03c74440ab13b1423c917e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:ok, pid}&lt;/code&gt; and the process to enter its loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3cdecd3e6dd19af77a3ae2d89ad09a2ac949c2" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state}&lt;/code&gt; will cause &lt;code&gt;start_link/3&lt;/code&gt; to return &lt;code&gt;{:ok, pid}&lt;/code&gt; and the process to enter its loop.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, state}&lt;/code&gt; 의 원인이됩니다 &lt;code&gt;start_link/3&lt;/code&gt; 돌아 &lt;code&gt;{:ok, pid}&lt;/code&gt; 과 그 루프를 입력하는 과정.</target>
        </trans-unit>
        <trans-unit id="ff4885b193e5e31cd9b10b3bed429dbfedccbf7d" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:error, reason}&lt;/code&gt; and the process to exit with reason &lt;code&gt;reason&lt;/code&gt; without entering the loop or calling &lt;code&gt;c:terminate/2&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:stop, reason}&lt;/code&gt; 의 원인이됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 돌아 &lt;code&gt;{:error, reason}&lt;/code&gt; 및 이유와 출구 과정 &lt;code&gt;reason&lt;/code&gt; 루프를 입력하거나 호출하지 않고 &lt;code&gt;c:terminate/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="958ba96970f27c1edef49fa9a09b56e9fb4a1f11" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason}&lt;/code&gt; will cause &lt;code&gt;start_link/3&lt;/code&gt; to return &lt;code&gt;{:error, reason}&lt;/code&gt; and the process to exit with reason &lt;code&gt;reason&lt;/code&gt; without entering the loop or calling &lt;code&gt;c:terminate/2&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:stop, reason}&lt;/code&gt; 의 원인이됩니다 &lt;code&gt;start_link/3&lt;/code&gt; 돌아 &lt;code&gt;{:error, reason}&lt;/code&gt; 및 이유와 출구 과정 &lt;code&gt;reason&lt;/code&gt; 루프를 입력하거나 호출하지 않고 &lt;code&gt;c:terminate/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ead0287f37dbf41a5b3e642fa183f6cceae5aa19" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if it was created successfully.</source>
          <target state="translated">성공적으로 작성된 경우 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="70939585b75d8df6aeae0245bfdd5f2e2587b1a3" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if it was dropped successfully.</source>
          <target state="translated">성공적으로 삭제 된 경우 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a2267d38e27ee29bf7513fada6d2716e40cdb163" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;nil&lt;/code&gt; if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error.</source>
          <target state="translated">결과가 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 쿼리 가능의 구조체에 기본 키가 하나 이상 없거나 기본 키가 있으면 인수 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e53620a3b277dbf9a9602eb773594a80db3e44d6" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;nil&lt;/code&gt; if no result was found. Raises if more than one entry.</source>
          <target state="translated">결과가 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 둘 이상의 항목이 있으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9360c2d44ef312594284b5a710755e2346b37d4b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if module implements behaviour</source>
          <target state="translated">모듈이 동작을 구현하면 &lt;code&gt;true&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="23a59d892319f7f0fbbc2e7a9dd75fa134a0f90b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if module implements behaviour.</source>
          <target state="translated">모듈이 동작을 구현하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d19c7ee6da1e3f5da0fb1807858b4ade5c50360" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if query has binding with a given name, otherwise &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">쿼리에 지정된 이름의 바인딩이 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b85e7f5d19e828b88b0b056874576033b0a6b40f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if query has binding with a given name, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">쿼리에 지정된 이름의 바인딩이 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="3c78f17bafbd0dd213461c41dc67d858e69064d2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:error, :already_down}&lt;/code&gt; if the storage has already been dropped or &lt;code&gt;{:error, term}&lt;/code&gt; in case anything else goes wrong.</source>
          <target state="translated">저장소가 이미 삭제 된 경우 &lt;code&gt;{:error, :already_down}&lt;/code&gt; 반환하거나 다른 문제가 발생할 경우 &lt;code&gt;{:error, term}&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="605d378ffa674fae5a00cee570b0b7cdcad07117" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:error, :already_up}&lt;/code&gt; if the storage has already been created or &lt;code&gt;{:error, term}&lt;/code&gt; in case anything else goes wrong.</source>
          <target state="translated">저장소가 이미 생성 된 경우 &lt;code&gt;{:error, :already_up}&lt;/code&gt; 반환하거나 다른 문제가 발생할 경우 &lt;code&gt;{:error, term}&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bbb74ea38a6533d0fe461ebaab3531e6bbb4441f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; if the repo is already started or &lt;code&gt;{:error, term}&lt;/code&gt; in case anything else goes wrong.</source>
          <target state="translated">반환 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 의 repo은 이미 시작되었을 경우, 또는 &lt;code&gt;{:error, term}&lt;/code&gt; 다른 경우 아무것도에 잘못.</target>
        </trans-unit>
        <trans-unit id="58e63b43ef9abbb082be42bd8c0a86235c15cd73" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, body, conn}&lt;/code&gt; if all body has been read, &lt;code&gt;{:more, binary, conn}&lt;/code&gt; otherwise, and &lt;code&gt;{:done, conn}&lt;/code&gt; if there is no more body.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, body, conn}&lt;/code&gt; 모든 몸이 된 경우 읽기, &lt;code&gt;{:more, binary, conn}&lt;/code&gt; 그렇지 않으면, 그리고 &lt;code&gt;{:done, conn}&lt;/code&gt; 더 이상 몸이없는 경우.</target>
        </trans-unit>
        <trans-unit id="492087e16b1e08208596bad63dcf4e6983dd69a6" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, value}&lt;/code&gt; if the transaction was successful where &lt;code&gt;value&lt;/code&gt; is the value return by the function or &lt;code&gt;{:error, value}&lt;/code&gt; if the transaction was rolled back where &lt;code&gt;value&lt;/code&gt; is the value given to &lt;code&gt;rollback/1&lt;/code&gt;.</source>
          <target state="translated">트랜잭션이 성공한 경우 &lt;code&gt;{:ok, value}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;value&lt;/code&gt; 는 함수에 의해 리턴 된 값이거나 트랜잭션이 롤백 된 경우에는 &lt;code&gt;{:error, value}&lt;/code&gt; 여기서 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;rollback/1&lt;/code&gt; 에 제공된 값 입니다 .</target>
        </trans-unit>
        <trans-unit id="b3ac990ec0b9514356d2a034319c859849a9e6e5" translate="yes" xml:space="preserve">
          <source>Returns a 3-tuple of the updated set, and the joined and left elements.</source>
          <target state="translated">업데이트 된 세트의 3 튜플과 결합 및 왼쪽 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f35d9695ecb23f999b9998650d30381261bef9f" translate="yes" xml:space="preserve">
          <source>Returns a boolean.</source>
          <target state="translated">부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ee158500b9f89a33b9ce70235221ba32299a4c5" translate="yes" xml:space="preserve">
          <source>Returns a connection with the value resulting from the async assignment placed under &lt;code&gt;key&lt;/code&gt; in the &lt;code&gt;:assigns&lt;/code&gt; field.</source>
          <target state="translated">반환 비동기 할당의 결과 값과의 연결은 아래에 배치 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;:assigns&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="07bac1c9be8bf8bb3367a18c96209210550c6899" translate="yes" xml:space="preserve">
          <source>Returns a derived key suitable for use</source>
          <target state="translated">사용하기에 적합한 파생 키를 반환</target>
        </trans-unit>
        <trans-unit id="5e75f3416132b9bd95f6a63b5c6c85239a872598" translate="yes" xml:space="preserve">
          <source>Returns a derived key suitable for use.</source>
          <target state="translated">사용하기에 적합한 파생 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f0d71c80f5d0cc1a9d0ab8793b15d37692fd2cd" translate="yes" xml:space="preserve">
          <source>Returns a keyword list of the validations for this changeset</source>
          <target state="translated">이 변경 집합에 대한 유효성 검사 키워드 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a05481cc133c5c294e5f4dc6b7b8e55db365bfdf" translate="yes" xml:space="preserve">
          <source>Returns a keyword list of the validations for this changeset.</source>
          <target state="translated">이 변경 세트에 대한 유효성 검증 키워드 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4eceacd5368c78d30c87b34a7ca397a7e8c03b4a" translate="yes" xml:space="preserve">
          <source>Returns a lazy enumerable that emits all entries from the data store matching the given query</source>
          <target state="translated">주어진 쿼리와 일치하는 데이터 저장소에서 모든 항목을 내보내는 게으른 열거 형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d404a7c17f5a0b0c1453ff865660d917c5678214" translate="yes" xml:space="preserve">
          <source>Returns a lazy enumerable that emits all entries from the data store matching the given query.</source>
          <target state="translated">주어진 쿼리와 일치하는 데이터 저장소에서 모든 항목을 내보내는 지연 열거 형을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6a34a3db584f9e3fd9604539366fb57ea2cd9ec6" translate="yes" xml:space="preserve">
          <source>Returns a list of elements for the topic who belong to an online replica</source>
          <target state="translated">온라인 복제본에 속하는 주제의 요소 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9728c9b94accd9419ab46a4602b235851d8df84e" translate="yes" xml:space="preserve">
          <source>Returns a list of elements for the topic who belong to an online replica.</source>
          <target state="translated">온라인 복제본에 속하는 주제의 요소 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="98ecba6737698c276fc7aa3bdae3b968207495ca" translate="yes" xml:space="preserve">
          <source>Returns a list of elements in the set belonging to an online replica</source>
          <target state="translated">온라인 복제본에 속하는 세트의 요소 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fc5e4101925193876bb5c320c36427d878ef3ae3" translate="yes" xml:space="preserve">
          <source>Returns a list of elements in the set belonging to an online replica.</source>
          <target state="translated">온라인 복제본에 속하는 세트의 요소 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8f6fc0dce67c81b4ef9135a5edd3f136b2cc99cb" translate="yes" xml:space="preserve">
          <source>Returns a lists of presence metadata.</source>
          <target state="translated">현재 상태 메타 데이터 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dba8891d7dff85bea5812cb85aa4e955ebb95f7" translate="yes" xml:space="preserve">
          <source>Returns a lists of presences in key/metadata tuple pairs.</source>
          <target state="translated">키 / 메타 데이터 튜플 쌍으로 존재 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dff9c6907481d25cab3f4d2d9b09bf07ac097138" translate="yes" xml:space="preserve">
          <source>Returns a map of previously set flash messages or an empty map</source>
          <target state="translated">이전에 설정된 플래시 메시지의 맵 또는 빈 맵을 반환합니다</target>
        </trans-unit>
        <trans-unit id="6abe9dd0b8966c47f830c2f72b614d2c40758609" translate="yes" xml:space="preserve">
          <source>Returns a map of previously set flash messages or an empty map.</source>
          <target state="translated">이전에 설정된 플래시 메시지의 맵 또는 빈 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3bcc9e9461f0d40bcb8ba9f9ff8bfdc0346797f" translate="yes" xml:space="preserve">
          <source>Returns a message from flash by key</source>
          <target state="translated">키를 기준으로 플래시에서 메시지를 반환</target>
        </trans-unit>
        <trans-unit id="c2fe41e82f07a1fbbbec018c8f53d0b6182a1482" translate="yes" xml:space="preserve">
          <source>Returns a message from flash by key.</source>
          <target state="translated">키를 기준으로 플래시에서 메시지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93a50ae2e333787da62138b423eb8110c1bac7b7" translate="yes" xml:space="preserve">
          <source>Returns a name of a corresponding form field</source>
          <target state="translated">해당 양식 필드의 이름을 반환</target>
        </trans-unit>
        <trans-unit id="ba24e463caf9df93c02dd51780a0d08b0d2a6f81" translate="yes" xml:space="preserve">
          <source>Returns a name of a corresponding form field.</source>
          <target state="translated">해당 양식 필드의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23d8b361ddbae32c3b63666cb80ebf1801f12704" translate="yes" xml:space="preserve">
          <source>Returns a new struct with updated metadata</source>
          <target state="translated">메타 데이터가 업데이트 된 새 구조체를 반환</target>
        </trans-unit>
        <trans-unit id="ea74e5d44dc13f49afdcf6a9719c7e7f2969a947" translate="yes" xml:space="preserve">
          <source>Returns a new struct with updated metadata.</source>
          <target state="translated">메타 데이터가 업데이트 된 새 구조체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cc37772c9a6de6fa11c8e433fbbf34e6823bf54" translate="yes" xml:space="preserve">
          <source>Returns a session id and the session contents. The session id is any value that can be used to identify the session by the store.</source>
          <target state="translated">세션 ID와 세션 내용을 반환합니다. 세션 ID는 상점에서 세션을 식별하는 데 사용할 수있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="712005fc2a8f17e99905df105e8d47cda95bf3f0" translate="yes" xml:space="preserve">
          <source>Returns a set of subscribers pids for the given topic</source>
          <target state="translated">주어진 주제에 대한 구독자 pid 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="df937cfc113e642fc0ab14e0072f837eab655ec5" translate="yes" xml:space="preserve">
          <source>Returns a set of subscribers pids for the given topic with fastlane tuples. See &lt;code&gt;subscribers/1&lt;/code&gt; for more information</source>
          <target state="translated">fastlane 튜플이있는 주어진 주제에 대한 구독자 pid 세트를 리턴합니다. 참조 &lt;code&gt;subscribers/1&lt;/code&gt; 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="42006bcaaa53701de4479a6f3f691e45702d2f9d" translate="yes" xml:space="preserve">
          <source>Returns a set of subscribers pids for the given topic with fastlane tuples. See &lt;code&gt;subscribers/1&lt;/code&gt; for more information.</source>
          <target state="translated">fastlane 튜플이있는 주어진 주제에 대한 구독자 pid 세트를 리턴합니다. 자세한 내용은 &lt;code&gt;subscribers/1&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8369338e0c05711ad6cbabafe9b930425cf95ff" translate="yes" xml:space="preserve">
          <source>Returns a set of subscribers pids for the given topic.</source>
          <target state="translated">주어진 주제에 대한 구독자 pid 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f7fa95a2bef4637d7a4c87c84d82a9dc0cc098a5" translate="yes" xml:space="preserve">
          <source>Returns a specification to start this module under a supervisor</source>
          <target state="translated">감독자 하에서이 모듈을 시작하기위한 사양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b59fc82f7ced9ba4e9462febb3a349db49c4788" translate="yes" xml:space="preserve">
          <source>Returns a specification to start this module under a supervisor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091a21dd36a626bfc0c9fdf11d83c715167ffcdf" translate="yes" xml:space="preserve">
          <source>Returns a value of a corresponding form field</source>
          <target state="translated">해당 양식 필드의 값을 반환</target>
        </trans-unit>
        <trans-unit id="c131065afabb90589ca5cb098a3f27dc4b8fbde7" translate="yes" xml:space="preserve">
          <source>Returns a value of a corresponding form field.</source>
          <target state="translated">해당 양식 필드의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3e30cae1b351831558c3c4eda6364b611ab6b4d" translate="yes" xml:space="preserve">
          <source>Returns all constraints in a changeset</source>
          <target state="translated">변경 세트의 모든 제약 조건을 반환</target>
        </trans-unit>
        <trans-unit id="4aaa08f650c9e2be4daa322f5d4b3b46852ea886" translate="yes" xml:space="preserve">
          <source>Returns all constraints in a changeset.</source>
          <target state="translated">변경 세트의 모든 제약 조건을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6d383e0581ef77b281929559a10916020b77b8e" translate="yes" xml:space="preserve">
          <source>Returns all elements for the pid</source>
          <target state="translated">pid에 대한 모든 요소를 ​​반환</target>
        </trans-unit>
        <trans-unit id="4c5f82e0c986b328023167350fce7177ba20f9e1" translate="yes" xml:space="preserve">
          <source>Returns all elements for the pid.</source>
          <target state="translated">pid에 대한 모든 요소를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="34a3567f03d097e0d031fe8d6992717e2757962c" translate="yes" xml:space="preserve">
          <source>Returns an empty &lt;a href=&quot;ecto.multi#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct</source>
          <target state="translated">빈 &lt;a href=&quot;ecto.multi#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt; 구조체를 반환</target>
        </trans-unit>
        <trans-unit id="1867f1f84bca2a6baf78a27e20f0fdce6e1ae1c2" translate="yes" xml:space="preserve">
          <source>Returns an empty &lt;a href=&quot;ecto.multi#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">빈 &lt;a href=&quot;ecto.multi#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt; 구조체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="526b65bcb4e29d1d2c27932264c429305f684b08" translate="yes" xml:space="preserve">
          <source>Returns an id of a corresponding form field</source>
          <target state="translated">해당 양식 필드의 id를 반환</target>
        </trans-unit>
        <trans-unit id="6acc1204e5851adb35e290223e348a15e77cdcad" translate="yes" xml:space="preserve">
          <source>Returns an id of a corresponding form field and value attached to it</source>
          <target state="translated">해당 양식 필드의 ID와 이에 첨부 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84efac80dbe5e7ed56e7537f4f686f3b07b5a266" translate="yes" xml:space="preserve">
          <source>Returns an id of a corresponding form field and value attached to it.</source>
          <target state="translated">해당 양식 필드의 ID와 이에 첨부 된 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="06d59f08ef07f39b3381c35ebeeaac3548d6915d" translate="yes" xml:space="preserve">
          <source>Returns an id of a corresponding form field.</source>
          <target state="translated">해당 양식 필드의 id를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c950ea011ddd66d93e6085ee84e7633de7da47d" translate="yes" xml:space="preserve">
          <source>Returns integer ranging from 1 to the argument value, dividing the partition as equally as possible</source>
          <target state="translated">1에서 인수 값까지의 정수를 리턴하여 파티션을 가능한 한 동등하게 나눕니다.</target>
        </trans-unit>
        <trans-unit id="8ad75873b2bd9a76b194b17a4c985c8f1e83c429" translate="yes" xml:space="preserve">
          <source>Returns integer ranging from 1 to the argument value, dividing the partition as equally as possible.</source>
          <target state="translated">1에서 인수 값 사이의 정수를 리턴하여 파티션을 가능한 동일하게 나눕니다.</target>
        </trans-unit>
        <trans-unit id="1baae41f6c99996eaf501d247824dadd023b10fa" translate="yes" xml:space="preserve">
          <source>Returns number of the current row within its partition, counting from 1</source>
          <target state="translated">파티션 내에서 현재 행의 수를 1부터 계산하여 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
