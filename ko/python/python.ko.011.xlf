<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="1489759a66ae1aa1d73ef33403aebd13063968d9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it is set as the name of the task using &lt;a href=&quot;#asyncio.Task.set_name&quot;&gt;&lt;code&gt;Task.set_name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;name&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;#asyncio.Task.set_name&quot;&gt; &lt;code&gt;Task.set_name()&lt;/code&gt; &lt;/a&gt; 사용하여 작업 이름으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9757d615d57917081da1f9a4bda1c19a2f37a8bd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is not found, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;이름이&lt;/em&gt; 발견되지 않는, 돌아 오지 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f6781895f736e401572500b4ef19d36ece9f67" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is not provided in the constructor, the name returned by &lt;code&gt;tzname(dt)&lt;/code&gt; is generated from the value of the &lt;code&gt;offset&lt;/code&gt; as follows. If &lt;em&gt;offset&lt;/em&gt; is &lt;code&gt;timedelta(0)&lt;/code&gt;, the name is &amp;ldquo;UTC&amp;rdquo;, otherwise it is a string in the format &lt;code&gt;UTC&amp;plusmn;HH:MM&lt;/code&gt;, where &amp;plusmn; is the sign of &lt;code&gt;offset&lt;/code&gt;, HH and MM are two digits of &lt;code&gt;offset.hours&lt;/code&gt; and &lt;code&gt;offset.minutes&lt;/code&gt; respectively.</source>
          <target state="translated">경우 &lt;em&gt;이름&lt;/em&gt; 생성자에 제공되지 않고, 이름에 의해 반환 &lt;code&gt;tzname(dt)&lt;/code&gt; 의 값으로부터 생성 된 &lt;code&gt;offset&lt;/code&gt; 은 다음과 같이. 경우 &lt;em&gt;오프셋 (offset)&lt;/em&gt; 입니다 &lt;code&gt;timedelta(0)&lt;/code&gt; , 이름, 그렇지 않으면 형식의 문자열, &quot;UTC&quot;입니다 &lt;code&gt;UTC&amp;plusmn;HH:MM&lt;/code&gt; &amp;plusmn;가의 부호이며, &lt;code&gt;offset&lt;/code&gt; , HH 및 MM은 두 자리하고 있습니다 &lt;code&gt;offset.hours&lt;/code&gt; 및 &lt;code&gt;offset.minutes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34baedb9fa444a6c6bcfd5a19fda6da4eff56aaf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;new&lt;/em&gt; is omitted, then the target is replaced with an &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt;&lt;code&gt;AsyncMock&lt;/code&gt;&lt;/a&gt; if the patched object is an async function or a &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; otherwise. If &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is used as a decorator and &lt;em&gt;new&lt;/em&gt; is omitted, the created mock is passed in as an extra argument to the decorated function. If &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is used as a context manager the created mock is returned by the context manager.</source>
          <target state="translated">경우 &lt;em&gt;새로운는&lt;/em&gt; 생략하고 대상은으로 치환 &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt; &lt;code&gt;AsyncMock&lt;/code&gt; &lt;/a&gt; 패치 된 객체가 비동기 함수 또는 경우 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; , 그렇지. 경우 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 데코레이터로 사용되는 &lt;em&gt;새로운&lt;/em&gt; 생략, 생성 된 모의은 장식 기능을 추가 인수로 전달됩니다. 경우 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 콘텍스트 관리자로서 사용하는 생성 모의는 콘텍스트 관리자로 리턴된다.</target>
        </trans-unit>
        <trans-unit id="bdbb8a0ef01210cf36a93be1fc72449e2c9a07dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;newindex&lt;/em&gt; is specified, sets the combobox value to the element position &lt;em&gt;newindex&lt;/em&gt;. Otherwise, returns the index of the current value or -1 if the current value is not in the values list.</source>
          <target state="translated">경우 &lt;em&gt;와 newIndex가&lt;/em&gt; 지정되어, 소자의 위치에 콤보 값 세트 &lt;em&gt;와 newIndex&lt;/em&gt; . 그렇지 않으면 현재 값의 색인을 리턴하거나 현재 값이 값 목록에없는 경우 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e337316c1e611ca8905f1e941e19e507d1281cae" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ns&lt;/em&gt; is specified, it must be a 2-tuple of the form &lt;code&gt;(atime_ns, mtime_ns)&lt;/code&gt; where each member is an int expressing nanoseconds.</source>
          <target state="translated">경우 &lt;em&gt;NS가&lt;/em&gt; 지정되어, 상기 형태의 2- 튜플이어야 &lt;code&gt;(atime_ns, mtime_ns)&lt;/code&gt; 각 부재 나노초 표현한 INT이다.</target>
        </trans-unit>
        <trans-unit id="17680ea1c66682ed7ecb735074a91fe5b504f141" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;numeric_owner&lt;/em&gt; is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files. Otherwise, the named values from the tarfile are used.</source>
          <target state="translated">&lt;em&gt;numeric_owner&lt;/em&gt; 가 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 tar 파일의 uid 및 gid 번호가 추출 된 파일의 소유자 / 그룹을 설정하는 데 사용됩니다. 그렇지 않으면 tarfile의 명명 된 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27c4c94e6ce3ccf84f7ed2aea1284d8994324b1c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;obj&lt;/em&gt; is neither of the above a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 가 위의 어느 것도 아닌 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="26791b8e13e2f8fc527c3deabc666fe937e4ae87" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;offset&lt;/em&gt; is given then data is read from that position in &lt;em&gt;buffer&lt;/em&gt;. If &lt;em&gt;size&lt;/em&gt; is given then that many bytes will be read from buffer. Very large buffers (approximately 32 MiB+, though it depends on the OS) may raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception</source>
          <target state="translated">경우 &lt;em&gt;오프셋&lt;/em&gt; 지정되고있는 데이터의 그 위치로부터 판독되어 &lt;em&gt;버퍼&lt;/em&gt; . 경우 &lt;em&gt;크기가&lt;/em&gt; 지정되고있는 바이트 버퍼에서 읽어됩니다. 매우 큰 버퍼 (OS에 따라 다르지만 대략 32MiB +)에 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1eb1415e8bf69142526ae3a0d79981219d8743ee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;onerror&lt;/em&gt; is provided, it must be a callable that accepts three parameters: &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;path&lt;/em&gt;, and &lt;em&gt;excinfo&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;의 OnError가&lt;/em&gt; : 제공, 그것은 세 개의 매개 변수를 허용하는 호출해야합니다 &lt;em&gt;기능&lt;/em&gt; , &lt;em&gt;경로&lt;/em&gt; 및 &lt;em&gt;excinfo을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a54a6cff529e67ad9256b50db56cfc700f1a554" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;outcome&lt;/em&gt; is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the subtest succeeded. Otherwise, it failed with an exception where &lt;em&gt;outcome&lt;/em&gt; is a tuple of the form returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;(type, value, traceback)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;결과가&lt;/em&gt; 없습니다 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 하위 검사는 성공했다. 그렇지 않으면 &lt;em&gt;결과&lt;/em&gt; 가 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;(type, value, traceback)&lt;/code&gt; 반환 한 형식의 튜플 인 경우를 제외하고 실패했습니다 .</target>
        </trans-unit>
        <trans-unit id="a3b88cfef8d16d5c39cd9551217cde560b733287" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pad&lt;/em&gt; is true, the input is padded with &lt;code&gt;b'\0'&lt;/code&gt; so its length is a multiple of 4 bytes before encoding.</source>
          <target state="translated">경우에 &lt;em&gt;패드는&lt;/em&gt; 참 입력으로는 패딩 &lt;code&gt;b'\0'&lt;/code&gt; 의 길이 부호화 전의 4 바이트의 배수가되도록.</target>
        </trans-unit>
        <trans-unit id="21c2c919a75ee69d0dcd72db6a0617293d88b398" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;padded&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the first line of a multi-line statement will be padded with spaces to match its original position.</source>
          <target state="translated">&lt;em&gt;padded&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 여러 줄 문의 첫 번째 줄은 원래 위치와 일치하는 공백으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="122ddd43051ad3f6afe1e426367c921264fdf80e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;params&lt;/em&gt; is specified, iterate its &lt;code&gt;items&lt;/code&gt; method and use the resulting &lt;code&gt;(key, value)&lt;/code&gt; pairs to set additional parameters on the &lt;em&gt;Content-Type&lt;/em&gt; header.</source>
          <target state="translated">경우 &lt;em&gt;PARAMS는&lt;/em&gt; 반복, 그 지정 &lt;code&gt;items&lt;/code&gt; 방법 및 결과 사용 &lt;code&gt;(key, value)&lt;/code&gt; 상의 추가 매개 변수를 설정하는 쌍을 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="d2742098af95f156e52d71eb33134930cc5b2d2b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;parents&lt;/em&gt; is false (the default), a missing parent raises &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;부모가&lt;/em&gt; false (기본값), 누락 된 부모 제기 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c4c366ed6d7e659455c85c50fcab426cfddafe8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;parents&lt;/em&gt; is true, any missing parents of this path are created as needed; they are created with the default permissions without taking &lt;em&gt;mode&lt;/em&gt; into account (mimicking the POSIX &lt;code&gt;mkdir -p&lt;/code&gt; command).</source>
          <target state="translated">경우 &lt;em&gt;부모가&lt;/em&gt; 사실 필요에 따라,이 경로의 누락 부모가 만들어집니다; POSIX &lt;code&gt;mkdir -p&lt;/code&gt; 명령을 모방 한 &lt;em&gt;모드&lt;/em&gt; 를 고려 하지 않고 기본 권한으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfb728e63dc4d6becb096af8bffbd3133d9658f2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the temporary directory is created using &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile.mkdtemp()&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the context manager raises an exception on error. Otherwise, if &lt;em&gt;path&lt;/em&gt; is specified and cannot be created, only a warning is issued.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt; &lt;/a&gt; 사용하여 임시 디렉토리가 작성됩니다 . 경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 상황에 맞는 관리자 오류에 예외를 발생시킵니다. 그렇지 않으면 &lt;em&gt;경로&lt;/em&gt; 가 지정되어 작성 될 수없는 경우 경고 만 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="279e8821e221ab83a590df5547bdc8fe83b891ad" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pathname&lt;/em&gt; is a file, the filename must end with &lt;code&gt;.py&lt;/code&gt;, and just the (corresponding &lt;code&gt;*.pyc&lt;/code&gt;) file is added at the top level (no path information). If &lt;em&gt;pathname&lt;/em&gt; is a file that does not end with &lt;code&gt;.py&lt;/code&gt;, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; will be raised. If it is a directory, and the directory is not a package directory, then all the files &lt;code&gt;*.pyc&lt;/code&gt; are added at the top level. If the directory is a package directory, then all &lt;code&gt;*.pyc&lt;/code&gt; are added under the package name as a file path, and if any subdirectories are package directories, all of these are added recursively in sorted order.</source>
          <target state="translated">경우 &lt;em&gt;경로는&lt;/em&gt; 파일이며, 파일 이름이 끝나야 &lt;code&gt;.py&lt;/code&gt; , 단지 (대응 &lt;code&gt;*.pyc&lt;/code&gt; ) 파일은 최상위 (NO 경로 정보)에 부가된다. 경우 &lt;em&gt;경로 이름&lt;/em&gt; 으로 끝나지 않는 파일입니다 &lt;code&gt;.py&lt;/code&gt; 하는 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에이&lt;/a&gt; 발생합니다. 디렉토리이고 디렉토리가 패키지 디렉토리가 아닌 경우 모든 파일 &lt;code&gt;*.pyc&lt;/code&gt; 가 최상위 레벨에 추가됩니다. 디렉토리가 패키지 디렉토리 인 경우, 모든 &lt;code&gt;*.pyc&lt;/code&gt; 는 패키지 이름 아래에 파일 경로로 추가되며, 서브 디렉토리가 패키지 디렉토리 인 경우, 모든 디렉토리는 재귀 적으로 정렬 된 순서로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="41b2681b700b43aa39bbefe5e6b6c8affd770518" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pattern&lt;/em&gt; is absolute, the path must be absolute, and the whole path must match:</source>
          <target state="translated">경우 &lt;em&gt;패턴이&lt;/em&gt; 절대 경로는 절대이어야하며, 전체 경로가 일치해야합니다 :</target>
        </trans-unit>
        <trans-unit id="dc3dc34c3e256a8f40643eeec54c50b0a72ef1b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pattern&lt;/em&gt; is relative, the path can be either relative or absolute, and matching is done from the right:</source>
          <target state="translated">&lt;em&gt;패턴&lt;/em&gt; 이 상대적인 경우 경로는 상대 또는 절대 일 수 있으며 오른쪽에서 일치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ae4f495484349c434b35e20b4a937b07e53b6277" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pid&lt;/em&gt; is greater than &lt;code&gt;0&lt;/code&gt;, &lt;a href=&quot;#os.waitpid&quot;&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/a&gt; requests status information for that specific process. If &lt;em&gt;pid&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt;, the request is for the status of any child in the process group of the current process. If &lt;em&gt;pid&lt;/em&gt; is &lt;code&gt;-1&lt;/code&gt;, the request pertains to any child of the current process. If &lt;em&gt;pid&lt;/em&gt; is less than &lt;code&gt;-1&lt;/code&gt;, status is requested for any process in the process group &lt;code&gt;-pid&lt;/code&gt; (the absolute value of &lt;em&gt;pid&lt;/em&gt;).</source>
          <target state="translated">경우 &lt;em&gt;pid는&lt;/em&gt; 보다 큰 &lt;code&gt;0&lt;/code&gt; , &lt;a href=&quot;#os.waitpid&quot;&gt; &lt;code&gt;waitpid()&lt;/code&gt; &lt;/a&gt; 특정 프로세스에 대한 상태 정보를 요청합니다. 경우 &lt;em&gt;pid는&lt;/em&gt; 것입니다 &lt;code&gt;0&lt;/code&gt; , 요청은 현재 프로세스의 프로세스 그룹에있는 아이의 상태입니다. 경우 &lt;em&gt;PID가&lt;/em&gt; 있다 &lt;code&gt;-1&lt;/code&gt; , 현재 프로세스의 자식에 대한 요청이 속하는. 경우 &lt;em&gt;, PID는&lt;/em&gt; 11보다 &lt;code&gt;-1&lt;/code&gt; , 상태는 프로세스 그룹의 모든 프로세스에 대해 요구되는 &lt;code&gt;-pid&lt;/code&gt; (의 절대치 &lt;em&gt;PID&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="158f301a96505e39d53ef0b213995b204eb36ca6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt;, the default policy is restored.</source>
          <target state="translated">경우 &lt;em&gt;정책이&lt;/em&gt; 설정되어 &lt;code&gt;None&lt;/code&gt; , 기본 정책이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="a33cda1caeb8620df4cbd866550cefe362b20013" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified (it must be an instance of a &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; class) use the rules it specifies to update and serialize the representation of the message. If &lt;em&gt;policy&lt;/em&gt; is not set, use the &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy, which maintains backward compatibility with the Python 3.2 version of the email package. For more information see the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">경우 &lt;em&gt;정책이&lt;/em&gt; 지정됩니다 (인스턴스해야 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 이 업데이트 메시지의 표현을 직렬화 지정 규칙을 사용하여 클래스). 경우 &lt;em&gt;정책이&lt;/em&gt; 설정되어 있지 않은, 사용 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 의&lt;/a&gt; 전자 메일 패키지의 파이썬 3.2 버전과 이전 버전과의 호환성을 유지 정책을. 자세한 내용은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b06b36408a6fd37b66a32d5d1725489b1aa43b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified use the rules it specifies to update and serialize the representation of the message. If &lt;em&gt;policy&lt;/em&gt; is not set, use the &lt;a href=&quot;email.policy#email.policy.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; policy, which follows the rules of the email RFCs except for line endings (instead of the RFC mandated &lt;code&gt;\r\n&lt;/code&gt;, it uses the Python standard &lt;code&gt;\n&lt;/code&gt; line endings). For more information see the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">경우 &lt;em&gt;정책은&lt;/em&gt; 특정 사용이 갱신에 지정하고 메시지의 표현을 직렬화하는 규칙이다. &lt;em&gt;정책&lt;/em&gt; 이 설정되어 있지 않은 경우 RFC 명령 &lt;code&gt;\r\n&lt;/code&gt; 대신 \ n 줄 끝을 제외하고 전자 메일 RFC 규칙을 따르는 &lt;a href=&quot;email.policy#email.policy.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 정책 을 사용하십시오. 이는 Python 표준 &lt;code&gt;\n&lt;/code&gt; 줄 끝을 사용합니다 . 자세한 내용은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6693268834f69640651269a3a6f634c6aa263db" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified use the rules it specifies to update the representation of the message. If &lt;em&gt;policy&lt;/em&gt; is not set, use the &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy, which maintains backward compatibility with the Python 3.2 version of the email package and provides &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; as the default factory. All other policies provide &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; as the default &lt;em&gt;_factory&lt;/em&gt;. For more information on what else &lt;em&gt;policy&lt;/em&gt; controls, see the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">경우 &lt;em&gt;정책이&lt;/em&gt; 사용에게 규칙을 지정은 메시지의 표현을 업데이트 지정합니다. 경우 &lt;em&gt;정책이&lt;/em&gt; 설정되어 있지 않은, 사용 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 의&lt;/a&gt; 전자 메일 패키지의 파이썬 3.2 버전과 이전 버전과의 호환성을 유지하고 제공하는 정책, &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 기본 공장으로합니다. 다른 모든 정책은 제공 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 을&lt;/a&gt; 기본으로 &lt;em&gt;_factory&lt;/em&gt; . 기타 &lt;em&gt;정책&lt;/em&gt; 제어 에 대한 자세한 내용 은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1b19921a08fb3038055adec87fe883544995964" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified, (defaults to the &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy) it will be passed to &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;정책을&lt;/em&gt; 지정,합니다 (기본값 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 의&lt;/a&gt; 정책은)는 전달 될 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2399425e522c294a6da30e75c6833061e72088e7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified, use that policy to control message generation. If &lt;em&gt;policy&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), use the policy associated with the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object passed to &lt;code&gt;flatten&lt;/code&gt; to control the message generation. See &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;email.policy&lt;/code&gt;&lt;/a&gt; for details on what &lt;em&gt;policy&lt;/em&gt; controls.</source>
          <target state="translated">경우 &lt;em&gt;정책을&lt;/em&gt; 지정, 제어 메시지 생성에이 정책을 사용합니다. 경우 &lt;em&gt;정책이&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; (기본값)에서와 관련된 정책 사용 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 전달 객체를 &lt;code&gt;flatten&lt;/code&gt; 메시지 생성을 제어 할 수 있습니다. &lt;em&gt;정책&lt;/em&gt; 제어 에 대한 자세한 내용 은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;email.policy&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="234372ba74ab2a1f7e9543f3c025cced7baa0bcd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;preexec_fn&lt;/em&gt; is set to a callable object, this object will be called in the child process just before the child is executed. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;preexec_fn가&lt;/em&gt; 호출 가능한 객체로 설정되어,이 개체는 아이가 실행되기 직전에 자식 프로세스에서 호출됩니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="e055baae3a89e75ac216cb3b78aecef961d8ea30" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;prefix&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the file name will begin with that prefix; otherwise, a default prefix is used. The default is the return value of &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt;&lt;code&gt;gettempprefix()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#tempfile.gettempprefixb&quot;&gt;&lt;code&gt;gettempprefixb()&lt;/code&gt;&lt;/a&gt;, as appropriate.</source>
          <target state="translated">&lt;em&gt;prefix&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 파일 이름은 해당 접두어로 시작합니다. 그렇지 않으면 기본 접두사가 사용됩니다. 기본값은 &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt; &lt;code&gt;gettempprefix()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#tempfile.gettempprefixb&quot;&gt; &lt;code&gt;gettempprefixb()&lt;/code&gt; &lt;/a&gt; 의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="320d6a341f543a03504526e2053eb17df2ebd864" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;progress&lt;/em&gt; is specified, it must either be &lt;code&gt;None&lt;/code&gt; or a callable object that will be executed at each iteration with three integer arguments, respectively the &lt;em&gt;status&lt;/em&gt; of the last iteration, the &lt;em&gt;remaining&lt;/em&gt; number of pages still to be copied and the &lt;em&gt;total&lt;/em&gt; number of pages.</source>
          <target state="translated">경우 &lt;em&gt;진행이&lt;/em&gt; 지정되어,이 중 하나 여야합니다 &lt;code&gt;None&lt;/code&gt; 또는 세 개의 정수 인수, 각각 각각의 반복에서 실행됩니다 호출 객체 &lt;em&gt;상태&lt;/em&gt; 마지막 반복의 &lt;em&gt;나머지&lt;/em&gt; 여전히 복사 할 페이지 수와 &lt;em&gt;총&lt;/em&gt; 페이지 수.</target>
        </trans-unit>
        <trans-unit id="fd9af5ff1d54bf3dba9ffd1e4521d25aa43c2aa9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; and it is not possible to create or change the CWD, an error is raised. Otherwise, only a warning is raised and the original CWD is used.</source>
          <target state="translated">경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 과는 CWD를 만들거나 변경할 수 없습니다, 오류가 발생합니다. 그렇지 않으면 경고 만 발생하고 원래 CWD가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="835884060a8a9192218bcab1cde5f47ef1b050ce" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; (the default), the filenames and other information are printed to standard out. Set to &lt;code&gt;1&lt;/code&gt;, only errors are printed. Set to &lt;code&gt;2&lt;/code&gt;, all output is suppressed.</source>
          <target state="translated">경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; (기본값), 파일 이름 및 기타 정보를 표준 출력에 인쇄됩니다. &lt;code&gt;1&lt;/code&gt; 로 설정하면 오류 만 인쇄됩니다. &lt;code&gt;2&lt;/code&gt; 로 설정하면 모든 출력이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="8dadb44823dad128ad864c2298313a9d5da71265" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the context manager raises an exception on error. Otherwise, it issues only a warning and keeps the current working directory the same.</source>
          <target state="translated">경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 상황에 맞는 관리자 오류에 예외를 발생시킵니다. 그렇지 않으면, 경고 만 발행하고 현재 작업 디렉토리를 동일하게 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e77db954cc02cf6ffcd1e5162b0740633d6c9859" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations are generated.</source>
          <target state="translated">경우 &lt;em&gt;연구가&lt;/em&gt; 지정되거나 없다되지 &lt;code&gt;None&lt;/code&gt; , 다음 &lt;em&gt;r에&lt;/em&gt; 의 길이에 기본값을 &lt;em&gt;반복 가능한&lt;/em&gt; 모든 가능한 전체 길이 순열이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="eb898bae774457e0cd44b1cda07745bfe870b0dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rawdata&lt;/em&gt; is a string, parse it as an &lt;code&gt;HTTP_COOKIE&lt;/code&gt; and add the values found there as &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt;s. If it is a dictionary, it is equivalent to:</source>
          <target state="translated">&lt;em&gt;rawdata&lt;/em&gt; 가 문자열 인 경우 이를 &lt;code&gt;HTTP_COOKIE&lt;/code&gt; 로 구문 분석하고 찾은 값을 &lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt; 로 추가하십시오 . 사전 인 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c178f6125a527b13b9c928333c2db9e291dd9095" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;recursive&lt;/em&gt; is true, the pattern &amp;ldquo;&lt;code&gt;**&lt;/code&gt;&amp;rdquo; will match any files and zero or more directories, subdirectories and symbolic links to directories. If the pattern is followed by an &lt;a href=&quot;os#os.sep&quot;&gt;&lt;code&gt;os.sep&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.altsep&quot;&gt;&lt;code&gt;os.altsep&lt;/code&gt;&lt;/a&gt; then files will not match.</source>
          <target state="translated">경우 &lt;em&gt;재귀는&lt;/em&gt; 사실이다, 패턴은 &quot; &lt;code&gt;**&lt;/code&gt; &quot;디렉토리에있는 파일과 0 개 이상의 디렉토리, 하위 디렉토리 및 기호 링크를 일치합니다. 패턴 뒤에 &lt;a href=&quot;os#os.sep&quot;&gt; &lt;code&gt;os.sep&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.altsep&quot;&gt; &lt;code&gt;os.altsep&lt;/code&gt; 가 있으면&lt;/a&gt; 파일이 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="652f42ab0e60e31310c32efc30bfe26cd213dcee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rename&lt;/em&gt; is true, invalid fieldnames are automatically replaced with positional names. For example, &lt;code&gt;['abc', 'def', 'ghi', 'abc']&lt;/code&gt; is converted to &lt;code&gt;['abc', '_1', 'ghi', '_3']&lt;/code&gt;, eliminating the keyword &lt;code&gt;def&lt;/code&gt; and the duplicate fieldname &lt;code&gt;abc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;이름 바꾸기가&lt;/em&gt; 참 잘못된 fieldName에 자동으로 위치 이름으로 대체됩니다. 예를 들어, &lt;code&gt;['abc', 'def', 'ghi', 'abc']&lt;/code&gt; 는 &lt;code&gt;['abc', '_1', 'ghi', '_3']&lt;/code&gt; 로 변환되어 키워드 &lt;code&gt;def&lt;/code&gt; 및 중복 필드 이름 &lt;code&gt;abc&lt;/code&gt; 를 제거합니다. .</target>
        </trans-unit>
        <trans-unit id="6b0fc2117fa452e5fb0901602f2e235ae4931393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;repl&lt;/em&gt; is a function, it is called for every non-overlapping occurrence of &lt;em&gt;pattern&lt;/em&gt;. The function takes a single &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt; argument, and returns the replacement string. For example:</source>
          <target state="translated">경우 &lt;em&gt;REPL는&lt;/em&gt; 함수이며, 이는 모든 비 중첩 발생을 호출 &lt;em&gt;패턴&lt;/em&gt; . 이 함수는 단일 &lt;a href=&quot;#match-objects&quot;&gt;일치 오브젝트&lt;/a&gt; 인수를 사용하고 대체 문자열을 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a093846d95a069713492d1fd6ead5de8bd55f04" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;replace&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default) the header is moved to the end of the list of headers. If &lt;em&gt;replace&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the header will be updated in place.</source>
          <target state="translated">경우 &lt;em&gt;교체&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; (기본) 헤더는 헤더의 목록의 끝으로 이동합니다. 경우 &lt;em&gt;교체&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 헤더 자리에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="989522b42bb979106607a604c110fad8c9045475" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;restore_signals&lt;/em&gt; is true (the default) all signals that Python has set to SIG_IGN are restored to SIG_DFL in the child process before the exec. Currently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;restore_signals이&lt;/em&gt; 참 (기본) 파이썬이 SIG_IGN으로 설정했다고 모든 것을 알리는 간부하기 전에 자식 프로세스에 SIG_DFL로 복원됩니다. 현재 여기에는 SIGPIPE, SIGXFZ 및 SIGXFSZ 신호가 포함됩니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="eb9630daaf2813c2a4fbd9d5532117273440d21b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;result&lt;/em&gt; is provided, it is returned to the caller when the coroutine completes.</source>
          <target state="translated">경우 &lt;em&gt;결과가&lt;/em&gt; 제공되며, 호출자 때 코 루틴이 완료 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5684052c764729c0f68c3561f034eace258e3a1a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;return_exceptions&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (default), the first raised exception is immediately propagated to the task that awaits on &lt;code&gt;gather()&lt;/code&gt;. Other awaitables in the &lt;em&gt;aws&lt;/em&gt; sequence &lt;strong&gt;won&amp;rsquo;t be cancelled&lt;/strong&gt; and will continue to run.</source>
          <target state="translated">경우 &lt;em&gt;return_exceptions이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본), 첫 번째 발생한 예외가 바로 기다리고있다가하는 작업에 전파 &lt;code&gt;gather()&lt;/code&gt; . 의 다른 awaitables &lt;em&gt;AWS의&lt;/em&gt; 순서는 &lt;strong&gt;취소되지 않습니다&lt;/strong&gt; 및 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d6de4a327272d8e394442d6de35dbc10f4156abb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;return_exceptions&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, exceptions are treated the same as successful results, and aggregated in the result list.</source>
          <target state="translated">경우 &lt;em&gt;return_exceptions가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 예외는 성공적인 결과와 동일하게 취급하고 결과 목록에서 집계됩니다.</target>
        </trans-unit>
        <trans-unit id="c43a33c76c7da2f4198988b499c7fcff4ea7e0ba" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rx&lt;/em&gt; is given, its search method is called on the complete path to each file considered for compilation, and if it returns a true value, the file is skipped.</source>
          <target state="translated">경우 &lt;em&gt;RX가&lt;/em&gt; 주어, 그 검색 방법은 편집을 위해 고려 각 파일의 전체 경로라고하며가 true 값을 반환하는 경우, 파일은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="bceb5a6050a398999357f2debabd55d53448093b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rx&lt;/em&gt; is given, its search method is passed the full path name to the file being compiled, and if it returns a true value, the file is not compiled and &lt;code&gt;True&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;em&gt;RX가&lt;/em&gt; 주어, 그 검색 방법은 파일의 전체 경로 이름이 컴파일되는 전달하고가 true 값을 반환하는 경우, 파일은 컴파일되지 않고 &lt;code&gt;True&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="11ffb51839f338f99c26b93f469a2ff3e996354c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is an instance of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;charset&lt;/em&gt; is a hint specifying the character set of the characters in the string.</source>
          <target state="translated">경우 &lt;em&gt;들&lt;/em&gt; 의 인스턴스 인 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , 다음 &lt;em&gt;캐릭터 세트는&lt;/em&gt; 문자열에서 문자의 문자 집합을 지정하는 힌트이다.</target>
        </trans-unit>
        <trans-unit id="c4b191218804654e28d488d61d7963e295b8ba38" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scheme&lt;/em&gt; is not an existing scheme, &lt;a href=&quot;#sysconfig.get_paths&quot;&gt;&lt;code&gt;get_paths()&lt;/code&gt;&lt;/a&gt; will raise a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;scheme&lt;/em&gt; 이 기존 &lt;em&gt;체계&lt;/em&gt; 가 아닌 경우 &lt;a href=&quot;#sysconfig.get_paths&quot;&gt; &lt;code&gt;get_paths()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="579ce2501f9bd2e51356cbfaa3d40376b9ab476a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scheme&lt;/em&gt; is not provided, will use the default scheme for the current platform.</source>
          <target state="translated">경우 &lt;em&gt;계획이&lt;/em&gt; 제공되지 않으며, 현재 플랫폼의 기본 방식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dcde2be3fbea710fd434bc34595dec1ea0f24076" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scheme&lt;/em&gt; is provided, it must be a value from the list returned by &lt;a href=&quot;#sysconfig.get_scheme_names&quot;&gt;&lt;code&gt;get_scheme_names()&lt;/code&gt;&lt;/a&gt;. Otherwise, the default scheme for the current platform is used.</source>
          <target state="translated">경우 &lt;em&gt;방식을&lt;/em&gt; 제공, 그것은에 의해 반환 된 목록에서 값이어야합니다 &lt;a href=&quot;#sysconfig.get_scheme_names&quot;&gt; &lt;code&gt;get_scheme_names()&lt;/code&gt; &lt;/a&gt; . 그렇지 않으면 현재 플랫폼의 기본 체계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e383345ed1ffb777fd51335060944d7c8849d95" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;secs&lt;/em&gt; is not provided or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the current time as returned by &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; is used. &lt;code&gt;ctime(secs)&lt;/code&gt; is equivalent to &lt;code&gt;asctime(localtime(secs))&lt;/code&gt;. Locale information is not used by &lt;a href=&quot;#time.ctime&quot;&gt;&lt;code&gt;ctime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;초이&lt;/em&gt; 제공되지 않거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 반환 된 현재 시간 &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 사용되지 않는다. &lt;code&gt;ctime(secs)&lt;/code&gt; 는 &lt;code&gt;asctime(localtime(secs))&lt;/code&gt; . 로케일 정보는 &lt;a href=&quot;#time.ctime&quot;&gt; &lt;code&gt;ctime()&lt;/code&gt; &lt;/a&gt; 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="52127174ed10907e5ff17d5141342c89e06f5f85" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;seed&lt;/em&gt; is given, creates a new instance of the underlying random number generator. This is useful for creating reproducible results, even in a multi-threading context.</source>
          <target state="translated">경우 &lt;em&gt;씨앗이&lt;/em&gt; 주어집니다, 기본 난수 생성기의 새 인스턴스를 만듭니다. 이는 다중 스레딩 컨텍스트에서도 재현 가능한 결과를 생성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4edab34fe0d303f2ab6c480c28b9df03c2bd34c0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;self&lt;/em&gt; is alive then mark it as dead and return the result of calling &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is dead then return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; 가 살아 있으면 죽은 것으로 표시하고 &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 호출 결과를 반환합니다 . &lt;em&gt;self&lt;/em&gt; 가 죽은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d5cc9d166c3fd7fa9f433e7f26249d72bf951f3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;self&lt;/em&gt; is alive then mark it as dead and return the tuple &lt;code&gt;(obj, func, args, kwargs)&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is dead then return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; 가 살아 있으면 죽은 것으로 표시하고 튜플 &lt;code&gt;(obj, func, args, kwargs)&lt;/code&gt; 반환하십시오 . &lt;em&gt;self&lt;/em&gt; 가 죽은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="d62395a4c8cd7edcdbc400ae85af1063602e83fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;self&lt;/em&gt; is alive then return the tuple &lt;code&gt;(obj, func, args,
kwargs)&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is dead then return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; 가 살아 있으면 튜플 &lt;code&gt;(obj, func, args, kwargs)&lt;/code&gt; 을 반환하십시오 . &lt;em&gt;self&lt;/em&gt; 가 죽은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c78e910291328954d1c689354013e70073a04fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, &lt;code&gt;'1,,2'.split(',')&lt;/code&gt; returns &lt;code&gt;['1', '', '2']&lt;/code&gt;). The &lt;em&gt;sep&lt;/em&gt; argument may consist of multiple characters (for example, &lt;code&gt;'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split('&amp;lt;&amp;gt;')&lt;/code&gt; returns &lt;code&gt;['1', '2', '3']&lt;/code&gt;). Splitting an empty string with a specified separator returns &lt;code&gt;['']&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월이&lt;/em&gt; 주어진 연속적인 분리는 그룹화하지 않으며를 단락 비어있는 스트링으로 간주된다 (예를 들어, &lt;code&gt;'1,,2'.split(',')&lt;/code&gt; 를 반환 &lt;code&gt;['1', '', '2']&lt;/code&gt; ). &lt;em&gt;9 월&lt;/em&gt; 인수는 복수의 문자로 구성 될 수있다 (예를 들면, &lt;code&gt;'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split('&amp;lt;&amp;gt;')&lt;/code&gt; 복귀 &lt;code&gt;['1', '2', '3']&lt;/code&gt; ). 지정된 구분 기호로 빈 문자열을 분할하면 &lt;code&gt;['']&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d32a65d384a22e7aca1e7f72f27cdc388ee1ce1e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, &lt;code&gt;b'1,,2'.split(b',')&lt;/code&gt; returns &lt;code&gt;[b'1', b'', b'2']&lt;/code&gt;). The &lt;em&gt;sep&lt;/em&gt; argument may consist of a multibyte sequence (for example, &lt;code&gt;b'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split(b'&amp;lt;&amp;gt;')&lt;/code&gt; returns &lt;code&gt;[b'1', b'2', b'3']&lt;/code&gt;). Splitting an empty sequence with a specified separator returns &lt;code&gt;[b'']&lt;/code&gt; or &lt;code&gt;[bytearray(b'')]&lt;/code&gt; depending on the type of object being split. The &lt;em&gt;sep&lt;/em&gt; argument may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월이&lt;/em&gt; 주어진다 연속 구분 기호가 함께 그룹화되지 않고, 예, 대한 (를 단락 빈 시퀀스로 간주됩니다 &lt;code&gt;b'1,,2'.split(b',')&lt;/code&gt; 반환 &lt;code&gt;[b'1', b'', b'2']&lt;/code&gt; ). &lt;em&gt;9 월&lt;/em&gt; 인수는 멀티 바이트 시퀀스로 구성 될 수있다 (예를 들면, &lt;code&gt;b'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split(b'&amp;lt;&amp;gt;')&lt;/code&gt; 복귀 &lt;code&gt;[b'1', b'2', b'3']&lt;/code&gt; ) . 지정된 구분 기호로 빈 시퀀스를 분할하면 분할되는 객체 유형에 따라 &lt;code&gt;[b'']&lt;/code&gt; 또는 &lt;code&gt;[bytearray(b'')]&lt;/code&gt; 반환 됩니다. &lt;em&gt;9 월&lt;/em&gt; 인수는있을 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf21781d7159ff06d30d7d7782c5cadffcfb73e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월가&lt;/em&gt; 지정되거나 없다되지 않는 &lt;code&gt;None&lt;/code&gt; 하나의 구분으로 간주된다 공백 연속 ASCII의 실행, 그리고 순서가 선행 또는 후행 공백 경우 결과는 시작 또는 끝 부분에 빈 문자열을 포함하지 않습니다 : 다른 분할 알고리즘이 적용됩니다. 결과적으로, 지정된 구분 기호없이 빈 시퀀스 또는 ASCII 공백으로 만 구성된 시퀀스를 분할하면 &lt;code&gt;[]&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="75815e1c039cef44f7ce05b27c1b9d61fa4ea0ed" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a &lt;code&gt;None&lt;/code&gt; separator returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월가&lt;/em&gt; 지정되거나 없다되지 &lt;code&gt;None&lt;/code&gt; 연속 공백의 실행은 하나의 구분으로 간주하고, 문자열이 선행 또는 후행 공백 경우 결과는 시작 또는 끝 부분에 빈 문자열을 포함하지 않습니다 : 다른 분할 알고리즘이 적용됩니다. 따라서 빈 문자열이나 공백만으로 구성된 문자열을 &lt;code&gt;None&lt;/code&gt; 구분 기호 로 분할하면 &lt;code&gt;[]&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="bacd7e201472689d45d2129900593e8ba53a276f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is specified, it must be a single character str or bytes object. It will be inserted in the output after every &lt;em&gt;bytes_per_sep&lt;/em&gt; input bytes. Separator placement is counted from the right end of the output by default, if you wish to count from the left, supply a negative &lt;em&gt;bytes_per_sep&lt;/em&gt; value.</source>
          <target state="translated">경우 &lt;em&gt;9월가&lt;/em&gt; 지정, 단일 문자 STR 또는 객체 바이트 여야합니다. 모든 &lt;em&gt;bytes_per_sep&lt;/em&gt; 입력 바이트 후에 출력에 삽입 됩니다. 구분자 배치는 기본적으로 출력의 오른쪽 끝에서 계산됩니다. 왼쪽에서 계산하려면 음수 &lt;em&gt;bytes_per_sep&lt;/em&gt; 값을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b2e53523b64aa1ece0f05f00001ffc33c683dfc6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;shallow&lt;/em&gt; is true, files with identical &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; signatures are taken to be equal. Otherwise, the contents of the files are compared.</source>
          <target state="translated">&lt;em&gt;shallow&lt;/em&gt; 가 true 인 경우 동일한 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 서명을 가진 파일은 동일합니다 . 그렇지 않으면 파일의 내용이 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="6a14ade8fc04b529f8c66e54b142b5f11123facc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;shell&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of &lt;code&gt;~&lt;/code&gt; to a user&amp;rsquo;s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, &lt;a href=&quot;glob#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;fnmatch#module-fnmatch&quot;&gt;&lt;code&gt;fnmatch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os#os.walk&quot;&gt;&lt;code&gt;os.walk()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os.path#os.path.expandvars&quot;&gt;&lt;code&gt;os.path.expandvars()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os.path#os.path.expanduser&quot;&gt;&lt;code&gt;os.path.expanduser()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;shutil#module-shutil&quot;&gt;&lt;code&gt;shutil&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;em&gt;쉘&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 지정된 명령은 쉘을 통해 실행됩니다. 이것은 대부분의 시스템 셸에서 제공하는 향상된 제어 흐름을 위해 Python을 주로 사용하면서 셸 파이프, 파일 이름 와일드 카드, 환경 변수 확장 및 사용자의 집 으로 &lt;code&gt;~&lt;/code&gt; 확장과 같은 다른 셸 기능에 편리하게 액세스하려는 경우 유용합니다. 예배 규칙서. 그러나 Python 자체는 많은 쉘과 같은 기능 (특히 &lt;a href=&quot;glob#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;fnmatch#module-fnmatch&quot;&gt; &lt;code&gt;fnmatch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os#os.walk&quot;&gt; &lt;code&gt;os.walk()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os.path#os.path.expandvars&quot;&gt; &lt;code&gt;os.path.expandvars()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os.path#os.path.expanduser&quot;&gt; &lt;code&gt;os.path.expanduser()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;shutil#module-shutil&quot;&gt; &lt;code&gt;shutil&lt;/code&gt; &lt;/a&gt; )의 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c3fabb4f0dfc614531e56476a132b5752f344c2f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;side_effect&lt;/em&gt; is an iterable then each call to the mock will return the next value from the iterable.</source>
          <target state="translated">&lt;em&gt;side_effect&lt;/em&gt; 가 iterable 인 경우 &lt;em&gt;mock&lt;/em&gt; 에 대한 각 호출은 iterable에서 다음 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32d4906d1c181de707adccc5361aecabb724997b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sigma&lt;/em&gt; is negative, raises &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;시그마는&lt;/em&gt; 음수, 제기 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84a4b0f24b46c93f18da5c06f6ae94445c0fe2cf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;signalnum&lt;/em&gt; is 0, then no signal is sent, but error checking is still performed; this can be used to check if the target thread is still running.</source>
          <target state="translated">경우 &lt;em&gt;signalnum이&lt;/em&gt; 0, 후 아무런 신호도 전송되지 않고, 오류 검사가 여전히 수행된다; 대상 스레드가 여전히 실행 중인지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8a8c085c8f93c34a62d1f5006e023a789d7f748" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;size&lt;/em&gt; is &lt;code&gt;-1&lt;/code&gt; (the default), an arbitrary number of bytes are returned (more than zero unless EOF is reached).</source>
          <target state="translated">경우 &lt;em&gt;크기&lt;/em&gt; 입니다 &lt;code&gt;-1&lt;/code&gt; (기본), 바이트의 임의의 수는 (EOF 않는 이상 제로에 도달) 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="783061ee6ebe0a3e848628b0e39a754d7f845bd2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;size&lt;/em&gt; is specified, at most &lt;em&gt;size&lt;/em&gt; characters will be read.</source>
          <target state="translated">경우 &lt;em&gt;크기가&lt;/em&gt; 지정되어, 기껏 &lt;em&gt;크기의&lt;/em&gt; 문자를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="847d50bbad63ed5c73adc70a9729f398c1c78b9f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;skip_curdir&lt;/em&gt; is true (the default), the current directory is not included in the search. All other parameters are passed to the &lt;a href=&quot;#compileall.compile_dir&quot;&gt;&lt;code&gt;compile_dir()&lt;/code&gt;&lt;/a&gt; function. Note that unlike the other compile functions, &lt;code&gt;maxlevels&lt;/code&gt; defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;skip_curdir가&lt;/em&gt; true (디폴트), 현재 디렉토리는 검색에 포함되지 않습니다. 다른 모든 매개 변수는 &lt;a href=&quot;#compileall.compile_dir&quot;&gt; &lt;code&gt;compile_dir()&lt;/code&gt; &lt;/a&gt; 함수 로 전달됩니다 . 다른 컴파일 함수와 달리 &lt;code&gt;maxlevels&lt;/code&gt; 의 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1622612acffaa08ff5b0ba0489c4b9b99e2215a3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;skipkeys&lt;/em&gt; is false (the default), then it is a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; to attempt encoding of keys that are not &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;None&lt;/code&gt;. If &lt;em&gt;skipkeys&lt;/em&gt; is true, such items are simply skipped.</source>
          <target state="translated">경우 &lt;em&gt;skipkeys가&lt;/em&gt; false (기본값)이며, 다음은입니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 없는 키의 인코딩을 시도하는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;None&lt;/code&gt; . 경우 &lt;em&gt;skipkeys는&lt;/em&gt; 사실, 같은 항목은 단순히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fdad7b18b91cc5adf5f82da39ab59d5d78a1ecfd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;skipkeys&lt;/em&gt; is true (default: &lt;code&gt;False&lt;/code&gt;), then dict keys that are not of a basic type (&lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt;) will be skipped instead of raising a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;skipkeys이&lt;/em&gt; 참 (기본 : 인 &lt;code&gt;False&lt;/code&gt; ), 다음 기본 유형 (의 아닌 DICT 키 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;None&lt;/code&gt; ) 대신에 양육의 생략됩니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="919e52d14550425c25e9a8891929227e5c2b4b36" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sort_keys&lt;/em&gt; is true (default: &lt;code&gt;False&lt;/code&gt;), then the output of dictionaries will be sorted by key.</source>
          <target state="translated">경우 &lt;em&gt;sort_keys이&lt;/em&gt; 참 (기본 : 인 &lt;code&gt;False&lt;/code&gt; ), 다음 사전의 출력은 키에 의해 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="141cc93734b2806ef0b422eaafd25c2a3bb5717d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sort_keys&lt;/em&gt; is true (default: &lt;code&gt;False&lt;/code&gt;), then the output of dictionaries will be sorted by key; this is useful for regression tests to ensure that JSON serializations can be compared on a day-to-day basis.</source>
          <target state="translated">경우 &lt;em&gt;sort_keys이&lt;/em&gt; 참 (기본 : 인 &lt;code&gt;False&lt;/code&gt; ), 다음 사전의 출력은 키에 의해 정렬됩니다; 이는 JSON 직렬화를 매일 비교할 수 있도록 회귀 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0ec4d3670001eb4630add8e5d77a6b7f8a38307e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;source&lt;/em&gt; is a directory, this will create an archive from the contents of &lt;em&gt;source&lt;/em&gt;. If &lt;em&gt;source&lt;/em&gt; is a file, it should be an archive, and it will be copied to the target archive (or the contents of its shebang line will be displayed if the &amp;ndash;info option is specified).</source>
          <target state="translated">경우 &lt;em&gt;소스&lt;/em&gt; 디렉토리이며,이 내용에서 아카이브 만듭니다 &lt;em&gt;소스를&lt;/em&gt; . 경우 &lt;em&gt;소스&lt;/em&gt; 파일이, 그것은 보관해야하며합니다 (-info 옵션이 지정된 경우 표시됩니다 또는 오두막 라인의 내용) 대상 아카이브에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="dd866a51c1af75263cc3da023ee73b4ff52a8f3f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spec&lt;/em&gt; is an object (rather than a list of strings) then &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt;&lt;code&gt;__class__&lt;/code&gt;&lt;/a&gt; returns the class of the spec object. This allows mocks to pass &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">&lt;em&gt;spec&lt;/em&gt; 이 문자열 목록이 아닌 객체 인 경우 &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt; &lt;code&gt;__class__&lt;/code&gt; &lt;/a&gt; 는 spec 객체의 클래스를 반환합니다. 이를 통해 모의가 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 테스트 를 통과 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e430ec45184814b7e3a5423aaa67762e8ff2ee26" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spec_set&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; then attempting to set attributes that don&amp;rsquo;t exist on the spec object will raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;spec_set&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 spec 객체에없는 속성을 설정하려고하면 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="afed44ee7ef600b461a700a3398505683d4ea66e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spec_set&lt;/em&gt; is true then only attributes on the spec can be set.</source>
          <target state="translated">경우 &lt;em&gt;spec_set는&lt;/em&gt; 사실 만 사양을 설정할 수 있습니다에 속성.</target>
        </trans-unit>
        <trans-unit id="e7a8ce63e7abc528992721347309573385b89984" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;start&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, then iteration starts at zero. If &lt;em&gt;step&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, then the step defaults to one.</source>
          <target state="translated">경우 &lt;em&gt;시작은&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 다음 반복은 0에서 시작. 경우 &lt;em&gt;단계는&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 하나 다음 단계로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="24863e0f029a6a7992cca82f7b21086bad27e744" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;start_new_session&lt;/em&gt; is true the setsid() system call will be made in the child process prior to the execution of the subprocess. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;start_new_session는&lt;/em&gt; 사실이다 setsid () 시스템 호출은 서브 프로세스의 실행 이전에 자식 프로세스에서 이루어집니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="dae10e2b8108370fbc36f3fb951b2b6fcfa7ee03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;state&lt;/em&gt; is specified, it is expected to be a sequence of one or more states. If the &lt;em&gt;default&lt;/em&gt; argument is set, it is used as a fallback value in case no specification for option is found.</source>
          <target state="translated">경우 &lt;em&gt;상태가&lt;/em&gt; 지정되어, 하나 개 이상의 상태의 순서가 될 것으로 예상된다. 경우 &lt;em&gt;기본&lt;/em&gt; 인수를 설정, 그것은 옵션에 대한 사양을 찾을 수없는 경우에 대체 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03eb4116ba9791728aa443f40f34198f5e04395f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; and host bits are set in the supplied address, then &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. Otherwise, the host bits are masked out to determine the appropriate network address.</source>
          <target state="translated">경우 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; 호스트 비트가 제공된 주소를 설정 한 다음 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 발생합니다. 그렇지 않으면 호스트 비트가 마스킹되어 적절한 네트워크 주소를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="973cfc980a368126ab372341f5a82f90bd2ace1b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, information will be added to list of standard types, else to the list of non-standard types.</source>
          <target state="translated">경우 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 정보는 다른 표준이 아닌 유형의 목록에 표준 유형의 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c63d58de5c2b785bb280134953605f32b3e0b06f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, information will be added to the list of standard types, else to the list of non-standard types.</source>
          <target state="translated">경우 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 정보는 다른 표준이 아닌 유형의 목록에 표준 유형의 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="59fa67b55f66822993cd529b9e43d4b11387a896" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is false (&lt;code&gt;True&lt;/code&gt; is the default), then control characters will be allowed inside strings. Control characters in this context are those with character codes in the 0&amp;ndash;31 range, including &lt;code&gt;'\t'&lt;/code&gt; (tab), &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt; and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;strict&lt;/em&gt; 가 false 인 경우 ( &lt;code&gt;True&lt;/code&gt; 가 기본값 임) 문자열 내에서 제어 문자가 허용됩니다. 이 컨텍스트에서 제어 문자는 &lt;code&gt;'\t'&lt;/code&gt; (탭), &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 및 &lt;code&gt;'\0'&lt;/code&gt; 포함하여 0-31 범위의 문자 코드가있는 제어 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="00bb41b8d4ff338b7ff04695279e77d2e3c93ebd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;suffix&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the file name will end with that suffix, otherwise there will be no suffix. &lt;a href=&quot;#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt; does not put a dot between the file name and the suffix; if you need one, put it at the beginning of &lt;em&gt;suffix&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;접미사&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 파일 이름은 해당 접미사로 끝나고 그렇지 않으면 접미사가 없습니다. &lt;a href=&quot;#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; 는 파일 이름과 접미사 사이에 점을 넣지 않습니다. 필요한 경우 &lt;em&gt;접미사&lt;/em&gt; 시작 부분에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="13150c99ab21ad6513149f3afd00516abf1afabf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;symlinks&lt;/em&gt; is true, symbolic links in the source tree are represented as symbolic links in the new tree and the metadata of the original links will be copied as far as the platform allows; if false or omitted, the contents and metadata of the linked files are copied to the new tree.</source>
          <target state="translated">경우 &lt;em&gt;심볼릭 링크는&lt;/em&gt; 사실, 소스 트리의 심볼릭 링크는 플랫폼이 허용까지 복사 될 새 트리 원래 링크의 메타 데이터에 심볼릭 링크로 표시됩니다; false이거나 생략되면 링크 된 파일의 내용 및 메타 데이터가 새 트리에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="790a7891dbe26c0d182cc188c6888155d0da69dc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;t&lt;/em&gt; is not provided, the current time as returned by &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; is used. Locale information is not used by &lt;a href=&quot;#time.asctime&quot;&gt;&lt;code&gt;asctime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하면 &lt;em&gt;t가&lt;/em&gt; 제공되지 않고, 반환 된 현재 시간 &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 사용된다. 로케일 정보는 &lt;a href=&quot;#time.asctime&quot;&gt; &lt;code&gt;asctime()&lt;/code&gt; &lt;/a&gt; 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="02d5c93f7a324aa5bde0984e4ba37a751a5f3a3c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;tests&lt;/em&gt; is given, it must be an iterable of individual test cases or other test suites that will be used to build the suite initially. Additional methods are provided to add test cases and suites to the collection later on.</source>
          <target state="translated">경우 &lt;em&gt;테스트가&lt;/em&gt; 주어집니다, 그것은 처음 제품군을 구축하는 데 사용됩니다 개별 테스트 케이스 또는 다른 테스트 스위트의 반복 가능한해야합니다. 나중에 테스트 케이스 및 스위트를 콜렉션에 추가하기위한 추가 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="32cd3e51c090a1bc9065f8c1d01729be7286d1ed" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;text&lt;/em&gt; is specified, it indicates whether to open the file in binary mode (the default) or text mode. On some platforms, this makes no difference.</source>
          <target state="translated">경우 &lt;em&gt;텍스트가&lt;/em&gt; 지정되어, 그것은 바이너리 모드 (기본값) 또는 텍스트 모드에서 파일을 열 수 있는지 여부를 나타냅니다. 일부 플랫폼에서는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4559c7dea064e6ee3c47db167d23f484bc1c7d3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;themename&lt;/em&gt; is not given, returns the theme in use. Otherwise, sets the current theme to &lt;em&gt;themename&lt;/em&gt;, refreshes all widgets and emits a &amp;lt;&amp;lt;ThemeChanged&amp;gt;&amp;gt; event.</source>
          <target state="translated">경우 &lt;em&gt;THEMENAME가&lt;/em&gt; 주어지지 않는, 사용중인 테마를 반환합니다. 그렇지 않으면 현재 테마를 &lt;em&gt;themename으로&lt;/em&gt; 설정하고 모든 위젯을 새로 고치고 &amp;lt;&amp;lt; ThemeChanged &amp;gt;&amp;gt; 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="28532016ce2dec2f43f2440bb50823bc42171d6a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;time&lt;/em&gt; is non-zero, this function requests that a &lt;code&gt;SIGALRM&lt;/code&gt; signal be sent to the process in &lt;em&gt;time&lt;/em&gt; seconds. Any previously scheduled alarm is canceled (only one alarm can be scheduled at any time). The returned value is then the number of seconds before any previously set alarm was to have been delivered. If &lt;em&gt;time&lt;/em&gt; is zero, no alarm is scheduled, and any scheduled alarm is canceled. If the return value is zero, no alarm is currently scheduled.</source>
          <target state="translated">경우 &lt;em&gt;시간은&lt;/em&gt; 비 - 제로하는 것이이 기능 요청 인 &lt;code&gt;SIGALRM&lt;/code&gt; 의 신호의 처리로 보낼 수 &lt;em&gt;시간&lt;/em&gt; 초. 이전에 예약 된 알람은 취소됩니다 (언제든지 하나의 알람 만 예약 할 수 있음). 반환 된 값은 이전에 설정된 알람이 전달되기 전의 시간 (초)입니다. 경우 &lt;em&gt;시간&lt;/em&gt; 제로, 더 알람이 예정되지 않으며, 예약 된 알람이 취소됩니다. 반환 값이 0이면 현재 예약 된 알람이 없습니다.</target>
        </trans-unit>
        <trans-unit id="497079b5b5c0bcfc850eb270a835cdeff89fcdd1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;timeout&lt;/em&gt; is not specified then it will return immediately. If &lt;em&gt;timeout&lt;/em&gt; is a number then this specifies the maximum time in seconds to block. If &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; then an infinite timeout is used.</source>
          <target state="translated">경우 &lt;em&gt;타임 아웃이&lt;/em&gt; 지정되지 즉시 반환합니다. 경우 &lt;em&gt;타임 아웃&lt;/em&gt; 후 수 초 블록이 지정되는 최대 시간이다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 후 무한 시간 제한이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="38330b7243617ce7e169c4b1ec03b6f57cadf500" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;times&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;em&gt;ns&lt;/em&gt; is unspecified, this is equivalent to specifying &lt;code&gt;ns=(atime_ns, mtime_ns)&lt;/code&gt; where both times are the current time.</source>
          <target state="translated">경우 &lt;em&gt;시간이&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; 및 &lt;em&gt;NS를&lt;/em&gt; 지정하고,이 지정에 해당 &lt;code&gt;ns=(atime_ns, mtime_ns)&lt;/code&gt; 두 시간은 현재 시간이다.</target>
        </trans-unit>
        <trans-unit id="8db77a303cd49acf6960de74cc642fc8c3611507" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;times&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a 2-tuple of the form &lt;code&gt;(atime, mtime)&lt;/code&gt; where each member is an int or float expressing seconds.</source>
          <target state="translated">&lt;em&gt;times&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 각 멤버가 int 또는 float 표현 초인 2 개의 형식 &lt;code&gt;(atime, mtime)&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="347e1c7b8f66668341af1aa8af2cae34d5219df5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;typed&lt;/em&gt; is set to true, function arguments of different types will be cached separately. For example, &lt;code&gt;f(3)&lt;/code&gt; and &lt;code&gt;f(3.0)&lt;/code&gt; will be treated as distinct calls with distinct results.</source>
          <target state="translated">&lt;em&gt;typed&lt;/em&gt; 가 true로 설정 되면 다른 유형의 함수 인수가 별도로 캐시됩니다. 예를 들어, &lt;code&gt;f(3)&lt;/code&gt; 및 &lt;code&gt;f(3.0)&lt;/code&gt; 은 별개의 결과를 가진 별개의 호출로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="35713c7d2a1b17f3adfee94e67fe51913e45bad5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;tz&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass, and the current date and time are converted to &lt;em&gt;tz&lt;/em&gt;&amp;rsquo;s time zone.</source>
          <target state="translated">&lt;em&gt;tz&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 여야하며 현재 날짜와 시간이 &lt;em&gt;tz&lt;/em&gt; 의 시간대 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="260c901c4e473510ed15a11c2c9dd83021ee8189" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;tz&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass, and the timestamp is converted to &lt;em&gt;tz&lt;/em&gt;&amp;rsquo;s time zone.</source>
          <target state="translated">&lt;em&gt;tz&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 여야하며 타임 스탬프는 &lt;em&gt;tz&lt;/em&gt; 의 시간대 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a43748fde1efea83cc1d49bf1dde82fa0eb165d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;unixfrom&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, print the envelope header delimiter used by the Unix mailbox format (see &lt;a href=&quot;mailbox#module-mailbox&quot;&gt;&lt;code&gt;mailbox&lt;/code&gt;&lt;/a&gt;) before the first of the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; headers of the root message object. If the root object has no envelope header, craft a standard one. The default is &lt;code&gt;False&lt;/code&gt;. Note that for subparts, no envelope header is ever printed.</source>
          <target state="translated">경우 &lt;em&gt;unixfrom가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 유닉스 사서함 형식 (참조가 사용하는 봉투 헤더 구분 기호 인쇄 &lt;a href=&quot;mailbox#module-mailbox&quot;&gt; &lt;code&gt;mailbox&lt;/code&gt; &lt;/a&gt; 의 첫 번째 전) &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 루트 메시지 개체의 헤더를. 루트 개체에 봉투 헤더가 없으면 표준 헤더를 만듭니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. 하위 부품의 경우 봉투 헤더가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09ee2106f178148b8593077159fed634361f4c90" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;unixfrom&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, print the envelope header delimiter used by the Unix mailbox format (see &lt;a href=&quot;mailbox#module-mailbox&quot;&gt;&lt;code&gt;mailbox&lt;/code&gt;&lt;/a&gt;) before the first of the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; headers of the root message object. If the root object has no envelope header, craft a standard one. The default is &lt;code&gt;False&lt;/code&gt;. Note that for subparts, no envelope header is ever printed.</source>
          <target state="translated">경우 &lt;em&gt;unixfrom가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 유닉스 사서함 형식 (참조가 사용하는 봉투 헤더 구분 기호 인쇄 &lt;a href=&quot;mailbox#module-mailbox&quot;&gt; &lt;code&gt;mailbox&lt;/code&gt; &lt;/a&gt; 의 첫 번째 전) &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 루트 메시지 개체의 헤더를. 루트 개체에 봉투 헤더가 없으면 표준 헤더를 만듭니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. 하위 부품의 경우 봉투 헤더가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="564c391e2eea7b00e0d4511879cbcfaf5a4d8d17" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;uri&lt;/em&gt; is true, &lt;em&gt;database&lt;/em&gt; is interpreted as a URI. This allows you to specify options. For example, to open a database in read-only mode you can use:</source>
          <target state="translated">경우 &lt;em&gt;URI는&lt;/em&gt; 사실, &lt;em&gt;데이터베이스&lt;/em&gt; 는 URI로 해석됩니다. 옵션을 지정할 수 있습니다. 예를 들어, 데이터베이스를 읽기 전용 모드로 열려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92ee0e1dd0fe08e277eb2f16cc058b3ac9c272b9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; contains a fragment identifier, return a modified version of &lt;em&gt;url&lt;/em&gt; with no fragment identifier, and the fragment identifier as a separate string. If there is no fragment identifier in &lt;em&gt;url&lt;/em&gt;, return &lt;em&gt;url&lt;/em&gt; unmodified and an empty string.</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; 부분 식별자를 포함, 수정 된 버전의 반환 &lt;em&gt;URL을&lt;/em&gt; 어떤 조각 식별자, 별도의 문자열로 조각 식별자. &lt;em&gt;url에&lt;/em&gt; 조각 식별자가 없으면 수정되지 않은 &lt;em&gt;url&lt;/em&gt; 과 빈 문자열을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="35a93d83feb3c7efc87442bcc3ea9ca48667e136" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; is an absolute URL (that is, starting with &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;scheme://&lt;/code&gt;), the &lt;em&gt;url&lt;/em&gt;&amp;rsquo;s host name and/or scheme will be present in the result. For example:</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; (로 시작이며, 절대 URL입니다 &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;scheme://&lt;/code&gt; )에 &lt;em&gt;URL이&lt;/em&gt; 의 호스트 이름 및 / 또는 방식은 결과에있을 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d52da6544fdd2712a853ec73945e433591662e8f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;use_builtin_types&lt;/em&gt; is true (the default) binary data will be returned as instances of &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, otherwise it is returned as instances of &lt;a href=&quot;#plistlib.Data&quot;&gt;&lt;code&gt;Data&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;use_builtin_types이&lt;/em&gt; 참 (기본) 바이너리 데이터의 인스턴스로 반환됩니다 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 그렇지 않으면 인스턴스로 반환됩니다, &lt;a href=&quot;#plistlib.Data&quot;&gt; &lt;code&gt;Data&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a9f1ac8559eac5c86eefcea83c87b1263668062" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;user_function&lt;/em&gt; is specified, it must be a callable. This allows the &lt;em&gt;lru_cache&lt;/em&gt; decorator to be applied directly to a user function, leaving the &lt;em&gt;maxsize&lt;/em&gt; at its default value of 128:</source>
          <target state="translated">경우 &lt;em&gt;user_function가&lt;/em&gt; 지정되어, 그것은 호출해야합니다. 이를 통해 &lt;em&gt;lru_cache&lt;/em&gt; 데코레이터를 사용자 함수에 직접 적용 할 수 있으며 &lt;em&gt;maxsize&lt;/em&gt; 의 기본값은 128입니다.</target>
        </trans-unit>
        <trans-unit id="a9352d72ddc99ca448cdec42d9f75b91943270d1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;validate&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default), characters that are neither in the normal base-64 alphabet nor the alternative alphabet are discarded prior to the padding check. If &lt;em&gt;validate&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, these non-alphabet characters in the input result in a &lt;a href=&quot;binascii#binascii.Error&quot;&gt;&lt;code&gt;binascii.Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;유효성 검사가&lt;/em&gt; 있습니다 &lt;code&gt;False&lt;/code&gt; (기본), 일반베이스 (64) 알파벳이나 다른 알파벳에 어느 쪽도없는 문자는 패딩 검사 이전에 삭제됩니다. &lt;em&gt;validate&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 입력에서 알파벳이 아닌 문자는 &lt;a href=&quot;binascii#binascii.Error&quot;&gt; &lt;code&gt;binascii.Error&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="041b397f09c0fc84d045447fef90474b85a692b7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;value&lt;/em&gt; is a &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, &lt;code&gt;Decimal(float('1.1'))&lt;/code&gt; converts to &lt;code&gt;Decimal('1.100000000000000088817841970012523233890533447265625')&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;값이&lt;/em&gt; A는 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , 이진 부동 소수점 값은 손실없이 정확한 진수 동등한로 변환됩니다. 이 변환에는 종종 53 자리 이상의 정밀도가 필요할 수 있습니다. 예를 들어, &lt;code&gt;Decimal(float('1.1'))&lt;/code&gt; 은 &lt;code&gt;Decimal('1.100000000000000088817841970012523233890533447265625')&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="16a5fca024ec28b87ad8022c2ff864fdc8a9edce" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;value&lt;/em&gt; is a &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt;, it should have three components, a sign (&lt;code&gt;0&lt;/code&gt; for positive or &lt;code&gt;1&lt;/code&gt; for negative), a &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; of digits, and an integer exponent. For example, &lt;code&gt;Decimal((0, (1, 4, 1, 4), -3))&lt;/code&gt; returns &lt;code&gt;Decimal('1.414')&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;값&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; , 그 세 가지 구성 요소 (부호 있어야 &lt;code&gt;0&lt;/code&gt; 포지티브 또는 &lt;code&gt;1&lt;/code&gt; 네거티브)하는 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 숫자 및 정수 지수. 예를 들어 &lt;code&gt;Decimal((0, (1, 4, 1, 4), -3))&lt;/code&gt; 은 &lt;code&gt;Decimal('1.414')&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6a26098b49583f3821ec64d052c3aa7592a7689" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;value&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, this function prints &lt;code&gt;repr(value)&lt;/code&gt; to &lt;code&gt;sys.stdout&lt;/code&gt;, and saves &lt;em&gt;value&lt;/em&gt; in &lt;code&gt;builtins._&lt;/code&gt;. If &lt;code&gt;repr(value)&lt;/code&gt; is not encodable to &lt;code&gt;sys.stdout.encoding&lt;/code&gt; with &lt;code&gt;sys.stdout.errors&lt;/code&gt; error handler (which is probably &lt;code&gt;'strict'&lt;/code&gt;), encode it to &lt;code&gt;sys.stdout.encoding&lt;/code&gt; with &lt;code&gt;'backslashreplace'&lt;/code&gt; error handler.</source>
          <target state="translated">경우 &lt;em&gt;값은&lt;/em&gt; 아니다되지 &lt;code&gt;None&lt;/code&gt; 이 함수를 인쇄 &lt;code&gt;repr(value)&lt;/code&gt; 에 &lt;code&gt;sys.stdout&lt;/code&gt; 는 한 저장 &lt;em&gt;값&lt;/em&gt; 에 &lt;code&gt;builtins._&lt;/code&gt; . 경우 &lt;code&gt;repr(value)&lt;/code&gt; 에 encodable하지 &lt;code&gt;sys.stdout.encoding&lt;/code&gt; 와 &lt;code&gt;sys.stdout.errors&lt;/code&gt; 의 (아마 인 오류 처리기 &lt;code&gt;'strict'&lt;/code&gt; 에, 인코딩을) &lt;code&gt;sys.stdout.encoding&lt;/code&gt; 와 &lt;code&gt;'backslashreplace'&lt;/code&gt; 오류 처리기가.</target>
        </trans-unit>
        <trans-unit id="b6c068a3fde871a0618297833b8d4828d3974011" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;vars&lt;/em&gt; is provided, it must be a dictionary of variables that will update the dictionary return by &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt;&lt;code&gt;get_config_vars()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;vars&lt;/em&gt; 가 제공되는 경우 &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt; &lt;code&gt;get_config_vars()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 사전을 업데이트 할 변수의 사전이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8460fba468dd9bc7ed1d9f47454b97a770706f8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;vars&lt;/em&gt; is provided, it must be a dictionary of variables that will update the dictionary used to expand the paths.</source>
          <target state="translated">&lt;em&gt;vars&lt;/em&gt; 가 제공되는 경우 경로를 확장하는 데 사용되는 사전을 업데이트하는 변수의 사전이어야합니다.</target>
        </trans-unit>
        <trans-unit id="65259ad55e207c66c56ade920231ad288fcf9123" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;verbosity&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;doctest#doctest.testmod&quot;&gt;&lt;code&gt;doctest.testmod()&lt;/code&gt;&lt;/a&gt; is run with verbosity set to &lt;a href=&quot;#test.support.verbose&quot;&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/a&gt;. Otherwise, it is run with verbosity set to &lt;code&gt;None&lt;/code&gt;. &lt;em&gt;optionflags&lt;/em&gt; is passed as &lt;code&gt;optionflags&lt;/code&gt; to &lt;a href=&quot;doctest#doctest.testmod&quot;&gt;&lt;code&gt;doctest.testmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;상세가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;doctest#doctest.testmod&quot;&gt; &lt;code&gt;doctest.testmod()&lt;/code&gt; &lt;/a&gt; 에 상세 설정으로 실행됩니다 &lt;a href=&quot;#test.support.verbose&quot;&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/a&gt; . 그렇지 않으면, 상세가 &lt;code&gt;None&lt;/code&gt; 으로 설정된 상태로 실행됩니다 . &lt;em&gt;optionflags&lt;/em&gt; 는 &lt;code&gt;optionflags&lt;/code&gt; 로 &lt;a href=&quot;doctest#doctest.testmod&quot;&gt; &lt;code&gt;doctest.testmod()&lt;/code&gt; &lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="942606e11a16e77c16cf6f2083e90d213368e12c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;wait&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; then this method will not return until all the pending futures are done executing and the resources associated with the executor have been freed. If &lt;em&gt;wait&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then this method will return immediately and the resources associated with the executor will be freed when all pending futures are done executing. Regardless of the value of &lt;em&gt;wait&lt;/em&gt;, the entire Python program will not exit until all pending futures are done executing.</source>
          <target state="translated">경우 &lt;em&gt;대기가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; 모든 보류중인 미래가 실행 완료 및 집행과 관련된 자원이 해제 될 때까지이 메서드는 반환하지 않습니다. 경우 &lt;em&gt;대기가&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 이 메소드는 즉시 반환하고 대기중인 모든 선물 실행이 완료되면 집행자와 관련된 자원이 해제됩니다. &lt;em&gt;wait&lt;/em&gt; 값에 관계없이 모든 보류중인 선물이 실행을 완료 할 때까지 전체 Python 프로그램이 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c093aaca359d099d06e48dc626af24bc9190ff1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;write_through&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, calls to &lt;code&gt;write()&lt;/code&gt; are guaranteed not to be buffered: any data written on the &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt; object is immediately handled to its underlying binary &lt;em&gt;buffer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;write_through&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;write()&lt;/code&gt; 호출 은 버퍼링되지 않습니다. &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; 객체 에 작성된 모든 데이터 는 즉시 기본 이진 &lt;em&gt;버퍼로&lt;/em&gt; 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eabe5555eb349dd57c749df6fcb8345ed8d6ff8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is not a number or if &lt;em&gt;base&lt;/em&gt; is given, then &lt;em&gt;x&lt;/em&gt; must be a string, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; instance representing an &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#integers&quot;&gt;integer literal&lt;/a&gt; in radix &lt;em&gt;base&lt;/em&gt;. Optionally, the literal can be preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; (or &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;Z&lt;/code&gt;) having values 10 to 35. The default &lt;em&gt;base&lt;/em&gt; is 10. The allowed values are 0 and 2&amp;ndash;36. Base-2, -8, and -16 literals can be optionally prefixed with &lt;code&gt;0b&lt;/code&gt;/&lt;code&gt;0B&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt;/&lt;code&gt;0O&lt;/code&gt;, or &lt;code&gt;0x&lt;/code&gt;/&lt;code&gt;0X&lt;/code&gt;, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that &lt;code&gt;int('010', 0)&lt;/code&gt; is not legal, while &lt;code&gt;int('010')&lt;/code&gt; is, as well as &lt;code&gt;int('010', 8)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;x는&lt;/em&gt; 숫자가 아닌 경우, 또는 &lt;em&gt;기초가&lt;/em&gt; 지정되고있는 경우, &lt;em&gt;x는&lt;/em&gt; 문자열이어야합니다, &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 인스턴스는 나타내는 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#integers&quot;&gt;정수 리터럴&lt;/a&gt; 의 기수 &lt;em&gt;기반을&lt;/em&gt; . 선택적으로 리터럴 앞에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; (공백 없음)가 있고 공백으로 둘러 쌀 수 있습니다. 베이스-N 리터럴와, N-1에있는 숫자 0 구성 에 &lt;code&gt;z&lt;/code&gt; (또는 에 &lt;code&gt;Z&lt;/code&gt; 기본 10 (35))을 갖는 값을 &lt;em&gt;기지&lt;/em&gt; 허용되는 값은 0이다 10. 2-36이다. Base-2, -8 및 -16 리터럴은 선택적으로 &lt;code&gt;0b&lt;/code&gt; 접두어를 붙일 수 있습니다 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;em&gt;&lt;/em&gt;코드의 정수 리터럴과 마찬가지로 / &lt;code&gt;0B&lt;/code&gt; , &lt;code&gt;0o&lt;/code&gt; / &lt;code&gt;0O&lt;/code&gt; 또는 &lt;code&gt;0x&lt;/code&gt; / &lt;code&gt;0X&lt;/code&gt; 밑수 0은 코드 리터럴로 정확하게 해석하여 실제 밑 수가 2, 8, 10 또는 16이고 &lt;code&gt;int('010', 0)&lt;/code&gt; 가 유효하지 않고 &lt;code&gt;int('010')&lt;/code&gt; 가 뿐만 아니라 &lt;code&gt;int('010', 8)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ca00c56cdce0b10d4e7ca75f4203a4d4dbe4b3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;y&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;em&gt;x&lt;/em&gt; must be a pair of coordinates or a &lt;a href=&quot;#turtle.Vec2D&quot;&gt;&lt;code&gt;Vec2D&lt;/code&gt;&lt;/a&gt; (e.g. as returned by &lt;a href=&quot;#turtle.pos&quot;&gt;&lt;code&gt;pos()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;em&gt;y는&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , &lt;em&gt;X는&lt;/em&gt; 좌표의 쌍 또는이어야 &lt;a href=&quot;#turtle.Vec2D&quot;&gt; &lt;code&gt;Vec2D&lt;/code&gt; &lt;/a&gt; (예에 의해 반환되는 &lt;a href=&quot;#turtle.pos&quot;&gt; &lt;code&gt;pos()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fdae1f0f9315700b86b3f53ba94aa3d7efe1b994" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;zdict&lt;/em&gt; is a mutable object (such as a &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;), you must not modify its contents between the call to &lt;a href=&quot;#zlib.decompressobj&quot;&gt;&lt;code&gt;decompressobj()&lt;/code&gt;&lt;/a&gt; and the first call to the decompressor&amp;rsquo;s &lt;code&gt;decompress()&lt;/code&gt; method.</source>
          <target state="translated">경우 &lt;em&gt;zdict는&lt;/em&gt; (예 :로 변경 가능한 객체 인 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ), 당신은 호출 사이에 그 내용을 수정해서는 안 &lt;a href=&quot;#zlib.decompressobj&quot;&gt; &lt;code&gt;decompressobj()&lt;/code&gt; &lt;/a&gt; 와 압축의 첫 번째 호출 &lt;code&gt;decompress()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="98b6444e6bf4fa2e7a824739c1040724489b08e5" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;name&lt;/strong&gt; has no leading dots, then &lt;strong&gt;name&lt;/strong&gt; is simply returned. This allows for usage such as &lt;code&gt;importlib.util.resolve_name('sys', __package__)&lt;/code&gt; without doing a check to see if the &lt;strong&gt;package&lt;/strong&gt; argument is needed.</source>
          <target state="translated">경우 &lt;strong&gt;이름은&lt;/strong&gt; 선두에 도트가 없습니다, 다음 &lt;strong&gt;이름은&lt;/strong&gt; 단순히 반환됩니다. 이를 통해 &lt;strong&gt;package&lt;/strong&gt; 인수가 필요한지 확인하지 않고도 &lt;code&gt;importlib.util.resolve_name('sys', __package__)&lt;/code&gt; 과 같은 사용이 가능 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4184d0852443b8deb67c16f50527b5c78f15fd7" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;name&lt;/strong&gt; is for a submodule (contains a dot), the parent module is automatically imported.</source>
          <target state="translated">&lt;strong&gt;이름&lt;/strong&gt; 이 하위 모듈의 &lt;strong&gt;이름 인&lt;/strong&gt; 경우 (점 포함) 상위 모듈을 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a96ea5a5013dd3fe9b6e8602e6df4e7d733e2d24" translate="yes" xml:space="preserve">
          <source>If EOF is reached before the complete separator is found, an &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError&quot;&gt;&lt;code&gt;IncompleteReadError&lt;/code&gt;&lt;/a&gt; exception is raised, and the internal buffer is reset. The &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError.partial&quot;&gt;&lt;code&gt;IncompleteReadError.partial&lt;/code&gt;&lt;/a&gt; attribute may contain a portion of the separator.</source>
          <target state="translated">완전한 분리 기호를 찾기 전에 EOF에 도달하면 &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError&quot;&gt; &lt;code&gt;IncompleteReadError&lt;/code&gt; &lt;/a&gt; 예외가 발생하고 내부 버퍼가 재설정됩니다. &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError.partial&quot;&gt; &lt;code&gt;IncompleteReadError.partial&lt;/code&gt; 의&lt;/a&gt; 특성은 세퍼레이터의 일부를 포함 할 수있다.</target>
        </trans-unit>
        <trans-unit id="64966df5aaf0fe93384998cc74db09b1b1e0908b" translate="yes" xml:space="preserve">
          <source>If EOF is received and &lt;code&gt;\n&lt;/code&gt; was not found, the method returns partially read data.</source>
          <target state="translated">EOF가 수신되고 &lt;code&gt;\n&lt;/code&gt; 을 찾을 수 없으면이 메소드는 부분적으로 읽은 데이터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="37ccc310a3c93f0e5b0c94cdc94d47902bd4a292" translate="yes" xml:space="preserve">
          <source>If EOF is received and the internal buffer is empty, return an empty &lt;code&gt;bytes&lt;/code&gt; object.</source>
          <target state="translated">EOF가 수신되고 내부 버퍼가 비어 있으면 빈 &lt;code&gt;bytes&lt;/code&gt; 오브젝트를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="b333fc07ff7677c5890283c373e9cd05a53e6b15" translate="yes" xml:space="preserve">
          <source>If EOF was received and the internal buffer is empty, return an empty &lt;code&gt;bytes&lt;/code&gt; object.</source>
          <target state="translated">EOF가 수신되고 내부 버퍼가 비어 있으면 빈 &lt;code&gt;bytes&lt;/code&gt; 오브젝트를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="565904950e6bb3477bfa33cb4d9c35fc162ea0d1" translate="yes" xml:space="preserve">
          <source>If IDLE is started with the -n command line switch it will run in a single process and will not create the subprocess which runs the RPC Python execution server. This can be useful if Python cannot create the subprocess or the RPC socket interface on your platform. However, in this mode user code is not isolated from IDLE itself. Also, the environment is not restarted when Run/Run Module (F5) is selected. If your code has been modified, you must reload() the affected modules and re-import any specific items (e.g. from foo import baz) if the changes are to take effect. For these reasons, it is preferable to run IDLE with the default subprocess if at all possible.</source>
          <target state="translated">IDLE이 -n 명령 줄 스위치로 시작되면 단일 프로세스에서 실행되며 RPC Python 실행 서버를 실행하는 하위 프로세스를 만들지 않습니다. Python이 플랫폼에서 하위 프로세스 또는 RPC 소켓 인터페이스를 만들 수없는 경우에 유용 할 수 있습니다. 그러나이 모드에서 사용자 코드는 IDLE 자체와 분리되지 않습니다. 또한 Run / Run Module (F5)을 선택하면 환경이 다시 시작되지 않습니다. 코드가 수정 된 경우 변경 사항을 적용하려면 영향을받는 모듈을 다시로드 ()하고 특정 항목 (예 : foo import baz)을 다시 가져와야합니다. 이러한 이유로 가능한 경우 기본 서브 프로세스로 IDLE을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4b89fe059f09f502735b8f9ac90a0efcb1f4144f" translate="yes" xml:space="preserve">
          <source>If IDLE quits with no message, and it was not started from a console, try starting from a console (&lt;code&gt;python -m idlelib&lt;/code&gt;) and see if a message appears.</source>
          <target state="translated">IDLE이 메시지없이 종료되고 콘솔에서 시작되지 않은 경우 콘솔 ( &lt;code&gt;python -m idlelib&lt;/code&gt; ) 에서 시작 하여 메시지가 나타나는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6da326dbc2e0f620d5b3562ac4003336f6c4fcbf" translate="yes" xml:space="preserve">
          <source>If Python is configured &amp;ndash;with-pydebug, it also performs some expensive internal consistency checks.</source>
          <target state="translated">Python이 &amp;ndash;with-pydebug로 구성되면 값 비싼 내부 일관성 검사도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7e8ad6a5bf4b4e800e3d3c07556ce745ad232c22" translate="yes" xml:space="preserve">
          <source>If TOS is &lt;code&gt;NULL&lt;/code&gt; (pushed by &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt;&lt;code&gt;BEGIN_FINALLY&lt;/code&gt;&lt;/a&gt;) continue from the next instruction. TOS is popped.</source>
          <target state="translated">TOS가 &lt;code&gt;NULL&lt;/code&gt; 이면 ( &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt; &lt;code&gt;BEGIN_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 됨 ) 다음 명령어부터 계속합니다. TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="4cf9fa5811d78e12561243fd40b78efba546d577" translate="yes" xml:space="preserve">
          <source>If TOS is &lt;code&gt;NULL&lt;/code&gt; or an integer (pushed by &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt;&lt;code&gt;BEGIN_FINALLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt;&lt;code&gt;CALL_FINALLY&lt;/code&gt;&lt;/a&gt;) it is popped from the stack.</source>
          <target state="translated">TOS가 &lt;code&gt;NULL&lt;/code&gt; 이거나 정수 ( &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt; &lt;code&gt;BEGIN_FINALLY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt; &lt;code&gt;CALL_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 된 ) 인 경우 스택에서 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="f48c5490bf7b7f8935f8dee66c02900d2c4ab8df" translate="yes" xml:space="preserve">
          <source>If TOS is &lt;code&gt;NULL&lt;/code&gt;, calls &lt;code&gt;SECOND(None, None, None)&lt;/code&gt;, removes the function from the stack, leaving TOS, and pushes &lt;code&gt;None&lt;/code&gt; to the stack. Otherwise calls &lt;code&gt;SEVENTH(TOP, SECOND, THIRD)&lt;/code&gt;, shifts the bottom 3 values of the stack down, replaces the empty spot with &lt;code&gt;NULL&lt;/code&gt; and pushes TOS. Finally pushes the result of the call.</source>
          <target state="translated">TOS가 &lt;code&gt;NULL&lt;/code&gt; 이면 &lt;code&gt;SECOND(None, None, None)&lt;/code&gt; 호출 하고 스택에서 함수를 제거하고 TOS를 남겨두고 &lt;code&gt;None&lt;/code&gt; 을 스택으로 푸시 합니다. 그렇지 않으면 &lt;code&gt;SEVENTH(TOP, SECOND, THIRD)&lt;/code&gt; 호출 하고 스택의 맨 아래 3 값을 아래로 이동하고 빈 자리를 &lt;code&gt;NULL&lt;/code&gt; 로 바꾸고 TOS를 푸시합니다. 마지막으로 통화 결과를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="abb8b40f1da2f2b2347978a298ac651c1725f8e8" translate="yes" xml:space="preserve">
          <source>If TOS is an exception type (pushed when an exception has been raised) 6 values are popped from the stack, the first three popped values are used to re-raise the exception and the last three popped values are used to restore the exception state. An exception handler block is removed from the block stack.</source>
          <target state="translated">TOS가 예외 유형 (예외가 발생했을 때 푸시 됨) 인 경우 스택에서 6 개의 값이 팝되고 처음 3 개의 팝된 값이 예외를 다시 발생시키는 데 사용되고 마지막 3 개의 팝된 값이 예외 상태를 복원하는 데 사용됩니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2302c4982e8b01f632b216292ea649801c6c0d96" translate="yes" xml:space="preserve">
          <source>If TOS is an exception type (pushed when an exception has been raised) 6 values are popped from the stack, the last three popped values are used to restore the exception state. An exception handler block is removed from the block stack.</source>
          <target state="translated">TOS가 예외 유형 인 경우 (예외가 발생하면 푸시 됨) 스택에서 6 개의 값이 팝되고 마지막 3 개의 팝된 값이 예외 상태를 복원하는 데 사용됩니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fd2cf047c9942e0f550e6077fa8d21cb90b76cb7" translate="yes" xml:space="preserve">
          <source>If TOS is an integer (pushed by &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt;&lt;code&gt;CALL_FINALLY&lt;/code&gt;&lt;/a&gt;), sets the bytecode counter to TOS. TOS is popped.</source>
          <target state="translated">TOS가 정수인 경우 ( &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt; &lt;code&gt;CALL_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 됨 ) 바이트 코드 카운터를 TOS로 설정합니다. TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c824aa2841edf27744c99adfaeb683cc13ab98" translate="yes" xml:space="preserve">
          <source>If TOS is false, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt; and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.</source>
          <target state="translated">TOS가 false이면 바이트 코드 카운터를 &lt;em&gt;대상으로&lt;/em&gt; 설정 하고 스택에 TOS를 남겨 둡니다. 그렇지 않으면 (TOS는 true) TOS가 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="38d252fb2c0b51db170eaaf60178e5958dde0da6" translate="yes" xml:space="preserve">
          <source>If TOS is false, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt;. TOS is popped.</source>
          <target state="translated">TOS가 false 인 경우 바이트 코드 카운터를 &lt;em&gt;target으로&lt;/em&gt; 설정하십시오 . TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="4d11fcb64b49991d5e23ff5378876664a570eb06" translate="yes" xml:space="preserve">
          <source>If TOS is true, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt; and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.</source>
          <target state="translated">TOS가 true이면 바이트 코드 카운터를 &lt;em&gt;대상으로&lt;/em&gt; 설정 하고 스택에 TOS를 남겨 둡니다. 그렇지 않으면 (TOS가 false 임) TOS가 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="8563156513d08688acbcc0dcf86ef18bbf609716" translate="yes" xml:space="preserve">
          <source>If TOS is true, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt;. TOS is popped.</source>
          <target state="translated">TOS가 true이면 바이트 코드 카운터를 &lt;em&gt;target으로&lt;/em&gt; 설정합니다 . TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc1fd538beeedcb8c3c03d14bb5f0c903b80416" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#asyncio.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is currently blocking, it will resume when all items have been processed (meaning that a &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; call was received for every item that had been &lt;a href=&quot;#asyncio.Queue.put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt; into the queue).</source>
          <target state="translated">A는 경우 &lt;a href=&quot;#asyncio.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 현재 차단하고 모든 항목 (A 것을 의미 처리 된 때, 그것은 다시 시작됩니다 &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출이 있었다 모든 항목에 대해받은 &lt;a href=&quot;#asyncio.Queue.put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; 큐에).</target>
        </trans-unit>
        <trans-unit id="0f22d8dc16cef20350827c1688943ea1d51e1b6e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt; specifies a &lt;code&gt;default_factory&lt;/code&gt;, it is called with zero arguments when a default value for the field is needed. For example, to create a new instance of a list, use:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;default_factory&lt;/code&gt; 를 지정 하면 필드 의 기본값이 필요할 때 인수없이 0으로 호출됩니다. 예를 들어, 목록의 새 인스턴스를 만들려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="88fb56a53222e7bda82191727d7975a25a26bcde" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is currently blocking, it will resume when all items have been processed (meaning that a &lt;a href=&quot;#queue.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; call was received for every item that had been &lt;a href=&quot;#queue.Queue.put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt; into the queue).</source>
          <target state="translated">A는 경우 &lt;a href=&quot;#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 현재 차단하고 모든 항목 (A 것을 의미 처리 된 때, 그것은 다시 시작됩니다 &lt;a href=&quot;#queue.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출이 있었다 모든 항목에 대해받은 &lt;a href=&quot;#queue.Queue.put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; 큐에).</target>
        </trans-unit>
        <trans-unit id="8738b4c21d7c83839b7de0b30dc8bf54b691da48" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;asyncio-future#asyncio.Future.set_exception&quot;&gt;&lt;code&gt;Future.set_exception()&lt;/code&gt;&lt;/a&gt; is called but the Future object is never awaited on, the exception would never be propagated to the user code. In this case, asyncio would emit a log message when the Future object is garbage collected.</source>
          <target state="translated">경우 &lt;a href=&quot;asyncio-future#asyncio.Future.set_exception&quot;&gt; &lt;code&gt;Future.set_exception()&lt;/code&gt; &lt;/a&gt; 호출하지만 미래의 객체가 기다려온 결코 예외는 사용자 코드에 전달되지 않을 것입니다. 이 경우 Future 객체가 가비지 수집 될 때 asyncio가 로그 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8e4d1e78b745e52d4ebe30db3c57ec62db32a37b" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;queue#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is currently blocking, it will resume when all items have been processed (meaning that a &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; call was received for every item that had been &lt;a href=&quot;#multiprocessing.Queue.put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt; into the queue).</source>
          <target state="translated">A는 경우 &lt;a href=&quot;queue#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 현재 차단하고 모든 항목 (A 것을 의미 처리 된 때, 그것은 다시 시작됩니다 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출이 있었다 모든 항목에 대해받은 &lt;a href=&quot;#multiprocessing.Queue.put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; 큐에).</target>
        </trans-unit>
        <trans-unit id="d195caefdbc4c716fdba586aa4513e02d88af028" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;venv#venv-def&quot;&gt;virtual environment&lt;/a&gt; is in effect, this value will be changed in &lt;code&gt;site.py&lt;/code&gt; to point to the virtual environment. The value for the Python installation will still be available, via &lt;a href=&quot;#sys.base_exec_prefix&quot;&gt;&lt;code&gt;base_exec_prefix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;venv#venv-def&quot;&gt;가상 환경에&lt;/a&gt; 적용되는 경우,이 값은 변경 될 &lt;code&gt;site.py&lt;/code&gt; 가상 환경 포인트. Python 설치 값은 &lt;a href=&quot;#sys.base_exec_prefix&quot;&gt; &lt;code&gt;base_exec_prefix&lt;/code&gt; &lt;/a&gt; 를 통해 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cadf44283b95910d5b7d617daadb92f12ea1588c" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;venv#venv-def&quot;&gt;virtual environment&lt;/a&gt; is in effect, this value will be changed in &lt;code&gt;site.py&lt;/code&gt; to point to the virtual environment. The value for the Python installation will still be available, via &lt;a href=&quot;#sys.base_prefix&quot;&gt;&lt;code&gt;base_prefix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;venv#venv-def&quot;&gt;가상 환경에&lt;/a&gt; 적용되는 경우,이 값은 변경 될 &lt;code&gt;site.py&lt;/code&gt; 가상 환경 포인트. Python 설치 값은 &lt;a href=&quot;#sys.base_prefix&quot;&gt; &lt;code&gt;base_prefix&lt;/code&gt; &lt;/a&gt; 를 통해 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fe39842fffdbab07a3dcbd6ca0ebfc6e8ddea4e" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;func&lt;/em&gt; call raises an exception, then that exception will be raised when its value is retrieved from the iterator.</source>
          <target state="translated">경우 &lt;em&gt;FUNC의&lt;/em&gt; 호출이 예외가 발생 값이 반복자에서 검색 할 때, 그 예외가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="514035568d6c1e520c43a7a94949e224b330525e" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;weights&lt;/em&gt; sequence is specified, selections are made according to the relative weights. Alternatively, if a &lt;em&gt;cum_weights&lt;/em&gt; sequence is given, the selections are made according to the cumulative weights (perhaps computed using &lt;a href=&quot;itertools#itertools.accumulate&quot;&gt;&lt;code&gt;itertools.accumulate()&lt;/code&gt;&lt;/a&gt;). For example, the relative weights &lt;code&gt;[10, 5, 30, 5]&lt;/code&gt; are equivalent to the cumulative weights &lt;code&gt;[10, 15, 45, 50]&lt;/code&gt;. Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work.</source>
          <target state="translated">경우 &lt;em&gt;가중치&lt;/em&gt; 시퀀스를 지정하고, 선택은 상대 가중치에 따라 제조된다. 또는 &lt;em&gt;cum_weights&lt;/em&gt; 시퀀스가 제공되면 누적 가중치에 따라 선택됩니다 (아마 &lt;a href=&quot;itertools#itertools.accumulate&quot;&gt; &lt;code&gt;itertools.accumulate()&lt;/code&gt; &lt;/a&gt; 사용하여 계산 ). 예를 들어, 상대 가중치 &lt;code&gt;[10, 5, 30, 5]&lt;/code&gt; 는 누적 가중치 &lt;code&gt;[10, 15, 45, 50]&lt;/code&gt; . 내부적으로 상대 가중치는 선택하기 전에 누적 가중치로 변환되므로 누적 가중치를 제공하면 작업이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="4f41fb59be7ba020951a7118cd7f719bcea2d8d7" translate="yes" xml:space="preserve">
          <source>If a DOM implementation supports modification of the document, the &lt;code&gt;NodeList&lt;/code&gt; implementation must also support the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delitem__&quot;&gt;&lt;code&gt;__delitem__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">DOM 구현이 문서 수정을 지원하는 경우 &lt;code&gt;NodeList&lt;/code&gt; 구현은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delitem__&quot;&gt; &lt;code&gt;__delitem__()&lt;/code&gt; &lt;/a&gt; 메소드 도 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a7b9e9c072e9d7f0dad90957cde9dde1a308b30" translate="yes" xml:space="preserve">
          <source>If a Python build or implementation cannot reasonably compute this information, &lt;a href=&quot;#sys.getallocatedblocks&quot;&gt;&lt;code&gt;getallocatedblocks()&lt;/code&gt;&lt;/a&gt; is allowed to return 0 instead.</source>
          <target state="translated">Python 빌드 또는 구현에서이 정보를 합리적으로 계산할 수없는 경우 &lt;a href=&quot;#sys.getallocatedblocks&quot;&gt; &lt;code&gt;getallocatedblocks()&lt;/code&gt; &lt;/a&gt; 대신 0을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60da62d17196410fef26f1732934782af59026ed" translate="yes" xml:space="preserve">
          <source>If a bytes object is specified as first argument, the buffer is made one item larger than its length so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows specifying the size of the array if the length of the bytes should not be used.</source>
          <target state="translated">bytes 객체가 첫 번째 인수로 지정되면 버퍼의 길이보다 한 항목을 크게하여 배열의 마지막 요소가 NUL 종료 문자가되도록합니다. 바이트 길이를 사용하지 않아야 할 경우 배열의 크기를 지정할 수있는 정수를 두 번째 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a9df58cde01c85e3e361479c2eaa47542a1d1e" translate="yes" xml:space="preserve">
          <source>If a class is used as a spec then the return value of the mock (the instance of the class) will have the same spec. You can use a class as the spec for an instance object by passing &lt;code&gt;instance=True&lt;/code&gt;. The returned mock will only be callable if instances of the mock are callable.</source>
          <target state="translated">클래스가 스펙으로 사용되면 모의 리턴 값 (클래스의 인스턴스)은 동일한 스펙을 갖습니다. &lt;code&gt;instance=True&lt;/code&gt; 를 전달하여 클래스를 인스턴스 객체의 사양으로 사용할 수 있습니다 . 반환 된 mock은 mock의 인스턴스가 호출 가능한 경우에만 호출 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b4f43db4f49808e0e46033f11efdb30feae93504" translate="yes" xml:space="preserve">
          <source>If a client certificate is needed for the connection, it can be added with &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt;&lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결에 클라이언트 인증서가 필요한 경우 &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt; &lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt; &lt;/a&gt; 으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b445a457d97e0f901bef2a89a3d771923959d7" translate="yes" xml:space="preserve">
          <source>If a combination of Flag members is not named, the &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; will include all named flags and all named combinations of flags that are in the value:</source>
          <target state="translated">Flag 멤버 조합의 이름이 지정되지 않은 경우 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 에는 이름이 지정된 모든 플래그 및 값에있는 플래그의 모든 이름 지정된 조합이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5ec6b65a6b4e8ded11a923539e5e70636ccd0baa" translate="yes" xml:space="preserve">
          <source>If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case.</source>
          <target state="translated">파생 클래스가이 요구 사항을 준수하지 않으려면이 클래스에서 지원하는 모든 특수 메서드를 재정의해야합니다. 이 경우 제공해야하는 방법에 대한 정보는 소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06eec7a5cb652201659973dd7752b18166617a4a" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;a href=&quot;#gettext.npgettext&quot;&gt;&lt;code&gt;npgettext()&lt;/code&gt;&lt;/a&gt; to the fallback. Otherwise, return the translated message. Overridden in derived classes.</source>
          <target state="translated">&lt;a href=&quot;#gettext.npgettext&quot;&gt; &lt;code&gt;npgettext()&lt;/code&gt; &lt;/a&gt; 설정된 경우 npgettext () 를 폴백으로 전달하십시오. 그렇지 않으면 번역 된 메시지를 반환하십시오. 파생 클래스에서 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc269c958946b76f1994096408ccbb977101ec26" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;a href=&quot;#gettext.pgettext&quot;&gt;&lt;code&gt;pgettext()&lt;/code&gt;&lt;/a&gt; to the fallback. Otherwise, return the translated message. Overridden in derived classes.</source>
          <target state="translated">&lt;a href=&quot;#gettext.pgettext&quot;&gt; &lt;code&gt;pgettext()&lt;/code&gt; &lt;/a&gt; 설정된 경우 pgettext () 를 폴백으로 전달하십시오. 그렇지 않으면 번역 된 메시지를 반환하십시오. 파생 클래스에서 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="31061e62016f356b1c4c0fbc4aa1f88db7f71ad7" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;code&gt;gettext()&lt;/code&gt; to the fallback. Otherwise, return &lt;em&gt;message&lt;/em&gt;. Overridden in derived classes.</source>
          <target state="translated">폴 백이 설정된 경우 &lt;code&gt;gettext()&lt;/code&gt; 를 폴백으로 전달하십시오. 그렇지 않으면 &lt;em&gt;message를&lt;/em&gt; 반환하십시오 . 파생 클래스에서 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="1742c3486fc827c0e30b5e6a8b02073a52c6f50e" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;code&gt;ngettext()&lt;/code&gt; to the fallback. Otherwise, return &lt;em&gt;singular&lt;/em&gt; if &lt;em&gt;n&lt;/em&gt; is 1; return &lt;em&gt;plural&lt;/em&gt; otherwise. Overridden in derived classes.</source>
          <target state="translated">&lt;code&gt;ngettext()&lt;/code&gt; 백이 설정된 경우 ngettext () 를 폴백으로 전달하십시오. 그렇지 않으면 &lt;em&gt;n&lt;/em&gt; 이 1 이면 &lt;em&gt;특이&lt;/em&gt; 값을 반환합니다 . 반환 &lt;em&gt;복수&lt;/em&gt; 그렇지. 파생 클래스에서 재정의되었습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d7b45636976cf2d05c5fad71555cb6ec8a500e2" translate="yes" xml:space="preserve">
          <source>If a field is excluded from &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;init=False&lt;/code&gt;) and the field also specifies &lt;code&gt;default_factory&lt;/code&gt;, then the default factory function will always be called from the generated &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; function. This happens because there is no other way to give the field an initial value.</source>
          <target state="translated">필드가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 에서 제외되고 ( &lt;code&gt;init=False&lt;/code&gt; 사용 ) 필드도 &lt;code&gt;default_factory&lt;/code&gt; 를 지정 하면 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 함수 에서 기본 팩토리 함수가 항상 호출됩니다 . 이는 필드에 초기 값을 제공 할 다른 방법이 없기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="565807013493930067f8f17afe47ed0e67b8a0c2" translate="yes" xml:space="preserve">
          <source>If a field represents an uploaded file, accessing the value via the &lt;code&gt;value&lt;/code&gt; attribute or the &lt;code&gt;getvalue()&lt;/code&gt; method reads the entire file in memory as bytes. This may not be what you want. You can test for an uploaded file by testing either the &lt;code&gt;filename&lt;/code&gt; attribute or the &lt;code&gt;file&lt;/code&gt; attribute. You can then read the data from the &lt;code&gt;file&lt;/code&gt; attribute before it is automatically closed as part of the garbage collection of the &lt;code&gt;FieldStorage&lt;/code&gt; instance (the &lt;a href=&quot;io#io.RawIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt; methods will return bytes):</source>
          <target state="translated">필드가 업로드 된 파일을 나타내는 경우 &lt;code&gt;value&lt;/code&gt; 속성 또는 &lt;code&gt;getvalue()&lt;/code&gt; 메소드 를 통해 값에 액세스하면 메모리에서 전체 파일을 바이트로 읽습니다. 이것은 당신이 원하는 것이 아닐 수도 있습니다. 당신이 중 하나를 테스트하여 업로드 된 파일을 테스트 할 수 있습니다 &lt;code&gt;filename&lt;/code&gt; 특성 또는 &lt;code&gt;file&lt;/code&gt; 속성을. 그런 다음 &lt;code&gt;FieldStorage&lt;/code&gt; 인스턴스 의 가비지 콜렉션의 일부로 &lt;code&gt;file&lt;/code&gt; 속성이 자동으로 닫히기 전에 파일 속성 에서 데이터를 읽을 수 있습니다 ( &lt;a href=&quot;io#io.RawIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt; 메소드는 바이트를 리턴 함).</target>
        </trans-unit>
        <trans-unit id="2ac00aa24d225f2a25916402cc6d54632f003730" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;.pdbrc&lt;/code&gt; exists in the user&amp;rsquo;s home directory or in the current directory, it is read in and executed as if it had been typed at the debugger prompt. This is particularly useful for aliases. If both files exist, the one in the home directory is read first and aliases defined there can be overridden by the local file.</source>
          <target state="translated">&lt;code&gt;.pdbrc&lt;/code&gt; 파일 이 사용자의 홈 디렉토리 또는 현재 디렉토리에 존재하면 마치 디버거 프롬프트에서 입력 한 것처럼 파일을 읽고 실행합니다. 별명에 특히 유용합니다. 두 파일이 모두 존재하면 홈 디렉토리에있는 파일을 먼저 읽고 별명을 정의하여 로컬 파일로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5448f252b6aeff14276e99301e4c6e612a601743" translate="yes" xml:space="preserve">
          <source>If a file named &amp;ldquo;pyvenv.cfg&amp;rdquo; exists one directory above sys.executable, sys.prefix and sys.exec_prefix are set to that directory and it is also checked for site-packages (sys.base_prefix and sys.base_exec_prefix will always be the &amp;ldquo;real&amp;rdquo; prefixes of the Python installation). If &amp;ldquo;pyvenv.cfg&amp;rdquo; (a bootstrap configuration file) contains the key &amp;ldquo;include-system-site-packages&amp;rdquo; set to anything other than &amp;ldquo;true&amp;rdquo; (case-insensitive), the system-level prefixes will not be searched for site-packages; otherwise they will.</source>
          <target state="translated">&amp;ldquo;pyvenv.cfg&amp;rdquo;라는 파일이 sys. executable 위에 하나의 디렉토리가 존재하면 sys.prefix 및 sys.exec_prefix가 해당 디렉토리로 설정되고 사이트 패키지도 검사됩니다 (sys.base_prefix 및 sys.base_exec_prefix는 항상 Python 설치의 &quot;실제&quot;접두사). &quot;pyvenv.cfg&quot;(부트 스트랩 구성 파일)에 &quot;true&quot;(대소 문자 구분) 이외의 것으로 설정된 &quot;include-system-site-packages&quot;키가 포함되어 있으면 시스템 수준 접두사에서 사이트를 검색하지 않습니다. 패키지; 그렇지 않으면 그들은 할 것이다.</target>
        </trans-unit>
        <trans-unit id="b1c78860034600d414c83db7d32c54bb73e1ecd7" translate="yes" xml:space="preserve">
          <source>If a file named &lt;em&gt;filename&lt;/em&gt; is not found, the function first checks for a &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;&lt;code&gt;__loader__&lt;/code&gt; in &lt;em&gt;module_globals&lt;/em&gt;. If there is such a loader and it defines a &lt;code&gt;get_source&lt;/code&gt; method, then that determines the source lines (if &lt;code&gt;get_source()&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, then &lt;code&gt;''&lt;/code&gt; is returned). Finally, if &lt;em&gt;filename&lt;/em&gt; is a relative filename, it is looked up relative to the entries in the module search path, &lt;code&gt;sys.path&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일을&lt;/em&gt; 찾을 수 없으면, 함수는 먼저 &lt;code&gt;__loader__&lt;/code&gt; 에서 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; __loader__ 를 &lt;em&gt;확인&lt;/em&gt; 합니다. 그러한 로더가 있고 &lt;code&gt;get_source&lt;/code&gt; 메소드를 정의 하면 소스 라인을 판별합니다 ( &lt;code&gt;get_source()&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 을 리턴 하면 &lt;code&gt;''&lt;/code&gt; 가 리턴 됨). 마지막으로 &lt;em&gt;filename&lt;/em&gt; 이 상대 파일 이름 인 경우 모듈 검색 경로 ( &lt;code&gt;sys.path&lt;/code&gt; ) 의 항목을 기준으로 조회 됩니다.</target>
        </trans-unit>
        <trans-unit id="f21e40fc27ce27eb35a61db85ca27f562b3c3c39" translate="yes" xml:space="preserve">
          <source>If a file object is specified for &lt;em&gt;source&lt;/em&gt; or &lt;em&gt;target&lt;/em&gt;, it is the caller&amp;rsquo;s responsibility to close it after calling create_archive.</source>
          <target state="translated">&lt;em&gt;source&lt;/em&gt; 또는 &lt;em&gt;target에&lt;/em&gt; 파일 객체가 지정된 경우 create_archive를 호출 한 후 파일 객체 를 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="a3207350b9a94fa842bcda66334617cd920267c5" translate="yes" xml:space="preserve">
          <source>If a formatter is specified, it is used to format the record. The record is then written to the stream with a terminator. If exception information is present, it is formatted using &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt;&lt;code&gt;traceback.print_exception()&lt;/code&gt;&lt;/a&gt; and appended to the stream.</source>
          <target state="translated">포맷터가 지정된 경우 레코드를 포맷하는 데 사용됩니다. 그런 다음 레코드는 종결 자와 함께 스트림에 기록됩니다. 예외 정보가있는 경우 &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt; &lt;code&gt;traceback.print_exception()&lt;/code&gt; &lt;/a&gt; 사용하여 형식이 지정 되고 스트림에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="76e26d9c99665021cd2747cf34bdb27b0c694a2b" translate="yes" xml:space="preserve">
          <source>If a generator code directly or indirectly raises &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt;, it is converted into a &lt;a href=&quot;#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; (retaining the &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; as the new exception&amp;rsquo;s cause).</source>
          <target state="translated">생성기 코드가 직접 또는 간접적으로 &lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; 을&lt;/a&gt; 발생시키는 경우, &lt;a href=&quot;#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 ( &lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 을 새 예외의 원인으로 유지함 ).</target>
        </trans-unit>
        <trans-unit id="93d34f8fd817c6e0f1345b2e762a4c72177524ff" translate="yes" xml:space="preserve">
          <source>If a group matches multiple times, only the last match is accessible:</source>
          <target state="translated">그룹이 여러 번 일치하면 마지막 일치 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbbe58498c91a0c4d108c85bbbabc900782816b" translate="yes" xml:space="preserve">
          <source>If a member filename is an absolute path, a drive/UNC sharepoint and leading (back)slashes will be stripped, e.g.: &lt;code&gt;///foo/bar&lt;/code&gt; becomes &lt;code&gt;foo/bar&lt;/code&gt; on Unix, and &lt;code&gt;C:\foo\bar&lt;/code&gt; becomes &lt;code&gt;foo\bar&lt;/code&gt; on Windows. And all &lt;code&gt;&quot;..&quot;&lt;/code&gt; components in a member filename will be removed, e.g.: &lt;code&gt;../../foo../../ba..r&lt;/code&gt; becomes &lt;code&gt;foo../ba..r&lt;/code&gt;. On Windows illegal characters (&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt;) replaced by underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">: 멤버 이름 절대 경로, 드라이브 / UNC 셰어 선도 (뒷면) 슬래시 경우, 예를 들어 제거한다 &lt;code&gt;///foo/bar&lt;/code&gt; 해진다 &lt;code&gt;foo/bar&lt;/code&gt; 유닉스 및 &lt;code&gt;C:\foo\bar&lt;/code&gt; 된다 &lt;code&gt;foo\bar&lt;/code&gt; Windows에서. 그리고 멤버 파일 이름의 모든 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 구성 요소가 제거됩니다. 예 : &lt;code&gt;../../foo../../ba..r&lt;/code&gt; 은 &lt;code&gt;foo../ba..r&lt;/code&gt; 됩니다. Windows에서 잘못된 문자 ( &lt;code&gt;:&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; )는 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="503137eb198604b87efeb2bcd433e998e37317d8" translate="yes" xml:space="preserve">
          <source>If a member occurs more than once in the archive, its last occurrence is assumed to be the most up-to-date version.</source>
          <target state="translated">아카이브에서 멤버가 두 번 이상 발생하면 마지막 발생이 최신 버전 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f787e74c446e2990e618d08579803f817ebdb5cc" translate="yes" xml:space="preserve">
          <source>If a mock instance with a name or a spec is assigned to an attribute it won&amp;rsquo;t be considered in the sealing chain. This allows one to prevent seal from fixing part of the mock object.</source>
          <target state="translated">이름이나 사양을 가진 모의 인스턴스가 속성에 할당되면 실링 체인에서 고려되지 않습니다. 이것은 실이 모의 물체의 일부를 고정시키는 것을 방지 할 수있게한다.</target>
        </trans-unit>
        <trans-unit id="392fa48383638f6ca8f0993f37a1ecb79cf4aca5" translate="yes" xml:space="preserve">
          <source>If a module imports objects from another module using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; &amp;hellip;, calling &lt;a href=&quot;#importlib.reload&quot;&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/a&gt; for the other module does not redefine the objects imported from it &amp;mdash; one way around this is to re-execute the &lt;code&gt;from&lt;/code&gt; statement, another is to use &lt;code&gt;import&lt;/code&gt; and qualified names (&lt;em&gt;module.name&lt;/em&gt;) instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; &amp;hellip;를 사용하여 모듈이 다른 모듈에서 객체를 가져 오는 경우 다른 모듈 에 대해 &lt;a href=&quot;#importlib.reload&quot;&gt; &lt;code&gt;reload()&lt;/code&gt; &lt;/a&gt; 를 호출 해도 가져온 모듈은 다시 정의되지 않습니다.이 중 한 가지 방법은 &lt;code&gt;from&lt;/code&gt; 문 을 다시 실행하는 것이고 , 다른 하나는 &lt;code&gt;import&lt;/code&gt; 및 정규화 된 이름 ( &lt;em&gt;module.name&lt;/em&gt; )을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b76b30a9fc3685533f4941dde34b064d15308902" translate="yes" xml:space="preserve">
          <source>If a module instantiates instances of a class, reloading the module that defines the class does not affect the method definitions of the instances &amp;mdash; they continue to use the old class definition. The same is true for derived classes.</source>
          <target state="translated">모듈이 클래스의 인스턴스를 인스턴스화하는 경우 클래스를 정의하는 모듈을 다시로드해도 인스턴스의 메서드 정의에는 영향을 미치지 않습니다. 이전 클래스 정의는 계속 사용됩니다. 파생 클래스에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c7274841cd2a6c4fb6fc0a1fd5f00a02812a3cd7" translate="yes" xml:space="preserve">
          <source>If a module provides a &lt;code&gt;load_tests&lt;/code&gt; function it will be called to load the tests. This allows modules to customize test loading. This is the &lt;a href=&quot;#load-tests-protocol&quot;&gt;load_tests protocol&lt;/a&gt;. The &lt;em&gt;pattern&lt;/em&gt; argument is passed as the third argument to &lt;code&gt;load_tests&lt;/code&gt;.</source>
          <target state="translated">모듈이 &lt;code&gt;load_tests&lt;/code&gt; 함수를 제공 하면 테스트를로드하기 위해 호출됩니다. 이를 통해 모듈은 테스트로드를 사용자 정의 할 수 있습니다. 이것이 &lt;a href=&quot;#load-tests-protocol&quot;&gt;load_tests 프로토콜&lt;/a&gt; 입니다. &lt;em&gt;패턴&lt;/em&gt; 인수는 세 번째 인수로 전달됩니다 &lt;code&gt;load_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9967a7e9f61023ca795710b85aa3fd3437d08d6a" translate="yes" xml:space="preserve">
          <source>If a mutable buffer is passed, then the behaviour is determined by the value of the &lt;em&gt;mutate_flag&lt;/em&gt; parameter.</source>
          <target state="translated">변경 가능한 버퍼가 전달되면 &lt;em&gt;mutate_flag&lt;/em&gt; 매개 변수 의 값에 의해 동작이 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc9fb74f4ebf143daf34473be06e5da4ab833c" translate="yes" xml:space="preserve">
          <source>If a new seeding method is added, then a backward compatible seeder will be offered.</source>
          <target state="translated">새로운 파종 방법이 추가되면 이전 버전과 호환되는 파종기가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="133e9d936cb0cf3ade6b9637c210b91b2ab80815" translate="yes" xml:space="preserve">
          <source>If a package (a directory containing a file named &lt;code&gt;__init__.py&lt;/code&gt;) is found, the package will be checked for a &lt;code&gt;load_tests&lt;/code&gt; function. If this exists then it will be called &lt;code&gt;package.load_tests(loader, tests, pattern)&lt;/code&gt;. Test discovery takes care to ensure that a package is only checked for tests once during an invocation, even if the load_tests function itself calls &lt;code&gt;loader.discover&lt;/code&gt;.</source>
          <target state="translated">패키지 ( &lt;code&gt;__init__.py&lt;/code&gt; 라는 파일을 포함하는 디렉토리 )가 발견되면 패키지는 &lt;code&gt;load_tests&lt;/code&gt; 함수를 검사 합니다. 이것이 존재하면 &lt;code&gt;package.load_tests(loader, tests, pattern)&lt;/code&gt; 합니다. &lt;code&gt;loader.discover&lt;/code&gt; 함수 자체가 loader.discover를 호출하더라도 호출 중에 패키지가 테스트에 대해 한 번만 검사되도록 테스트 감지가주의를 기울 입니다.</target>
        </trans-unit>
        <trans-unit id="de4d246a31d1c98bfbbe12597b38a1577e9dcbc3" translate="yes" xml:space="preserve">
          <source>If a part has a &lt;em&gt;Content-Disposition&lt;/em&gt; header, only consider the part a candidate match if the value of the header is &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">파트에 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 가있는 경우 헤더 값이 &lt;code&gt;inline&lt;/code&gt; 인 경우에만 해당 파트가 후보 일치 항목으로 간주하십시오 .</target>
        </trans-unit>
        <trans-unit id="08bdb3b5117fe753e55ab3386000a7b11f147e33" translate="yes" xml:space="preserve">
          <source>If a particular application uses this pattern a lot, it can be simplified even further by means of a small helper class:</source>
          <target state="translated">특정 응용 프로그램에서이 패턴을 많이 사용하면 작은 도우미 클래스를 사용하여 훨씬 더 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca72e817de266e57decb5a9ba95638d41c318561" translate="yes" xml:space="preserve">
          <source>If a pointer points to an array, its elements can be read and written using standard subscript and slice accesses. Pointer objects have no size, so &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. Negative subscripts will read from the memory &lt;em&gt;before&lt;/em&gt; the pointer (as in C), and out-of-range subscripts will probably crash with an access violation (if you&amp;rsquo;re lucky).</source>
          <target state="translated">포인터가 배열을 가리키는 경우 표준 첨자 및 슬라이스 액세스를 사용하여 해당 요소를 읽고 쓸 수 있습니다. 포인터 객체는 크기가 없으므로 &lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 음수 첨자는 포인터 &lt;em&gt;앞&lt;/em&gt; 의 메모리에서 읽으며 (C에서와 같이) 범위를 벗어난 첨자는 액세스 위반으로 인해 충돌 할 수 있습니다 (행운이있는 경우).</target>
        </trans-unit>
        <trans-unit id="eed381cd380722df57d19d1544f97f6af790e234" translate="yes" xml:space="preserve">
          <source>If a process is killed using &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.kill&quot;&gt;&lt;code&gt;os.kill()&lt;/code&gt;&lt;/a&gt; while it is trying to use a &lt;a href=&quot;#multiprocessing.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt;, then the data in the queue is likely to become corrupted. This may cause any other process to get an exception when it tries to use the queue later on.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 를 사용하려고 시도하는 동안 &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.kill&quot;&gt; &lt;code&gt;os.kill()&lt;/code&gt; &lt;/a&gt; 을 사용하여 프로세스가 종료 되면 큐의 데이터가 손상 될 수 있습니다. 이로 인해 나중에 큐를 사용하려고 할 때 다른 프로세스에서 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d1f01d3ec2d55cce1c8cf716b703713495099e" translate="yes" xml:space="preserve">
          <source>If a process is killed while it is trying to read or write to a pipe then the data in the pipe is likely to become corrupted, because it may become impossible to be sure where the message boundaries lie.</source>
          <target state="translated">파이프를 읽거나 쓰려고 시도하는 동안 프로세스가 종료되면 파이프의 데이터가 손상 될 수 있습니다. 메시지 경계가 어디에 있는지 확신 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ee27c621c4af454357253732e654ec550abd9b30" translate="yes" xml:space="preserve">
          <source>If a regular expression ends with a greedy match (such as &lt;code&gt;.*&lt;/code&gt;) or if more than one expression can match the same input, the results are non-deterministic, and may depend on the I/O timing.</source>
          <target state="translated">정규식이 욕심 일치 (예 : &lt;code&gt;.*&lt;/code&gt; ) 로 끝나 거나 둘 이상의식이 동일한 입력과 일치 할 수있는 경우 결과는 결정적이지 않으며 I / O 타이밍에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f18a5c5319b593cf33dfdbccb25dc47d86b19fc" translate="yes" xml:space="preserve">
          <source>If a row has more fields than fieldnames, the remaining data is put in a list and stored with the fieldname specified by &lt;em&gt;restkey&lt;/em&gt; (which defaults to &lt;code&gt;None&lt;/code&gt;). If a non-blank row has fewer fields than fieldnames, the missing values are filled-in with &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">행에 fieldnames보다 많은 필드가있는 경우 나머지 데이터는 목록에 저장되고 &lt;em&gt;restkey에&lt;/em&gt; 의해 지정된 fieldname (기본값은 &lt;code&gt;None&lt;/code&gt; )으로 저장됩니다. 공백이 아닌 행에 fieldnames보다 적은 수의 필드가 있으면 결 측값은 &lt;code&gt;None&lt;/code&gt; 으로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="005f4f5ea8b5cbe5aac64333d420adc456c1595c" translate="yes" xml:space="preserve">
          <source>If a second argument is present, it is an expression which must evaluate to true before the breakpoint is honored.</source>
          <target state="translated">두 번째 인수가 있으면 중단 점이 적용되기 전에 true로 평가되어야하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="8557dead7893ee28dc4312dd3fbd82bd7ef26377" translate="yes" xml:space="preserve">
          <source>If a sequence of events takes longer to run than the time available before the next event, the scheduler will simply fall behind. No events will be dropped; the calling code is responsible for canceling events which are no longer pertinent.</source>
          <target state="translated">일련의 이벤트가 다음 이벤트 이전에 사용 가능한 시간보다 실행하는 데 시간이 오래 걸리면 스케줄러가 단순히 뒤처집니다. 이벤트가 삭제되지 않습니다. 호출 코드는 더 이상 관련이없는 이벤트를 취소합니다.</target>
        </trans-unit>
        <trans-unit id="a04337ee52a07d55c116e62a9138163aca040133" translate="yes" xml:space="preserve">
          <source>If a string is returned, the string should be interpreted as the name of a global variable. It should be the object&amp;rsquo;s local name relative to its module; the pickle module searches the module namespace to determine the object&amp;rsquo;s module. This behaviour is typically useful for singletons.</source>
          <target state="translated">문자열이 반환되면 문자열을 전역 변수의 이름으로 해석해야합니다. 모듈과 관련된 객체의 로컬 이름이어야합니다. 피클 모듈은 모듈 네임 스페이스를 검색하여 객체의 모듈을 결정합니다. 이 동작은 일반적으로 싱글 톤에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b77fc0289dcb779f53a98f0301822ac00449bb60" translate="yes" xml:space="preserve">
          <source>If a string is specified as first argument, the buffer is made one item larger than the length of the string so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows specifying the size of the array if the length of the string should not be used.</source>
          <target state="translated">문자열이 첫 번째 인수로 지정된 경우, 배열의 마지막 요소가 NUL 종료 문자가되도록 버퍼는 문자열 길이보다 하나의 항목을 크게 만듭니다. 문자열의 길이를 사용하지 않아야 할 경우 배열의 크기를 지정할 수있는 정수를 두 번째 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21c6bea79d147aa97afcd362c1b240007ff84d93" translate="yes" xml:space="preserve">
          <source>If a string of characters is typed, the ACW selection will jump to the entry most closely matching those characters. Entering a</source>
          <target state="translated">문자열을 입력하면 ACW 선택 항목이 해당 문자와 ​​가장 일치하는 항목으로 이동합니다. 입력</target>
        </trans-unit>
        <trans-unit id="1ad7ab62792840cafd5c6a7e7c21e711f92ec2c4" translate="yes" xml:space="preserve">
          <source>If a subclass of dict defines a method &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;key&lt;/em&gt; is not present, the &lt;code&gt;d[key]&lt;/code&gt; operation calls that method with the key &lt;em&gt;key&lt;/em&gt; as argument. The &lt;code&gt;d[key]&lt;/code&gt; operation then returns or raises whatever is returned or raised by the &lt;code&gt;__missing__(key)&lt;/code&gt; call. No other operations or methods invoke &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; is not defined, &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised. &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; must be a method; it cannot be an instance variable:</source>
          <target state="translated">dict의 서브 클래스가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 메소드를 정의 하고 &lt;em&gt;키&lt;/em&gt; 가없는 경우 &lt;code&gt;d[key]&lt;/code&gt; 조작은 키 &lt;em&gt;키&lt;/em&gt; 를 인수로 사용하여 해당 메소드를 호출합니다 . 그런 다음 &lt;code&gt;d[key]&lt;/code&gt; 작업은 &lt;code&gt;__missing__(key)&lt;/code&gt; 호출에 의해 반환되거나 발생한 것을 반환하거나 발생 시킵니다 . 다른 작업이나 메서드는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 호출하지 않습니다 . 경우 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 정의되지 않은, &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 은 메서드 여야합니다. 인스턴스 변수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f05a402a563718610b92e3f5ebab6bc115c75aff" translate="yes" xml:space="preserve">
          <source>If a subclass overrides the constructor, it must make sure it invokes the base class constructor (&lt;code&gt;Process.__init__()&lt;/code&gt;) before doing anything else to the process.</source>
          <target state="translated">서브 클래스가 생성자를 대체하는 경우 &lt;code&gt;Process.__init__()&lt;/code&gt; 다른 작업을 수행하기 전에 기본 클래스 생성자 ( Process .__ init __ () )를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7167bd01592177c6831e227c0f96cfa70f5703f6" translate="yes" xml:space="preserve">
          <source>If a test is dependent on a specific condition of the operating system then verify the condition already exists before attempting the test.</source>
          <target state="translated">테스트가 운영 체제의 특정 조건에 종속 된 경우 테스트를 시도하기 전에 조건이 이미 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fdb64156356707d7f00a7d8b9a96bfe1ba13d7ee" translate="yes" xml:space="preserve">
          <source>If a test module defines &lt;code&gt;load_tests&lt;/code&gt; it will be called by &lt;a href=&quot;#unittest.TestLoader.loadTestsFromModule&quot;&gt;&lt;code&gt;TestLoader.loadTestsFromModule()&lt;/code&gt;&lt;/a&gt; with the following arguments:</source>
          <target state="translated">테스트 모듈을 정의하는 경우 &lt;code&gt;load_tests&lt;/code&gt; 가 호출됩니다 &lt;a href=&quot;#unittest.TestLoader.loadTestsFromModule&quot;&gt; &lt;code&gt;TestLoader.loadTestsFromModule()&lt;/code&gt; &lt;/a&gt; 다음 인수와 함께 :</target>
        </trans-unit>
        <trans-unit id="56a75cd42f01b47ed5b176576dca9593b3d7d4ee" translate="yes" xml:space="preserve">
          <source>If a timeout occurs, it cancels the task and raises &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt;&lt;code&gt;asyncio.TimeoutError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시간 초과가 발생하면 작업이 취소되고 &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt; &lt;code&gt;asyncio.TimeoutError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4894447c60737f3d9dbafbd5dd46efa9b16f3b36" translate="yes" xml:space="preserve">
          <source>If a timestamp stored in SQLite has a fractional part longer than 6 numbers, its value will be truncated to microsecond precision by the timestamp converter.</source>
          <target state="translated">SQLite에 저장된 타임 스탬프가 6보다 긴 소수 부분을 가진 경우 타임 스탬프 변환기에서 해당 값이 마이크로 초 정밀도로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="5ac42206d9872e5d1063a9d182b043d77e4d7069" translate="yes" xml:space="preserve">
          <source>If a valid &lt;em&gt;align&lt;/em&gt; value is specified, it can be preceded by a &lt;em&gt;fill&lt;/em&gt; character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (&amp;ldquo;&lt;code&gt;{&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;}&lt;/code&gt;&amp;rdquo;) as the &lt;em&gt;fill&lt;/em&gt; character in a &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;formatted string literal&lt;/a&gt; or when using the &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn&amp;rsquo;t affect the &lt;a href=&quot;functions#format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">유효한 &lt;em&gt;정렬&lt;/em&gt; 값이 지정되면 임의의 문자가 될 수 있는 &lt;em&gt;채우기&lt;/em&gt; 문자가 앞에 올 수 있으며 생략하면 기본값이 공백이됩니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;포맷 된 문자열 리터럴에서&lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 메소드 를 사용할 때 리터럴 중괄호 (&amp;ldquo; &lt;code&gt;{&lt;/code&gt; &amp;rdquo;또는&amp;ldquo; &lt;code&gt;}&lt;/code&gt; &amp;rdquo;)를 &lt;em&gt;채우기&lt;/em&gt; 문자로 사용할 수 없습니다 . 그러나 중첩 된 대체 필드와 함께 중괄호를 삽입 할 수 있습니다. 이 제한은 &lt;a href=&quot;functions#format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; 함수에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7c00602bdfa725779b622a293e31f264d4ee274c" translate="yes" xml:space="preserve">
          <source>If a warning is reported and doesn&amp;rsquo;t match any registered filter then the &amp;ldquo;default&amp;rdquo; action is applied (hence its name).</source>
          <target state="translated">경고가보고되고 등록 된 필터와 일치하지 않으면 &quot;기본&quot;작업이 적용됩니다 (따라서 이름).</target>
        </trans-unit>
        <trans-unit id="cb0337d207d18ad7007727b229c1af4d0cd626a1" translate="yes" xml:space="preserve">
          <source>If a welcome message is not received, then &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt;&lt;code&gt;AuthenticationError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">환영 메시지가 수신되지 않으면 &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt; &lt;code&gt;AuthenticationError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8fcc1d5a91e23de43d9a5dc52b88297e33f33bba" translate="yes" xml:space="preserve">
          <source>If all awaitables are completed successfully, the result is an aggregate list of returned values. The order of result values corresponds to the order of awaitables in &lt;em&gt;aws&lt;/em&gt;.</source>
          <target state="translated">모든 대기 가능 항목이 성공적으로 완료되면 결과는 전체 반환 값 목록입니다. 결과 값의 순서는 &lt;em&gt;aws&lt;/em&gt; 의 대기 가능 순서와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="2547834e994630d32d2037a19c05c10c7d6ee975" translate="yes" xml:space="preserve">
          <source>If all of the input data was decompressed and returned (either because this was less than &lt;em&gt;max_length&lt;/em&gt; bytes, or because &lt;em&gt;max_length&lt;/em&gt; was negative), the &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">모든 입력 데이터가 압축 해제되어 리턴 된 경우 (이 값이 &lt;em&gt;max_length&lt;/em&gt; 바이트 미만 이거나 &lt;em&gt;max_length&lt;/em&gt; 가 음수 이기 때문에 ) &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성은 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e121cbdbd9c19e9656d52cccebd105f837012c9" translate="yes" xml:space="preserve">
          <source>If all of the input data was decompressed and returned (either because this was less than &lt;em&gt;max_length&lt;/em&gt; bytes, or because &lt;em&gt;max_length&lt;/em&gt; was negative), the &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">모든 입력 데이터가 압축 해제되어 리턴 된 경우 (이 값이 &lt;em&gt;max_length&lt;/em&gt; 바이트 미만 이거나 &lt;em&gt;max_length&lt;/em&gt; 가 음수 이기 때문에 ) &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성은 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d829aa8e2300eed8aa97b16a76abdddadb851327" translate="yes" xml:space="preserve">
          <source>If all you want is a unique ID, you should probably call &lt;a href=&quot;#uuid.uuid1&quot;&gt;&lt;code&gt;uuid1()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uuid.uuid4&quot;&gt;&lt;code&gt;uuid4()&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#uuid.uuid1&quot;&gt;&lt;code&gt;uuid1()&lt;/code&gt;&lt;/a&gt; may compromise privacy since it creates a UUID containing the computer&amp;rsquo;s network address. &lt;a href=&quot;#uuid.uuid4&quot;&gt;&lt;code&gt;uuid4()&lt;/code&gt;&lt;/a&gt; creates a random UUID.</source>
          <target state="translated">원하는 것이 고유 ID이면 &lt;a href=&quot;#uuid.uuid1&quot;&gt; &lt;code&gt;uuid1()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#uuid.uuid4&quot;&gt; &lt;code&gt;uuid4()&lt;/code&gt; &lt;/a&gt; 호출해야합니다 . 참고 &lt;a href=&quot;#uuid.uuid1&quot;&gt; &lt;code&gt;uuid1()&lt;/code&gt; &lt;/a&gt; 는 컴퓨터의 네트워크 주소를 포함하는 UUID를 생성하기 때문에 개인 정보를 손상시킬 수 있습니다. &lt;a href=&quot;#uuid.uuid4&quot;&gt; &lt;code&gt;uuid4()&lt;/code&gt; &lt;/a&gt; 는 임의의 UUID를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a1f1d33458f6e961931c3b1a1e541c58fb116cf6" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;action&lt;/em&gt; was provided to the constructor, one of the threads will have called it prior to being released. Should this call raise an error, the barrier is put into the broken state.</source>
          <target state="translated">생성자에 &lt;em&gt;조치&lt;/em&gt; 가 제공된 경우 스레드 중 하나가 해제되기 전에이를 호출했을 것입니다. 이 호출로 오류가 발생하면 장벽이 끊어진 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="299a160b2857a2e046717940313b837ea0255ecb" translate="yes" xml:space="preserve">
          <source>If an address of &amp;lsquo;0.0.0.0&amp;rsquo; is used, the address will not be a connectable end point on Windows. If you require a connectable end-point, you should use &amp;lsquo;127.0.0.1&amp;rsquo;.</source>
          <target state="translated">주소가 '0.0.0.0'인 경우 주소는 Windows에서 연결 가능한 엔드 포인트가 아닙니다. 연결 가능한 엔드 포인트가 필요한 경우 '127.0.0.1'을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fafdef20b0392cfa5094409aaee99cd26f4d16c3" translate="yes" xml:space="preserve">
          <source>If an ancestor is found with a level other than NOTSET, then that ancestor&amp;rsquo;s level is treated as the effective level of the logger where the ancestor search began, and is used to determine how a logging event is handled.</source>
          <target state="translated">조상이 NOTSET 이외의 레벨로 발견되면 해당 조상의 레벨은 조상 검색이 시작된 로거의 유효 레벨로 처리되며 로깅 이벤트 처리 방법을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="042dca6beb53678ea3404d9d765bfdcb1778c211" translate="yes" xml:space="preserve">
          <source>If an application archive has a shebang line, it may have the executable bit set on POSIX systems, to allow it to be executed directly.</source>
          <target state="translated">응용 프로그램 아카이브에 shebang 라인이있는 경우 POSIX 시스템에 실행 가능 비트가 설정되어이를 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="256f4fa29f36d441db33ab5876bc2ec311be265f" translate="yes" xml:space="preserve">
          <source>If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeroes, losing significance, but keeping the value unchanged:</source>
          <target state="translated">응용 프로그램이 유의성 추적을 신경 쓰지 않으면 지수와 후행 0을 쉽게 제거하고 유의성을 잃지 만 값은 변경하지 않고 유지합니다.</target>
        </trans-unit>
        <trans-unit id="adadff191e4f3cff9fafee17cbdf1b2c0fa260d7" translate="yes" xml:space="preserve">
          <source>If an argument outside those ranges is given, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">해당 범위 밖의 인수가 제공되면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac5211f8f4fad0b439f05ba8bae6b1f51d4b9857" translate="yes" xml:space="preserve">
          <source>If an argument outside those ranges is given, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. All default to &lt;code&gt;0&lt;/code&gt; except &lt;em&gt;tzinfo&lt;/em&gt;, which defaults to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">해당 범위 밖의 인수가 제공되면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;em&gt;tzinfo를&lt;/em&gt; 제외한 모든 기본값은 &lt;code&gt;0&lt;/code&gt; 이며 기본값은 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cf8ab7a4f610ae0e91814539a3ad269a9742c39" translate="yes" xml:space="preserve">
          <source>If an attempt is made to change any object in a way that is not permitted with regard to the &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;Namespaces in XML&lt;/a&gt; recommendation, this exception is raised.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;XML&lt;/a&gt; 권장 사항 의 네임 스페이스 와 관련하여 허용되지 않는 방식으로 오브젝트를 변경하려고 시도하면 이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53d8a1b202b136b96256c5d5d6a53d98a6548fc9" translate="yes" xml:space="preserve">
          <source>If an error is encountered during configuration, this function will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; with a suitably descriptive message. The following is a (possibly incomplete) list of conditions which will raise an error:</source>
          <target state="translated">구성 중에 오류가 발생하면이 함수는 적절한 설명 메시지와 함께 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. 다음은 오류가 발생할 수있는 조건 목록입니다 (아마도 불완전한 목록).</target>
        </trans-unit>
        <trans-unit id="4574f822c008c1deacbc94bbf73252f1957961ce" translate="yes" xml:space="preserve">
          <source>If an error is encountered when obtaining the contents of an uploaded file (for example, when the user interrupts the form submission by clicking on a Back or Cancel button) the &lt;code&gt;done&lt;/code&gt; attribute of the object for the field will be set to the value -1.</source>
          <target state="translated">업로드 된 파일의 내용을 가져올 때 오류가 발생하는 경우 (예 : 사용자가 뒤로 또는 취소 단추를 클릭하여 양식 제출을 중단 한 경우) 필드에 대한 오브젝트 의 &lt;code&gt;done&lt;/code&gt; 속성은 값 -1로 설정됩니다. .</target>
        </trans-unit>
        <trans-unit id="f60eea2b32259323dba912ba5d7f1dfbdfc71476" translate="yes" xml:space="preserve">
          <source>If an exception is raised by the call, then is re-raised by &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt;&lt;code&gt;_callmethod()&lt;/code&gt;&lt;/a&gt;. If some other exception is raised in the manager&amp;rsquo;s process then this is converted into a &lt;code&gt;RemoteError&lt;/code&gt; exception and is raised by &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt;&lt;code&gt;_callmethod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출로 예외가 발생하면 &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt; &lt;code&gt;_callmethod()&lt;/code&gt; &lt;/a&gt; 의해 다시 발생합니다 . 관리자 프로세스에서 다른 예외가 발생하면 &lt;code&gt;RemoteError&lt;/code&gt; 예외 로 변환되고 &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt; &lt;code&gt;_callmethod()&lt;/code&gt; &lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f85bdbc54de505eec7f8ff1f7bab9e90300754e6" translate="yes" xml:space="preserve">
          <source>If an exception is raised by the decorated method and a module was added to &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;, then the module will be removed to prevent a partially initialized module from being in left in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;. If the module was already in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; then it is left alone.</source>
          <target state="translated">데코 레이팅 된 메소드에 의해 예외가 발생하고 모듈이 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에 추가 된 경우 , 부분적으로 초기화 된 모듈이 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에 남아 있지 않도록 모듈이 제거됩니다 . 모듈이 이미 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 있으면 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="a7bc6eb7f643b6c0eaaabf73ac57b62236f71065" translate="yes" xml:space="preserve">
          <source>If an exception is raised during a &lt;code&gt;setUpClass&lt;/code&gt; then the tests in the class are not run and the &lt;code&gt;tearDownClass&lt;/code&gt; is not run. Skipped classes will not have &lt;code&gt;setUpClass&lt;/code&gt; or &lt;code&gt;tearDownClass&lt;/code&gt; run. If the exception is a &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt; exception then the class will be reported as having been skipped instead of as an error.</source>
          <target state="translated">&lt;code&gt;setUpClass&lt;/code&gt; 중에 예외가 발생 하면 클래스의 테스트 가 실행되지 않고 &lt;code&gt;tearDownClass&lt;/code&gt; 가 실행되지 않습니다. 건너 뛴 클래스에는 &lt;code&gt;setUpClass&lt;/code&gt; 또는 &lt;code&gt;tearDownClass&lt;/code&gt; 가 실행 되지 않습니다 . 예외가 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 예외 인 경우 클래스는 오류 대신 건너 뛴 것으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="4533ac88ecc0c7c6a8780ebbf4203e5ab1429294" translate="yes" xml:space="preserve">
          <source>If an exception is raised during execution of the exit handlers, a traceback is printed (unless &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; is raised) and the exception information is saved. After all exit handlers have had a chance to run the last exception to be raised is re-raised.</source>
          <target state="translated">예외가 종료 핸들러의 실행 중에 발생하는 경우, 역 추적은 (하지 않는 한 인쇄 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; 없이이&lt;/a&gt; 발생) 및 예외 정보가 저장됩니다. 모든 엑시트 핸들러가 마지막 예외를 실행할 수있는 기회를 얻은 후 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d998d88a8ce16f7be9ebac1b439bf842f586529" translate="yes" xml:space="preserve">
          <source>If an exception is raised from the &lt;em&gt;sni_callback&lt;/em&gt; function the TLS connection will terminate with a fatal TLS alert message &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_HANDSHAKE_FAILURE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;sni_callback&lt;/em&gt; 함수 에서 예외가 발생 하면 치명적인 TLS 경고 메시지 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_HANDSHAKE_FAILURE&lt;/code&gt; &lt;/a&gt; 와 함께 TLS 연결이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a43dea4c94d3c2af36ea8264f982c5356cb01f9" translate="yes" xml:space="preserve">
          <source>If an exception is raised in a &lt;code&gt;setUpModule&lt;/code&gt; then none of the tests in the module will be run and the &lt;code&gt;tearDownModule&lt;/code&gt; will not be run. If the exception is a &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt; exception then the module will be reported as having been skipped instead of as an error.</source>
          <target state="translated">&lt;code&gt;setUpModule&lt;/code&gt; 에서 예외가 발생 하면 모듈의 테스트가 실행 되지 않으며 &lt;code&gt;tearDownModule&lt;/code&gt; 이 실행되지 않습니다. 예외가 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 예외 인 경우 모듈은 오류 대신 건너 뛴 것으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="dd703abca148b756a14a9c781a44d9f0b2ac0696" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the coroutine, the returned Future will be notified. It can also be used to cancel the task in the event loop:</source>
          <target state="translated">코 루틴에서 예외가 발생하면 반환 된 미래에 통지됩니다. 또한 이벤트 루프에서 작업을 취소하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0153b7e6f09b5f4cdeeae21ebab69aa25ec08be0" translate="yes" xml:space="preserve">
          <source>If an implementation wishes to retain compatibility with the existing email package policies, &lt;em&gt;name&lt;/em&gt; should be the case preserved name (all characters up to the &amp;lsquo;&lt;code&gt;:&lt;/code&gt;&amp;rsquo; separator), while &lt;em&gt;value&lt;/em&gt; should be the unfolded value (all line separator characters removed, but whitespace kept intact), stripped of leading whitespace.</source>
          <target state="translated">구현시 기존 전자 메일 패키지 정책과의 호환성을 유지하려면 &lt;em&gt;name&lt;/em&gt; 은 대소 문자를 유지 한 이름 ( ' &lt;code&gt;:&lt;/code&gt; '구분 기호 까지의 모든 문자 ) 이어야 하고 &lt;em&gt;value&lt;/em&gt; 는 펼친 값이어야합니다 (모든 행 구분 기호 문자는 제거되지만 공백은 유지됨) 그대로), 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e6cd0b0b3afc2fba0e7fc3c8402c2b5436592af6" translate="yes" xml:space="preserve">
          <source>If an implementation wishes to retain compatibility with the existing email package policies, the &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; should be strings or string subclasses that do not change the content of the passed in arguments.</source>
          <target state="translated">구현시 기존 이메일 패키지 정책과의 호환성을 유지하려면 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 은 전달 된 인수의 내용을 변경하지 않는 문자열 또는 문자열 서브 클래스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4cbad0f63bdd9fa84f8130dbeeb23dc3b6cbb508" translate="yes" xml:space="preserve">
          <source>If an object containing an unsupported type was marshalled with &lt;a href=&quot;#marshal.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#marshal.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; will substitute &lt;code&gt;None&lt;/code&gt; for the unmarshallable type.</source>
          <target state="translated">지원되지 않는 유형을 포함하는 객체가 &lt;a href=&quot;#marshal.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 로 마샬링 된 경우 &lt;a href=&quot;#marshal.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 는 정렬 할 수없는 유형을 &lt;code&gt;None&lt;/code&gt; 으로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="4d67c470c08505e21fcfb4046a1dfce4ba755fea" translate="yes" xml:space="preserve">
          <source>If any Task or Future from the &lt;em&gt;aws&lt;/em&gt; sequence is &lt;em&gt;cancelled&lt;/em&gt;, it is treated as if it raised &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; &amp;ndash; the &lt;code&gt;gather()&lt;/code&gt; call is &lt;strong&gt;not&lt;/strong&gt; cancelled in this case. This is to prevent the cancellation of one submitted Task/Future to cause other Tasks/Futures to be cancelled.</source>
          <target state="translated">로부터 어떤 작업 또는 미래의 경우 &lt;em&gt;AWS의&lt;/em&gt; 순서가되어 &lt;em&gt;취소&lt;/em&gt; 가 제기처럼 처리된다 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; 을&lt;/a&gt; - &lt;code&gt;gather()&lt;/code&gt; 호출되어 &lt;strong&gt;있지&lt;/strong&gt; ,이 경우 취소했다. 이는 제출 된 하나의 작업 / 미래가 취소되어 다른 작업 / 미래가 취소되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="05fdb3a1d8014df423fd4d720c0c1096b43f8291" translate="yes" xml:space="preserve">
          <source>If any argument is a float and there are fractional microseconds, the fractional microseconds left over from all arguments are combined and their sum is rounded to the nearest microsecond using round-half-to-even tiebreaker. If no argument is a float, the conversion and normalization processes are exact (no information is lost).</source>
          <target state="translated">어떤 인수가 부동 소수점이고 소수 마이크로 초가있는 경우 모든 인수에서 남은 소수 마이크로 초가 합산되고 그 반은 반에서 11까지의 타이 브레이커를 사용하여 가장 가까운 마이크로 초로 반올림됩니다. 부동 소수점이없는 경우 변환 및 정규화 프로세스가 정확합니다 (정보 손실 없음).</target>
        </trans-unit>
        <trans-unit id="9d56491638c3d7ac65a56ae607e299d4de0401c5" translate="yes" xml:space="preserve">
          <source>If any awaitable in &lt;em&gt;aws&lt;/em&gt; is a coroutine, it is automatically scheduled as a Task.</source>
          <target state="translated">&lt;em&gt;aws&lt;/em&gt; 에서 대기 가능한 항목이 코 루틴 인 경우 작업으로 자동 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="c5aebf3c75452198e6c5d279e23fde1e5f1cf025" translate="yes" xml:space="preserve">
          <source>If any members of the iterable are exceptions they will be raised instead of returned:</source>
          <target state="translated">iterable의 멤버가 예외 인 경우 반환되는 대신 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="27863231d65cea126a57b6d24dbf17c8f2a32c4a" translate="yes" xml:space="preserve">
          <source>If any of &lt;em&gt;suffix&lt;/em&gt;, &lt;em&gt;prefix&lt;/em&gt;, and &lt;em&gt;dir&lt;/em&gt; are not &lt;code&gt;None&lt;/code&gt;, they must be the same type. If they are bytes, the returned name will be bytes instead of str. If you want to force a bytes return value with otherwise default behavior, pass &lt;code&gt;suffix=b''&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 &lt;em&gt;접미사&lt;/em&gt; , &lt;em&gt;접두사&lt;/em&gt; 및 &lt;em&gt;디렉토리가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; , 그들은 같은 유형이어야합니다. 이들이 바이트 인 경우 반환되는 이름은 str 대신 바이트입니다. 기본 동작이 아닌 바이트 반환 값을 강제로 적용하려면 &lt;code&gt;suffix=b''&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="907ec62b4e5199551950ce42a0c4c3bcd986262a" translate="yes" xml:space="preserve">
          <source>If any option is given, the script will exit with one of these values: &lt;code&gt;0&lt;/code&gt; if the user site-packages directory is enabled, &lt;code&gt;1&lt;/code&gt; if it was disabled by the user, &lt;code&gt;2&lt;/code&gt; if it is disabled for security reasons or by an administrator, and a value greater than 2 if there is an error.</source>
          <target state="translated">옵션이 제공되면 스크립트는 다음 값 중 하나로 종료됩니다. &lt;code&gt;0&lt;/code&gt; 사용자 사이트 패키지 디렉토리가 활성화 된 경우 , &lt;code&gt;1&lt;/code&gt; 사용자가 비활성화 한 경우 , &lt;code&gt;2&lt;/code&gt; 보안상의 이유로 또는 관리자가 비활성화 한 경우, 오류가있는 경우 2보다 큰 값</target>
        </trans-unit>
        <trans-unit id="24d1e1e82f1f2ee9e1949816fed45d7ac33121d6" translate="yes" xml:space="preserve">
          <source>If any precondition isn&amp;rsquo;t met (e.g. not TLS 1.3, PHA not enabled), an &lt;a href=&quot;#ssl.SSLError&quot;&gt;&lt;code&gt;SSLError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">사전 조건이 충족되지 않으면 (예 : TLS 1.3이 아닌 PHA가 활성화되지 않은 경우) &lt;a href=&quot;#ssl.SSLError&quot;&gt; &lt;code&gt;SSLError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37276ee5d3e42e8336da18222c175ce80e212073" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; is given, &lt;em&gt;object&lt;/em&gt; should be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; (e.g. &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;). In this case, if &lt;em&gt;object&lt;/em&gt; is a &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;) object, then &lt;code&gt;str(bytes, encoding, errors)&lt;/code&gt; is equivalent to &lt;a href=&quot;#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode(encoding, errors)&lt;/code&gt;&lt;/a&gt;. Otherwise, the bytes object underlying the buffer object is obtained before calling &lt;a href=&quot;#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode()&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#binaryseq&quot;&gt;Binary Sequence Types &amp;mdash; bytes, bytearray, memoryview&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt; for information on buffer objects.</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 중 적어도 하나 가 제공되면 &lt;em&gt;object&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 오브젝트&lt;/a&gt; (예 : &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 여야합니다 . 이 경우 &lt;em&gt;object&lt;/em&gt; 가 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 객체 인 경우 &lt;code&gt;str(bytes, encoding, errors)&lt;/code&gt; 는 &lt;a href=&quot;#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode(encoding, errors)&lt;/code&gt; &lt;/a&gt; . 그렇지 않은 경우, &lt;a href=&quot;#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 버퍼 객체의 기본이되는 bytes 객체가 취득 됩니다. 버퍼 객체에 대한 내용 은 &lt;a href=&quot;#binaryseq&quot;&gt;이진 시퀀스 유형-바이트, 바이트 배열, 메모리 뷰&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a08ad24a4b377d2b7fc4af8b136e23de7adba584" translate="yes" xml:space="preserve">
          <source>If authentication is requested but no authentication key is specified then the return value of &lt;code&gt;current_process().authkey&lt;/code&gt; is used (see &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt;). This value will be automatically inherited by any &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object that the current process creates. This means that (by default) all processes of a multi-process program will share a single authentication key which can be used when setting up connections between themselves.</source>
          <target state="translated">인증이 요청되었지만 인증 키가 지정되지 않은 경우 &lt;code&gt;current_process().authkey&lt;/code&gt; 의 반환 값 이 사용됩니다 ( &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 참조 ). 이 값은 현재 프로세스가 생성 한 모든 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체에 의해 자동으로 상속됩니다 . 즉, 기본적으로 다중 프로세스 프로그램의 모든 프로세스는 단일 인증 키를 공유하며이 키는 서로간에 연결을 설정할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e20a8216bd741a08c72ea1c6ed3561d4c0175953" translate="yes" xml:space="preserve">
          <source>If backslashes immediately precede a double quotation mark, every pair of backslashes is interpreted as a literal backslash. If the number of backslashes is odd, the last backslash escapes the next double quotation mark as described in rule 3.</source>
          <target state="translated">백 슬래시가 큰 따옴표 앞에 즉시 있으면 모든 백 슬래시 쌍은 리터럴 백 슬래시로 해석됩니다. 백 슬래시 수가 홀수이면 규칙 3에 설명 된대로 마지막 백 슬래시는 다음 큰 따옴표를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="c7232d0f35717aeee89b7f01e116b1ce15ef033a" translate="yes" xml:space="preserve">
          <source>If both are aware and have different &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes, &lt;code&gt;a-b&lt;/code&gt; acts as if &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; were first converted to naive UTC datetimes first. The result is &lt;code&gt;(a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None)
- b.utcoffset())&lt;/code&gt; except that the implementation never overflows.</source>
          <target state="translated">둘 다 인식하고 다른 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 , &lt;code&gt;a-b&lt;/code&gt; 는 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 가 처음으로 순진한 UTC 날짜 시간으로 먼저 변환 된 것처럼 작동 &lt;em&gt;합니다&lt;/em&gt; . 결과는 &lt;code&gt;(a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset())&lt;/code&gt; 이며 구현이 오버플로되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21414aeb047eb522c66140299d9c38360d32d811" translate="yes" xml:space="preserve">
          <source>If both are naive, or both are aware and have the same &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute, the &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes are ignored, and the result is a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object &lt;em&gt;t&lt;/em&gt; such that &lt;code&gt;datetime2 + t == datetime1&lt;/code&gt;. No time zone adjustments are done in this case.</source>
          <target state="translated">모두 순진, 또는 두 가지 모두가 인식하고 같은 경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 의&lt;/a&gt; 1, 속성을 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성이 무시되고 결과가있다 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 객체 &lt;em&gt;t&lt;/em&gt; 그러한 &lt;code&gt;datetime2 + t == datetime1&lt;/code&gt; . 이 경우 시간대 조정이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6f9d2935f72f29d54f2f1f7b010c9d2226c8c57" translate="yes" xml:space="preserve">
          <source>If both callbacks signal EOF then &lt;em&gt;spawn&lt;/em&gt; will probably never return, unless &lt;em&gt;select&lt;/em&gt; throws an error on your platform when passed three empty lists. This is a bug, documented in &lt;a href=&quot;https://bugs.python.org/issue26228&quot;&gt;issue 26228&lt;/a&gt;.</source>
          <target state="translated">두 콜백 모두 EOF 신호를 보내면 빈 목록이 세 개 전달 될 때 &lt;em&gt;select&lt;/em&gt; 에서 플랫폼에 오류가 발생 하지 않는 한 &lt;em&gt;스폰&lt;/em&gt; 은 절대 반환되지 않습니다 . 이것은 &lt;a href=&quot;https://bugs.python.org/issue26228&quot;&gt;이슈 26228에&lt;/a&gt; 설명 된 버그 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b4e1f0c2a028fb50a27b3609c4d3827918db65a" translate="yes" xml:space="preserve">
          <source>If both comparands are aware, and have the same &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute, the common &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute is ignored and the base datetimes are compared. If both comparands are aware and have different &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes, the comparands are first adjusted by subtracting their UTC offsets (obtained from &lt;code&gt;self.utcoffset()&lt;/code&gt;).</source>
          <target state="translated">두 비교자가 모두 인식하고 동일한 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 공통 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성은 무시되고 기본 날짜 시간이 비교됩니다. 두 비교자가 모두 인식하고 다른 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 비교는 먼저 UTC 오프셋을 &lt;code&gt;self.utcoffset()&lt;/code&gt; 에서 획득 함 ) 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d641321a92c1f78e2ea9102fa10acde0aa020cab" translate="yes" xml:space="preserve">
          <source>If both comparands are aware, and have the same &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute, the common &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute is ignored and the base times are compared. If both comparands are aware and have different &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes, the comparands are first adjusted by subtracting their UTC offsets (obtained from &lt;code&gt;self.utcoffset()&lt;/code&gt;). In order to stop mixed-type comparisons from falling back to the default comparison by object address, when a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object is compared to an object of a different type, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised unless the comparison is &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. The latter cases return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">두 비교자가 모두 인식하고 동일한 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 공통 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성은 무시되고 기본 시간이 비교됩니다. 두 비교자가 모두 인식하고 다른 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 비교는 먼저 UTC 오프셋을 &lt;code&gt;self.utcoffset()&lt;/code&gt; 에서 획득 함 ) 조정됩니다. 혼합 유형 비교가 객체 주소 별 기본 비교로 돌아 가지 않도록 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체를 다른 유형의 객체와 비교할 때 비교가 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 가 아니면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 후자의 경우 각각 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="640348c16c27f575031545c2822c834b44553bb0" translate="yes" xml:space="preserve">
          <source>If both options are given, user base and user site will be printed (always in this order), separated by &lt;a href=&quot;os#os.pathsep&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 옵션이 모두 제공되면 &lt;a href=&quot;os#os.pathsep&quot;&gt; &lt;code&gt;os.pathsep&lt;/code&gt; 로&lt;/a&gt; 구분되어 사용자 기반과 사용자 사이트가 항상 순서대로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="5636d444bb3185b61c96a8708aabc4aa7259b873" translate="yes" xml:space="preserve">
          <source>If both the &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt;&lt;code&gt;dispatch_table&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt;&lt;code&gt;reducer_override()&lt;/code&gt;&lt;/a&gt; are defined, then &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt;&lt;code&gt;reducer_override()&lt;/code&gt;&lt;/a&gt; method takes priority.</source>
          <target state="translated">양쪽 경우 &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt; &lt;code&gt;dispatch_table&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt; &lt;code&gt;reducer_override()&lt;/code&gt; &lt;/a&gt; 정의되고, 다음 &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt; &lt;code&gt;reducer_override()&lt;/code&gt; &lt;/a&gt; 메소드가 우선한다.</target>
        </trans-unit>
        <trans-unit id="0084a482d9be8fc3608c4a7c65006f2f65fc3c35" translate="yes" xml:space="preserve">
          <source>If called for &lt;em&gt;text&lt;/em&gt; that doesn&amp;rsquo;t include a period character (&lt;code&gt;'.'&lt;/code&gt;), it will complete from names currently defined in &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; and keywords (as defined by the &lt;a href=&quot;keyword#module-keyword&quot;&gt;&lt;code&gt;keyword&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">마침표 문자 ( &lt;code&gt;'.'&lt;/code&gt; )를 포함하지 않는 &lt;em&gt;텍스트&lt;/em&gt; 를 호출하면 현재 &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; 에&lt;/a&gt; 정의 된 이름 , &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 및 키워드 ( &lt;a href=&quot;keyword#module-keyword&quot;&gt; &lt;code&gt;keyword&lt;/code&gt; &lt;/a&gt; 모듈에 의해 정의 됨 )에서 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="9c41c5f7a69443087f2a6c12e1c09cf638abbcdd" translate="yes" xml:space="preserve">
          <source>If called for a dotted name, it will try to evaluate anything without obvious side-effects (functions will not be evaluated, but it can generate calls to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;) up to the last part, and find matches for the rest via the &lt;a href=&quot;functions#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; function. Any exception raised during the evaluation of the expression is caught, silenced and &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">점으로 구분 된 이름을 요구하는 경우는 명백한 부작용없이 어떤 평가하려고합니다 (기능 평가되지 않습니다,하지만 그것은 호출을 생성 할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; )를 마지막 부분에, 그리고를 통해 나머지 일치를 찾을 &lt;a href=&quot;functions#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 기능. 식을 평가하는 동안 발생한 예외는 포착되고, 침묵되며, &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1db8ca82fb7c38924ab71e87dc3d3f1a74a4cf1e" translate="yes" xml:space="preserve">
          <source>If called without arguments (or with &lt;code&gt;tz=None&lt;/code&gt;) the system local timezone is assumed for the target timezone. The &lt;code&gt;.tzinfo&lt;/code&gt; attribute of the converted datetime instance will be set to an instance of &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; with the zone name and offset obtained from the OS.</source>
          <target state="translated">인수없이 (또는 &lt;code&gt;tz=None&lt;/code&gt; 으로 ) 호출 하면 대상 시간대에 대해 시스템 로컬 시간대가 사용됩니다. 변환 된 datetime 인스턴스 의 &lt;code&gt;.tzinfo&lt;/code&gt; 속성은 OS에서 가져온 영역 이름 및 오프셋을 가진 &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 인스턴스로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed2cd04e51ea2f7f1214c3f95faf0caa16f6b695" translate="yes" xml:space="preserve">
          <source>If calling &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; raises an exception this exception is propagated unchanged.</source>
          <target state="translated">&lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; 를&lt;/a&gt; 호출 하면 예외가 발생하면이 예외는 변경되지 않고 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="52f86dd4dc687753a2bf5577502ab4b99d7efacd" translate="yes" xml:space="preserve">
          <source>If completion is enabled, completing commands will be done automatically, and completing of commands args is done by calling &lt;code&gt;complete_foo()&lt;/code&gt; with arguments &lt;em&gt;text&lt;/em&gt;, &lt;em&gt;line&lt;/em&gt;, &lt;em&gt;begidx&lt;/em&gt;, and &lt;em&gt;endidx&lt;/em&gt;. &lt;em&gt;text&lt;/em&gt; is the string prefix we are attempting to match: all returned matches must begin with it. &lt;em&gt;line&lt;/em&gt; is the current input line with leading whitespace removed, &lt;em&gt;begidx&lt;/em&gt; and &lt;em&gt;endidx&lt;/em&gt; are the beginning and ending indexes of the prefix text, which could be used to provide different completion depending upon which position the argument is in.</source>
          <target state="translated">완료가 사용 가능한 경우 명령 완료가 자동으로 수행되며 인수 &lt;em&gt;text&lt;/em&gt; , &lt;em&gt;line&lt;/em&gt; , &lt;em&gt;begidx&lt;/em&gt; 및 &lt;em&gt;endidx&lt;/em&gt; 와 함께 &lt;code&gt;complete_foo()&lt;/code&gt; 를 호출하여 명령 완료가 완료됩니다 . &lt;em&gt;text&lt;/em&gt; 는 일치시키려는 문자열 접두사입니다. 반환 된 모든 일치 항목은 시작해야합니다. &lt;em&gt;line&lt;/em&gt; 은 선행 공백이 제거 된 현재 입력 라인이고 &lt;em&gt;begidx&lt;/em&gt; 및 &lt;em&gt;endidx&lt;/em&gt; 는 접두사 텍스트의 시작 및 끝 인덱스이며 인수의 위치에 따라 다른 완성을 제공하는 데 사용될 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fec01fc70889d001a5e5d5e76ebae2d730e863d" translate="yes" xml:space="preserve">
          <source>If cookie has the named cookie-attribute, return its value. Otherwise, return &lt;em&gt;default&lt;/em&gt;.</source>
          <target state="translated">cookie에 이름이 cookie-attribute 인 경우 해당 값을 리턴하십시오. 그렇지 않으면 &lt;em&gt;default를&lt;/em&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="67343970e1a1e7fd355a02bf76406a533d9720d9" translate="yes" xml:space="preserve">
          <source>If defined, &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt;&lt;code&gt;persistent_load()&lt;/code&gt;&lt;/a&gt; should return the object specified by the persistent ID &lt;em&gt;pid&lt;/em&gt;. If an invalid persistent ID is encountered, an &lt;a href=&quot;#pickle.UnpicklingError&quot;&gt;&lt;code&gt;UnpicklingError&lt;/code&gt;&lt;/a&gt; should be raised.</source>
          <target state="translated">정의 된 경우 &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt; &lt;code&gt;persistent_load()&lt;/code&gt; &lt;/a&gt; 는 지속적 ID &lt;em&gt;pid로&lt;/em&gt; 지정된 오브젝트를 리턴해야합니다 . 유효하지 않은 영구 ID가 발견되면 &lt;a href=&quot;#pickle.UnpicklingError&quot;&gt; &lt;code&gt;UnpicklingError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6474a9f723b4362b908bfb9818eb48e3ccd80f58" translate="yes" xml:space="preserve">
          <source>If discovery is started in a directory containing a package, either from the command line or by calling &lt;a href=&quot;#unittest.TestLoader.discover&quot;&gt;&lt;code&gt;TestLoader.discover()&lt;/code&gt;&lt;/a&gt;, then the package &lt;code&gt;__init__.py&lt;/code&gt; will be checked for &lt;code&gt;load_tests&lt;/code&gt;. If that function does not exist, discovery will recurse into the package as though it were just another directory. Otherwise, discovery of the package&amp;rsquo;s tests will be left up to &lt;code&gt;load_tests&lt;/code&gt; which is called with the following arguments:</source>
          <target state="translated">발견은 명령 줄에서 또는 전화로하거나, 패키지를 포함하는 디렉토리에 시작되는 경우 &lt;a href=&quot;#unittest.TestLoader.discover&quot;&gt; &lt;code&gt;TestLoader.discover()&lt;/code&gt; &lt;/a&gt; , 다음 패키지 &lt;code&gt;__init__.py&lt;/code&gt; 가 검사됩니다 &lt;code&gt;load_tests&lt;/code&gt; . 해당 기능이 존재하지 않으면 검색은 마치 다른 디렉토리 인 것처럼 패키지로 재귀됩니다. 그렇지 않으면 패키지 테스트의 발견은 다음 인수로 호출되는 &lt;code&gt;load_tests&lt;/code&gt; 로 남습니다 .</target>
        </trans-unit>
        <trans-unit id="f3d282be498a158600c18b4f9266fe30d1c639ff" translate="yes" xml:space="preserve">
          <source>If echo free input is unavailable getpass() falls back to printing a warning message to &lt;em&gt;stream&lt;/em&gt; and reading from &lt;code&gt;sys.stdin&lt;/code&gt; and issuing a &lt;a href=&quot;#getpass.GetPassWarning&quot;&gt;&lt;code&gt;GetPassWarning&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반향없는 입력을 사용할 수없는 경우 getpass ()는 &lt;code&gt;sys.stdin&lt;/code&gt; 에서 &lt;em&gt;스트림&lt;/em&gt; 및 읽기 위한 경고 메시지 인쇄 및 &lt;a href=&quot;#getpass.GetPassWarning&quot;&gt; &lt;code&gt;GetPassWarning&lt;/code&gt; &lt;/a&gt; 발행으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="f9040a07fe9c1bf05ab58e880006a37bf7aba0a3" translate="yes" xml:space="preserve">
          <source>If either &lt;a href=&quot;exceptions#BrokenPipeError&quot;&gt;&lt;code&gt;BrokenPipeError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#ConnectionResetError&quot;&gt;&lt;code&gt;ConnectionResetError&lt;/code&gt;&lt;/a&gt; exception is raised when writing &lt;em&gt;input&lt;/em&gt; into &lt;em&gt;stdin&lt;/em&gt;, the exception is ignored. This condition occurs when the process exits before all data are written into &lt;em&gt;stdin&lt;/em&gt;.</source>
          <target state="translated">어느 경우 &lt;a href=&quot;exceptions#BrokenPipeError&quot;&gt; &lt;code&gt;BrokenPipeError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#ConnectionResetError&quot;&gt; &lt;code&gt;ConnectionResetError&lt;/code&gt; &lt;/a&gt; 기록 할 때 예외가 발생 &lt;em&gt;입력&lt;/em&gt; 에 &lt;em&gt;표준 입력을&lt;/em&gt; , 예외는 무시됩니다. 이 조건은 모든 데이터가 &lt;em&gt;stdin에&lt;/em&gt; 기록되기 전에 프로세스가 종료 될 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="be4f44baf0b306a7dfcbf05bf212b256e0623d5a" translate="yes" xml:space="preserve">
          <source>If either format string is not supported by the &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module, then the objects will always compare as unequal (even if the format strings and buffer contents are identical):</source>
          <target state="translated">&lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 모듈에서 형식 문자열을 지원하지 않으면 형식 문자열과 버퍼 내용이 동일한 경우에도 객체가 항상 동일하지 않은 것으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8cf100d8fc5cb58fc7dd2777bc293a42ecb2c2" translate="yes" xml:space="preserve">
          <source>If end of file is found and no bytes were read, raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt;. Otherwise, when nothing matches, return &lt;code&gt;(-1, None, data)&lt;/code&gt; where &lt;em&gt;data&lt;/em&gt; is the bytes received so far (may be empty bytes if a timeout happened).</source>
          <target state="translated">파일 끝이 발견되고 바이트가 읽히지 않으면 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; 를 발생 시키십시오&lt;/a&gt; . 그렇지 않으면 때 아무것도 일치, 반환 &lt;code&gt;(-1, None, data)&lt;/code&gt; &lt;em&gt;데이터&lt;/em&gt; (시간 초과가 발생하는 경우 빈 바이트 수 있음) 지금까지받은 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="2e0604802c9b1772457ef4937546641bbade8d20" translate="yes" xml:space="preserve">
          <source>If exception(s) occur, an &lt;a href=&quot;#shutil.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; is raised with a list of reasons.</source>
          <target state="translated">예외 가 발생하면 이유 목록과 함께 &lt;a href=&quot;#shutil.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71e75d563ccaca9a7a7e9ebdc073bdb50eae3f53" translate="yes" xml:space="preserve">
          <source>If fullname contains a &amp;lsquo;.&amp;rsquo;, the finders will be for the package containing fullname, otherwise they will be all registered top level finders (i.e. those on both sys.meta_path and sys.path_hooks).</source>
          <target state="translated">fullname에 '.'이 포함되어 있으면 파인더는 fullname을 포함하는 패키지에 대한 것이며, 그렇지 않으면 모든 등록 된 최상위 레벨 파인더입니다 (예 : sys.meta_path 및 sys.path_hooks에있는 것).</target>
        </trans-unit>
        <trans-unit id="01110f1d67d6e9a5355fb7676557e4a50b926762" translate="yes" xml:space="preserve">
          <source>If given a list or string, the initializer is passed to the new array&amp;rsquo;s &lt;a href=&quot;#array.array.fromlist&quot;&gt;&lt;code&gt;fromlist()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#array.array.frombytes&quot;&gt;&lt;code&gt;frombytes()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#array.array.fromunicode&quot;&gt;&lt;code&gt;fromunicode()&lt;/code&gt;&lt;/a&gt; method (see below) to add initial items to the array. Otherwise, the iterable initializer is passed to the &lt;a href=&quot;#array.array.extend&quot;&gt;&lt;code&gt;extend()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">목록이나 문자열이 제공되면 초기화 프로그램은 새 배열의 &lt;a href=&quot;#array.array.fromlist&quot;&gt; &lt;code&gt;fromlist()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#array.array.frombytes&quot;&gt; &lt;code&gt;frombytes()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#array.array.fromunicode&quot;&gt; &lt;code&gt;fromunicode()&lt;/code&gt; &lt;/a&gt; 메소드 (아래 참조)로 전달되어 배열에 초기 항목을 추가합니다. 그렇지 않으면, 반복 가능한 이니셜 라이저가 &lt;a href=&quot;#array.array.extend&quot;&gt; &lt;code&gt;extend()&lt;/code&gt; &lt;/a&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="2af680c07fb1f88b58852d1a71d38f2be07b2607" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;compress_type&lt;/em&gt; overrides the value given for the &lt;em&gt;compression&lt;/em&gt; parameter to the constructor for the new entry, or in the &lt;em&gt;zinfo_or_arcname&lt;/em&gt; (if that is a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance). Similarly, &lt;em&gt;compresslevel&lt;/em&gt; will override the constructor if given.</source>
          <target state="translated">주어진 경우, &lt;em&gt;compress_type&lt;/em&gt; 은 &lt;em&gt;압축&lt;/em&gt; 매개 변수에 제공된 값을 새 항목의 생성자 또는 &lt;em&gt;zinfo_or_arcname&lt;/em&gt; ( &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스 인 경우) 으로 대체 합니다. 마찬가지로, &lt;em&gt;압축&lt;/em&gt; 레벨은 주어진 경우 생성자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="609f14a5d88e9d16549cb48055d0b9bddf3d600e" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;default&lt;/em&gt; will be returned if the object does not provide means to retrieve the size. Otherwise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">주어진 경우, 객체가 크기를 검색하는 수단을 제공하지 않으면 &lt;em&gt;기본값&lt;/em&gt; 이 반환됩니다. 그렇지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f38935e27047cadfc0462ecbb2dd5665952c0eb" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;doc&lt;/em&gt; will be the docstring of the property attribute. Otherwise, the property will copy &lt;em&gt;fget&lt;/em&gt;&amp;rsquo;s docstring (if it exists). This makes it possible to create read-only properties easily using &lt;a href=&quot;#property&quot;&gt;&lt;code&gt;property()&lt;/code&gt;&lt;/a&gt; as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt;:</source>
          <target state="translated">주어진 경우, &lt;em&gt;doc&lt;/em&gt; 은 속성 속성의 docstring이됩니다. 그렇지 않으면이 속성은 &lt;em&gt;fget&lt;/em&gt; 의 docstring (있는 경우)을 복사 합니다. &lt;a href=&quot;#property&quot;&gt; &lt;code&gt;property()&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;데코레이터&lt;/a&gt; 로 사용하여 읽기 전용 속성을 쉽게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47874343de9186efbf845a71e131f69e43d9eafd" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;extra_args&lt;/em&gt; is a sequence of &lt;code&gt;(name, value)&lt;/code&gt; pairs that will be used as extra keywords arguments when the archiver callable is used.</source>
          <target state="translated">지정된 경우 &lt;em&gt;extra_args&lt;/em&gt; 는 아카이버 호출 가능을 사용할 때 추가 키워드 인수로 사용되는 일련의 &lt;code&gt;(name, value)&lt;/code&gt; 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="fa087efbf7689c1c4adc26135d774f6bca7fd2e9" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;level&lt;/em&gt; should be either a numeric logging level or its string equivalent (for example either &lt;code&gt;&quot;ERROR&quot;&lt;/code&gt; or &lt;code&gt;logging.ERROR&lt;/code&gt;). The default is &lt;code&gt;logging.INFO&lt;/code&gt;.</source>
          <target state="translated">주어진 경우, &lt;em&gt;level&lt;/em&gt; 은 숫자 로깅 레벨이거나 이에 상응하는 문자열이어야합니다 (예 : &lt;code&gt;&quot;ERROR&quot;&lt;/code&gt; 또는 &lt;code&gt;logging.ERROR&lt;/code&gt; ). 기본값은 &lt;code&gt;logging.INFO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6742a72866173acc4c64ea3543dda8799bca224e" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;logger&lt;/em&gt; should be a &lt;a href=&quot;logging#logging.Logger&quot;&gt;&lt;code&gt;logging.Logger&lt;/code&gt;&lt;/a&gt; object or a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; giving the name of a logger. The default is the root logger, which will catch all messages.</source>
          <target state="translated">주어진 &lt;em&gt;로거&lt;/em&gt; 는 &lt;a href=&quot;logging#logging.Logger&quot;&gt; &lt;code&gt;logging.Logger&lt;/code&gt; &lt;/a&gt; 객체 또는 로거의 이름을 지정 하는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 이어야합니다 . 기본값은 루트 로거이며 모든 메시지를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="5d1743db3a55e3d1d851253caed66fb63e4ec4ba" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;startupinfo&lt;/em&gt; will be a &lt;a href=&quot;#subprocess.STARTUPINFO&quot;&gt;&lt;code&gt;STARTUPINFO&lt;/code&gt;&lt;/a&gt; object, which is passed to the underlying &lt;code&gt;CreateProcess&lt;/code&gt; function. &lt;em&gt;creationflags&lt;/em&gt;, if given, can be one or more of the following flags:</source>
          <target state="translated">주어진 경우 &lt;em&gt;startupinfo&lt;/em&gt; 는 &lt;a href=&quot;#subprocess.STARTUPINFO&quot;&gt; &lt;code&gt;STARTUPINFO&lt;/code&gt; &lt;/a&gt; 객체가되며 기본 &lt;code&gt;CreateProcess&lt;/code&gt; 함수에 전달됩니다 . &lt;em&gt;creationflags&lt;/em&gt; 는 지정된 경우 다음 플래그 중 하나 이상일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44cb0cd8c45e437d22c4b42cdbed99611a31b48c" translate="yes" xml:space="preserve">
          <source>If greater than zero, specifies how much space, in character widths, to allocate for the text label, if less than zero, specifies a minimum width. If zero or unspecified, the natural width of the text label is used.</source>
          <target state="translated">0보다 큰 경우 문자 너비로 텍스트 레이블에 할당 할 공간을 지정합니다 (0보다 작은 경우). 최소 너비를 지정합니다. 0으로 지정하거나 지정하지 않으면 텍스트 레이블의 자연 너비가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="718d9d10f66de628c1bab6c410a233a3ac12213c" translate="yes" xml:space="preserve">
          <source>If importing a module fails, for example due to a syntax error, then this will be recorded as a single error and discovery will continue. If the import failure is due to &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt; being raised, it will be recorded as a skip instead of an error.</source>
          <target state="translated">예를 들어 구문 오류로 인해 모듈 가져 오기에 실패하면 단일 오류로 기록되고 검색이 계속됩니다. 가져 오기 실패로 인해 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 가 발생하면 오류 대신 건너 뛰기로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="79f23909838ce6528a57771817116435f2739054" translate="yes" xml:space="preserve">
          <source>If input is a number greater than 10 or smaller than 0.5, speed is set to 0. Speedstrings are mapped to speedvalues as follows:</source>
          <target state="translated">입력 값이 10보다 크거나 0.5보다 작은 경우 속도는 0으로 설정됩니다. 스피드 스트링은 다음과 같이 속도 값에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="5989f9c468e2d22d579475f78ddf414d62121f7d" translate="yes" xml:space="preserve">
          <source>If invalid arguments are passed in, it will issue an error:</source>
          <target state="translated">잘못된 인수가 전달되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93a952190c9333e02d422078312ba6dfe53a93fe" translate="yes" xml:space="preserve">
          <source>If invoked without arguments, clear all cookies. If given a single argument, only cookies belonging to that &lt;em&gt;domain&lt;/em&gt; will be removed. If given two arguments, cookies belonging to the specified &lt;em&gt;domain&lt;/em&gt; and URL &lt;em&gt;path&lt;/em&gt; are removed. If given three arguments, then the cookie with the specified &lt;em&gt;domain&lt;/em&gt;, &lt;em&gt;path&lt;/em&gt; and &lt;em&gt;name&lt;/em&gt; is removed.</source>
          <target state="translated">인수없이 호출 된 경우 모든 쿠키를 지우십시오. 단일 인수가 제공되면 해당 &lt;em&gt;도메인에&lt;/em&gt; 속한 쿠키 만 제거됩니다. 두 개의 인수가 제공되면 지정된 &lt;em&gt;도메인&lt;/em&gt; 및 URL &lt;em&gt;경로에&lt;/em&gt; 속하는 쿠키 가 제거됩니다. 세 개의 인수가 제공되면 지정된 &lt;em&gt;도메인&lt;/em&gt; , &lt;em&gt;경로&lt;/em&gt; 및 &lt;em&gt;이름을&lt;/em&gt; 가진 쿠키 가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="00314545be4a33bc05a395af1ac6499955ea39c3" translate="yes" xml:space="preserve">
          <source>If it falls back to the boilerplate, there are no more possible methods to try, so this is where the default implementation should live.</source>
          <target state="translated">상용구로 넘어 가면 더 이상 시도 할 수있는 방법이 없으므로 기본 구현이 적용되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="967a860c70a7b59392bb2e73d01133edf0c97f92" translate="yes" xml:space="preserve">
          <source>If it is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, unescaped non-ASCII characters in &lt;em&gt;string&lt;/em&gt; are encoded into UTF-8 bytes.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;em&gt;문자열&lt;/em&gt; 에서 이스케이프되지 않은 비 ASCII 문자는 UTF-8 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="cb04b7e71c45bcf4eca27bc7c2fbd2f0873fc977" translate="yes" xml:space="preserve">
          <source>If it is a &lt;em&gt;string&lt;/em&gt;, you must also give the &lt;em&gt;encoding&lt;/em&gt; (and optionally, &lt;em&gt;errors&lt;/em&gt;) parameters; &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray()&lt;/code&gt;&lt;/a&gt; then converts the string to bytes using &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;str.encode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그것은 경우 &lt;em&gt;문자열이&lt;/em&gt; , 당신은 또한 제공해야합니다 &lt;em&gt;인코딩&lt;/em&gt; (및 선택적 &lt;em&gt;오류&lt;/em&gt; ) 매개 변수; 그런 다음 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;str.encode()&lt;/code&gt; &lt;/a&gt; 사용하여 문자열을 바이트로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="2e5fd905d7cb634eab36e5f7022d541dd08678a8" translate="yes" xml:space="preserve">
          <source>If it is an &lt;em&gt;integer&lt;/em&gt;, the array will have that size and will be initialized with null bytes.</source>
          <target state="translated">그것이이면 &lt;em&gt;정수&lt;/em&gt; 어레이는 그 크기를 가질 것이며, 널 바이트로 초기화한다.</target>
        </trans-unit>
        <trans-unit id="ddd8748ceb366423912a917b053d73ddd49a2edd" translate="yes" xml:space="preserve">
          <source>If it is an &lt;em&gt;iterable&lt;/em&gt;, it must be an iterable of integers in the range &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt;, which are used as the initial contents of the array.</source>
          <target state="translated">그것이 있다면 &lt;em&gt;반복 가능을&lt;/em&gt; , 상기 범위 내에서 정수의 반복 가능한이어야 &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; 어레이의 초기 내용으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="b3634a5c7e10c7f8808e49a74bf8a6b4e7fd50a4" translate="yes" xml:space="preserve">
          <source>If it is an object conforming to the &lt;em&gt;buffer&lt;/em&gt; interface, a read-only buffer of the object will be used to initialize the bytes array.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 인터페이스를 준수하는 객체 인 경우 객체 의 읽기 전용 버퍼를 사용하여 바이트 배열을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9cdca5ec79b73d99eb39c2ec4e51e31cb8a1c732" translate="yes" xml:space="preserve">
          <source>If it is an open file object, the archive will be written to that file object, which must be open for writing in bytes mode.</source>
          <target state="translated">열린 파일 객체 인 경우 해당 파일 객체에 아카이브가 기록되며 바이트 모드로 쓰기 위해 열려야합니다.</target>
        </trans-unit>
        <trans-unit id="44706e24cce0d97822e15cc2cdd3d9f22b0e7993" translate="yes" xml:space="preserve">
          <source>If it is called without arguments, it will print the contents of &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; on the standard output, followed by the value of &lt;a href=&quot;#site.USER_BASE&quot;&gt;&lt;code&gt;USER_BASE&lt;/code&gt;&lt;/a&gt; and whether the directory exists, then the same thing for &lt;a href=&quot;#site.USER_SITE&quot;&gt;&lt;code&gt;USER_SITE&lt;/code&gt;&lt;/a&gt;, and finally the value of &lt;a href=&quot;#site.ENABLE_USER_SITE&quot;&gt;&lt;code&gt;ENABLE_USER_SITE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인자가없이 호출되면, 그것의 내용을 인쇄합니다 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에을&lt;/a&gt; 의 값에 의해 다음, 표준 출력에 &lt;a href=&quot;#site.USER_BASE&quot;&gt; &lt;code&gt;USER_BASE&lt;/code&gt; &lt;/a&gt; 및 디렉토리가 존재하는지, 다음에 같은 일 &lt;a href=&quot;#site.USER_SITE&quot;&gt; &lt;code&gt;USER_SITE&lt;/code&gt; &lt;/a&gt; , 그리고 마지막으로 값 &lt;a href=&quot;#site.ENABLE_USER_SITE&quot;&gt; &lt;code&gt;ENABLE_USER_SITE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e4f1f075612bafa0ec058bfc6d0d37706417e13" translate="yes" xml:space="preserve">
          <source>If it is desired to completely ignore cancellation (not recommended) the &lt;code&gt;shield()&lt;/code&gt; function should be combined with a try/except clause, as follows:</source>
          <target state="translated">취소 (권장하지 않음)를 완전히 무시하려면 &lt;code&gt;shield()&lt;/code&gt; 함수를 다음과 같이 try / except 절과 결합해야합니다.</target>
        </trans-unit>
        <trans-unit id="01192a9f95f76e2eb7be7dea65299a6baa4bc2ab" translate="yes" xml:space="preserve">
          <source>If it is desired to send data to the process&amp;rsquo; &lt;em&gt;stdin&lt;/em&gt;, the process needs to be created with &lt;code&gt;stdin=PIPE&lt;/code&gt;. Similarly, to get anything other than &lt;code&gt;None&lt;/code&gt; in the result tuple, the process has to be created with &lt;code&gt;stdout=PIPE&lt;/code&gt; and/or &lt;code&gt;stderr=PIPE&lt;/code&gt; arguments.</source>
          <target state="translated">프로세스의 &lt;em&gt;stdin으로&lt;/em&gt; 데이터를 보내려면 &lt;code&gt;stdin=PIPE&lt;/code&gt; 로 프로세스를 작성해야합니다 . 마찬가지로 결과 튜플에서 &lt;code&gt;None&lt;/code&gt; 이외의 값을 얻으려면 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 / 또는 &lt;code&gt;stderr=PIPE&lt;/code&gt; 인수를 사용 하여 프로세스를 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="36e5b58797559e7d7360ba24eec2865eada11f86" translate="yes" xml:space="preserve">
          <source>If it is false, the buffer&amp;rsquo;s mutability is ignored and behaviour is as for a read-only buffer, except that the 1024 byte limit mentioned above is avoided &amp;ndash; so long as the buffer you pass is at least as long as what the operating system wants to put there, things should work.</source>
          <target state="translated">False 인 경우 버퍼의 변경 가능성은 무시되고 동작은 읽기 전용 버퍼와 동일합니다. 단, 위에서 언급 한 1024 바이트 제한을 피해야합니다. 전달하는 버퍼가 운영 체제에서 원하는만큼 거기에 넣으려면 일이 잘되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f61ccb0d5046c26bcd78e1f1f830264ae4214727" translate="yes" xml:space="preserve">
          <source>If it is temporary or not.</source>
          <target state="translated">일시적인지 아닌지.</target>
        </trans-unit>
        <trans-unit id="04ea50b1d44dcb9e42bb0e15073254ec5d646ca9" translate="yes" xml:space="preserve">
          <source>If it is the name of a file, or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;, the archive will be written to that file.</source>
          <target state="translated">파일 이름이거나 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은 객체&lt;/a&gt; 인 경우 아카이브가 해당 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b445164335a5373b51d2219b8df35ac044c9a899" translate="yes" xml:space="preserve">
          <source>If it must be ignored the next N times.</source>
          <target state="translated">다음 N 번 무시해야하는 경우</target>
        </trans-unit>
        <trans-unit id="9df4a0ab1dcaed9052df14308a45b7732b61c521" translate="yes" xml:space="preserve">
          <source>If it was set via line number, it checks if &lt;code&gt;b.line&lt;/code&gt; is the same as the one in the frame also passed as argument. If the breakpoint was set via function name, we have to check we are in the right frame (the right function) and if we are in its first executable line.</source>
          <target state="translated">행 번호를 통해 설정된 경우 &lt;code&gt;b.line&lt;/code&gt; 이 인수로 전달 된 프레임의 b.line 과 동일한 지 확인합니다 . 함수 이름을 통해 중단 점이 설정 되었다면, 오른쪽 프레임 (오른쪽 기능)에 있는지 그리고 첫 번째 실행 가능한 행에 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d92fb59232d64b94f33278f3d1f5a387b837f8fe" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument. If a key being added is already present, the value from the keyword argument replaces the value from the positional argument.</source>
          <target state="translated">키워드 인수가 제공되면 키워드 인수 및 해당 값이 위치 인수에서 작성된 사전에 추가됩니다. 추가되는 키가 이미 존재하면 키워드 인수의 값이 위치 인수의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="298d4ffd5a1a153665fe65937860d394e9ce55c5" translate="yes" xml:space="preserve">
          <source>If line is blank, delete it, otherwise clear to end of line.</source>
          <target state="translated">줄이 비어 있으면 삭제하고 그렇지 않으면 줄 끝을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="e5b5e5077dcfb2543cd16c5eaa3971bdfe538b2b" translate="yes" xml:space="preserve">
          <source>If modifying your production classes to add defaults isn&amp;rsquo;t to your liking then there are more options. One of these is simply to use an instance as the spec rather than the class. The other is to create a subclass of the production class and add the defaults to the subclass without affecting the production class. Both of these require you to use an alternative object as the spec. Thankfully &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; supports this - you can simply pass the alternative object as the &lt;em&gt;autospec&lt;/em&gt; argument:</source>
          <target state="translated">프로덕션 클래스를 수정하여 기본값을 추가하는 것이 마음에 들지 않으면 더 많은 옵션이 있습니다. 이 중 하나는 단순히 클래스가 아닌 스펙으로 인스턴스를 사용하는 것입니다. 다른 하나는 프로덕션 클래스의 서브 클래스를 작성하고 프로덕션 클래스에 영향을주지 않고 기본값을 서브 클래스에 추가하는 것입니다. 이 두 가지 모두 스펙으로 대체 오브젝트를 사용해야합니다. 고맙게도 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 는 이것을 지원합니다. &lt;em&gt;autospec&lt;/em&gt; 인수 로 대체 객체를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17ae7629605c78f2ad74ec604b851cab4b9b9b18" translate="yes" xml:space="preserve">
          <source>If multiple directive comments are used for a single example, then they are combined:</source>
          <target state="translated">단일 지시문에 여러 지시문 주석이 사용 된 경우 다음과 같이 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="7453bc4e224cf54a5aeef5110e30a59fe07fd075" translate="yes" xml:space="preserve">
          <source>If multiple files are found, later files are used as fallbacks for earlier ones. To allow setting the fallback, &lt;a href=&quot;copy#copy.copy&quot;&gt;&lt;code&gt;copy.copy()&lt;/code&gt;&lt;/a&gt; is used to clone each translation object from the cache; the actual instance data is still shared with the cache.</source>
          <target state="translated">여러 파일이 발견되면 이후 파일은 이전 파일에 대한 폴백으로 사용됩니다. 폴백을 설정하기 위해 &lt;a href=&quot;copy#copy.copy&quot;&gt; &lt;code&gt;copy.copy()&lt;/code&gt; &lt;/a&gt; 를 사용하여 캐시에서 각 변환 객체를 복제합니다. 실제 인스턴스 데이터는 여전히 캐시와 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="8452349a938b29d0b36774ae51c5edbf888f2236" translate="yes" xml:space="preserve">
          <source>If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as &lt;code&gt;sorted(iterable, key=keyfunc, reverse=True)[0]&lt;/code&gt; and &lt;code&gt;heapq.nlargest(1, iterable, key=keyfunc)&lt;/code&gt;.</source>
          <target state="translated">여러 항목이 최대 인 경우이 함수는 처음 발생한 항목을 반환합니다. 이는 &lt;code&gt;sorted(iterable, key=keyfunc, reverse=True)[0]&lt;/code&gt; 및 &lt;code&gt;heapq.nlargest(1, iterable, key=keyfunc)&lt;/code&gt; 와 같은 다른 정렬 안정성 보존 도구와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c3c9e3d0380e3afc1d3245499ca493b8cdbe62b9" translate="yes" xml:space="preserve">
          <source>If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as &lt;code&gt;sorted(iterable, key=keyfunc)[0]&lt;/code&gt; and &lt;code&gt;heapq.nsmallest(1,
iterable, key=keyfunc)&lt;/code&gt;.</source>
          <target state="translated">여러 항목이 최소 인 경우이 함수는 처음 발생한 항목을 반환합니다. 이는 &lt;code&gt;sorted(iterable, key=keyfunc)[0]&lt;/code&gt; 및 &lt;code&gt;heapq.nsmallest(1, iterable, key=keyfunc)&lt;/code&gt; 와 같은 다른 정렬 안정성 보존 도구와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="f562be4d3070268fdf6e36d18ca74512853d9784" translate="yes" xml:space="preserve">
          <source>If multiple processes are enqueuing objects, it is possible for the objects to be received at the other end out-of-order. However, objects enqueued by the same process will always be in the expected order with respect to each other.</source>
          <target state="translated">여러 프로세스가 개체를 큐에 넣는 경우 다른 쪽 끝에서 순서가 잘못된 개체를받을 수 있습니다. 그러나 동일한 프로세스에 의해 대기열에 포함 된 객체는 항상 서로에 대해 예상되는 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b636cc065ec6ef42100c3456eb6185694bc5d4f7" translate="yes" xml:space="preserve">
          <source>If name is not given, this examines the available implementations to find one with the required feature set. If no implementation can be found, raise an &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt;. The features list must be a sequence of &lt;code&gt;(feature,
version)&lt;/code&gt; pairs which are passed to the &lt;code&gt;hasFeature()&lt;/code&gt; method on available &lt;code&gt;DOMImplementation&lt;/code&gt; objects.</source>
          <target state="translated">이름을 지정하지 않으면 사용 가능한 구현을 검사하여 필요한 기능 세트가있는 구현을 찾습니다. 구현을 찾을 수 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 기능 목록은 사용 가능한 &lt;code&gt;DOMImplementation&lt;/code&gt; 오브젝트 에서 &lt;code&gt;hasFeature()&lt;/code&gt; 메소드 로 전달되는 일련의 &lt;code&gt;(feature, version)&lt;/code&gt; 쌍 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="26b2ddfd53b925d6fed2be41cbcc44c6bb590446" translate="yes" xml:space="preserve">
          <source>If neither &lt;em&gt;encoding&lt;/em&gt; nor &lt;em&gt;errors&lt;/em&gt; is given, &lt;code&gt;str(object)&lt;/code&gt; returns &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;object.__str__()&lt;/code&gt;&lt;/a&gt;, which is the &amp;ldquo;informal&amp;rdquo; or nicely printable string representation of &lt;em&gt;object&lt;/em&gt;. For string objects, this is the string itself. If &lt;em&gt;object&lt;/em&gt; does not have a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt; method, then &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; falls back to returning &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr(object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어느 경우 &lt;em&gt;인코딩&lt;/em&gt; 이나 &lt;em&gt;오류가&lt;/em&gt; 주어진다, &lt;code&gt;str(object)&lt;/code&gt; 반환 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;object.__str__()&lt;/code&gt; &lt;/a&gt; 의 &quot;비공식&quot;또는 잘 인쇄 문자열 표현, &lt;em&gt;개체를&lt;/em&gt; . 문자열 객체의 경우 문자열 자체입니다. 경우 &lt;em&gt;개체가&lt;/em&gt; 이없는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; 다음 메서드를 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 복귀로 다시 떨어질 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr(object)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54d4d7ea65c7bad4af575a43659f61752244563a" translate="yes" xml:space="preserve">
          <source>If neither &lt;em&gt;weights&lt;/em&gt; nor &lt;em&gt;cum_weights&lt;/em&gt; are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the &lt;em&gt;population&lt;/em&gt; sequence. It is a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; to specify both &lt;em&gt;weights&lt;/em&gt; and &lt;em&gt;cum_weights&lt;/em&gt;.</source>
          <target state="translated">어느 경우 &lt;em&gt;무게&lt;/em&gt; 도 &lt;em&gt;cum_weights가&lt;/em&gt; 지정, 선택은 동일한 확률로 만들어집니다. 무게 시퀀스가 공급되는 경우, 같은 길이이어야 &lt;em&gt;인구&lt;/em&gt; 순서. &lt;em&gt;weights&lt;/em&gt; 와 &lt;em&gt;cum_weights를&lt;/em&gt; 모두 지정 하는 것은 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="23e71f0816a9280c7a878c8d86eb0dc6fc13142c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;.mo&lt;/code&gt; file is found, this function raises &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;fallback&lt;/em&gt; is false (which is the default), and returns a &lt;a href=&quot;#gettext.NullTranslations&quot;&gt;&lt;code&gt;NullTranslations&lt;/code&gt;&lt;/a&gt; instance if &lt;em&gt;fallback&lt;/em&gt; is true.</source>
          <target state="translated">&lt;code&gt;.mo&lt;/code&gt; 파일이 없으면 이 함수 는 &lt;a href=&quot;#gettext.NullTranslations&quot;&gt; &lt;code&gt;NullTranslations&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 백이&lt;/em&gt; false 인 경우 (기본값) &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 발생 시키고 폴&lt;em&gt; 백이&lt;/em&gt; true 인 경우 NullTranslations 인스턴스를 반환 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5fa475a3d6271ad07e3d7908a4b54063aef9110" translate="yes" xml:space="preserve">
          <source>If no &lt;em&gt;Content-Length&lt;/em&gt; header was supplied, urlretrieve can not check the size of the data it has downloaded, and just returns it. In this case you just have to assume that the download was successful.</source>
          <target state="translated">어떤 경우 &lt;em&gt;콘텐츠 길이&lt;/em&gt; 헤더가 제공되지 않았던, urlretrieve는 다운로드 한 데이터의 크기를 확인하고 그 값을 돌려줍니다 수 없습니다. 이 경우 다운로드가 성공했다고 가정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b66b107ef18a6ec29206237c3b1968db398d135d" translate="yes" xml:space="preserve">
          <source>If no argument is given, &lt;code&gt;0.0&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 제공되지 않으면 &lt;code&gt;0.0&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="46157783a038d57f5604740e6a9b616a64d86cd0" translate="yes" xml:space="preserve">
          <source>If no arguments are given, return current (canvaswidth, canvasheight). Else resize the canvas the turtles are drawing on. Do not alter the drawing window. To observe hidden parts of the canvas, use the scrollbars. With this method, one can make visible those parts of a drawing which were outside the canvas before.</source>
          <target state="translated">인수가 제공되지 않으면 current (canvaswidth, canvasheight)를 반환합니다. 그렇지 않으면 거북이가 그리는 캔버스의 크기를 조정하십시오. 도면 창을 변경하지 마십시오. 캔버스의 숨겨진 부분을 보려면 스크롤 막대를 사용하십시오. 이 방법을 사용하면 이전에 캔버스 외부에 있던 도면 부분을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e52dc62f51669f668a33bf460b7f8bf82543a15" translate="yes" xml:space="preserve">
          <source>If no arguments are specified, it defaults to:</source>
          <target state="translated">인수가 지정되지 않은 경우 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17c7d031f77de40c273fcdef1ad3809784776686" translate="yes" xml:space="preserve">
          <source>If no blocks match, this returns &lt;code&gt;(alo, blo, 0)&lt;/code&gt;.</source>
          <target state="translated">일치하는 블록이 없으면 &lt;code&gt;(alo, blo, 0)&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="fce8e5571f9d4e61cf90e90a33029b4a46f9fdae" translate="yes" xml:space="preserve">
          <source>If no encoding is specified, then the default of &lt;code&gt;'utf-8'&lt;/code&gt; will be returned.</source>
          <target state="translated">인코딩을 지정하지 않으면 기본값 &lt;code&gt;'utf-8'&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b220a8961aa756600716c9da500833111cb46e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the result will be: &lt;code&gt;abs(a-b) &amp;lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하지 않으면 결과는 &lt;code&gt;abs(a-b) &amp;lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ad242d3e56bb64a3f42863144cd33fbe0e3221f2" translate="yes" xml:space="preserve">
          <source>If no exception is being handled anywhere on the stack, a tuple containing three &lt;code&gt;None&lt;/code&gt; values is returned. Otherwise, the values returned are &lt;code&gt;(type, value, traceback)&lt;/code&gt;. Their meaning is: &lt;em&gt;type&lt;/em&gt; gets the type of the exception being handled (a subclass of &lt;a href=&quot;exceptions#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;); &lt;em&gt;value&lt;/em&gt; gets the exception instance (an instance of the exception type); &lt;em&gt;traceback&lt;/em&gt; gets a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#traceback-objects&quot;&gt;traceback object&lt;/a&gt; which encapsulates the call stack at the point where the exception originally occurred.</source>
          <target state="translated">스택의 어느 곳에서도 예외가 처리되지 않으면 3 개의 &lt;code&gt;None&lt;/code&gt; 값을 포함하는 튜플 이 반환됩니다. 그렇지 않으면 리턴 된 값은 &lt;code&gt;(type, value, traceback)&lt;/code&gt; 입니다. 의미는 다음과 같습니다. &lt;em&gt;type&lt;/em&gt; 은 처리중인 예외 유형 ( &lt;a href=&quot;exceptions#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 의 서브 클래스)을 가져옵니다 . &lt;em&gt;value&lt;/em&gt; 는 예외 인스턴스 (예외 유형의 인스턴스)를 가져옵니다. &lt;em&gt;traceback&lt;/em&gt; 은 예외가 원래 발생한 지점에서 호출 스택을 캡슐화 하는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#traceback-objects&quot;&gt;traceback 객체&lt;/a&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="a41e77f992af07e40b87a473294e5a8dd6509be1" translate="yes" xml:space="preserve">
          <source>If no free slot is immediately available, raise &lt;a href=&quot;#asyncio.QueueFull&quot;&gt;&lt;code&gt;QueueFull&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 슬롯이 즉시 &lt;a href=&quot;#asyncio.QueueFull&quot;&gt; &lt;code&gt;QueueFull&lt;/code&gt; &lt;/a&gt; 올리 십시오 .</target>
        </trans-unit>
        <trans-unit id="a4ced0a7f5ac900ff7845bee14185b70154aab39" translate="yes" xml:space="preserve">
          <source>If no module name is specified, all top level finders are produced.</source>
          <target state="translated">모듈 이름을 지정하지 않으면 모든 최상위 파인더가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="24caaa893d53e123c1924dd2370cf821d291d32b" translate="yes" xml:space="preserve">
          <source>If no name has been explicitly assigned to the Task, the default asyncio Task implementation generates a default name during instantiation.</source>
          <target state="translated">작업에 이름이 명시 적으로 지정되지 않은 경우 기본 asyncio 작업 구현은 인스턴스화 중에 기본 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="476aa611f101edc0bc9619df18f523a41ebd1c82" translate="yes" xml:space="preserve">
          <source>If no options are given, a dict with options/values for the item is returned. If &lt;em&gt;option&lt;/em&gt; is specified then the value for that option is returned. Otherwise, sets the options to the corresponding values as given by &lt;em&gt;kw&lt;/em&gt;.</source>
          <target state="translated">옵션이 제공되지 않으면 항목에 대한 옵션 / 값이 포함 된 dict가 반환됩니다. &lt;em&gt;option&lt;/em&gt; 이 지정 되면 해당 옵션의 값이 반환됩니다. 그렇지 않은 경우 옵션을 &lt;em&gt;kw&lt;/em&gt; 로 지정된 해당 값으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="bea50889454379e91f30a2f42fee654aa7de3fcf" translate="yes" xml:space="preserve">
          <source>If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary.</source>
          <target state="translated">위치 인수가 제공되지 않으면 빈 사전이 작성됩니다. 위치 인수가 제공되고 맵핑 오브젝트 인 경우 맵핑 오브젝트와 동일한 키-값 쌍으로 사전이 작성됩니다. 그렇지 않으면 위치 인수는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능한&lt;/a&gt; 객체 여야 합니다. iterable의 각 항목 자체는 정확히 두 개의 오브젝트가있는 iterable이어야합니다. 각 항목의 첫 번째 개체는 새 사전에서 키가되고 두 ​​번째 개체는 해당 값이됩니다. 키가 두 번 이상 나타나면 해당 키의 마지막 값이 새 사전의 해당 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="a3c12853377a0fdf751ae91320dcc270d07f4698" translate="yes" xml:space="preserve">
          <source>If no signature is defined for the method, a non-array value is returned. In Python this means that the type of the returned value will be something other than list.</source>
          <target state="translated">메소드에 서명이 정의되지 않은 경우 배열이 아닌 값이 리턴됩니다. 파이썬에서 이것은 반환 된 값의 유형이 list 이외의 것이 될 것임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="20bea7147a663550bf73fbd6aa35936ec0f1727f" translate="yes" xml:space="preserve">
          <source>If no such message exists, a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised if the method was called as &lt;a href=&quot;#mailbox.Mailbox.remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.Mailbox.__delitem__&quot;&gt;&lt;code&gt;__delitem__()&lt;/code&gt;&lt;/a&gt; but no exception is raised if the method was called as &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt;. The behavior of &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt; may be preferred if the underlying mailbox format supports concurrent modification by other processes.</source>
          <target state="translated">이러한 메시지가 존재하지 않으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 방법과 같이 호출 한 경우 예외가 발생 &lt;a href=&quot;#mailbox.Mailbox.remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;#mailbox.Mailbox.__delitem__&quot;&gt; &lt;code&gt;__delitem__()&lt;/code&gt; &lt;/a&gt; 그러나이 방법으로 호출 된 경우, 예외가 발생되지 않는 &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; . 기본 사서함 형식이 다른 프로세스에 의한 동시 수정을 지원하는 경우 &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; 동작이 선호 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cd75852ba66a942e3ef9da043c72d0616bb9860" translate="yes" xml:space="preserve">
          <source>If none of the above match, repeat all of the checks above for each of the types in the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-mro&quot;&gt;MRO&lt;/a&gt; (&lt;code&gt;typ.__mro__&lt;/code&gt;). Finally, if no other key yields a handler, check for a handler for the key &lt;code&gt;None&lt;/code&gt;. If there is no handler for &lt;code&gt;None&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; for the fully qualified name of the type.</source>
          <target state="translated">위와 일치하는 것이 없으면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-mro&quot;&gt;MRO&lt;/a&gt; 의 각 유형에 대해 위의 모든 검사를 반복하십시오 ( &lt;code&gt;typ.__mro__&lt;/code&gt; ). 마지막으로, 다른 키가 핸들러를 생성하지 않으면 &lt;code&gt;None&lt;/code&gt; 키에 대한 핸들러를 확인하십시오 . 에 대한 핸들러가없는 경우 &lt;code&gt;None&lt;/code&gt; , 인상 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를&lt;/a&gt; 유형의 정규화 된 이름을.</target>
        </trans-unit>
        <trans-unit id="6ab966a0bae68c566e4582d75c7e75e79ff60df0" translate="yes" xml:space="preserve">
          <source>If none of the candidates matches any of the preferences in &lt;em&gt;preferencelist&lt;/em&gt;, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">후보자의 아무도의 환경 설정의 일치하지 않는 경우 &lt;em&gt;preferencelist을&lt;/em&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0af9b04d52a06016027c04f7762d012d26364887" translate="yes" xml:space="preserve">
          <source>If none of the matrix elements are given, return the transformation matrix as a tuple of 4 elements. Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row t11, t12 and second row t21, 22. The determinant t11 * t22 - t12 * t21 must not be zero, otherwise an error is raised. Modify stretchfactor, shearfactor and tiltangle according to the given matrix.</source>
          <target state="translated">행렬 요소가 제공되지 않으면 변환 행렬을 4 개 요소의 튜플로 반환합니다. 그렇지 않으면 주어진 요소를 설정하고 첫 번째 행 t11, t12 및 두 번째 행 t21, 22로 구성된 행렬에 따라 거북이 모양을 변환합니다. 결정자 t11 * t22-t12 * t21은 0이 아니어야합니다. 그렇지 않으면 오류가 발생합니다. 주어진 행렬에 따라 신축 계수, 전단 계수 및 경사 각도를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="d022ff617a119c979b5be13e4ac716aea9e10a76" translate="yes" xml:space="preserve">
          <source>If none of the named files exist, the &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; instance will contain an empty dataset. An application which requires initial values to be loaded from a file should load the required file or files using &lt;a href=&quot;#configparser.ConfigParser.read_file&quot;&gt;&lt;code&gt;read_file()&lt;/code&gt;&lt;/a&gt; before calling &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; for any optional files:</source>
          <target state="translated">명명 된 파일이 없으면 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; &lt;/a&gt; 인스턴스에 빈 데이터 집합이 포함됩니다. 파일에서 초기 값을로드해야하는 응용 프로그램은 선택적 파일에 대해 &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;a href=&quot;#configparser.ConfigParser.read_file&quot;&gt; &lt;code&gt;read_file()&lt;/code&gt; &lt;/a&gt; 사용하여 필요한 파일을로드해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d63f28fd05ae33a3c995e80b7d7ac4d24283f9a6" translate="yes" xml:space="preserve">
          <source>If none of these keys produce a handler, raise a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; for the full MIME type.</source>
          <target state="translated">이러한 키가 핸들러를 생성하지 않으면 전체 MIME 유형에 대해 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c4b559d6709f523acb559ebc9de05a632f179410" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, &lt;em&gt;daemon&lt;/em&gt; explicitly sets whether the thread is daemonic. If &lt;code&gt;None&lt;/code&gt; (the default), the daemonic property is inherited from the current thread.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , &lt;em&gt;daemon&lt;/em&gt; 은 스레드가 &lt;em&gt;데몬&lt;/em&gt; 인지 여부를 명시 적으로 설정합니다. 경우 &lt;code&gt;None&lt;/code&gt; (기본값) 악마의 속성은 현재 스레드에서 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c475ada572eb526f097538d76dc4f24e8fb21ac" translate="yes" xml:space="preserve">
          <source>If not passed as a parameter when creating the object, this attribute is initialized upon first access or when the first record is read from the file.</source>
          <target state="translated">객체를 생성 할 때 매개 변수로 전달되지 않으면이 속성은 처음 액세스 할 때 또는 파일에서 첫 번째 레코드를 읽을 때 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b0f653097180825fd4fc47faf0827556509908" translate="yes" xml:space="preserve">
          <source>If not specified, the directory to serve is the current working directory.</source>
          <target state="translated">지정되지 않은 경우 제공 할 디렉토리는 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="46415929d11820d8c6bb9f358d9a2092933c6fcf" translate="yes" xml:space="preserve">
          <source>If one comparand is naive and the other is aware, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised if an order comparison is attempted. For equality comparisons, naive instances are never equal to aware instances.</source>
          <target state="translated">하나의 비교가 순진하고 다른 하나가 인식 하는 경우 주문 비교를 시도하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 동등 비교의 경우, 순진 인스턴스는 인식 인스턴스와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f586af1a41a07ac3dcc0f4d3f82539d6176c3e4c" translate="yes" xml:space="preserve">
          <source>If one of the iterables is potentially infinite, then the &lt;a href=&quot;#itertools.zip_longest&quot;&gt;&lt;code&gt;zip_longest()&lt;/code&gt;&lt;/a&gt; function should be wrapped with something that limits the number of calls (for example &lt;a href=&quot;#itertools.islice&quot;&gt;&lt;code&gt;islice()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#itertools.takewhile&quot;&gt;&lt;code&gt;takewhile()&lt;/code&gt;&lt;/a&gt;). If not specified, &lt;em&gt;fillvalue&lt;/em&gt; defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">iterable 중 하나가 잠재적으로 무한한 경우, &lt;a href=&quot;#itertools.zip_longest&quot;&gt; &lt;code&gt;zip_longest()&lt;/code&gt; &lt;/a&gt; 함수는 호출 횟수를 제한하는 무언가로 랩핑되어야합니다 (예 : &lt;a href=&quot;#itertools.islice&quot;&gt; &lt;code&gt;islice()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#itertools.takewhile&quot;&gt; &lt;code&gt;takewhile()&lt;/code&gt; &lt;/a&gt; ). 지정하지 않으면 &lt;em&gt;fillvalue의&lt;/em&gt; 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fed106ddf387a9f27caba16b43370e63282aec73" translate="yes" xml:space="preserve">
          <source>If one positional argument is provided, it should be an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt;. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned.</source>
          <target state="translated">하나의 위치 인수가 제공되면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능&lt;/a&gt; 해야합니다 . iterable에서 가장 큰 항목이 반환됩니다. 둘 이상의 위치 인수가 제공되면 가장 큰 위치 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cd31c867fd89a7c1d95f7f40da4f4f0882fa7af1" translate="yes" xml:space="preserve">
          <source>If one positional argument is provided, it should be an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt;. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned.</source>
          <target state="translated">하나의 위치 인수가 제공되면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능&lt;/a&gt; 해야합니다 . iterable에서 가장 작은 항목이 반환됩니다. 둘 이상의 위치 인수가 제공되면 가장 작은 위치 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b1237f29843fb6e1241d53edd8dcf105508a566f" translate="yes" xml:space="preserve">
          <source>If one wants more information about all matches of a pattern than the matched text, &lt;a href=&quot;#re.finditer&quot;&gt;&lt;code&gt;finditer()&lt;/code&gt;&lt;/a&gt; is useful as it provides &lt;a href=&quot;#match-objects&quot;&gt;match objects&lt;/a&gt; instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs &lt;em&gt;and their positions&lt;/em&gt; in some text, they would use &lt;a href=&quot;#re.finditer&quot;&gt;&lt;code&gt;finditer()&lt;/code&gt;&lt;/a&gt; in the following manner:</source>
          <target state="translated">일치하는 텍스트보다 패턴의 모든 일치에 대한 자세한 정보를 원하는 경우 &lt;a href=&quot;#re.finditer&quot;&gt; &lt;code&gt;finditer()&lt;/code&gt; &lt;/a&gt; 는 문자열 대신 &lt;a href=&quot;#match-objects&quot;&gt;일치 객체&lt;/a&gt; 를 제공하므로 유용합니다 . 앞의 예제를 계속하여 작가가 모든 부사 &lt;em&gt;와 그 위치&lt;/em&gt; 를 텍스트 로 찾으 려면 &lt;a href=&quot;#re.finditer&quot;&gt; &lt;code&gt;finditer()&lt;/code&gt; &lt;/a&gt; 를 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f1347dbe4680d59bafdc6451d2e8d67e574fff02" translate="yes" xml:space="preserve">
          <source>If one wants to customize pickling of some classes without disturbing any other code which depends on pickling, then one can create a pickler with a private dispatch table.</source>
          <target state="translated">피클 링에 의존하는 다른 코드를 방해하지 않고 일부 클래스의 피클 링을 사용자 정의하려면 개인 디스패치 테이블을 사용하여 피커를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a72b7770c6c17e2466572d1f613dd461295e35" translate="yes" xml:space="preserve">
          <source>If only some components are abstract, only those components need to be updated to create a concrete property in a subclass:</source>
          <target state="translated">일부 컴포넌트 만 추상적 인 경우 서브 클래스에서 구체적 특성을 작성하려면 해당 컴포넌트 만 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c740863730ebbf14b847aaee2c1d18d2436d45e" translate="yes" xml:space="preserve">
          <source>If only the &lt;em&gt;exception&lt;/em&gt; and possibly the &lt;em&gt;msg&lt;/em&gt; arguments are given, return a context manager so that the code under test can be written inline rather than as a function:</source>
          <target state="translated">단지 경우 &lt;em&gt;를 제외&lt;/em&gt; 하고는 아마도 &lt;em&gt;MSG의&lt;/em&gt; 인수가 주어 테스트중인 코드가 아니라 함수로보다 인라인 기록 될 수 있도록하는 컨텍스트 관리자를 반환 :</target>
        </trans-unit>
        <trans-unit id="7753140c3a7be41fbf94278880c58bc397646c99" translate="yes" xml:space="preserve">
          <source>If only the &lt;em&gt;warning&lt;/em&gt; and possibly the &lt;em&gt;msg&lt;/em&gt; arguments are given, return a context manager so that the code under test can be written inline rather than as a function:</source>
          <target state="translated">단지 경우 &lt;em&gt;경고&lt;/em&gt; 와는 가능성이 &lt;em&gt;MSG의&lt;/em&gt; 인수가 주어 테스트중인 코드가 아니라 함수로보다 인라인 기록 될 수 있도록하는 컨텍스트 관리자를 반환 :</target>
        </trans-unit>
        <trans-unit id="daaad11308bf3ecc56da6270a84c953330e34e9b" translate="yes" xml:space="preserve">
          <source>If optional &lt;em&gt;charset&lt;/em&gt; is specified, the parameter will be encoded according to &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;. Optional &lt;em&gt;language&lt;/em&gt; specifies the RFC 2231 language, defaulting to the empty string. Both &lt;em&gt;charset&lt;/em&gt; and &lt;em&gt;language&lt;/em&gt; should be strings.</source>
          <target state="translated">선택적 &lt;em&gt;문자 집합&lt;/em&gt; 이 지정된 경우 매개 변수는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 에 따라 인코딩됩니다 . 선택적 &lt;em&gt;언어&lt;/em&gt; 는 RFC 2231 &lt;em&gt;언어를&lt;/em&gt; 지정하며 기본값은 빈 문자열입니다. 두 &lt;em&gt;캐릭터 세트&lt;/em&gt; 와 &lt;em&gt;언어는&lt;/em&gt; 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="30e460f7c1de270b9a5d3d19b52510be2728dbac" translate="yes" xml:space="preserve">
          <source>If optional &lt;em&gt;mangle_from_&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, put a &lt;code&gt;&amp;gt;&lt;/code&gt; character in front of any line in the body that starts with the exact string &lt;code&gt;&quot;From &quot;&lt;/code&gt;, that is &lt;code&gt;From&lt;/code&gt; followed by a space at the beginning of a line. &lt;em&gt;mangle_from_&lt;/em&gt; defaults to the value of the &lt;a href=&quot;email.policy#email.policy.Policy.mangle_from_&quot;&gt;&lt;code&gt;mangle_from_&lt;/code&gt;&lt;/a&gt; setting of the &lt;em&gt;policy&lt;/em&gt; (which is &lt;code&gt;True&lt;/code&gt; for the &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy and &lt;code&gt;False&lt;/code&gt; for all others). &lt;em&gt;mangle_from_&lt;/em&gt; is intended for use when messages are stored in unix mbox format (see &lt;a href=&quot;mailbox#module-mailbox&quot;&gt;&lt;code&gt;mailbox&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.jwz.org/doc/content-length.html&quot;&gt;WHY THE CONTENT-LENGTH FORMAT IS BAD&lt;/a&gt;).</source>
          <target state="translated">선택적인 &lt;em&gt;mangle_from_&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 본문에서 정확한 문자열 &lt;code&gt;&quot;From &quot;&lt;/code&gt; 시작하는 줄 앞에 &lt;code&gt;&amp;gt;&lt;/code&gt; 문자를 입력하십시오. 즉 , &lt;code&gt;From&lt;/code&gt; 다음에 줄 시작 부분에 공백 &lt;em&gt;이옵니다&lt;/em&gt; . &lt;em&gt;mangle_from_의&lt;/em&gt; 기본값 은 &lt;em&gt;정책&lt;/em&gt; 의 &lt;a href=&quot;email.policy#email.policy.Policy.mangle_from_&quot;&gt; &lt;code&gt;mangle_from_&lt;/code&gt; &lt;/a&gt; 설정 값입니다 ( &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; 정책의 경우 &lt;code&gt;True&lt;/code&gt; , 다른 모든 경우 &lt;code&gt;False&lt;/code&gt; ). &lt;em&gt;mangle_from_&lt;/em&gt; 은 메시지가 유닉스 mbox 형식으로 저장 될 때 사용하기위한 것입니다 ( &lt;a href=&quot;mailbox#module-mailbox&quot;&gt; &lt;code&gt;mailbox&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://www.jwz.org/doc/content-length.html&quot;&gt;컨텐츠 길이 형식이 나쁜 이유&lt;/a&gt; 참조 ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c8605e1fe87239a6939ac038c36a1310db420f6" translate="yes" xml:space="preserve">
          <source>If optional &lt;em&gt;rest&lt;/em&gt; is given, a &lt;code&gt;REST&lt;/code&gt; command is sent to the server, passing &lt;em&gt;rest&lt;/em&gt; as an argument. &lt;em&gt;rest&lt;/em&gt; is usually a byte offset into the requested file, telling the server to restart sending the file&amp;rsquo;s bytes at the requested offset, skipping over the initial bytes. Note however that &lt;a href=&quot;https://tools.ietf.org/html/rfc959.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 959&lt;/strong&gt;&lt;/a&gt; requires only that &lt;em&gt;rest&lt;/em&gt; be a string containing characters in the printable range from ASCII code 33 to ASCII code 126. The &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt; method, therefore, converts &lt;em&gt;rest&lt;/em&gt; to a string, but no check is performed on the string&amp;rsquo;s contents. If the server does not recognize the &lt;code&gt;REST&lt;/code&gt; command, an &lt;a href=&quot;#ftplib.error_reply&quot;&gt;&lt;code&gt;error_reply&lt;/code&gt;&lt;/a&gt; exception will be raised. If this happens, simply call &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt; without a &lt;em&gt;rest&lt;/em&gt; argument.</source>
          <target state="translated">선택적 &lt;em&gt;rest&lt;/em&gt; 가 제공되면 &lt;code&gt;REST&lt;/code&gt; 명령이 서버로 전송되어 &lt;em&gt;rest&lt;/em&gt; 를 인수로 전달합니다. &lt;em&gt;rest&lt;/em&gt; 는 일반적으로 요청 된 파일에 대한 바이트 오프셋으로, 서버가 요청 된 오프셋에서 파일 바이트 전송을 다시 시작하고 초기 바이트를 건너 뛰도록 서버에 지시합니다. 그러나 &lt;a href=&quot;https://tools.ietf.org/html/rfc959.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 959&lt;/strong&gt;&lt;/a&gt; 는 &lt;em&gt;rest&lt;/em&gt; 가 ASCII 코드 33에서 ASCII 코드 126까지 인쇄 가능한 범위의 문자를 포함하는 문자열이어야 한다는 점에 유의하십시오 . 따라서 &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;em&gt;rest&lt;/em&gt; 를 문자열 로 변환 하지만 문자열의 내용을 점검하지는 않습니다. . 서버가 &lt;code&gt;REST&lt;/code&gt; 명령을 인식하지 못하면 &lt;a href=&quot;#ftplib.error_reply&quot;&gt; &lt;code&gt;error_reply&lt;/code&gt; &lt;/a&gt;예외가 발생합니다. 이런 일이 발생 하면 &lt;em&gt;rest&lt;/em&gt; 인수 없이 &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12e5876c996fe3ce7e5f11f23f2acba47a2002c2" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; or not specified, the triple for a directory is generated before the triples for any of its subdirectories (directories are generated top-down). If &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the triple for a directory is generated after the triples for all of its subdirectories (directories are generated bottom-up). No matter the value of &lt;em&gt;topdown&lt;/em&gt;, the list of subdirectories is retrieved before the tuples for the directory and its subdirectories are generated.</source>
          <target state="translated">선택적 인수 &lt;em&gt;topdown&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 이거나 지정되지 않은 경우 디렉토리의 트리플이 서브 디렉토리의 트리플보다 먼저 생성됩니다 (디렉토리는 하향식으로 생성됨). &lt;em&gt;topdown&lt;/em&gt; 이 &lt;code&gt;False&lt;/code&gt; 인 경우 모든 하위 디렉토리의 트리플이 끝난 후 디렉토리의 트리플이 생성됩니다 (디렉토리는 상향식으로 생성됨). &lt;em&gt;topdown&lt;/em&gt; 값에 관계없이 디렉토리 및 서브 디렉토리의 튜플이 생성되기 전에 서브 디렉토리 목록이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="c43cb00d5fc16bd54dc39ceae5b45c2ffe796cc5" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;em&gt;tz&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; or not specified, this is like &lt;a href=&quot;#datetime.datetime.today&quot;&gt;&lt;code&gt;today()&lt;/code&gt;&lt;/a&gt;, but, if possible, supplies more precision than can be gotten from going through a &lt;a href=&quot;time#time.time&quot;&gt;&lt;code&gt;time.time()&lt;/code&gt;&lt;/a&gt; timestamp (for example, this may be possible on platforms supplying the C &lt;code&gt;gettimeofday()&lt;/code&gt; function).</source>
          <target state="translated">선택적 인수 &lt;em&gt;tz&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이거나 지정되지 않은 경우 이는 &lt;a href=&quot;#datetime.datetime.today&quot;&gt; &lt;code&gt;today()&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 가능하면 &lt;a href=&quot;time#time.time&quot;&gt; &lt;code&gt;time.time()&lt;/code&gt; &lt;/a&gt; 타임 스탬프를 통과하는 것보다 더 정확한 정밀도를 제공합니다 (예 : 플랫폼을 제공하는 플랫폼에서 가능할 수 있음) C &lt;code&gt;gettimeofday()&lt;/code&gt; 함수).</target>
        </trans-unit>
        <trans-unit id="8ebb578f00d1c7fad8844f4eebad620649156c22" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;em&gt;verbose&lt;/em&gt; is true, output is generated even if there are no failures. By default, output is generated only in case of an example failure.</source>
          <target state="translated">선택적 인수 &lt;em&gt;verbose&lt;/em&gt; 가 true이면 실패가없는 경우에도 출력이 생성됩니다. 기본적으로 출력은 예제 실패의 경우에만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ffdd4e7b5895f1e0d5dff890e02c15a4800f31a" translate="yes" xml:space="preserve">
          <source>If optional keyword argument &lt;em&gt;initial_response_ok&lt;/em&gt; is true, &lt;code&gt;authobject()&lt;/code&gt; will be called first with no argument. It can return the &lt;a href=&quot;https://tools.ietf.org/html/rfc4954.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 4954&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;initial response&amp;rdquo; ASCII &lt;code&gt;str&lt;/code&gt; which will be encoded and sent with the &lt;code&gt;AUTH&lt;/code&gt; command as below. If the &lt;code&gt;authobject()&lt;/code&gt; does not support an initial response (e.g. because it requires a challenge), it should return &lt;code&gt;None&lt;/code&gt; when called with &lt;code&gt;challenge=None&lt;/code&gt;. If &lt;em&gt;initial_response_ok&lt;/em&gt; is false, then &lt;code&gt;authobject()&lt;/code&gt; will not be called first with &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">선택적 키워드 인수 &lt;em&gt;initial_response_ok&lt;/em&gt; 가 true 인 경우, 인수 &lt;code&gt;authobject()&lt;/code&gt; 가 먼저 호출됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc4954.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 4954&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;초기 응답&amp;rdquo;ASCII &lt;code&gt;str&lt;/code&gt; 을 반환 할 수 있으며 , 아래와 같이 &lt;code&gt;AUTH&lt;/code&gt; 명령으로 인코딩 및 전송 됩니다. &lt;code&gt;authobject()&lt;/code&gt; 가 초기 응답을 지원하지 않는 경우 (예 : 인증 요청이 필요한 경우) &lt;code&gt;challenge=None&lt;/code&gt; 으로 호출하면 &lt;code&gt;None&lt;/code&gt; 을 반환해야합니다 . 경우 &lt;em&gt;initial_response_ok은&lt;/em&gt; 거짓, 다음 &lt;code&gt;authobject()&lt;/code&gt; 처음으로 호출되지 않습니다 &lt;code&gt;None&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae29e2c8c341be783838f132ff21d9ab34d97fc" translate="yes" xml:space="preserve">
          <source>If passed an object that is not a context manager, this method assumes it is a callback with the same signature as a context manager&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method and adds it directly to the callback stack.</source>
          <target state="translated">컨텍스트 관리자가 아닌 객체를 전달한 경우이 메서드는 컨텍스트 관리자의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메서드와 동일한 서명을 가진 콜백 인 것으로 가정 하여 콜백 스택에 직접 추가합니다.</target>
        </trans-unit>
        <trans-unit id="38619f38fb2e8ea83cef76fefbe9fa418722ab8f" translate="yes" xml:space="preserve">
          <source>If policy allows (ie. the &lt;code&gt;rfc2965&lt;/code&gt; and &lt;code&gt;hide_cookie2&lt;/code&gt; attributes of the &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; instance are true and false respectively), the &lt;em&gt;Cookie2&lt;/em&gt; header is also added when appropriate.</source>
          <target state="translated">정책 (예. 허용하는 경우 &lt;code&gt;rfc2965&lt;/code&gt; 및 &lt;code&gt;hide_cookie2&lt;/code&gt; 의 속성 &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 인스턴스는 진정한 각각 거짓)의 &lt;em&gt;Cookie2를의&lt;/em&gt; 헤더는 또한 적절한 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d11ebbe292ed1e1ee178b91b1ecd2889a70e4116" translate="yes" xml:space="preserve">
          <source>If precision is &lt;code&gt;N&lt;/code&gt;, the output is truncated to &lt;code&gt;N&lt;/code&gt; characters.</source>
          <target state="translated">정밀도가 &lt;code&gt;N&lt;/code&gt; 인 경우 출력은 &lt;code&gt;N&lt;/code&gt; 자로 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="443ece5632be703c310845263c3ce1e3e31a1c39" translate="yes" xml:space="preserve">
          <source>If prefix &amp;ldquo;0b&amp;rdquo; is desired or not, you can use either of the following ways.</source>
          <target state="translated">접두사 &quot;0b&quot;가 필요한지 여부는 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ce265a9ea589b84bb1ae1a723bd20e1e88bd3e" translate="yes" xml:space="preserve">
          <source>If present and greater than zero, specified the desired width of the pane area (not including internal padding). Otherwise, the maximum width of all panes is used.</source>
          <target state="translated">존재하고 0보다 큰 경우, 원하는 페인 영역 너비를 지정하십시오 (내부 패딩 제외). 그렇지 않으면 모든 창의 최대 너비가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b03a80e9a562cf9b1589a814197ce3243d92bcb" translate="yes" xml:space="preserve">
          <source>If present and greater than zero, specifies the desired height of the pane area (not including internal padding or tabs). Otherwise, the maximum height of all panes is used.</source>
          <target state="translated">존재하고 0보다 큰 경우, 분할 영역의 원하는 높이를 지정합니다 (내부 패딩 또는 탭 제외). 그렇지 않으면 모든 창의 최대 높이가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4545dbeee8dafb95a5bd0e1db8e7852d40b3ad54" translate="yes" xml:space="preserve">
          <source>If provided, &lt;em&gt;tz&lt;/em&gt; must be an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass, and its &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.datetime.dst&quot;&gt;&lt;code&gt;dst()&lt;/code&gt;&lt;/a&gt; methods must not return &lt;code&gt;None&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is naive, it is presumed to represent time in the system timezone.</source>
          <target state="translated">제공되는 경우 &lt;em&gt;tz&lt;/em&gt; 는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 여야하며 utcoffset &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.datetime.dst&quot;&gt; &lt;code&gt;dst()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;code&gt;None&lt;/code&gt; 을 리턴하지 않아야합니다 . &lt;em&gt;self&lt;/em&gt; 가 순진한 경우 시스템 시간대의 시간을 나타내는 것으로 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="70f41e2c7bc507b15fffa53f66966c258b97643a" translate="yes" xml:space="preserve">
          <source>If returning a tuple doesn&amp;rsquo;t suffice and you want name-based access to columns, you should consider setting &lt;a href=&quot;#sqlite3.Connection.row_factory&quot;&gt;&lt;code&gt;row_factory&lt;/code&gt;&lt;/a&gt; to the highly-optimized &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;sqlite3.Row&lt;/code&gt;&lt;/a&gt; type. &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;Row&lt;/code&gt;&lt;/a&gt; provides both index-based and case-insensitive name-based access to columns with almost no memory overhead. It will probably be better than your own custom dictionary-based approach or even a db_row based solution.</source>
          <target state="translated">튜플을 반환해도 충분하지 않고 열에 대한 이름 기반 액세스를 &lt;a href=&quot;#sqlite3.Connection.row_factory&quot;&gt; &lt;code&gt;row_factory&lt;/code&gt; &lt;/a&gt; 를 최적화 된 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;sqlite3.Row&lt;/code&gt; &lt;/a&gt; 유형으로 설정하는 것을 고려해야합니다 . &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;Row&lt;/code&gt; &lt;/a&gt; 는 메모리 오버 헤드가 거의없이 열에 대한 인덱스 기반 및 대소 문자 구분이없는 이름 기반 액세스를 제공합니다. 아마도 사용자 정의 사전 기반 접근 방식 또는 심지어 db_row 기반 솔루션보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="fb1cc245a11320da1db54ed5268d026fb86fcc00" translate="yes" xml:space="preserve">
          <source>If set to 1, causes the element and all of its descendants to be treated as a single element for the purposes of &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt;&lt;code&gt;Widget.identify()&lt;/code&gt;&lt;/a&gt; et al. It&amp;rsquo;s used for things like scrollbar thumbs with grips.</source>
          <target state="translated">1로 설정하면 &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt; &lt;code&gt;Widget.identify()&lt;/code&gt; &lt;/a&gt; 등 의 목적으로 요소와 모든 하위 항목이 단일 요소로 처리됩니다 . 그립이있는 스크롤 막대 엄지 손가락과 같은 것들에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4c1e34442088e1b288c391bdce23a843d942a1" translate="yes" xml:space="preserve">
          <source>If set to a non-zero integer, the parser will report only those attributes which were specified in the document instance and not those which were derived from attribute declarations. Applications which set this need to be especially careful to use what additional information is available from the declarations as needed to comply with the standards for the behavior of XML processors. By default, this attribute is false; it may be changed at any time.</source>
          <target state="translated">0이 아닌 정수로 설정하면 구문 분석기는 문서 인스턴스에 지정된 속성 만보고하고 속성 선언에서 파생 된 속성은보고하지 않습니다. 이를 설정 한 응용 프로그램은 XML 프로세서의 동작에 대한 표준을 준수하기 위해 선언에서 사용 가능한 추가 정보를 사용할 때 특히주의해야합니다. 기본적으로이 속성은 false입니다. 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee3f2b48192a68f3a6682ab4100a180bef3319f" translate="yes" xml:space="preserve">
          <source>If set to true &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; will be called on the first failure or error, halting the test run.</source>
          <target state="translated">true로 설정 하면 첫 번째 실패 또는 오류시 &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 이 호출되어 테스트 실행이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="e51e0d8058becfc44eb0b15e9fbb655eff6ca1d8" translate="yes" xml:space="preserve">
          <source>If set to true then local variables will be shown in tracebacks.</source>
          <target state="translated">true로 설정하면 지역 변수가 역 추적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="64b6f3bafe48fa6aa11d7a7bedca0dc485936902" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;code&gt;sys.stdout&lt;/code&gt; and &lt;code&gt;sys.stderr&lt;/code&gt; will be buffered in between &lt;a href=&quot;#unittest.TestResult.startTest&quot;&gt;&lt;code&gt;startTest()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.TestResult.stopTest&quot;&gt;&lt;code&gt;stopTest()&lt;/code&gt;&lt;/a&gt; being called. Collected output will only be echoed onto the real &lt;code&gt;sys.stdout&lt;/code&gt; and &lt;code&gt;sys.stderr&lt;/code&gt; if the test fails or errors. Any output is also attached to the failure / error message.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;sys.stdout&lt;/code&gt; 및 &lt;code&gt;sys.stderr&lt;/code&gt; 이 호출되는 &lt;a href=&quot;#unittest.TestResult.startTest&quot;&gt; &lt;code&gt;startTest()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#unittest.TestResult.stopTest&quot;&gt; &lt;code&gt;stopTest()&lt;/code&gt; &lt;/a&gt; 사이에 버퍼링됩니다 . 수집 된 출력은 테스트가 실패하거나 오류가 발생하는 경우 실제 &lt;code&gt;sys.stdout&lt;/code&gt; 및 &lt;code&gt;sys.stderr&lt;/code&gt; 에만 에코 됩니다. 모든 출력은 실패 / 오류 메시지에도 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="ecf8c4b33b20be57bc6efdf4b39c10800d750a9d" translate="yes" xml:space="preserve">
          <source>If set, a new dict will be created for the frame&amp;rsquo;s &lt;code&gt;f_locals&lt;/code&gt; when the code object is executed.</source>
          <target state="translated">설정 하면 코드 객체가 실행될 때 프레임의 &lt;code&gt;f_locals&lt;/code&gt; 에 대한 새 dict가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="90c8757d24024109684a25cf5517e4c9f2ec4bd1" translate="yes" xml:space="preserve">
          <source>If set, specifies the index (0-based) of a character to underline in the text string. The underline character is used for mnemonic activation.</source>
          <target state="translated">설정된 경우 텍스트 문자열에서 밑줄을 긋는 문자의 인덱스 (0 기반)를 지정합니다. 밑줄 문자는 니모닉 활성화에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6c0ce7a7752011eb06bc4de3089d05ce6f551e" translate="yes" xml:space="preserve">
          <source>If some data was successfully read, it will return the number of bytes read. If no bytes were read, it will return &lt;code&gt;-1&lt;/code&gt; and set errno to &lt;a href=&quot;errno#errno.EAGAIN&quot;&gt;&lt;code&gt;errno.EAGAIN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 데이터를 읽은 경우 읽은 바이트 수를 반환합니다. 읽은 바이트가 없으면 &lt;code&gt;-1&lt;/code&gt; 을 반환 하고 errno를 &lt;a href=&quot;errno#errno.EAGAIN&quot;&gt; &lt;code&gt;errno.EAGAIN&lt;/code&gt; 으로&lt;/a&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8c0a8612344f25e81798fab5bf81643a26a155fd" translate="yes" xml:space="preserve">
          <source>If source code is available, then the method should return the path to the source file, regardless of whether a bytecode was used to load the module.</source>
          <target state="translated">소스 코드가 사용 가능한 경우 메소드는 바이트 코드를 사용하여 모듈을로드했는지 여부에 관계없이 소스 파일의 경로를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e0b6d4c847d28d357f25ee69a7125504c0d6bad" translate="yes" xml:space="preserve">
          <source>If specified, &lt;em&gt;default&lt;/em&gt; should be a function that gets called for objects that can&amp;rsquo;t otherwise be serialized. It should return a JSON encodable version of the object or raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. If not specified, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 경우 &lt;em&gt;기본값&lt;/em&gt; 은 직렬화 할 수없는 객체를 호출하는 함수 여야합니다. JSON 인코딩 가능한 버전의 객체를 반환하거나 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시켜야합니다 . 지정하지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59bccf61da6bc8aa73e6b26d9107f86de89d1f17" translate="yes" xml:space="preserve">
          <source>If specified, &lt;em&gt;env&lt;/em&gt; must provide any variables required for the program to execute. On Windows, in order to run a &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-by-Side_Assembly&quot;&gt;side-by-side assembly&lt;/a&gt; the specified &lt;em&gt;env&lt;/em&gt;&lt;strong&gt;must&lt;/strong&gt; include a valid &lt;code id=&quot;index-3&quot;&gt;SystemRoot&lt;/code&gt;.</source>
          <target state="translated">지정된 경우 &lt;em&gt;env&lt;/em&gt; 는 프로그램 실행에 필요한 변수를 제공해야합니다. Windows에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-by-Side_Assembly&quot;&gt;병렬 어셈블리&lt;/a&gt; 를 실행 하려면 지정된 &lt;em&gt;env&lt;/em&gt; 에 유효한 &lt;code id=&quot;index-3&quot;&gt;SystemRoot&lt;/code&gt; &lt;strong&gt;가&lt;/strong&gt; 포함 &lt;strong&gt;되어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="55004220c3f31c4448c84db4c687ec30a9bc0a57" translate="yes" xml:space="preserve">
          <source>If specified, &lt;em&gt;separators&lt;/em&gt; should be an &lt;code&gt;(item_separator, key_separator)&lt;/code&gt; tuple. The default is &lt;code&gt;(', ', ': ')&lt;/code&gt; if &lt;em&gt;indent&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;(',', ': ')&lt;/code&gt; otherwise. To get the most compact JSON representation, you should specify &lt;code&gt;(',', ':')&lt;/code&gt; to eliminate whitespace.</source>
          <target state="translated">지정된 경우 &lt;em&gt;구분 기호&lt;/em&gt; 는 &lt;code&gt;(item_separator, key_separator)&lt;/code&gt; 튜플 이어야합니다 . 기본값은 &lt;code&gt;(', ', ': ')&lt;/code&gt; 경우 &lt;em&gt;들여 쓰기가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;(',', ': ')&lt;/code&gt; 그렇지. 가장 간단한 JSON 표현을 얻으려면 공백을 제거하기 위해 &lt;code&gt;(',', ':')&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="51387c50308ba22f05c775c6091c3e23657f8358" translate="yes" xml:space="preserve">
          <source>If specified, this should be an iterable of already created handlers to add to the root logger. Any handlers which don&amp;rsquo;t already have a formatter set will be assigned the default formatter created in this function. Note that this argument is incompatible with &lt;em&gt;filename&lt;/em&gt; or &lt;em&gt;stream&lt;/em&gt; - if both are present, a &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="translated">지정된 경우 루트 로거에 추가하기 위해 이미 작성된 핸들러의 반복 가능해야합니다. 포맷터 세트가없는 핸들러에는이 함수에서 생성 된 기본 포맷터가 할당됩니다. 이 인수는 &lt;em&gt;filename&lt;/em&gt; 또는 &lt;em&gt;stream&lt;/em&gt; 과 호환되지 않습니다. 둘 다 존재하면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2396c9bd05ca934d78b97fe306102f571da9db25" translate="yes" xml:space="preserve">
          <source>If stack information is available, it&amp;rsquo;s appended after the exception information, using &lt;a href=&quot;#logging.Formatter.formatStack&quot;&gt;&lt;code&gt;formatStack()&lt;/code&gt;&lt;/a&gt; to transform it if necessary.</source>
          <target state="translated">스택 정보를 사용할 수 있으면 예외 정보 뒤에 추가되어 &lt;a href=&quot;#logging.Formatter.formatStack&quot;&gt; &lt;code&gt;formatStack()&lt;/code&gt; &lt;/a&gt; 을 사용하여 필요한 경우 변환합니다.</target>
        </trans-unit>
        <trans-unit id="49e5edaf7d45ad995b7d09a564fc8b598f00fc32" translate="yes" xml:space="preserve">
          <source>If standard (non-proxy) &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; objects are contained in a referent, modifications to those mutable values will not be propagated through the manager because the proxy has no way of knowing when the values contained within are modified. However, storing a value in a container proxy (which triggers a &lt;code&gt;__setitem__&lt;/code&gt; on the proxy object) does propagate through the manager and so to effectively modify such an item, one could re-assign the modified value to the container proxy:</source>
          <target state="translated">표준 (프록시가 아닌) &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 오브젝트가 참조에 포함 된 경우 프록시에 포함 된 값이 수정되는시기를 알 수 없으므로 프록시를 통해 해당 변경 가능 값에 대한 수정 사항이 관리자를 통해 전파되지 않습니다. 그러나 컨테이너 프록시에 값을 저장하면 ( 프록시 객체 에서 &lt;code&gt;__setitem__&lt;/code&gt; 트리거 ) 관리자를 통해 전파되므로 이러한 항목을 효과적으로 수정하기 위해 수정 된 값을 컨테이너 프록시에 다시 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8f87d5d4d9f4f5995cccc6502c2c7f249e6db4" translate="yes" xml:space="preserve">
          <source>If supplied, &lt;em&gt;source_address&lt;/em&gt; must be a 2-tuple &lt;code&gt;(host, port)&lt;/code&gt; for the socket to bind to as its source address before connecting. If host or port are &amp;lsquo;&amp;rsquo; or 0 respectively the OS default behavior will be used.</source>
          <target state="translated">제공된 경우, &lt;em&gt;source_address&lt;/em&gt; 는 소켓이 연결하기 전에 소스 주소로 바인드하기 위해 2- 튜플 &lt;code&gt;(host, port)&lt;/code&gt; 이어야합니다 . 호스트 또는 포트가 각각 ''또는 0 인 경우 OS 기본 동작이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7158776ee648d11018c88143c872cabdaad5856c" translate="yes" xml:space="preserve">
          <source>If text mode is not used, &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; will be opened as binary streams. No encoding or line ending conversion is performed.</source>
          <target state="translated">텍스트 모드를 사용하지 않으면 &lt;em&gt;stdin&lt;/em&gt; , &lt;em&gt;stdout&lt;/em&gt; 및 &lt;em&gt;stderr&lt;/em&gt; 이 이진 스트림으로 열립니다. 인코딩 또는 줄 끝 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b647614fdb703e999c4e6277543848afe83dfe6b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; attribute is &lt;code&gt;None&lt;/code&gt;, this raises a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception with the &lt;em&gt;key&lt;/em&gt; as argument.</source>
          <target state="translated">는 IF &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 속성이 없습니다 &lt;code&gt;None&lt;/code&gt; 이이 제기 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 와 예외 &lt;em&gt;키&lt;/em&gt; 인수로합니다.</target>
        </trans-unit>
        <trans-unit id="5166c50db841216329f470ef00ee35316868399a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#decimal.FloatOperation&quot;&gt;&lt;code&gt;FloatOperation&lt;/code&gt;&lt;/a&gt; signal is trapped, accidental mixing of decimals and floats in constructors or ordering comparisons raises an exception:</source>
          <target state="translated">경우 &lt;a href=&quot;#decimal.FloatOperation&quot;&gt; &lt;code&gt;FloatOperation&lt;/code&gt; 의&lt;/a&gt; 신호가 갇혀, 생성자 또는 주문 비교에 소수와 수레의 실수로 혼합 예외가 발생 :</target>
        </trans-unit>
        <trans-unit id="9bbeb2f2786191004c4aacbd9b237c32b9a9e470" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt;&lt;code&gt;GRND_NONBLOCK&lt;/code&gt;&lt;/a&gt; flag is set, then &lt;a href=&quot;#os.getrandom&quot;&gt;&lt;code&gt;getrandom()&lt;/code&gt;&lt;/a&gt; does not block in these cases, but instead immediately raises &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt; &lt;code&gt;GRND_NONBLOCK&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정되어, 다음 &lt;a href=&quot;#os.getrandom&quot;&gt; &lt;code&gt;getrandom()&lt;/code&gt; &lt;/a&gt; 이러한 경우에 차단, 대신 즉시 제기하지 않습니다 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e5c2c854be11bcf191a49fa0ebcc698cb65781e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method raises an exception, &lt;a href=&quot;#threading.excepthook&quot;&gt;&lt;code&gt;threading.excepthook()&lt;/code&gt;&lt;/a&gt; is called to handle it. By default, &lt;a href=&quot;#threading.excepthook&quot;&gt;&lt;code&gt;threading.excepthook()&lt;/code&gt;&lt;/a&gt; ignores silently &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드가 예외를 제기, &lt;a href=&quot;#threading.excepthook&quot;&gt; &lt;code&gt;threading.excepthook()&lt;/code&gt; &lt;/a&gt; 그것을 처리하기 위해 호출됩니다. 기본적으로 &lt;a href=&quot;#threading.excepthook&quot;&gt; &lt;code&gt;threading.excepthook()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; 를&lt;/a&gt; 자동으로 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="e96f8cfc40738bbb062383e1cc52fead6fbf34f8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; method raises an exception while the test is running, the framework will consider the test to have suffered an error, and the test method will not be executed.</source>
          <target state="translated">는 IF &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 테스트가 실행되는 동안 메소드가 예외를 제기, 프레임 워크는 테스트에 오류가 고통을 생각하며, 시험 방법은 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83922f016248c8cd1e133445c39b06053bf60d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt;&lt;code&gt;origin_server&lt;/code&gt;&lt;/a&gt; attribute is set, this attribute&amp;rsquo;s value is used to set the default &lt;code&gt;SERVER_SOFTWARE&lt;/code&gt; WSGI environment variable, and also to set a default &lt;code&gt;Server:&lt;/code&gt; header in HTTP responses. It is ignored for handlers (such as &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt;&lt;code&gt;BaseCGIHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;) that are not HTTP origin servers.</source>
          <target state="translated">는 IF &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt; &lt;code&gt;origin_server&lt;/code&gt; 의&lt;/a&gt; 속성이 설정되어,이 속성의 값은 기본 설정하는 데 사용됩니다 &lt;code&gt;SERVER_SOFTWARE&lt;/code&gt; WSGI 환경 변수를, 또한 기본 설정 &lt;code&gt;Server:&lt;/code&gt; 헤더를 HTTP 응답에. HTTP 오리진 서버가 아닌 핸들러 (예 : &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt; &lt;code&gt;BaseCGIHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; )에서는 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e6190ef04b122e93b83bb48591b9a20ea9d1832" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; option &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;8bit&lt;/code&gt; (the default), copy any headers in the original parsed message that have not been modified to the output with any bytes with the high bit set reproduced as in the original, and preserve the non-ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; of any body parts that have them. If &lt;code&gt;cte_type&lt;/code&gt; is &lt;code&gt;7bit&lt;/code&gt;, convert the bytes with the high bit set as needed using an ASCII-compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;. That is, transform parts with non-ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; (&lt;em&gt;Content-Transfer-Encoding: 8bit&lt;/em&gt;) to an ASCII compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;, and encode RFC-invalid non-ASCII bytes in headers using the MIME &lt;code&gt;unknown-8bit&lt;/code&gt; character set, thus rendering them RFC-compliant.</source>
          <target state="translated">는 IF &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 옵션 &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 이&lt;/a&gt; 입니다 &lt;code&gt;8bit&lt;/code&gt; (기본값), 원래 같이 재현 높은 비트 세트와 어떤 바이트 출력에 수정되지 않은 원래 구문 분석 된 메시지의 모든 헤더를 복사하고, 비 ASCII 보존 &lt;em&gt;된 Content를&lt;/em&gt; 신체 부위가있는 &lt;em&gt;전사 인코딩&lt;/em&gt; . 경우 &lt;code&gt;cte_type&lt;/code&gt; 가 있습니다 &lt;code&gt;7bit&lt;/code&gt; 있는 ASCII 호환 사용하여 필요에 따라, 높은 비트 세트와 바이트를 변환 &lt;em&gt;콘텐츠 전송 인코딩을&lt;/em&gt; . 즉, 비 ASCII &lt;em&gt;컨텐츠 전송 인코딩&lt;/em&gt; ( &lt;em&gt;컨텐츠 전송 인코딩 : 8 비트&lt;/em&gt; )이있는 파트를 ASCII 호환 &lt;em&gt;컨텐츠 전송 인코딩으로 변환하십시오.&lt;/em&gt;MIME &lt;code&gt;unknown-8bit&lt;/code&gt; 문자 집합을 사용하여 헤더에서 RFC 유효하지 않은 비 ASCII 바이트를 인코딩 하여 RFC 호환으로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="2c701b67912c6e3c4a20fa3bedd65247e3914281" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; option &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;8bit&lt;/code&gt;, generate the message as if the option were set to &lt;code&gt;7bit&lt;/code&gt;. (This is required because strings cannot represent non-ASCII bytes.) Convert any bytes with the high bit set as needed using an ASCII-compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;. That is, transform parts with non-ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; (&lt;em&gt;Content-Transfer-Encoding: 8bit&lt;/em&gt;) to an ASCII compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;, and encode RFC-invalid non-ASCII bytes in headers using the MIME &lt;code&gt;unknown-8bit&lt;/code&gt; character set, thus rendering them RFC-compliant.</source>
          <target state="translated">는 IF &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 옵션 &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 이&lt;/a&gt; 입니다 &lt;code&gt;8bit&lt;/code&gt; 옵션으로 설정된 것처럼 메시지를 생성하는 &lt;code&gt;7bit&lt;/code&gt; . 문자열은 비 ASCII 바이트를 나타낼 수 없기 때문에 필요합니다. ASCII 호환 &lt;em&gt;Content-Transfer-Encoding을&lt;/em&gt; 사용하여 필요에 따라 높은 비트 세트의 바이트를 변환하십시오 . 즉, 비 ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; ( &lt;em&gt;Content-Transfer-Encoding : 8bit&lt;/em&gt; )이있는 파트를 ASCII 호환 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 으로 변환하고 MIME &lt;code&gt;unknown-8bit&lt;/code&gt; 를 사용하여 헤더에서 RFC 유효하지 않은 비 ASCII 바이트를 인코딩하십시오. 문자 세트를 사용하여 RFC를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="6705ff167ef2a10be922c82015337dad5632886f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module is loaded, input will automatically inherit &lt;strong&gt;bash&lt;/strong&gt;-like history-list editing (e.g.</source>
          <target state="translated">는 IF &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈이로드, 입력이 자동으로 상속됩니다 &lt;strong&gt;bash는&lt;/strong&gt; 역사 목록 -like 편집 (예 :</target>
        </trans-unit>
        <trans-unit id="992e16a7eb0c65f78ed4d6b22ea21a69e69f88d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module was loaded, then &lt;a href=&quot;#input&quot;&gt;&lt;code&gt;input()&lt;/code&gt;&lt;/a&gt; will use it to provide elaborate line editing and history features.</source>
          <target state="translated">는 IF &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈이로드 한 후 &lt;a href=&quot;#input&quot;&gt; &lt;code&gt;input()&lt;/code&gt; &lt;/a&gt; 정교한 라인 편집과 역사 기능을 제공하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f400827c02071e6ef95ee0237e542f0c4ec14fd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;.mo&lt;/code&gt; file&amp;rsquo;s magic number is invalid, the major version number is unexpected, or if other problems occur while reading the file, instantiating a &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt;&lt;code&gt;GNUTranslations&lt;/code&gt;&lt;/a&gt; class can raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;.mo&lt;/code&gt; 의 파일의 매직 번호가 유효하지 않은 인스턴스 파일을 읽는 동안 다른 문제가 발생하면, 주 버전 번호는 예상치 못한, 또는 &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt; &lt;code&gt;GNUTranslations&lt;/code&gt; 에&lt;/a&gt; 올릴 수 클래스를 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="210a0037ce73d1bfc67ee4b4b5e95490df8f8b6b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;REPLACE&lt;/code&gt; statement failed to insert the previous successful rowid is returned.</source>
          <target state="translated">는 IF &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;REPLACE&lt;/code&gt; 문이 이전에 성공한 ROWID를 삽입하는 데 실패 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf74d5b2f54438d18ff96c889c2efdf40add3ab4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;__cleanenv&lt;/code&gt; keyword is set, &lt;em&gt;env_vars&lt;/em&gt; is used as a fresh environment.</source>
          <target state="translated">는 IF &lt;code&gt;__cleanenv&lt;/code&gt; 의 키워드를 설정, &lt;em&gt;env_vars는&lt;/em&gt; 새로운 환경으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="7797779c313c0745d10542dc3e51baa071288853" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;binary_form&lt;/code&gt; parameter is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, and a certificate was received from the peer, this method returns a &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; instance. If the certificate was not validated, the dict is empty. If the certificate was validated, it returns a dict with several keys, amongst them &lt;code&gt;subject&lt;/code&gt; (the principal for which the certificate was issued) and &lt;code&gt;issuer&lt;/code&gt; (the principal issuing the certificate). If a certificate contains an instance of the &lt;em&gt;Subject Alternative Name&lt;/em&gt; extension (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3280.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 3280&lt;/strong&gt;&lt;/a&gt;), there will also be a &lt;code&gt;subjectAltName&lt;/code&gt; key in the dictionary.</source>
          <target state="translated">는 IF &lt;code&gt;binary_form&lt;/code&gt; 의 매개 변수가 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , 그리고 인증서가 피어로부터받은이 방법은 반환 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 인스턴스를. 인증서의 유효성이 검사되지 않으면 dict가 비어 있습니다. 인증서의 유효성이 검증 된 경우 &lt;code&gt;subject&lt;/code&gt; (인증서가 발행 된 주체 )와 &lt;code&gt;issuer&lt;/code&gt; ( 인증서가 발행 된 주체) 사이에 여러 키가 포함 된 dict를 리턴합니다 . 인증서에 &lt;em&gt;주체 대체 이름&lt;/em&gt; 확장 의 인스턴스가 포함 된 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3280.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 3280&lt;/strong&gt;&lt;/a&gt; 참조 ) 사전에 &lt;code&gt;subjectAltName&lt;/code&gt; 키 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2e0d519216a7d9523337363e10594cf657eace6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;binary_form&lt;/code&gt; parameter is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, and a certificate was provided, this method returns the DER-encoded form of the entire certificate as a sequence of bytes, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the peer did not provide a certificate. Whether the peer provides a certificate depends on the SSL socket&amp;rsquo;s role:</source>
          <target state="translated">는 IF &lt;code&gt;binary_form&lt;/code&gt; 의 매개 변수가 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; , 그리고 인증서가 제공되었다,이 메소드 리턴한다 바이트 순서, 또는 전체 인증서의 DER로 인코딩 된 형태 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 피어 인증서를 제공하지 않은 경우. 피어가 인증서를 제공하는지 여부는 SSL 소켓의 역할에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b7602209fb479da231610b89b7e98c9ce4312d1b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;default&lt;/code&gt; value is a string, the parser parses the value as if it were a command-line argument. In particular, the parser applies any &lt;a href=&quot;#type&quot;&gt;type&lt;/a&gt; conversion argument, if provided, before setting the attribute on the &lt;a href=&quot;#argparse.Namespace&quot;&gt;&lt;code&gt;Namespace&lt;/code&gt;&lt;/a&gt; return value. Otherwise, the parser uses the value as is:</source>
          <target state="translated">경우 &lt;code&gt;default&lt;/code&gt; 값이 문자열은 명령 줄 인수 것처럼, 파서는 값을 구문 분석합니다. 특히 구문 분석기는 &lt;a href=&quot;#argparse.Namespace&quot;&gt; &lt;code&gt;Namespace&lt;/code&gt; &lt;/a&gt; 리턴 값 에 속성을 설정하기 전에 제공된 경우 모든 &lt;a href=&quot;#type&quot;&gt;유형&lt;/a&gt; 변환 인수를 적용합니다 . 그렇지 않으면 파서는 값을 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="524a418bcb1a0b57bbd955c0618848eef7130b81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errcheck&lt;/code&gt; function returns the argument tuple it receives unchanged, &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; continues the normal processing it does on the output parameters. If you want to return a tuple of window coordinates instead of a &lt;code&gt;RECT&lt;/code&gt; instance, you can retrieve the fields in the function and return them instead, the normal processing will no longer take place:</source>
          <target state="translated">경우] &lt;code&gt;errcheck&lt;/code&gt; 의 것이 그대로 수신 튜플 함수는 인수를 반환 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 상기 출력 파라미터는 않는 통상의 처리를 계속한다. &lt;code&gt;RECT&lt;/code&gt; 인스턴스 대신 창 좌표의 튜플을 반환하려는 경우 함수에서 필드를 검색하여 대신 반환 할 수 있으며, 일반적인 처리는 더 이상 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf2573a0870de1e1acad81d1f5302762db9e30a1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fcntl()&lt;/code&gt; fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">는 IF &lt;code&gt;fcntl()&lt;/code&gt; 실패 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed678ab7c2a7ff6be9a99eeaf17a3ebf9fd3c1d0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flock()&lt;/code&gt; fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우] &lt;code&gt;flock()&lt;/code&gt; 실패 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="a7eec3c89612e0c25a2a5977559eba7c168d3900" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;freeze_support()&lt;/code&gt; line is omitted then trying to run the frozen executable will raise &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;freeze_support()&lt;/code&gt; 라인이 생략 된 후 올릴 냉동 실행 실행하려고 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed2522d782a9625d0947133482aaae29a6c466db" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ioctl()&lt;/code&gt; fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우] &lt;code&gt;ioctl()&lt;/code&gt; 실패 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="0cc2fbe72c3b4ad145fe3964a92c94ac6062f4e1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;maintype&lt;/code&gt; is &lt;code&gt;multipart&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;; otherwise look up a handler function based on the type of &lt;em&gt;obj&lt;/em&gt; (see next paragraph), call &lt;a href=&quot;email.message#email.message.EmailMessage.clear_content&quot;&gt;&lt;code&gt;clear_content()&lt;/code&gt;&lt;/a&gt; on the &lt;em&gt;msg&lt;/em&gt;, and call the handler function, passing through all arguments. The expectation is that the handler will transform and store &lt;em&gt;obj&lt;/em&gt; into &lt;em&gt;msg&lt;/em&gt;, possibly making other changes to &lt;em&gt;msg&lt;/em&gt; as well, such as adding various MIME headers to encode information needed to interpret the stored data.</source>
          <target state="translated">경우 &lt;code&gt;maintype&lt;/code&gt; 가 있다 &lt;code&gt;multipart&lt;/code&gt; , 인상 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 &lt;em&gt;obj&lt;/em&gt; 유형에 따라 핸들러 함수를 찾고 (다음 단락 참조 &lt;a href=&quot;email.message#email.message.EmailMessage.clear_content&quot;&gt; &lt;code&gt;clear_content()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; msg&lt;/em&gt; 에서 clear_content () 를 호출하고 모든 인수를 통해 핸들러 함수를 호출하십시오. 핸들러는 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;msg&lt;/em&gt; 로 변환하고 저장 하여 저장된 데이터를 해석하는 데 필요한 정보를 인코딩하기 위해 다양한 MIME 헤더를 추가하는 등 &lt;em&gt;msg에&lt;/em&gt; 대한 다른 변경도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="01aab64feb734e15541a9ef45d407a359bd7163d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nargs&lt;/code&gt; keyword argument is not provided, the number of arguments consumed is determined by the &lt;a href=&quot;#action&quot;&gt;action&lt;/a&gt;. Generally this means a single command-line argument will be consumed and a single item (not a list) will be produced.</source>
          <target state="translated">는 IF &lt;code&gt;nargs&lt;/code&gt; 키워드 인수가 제공되지 않는 인수의 수에 의해 결정됩니다 소비 &lt;a href=&quot;#action&quot;&gt;행동&lt;/a&gt; . 일반적으로 이는 단일 명령 줄 인수가 사용되고 단일 항목 (목록이 아님)이 생성됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d61c61e67464c67c3680c4713d3809692520d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;policy&lt;/code&gt; defines certain headers to be unique (as the standard policies do), this method may raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when an attempt is made to assign a value to such a header when one already exists. This behavior is intentional for consistency&amp;rsquo;s sake, but do not depend on it as we may choose to make such assignments do an automatic deletion of the existing header in the future.</source>
          <target state="translated">는 IF &lt;code&gt;policy&lt;/code&gt; (표준 정책처럼) 특정 헤더를 고유하게 정의하고,이 방법은 제기 할 수 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를을&lt;/a&gt; 시도가 이미있는 경우 이러한 헤더에 값을 할당하려고 할 때. 이 동작은 일관성을 위해 의도적 인 것이지만, 이러한 할당이 향후 기존 헤더를 자동으로 삭제하도록 선택할 수 있으므로 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b0c4b939b714d8d4621edf9c00758ce14c62b46" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;allow_fragments&lt;/em&gt; argument is false, fragment identifiers are not recognized. Instead, they are parsed as part of the path, parameters or query component, and &lt;code&gt;fragment&lt;/code&gt; is set to the empty string in the return value.</source>
          <target state="translated">는 IF &lt;em&gt;allow_fragments의&lt;/em&gt; 인수가 false, 조각 식별자는 인식되지 않습니다. 대신 경로, 매개 변수 또는 쿼리 구성 요소의 일부로 파싱되고 &lt;code&gt;fragment&lt;/code&gt; 은 반환 값에서 빈 문자열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="07fd1d70e19aeb308ff95aa96b168f877108f2f2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;data&lt;/em&gt; elements are not comparable, the data can be wrapped in a class that ignores the data item and only compares the priority number:</source>
          <target state="translated">상기 중간 &lt;em&gt;데이터&lt;/em&gt; 요소를 비교하지 않은 데이터는 상기 데이터 항목을 무시하고 우선 순위 번호를 비교하는 클래스로 래핑 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="2ff12e160cec1aee3fa846e0341806c3c002aa1b" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;decode_data&lt;/em&gt; constructor keyword is set to &lt;code&gt;True&lt;/code&gt;, the &lt;em&gt;data&lt;/em&gt; argument will be a unicode string. If it is set to &lt;code&gt;False&lt;/code&gt;, it will be a bytes object.</source>
          <target state="translated">는 IF &lt;em&gt;decode_data&lt;/em&gt; 생성자 키워드로 설정되어 &lt;code&gt;True&lt;/code&gt; 의 &lt;em&gt;데이터&lt;/em&gt; 인수는 유니 코드 문자열입니다. &lt;code&gt;False&lt;/code&gt; 로 설정되면 bytes 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="b6fd4d95e538d8f47be51a60097509c8d1f0049b" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;globals&lt;/em&gt; dictionary does not contain a value for the key &lt;code&gt;__builtins__&lt;/code&gt;, a reference to the dictionary of the built-in module &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; is inserted under that key. That way you can control what builtins are available to the executed code by inserting your own &lt;code&gt;__builtins__&lt;/code&gt; dictionary into &lt;em&gt;globals&lt;/em&gt; before passing it to &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;em&gt;전역의&lt;/em&gt; 딕셔너리는 키 값을 포함하지 않는 &lt;code&gt;__builtins__&lt;/code&gt; , 내장 모듈의 사전 참조 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 해당 키에 삽입된다. 그렇게하면 자신의 &lt;code&gt;__builtins__&lt;/code&gt; 사전을 &lt;em&gt;전역&lt;/em&gt; 에 삽입하여 &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 전달 함으로써 실행 된 코드에서 사용 가능한 내장을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="069dacc3747df8898ad29dd490b8b3d318fd8df1" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;lock&lt;/em&gt; argument is given and not &lt;code&gt;None&lt;/code&gt;, it must be a &lt;a href=&quot;#threading.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object, and it is used as the underlying lock. Otherwise, a new &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object is created and used as the underlying lock.</source>
          <target state="translated">경우 &lt;em&gt;잠금&lt;/em&gt; 인수가 주어지지되지 않고 &lt;code&gt;None&lt;/code&gt; , 그것은해야 &lt;a href=&quot;#threading.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체, 그것은 기본 잠금 장치로 사용됩니다. 그렇지 않으면 새 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체가 만들어져 기본 잠금으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b6ebb4583fd8191695e04b7d39b1f581cf29da7" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;name&lt;/em&gt; argument is provided and not &lt;code&gt;None&lt;/code&gt;, it is set as the name of the task using &lt;a href=&quot;asyncio-task#asyncio.Task.set_name&quot;&gt;&lt;code&gt;Task.set_name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 인수가 제공되고 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;asyncio-task#asyncio.Task.set_name&quot;&gt; &lt;code&gt;Task.set_name()&lt;/code&gt; &lt;/a&gt; 사용하여 작업의 이름으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="944dd20e7d4a05557cec3a977a23d9d4d3f2d8ce" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;names&lt;/em&gt; parameter is given, it must be a sequence containing the names of functions you want to install in the builtins namespace in addition to &lt;code&gt;_()&lt;/code&gt;. Supported names are &lt;code&gt;'gettext'&lt;/code&gt;, &lt;code&gt;'ngettext'&lt;/code&gt;, &lt;code&gt;'pgettext'&lt;/code&gt;, &lt;code&gt;'npgettext'&lt;/code&gt;, &lt;code&gt;'lgettext'&lt;/code&gt;, and &lt;code&gt;'lngettext'&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;em&gt;이름&lt;/em&gt; 매개 변수가 제공되어, 당신이뿐만 아니라 내장 매크로 이름 공간에 설치하려는 함수의 이름을 포함하는 순서해야합니다 &lt;code&gt;_()&lt;/code&gt; . 지원되는 이름은 &lt;code&gt;'gettext'&lt;/code&gt; , &lt;code&gt;'ngettext'&lt;/code&gt; , &lt;code&gt;'pgettext'&lt;/code&gt; , &lt;code&gt;'npgettext'&lt;/code&gt; , &lt;code&gt;'lgettext'&lt;/code&gt; 및 &lt;code&gt;'lngettext'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="158a36858ed9af1b9e9c3d28c384cc021e46769c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;optimize&lt;/em&gt; parameter to &lt;a href=&quot;#zipfile.PyZipFile&quot;&gt;&lt;code&gt;PyZipFile&lt;/code&gt;&lt;/a&gt; was &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;, only files with that optimization level (see &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;) are added to the archive, compiling if necessary.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.PyZipFile&quot;&gt; &lt;code&gt;PyZipFile&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;em&gt;optimize&lt;/em&gt; 매개 변수 가 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt; 이면 해당 최적화 레벨 ( &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 참조)을 가진 파일 만 아카이브에 추가되어 필요한 경우 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="7d5c62ff88707e4df1f101083878379244687d02" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;optimize&lt;/em&gt; parameter to &lt;a href=&quot;#zipfile.PyZipFile&quot;&gt;&lt;code&gt;PyZipFile&lt;/code&gt;&lt;/a&gt; was not given or &lt;code&gt;-1&lt;/code&gt;, the corresponding file is a &lt;code&gt;*.pyc&lt;/code&gt; file, compiling if necessary.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.PyZipFile&quot;&gt; &lt;code&gt;PyZipFile&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;em&gt;optimize&lt;/em&gt; 매개 변수 가 제공되지 않거나 &lt;code&gt;-1&lt;/code&gt; 이면 해당 파일은 &lt;code&gt;*.pyc&lt;/code&gt; 파일이며 필요한 경우 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="c7cdfc5e325d7266ce128da3b51f1e8b3f9943d8" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;password&lt;/em&gt; argument is not specified and a password is required, OpenSSL&amp;rsquo;s built-in password prompting mechanism will be used to interactively prompt the user for a password.</source>
          <target state="translated">경우 &lt;em&gt;암호&lt;/em&gt; 인수가 지정되지 않고 암호가 필요합니다, OpenSSL이 내장 된 암호 프롬프트 메커니즘은 암호를 대화 형 프롬프트 사용자에게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35fcb585a20584b556f4e162e5309c98983b0178" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;path&lt;/em&gt; is a string object (directly or indirectly through a &lt;a href=&quot;#os.PathLike&quot;&gt;&lt;code&gt;PathLike&lt;/code&gt;&lt;/a&gt; interface), the result will also be a string object, and the call may raise a UnicodeDecodeError. If the &lt;em&gt;path&lt;/em&gt; is a bytes object (direct or indirectly), the result will be a bytes object.</source>
          <target state="translated">상기 중간 &lt;em&gt;경로&lt;/em&gt; 캐릭터 오브젝트 (직접 또는 간접적 통해 &lt;a href=&quot;#os.PathLike&quot;&gt; &lt;code&gt;PathLike&lt;/code&gt; 의&lt;/a&gt; 인터페이스), 결과는 문자열 오브젝트 것이고, 통화는 UnicodeDecodeError을 올릴 수있다. 상기 중간 &lt;em&gt;경로&lt;/em&gt; (직접 또는 간접적으로) bytes 객체이며, 그 결과는 개체를 바이트 일 것이다.</target>
        </trans-unit>
        <trans-unit id="8c9066b80c3d8a541423631fefca4e57b368ec7b" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;prompt&lt;/em&gt; argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; is raised. Example:</source>
          <target state="translated">경우 &lt;em&gt;프롬프트&lt;/em&gt; 인수가 존재하고, 그것은 뒤에 줄 바꿈하지 않고 표준 출력에 기록됩니다. 그런 다음 함수는 입력에서 행을 읽고 문자열로 변환하여 (마지막 줄 바꿈), 반환합니다. EOF를 읽으면 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 예:</target>
        </trans-unit>
        <trans-unit id="93285696a22411d5d2e8a7f6363aa84855969bd3" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;resetids&lt;/em&gt; argument is &lt;code&gt;True&lt;/code&gt; it will reset the effective UID and GID of the child to the real UID and GID of the parent process. If the argument is &lt;code&gt;False&lt;/code&gt;, then the child retains the effective UID and GID of the parent. In either case, if the set-user-ID and set-group-ID permission bits are enabled on the executable file, their effect will override the setting of the effective UID and GID. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_RESETIDS&lt;/code&gt; flag.</source>
          <target state="translated">는 IF &lt;em&gt;resetids의&lt;/em&gt; 인수가 &lt;code&gt;True&lt;/code&gt; 은 부모 프로세스의 실제 UID와 GID에 아이의 유효 UID와 GID를 재설정합니다. 인수가 &lt;code&gt;False&lt;/code&gt; 인 경우 자식은 부모의 유효 UID 및 GID를 유지합니다. 두 경우 모두, 실행 파일에서 set-user-ID 및 set-group-ID 권한 비트가 활성화 된 경우 유효 UID 및 GID 설정이 무시됩니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_RESETIDS&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="88919bba2afc8f184e2a327acf142c1486867e0d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;setsid&lt;/em&gt; argument is &lt;code&gt;True&lt;/code&gt;, it will create a new session ID for &lt;code&gt;posix_spawn&lt;/code&gt;. &lt;em&gt;setsid&lt;/em&gt; requires &lt;code&gt;POSIX_SPAWN_SETSID&lt;/code&gt; or &lt;code&gt;POSIX_SPAWN_SETSID_NP&lt;/code&gt; flag. Otherwise, &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">는 IF &lt;em&gt;setsid&lt;/em&gt; 인수가 &lt;code&gt;True&lt;/code&gt; , 그것은을위한 새로운 세션 ID 생성합니다 &lt;code&gt;posix_spawn&lt;/code&gt; . &lt;em&gt;setsid&lt;/em&gt; 에는 &lt;code&gt;POSIX_SPAWN_SETSID&lt;/code&gt; 또는 &lt;code&gt;POSIX_SPAWN_SETSID_NP&lt;/code&gt; 플래그 가 필요합니다 . 그렇지 않으면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d24ec0d17c1f7e1a0a329ec520394941ae2b010" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;stderr&lt;/em&gt; argument was &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is a readable stream object as returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. Reading from the stream provides error output from the child process. If the &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; arguments were specified or the &lt;em&gt;universal_newlines&lt;/em&gt; argument was &lt;code&gt;True&lt;/code&gt;, the stream is a text stream, otherwise it is a byte stream. If the &lt;em&gt;stderr&lt;/em&gt; argument was not &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;em&gt;열려진&lt;/em&gt; 인수였다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 특성에 의해 반환 판독 스트림 목적 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; . 스트림에서 읽기는 하위 프로세스에서 오류 출력을 제공합니다. 경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 인수가 지정하거나 한 &lt;em&gt;universal_newlines의&lt;/em&gt; 인수가 있었다 &lt;code&gt;True&lt;/code&gt; , 스트림, 그렇지 않으면 바이트 스트림, 텍스트 스트림입니다. 경우 &lt;em&gt;표준 오류의&lt;/em&gt; 인수가 아니었다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 속성은 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e6be0106d84be33c234e54aaea99852564b5e3c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;stdin&lt;/em&gt; argument was &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is a writeable stream object as returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. If the &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; arguments were specified or the &lt;em&gt;universal_newlines&lt;/em&gt; argument was &lt;code&gt;True&lt;/code&gt;, the stream is a text stream, otherwise it is a byte stream. If the &lt;em&gt;stdin&lt;/em&gt; argument was not &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;em&gt;표준 입력&lt;/em&gt; 인자였다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 특성에 의해 반환 쓰기 가능한 스트림 목적 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 인수가 지정하거나 한 &lt;em&gt;universal_newlines의&lt;/em&gt; 인수가 있었다 &lt;code&gt;True&lt;/code&gt; , 스트림, 그렇지 않으면 바이트 스트림, 텍스트 스트림입니다. 경우 &lt;em&gt;표준 입력&lt;/em&gt; 인수가 아니었다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 속성은 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec355cf89b9dc73b02f80f0df2eaf169cc492684" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;stdout&lt;/em&gt; argument was &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is a readable stream object as returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. Reading from the stream provides output from the child process. If the &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; arguments were specified or the &lt;em&gt;universal_newlines&lt;/em&gt; argument was &lt;code&gt;True&lt;/code&gt;, the stream is a text stream, otherwise it is a byte stream. If the &lt;em&gt;stdout&lt;/em&gt; argument was not &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;em&gt;표준 출력의&lt;/em&gt; 인수였다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 특성에 의해 반환 판독 스트림 목적 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; . 스트림에서 읽기는 하위 프로세스의 출력을 제공합니다. 경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 인수가 지정하거나 한 &lt;em&gt;universal_newlines의&lt;/em&gt; 인수가 있었다 &lt;code&gt;True&lt;/code&gt; , 스트림, 그렇지 않으면 바이트 스트림, 텍스트 스트림입니다. 경우 &lt;em&gt;표준 출력의&lt;/em&gt; 인수가 아니었다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 속성은 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60dd2e899bc85f2db36a0109aa802d1a7f4ce7a0" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;url&lt;/em&gt; uses the &lt;code&gt;http:&lt;/code&gt; scheme identifier, the optional &lt;em&gt;data&lt;/em&gt; argument may be given to specify a &lt;code&gt;POST&lt;/code&gt; request (normally the request type is &lt;code&gt;GET&lt;/code&gt;). The &lt;em&gt;data&lt;/em&gt; argument must be a bytes object in standard &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt; format; see the &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt;&lt;code&gt;urllib.parse.urlencode()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; 용도 &lt;code&gt;http:&lt;/code&gt; 체계 식별자를, 선택적인 &lt;em&gt;데이터&lt;/em&gt; 인수가 지정받을 수 있습니다 &lt;code&gt;POST&lt;/code&gt; 의 요청 (일반적으로 요청 유형이다 &lt;code&gt;GET&lt;/code&gt; ). &lt;em&gt;데이터&lt;/em&gt; 인수 표준 bytes 객체 여야 &lt;em&gt;을 application / x-www-form-urlencoded 된&lt;/em&gt; 형태; &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt; &lt;code&gt;urllib.parse.urlencode()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="294c59bd568e04803a80acb61e134333ab0b073c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;url&lt;/em&gt; uses the &lt;code&gt;http:&lt;/code&gt; scheme identifier, the optional &lt;em&gt;data&lt;/em&gt; argument may be given to specify a &lt;code&gt;POST&lt;/code&gt; request (normally the request type is &lt;code&gt;GET&lt;/code&gt;). The &lt;em&gt;data&lt;/em&gt; argument must in standard &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt; format; see the &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt;&lt;code&gt;urllib.parse.urlencode()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; 용도 &lt;code&gt;http:&lt;/code&gt; 체계 식별자를, 선택적인 &lt;em&gt;데이터&lt;/em&gt; 인수가 지정받을 수 있습니다 &lt;code&gt;POST&lt;/code&gt; 의 요청 (일반적으로 요청 유형이다 &lt;code&gt;GET&lt;/code&gt; ). &lt;em&gt;데이터&lt;/em&gt; 표준 인자 필수 &lt;em&gt;어플리케이션 / x-www-form-urlencoded를&lt;/em&gt; 포맷; &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt; &lt;code&gt;urllib.parse.urlencode()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9974f7a3aebe3f3ce47175d7359b29d02772cfa6" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;utc&lt;/em&gt; argument is true, times in UTC will be used; otherwise local time is used.</source>
          <target state="translated">경우 &lt;em&gt;UTC&lt;/em&gt; 인수가 true, UTC에서 시간이 사용됩니다; 그렇지 않으면 현지 시간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b84602b7fa18863b22e6dbcff32969883dda4684" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;writeback&lt;/em&gt; parameter is &lt;code&gt;True&lt;/code&gt;, the object will hold a cache of all entries accessed and write them back to the &lt;em&gt;dict&lt;/em&gt; at sync and close times. This allows natural operations on mutable entries, but can consume much more memory and make sync and close take a long time.</source>
          <target state="translated">는 IF &lt;em&gt;쓰기 저장&lt;/em&gt; 매개 변수가 &lt;code&gt;True&lt;/code&gt; 오브젝트 액세스 모든 항목의 캐시를 잡고 다시에 기록됩니다 &lt;em&gt;DICT&lt;/em&gt; 동기화 및 가까운 시간에. 이를 통해 변경 가능한 항목에 대한 자연스러운 작업이 가능하지만 훨씬 더 많은 메모리를 소비하고 동기화 및 닫기에 오랜 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c144dbd6eb2a2ec5c9464d6a3b5b49fd560d35b3" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;parse&lt;/strong&gt; attribute is omitted, it defaults to &amp;ldquo;xml&amp;rdquo;. The href attribute is required.</source>
          <target state="translated">는 IF &lt;strong&gt;구문 분석&lt;/strong&gt; 속성은 &quot;XML&quot;에, 기본값을 생략하기로한다. href 속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="651912b3d40236c9ca01d4f642c00c2265e6c0e1" translate="yes" xml:space="preserve">
          <source>If the Future has been &lt;em&gt;cancelled&lt;/em&gt;, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Future가 &lt;em&gt;취소 된 경우&lt;/em&gt; ,이 메소드는 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6620141bffb844ff7e0a325c37437088a6fc0bb4" translate="yes" xml:space="preserve">
          <source>If the Future is &lt;em&gt;done&lt;/em&gt; and has a result set by the &lt;a href=&quot;#asyncio.Future.set_result&quot;&gt;&lt;code&gt;set_result()&lt;/code&gt;&lt;/a&gt; method, the result value is returned.</source>
          <target state="translated">Future가 &lt;em&gt;수행&lt;/em&gt; 되고 &lt;a href=&quot;#asyncio.Future.set_result&quot;&gt; &lt;code&gt;set_result()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 결과가 설정 되면 결과 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e0644b75daac5e15661852c684cb262de9f51c89" translate="yes" xml:space="preserve">
          <source>If the Future is &lt;em&gt;done&lt;/em&gt; and has an exception set by the &lt;a href=&quot;#asyncio.Future.set_exception&quot;&gt;&lt;code&gt;set_exception()&lt;/code&gt;&lt;/a&gt; method, this method raises the exception.</source>
          <target state="translated">Future가 &lt;em&gt;수행&lt;/em&gt; 되고 &lt;a href=&quot;#asyncio.Future.set_exception&quot;&gt; &lt;code&gt;set_exception()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 설정된 예외가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1195f6304df98cd2d3bc86ac4e83f5d2f868771a" translate="yes" xml:space="preserve">
          <source>If the Future is already &lt;em&gt;done&lt;/em&gt; or &lt;em&gt;cancelled&lt;/em&gt;, return &lt;code&gt;False&lt;/code&gt;. Otherwise, change the Future&amp;rsquo;s state to &lt;em&gt;cancelled&lt;/em&gt;, schedule the callbacks, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">미래가 이미 &lt;em&gt;완료&lt;/em&gt; 또는 &lt;em&gt;취소 된&lt;/em&gt; 경우 &lt;code&gt;False&lt;/code&gt; 를 반환하십시오 . 그렇지 않으면 Future 상태를 &lt;em&gt;canceled로&lt;/em&gt; 변경하고 콜백을 예약 한 다음 &lt;code&gt;True&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="37006e9f079c3accc6d5f6040b789291ba917d94" translate="yes" xml:space="preserve">
          <source>If the Future is already &lt;em&gt;done&lt;/em&gt; when this method is called, the callback is scheduled with &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 호출 될 때 Future가 이미 &lt;em&gt;완료된&lt;/em&gt; 경우 콜백은 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 예약됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb914681d6d5d5b08170de81c66e21d60e415ba0" translate="yes" xml:space="preserve">
          <source>If the Future isn&amp;rsquo;t &lt;em&gt;done&lt;/em&gt; yet, this method raises an &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Future가 아직 &lt;em&gt;완료&lt;/em&gt; 되지 않은 경우,이 메소드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="81ccf8aacb015ef04d4641484c8369a9b1dc7178" translate="yes" xml:space="preserve">
          <source>If the Future&amp;rsquo;s result isn&amp;rsquo;t yet available, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Future의 결과를 아직 사용할 수없는 경우이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2b7f6762700d8fee47524d6de578cf0f5d964de0" translate="yes" xml:space="preserve">
          <source>If the IPv4 address string passed to this function is invalid, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised. Note that exactly what is valid depends on the underlying C implementation of &lt;code&gt;inet_aton()&lt;/code&gt;.</source>
          <target state="translated">이 함수에 전달 된 IPv4 주소 문자열이 유효하지 않으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 정확히 유효한 것은 &lt;code&gt;inet_aton()&lt;/code&gt; 의 기본 C 구현에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="560fe43f47d62379a66ce9688e16e4014a73fc5a" translate="yes" xml:space="preserve">
          <source>If the Python installation has SSL support (i.e., if the &lt;a href=&quot;ssl#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module can be imported), &lt;a href=&quot;#urllib.request.HTTPSHandler&quot;&gt;&lt;code&gt;HTTPSHandler&lt;/code&gt;&lt;/a&gt; will also be added.</source>
          <target state="translated">Python 설치에 SSL 지원이있는 경우 (예 : &lt;a href=&quot;ssl#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 모듈을 가져올 수있는 경우 ) &lt;a href=&quot;#urllib.request.HTTPSHandler&quot;&gt; &lt;code&gt;HTTPSHandler&lt;/code&gt; &lt;/a&gt; 도 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea0b3ed7f3baf4db7002928837be7003ffe5eb0" translate="yes" xml:space="preserve">
          <source>If the SIGINT signal generated by</source>
          <target state="translated">SIGINT 신호가</target>
        </trans-unit>
        <trans-unit id="ca9dca35c700b2a4f039a704ed976b0b70c0a61f" translate="yes" xml:space="preserve">
          <source>If the Task has been &lt;em&gt;cancelled&lt;/em&gt;, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">작업이 &lt;em&gt;취소 된&lt;/em&gt; 경우이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="de231fa26bffd71d36d4fadee99f70cdd007208c" translate="yes" xml:space="preserve">
          <source>If the Task is &lt;em&gt;done&lt;/em&gt;, the result of the wrapped coroutine is returned (or if the coroutine raised an exception, that exception is re-raised.)</source>
          <target state="translated">태스크가 &lt;em&gt;완료&lt;/em&gt; 되면 랩핑 된 코 루틴의 결과가 리턴됩니다 (또는 코 루틴이 예외를 발생시킨 경우 해당 예외가 다시 발생합니다).</target>
        </trans-unit>
        <trans-unit id="c6606fc1940874e65aa19f560ba1745a72e10a6e" translate="yes" xml:space="preserve">
          <source>If the Task isn&amp;rsquo;t &lt;em&gt;done&lt;/em&gt; yet, this method raises an &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">작업이 아직 &lt;em&gt;완료&lt;/em&gt; 되지 않은 경우이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1dc46f1d10f9c96a479d508e9267096933ed6fa6" translate="yes" xml:space="preserve">
          <source>If the Task&amp;rsquo;s result isn&amp;rsquo;t yet available, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">작업 결과를 아직 사용할 수 없으면이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0d2428fdf8b60d8010dea0a01f7c47a9ea2e0739" translate="yes" xml:space="preserve">
          <source>If the XML input has &lt;a href=&quot;https://en.wikipedia.org/wiki/XML_namespace&quot;&gt;namespaces&lt;/a&gt;, tags and attributes with prefixes in the form &lt;code&gt;prefix:sometag&lt;/code&gt; get expanded to &lt;code&gt;{uri}sometag&lt;/code&gt; where the &lt;em&gt;prefix&lt;/em&gt; is replaced by the full &lt;em&gt;URI&lt;/em&gt;. Also, if there is a &lt;a href=&quot;https://www.w3.org/TR/xml-names/#defaulting&quot;&gt;default namespace&lt;/a&gt;, that full URI gets prepended to all of the non-prefixed tags.</source>
          <target state="translated">XML 입력에 &lt;a href=&quot;https://en.wikipedia.org/wiki/XML_namespace&quot;&gt;네임 스페이스&lt;/a&gt; 가 있는 경우 &lt;code&gt;prefix:sometag&lt;/code&gt; 양식의 &lt;em&gt;접 &lt;/em&gt;&lt;em&gt;두부&lt;/em&gt; 가 있는 태그 및 속성은 &lt;code&gt;{uri}sometag&lt;/code&gt; 로 확장되며 &lt;em&gt;접 &lt;/em&gt;&lt;em&gt;두부&lt;/em&gt; 가 전체 &lt;em&gt;URI&lt;/em&gt; 로 대체됩니다 . 또한 &lt;a href=&quot;https://www.w3.org/TR/xml-names/#defaulting&quot;&gt;기본 네임 스페이스&lt;/a&gt; 가 있으면 해당 전체 URI가 접두사가없는 모든 태그 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1035788874be82f93e34090a34131ddf3cbc5486" translate="yes" xml:space="preserve">
          <source>If the amount of data read exceeds the configured stream limit, a &lt;a href=&quot;asyncio-exceptions#asyncio.LimitOverrunError&quot;&gt;&lt;code&gt;LimitOverrunError&lt;/code&gt;&lt;/a&gt; exception is raised, and the data is left in the internal buffer and can be read again.</source>
          <target state="translated">읽은 데이터 양이 구성된 스트림 제한을 초과하면 &lt;a href=&quot;asyncio-exceptions#asyncio.LimitOverrunError&quot;&gt; &lt;code&gt;LimitOverrunError&lt;/code&gt; &lt;/a&gt; 예외가 발생하고 데이터가 내부 버퍼에 남아 있으며 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b49e74988c341dbee66d98c70300f05b412e8ad" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set it with the setEncoding method.</source>
          <target state="translated">응용 프로그램이 바이트 스트림의 문자 인코딩을 알고 있으면 setEncoding 메소드로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fa82cef5f28606b6fd2a9d2c0bbbdbbb88b6591" translate="yes" xml:space="preserve">
          <source>If the argument &lt;em&gt;alter_sys&lt;/em&gt; is supplied and evaluates to &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;sys.argv[0]&lt;/code&gt; is updated with the value of &lt;code&gt;__file__&lt;/code&gt; and &lt;code&gt;sys.modules[__name__]&lt;/code&gt; is updated with a temporary module object for the module being executed. Both &lt;code&gt;sys.argv[0]&lt;/code&gt; and &lt;code&gt;sys.modules[__name__]&lt;/code&gt; are restored to their original values before the function returns.</source>
          <target state="translated">인수 경우 &lt;em&gt;alter_sys가&lt;/em&gt; 공급되고, 평가되고 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;sys.argv[0]&lt;/code&gt; 의 값으로 갱신된다 &lt;code&gt;__file__&lt;/code&gt; 및 &lt;code&gt;sys.modules[__name__]&lt;/code&gt; 모듈이 실행되는 임시 모듈 오브젝트로 갱신된다. 두 &lt;code&gt;sys.argv[0]&lt;/code&gt; 및 &lt;code&gt;sys.modules[__name__]&lt;/code&gt; 함수 반환되기 전에 원래의 값으로 복원된다.</target>
        </trans-unit>
        <trans-unit id="a5411ed7af975d74d9bde61eea8619af34a7725c" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;a href=&quot;asyncio-task#coroutine&quot;&gt;coroutine object&lt;/a&gt; it is implicitly scheduled to run as a &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;asyncio.Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 &lt;a href=&quot;asyncio-task#coroutine&quot;&gt;코 루틴 오브젝트 인&lt;/a&gt; 경우 암시 적으로 &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;asyncio.Task&lt;/code&gt; &lt;/a&gt; 로 실행되도록 스케줄됩니다 .</target>
        </trans-unit>
        <trans-unit id="81ba162b85ef412221638aff281d53793a7875ce" translate="yes" xml:space="preserve">
          <source>If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be &lt;code&gt;'+'&lt;/code&gt; or &lt;code&gt;'-'&lt;/code&gt;; a &lt;code&gt;'+'&lt;/code&gt; sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or a positive or negative infinity. More precisely, the input must conform to the following grammar after leading and trailing whitespace characters are removed:</source>
          <target state="translated">인수가 문자열 인 경우 10 진수를 포함해야하며 선택적으로 부호가 앞에오고 선택적으로 공백에 포함됩니다. 선택적 부호는 &lt;code&gt;'+'&lt;/code&gt; 또는 &lt;code&gt;'-'&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;'+'&lt;/code&gt; 기호가 생성되는 값에 영향을주지 않습니다. 인수는 NaN (숫자가 아님)을 나타내는 문자열이거나 양수 또는 음수 무한대 일 수도 있습니다. 더 정확하게 말하면 선행 및 후행 공백 문자가 제거 된 후 입력은 다음 문법을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="e0bf4582d5afa94925ba1fb86d35299839904863" translate="yes" xml:space="preserve">
          <source>If the argument is positive, and the underlying raw stream is not interactive, multiple raw reads may be issued to satisfy the byte count (unless EOF is reached first). But for interactive raw streams, at most one raw read will be issued, and a short result does not imply that EOF is imminent.</source>
          <target state="translated">인수가 양수이고 기본 원시 스트림이 대화식이 아닌 경우 바이트 수를 만족시키기 위해 여러 원시 읽기가 발행 될 수 있습니다 (EOF에 먼저 도달하지 않은 경우). 그러나 대화식 원시 스트림의 경우 최대 하나의 원시 읽기가 발행되며 짧은 결과가 EOF가 임박했음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf5c155da4b8b4fe57abec8d0c0e72c648a413c5" translate="yes" xml:space="preserve">
          <source>If the argument to the closure is not an existing directory, &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">클로저에 대한 인수가 기존 디렉토리가 아닌 경우 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e34bdcceb6034130f11958c3ceb8f25313fc52d" translate="yes" xml:space="preserve">
          <source>If the attempt to make the socket connection fails, Idle will notify you. Such failures are sometimes transient, but if persistent, the problem may be either a firewall blocking the connection or misconfiguration of a particular system. Until the problem is fixed, one can run Idle with the -n command line switch.</source>
          <target state="translated">소켓 연결 시도가 실패하면 유휴 상태가 표시됩니다. 이러한 장애는 때때로 일시적이지만, 지속되는 경우 문제는 방화벽이 연결을 차단하거나 특정 시스템의 구성이 잘못되었을 수 있습니다. 문제가 해결 될 때까지 -n 명령 행 스위치를 사용하여 유휴를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5376fd70393bce3b2627873412a2a120086e43a7" translate="yes" xml:space="preserve">
          <source>If the buffer is too short then a &lt;code&gt;BufferTooShort&lt;/code&gt; exception is raised and the complete message is available as &lt;code&gt;e.args[0]&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is the exception instance.</source>
          <target state="translated">버퍼가 너무 짧으면 &lt;code&gt;BufferTooShort&lt;/code&gt; 예외가 발생하고 전체 메시지를 &lt;code&gt;e.args[0]&lt;/code&gt; 으로 사용할 수 있습니다 . 여기서 &lt;code&gt;e&lt;/code&gt; 는 예외 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b55ba6cd680fc7c446defa1148be7f603a8c347a" translate="yes" xml:space="preserve">
          <source>If the buffer size equals the high watermark, &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt;&lt;code&gt;pause_writing()&lt;/code&gt;&lt;/a&gt; is not called: the buffer size must go strictly over.</source>
          <target state="translated">버퍼 크기가 높은 워터 마크와 &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt; &lt;code&gt;pause_writing()&lt;/code&gt; &lt;/a&gt; 이 호출되지 않습니다. 버퍼 크기는 엄격하게 넘어 가야합니다.</target>
        </trans-unit>
        <trans-unit id="c975333ddfdaa3bf375713fbe96ca6198feddace" translate="yes" xml:space="preserve">
          <source>If the byte sequence passed to this function is not exactly 4 bytes in length, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised. &lt;a href=&quot;#socket.inet_ntoa&quot;&gt;&lt;code&gt;inet_ntoa()&lt;/code&gt;&lt;/a&gt; does not support IPv6, and &lt;a href=&quot;#socket.inet_ntop&quot;&gt;&lt;code&gt;inet_ntop()&lt;/code&gt;&lt;/a&gt; should be used instead for IPv4/v6 dual stack support.</source>
          <target state="translated">이 함수에 전달 된 바이트 시퀀스의 길이가 정확히 4 바이트가 아닌 경우 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;a href=&quot;#socket.inet_ntoa&quot;&gt; &lt;code&gt;inet_ntoa()&lt;/code&gt; &lt;/a&gt; 는 IPv6을 지원하지 않으며 IPv4 / v6 이중 스택 지원에는 &lt;a href=&quot;#socket.inet_ntop&quot;&gt; &lt;code&gt;inet_ntop()&lt;/code&gt; &lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4080aabef6f9144e191027041093c739d2c1b3bd" translate="yes" xml:space="preserve">
          <source>If the call completed without raising, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">전화를 올리지 않고 완료하면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f83b4efd6f712f456500a47232013459d991539c" translate="yes" xml:space="preserve">
          <source>If the call raised, this method will raise the same exception.</source>
          <target state="translated">호출이 발생하면이 메소드는 동일한 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="98c6607719d86226a4951bc27faa2632178e9837" translate="yes" xml:space="preserve">
          <source>If the call times out, the barrier is put into the broken state.</source>
          <target state="translated">호출 시간이 초과되면 장벽이 끊어진 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="34c6962c614477a6094fef9f3349e26138a51253" translate="yes" xml:space="preserve">
          <source>If the calling task has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">이 메소드가 호출 될 때 호출 태스크가 잠금을 획득하지 않은 경우 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8100a6b6af3438279c1efdd3048e83262e4a542c" translate="yes" xml:space="preserve">
          <source>If the character set must be encoded before it can be used in an email header, this attribute will be set to &lt;code&gt;Charset.QP&lt;/code&gt; (for quoted-printable), &lt;code&gt;Charset.BASE64&lt;/code&gt; (for base64 encoding), or &lt;code&gt;Charset.SHORTEST&lt;/code&gt; for the shortest of QP or BASE64 encoding. Otherwise, it will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문자 세트를 이메일 헤더에 사용하기 전에 인코딩해야하는 경우이 속성은 &lt;code&gt;Charset.QP&lt;/code&gt; (따옴표로 인쇄 가능), &lt;code&gt;Charset.BASE64&lt;/code&gt; (base64 인코딩) 또는 &lt;code&gt;Charset.SHORTEST&lt;/code&gt; ( 가장 짧은 것)로 설정됩니다 . QP 또는 BASE64 인코딩 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8caac2adb6bf9423fea6039c1be36f8bc7d75e" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5173bdebec1086940c7a8a6c5f27b3d81d48ed3a" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb1399398df7c668ff6210d8b504532d3b5fe53" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 이미 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e40f424d0a60fa1524e20d8b1ff8a462f2310e" translate="yes" xml:space="preserve">
          <source>If the class already defines any of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; 중 하나를 정의하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18d54afc52e2190ab5698bf62a007d327a0d9532" translate="yes" xml:space="preserve">
          <source>If the class is instantiated multiple times you could use &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; to return a new mock each time. Alternatively you can set the &lt;em&gt;return_value&lt;/em&gt; to be anything you want.</source>
          <target state="translated">클래스가 여러 번 인스턴스화되면 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 를 사용하여 매번 새 모의를 반환 할 수 있습니다 . 또는 &lt;em&gt;return_value&lt;/em&gt; 를 원하는 것으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0844b2f1f4f28f1d3c7e82725d649a65558d8346" translate="yes" xml:space="preserve">
          <source>If the cmd argument to popen2 functions is a string, the command is executed through /bin/sh. If it is a list, the command is directly executed.</source>
          <target state="translated">popen2 함수에 대한 cmd 인수가 문자열이면 / bin / sh를 통해 명령이 실행됩니다. 목록 인 경우 명령이 직접 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0b487b3fa1bfe238daee50939a9f3547d743abdb" translate="yes" xml:space="preserve">
          <source>If the code has a jump target and &lt;em&gt;jump&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#dis.stack_effect&quot;&gt;&lt;code&gt;stack_effect()&lt;/code&gt;&lt;/a&gt; will return the stack effect of jumping. If &lt;em&gt;jump&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, it will return the stack effect of not jumping. And if &lt;em&gt;jump&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (default), it will return the maximal stack effect of both cases.</source>
          <target state="translated">코드에 점프 대상이 있고 &lt;em&gt;jump&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;#dis.stack_effect&quot;&gt; &lt;code&gt;stack_effect()&lt;/code&gt; &lt;/a&gt; 는 점프의 스택 효과를 반환합니다. &lt;em&gt;jump&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 이면 &lt;em&gt;점프&lt;/em&gt; 하지 않는 스택 효과를 반환합니다. 그리고 &lt;em&gt;jump&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 두 경우의 최대 스택 효과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f49dfb1d7b288c0f309278b39f37d05e88304b1" translate="yes" xml:space="preserve">
          <source>If the configuration value specified by &lt;em&gt;name&lt;/em&gt; isn&amp;rsquo;t defined, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;em&gt;name&lt;/em&gt; 으로 지정된 구성 값 이 정의되지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0290d581f118be47fbc672209c5237cf2ee347a" translate="yes" xml:space="preserve">
          <source>If the connection is interrupted by a signal, the method waits until the connection completes, or raise a &lt;a href=&quot;#socket.timeout&quot;&gt;&lt;code&gt;socket.timeout&lt;/code&gt;&lt;/a&gt; on timeout, if the signal handler doesn&amp;rsquo;t raise an exception and the socket is blocking or has a timeout. For non-blocking sockets, the method raises an &lt;a href=&quot;exceptions#InterruptedError&quot;&gt;&lt;code&gt;InterruptedError&lt;/code&gt;&lt;/a&gt; exception if the connection is interrupted by a signal (or the exception raised by the signal handler).</source>
          <target state="translated">신호에 의해 연결이 중단 된 경우 신호 처리기가 예외를 발생시키지 않고 소켓이 차단되거나 시간 초과 된 경우 연결이 완료 될 때까지 대기하거나 시간 &lt;a href=&quot;#socket.timeout&quot;&gt; &lt;code&gt;socket.timeout&lt;/code&gt; &lt;/a&gt; 을 발생시킵니다. 비 블로킹 소켓의 경우,이 메소드 는 연결이 신호 (또는 신호 처리기에서 발생한 예외)에 의해 중단되면 &lt;a href=&quot;exceptions#InterruptedError&quot;&gt; &lt;code&gt;InterruptedError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1ccfc1df4a51fc69641651224aae9f0339a11398" translate="yes" xml:space="preserve">
          <source>If the connection to the server is lost while waiting for the reply, &lt;a href=&quot;#smtplib.SMTPServerDisconnected&quot;&gt;&lt;code&gt;SMTPServerDisconnected&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">응답을 기다리는 동안 서버와의 연결이 끊어지면 &lt;a href=&quot;#smtplib.SMTPServerDisconnected&quot;&gt; &lt;code&gt;SMTPServerDisconnected&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ad155938abd6bd816f11164daa5559b5b6f8335" translate="yes" xml:space="preserve">
          <source>If the containing toplevel&amp;rsquo;s position was specified relative to the right or bottom of the screen (e.g. &amp;hellip;.), the &lt;code&gt;Sizegrip&lt;/code&gt; widget will not resize the window.</source>
          <target state="translated">포함하는 최상위 레벨의 위치가 화면의 오른쪽 또는 아래쪽을 기준으로 지정된 경우 (예 :&amp;hellip;.) &lt;code&gt;Sizegrip&lt;/code&gt; 위젯은 창 크기를 조정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43dd941fcd2c8ec7d6f5b3b06bac3aa6c32162ba" translate="yes" xml:space="preserve">
          <source>If the context&amp;rsquo;s trap enabler is set for the signal, then the condition causes a Python exception to be raised. For example, if the &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt; trap is set, then a &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt; exception is raised upon encountering the condition.</source>
          <target state="translated">컨텍스트의 트랩 인 에이 블러가 신호에 대해 설정된 경우이 조건으로 인해 Python 예외가 발생합니다. 예를 들어, &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; &lt;/a&gt; 트랩이 설정된 경우 조건이 발생 하면 &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22595aef4892c0871cfe75e3e28f828bb007ef0c" translate="yes" xml:space="preserve">
          <source>If the converter needs to access the state of the parser, it can be implemented as a method on a config parser subclass. If the name of this method starts with &lt;code&gt;get&lt;/code&gt;, it will be available on all section proxies, in the dict-compatible form (see the &lt;code&gt;getdecimal()&lt;/code&gt; example above).</source>
          <target state="translated">변환기가 구문 분석기의 상태에 액세스해야하는 경우 구성 구문 분석기 서브 클래스에서 메소드로 구현 될 수 있습니다. 이 메소드의 이름이 &lt;code&gt;get&lt;/code&gt; 로 시작 하면 모든 섹션 프록시에서 dict 호환 형식으로 사용할 수 있습니다 &lt;code&gt;getdecimal()&lt;/code&gt; 위 의 getdecimal () 예제 참조).</target>
        </trans-unit>
        <trans-unit id="8b3d3dc34b0d0bf1c8c7d4897bc704963dd23f37" translate="yes" xml:space="preserve">
          <source>If the cursor is over an output line, squeeze all the output between the code above and the prompt below down to a &amp;lsquo;Squeezed text&amp;rsquo; label.</source>
          <target state="translated">커서가 출력 행 위에 있으면 위 코드와 아래 프롬프트 사이의 모든 출력을 '압착 된 텍스트'레이블로 꽉 쥐십시오.</target>
        </trans-unit>
        <trans-unit id="a84ed8f0fda6ec2ae9ca1bc860b4c3906be5fb5d" translate="yes" xml:space="preserve">
          <source>If the data being deserialized is not a valid JSON document, a &lt;a href=&quot;#json.JSONDecodeError&quot;&gt;&lt;code&gt;JSONDecodeError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">직렬화 해제중인 데이터가 유효한 JSON 문서가 아닌 경우 &lt;a href=&quot;#json.JSONDecodeError&quot;&gt; &lt;code&gt;JSONDecodeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="722e3f031b5abfe9b3484e64e6d2902f708fa4b0" translate="yes" xml:space="preserve">
          <source>If the data is ordinal (supports order operations) but not numeric (doesn&amp;rsquo;t support addition), consider using &lt;a href=&quot;#statistics.median_low&quot;&gt;&lt;code&gt;median_low()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#statistics.median_high&quot;&gt;&lt;code&gt;median_high()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">데이터가 순 &lt;a href=&quot;#statistics.median_low&quot;&gt; &lt;code&gt;median_low()&lt;/code&gt; &lt;/a&gt; 순서 연산 지원)이지만 숫자가 아닌 (더하기를 지원하지 않는) 경우 median_low () 또는 &lt;a href=&quot;#statistics.median_high&quot;&gt; &lt;code&gt;median_high()&lt;/code&gt; &lt;/a&gt; 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="154822805c12d2aab70f1b641202eb990335ef91" translate="yes" xml:space="preserve">
          <source>If the database file already exists, the &lt;a href=&quot;#dbm.whichdb&quot;&gt;&lt;code&gt;whichdb()&lt;/code&gt;&lt;/a&gt; function is used to determine its type and the appropriate module is used; if it does not exist, the first module listed above that can be imported is used.</source>
          <target state="translated">데이터베이스 파일이 이미 존재하면 &lt;a href=&quot;#dbm.whichdb&quot;&gt; &lt;code&gt;whichdb()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 유형을 판별하고 적절한 모듈이 사용됩니다. 존재하지 않으면 위에 나열된 첫 번째 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b118369699b7fc02d2c91e666ca503503b584356" translate="yes" xml:space="preserve">
          <source>If the debugger should stop at this exception, invokes the &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt;&lt;code&gt;user_exception()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt;&lt;code&gt;user_exception()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가이 예외에서 중지해야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt; &lt;code&gt;user_exception()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt; &lt;code&gt;user_exception()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="d65f4eae2712c33680ab9efbc1f19062565841d8" translate="yes" xml:space="preserve">
          <source>If the debugger should stop on the current line, invoke the &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt;&lt;code&gt;user_line()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt;&lt;code&gt;user_line()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가 현재 행에서 중지되어야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt; &lt;code&gt;user_line()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt; &lt;code&gt;user_line()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1c7df4d0adf08d6f3c7e84cf0ae146dc6be7d64" translate="yes" xml:space="preserve">
          <source>If the debugger should stop on this function call, invoke the &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt;&lt;code&gt;user_call()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt;&lt;code&gt;user_call()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가이 함수 호출에서 중지해야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt; &lt;code&gt;user_call()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt; &lt;code&gt;user_call()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="be5272f439cf1bb932bed5ba2fa9705c6449082c" translate="yes" xml:space="preserve">
          <source>If the debugger should stop on this function return, invoke the &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt;&lt;code&gt;user_return()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt;&lt;code&gt;user_return()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가이 함수 리턴에서 중지해야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt; &lt;code&gt;user_return()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt; &lt;code&gt;user_return()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="201fc8099c1ec49d0ede598d1afe842c5aadcbab" translate="yes" xml:space="preserve">
          <source>If the default value of a field is specified by a call to &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt;, then the class attribute for this field will be replaced by the specified &lt;code&gt;default&lt;/code&gt; value. If no &lt;code&gt;default&lt;/code&gt; is provided, then the class attribute will be deleted. The intent is that after the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator runs, the class attributes will all contain the default values for the fields, just as if the default value itself were specified. For example, after:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt; 호출하여 필드의 &lt;code&gt;default&lt;/code&gt; 지정하면이 필드의 클래스 속성이 지정된 기본값 으로 바뀝니다 . &lt;code&gt;default&lt;/code&gt; 이 제공 되지 않으면 클래스 속성이 삭제됩니다. 의도는 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 데코레이터가 실행 된 후 , 기본값 자체가 지정된 것처럼 클래스 속성이 모두 필드의 기본값을 포함한다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ae4681cafc2df817b63559ac73e2e01d8b7ddf0" translate="yes" xml:space="preserve">
          <source>If the destination is an existing directory, then &lt;em&gt;src&lt;/em&gt; is moved inside that directory. If the destination already exists but is not a directory, it may be overwritten depending on &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt; semantics.</source>
          <target state="translated">대상이 기존 디렉토리 인 경우 &lt;em&gt;src&lt;/em&gt; 는 해당 디렉토리 내로 이동합니다. 대상이 이미 존재하지만 디렉토리가 아닌 경우 &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; 의미 에 따라 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90a483529ef380acfabb4df595aa7f9eedaacd18" translate="yes" xml:space="preserve">
          <source>If the destination is on the current filesystem, then &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt; is used. Otherwise, &lt;em&gt;src&lt;/em&gt; is copied to &lt;em&gt;dst&lt;/em&gt; using &lt;em&gt;copy_function&lt;/em&gt; and then removed. In case of symlinks, a new symlink pointing to the target of &lt;em&gt;src&lt;/em&gt; will be created in or as &lt;em&gt;dst&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; will be removed.</source>
          <target state="translated">대상이 현재 파일 시스템에 있으면 &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 그렇지 않으면, &lt;em&gt;src&lt;/em&gt; 는 &lt;em&gt;copy_function을&lt;/em&gt; 사용하여 &lt;em&gt;dst에&lt;/em&gt; 복사 된 후 제거됩니다. 심볼릭 링크의 경우, &lt;em&gt;src&lt;/em&gt; 대상을 가리키는 새로운 심볼릭 링크 가 &lt;em&gt;dst에&lt;/em&gt; 생성되거나 &lt;em&gt;dst&lt;/em&gt; 와 &lt;em&gt;src&lt;/em&gt; 가 제거됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7f148091df358050d8bcfaf1e96d8acba5a8a3d" translate="yes" xml:space="preserve">
          <source>If the directory already exists, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">디렉토리가 이미 존재하면 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f4bf018015908f2a980d2821276c417e78ee5737" translate="yes" xml:space="preserve">
          <source>If the directory contains files starting with &lt;code&gt;.&lt;/code&gt; they won&amp;rsquo;t be matched by default. For example, consider a directory containing &lt;code&gt;card.gif&lt;/code&gt; and &lt;code&gt;.card.gif&lt;/code&gt;:</source>
          <target state="translated">디렉토리로 시작하는 파일에 포함되어있는 경우 &lt;code&gt;.&lt;/code&gt; 기본적으로 일치하지 않습니다. 예를 들어, &lt;code&gt;card.gif&lt;/code&gt; 및 &lt;code&gt;.card.gif&lt;/code&gt; 를 포함하는 디렉토리를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ced573f72ad49106a583ae064c2db74e18bb9c9" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code id=&quot;index-0&quot;&gt;BROWSER&lt;/code&gt; exists, it is interpreted as the &lt;a href=&quot;os#os.pathsep&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt;-separated list of browsers to try ahead of the platform defaults. When the value of a list part contains the string &lt;code&gt;%s&lt;/code&gt;, then it is interpreted as a literal browser command line to be used with the argument URL substituted for &lt;code&gt;%s&lt;/code&gt;; if the part does not contain &lt;code&gt;%s&lt;/code&gt;, it is simply interpreted as the name of the browser to launch. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">환경 변수 &lt;code id=&quot;index-0&quot;&gt;BROWSER&lt;/code&gt; 가 존재하면 이는 플랫폼 기본값보다 먼저 시도하기 위해 &lt;a href=&quot;os#os.pathsep&quot;&gt; &lt;code&gt;os.pathsep&lt;/code&gt; 로 구분 된&lt;/a&gt; 브라우저 목록으로 해석됩니다 . 목록 부분의 값에 문자열 &lt;code&gt;%s&lt;/code&gt; 가 포함 된 경우 &lt;code&gt;%s&lt;/code&gt; 대신 인수 URL과 함께 사용되는 리터럴 브라우저 명령 행으로 해석됩니다 . 부품에 &lt;code&gt;%s&lt;/code&gt; 가 포함되어 있지 않으면 단순히 시작할 브라우저의 이름으로 해석됩니다. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4992ba0add3e62936beba1abed0141fdfe5937a4" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;REQUEST_METHOD&lt;/code&gt; is set, which usually indicates your script is running in a CGI environment, the environment variable &lt;code&gt;HTTP_PROXY&lt;/code&gt; (uppercase &lt;code&gt;_PROXY&lt;/code&gt;) will be ignored. This is because that variable can be injected by a client using the &amp;ldquo;Proxy:&amp;rdquo; HTTP header. If you need to use an HTTP proxy in a CGI environment, either use &lt;code&gt;ProxyHandler&lt;/code&gt; explicitly, or make sure the variable name is in lowercase (or at least the &lt;code&gt;_proxy&lt;/code&gt; suffix).</source>
          <target state="translated">스크립트가 CGI 환경에서 실행 중임을 나타내는 환경 변수 &lt;code&gt;REQUEST_METHOD&lt;/code&gt; 가 설정되면 환경 변수 &lt;code&gt;HTTP_PROXY&lt;/code&gt; (대문자 &lt;code&gt;_PROXY&lt;/code&gt; )가 무시됩니다. 이는 클라이언트가&amp;ldquo;Proxy :&amp;rdquo;HTTP 헤더를 사용하여 해당 변수를 주입 할 수 있기 때문입니다. CGI 환경에서 HTTP 프록시를 사용해야하는 경우 &lt;code&gt;ProxyHandler&lt;/code&gt; 를 명시 적으로 사용 하거나 변수 이름이 소문자 (또는 &lt;code&gt;_proxy&lt;/code&gt; 접미어 이상)인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="733c3f8ae616712998ec582c7dc9418f60036c61" translate="yes" xml:space="preserve">
          <source>If the event is set, return &lt;code&gt;True&lt;/code&gt; immediately. Otherwise block until another task calls &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이벤트가 설정되면 즉시 &lt;code&gt;True&lt;/code&gt; 를 리턴 하십시오. 그렇지 않으면 다른 작업이 &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 차단하십시오 .</target>
        </trans-unit>
        <trans-unit id="378c9e1cdfb8344fd77c512889f953f89cb90508" translate="yes" xml:space="preserve">
          <source>If the exact value is unimportant you can use &lt;a href=&quot;#enum.auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">정확한 값이 중요하지 않은 경우 &lt;a href=&quot;#enum.auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80196981eb3b8cd3185224864fb45d685edece2b" translate="yes" xml:space="preserve">
          <source>If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged.</source>
          <target state="translated">확장이 실패하거나 경로가 물결표로 시작하지 않으면 경로는 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="25581f556094bf0f7a3af63df730aedc4bbc5af1" translate="yes" xml:space="preserve">
          <source>If the exponent of the second operand is larger than that of the first then rounding may be necessary. In this case, the rounding mode is determined by the &lt;code&gt;rounding&lt;/code&gt; argument if given, else by the given &lt;code&gt;context&lt;/code&gt; argument; if neither argument is given the rounding mode of the current thread&amp;rsquo;s context is used.</source>
          <target state="translated">두 번째 피연산자의 지수가 첫 번째 피연산자의 지수보다 크면 반올림이 필요할 수 있습니다. 이 경우 반올림 모드는 &lt;code&gt;rounding&lt;/code&gt; 인수에 의해 결정되며 , 그렇지 않으면 주어진 &lt;code&gt;context&lt;/code&gt; 인수에 의해 결정됩니다 . 인수에 현재 스레드 컨텍스트의 반올림 모드가 제공되지 않은 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f40d8b7c76b10f8d6afc27ed43238ec343c52d0a" translate="yes" xml:space="preserve">
          <source>If the fast-copy operation fails and no data was written in the destination file then shutil will silently fallback on using less efficient &lt;a href=&quot;#shutil.copyfileobj&quot;&gt;&lt;code&gt;copyfileobj()&lt;/code&gt;&lt;/a&gt; function internally.</source>
          <target state="translated">빠른 복사 작업이 실패하고 대상 파일에 데이터가 기록되지 않은 경우 shutil은 내부적으로 덜 효율적인 &lt;a href=&quot;#shutil.copyfileobj&quot;&gt; &lt;code&gt;copyfileobj()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 자동으로 폴백됩니다 .</target>
        </trans-unit>
        <trans-unit id="7904f5dd4c3c1ff4fa7eecbfcee0078bf02fe590" translate="yes" xml:space="preserve">
          <source>If the file descriptor is not connected to a terminal, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">파일 디스크립터가 터미널에 연결되어 있지 않으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="204d5c0bddce0bad70b8e8384a949257afd035f7" translate="yes" xml:space="preserve">
          <source>If the file is created with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt; and then &lt;a href=&quot;#zipfile.ZipFile.close&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt; without adding any files to the archive, the appropriate ZIP structures for an empty archive will be written to the file.</source>
          <target state="translated">파일이 &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 모드로 작성된 후 파일을 아카이브에 추가하지 않고 &lt;a href=&quot;#zipfile.ZipFile.close&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 빈 아카이브에 대한 적절한 ZIP 구조가 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b3807f55b2bb553078d84e9b4f290c46390447" translate="yes" xml:space="preserve">
          <source>If the first character is not one of these, &lt;code&gt;'@'&lt;/code&gt; is assumed.</source>
          <target state="translated">첫 번째 문자가 이들 중 하나가 아닌 경우 &lt;code&gt;'@'&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd2158e2f17566a6c9110f348c8d34a00d129fc" translate="yes" xml:space="preserve">
          <source>If the first character of the option string is &lt;code&gt;'+'&lt;/code&gt;, or if the environment variable &lt;code id=&quot;index-0&quot;&gt;POSIXLY_CORRECT&lt;/code&gt; is set, then option processing stops as soon as a non-option argument is encountered.</source>
          <target state="translated">옵션 문자열의 첫 문자가 &lt;code&gt;'+'&lt;/code&gt; 이거나 환경 변수 &lt;code id=&quot;index-0&quot;&gt;POSIXLY_CORRECT&lt;/code&gt; 가 설정된 경우 비 옵션 인수가 발생하자마자 옵션 처리가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="c76146671826ba2b4412a62fe7631ca797af78d5" translate="yes" xml:space="preserve">
          <source>If the floating-point &lt;em&gt;timeout&lt;/em&gt; argument is present and positive, it specifies the maximum wait time in seconds before returning. A negative &lt;em&gt;timeout&lt;/em&gt; argument specifies an unbounded wait. You cannot specify a &lt;em&gt;timeout&lt;/em&gt; if &lt;em&gt;waitflag&lt;/em&gt; is zero.</source>
          <target state="translated">부동 소수점 &lt;em&gt;시간 종료&lt;/em&gt; 인수가 존재하고 양수인 경우 리턴하기 전에 최대 대기 시간 (초)을 지정합니다. 음의 &lt;em&gt;시간 초과&lt;/em&gt; 인수는 무제한 대기를 지정합니다. &lt;em&gt;waitflag&lt;/em&gt; 가 0 이면 &lt;em&gt;시간 종료를&lt;/em&gt; 지정할 수 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71f137ca45f1f4315df5ce3a53742f74127f3689" translate="yes" xml:space="preserve">
          <source>If the function also supports &lt;em&gt;dir_fd&lt;/em&gt; or &lt;em&gt;follow_symlinks&lt;/em&gt; arguments, it&amp;rsquo;s an error to specify one of those when supplying &lt;em&gt;path&lt;/em&gt; as a file descriptor.</source>
          <target state="translated">함수가 &lt;em&gt;dir_fd&lt;/em&gt; 또는 &lt;em&gt;follow_symlinks&lt;/em&gt; 인수 도 지원 하는 경우 &lt;em&gt;경로&lt;/em&gt; 를 파일 디스크립터로 제공 할 때 이들 중 하나를 지정하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="9e255e0f89d3c1037cfd2af8f07b7a7b9b651a55" translate="yes" xml:space="preserve">
          <source>If the function fails, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">기능이 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5356d77e205569cd60b75101b731b99c07bcf65d" translate="yes" xml:space="preserve">
          <source>If the future has already completed or been cancelled, &lt;em&gt;fn&lt;/em&gt; will be called immediately.</source>
          <target state="translated">미래가 이미 완료되었거나 취소 된 경우 &lt;em&gt;fn&lt;/em&gt; 이 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7602bbb5410a8b437816b287f32e8aba7e81abc" translate="yes" xml:space="preserve">
          <source>If the future is cancelled before completing then &lt;a href=&quot;#concurrent.futures.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">완료하기 전에 미래가 취소되면 &lt;a href=&quot;#concurrent.futures.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22d45851562f9f10333edeb0961c986bb8146cb1" translate="yes" xml:space="preserve">
          <source>If the given &lt;em&gt;section&lt;/em&gt; exists, and contains the given &lt;em&gt;option&lt;/em&gt;, return &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;; otherwise return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. If the specified &lt;em&gt;section&lt;/em&gt; is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or an empty string, DEFAULT is assumed.</source>
          <target state="translated">주어진 &lt;em&gt;섹션&lt;/em&gt; 이 존재하고 주어진 &lt;em&gt;옵션이&lt;/em&gt; 포함되어 있으면 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 그렇지 않으면 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환 합니다. 지정된 &lt;em&gt;섹션&lt;/em&gt; 이 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이거나 빈 문자열이면 DEFAULT로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="1285768fc63d1e86280e3cad6887bc85265a423a" translate="yes" xml:space="preserve">
          <source>If the given encoding is not known, the function defaults to the default encoding for the locale code just like &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 인코딩이 알려지지 않은 경우, 함수는 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 과 같이 로케일 코드의 기본 인코딩으로 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e03a404aa9f2043079442bcf94d4ec5e79efc91" translate="yes" xml:space="preserve">
          <source>If the given section exists, set the given option to the specified value; otherwise raise &lt;a href=&quot;#configparser.NoSectionError&quot;&gt;&lt;code&gt;NoSectionError&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;option&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; must be strings; if not, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">주어진 섹션이 존재하면 주어진 옵션을 지정된 값으로 설정하십시오. 그렇지 않으면 &lt;a href=&quot;#configparser.NoSectionError&quot;&gt; &lt;code&gt;NoSectionError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . &lt;em&gt;옵션&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 은 문자열이어야합니다. 그렇지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1402525cf09cdaaddadb10846e26316cab80e378" translate="yes" xml:space="preserve">
          <source>If the given section exists, set the given option to the specified value; otherwise raise &lt;a href=&quot;#configparser.NoSectionError&quot;&gt;&lt;code&gt;NoSectionError&lt;/code&gt;&lt;/a&gt;. While it is possible to use &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt;&lt;code&gt;RawConfigParser&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; with &lt;em&gt;raw&lt;/em&gt; parameters set to true) for &lt;em&gt;internal&lt;/em&gt; storage of non-string values, full functionality (including interpolation and output to files) can only be achieved using string values.</source>
          <target state="translated">주어진 섹션이 존재하면 주어진 옵션을 지정된 값으로 설정하십시오. 그렇지 않으면 &lt;a href=&quot;#configparser.NoSectionError&quot;&gt; &lt;code&gt;NoSectionError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . 그것이 가능하지만 사용 &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt; &lt;code&gt;RawConfigParser&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; 를&lt;/a&gt; 가진 &lt;em&gt;원료&lt;/em&gt; 를 true로 설정된 파라미터) &lt;em&gt;의 내부&lt;/em&gt; 문자열이 아닌 값 (파일 출력 보간을 포함한) 전체 기능만을 저장 문자열 값을 사용하여 달성 될 수있다.</target>
        </trans-unit>
        <trans-unit id="25fbf997b0a78ead811d3ad55217a116fa50d909" translate="yes" xml:space="preserve">
          <source>If the handle is already closed, no error is raised.</source>
          <target state="translated">핸들이 이미 닫혀 있으면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="641b7d4d28be7e1599a1dccf300ba61a3ce1d4ca" translate="yes" xml:space="preserve">
          <source>If the header value can be recognized as a valid date of one form or another, this attribute will contain a &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance representing that date. If the timezone of the input date is specified as &lt;code&gt;-0000&lt;/code&gt; (indicating it is in UTC but contains no information about the source timezone), then &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; will be a naive &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;. If a specific timezone offset is found (including &lt;code&gt;+0000&lt;/code&gt;), then &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; will contain an aware &lt;code&gt;datetime&lt;/code&gt; that uses &lt;a href=&quot;datetime#datetime.timezone&quot;&gt;&lt;code&gt;datetime.timezone&lt;/code&gt;&lt;/a&gt; to record the timezone offset.</source>
          <target state="translated">헤더 값이 한 양식 또는 다른 양식의 유효한 날짜로 인식 될 수있는 경우이 속성에는 해당 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 를 나타내는 datetime 인스턴스 가 포함 됩니다. 입력 날짜의 시간대가 &lt;code&gt;-0000&lt;/code&gt; 으로 지정 되면 (UTC이지만 소스 시간대에 대한 정보가 없음을 나타냄) &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 은 순진한 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 입니다. 오프셋 특정 시간대가 (포함 발견되면 &lt;code&gt;+0000&lt;/code&gt; ), 다음 &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 의식적 포함 &lt;code&gt;datetime&lt;/code&gt; 용도는 것을 &lt;a href=&quot;datetime#datetime.timezone&quot;&gt; &lt;code&gt;datetime.timezone&lt;/code&gt; &lt;/a&gt; 오프셋 시간대를 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a777ed5d38b562baf8f3d74ea5382e00d35e44" translate="yes" xml:space="preserve">
          <source>If the higher-level protocol supports its own compression mechanism, you can use &lt;a href=&quot;#ssl.OP_NO_COMPRESSION&quot;&gt;&lt;code&gt;OP_NO_COMPRESSION&lt;/code&gt;&lt;/a&gt; to disable SSL-level compression.</source>
          <target state="translated">상위 레벨 프로토콜이 자체 압축 메커니즘을 지원하는 경우 &lt;a href=&quot;#ssl.OP_NO_COMPRESSION&quot;&gt; &lt;code&gt;OP_NO_COMPRESSION&lt;/code&gt; &lt;/a&gt; 을 사용하여 SSL 레벨 압축을 사용 안함 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52c8f2ad85aead8b4995e491e22aafadac0261c9" translate="yes" xml:space="preserve">
          <source>If the index or keyword refers to an item that does not exist, then an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; should be raised.</source>
          <target state="translated">인덱스 또는 키워드가 존재하지 않는 항목을 참조하면 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="c788569ddd7977c4b0bf996b77dcb6e2c7a3c442" translate="yes" xml:space="preserve">
          <source>If the initial response check returns &lt;code&gt;None&lt;/code&gt;, or if &lt;em&gt;initial_response_ok&lt;/em&gt; is false, &lt;code&gt;authobject()&lt;/code&gt; will be called to process the server&amp;rsquo;s challenge response; the &lt;em&gt;challenge&lt;/em&gt; argument it is passed will be a &lt;code&gt;bytes&lt;/code&gt;. It should return ASCII &lt;code&gt;str&lt;/code&gt;&lt;em&gt;data&lt;/em&gt; that will be base64 encoded and sent to the server.</source>
          <target state="translated">초기 응답 확인이 &lt;code&gt;None&lt;/code&gt; 을 반환 하거나 &lt;em&gt;initial_response_ok&lt;/em&gt; 가 false 인 경우 서버의 인증 확인 응답을 처리하기 위해 &lt;code&gt;authobject()&lt;/code&gt; 가 호출됩니다. &lt;em&gt;도전&lt;/em&gt; 이 전달되는 인수가 될 것입니다 &lt;code&gt;bytes&lt;/code&gt; . base64로 인코딩되어 서버로 전송 될 ASCII &lt;code&gt;str&lt;/code&gt; &lt;em&gt;데이터&lt;/em&gt; 를 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dab9d8717f742399cb738b981063ba490b7eb6fd" translate="yes" xml:space="preserve">
          <source>If the input path is not a list (as is the case for frozen packages) it is returned unchanged. The input path is not modified; an extended copy is returned. Items are only appended to the copy at the end.</source>
          <target state="translated">입력 경로가 목록이 아닌 경우 (냉동 패키지의 경우와 같이) 변경되지 않은 상태로 반환됩니다. 입력 경로는 수정되지 않습니다. 확장 사본이 리턴됩니다. 항목은 마지막에 사본에만 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b943d29ac87cd73e259d10ec9f1b9fd2ca008d7c" translate="yes" xml:space="preserve">
          <source>If the insertion would cause a bounded deque to grow beyond &lt;em&gt;maxlen&lt;/em&gt;, an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">삽입이 제한된 양단 큐를 넘어 성장하는 원인이 경우 &lt;em&gt;MAXLEN&lt;/em&gt; , &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed6b40b45f9572155a78f6d589785061f5e1cae3" translate="yes" xml:space="preserve">
          <source>If the instance &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; is shadowed by another member (for example a property) then this function will be unable to find instance members.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 인스턴스 가 다른 멤버 (예 : 속성)에 의해 음영 처리 되면 이 함수는 인스턴스 멤버를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb4531fcea1f06a7582067573022ca8343fb967f" translate="yes" xml:space="preserve">
          <source>If the integer &lt;em&gt;waitflag&lt;/em&gt; argument is present, the action depends on its value: if it is zero, the lock is only acquired if it can be acquired immediately without waiting, while if it is nonzero, the lock is acquired unconditionally as above.</source>
          <target state="translated">정수 &lt;em&gt;waitflag&lt;/em&gt; 인수가 존재하는 경우 조치는 해당 값에 따라 다릅니다. 값이 0 인 경우 대기하지 않고 즉시 획득 할 수있는 경우에만 잠금이 획득되지만 0이 아닌 경우 잠금은 위와 같이 무조건적으로 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="205ca1ee8e670ddfe86eb319c90becb94497b60e" translate="yes" xml:space="preserve">
          <source>If the internal counter is greater than zero, decrement it by one and return &lt;code&gt;True&lt;/code&gt; immediately. If it is zero, wait until a &lt;a href=&quot;#asyncio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; is called and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">내부 카운터가 0보다 크면 1 씩 감소시키고 즉시 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다. 값이 0이면 &lt;a href=&quot;#asyncio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때까지 기다렸다가 &lt;code&gt;True&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="9198aebf4f31811d32099cd373d77078c5c73698" translate="yes" xml:space="preserve">
          <source>If the internal counter is larger than zero on entry, decrement it by one and return &lt;code&gt;True&lt;/code&gt; immediately.</source>
          <target state="translated">입력시 내부 카운터가 0보다 크면 1 씩 감소시키고 즉시 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="21e399ee49393f3430f9b48c05c804f297ac4618" translate="yes" xml:space="preserve">
          <source>If the internal counter is zero on entry, block until awoken by a call to &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;. Once awoken (and the counter is greater than 0), decrement the counter by 1 and return &lt;code&gt;True&lt;/code&gt;. Exactly one thread will be awoken by each call to &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;. The order in which threads are awoken should not be relied on.</source>
          <target state="translated">시작시 내부 카운터가 0이면 &lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출로 깨울 때까지 차단하십시오 . 일단 깨어 나면 (그리고 카운터가 0보다 큰 경우), 카운터를 1 씩 줄이고 &lt;code&gt;True&lt;/code&gt; 를 반환하십시오 . &lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 할 때마다 정확히 하나의 스레드가 해제 됩니다. 스레드가 깨어 난 순서는 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae60cc570833d155b59d2cc8b8afcbadf08444b" translate="yes" xml:space="preserve">
          <source>If the internal limits of the C version are exceeded, constructing a decimal raises &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">C 버전의 내부 한계를 초과하면 10 진수를 구성하면 &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ffeab8a7c96e27484e303216d68be0fc6343fa6" translate="yes" xml:space="preserve">
          <source>If the interpreter would have been started with &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the sample would have printed &lt;code&gt;c_long(1)&lt;/code&gt;, or &lt;code&gt;c_long(2)&lt;/code&gt; if &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-oo&quot;&gt;&lt;code&gt;-OO&lt;/code&gt;&lt;/a&gt; would have been specified.</source>
          <target state="translated">인터프리터가 시작되었을 것입니다 경우 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; , 샘플 인쇄 한 것 &lt;code&gt;c_long(1)&lt;/code&gt; , 또는 &lt;code&gt;c_long(2)&lt;/code&gt; 경우 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-oo&quot;&gt; &lt;code&gt;-OO&lt;/code&gt; 가&lt;/a&gt; 지정되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ef843c9a43f59994d3da2c5e8418b405453ca10" translate="yes" xml:space="preserve">
          <source>If the key already exists, this function opens the existing key.</source>
          <target state="translated">키가 이미 존재하면이 기능은 기존 키를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="509b60b16f13bbedfe1f6d9e50bffcd673298294" translate="yes" xml:space="preserve">
          <source>If the key is not on the reflection list, the function succeeds but has no effect. Disabling reflection for a key does not affect reflection of any subkeys.</source>
          <target state="translated">키가 리플렉션 목록에 없으면 기능은 성공하지만 아무런 효과가 없습니다. 키에 대한 반사를 비활성화해도 하위 키의 반사에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="930e9f6ed338a6954d9cbd0e2a7335e5749df5c2" translate="yes" xml:space="preserve">
          <source>If the key specified by the &lt;em&gt;sub_key&lt;/em&gt; parameter does not exist, the SetValue function creates it.</source>
          <target state="translated">&lt;em&gt;sub_key&lt;/em&gt; 매개 변수로 지정된 키 가 없으면 SetValue 함수가이를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7f0fd305b3a1c159e43727b6d7cbb51944be9b83" translate="yes" xml:space="preserve">
          <source>If the listener object uses a socket then &lt;em&gt;backlog&lt;/em&gt; (1 by default) is passed to the &lt;a href=&quot;socket#socket.socket.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; method of the socket once it has been bound.</source>
          <target state="translated">리스너 객체가 소켓을 사용하는 경우 &lt;em&gt;백 로그&lt;/em&gt; (기본적으로 1)는 바인드 된 소켓 의 &lt;a href=&quot;socket#socket.socket.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fcbb3ff56b47c3934c001b5fdf01a88c7f7abf9" translate="yes" xml:space="preserve">
          <source>If the lock is &lt;em&gt;unlocked&lt;/em&gt;, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">잠금이 &lt;em&gt;잠금 해제&lt;/em&gt; 되면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0cd48a8f0e050bbf8d1af3c021ed42cd478aed78" translate="yes" xml:space="preserve">
          <source>If the locking flags &lt;a href=&quot;os#os.O_SHLOCK&quot;&gt;&lt;code&gt;O_SHLOCK&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os#os.O_EXLOCK&quot;&gt;&lt;code&gt;O_EXLOCK&lt;/code&gt;&lt;/a&gt; are present in the &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module (on BSD only), the &lt;a href=&quot;os#os.open&quot;&gt;&lt;code&gt;os.open()&lt;/code&gt;&lt;/a&gt; function provides an alternative to the &lt;a href=&quot;#fcntl.lockf&quot;&gt;&lt;code&gt;lockf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#fcntl.flock&quot;&gt;&lt;code&gt;flock()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">잠금 플래그 &lt;a href=&quot;os#os.O_SHLOCK&quot;&gt; &lt;code&gt;O_SHLOCK&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;os#os.O_EXLOCK&quot;&gt; &lt;code&gt;O_EXLOCK&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈에있는 경우 (BSD에만 해당) &lt;a href=&quot;os#os.open&quot;&gt; &lt;code&gt;os.open()&lt;/code&gt; &lt;/a&gt; 함수는 &lt;a href=&quot;#fcntl.lockf&quot;&gt; &lt;code&gt;lockf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#fcntl.flock&quot;&gt; &lt;code&gt;flock()&lt;/code&gt; &lt;/a&gt; 함수에 대한 대안을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="266c606d27bf00d6844ea3d600920e9ed72976cd" translate="yes" xml:space="preserve">
          <source>If the message id for &lt;em&gt;context&lt;/em&gt; is not found in the catalog, and a fallback is specified, the request is forwarded to the fallback&amp;rsquo;s &lt;a href=&quot;#gettext.npgettext&quot;&gt;&lt;code&gt;npgettext()&lt;/code&gt;&lt;/a&gt; method. Otherwise, when &lt;em&gt;n&lt;/em&gt; is 1 &lt;em&gt;singular&lt;/em&gt; is returned, and &lt;em&gt;plural&lt;/em&gt; is returned in all other cases.</source>
          <target state="translated">&lt;em&gt;컨텍스트에&lt;/em&gt; 대한 메시지 ID 가 카탈로그에없고 &lt;a href=&quot;#gettext.npgettext&quot;&gt; &lt;code&gt;npgettext()&lt;/code&gt; &lt;/a&gt; 백이 지정된 경우 요청은 폴 백의 npgettext () 메소드로 전달됩니다 . 그렇지 않으면 &lt;em&gt;n&lt;/em&gt; 이 1 일 때 &lt;em&gt;단수&lt;/em&gt; 를 반환 하고 다른 모든 경우에는 &lt;em&gt;복수&lt;/em&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83b4d9a88e07f7820cdb0b2639ae3a66c2f8ddbd" translate="yes" xml:space="preserve">
          <source>If the message id is not found in the catalog, and a fallback is specified, the request is forwarded to the fallback&amp;rsquo;s &lt;a href=&quot;#gettext.NullTranslations.ngettext&quot;&gt;&lt;code&gt;ngettext()&lt;/code&gt;&lt;/a&gt; method. Otherwise, when &lt;em&gt;n&lt;/em&gt; is 1 &lt;em&gt;singular&lt;/em&gt; is returned, and &lt;em&gt;plural&lt;/em&gt; is returned in all other cases.</source>
          <target state="translated">카탈로그에서 메시지 ID를 찾을 수없고 &lt;a href=&quot;#gettext.NullTranslations.ngettext&quot;&gt; &lt;code&gt;ngettext()&lt;/code&gt; &lt;/a&gt; 백이 지정된 경우 요청은 폴 백의 ngettext () 메소드로 전달됩니다 . 그렇지 않으면 &lt;em&gt;n&lt;/em&gt; 이 1 일 때 &lt;em&gt;단수&lt;/em&gt; 를 반환 하고 다른 모든 경우에는 &lt;em&gt;복수&lt;/em&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84aa620a75940f54a9d2650b7be09bf90a61d67a" translate="yes" xml:space="preserve">
          <source>If the message is a &lt;code&gt;multipart/alternative&lt;/code&gt;, create a new message object, pass all of the arguments to its &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method, and &lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt;&lt;code&gt;attach()&lt;/code&gt;&lt;/a&gt; it to the &lt;code&gt;multipart&lt;/code&gt;. If the message is a non-&lt;code&gt;multipart&lt;/code&gt; or &lt;code&gt;multipart/related&lt;/code&gt;, call &lt;a href=&quot;#email.message.EmailMessage.make_alternative&quot;&gt;&lt;code&gt;make_alternative()&lt;/code&gt;&lt;/a&gt; and then proceed as above. If the message is any other type of &lt;code&gt;multipart&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;content_manager&lt;/em&gt; is not specified, use the &lt;code&gt;content_manager&lt;/code&gt; specified by the current &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메시지가 &lt;code&gt;multipart/alternative&lt;/code&gt; 인 경우 새 메시지 객체를 작성하고 모든 인수를 &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 메소드에 전달한 후 &lt;code&gt;multipart&lt;/code&gt; 에&lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt; &lt;code&gt;attach()&lt;/code&gt; &lt;/a&gt; . 메시지가 &lt;code&gt;multipart&lt;/code&gt; 또는 &lt;code&gt;multipart/related&lt;/code&gt; 인 경우 &lt;a href=&quot;#email.message.EmailMessage.make_alternative&quot;&gt; &lt;code&gt;make_alternative()&lt;/code&gt; &lt;/a&gt; 호출 한 다음 위와 같이 진행하십시오. 메시지가 다른 유형의 &lt;code&gt;multipart&lt;/code&gt; 인 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 경우 &lt;em&gt;CONTENT_MANAGER가&lt;/em&gt; 지정되지 않은, 사용 &lt;code&gt;content_manager&lt;/code&gt; 전류에 의해 지정된 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b6c62590a9b06138d696cdbccce215f1bf1d175" translate="yes" xml:space="preserve">
          <source>If the message is a &lt;code&gt;multipart/mixed&lt;/code&gt;, create a new message object, pass all of the arguments to its &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method, and &lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt;&lt;code&gt;attach()&lt;/code&gt;&lt;/a&gt; it to the &lt;code&gt;multipart&lt;/code&gt;. If the message is a non-&lt;code&gt;multipart&lt;/code&gt;, &lt;code&gt;multipart/related&lt;/code&gt;, or &lt;code&gt;multipart/alternative&lt;/code&gt;, call &lt;a href=&quot;#email.message.EmailMessage.make_mixed&quot;&gt;&lt;code&gt;make_mixed()&lt;/code&gt;&lt;/a&gt; and then proceed as above. If &lt;em&gt;content_manager&lt;/em&gt; is not specified, use the &lt;code&gt;content_manager&lt;/code&gt; specified by the current &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;. If the added part has no &lt;em&gt;Content-Disposition&lt;/em&gt; header, add one with the value &lt;code&gt;attachment&lt;/code&gt;. This method can be used both for explicit attachments (&lt;em&gt;Content-Disposition: attachment&lt;/em&gt;) and &lt;code&gt;inline&lt;/code&gt; attachments (&lt;em&gt;Content-Disposition: inline&lt;/em&gt;), by passing appropriate options to the &lt;code&gt;content_manager&lt;/code&gt;.</source>
          <target state="translated">메시지가 &lt;code&gt;multipart/mixed&lt;/code&gt; 인 경우 새 메시지 객체를 작성하고 모든 인수를 &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 메소드에 전달한 후 &lt;code&gt;multipart&lt;/code&gt; 에&lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt; &lt;code&gt;attach()&lt;/code&gt; &lt;/a&gt; . 메시지가 &lt;code&gt;multipart&lt;/code&gt; , &lt;code&gt;multipart/related&lt;/code&gt; 또는 &lt;code&gt;multipart/alternative&lt;/code&gt; 가 아닌 경우 &lt;a href=&quot;#email.message.EmailMessage.make_mixed&quot;&gt; &lt;code&gt;make_mixed()&lt;/code&gt; &lt;/a&gt; 호출 한 다음 위와 같이 진행하십시오. 경우 &lt;em&gt;CONTENT_MANAGER가&lt;/em&gt; 지정되지 않은, 사용 &lt;code&gt;content_manager&lt;/code&gt; 전류에 의해 지정된 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; . 추가 된 부품에 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 가 없으면 값이 &lt;code&gt;attachment&lt;/code&gt; 된 부품을 추가 하십시오.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;. 이 메소드는 적절한 옵션을 &lt;code&gt;content_manager&lt;/code&gt; 에 전달 하여 명시 적 첨부 파일 ( &lt;em&gt;Content-Disposition : attachment&lt;/em&gt; ) 및 &lt;code&gt;inline&lt;/code&gt; 첨부 파일 ( &lt;em&gt;Content-Disposition : inline&lt;/em&gt; ) 모두에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="242ebb9aa3a221a1cc2e7cc02579fdb6a91649b7" translate="yes" xml:space="preserve">
          <source>If the message is a &lt;code&gt;multipart/related&lt;/code&gt;, create a new message object, pass all of the arguments to its &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method, and &lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt;&lt;code&gt;attach()&lt;/code&gt;&lt;/a&gt; it to the &lt;code&gt;multipart&lt;/code&gt;. If the message is a non-&lt;code&gt;multipart&lt;/code&gt;, call &lt;a href=&quot;#email.message.EmailMessage.make_related&quot;&gt;&lt;code&gt;make_related()&lt;/code&gt;&lt;/a&gt; and then proceed as above. If the message is any other type of &lt;code&gt;multipart&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;content_manager&lt;/em&gt; is not specified, use the &lt;code&gt;content_manager&lt;/code&gt; specified by the current &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;. If the added part has no &lt;em&gt;Content-Disposition&lt;/em&gt; header, add one with the value &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">메시지가 &lt;code&gt;multipart/related&lt;/code&gt; 인 경우 새 메시지 객체를 만들고 모든 인수를 &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 메서드에 전달한 다음 &lt;code&gt;multipart&lt;/code&gt; 에&lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt; &lt;code&gt;attach()&lt;/code&gt; &lt;/a&gt; . 메시지가 &lt;code&gt;multipart&lt;/code&gt; 가 아닌 경우 &lt;a href=&quot;#email.message.EmailMessage.make_related&quot;&gt; &lt;code&gt;make_related()&lt;/code&gt; &lt;/a&gt; 호출 한 다음 위와 같이 진행하십시오. 메시지가 다른 유형의 &lt;code&gt;multipart&lt;/code&gt; 인 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 경우 &lt;em&gt;CONTENT_MANAGER가&lt;/em&gt; 지정되지 않은, 사용 &lt;code&gt;content_manager&lt;/code&gt; 전류에 의해 지정된 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; . 추가 된 부품에 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 가없는 경우 값이 &lt;code&gt;inline&lt;/code&gt; 인 부품을 추가하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c9d1deafb768d7777ddc466b02dc8f72673a7cf" translate="yes" xml:space="preserve">
          <source>If the message object contains binary data that is not encoded according to RFC standards, the non-compliant data will be replaced by unicode &amp;ldquo;unknown character&amp;rdquo; code points. (See also &lt;a href=&quot;#email.message.Message.as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">메시지 객체에 RFC 표준에 따라 인코딩되지 않은 이진 데이터가 포함 된 경우 비 호환 데이터는 유니 코드 &quot;알 수없는 문자&quot;코드 포인트로 대체됩니다. ( &lt;a href=&quot;#email.message.Message.as_bytes&quot;&gt; &lt;code&gt;as_bytes()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1d471d00aa6a8fd988a0ba607f8c74c947b07502" translate="yes" xml:space="preserve">
          <source>If the method returns &lt;code&gt;False&lt;/code&gt; then the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; was cancelled, i.e. &lt;a href=&quot;#concurrent.futures.Future.cancel&quot;&gt;&lt;code&gt;Future.cancel()&lt;/code&gt;&lt;/a&gt; was called and returned &lt;code&gt;True&lt;/code&gt;. Any threads waiting on the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completing (i.e. through &lt;a href=&quot;#concurrent.futures.as_completed&quot;&gt;&lt;code&gt;as_completed()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#concurrent.futures.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;) will be woken up.</source>
          <target state="translated">메소드가 &lt;code&gt;False&lt;/code&gt; 를 리턴 하면 &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 가 취소됩니다. 즉 &lt;a href=&quot;#concurrent.futures.Future.cancel&quot;&gt; &lt;code&gt;Future.cancel()&lt;/code&gt; &lt;/a&gt; 이 호출되어 &lt;code&gt;True&lt;/code&gt; 를 리턴했습니다 . &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 완료 대기중인 스레드 (예 : &lt;a href=&quot;#concurrent.futures.as_completed&quot;&gt; &lt;code&gt;as_completed()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#concurrent.futures.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; )는 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="3cec9785f35a66b9250f6994cb4b5ad2f020d3b4" translate="yes" xml:space="preserve">
          <source>If the method returns &lt;code&gt;True&lt;/code&gt; then the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; was not cancelled and has been put in the running state, i.e. calls to &lt;a href=&quot;#concurrent.futures.Future.running&quot;&gt;&lt;code&gt;Future.running()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">메소드가 &lt;code&gt;True&lt;/code&gt; 를 반환 하면 &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 는 취소되지 않고 실행 상태가됩니다. 즉 &lt;a href=&quot;#concurrent.futures.Future.running&quot;&gt; &lt;code&gt;Future.running()&lt;/code&gt; &lt;/a&gt; 호출 은 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fbff94a7b3ccf99de926f202b3c2b1024530b6b5" translate="yes" xml:space="preserve">
          <source>If the method succeeds, the entire key, including all of its values, is removed. If the method fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">메소드가 성공하면 모든 값을 포함하여 전체 키가 제거됩니다. 메소드가 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0c7e815087343f8292c99aab7ab0f093f5891323" translate="yes" xml:space="preserve">
          <source>If the method succeeds, the server&amp;rsquo;s response is returned. If the server refuses posting, a &lt;a href=&quot;#nntplib.NNTPReplyError&quot;&gt;&lt;code&gt;NNTPReplyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">메소드가 성공하면 서버의 응답이 리턴됩니다. 서버가 게시를 거부하면 &lt;a href=&quot;#nntplib.NNTPReplyError&quot;&gt; &lt;code&gt;NNTPReplyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7153563f652430df4d79eea119afe5c6dc69a83e" translate="yes" xml:space="preserve">
          <source>If the mock has an explicit &lt;em&gt;return_value&lt;/em&gt; set then calls are not passed to the wrapped object and the &lt;em&gt;return_value&lt;/em&gt; is returned instead.</source>
          <target state="translated">모형에 명시적인 &lt;em&gt;return_value가&lt;/em&gt; 설정 되어 있으면 래핑 된 객체에 호출이 전달되지 않고 대신 &lt;em&gt;return_value&lt;/em&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="45919ac1b7a80b5e3b67f287a2f90644613d8e96" translate="yes" xml:space="preserve">
          <source>If the module or package is accessible via the normal import mechanism, a wrapper around the relevant part of that machinery is returned. Returns &lt;code&gt;None&lt;/code&gt; if the module cannot be found or imported. If the named module is not already imported, its containing package (if any) is imported, in order to establish the package &lt;code&gt;__path__&lt;/code&gt;.</source>
          <target state="translated">일반 가져 오기 메커니즘을 통해 모듈 또는 패키지에 액세스 할 수있는 경우 해당 기계의 관련 부분에 대한 랩퍼가 리턴됩니다. 모듈을 찾거나 가져올 수 없으면 &lt;code&gt;None&lt;/code&gt; 반환 합니다. 명명 된 모듈을 아직 가져 오지 않은 경우 &lt;code&gt;__path__&lt;/code&gt; 패키지를 설정하기 위해 포함 된 패키지 (있는 경우)를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="51e5842707c11d94e17db137bb67b47236a037bf" translate="yes" xml:space="preserve">
          <source>If the name is used as the target of a function or class statement, this will be true.</source>
          <target state="translated">이름이 함수 또는 클래스 문의 대상으로 사용되는 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0362f1195e807cb7d35fcee8c326c2a06bfad6" translate="yes" xml:space="preserve">
          <source>If the named module is in a package, that package is imported as a side effect of invoking this function.</source>
          <target state="translated">명명 된 모듈이 패키지에있는 경우이 기능을 호출하면 부작용으로 해당 패키지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9189c0d6152e209a08169bddf71ad00af16f14e9" translate="yes" xml:space="preserve">
          <source>If the new limit is too low at the current recursion depth, a &lt;a href=&quot;exceptions#RecursionError&quot;&gt;&lt;code&gt;RecursionError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">현재 재귀 수준에서 새 제한이 너무 낮 으면 &lt;a href=&quot;exceptions#RecursionError&quot;&gt; &lt;code&gt;RecursionError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8460feb89a7b7829874aae5225965d9b87e2ad34" translate="yes" xml:space="preserve">
          <source>If the normalized value of days lies outside the indicated range, &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">정규화 된 일 수 값이 표시된 범위를 벗어나면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="588410c54abe56967f1464e64a03d18c20cd3967" translate="yes" xml:space="preserve">
          <source>If the object does not provide &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt;&lt;code&gt;__dir__()&lt;/code&gt;&lt;/a&gt;, the function tries its best to gather information from the object&amp;rsquo;s &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute, if defined, and from its type object. The resulting list is not necessarily complete, and may be inaccurate when the object has a custom &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt; &lt;code&gt;__dir__()&lt;/code&gt; &lt;/a&gt; 제공하지 않으면 함수는 객체의 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 속성 (정의 된 경우) 및 유형 객체에서 정보를 수집하기 위해 최선을 다합니다 . 결과 목록이 반드시 완전하지는 않으며 객체에 사용자 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 이있는 경우 정확하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00cb3870e9b06174890128e7e72fbdcdb2084f55" translate="yes" xml:space="preserve">
          <source>If the object has a method named &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt;&lt;code&gt;__dir__()&lt;/code&gt;&lt;/a&gt;, this method will be called and must return the list of attributes. This allows objects that implement a custom &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; function to customize the way &lt;a href=&quot;#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; reports their attributes.</source>
          <target state="translated">객체에 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt; &lt;code&gt;__dir__()&lt;/code&gt; &lt;/a&gt; 이라는 메소드가있는 경우이 메소드가 호출되며 속성 목록을 리턴해야합니다. 이를 통해 사용자 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 함수를 구현하는 객체는 &lt;a href=&quot;#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 이 속성을보고 하는 방식을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6efa5f83d57e360fb04084d7429ce45f6b697027" translate="yes" xml:space="preserve">
          <source>If the object is a module object, the list contains the names of the module&amp;rsquo;s attributes.</source>
          <target state="translated">객체가 모듈 객체 인 경우 목록에 모듈 속성의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7573a086962ae326425c85210e2af2f83614b6a3" translate="yes" xml:space="preserve">
          <source>If the object is a type or class object, the list contains the names of its attributes, and recursively of the attributes of its bases.</source>
          <target state="translated">객체가 유형 또는 클래스 객체 인 경우 목록에는 해당 속성의 이름과 기본 속성의 재귀 적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2997ac7e88144e3d7c1c1886f52b5f3da5581222" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;infile&lt;/code&gt; and &lt;code&gt;outfile&lt;/code&gt; arguments are not specified, &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; will be used respectively:</source>
          <target state="translated">선택적 &lt;code&gt;infile&lt;/code&gt; 및 &lt;code&gt;outfile&lt;/code&gt; 인수가 지정되지 않은 경우 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 이 각각 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="549e746dc68c5d98d85de52964752ff8fe6a8117" translate="yes" xml:space="preserve">
          <source>If the optional &lt;em&gt;allow_dotted_names&lt;/em&gt; argument is true and the instance does not have a &lt;code&gt;_dispatch()&lt;/code&gt; method, then if the requested method name contains periods, each component of the method name is searched for individually, with the effect that a simple hierarchical search is performed. The value found from this search is then called with the parameters from the request, and the return value is passed back to the client.</source>
          <target state="translated">선택적인 &lt;em&gt;allow_dotted_names&lt;/em&gt; 인수가 true이고 인스턴스에 &lt;code&gt;_dispatch()&lt;/code&gt; 메소드 가없는 경우 요청 된 메소드 이름에 마침표가 포함되어 있으면 간단한 계층 구조 검색이 수행되는 방식으로 요청 된 메소드 이름에 개별 컴포넌트가 검색됩니다. 그런 다음이 검색에서 찾은 값이 요청의 매개 변수와 함께 호출되고 리턴 값이 클라이언트로 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7bf594fe9f1e866693d0d56f18167c8228362f08" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;em&gt;exclude_empty&lt;/em&gt; is false, then &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt;&lt;code&gt;DocTestFinder.find()&lt;/code&gt;&lt;/a&gt; will include tests for objects with empty docstrings.</source>
          <target state="translated">선택적 인수 &lt;em&gt;exclude_empty&lt;/em&gt; 가 false 인 경우 &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt; &lt;code&gt;DocTestFinder.find()&lt;/code&gt; &lt;/a&gt; 는 빈 docstring이있는 객체에 대한 테스트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4dda0a6681904db033d6436f3b4c07ed02a5cd5c" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;em&gt;recurse&lt;/em&gt; is false, then &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt;&lt;code&gt;DocTestFinder.find()&lt;/code&gt;&lt;/a&gt; will only examine the given object, and not any contained objects.</source>
          <target state="translated">선택적 인수 &lt;em&gt;재귀&lt;/em&gt; 가 false 인 경우 &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt; &lt;code&gt;DocTestFinder.find()&lt;/code&gt; &lt;/a&gt; 는 포함 된 개체가 아닌 지정된 개체 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="87f9d738288c72fc56cefc596ae3035e04fd6c01" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), the method blocks until the process whose &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method is called terminates. If &lt;em&gt;timeout&lt;/em&gt; is a positive number, it blocks at most &lt;em&gt;timeout&lt;/em&gt; seconds. Note that the method returns &lt;code&gt;None&lt;/code&gt; if its process terminates or if the method times out. Check the process&amp;rsquo;s &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt;&lt;code&gt;exitcode&lt;/code&gt;&lt;/a&gt; to determine if it terminated.</source>
          <target state="translated">선택적 인수 &lt;em&gt;timeout&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 메서드가 호출 된 프로세스가 종료 될 때까지 메서드가 차단 됩니다. 경우 &lt;em&gt;제한 시간은&lt;/em&gt; 최대 양수, 차단입니다 &lt;em&gt;시간 제한&lt;/em&gt; 초. 프로세스가 종료되거나 메소드가 시간 종료되면 메소드는 &lt;code&gt;None&lt;/code&gt; 리턴 합니다. 프로세스 종료 &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt; &lt;code&gt;exitcode&lt;/code&gt; &lt;/a&gt; 를 확인하여 프로세스가 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="907e323a441ade6004f0f9b1d15889b1a6cbc0b5" translate="yes" xml:space="preserve">
          <source>If the optional parameter &lt;em&gt;max_length&lt;/em&gt; is non-zero then the return value will be no longer than &lt;em&gt;max_length&lt;/em&gt;. This may mean that not all of the compressed input can be processed; and unconsumed data will be stored in the attribute &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt;&lt;code&gt;unconsumed_tail&lt;/code&gt;&lt;/a&gt;. This bytestring must be passed to a subsequent call to &lt;a href=&quot;#zlib.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; if decompression is to continue. If &lt;em&gt;max_length&lt;/em&gt; is zero then the whole input is decompressed, and &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt;&lt;code&gt;unconsumed_tail&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">선택적 매개 변수 &lt;em&gt;max_length&lt;/em&gt; 가 0이 아니면 리턴 값은 &lt;em&gt;max_length&lt;/em&gt; 보다 길지 않습니다 . 이는 모든 압축 입력을 처리 할 수있는 것은 아닙니다. 및 사용되지 않은 데이터는 속성에 저장 될 &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt; &lt;code&gt;unconsumed_tail&lt;/code&gt; &lt;/a&gt; . 압축 해제를 계속 하려면이 바이트 문자열을 후속 &lt;a href=&quot;#zlib.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 호출로 전달해야합니다 . 경우 &lt;em&gt;MAX_LENGTH은&lt;/em&gt; 다음 제로 전체 입력이 압축 해제되어 &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt; &lt;code&gt;unconsumed_tail&lt;/code&gt; 는&lt;/a&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1a61b6065550962e0f197aa4aa509c70c359be" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;em&gt;mu&lt;/em&gt; is given, it is typically the mean of the &lt;em&gt;data&lt;/em&gt;. It can also be used to compute the second moment around a point that is not the mean. If it is missing or &lt;code&gt;None&lt;/code&gt; (the default), the arithmetic mean is automatically calculated.</source>
          <target state="translated">선택적 두 번째 인수 &lt;em&gt;mu&lt;/em&gt; 가 제공되면 일반적으로 &lt;em&gt;데이터&lt;/em&gt; 의 평균입니다 . 또한 평균이 아닌 지점을 기준으로 두 번째 모멘트를 계산하는 데 사용할 수도 있습니다. 누락되거나 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우 산술 평균이 자동으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e99c895d04ea8fb9d48b5ad452d4282ff6838cfb" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;em&gt;xbar&lt;/em&gt; is given, it should be the mean of &lt;em&gt;data&lt;/em&gt;. If it is missing or &lt;code&gt;None&lt;/code&gt; (the default), the mean is automatically calculated.</source>
          <target state="translated">선택적 두 번째 인수 &lt;em&gt;xbar&lt;/em&gt; 가 제공되면 &lt;em&gt;data&lt;/em&gt; 의 평균이어야합니다 . 누락되거나 &lt;code&gt;None&lt;/code&gt; (기본값)이면 평균이 자동으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="519de9aef0c2fe8269af8bb45ede63861ec8669a" translate="yes" xml:space="preserve">
          <source>If the package cannot be located or loaded, or it uses a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; which does not support &lt;a href=&quot;importlib#importlib.abc.ResourceLoader.get_data&quot;&gt;&lt;code&gt;get_data&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;None&lt;/code&gt; is returned. In particular, the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; for &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-namespace-package&quot;&gt;namespace packages&lt;/a&gt; does not support &lt;a href=&quot;importlib#importlib.abc.ResourceLoader.get_data&quot;&gt;&lt;code&gt;get_data&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지를 찾거나로드 할 수 없거나 &lt;a href=&quot;importlib#importlib.abc.ResourceLoader.get_data&quot;&gt; &lt;code&gt;get_data&lt;/code&gt; 를&lt;/a&gt; 지원하지 않는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 를 사용하는 경우 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 특히 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-namespace-package&quot;&gt;네임 스페이스 패키지&lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 는 &lt;a href=&quot;importlib#importlib.abc.ResourceLoader.get_data&quot;&gt; &lt;code&gt;get_data&lt;/code&gt; 를&lt;/a&gt; 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2bf31cbb63bcd5170fdee78792fd311e362a5c3e" translate="yes" xml:space="preserve">
          <source>If the path contains a UNC path, drive will contain the host name and share, up to but not including the fourth separator. e.g. &lt;code&gt;splitdrive(&quot;//host/computer/dir&quot;)&lt;/code&gt; returns &lt;code&gt;(&quot;//host/computer&quot;, &quot;/dir&quot;)&lt;/code&gt;</source>
          <target state="translated">경로에 UNC 경로가 포함 된 경우 드라이브는 호스트 이름과 공유를 포함하며 최대 네 번째 구분 기호는 포함하지 않습니다. 예 : &lt;code&gt;splitdrive(&quot;//host/computer/dir&quot;)&lt;/code&gt; 는 &lt;code&gt;(&quot;//host/computer&quot;, &quot;/dir&quot;)&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7031f23f71038fb209bf8f54ab8a04e1845013c6" translate="yes" xml:space="preserve">
          <source>If the path contains a drive letter, drive will contain everything up to and including the colon. e.g. &lt;code&gt;splitdrive(&quot;c:/dir&quot;)&lt;/code&gt; returns &lt;code&gt;(&quot;c:&quot;, &quot;/dir&quot;)&lt;/code&gt;</source>
          <target state="translated">경로에 드라이브 문자가 포함 된 경우 드라이브는 콜론까지의 모든 것을 포함합니다. 예 : &lt;code&gt;splitdrive(&quot;c:/dir&quot;)&lt;/code&gt; 은 &lt;code&gt;(&quot;c:&quot;, &quot;/dir&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af52da286f518b1289952aa6209b0505b4fe92ec" translate="yes" xml:space="preserve">
          <source>If the path doesn&amp;rsquo;t exist and &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt; is raised. If &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the path is resolved as far as possible and any remainder is appended without checking whether it exists. If an infinite loop is encountered along the resolution path, &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경로가 존재하지 않고 &lt;em&gt;strict&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 이면 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 경우 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 경로는 가능한 한 해결하고 나머지가 존재하는지 여부를 확인하지 않고 추가됩니다. 해결 경로를 따라 무한 루프가 발생하면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40dbde78914080d45949f61923851c99159b5b52" translate="yes" xml:space="preserve">
          <source>If the path points to a symlink, &lt;a href=&quot;#pathlib.Path.exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt; returns whether the symlink &lt;em&gt;points to&lt;/em&gt; an existing file or directory.</source>
          <target state="translated">경로 가 심볼릭 링크를 &lt;em&gt;가리키는&lt;/em&gt; 경우 exist &lt;a href=&quot;#pathlib.Path.exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt; 는 심볼릭 링크 가 기존 파일 또는 디렉토리를 &lt;em&gt;가리키는&lt;/em&gt; 지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="44f1c1068fb3f75ecb6e1e324e661782e6111e57" translate="yes" xml:space="preserve">
          <source>If the path that &lt;em&gt;cfile&lt;/em&gt; becomes (either explicitly specified or computed) is a symlink or non-regular file, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; will be raised. This is to act as a warning that import will turn those paths into regular files if it is allowed to write byte-compiled files to those paths. This is a side-effect of import using file renaming to place the final byte-compiled file into place to prevent concurrent file writing issues.</source>
          <target state="translated">&lt;em&gt;cfile&lt;/em&gt; 이 되는 경로 (명시 적으로 지정되거나 계산 된)가 symlink 또는 비정규 파일 인 경우 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 바이트 컴파일 파일을 해당 경로에 쓸 수 있으면 가져 오기에서 해당 경로를 일반 파일로 변환한다는 경고의 역할을합니다. 이는 파일 이름 바꾸기를 사용하여 최종 바이트 컴파일 된 파일을 제자리에 배치하여 동시 파일 쓰기 문제를 방지하는 가져 오기의 부작용입니다.</target>
        </trans-unit>
        <trans-unit id="ae2d2687ad3551ef8bd1472c724bb07372b1e0e7" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; function, this mapping may be used to modify the environment as well as query the environment. &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; will be called automatically when the mapping is modified.</source>
          <target state="translated">플랫폼이 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 함수를 지원하는 경우이 맵핑을 사용하여 환경을 조회하고 환경을 조회 할 수 있습니다. &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 는 매핑이 수정 될 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="359b0fc2d0ac172f51521bc634e7ed8e651ae47d" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; function, you can delete items in this mapping to unset environment variables. &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; will be called automatically when an item is deleted from &lt;code&gt;os.environ&lt;/code&gt;, and when one of the &lt;code&gt;pop()&lt;/code&gt; or &lt;code&gt;clear()&lt;/code&gt; methods is called.</source>
          <target state="translated">플랫폼이 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 함수를 지원하는 경우이 맵핑에서 항목을 삭제하여 환경 변수를 설정 해제 할 수 있습니다. &lt;code&gt;os.environ&lt;/code&gt; 에서 항목이 삭제되고 &lt;code&gt;pop()&lt;/code&gt; 또는 &lt;code&gt;clear()&lt;/code&gt; 메소드 중 하나 가 호출되면 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 가 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c98e4ced54c3de726831a13682ac05eaffe4094a" translate="yes" xml:space="preserve">
          <source>If the priority of a task changes, how do you move it to a new position in the heap?</source>
          <target state="translated">작업의 우선 순위가 변경되면 어떻게 작업을 힙의 새로운 위치로 이동합니까?</target>
        </trans-unit>
        <trans-unit id="a498076041fadf1d07bb9300b846a643e776f60f" translate="yes" xml:space="preserve">
          <source>If the process does not terminate after &lt;em&gt;timeout&lt;/em&gt; seconds, a &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt;&lt;code&gt;TimeoutExpired&lt;/code&gt;&lt;/a&gt; exception will be raised. Catching this exception and retrying communication will not lose any output.</source>
          <target state="translated">&lt;em&gt;타임 아웃&lt;/em&gt; 초 후에 프로세스가 종료되지 않으면 &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt; &lt;code&gt;TimeoutExpired&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 이 예외를 포착하고 통신을 다시 시도해도 출력이 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d9458f7fed96d843f923a0a12238a4b1050fd9f" translate="yes" xml:space="preserve">
          <source>If the process does not terminate after &lt;em&gt;timeout&lt;/em&gt; seconds, raise a &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt;&lt;code&gt;TimeoutExpired&lt;/code&gt;&lt;/a&gt; exception. It is safe to catch this exception and retry the wait.</source>
          <target state="translated">프로세스가 이후에 종료되지 않는 경우 &lt;em&gt;제한 시간&lt;/em&gt; (초), 인상 &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt; &lt;code&gt;TimeoutExpired&lt;/code&gt; 의&lt;/a&gt; 예외. 이 예외를 포착하고 대기를 재 시도하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f7262122dc4b6b829f446558da074d130b2a5add" translate="yes" xml:space="preserve">
          <source>If the queue was initialized with &lt;code&gt;maxsize=0&lt;/code&gt; (the default), then &lt;a href=&quot;#asyncio.Queue.full&quot;&gt;&lt;code&gt;full()&lt;/code&gt;&lt;/a&gt; never returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">큐가 &lt;code&gt;maxsize=0&lt;/code&gt; (기본값) 으로 초기화 된 경우 &lt;a href=&quot;#asyncio.Queue.full&quot;&gt; &lt;code&gt;full()&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;True&lt;/code&gt; 를 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d78a8ec352511b839919bc03232ce959083bf45a" translate="yes" xml:space="preserve">
          <source>If the referent is unpicklable then this will raise an exception.</source>
          <target state="translated">심판이 피클 링 할 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91ada59b96a0d8cfa6712ce3f61b93c29c1b67a6" translate="yes" xml:space="preserve">
          <source>If the referent no longer exists, calling the reference object returns &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">참조자가 더 이상 존재하지 않으면 참조 객체를 호출하면 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 이&lt;/a&gt; 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="909c01304c9716dba0fff5875fca0ce88ce2dc59" translate="yes" xml:space="preserve">
          <source>If the regular expression uses the &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; syntax, the &lt;em&gt;groupN&lt;/em&gt; arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">정규식이 &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 구문을 사용하는 경우 &lt;em&gt;groupN&lt;/em&gt; 인수는 그룹 이름으로 그룹을 식별하는 문자열 일 수도 있습니다. 패턴에서 문자열 인수가 그룹 이름으로 사용되지 않으면 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9150bc1a07c7bb0e57bdc9eaf32d4f61f9798eda" translate="yes" xml:space="preserve">
          <source>If the reply matches the digest of the message using &lt;em&gt;authkey&lt;/em&gt; as the key then a welcome message is sent to the other end of the connection. Otherwise &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt;&lt;code&gt;AuthenticationError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">응답이 &lt;em&gt;authkey&lt;/em&gt; 를 키로 사용하여 메시지의 요약과 일치 하면 연결의 다른 쪽 끝으로 환영 메시지가 전송됩니다. 그렇지 않으면 &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt; &lt;code&gt;AuthenticationError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="335f0408ae4594f8d3341768174fc78d95715a5d" translate="yes" xml:space="preserve">
          <source>If the request was mapped to a directory, the directory is checked for a file named &lt;code&gt;index.html&lt;/code&gt; or &lt;code&gt;index.htm&lt;/code&gt; (in that order). If found, the file&amp;rsquo;s contents are returned; otherwise a directory listing is generated by calling the &lt;code&gt;list_directory()&lt;/code&gt; method. This method uses &lt;a href=&quot;os#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt; to scan the directory, and returns a &lt;code&gt;404&lt;/code&gt; error response if the &lt;a href=&quot;os#os.listdir&quot;&gt;&lt;code&gt;listdir()&lt;/code&gt;&lt;/a&gt; fails.</source>
          <target state="translated">요청이 디렉토리에 맵핑 된 경우, 디렉토리는 &lt;code&gt;index.html&lt;/code&gt; 또는 &lt;code&gt;index.htm&lt;/code&gt; (순서대로) 파일을 점검합니다 . 발견되면 파일 내용이 반환됩니다. 그렇지 않으면 &lt;code&gt;list_directory()&lt;/code&gt; 메소드를 호출하여 디렉토리 목록이 생성됩니다 . 이 메소드는 &lt;a href=&quot;os#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 디렉토리를 스캔 하고 &lt;a href=&quot;os#os.listdir&quot;&gt; &lt;code&gt;listdir()&lt;/code&gt; &lt;/a&gt; 이 실패하면 &lt;code&gt;404&lt;/code&gt; 오류 응답을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="785b81ecc43784be1a5372c2c81457edd17d9681" translate="yes" xml:space="preserve">
          <source>If the request was mapped to a file, it is opened. Any &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception in opening the requested file is mapped to a &lt;code&gt;404&lt;/code&gt;, &lt;code&gt;'File not found'&lt;/code&gt; error. If there was a &lt;code&gt;'If-Modified-Since'&lt;/code&gt; header in the request, and the file was not modified after this time, a &lt;code&gt;304&lt;/code&gt;, &lt;code&gt;'Not Modified'&lt;/code&gt; response is sent. Otherwise, the content type is guessed by calling the &lt;code&gt;guess_type()&lt;/code&gt; method, which in turn uses the &lt;em&gt;extensions_map&lt;/em&gt; variable, and the file contents are returned.</source>
          <target state="translated">요청이 파일에 맵핑 된 경우 열립니다. 모든 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 요청 된 파일을 여는 예외가 매핑됩니다 &lt;code&gt;404&lt;/code&gt; , &lt;code&gt;'File not found'&lt;/code&gt; 오류가 발생했습니다. 거기 경우 &lt;code&gt;'If-Modified-Since'&lt;/code&gt; 요청의 헤더 및 파일이 시간 후에 변형되지 않은 &lt;code&gt;304&lt;/code&gt; , &lt;code&gt;'Not Modified'&lt;/code&gt; 응답이 전송된다. 그렇지 않은 경우, &lt;em&gt;extensions_map&lt;/em&gt; 변수를 사용하는 &lt;code&gt;guess_type()&lt;/code&gt; 메소드 를 호출하여 컨텐츠 유형을 추측 하고 파일 컨텐츠가 리턴됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="164f68a4853c0030aecaf77543f70404dffd338d" translate="yes" xml:space="preserve">
          <source>If the requested module already exists in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;, that module should be used and reloaded. Otherwise the loader should create a new module and insert it into &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; before any loading begins, to prevent recursion from the import. If the loader inserted a module and the load fails, it must be removed by the loader from &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;; modules already in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; before the loader began execution should be left alone (see &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt;&lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">요청 된 모듈이 이미 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 존재 하면 해당 모듈을 사용하고 다시로드해야합니다. 그렇지 않으면 로더는 가져 오기에서 재귀를 방지하기 위해로드를 시작하기 전에 새 모듈을 작성하고 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 삽입해야 합니다. 로더가 모듈을 삽입했는데로드가 실패하면 로더가 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에서 제거해야합니다 . 로더가 실행을 시작하기 전에 이미 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에있는 모듈 은 그대로 두어야합니다 ( &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt; &lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="03b4e196b2e9acd5ba4a384dea909aa2a6ee615a" translate="yes" xml:space="preserve">
          <source>If the resource cannot be found, &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">리소스를 찾을 수 없으면 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0df3e09c5b36021f773ac46f41a2c43194c9fca6" translate="yes" xml:space="preserve">
          <source>If the resource cleanup isn&amp;rsquo;t already neatly bundled into a standalone function, then it is still possible to use the decorator form of &lt;a href=&quot;#contextlib.ExitStack.callback&quot;&gt;&lt;code&gt;ExitStack.callback()&lt;/code&gt;&lt;/a&gt; to declare the resource cleanup in advance:</source>
          <target state="translated">자원 정리가 아직 독립형 함수에 깔끔하게 번들되어 있지 않은 경우에도 &lt;a href=&quot;#contextlib.ExitStack.callback&quot;&gt; &lt;code&gt;ExitStack.callback()&lt;/code&gt; &lt;/a&gt; 형식 ExitStack.callback () 을 사용하여 자원 정리를 미리 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1ab5f376bf69b7b54158c8e22471cb84fdbe8d" translate="yes" xml:space="preserve">
          <source>If the resource does not concretely exist on the file system, raise &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자원이 파일 시스템에 구체적으로 존재하지 않으면 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; &lt;/a&gt; 를 발생 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="e8f1ce475d9c36397896ac205e613c6b1f406f21" translate="yes" xml:space="preserve">
          <source>If the result is zero then its sign will be the sign of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">결과가 0이면 해당 부호는 &lt;em&gt;self&lt;/em&gt; 의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="5a98dda2c1e7c49ba619d9723afd406089bc22f0" translate="yes" xml:space="preserve">
          <source>If the return code was non-zero it raises a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt; object will have the return code in the &lt;a href=&quot;#subprocess.CalledProcessError.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; attribute and any output in the &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">리턴 코드가 0이 아닌 경우 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다. &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 의&lt;/a&gt; 객체는의 리턴 코드가됩니다 &lt;a href=&quot;#subprocess.CalledProcessError.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 특성과 어떤 출력 &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="1499f9fffce42eacfcc4c16359b64bca87b01b5c" translate="yes" xml:space="preserve">
          <source>If the return value &lt;em&gt;is&lt;/em&gt; an iterator, then iterating over it once will consume it and subsequent iterations will result in an empty list:</source>
          <target state="translated">반환 값 &lt;em&gt;이&lt;/em&gt; 이터레이터 인 경우 한 번 반복 하면 그 값 &lt;em&gt;이&lt;/em&gt; 소비되고 그 이후의 반복에서는 빈 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="108f2d44c66943b7534256bc63b5f502b9a8ba5a" translate="yes" xml:space="preserve">
          <source>If the root is reached, and it has a level of NOTSET, then all messages will be processed. Otherwise, the root&amp;rsquo;s level will be used as the effective level.</source>
          <target state="translated">루트에 도달하고 레벨이 NOTSET이면 모든 메시지가 처리됩니다. 그렇지 않으면 루트 레벨이 유효 레벨로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09d539352f4b8bde471c4c7a5b1b7605d75d424f" translate="yes" xml:space="preserve">
          <source>If the sample size is larger than the population size, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">표본 크기가 모집단 크기보다 크면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d4676a6fdc2402cf5a3dbbb4a4b2ed50deb25ed" translate="yes" xml:space="preserve">
          <source>If the second argument is omitted, the super object returned is unbound. If the second argument is an object, &lt;code&gt;isinstance(obj, type)&lt;/code&gt; must be true. If the second argument is a type, &lt;code&gt;issubclass(type2, type)&lt;/code&gt; must be true (this is useful for classmethods).</source>
          <target state="translated">두 번째 인수가 생략되면 리턴 된 수퍼 오브젝트가 바인드되지 않습니다. 두 번째 인수가 객체 인 경우 &lt;code&gt;isinstance(obj, type)&lt;/code&gt; 는 true 여야합니다. 두 번째 인수가 유형 인 경우 &lt;code&gt;issubclass(type2, type)&lt;/code&gt; 는 true 여야합니다 (이는 클래스 메소드에 유용합니다).</target>
        </trans-unit>
        <trans-unit id="5001076d001501658658c23588861355b9db6f5b" translate="yes" xml:space="preserve">
          <source>If the signal is not trapped (default), mixing floats and Decimals is permitted in the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; constructor, &lt;a href=&quot;#decimal.Context.create_decimal&quot;&gt;&lt;code&gt;create_decimal()&lt;/code&gt;&lt;/a&gt; and all comparison operators. Both conversion and comparisons are exact. Any occurrence of a mixed operation is silently recorded by setting &lt;a href=&quot;#decimal.FloatOperation&quot;&gt;&lt;code&gt;FloatOperation&lt;/code&gt;&lt;/a&gt; in the context flags. Explicit conversions with &lt;a href=&quot;#decimal.Decimal.from_float&quot;&gt;&lt;code&gt;from_float()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#decimal.Context.create_decimal_from_float&quot;&gt;&lt;code&gt;create_decimal_from_float()&lt;/code&gt;&lt;/a&gt; do not set the flag.</source>
          <target state="translated">신호가 트래핑되지 않으면 (기본값) 부동 소수점과 소수를 혼합하는 것이 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 생성자, &lt;a href=&quot;#decimal.Context.create_decimal&quot;&gt; &lt;code&gt;create_decimal()&lt;/code&gt; &lt;/a&gt; 및 모든 비교 연산자 에서 허용됩니다 . 변환과 비교는 모두 정확합니다. 컨텍스트 플래그에서 &lt;a href=&quot;#decimal.FloatOperation&quot;&gt; &lt;code&gt;FloatOperation&lt;/code&gt; &lt;/a&gt; 을 설정하면 혼합 작업이 자동으로 기록됩니다 . &lt;a href=&quot;#decimal.Decimal.from_float&quot;&gt; &lt;code&gt;from_float()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#decimal.Context.create_decimal_from_float&quot;&gt; &lt;code&gt;create_decimal_from_float()&lt;/code&gt; &lt;/a&gt; 를 사용한 명시 적 변환 은 플래그를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5eb98687458be9bdfcd1779f07871d42fe11615b" translate="yes" xml:space="preserve">
          <source>If the specified check is not supported, an &lt;a href=&quot;#lzma.LZMAError&quot;&gt;&lt;code&gt;LZMAError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 검사가 지원되지 않으면 &lt;a href=&quot;#lzma.LZMAError&quot;&gt; &lt;code&gt;LZMAError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b54c9f0cfe02eb7352da72b9945e23c261ee5f4" translate="yes" xml:space="preserve">
          <source>If the specified sound cannot be found, do not play the system default sound.</source>
          <target state="translated">지정된 사운드를 찾을 수 없으면 시스템 기본 사운드를 재생하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="778c39a7849194812f3b69dbd53ec4638f531eda" translate="yes" xml:space="preserve">
          <source>If the specified value is &lt;code&gt;True&lt;/code&gt;, the configuration is processed as described in the section on &lt;a href=&quot;#logging-config-dict-incremental&quot;&gt;Incremental Configuration&lt;/a&gt;.</source>
          <target state="translated">지정된 값이 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;#logging-config-dict-incremental&quot;&gt;증분 구성&lt;/a&gt; 섹션에 설명 된대로 구성이 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="06cc8f856e11dad88ac598335b513ab61be78c92" translate="yes" xml:space="preserve">
          <source>If the start method has not been fixed and &lt;em&gt;allow_none&lt;/em&gt; is false, then the start method is fixed to the default and the name is returned. If the start method has not been fixed and &lt;em&gt;allow_none&lt;/em&gt; is true then &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">start 메소드가 수정되지 않고 &lt;em&gt;allow_none&lt;/em&gt; 이 false 인 경우 start 메소드가 기본값으로 고정되고 이름이 리턴됩니다. start 메소드가 수정되지 않고 &lt;em&gt;allow_none&lt;/em&gt; 이 true이면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1b8c9208a62d78a294576a65a53059a1c5f6f17a" translate="yes" xml:space="preserve">
          <source>If the subclass overrides the constructor, it must make sure to invoke the base class constructor (&lt;code&gt;Thread.__init__()&lt;/code&gt;) before doing anything else to the thread.</source>
          <target state="translated">서브 클래스가 생성자를 대체하는 경우 스레드에 다른 작업을 수행하기 전에 기본 클래스 생성자 ( &lt;code&gt;Thread.__init__()&lt;/code&gt; ) 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="acce8b93fe985a72766f9ac89c69d8af02e986e6" translate="yes" xml:space="preserve">
          <source>If the submitted form data contains more than one field with the same name, the object retrieved by &lt;code&gt;form[key]&lt;/code&gt; is not a &lt;code&gt;FieldStorage&lt;/code&gt; or &lt;code&gt;MiniFieldStorage&lt;/code&gt; instance but a list of such instances. Similarly, in this situation, &lt;code&gt;form.getvalue(key)&lt;/code&gt; would return a list of strings. If you expect this possibility (when your HTML form contains multiple fields with the same name), use the &lt;a href=&quot;#cgi.FieldStorage.getlist&quot;&gt;&lt;code&gt;getlist()&lt;/code&gt;&lt;/a&gt; method, which always returns a list of values (so that you do not need to special-case the single item case). For example, this code concatenates any number of username fields, separated by commas:</source>
          <target state="translated">제출 된 양식 데이터에 동일한 이름의 필드가 둘 이상 있으면 &lt;code&gt;form[key]&lt;/code&gt; 의해 검색된 오브젝트 는 &lt;code&gt;FieldStorage&lt;/code&gt; 또는 &lt;code&gt;MiniFieldStorage&lt;/code&gt; 인스턴스가 아니라 해당 인스턴스 목록입니다. 이와 유사 &lt;code&gt;form.getvalue(key)&lt;/code&gt; 상황에서 form.getvalue (key) 는 문자열 목록을 반환합니다. 이러한 가능성이 예상되면 (HTML 양식에 동일한 이름을 가진 여러 필드가 포함 된 경우) &lt;a href=&quot;#cgi.FieldStorage.getlist&quot;&gt; &lt;code&gt;getlist()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오.이 메소드는 항상 값 목록을 리턴하므로 단일 항목 케이스를 특수하게 처리 할 필요가 없습니다. 예를 들어이 코드는 쉼표로 구분하여 여러 사용자 이름 필드를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="5ca69890189daafd25a2e36e6b3b7787040e88e4" translate="yes" xml:space="preserve">
          <source>If the subprocess hasn&amp;rsquo;t returned yet, and close transports of &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt;, and &lt;em&gt;stderr&lt;/em&gt; pipes.</source>
          <target state="translated">서브 프로세스가 아직 리턴되지 않은 경우 &lt;em&gt;stdin&lt;/em&gt; , &lt;em&gt;stdout&lt;/em&gt; 및 &lt;em&gt;stderr&lt;/em&gt; 파이프의 전송을 닫으십시오 .</target>
        </trans-unit>
        <trans-unit id="97b2ccdb92b73cedf9597250b83de25464d1e506" translate="yes" xml:space="preserve">
          <source>If the supplied path directly references a script file (whether as source or as precompiled byte code), then &lt;code&gt;__file__&lt;/code&gt; will be set to the supplied path, and &lt;code&gt;__spec__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; will all be set to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 경로가 스크립트 파일 (소스 또는 사전 컴파일 된 바이트 코드)을 직접 참조하는 경우 &lt;code&gt;__file__&lt;/code&gt; 은 제공된 경로로 설정되고 &lt;code&gt;__spec__&lt;/code&gt; , &lt;code&gt;__cached__&lt;/code&gt; , &lt;code&gt;__loader__&lt;/code&gt; 및 &lt;code&gt;__package__&lt;/code&gt; 는 모두 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c60916833581a918770fd11c43105b09a19f5fd3" translate="yes" xml:space="preserve">
          <source>If the supplied path is a reference to a valid sys.path entry, then &lt;code&gt;__spec__&lt;/code&gt; will be set appropriately for the imported &lt;code&gt;__main__&lt;/code&gt; module (that is, &lt;code&gt;__spec__.name&lt;/code&gt; will always be &lt;code&gt;__main__&lt;/code&gt;). &lt;code&gt;__file__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; will be &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#import-mod-attrs&quot;&gt;set as normal&lt;/a&gt; based on the module spec.</source>
          <target state="translated">제공된 경로가 유효한 sys.path 항목에 대한 참조 이면 가져온 &lt;code&gt;__main__&lt;/code&gt; 모듈에 대해 &lt;code&gt;__spec__&lt;/code&gt; 이 적절하게 설정됩니다 (즉, &lt;code&gt;__spec__.name&lt;/code&gt; 은 항상 &lt;code&gt;__main__&lt;/code&gt; 입니다 ). &lt;code&gt;__file__&lt;/code&gt; , &lt;code&gt;__cached__&lt;/code&gt; , &lt;code&gt;__loader__&lt;/code&gt; 및 &lt;code&gt;__package__&lt;/code&gt; 는 모듈 사양에 따라 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#import-mod-attrs&quot;&gt;정상적으로 설정됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1adf55313515a9d46f4badde3d9f05bb3bac807d" translate="yes" xml:space="preserve">
          <source>If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an &lt;a href=&quot;exceptions#InterruptedError&quot;&gt;&lt;code&gt;InterruptedError&lt;/code&gt;&lt;/a&gt; exception (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0475&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;PEP 475&lt;/strong&gt;&lt;/a&gt; for the rationale).</source>
          <target state="translated">시스템 호출이 중단되고 신호 핸들러가 예외를 발생시키지 않으면이 함수는 이제 &lt;a href=&quot;exceptions#InterruptedError&quot;&gt; &lt;code&gt;InterruptedError&lt;/code&gt; &lt;/a&gt; 예외 를 발생시키는 대신 시스템 호출을 재 시도합니다 ( 이론 은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0475&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;PEP 475&lt;/strong&gt;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a6d43cf81da71fff4123417dbbd417d2066dd963" translate="yes" xml:space="preserve">
          <source>If the system has little free memory, snapshots can be written on disk using the &lt;a href=&quot;#tracemalloc.Snapshot.dump&quot;&gt;&lt;code&gt;Snapshot.dump()&lt;/code&gt;&lt;/a&gt; method to analyze the snapshot offline. Then use the &lt;a href=&quot;#tracemalloc.Snapshot.load&quot;&gt;&lt;code&gt;Snapshot.load()&lt;/code&gt;&lt;/a&gt; method reload the snapshot.</source>
          <target state="translated">시스템에 사용 가능한 메모리가 거의없는 경우 &lt;a href=&quot;#tracemalloc.Snapshot.dump&quot;&gt; &lt;code&gt;Snapshot.dump()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 디스크에 스냅 샷을 작성 하여 스냅 샷을 오프라인으로 분석 할 수 있습니다 . 그런 다음 &lt;a href=&quot;#tracemalloc.Snapshot.load&quot;&gt; &lt;code&gt;Snapshot.load()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 스냅 샷을 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="31f84dc9d5116f5e6dfe6a1466f5a476a9188d05" translate="yes" xml:space="preserve">
          <source>If the target is omitted (or &lt;code&gt;None&lt;/code&gt;), the source must be a directory and the target will be a file with the same name as the source, with a &lt;code&gt;.pyz&lt;/code&gt; extension added.</source>
          <target state="translated">대상이 생략 된 경우 (또는 &lt;code&gt;None&lt;/code&gt; ) 소스는 디렉토리 여야하며 대상은 소스와 이름이 같은 파일 &lt;code&gt;.pyz&lt;/code&gt; 확장자 는 .pyz 입니다.</target>
        </trans-unit>
        <trans-unit id="a81ad72c0eb0b73e6a8f61b1a3e045791f08818e" translate="yes" xml:space="preserve">
          <source>If the terminal size cannot be successfully queried, either because the system doesn&amp;rsquo;t support querying, or because we are not connected to a terminal, the value given in &lt;code&gt;fallback&lt;/code&gt; parameter is used. &lt;code&gt;fallback&lt;/code&gt; defaults to &lt;code&gt;(80, 24)&lt;/code&gt; which is the default size used by many terminal emulators.</source>
          <target state="translated">시스템이 쿼리를 지원하지 않거나 터미널에 연결되어 있지 않기 때문에 터미널 크기를 성공적으로 쿼리 할 수없는 경우 &lt;code&gt;fallback&lt;/code&gt; 매개 변수에 지정된 값 이 사용됩니다. &lt;code&gt;fallback&lt;/code&gt; 디폴트 &lt;code&gt;(80, 24)&lt;/code&gt; 많은 단말기 에뮬레이터에 의해 사용되는 디폴트 크기.</target>
        </trans-unit>
        <trans-unit id="2de2938d3bd0d33a2753ba4337962dd33d95e0ce" translate="yes" xml:space="preserve">
          <source>If the testing strategy changes, there is no need to change the source code.</source>
          <target state="translated">테스트 전략이 변경되면 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcd64126f5fb037416eebb3476593dfc24805624" translate="yes" xml:space="preserve">
          <source>If the transport has a buffer for outgoing data, buffered data will be flushed asynchronously. No more data will be received. After all buffered data is flushed, the protocol&amp;rsquo;s &lt;a href=&quot;#asyncio.BaseProtocol.connection_lost&quot;&gt;&lt;code&gt;protocol.connection_lost()&lt;/code&gt;&lt;/a&gt; method will be called with &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; as its argument.</source>
          <target state="translated">전송에 나가는 데이터에 대한 버퍼가있는 경우 버퍼링 된 데이터는 비동기 적으로 플러시됩니다. 더 이상 데이터가 수신되지 않습니다. 버퍼링 된 모든 데이터가 플러시 된 후, 프로토콜의 &lt;a href=&quot;#asyncio.BaseProtocol.connection_lost&quot;&gt; &lt;code&gt;protocol.connection_lost()&lt;/code&gt; &lt;/a&gt; 메소드가 인수 로 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f1d6afc6fe93a09cfe3361f1b4868b729dcdad9" translate="yes" xml:space="preserve">
          <source>If the two operands are unequal, return the number closest to the first operand in the direction of the second operand. If both operands are numerically equal, return a copy of the first operand with the sign set to be the same as the sign of the second operand.</source>
          <target state="translated">두 피연산자가 같지 않으면 두 번째 피연산자 방향으로 첫 번째 피연산자에 가장 가까운 숫자를 반환하십시오. 두 피연산자가 모두 숫자가 같으면 부호가 두 번째 피연산자의 부호와 동일하게 설정된 첫 번째 피연산자의 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5a546ad02eac6e07241889e84cea3b1a7f283a82" translate="yes" xml:space="preserve">
          <source>If the underlying object is writable, the memoryview supports one-dimensional slice assignment. Resizing is not allowed:</source>
          <target state="translated">기본 개체가 쓰기 가능한 경우 memoryview는 1 차원 슬라이스 할당을 지원합니다. 크기 조정은 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="1896841bb368d293e9660afd2874585397d59819" translate="yes" xml:space="preserve">
          <source>If the value &amp;ldquo;using_IDLE&amp;rdquo; in the configuration dictionary is &lt;code&gt;False&lt;/code&gt; (default value), also enter mainloop. Remark: If IDLE with the &lt;code&gt;-n&lt;/code&gt; switch (no subprocess) is used, this value should be set to &lt;code&gt;True&lt;/code&gt; in &lt;code&gt;turtle.cfg&lt;/code&gt;. In this case IDLE&amp;rsquo;s own mainloop is active also for the client script.</source>
          <target state="translated">구성 사전의&amp;ldquo;using_IDLE&amp;rdquo;값이 &lt;code&gt;False&lt;/code&gt; (기본값) 인 경우 mainloop 도 입력하십시오. 비고 다음과 IDLE 경우 &lt;code&gt;-n&lt;/code&gt; 스위치 (NO 하위 프로세스)을 사용하고,이 값을 설정해야 &lt;code&gt;True&lt;/code&gt; 으로 &lt;code&gt;turtle.cfg&lt;/code&gt; . 이 경우 IDLE의 자체 메인 루프는 클라이언트 스크립트에서도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="89e5de1d1a57cbd9a0fc9d4e4a4217ecc10e0356" translate="yes" xml:space="preserve">
          <source>If the value contains binary data, it is converted into a &lt;a href=&quot;email.header#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; object using the &lt;code&gt;unknown-8bit&lt;/code&gt; charset. Otherwise it is returned unmodified.</source>
          <target state="translated">값에 이진 데이터가 포함되어 있으면 &lt;code&gt;unknown-8bit&lt;/code&gt; 문자 집합을 사용하여 &lt;a href=&quot;email.header#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 개체 로 변환됩니다 . 그렇지 않으면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3065c24d18047dbd8738a4165aafe7e2b3d722cb" translate="yes" xml:space="preserve">
          <source>If the value contains non-ASCII characters, the charset and language may be explicitly controlled by specifying the value as a three tuple in the format &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt;, where &lt;code&gt;CHARSET&lt;/code&gt; is a string naming the charset to be used to encode the value, &lt;code&gt;LANGUAGE&lt;/code&gt; can usually be set to &lt;code&gt;None&lt;/code&gt; or the empty string (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; for other possibilities), and &lt;code&gt;VALUE&lt;/code&gt; is the string value containing non-ASCII code points. If a three tuple is not passed and the value contains non-ASCII characters, it is automatically encoded in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; format using a &lt;code&gt;CHARSET&lt;/code&gt; of &lt;code&gt;utf-8&lt;/code&gt; and a &lt;code&gt;LANGUAGE&lt;/code&gt; of &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">값에 ASCII가 아닌 문자가 포함 된 경우 &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt; 형식으로 값을 3 개의 튜플로 지정하여 문자 세트 및 언어를 명시 적으로 제어 할 수 있습니다 . 여기서 &lt;code&gt;CHARSET&lt;/code&gt; 은 값은, &lt;code&gt;LANGUAGE&lt;/code&gt; 일반적으로 설정 될 수 &lt;code&gt;None&lt;/code&gt; 또는 빈 문자열 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 다른 가능성에 대한)을하고, &lt;code&gt;VALUE&lt;/code&gt; 는 비 ASCII 코드 포인트가 포함 된 문자열 값입니다. 세 튜플이 통과하고 값이 비 ASCII 문자가 포함되어 있지 않은 경우, 자동으로 인코딩 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 사용하여 형식 &lt;code&gt;CHARSET&lt;/code&gt; 의 &lt;code&gt;utf-8&lt;/code&gt; 과 &lt;code&gt;LANGUAGE&lt;/code&gt; 의를 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8fcbdf6220f66ea7da06b9cbc74f6b8c7af4352" translate="yes" xml:space="preserve">
          <source>If the value contains non-ASCII characters, the charset and language may be explicitly specified using the optional &lt;em&gt;charset&lt;/em&gt; and &lt;em&gt;language&lt;/em&gt; parameters. Optional &lt;em&gt;language&lt;/em&gt; specifies the &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; language, defaulting to the empty string. Both &lt;em&gt;charset&lt;/em&gt; and &lt;em&gt;language&lt;/em&gt; should be strings. The default is to use the &lt;code&gt;utf8&lt;/code&gt;&lt;em&gt;charset&lt;/em&gt; and &lt;code&gt;None&lt;/code&gt; for the &lt;em&gt;language&lt;/em&gt;.</source>
          <target state="translated">값에 ASCII가 아닌 문자가 포함 된 경우 선택적 &lt;em&gt;문자 집합&lt;/em&gt; 및 &lt;em&gt;언어&lt;/em&gt; 매개 변수를 사용하여 &lt;em&gt;문자 집합&lt;/em&gt; 및 &lt;em&gt;언어&lt;/em&gt; 를 명시 적으로 지정할 수 있습니다 . 선택적 &lt;em&gt;언어&lt;/em&gt; 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;&lt;em&gt; 언어를&lt;/em&gt; 지정하며 기본값은 빈 문자열입니다. 두 &lt;em&gt;캐릭터 세트&lt;/em&gt; 와 &lt;em&gt;언어는&lt;/em&gt; 문자열이어야합니다. 기본값은 사용하는 것입니다 &lt;code&gt;utf8&lt;/code&gt; &lt;em&gt;캐릭터 세트&lt;/em&gt; 및 &lt;code&gt;None&lt;/code&gt; 위한 &lt;em&gt;언어&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fd5432d4a79d323ca399133a88c268b9b6146b6f" translate="yes" xml:space="preserve">
          <source>If the value for a header in the &lt;code&gt;Message&lt;/code&gt; object originated from a &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; (as opposed to being set by a program), this attribute indicates whether or not a generator should refold that value when transforming the message back into serialized form. The possible values are:</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 객체 의 헤더 값 이 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 에서 시작된 경우 (프로그램에 의해 설정되는 것이 아니라),이 속성은 메시지를 직렬화 된 형식으로 다시 변환 할 때 생성기가 해당 값을 다시 접어야하는지 여부를 나타냅니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61f619f6c6e535a52f8e51d5c113f91f23edb137" translate="yes" xml:space="preserve">
          <source>If the value has (or contains an object that has) an unsupported type, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception is raised &amp;mdash; but garbage data will also be written to the file. The object will not be properly read back by &lt;a href=&quot;#marshal.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값에 지원되지 않는 유형이 있거나 포함 된 객체가 포함 된 경우 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외가 발생하지만 가비지 데이터도 파일에 기록됩니다. &lt;a href=&quot;#marshal.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 객체를 제대로 읽지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="ac70e682ecd6b9523bcc00452173d51c8483ed90" translate="yes" xml:space="preserve">
          <source>If the value has a &lt;code&gt;name&lt;/code&gt; attribute, it is returned to unmodified. Otherwise the &lt;em&gt;name&lt;/em&gt;, and the &lt;em&gt;value&lt;/em&gt; with any CR or LF characters removed, are passed to the &lt;code&gt;header_factory&lt;/code&gt;, and the resulting header object is returned. Any surrogateescaped bytes get turned into the unicode unknown-character glyph.</source>
          <target state="translated">값에 &lt;code&gt;name&lt;/code&gt; 속성이 있으면 수정되지 않은 상태로 반환됩니다. 그렇지 않으면 &lt;em&gt;name&lt;/em&gt; 과 CR 또는 LF 문자가 제거 된 &lt;em&gt;값&lt;/em&gt; 이 &lt;code&gt;header_factory&lt;/code&gt; 로 전달되고 결과 헤더 객체가 반환됩니다. 대리 이스케이프 된 바이트는 유니 코드 알 수없는 문자 글리프로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="ecac18b5d34fc503358e09e7a4c0d8959266d301" translate="yes" xml:space="preserve">
          <source>If the wait is cancelled, the future &lt;em&gt;aw&lt;/em&gt; is also cancelled.</source>
          <target state="translated">대기가 취소되면 향후 &lt;em&gt;aw&lt;/em&gt; 도 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="56c5f97d09e31156fff54feae27ef3f4943d5433" translate="yes" xml:space="preserve">
          <source>If the watcher was previously attached to an event loop, then it is first detached before attaching to the new loop.</source>
          <target state="translated">감시자가 이전에 이벤트 루프에 연결된 경우 새 루프에 연결하기 전에 먼저 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf203d12061685d40f0461125be7723191a6603" translate="yes" xml:space="preserve">
          <source>If the whole &lt;em&gt;string&lt;/em&gt; matches the regular expression &lt;em&gt;pattern&lt;/em&gt;, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">전체 &lt;em&gt;문자열이&lt;/em&gt; 정규식 &lt;em&gt;패턴 &lt;/em&gt;&lt;a href=&quot;#match-objects&quot;&gt;과 일치&lt;/a&gt; 하면 해당하는 일치 객체를 반환 합니다 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="59c52023f4547acb57c7c8cf28c845aed9e66702" translate="yes" xml:space="preserve">
          <source>If the whole &lt;em&gt;string&lt;/em&gt; matches this regular expression, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">전체 &lt;em&gt;문자열&lt;/em&gt; 이이 정규식과 일치하면 해당하는 &lt;a href=&quot;#match-objects&quot;&gt;일치 오브젝트를&lt;/a&gt; 리턴하십시오 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4d277c1615b59061e36b6cff551c4b7615a3cee8" translate="yes" xml:space="preserve">
          <source>If the wrapped coroutine is not done, this returns the stack where it is suspended. If the coroutine has completed successfully or was cancelled, this returns an empty list. If the coroutine was terminated by an exception, this returns the list of traceback frames.</source>
          <target state="translated">랩핑 된 코 루틴이 수행되지 않으면, 중단 된 스택을 리턴합니다. 코 루틴이 성공적으로 완료되었거나 취소 된 경우 빈 목록이 반환됩니다. 코 루틴이 예외로 종료 된 경우, 이는 역 추적 프레임 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="18bdf0075a155b02791d5a0bac71eb783654ca33" translate="yes" xml:space="preserve">
          <source>If the wrapped coroutine raised an exception that exception is returned. If the wrapped coroutine returned normally this method returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">랩핑 된 코 루틴에서 예외가 발생하면 해당 예외가 리턴됩니다. 랩핑 된 코 루틴이 정상적으로 반환되면이 메서드는 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f7728d4c859a24cbc45d6d58427ec4561648e7f" translate="yes" xml:space="preserve">
          <source>If there are any exceptions raised during one of the shared fixture functions the test is reported as an error. Because there is no corresponding test instance an &lt;code&gt;_ErrorHolder&lt;/code&gt; object (that has the same interface as a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt;) is created to represent the error. If you are just using the standard unittest test runner then this detail doesn&amp;rsquo;t matter, but if you are a framework author it may be relevant.</source>
          <target state="translated">공유 픽스처 기능 중 하나에서 예외가 발생하면 테스트는 오류로보고됩니다. 해당 테스트 인스턴스가 &lt;code&gt;_ErrorHolder&lt;/code&gt; 오류를 나타내는 _ErrorHolder 객체 ( &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 와 동일한 인터페이스 )가 작성됩니다. 표준 unittest 테스트 러너를 사용하는 경우이 세부 사항은 중요하지 않지만 프레임 워크 작성자 인 경우 관련이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d4834d5062c8d19bbd59417935a75681b0f714" translate="yes" xml:space="preserve">
          <source>If there are arguments:</source>
          <target state="translated">인수가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="afe713097f513403e4602cccddaf88e097fca7b5" translate="yes" xml:space="preserve">
          <source>If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string:</source>
          <target state="translated">구분 기호에 캡처 그룹이 있고 문자열 시작시 일치하면 결과는 빈 문자열로 시작합니다. 문자열 끝에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b105dd89905ca457b0617942c150ccc9ce8c2ecd" translate="yes" xml:space="preserve">
          <source>If there are keyword arguments, they will set the attributes of the same names to the given values.</source>
          <target state="translated">키워드 인수가 있으면 동일한 이름의 속성을 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="06875e271bfc97aca9aed5132911283e876fd1e3" translate="yes" xml:space="preserve">
          <source>If there are multiple modes with the same frequency, returns the first one encountered in the &lt;em&gt;data&lt;/em&gt;. If the smallest or largest of those is desired instead, use &lt;code&gt;min(multimode(data))&lt;/code&gt; or &lt;code&gt;max(multimode(data))&lt;/code&gt;. If the input &lt;em&gt;data&lt;/em&gt; is empty, &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">주파수가 동일한 여러 모드가있는 경우 &lt;em&gt;데이터&lt;/em&gt; 에서 처음 발견 된 모드를 반환합니다 . 가장 작거나 가장 큰 것을 원하는 경우 &lt;code&gt;min(multimode(data))&lt;/code&gt; 또는 &lt;code&gt;max(multimode(data))&lt;/code&gt; . 입력 &lt;em&gt;데이터&lt;/em&gt; 가 비어 있으면 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f44c76149f8456dfb2f9b8dc82d343dcb9e7029d" translate="yes" xml:space="preserve">
          <source>If there are no remaining path segments in &lt;code&gt;PATH_INFO&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">에 남아 패스 세그먼트 (segment)가없는 경우 &lt;code&gt;PATH_INFO&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70b04fc0fe654b81856797a63a15dc517bb87a72" translate="yes" xml:space="preserve">
          <source>If there are positional arguments, there must be as many as there are items in &lt;code&gt;T._fields&lt;/code&gt;; they will be assigned as attributes of these names.</source>
          <target state="translated">위치 인수가 있으면 &lt;code&gt;T._fields&lt;/code&gt; 에 항목이있는 수만큼 있어야합니다 . 이러한 이름의 속성으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0f42d2c2054cdfdb7413a7243a89893529ac2223" translate="yes" xml:space="preserve">
          <source>If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to &lt;code&gt;None&lt;/code&gt; in the result.</source>
          <target state="translated">두 개의 인수가 있으면 길이가 같은 문자열이어야하며 결과 사전에서 x의 각 문자는 y의 동일한 위치에있는 문자에 매핑됩니다. 세 번째 인수가 있는 경우 결과에서 문자가 &lt;code&gt;None&lt;/code&gt; 에 매핑되는 문자열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="710f0541779e51ddda266bf2e4665a21cc66a9aa" translate="yes" xml:space="preserve">
          <source>If there has been no previous &lt;code&gt;EHLO&lt;/code&gt; or &lt;code&gt;HELO&lt;/code&gt; command this session, this method tries ESMTP &lt;code&gt;EHLO&lt;/code&gt; first.</source>
          <target state="translated">이 세션에 이전 &lt;code&gt;EHLO&lt;/code&gt; 또는 &lt;code&gt;HELO&lt;/code&gt; 명령이 없는 경우이 방법은 먼저 ESMTP &lt;code&gt;EHLO&lt;/code&gt; 를 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1386edd9abb7368a780ead9fa2633755d22aab5e" translate="yes" xml:space="preserve">
          <source>If there has been no previous &lt;code&gt;EHLO&lt;/code&gt; or &lt;code&gt;HELO&lt;/code&gt; command this session, this method tries ESMTP &lt;code&gt;EHLO&lt;/code&gt; first. If the server does ESMTP, message size and each of the specified options will be passed to it (if the option is in the feature set the server advertises). If &lt;code&gt;EHLO&lt;/code&gt; fails, &lt;code&gt;HELO&lt;/code&gt; will be tried and ESMTP options suppressed.</source>
          <target state="translated">이 세션에 이전 &lt;code&gt;EHLO&lt;/code&gt; 또는 &lt;code&gt;HELO&lt;/code&gt; 명령이 없는 경우이 방법은 먼저 ESMTP &lt;code&gt;EHLO&lt;/code&gt; 를 시도합니다 . 서버가 ESMTP를 수행하면 메시지 크기 및 지정된 각 옵션이 전달됩니다 (옵션이 기능 세트에있는 경우 서버가 알립니다). 경우 &lt;code&gt;EHLO&lt;/code&gt; 가 실패 &lt;code&gt;HELO&lt;/code&gt; 이 시도되고 ESMTP 옵션을 억제.</target>
        </trans-unit>
        <trans-unit id="8264923428e93189de3d9488f3d02a8d83fd11ec" translate="yes" xml:space="preserve">
          <source>If there is a character stream specified, the SAX parser will ignore any byte stream and will not attempt to open a URI connection to the system identifier.</source>
          <target state="translated">문자 스트림이 지정된 경우 SAX 파서는 바이트 스트림을 무시하고 시스템 식별자에 대한 URI 연결을 열려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7846e0ef14d60bd28e7efa81ee77d44a8c2917bd" translate="yes" xml:space="preserve">
          <source>If there is a problem with &lt;em&gt;source&lt;/em&gt;, an exception will be raised. &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; is raised if there is invalid Python syntax, and &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if there is an invalid literal.</source>
          <target state="translated">&lt;em&gt;source에&lt;/em&gt; 문제가 있으면 예외가 발생합니다. 유효하지 않은 Python 구문이 있으면 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 가 발생 하고 유효하지 않은 리터럴이 있으면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c624ff3e0c15c1748938e12da19d4755d79f2928" translate="yes" xml:space="preserve">
          <source>If there is an decoding error on the server name, the TLS connection will terminate with an &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt;&lt;/a&gt; fatal TLS alert message to the client.</source>
          <target state="translated">서버 이름에 디코딩 오류가있는 경우 클라이언트에 대한 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt; &lt;/a&gt; 치명적인 TLS 경고 메시지 와 함께 TLS 연결이 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="c08a28ed04606b4fe20cd569bde11df730c25ffd" translate="yes" xml:space="preserve">
          <source>If there is an error opening the terminal, the underlying curses library may cause the interpreter to exit.</source>
          <target state="translated">터미널을 여는 중 오류가 발생하면 기본 curses 라이브러리가 인터프리터를 종료시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20d9f9895dc923352fb368d4bf728ee9c56de965" translate="yes" xml:space="preserve">
          <source>If there is any error occurred in the trace function, it will be unset, just like &lt;code&gt;settrace(None)&lt;/code&gt; is called.</source>
          <target state="translated">추적 기능에서 오류가 발생하면 &lt;code&gt;settrace(None)&lt;/code&gt; 이 호출되는 것처럼 설정이 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="0926a91c9853e7eeca2a1fc656ef6115ed6a1bf4" translate="yes" xml:space="preserve">
          <source>If there is no certificate for the peer on the other end of the connection, return &lt;code&gt;None&lt;/code&gt;. If the SSL handshake hasn&amp;rsquo;t been done yet, raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결의 다른 쪽 끝에 피어에 대한 인증서가 없으면 &lt;code&gt;None&lt;/code&gt; 을 반환하십시오 . SSL 핸드 셰이크가 아직 완료되지 않은 경우 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를 발생&lt;/a&gt; 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="a16e417025a92b683985a38322a1cd0d3d0859ca" translate="yes" xml:space="preserve">
          <source>If there is no existing &lt;em&gt;MIME-Version&lt;/em&gt; header one will be added. If there is no existing &lt;em&gt;Content-Type&lt;/em&gt; header, one will be added with a value of &lt;em&gt;text/plain&lt;/em&gt;. Whether the &lt;em&gt;Content-Type&lt;/em&gt; header already exists or not, its &lt;code&gt;charset&lt;/code&gt; parameter will be set to &lt;em&gt;charset.output_charset&lt;/em&gt;. If &lt;em&gt;charset.input_charset&lt;/em&gt; and &lt;em&gt;charset.output_charset&lt;/em&gt; differ, the payload will be re-encoded to the &lt;em&gt;output_charset&lt;/em&gt;. If there is no existing &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header, then the payload will be transfer-encoded, if needed, using the specified &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt;, and a header with the appropriate value will be added. If a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header already exists, the payload is assumed to already be correctly encoded using that &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; and is not modified.</source>
          <target state="translated">기존 &lt;em&gt;MIME 버전&lt;/em&gt; 헤더 가없는 경우 헤더가 추가됩니다. 기존 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 가 없으면 &lt;em&gt;text / plain&lt;/em&gt; 값으로 추가됩니다 . &lt;em&gt;Content-Type&lt;/em&gt; 헤더의 존재 여부에 관계없이 해당 &lt;code&gt;charset&lt;/code&gt; 매개 변수는 &lt;em&gt;charset.output_charset&lt;/em&gt; 로 설정됩니다 . 경우 &lt;em&gt;charset.input_charset&lt;/em&gt; 및 &lt;em&gt;charset.output_charset가&lt;/em&gt; 다를 상기 페이로드로 재 인코딩 될 것이다 &lt;em&gt;output_charset&lt;/em&gt; . 기존 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더 가없는 경우 페이로드는 필요한 경우 지정된 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; 을&lt;/a&gt; 사용하여 전송 인코딩됩니다.적절한 값을 가진 헤더가 추가됩니다. 경우 &lt;em&gt;콘텐츠 전송 인코딩&lt;/em&gt; 헤더가 이미 존재, 페이로드는 사용하여 이미 제대로 인코딩 된 것으로 간주됩니다 &lt;em&gt;콘텐츠 전송 인코딩을&lt;/em&gt; 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="668457ccf6ecd6f3a813b38d49f7b92435618884" translate="yes" xml:space="preserve">
          <source>If there is no running event loop a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised. This function can only be called from a coroutine or a callback.</source>
          <target state="translated">실행중인 이벤트 루프가 없으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 이 함수는 코 루틴이나 콜백에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69cac254e6b298fe4270f509ae2413d5927fd1a9" translate="yes" xml:space="preserve">
          <source>If there is no value for the variable in the current context, the method will:</source>
          <target state="translated">현재 컨텍스트에 변수 값이 없으면 메소드는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="80c2dc75a994416645ae1c9380a6d0ceb3f65147" translate="yes" xml:space="preserve">
          <source>If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or &lt;code&gt;None&lt;/code&gt;. Character keys will then be converted to ordinals.</source>
          <target state="translated">인수가 하나만있는 경우 유니 코드 서수 (정수) 또는 문자 (길이 1의 문자열)를 유니 코드 서수, 문자열 (임의의 길이) 또는 &lt;code&gt;None&lt;/code&gt; 에 매핑하는 사전이어야합니다 . 문자 키는 서수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b89ec1a8424896e51072da33f9efe49e974e577" translate="yes" xml:space="preserve">
          <source>If there is only one possible completion for the characters entered, a</source>
          <target state="translated">입력 한 문자에 대해 하나의 가능한 완성 만 있으면</target>
        </trans-unit>
        <trans-unit id="8b2610dd6d4564147cdc6a071edbeae596a215ec" translate="yes" xml:space="preserve">
          <source>If these attributes are marked as optional in the grammar (using a question mark), the value might be &lt;code&gt;None&lt;/code&gt;. If the attributes can have zero-or-more values (marked with an asterisk), the values are represented as Python lists. All possible attributes must be present and have valid values when compiling an AST with &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문법에서 이러한 속성이 선택 사항으로 표시되면 (물음표 사용) 값은 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 속성이 별표로 표시된 0 개 이상의 값을 가질 수있는 경우 값은 Python 목록으로 표시됩니다. &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; AST를 컴파일 할 때 가능한 모든 속성이 존재하고 유효한 값을 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="4cc8f6301859f9ffe9df6772bfd5316c956f6429" translate="yes" xml:space="preserve">
          <source>If this attribute evaluates to true, events logged to this logger will be passed to the handlers of higher level (ancestor) loggers, in addition to any handlers attached to this logger. Messages are passed directly to the ancestor loggers&amp;rsquo; handlers - neither the level nor filters of the ancestor loggers in question are considered.</source>
          <target state="translated">이 속성이 true로 평가되면이 로거에 기록 된 이벤트는이 로거에 첨부 된 핸들러와 함께 상위 레벨 (로스터) 로거의 핸들러로 전달됩니다. 메시지는 조상 로거의 처리기로 직접 전달됩니다. 해당 조상 로거의 수준이나 필터는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abdb9590d870789abfb1d2c6cd1c630b5f260a6c" translate="yes" xml:space="preserve">
          <source>If this attribute is accessed before the end of the stream has been reached, its value will be &lt;code&gt;b''&lt;/code&gt;.</source>
          <target state="translated">스트림의 끝에 도달하기 전에이 속성에 액세스하면 해당 값은 &lt;code&gt;b''&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57abef9824fea6e680f0e895e49db397a22940bc" translate="yes" xml:space="preserve">
          <source>If this attribute is not &lt;code&gt;None&lt;/code&gt; (the default), all test methods to be included in test suites must match one of the patterns in this list. Note that matches are always performed using &lt;a href=&quot;fnmatch#fnmatch.fnmatchcase&quot;&gt;&lt;code&gt;fnmatch.fnmatchcase()&lt;/code&gt;&lt;/a&gt;, so unlike patterns passed to the &lt;code&gt;-v&lt;/code&gt; option, simple substring patterns will have to be converted using &lt;code&gt;*&lt;/code&gt; wildcards.</source>
          <target state="translated">이 속성이 &lt;code&gt;None&lt;/code&gt; (기본값) 이 아닌 경우 테스트 스위트에 포함 할 모든 테스트 메소드는이 목록의 패턴 중 하나와 일치해야합니다. 일치는 항상 &lt;a href=&quot;fnmatch#fnmatch.fnmatchcase&quot;&gt; &lt;code&gt;fnmatch.fnmatchcase()&lt;/code&gt; &lt;/a&gt; 사용하여 수행 되므로 &lt;code&gt;-v&lt;/code&gt; 옵션에 전달 된 패턴과 달리 간단한 하위 문자열 패턴은 &lt;code&gt;*&lt;/code&gt; 와일드 카드를 사용하여 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0e0a95050375345febb5eec5f5dd1307acaa7573" translate="yes" xml:space="preserve">
          <source>If this attribute is numeric and &lt;code&gt;1&lt;/code&gt; or more, a &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; instance will print verbose progress output on its behavior. If you need to use this, you can read the module source code to learn the details.</source>
          <target state="translated">이 속성이 숫자이고 &lt;code&gt;1&lt;/code&gt; 이상인 경우 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 인스턴스는 동작에 대한 자세한 진행률 출력을 인쇄합니다. 이것을 사용해야 할 경우, 세부 사항을 배우기 위해 모듈 소스 코드를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b804a91b5f1f64f8e7129df9975fc4040a040277" translate="yes" xml:space="preserve">
          <source>If this attribute is set to a callable, the &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/a&gt; method delegates to this callable. The parameters passed to the callable are those passed to &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성이 호출 가능으로 설정된 경우 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt; &lt;code&gt;rotate()&lt;/code&gt; &lt;/a&gt; 메소드는이 호출 가능에 위임합니다. 콜 러블에 전달 된 매개 변수는 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt; &lt;code&gt;rotate()&lt;/code&gt; &lt;/a&gt; 전달 된 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="7ebbb6f8f84980f280f393669d0bd62b9cd2bef9" translate="yes" xml:space="preserve">
          <source>If this attribute is set to a callable, the &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt;&lt;code&gt;rotation_filename()&lt;/code&gt;&lt;/a&gt; method delegates to this callable. The parameters passed to the callable are those passed to &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt;&lt;code&gt;rotation_filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성이 호출 가능으로 설정된 경우 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt; &lt;code&gt;rotation_filename()&lt;/code&gt; &lt;/a&gt; 메서드는이 호출 가능에 위임합니다. 콜 러블에 전달 된 매개 변수는 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt; &lt;code&gt;rotation_filename()&lt;/code&gt; &lt;/a&gt; 전달 된 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="dff1b29a4811ae4a2758c854c0086cdf364b91aa" translate="yes" xml:space="preserve">
          <source>If this bit is set, then random bytes are drawn from the &lt;code&gt;/dev/random&lt;/code&gt; pool instead of the &lt;code&gt;/dev/urandom&lt;/code&gt; pool.</source>
          <target state="translated">이 비트가 설정되면 &lt;code&gt;/dev/urandom&lt;/code&gt; 풀 대신 &lt;code&gt;/dev/random&lt;/code&gt; 풀 에서 임의 바이트가 그려집니다 .</target>
        </trans-unit>
        <trans-unit id="90bb6faa5b3834263ad7c4573939b37c5a542a65" translate="yes" xml:space="preserve">
          <source>If this evaluates to false, logging messages are not passed to the handlers of ancestor loggers.</source>
          <target state="translated">이것이 거짓으로 평가되면, 로깅 메시지는 상위 로거의 핸들러로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="017d3d68f19210726c382bec27e52a2d417c3981" translate="yes" xml:space="preserve">
          <source>If this function raises an exception, &lt;a href=&quot;sys#sys.excepthook&quot;&gt;&lt;code&gt;sys.excepthook()&lt;/code&gt;&lt;/a&gt; is called to handle it.</source>
          <target state="translated">이 함수에서 예외가 발생하면이 를 처리하기 위해 &lt;a href=&quot;sys#sys.excepthook&quot;&gt; &lt;code&gt;sys.excepthook()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="58d8a99c356472fc70700f6ecb9c84865af60bb2" translate="yes" xml:space="preserve">
          <source>If this gives an error of type 404, the server cannot find the script &amp;ndash; perhaps you need to install it in a different directory. If it gives another error, there&amp;rsquo;s an installation problem that you should fix before trying to go any further. If you get a nicely formatted listing of the environment and form content (in this example, the fields should be listed as &amp;ldquo;addr&amp;rdquo; with value &amp;ldquo;At Home&amp;rdquo; and &amp;ldquo;name&amp;rdquo; with value &amp;ldquo;Joe Blow&amp;rdquo;), the &lt;code&gt;cgi.py&lt;/code&gt; script has been installed correctly. If you follow the same procedure for your own script, you should now be able to debug it.</source>
          <target state="translated">404 유형의 오류가 발생하면 서버가 스크립트를 찾을 수 없습니다. 다른 디렉토리에 스크립트를 설치해야합니다. 다른 오류가 발생하면 더 이상 진행하기 전에 수정해야하는 설치 문제가 있습니다. &lt;code&gt;cgi.py&lt;/code&gt; 스크립트 는 환경과 양식 컨텐츠의 형식이 잘 지정된 목록 (이 예제에서 &quot;At Home&quot;및 &quot;name&quot;, &quot;Joe Blow&quot;값을 갖는 &quot;addr&quot;)으로 나열되어야합니다. 올바르게 설치되었습니다. 자신의 스크립트에 대해 동일한 절차를 따르면 이제 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f7b6501e5b158a220ae98c2d595a7087ee640a" translate="yes" xml:space="preserve">
          <source>If this handler is not provided, external entities are reported by the &lt;a href=&quot;#xml.parsers.expat.xmlparser.DefaultHandler&quot;&gt;&lt;code&gt;DefaultHandler&lt;/code&gt;&lt;/a&gt; callback, if provided.</source>
          <target state="translated">이 핸들러가 제공되지 않으면 외부 엔티티가 제공되는 경우 &lt;a href=&quot;#xml.parsers.expat.xmlparser.DefaultHandler&quot;&gt; &lt;code&gt;DefaultHandler&lt;/code&gt; &lt;/a&gt; 콜백에 의해보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="85450d770d6418bc4deec157d80a4e51aa30db87" translate="yes" xml:space="preserve">
          <source>If this heap invariant is protected at all time, index 0 is clearly the overall winner. The simplest algorithmic way to remove it and find the &amp;ldquo;next&amp;rdquo; winner is to move some loser (let&amp;rsquo;s say cell 30 in the diagram above) into the 0 position, and then percolate this new 0 down the tree, exchanging values, until the invariant is re-established. This is clearly logarithmic on the total number of items in the tree. By iterating over all items, you get an O(n log n) sort.</source>
          <target state="translated">이 힙 불변 값이 항상 보호되는 경우 인덱스 0은 분명히 전체 승자입니다. 그것을 제거하고 &quot;다음&quot;우승자를 찾는 가장 간단한 알고리즘 방법은 패자를 (위의 다이어그램에서 30 번 셀이라고합시다) 0 위치로 옮기고 불변 할 때까지 값을 교환하면서이 새로운 0을 트리 아래로 퍼뜨리는 것입니다. 다시 설립되었습니다. 이것은 트리의 총 항목 수에 대해 분명히 대수입니다. 모든 항목을 반복하면 O (n log n) 정렬이됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3e8042246e5ac5ba9685632876ea8a3d42c4e7" translate="yes" xml:space="preserve">
          <source>If this is set (not &lt;code&gt;None&lt;/code&gt;), Python will write bytecode-cache &lt;code&gt;.pyc&lt;/code&gt; files to (and read them from) a parallel directory tree rooted at this directory, rather than from &lt;code&gt;__pycache__&lt;/code&gt; directories in the source code tree. Any &lt;code&gt;__pycache__&lt;/code&gt; directories in the source code tree will be ignored and new &lt;code&gt;.pyc&lt;/code&gt; files written within the pycache prefix. Thus if you use &lt;a href=&quot;compileall#module-compileall&quot;&gt;&lt;code&gt;compileall&lt;/code&gt;&lt;/a&gt; as a pre-build step, you must ensure you run it with the same pycache prefix (if any) that you will use at runtime.</source>
          <target state="translated">이것이 설정되어 있지 않으면 ( &lt;code&gt;None&lt;/code&gt; 아님), 파이썬은 소스 코드 트리의 &lt;code&gt;__pycache__&lt;/code&gt; 디렉토리가 아닌이 디렉토리에 뿌리를 둔 병렬 디렉토리 트리에 bytecode-cache &lt;code&gt;.pyc&lt;/code&gt; 파일을 쓰고 읽습니다 . 소스 코드 트리의 모든 &lt;code&gt;__pycache__&lt;/code&gt; 디렉토리는 무시되고 pycache 접두사 안에 새 &lt;code&gt;.pyc&lt;/code&gt; 파일이 작성됩니다. 따라서 &lt;a href=&quot;compileall#module-compileall&quot;&gt; &lt;code&gt;compileall&lt;/code&gt; &lt;/a&gt; 을 사전 빌드 단계로 사용하는 경우 런타임시 사용할 동일한 pycache 접두어 (있는 경우)로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b26511950bcfbe88174f69e9200e69454a2056a" translate="yes" xml:space="preserve">
          <source>If this is true, Python won&amp;rsquo;t try to write &lt;code&gt;.pyc&lt;/code&gt; files on the import of source modules. This value is initially set to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; depending on the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id1&quot;&gt;&lt;code&gt;-B&lt;/code&gt;&lt;/a&gt; command line option and the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;PYTHONDONTWRITEBYTECODE&lt;/code&gt;&lt;/a&gt; environment variable, but you can set it yourself to control bytecode file generation.</source>
          <target state="translated">이것이 사실이라면, 파이썬은 소스 모듈을 가져올 때 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 쓰려고하지 않습니다 . 이 값은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id1&quot;&gt; &lt;code&gt;-B&lt;/code&gt; &lt;/a&gt; 명령 행 옵션 및 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;PYTHONDONTWRITEBYTECODE&lt;/code&gt; &lt;/a&gt; 환경 변수 에 따라 초기에 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 로 설정되지만 바이트 코드 파일 생성을 제어하도록 직접 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3314650337b2349372ab978feed37d7432cf9791" translate="yes" xml:space="preserve">
          <source>If this keyword argument is specified as true, any existing handlers attached to the root logger are removed and closed, before carrying out the configuration as specified by the other arguments.</source>
          <target state="translated">이 키워드 인수가 true로 지정된 경우, 다른 인수로 지정된 구성을 수행하기 전에 루트 로거에 연결된 기존 핸들러가 제거되고 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="11e62c76d42fa37b48327413f77512cf4b5df592" translate="yes" xml:space="preserve">
          <source>If this method is used when the associated process is using a pipe or queue then the pipe or queue is liable to become corrupted and may become unusable by other process. Similarly, if the process has acquired a lock or semaphore etc. then terminating it is liable to cause other processes to deadlock.</source>
          <target state="translated">연관된 프로세스가 파이프 또는 큐를 사용할 때이 방법을 사용하면 파이프 또는 큐가 손상되어 다른 프로세스에서 사용하지 못하게 될 수 있습니다. 마찬가지로 프로세스가 잠금 또는 세마포어 등을 획득 한 경우 종료하면 다른 프로세스가 교착 상태에 빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40b84b7c2b8cd75da3b54cede5c5b30cfe17179e" translate="yes" xml:space="preserve">
          <source>If true, load cookies lazily from disk. This attribute should not be assigned to. This is only a hint, since this only affects performance, not behaviour (unless the cookies on disk are changing). A &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; object may ignore it. None of the &lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt;&lt;code&gt;FileCookieJar&lt;/code&gt;&lt;/a&gt; classes included in the standard library lazily loads cookies.</source>
          <target state="translated">참이면 디스크에서 쿠키를 느리게로드하십시오. 이 속성은 할당하지 않아야합니다. 이것은 힌트 일뿐입니다 (디스크의 쿠키가 변경되지 않는 한), 동작에만 영향을 미치지 않기 때문입니다. &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; 의&lt;/a&gt; 객체는 그것을 무시할 수 있습니다. 의 없음 &lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt; &lt;code&gt;FileCookieJar&lt;/code&gt; 의&lt;/a&gt; 표준 라이브러리 느리게로드 쿠키에 포함 된 클래스.</target>
        </trans-unit>
        <trans-unit id="4b776e3e6964e37b47588161e44e80da43328cd0" translate="yes" xml:space="preserve">
          <source>If true, request that the &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; instance downgrade &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; cookies (ie. cookies received in a &lt;em&gt;Set-Cookie&lt;/em&gt; header with a version cookie-attribute of 1) to Netscape cookies by setting the version attribute of the &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; instance to 0. The default value is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, in which case RFC 2109 cookies are downgraded if and only if &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; handling is turned off. Therefore, RFC 2109 cookies are downgraded by default.</source>
          <target state="translated">만약 사실, 요청 &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; 의&lt;/a&gt; 인스턴스 다운 그레이드 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;RFC 2109 개&lt;/strong&gt;&lt;/a&gt; 쿠키 (예. 쿠키는 수신 &lt;em&gt;설정 - 쿠키&lt;/em&gt; 의 버전 속성을 설정하여 넷스케이프 쿠키 1의 버전 쿠키 속성 헤더) &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 0 기본 값으로 인스턴스를 는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이며,이 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 처리가 해제 된 경우에만 RFC 2109 쿠키가 다운 그레이드됩니다 . 따라서 RFC 2109 쿠키는 기본적으로 다운 그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="ae1121f9e45a9703c97a6bf40a561f0b607ea007" translate="yes" xml:space="preserve">
          <source>If turtleshape is a polygon, outline and interior of that polygon is drawn with the newly set colors.</source>
          <target state="translated">turtleshape가 다각형 인 경우 해당 다각형의 외곽선과 내부가 새로 설정된 색상으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="6b992dbf815e5a48ca08b90300fa3a4771a7068e" translate="yes" xml:space="preserve">
          <source>If turtleshape is a polygon, the interior of that polygon is drawn with the newly set fillcolor.</source>
          <target state="translated">turtleshape가 다각형 인 경우 해당 다각형의 내부는 새로 설정된 채우기 색상으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="be2827a5012b6740877e0b7b0e62c1a742812bf7" translate="yes" xml:space="preserve">
          <source>If turtleshape is a polygon, the outline of that polygon is drawn with the newly set pencolor.</source>
          <target state="translated">turtleshape가 다각형 인 경우 해당 다각형의 외곽선은 새로 설정된 펜 색상으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="0c29d653e6b038e2fe7684142d34103dcd03b42e" translate="yes" xml:space="preserve">
          <source>If two &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;Row&lt;/code&gt;&lt;/a&gt; objects have exactly the same columns and their members are equal, they compare equal.</source>
          <target state="translated">두 개의 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;Row&lt;/code&gt; &lt;/a&gt; 객체가 정확히 동일한 열을 가지고 있고 해당 멤버가 같으면 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="260d0a1b06a2d521034b375df46c28e25cc4e075" translate="yes" xml:space="preserve">
          <source>If used, this function should be called before &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; or newterm are called. When &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the values of lines and columns specified in the terminfo database will be used, even if environment variables &lt;code id=&quot;index-5&quot;&gt;LINES&lt;/code&gt; and &lt;code id=&quot;index-6&quot;&gt;COLUMNS&lt;/code&gt; (used by default) are set, or if curses is running in a window (in which case default behavior would be to use the window size if &lt;code id=&quot;index-7&quot;&gt;LINES&lt;/code&gt; and &lt;code id=&quot;index-8&quot;&gt;COLUMNS&lt;/code&gt; are not set).</source>
          <target state="translated">사용되는 경우,이 함수는 &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 또는 newterm이 호출 되기 전에 호출되어야합니다 . 때 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 선과 terminfo 데이터베이스에서 지정된 열의 값은 환경 변수의 경우에도 사용됩니다 &lt;code id=&quot;index-5&quot;&gt;LINES&lt;/code&gt; 과 &lt;code id=&quot;index-6&quot;&gt;COLUMNS&lt;/code&gt; (이 경우 기본 동작 것이다 (기본적으로 사용)을 설정, 또는 저주 경우 윈도우에서 실행 &lt;code id=&quot;index-7&quot;&gt;LINES&lt;/code&gt; 및 &lt;code id=&quot;index-8&quot;&gt;COLUMNS&lt;/code&gt; 가 설정되지 않은 경우 창 크기를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b09a2a72ca9eebcfaf2f7a111fffa10693a0be54" translate="yes" xml:space="preserve">
          <source>If using this module as part of a multi-processed application (using, for example the &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;concurrent.futures#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; modules), be aware that OpenSSL&amp;rsquo;s internal random number generator does not properly handle forked processes. Applications must change the PRNG state of the parent process if they use any SSL feature with &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt;. Any successful call of &lt;a href=&quot;#ssl.RAND_add&quot;&gt;&lt;code&gt;RAND_add()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.RAND_bytes&quot;&gt;&lt;code&gt;RAND_bytes()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.RAND_pseudo_bytes&quot;&gt;&lt;code&gt;RAND_pseudo_bytes()&lt;/code&gt;&lt;/a&gt; is sufficient.</source>
          <target state="translated">다중 처리 응용 프로그램의 일부로이 모듈을 사용하는 경우 (예 : &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;concurrent.futures#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt; 모듈 사용) OpenSSL의 내부 난수 생성기가 분기 프로세스를 제대로 처리하지 못합니다. 애플리케이션이 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt; 와 함께 SSL 기능을 사용하는 경우 상위 프로세스의 PRNG 상태를 변경해야합니다 . &lt;a href=&quot;#ssl.RAND_add&quot;&gt; &lt;code&gt;RAND_add()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.RAND_bytes&quot;&gt; &lt;code&gt;RAND_bytes()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.RAND_pseudo_bytes&quot;&gt; &lt;code&gt;RAND_pseudo_bytes()&lt;/code&gt; &lt;/a&gt; 호출 이 충분합니다.</target>
        </trans-unit>
        <trans-unit id="40cadaadf40f8d88630127c112a5dbe1fa546685" translate="yes" xml:space="preserve">
          <source>If we make the decimal place and everything after it optional, not all groups might participate in the match. These groups will default to &lt;code&gt;None&lt;/code&gt; unless the &lt;em&gt;default&lt;/em&gt; argument is given:</source>
          <target state="translated">소수점 이하 자릿수와 그 이후의 모든 항목을 선택 사항으로 지정하면 모든 그룹이 일치하는 것은 아닙니다. &lt;em&gt;기본&lt;/em&gt; 인수가 제공 되지 않으면 이러한 그룹은 기본적으로 &lt;code&gt;None&lt;/code&gt; 으로 설정됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21252e699b38c9bde015d527adf98063ea9f956c" translate="yes" xml:space="preserve">
          <source>If we were sent the message from the last example, here is one way we could process it:</source>
          <target state="translated">마지막 예에서 메시지를 보냈다면 다음과 같이 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6bfdd750da38ffcee31dea60ae619912d24791e2" translate="yes" xml:space="preserve">
          <source>If window is currently managed by the notebook but hidden, it is restored to its previous position.</source>
          <target state="translated">노트북이 현재 창을 관리하지만 숨겨져있는 경우 창은 이전 위치로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="aec5c8d5afc40ab554ad46b385c383363932d7b7" translate="yes" xml:space="preserve">
          <source>If wrapping a shared library with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;, it &lt;em&gt;may&lt;/em&gt; be better to determine the shared library name at development time, and hardcode that into the wrapper module instead of using &lt;code&gt;find_library()&lt;/code&gt; to locate the library at runtime.</source>
          <target state="translated">와 공유 라이브러리 포장하면 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; ,이 &lt;em&gt;수&lt;/em&gt; 대신 사용하는 래퍼 모듈에 공유 라이브러리 개발시 이름 및 하드 코드를 결정하는 것이 더 &lt;code&gt;find_library()&lt;/code&gt; 런타임 라이브러리를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f6e263b3d734f898bddb0b90497009b949e688c7" translate="yes" xml:space="preserve">
          <source>If you (or your students) want to use &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; with online help in your native language, you have to translate the docstrings and save the resulting file as e.g. &lt;code&gt;turtle_docstringdict_german.py&lt;/code&gt;.</source>
          <target state="translated">귀하 (또는 학생)가 모국어로 온라인 도움말을 통해 &lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 을 사용 하려면 문서 문자열을 번역하고 결과 파일을 다음과 같이 저장해야합니다 . &lt;code&gt;turtle_docstringdict_german.py&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="681001f9dedd39553c496bc8278d37c4dfe3445e" translate="yes" xml:space="preserve">
          <source>If you access a method (a function defined in a class namespace) through an instance, you get a special object: a &lt;em&gt;bound method&lt;/em&gt; (also called &lt;em&gt;instance method&lt;/em&gt;) object. When called, it will add the &lt;code&gt;self&lt;/code&gt; argument to the argument list. Bound methods have two special read-only attributes: &lt;code&gt;m.__self__&lt;/code&gt; is the object on which the method operates, and &lt;code&gt;m.__func__&lt;/code&gt; is the function implementing the method. Calling &lt;code&gt;m(arg-1, arg-2, ..., arg-n)&lt;/code&gt; is completely equivalent to calling &lt;code&gt;m.__func__(m.__self__, arg-1, arg-2, ...,
arg-n)&lt;/code&gt;.</source>
          <target state="translated">인스턴스를 통해 메서드 (클래스 네임 스페이스에 정의 된 함수)에 액세스하면 &lt;em&gt;바인딩 된 메서드&lt;/em&gt; ( &lt;em&gt;인스턴스 메서드&lt;/em&gt; 라고도 함 ) 개체 라는 특수한 개체가 생성됩니다. 호출되면 &lt;code&gt;self&lt;/code&gt; 인수를 인수 목록에 추가 합니다. 바운드 메소드에는 두 가지 특수 읽기 전용 속성이 있습니다. &lt;code&gt;m.__self__&lt;/code&gt; 는 메소드가 작동하는 오브젝트이고 &lt;code&gt;m.__func__&lt;/code&gt; 는 메소드를 구현하는 함수입니다. 호출 &lt;code&gt;m(arg-1, arg-2, ..., arg-n)&lt;/code&gt; 호출 완전히 동등 &lt;code&gt;m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a1f07de56da7ccfad9978d85c56532e9c3232e2" translate="yes" xml:space="preserve">
          <source>If you are dynamically importing a module that was created since the interpreter began execution (e.g., created a Python source file), you may need to call &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt;&lt;code&gt;invalidate_caches()&lt;/code&gt;&lt;/a&gt; in order for the new module to be noticed by the import system.</source>
          <target state="translated">인터프리터가 실행을 시작한 이후 생성 된 모듈 (예 : Python 소스 파일 생성)을 동적으로 가져 오는 경우 가져 오기 시스템에서 새 모듈을 알 수 있도록 &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt; &lt;code&gt;invalidate_caches()&lt;/code&gt; &lt;/a&gt; 를 호출해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4f0de1719448ed4a63c40279ef044d3f941a85" translate="yes" xml:space="preserve">
          <source>If you are going to create a server that provides SSL-encrypted connection services, you will need to acquire a certificate for that service. There are many ways of acquiring appropriate certificates, such as buying one from a certification authority. Another common practice is to generate a self-signed certificate. The simplest way to do this is with the OpenSSL package, using something like the following:</source>
          <target state="translated">SSL 암호화 연결 서비스를 제공하는 서버를 만들려면 해당 서비스에 대한 인증서를 얻어야합니다. 인증 기관에서 인증서를 구입하는 등 적절한 인증서를 얻는 방법에는 여러 가지가 있습니다. 다른 일반적인 방법은 자체 서명 된 인증서를 생성하는 것입니다. 이를 수행하는 가장 간단한 방법은 다음과 같은 방법을 사용하여 OpenSSL 패키지를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="48d6cd7b9afb257bc9891717d33d65b967870ac6" translate="yes" xml:space="preserve">
          <source>If you are going to require validation of the other side of the connection&amp;rsquo;s certificate, you need to provide a &amp;ldquo;CA certs&amp;rdquo; file, filled with the certificate chains for each issuer you are willing to trust. Again, this file just contains these chains concatenated together. For validation, Python will use the first chain it finds in the file which matches. The platform&amp;rsquo;s certificates file can be used by calling &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt;, this is done automatically with &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결 인증서의 다른쪽에 대한 유효성 검사가 필요한 경우 신뢰할 수있는 각 발급자에 대한 인증서 체인으로 채워진 &quot;CA 인증서&quot;파일을 제공해야합니다. 다시,이 파일에는이 체인들이 함께 연결되어 있습니다. 유효성 검사를 위해 Python은 파일에서 일치하는 첫 번째 체인을 사용합니다. 플랫폼의 인증서 파일은 &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용할 수 있으며 &lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 하여 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f73a6f10ffa7b443163f14e92196bc1fc4490c7" translate="yes" xml:space="preserve">
          <source>If you are implementing a CGI-based handler of your own, you probably want to use this routine instead of just copying values out of &lt;code&gt;os.environ&lt;/code&gt; directly.</source>
          <target state="translated">CGI 기반 핸들러를 직접 구현하는 경우 &lt;code&gt;os.environ&lt;/code&gt; 에서 직접 값을 복사하는 대신이 루틴을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="7b970e3329e89a382ded0086b19b66d215dd892f" translate="yes" xml:space="preserve">
          <source>If you are implementing asynchronous signal handlers using the &lt;a href=&quot;signal#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module, you may not be able to use logging from within such handlers. This is because lock implementations in the &lt;a href=&quot;threading#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; module are not always re-entrant, and so cannot be invoked from such signal handlers.</source>
          <target state="translated">&lt;a href=&quot;signal#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 비동기 신호 핸들러를 구현하는 경우 해당 핸들러 내에서 로깅을 사용하지 못할 수 있습니다. &lt;a href=&quot;threading#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈의 잠금 구현 이 항상 재진입되는 것은 아니므로 이러한 신호 처리기에서 호출 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4f3cb106b921f87d2d40c7d80ff67464e95e3f8e" translate="yes" xml:space="preserve">
          <source>If you are localizing your application, you can install the &lt;code&gt;_()&lt;/code&gt; function globally into the built-in namespace, usually in the main driver file of your application. This will let all your application-specific files just use &lt;code&gt;_('...')&lt;/code&gt; without having to explicitly install it in each file.</source>
          <target state="translated">응용 프로그램을 지역화하는 경우 일반적으로 응용 프로그램의 기본 드라이버 파일에서 기본 제공 네임 스페이스에 &lt;code&gt;_()&lt;/code&gt; 함수를 설치할 수 있습니다 . 이렇게하면 모든 응용 프로그램 별 파일 이 각 파일에 명시 적으로 설치하지 않고도 &lt;code&gt;_('...')&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5e00d28ce108672fa04f99996f53e40842cac4" translate="yes" xml:space="preserve">
          <source>If you are localizing your module, you must take care not to make global changes, e.g. to the built-in namespace. You should not use the GNU &lt;strong&gt;gettext&lt;/strong&gt; API but instead the class-based API.</source>
          <target state="translated">모듈을 지역화하는 경우 내장 네임 스페이스와 같이 전역 적으로 변경되지 않도록주의해야합니다. GNU &lt;strong&gt;gettext&lt;/strong&gt; API 대신 클래스 기반 API를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="11373b731524ebbb3396ed6f424ed35b172c4f94" translate="yes" xml:space="preserve">
          <source>If you are running an entropy-gathering daemon (EGD) somewhere, and &lt;em&gt;path&lt;/em&gt; is the pathname of a socket connection open to it, this will read 256 bytes of randomness from the socket, and add it to the SSL pseudo-random number generator to increase the security of generated secret keys. This is typically only necessary on systems without better sources of randomness.</source>
          <target state="translated">엔트로피 수집 데몬 (EGD)을 어딘가에서 실행 중이고 &lt;em&gt;경로&lt;/em&gt; 가 열려있는 소켓 연결의 경로 이름 인 경우 소켓에서 256 바이트의 임의성을 읽고 SSL 의사 난수 생성기에 추가합니다. 생성 된 비밀 키의 보안을 강화하십시오. 이것은 일반적으로 더 나은 무작위 소스가없는 시스템에서만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5d915c3ac798b1162027d4b78ee74eb32aecf245" translate="yes" xml:space="preserve">
          <source>If you are shipping a Windows executable as described above, you either need to ensure that your users have &lt;code&gt;python3.dll&lt;/code&gt; on their PATH (which is not the default behaviour of the installer) or you should bundle your application with the embedded distribution.</source>
          <target state="translated">위에서 설명한대로 Windows 실행 파일을 제공하는 경우 사용자가 PATH에 &lt;code&gt;python3.dll&lt;/code&gt; 이 있는지 (설치 프로그램의 기본 동작이 아님) 확인해야하거나 응용 프로그램을 포함 된 배포와 함께 번들로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3c30a5d84ebc01f28c65df6e216a65d2921455f" translate="yes" xml:space="preserve">
          <source>If you are thinking of defining your own levels, please see the section on &lt;a href=&quot;https://docs.python.org/3.8/howto/logging.html#custom-levels&quot;&gt;Custom Levels&lt;/a&gt;.</source>
          <target state="translated">자신의 레벨을 정의 할 생각이라면 &lt;a href=&quot;https://docs.python.org/3.8/howto/logging.html#custom-levels&quot;&gt;사용자 정의 레벨&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49e3cbf5ea7b5f0ea71d8bc500fc226c950f1779" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; to create a mock for you then it will be returned by the call to &lt;code&gt;patcher.start&lt;/code&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 가 호출에 의해 반환 될 것이다 당신을위한 모의를 만들 수 &lt;code&gt;patcher.start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="364049631376a2a1d8911fd5401507c7f5516ee6" translate="yes" xml:space="preserve">
          <source>If you are using code that you know will raise a warning, such as a deprecated function, but do not want to see the warning (even when warnings have been explicitly configured via the command line), then it is possible to suppress the warning using the &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; context manager:</source>
          <target state="translated">더 이상 사용되지 않는 기능과 같이 경고를 발생시키는 코드를 사용하고 있지만 경고를 표시하지 않으려는 경우 (명령 줄을 통해 경고가 명시 적으로 구성된 경우에도) 사용하여 경고를 표시하지 않을 수 있습니다 &lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; 의&lt;/a&gt; 컨텍스트 매니저 :</target>
        </trans-unit>
        <trans-unit id="0c3d77e1b4bf3414b19d6e3647400caf29838bae" translate="yes" xml:space="preserve">
          <source>If you are using {}-formatting (&lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt;), you can use &lt;code&gt;{attrname}&lt;/code&gt; as the placeholder in the format string. If you are using $-formatting (&lt;a href=&quot;string#string.Template&quot;&gt;&lt;code&gt;string.Template&lt;/code&gt;&lt;/a&gt;), use the form &lt;code&gt;${attrname}&lt;/code&gt;. In both cases, of course, replace &lt;code&gt;attrname&lt;/code&gt; with the actual attribute name you want to use.</source>
          <target state="translated">{} &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; ( str.format () )를 사용 하는 경우 형식 문자열에서 &lt;code&gt;{attrname}&lt;/code&gt; 을 자리 표시 자로 사용할 수 있습니다 . $ -formatting ( &lt;a href=&quot;string#string.Template&quot;&gt; &lt;code&gt;string.Template&lt;/code&gt; &lt;/a&gt; )을 사용하는 경우 &lt;code&gt;${attrname}&lt;/code&gt; 형식을 사용하십시오 . 두 경우 모두 &lt;code&gt;attrname&lt;/code&gt; 을 사용하려는 실제 속성 이름 으로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="b6c36be2e20c5d0cd71ba05a7b714e1c1aa79df2" translate="yes" xml:space="preserve">
          <source>If you attach a handler to a logger &lt;em&gt;and&lt;/em&gt; one or more of its ancestors, it may emit the same record multiple times. In general, you should not need to attach a handler to more than one logger - if you just attach it to the appropriate logger which is highest in the logger hierarchy, then it will see all events logged by all descendant loggers, provided that their propagate setting is left set to &lt;code&gt;True&lt;/code&gt;. A common scenario is to attach handlers only to the root logger, and to let propagation take care of the rest.</source>
          <target state="translated">처리기를 로거 &lt;em&gt;와&lt;/em&gt; 하나 이상의 조상에 첨부 하면 동일한 레코드를 여러 번 방출 할 수 있습니다. 일반적으로 처리기를 둘 이상의 로거에 첨부 할 필요는 없습니다. 로거 계층 구조에서 가장 높은 적절한 로거에 연결하면 전파되는 경우 모든 하위 로거가 기록한 모든 이벤트가 표시됩니다. 설정은 &lt;code&gt;True&lt;/code&gt; 로 설정되어 있습니다. 일반적인 시나리오는 처리기를 루트 로거에만 연결하고 전파가 나머지를 처리하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71db1cfc049ed9436b58c3258dd2abae66bed7a0" translate="yes" xml:space="preserve">
          <source>If you call getpass from within IDLE, the input may be done in the terminal you launched IDLE from rather than the idle window itself.</source>
          <target state="translated">IDLE 내에서 getpass를 호출하면 유휴 창 자체가 아닌 IDLE을 시작한 터미널에서 입력이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcfe31f0c3025ba1247b84cd55bce06307c9aaab" translate="yes" xml:space="preserve">
          <source>If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; has been set up with a format string which expects &amp;lsquo;clientip&amp;rsquo; and &amp;lsquo;user&amp;rsquo; in the attribute dictionary of the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt;. If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the &lt;em&gt;extra&lt;/em&gt; dictionary with these keys.</source>
          <target state="translated">기록 된 메시지에 이러한 속성을 사용하도록 선택한 경우 약간의주의가 필요합니다. 위의 예에서, 예를 들어, &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 의 속성 사전에서 'clientip'및 'user'를 예상하는 형식 문자열로 설정되었습니다 . 누락 된 경우 문자열 형식화 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서이 경우 항상 이러한 키로 &lt;em&gt;추가&lt;/em&gt; 사전 을 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9a9e4560c049a5fff3d7922f2065fe9c4f0bab32" translate="yes" xml:space="preserve">
          <source>If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; has been set up with a format string which expects &amp;lsquo;clientip&amp;rsquo; and &amp;lsquo;user&amp;rsquo; in the attribute dictionary of the LogRecord. If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the &lt;em&gt;extra&lt;/em&gt; dictionary with these keys.</source>
          <target state="translated">기록 된 메시지에 이러한 속성을 사용하도록 선택한 경우 약간의주의가 필요합니다. 예를 들어, 위의 예에서 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 는 LogRecord의 속성 사전에 'clientip'및 'user'가 필요한 형식 문자열로 설정되었습니다. 누락 된 경우 문자열 형식화 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서이 경우 항상 이러한 키로 &lt;em&gt;추가&lt;/em&gt; 사전 을 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c553bc4df8103396b1cf2c4eb7ef7300e63b8315" translate="yes" xml:space="preserve">
          <source>If you code or decode textfiles on non-Macintosh platforms they will still use the old Macintosh newline convention (carriage-return as end of line).</source>
          <target state="translated">매킨토시가 아닌 플랫폼에서 텍스트 파일을 코딩하거나 디코딩하는 경우 여전히 기존 Macintosh 줄 바꿈 규칙 (캐리지 리턴 행 끝)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d1ed81961b6cb7496a0e0f060cff06cad3d1812" translate="yes" xml:space="preserve">
          <source>If you continue a line via backslashing in an interactive session, or for any other reason use a backslash, you should use a raw docstring, which will preserve your backslashes exactly as you type them:</source>
          <target state="translated">대화식 세션에서 백 슬래시를 통해 줄을 계속하거나 다른 이유로 백 슬래시를 사용하는 경우 원시 문서 문자열을 사용해야합니다. 이렇게하면 입력 한대로 백 슬래시가 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5cac94944ad97618e4be13390591255007102a1f" translate="yes" xml:space="preserve">
          <source>If you create a finalizer object in a daemonic thread just as the program exits then there is the possibility that the finalizer does not get called at exit. However, in a daemonic thread &lt;a href=&quot;atexit#atexit.register&quot;&gt;&lt;code&gt;atexit.register()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;try: ... finally: ...&lt;/code&gt; and &lt;code&gt;with: ...&lt;/code&gt; do not guarantee that cleanup occurs either.</source>
          <target state="translated">프로그램이 종료 될 때 데몬 스레드에서 종료 자 오브젝트를 작성하면 종료시에 종료자가 호출되지 않을 가능성이 있습니다. 그러나 &lt;a href=&quot;atexit#atexit.register&quot;&gt; &lt;code&gt;atexit.register()&lt;/code&gt; &lt;/a&gt; 스레드 atexit.register () 에서 다음을 &lt;code&gt;try: ... finally: ...&lt;/code&gt; 및 &lt;code&gt;with: ...&lt;/code&gt; 는 정리도 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a460562d42a2a11f6a379108a05dfc43f47c1591" translate="yes" xml:space="preserve">
          <source>If you define the &lt;code&gt;WINDOWS&lt;/code&gt; preprocessor symbol, this will generate a GUI executable, and without it, a console executable.</source>
          <target state="translated">&lt;code&gt;WINDOWS&lt;/code&gt; 전 처리기 기호 를 정의하면 GUI 실행 파일과 콘솔 실행 파일없이 GUI 실행 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8d268659c0afbd91ab53443b6a751cff765c3b" translate="yes" xml:space="preserve">
          <source>If you do not want that behavior, preprocess the &lt;em&gt;url&lt;/em&gt; with &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt;&lt;code&gt;urlsplit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.parse.urlunsplit&quot;&gt;&lt;code&gt;urlunsplit()&lt;/code&gt;&lt;/a&gt;, removing possible &lt;em&gt;scheme&lt;/em&gt; and &lt;em&gt;netloc&lt;/em&gt; parts.</source>
          <target state="translated">이 동작을 원하지 않으면 &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt; &lt;code&gt;urlsplit()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.parse.urlunsplit&quot;&gt; &lt;code&gt;urlunsplit()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; URL&lt;/em&gt; 을 사전 처리하여 가능한 &lt;em&gt;구성표&lt;/em&gt; 와 &lt;em&gt;netloc&lt;/em&gt; 부분을 제거하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="75f973cadf33dbb5346b31c20f9455a09e62a539" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know whether a &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; call is required, it probably isn&amp;rsquo;t.</source>
          <target state="translated">&lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 호출이 필요한지 여부를 모르면 필요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e329f1a76521b4e0c106f18d644a53b002a016b" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like the ACW popping up unbidden, simply make the delay longer or disable the extension.</source>
          <target state="translated">ACW 팝업이 마음에 들지 않으면 지연 시간을 늘리거나 확장 프로그램을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="c0b378bb20bf0aa3247056c249ea998b15eb65e8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to store the instance&amp;rsquo;s data in the &lt;code&gt;_as_parameter_&lt;/code&gt; instance variable, you could define a &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; which makes the attribute available on request.</source>
          <target state="translated">&lt;code&gt;_as_parameter_&lt;/code&gt; 인스턴스 변수에 인스턴스 데이터를 저장하지 않으려는 경우 요청시 속성을 사용할 수 있는 &lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a8d040851b0915051f326bd15d54a88ae21e65f" translate="yes" xml:space="preserve">
          <source>If you find that when certain older clients or servers attempt to connect with a &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; created by this function that they get an error stating &amp;ldquo;Protocol or cipher suite mismatch&amp;rdquo;, it may be that they only support SSL3.0 which this function excludes using the &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt;&lt;code&gt;OP_NO_SSLv3&lt;/code&gt;&lt;/a&gt;. SSL3.0 is widely considered to be &lt;a href=&quot;https://en.wikipedia.org/wiki/POODLE&quot;&gt;completely broken&lt;/a&gt;. If you still wish to continue to use this function but still allow SSL 3.0 connections you can re-enable them using:</source>
          <target state="translated">특정 구형 클라이언트 또는 서버 가이 기능으로 생성 된 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 와 연결을 시도 할 때 &quot;프로토콜 또는 암호 제품군 불일치&quot;라는 오류가 발생하면 SSL3.0 만 지원할 수 있습니다. &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt; &lt;code&gt;OP_NO_SSLv3&lt;/code&gt; &lt;/a&gt; . SSL3.0은 &lt;a href=&quot;https://en.wikipedia.org/wiki/POODLE&quot;&gt;완전히 고장난&lt;/a&gt; 것으로 널리 알려져 있습니다 . 여전히이 기능을 계속 사용하지만 여전히 SSL 3.0 연결을 허용하려면 다음을 사용하여 다시 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9aa74952f83bd4d51d51d4e83cebc44b0b2fe0" translate="yes" xml:space="preserve">
          <source>If you give your &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; subclass extra methods, like the &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; class above, those methods will show up in a &lt;a href=&quot;functions#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; of the member, but not of the class:</source>
          <target state="translated">위 의 &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; 클래스 와 같이 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 서브 클래스에 추가 메소드 를 제공하면 해당 메소드는 멤버 의 &lt;a href=&quot;functions#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 에 표시 되지만 클래스에는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddea48c736e63a88242d988d2f93ca78d7b3b84d" translate="yes" xml:space="preserve">
          <source>If you have XML in a string, you can use the &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt;&lt;code&gt;parseString()&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">문자열에 XML이있는 경우 &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt; &lt;code&gt;parseString()&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68b99e8b222c2278454b1cadc38d91ffc4b68997" translate="yes" xml:space="preserve">
          <source>If you have XML in a string, you can use the &lt;a href=&quot;#xml.dom.pulldom.parseString&quot;&gt;&lt;code&gt;parseString()&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">문자열에 XML이있는 경우 &lt;a href=&quot;#xml.dom.pulldom.parseString&quot;&gt; &lt;code&gt;parseString()&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e75dc8b8eb57f89ef2cc0c8f2d61866415c62ce9" translate="yes" xml:space="preserve">
          <source>If you have a choice, you are better off choosing a smaller constant, and then your results will &amp;ldquo;less often&amp;rdquo; show up as negative in profile statistics.</source>
          <target state="translated">선택 사항이 있으면 더 작은 상수를 선택하는 것이 좋습니다. 그러면 결과가 프로파일 통계에서 &quot;덜 자주&quot;부정으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="08f422ccd0761694976f4b7f344ccca267ef692c" translate="yes" xml:space="preserve">
          <source>If you have a package installed globally and attempt test discovery on a different copy of the package then the import &lt;em&gt;could&lt;/em&gt; happen from the wrong place. If this happens test discovery will warn you and exit.</source>
          <target state="translated">패키지가 전체적으로 설치되어 있고 다른 패키지 사본에서 테스트 발견을 시도 하면 잘못된 위치에서 가져 오기 &lt;em&gt;가&lt;/em&gt; 발생할 &lt;em&gt;수&lt;/em&gt; 있습니다. 이 경우 테스트 발견이 경고하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="fdc90a074f4d5efa53ede11d8bcd3da1d1900c9c" translate="yes" xml:space="preserve">
          <source>If you have advanced security requirements, fine-tuning of the ciphers enabled when negotiating a SSL session is possible through the &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt;&lt;/a&gt; method. Starting from Python 3.2.3, the ssl module disables certain weak ciphers by default, but you may want to further restrict the cipher choice. Be sure to read OpenSSL&amp;rsquo;s documentation about the &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;cipher list format&lt;/a&gt;. If you want to check which ciphers are enabled by a given cipher list, use &lt;a href=&quot;#ssl.SSLContext.get_ciphers&quot;&gt;&lt;code&gt;SSLContext.get_ciphers()&lt;/code&gt;&lt;/a&gt; or the &lt;code&gt;openssl ciphers&lt;/code&gt; command on your system.</source>
          <target state="translated">고급 보안 요구 사항이있는 경우 &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 SSL 세션을 협상 할 때 활성화 된 암호를 미세 조정할 수 있습니다 . Python 3.2.3부터 ssl 모듈은 기본적으로 특정 취약한 암호를 비활성화하지만 암호 선택을 추가로 제한 할 수 있습니다. &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;암호 목록 형식&lt;/a&gt; 에 대한 OpenSSL 설명서를 읽으십시오 . 주어진 암호 목록으로 활성화 된 암호를 확인 &lt;code&gt;openssl ciphers&lt;/code&gt; 시스템에서 &lt;a href=&quot;#ssl.SSLContext.get_ciphers&quot;&gt; &lt;code&gt;SSLContext.get_ciphers()&lt;/code&gt; &lt;/a&gt; 또는 openssl ciphers 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f1e86f5dd0e423a473b0f05f43d4240f3be40b1e" translate="yes" xml:space="preserve">
          <source>If you have already calculated the mean of your data, you can pass it as the optional second argument &lt;em&gt;mu&lt;/em&gt; to avoid recalculation:</source>
          <target state="translated">데이터의 평균을 이미 계산 한 경우 재 계산을 피하기 위해 선택적인 두 번째 인수 &lt;em&gt;mu&lt;/em&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f65249585348639b163a15c90fb125aadfb0a99" translate="yes" xml:space="preserve">
          <source>If you have already calculated the mean of your data, you can pass it as the optional second argument &lt;em&gt;xbar&lt;/em&gt; to avoid recalculation:</source>
          <target state="translated">데이터의 평균을 이미 계산 한 경우 재 계산을 피하기 위해 선택적인 두 번째 인수 &lt;em&gt;xbar&lt;/em&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b5f4691daf2771d8fbe481e68889a589550470c" translate="yes" xml:space="preserve">
          <source>If you have an appropriate entry in your &lt;code&gt;turtle.cfg&lt;/code&gt; file this dictionary will be read in at import time and will replace the original English docstrings.</source>
          <target state="translated">&lt;code&gt;turtle.cfg&lt;/code&gt; 파일 에 적절한 항목이 있으면 이 사전을 가져올 때 읽히고 원래 영어 문서 문자열을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0a1e2776fdb2c280f99d04fa6d3f9aadbbdd2668" translate="yes" xml:space="preserve">
          <source>If you have an enum member and need its &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="translated">열거 형 멤버가 있고 &lt;code&gt;name&lt;/code&gt; 이나 &lt;code&gt;value&lt;/code&gt; 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="adddc6c47cf6a214332d2bba1e6dcbb1cf7609c4" translate="yes" xml:space="preserve">
          <source>If you have carried out a lot of deletions and would like to shrink the space used by the &lt;code&gt;gdbm&lt;/code&gt; file, this routine will reorganize the database. &lt;code&gt;gdbm&lt;/code&gt; objects will not shorten the length of a database file except by using this reorganization; otherwise, deleted file space will be kept and reused as new (key, value) pairs are added.</source>
          <target state="translated">많은 삭제를 수행했으며 &lt;code&gt;gdbm&lt;/code&gt; 파일이 사용하는 공간을 줄이려면 이 루틴이 데이터베이스를 재구성합니다. &lt;code&gt;gdbm&lt;/code&gt; 객체는이 재구성을 사용하지 않는 한 데이터베이스 파일의 길이를 줄이지 않습니다. 그렇지 않으면 삭제 된 파일 공간이 유지되고 새 (키, 값) 쌍이 추가 될 때 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3941a6c86792842a0db1694694d8d40f3510d0d" translate="yes" xml:space="preserve">
          <source>If you have defined your own classes which you pass to function calls, you have to implement a &lt;code&gt;from_param()&lt;/code&gt; class method for them to be able to use them in the &lt;code&gt;argtypes&lt;/code&gt; sequence. The &lt;code&gt;from_param()&lt;/code&gt; class method receives the Python object passed to the function call, it should do a typecheck or whatever is needed to make sure this object is acceptable, and then return the object itself, its &lt;code&gt;_as_parameter_&lt;/code&gt; attribute, or whatever you want to pass as the C function argument in this case. Again, the result should be an integer, string, bytes, a &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; instance, or an object with an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute.</source>
          <target state="translated">함수 호출에 전달할 자체 클래스를 정의한 경우 해당 &lt;code&gt;from_param()&lt;/code&gt; &lt;code&gt;argtypes&lt;/code&gt; 시퀀스 에서 사용할 수 있도록 from_param () 클래스 메소드 를 구현해야합니다 . &lt;code&gt;from_param()&lt;/code&gt; 클래스 메소드는이 유형 체킹을 수행해야합니다, 함수 호출에 전달 된 파이썬 객체를 수신하거나 확인이 객체가 허용되어 있는지 확인하고 개체 자체, 그것의 반환에 필요한 무엇이든 &lt;code&gt;_as_parameter_&lt;/code&gt; 의 당신이 전달하려는 어떤 속성, 또는 이 경우 C 함수 인수로. 다시, 결과는 정수, 문자열, 바이트, &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 &lt;code&gt;_as_parameter_&lt;/code&gt; 속성을 가진 객체 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="c7ba5f87f67362e164e00c45234b25b88116bc45" translate="yes" xml:space="preserve">
          <source>If you have positional arguments that must begin with &lt;code&gt;-&lt;/code&gt; and don&amp;rsquo;t look like negative numbers, you can insert the pseudo-argument &lt;code&gt;'--'&lt;/code&gt; which tells &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; that everything after that is a positional argument:</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 로 시작해야하는 위치 인수가 있고 음수로 보이지 않으면 의사 인수 &lt;code&gt;'--'&lt;/code&gt; 를 삽입하면 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 에게 그 이후의 모든 것이 위치 인수임을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ad6fc06b4f04b51136dd86e77cdf44c2345475" translate="yes" xml:space="preserve">
          <source>If you instantiate any of these types, note that signatures may vary between Python versions.</source>
          <target state="translated">이러한 유형을 인스턴스화하는 경우 서명은 Python 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ee2c99f3c1ce008b2482f9a4bd039eac988eb85" translate="yes" xml:space="preserve">
          <source>If you merely want to attach a time zone object &lt;em&gt;tz&lt;/em&gt; to a datetime &lt;em&gt;dt&lt;/em&gt; without adjustment of date and time data, use &lt;code&gt;dt.replace(tzinfo=tz)&lt;/code&gt;. If you merely want to remove the time zone object from an aware datetime &lt;em&gt;dt&lt;/em&gt; without conversion of date and time data, use &lt;code&gt;dt.replace(tzinfo=None)&lt;/code&gt;.</source>
          <target state="translated">날짜 및 시간 데이터를 조정하지 않고 시간대 오브젝트 &lt;em&gt;tz&lt;/em&gt; 를 날짜 / 시간 &lt;em&gt;dt&lt;/em&gt; 에 첨부하려는 경우 &lt;code&gt;dt.replace(tzinfo=tz)&lt;/code&gt; . 날짜 및 시간 데이터를 변환하지 않고 인식 가능한 날짜 시간 &lt;em&gt;dt&lt;/em&gt; 에서 시간대 오브젝트를 제거하려는 경우 &lt;code&gt;dt.replace(tzinfo=None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6c75c360131321b14d956646dcffde70eca5a7" translate="yes" xml:space="preserve">
          <source>If you need a fully populated element, look for &amp;ldquo;end&amp;rdquo; events instead.</source>
          <target state="translated">완전히 채워진 요소가 필요한 경우 대신 &quot;종료&quot;이벤트를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="86368d19f69c93150072272046943f1484ff2526" translate="yes" xml:space="preserve">
          <source>If you need to find out if a module can be imported without actually doing the import, then you should use &lt;a href=&quot;#importlib.util.find_spec&quot;&gt;&lt;code&gt;importlib.util.find_spec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">실제로 가져 오기를 수행하지 않고 모듈을 가져올 수 있는지 확인해야하는 경우 &lt;a href=&quot;#importlib.util.find_spec&quot;&gt; &lt;code&gt;importlib.util.find_spec()&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4101124fa4b09fc6cc1ef68bc64b034b218ec7e6" translate="yes" xml:space="preserve">
          <source>If you need to free memory, for example, allocated by an extension module with a call to the &lt;code&gt;free(void *)&lt;/code&gt;, it is important that you use the function in the same library that allocated the memory.</source>
          <target state="translated">예를 들어, &lt;code&gt;free(void *)&lt;/code&gt; 호출하여 확장 모듈에 의해 할당 된 메모리를 비워야하는 경우 메모리를 할당 한 동일한 라이브러리에서 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca61f6332d6d58306dfe4cd895fbd3ec252e9fa" translate="yes" xml:space="preserve">
          <source>If you need to know if a class is an instance of a dataclass (and not a dataclass itself), then add a further check for &lt;code&gt;not
isinstance(obj, type)&lt;/code&gt;:</source>
          <target state="translated">클래스가 데이터 클래스 자체가 아닌 데이터 클래스의 인스턴스인지 알아야하는 경우 &lt;code&gt;not isinstance(obj, type)&lt;/code&gt; 여부에 대한 추가 검사를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fbb0aa423003d7733fbd8694a32a308d63c2747" translate="yes" xml:space="preserve">
          <source>If you need to load modules from a directory which is not on Python&amp;rsquo;s default module search path, you can change the path in your script, before importing other modules. For example:</source>
          <target state="translated">Python의 기본 모듈 검색 경로에없는 디렉토리에서 모듈을로드해야하는 경우 다른 모듈을 가져 오기 전에 스크립트에서 경로를 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cf32b7cc15737ca5c3f1bc7291a3230ef00b4ed" translate="yes" xml:space="preserve">
          <source>If you need to make more significant changes to rotation processing, you can override the methods.</source>
          <target state="translated">회전 처리를보다 크게 변경해야하는 경우 메서드를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d96003b130e0abd7634352c365ff1181febdd21c" translate="yes" xml:space="preserve">
          <source>If you need to modify the environment for the child use the &lt;em&gt;env&lt;/em&gt; parameter rather than doing it in a &lt;em&gt;preexec_fn&lt;/em&gt;. The &lt;em&gt;start_new_session&lt;/em&gt; parameter can take the place of a previously common use of &lt;em&gt;preexec_fn&lt;/em&gt; to call os.setsid() in the child.</source>
          <target state="translated">하위 환경을 수정해야하는 경우 , &lt;em&gt;preexec_fn&lt;/em&gt; 에서 &lt;em&gt;env&lt;/em&gt; 매개 변수를 사용하지 말고 &lt;em&gt;env&lt;/em&gt; 매개 변수를 사용하십시오 . &lt;em&gt;start_new_session의&lt;/em&gt; 매개 변수의 이전에 일반적인 사용의 장소 걸릴 수 &lt;em&gt;preexec_fn을&lt;/em&gt; 아이에 () os.setsid 전화.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f304fd08cfd78b8854b1fd29f66f112cd5c13e1e" translate="yes" xml:space="preserve">
          <source>If you need to set the locale directory, you can pass it into the &lt;a href=&quot;#gettext.install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">로케일 디렉토리를 설정해야하는 경우 &lt;a href=&quot;#gettext.install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 함수 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="989b83d5f423a04c98cf18328ded12c8c1f9993b" translate="yes" xml:space="preserve">
          <source>If you pass a relative pathname, don&amp;rsquo;t change the current working directory between resumptions of &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; never changes the current directory, and assumes that its caller doesn&amp;rsquo;t either.</source>
          <target state="translated">상대 경로 이름을 전달하면 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 재개간에 현재 작업 디렉토리를 변경하지 마십시오 . &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 는 현재 디렉토리를 변경하지 않으며 호출자도 마찬가지라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="14e992d9d4752d16d4f2db4c0441e7739cd4616d" translate="yes" xml:space="preserve">
          <source>If you pass in a file-like object, the wave object will not close it when its &lt;code&gt;close()&lt;/code&gt; method is called; it is the caller&amp;rsquo;s responsibility to close the file object.</source>
          <target state="translated">파일과 같은 객체를 전달하면, &lt;code&gt;close()&lt;/code&gt; 메소드가 호출 될 때 웨이브 객체가이를 닫지 않습니다 . 파일 객체를 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="bce6fbed23eb5dcd1301360b71b6c428b6101471" translate="yes" xml:space="preserve">
          <source>If you pass in a function it will be called with same arguments as the mock and unless the function returns the &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; singleton the call to the mock will then return whatever the function returns. If the function returns &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; then the mock will return its normal value (from the &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt;&lt;code&gt;return_value&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수를 전달하면 mock과 동일한 인수로 호출되며 함수가 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 싱글 톤을 반환하지 않으면 mock에 대한 호출은 함수가 반환하는 모든 것을 반환합니다. 함수가 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 를 반환 하면 모의는 정상 값을 반환합니다 ( &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt; &lt;code&gt;return_value&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a5bcec43963bc6522bf0a067657c871d04e72c94" translate="yes" xml:space="preserve">
          <source>If you pass in an iterable, it is used to retrieve an iterator which must yield a value on every call. This value can either be an exception instance to be raised, or a value to be returned from the call to the mock (&lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; handling is identical to the function case).</source>
          <target state="translated">iterable을 전달하면 모든 호출에서 값을 산출해야하는 반복자를 검색하는 데 사용됩니다. 이 값은 예외 인스턴스가 발생하거나 모의 호출에서 반환되는 값일 수 있습니다 ( &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 처리는 함수 경우와 동일).</target>
        </trans-unit>
        <trans-unit id="e8f98dd86ae9edd376ec292daf25469e857090bc" translate="yes" xml:space="preserve">
          <source>If you prefer to tune security settings yourself, you might create a context from scratch (but beware that you might not get the settings right):</source>
          <target state="translated">보안 설정을 직접 조정하려면 컨텍스트를 처음부터 새로 작성해야합니다 (그러나 설정이 올바르지 않을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="13d9f70eafdbcb60562762894f8800d86df24ae3" translate="yes" xml:space="preserve">
          <source>If you ran the process with &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt;, stdout and stderr will be combined in this attribute, and &lt;a href=&quot;#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt; 으로 프로세스를 실행 한 경우 stdout 및 stderr이이 속성에 결합되고 &lt;a href=&quot;#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="097c1b21b4dc383068accbc4c009da7628ba1b98" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;example.py&lt;/code&gt; directly from the command line, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; works its magic:</source>
          <target state="translated">명령 행에서 &lt;code&gt;example.py&lt;/code&gt; 를 직접 실행하면 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 그 마법을 작동 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4f231c383bc8b650abcdc023f68a52b9b627363e" translate="yes" xml:space="preserve">
          <source>If you set e.g. &lt;code&gt;language = italian&lt;/code&gt; the docstringdict &lt;code&gt;turtle_docstringdict_italian.py&lt;/code&gt; will be loaded at import time (if present on the import path, e.g. in the same directory as &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;language = italian&lt;/code&gt; 을 설정 하면 docstringdict &lt;code&gt;turtle_docstringdict_italian.py&lt;/code&gt; 는 가져 오기시에로드됩니다 (예 : 가져 오기 경로에있는 경우 (예 : &lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; ))&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f9ca74752ebe3e1cde63708838074a0ef64b8ab" translate="yes" xml:space="preserve">
          <source>If you simply want to import a module (potentially within a package) by name, use &lt;a href=&quot;importlib#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름으로 모듈 (잠재적으로 패키지 내)을 가져 오려면 &lt;a href=&quot;importlib#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadedf4eaab1c80ba2f6a6ef7e45a206594d656a" translate="yes" xml:space="preserve">
          <source>If you somehow know the actual population mean &amp;mu; you should pass it to the &lt;a href=&quot;#statistics.pvariance&quot;&gt;&lt;code&gt;pvariance()&lt;/code&gt;&lt;/a&gt; function as the &lt;em&gt;mu&lt;/em&gt; parameter to get the variance of a sample.</source>
          <target state="translated">실제 모집단 평균 &amp;mu;를 어떻게 든 알고 있다면이를 &lt;a href=&quot;#statistics.pvariance&quot;&gt; &lt;code&gt;pvariance()&lt;/code&gt; &lt;/a&gt; 함수에 &lt;em&gt;mu&lt;/em&gt; 매개 변수로 전달하여 표본의 분산을 구해야합니다.</target>
        </trans-unit>
        <trans-unit id="6158aab4724beaceaa6e79b29d9be8382f2e23f9" translate="yes" xml:space="preserve">
          <source>If you somehow know the true population mean &amp;mu;, you may use this function to calculate the variance of a sample, giving the known population mean as the second argument. Provided the data points are a random sample of the population, the result will be an unbiased estimate of the population variance.</source>
          <target state="translated">실제 모집단 평균 &amp;mu;를 어떻게 든 알고 있다면이 함수를 사용하여 표본의 분산을 계산하여 알려진 모집단 평균을 두 번째 인수로 지정할 수 있습니다. 데이터 점이 모집단의 랜덤 표본 인 경우 결과는 모집단 분산의 편견 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="c10de555c4449d7964f6af5647d563052cabd068" translate="yes" xml:space="preserve">
          <source>If you supply the start directory as a package name rather than a path to a directory then discover assumes that whichever location it imports from is the location you intended, so you will not get the warning.</source>
          <target state="translated">디렉토리에 대한 경로가 아닌 패키지 이름으로 시작 디렉토리를 제공하는 경우, 감지 할 디렉토리가 가져 오는 위치가 의도 한 위치라고 가정하므로 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc2a6c7429466d8bb8a989fdc7ce4cc694cd926" translate="yes" xml:space="preserve">
          <source>If you suspect that there may be a problem in importing the &lt;a href=&quot;cgitb#module-cgitb&quot;&gt;&lt;code&gt;cgitb&lt;/code&gt;&lt;/a&gt; module, you can use an even more robust approach (which only uses built-in modules):</source>
          <target state="translated">&lt;a href=&quot;cgitb#module-cgitb&quot;&gt; &lt;code&gt;cgitb&lt;/code&gt; &lt;/a&gt; 모듈 을 가져 오는 데 문제가 있다고 생각되면 보다 강력한 접근 방식 (내장 모듈 만 사용)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50de709429c8c96a2fb6b6fdf0e8b44acd7d7e0a" translate="yes" xml:space="preserve">
          <source>If you use &amp;ldquo;/usr/bin/env python&amp;rdquo; (or other forms of the &amp;ldquo;python&amp;rdquo; command, such as &amp;ldquo;/usr/bin/python&amp;rdquo;), you need to consider that your users may have either Python 2 or Python 3 as their default, and write your code to work under both versions.</source>
          <target state="translated">&quot;/ usr / bin / env python&quot;(또는 &quot;/ usr / bin / python&quot;과 같은 다른 형태의 &quot;python&quot;명령)을 사용하는 경우 사용자에게 Python 2 또는 Python 3이있을 수 있음을 고려해야합니다 기본값으로 사용하고 두 버전에서 작동하도록 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3327948dd8642cd268b3754e1a2f4b14a2babf7c" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;#multiprocessing.JoinableQueue&quot;&gt;&lt;code&gt;JoinableQueue&lt;/code&gt;&lt;/a&gt; then you &lt;strong&gt;must&lt;/strong&gt; call &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;JoinableQueue.task_done()&lt;/code&gt;&lt;/a&gt; for each task removed from the queue or else the semaphore used to count the number of unfinished tasks may eventually overflow, raising an exception.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.JoinableQueue&quot;&gt; &lt;code&gt;JoinableQueue&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 대기열에서 제거 된 각 작업에 대해 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;JoinableQueue.task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 &lt;strong&gt;해야합니다.&lt;/strong&gt; 그렇지 않으면 완료되지 않은 작업 수를 계산하는 데 사용되는 세마포어가 오버플로되어 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f4f2a66699a6ccb9a802c6a128aa2a5c76c7e61" translate="yes" xml:space="preserve">
          <source>If you use &lt;em&gt;editline&lt;/em&gt;/&lt;code&gt;libedit&lt;/code&gt; readline emulation on macOS, the initialization file located in your home directory is named &lt;code&gt;.editrc&lt;/code&gt;. For example, the following content in &lt;code&gt;~/.editrc&lt;/code&gt; will turn ON &lt;em&gt;vi&lt;/em&gt; keybindings and TAB completion:</source>
          <target state="translated">macOS에서 &lt;em&gt;editline&lt;/em&gt; / &lt;code&gt;libedit&lt;/code&gt; readline 에뮬레이션 을 사용하는 경우 홈 디렉토리에있는 초기화 파일의 이름은 &lt;code&gt;.editrc&lt;/code&gt; 입니다. 예를 들어,에서 다음과 같은 내용 &lt;code&gt;~/.editrc&lt;/code&gt; 가 ON으로 바뀝니다 &lt;em&gt;VI&lt;/em&gt; 키 바인딩 및 TAB 완료 :</target>
        </trans-unit>
        <trans-unit id="c3d4a93e13f71d80556de33a53d4ec361fe070d9" translate="yes" xml:space="preserve">
          <source>If you use &lt;em&gt;spec&lt;/em&gt; or &lt;em&gt;spec_set&lt;/em&gt; and &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is replacing a &lt;em&gt;class&lt;/em&gt;, then the return value of the created mock will have the same spec.</source>
          <target state="translated">&lt;em&gt;spec&lt;/em&gt; 또는 &lt;em&gt;spec_set&lt;/em&gt; 을 사용 하고 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;class를&lt;/em&gt; 바꾸면 작성된 모의 반환 값은 동일한 스펙을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="514f9487f7b2350c961e01f947173c311579e162" translate="yes" xml:space="preserve">
          <source>If you use a hostname in the &lt;em&gt;host&lt;/em&gt; portion of IPv4/v6 socket address, the program may show a nondeterministic behavior, as Python uses the first address returned from the DNS resolution. The socket address will be resolved differently into an actual IPv4/v6 address, depending on the results from DNS resolution and/or the host configuration. For deterministic behavior use a numeric address in &lt;em&gt;host&lt;/em&gt; portion.</source>
          <target state="translated">IPv4 / v6 소켓 주소 의 &lt;em&gt;호스트&lt;/em&gt; 부분 에서 &lt;em&gt;호스트&lt;/em&gt; 이름을 사용하는 경우 Python에서 DNS 확인에서 반환 된 첫 번째 주소를 사용하므로 프로그램에 비 결정적 동작이 표시 될 수 있습니다. 소켓 주소는 DNS 확인 결과 및 / 또는 호스트 구성 결과에 따라 실제 IPv4 / v6 주소로 다르게 해석됩니다. 결정적인 동작을 위해서는 &lt;em&gt;호스트&lt;/em&gt; 부분에 숫자 주소를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="96ea7b1cf88562cf80e633c2b1c94203e479e327" translate="yes" xml:space="preserve">
          <source>If you use an explicit version, for example &amp;ldquo;/usr/bin/env python3&amp;rdquo; your application will not work for users who do not have that version. (This may be what you want if you have not made your code Python 2 compatible).</source>
          <target state="translated">&quot;/ usr / bin / env python3&quot;과 같은 명시 적 버전을 사용하는 경우 해당 버전이없는 사용자에게는 응용 프로그램이 작동하지 않습니다. (이 코드를 Python 2 호환으로 만들지 않은 경우 원하는 것일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="6997de2e41b96b52ebe4782063e52556ff05a848" translate="yes" xml:space="preserve">
          <source>If you use the &amp;lsquo;silent&amp;rsquo; command in the command list, the usual message about stopping at a breakpoint is not printed. This may be desirable for breakpoints that are to print a specific message and then continue. If none of the other commands print anything, you see no sign that the breakpoint was reached.</source>
          <target state="translated">명령 목록에서 'silent'명령을 사용하면 중단 점에서 중지하는 데 대한 일반적인 메시지가 인쇄되지 않습니다. 특정 메시지를 인쇄 한 다음 계속해야하는 중단 점에 바람직 할 수 있습니다. 다른 명령으로 아무것도 인쇄하지 않으면 중단 점에 도달했다는 신호가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f69dd2dd959b985277dcf16e4c5303ee3dde0861" translate="yes" xml:space="preserve">
          <source>If you use the &lt;em&gt;spec&lt;/em&gt; keyword argument to create a mock then attempting to set a magic method that isn&amp;rsquo;t in the spec will raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;em&gt;사양&lt;/em&gt; 모의를 만들 키워드 인수를 다음 올릴 사양에없는 마법의 방법을 설정하려고 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="353ad31e4d774964063f5b58ea1776698ab8f303" translate="yes" xml:space="preserve">
          <source>If you use the &lt;em&gt;spec&lt;/em&gt; or &lt;em&gt;spec_set&lt;/em&gt; arguments then &lt;em&gt;only&lt;/em&gt; magic methods that exist in the spec will be created.</source>
          <target state="translated">&lt;em&gt;spec&lt;/em&gt; 또는 &lt;em&gt;spec_set&lt;/em&gt; 인수를 사용하면 &lt;em&gt;스펙&lt;/em&gt; 에 존재하는 마술 메소드 &lt;em&gt;만&lt;/em&gt; 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3be1784a6b9e18d186acdce6908f38010e51c9ef" translate="yes" xml:space="preserve">
          <source>If you use the ADPCM coder to build network packets and you want your protocol to be stateless (i.e. to be able to tolerate packet loss) you should not only transmit the data but also the state. Note that you should send the &lt;em&gt;initial&lt;/em&gt; state (the one you passed to &lt;a href=&quot;#audioop.lin2adpcm&quot;&gt;&lt;code&gt;lin2adpcm()&lt;/code&gt;&lt;/a&gt;) along to the decoder, not the final state (as returned by the coder). If you want to use &lt;a href=&quot;struct#struct.Struct&quot;&gt;&lt;code&gt;struct.Struct&lt;/code&gt;&lt;/a&gt; to store the state in binary you can code the first element (the predicted value) in 16 bits and the second (the delta index) in 8.</source>
          <target state="translated">ADPCM 코더를 사용하여 네트워크 패킷을 작성하고 프로토콜이 상태 비 저장 (즉, 패킷 손실을 허용 할 수 있도록)을 원하면 데이터뿐만 아니라 상태도 전송해야합니다. 당신이 보내는 것을 참고 &lt;em&gt;초기&lt;/em&gt; (당신이 전달 된 하나의 상태 &lt;a href=&quot;#audioop.lin2adpcm&quot;&gt; &lt;code&gt;lin2adpcm()&lt;/code&gt; &lt;/a&gt; ) 디코더,하지 (코더에 의해 반환) 최종 상태에 따라. 사용할 경우 &lt;a href=&quot;struct#struct.Struct&quot;&gt; &lt;code&gt;struct.Struct&lt;/code&gt; 을&lt;/a&gt; 이진 상태를 저장하는 경우 16 비트의 첫 번째 요소 (예측치)와 8 번째 (델타 인덱스)를 부호화 할 수있다.</target>
        </trans-unit>
        <trans-unit id="9c83d7f1f379ed7a6cf04574d6c921d79a111100" translate="yes" xml:space="preserve">
          <source>If you use this technique you must ensure that the patching is &amp;ldquo;undone&amp;rdquo; by calling &lt;code&gt;stop&lt;/code&gt;. This can be fiddlier than you might think, because if an exception is raised in the &lt;code&gt;setUp&lt;/code&gt; then &lt;code&gt;tearDown&lt;/code&gt; is not called. &lt;a href=&quot;unittest#unittest.TestCase.addCleanup&quot;&gt;&lt;code&gt;unittest.TestCase.addCleanup()&lt;/code&gt;&lt;/a&gt; makes this easier:</source>
          <target state="translated">이 기술을 사용하는 경우 &lt;code&gt;stop&lt;/code&gt; 을 호출하여 패치가 &quot;실행 취소&quot;되었는지 확인해야합니다 . 예외가 제기되는 경우 때문에, 당신이 생각하는 것보다 fiddlier 수 있습니다 &lt;code&gt;setUp&lt;/code&gt; 다음 &lt;code&gt;tearDown&lt;/code&gt; 호출되지 않습니다. &lt;a href=&quot;unittest#unittest.TestCase.addCleanup&quot;&gt; &lt;code&gt;unittest.TestCase.addCleanup()&lt;/code&gt; &lt;/a&gt; 은 이것을 쉽게 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="75bf0749f0dd727a13fcc6a835a82d9cd272d1fc" translate="yes" xml:space="preserve">
          <source>If you want &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; to create mocks for you, then you can use &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; as the value. If you use &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; as a decorator then the created mocks are passed into the decorated function by keyword.</source>
          <target state="translated">당신이 원하는 경우 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 당신을위한 모의 객체를 생성하기를, 당신은 사용할 수있는 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 값으로. 당신이 사용하는 경우 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 데코레이터로 다음 생성 된 모의 객체는 키워드로 장식 된 함수에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6a385ee3f431c0cf8aa5476eab766bc532450fe5" translate="yes" xml:space="preserve">
          <source>If you want a given &lt;em&gt;stdin&lt;/em&gt; to be used, make sure to set the instance&amp;rsquo;s &lt;a href=&quot;#cmd.Cmd.use_rawinput&quot;&gt;&lt;code&gt;use_rawinput&lt;/code&gt;&lt;/a&gt; attribute to &lt;code&gt;False&lt;/code&gt;, otherwise &lt;em&gt;stdin&lt;/em&gt; will be ignored.</source>
          <target state="translated">지정된 &lt;em&gt;stdin&lt;/em&gt; 을 사용하려면 인스턴스의 &lt;a href=&quot;#cmd.Cmd.use_rawinput&quot;&gt; &lt;code&gt;use_rawinput&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;False&lt;/code&gt; 로 설정해야합니다 . 그렇지 않으면 &lt;em&gt;stdin&lt;/em&gt; 이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bcf54413bb963aa019597f5acad81401f292e6" translate="yes" xml:space="preserve">
          <source>If you want cross-platform overwriting of the destination, use &lt;a href=&quot;#os.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대상을 크로스 플랫폼으로 덮어 쓰려면 &lt;a href=&quot;#os.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a129089344fee48b88396b82f4d19b77ca7fc4d" translate="yes" xml:space="preserve">
          <source>If you want more functionality, you&amp;rsquo;re going to have to read the manual, or guess what the following functions do:</source>
          <target state="translated">더 많은 기능을 원하면 매뉴얼을 읽거나 다음 기능이 무엇인지 추측해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ae975db4dc6412041430b1daafaa6c1c0e31b5d" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;setUpClass&lt;/code&gt; and &lt;code&gt;tearDownClass&lt;/code&gt; on base classes called then you must call up to them yourself. The implementations in &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; are empty.</source>
          <target state="translated">호출 된 기본 클래스 에서 &lt;code&gt;setUpClass&lt;/code&gt; 및 &lt;code&gt;tearDownClass&lt;/code&gt; 를 원하는 경우 직접 호출해야합니다. &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 의 구현 이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fc69a19f6a319eafed02a83645ae1ec1683cb6c" translate="yes" xml:space="preserve">
          <source>If you want the adler32 or crc32 hash functions, they are available in the &lt;a href=&quot;zlib#module-zlib&quot;&gt;&lt;code&gt;zlib&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">adler32 또는 crc32 해시 함수를 원하는 경우 &lt;a href=&quot;zlib#module-zlib&quot;&gt; &lt;code&gt;zlib&lt;/code&gt; &lt;/a&gt; 모듈 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cc2b2701ce617852e01ad2fdbb4d98e0e062510" translate="yes" xml:space="preserve">
          <source>If you want the mock to still return the default return value (a new mock), or any set return value, then there are two ways of doing this. Either return &lt;code&gt;mock.return_value&lt;/code&gt; from inside &lt;code&gt;side_effect&lt;/code&gt;, or return &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">mock이 여전히 기본 반환 값 (새로운 mock) 또는 설정된 반환 값을 반환하도록하려면 두 가지 방법이 있습니다. 어느 반환 &lt;code&gt;mock.return_value&lt;/code&gt; 내부에서 &lt;code&gt;side_effect&lt;/code&gt; , 또는 반환 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c2e7b29010c2bd4bd3a7b2186800720ade7653a7" translate="yes" xml:space="preserve">
          <source>If you want to access enum members by &lt;em&gt;name&lt;/em&gt;, use item access:</source>
          <target state="translated">&lt;em&gt;name으로&lt;/em&gt; 열거 형 멤버에 액세스하려면 항목 액세스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c2d72cb023b23999d092f07ff8849d8edf000d1" translate="yes" xml:space="preserve">
          <source>If you want to avoid the &lt;code&gt;ord(&quot;x&quot;)&lt;/code&gt; calls above, you can set the &lt;code&gt;argtypes&lt;/code&gt; attribute, and the second argument will be converted from a single character Python bytes object into a C char:</source>
          <target state="translated">위의 &lt;code&gt;ord(&quot;x&quot;)&lt;/code&gt; 호출 을 피하려면 &lt;code&gt;argtypes&lt;/code&gt; 속성을 설정 하면 두 번째 인수가 단일 문자 Python bytes 객체에서 C 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="279c29c89aa9656f84b48678016178fbd67cb71c" translate="yes" xml:space="preserve">
          <source>If you want to change how current time is determined (for example, to force use of wall-clock time or elapsed process time), pass the timing function you want to the &lt;code&gt;Profile&lt;/code&gt; class constructor:</source>
          <target state="translated">현재 시간을 결정하는 방법을 변경하려면 (예 : 벽시계 시간 또는 경과 된 프로세스 시간 사용) &lt;code&gt;Profile&lt;/code&gt; 클래스 생성자 에게 원하는 타이밍 함수를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="73a589407368c78ec530e2f941e80cc64760ae2f" translate="yes" xml:space="preserve">
          <source>If you want to clear any previously installed progress handler, call the method with &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;handler&lt;/em&gt;.</source>
          <target state="translated">당신이 이전에 설치된 진행 핸들러를 취소하려는 경우와 메서드를 호출 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;em&gt;처리기를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b85687d6933b3a0fe36fbb7a49d525fedab74695" translate="yes" xml:space="preserve">
          <source>If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways:</source>
          <target state="translated">정수를 접두사를 사용하여 대문자 또는 하위 16 진 문자열로 변환하려면 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="555dbff41f37109f588fa5abd198ada8e8af5c33" translate="yes" xml:space="preserve">
          <source>If you want to convert an integer number to octal string either with prefix &amp;ldquo;0o&amp;rdquo; or not, you can use either of the following ways.</source>
          <target state="translated">접두사&amp;ldquo;0o&amp;rdquo;를 사용하여 정수를 8 진수 문자열로 변환하려는 경우 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7e395a436c737fb4f983babcb85c37f7ffba2a" translate="yes" xml:space="preserve">
          <source>If you want to create a memory-mapping for a writable, buffered file, you should &lt;a href=&quot;io#io.IOBase.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; the file first. This is necessary to ensure that local modifications to the buffers are actually available to the mapping.</source>
          <target state="translated">쓰기 가능하고 버퍼링 된 파일에 대한 메모리 매핑을 만들려면 먼저 파일을 &lt;a href=&quot;io#io.IOBase.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 해야합니다. 이는 버퍼에 대한 로컬 수정이 실제로 맵핑에 사용 가능하도록하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8c96548f19f99190ded12d511ae463febe2b5258" translate="yes" xml:space="preserve">
          <source>If you want to create a new ZIP archive, specify its name after the &lt;a href=&quot;#cmdoption-zipfile-c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option and then list the filename(s) that should be included:</source>
          <target state="translated">새 ZIP 아카이브를 작성하려면 &lt;a href=&quot;#cmdoption-zipfile-c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 옵션 뒤에 이름을 지정한 다음 포함해야하는 파일 이름을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b106ae412fab326b87e70a6ef024d49bf607babb" translate="yes" xml:space="preserve">
          <source>If you want to create a new tar archive, specify its name after the &lt;a href=&quot;#cmdoption-tarfile-c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option and then list the filename(s) that should be included:</source>
          <target state="translated">새 tar 아카이브를 작성하려면 &lt;a href=&quot;#cmdoption-tarfile-c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 옵션 뒤에 이름을 지정한 다음 포함해야하는 파일 이름을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="7c1a46617f45e12138983a57722199d3eb708a28" translate="yes" xml:space="preserve">
          <source>If you want to extract a ZIP archive into the specified directory, use the &lt;a href=&quot;#cmdoption-zipfile-e&quot;&gt;&lt;code&gt;-e&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">ZIP 아카이브를 지정된 디렉토리로 추출하려면 &lt;a href=&quot;#cmdoption-zipfile-e&quot;&gt; &lt;code&gt;-e&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="700b384e128d1fbde8cf4400e885f3cf8732d78d" translate="yes" xml:space="preserve">
          <source>If you want to extract a tar archive into the current directory, use the &lt;a href=&quot;#cmdoption-tarfile-e&quot;&gt;&lt;code&gt;-e&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">tar 아카이브를 현재 디렉토리로 추출하려면 &lt;a href=&quot;#cmdoption-tarfile-e&quot;&gt; &lt;code&gt;-e&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="58588189cff4519d00d0897d652e2f735d514b04" translate="yes" xml:space="preserve">
          <source>If you want to include non-ASCII characters in your email headers, say in the &lt;em&gt;Subject&lt;/em&gt; or &lt;em&gt;To&lt;/em&gt; fields, you should use the &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; class and assign the field in the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; object to an instance of &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; instead of using a string for the header value. Import the &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; class from the &lt;a href=&quot;#module-email.header&quot;&gt;&lt;code&gt;email.header&lt;/code&gt;&lt;/a&gt; module. For example:</source>
          <target state="translated">&lt;em&gt;제목&lt;/em&gt; 또는받는 &lt;em&gt;사람&lt;/em&gt; 필드 와 같이 전자 메일 헤더에 ASCII가 아닌 문자를 포함 시키 &lt;em&gt;려면 &lt;/em&gt;&lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 클래스 를 사용하고 헤더 값에 문자열을 사용하는 대신 &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 의 인스턴스에 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체 의 필드를 할당해야합니다 . &lt;a href=&quot;#module-email.header&quot;&gt; &lt;code&gt;email.header&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 클래스를 가져 오십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24ec3c78c55c3f145a14ab40bbeb1ab84cc85d19" translate="yes" xml:space="preserve">
          <source>If you want to keep the frame around (for example to print a traceback later), you can also break reference cycles by using the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame.clear&quot;&gt;&lt;code&gt;frame.clear()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">프레임을 유지하려면 (예 : 나중에 역 추적 인쇄) &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame.clear&quot;&gt; &lt;code&gt;frame.clear()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 참조주기를 중단 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6549b472b422a2e03ce43ff8ed3f5196f818e1c" translate="yes" xml:space="preserve">
          <source>If you want to know how to change the first sequence into the second, use &lt;code&gt;get_opcodes()&lt;/code&gt;:</source>
          <target state="translated">첫 번째 시퀀스를 두 번째 시퀀스로 변경하는 방법을 알고 싶다면 &lt;code&gt;get_opcodes()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd6b6c79b6bb6752c1926957d748425869a9d94e" translate="yes" xml:space="preserve">
          <source>If you want to locate a match anywhere in &lt;em&gt;string&lt;/em&gt;, use &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; instead (see also &lt;a href=&quot;#search-vs-match&quot;&gt;search() vs. match()&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;string&lt;/em&gt; 어디에서나 일치하는 위치를 찾으려면 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 &lt;a href=&quot;#search-vs-match&quot;&gt;(search () vs. match () 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="90b7dc5b7c7d64eb5dcf8c64af54da317f615167" translate="yes" xml:space="preserve">
          <source>If you want to locate a match anywhere in &lt;em&gt;string&lt;/em&gt;, use &lt;a href=&quot;#re.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; instead (see also &lt;a href=&quot;#search-vs-match&quot;&gt;search() vs. match()&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;string&lt;/em&gt; 어디에서나 일치하는 위치를 찾으려면 &lt;a href=&quot;#re.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 &lt;a href=&quot;#search-vs-match&quot;&gt;(search () vs. match () 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7691cb3a9d42f9132cc69c1d67bf2035399d4696" translate="yes" xml:space="preserve">
          <source>If you want to make the hex string easier to read, you can specify a single character separator &lt;em&gt;sep&lt;/em&gt; parameter to include in the output. By default between each byte. A second optional &lt;em&gt;bytes_per_sep&lt;/em&gt; parameter controls the spacing. Positive values calculate the separator position from the right, negative values from the left.</source>
          <target state="translated">16 진 문자열을 더 읽기 쉽게 하려면 출력에 포함 할 단일 문자 분리기 &lt;em&gt;sep&lt;/em&gt; 매개 변수를 지정할 수 있습니다 . 기본적으로 각 바이트 사이. 두 번째 선택적 &lt;em&gt;bytes_per_sep&lt;/em&gt; 매개 변수는 간격을 제어합니다. 양수 값은 오른쪽에서 분리 자 위치를 계산하고 왼쪽에서 음수 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7f82f6a50d02c1f8accc0d99988bbd66002ab317" translate="yes" xml:space="preserve">
          <source>If you want to manipulate Windows paths on a Unix machine (or vice versa). You cannot instantiate a &lt;a href=&quot;#pathlib.WindowsPath&quot;&gt;&lt;code&gt;WindowsPath&lt;/code&gt;&lt;/a&gt; when running on Unix, but you can instantiate &lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt;&lt;code&gt;PureWindowsPath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix 머신에서 Windows 경로를 조작하려는 경우 (또는 그 반대). 당신은 인스턴스화 할 수 없습니다 &lt;a href=&quot;#pathlib.WindowsPath&quot;&gt; &lt;code&gt;WindowsPath&lt;/code&gt; 를&lt;/a&gt; 유닉스에서 실행하는 경우,하지만 당신은 인스턴스화 할 수 있습니다 &lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt; &lt;code&gt;PureWindowsPath&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7de6afd3109312dd2620f94a9fb410828a34c7" translate="yes" xml:space="preserve">
          <source>If you want to parse Python code into its AST representation, see &lt;a href=&quot;ast#ast.parse&quot;&gt;&lt;code&gt;ast.parse()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 코드를 AST 표현으로 구문 분석하려면 &lt;a href=&quot;ast#ast.parse&quot;&gt; &lt;code&gt;ast.parse()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8826f07288ab3dad612019804c049ce5ddd0e19a" translate="yes" xml:space="preserve">
          <source>If you want to perform multiple patches then you can simply stack up the decorators.</source>
          <target state="translated">여러 패치를 수행하려면 데코레이터를 간단히 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f79361e9cfffc79417f13f6a383a9717a273aa3" translate="yes" xml:space="preserve">
          <source>If you want to reflect the turtle its state, you have to use &lt;code&gt;resizemode =
auto&lt;/code&gt;.</source>
          <target state="translated">거북이의 상태를 반영하려면 &lt;code&gt;resizemode = auto&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f28c7d51ec7d8d10c742281de629eb006ff45c11" translate="yes" xml:space="preserve">
          <source>If you want to send configurations to the listener which don&amp;rsquo;t disable existing loggers, you will need to use a JSON format for the configuration, which will use &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; for configuration. This method allows you to specify &lt;code&gt;disable_existing_loggers&lt;/code&gt; as &lt;code&gt;False&lt;/code&gt; in the configuration you send.</source>
          <target state="translated">기존 로거를 비활성화하지 않는 리스너로 구성을 보내려면 구성에 JSON 형식을 사용해야하며 구성에 &lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 를 사용합니다. 이 방법을 사용 하면 전송하는 구성에서 &lt;code&gt;disable_existing_loggers&lt;/code&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ebc31a3f94e9849595d45e456c192050750c4e3" translate="yes" xml:space="preserve">
          <source>If you want to specify a subject line which is record-dependent, override this method.</source>
          <target state="translated">레코드 종속적 인 제목 줄을 지정하려면이 방법을 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="745b19cebcf113a8d5f26626ff17bb861b6e043f" translate="yes" xml:space="preserve">
          <source>If you want to use a different configuration which better reflects the features of this module or which better fits to your needs, e.g. for use in a classroom, you can prepare a configuration file &lt;code&gt;turtle.cfg&lt;/code&gt; which will be read at import time and modify the configuration according to its settings.</source>
          <target state="translated">이 모듈의 기능을 더 잘 반영하거나 강의실에서 사용하기 위해 필요에 더 잘 맞는 다른 구성을 사용하려는 경우 가져 오기시에 읽히고 수정할 구성 파일 &lt;code&gt;turtle.cfg&lt;/code&gt; 를 준비 할 수 있습니다 . 설정에 따라 구성.</target>
        </trans-unit>
        <trans-unit id="6b8dc840c342df51fe5ce8af14007a99dd5c3a47" translate="yes" xml:space="preserve">
          <source>If you want to use a different prefix for your test, you can inform the patchers of the different prefix by setting &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt;. For more details about how to change the value of see &lt;a href=&quot;#test-prefix&quot;&gt;TEST_PREFIX&lt;/a&gt;.</source>
          <target state="translated">테스트에 다른 접두사를 사용하려면 patch.TEST_PREFIX를 설정하여 패치 프로그램에 다른 접두사를 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 있습니다. 값을 변경하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#test-prefix&quot;&gt;TEST_PREFIX&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fad4732a998a9e23ea176b65c3a718c625cdcc4" translate="yes" xml:space="preserve">
          <source>If you want to use no fillcolor (i.e. make the turtle transparent), you have to write &lt;code&gt;fillcolor = &quot;&quot;&lt;/code&gt; (but all nonempty strings must not have quotes in the cfg-file).</source>
          <target state="translated">fillcolor를 사용하지 않으려면 (즉, 거북이를 투명하게 만들려면) &lt;code&gt;fillcolor = &quot;&quot;&lt;/code&gt; 를 작성 해야합니다 (그러나 비어 있지 않은 모든 문자열은 cfg 파일에 따옴표가 없어야합니다).</target>
        </trans-unit>
        <trans-unit id="0f8f3a435f429e1cd523ef833f8de0aef1f31607" translate="yes" xml:space="preserve">
          <source>If you want to walk an arbitrary filesystem path upwards, it is recommended to first call &lt;a href=&quot;#pathlib.Path.resolve&quot;&gt;&lt;code&gt;Path.resolve()&lt;/code&gt;&lt;/a&gt; so as to resolve symlinks and eliminate &lt;code&gt;&amp;ldquo;..&amp;rdquo;&lt;/code&gt; components.</source>
          <target state="translated">임의의 파일 시스템 경로를 위쪽으로 걸어가려면 먼저 &lt;a href=&quot;#pathlib.Path.resolve&quot;&gt; &lt;code&gt;Path.resolve()&lt;/code&gt; &lt;/a&gt; 호출 하여 심볼릭 링크를 해결하고 &lt;code&gt;&amp;ldquo;..&amp;rdquo;&lt;/code&gt; 구성 요소를 제거 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="70ac8ffb536e6d85123fe960473989eb7a059ddc" translate="yes" xml:space="preserve">
          <source>If you were looking to see what functions were looping a lot, and taking a lot of time, you would do:</source>
          <target state="translated">어떤 함수가 많이 루핑되고 많은 시간이 걸리는지 알고 싶다면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="acf8d273366df0fb10eec018a0ee0ccd5949445d" translate="yes" xml:space="preserve">
          <source>If you wondered what functions called the above functions, you could now (&lt;code&gt;p&lt;/code&gt; is still sorted according to the last criteria) do:</source>
          <target state="translated">위의 함수라고 불리는 함수가 무엇인지 궁금하다면, 이제 &lt;code&gt;p&lt;/code&gt; 는 마지막 기준에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a0bf217f357783caa209594b9bcd75c3ce805fda" translate="yes" xml:space="preserve">
          <source>If you write a file-like object and implement your own caching, you can make it fork-safe by storing the pid whenever you append to the cache, and discarding the cache when the pid changes. For example:</source>
          <target state="translated">파일과 같은 객체를 작성하고 자체 캐싱을 구현하는 경우 캐시에 추가 할 때마다 pid를 저장하고 pid가 변경 될 때 캐시를 삭제하여 포크로 안전하게 만들 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe0eb8d599c47b7f3926f4416144dc29d275eb9e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn&amp;rsquo;t recognized by Python&amp;rsquo;s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it&amp;rsquo;s highly recommended that you use raw strings for all but the simplest expressions.</source>
          <target state="translated">원시 문자열을 사용하여 패턴을 표현하지 않는 경우 Python은 문자열 리터럴에서 이스케이프 시퀀스로 백 슬래시도 사용한다는 점을 기억하십시오. 파이썬의 파서가 이스케이프 시퀀스를 인식하지 못하면 백 슬래시와 그 뒤의 문자가 결과 문자열에 포함됩니다. 그러나 파이썬이 결과 시퀀스를 인식하면 백 슬래시를 두 번 반복해야합니다. 이것은 복잡하고 이해하기 어렵 기 때문에 가장 간단한 표현식을 제외하고는 원시 문자열을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="63ba1bb5f63d28b0a2652e45a8f7caac7c895c2a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only interested in where the sequences match, &lt;code&gt;get_matching_blocks()&lt;/code&gt; is handy:</source>
          <target state="translated">시퀀스가 일치하는 위치에만 관심이 있다면 &lt;code&gt;get_matching_blocks()&lt;/code&gt; 가 편리합니다.</target>
        </trans-unit>
        <trans-unit id="f936f48bc81e3933728945057465fe8b1eaf71cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting with a buffered Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;, first do &lt;code&gt;f.flush()&lt;/code&gt;, and then do &lt;code&gt;os.fsync(f.fileno())&lt;/code&gt;, to ensure that all internal buffers associated with &lt;em&gt;f&lt;/em&gt; are written to disk.</source>
          <target state="translated">버퍼링 된 Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;f로&lt;/em&gt; 시작하는 경우 먼저 &lt;code&gt;f.flush()&lt;/code&gt; 를 수행 한 다음 &lt;code&gt;os.fsync(f.fileno())&lt;/code&gt; 를 수행 하여 &lt;em&gt;f&lt;/em&gt; 와 연관된 모든 내부 버퍼 가 디스크에 기록되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="c32e5e3d701ca2fc3b2aabba2d5788af273dfeb3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve never used this module before or just aren&amp;rsquo;t sure which class is right for your task, &lt;a href=&quot;#pathlib.Path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; is most likely what you need. It instantiates a &lt;a href=&quot;#concrete-paths&quot;&gt;concrete path&lt;/a&gt; for the platform the code is running on.</source>
          <target state="translated">이전에이 모듈을 사용한 적이 없거나 어떤 클래스가 작업에 적합한 지 확실하지 않은 경우 &lt;a href=&quot;#pathlib.Path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 가 가장 필요할 것입니다. 코드가 실행되는 플랫폼의 &lt;a href=&quot;#concrete-paths&quot;&gt;구체적인 경로&lt;/a&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="f33f0fe74a1d8aa8c68e244e2bc5362d95964bbf" translate="yes" xml:space="preserve">
          <source>If your application depends on a package that includes a C extension, that package cannot be run from a zip file (this is an OS limitation, as executable code must be present in the filesystem for the OS loader to load it). In this case, you can exclude that dependency from the zipfile, and either require your users to have it installed, or ship it alongside your zipfile and add code to your &lt;code&gt;__main__.py&lt;/code&gt; to include the directory containing the unzipped module in &lt;code&gt;sys.path&lt;/code&gt;. In this case, you will need to make sure to ship appropriate binaries for your target architecture(s) (and potentially pick the correct version to add to &lt;code&gt;sys.path&lt;/code&gt; at runtime, based on the user&amp;rsquo;s machine).</source>
          <target state="translated">응용 프로그램이 C 확장을 포함하는 패키지에 의존하는 경우 해당 패키지는 zip 파일에서 실행할 수 없습니다 (OS 로더가로드 할 수 있도록 파일 시스템에 실행 코드가 있어야하므로 OS 제한 사항 임). 이 경우 zip 파일에서 해당 종속성을 제외하고 사용자가 파일을 설치하도록 요구하거나 zip 파일과 함께 제공하고 &lt;code&gt;__main__.py&lt;/code&gt; 에 코드를 추가 하여 &lt;code&gt;sys.path&lt;/code&gt; 에 압축 해제 된 모듈을 포함하는 디렉토리를 포함시킬 수 있습니다. 이 경우 대상 아키텍처에 적합한 바이너리를 제공해야합니다 (그리고 사용자 컴퓨터를 기반으로 런타임 에 &lt;code&gt;sys.path&lt;/code&gt; 에 추가 할 올바른 버전을 선택해야합니다 ).</target>
        </trans-unit>
        <trans-unit id="2a11020c14c0b00c5484221191c5a40664dd44bf" translate="yes" xml:space="preserve">
          <source>If your application doesn&amp;rsquo;t care whether the parameter was encoded as in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;, you can collapse the parameter value by calling &lt;a href=&quot;email.utils#email.utils.collapse_rfc2231_value&quot;&gt;&lt;code&gt;email.utils.collapse_rfc2231_value()&lt;/code&gt;&lt;/a&gt;, passing in the return value from &lt;a href=&quot;#email.message.Message.get_param&quot;&gt;&lt;code&gt;get_param()&lt;/code&gt;&lt;/a&gt;. This will return a suitably decoded Unicode string when the value is a tuple, or the original string unquoted if it isn&amp;rsquo;t. For example:</source>
          <target state="translated">응용 프로그램이 매개 변수에로 인코딩되었는지 여부를 상관하지 않는 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; , 당신이 호출하여 매개 변수 값을 축소 할 수 있습니다 &lt;a href=&quot;email.utils#email.utils.collapse_rfc2231_value&quot;&gt; &lt;code&gt;email.utils.collapse_rfc2231_value()&lt;/code&gt; &lt;/a&gt; 에서 반환 값을 전달 &lt;a href=&quot;#email.message.Message.get_param&quot;&gt; &lt;code&gt;get_param()&lt;/code&gt; &lt;/a&gt; . 값이 튜플 일 때 적절하게 디코딩 된 유니 코드 문자열을 반환하거나 그렇지 않은 경우 원래 문자열을 따옴표로 묶지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7027931b44d28707bd4c664ebc8956c5af833c14" translate="yes" xml:space="preserve">
          <source>If your application needs specific settings, you should create a &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; and apply the settings yourself.</source>
          <target state="translated">애플리케이션에 특정 설정이 필요한 경우 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; 를&lt;/a&gt; 작성 하고 설정을 직접 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5edf794d03c4b2ffd7486fd7e128bf5e002387d1" translate="yes" xml:space="preserve">
          <source>If your generator will only yield values, set the &lt;code&gt;SendType&lt;/code&gt; and &lt;code&gt;ReturnType&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">생성기가 값만 산출하는 경우 &lt;code&gt;SendType&lt;/code&gt; 및 &lt;code&gt;ReturnType&lt;/code&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a6fc9f504fb9ac47a5e232ec8b3e5d967c1d094" translate="yes" xml:space="preserve">
          <source>If your generator will only yield values, set the &lt;code&gt;SendType&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">생성기가 값만 산출하는 경우 &lt;code&gt;SendType&lt;/code&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae8a1702501d5b127615e973ca97f9e761c7eb59" translate="yes" xml:space="preserve">
          <source>If your operating system supports the &lt;code&gt;select()&lt;/code&gt; system call in its I/O library (and nearly all do), then you can use it to juggle multiple communication channels at once; doing other work while your I/O is taking place in the &amp;ldquo;background.&amp;rdquo; Although this strategy can seem strange and complex, especially at first, it is in many ways easier to understand and control than multi-threaded programming. The &lt;a href=&quot;#module-asyncore&quot;&gt;&lt;code&gt;asyncore&lt;/code&gt;&lt;/a&gt; module solves many of the difficult problems for you, making the task of building sophisticated high-performance network servers and clients a snap. For &amp;ldquo;conversational&amp;rdquo; applications and protocols the companion &lt;a href=&quot;asynchat#module-asynchat&quot;&gt;&lt;code&gt;asynchat&lt;/code&gt;&lt;/a&gt; module is invaluable.</source>
          <target state="translated">운영 체제가 I / O 라이브러리에서 &lt;code&gt;select()&lt;/code&gt; 시스템 호출을 지원하는 경우 (그리고 거의 모든 경우) 여러 통신 채널을 한 번에 저글링하는 데 사용할 수 있습니다. &quot;배경&quot;에서 I / O가 진행되는 동안 다른 작업을 수행합니다. 이 전략은 특히 처음에는 이상하고 복잡해 보이지만 여러 스레드 프로그래밍보다 이해하고 제어하는 ​​것이 더 쉽습니다. &lt;a href=&quot;#module-asyncore&quot;&gt; &lt;code&gt;asyncore&lt;/code&gt; 의&lt;/a&gt; 모듈은 정교한 고성능 네트워크 서버와 클라이언트에게 스냅을 구축하는 작업을, 당신을 위해 어려운 많은 문제를 해결합니다. &quot;대화식&quot;애플리케이션 및 프로토콜의 경우 동반자 &lt;a href=&quot;asynchat#module-asynchat&quot;&gt; &lt;code&gt;asynchat&lt;/code&gt; &lt;/a&gt; 모듈은 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="955a544f9e1d26fd1d26d80d1022f0327fd7582e" translate="yes" xml:space="preserve">
          <source>If your program needs to support many languages at the same time, you may want to create multiple translation instances and then switch between them explicitly, like so:</source>
          <target state="translated">프로그램이 동시에 여러 언어를 지원해야하는 경우 여러 번역 인스턴스를 만든 다음 다음과 같이 명시 적으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93490801dea0da95308cb5a5318fbdcbabcfcf7b" translate="yes" xml:space="preserve">
          <source>If your script does not have any syntax errors, try adding &lt;code&gt;import cgitb;
cgitb.enable()&lt;/code&gt; to the top of the script.</source>
          <target state="translated">스크립트에 구문 오류가 없으면 &lt;code&gt;import cgitb; cgitb.enable()&lt;/code&gt; 추가하십시오 . cgitb.enable () 을 스크립트 상단으로</target>
        </trans-unit>
        <trans-unit id="f31cb37df73b3125c3f57c9d809d3e1ed793e729" translate="yes" xml:space="preserve">
          <source>If your server supports the command, &lt;a href=&quot;#ftplib.FTP.mlsd&quot;&gt;&lt;code&gt;mlsd()&lt;/code&gt;&lt;/a&gt; offers a better API.</source>
          <target state="translated">서버가 명령을 지원하면 &lt;a href=&quot;#ftplib.FTP.mlsd&quot;&gt; &lt;code&gt;mlsd()&lt;/code&gt; &lt;/a&gt; 가 더 나은 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cbbc5ab274a4717efc6cc381b10937fbe7d77265" translate="yes" xml:space="preserve">
          <source>If zero or more characters at the &lt;em&gt;beginning&lt;/em&gt; of &lt;em&gt;string&lt;/em&gt; match this regular expression, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 의 &lt;em&gt;시작 부분&lt;/em&gt; 에 0 개 이상의 문자 가이 정규식과 일치하면 해당하는 &lt;a href=&quot;#match-objects&quot;&gt;일치 오브젝트를&lt;/a&gt; 리턴하십시오 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b4350db35f3b9bbabeaa05f2baf19f9fc617cb2" translate="yes" xml:space="preserve">
          <source>If zero or more characters at the beginning of &lt;em&gt;string&lt;/em&gt; match the regular expression &lt;em&gt;pattern&lt;/em&gt;, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 의 시작 부분에 0 개 이상의 문자가 정규식 &lt;em&gt;패턴 &lt;/em&gt;&lt;a href=&quot;#match-objects&quot;&gt;과 일치&lt;/a&gt; 하면 해당하는 일치 객체를 반환 합니다 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="092f14f1f8cb7d25b3e6d70dcd0a46d04a6819c6" translate="yes" xml:space="preserve">
          <source>If, that is, we ignore the effects of Relativity</source>
          <target state="translated">만약 우리가 상대성의 영향을 무시한다면</target>
        </trans-unit>
        <trans-unit id="2fa5b809a29b75e222e19a786786494e855b9b8b" translate="yes" xml:space="preserve">
          <source>If, when coding a module for general use, you need a locale independent version of an operation that is affected by the locale (such as certain formats used with &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt;), you will have to find a way to do it without using the standard library routine. Even better is convincing yourself that using locale settings is okay. Only as a last resort should you document that your module is not compatible with non-&lt;code&gt;C&lt;/code&gt; locale settings.</source>
          <target state="translated">일반적인 용도로 모듈을 코딩 할 때 로케일의 영향을받는 로케일 독립적 인 버전의 작업이 필요한 경우 (예 : &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 과 함께 사용되는 특정 형식 ), 표준 라이브러리 루틴을 사용합니다. 로케일 설정을 사용하는 것이 좋습니다. 최후의 수단으로 만 모듈이 &lt;code&gt;C&lt;/code&gt; 이외의 로케일 설정 과 호환되지 않는다는 것을 문서화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9964433f6a0266bdf9fa6725a19e41fef8b37330" translate="yes" xml:space="preserve">
          <source>If/how &lt;em&gt;atTime&lt;/em&gt; is used</source>
          <target state="translated">&lt;em&gt;at&lt;/em&gt; / how &lt;em&gt;atTime&lt;/em&gt; 이 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="1c210c82683143a51cb6e3ad028c9f8883a010ad" translate="yes" xml:space="preserve">
          <source>Ignore all modules and packages in the named directory and subdirectories. The argument can be a list of directories separated by &lt;a href=&quot;os#os.pathsep&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명명 된 디렉토리 및 하위 디렉토리에있는 모든 모듈과 패키지를 무시하십시오. 인수는 &lt;a href=&quot;os#os.pathsep&quot;&gt; &lt;code&gt;os.pathsep&lt;/code&gt; 로&lt;/a&gt; 구분 된 디렉토리 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fce84b920d19c50aa58d91da2a36c60b8c2de65" translate="yes" xml:space="preserve">
          <source>Ignore cookies in Set-Cookie: headers that have names starting with &lt;code&gt;'$'&lt;/code&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;'$'&lt;/code&gt; 로 시작하는 Set-Cookie : 헤더의 쿠키는 무시하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2855bf1eb59ace3c404c75993cf42a4581a04c3" translate="yes" xml:space="preserve">
          <source>Ignore each of the given module names and its submodules (if it is a package). The argument can be a list of names separated by a comma.</source>
          <target state="translated">주어진 각 모듈 이름과 하위 모듈 (패키지 인 경우)을 무시하십시오. 인수는 쉼표로 구분 된 이름 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="930fbf8a76be290144b9247e218920a109183ddb" translate="yes" xml:space="preserve">
          <source>Ignore the malformed data and continue without further notice. Implemented in &lt;a href=&quot;#codecs.ignore_errors&quot;&gt;&lt;code&gt;ignore_errors()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잘못된 데이터는 무시하고 추가 통지없이 계속 진행하십시오. &lt;a href=&quot;#codecs.ignore_errors&quot;&gt; &lt;code&gt;ignore_errors()&lt;/code&gt; &lt;/a&gt; 에서 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="1e65bb4eca2d3c71529c96890a4b735eb7dafeac" translate="yes" xml:space="preserve">
          <source>Ignored.</source>
          <target state="translated">Ignored.</target>
        </trans-unit>
        <trans-unit id="b90e620c5d88940bfdd404823e410652bfa5a956" translate="yes" xml:space="preserve">
          <source>Ignoring the timeout feature, calling this method is roughly equivalent to writing:</source>
          <target state="translated">시간 초과 기능을 무시하고이 메소드를 호출하는 것은 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">잘못된 바이트 시퀀스</target>
        </trans-unit>
        <trans-unit id="3176fdb344f7026fb9cd9da003d83547cd35fc12" translate="yes" xml:space="preserve">
          <source>Illegal seek</source>
          <target state="translated">불법 탐색</target>
        </trans-unit>
        <trans-unit id="e221fe5a3e6f4ff124e28b73d70e7afa9ab3f313" translate="yes" xml:space="preserve">
          <source>Image Types</source>
          <target state="translated">이미지 타입</target>
        </trans-unit>
        <trans-unit id="c177d6ae70be09c0df8491f4bb934a1ebcbac143" translate="yes" xml:space="preserve">
          <source>Image format</source>
          <target state="translated">이미지 형식</target>
        </trans-unit>
        <trans-unit id="42de00097c89c82d17336b2d87ec32e4f21480ff" translate="yes" xml:space="preserve">
          <source>Image shapes &lt;em&gt;do not&lt;/em&gt; rotate when turning the turtle, so they do not display the heading of the turtle!</source>
          <target state="translated">거북이를 돌릴 때 이미지 모양 &lt;em&gt;이&lt;/em&gt; 회전 &lt;em&gt;하지 않으므로&lt;/em&gt; 거북이 방향을 표시하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="70b3cbc7767df833fa045e36e82910b275002110" translate="yes" xml:space="preserve">
          <source>Images of different formats can be created through the corresponding subclass of &lt;code&gt;tkinter.Image&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tkinter.Image&lt;/code&gt; 의 해당 서브 클래스를 통해 다른 형식의 이미지를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a13a369729af2332fed8dda8e39f614910984143" translate="yes" xml:space="preserve">
          <source>Imagine a robotic turtle starting at (0, 0) in the x-y plane. After an &lt;code&gt;import turtle&lt;/code&gt;, give it the command &lt;code&gt;turtle.forward(15)&lt;/code&gt;, and it moves (on-screen!) 15 pixels in the direction it is facing, drawing a line as it moves. Give it the command &lt;code&gt;turtle.right(25)&lt;/code&gt;, and it rotates in-place 25 degrees clockwise.</source>
          <target state="translated">xy 비행기에서 (0, 0)에서 시작하는 로봇 거북이를 상상해보십시오. &lt;code&gt;import turtle&lt;/code&gt; 후, &lt;code&gt;turtle.forward(15)&lt;/code&gt; 명령을 내리면 , 화면을 향한 방향으로 15 픽셀 움직여서 화면에 움직이는 선을 그립니다. &lt;code&gt;turtle.right(25)&lt;/code&gt; 명령을 내리면 시계 방향으로 25도 회전합니다.</target>
        </trans-unit>
        <trans-unit id="687db08c82f3ad0c17cb55a8e0f53abf69ca4195" translate="yes" xml:space="preserve">
          <source>Imagine we have a project that we want to test with the following structure:</source>
          <target state="translated">다음 구조로 테스트하려는 프로젝트가 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="40c36dcfc5b7dc5aaaaa183a438e2f62f6e25008" translate="yes" xml:space="preserve">
          <source>Immediately stop playing or recording and return the device to a state where it can accept commands. The OSS documentation recommends closing and re-opening the device after calling &lt;a href=&quot;#ossaudiodev.oss_audio_device.reset&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">즉시 재생 또는 녹음을 중지하고 장치를 명령을 받아 들일 수있는 상태로 되돌립니다. OSS 문서는 &lt;a href=&quot;#ossaudiodev.oss_audio_device.reset&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 을 호출 한 후 장치를 닫았다가 다시 열 것을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="80cb7526f8f17d0e625c37d38a71d1b8b176c45b" translate="yes" xml:space="preserve">
          <source>Immediately unwinds the callback stack, invoking callbacks in the reverse order of registration. For any context managers and exit callbacks registered, the arguments passed in will indicate that no exception occurred.</source>
          <target state="translated">콜백 스택을 즉시 풀고 등록 순서와 반대로 콜백을 호출합니다. 컨텍스트 관리자 및 엑시트 콜백이 등록 된 경우 전달 된 인수는 예외가 발생하지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="42e8811b32cc14bd73ca1c7cf254e434ca1c4be2" translate="yes" xml:space="preserve">
          <source>Immutable Sequence Types</source>
          <target state="translated">불변 시퀀스 타입</target>
        </trans-unit>
        <trans-unit id="7d364b632538803974da1c9485bc7401ef2fd2eb" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 프로토콜을 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="876c8f17da52cca0c2c72876d566383804f060a0" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://tools.ietf.org/html/rfc3490.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 3490&lt;/strong&gt;&lt;/a&gt;, see also &lt;a href=&quot;#module-encodings.idna&quot;&gt;&lt;code&gt;encodings.idna&lt;/code&gt;&lt;/a&gt;. Only &lt;code&gt;errors='strict'&lt;/code&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3490.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 3490을&lt;/strong&gt;&lt;/a&gt; 구현 하십시오 ( &lt;a href=&quot;#module-encodings.idna&quot;&gt; &lt;code&gt;encodings.idna&lt;/code&gt; &lt;/a&gt; 참조) . 만 &lt;code&gt;errors='strict'&lt;/code&gt; 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4dbe2ee30f05a84b86d098b6ad21ef61bde254e0" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://tools.ietf.org/html/rfc3492.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 3492&lt;/strong&gt;&lt;/a&gt;. Stateful codecs are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3492.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 3492를&lt;/strong&gt;&lt;/a&gt; 구현하십시오 . 상태 저장 코덱은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb9ce8751f48a6114c443a4bb2aac9cb2915809a" translate="yes" xml:space="preserve">
          <source>Implement Netscape protocol.</source>
          <target state="translated">Netscape 프로토콜을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed133685773097940d3cf663208ebc50eb17709" translate="yes" xml:space="preserve">
          <source>Implement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; that was passed to vformat. The set of unused args can be calculated from these parameters. &lt;a href=&quot;#string.Formatter.check_unused_args&quot;&gt;&lt;code&gt;check_unused_args()&lt;/code&gt;&lt;/a&gt; is assumed to raise an exception if the check fails.</source>
          <target state="translated">원하는 경우 사용하지 않는 인수 검사를 구현하십시오. 이 함수의 인수가 실제로 (라는 인수 위치 인수 정수 및 문자열) 형식 문자열에 언급 된 모든 인자 키 세트, 및에 대한 참조 &lt;em&gt;인수&lt;/em&gt; 및 &lt;em&gt;kwargs로&lt;/em&gt; vformat에 전달 하였다. 사용되지 않은 인수 세트는이 매개 변수에서 계산할 수 있습니다. &lt;a href=&quot;#string.Formatter.check_unused_args&quot;&gt; &lt;code&gt;check_unused_args()&lt;/code&gt; &lt;/a&gt; 는 검사가 실패하면 예외를 발생시키는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fd8c27461faf491446b966e22536bdd5517a900e" translate="yes" xml:space="preserve">
          <source>Implement this method in a subclass such that it returns a serializable object for &lt;em&gt;o&lt;/em&gt;, or calls the base implementation (to raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">서브 클래스에서이 메소드를 구현하여 &lt;em&gt;o&lt;/em&gt; 에 대한 직렬화 가능 오브젝트를 리턴 하거나 기본 구현을 호출하여 ( &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 발생&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6372052045f8af6340009762eb4a097bf006bc91" translate="yes" xml:space="preserve">
          <source>Implementation Limitations</source>
          <target state="translated">구현 한계</target>
        </trans-unit>
        <trans-unit id="a928eb642e8d69164143d07e134772861cb6056c" translate="yes" xml:space="preserve">
          <source>Implementation note: Some of the mixin methods, such as &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__reversed__&quot;&gt;&lt;code&gt;__reversed__()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;index()&lt;/code&gt;, make repeated calls to the underlying &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; method. Consequently, if &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; is implemented with constant access speed, the mixin methods will have linear performance; however, if the underlying method is linear (as it would be with a linked list), the mixins will have quadratic performance and will likely need to be overridden.</source>
          <target state="translated">구현 참고 사항 : &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__reversed__&quot;&gt; &lt;code&gt;__reversed__()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;index()&lt;/code&gt; 와 같은 일부 믹스 인 메소드 는 기본 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 메소드 를 반복적으로 호출합니다 . 결과적으로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 이 일정한 액세스 속도로 구현되면 mixin 메소드는 선형 성능을 갖습니다. 그러나 기본 방법이 선형 인 경우 (링크 된 목록과 마찬가지로) 믹스 인은 2 차 성능을 가지며 재정의해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="602e467a96a4864b3e865c151d6768f89e1f6c9a" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;Loader.exec_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현 &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;Loader.exec_module()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b24035207ed54bd400485a1684e18bf3533d78a" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;#importlib.abc.Loader.load_module&quot;&gt;&lt;code&gt;Loader.load_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현 &lt;a href=&quot;#importlib.abc.Loader.load_module&quot;&gt; &lt;code&gt;Loader.load_module()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20977e3c93bce44f3af2c831893e3343efa9bf7c" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;process_message&lt;/code&gt; should use the &lt;code&gt;**kwargs&lt;/code&gt; signature to accept arbitrary keyword arguments, since future feature enhancements may add keys to the kwargs dictionary.</source>
          <target state="translated">향후의 기능 향상으로 kwargs 사전에 키가 추가 될 수 있으므로 &lt;code&gt;process_message&lt;/code&gt; 구현 에서는 &lt;code&gt;**kwargs&lt;/code&gt; 서명을 사용하여 임의의 키워드 인수를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d8b1b41137285f8c4de39c176a278d9f49ddf2e" translate="yes" xml:space="preserve">
          <source>Implementing the arithmetic operations</source>
          <target state="translated">산술 연산 구현</target>
        </trans-unit>
        <trans-unit id="ca6c4d83cb31522562758f2caae6de20eb026979" translate="yes" xml:space="preserve">
          <source>Implementors should be careful to make equal numbers equal and hash them to the same values. This may be subtle if there are two different extensions of the real numbers. For example, &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">구현자는 동일한 숫자를 동일하게 만들고 동일한 값으로 해시하도록주의해야합니다. 실수의 두 가지 다른 확장이있는 경우 미묘 할 수 있습니다. 예를 들어 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt; 은 다음과 같이 &lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="d903524c1ea6aa12c931b0a6c641b3778b3888a8" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;PUSH(get_awaitable(TOS.__anext__()))&lt;/code&gt;. See &lt;code&gt;GET_AWAITABLE&lt;/code&gt; for details about &lt;code&gt;get_awaitable&lt;/code&gt;</source>
          <target state="translated">구현은 &lt;code&gt;PUSH(get_awaitable(TOS.__anext__()))&lt;/code&gt; . &lt;code&gt;GET_AWAITABLE&lt;/code&gt; 대한 자세한 내용은 &lt;code&gt;get_awaitable&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cb421f905057ea14812c7d7b55740f7dcb3aa14" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = +TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = +TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="9f8030dd288cf838d962bc81cf0b1e710e59dab6" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = -TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = -TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="23caf167f55ab86f7acf8ef10a08029547ccae56" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS.__aiter__()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS.__aiter__()&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6804ffbe6ca6db0446550f606e8c3b827c72019d" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1ccd836db2748a42cdb6568840d6b34ab7680997" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="98b212dadbaf80fff0c651d73234d968ff6d57ff" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a92a967387ba75f1c824f8c282c1b389323c1c12" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="fe06b1264a086dd70cc373eb95043d5b61c0bdec" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e7727e8610b32769f888b796569df51894a6e1a4" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a68a686d5d97ef25da29ba50188cfe812c2b160c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="0b7f98171174dff07ba4794fcfc188a2b547babd" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e03d1b043f5b83ce06f326b9be67568ba2593f09" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="54632e771c9265cca4e71a87f0788919f6c1a468" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b4ff4094536277707470df447fbf4ac881111c43" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="70062ec736c872ff9695663f40f72ab315ef9ddf" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ed9a0b5ebb7afed19c96ac5e2a783c31cb5f2376" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt; 구현 | TOS .</target>
        </trans-unit>
        <trans-unit id="a435cd9e0a8ca34e1604fda39f5b0f09b410d773" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1[TOS]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1[TOS]&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a55222ca989584dee87037902ae61c754d1433ea" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = get_awaitable(TOS)&lt;/code&gt;, where &lt;code&gt;get_awaitable(o)&lt;/code&gt; returns &lt;code&gt;o&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is a coroutine object or a generator object with the CO_ITERABLE_COROUTINE flag, or resolves &lt;code&gt;o.__await__&lt;/code&gt;.</source>
          <target state="translated">이물질 &lt;code&gt;TOS = get_awaitable(TOS)&lt;/code&gt; , 여기서 &lt;code&gt;get_awaitable(o)&lt;/code&gt; 복귀 &lt;code&gt;o&lt;/code&gt; 경우 &lt;code&gt;o&lt;/code&gt; 코 루틴 개체 또는 CO_ITERABLE_COROUTINE 플래그 생성기 개체 또는 리졸이다 &lt;code&gt;o.__await__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e24956a48bbfdcc09d0cf754f3dad5634e36ef6" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = iter(TOS)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = iter(TOS)&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7127e3da317dbd834e1c9fa4d150709b0595c38c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = not TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = not TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6aefd62fa0df0b5ae152afef20eb6a2be7bc7fe1" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = ~TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = ~TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4f729d424456b44dfd8d226e0748fec98a45f659" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS.name = TOS1&lt;/code&gt;, where &lt;em&gt;namei&lt;/em&gt; is the index of name in &lt;code&gt;co_names&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS.name = TOS1&lt;/code&gt; 구현합니다 . 여기서 &lt;em&gt;namei&lt;/em&gt; 는 &lt;code&gt;co_names&lt;/code&gt; 의 이름 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="f7674022864a24bfc63ce8ce10c8db53e65eff9f" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS1[TOS] = TOS2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS1[TOS] = TOS2&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="47c788dc833478a625bb744ec09e58aea9fc10d4" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;del TOS.name&lt;/code&gt;, using &lt;em&gt;namei&lt;/em&gt; as index into &lt;code&gt;co_names&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;namei&lt;/em&gt; 를 &lt;code&gt;co_names&lt;/code&gt; 의 색인으로 사용하여 &lt;code&gt;del TOS.name&lt;/code&gt; 을 구현 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab97a7e60a0b065d453ed23af196b35ed6d71cfd" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;del TOS1[TOS]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;del TOS1[TOS]&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c6cb3ef10de23ff06b085fdd4bd8df8cca8edb2e" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;del name&lt;/code&gt;, where &lt;em&gt;namei&lt;/em&gt; is the index into &lt;code&gt;co_names&lt;/code&gt; attribute of the code object.</source>
          <target state="translated">&lt;code&gt;del name&lt;/code&gt; 을 구현합니다 . 여기서 &lt;em&gt;namei&lt;/em&gt; 는 코드 객체의 &lt;code&gt;co_names&lt;/code&gt; 속성에 대한 색인 입니다.</target>
        </trans-unit>
        <trans-unit id="0e9bf63b19593d04613e29b26ddb368205c21880" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;name = TOS&lt;/code&gt;. &lt;em&gt;namei&lt;/em&gt; is the index of &lt;em&gt;name&lt;/em&gt; in the attribute &lt;code&gt;co_names&lt;/code&gt; of the code object. The compiler tries to use &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt;&lt;code&gt;STORE_FAST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#opcode-STORE_GLOBAL&quot;&gt;&lt;code&gt;STORE_GLOBAL&lt;/code&gt;&lt;/a&gt; if possible.</source>
          <target state="translated">&lt;code&gt;name = TOS&lt;/code&gt; 구현합니다 . &lt;em&gt;namei&lt;/em&gt; 는 코드 객체의 &lt;code&gt;co_names&lt;/code&gt; 속성에있는 &lt;em&gt;이름&lt;/em&gt; 의 색인입니다 . 컴파일러는 가능하면 &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt; &lt;code&gt;STORE_FAST&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#opcode-STORE_GLOBAL&quot;&gt; &lt;code&gt;STORE_GLOBAL&lt;/code&gt; &lt;/a&gt; 을 사용하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="3bb12d25ddb30f12352643b960eb58634dcff262" translate="yes" xml:space="preserve">
          <source>Implements a mutex lock for asyncio tasks. Not thread-safe.</source>
          <target state="translated">비동기 작업을위한 뮤텍스 잠금을 구현합니다. 스레드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f127d7511ab821d90fc0d9e0415de725710e1c0e" translate="yes" xml:space="preserve">
          <source>Implements assignment with a starred target: Unpacks an iterable in TOS into individual values, where the total number of values can be smaller than the number of items in the iterable: one of the new values will be a list of all leftover items.</source>
          <target state="translated">별표로 표시된 대상으로 할당을 구현합니다. TOS에서 반복 가능한 항목을 개별 값으로 압축 해제합니다. 여기서 총 값 수는 반복 가능한 항목 수보다 작을 수 있습니다. 새 값 중 하나는 남은 모든 항목의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ad8c71c60917e28ec70cc6e72ac5aba785cd2533" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt;.</source>
          <target state="translated">전체 &lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="34a2e00a28f9e41709e5a409debe9f70047ccfa5" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="58c41048e48b098a8662937aa13eba0fb458de61" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="fa04e754a31d6027a7f4daa4b4fdd702965038b1" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1ee8bdd10bfb59d1de1b7233652a10a6aebf648c" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="239c416c5552e24e40b0c3f5a8da8834a4549b9c" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt;.</source>
          <target state="translated">현재 위치 &lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b92e466e855a22dcee87a299d9f506bd0bd45e91" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e4a87fbd97f23bdda16b8cf5fe0fe1fd3bb5bef6" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6b26e08c65cff3d8460f7b64f132529ac3dc22be" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="44d86e1dd26553b877ecf8c640b2c2b6832071f1" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 위치에 &lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b416ab2beeb3c3d6516c059eeb07d58936d0e6df" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e9962e5508639fbb25594a1f43d3b5f76b2afc27" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="3896caff55805b902dd285f3c899f9096710e046" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt;.</source>
          <target state="translated">내부 구현 &lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85bad2fb59570e2a5eef60329848ed4622403300" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'backslashreplace'&lt;/code&gt; error handling (for &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): malformed data is replaced by a backslashed escape sequence.</source>
          <target state="translated">&lt;code&gt;'backslashreplace'&lt;/code&gt; 대체 ' 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 에만 해당). 잘못된 형식의 데이터는 백 슬래시 이스케이프 시퀀스로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c10a6bbb7422a691823579f3081bab9b0e71d9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'ignore'&lt;/code&gt; error handling: malformed data is ignored and encoding or decoding is continued without further notice.</source>
          <target state="translated">&lt;code&gt;'ignore'&lt;/code&gt; 오류 처리를 구현합니다 . 잘못된 형식의 데이터는 무시되고 추가 통지없이 인코딩 또는 디코딩이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d23f24683ac08882aaa07d91874ed6ef4c6dd2" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'namereplace'&lt;/code&gt; error handling (for encoding with &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): the unencodable character is replaced by a &lt;code&gt;\N{...}&lt;/code&gt; escape sequence.</source>
          <target state="translated">&lt;code&gt;'namereplace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩으로 인코딩하는&lt;/a&gt; 경우에만 해당). 불가피한 문자는 &lt;code&gt;\N{...}&lt;/code&gt; 이스케이프 시퀀스 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="663edbb12a782a964e38e6f015a8ae61e59c5cb6" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'replace'&lt;/code&gt; error handling (for &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): substitutes &lt;code&gt;'?'&lt;/code&gt; for encoding errors (to be encoded by the codec), and &lt;code&gt;'\ufffd'&lt;/code&gt; (the Unicode replacement character) for decoding errors.</source>
          <target state="translated">&lt;code&gt;'replace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 에만 해당) : &lt;code&gt;'?'&lt;/code&gt; 대체 인코딩 오류 (코덱으로 인코딩) 및 오류 디코딩을위한 &lt;code&gt;'\ufffd'&lt;/code&gt; (유니 코드 대체 문자)</target>
        </trans-unit>
        <trans-unit id="a478a6a191e85196bdcece7d24cdbeb8b90bb3e4" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'strict'&lt;/code&gt; error handling: each encoding or decoding error raises a &lt;a href=&quot;exceptions#UnicodeError&quot;&gt;&lt;code&gt;UnicodeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;'strict'&lt;/code&gt; 오류 처리를 구현합니다 . 각 인코딩 또는 디코딩 오류는 &lt;a href=&quot;exceptions#UnicodeError&quot;&gt; &lt;code&gt;UnicodeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="45e09434edbbb004dd6529a8c664f47c18ec9c8a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'xmlcharrefreplace'&lt;/code&gt; error handling (for encoding with &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): the unencodable character is replaced by an appropriate XML character reference.</source>
          <target state="translated">&lt;code&gt;'xmlcharrefreplace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 만 사용 하여 인코딩하는 경우). 허용 할 수없는 문자는 적절한 XML 문자 참조로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="4589678f737340f266ad3c03c880cd6693ba765b" translate="yes" xml:space="preserve">
          <source>Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with &lt;a href=&quot;#opcode-POP_TOP&quot;&gt;&lt;code&gt;POP_TOP&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대화식 모드에 대한 표현식 명령문을 구현합니다. 스택에서 TOS가 제거되어 인쇄됩니다. 비 대화식 모드에서 표현식 문은 &lt;a href=&quot;#opcode-POP_TOP&quot;&gt; &lt;code&gt;POP_TOP&lt;/code&gt; &lt;/a&gt; 으로 종료됩니다 . .</target>
        </trans-unit>
        <trans-unit id="431d2662e4cf482dbbd51ee873a2bf4d4dbe506a" translate="yes" xml:space="preserve">
          <source>Implements the standard rules for accepting and returning cookies.</source>
          <target state="translated">쿠키 수락 및 반환에 대한 표준 규칙을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="357be719dc69e352146cd9351979e2f88b18aa53" translate="yes" xml:space="preserve">
          <source>Implicit namespace packages</source>
          <target state="translated">암시 적 네임 스페이스 패키지</target>
        </trans-unit>
        <trans-unit id="3d1027d5bfea0f5b907c45a2719ba20af2951bac" translate="yes" xml:space="preserve">
          <source>Implicitly via the declared type</source>
          <target state="translated">선언 된 형식을 통해 암시 적으로</target>
        </trans-unit>
        <trans-unit id="87b9fc3f346510b76b17999f7a146e2b1534c297" translate="yes" xml:space="preserve">
          <source>Implied by a read event on a listening socket</source>
          <target state="translated">청취 소켓의 read 이벤트에 의해 암시됩니다</target>
        </trans-unit>
        <trans-unit id="4698e1d5e35f008f6196e32547364bf825c475dc" translate="yes" xml:space="preserve">
          <source>Implied by a read event with no data available</source>
          <target state="translated">사용 가능한 데이터가없는 읽기 이벤트에 의해 암시 됨</target>
        </trans-unit>
        <trans-unit id="21611d57f0838ec535115caab52079c6fc745f43" translate="yes" xml:space="preserve">
          <source>Implied by the first read or write event</source>
          <target state="translated">첫 번째 읽기 또는 쓰기 이벤트에 의해 암시</target>
        </trans-unit>
        <trans-unit id="da96b428d292acbbe72df9e50d4e769cb28b7b27" translate="yes" xml:space="preserve">
          <source>Import &lt;em&gt;module&lt;/em&gt; if necessary and return the object called &lt;em&gt;name&lt;/em&gt; from it, where the &lt;em&gt;module&lt;/em&gt; and &lt;em&gt;name&lt;/em&gt; arguments are &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects. Note, unlike its name suggests, &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt;&lt;code&gt;find_class()&lt;/code&gt;&lt;/a&gt; is also used for finding functions.</source>
          <target state="translated">필요한 경우 &lt;em&gt;모듈을&lt;/em&gt; 가져 와서 &lt;em&gt;name&lt;/em&gt; 이라는 객체를 반환합니다 . 여기서 &lt;em&gt;module&lt;/em&gt; 및 &lt;em&gt;name&lt;/em&gt; 인수는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체입니다. 이름에서 알 수 있듯이 &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt; &lt;code&gt;find_class()&lt;/code&gt; &lt;/a&gt; 는 함수를 찾는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b52818d6d21a3617010654286ad1530ac0e14b13" translate="yes" xml:space="preserve">
          <source>Import a module. The &lt;em&gt;name&lt;/em&gt; argument specifies what module to import in absolute or relative terms (e.g. either &lt;code&gt;pkg.mod&lt;/code&gt; or &lt;code&gt;..mod&lt;/code&gt;). If the name is specified in relative terms, then the &lt;em&gt;package&lt;/em&gt; argument must be set to the name of the package which is to act as the anchor for resolving the package name (e.g. &lt;code&gt;import_module('..mod', 'pkg.subpkg')&lt;/code&gt; will import &lt;code&gt;pkg.mod&lt;/code&gt;).</source>
          <target state="translated">모듈을 가져옵니다. &lt;em&gt;이름&lt;/em&gt; 인수를 지정 절대 또는 상대 측면에서 수입에 어떤 모듈 (예를 들어, 하나 &lt;code&gt;pkg.mod&lt;/code&gt; 또는 &lt;code&gt;..mod&lt;/code&gt; ). 이름이 상대적인 용어로 지정된 경우 &lt;em&gt;패키지&lt;/em&gt; 인수는 패키지 이름을 해결하기위한 앵커 역할을하는 패키지 이름으로 설정해야합니다 (예 : &lt;code&gt;import_module('..mod', 'pkg.subpkg')&lt;/code&gt; &lt;code&gt;pkg.mod&lt;/code&gt; 를 가져옵니다 .)</target>
        </trans-unit>
        <trans-unit id="509eb07f39761a76413d728e8002d91cab5669f9" translate="yes" xml:space="preserve">
          <source>Import as few modules as possible and do it as soon as possible. This minimizes external dependencies of tests and also minimizes possible anomalous behavior from side-effects of importing a module.</source>
          <target state="translated">가능한 적은 수의 모듈을 가져 와서 최대한 빨리 수행하십시오. 이는 테스트의 외부 종속성을 최소화하고 모듈 가져 오기의 부작용으로 인한 비정상적인 동작을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="ebf453241874ae9140f1c4fba4572af23be16d96" translate="yes" xml:space="preserve">
          <source>Import itself is implemented in Python code, making it possible to expose most of the import machinery through importlib. The following helps illustrate the various APIs that importlib exposes by providing an approximate implementation of &lt;a href=&quot;#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt; (Python 3.4 and newer for the importlib usage, Python 3.6 and newer for other parts of the code).</source>
          <target state="translated">가져 오기 자체는 Python 코드로 구현되므로 importlib를 통해 대부분의 가져 오기 기계를 노출 할 수 있습니다. 다음은 &lt;a href=&quot;#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt; 의 대략적인 구현을 제공하여 importlib가 노출하는 다양한 API를 보여줍니다. .</target>
        </trans-unit>
        <trans-unit id="eb7d80557274b41c25be1de7f2b2a9c69daa9de1" translate="yes" xml:space="preserve">
          <source>Import on Case-Insensitive Platforms</source>
          <target state="translated">대소 문자를 구분하지 않는 플랫폼에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="51a0d1e201d38ceab71bb750a252b512b10de5c2" translate="yes" xml:space="preserve">
          <source>Import resolution and custom importers</source>
          <target state="translated">수입 해결 및 맞춤형 수입업자</target>
        </trans-unit>
        <trans-unit id="b46dda0f3af0f364b45aca902f93a2030e1d6cf0" translate="yes" xml:space="preserve">
          <source>Import resolution, by default, uses the builtin &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function to do its importing. You may want to replace this with your own importing mechanism: if so, you can replace the &lt;code&gt;importer&lt;/code&gt; attribute of the &lt;code&gt;DictConfigurator&lt;/code&gt; or its superclass, the &lt;code&gt;BaseConfigurator&lt;/code&gt; class. However, you need to be careful because of the way functions are accessed from classes via descriptors. If you are using a Python callable to do your imports, and you want to define it at class level rather than instance level, you need to wrap it with &lt;a href=&quot;functions#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">가져 오기 해상도는 기본적으로 내장 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 가져 오기를 수행합니다. 이를 자신의 가져 오기 메커니즘으로 바꾸고 싶을 수 있습니다. 그렇다면 &lt;code&gt;DictConfigurator&lt;/code&gt; 또는 해당 수퍼 클래스 인 &lt;code&gt;BaseConfigurator&lt;/code&gt; 클래스 의 &lt;code&gt;importer&lt;/code&gt; 속성을 바꿀 수 있습니다 . 그러나 디스크립터를 통해 클래스에서 함수에 액세스하는 방식 때문에주의해야합니다. 가져 오기를 수행하기 위해 호출 가능한 Python을 사용하고 인스턴스 레벨이 아닌 클래스 레벨에서 정의하려는 경우 &lt;a href=&quot;functions#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt; 로 랩핑해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed9b8c2261e65d838380f42dc0d920d3b56a2dfe" translate="yes" xml:space="preserve">
          <source>Import this class from the &lt;a href=&quot;#module-email.charset&quot;&gt;&lt;code&gt;email.charset&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#module-email.charset&quot;&gt; &lt;code&gt;email.charset&lt;/code&gt; &lt;/a&gt; 모듈 에서이 클래스를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="d88d4c76f774a45881449d93cfdd576af021e9ee" translate="yes" xml:space="preserve">
          <source>ImportWarning</source>
          <target state="translated">ImportWarning</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="fe0f554fef6d8bbe2bada744a7a99611cdfdc416" translate="yes" xml:space="preserve">
          <source>Importing Modules</source>
          <target state="translated">모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="7d7d20fec55d874b61e9a23d4848e2fe11f9ac1d" translate="yes" xml:space="preserve">
          <source>Importing a source file directly</source>
          <target state="translated">소스 파일을 직접 가져 오기</target>
        </trans-unit>
        <trans-unit id="c638d5fe75ce243c593fb88053ccdfc251f4221c" translate="yes" xml:space="preserve">
          <source>Importing programmatically</source>
          <target state="translated">프로그래밍 방식으로 가져 오기</target>
        </trans-unit>
        <trans-unit id="da4b6fd661f8f0ff59c6e77bf0660d2518b7404d" translate="yes" xml:space="preserve">
          <source>Importing the main class:</source>
          <target state="translated">메인 클래스 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="1ab6816ef80ddd057eefbe256b51f340873b1f96" translate="yes" xml:space="preserve">
          <source>Importing this module will append site-specific paths to the module search path and add a few builtins, unless &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; was used. In that case, this module can be safely imported with no automatic modifications to the module search path or additions to the builtins. To explicitly trigger the usual site-specific additions, call the &lt;a href=&quot;#site.main&quot;&gt;&lt;code&gt;site.main()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 모듈을 가져 오면 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 를 사용 하지 않는 한 사이트 별 경로를 모듈 검색 경로에 추가하고 몇 가지 내장을 추가합니다 . 이 경우이 모듈은 모듈 검색 경로를 자동으로 수정하거나 내장을 추가하지 않고도 안전하게 가져올 수 있습니다. 일반적인 사이트 별 추가를 명시 적으로 트리거하려면 &lt;a href=&quot;#site.main&quot;&gt; &lt;code&gt;site.main()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f16b4231e3d6ba6a1713c3f5cbbd7c9a26c500c5" translate="yes" xml:space="preserve">
          <source>Imports the module &lt;code&gt;co_names[namei]&lt;/code&gt;. TOS and TOS1 are popped and provide the &lt;em&gt;fromlist&lt;/em&gt; and &lt;em&gt;level&lt;/em&gt; arguments of &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt;. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt;&lt;code&gt;STORE_FAST&lt;/code&gt;&lt;/a&gt; instruction modifies the namespace.</source>
          <target state="translated">&lt;code&gt;co_names[namei]&lt;/code&gt; 모듈을 가져옵니다 . TOS 및 TOS1이 팝업되고 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;fromlist&lt;/em&gt; 및 &lt;em&gt;level&lt;/em&gt; 인수를 제공합니다 . 모듈 객체가 스택으로 푸시됩니다. 현재 네임 스페이스는 영향을받지 않습니다. 올바른 가져 오기 명령문의 경우 후속 &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt; &lt;code&gt;STORE_FAST&lt;/code&gt; &lt;/a&gt; 명령이 네임 스페이스를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3a067f8e863950831516af1d650bd9d3d58d9c6c" translate="yes" xml:space="preserve">
          <source>Imports: Multi-Line and Absolute/Relative</source>
          <target state="translated">수입품 : 다중 라인 및 절대 / 상대</target>
        </trans-unit>
        <trans-unit id="e34afa4c6c43fdf304519c4cf65d27d88a721571" translate="yes" xml:space="preserve">
          <source>Improved Compatibility with Shells</source>
          <target state="translated">쉘과의 호환성 향상</target>
        </trans-unit>
        <trans-unit id="089354fe34004fc9de595d32a05e79153d2c456c" translate="yes" xml:space="preserve">
          <source>In 3.8, the two primary ways DLLs are loaded now explicitly override the process-wide behavior to ensure consistency. See the &lt;a href=&quot;https://docs.python.org/3.8/whatsnew/3.8.html#bpo-36085-whatsnew&quot;&gt;porting notes&lt;/a&gt; for information on updating libraries.</source>
          <target state="translated">3.8에서는 DLL이로드되는 두 가지 기본 방법이 일관성을 보장하기 위해 프로세스 전체 동작을 명시 적으로 무시합니다. 라이브러리 업데이트에 대한 정보 는 &lt;a href=&quot;https://docs.python.org/3.8/whatsnew/3.8.html#bpo-36085-whatsnew&quot;&gt;포팅 노트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09b2f076615a334a17aaf9a55dfdf31ef870f1d5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt;, this is the same as &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에서는 &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; , 이것과 동일 &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b38fe556a6e29923e6bee3656f92a012825b5239" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt;, this is the same as &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt;&lt;code&gt;readinto()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 에서는 readinto &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt; &lt;code&gt;readinto()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="cb4f5fa376dc3e2057a73ea4e8efbb45b9541ac5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;, processes are spawned by creating a &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object and then calling its &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; follows the API of &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt;. A trivial example of a multiprocess program is</source>
          <target state="translated">에서 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 프로세스가 만들어 양산하는 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 오브젝트를 다음의 호출 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메소드를. &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 의 API를 따릅니다 . 다중 프로세스 프로그램의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a41975f414337b4161e766ea1a36bb88654c31c4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;, an unstructured header is a run of arbitrary text in the ASCII character set. &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt;, however, has an &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; compatible mechanism for encoding non-ASCII text as ASCII characters within a header value. When a &lt;em&gt;value&lt;/em&gt; containing encoded words is passed to the constructor, the &lt;code&gt;UnstructuredHeader&lt;/code&gt; parser converts such encoded words into unicode, following the &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; rules for unstructured text. The parser uses heuristics to attempt to decode certain non-compliant encoded words. Defects are registered in such cases, as well as defects for issues such as invalid characters within the encoded words or the non-encoded text.</source>
          <target state="translated">에서 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; , 구조화되지 않은 헤더는 ASCII 문자 세트에서 임의의 텍스트의 실행이다. 그러나 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 에는 비 ASCII 텍스트를 헤더 값 내에서 ASCII 문자로 인코딩하기위한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 호환 메커니즘이 있습니다. 때 &lt;em&gt;값&lt;/em&gt; 인코딩 된 단어를 포함하는 상기 생성자로 전달되는 상기 &lt;code&gt;UnstructuredHeader&lt;/code&gt; 의 파서는 다음에 이러한 인코딩 된 유니 단어 변환 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 비정형 텍스트 규칙. 파서는 휴리스틱을 사용하여 특정 비 호환 인코딩 단어를 디코딩하려고 시도합니다. 이러한 경우 결함은 물론 인코딩 된 단어 내의 유효하지 않은 문자 또는 인코딩되지 않은 텍스트와 같은 문제의 결함도 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="6551877af47b9396e87eaa7a777f7c956f3407a3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;[0, 1]&lt;/code&gt;. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The value 0 (1) represents the earlier (later) of the two moments with the same wall time representation.</source>
          <target state="translated">에서는 &lt;code&gt;[0, 1]&lt;/code&gt; . 반복되는 간격 동안 벽 시간을 명확하게하는 데 사용됩니다. (일광 절약 시간이 끝날 때 시계가 롤백되거나 정치적 이유로 현재 영역의 UTC 오프셋이 감소하면 반복되는 간격이 발생합니다.) 값 0 (1)은 동일한 월 시간 표현.</target>
        </trans-unit>
        <trans-unit id="93133f5ae9ab6ab0577f712c1e104727b3ae2cfc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(1000000)&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;range(1000000)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0618520a9a19fea1f2fc3b1e38952ba554e40a73" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(24)&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;range(24)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e20d8913c951c136cbfa4ba9fbeb279dcb3126a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(60)&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;range(60)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80cddb7b7e3874d06e76f8eb562205fbd3b77d3e" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;blocking mode&lt;/em&gt;, operations block until complete or the system returns an error (such as connection timed out).</source>
          <target state="translated">에서는 &lt;em&gt;블록 모드&lt;/em&gt; , 작업이 완료 될 때까지 차단 또는 시스템 에러 (접속 시간 초과 등) 리턴한다.</target>
        </trans-unit>
        <trans-unit id="6d6a9efba04a47d4781b6de1610f6fe37834e4f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;non-blocking mode&lt;/em&gt;, operations fail (with an error that is unfortunately system-dependent) if they cannot be completed immediately: functions from the &lt;a href=&quot;select#module-select&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; can be used to know when and whether a socket is available for reading or writing.</source>
          <target state="translated">에서 &lt;em&gt;비 차단 모드&lt;/em&gt; 로부터 기능 : 작업은 즉시 완료 할 수없는 경우 (불행하게도 시스템에 의존 오류가) 실패 &lt;a href=&quot;select#module-select&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 소켓이 읽거나 쓰기 위해 사용할 수있는 경우인지 알고하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1de600e7748b1b2c637dacf9c402ecc59c2e3930" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;timeout mode&lt;/em&gt;, operations fail if they cannot be completed within the timeout specified for the socket (they raise a &lt;a href=&quot;#socket.timeout&quot;&gt;&lt;code&gt;timeout&lt;/code&gt;&lt;/a&gt; exception) or if the system returns an error.</source>
          <target state="translated">에서 &lt;em&gt;시간 제한 모드&lt;/em&gt; 가 소켓 (그들이 제기에 대해 지정된 제한 시간 내에 완료 할 수없는 경우, 작업이 실패 &lt;a href=&quot;#socket.timeout&quot;&gt; &lt;code&gt;timeout&lt;/code&gt; &lt;/a&gt; 예외) 또는 시스템 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93e4a4e56d6d1e50756bb9c6e4bc1bc4ccb5eed5" translate="yes" xml:space="preserve">
          <source>In BLAKE2 the salt is processed as a one-time input to the hash function during initialization, rather than as an input to each compression function.</source>
          <target state="translated">BLAKE2에서 솔트는 각 압축 함수에 대한 입력이 아니라 초기화 중에 해시 함수에 대한 일회성 입력으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7d0b0868fac88a221721ed400ce1bb944f7db5" translate="yes" xml:space="preserve">
          <source>In Babyl mailboxes, the headers of a message are not stored contiguously with the body of the message. To generate a file-like representation, the headers and body are copied together into an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; instance, which has an API identical to that of a file. As a result, the file-like object is truly independent of the underlying mailbox but does not save memory compared to a string representation.</source>
          <target state="translated">Babyl 메일 함에서 메시지 헤더는 메시지 본문과 연속적으로 저장되지 않습니다. 파일과 같은 표현을 생성하기 위해 헤더와 본문이 &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 인스턴스에 함께 복사되며 파일과 동일한 API를 갖습니다. 결과적으로 파일과 같은 개체는 기본 사서함과 독립적이지만 문자열 표현에 비해 메모리를 절약하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="a441fd784df981e42da3513e4f1b407c066fa595" translate="yes" xml:space="preserve">
          <source>In Boolean contexts, a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object is always considered to be true.</source>
          <target state="translated">부울 컨텍스트에서 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체는 항상 참으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3c9b44f6dcf172af2afd8e8696bebf4c5016d825" translate="yes" xml:space="preserve">
          <source>In Boolean contexts, a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object is considered to be true if and only if it isn&amp;rsquo;t equal to &lt;code&gt;timedelta(0)&lt;/code&gt;.</source>
          <target state="translated">부울 컨텍스트에서 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체는 &lt;code&gt;timedelta(0)&lt;/code&gt; 과 같지 않은 경우에만 true로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f761eb1aa256d436b20321c9c6e424dc4749847" translate="yes" xml:space="preserve">
          <source>In Boolean contexts, all &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; objects are considered to be true.</source>
          <target state="translated">부울 컨텍스트에서 모든 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 개체는 true로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4133c1559bb69d3748ad119bc549a3b63e788a0f" translate="yes" xml:space="preserve">
          <source>In CPython, generator-based coroutines (generators decorated with &lt;a href=&quot;types#types.coroutine&quot;&gt;&lt;code&gt;types.coroutine()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt;&lt;code&gt;asyncio.coroutine()&lt;/code&gt;&lt;/a&gt;) are &lt;em&gt;awaitables&lt;/em&gt;, even though they do not have an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt;&lt;code&gt;__await__()&lt;/code&gt;&lt;/a&gt; method. Using &lt;code&gt;isinstance(gencoro, Awaitable)&lt;/code&gt; for them will return &lt;code&gt;False&lt;/code&gt;. Use &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; to detect them.</source>
          <target state="translated">CPython에있어서, 발전기 계 코 루틴 (장식 발전기 &lt;a href=&quot;types#types.coroutine&quot;&gt; &lt;code&gt;types.coroutine()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt; &lt;code&gt;asyncio.coroutine()&lt;/code&gt; &lt;/a&gt; )이다 &lt;em&gt;awaitables&lt;/em&gt; 그들이 갖고 있지 않더라도 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt; &lt;code&gt;__await__()&lt;/code&gt; &lt;/a&gt; 방법. 그들을 위해 &lt;code&gt;isinstance(gencoro, Awaitable)&lt;/code&gt; 를 사용하면 &lt;code&gt;False&lt;/code&gt; 가 반환 됩니다. &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 감지 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cae09edf26f6e37b7e750f76e28a3e8c3c44cf6" translate="yes" xml:space="preserve">
          <source>In CPython, generator-based coroutines (generators decorated with &lt;a href=&quot;types#types.coroutine&quot;&gt;&lt;code&gt;types.coroutine()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt;&lt;code&gt;asyncio.coroutine()&lt;/code&gt;&lt;/a&gt;) are &lt;em&gt;awaitables&lt;/em&gt;, even though they do not have an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt;&lt;code&gt;__await__()&lt;/code&gt;&lt;/a&gt; method. Using &lt;code&gt;isinstance(gencoro, Coroutine)&lt;/code&gt; for them will return &lt;code&gt;False&lt;/code&gt;. Use &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; to detect them.</source>
          <target state="translated">CPython에있어서, 발전기 계 코 루틴 (장식 발전기 &lt;a href=&quot;types#types.coroutine&quot;&gt; &lt;code&gt;types.coroutine()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt; &lt;code&gt;asyncio.coroutine()&lt;/code&gt; &lt;/a&gt; )이다 &lt;em&gt;awaitables&lt;/em&gt; 그들이 갖고 있지 않더라도 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt; &lt;code&gt;__await__()&lt;/code&gt; &lt;/a&gt; 방법. 그들을 위해 &lt;code&gt;isinstance(gencoro, Coroutine)&lt;/code&gt; 를 사용하면 &lt;code&gt;False&lt;/code&gt; 가 반환 됩니다. &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 감지 하십시오 .</target>
        </trans-unit>
        <trans-unit id="631366628298d4582a6ee037a9362b871c3234a2" translate="yes" xml:space="preserve">
          <source>In Python 2 code the &lt;code&gt;_order_&lt;/code&gt; attribute is necessary as definition order is lost before it can be recorded.</source>
          <target state="translated">Python 2 코드에서 &lt;code&gt;_order_&lt;/code&gt; 속성은 정의 순서가 기록되기 전에 유실되므로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3bc7f7458422d2effbdbed743271c2b54fbb7402" translate="yes" xml:space="preserve">
          <source>In Python, all exceptions must be instances of a class that derives from &lt;a href=&quot;#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;. In a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement with an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; clause that mentions a particular class, that clause also handles any exception classes derived from that class (but not exception classes from which &lt;em&gt;it&lt;/em&gt; is derived). Two exception classes that are not related via subclassing are never equivalent, even if they have the same name.</source>
          <target state="translated">Python에서 모든 예외는 &lt;a href=&quot;#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 에서 파생 된 클래스의 인스턴스 여야합니다 . A의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 에 문 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; 특정 클래스를 언급 절, 그 조항은 그 클래스 (있는하지만 예외 클래스에서 파생 된 예외 클래스 처리 &lt;em&gt;가&lt;/em&gt; 파생됩니다). 서브 클래 싱을 통해 관련되지 않은 두 개의 예외 클래스는 이름이 같더라도 절대 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0e22094af023753a3f8645474baf7875adb216c" translate="yes" xml:space="preserve">
          <source>In Python, file names, command line arguments, and environment variables are represented using the string type. On some systems, decoding these strings to and from bytes is necessary before passing them to the operating system. Python uses the file system encoding to perform this conversion (see &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Python에서 파일 이름, 명령 행 인수 및 환경 변수는 문자열 유형을 사용하여 표시됩니다. 일부 시스템에서는 이러한 문자열을 운영 체제로 전달하기 전에 바이트와의 디코딩이 필요합니다. Python은 파일 시스템 인코딩을 사용하여이 변환을 수행합니다 ( &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4a265e5614bc913aa2b5d3df9ffa283db482f3d1" translate="yes" xml:space="preserve">
          <source>In Python, since there is an interpreter active during execution, the presence of instrumented code is not required in order to do deterministic profiling. Python automatically provides a &lt;em&gt;hook&lt;/em&gt; (optional callback) for each event. In addition, the interpreted nature of Python tends to add so much overhead to execution, that deterministic profiling tends to only add small processing overhead in typical applications. The result is that deterministic profiling is not that expensive, yet provides extensive run time statistics about the execution of a Python program.</source>
          <target state="translated">Python에서는 실행 중에 활성 인터프리터가 있으므로 결정적 프로파일 링을 수행하기 위해 인스트루먼트 된 코드가 필요하지 않습니다. 파이썬은 자동으로 각 이벤트에 대한 &lt;em&gt;후크&lt;/em&gt; (선택적 콜백)를 제공합니다 . 또한, 파이썬의 해석 된 특성은 실행에 너무 많은 오버 헤드를 추가하는 경향이 있으며, 결정적 프로파일 링은 일반적인 애플리케이션에서 작은 처리 오버 헤드 만 추가하는 경향이 있습니다. 결과적으로 결정 론적 프로파일 링은 그다지 비싸지 않지만 파이썬 프로그램의 실행에 대한 광범위한 런타임 통계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="07ba9e60148d18758b640f6ed814832833d34be7" translate="yes" xml:space="preserve">
          <source>In Tk, there is a utility command, &lt;code&gt;wm&lt;/code&gt;, for interacting with the window manager. Options to the &lt;code&gt;wm&lt;/code&gt; command allow you to control things like titles, placement, icon bitmaps, and the like. In &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt;, these commands have been implemented as methods on the &lt;code&gt;Wm&lt;/code&gt; class. Toplevel widgets are subclassed from the &lt;code&gt;Wm&lt;/code&gt; class, and so can call the &lt;code&gt;Wm&lt;/code&gt; methods directly.</source>
          <target state="translated">Tk에는 &lt;code&gt;wm&lt;/code&gt; 이라는 유틸리티 명령이 있습니다. 에는 창 관리자와 상호 작용하기위한 이 있습니다. &lt;code&gt;wm&lt;/code&gt; 명령 옵션을 사용하면 제목, 배치, 아이콘 비트 맵 등과 같은 항목을 제어 할 수 있습니다. 에서 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; ,이 명령은 메소드로 구현 된 &lt;code&gt;Wm&lt;/code&gt; 클래스입니다. 최상위 레벨 위젯은 &lt;code&gt;Wm&lt;/code&gt; 클래스 에서 서브 클래스 되므로 &lt;code&gt;Wm&lt;/code&gt; 메소드를 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4bf65333e7dc9c2da7ca99bbab91025e00bf167" translate="yes" xml:space="preserve">
          <source>In Tk, to perform an action on a widget, use the widget name as a command, and follow it with an action name, possibly with arguments (options). In Tkinter, you call methods on the class instance to invoke actions on the widget. The actions (methods) that a given widget can perform are listed in &lt;code&gt;tkinter/__init__.py&lt;/code&gt;.</source>
          <target state="translated">Tk에서 위젯에 대한 조치를 수행하려면 위젯 이름을 명령으로 사용하고 조치 이름을 인수 (옵션)와 함께 사용하십시오. Tkinter에서는 클래스 인스턴스에서 메소드를 호출하여 위젯에서 조치를 호출합니다. 주어진 위젯이 수행 할 수있는 조치 (방법)는 &lt;code&gt;tkinter/__init__.py&lt;/code&gt; 에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b35e4b6aee318c8476142aafce45b3919ab5f7" translate="yes" xml:space="preserve">
          <source>In a mailcap file, the &amp;ldquo;test&amp;rdquo; field can optionally be specified to test some external condition (such as the machine architecture, or the window system in use) to determine whether or not the mailcap line applies. &lt;a href=&quot;#mailcap.findmatch&quot;&gt;&lt;code&gt;findmatch()&lt;/code&gt;&lt;/a&gt; will automatically check such conditions and skip the entry if the check fails.</source>
          <target state="translated">메일 캡 파일에서 &quot;테스트&quot;필드를 선택하여 메일 캡 라인이 적용되는지 여부를 결정하기 위해 일부 외부 조건 (예 : 머신 아키텍처 또는 사용중인 윈도우 시스템)을 테스트 할 수 있습니다. &lt;a href=&quot;#mailcap.findmatch&quot;&gt; &lt;code&gt;findmatch()&lt;/code&gt; &lt;/a&gt; 는 이러한 조건을 자동으로 확인하고 확인에 실패하면 항목을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="dff27fd73d9cbfd83fc3861e07e29a5ce9fa9b2c" translate="yes" xml:space="preserve">
          <source>In a model generated from bytes, any header values that (in contravention of the RFCs) contain non-ASCII bytes will, when retrieved through this interface, be represented as &lt;a href=&quot;email.header#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; objects with a charset of &lt;code&gt;unknown-8bit&lt;/code&gt;.</source>
          <target state="translated">바이트에서 생성 된 모델에서, RFC와 충돌하여 비 ASCII 바이트를 포함하는 헤더 값은이 인터페이스를 통해 검색 될 때 &lt;code&gt;unknown-8bit&lt;/code&gt; 의 문자 세트를 가진 &lt;a href=&quot;email.header#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 오브젝트 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcdf824d25e196bd0265599e5fc259b9d7a7343d" translate="yes" xml:space="preserve">
          <source>In a multithreaded process, use caution to avoid leaking handles that are marked inheritable when combining this feature with concurrent calls to other process creation functions that inherit all handles such as &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt;. This also applies to standard handle redirection, which temporarily creates inheritable handles.</source>
          <target state="translated">멀티 스레드 프로세스에서는이 기능을 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 과 같은 모든 핸들을 상속하는 다른 프로세스 작성 함수에 대한 동시 호출과 결합 할 때 상속 가능으로 표시된 핸들이 새지 않도록주의하십시오 . 이것은 상속 가능한 핸들을 일시적으로 생성하는 표준 핸들 리디렉션에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="29450dfd4c15b79ba3d022659c17515b216a2723" translate="yes" xml:space="preserve">
          <source>In a script, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will typically be called with no arguments, and the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; will automatically determine the command-line arguments from &lt;a href=&quot;sys#sys.argv&quot;&gt;&lt;code&gt;sys.argv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스크립트에서 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 일반적으로 인수없이 호출되며&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;sys#sys.argv&quot;&gt; &lt;code&gt;sys.argv&lt;/code&gt; &lt;/a&gt; 에서 명령 줄 인수를 자동으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b3bcc045679addb686c190d0e988b9e965c3a92d" translate="yes" xml:space="preserve">
          <source>In a script, typical usage is something like this:</source>
          <target state="translated">스크립트에서 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2b64a4d09137b4b9dd59b9330a2c7d91bb6320b" translate="yes" xml:space="preserve">
          <source>In a word, heaps are useful memory structures to know. I use them in a few applications, and I think it is good to keep a &amp;lsquo;heap&amp;rsquo; module around. :-)</source>
          <target state="translated">한마디로, 힙은 알아야 할 유용한 메모리 구조입니다. 나는 몇 가지 응용 프로그램에서 사용하며 '힙'모듈을 유지하는 것이 좋습니다. :-)</target>
        </trans-unit>
        <trans-unit id="9f2f0f5240c4f2006c555b058d4decb08fc35f55" translate="yes" xml:space="preserve">
          <source>In accordance with the standard, the &lt;a href=&quot;#module-decimal&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; module provides two ready to use standard contexts, &lt;a href=&quot;#decimal.BasicContext&quot;&gt;&lt;code&gt;BasicContext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decimal.ExtendedContext&quot;&gt;&lt;code&gt;ExtendedContext&lt;/code&gt;&lt;/a&gt;. The former is especially useful for debugging because many of the traps are enabled:</source>
          <target state="translated">표준에 따라 &lt;a href=&quot;#module-decimal&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;a href=&quot;#decimal.BasicContext&quot;&gt; &lt;code&gt;BasicContext&lt;/code&gt; &lt;/a&gt; 와 BasicContext 및&lt;a href=&quot;#decimal.ExtendedContext&quot;&gt; &lt;code&gt;ExtendedContext&lt;/code&gt; 라는&lt;/a&gt;. 전자는 많은 트랩이 활성화되어 있기 때문에 디버깅에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d46ae7189ab259286c168e0b80b2fd3235fd9aed" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;, &lt;code&gt;'base64_codec'&lt;/code&gt; also accepts ASCII-only instances of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; for decoding</source>
          <target state="translated">뿐만 아니라 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;code&gt;'base64_codec'&lt;/code&gt; 도의 ASCII 전용 인스턴스를 받아 들인다&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 디코딩을</target>
        </trans-unit>
        <trans-unit id="a7b20715c6c20497ac319a68d7016a8f75ae620e" translate="yes" xml:space="preserve">
          <source>In addition to being more CPU-intensive, compression with higher presets also requires much more memory (and produces output that needs more memory to decompress). With preset &lt;code&gt;9&lt;/code&gt; for example, the overhead for an &lt;a href=&quot;#lzma.LZMACompressor&quot;&gt;&lt;code&gt;LZMACompressor&lt;/code&gt;&lt;/a&gt; object can be as high as 800 MiB. For this reason, it is generally best to stick with the default preset.</source>
          <target state="translated">CPU를 많이 사용하는 것 외에도 사전 설정이 높은 압축에는 훨씬 더 많은 메모리가 필요하며 압축을 풀기 위해 더 많은 메모리가 필요한 출력이 생성됩니다. 예를 들어 사전 설정 &lt;code&gt;9&lt;/code&gt; 를 사용 하면&lt;a href=&quot;#lzma.LZMACompressor&quot;&gt; &lt;code&gt;LZMACompressor&lt;/code&gt; &lt;/a&gt; 객체 800MiB에이를 수 있습니다. 따라서 일반적으로 기본 사전 설정을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="62f40ff2f60f38cdc6a391277467f1c0b2fc7189" translate="yes" xml:space="preserve">
          <source>In addition to enabling the debug mode, consider also:</source>
          <target state="translated">디버그 모드를 활성화하는 것 외에도 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9b6341c25f3405f85d37bcad24b0b303303d029c" translate="yes" xml:space="preserve">
          <source>In addition to implementing the methods above, implementations of the &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; interface must also supply the following attributes, indicating which protocols should be used, and how. All of these attributes may be assigned to.</source>
          <target state="translated">위의 방법을 구현하는 것 외에도 &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; 의&lt;/a&gt; 구현 인터페이스의 사용해야 할 프로토콜과 방법을 나타내는 다음 속성을 제공해야합니다. 이러한 모든 속성이 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8600bc88afada2a15d07e3d3b860294a40b1a7" translate="yes" xml:space="preserve">
          <source>In addition to many functions described in the &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module documentation, &lt;a href=&quot;#module-posix&quot;&gt;&lt;code&gt;posix&lt;/code&gt;&lt;/a&gt; defines the following data item:</source>
          <target state="translated">&lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈 설명서에 설명 된 많은 기능 외에도&lt;a href=&quot;#module-posix&quot;&gt; &lt;code&gt;posix&lt;/code&gt; &lt;/a&gt; 는 다음 데이터 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ea70a6e7df22f6334f5444417337936e1629f2a1" translate="yes" xml:space="preserve">
          <source>In addition to method lookups, &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; also works for attribute lookups. One possible use case for this is calling &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;descriptors&lt;/a&gt; in a parent or sibling class.</source>
          <target state="translated">메소드 조회 외에도 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 는 속성 조회에도 작동합니다. 이에 대한 가능한 사용 사례는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;디스크립터를&lt;/a&gt; 호출하는 것입니다. 는 부모 또는 형제 클래스에서 를 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dcad6a5eb6d0ad37696a20f7d2411fda996f3b45" translate="yes" xml:space="preserve">
          <source>In addition to size-limiting tools, the module also provides a decorator for detecting recursive calls to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt; and substituting a placeholder string instead.</source>
          <target state="translated">크기 제한 도구 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 모듈은 __repr __ ()에 대한 재귀 호출을 감지하기위한 데코레이터를 제공합니다. 하고 대신 자리 표시 자 문자열을 대체 .</target>
        </trans-unit>
        <trans-unit id="8d830c6765c9dc0300fe6b5cbc2b3e8460866e69" translate="yes" xml:space="preserve">
          <source>In addition to supporting the methods and operations of mappings, &lt;a href=&quot;#collections.UserDict&quot;&gt;&lt;code&gt;UserDict&lt;/code&gt;&lt;/a&gt; instances provide the following attribute:</source>
          <target state="translated">&lt;a href=&quot;#collections.UserDict&quot;&gt; &lt;code&gt;UserDict&lt;/code&gt; &lt;/a&gt; 매핑 방법 및 작업을 지원할뿐만 아니라 인스턴스 다음과 같은 특성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8807f211b2460760255a1709766f0a3137c6dab" translate="yes" xml:space="preserve">
          <source>In addition to supporting the methods and operations of mutable sequences, &lt;a href=&quot;#collections.UserList&quot;&gt;&lt;code&gt;UserList&lt;/code&gt;&lt;/a&gt; instances provide the following attribute:</source>
          <target state="translated">&lt;a href=&quot;#collections.UserList&quot;&gt; &lt;code&gt;UserList&lt;/code&gt; &lt;/a&gt; 는 가변 시퀀스의 방법과 작동을 지원할뿐만 아니라 인스턴스 다음과 같은 특성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04aa2e8b62d41221e69b20a54dc36f3e6372ea8e" translate="yes" xml:space="preserve">
          <source>In addition to supporting the methods and operations of strings, &lt;a href=&quot;#collections.UserString&quot;&gt;&lt;code&gt;UserString&lt;/code&gt;&lt;/a&gt; instances provide the following attribute:</source>
          <target state="translated">문자열의 메소드 및 조작을 지원하는 것 외에도 &lt;a href=&quot;#collections.UserString&quot;&gt; &lt;code&gt;UserString&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2cf43345efe70766c6640171cc92f01b4817ca97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt; API, &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; objects also support the following attributes and methods:</source>
          <target state="translated">&lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; API 외에도 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체는 다음과 같은 속성 및 메서드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3537cce0770809bd80cddc6370639f4675c1c292" translate="yes" xml:space="preserve">
          <source>In addition to the Tk interface module, &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; includes a number of Python modules, &lt;code&gt;tkinter.constants&lt;/code&gt; being one of the most important. Importing &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; will automatically import &lt;code&gt;tkinter.constants&lt;/code&gt;, so, usually, to use Tkinter all you need is a simple import statement:</source>
          <target state="translated">Tk 인터페이스 모듈 외에도 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 에는 많은 Python 모듈이 포함되어 있으며 &lt;code&gt;tkinter.constants&lt;/code&gt; 가 가장 중요합니다. 가져 오기 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 자동으로 가져옵니다 &lt;code&gt;tkinter.constants&lt;/code&gt; 을 , 그래서, 일반적으로, 당신이 필요로하는 모든 간단한 import 문이다 Tkinter를 사용하기 :</target>
        </trans-unit>
        <trans-unit id="9690476654ee5a2736c4ceafa04629e93b08060a" translate="yes" xml:space="preserve">
          <source>In addition to the above methods, the &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; must also inherit all other methods and attributes from the underlying stream.</source>
          <target state="translated">위의 방법 외에도 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 는 기본 스트림에서 다른 모든 메소드 및 속성을 상속해야합니다.</target>
        </trans-unit>
        <trans-unit id="222314dc286fea8c88b16cc332dcefcec6c56990" translate="yes" xml:space="preserve">
          <source>In addition to the above methods, the &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; must also inherit all other methods and attributes from the underlying stream.</source>
          <target state="translated">위의 메소드 외에도 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 는 기본 스트림에서 다른 모든 메소드 및 속성을 상속해야합니다.</target>
        </trans-unit>
        <trans-unit id="1720f463c1df0d0fe9311a603541746810b18c89" translate="yes" xml:space="preserve">
          <source>In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except &lt;code&gt;'n'&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt;). When doing so, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float()&lt;/code&gt;&lt;/a&gt; is used to convert the integer to a floating point number before formatting.</source>
          <target state="translated">위의 프리젠 테이션 유형 외에도 정수는 아래에 나열된 부동 소수점 프리젠 테이션 유형으로 형식화 될 수 있습니다 ( &lt;code&gt;'n'&lt;/code&gt; 및 &lt;code&gt;None&lt;/code&gt; 제외) . 그렇게 할 때, &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float()&lt;/code&gt; &lt;/a&gt; 는 포맷하기 전에 정수를 부동 소수점 숫자로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa4995b269e79140bbd715d66781cc2d6ced577" translate="yes" xml:space="preserve">
          <source>In addition to the above, &lt;a href=&quot;#logging.LoggerAdapter&quot;&gt;&lt;code&gt;LoggerAdapter&lt;/code&gt;&lt;/a&gt; supports the following methods of &lt;a href=&quot;#logging.Logger&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;#logging.Logger.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.warning&quot;&gt;&lt;code&gt;warning()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.error&quot;&gt;&lt;code&gt;error()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.exception&quot;&gt;&lt;code&gt;exception()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.critical&quot;&gt;&lt;code&gt;critical()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.log&quot;&gt;&lt;code&gt;log()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.isEnabledFor&quot;&gt;&lt;code&gt;isEnabledFor()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt;&lt;code&gt;getEffectiveLevel()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt;&lt;code&gt;setLevel()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#logging.Logger.hasHandlers&quot;&gt;&lt;code&gt;hasHandlers()&lt;/code&gt;&lt;/a&gt;. These methods have the same signatures as their counterparts in &lt;a href=&quot;#logging.Logger&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;, so you can use the two types of instances interchangeably.</source>
          <target state="translated">위의 이외에도 &lt;a href=&quot;#logging.LoggerAdapter&quot;&gt; &lt;code&gt;LoggerAdapter&lt;/code&gt; &lt;/a&gt; 는 다음 &lt;a href=&quot;#logging.Logger&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 메소드를 지원합니다 . &lt;a href=&quot;#logging.Logger.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.info&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.warning&quot;&gt; &lt;code&gt;warning()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.error&quot;&gt; &lt;code&gt;error()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.exception&quot;&gt; &lt;code&gt;exception()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.critical&quot;&gt; &lt;code&gt;critical()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.log&quot;&gt; &lt;code&gt;log()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.isEnabledFor&quot;&gt; &lt;code&gt;isEnabledFor()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt; &lt;code&gt;getEffectiveLevel()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt; &lt;code&gt;setLevel()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#logging.Logger.hasHandlers&quot;&gt; &lt;code&gt;hasHandlers()&lt;/code&gt; &lt;/a&gt; . 이러한 메소드는 &lt;a href=&quot;#logging.Logger&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 의&lt;/a&gt; 해당 메소드와 동일한 서명을 가지므로 두 가지 유형의 인스턴스를 상호 교환하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d50c1e6c07de1acc4db99246c84c882aabeeb1c" translate="yes" xml:space="preserve">
          <source>In addition to the above, deques support iteration, pickling, &lt;code&gt;len(d)&lt;/code&gt;, &lt;code&gt;reversed(d)&lt;/code&gt;, &lt;code&gt;copy.copy(d)&lt;/code&gt;, &lt;code&gt;copy.deepcopy(d)&lt;/code&gt;, membership testing with the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; operator, and subscript references such as &lt;code&gt;d[0]&lt;/code&gt; to access the first element. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access, use lists instead.</source>
          <target state="translated">위의 외에도 deques는 반복, 피클 링, &lt;code&gt;len(d)&lt;/code&gt; , &lt;code&gt;reversed(d)&lt;/code&gt; , &lt;code&gt;copy.copy(d)&lt;/code&gt; , &lt;code&gt;copy.deepcopy(d)&lt;/code&gt; ,&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 연산자를및 &lt;code&gt;d[0]&lt;/code&gt; 을 눌러 첫 번째 요소에 액세스하십시오. 인덱스 된 액세스는 양쪽 끝에 O (1)이지만 중간에 O (n)까지 느려집니다. 빠른 임의 액세스를 위해서는 대신 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ebaf021a38f23d1b3be305231ce1cfa6bc43bf01" translate="yes" xml:space="preserve">
          <source>In addition to the attributes and methods from &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.FileIO&quot;&gt;&lt;code&gt;FileIO&lt;/code&gt;&lt;/a&gt; provides the following data attributes:</source>
          <target state="translated">의 속성과 메소드 외에도 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#io.FileIO&quot;&gt; &lt;code&gt;FileIO&lt;/code&gt; &lt;/a&gt; 다음과 같은 데이터 속성을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="14586c995a780d78561f97624099b8e4ec9b4105" translate="yes" xml:space="preserve">
          <source>In addition to the attributes and methods from &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; provides the following methods:</source>
          <target state="translated">&lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 의 속성 및 메소드 외에도 , &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; 외에도&lt;/a&gt; 다음과 같은 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="52fd5a33b320649b6f1060489177810635c6ea92" translate="yes" xml:space="preserve">
          <source>In addition to the classes described above, there are a number of module-level functions.</source>
          <target state="translated">위에서 설명한 클래스 외에도 많은 모듈 수준 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1112b3c989ed862bdeb0f82d3c1bc4efa761003" translate="yes" xml:space="preserve">
          <source>In addition to the dictionary-like methods, &lt;code&gt;gdbm&lt;/code&gt; objects have the following methods:</source>
          <target state="translated">사전과 같은 방법 외에도 &lt;code&gt;gdbm&lt;/code&gt; 객체는 다음과 같은 메소드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6226060e492ea216f0e7f78ce7856fca0eebffd1" translate="yes" xml:space="preserve">
          <source>In addition to the dictionary-like methods, &lt;code&gt;ndbm&lt;/code&gt; objects provide the following method:</source>
          <target state="translated">사전과 같은 방법 외에도 &lt;code&gt;ndbm&lt;/code&gt; 객체는 다음과 같은 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cea61bcebf3b4dd67f209d89e9e334cbef2a059e" translate="yes" xml:space="preserve">
          <source>In addition to the environment functions above, the &lt;a href=&quot;#module-wsgiref.util&quot;&gt;&lt;code&gt;wsgiref.util&lt;/code&gt;&lt;/a&gt; module also provides these miscellaneous utilities:</source>
          <target state="translated">위의 환경 기능 외에도 &lt;a href=&quot;#module-wsgiref.util&quot;&gt; &lt;code&gt;wsgiref.util&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기타 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="858dce34107f4186993a5996db613388f2631800" translate="yes" xml:space="preserve">
          <source>In addition to the examples below, more examples are given in &lt;a href=&quot;https://docs.python.org/3.8/howto/urllib2.html#urllib-howto&quot;&gt;HOWTO Fetch Internet Resources Using The urllib Package&lt;/a&gt;.</source>
          <target state="translated">아래 예 외에도 더 많은 예가 나와 있습니다. &lt;a href=&quot;https://docs.python.org/3.8/howto/urllib2.html#urllib-howto&quot;&gt; urllib 패키지를 사용하여 인터넷 리소스를 가져&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b096e1520c7229739493907c163d5aa90e2c7fd3" translate="yes" xml:space="preserve">
          <source>In addition to the features required to implement the &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; interface, this class allows you to block and allow domains from setting and receiving cookies. There are also some strictness switches that allow you to tighten up the rather loose Netscape protocol rules a little bit (at the cost of blocking some benign cookies).</source>
          <target state="translated">구현하는 데 필요한 기능 외에도 &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 인터페이스 클래스를 사용하면 도메인이 쿠키를 설정 및 수신하지 못하도록 차단하고 허용 할 수 있습니다. 또한 다소 느슨한 Netscape 프로토콜 규칙을 약간 강화할 수있는 일부 엄격 성 스위치가 있습니다 (일부 양성 쿠키를 차단하는 비용으로).</target>
        </trans-unit>
        <trans-unit id="1dc8d82427b096c43fc2e7d5213bd591f0d85590" translate="yes" xml:space="preserve">
          <source>In addition to the literal forms, bytes objects can be created in a number of other ways:</source>
          <target state="translated">리터럴 형식 외에도 bytes 객체는 여러 가지 다른 방법으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c64e42d0dab883c69e970748044e9e77b97cb7a8" translate="yes" xml:space="preserve">
          <source>In addition to the methods inherited from tuples, named tuples support three additional methods and two attributes. To prevent conflicts with field names, the method and attribute names start with an underscore.</source>
          <target state="translated">튜플에서 상속 된 메서드 외에도 명명 된 튜플은 세 가지 추가 메서드와 두 가지 특성을 지원합니다. 필드 이름과의 충돌을 방지하기 위해 메소드와 속성 이름은 밑줄로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e2f6ddf1bf12cf34152fec328d39c9d8ce0a989d" translate="yes" xml:space="preserve">
          <source>In addition to the methods provided by the &lt;a href=&quot;collections.abc#collections.abc.MutableMapping&quot;&gt;&lt;code&gt;collections.abc.MutableMapping&lt;/code&gt;&lt;/a&gt; class, &lt;code&gt;dumbdbm&lt;/code&gt; objects provide the following methods:</source>
          <target state="translated">&lt;a href=&quot;collections.abc#collections.abc.MutableMapping&quot;&gt; &lt;code&gt;collections.abc.MutableMapping&lt;/code&gt; &lt;/a&gt; 클래스 &lt;code&gt;dumbdbm&lt;/code&gt; 에서 제공하는 메소드 외에도 오브젝트는 다음 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49c9b324d276aba55bfa28551beee12479bf0531" translate="yes" xml:space="preserve">
          <source>In addition to the operations listed above, &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; objects support certain additions and subtractions with &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; objects (see below).</source>
          <target state="translated">위에 나열된 작업 외에도 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체는 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 와 함께 특정 덧셈과 뺄셈을 지원 합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8c4c56f4ca00cb6b6be40eba948fd85089f6ade4" translate="yes" xml:space="preserve">
          <source>In addition to the settable attributes listed above that apply to all policies, this policy adds the following additional attributes:</source>
          <target state="translated">모든 정책에 적용되는 위에 나열된 설정 가능 속성 외에도이 정책은 다음과 같은 추가 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7d6fe1a1b1f7fcd5eef30c9780f9e8758b294753" translate="yes" xml:space="preserve">
          <source>In addition to the standard library, there is a growing collection of several thousand components (from individual programs and modules to packages and entire application development frameworks), available from the &lt;a href=&quot;https://pypi.org&quot;&gt;Python Package Index&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리 외에도 &lt;a href=&quot;https://pypi.org&quot;&gt;Python Package Index&lt;/a&gt; 에서 사용할 수있는 수천 개의 구성 요소 (개별 프로그램 및 모듈에서 패키지 및 전체 응용 프로그램 개발 프레임 워크) 컬렉션이 증가하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37b1282f5319fc90d1ae0fbf402438654f72c8b7" translate="yes" xml:space="preserve">
          <source>In addition to the standard numeric properties, decimal floating point objects also have a number of specialized methods:</source>
          <target state="translated">십진 부동 소수점 객체에는 표준 숫자 속성 외에도 여러 가지 특수한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="20844ff85a7de274374759963a07f03ca0ec2fa4" translate="yes" xml:space="preserve">
          <source>In addition to the three supplied contexts, new contexts can be created with the &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">세 공급 상황에 더하여, 새로운 컨텍스트가 생성 될 수와 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 생성자를 .</target>
        </trans-unit>
        <trans-unit id="032befaca731d1da6b9f55a3d41598ab32bb42d3" translate="yes" xml:space="preserve">
          <source>In addition to the two signed zeros which are distinct yet equal, there are various representations of zero with differing precisions yet equivalent in value. This takes a bit of getting used to. For an eye accustomed to normalized floating point representations, it is not immediately obvious that the following calculation returns a value equal to zero:</source>
          <target state="translated">서로 다르지만 동일한 두 개의 부호있는 0 외에도 정밀도는 다르지만 값은 동일한 0의 다양한 표현이 있습니다. 익숙해지는 데 약간의 시간이 걸립니다. 정규화 된 부동 소수점 표현에 익숙한 눈의 경우 다음 계산에서 0과 같은 값을 반환한다는 것은 분명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="470a6fd8b7a670e99e5471d463edd75a822561e0" translate="yes" xml:space="preserve">
          <source>In addition to the usual mapping methods, ordered dictionaries also support reverse iteration using &lt;a href=&quot;functions#reversed&quot;&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 매핑 방법 외에도 정렬 된 사전은 &lt;a href=&quot;functions#reversed&quot;&gt; &lt;code&gt;reversed()&lt;/code&gt; &lt;/a&gt; 사용하여 역 반복을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="1f6056a668fa6b597cd5e06fbb9eab25b2a47143" translate="yes" xml:space="preserve">
          <source>In addition to their mapping interface and formatting features, &lt;a href=&quot;#wsgiref.headers.Headers&quot;&gt;&lt;code&gt;Headers&lt;/code&gt;&lt;/a&gt; objects also have the following methods for querying and adding multi-valued headers, and for adding headers with MIME parameters:</source>
          <target state="translated">매핑 인터페이스 및 서식 기능 외에도 &lt;a href=&quot;#wsgiref.headers.Headers&quot;&gt; &lt;code&gt;Headers&lt;/code&gt; &lt;/a&gt; 객체에는 다중 값 헤더를 쿼리 및 추가하고 MIME 매개 변수를 사용하여 헤더를 추가하는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37effc66593dde7858807d6c481046b5424a851" translate="yes" xml:space="preserve">
          <source>In addition to these classes, &lt;a href=&quot;#module-xml.sax&quot;&gt;&lt;code&gt;xml.sax&lt;/code&gt;&lt;/a&gt; provides the following exception classes.</source>
          <target state="translated">이러한 클래스 외에도 &lt;a href=&quot;#module-xml.sax&quot;&gt; &lt;code&gt;xml.sax&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 예외 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3c5fc990cbc73c12c0b40300fad7df5e7ee287cd" translate="yes" xml:space="preserve">
          <source>In addition to these classes, &lt;a href=&quot;#module-xml.sax.handler&quot;&gt;&lt;code&gt;xml.sax.handler&lt;/code&gt;&lt;/a&gt; provides symbolic constants for the feature and property names.</source>
          <target state="translated">이러한 클래스 외에도 &lt;a href=&quot;#module-xml.sax.handler&quot;&gt; &lt;code&gt;xml.sax.handler&lt;/code&gt; &lt;/a&gt; 는 기능 및 속성 이름에 대한 기호 상수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="398bda298534a149091a837cc6c784d269a2e413" translate="yes" xml:space="preserve">
          <source>In addition to these methods, lock objects can also be used via the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, e.g.:</source>
          <target state="translated">이러한 방법 외에도 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 통해 잠금 객체를 사용할 수도 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="324d7520dd2db34f14989622298b9a50942c0a6b" translate="yes" xml:space="preserve">
          <source>In addition to these two forms, there are two additional normal forms based on compatibility equivalence. In Unicode, certain characters are supported which normally would be unified with other characters. For example, U+2160 (ROMAN NUMERAL ONE) is really the same thing as U+0049 (LATIN CAPITAL LETTER I). However, it is supported in Unicode for compatibility with existing character sets (e.g. gb2312).</source>
          <target state="translated">이 두 가지 형식 외에도 호환성 동등성에 따라 두 가지 추가 일반 형식이 있습니다. 유니 코드에서는 일반적으로 다른 문자와 통합되는 특정 문자가 지원됩니다. 예를 들어 U + 2160 (ROMAN NUMERAL ONE)은 실제로 U + 0049 (라틴 대문자 L)와 동일합니다. 그러나 기존 문자 세트와의 호환성을 위해 유니 코드로 지원됩니다 (예 : gb2312).</target>
        </trans-unit>
        <trans-unit id="9e0c6060f180bd1be434b002c3a8e1bb629b28ba" translate="yes" xml:space="preserve">
          <source>In addition to those of &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; can have one more attribute:</source>
          <target state="translated">(IPLA) 외에 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 는&lt;/a&gt; 하나 개 이상의 속성을 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="58b602fd4657546b90e8bec1feb16284ddd90bfc" translate="yes" xml:space="preserve">
          <source>In addition you can pass &lt;code&gt;spec=True&lt;/code&gt; or &lt;code&gt;spec_set=True&lt;/code&gt;, which causes patch to pass in the object being mocked as the spec/spec_set object.</source>
          <target state="translated">또한 &lt;code&gt;spec=True&lt;/code&gt; 또는 &lt;code&gt;spec_set=True&lt;/code&gt; 를 전달하면 spec / spec_set 객체로 조롱되는 객체에 패치가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1538a099b36c536517432c89a4b9de9737c1b154" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;#module-tkinter.tix&quot;&gt;&lt;code&gt;tkinter.tix&lt;/code&gt;&lt;/a&gt; augments &lt;a href=&quot;tkinter#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; by providing:</source>
          <target state="translated">또한 &lt;a href=&quot;#module-tkinter.tix&quot;&gt; &lt;code&gt;tkinter.tix&lt;/code&gt; &lt;/a&gt; 는 다음 을 제공 하여 &lt;a href=&quot;tkinter#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 를 보강 합니다.</target>
        </trans-unit>
        <trans-unit id="ad37a6225b74614726b479be7666d6240684d671" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; contains a base &lt;code&gt;Node&lt;/code&gt; class and the DOM exception classes. The &lt;code&gt;Node&lt;/code&gt; class provided by this module does not implement any of the methods or attributes defined by the DOM specification; concrete DOM implementations must provide those. The &lt;code&gt;Node&lt;/code&gt; class provided as part of this module does provide the constants used for the &lt;code&gt;nodeType&lt;/code&gt; attribute on concrete &lt;code&gt;Node&lt;/code&gt; objects; they are located within the class rather than at the module level to conform with the DOM specifications.</source>
          <target state="translated">또한 &lt;a href=&quot;#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt; 에는 기본 &lt;code&gt;Node&lt;/code&gt; 클래스와 DOM 예외 클래스가 포함됩니다. &lt;code&gt;Node&lt;/code&gt; 이 모듈에서 제공하는 클래스는 DOM 사양에 의해 정의 된 메소드 나 속성 중 하나를 구현하지 않습니다; 구체적인 DOM 구현은이를 제공해야합니다. &lt;code&gt;Node&lt;/code&gt; 사용되는 상수 제공 않고이 모듈의 일부로서 제공하는 클래스 &lt;code&gt;nodeType&lt;/code&gt; 콘크리트 특성 &lt;code&gt;Node&lt;/code&gt; 객체; 그것들은 DOM 스펙을 준수하기 위해 모듈 레벨이 아닌 클래스 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d44ab30dfa1f3ce24fbe120b70c25d4d0b4cc1" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;#venv.EnvBuilder&quot;&gt;&lt;code&gt;EnvBuilder&lt;/code&gt;&lt;/a&gt; provides this utility method that can be called from &lt;a href=&quot;#venv.EnvBuilder.setup_scripts&quot;&gt;&lt;code&gt;setup_scripts()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#venv.EnvBuilder.post_setup&quot;&gt;&lt;code&gt;post_setup()&lt;/code&gt;&lt;/a&gt; in subclasses to assist in installing custom scripts into the virtual environment.</source>
          <target state="translated">또한 &lt;a href=&quot;#venv.EnvBuilder&quot;&gt; &lt;code&gt;EnvBuilder&lt;/code&gt; &lt;/a&gt; 는 서브 클래스의 &lt;a href=&quot;#venv.EnvBuilder.setup_scripts&quot;&gt; &lt;code&gt;setup_scripts()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#venv.EnvBuilder.post_setup&quot;&gt; &lt;code&gt;post_setup()&lt;/code&gt; &lt;/a&gt; 에서 호출 할 수있는이 유틸리티 메소드를 제공 하여 사용자 정의 스크립트를 가상 환경에 설치하는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="8d5378207c9afa23bfe1afa0e6e3ef8b7515d910" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;Tk&lt;/code&gt; also loads a startup file if it is present. Note that the Tk file is loaded unconditionally. This additional file is &lt;code&gt;.Idle.py&lt;/code&gt; and is looked for in the user&amp;rsquo;s home directory. Statements in this file will be executed in the Tk namespace, so this file is not useful for importing functions to be used from IDLE&amp;rsquo;s Python shell.</source>
          <target state="translated">또한 &lt;code&gt;Tk&lt;/code&gt; 는 시작 파일이 있으면로드합니다. Tk 파일은 무조건로드됩니다. 이 추가 파일은 &lt;code&gt;.Idle.py&lt;/code&gt; 이며 사용자의 홈 디렉토리에서 찾습니다 . 이 파일의 명령문은 Tk 네임 스페이스에서 실행되므로이 ​​파일은 IDLE의 Python 셸에서 사용할 함수를 가져 오는 데 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="714413f1caa3214664dffb1034eb3924cd14e3f3" translate="yes" xml:space="preserve">
          <source>In addition, a custom &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt;&lt;code&gt;TreeBuilder&lt;/code&gt;&lt;/a&gt; object can provide the following methods:</source>
          <target state="translated">또한 사용자 정의 &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt; &lt;code&gt;TreeBuilder&lt;/code&gt; &lt;/a&gt; 객체는 다음과 같은 메소드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffffc9f25603a24b2ca6858559ed5b2e495ca947" translate="yes" xml:space="preserve">
          <source>In addition, each channel delegates or extends many of the socket methods. Most of these are nearly identical to their socket partners.</source>
          <target state="translated">또한 각 채널은 많은 소켓 메소드를 위임하거나 확장합니다. 이들 대부분은 소켓 파트너와 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c412f65e105df43e1227481dd3222239a0aaaa6f" translate="yes" xml:space="preserve">
          <source>In addition, every data type that can be packed with a &lt;a href=&quot;#xdrlib.Packer&quot;&gt;&lt;code&gt;Packer&lt;/code&gt;&lt;/a&gt;, can be unpacked with an &lt;a href=&quot;#xdrlib.Unpacker&quot;&gt;&lt;code&gt;Unpacker&lt;/code&gt;&lt;/a&gt;. Unpacking methods are of the form &lt;code&gt;unpack_type()&lt;/code&gt;, and take no arguments. They return the unpacked object.</source>
          <target state="translated">또한 &lt;a href=&quot;#xdrlib.Packer&quot;&gt; &lt;code&gt;Packer&lt;/code&gt; &lt;/a&gt; 로 압축 할 수있는 모든 데이터 유형 은 &lt;a href=&quot;#xdrlib.Unpacker&quot;&gt; &lt;code&gt;Unpacker&lt;/code&gt; &lt;/a&gt; 로 압축 해제 할 수 있습니다 . &lt;code&gt;unpack_type()&lt;/code&gt; 패킹 메소드는 unpack_type () 형식 이며 인수를 사용하지 않습니다. 포장이 풀린 물건을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="7ba3a9a49cc3e12a995a955c9b502b49ba170e63" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;M.__test__&lt;/code&gt; exists and &amp;ldquo;is true&amp;rdquo;, it must be a dict, and each entry maps a (string) name to a function object, class object, or string. Function and class object docstrings found from &lt;code&gt;M.__test__&lt;/code&gt; are searched, and strings are treated as if they were docstrings. In output, a key &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M.__test__&lt;/code&gt; appears with name</source>
          <target state="translated">또한 &lt;code&gt;M.__test__&lt;/code&gt; 가 존재하고 &quot;true&quot;인 경우 dict 여야하며 각 항목은 (문자열) 이름을 함수 객체, 클래스 객체 또는 문자열에 매핑합니다. &lt;code&gt;M.__test__&lt;/code&gt; 에서 찾은 함수 및 클래스 객체 docstring 이 검색되고 문자열은 마치 docstring 인 것처럼 처리됩니다. 출력 에서 &lt;code&gt;M.__test__&lt;/code&gt; 의 키 &lt;code&gt;K&lt;/code&gt; 가 이름과 함께 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7c4f27b629e481e3b68eabacd3944479c69ebbb1" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;'func_type'&lt;/code&gt;, the input syntax is modified to correspond to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;signature type comments&amp;rdquo;, e.g. &lt;code&gt;(str, int) -&amp;gt; List[str]&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;'func_type'&lt;/code&gt; 인 경우 입력 구문은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;서명 유형 주석&amp;rdquo; 에 해당하도록 수정됩니다 &lt;code&gt;(str, int) -&amp;gt; List[str]&lt;/code&gt; 예 : (str, int)-&amp;gt; List [str]) .</target>
        </trans-unit>
        <trans-unit id="30c6bed1ea7380108e2ca8ee55afe3a1b3931b43" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; are the exact same type and one of list, tuple, dict, set, frozenset or str or any type that a subclass registers with &lt;a href=&quot;#unittest.TestCase.addTypeEqualityFunc&quot;&gt;&lt;code&gt;addTypeEqualityFunc()&lt;/code&gt;&lt;/a&gt; the type-specific equality function will be called in order to generate a more useful default error message (see also the &lt;a href=&quot;#type-specific-methods&quot;&gt;list of type-specific methods&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;em&gt;첫 번째&lt;/em&gt; 와 &lt;em&gt;두 번째&lt;/em&gt; 가 정확히 동일한 유형이고 list, tuple, dict, set, frozenset 또는 str 또는 &lt;a href=&quot;#unittest.TestCase.addTypeEqualityFunc&quot;&gt; &lt;code&gt;addTypeEqualityFunc()&lt;/code&gt; &lt;/a&gt; 를 사용하여 서브 클래스가 등록하는 모든 유형 중 하나 인 경우 유형별 동등성 함수가 생성됩니다. 보다 유용한 기본 오류 메시지 ( &lt;a href=&quot;#type-specific-methods&quot;&gt;유형별 메소드 목록&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="0e854c4d4c93154cb656dd7533a63f2e464a95d5" translate="yes" xml:space="preserve">
          <source>In addition, if a function argument is explicitly declared to be a pointer type (such as &lt;code&gt;POINTER(c_int)&lt;/code&gt;) in &lt;code&gt;argtypes&lt;/code&gt;, an object of the pointed type (&lt;code&gt;c_int&lt;/code&gt; in this case) can be passed to the function. ctypes will apply the required &lt;a href=&quot;#ctypes.byref&quot;&gt;&lt;code&gt;byref()&lt;/code&gt;&lt;/a&gt; conversion in this case automatically.</source>
          <target state="translated">또한 함수 인수가 &lt;code&gt;argtypes&lt;/code&gt; 에서 포인터 유형 (예 : &lt;code&gt;POINTER(c_int)&lt;/code&gt; ) 으로 명시 적으로 선언 된 경우 지정된 유형의 객체 ( 이 경우 &lt;code&gt;c_int&lt;/code&gt; )가 함수에 전달 될 수 있습니다. 이 경우 ctypes는 필수 &lt;a href=&quot;#ctypes.byref&quot;&gt; &lt;code&gt;byref()&lt;/code&gt; &lt;/a&gt; 변환을 자동으로 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="be2d0ea0907cf041df70ca4f4e655493e7b46100" translate="yes" xml:space="preserve">
          <source>In addition, if proxy settings are detected (for example, when a &lt;code&gt;*_proxy&lt;/code&gt; environment variable like &lt;code id=&quot;index-0&quot;&gt;http_proxy&lt;/code&gt; is set), &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt;&lt;code&gt;ProxyHandler&lt;/code&gt;&lt;/a&gt; is default installed and makes sure the requests are handled through the proxy.</source>
          <target state="translated">또한 프록시 설정이 감지되면 (예 : &lt;code id=&quot;index-0&quot;&gt;http_proxy&lt;/code&gt; 와 같은 &lt;code&gt;*_proxy&lt;/code&gt; 환경 변수 가 설정된 경우) &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt; &lt;code&gt;ProxyHandler&lt;/code&gt; &lt;/a&gt; 가 기본적으로 설치되고 프록시를 통해 요청이 처리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="7b6bed6910e60de13a0aa73a3eceff08d688367d" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;#string.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; defines a number of methods that are intended to be replaced by subclasses:</source>
          <target state="translated">또한 &lt;a href=&quot;#string.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 는 서브 클래스로 대체 할 여러 메소드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c9ff53ab4ada69f7c64d6901e8e9786692449da2" translate="yes" xml:space="preserve">
          <source>In addition, the Python DOM interface requires that some additional support is provided to allow &lt;code&gt;NodeList&lt;/code&gt; objects to be used as Python sequences. All &lt;code&gt;NodeList&lt;/code&gt; implementations must include support for &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt;&lt;code&gt;__len__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;; this allows iteration over the &lt;code&gt;NodeList&lt;/code&gt; in &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; statements and proper support for the &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; built-in function.</source>
          <target state="translated">또한 Python DOM 인터페이스에는 &lt;code&gt;NodeList&lt;/code&gt; 객체를 Python 시퀀스로 사용할 수 있도록 몇 가지 추가 지원이 제공 되어야합니다. 모든 &lt;code&gt;NodeList&lt;/code&gt; 구현에는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt; &lt;code&gt;__len__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 대한 지원이 포함되어야합니다 . 이것은 &lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 내장 함수 에 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 명령문 및 적절한 지원을 위해 &lt;code&gt;NodeList&lt;/code&gt; in 을 반복 할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="d01bd464654d85025080875761ac5e61133f11b9" translate="yes" xml:space="preserve">
          <source>In addition, the following constants are defined:</source>
          <target state="translated">또한 다음 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b6828d60770f39f7550e18f2180b31c38e1ba2b8" translate="yes" xml:space="preserve">
          <source>In addition, the following error handler is specific to the given codecs:</source>
          <target state="translated">또한 다음 오류 처리기는 지정된 코덱에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a7d6c3e3ae1f40f0b841f0ae9fa2ce8b4b2c827e" translate="yes" xml:space="preserve">
          <source>In addition, the following methods unpack strings, bytes, and opaque data:</source>
          <target state="translated">또한 다음 메소드는 문자열, 바이트 및 불투명 한 데이터의 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="8f79591ef67ae18b0ee2f6ad572507855d4aebe8" translate="yes" xml:space="preserve">
          <source>In addition, the module exposes the following constant:</source>
          <target state="translated">또한 모듈은 다음 상수를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="7202589f315636dd521931132570107c0e2975e5" translate="yes" xml:space="preserve">
          <source>In addition, the module implements a &amp;ldquo;simple&amp;rdquo;</source>
          <target state="translated">또한 모듈은 &quot;간단한&quot;구현</target>
        </trans-unit>
        <trans-unit id="65768f8c8e36ecf98d8bfdf5c170282437244a45" translate="yes" xml:space="preserve">
          <source>In addition, the replacements using &lt;a href=&quot;#subprocess.check_output&quot;&gt;&lt;code&gt;check_output()&lt;/code&gt;&lt;/a&gt; will fail with a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt; if the requested operation produces a non-zero return code. The output is still available as the &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; attribute of the raised exception.</source>
          <target state="translated">또한, 요청 된 조작이 0이 아닌 리턴 코드를 생성하면 &lt;a href=&quot;#subprocess.check_output&quot;&gt; &lt;code&gt;check_output()&lt;/code&gt; &lt;/a&gt; 을 사용한 대체 는 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; &lt;/a&gt; 와 함께 실패 합니다. 출력은 여전히 발생한 예외 의 &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; 속성으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="24d6f5e76f333b5e2721aafc94f1e5f93dcadd61" translate="yes" xml:space="preserve">
          <source>In addition, those methods can raise &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; if the underlying raw stream is in non-blocking mode and cannot take or give enough data; unlike their &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; counterparts, they will never return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">또한 기본 원시 스트림이 비 블로킹 모드에 있고 충분한 데이터를 가져 오거나 제공 할 수없는 경우 이러한 메소드는 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 를&lt;/a&gt; 발생시킬 수 있습니다. &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;None&lt;/code&gt; 을 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0c8203792cc7837023ccc2f6c27be6b401948da" translate="yes" xml:space="preserve">
          <source>In all but the last case, behaviour is as for the &lt;a href=&quot;#fcntl.fcntl&quot;&gt;&lt;code&gt;fcntl()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">마지막 경우를 제외하고는 동작은 &lt;a href=&quot;#fcntl.fcntl&quot;&gt; &lt;code&gt;fcntl()&lt;/code&gt; &lt;/a&gt; 함수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="692d29dfab8ab67219a17ecaca49c353f09b7b11" translate="yes" xml:space="preserve">
          <source>In all cases, if the optional parts are omitted, the code is executed in the current scope. If only &lt;em&gt;globals&lt;/em&gt; is provided, it must be a dictionary (and not a subclass of dictionary), which will be used for both the global and the local variables. If &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; are given, they are used for the global and local variables, respectively. If provided, &lt;em&gt;locals&lt;/em&gt; can be any mapping object. Remember that at module level, globals and locals are the same dictionary. If exec gets two separate objects as &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt;, the code will be executed as if it were embedded in a class definition.</source>
          <target state="translated">모든 경우에 선택적 부분을 생략하면 현재 범위에서 코드가 실행됩니다. &lt;em&gt;전역 변수&lt;/em&gt; 만 제공되는 경우 사전 (하위 클래스의 하위 클래스 아님)이어야하며 전역 및 로컬 변수에 모두 사용됩니다. &lt;em&gt;전역 변수&lt;/em&gt; 와 &lt;em&gt;지역 &lt;/em&gt;&lt;em&gt;변수&lt;/em&gt; 가 제공 되면 &lt;em&gt;전역 변수&lt;/em&gt; 와 지역 변수에 각각 사용됩니다. 제공되는 경우 &lt;em&gt;로컬&lt;/em&gt; 은 모든 매핑 객체 일 수 있습니다. 모듈 수준에서 전역과 지역은 같은 사전입니다. exec가 &lt;em&gt;globals&lt;/em&gt; 및 &lt;em&gt;locals&lt;/em&gt; 로 두 개의 개별 객체를 얻는 경우 코드는 마치 클래스 정의에 포함 된 것처럼 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e125a1f4b01ec045b13c222789290bf79d3655aa" translate="yes" xml:space="preserve">
          <source>In an editor, import statements have no effect until one runs the file. One might want to run a file after writing the import statements at the top, or immediately run an existing file before editing.</source>
          <target state="translated">편집기에서 import 문은 파일을 실행할 때까지 적용되지 않습니다. 맨 위에 import 문을 작성한 후 파일을 실행하거나 편집하기 전에 기존 파일을 즉시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7585fd505655ba1d8efec7b44c9872a4847511d0" translate="yes" xml:space="preserve">
          <source>In any case, the parameter value (either the returned string, or the &lt;code&gt;VALUE&lt;/code&gt; item in the 3-tuple) is always unquoted, unless &lt;em&gt;unquote&lt;/em&gt; is set to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">어쨌든 &lt;em&gt;unquote&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 로 설정되어 있지 않으면 매개 변수 값 (반환 된 문자열 또는 3 튜플 의 &lt;code&gt;VALUE&lt;/code&gt; 항목)이 항상 인용되지 않습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ea5e474a620a942ee44b6caa68731405ccc53b7" translate="yes" xml:space="preserve">
          <source>In asyncio, child processes are created with &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">asyncio에서 하위 프로세스는 &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9c6189bdb6109a3314f3a6fa2e8324565b928c" translate="yes" xml:space="preserve">
          <source>In calls to &lt;a href=&quot;#time.mktime&quot;&gt;&lt;code&gt;mktime()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tm_isdst&lt;/code&gt; may be set to 1 when daylight savings time is in effect, and 0 when it is not. A value of -1 indicates that this is not known, and will usually result in the correct state being filled in.</source>
          <target state="translated">호출에 &lt;a href=&quot;#time.mktime&quot;&gt; &lt;code&gt;mktime()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;tm_isdst&lt;/code&gt; 는 그렇지 않은 경우 일광 절약 시간이 적용되는 경우에 1로 설정하고, 0 수있다. -1 값은 알 수 없음을 나타내며 일반적으로 올바른 상태가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="bc48b1dca0b1da787a928b9dd93dc589bfde5754" translate="yes" xml:space="preserve">
          <source>In cases when only the library handle is available rather than the object, accessing a function raises an auditing event &lt;code&gt;ctypes.dlsym/handle&lt;/code&gt; with arguments &lt;code&gt;handle&lt;/code&gt; (the raw library handle) and &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">오브젝트가 아닌 라이브러리 핸들 만 사용 가능한 경우, 함수에 액세스하면 인수 &lt;code&gt;handle&lt;/code&gt; (원시 라이브러리 핸들) 및 &lt;code&gt;name&lt;/code&gt; 과 함께 감사 이벤트 &lt;code&gt;ctypes.dlsym/handle&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="30db5ca10a27995819aa59775e12a2ebd80f3013" translate="yes" xml:space="preserve">
          <source>In cases where canonical output is not applicable but a specific attribute order is still desirable on output, code should aim for creating the attributes directly in the desired order, to avoid perceptual mismatches for readers of the code. In cases where this is difficult to achieve, a recipe like the following can be applied prior to serialisation to enforce an order independently from the Element creation:</source>
          <target state="translated">표준 출력이 적용되지 않지만 출력에서 ​​특정 속성 순서가 여전히 바람직한 경우, 코드는 코드 판독기에 대한 지각 불일치를 피하기 위해 원하는 순서로 속성을 직접 작성하는 것을 목표로해야합니다. 이를 달성하기 어려운 경우, 요소 생성과 독립적으로 주문을 시행하기 위해 직렬화 전에 다음과 같은 레시피를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a76a269c9a0813ca8158d4ca521d20cd58a501b" translate="yes" xml:space="preserve">
          <source>In config parsers, values can span multiple lines as long as they are indented more than the key that holds them. By default parsers also let empty lines to be parts of values. At the same time, keys can be arbitrarily indented themselves to improve readability. In consequence, when configuration files get big and complex, it is easy for the user to lose track of the file structure. Take for instance:</source>
          <target state="translated">구성 파서에서는 값을 보유하는 키보다 들여 쓰기 만하면 값이 여러 줄에 걸쳐있을 수 있습니다. 기본적으로 파서는 빈 줄이 값의 일부가되도록합니다. 동시에 가독성을 높이기 위해 키를 임의로 들여 쓸 수 있습니다. 결과적으로 구성 파일이 커지고 복잡해지면 사용자가 파일 구조를 쉽게 잃을 수 있습니다. 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="4474384d258039b476c26e51f3dc73c8e1621318" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;NewType&lt;/code&gt; declares one type to be a &lt;em&gt;subtype&lt;/em&gt; of another. Doing &lt;code&gt;Derived = NewType('Derived', Original)&lt;/code&gt; will make the static type checker treat &lt;code&gt;Derived&lt;/code&gt; as a &lt;em&gt;subclass&lt;/em&gt; of &lt;code&gt;Original&lt;/code&gt;, which means a value of type &lt;code&gt;Original&lt;/code&gt; cannot be used in places where a value of type &lt;code&gt;Derived&lt;/code&gt; is expected. This is useful when you want to prevent logic errors with minimal runtime cost.</source>
          <target state="translated">반대로 &lt;code&gt;NewType&lt;/code&gt; 은 한 유형을 다른 &lt;em&gt;유형&lt;/em&gt; 의 &lt;em&gt;하위&lt;/em&gt; 유형으로 선언합니다 . 하고 &lt;code&gt;Derived = NewType('Derived', Original)&lt;/code&gt; 정적 형 검사 치료하게됩니다 &lt;code&gt;Derived&lt;/code&gt; A와 &lt;em&gt;서브 클래스&lt;/em&gt; 의 &lt;code&gt;Original&lt;/code&gt; 형식의 값 의미, &lt;code&gt;Original&lt;/code&gt; 유형의 값 장소에서 사용할 수 없습니다 &lt;code&gt;Derived&lt;/code&gt; 예상된다. 이는 최소한의 런타임 비용으로 논리 오류를 방지하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="808194d88f87f062e3f917a77c2fd08a648ff57f" translate="yes" xml:space="preserve">
          <source>In debug builds, the list of default warning filters is empty.</source>
          <target state="translated">디버그 빌드에서 기본 경고 필터 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acc6dc48ce98dfe1787544928804d1351131ed2d" translate="yes" xml:space="preserve">
          <source>In developing fixed-point applications, it is convenient to define functions to handle the &lt;code&gt;quantize()&lt;/code&gt; step:</source>
          <target state="translated">고정 소수점 애플리케이션을 개발할 때, &lt;code&gt;quantize()&lt;/code&gt; 단계 를 처리하는 함수를 정의하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="c977d792bc856342f19c64cada581050dd1e4694" translate="yes" xml:space="preserve">
          <source>In either case, the exception itself is always shown after any chained exceptions so that the final line of the traceback always shows the last exception that was raised.</source>
          <target state="translated">어느 경우 든 예외 자체는 항상 체인 예외 뒤에 표시되므로 역 추적의 마지막 행에는 항상 마지막으로 발생한 예외가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="22384914a04d22b7049ea2fa018ad8b0c6e7dc2b" translate="yes" xml:space="preserve">
          <source>In either case, when producing an &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant header using &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; rules, the string will be encoded using the output codec of the charset. If the string cannot be encoded using the output codec, a UnicodeError will be raised.</source>
          <target state="translated">두 경우 모두 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 규칙을 사용하여 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 호환 헤더를 생성 할 때 문자열은 문자셋의 출력 코덱을 사용하여 인코딩됩니다. 출력 코덱을 사용하여 문자열을 인코딩 할 수 없으면 UnicodeError가 발생합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="245fefefdc72a1779e932cbff8e651714d2e5fec" translate="yes" xml:space="preserve">
          <source>In emergencies this method will discard any data held in the input and/or output buffers and the producer queue.</source>
          <target state="translated">응급 상황에서이 방법은 입력 및 / 또는 출력 버퍼와 생산자 대기열에 보관 된 모든 데이터를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="965c8af21ae4828757fda71d55deb0166d6df2fd" translate="yes" xml:space="preserve">
          <source>In essence, a Condition object combines the functionality of an &lt;a href=&quot;#asyncio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;#asyncio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;. It is possible to have multiple Condition objects share one Lock, which allows coordinating exclusive access to a shared resource between different tasks interested in particular states of that shared resource.</source>
          <target state="translated">본질적으로 Condition 객체는 &lt;a href=&quot;#asyncio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 기능 과 &lt;a href=&quot;#asyncio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 기능을 결합합니다 . 여러 조건 개체가 하나의 잠금을 공유하도록하는 것이 가능하며,이를 통해 해당 공유 리소스의 특정 상태에 관심이있는 다른 작업간에 공유 리소스에 대한 독점 액세스를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab7997c363058025f4902dd79fa90e9d4f7cc8a" translate="yes" xml:space="preserve">
          <source>In fact, the above algorithm is first tried for methods named &lt;code&gt;default_open()&lt;/code&gt;. If all such methods return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the algorithm is repeated for methods named like &lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt;. If all such methods return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the algorithm is repeated for methods named &lt;code&gt;unknown_open()&lt;/code&gt;.</source>
          <target state="translated">사실 위의 알고리즘은 먼저 &lt;code&gt;default_open()&lt;/code&gt; 이라는 메서드에 대해 시도됩니다 . 이러한 모든 메소드가 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 리턴하면 &lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt; 과 같은 메소드에 대해 알고리즘이 반복됩니다 . 이러한 모든 메소드가 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 리턴 하면 &lt;code&gt;unknown_open()&lt;/code&gt; 이라는 메소드에 대해 알고리즘이 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="26db7d03f5d7b2f8484e83cc9df341e5fcb76c6d" translate="yes" xml:space="preserve">
          <source>In general, &lt;em&gt;t1&lt;/em&gt; * i == &lt;em&gt;t1&lt;/em&gt; * (i-1) + &lt;em&gt;t1&lt;/em&gt; is true. (1)</source>
          <target state="translated">일반적으로 &lt;em&gt;t1&lt;/em&gt; * i == &lt;em&gt;t1&lt;/em&gt; * (i-1) + &lt;em&gt;t1&lt;/em&gt; 은 true입니다. (1)</target>
        </trans-unit>
        <trans-unit id="0506d07a792bdf1420c6f5ee2d8683b4bb973f20" translate="yes" xml:space="preserve">
          <source>In general, it should be the case that &lt;a href=&quot;#http.cookies.BaseCookie.value_encode&quot;&gt;&lt;code&gt;value_encode()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.cookies.BaseCookie.value_decode&quot;&gt;&lt;code&gt;value_decode()&lt;/code&gt;&lt;/a&gt; are inverses on the range of &lt;em&gt;value_decode&lt;/em&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#http.cookies.BaseCookie.value_encode&quot;&gt; &lt;code&gt;value_encode()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#http.cookies.BaseCookie.value_decode&quot;&gt; &lt;code&gt;value_decode()&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;value_decode&lt;/em&gt; 범위에서 &lt;em&gt;반대 인 경우&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df0b5cf5765724139c03b2e68725a9a7fc0cadf5" translate="yes" xml:space="preserve">
          <source>In general, protocol implementations that use transport-based APIs such as &lt;a href=&quot;#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt; are faster than implementations that work with sockets directly. However, there are some use cases when performance is not critical, and working with &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; objects directly is more convenient.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; 와 같은 전송 기반 API를 사용하는 프로토콜 구현은 소켓에서 직접 작동하는 구현보다 빠릅니다. 그러나 성능이 중요하지 않은 경우가 있으며 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 객체를 직접 사용하는 것이 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="20cd72495b8797b1b45d990ccd4902f5c5f42a41" translate="yes" xml:space="preserve">
          <source>In general, the &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module assumes that flags like &lt;code&gt;-f&lt;/code&gt; and &lt;code&gt;--bar&lt;/code&gt; indicate &lt;em&gt;optional&lt;/em&gt; arguments, which can always be omitted at the command line. To make an option &lt;em&gt;required&lt;/em&gt;, &lt;code&gt;True&lt;/code&gt; can be specified for the &lt;code&gt;required=&lt;/code&gt; keyword argument to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;code&gt;-f&lt;/code&gt; 및 &lt;code&gt;--bar&lt;/code&gt; 와 같은 플래그 가 &lt;em&gt;선택적&lt;/em&gt; 인수를 나타내며 명령 행에서 항상 생략 할 수 있다고 가정합니다 . 옵션하려면 &lt;em&gt;필요를&lt;/em&gt; , &lt;code&gt;True&lt;/code&gt; 을 지정할 수 있습니다 &lt;code&gt;required=&lt;/code&gt; 키워드 인수 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c4db8812f85eaab112b76e9bb72d0ea809a10832" translate="yes" xml:space="preserve">
          <source>In general, the LRU cache should only be used when you want to reuse previously computed values. Accordingly, it doesn&amp;rsquo;t make sense to cache functions with side-effects, functions that need to create distinct mutable objects on each call, or impure functions such as time() or random().</source>
          <target state="translated">일반적으로 LRU 캐시는 이전에 계산 된 값을 재사용하려는 경우에만 사용해야합니다. 따라서 부작용이있는 함수, 각 호출마다 고유 한 가변 객체를 작성해야하는 함수, time () 또는 random ()과 같은 불순한 함수를 캐시하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0855957cf96cc591654edbae97ba73e1a179c2a2" translate="yes" xml:space="preserve">
          <source>In general, this function should be preferred over &lt;a href=&quot;os#os.getlogin&quot;&gt;&lt;code&gt;os.getlogin()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로이 함수는 &lt;a href=&quot;os#os.getlogin&quot;&gt; &lt;code&gt;os.getlogin()&lt;/code&gt; &lt;/a&gt; 보다 선호되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="440426040cf7cbfc6d96c968361e3b6f6f71b8cf" translate="yes" xml:space="preserve">
          <source>In general, user code should try not to depend on a specific ordering of attributes, given that the &lt;a href=&quot;https://www.w3.org/TR/xml-infoset/&quot;&gt;XML Information Set&lt;/a&gt; explicitly excludes the attribute order from conveying information. Code should be prepared to deal with any ordering on input. In cases where deterministic XML output is required, e.g. for cryptographic signing or test data sets, canonical serialisation is available with the &lt;a href=&quot;#xml.etree.ElementTree.canonicalize&quot;&gt;&lt;code&gt;canonicalize()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;https://www.w3.org/TR/xml-infoset/&quot;&gt;XML 정보 세트가 정보&lt;/a&gt; 전달에서 속성 순서를 명시 적으로 제외하는 경우 사용자 코드는 특정 속성 순서에 의존하지 않아야합니다. 입력에 대한 모든 주문을 처리 할 수 ​​있도록 코드를 준비해야합니다. 암호화 서명 또는 테스트 데이터 세트와 같이 결정 론적 XML 출력이 필요한 경우 &lt;a href=&quot;#xml.etree.ElementTree.canonicalize&quot;&gt; &lt;code&gt;canonicalize()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 표준 직렬화를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8e833685e558fad9e6d2aed4b5edd8ed53ab53a" translate="yes" xml:space="preserve">
          <source>In general, you can pack any of the most common XDR data types by calling the appropriate &lt;code&gt;pack_type()&lt;/code&gt; method. Each method takes a single argument, the value to pack. The following simple data type packing methods are supported: &lt;code&gt;pack_uint()&lt;/code&gt;, &lt;code&gt;pack_int()&lt;/code&gt;, &lt;code&gt;pack_enum()&lt;/code&gt;, &lt;code&gt;pack_bool()&lt;/code&gt;, &lt;code&gt;pack_uhyper()&lt;/code&gt;, and &lt;code&gt;pack_hyper()&lt;/code&gt;.</source>
          <target state="translated">일반적으로 적절한 &lt;code&gt;pack_type()&lt;/code&gt; 메소드를 호출하여 가장 일반적인 XDR 데이터 유형을 압축 할 수 있습니다 . 각 메소드는 팩킹 할 값인 단일 인수를 사용합니다. &lt;code&gt;pack_uint()&lt;/code&gt; , &lt;code&gt;pack_int()&lt;/code&gt; , &lt;code&gt;pack_enum()&lt;/code&gt; , &lt;code&gt;pack_bool()&lt;/code&gt; , &lt;code&gt;pack_uhyper()&lt;/code&gt; 및 &lt;code&gt;pack_hyper()&lt;/code&gt; 와 같은 간단한 데이터 유형 패킹 방법이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="7051fb77a6d138d8bb42933ac13b4fab45cc061e" translate="yes" xml:space="preserve">
          <source>In general, you will want to use the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package&amp;rsquo;s features to construct an email message, which you can then send via &lt;a href=&quot;#smtplib.SMTP.send_message&quot;&gt;&lt;code&gt;send_message()&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;email.examples#email-examples&quot;&gt;email: Examples&lt;/a&gt;.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지의 기능 을 사용하여 전자 메일 메시지를 &lt;a href=&quot;#smtplib.SMTP.send_message&quot;&gt; &lt;code&gt;send_message()&lt;/code&gt; &lt;/a&gt; 다음 send_message () 를 통해 보낼 수 있습니다 . &lt;a href=&quot;email.examples#email-examples&quot;&gt;이메일 : 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="840dd19adeba7204bf237688be99f304d742eb60" translate="yes" xml:space="preserve">
          <source>In its basic form, &lt;a href=&quot;#module-pprint&quot;&gt;&lt;code&gt;pprint()&lt;/code&gt;&lt;/a&gt; shows the whole object:</source>
          <target state="translated">기본 형식으로 &lt;a href=&quot;#module-pprint&quot;&gt; &lt;code&gt;pprint()&lt;/code&gt; &lt;/a&gt; 는 전체 객체를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="70cdc658f4f5ab332fd8069815a9324e25e35d83" translate="yes" xml:space="preserve">
          <source>In less formal terms, the replacement field can start with a &lt;em&gt;field_name&lt;/em&gt; that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The &lt;em&gt;field_name&lt;/em&gt; is optionally followed by a &lt;em&gt;conversion&lt;/em&gt; field, which is preceded by an exclamation point &lt;code&gt;'!'&lt;/code&gt;, and a &lt;em&gt;format_spec&lt;/em&gt;, which is preceded by a colon &lt;code&gt;':'&lt;/code&gt;. These specify a non-default format for the replacement value.</source>
          <target state="translated">덜 공식적인 용어로 대체 필드는 값을 바꾸고 대체 필드 대신 출력에 삽입 할 오브젝트를 지정 하는 &lt;em&gt;field_name으로&lt;/em&gt; 시작할 수 있습니다 . &lt;em&gt;FIELD_NAME은&lt;/em&gt; 임의로 이어진다 &lt;em&gt;변환&lt;/em&gt; 느낌표가 선행 필드, &lt;code&gt;'!'&lt;/code&gt; , 및 &lt;em&gt;format_spec&lt;/em&gt; 은 콜론 &lt;code&gt;':'&lt;/code&gt; 앞에옵니다 . 대체 값에 기본이 아닌 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="207eed5cab33c7fd44f50216fdcd9b7ae0089e35" translate="yes" xml:space="preserve">
          <source>In less ideal cases, applications can be checked for use of deprecated interfaces by passing &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-Wd&lt;/code&gt;&lt;/a&gt; to the Python interpreter (this is shorthand for &lt;code&gt;-W default&lt;/code&gt;) or setting &lt;code&gt;PYTHONWARNINGS=default&lt;/code&gt; in the environment. This enables default handling for all warnings, including those that are ignored by default. To change what action is taken for encountered warnings you can change what argument is passed to &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;-W error&lt;/code&gt;). See the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; flag for more details on what is possible.</source>
          <target state="translated">덜 이상적인 경우, &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-Wd&lt;/code&gt; &lt;/a&gt; 를 Python 인터프리터 에 전달 하거나 ( &lt;code&gt;-W default&lt;/code&gt; 의 약자 ) 환경에서 &lt;code&gt;PYTHONWARNINGS=default&lt;/code&gt; 를 설정 하여 더 이상 사용되지 않는 인터페이스의 사용 여부를 애플리케이션에서 확인할 수 있습니다 . 이를 통해 기본적으로 무시되는 경고를 포함하여 모든 경고에 대한 기본 처리가 가능합니다. 발생한 경고에 대해 수행 할 조치를 변경하려면 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 에&lt;/a&gt; 전달되는 인수를 변경하십시오 (예 : &lt;code&gt;-W error&lt;/code&gt; ). 가능한 것에 대한 자세한 내용 은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 플래그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="534991bf3a76b961bedcef085ae867583416a5d2" translate="yes" xml:space="preserve">
          <source>In many cases you will just be able to add &lt;code&gt;autospec=True&lt;/code&gt; to your existing &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; calls and then be protected against bugs due to typos and api changes.</source>
          <target state="translated">대부분의 경우 기존 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 호출 에 &lt;code&gt;autospec=True&lt;/code&gt; 를 추가 한 다음 오타 및 API 변경으로 인한 버그로부터 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8b6f5d72094bed2a418a171229c3a3461791a6" translate="yes" xml:space="preserve">
          <source>In many use-cases one doesn&amp;rsquo;t care what the actual value of an enumeration is. There are several ways to define this type of simple enumeration:</source>
          <target state="translated">많은 유스 케이스에서 열거의 실제 값이 무엇인지 신경 쓰지 않습니다. 이 유형의 간단한 열거를 정의하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="683dda921eb9dde69c65282fd8a1442adc4883df" translate="yes" xml:space="preserve">
          <source>In most cases a copy-and-paste of an interactive console session works fine, but doctest isn&amp;rsquo;t trying to do an exact emulation of any specific Python shell.</source>
          <target state="translated">대부분의 경우 대화 형 콘솔 세션의 복사하여 붙여 넣기는 잘 작동하지만 doctest는 특정 Python 셸을 정확하게 에뮬레이션하려고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c95379866d99798cdc6b44f569e45b47b03caff" translate="yes" xml:space="preserve">
          <source>In most cases, end users of Python shouldn&amp;rsquo;t need to invoke this module directly (as &lt;code&gt;pip&lt;/code&gt; should be bootstrapped by default), but it may be needed if installing &lt;code&gt;pip&lt;/code&gt; was skipped when installing Python (or when creating a virtual environment) or after explicitly uninstalling &lt;code&gt;pip&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 Python 최종 사용자는이 모듈을 직접 호출 할 필요는 없지만 ( &lt;code&gt;pip&lt;/code&gt; 는 기본적으로 부트 스트랩되어야 함) Python을 설치할 때 (또는 가상 환경을 만들 때) 또는 이후에 &lt;code&gt;pip&lt;/code&gt; 설치 를 건너 뛴 경우 필요할 수 있습니다. &lt;code&gt;pip&lt;/code&gt; 를 명시 적으로 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="976b8e0f0142bf68fb963efdbb1f64f443c3a2d4" translate="yes" xml:space="preserve">
          <source>In most cases, no additional code is needed to make instances picklable. By default, pickle will retrieve the class and the attributes of an instance via introspection. When a class instance is unpickled, its &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method is usually &lt;em&gt;not&lt;/em&gt; invoked. The default behaviour first creates an uninitialized instance and then restores the saved attributes. The following code shows an implementation of this behaviour:</source>
          <target state="translated">대부분의 경우 인스턴스를 선택 가능하게하기 위해 추가 코드가 필요하지 않습니다. 기본적으로 pickle은 내부 검사를 통해 인스턴스의 클래스 및 속성을 검색합니다. 클래스 인스턴스가 선택 해제되면 일반적으로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 &lt;em&gt;되지 않습니다&lt;/em&gt; . 기본 동작은 먼저 초기화되지 않은 인스턴스를 생성 한 다음 저장된 속성을 복원합니다. 다음 코드는이 동작의 구현을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4529cbb146eb6065739aafbd505c95e547aa3ac8" translate="yes" xml:space="preserve">
          <source>In most coding situations, strings are translated where they are coded. Occasionally however, you need to mark strings for translation, but defer actual translation until later. A classic example is:</source>
          <target state="translated">대부분의 코딩 상황에서 문자열은 코딩 된 위치에서 변환됩니다. 그러나 때때로 번역을 위해 문자열을 표시해야하지만 나중에 실제 번역을 연기해야합니다. 전형적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c31666ba6595f7dfef709e3c800c98df8b264362" translate="yes" xml:space="preserve">
          <source>In most of the cases the syntax is similar to the old &lt;code&gt;%&lt;/code&gt;-formatting, with the addition of the &lt;code&gt;{}&lt;/code&gt; and with &lt;code&gt;:&lt;/code&gt; used instead of &lt;code&gt;%&lt;/code&gt;. For example, &lt;code&gt;'%03.2f'&lt;/code&gt; can be translated to &lt;code&gt;'{:03.2f}'&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 구문은 &lt;code&gt;{}&lt;/code&gt; 을 추가 하고 &lt;code&gt;%&lt;/code&gt; 대신 &lt;code&gt;:&lt;/code&gt; 을 사용 하여 이전 &lt;code&gt;%&lt;/code&gt; 형식화 와 유사합니다 . 예를 들어 &lt;code&gt;'%03.2f'&lt;/code&gt; 는 &lt;code&gt;'{:03.2f}'&lt;/code&gt; 로 변환 될 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
