<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="d53ba21dee295896d8c0fc9de128483f4c1f4d26" translate="yes" xml:space="preserve">
          <source>The specified loggers will be configured according to the level, propagation, filters and handlers specified.</source>
          <target state="translated">지정된 로거는 지정된 레벨, 전파, 필터 및 핸들러에 따라 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e0612ec14e7221d85b8658075b6926be56ede2bc" translate="yes" xml:space="preserve">
          <source>The specifier &lt;em&gt;name&lt;/em&gt; is a &amp;ldquo;dotted name&amp;rdquo; that may resolve either to a module, a test case class, a test method within a test case class, a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; instance, or a callable object which returns a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; instance. These checks are applied in the order listed here; that is, a method on a possible test case class will be picked up as &amp;ldquo;a test method within a test case class&amp;rdquo;, rather than &amp;ldquo;a callable object&amp;rdquo;.</source>
          <target state="translated">지정자 &lt;em&gt;이름&lt;/em&gt; 은 모듈, 테스트 케이스 클래스, 테스트 케이스 클래스 내의 테스트 메소드, &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스 를 리턴하는 호출 가능 오브젝트로 해석 될 수있는 &quot;점 이름&quot;입니다 . 이러한 점검은 여기에 나열된 순서대로 적용됩니다. 즉, 가능한 테스트 케이스 클래스의 메소드는 &quot;호출 가능한 오브젝트&quot;가 아닌 &quot;테스트 케이스 클래스 내의 테스트 메소드&quot;로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="8327e74724788e9fd23faafae57d70e63b944955" translate="yes" xml:space="preserve">
          <source>The spinbox widget generates an &lt;strong&gt;&amp;lt;&amp;lt;Increment&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user presses &amp;lt;Up&amp;gt;, and a &lt;strong&gt;&amp;lt;&amp;lt;Decrement&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user presses &amp;lt;Down&amp;gt;.</source>
          <target state="translated">스핀 박스 위젯 은 사용자가 &amp;lt;Up&amp;gt;을 누르면 &lt;strong&gt;&amp;lt;&amp;lt; Increment &amp;gt;&amp;gt;&lt;/strong&gt; 가상 이벤트를 생성 하고 사용자가 &amp;lt;Down&amp;gt;을 누르면 &lt;strong&gt;&amp;lt;&amp;lt; Decrement &amp;gt;&amp;gt;&lt;/strong&gt; 가상 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="51a445c74beda03ed7a0326a9352f92f1dd4d706" translate="yes" xml:space="preserve">
          <source>The sqlite3 module is not built with loadable extension support by default, because some platforms (notably Mac OS X) have SQLite libraries which are compiled without this feature. To get loadable extension support, you must pass &amp;ndash;enable-loadable-sqlite-extensions to configure.</source>
          <target state="translated">일부 플랫폼 (특히 Mac OS X)에는이 기능없이 컴파일 된 SQLite 라이브러리가 있기 때문에 sqlite3 모듈은 기본적으로로드 가능한 확장 지원 기능으로 빌드되지 않습니다. 로드 가능한 확장 지원을 받으려면 &amp;ndash;enable-loadable-sqlite-extensions를 전달하여 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c357cdf2607bac2f5dbe1953aebb35c44af932e" translate="yes" xml:space="preserve">
          <source>The sqlite3 module was written by Gerhard H&amp;auml;ring. It provides a SQL interface compliant with the DB-API 2.0 specification described by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 249&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">sqlite3 모듈은 Gerhard H&amp;auml;ring이 작성했습니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 249에&lt;/strong&gt;&lt;/a&gt; 설명 된 DB-API 2.0 사양을 준수하는 SQL 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="bac169ab637e97d8d04b333be4d5b9e88d67748b" translate="yes" xml:space="preserve">
          <source>The standalone backport of this module provides more information on &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/using.html&quot;&gt;using importlib.resources&lt;/a&gt; and &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/migration.html&quot;&gt;migrating from pkg_resources to importlib.resources&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 독립형 백 포트는 &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/using.html&quot;&gt;importlib.resources 사용&lt;/a&gt; 및 &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/migration.html&quot;&gt;pkg_resources에서 importlib.resources로 마이그레이션&lt;/a&gt; 에 대한 자세한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b77674a95bf51acfb62957a46af0656c170047b7" translate="yes" xml:space="preserve">
          <source>The standard Python IMAP module.</source>
          <target state="translated">표준 Python IMAP 모듈.</target>
        </trans-unit>
        <trans-unit id="68889788aae8ae70cfc40e3231e1f8e78cb10352" translate="yes" xml:space="preserve">
          <source>The standard X cursor names from &lt;code&gt;cursorfont.h&lt;/code&gt; can be used, without the &lt;code&gt;XC_&lt;/code&gt; prefix. For example to get a hand cursor (&lt;code&gt;XC_hand2&lt;/code&gt;), use the string &lt;code&gt;&quot;hand2&quot;&lt;/code&gt;. You can also specify a bitmap and mask file of your own. See page 179 of Ousterhout&amp;rsquo;s book.</source>
          <target state="translated">에서 표준 X 커서 이름 &lt;code&gt;cursorfont.h&lt;/code&gt; 이 를 빼고, 사용할 수 &lt;code&gt;XC_&lt;/code&gt; 의 접두사. 예를 들어 손 모양 커서 ( &lt;code&gt;XC_hand2&lt;/code&gt; ) 를 얻으려면 &lt;code&gt;&quot;hand2&quot;&lt;/code&gt; 문자열을 사용하십시오 . 자신 만의 비트 맵 및 마스크 파일을 지정할 수도 있습니다. Ousterhout의 179 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48c570e26b992a39c9c6ac01d765d07ba873d695" translate="yes" xml:space="preserve">
          <source>The standard error device. Initially, this is the active console screen buffer, &lt;code&gt;CONOUT$&lt;/code&gt;.</source>
          <target state="translated">표준 오류 장치 처음에는 활성 콘솔 화면 버퍼 인 &lt;code&gt;CONOUT$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="838902f3ab46b04d98965c4728b7b35218852253" translate="yes" xml:space="preserve">
          <source>The standard format of the &lt;code id=&quot;index-17&quot;&gt;TZ&lt;/code&gt; environment variable is (whitespace added for clarity):</source>
          <target state="translated">&lt;code id=&quot;index-17&quot;&gt;TZ&lt;/code&gt; 환경 변수 의 표준 형식은 다음 과 같습니다 (명 백성을 위해 추가 된 공백).</target>
        </trans-unit>
        <trans-unit id="cb7f906caa68565a322b0c38155c9958a70af129" translate="yes" xml:space="preserve">
          <source>The standard input device. Initially, this is the console input buffer, &lt;code&gt;CONIN$&lt;/code&gt;.</source>
          <target state="translated">표준 입력 장치 처음에는 콘솔 입력 버퍼 인 &lt;code&gt;CONIN$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9fe9bf76be36079397d2cae51a3b2aece1a0ca0" translate="yes" xml:space="preserve">
          <source>The standard module &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; defines functions and constants that are useful for extracting information from a &lt;code&gt;stat&lt;/code&gt; structure. (On Windows, some items are filled with dummy values.)</source>
          <target state="translated">표준 모듈 &lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;stat&lt;/code&gt; 구조 에서 정보를 추출하는 데 유용한 함수와 상수를 정의합니다 . (Windows에서는 일부 항목이 더미 값으로 채워집니다.)</target>
        </trans-unit>
        <trans-unit id="6cdc8bfcbf49383bc1e73500c1b4de14a0e0fed5" translate="yes" xml:space="preserve">
          <source>The standard output and standard error streams are buffered during the test run. Output during a passing test is discarded. Output is echoed normally on test fail or error and is added to the failure messages.</source>
          <target state="translated">표준 출력 및 표준 오류 스트림은 테스트 실행 중에 버퍼링됩니다. 통과 테스트 중 출력이 삭제됩니다. 테스트 실패 또는 오류시 출력이 정상적으로 에코되고 실패 메시지에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="eb7cf066e8af540cf727db7cac24accf30ce076f" translate="yes" xml:space="preserve">
          <source>The standard output device. Initially, this is the active console screen buffer, &lt;code&gt;CONOUT$&lt;/code&gt;.</source>
          <target state="translated">표준 출력 장치 처음에는 활성 콘솔 화면 버퍼 인 &lt;code&gt;CONOUT$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bedde387bc6937840daa67ab375a6cae23a47eb7" translate="yes" xml:space="preserve">
          <source>The standard way to exit is &lt;code&gt;sys.exit(n)&lt;/code&gt;. &lt;a href=&quot;#os._exit&quot;&gt;&lt;code&gt;_exit()&lt;/code&gt;&lt;/a&gt; should normally only be used in the child process after a &lt;a href=&quot;#os.fork&quot;&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">종료하는 표준 방법은 &lt;code&gt;sys.exit(n)&lt;/code&gt; 입니다. &lt;a href=&quot;#os._exit&quot;&gt; &lt;code&gt;_exit()&lt;/code&gt; &lt;/a&gt; 은 일반적으로 &lt;a href=&quot;#os.fork&quot;&gt; &lt;code&gt;fork()&lt;/code&gt; &lt;/a&gt; 다음의 자식 프로세스에서만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a3ee6195d1060ec2a3f2616df734ae62aafdf49e" translate="yes" xml:space="preserve">
          <source>The standard way to open files for reading and writing with Python.</source>
          <target state="translated">파이썬으로 읽고 쓰는 파일을 여는 표준 방법.</target>
        </trans-unit>
        <trans-unit id="68d5384e54c19f936c634b6d988aedf31c295bf3" translate="yes" xml:space="preserve">
          <source>The start index of &lt;em&gt;doc&lt;/em&gt; where parsing failed.</source>
          <target state="translated">구문 분석에 실패한 &lt;em&gt;doc&lt;/em&gt; 의 시작 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="85b13200690d7aa62326c7849f57cc6925206c71" translate="yes" xml:space="preserve">
          <source>The starting column doesn&amp;rsquo;t matter:</source>
          <target state="translated">시작 열은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de2b727684bc631a4d8eca489abadd7633848760" translate="yes" xml:space="preserve">
          <source>The stateless encoding and decoding functions. These must be functions or methods which have the same interface as the &lt;a href=&quot;#codecs.Codec.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.Codec.decode&quot;&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/a&gt; methods of Codec instances (see &lt;a href=&quot;#codec-objects&quot;&gt;Codec Interface&lt;/a&gt;). The functions or methods are expected to work in a stateless mode.</source>
          <target state="translated">상태 비 저장 인코딩 및 디코딩 기능. 이들은 코덱 인스턴스 의 &lt;a href=&quot;#codecs.Codec.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.Codec.decode&quot;&gt; &lt;code&gt;decode()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 인터페이스를 가진 함수 또는 메소드 여야합니다 ( &lt;a href=&quot;#codec-objects&quot;&gt;코덱 인터페이스&lt;/a&gt; 참조 ). 함수 또는 메소드는 상태 비 저장 모드에서 작동 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="fc37fae53ad3d2cf8bbbb3fbc6970158d324b500" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;import spam.ham&lt;/code&gt; results in this call:</source>
          <target state="translated">&lt;code&gt;import spam.ham&lt;/code&gt; 문 은 다음 호출을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="57343ca400818c99d89cc954bac7f25bd563f12b" translate="yes" xml:space="preserve">
          <source>The statement:</source>
          <target state="translated">진술 :</target>
        </trans-unit>
        <trans-unit id="5f7f5bd7cdc067527c840f51d511b9f3a881789d" translate="yes" xml:space="preserve">
          <source>The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors:</source>
          <target state="translated">정적 유형 검사기는 새 유형을 원래 유형의 서브 클래스 인 것처럼 취급합니다. 이것은 논리적 오류를 포착하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="acb7f81b54e59ac66887405065b4bf032855f1db" translate="yes" xml:space="preserve">
          <source>The stdlib implementation is based on &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; module. It was written by &lt;em&gt;Dmitry Chestnykh&lt;/em&gt; based on C implementation written by &lt;em&gt;Samuel Neves&lt;/em&gt;. The documentation was copied from &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; and written by &lt;em&gt;Dmitry Chestnykh&lt;/em&gt;.</source>
          <target state="translated">stdlib 구현은 &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; 모듈을 기반으로 합니다. &lt;em&gt;Samuel Neves가&lt;/em&gt; 작성한 C 구현을 기반으로 &lt;em&gt;Dmitry Chestnykh&lt;/em&gt; 가 작성했습니다 . 이 문서는 &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; 에서 복사 되었으며 &lt;em&gt;Dmitry Chestnykh가&lt;/em&gt; 작성했습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6771d7c766fdf223fc75b578682b8b43ecb7225" translate="yes" xml:space="preserve">
          <source>The steps to create a standalone archive are as follows:</source>
          <target state="translated">독립형 아카이브를 작성하는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b08826ba03bafb388c1bd5be0f5d0ef0f9774b35" translate="yes" xml:space="preserve">
          <source>The straightforward translation into ctypes code would be this, but it does not work:</source>
          <target state="translated">ctypes 코드로의 간단한 변환은 다음과 같지만 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bbd18af7e807a1ecde8e654eeae316aad16083d" translate="yes" xml:space="preserve">
          <source>The strange invariant above is meant to be an efficient memory representation for a tournament. The numbers below are &lt;em&gt;k&lt;/em&gt;, not &lt;code&gt;a[k]&lt;/code&gt;:</source>
          <target state="translated">위의 이상한 불변은 토너먼트에 효율적인 메모리 표현을 의미합니다. 아래 번호는 &lt;em&gt;K&lt;/em&gt; 아닌 &lt;code&gt;a[k]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f3f83287161100c9dc848427c687a8403242c4e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'01234567'&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;'01234567'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="081b65b640d4fd9a1348073d2be076165e5d402b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'0123456789'&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;'0123456789'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4dc062e91d1dfe0b46d43e731a7d26c8429acd1c" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'0123456789abcdefABCDEF'&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;'0123456789abcdefABCDEF'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e169e91e10e1724d8d6b7fcde6b5762907d6051" translate="yes" xml:space="preserve">
          <source>The string &lt;em&gt;hash_name&lt;/em&gt; is the desired name of the hash digest algorithm for HMAC, e.g. &amp;lsquo;sha1&amp;rsquo; or &amp;lsquo;sha256&amp;rsquo;. &lt;em&gt;password&lt;/em&gt; and &lt;em&gt;salt&lt;/em&gt; are interpreted as buffers of bytes. Applications and libraries should limit &lt;em&gt;password&lt;/em&gt; to a sensible length (e.g. 1024). &lt;em&gt;salt&lt;/em&gt; should be about 16 or more bytes from a proper source, e.g. &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;hash_name&lt;/em&gt; 은 원하는 HMAC에 대한 해시 다이제스트 알고리즘의 이름입니다 (예 : 'sha1'또는 'sha256'). &lt;em&gt;비밀번호&lt;/em&gt; 와 &lt;em&gt;솔트&lt;/em&gt; 는 바이트 버퍼로 해석됩니다. 응용 프로그램 및 라이브러리는 &lt;em&gt;암호&lt;/em&gt; 를 적절한 길이 (예 : 1024)로 제한해야합니다 . &lt;em&gt;salt&lt;/em&gt; 는 적절한 소스에서 약 16 바이트 이상이어야합니다 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; 예 : os.urandom ()) .</target>
        </trans-unit>
        <trans-unit id="974fbe45930e6c9f7ed0ba945f3ca1dfc34eddbd" translate="yes" xml:space="preserve">
          <source>The string of characters accepted for the command prefix.</source>
          <target state="translated">명령 접두사에 허용되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="218df02f3b43ffd3271f33dc44503b415fe71878" translate="yes" xml:space="preserve">
          <source>The string of characters that are recognized as comment beginners. All characters from the comment beginner to end of line are ignored. Includes just &lt;code&gt;'#'&lt;/code&gt; by default.</source>
          <target state="translated">주석 초보자로 인식되는 문자열입니다. 주석 초보자부터 줄 끝까지의 모든 문자는 무시됩니다. 기본적으로 &lt;code&gt;'#'&lt;/code&gt; 만 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="08ac626721e1a485bd3af4b431e4c2809aea979e" translate="yes" xml:space="preserve">
          <source>The string of characters that will accumulate into multi-character tokens. By default, includes all ASCII alphanumerics and underscore. In POSIX mode, the accented characters in the Latin-1 set are also included. If &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt;&lt;code&gt;punctuation_chars&lt;/code&gt;&lt;/a&gt; is not empty, the characters &lt;code&gt;~-./*?=&lt;/code&gt;, which can appear in filename specifications and command line parameters, will also be included in this attribute, and any characters which appear in &lt;code&gt;punctuation_chars&lt;/code&gt; will be removed from &lt;code&gt;wordchars&lt;/code&gt; if they are present there. If &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt;&lt;code&gt;whitespace_split&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;True&lt;/code&gt;, this will have no effect.</source>
          <target state="translated">다중 문자 토큰에 누적 될 문자열입니다. 기본적으로 모든 ASCII 영숫자와 밑줄이 포함됩니다. POSIX 모드에서는 라틴 -1 세트의 악센트 부호 문자도 포함됩니다. 경우 &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt; &lt;code&gt;punctuation_chars&lt;/code&gt; 가&lt;/a&gt; 비어 있지 않은, 문자 &lt;code&gt;~-./*?=&lt;/code&gt; , 파일 이름 사양 및 명령 줄 매개 변수에 나타날 수 있습니다, 또한이 속성에 포함되며,에 나타나는 문자 &lt;code&gt;punctuation_chars&lt;/code&gt; 가 에서 제거됩니다 &lt;code&gt;wordchars&lt;/code&gt; 가있는 경우 거기에 선물하십시오. &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt; &lt;code&gt;whitespace_split&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;True&lt;/code&gt; 로 설정 되면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4659a50925d6df425ac6596dfc8a23084e3a4010" translate="yes" xml:space="preserve">
          <source>The string passed to &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열이 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5d5d7729b640e49a8b83a3c394f3b0662bfab3da" translate="yes" xml:space="preserve">
          <source>The string representation in dotted decimal notation. Leading zeroes are never included in the representation.</source>
          <target state="translated">점으로 구분 된 십진 표기법의 문자열 표현입니다. 선행 0은 표현에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36dad8efe406905d6d09a273705ad1e8e58e3f5c" translate="yes" xml:space="preserve">
          <source>The string representation of a path is the raw filesystem path itself (in native form, e.g. with backslashes under Windows), which you can pass to any function taking a file path as a string:</source>
          <target state="translated">경로의 문자열 표현은 원시 파일 시스템 경로 자체 (예 : Windows에서 백 슬래시 등)로 파일 경로를 문자열로 사용하는 모든 함수에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c60d280d907f21f86f32a46a5575681700d147" translate="yes" xml:space="preserve">
          <source>The string that the test was extracted from, or &lt;code&gt;None&lt;/code&gt; if the string is unavailable, or if the test was not extracted from a string.</source>
          <target state="translated">테스트가 추출 된 문자열 또는 문자열을 사용할 수 없거나 테스트가 문자열에서 추출되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e3d2b7a50a86f575f6fd45d43bbe5cf13d19875c" translate="yes" xml:space="preserve">
          <source>The string to be used to terminate lines in serialized output. The default is &lt;code&gt;\n&lt;/code&gt; because that&amp;rsquo;s the internal end-of-line discipline used by Python, though &lt;code&gt;\r\n&lt;/code&gt; is required by the RFCs.</source>
          <target state="translated">직렬화 된 출력에서 ​​라인을 종료하는 데 사용되는 문자열입니다. RFC에는 &lt;code&gt;\r\n&lt;/code&gt; 이 필요 하지만 파이썬에서 사용하는 내부 줄 끝 규칙이기 때문에 기본값은 &lt;code&gt;\n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a2ea49d3d095e008ddabf5c5d79618ebc583572" translate="yes" xml:space="preserve">
          <source>The string used to separate (or, rather, terminate) lines on the current platform. This may be a single character, such as &lt;code&gt;'\n'&lt;/code&gt; for POSIX, or multiple characters, for example, &lt;code&gt;'\r\n'&lt;/code&gt; for Windows. Do not use &lt;em&gt;os.linesep&lt;/em&gt; as a line terminator when writing files opened in text mode (the default); use a single &lt;code&gt;'\n'&lt;/code&gt; instead, on all platforms.</source>
          <target state="translated">현재 플랫폼에서 행을 분리 (또는 오히려 종료)하는 데 사용되는 문자열입니다. POSIX의 경우 &lt;code&gt;'\n'&lt;/code&gt; 과 같은 단일 문자 이거나 Windows의 경우 &lt;code&gt;'\r\n'&lt;/code&gt; 과 같은 여러 문자 일 수 있습니다. 텍스트 모드에서 열린 파일을 쓸 때 &lt;em&gt;os.linesep&lt;/em&gt; 를 줄 종결 &lt;em&gt;자로&lt;/em&gt; 사용하지 마십시오 (기본값). 모든 플랫폼 에서 단일 &lt;code&gt;'\n'&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8ea85089ca50f62fa2ade25bca0d6a593de3d007" translate="yes" xml:space="preserve">
          <source>The string used to terminate lines produced by the &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt;. It defaults to &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 생성 한 행을 종료하는 데 사용되는 문자열 입니다. 기본값은 &lt;code&gt;'\r\n'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9cf8db53ba3ecf1804cef93b7a3f29860b461c29" translate="yes" xml:space="preserve">
          <source>The structure of INI files is described &lt;a href=&quot;#supported-ini-file-structure&quot;&gt;in the following section&lt;/a&gt;. Essentially, the file consists of sections, each of which contains keys with values. &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; classes can read and write such files. Let&amp;rsquo;s start by creating the above configuration file programmatically.</source>
          <target state="translated">INI 파일의 구조 &lt;a href=&quot;#supported-ini-file-structure&quot;&gt;는 다음 섹션에서&lt;/a&gt; 설명 합니다 . 기본적으로 파일은 섹션으로 구성되며 각 섹션에는 값이있는 키가 포함됩니다. &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 클래스는 이러한 파일을 읽고 쓸 수 있습니다. 프로그래밍 방식으로 위의 구성 파일을 만들어 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="57ac7e21799c7f677af76b9cfb1a314919d92910" translate="yes" xml:space="preserve">
          <source>The subclass shown above sets &lt;code&gt;__slots__&lt;/code&gt; to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries.</source>
          <target state="translated">위에 표시된 서브 클래스는 &lt;code&gt;__slots__&lt;/code&gt; 를 빈 튜플로 설정합니다 . 이를 통해 인스턴스 사전 작성을 방지하여 메모리 요구 사항을 낮게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1049894083da3d6136643ae40107b301d4f0a75b" translate="yes" xml:space="preserve">
          <source>The subnets that join to make the current network definition, depending on the argument values. &lt;em&gt;prefixlen_diff&lt;/em&gt; is the amount our prefix length should be increased by. &lt;em&gt;new_prefix&lt;/em&gt; is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of &lt;em&gt;prefixlen_diff&lt;/em&gt; and &lt;em&gt;new_prefix&lt;/em&gt; must be set. Returns an iterator of network objects.</source>
          <target state="translated">인수 값에 따라 현재 네트워크 정의를 만들기 위해 참여하는 서브넷. &lt;em&gt;prefixlen_diff&lt;/em&gt; 는 접두사 길이를 늘려야하는 양입니다. &lt;em&gt;new_prefix&lt;/em&gt; 는 서브넷의 원하는 새 접두사입니다. 접두사보다 커야합니다. &lt;em&gt;prefixlen_diff&lt;/em&gt; 및 &lt;em&gt;new_prefix&lt;/em&gt; 중 하나만 설정해야합니다. 네트워크 객체의 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9437b122f21ab7e79496b92a68b7f9e5eeaac2be" translate="yes" xml:space="preserve">
          <source>The subpath within the ZIP file where modules are searched. This is the empty string for zipimporter objects which point to the root of the ZIP file.</source>
          <target state="translated">모듈이 검색되는 ZIP 파일 내의 서브 패스. ZIP 파일의 루트를 가리키는 zipimporter 객체의 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="326ec51a05e2c8d6e7c26dd0d96fea0857cfc5e7" translate="yes" xml:space="preserve">
          <source>The subprocess is created by th &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">서브 프로세스는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="830a5ed8adcd9cd5ec5ebf36f7cf9f4fb4e3e294" translate="yes" xml:space="preserve">
          <source>The subprocess is created by the &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">서브 프로세스는 &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="195b42e9196a41c00a54c69540f8c3689b081015" translate="yes" xml:space="preserve">
          <source>The subscription syntax must always be used with exactly two values: the argument list and the return type. The argument list must be a list of types or an ellipsis; the return type must be a single type.</source>
          <target state="translated">구독 구문은 항상 정확히 두 개의 값, 즉 인수 목록과 반환 유형과 함께 사용해야합니다. 인수 목록은 유형 또는 줄임표 목록이어야합니다. 리턴 유형은 단일 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6a7c51bccf2dda395b8edfb0931dfbbc3947a4fd" translate="yes" xml:space="preserve">
          <source>The subsequence to search for and its replacement may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 서브 시퀀스와 그 대체는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 유사 오브젝트&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f20be2f3a12314bdd168b8b8dc36ec5a219e64be" translate="yes" xml:space="preserve">
          <source>The subsequence to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an integer in the range 0 to 255.</source>
          <target state="translated">검색 할 서브 시퀀스는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 유사 오브젝트&lt;/a&gt; 이거나 0-255 범위의 정수일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="733f0146d975374d445236d55e27c28b82ab24a4" translate="yes" xml:space="preserve">
          <source>The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so &lt;em&gt;all&lt;/em&gt; of the following return &lt;code&gt;False&lt;/code&gt;: &lt;code&gt;a&amp;lt;b&lt;/code&gt;, &lt;code&gt;a==b&lt;/code&gt;, or &lt;code&gt;a&amp;gt;b&lt;/code&gt;.</source>
          <target state="translated">부분 집합과 동등 비교는 전체 순서 함수로 일반화되지 않습니다. 예를 들어, 비어 있지 않은 임의의 두 개의 분리 된 세트들은, 동일하지 않은 서로의 서브 세트되지 않도록 &lt;em&gt;모든&lt;/em&gt; 다음 리턴의 &lt;code&gt;False&lt;/code&gt; : &lt;code&gt;a&amp;lt;b&lt;/code&gt; , &lt;code&gt;a==b&lt;/code&gt; 또는 &lt;code&gt;a&amp;gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d313acbcf2f63dafe9fec9edee3d8cece85e3a5f" translate="yes" xml:space="preserve">
          <source>The suffix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 접미사는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​비슷한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc8de5ade168ce8d52e288779f29cce661700e1e" translate="yes" xml:space="preserve">
          <source>The suggested launcher above uses the Python embedding API. This means that in your application, &lt;code&gt;sys.executable&lt;/code&gt; will be your application, and &lt;em&gt;not&lt;/em&gt; a conventional Python interpreter. Your code and its dependencies need to be prepared for this possibility. For example, if your application uses the &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; module, it will need to call &lt;a href=&quot;multiprocessing#multiprocessing.set_executable&quot;&gt;&lt;code&gt;multiprocessing.set_executable()&lt;/code&gt;&lt;/a&gt; to let the module know where to find the standard Python interpreter.</source>
          <target state="translated">위의 제안 된 런처는 Python 임베딩 API를 사용합니다. 이것은 응용 프로그램에서 &lt;code&gt;sys.executable&lt;/code&gt; 이 일반적인 Python 인터프리터가 &lt;em&gt;아닌&lt;/em&gt; 응용 프로그램임을 의미합니다 . 이 가능성에 대비하여 코드와 해당 종속성을 준비해야합니다. 예를 들어, 애플리케이션이 &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 모듈을 사용하는 경우 multiprocessing.set_ &lt;a href=&quot;multiprocessing#multiprocessing.set_executable&quot;&gt; &lt;code&gt;multiprocessing.set_executable()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 모듈에 표준 Python 인터프리터를 찾을 수있는 위치를 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="4ca94cda6ea6ac6e5a70ea1ff1f1c7c7cd83fb8d" translate="yes" xml:space="preserve">
          <source>The supernet containing this network definition, depending on the argument values. &lt;em&gt;prefixlen_diff&lt;/em&gt; is the amount our prefix length should be decreased by. &lt;em&gt;new_prefix&lt;/em&gt; is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of &lt;em&gt;prefixlen_diff&lt;/em&gt; and &lt;em&gt;new_prefix&lt;/em&gt; must be set. Returns a single network object.</source>
          <target state="translated">인수 값에 따라이 네트워크 정의를 포함하는 슈퍼 넷. &lt;em&gt;prefixlen_diff&lt;/em&gt; 는 접두사 길이를 &lt;em&gt;줄여야&lt;/em&gt; 하는 양입니다. &lt;em&gt;new_prefix&lt;/em&gt; 는 수퍼 넷의 원하는 새 접두사입니다. 접두사보다 작아야합니다. &lt;em&gt;prefixlen_diff&lt;/em&gt; 및 &lt;em&gt;new_prefix&lt;/em&gt; 중 하나만 설정해야합니다. 단일 네트워크 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d3a132475eefbff651be1e9f60f5a01256ac706" translate="yes" xml:space="preserve">
          <source>The symbolic &lt;code&gt;LOG_&lt;/code&gt; values are defined in &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt;&lt;code&gt;SysLogHandler&lt;/code&gt;&lt;/a&gt; and mirror the values defined in the &lt;code&gt;sys/syslog.h&lt;/code&gt; header file.</source>
          <target state="translated">기호 &lt;code&gt;LOG_&lt;/code&gt; 값은 &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt; &lt;code&gt;SysLogHandler&lt;/code&gt; 에&lt;/a&gt; 정의되어 있으며 &lt;code&gt;sys/syslog.h&lt;/code&gt; 헤더 파일에 정의 된 값을 미러링 합니다.</target>
        </trans-unit>
        <trans-unit id="2855402ac7e633af0e756490916e4b0509c9ee96" translate="yes" xml:space="preserve">
          <source>The symbolic constants for the telnet commands are: IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</source>
          <target state="translated">텔넷 명령의 기호 상수는 IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO ( 출력 중단), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</target>
        </trans-unit>
        <trans-unit id="f8ce1d87c905659a0bf890b9cf481e55b1edc39a" translate="yes" xml:space="preserve">
          <source>The system handle used to access the library.</source>
          <target state="translated">라이브러리에 액세스하는 데 사용되는 시스템 핸들.</target>
        </trans-unit>
        <trans-unit id="6fc6b22d1825c9f09c313587868ef00b4493d95a" translate="yes" xml:space="preserve">
          <source>The system identifier for the external subset of the document type definition. This will be a URI as a string, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문서 유형 정의의 외부 서브 세트에 대한 시스템 ID. 이것은 문자열로서의 URI이거나 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44d450cf187b52bfa50e049a62fae0de2e42ee87" translate="yes" xml:space="preserve">
          <source>The system is a domain controller.</source>
          <target state="translated">시스템은 도메인 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="40e3a3638774f49e1f39d0e71a7abdae17b2e149" translate="yes" xml:space="preserve">
          <source>The system is a server, but not a domain controller.</source>
          <target state="translated">시스템은 서버이지만 도메인 컨트롤러는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7c73a5e107d91be1df5f93f12cd8765ccebb12ce" translate="yes" xml:space="preserve">
          <source>The system is a workstation.</source>
          <target state="translated">시스템은 워크 스테이션입니다.</target>
        </trans-unit>
        <trans-unit id="55ae6ebbe2e07465f0616803ac45ed0fa6855ad1" translate="yes" xml:space="preserve">
          <source>The system will save old log files by appending extensions to the filename. The extensions are date-and-time based, using the strftime format &lt;code&gt;%Y-%m-%d_%H-%M-%S&lt;/code&gt; or a leading portion thereof, depending on the rollover interval.</source>
          <target state="translated">시스템은 파일 이름에 확장자를 추가하여 이전 로그 파일을 저장합니다. 확장은 롤오버 간격에 따라 strftime 형식 &lt;code&gt;%Y-%m-%d_%H-%M-%S&lt;/code&gt; 또는 그 앞 부분을 사용하여 날짜 및 시간을 기준으로 합니다.</target>
        </trans-unit>
        <trans-unit id="179fc435688f8e8cc38d18cd776581a529b4d5f3" translate="yes" xml:space="preserve">
          <source>The tab will not be displayed, but the associated window remains managed by the notebook and its configuration remembered. Hidden tabs may be restored with the &lt;a href=&quot;#tkinter.ttk.Notebook.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">탭은 표시되지 않지만 관련 창은 노트북에 의해 관리되고 구성이 기억됩니다. 숨겨진 탭은 &lt;a href=&quot;#tkinter.ttk.Notebook.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 명령 으로 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b061342e7fcb41c80cbeeac10798ba4a35c7df9" translate="yes" xml:space="preserve">
          <source>The tab_id present in several methods of &lt;code&gt;ttk.Notebook&lt;/code&gt; may take any of the following forms:</source>
          <target state="translated">ttk.Notebook의 여러 메소드에 존재하는 &lt;code&gt;ttk.Notebook&lt;/code&gt; 는 다음 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d522d8935e08991d14cdfc081478c07442e166b" translate="yes" xml:space="preserve">
          <source>The table below compares the syntax for creating shared ctypes objects from shared memory with the normal ctypes syntax. (In the table &lt;code&gt;MyStruct&lt;/code&gt; is some subclass of &lt;a href=&quot;ctypes#ctypes.Structure&quot;&gt;&lt;code&gt;ctypes.Structure&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">아래 표는 공유 메모리에서 공유 ctypes 객체를 생성하는 구문과 일반 ctypes 구문을 비교합니다. (표에서 &lt;code&gt;MyStruct&lt;/code&gt; 는 &lt;a href=&quot;ctypes#ctypes.Structure&quot;&gt; &lt;code&gt;ctypes.Structure&lt;/code&gt; 의&lt;/a&gt; 일부 서브 클래스입니다 .)</target>
        </trans-unit>
        <trans-unit id="7bccc06bc889ee84856fdd46b401f47559a82ae4" translate="yes" xml:space="preserve">
          <source>The table below provides a high-level comparison of &lt;code&gt;strftime()&lt;/code&gt; versus &lt;code&gt;strptime()&lt;/code&gt;:</source>
          <target state="translated">아래 표는 &lt;code&gt;strftime()&lt;/code&gt; 과 &lt;code&gt;strptime()&lt;/code&gt; 의 높은 수준의 비교를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e3dbc221607127a001cdb67dd95041333051b2e0" translate="yes" xml:space="preserve">
          <source>The tar format was originally conceived to make backups on tape drives with the main focus on preserving file system information. Nowadays tar archives are commonly used for file distribution and exchanging archives over networks. One problem of the original format (which is the basis of all other formats) is that there is no concept of supporting different character encodings. For example, an ordinary tar archive created on a &lt;em&gt;UTF-8&lt;/em&gt; system cannot be read correctly on a &lt;em&gt;Latin-1&lt;/em&gt; system if it contains non-&lt;em&gt;ASCII&lt;/em&gt; characters. Textual metadata (like filenames, linknames, user/group names) will appear damaged. Unfortunately, there is no way to autodetect the encoding of an archive. The pax format was designed to solve this problem. It stores non-ASCII metadata using the universal character encoding &lt;em&gt;UTF-8&lt;/em&gt;.</source>
          <target state="translated">tar 형식은 원래 파일 시스템 정보 보존에 중점을 둔 테이프 드라이브에서 백업하기 위해 고안되었습니다. 오늘날 tar 아카이브는 파일 배포 및 네트워크를 통한 아카이브 교환에 일반적으로 사용됩니다. 원래 형식 (다른 모든 형식의 기초)의 한 가지 문제점은 다른 문자 인코딩을 지원한다는 개념이 없다는 것입니다. 예를 들어, &lt;em&gt;UTF-8&lt;/em&gt; 시스템 에서 작성된 일반 tar 아카이브는 &lt;em&gt;ASCII&lt;/em&gt; 가 아닌 경우 &lt;em&gt;라틴 -1&lt;/em&gt; 시스템 에서 올바르게 읽을 수 없습니다.&lt;em&gt;&lt;/em&gt;문자. 파일 이름, 링크 이름, 사용자 / 그룹 이름과 같은 텍스트 메타 데이터가 손상된 것으로 나타납니다. 불행히도, 아카이브 인코딩을 자동 감지하는 방법은 없습니다. pax 형식은이 문제를 해결하도록 설계되었습니다. 범용 문자 인코딩 &lt;em&gt;UTF-8을&lt;/em&gt; 사용하여 비 ASCII 메타 데이터를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="39109a83b1e6877b05cef869c019b4e8c66ec92a" translate="yes" xml:space="preserve">
          <source>The task is executed in the loop returned by &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised if there is no running loop in current thread.</source>
          <target state="translated">작업은 &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 루프에서 실행되며 현재 스레드에 실행중인 루프가 없으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6cd178d789e9c72b2db2b532b1e1730e28430479" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;delegation to the parent&amp;rsquo; means that if a logger has a level of NOTSET, its chain of ancestor loggers is traversed until either an ancestor with a level other than NOTSET is found, or the root is reached.</source>
          <target state="translated">'부모에게 위임'이라는 용어는 로거에 NOTSET 레벨이있는 ​​경우 NOTSET 이외의 레벨을 가진 조상을 찾거나 루트에 도달 할 때까지 상위 로거 체인이 순회 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="146eafd5f201d9458991952860d529510a852604" translate="yes" xml:space="preserve">
          <source>The term &lt;em&gt;seconds since the epoch&lt;/em&gt; refers to the total number of elapsed seconds since the epoch, typically excluding &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;leap seconds&lt;/a&gt;. Leap seconds are excluded from this total on all POSIX-compliant platforms.</source>
          <target state="translated">&lt;em&gt;에포크 이후 초라&lt;/em&gt; 는 용어 는 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;윤초를&lt;/a&gt; 제외하고 에포크 이후 경과 된 총 초 수를 나타냅니다 . 모든 POSIX 호환 플랫폼에서 윤초는이 총계에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="e94bbf67fcc1b6bd4b3967baa1ebc9ad25d9c0c5" translate="yes" xml:space="preserve">
          <source>The test code can more easily be separated from shipped code.</source>
          <target state="translated">테스트 코드는 제공된 코드와 쉽게 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="de4938c1a0bc8d676536f4fba441042877342846" translate="yes" xml:space="preserve">
          <source>The test function should return a string describing the image type if the test succeeded, or &lt;code&gt;None&lt;/code&gt; if it failed.</source>
          <target state="translated">테스트 함수는 테스트에 성공한 경우 이미지 유형을 설명하는 문자열을 반환하고 실패한 경우 &lt;code&gt;None&lt;/code&gt; 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="401d59c5ffb4d3b57f5880747f129772c3d55bd5" translate="yes" xml:space="preserve">
          <source>The test module can be run standalone from the command line.</source>
          <target state="translated">테스트 모듈은 명령 행에서 독립형으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060a6930386a9d1574b1aa1b3c3bc2d33784e7a8" translate="yes" xml:space="preserve">
          <source>The test passes if at least one message emitted inside the &lt;code&gt;with&lt;/code&gt; block matches the &lt;em&gt;logger&lt;/em&gt; and &lt;em&gt;level&lt;/em&gt; conditions, otherwise it fails.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내에서 생성 된 하나 이상의 메시지 가 &lt;em&gt;로거&lt;/em&gt; 및 &lt;em&gt;레벨&lt;/em&gt; 조건 과 일치하면 테스트가 통과 되고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0c1c8392f06e470e9763ff342c0bf458700b10d0" translate="yes" xml:space="preserve">
          <source>The test runner&amp;rsquo;s display output can be controlled in two ways. First, an output function can be passed to &lt;code&gt;TestRunner.run()&lt;/code&gt;; this function will be called with strings that should be displayed. It defaults to &lt;code&gt;sys.stdout.write&lt;/code&gt;. If capturing the output is not sufficient, then the display output can be also customized by subclassing DocTestRunner, and overriding the methods &lt;a href=&quot;#doctest.DocTestRunner.report_start&quot;&gt;&lt;code&gt;report_start()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.DocTestRunner.report_success&quot;&gt;&lt;code&gt;report_success()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.DocTestRunner.report_unexpected_exception&quot;&gt;&lt;code&gt;report_unexpected_exception()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#doctest.DocTestRunner.report_failure&quot;&gt;&lt;code&gt;report_failure()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테스트 러너의 디스플레이 출력은 두 가지 방법으로 제어 할 수 있습니다. 먼저, 출력 함수를 &lt;code&gt;TestRunner.run()&lt;/code&gt; 전달할 수 있습니다 . 이 함수는 표시되어야하는 문자열과 함께 호출됩니다. 기본값은 &lt;code&gt;sys.stdout.write&lt;/code&gt; 입니다. 출력을 캡처하는 데 충분하지 않은 경우 DocTestRunner를 서브 클래 싱하고 &lt;a href=&quot;#doctest.DocTestRunner.report_start&quot;&gt; &lt;code&gt;report_start()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#doctest.DocTestRunner.report_success&quot;&gt; &lt;code&gt;report_success()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#doctest.DocTestRunner.report_unexpected_exception&quot;&gt; &lt;code&gt;report_unexpected_exception()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#doctest.DocTestRunner.report_failure&quot;&gt; &lt;code&gt;report_failure()&lt;/code&gt; &lt;/a&gt; 메소드를 대체하여 표시 출력을 사용자 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb4a3424a4f1dda3e01eea1f89d1c0f58bff9865" translate="yes" xml:space="preserve">
          <source>The testing code of a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; instance should be entirely self contained, such that it can be run either in isolation or in arbitrary combination with any number of other test cases.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 인스턴스 의 테스트 코드는 완전히 독립적으로 포함되어 있어야하며, 별도로 테스트하거나 다른 테스트 사례와 임의의 조합으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ae3f29483e2ee3ea0f7163c30937acfdb9d4b25" translate="yes" xml:space="preserve">
          <source>The testing suite should exercise all classes, functions, and constants. This includes not just the external API that is to be presented to the outside world but also &amp;ldquo;private&amp;rdquo; code.</source>
          <target state="translated">테스트 스위트는 모든 클래스, 함수 및 상수를 연습해야합니다. 여기에는 외부에 제공되는 외부 API뿐만 아니라 &quot;비공개&quot;코드도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="daaa85794b2e5ea58362f9c215438cdd2e5ff243" translate="yes" xml:space="preserve">
          <source>The text and background colors for the context pane can be configured under the Highlights tab in the Configure IDLE dialog.</source>
          <target state="translated">컨텍스트 창의 텍스트 및 배경색은 IDLE 구성 대화 상자의 하이라이트 탭에서 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2ad191eeb4d0bbf960c378232847d949f175e9" translate="yes" xml:space="preserve">
          <source>The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches:</source>
          <target state="translated">텍스트 범주는 정규식으로 지정됩니다. 이 기술은 이들을 단일 마스터 정규 표현식으로 결합하고 연속 일치 항목을 반복하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d833b1a3893c5d6101423fd99ed50cd0a6703e5" translate="yes" xml:space="preserve">
          <source>The text stream API is described in detail in the documentation of &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">텍스트 스트림 API는 &lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; &lt;/a&gt; 문서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f2c2cd14f223c08b886437c2b9c2073b05f038" translate="yes" xml:space="preserve">
          <source>The text to display in the column heading.</source>
          <target state="translated">열 머리글에 표시 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="624bc91f26efa2f3c6b7ab6d643f9eaaecd49465" translate="yes" xml:space="preserve">
          <source>The text value of the attribute. This is a synonym for the &lt;code&gt;nodeValue&lt;/code&gt; attribute.</source>
          <target state="translated">속성의 텍스트 값입니다. 이것은 &lt;code&gt;nodeValue&lt;/code&gt; 속성 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="d1d2cdc643f2142769f11e3bf3f5f6639f0d087f" translate="yes" xml:space="preserve">
          <source>The text widget and scrollbar are packed together in a &lt;code&gt;Frame&lt;/code&gt;, and the methods of the &lt;code&gt;Grid&lt;/code&gt; and &lt;code&gt;Pack&lt;/code&gt; geometry managers are acquired from the &lt;code&gt;Frame&lt;/code&gt; object. This allows the &lt;code&gt;ScrolledText&lt;/code&gt; widget to be used directly to achieve most normal geometry management behavior.</source>
          <target state="translated">텍스트 위젯과 스크롤 막대는 &lt;code&gt;Frame&lt;/code&gt; 에 함께 묶여지고 &lt;code&gt;Grid&lt;/code&gt; 및 &lt;code&gt;Pack&lt;/code&gt; 지오메트리 관리자 의 메소드 는 &lt;code&gt;Frame&lt;/code&gt; 객체 에서 얻습니다 . 이를 통해 &lt;code&gt;ScrolledText&lt;/code&gt; 위젯을 직접 사용하여 가장 일반적인 형상 관리 동작을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781fd46cb32fb2d772f49135a740a4dd6122fbb5" translate="yes" xml:space="preserve">
          <source>The textual label to display for the item.</source>
          <target state="translated">항목에 표시 할 텍스트 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="7e98aa474e18722e2a15841579721066227b8523" translate="yes" xml:space="preserve">
          <source>The third optional keyword argument is &lt;em&gt;extra&lt;/em&gt; which can be used to pass a dictionary which is used to populate the __dict__ of the LogRecord created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example:</source>
          <target state="translated">세 번째 선택적 키워드 인수는 &lt;em&gt;extra&lt;/em&gt; 이며 이는 로깅 이벤트에 대해 작성된 LogRecord의 __dict__를 사용자 정의 속성으로 채우는 데 사용되는 사전을 전달하는 데 사용할 수 있습니다. 그런 다음이 사용자 정의 속성을 원하는대로 사용할 수 있습니다. 예를 들어, 로그 된 메시지에 통합 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="665f31530d18339b9c188c1b9103b2b958ccad7e" translate="yes" xml:space="preserve">
          <source>The third optional keyword argument is &lt;em&gt;stacklevel&lt;/em&gt;, which defaults to &lt;code&gt;1&lt;/code&gt;. If greater than 1, the corresponding number of stack frames are skipped when computing the line number and function name set in the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; created for the logging event. This can be used in logging helpers so that the function name, filename and line number recorded are not the information for the helper function/method, but rather its caller. The name of this parameter mirrors the equivalent one in the &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">세 번째 선택적 키워드 인수는 &lt;em&gt;stacklevel&lt;/em&gt; 이며 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 1보다 크면 로깅 이벤트에 대해 작성된 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 에&lt;/a&gt; 설정된 행 번호 및 기능 이름을 계산할 때 해당 수의 스택 프레임이 건너 뜁니다 . 이것은 헬퍼 로깅에 사용될 수 있으므로 기록 된 함수 이름, 파일 이름 및 행 번호는 헬퍼 기능 / 방법에 대한 정보가 아니라 호출자에 대한 정보입니다. 이 매개 변수의 이름은 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈 에서 동등한 것을 미러링합니다 .</target>
        </trans-unit>
        <trans-unit id="8eb0c095fa10852ea09d13926b5914515b40f06b" translate="yes" xml:space="preserve">
          <source>The third-party &lt;a href=&quot;https://pypi.org/project/regex/&quot;&gt;regex&lt;/a&gt; module, which has an API compatible with the standard library &lt;a href=&quot;#module-re&quot;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt; module, but offers additional functionality and a more thorough Unicode support.</source>
          <target state="translated">타사 &lt;a href=&quot;https://pypi.org/project/regex/&quot;&gt;정규식&lt;/a&gt; 표준 라이브러리와 호환 API가 모듈, &lt;a href=&quot;#module-re&quot;&gt; &lt;code&gt;re&lt;/code&gt; &lt;/a&gt; 모듈 만 제공 추가 기능 및보다 철저한 유니 코드 지원.</target>
        </trans-unit>
        <trans-unit id="afb06b3287857cf9d40f49ddb415dd4aae4a33b0" translate="yes" xml:space="preserve">
          <source>The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although &lt;code&gt;quick_ratio()&lt;/code&gt; and &lt;code&gt;real_quick_ratio()&lt;/code&gt; are always at least as large as &lt;code&gt;ratio()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;quick_ratio()&lt;/code&gt; 및 &lt;code&gt;real_quick_ratio()&lt;/code&gt; 는 항상 &lt;code&gt;ratio()&lt;/code&gt; 만큼 크지 만 총 문자에 대한 일치 비율을 반환하는 세 가지 방법은 근사 수준이 다르기 때문에 다른 결과를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="702f3b2e21f5e77bbf53b54dae40e50493de58c9" translate="yes" xml:space="preserve">
          <source>The time and date of the last modification to the archive member. This is a tuple of six values:</source>
          <target state="translated">아카이브 멤버를 마지막으로 수정 한 시간 및 날짜입니다. 이것은 6 가지 값의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="973cda5cc6748314dfb6fc94d1ded91647c97ce5" translate="yes" xml:space="preserve">
          <source>The time is an absolute timestamp, using the same time reference as &lt;a href=&quot;#asyncio.loop.time&quot;&gt;&lt;code&gt;loop.time()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시간은 &lt;a href=&quot;#asyncio.loop.time&quot;&gt; &lt;code&gt;loop.time()&lt;/code&gt; &lt;/a&gt; 과 동일한 시간 참조를 사용하는 절대 시간 소인 입니다.</target>
        </trans-unit>
        <trans-unit id="a0676e756a3ab92c3f906666f0e732cf57a4078c" translate="yes" xml:space="preserve">
          <source>The time limit (in microseconds) on CPU time that a process can spend under real-time scheduling without making a blocking syscall.</source>
          <target state="translated">프로세스가 syscall을 차단하지 않고 실시간 스케줄링 하에서 소비 할 수있는 CPU 시간의 시간 제한 (마이크로 초).</target>
        </trans-unit>
        <trans-unit id="f49b9982b8903d085f6ab35fedbabd6bf7292265" translate="yes" xml:space="preserve">
          <source>The time taken by this routine is proportional to &lt;code&gt;len(fragment)&lt;/code&gt;.</source>
          <target state="translated">이 루틴에 걸리는 시간은 &lt;code&gt;len(fragment)&lt;/code&gt; 비례합니다 .</target>
        </trans-unit>
        <trans-unit id="f9aa5984100afffa888154716c5fc64965cd814c" translate="yes" xml:space="preserve">
          <source>The time value as returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;, and accepted by &lt;a href=&quot;#time.asctime&quot;&gt;&lt;code&gt;asctime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.mktime&quot;&gt;&lt;code&gt;mktime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt;, is a sequence of 9 integers. The return values of &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; also offer attribute names for individual fields.</source>
          <target state="translated">&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 에서 반환되고 &lt;a href=&quot;#time.asctime&quot;&gt; &lt;code&gt;asctime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.mktime&quot;&gt; &lt;code&gt;mktime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; 에서 허용되는 시간 값 은 9 개의 정수 시퀀스입니다. &lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 의 반환 값은 개별 필드의 속성 이름도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="383501791bf73fad29eacbd1434a825d90dcda3d" translate="yes" xml:space="preserve">
          <source>The title bar contains the name of the file, the full path, and the version of Python and IDLE running the window. The status bar contains the line number (&amp;lsquo;Ln&amp;rsquo;) and column number (&amp;lsquo;Col&amp;rsquo;). Line numbers start with 1; column numbers with 0.</source>
          <target state="translated">제목 표시 줄에는 파일 이름, 전체 경로 및 창을 실행하는 Python 및 IDLE 버전이 포함됩니다. 상태 표시 줄에는 줄 번호 ( 'Ln')와 열 번호 ( 'Col')가 있습니다. 줄 번호는 1로 시작합니다. 열 번호는 0입니다.</target>
        </trans-unit>
        <trans-unit id="eb0ed541e548fb76d9c95f3b320418110775e844" translate="yes" xml:space="preserve">
          <source>The token buffer. It may be useful to examine this when catching exceptions.</source>
          <target state="translated">토큰 버퍼. 예외를 발견 할 때이를 검사하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af5684156d0632efbb688be764db6d9de4886083" translate="yes" xml:space="preserve">
          <source>The token constants are:</source>
          <target state="translated">토큰 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6369db38b3c0c1619322ec307a8d31c67ea8b3e6" translate="yes" xml:space="preserve">
          <source>The token is an opaque object (that supports equality testing) identifying the current version of the abstract base class cache for virtual subclasses. The token changes with every call to &lt;a href=&quot;#abc.ABCMeta.register&quot;&gt;&lt;code&gt;ABCMeta.register()&lt;/code&gt;&lt;/a&gt; on any ABC.</source>
          <target state="translated">토큰은 가상 서브 클래스에 대한 추상 기본 클래스 캐시의 현재 버전을 식별하는 불투명 오브젝트 (동일성 테스트를 지원)입니다. 모든 ABC 에서 &lt;a href=&quot;#abc.ABCMeta.register&quot;&gt; &lt;code&gt;ABCMeta.register()&lt;/code&gt; &lt;/a&gt; 를 호출 할 때마다 토큰이 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="39df4a005bd76c17fb119282afd8e40603dd44b7" translate="yes" xml:space="preserve">
          <source>The tokenizer produces the following output:</source>
          <target state="translated">토크 나이 저는 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e1221339de21aeb616c4d21ccf9328f0f362ac4" translate="yes" xml:space="preserve">
          <source>The total number (&lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;) of expected bytes.</source>
          <target state="translated">예상 바이트 의 총 수 ( &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="43f447355b23a2390fda8e4efbaeb61ee2a32abe" translate="yes" xml:space="preserve">
          <source>The total number of addresses in the network.</source>
          <target state="translated">네트워크의 총 주소 수입니다.</target>
        </trans-unit>
        <trans-unit id="533c0b6ab55091223e2fa983b0fc2fb594c66022" translate="yes" xml:space="preserve">
          <source>The total number of bits in the address representation for this version: &lt;code&gt;32&lt;/code&gt; for IPv4, &lt;code&gt;128&lt;/code&gt; for IPv6.</source>
          <target state="translated">이 버전에 대한 주소 표현의 총 비트 수 : IPv4의 경우 &lt;code&gt;32&lt;/code&gt; , IPv6의 경우 &lt;code&gt;128&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fa2435ac265900a21416de414ab6af83ae21237" translate="yes" xml:space="preserve">
          <source>The total number of tests run so far.</source>
          <target state="translated">지금까지 총 테스트 수입니다.</target>
        </trans-unit>
        <trans-unit id="e85ca4d6aa52bdeda7f809afceddc2f2528db8a5" translate="yes" xml:space="preserve">
          <source>The total number of to be consumed bytes.</source>
          <target state="translated">소비되는 총 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="ffa71222143917a1eb6464750e264a1c1dc0389a" translate="yes" xml:space="preserve">
          <source>The trace function is invoked (with &lt;em&gt;event&lt;/em&gt; set to &lt;code&gt;'call'&lt;/code&gt;) whenever a new local scope is entered; it should return a reference to a local trace function to be used for the new scope, or &lt;code&gt;None&lt;/code&gt; if the scope shouldn&amp;rsquo;t be traced.</source>
          <target state="translated">새로운 로컬 범위가 입력 될 때마다 추적 기능이 호출됩니다 ( &lt;em&gt;이벤트&lt;/em&gt; 가 &lt;code&gt;'call'&lt;/code&gt; 로 설정 됨 ). 새 범위에 사용할 로컬 추적 함수에 대한 참조를 반환하거나 범위를 추적하지 않아야하는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0276db0e37cffd313334d18dfb0ebfdd11f2c19" translate="yes" xml:space="preserve">
          <source>The traceback header is followed by an optional traceback stack, whose contents are ignored by doctest. The traceback stack is typically omitted, or copied verbatim from an interactive session.</source>
          <target state="translated">역 추적 헤더 다음에는 선택적인 역 추적 스택이 있으며, 그 내용은 doctest에 의해 무시됩니다. 트레이스 백 스택은 일반적으로 생략되거나 대화식 세션에서 그대로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="2d935d9b67ec8b6f96388a84f36cbe32492b44c2" translate="yes" xml:space="preserve">
          <source>The traceback stack is followed by the most interesting part: the line(s) containing the exception type and detail. This is usually the last line of a traceback, but can extend across multiple lines if the exception has a multi-line detail:</source>
          <target state="translated">트레이스 백 스택 다음에는 가장 흥미로운 부분이 있습니다 : 예외 유형과 세부 사항을 포함하는 라인. 이것은 일반적으로 역 추적의 마지막 행이지만 예외에 여러 행 세부 사항이있는 경우 여러 행으로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b1db494b134e9c8220a976eba1115a13e23b7c" translate="yes" xml:space="preserve">
          <source>The tracemalloc module is a debug tool to trace memory blocks allocated by Python. It provides the following information:</source>
          <target state="translated">tracemalloc 모듈은 Python이 할당 한 메모리 블록을 추적하는 디버그 도구입니다. 다음 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="31a9ce8a876ac0217c1463774c12a24481761b30" translate="yes" xml:space="preserve">
          <source>The traditional method with a 2 character salt and 13 characters of hash. This is the weakest method.</source>
          <target state="translated">2 자 소금과 13 자 해시를 사용하는 전통적인 방법입니다. 이것이 가장 약한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="16acab894e31876506303b91db879f68d418dbb4" translate="yes" xml:space="preserve">
          <source>The transport classes are &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;not thread safe&lt;/a&gt;.</source>
          <target state="translated">전송 클래스는 &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d4addb81580c66d88e12e490015db638f34f42" translate="yes" xml:space="preserve">
          <source>The tree area.</source>
          <target state="translated">트리 영역.</target>
        </trans-unit>
        <trans-unit id="63c5e92c4fd607dfc132dae25b1bde5801ce3c8a" translate="yes" xml:space="preserve">
          <source>The tree column has ID #0.</source>
          <target state="translated">트리 열의 ID는 # 0입니다.</target>
        </trans-unit>
        <trans-unit id="a7f4322c232ab22c451a4f904178e963f0c2b60b" translate="yes" xml:space="preserve">
          <source>The true value of the &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; type. Assignments to &lt;code&gt;True&lt;/code&gt; are illegal and raise a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형 의 실제 값입니다 . &lt;code&gt;True&lt;/code&gt; 에 대한 할당 은 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 않으며 SyntaxError를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f1385bf813f5ebaee50787de55cade7aa2ad93e9" translate="yes" xml:space="preserve">
          <source>The tuple of arguments given to the exception constructor. Some built-in exceptions (like &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;) expect a certain number of arguments and assign a special meaning to the elements of this tuple, while others are usually called only with a single string giving an error message.</source>
          <target state="translated">예외 생성자에 제공된 인수의 튜플. &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 와 같은 일부 내장 예외 는 특정 수의 인수를 예상하고이 튜플의 요소에 특별한 의미를 지정하는 반면, 다른 예외 는 일반적으로 오류 메시지를 제공하는 단일 문자열로만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="539f38dbbfed03502ac81a27a897e9fba44d57ad" translate="yes" xml:space="preserve">
          <source>The tuple of arguments merged into &lt;code&gt;msg&lt;/code&gt; to produce &lt;code&gt;message&lt;/code&gt;, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).</source>
          <target state="translated">인수의 튜플은 &lt;code&gt;msg&lt;/code&gt; 로 병합되어 &lt;code&gt;message&lt;/code&gt; 를 생성 하거나 병합에 사용되는 값을 갖는 dict (한 개의 인수 만 있고 사전 인 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="a56707db067b73f69f1d7eabd20ac87c56e218eb" translate="yes" xml:space="preserve">
          <source>The tuple of base classes of a class object.</source>
          <target state="translated">클래스 객체의 기본 클래스 튜플.</target>
        </trans-unit>
        <trans-unit id="39d9df05b4cf019ab0db7e17a8ec1ef2c24c1ad6" translate="yes" xml:space="preserve">
          <source>The turtle module provides turtle graphics primitives, in both object-oriented and procedure-oriented ways. Because it uses &lt;a href=&quot;tkinter#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; for the underlying graphics, it needs a version of Python installed with Tk support.</source>
          <target state="translated">turtle 모듈은 객체 지향 및 절차 지향 방식으로 거북이 그래픽 프리미티브를 제공합니다. 기본 그래픽에 &lt;a href=&quot;tkinter#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 를 사용하기 때문에 Tk 지원과 함께 설치된 Python 버전이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a905845d53cd321a94fdd9df15627053d06b84e2" translate="yes" xml:space="preserve">
          <source>The two connection objects returned by &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe()&lt;/code&gt;&lt;/a&gt; represent the two ends of the pipe. Each connection object has &lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt; methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the &lt;em&gt;same&lt;/em&gt; end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 두 개의 연결 오브젝트는 파이프 의 두 끝을 나타냅니다. 각 연결 개체에는 &lt;code&gt;send()&lt;/code&gt; 및 &lt;code&gt;recv()&lt;/code&gt; 메서드가 있습니다. 두 프로세스 (또는 스레드)가 &lt;em&gt;동시에&lt;/em&gt; 파이프 의 &lt;em&gt;동일한&lt;/em&gt; 끝 에서 읽거나 쓰려고하면 파이프의 데이터가 손상 될 수 있습니다 . 물론 파이프의 다른 끝을 동시에 사용하는 공정으로 인한 손상의 위험은 없습니다.</target>
        </trans-unit>
        <trans-unit id="33638c8f9ee12ee7ff74956b792e2571ed375108" translate="yes" xml:space="preserve">
          <source>The two equality methods, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt;, are special. They do the default equality comparison on identity, using the &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; attribute, unless you change their return value to return something else:</source>
          <target state="translated">두 개의 등식 메소드 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt; &lt;code&gt;__ne__()&lt;/code&gt; &lt;/a&gt; 은 특별합니다. 반환 값을 변경하여 다른 것을 반환하지 않는 한 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 동일성에 대한 기본 동등성을 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="272ded31de2db6b1c275e8c03cf46f61287b0fca" translate="yes" xml:space="preserve">
          <source>The two following opening hooks are provided by this module:</source>
          <target state="translated">이 모듈에는 다음과 같은 두 개의 개방 고리가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="aead13a3bf658785dba6c96c3877cce7bfdcf9ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;DOMString&lt;/code&gt; maps to Python strings. &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt; supports either bytes or strings, but will normally produce strings. Values of type &lt;code&gt;DOMString&lt;/code&gt; may also be &lt;code&gt;None&lt;/code&gt; where allowed to have the IDL &lt;code&gt;null&lt;/code&gt; value by the DOM specification from the W3C.</source>
          <target state="translated">&lt;code&gt;DOMString&lt;/code&gt; 유형 은 Python 문자열에 맵핑됩니다. &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 은 바이트 또는 문자열을 지원하지만 일반적으로 문자열을 생성합니다. &lt;code&gt;DOMString&lt;/code&gt; 유형의 값은 W3C의 DOM 스펙에 의해 IDL &lt;code&gt;null&lt;/code&gt; 값 을 가질 수 있는 경우 &lt;code&gt;None&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c595e9e60344120fd8650e635fb09cc7f554fb8e" translate="yes" xml:space="preserve">
          <source>The type for cell objects: such objects are used as containers for a function&amp;rsquo;s free variables.</source>
          <target state="translated">셀 객체의 유형 : 이러한 객체는 함수의 자유 변수에 대한 컨테이너로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71d15bb94ba8cba5ce52cb311ed2945413c1e6a5" translate="yes" xml:space="preserve">
          <source>The type for code objects such as returned by &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 반환 한 것과 같은 코드 객체의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="92c00f883941b35d8d88ec760276dd05ae566ab3" translate="yes" xml:space="preserve">
          <source>The type info for introspection can be accessed via &lt;code&gt;Point2D.__annotations__&lt;/code&gt; and &lt;code&gt;Point2D.__total__&lt;/code&gt;. To allow using this feature with older versions of Python that do not support &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;TypedDict&lt;/code&gt; supports two additional equivalent syntactic forms:</source>
          <target state="translated">검사에 대한 유형 정보는 &lt;code&gt;Point2D.__annotations__&lt;/code&gt; 및 &lt;code&gt;Point2D.__total__&lt;/code&gt; 통해 액세스 할 수 있습니다 . 지원하지 않는 파이썬의 이전 버전에이 기능을 사용할 수 있도록하려면 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP (526)&lt;/strong&gt;&lt;/a&gt; , &lt;code&gt;TypedDict&lt;/code&gt; 의 지원이 개 추가 상응하는 구문 형태 :</target>
        </trans-unit>
        <trans-unit id="bd18bd83b257d2f4e8efd82d8c82ff0e7639a2fe" translate="yes" xml:space="preserve">
          <source>The type is roughly equivalent to the following code:</source>
          <target state="translated">형식은 다음 코드와 대략 동일합니다.</target>
        </trans-unit>
        <trans-unit id="207228c87acec3636f2d576ab4dc507cd348293d" translate="yes" xml:space="preserve">
          <source>The type object for proxies of callable objects.</source>
          <target state="translated">호출 가능한 객체의 프록시에 대한 유형 객체입니다.</target>
        </trans-unit>
        <trans-unit id="e2b65c714818fb9af6dfc2060e17b6ec9e44a466" translate="yes" xml:space="preserve">
          <source>The type object for proxies of objects which are not callable.</source>
          <target state="translated">호출 할 수없는 객체의 프록시에 대한 유형 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2f87adab9b428d0dbbf82d7c97420fce2530fdb4" translate="yes" xml:space="preserve">
          <source>The type object for weak references objects.</source>
          <target state="translated">약한 참조 객체의 유형 객체입니다.</target>
        </trans-unit>
        <trans-unit id="aa5558fddf17c823ad3cef9043343cc8848a5e60" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;asynchronous generator&lt;/a&gt;-iterator objects, created by asynchronous generator functions.</source>
          <target state="translated">비동기 생성기 함수에 의해 작성된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;비동기 생성기-&lt;/a&gt; 반복자 오브젝트 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="fb3f39049fd95688f70b6d2f5803012a23c782f4" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; objects, created by &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 함수로 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 객체 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="c085b6d1256e66aba3e73f22eb8afbb70e8ef9d0" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; returned by the &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function depends on the mode. When &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; is used to open a file in a text mode (&lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, &lt;code&gt;'rt'&lt;/code&gt;, etc.), it returns a subclass of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt; (specifically &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;). When used to open a file in a binary mode with buffering, the returned class is a subclass of &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt;. The exact class varies: in read binary mode, it returns an &lt;a href=&quot;io#io.BufferedReader&quot;&gt;&lt;code&gt;io.BufferedReader&lt;/code&gt;&lt;/a&gt;; in write binary and append binary modes, it returns an &lt;a href=&quot;io#io.BufferedWriter&quot;&gt;&lt;code&gt;io.BufferedWriter&lt;/code&gt;&lt;/a&gt;, and in read/write mode, it returns an &lt;a href=&quot;io#io.BufferedRandom&quot;&gt;&lt;code&gt;io.BufferedRandom&lt;/code&gt;&lt;/a&gt;. When buffering is disabled, the raw stream, a subclass of &lt;a href=&quot;io#io.RawIOBase&quot;&gt;&lt;code&gt;io.RawIOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수가 반환 한 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 의 유형은 모드에 따라 다릅니다. 때 &lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 텍스트 모드에서 파일을 여는 데 사용됩니다 ( &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'wt'&lt;/code&gt; , &lt;code&gt;'rt'&lt;/code&gt; 등), 그것의 서브 리턴 &lt;a href=&quot;io#io.TextIOBase&quot;&gt; &lt;code&gt;io.TextIOBase&lt;/code&gt; &lt;/a&gt; (구체적 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 을&lt;/a&gt; ). 버퍼링을 사용하여 파일을 이진 모드로 여는 데 사용되는 경우 반환되는 클래스는 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . 정확한 클래스는 다음과 같습니다. 읽기 이진 모드에서는 &lt;a href=&quot;io#io.BufferedReader&quot;&gt; &lt;code&gt;io.BufferedReader&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 이진 쓰기 및 이진 추가 모드에서는 &lt;a href=&quot;io#io.BufferedWriter&quot;&gt; &lt;code&gt;io.BufferedWriter&lt;/code&gt; 를&lt;/a&gt; 반환하고 읽기 / 쓰기 모드에서는&lt;a href=&quot;io#io.BufferedRandom&quot;&gt; &lt;code&gt;io.BufferedRandom&lt;/code&gt; &lt;/a&gt; . 버퍼링이 비활성화 된 경우, 원료 스트림의 서브 클래스&lt;a href=&quot;io#io.RawIOBase&quot;&gt; &lt;code&gt;io.RawIOBase&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;io#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; 가&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9137c1f6ce5bd7c384224288ce23eb4e33c57845" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;-iterator objects, created by generator functions.</source>
          <target state="translated">의 타입 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 생성 기능에 의해 생성 -iterator 개체.</target>
        </trans-unit>
        <trans-unit id="51c3737cac091c710a9cdbbb1a2fd03113a51fe7" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module&quot;&gt;modules&lt;/a&gt;. Constructor takes the name of the module to be created and optionally its &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module&quot;&gt;모듈&lt;/a&gt; 유형 . 생성자는 만들 모듈의 이름과 선택적으로 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring을 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="851dfab6c777918e2e97801375bfa3600e1be478" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;self.request&lt;/code&gt; is different for datagram or stream services. For stream services, &lt;code&gt;self.request&lt;/code&gt; is a socket object; for datagram services, &lt;code&gt;self.request&lt;/code&gt; is a pair of string and socket.</source>
          <target state="translated">&lt;code&gt;self.request&lt;/code&gt; 의 유형은 데이터 그램 또는 스트림 서비스에 따라 다릅니다. 스트림 서비스의 경우 &lt;code&gt;self.request&lt;/code&gt; 는 소켓 객체입니다. 데이터 그램 서비스의 경우 &lt;code&gt;self.request&lt;/code&gt; 는 문자열과 소켓 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="39ace067e7b8a07177cd07450cb98fd890c32fb2" translate="yes" xml:space="preserve">
          <source>The type of &lt;em&gt;bound&lt;/em&gt; methods of some built-in data types and base classes. For example it is the type of &lt;code&gt;object().__str__&lt;/code&gt;.</source>
          <target state="translated">일부 내장 데이터 유형 및 기본 클래스 의 &lt;em&gt;바인딩 된&lt;/em&gt; 메소드 유형입니다 . 예를 들어, 이것은 &lt;code&gt;object().__str__&lt;/code&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="054ec7ace9d8f1f81933bf82d68367c2b78aad15" translate="yes" xml:space="preserve">
          <source>The type of &lt;em&gt;unbound&lt;/em&gt; class methods of some built-in data types such as &lt;code&gt;dict.__dict__['fromkeys']&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dict.__dict__['fromkeys']&lt;/code&gt; 와 같은 일부 내장 데이터 유형 의 &lt;em&gt;언 바운드&lt;/em&gt; 클래스 메소드 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="edc6b284de88d85c6dcdc7c5fb2de19cafa4c532" translate="yes" xml:space="preserve">
          <source>The type of built-in functions like &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt;, and methods of built-in classes. (Here, the term &amp;ldquo;built-in&amp;rdquo; means &amp;ldquo;written in C&amp;rdquo;.)</source>
          <target state="translated">&lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 와 같은 내장 함수의 유형 및 내장 클래스의 메소드. 여기서 &quot;내장&quot;이라는 용어는 &quot;C로 작성 됨&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e7a3e7e227b15d7de2c5d33d406e0fdb0848b0ef" translate="yes" xml:space="preserve">
          <source>The type of encoding (base64 or quoted-printable) will be based on the &lt;em&gt;body_encoding&lt;/em&gt; attribute.</source>
          <target state="translated">인코딩 유형 (base64 또는 quoted-printable)은 &lt;em&gt;body_encoding&lt;/em&gt; 속성을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="daa919876c8026bbd456f4980d7d66ce3c1e4e34" translate="yes" xml:space="preserve">
          <source>The type of encoding (base64 or quoted-printable) will be based on the &lt;em&gt;header_encoding&lt;/em&gt; attribute.</source>
          <target state="translated">인코딩 유형 (base64 또는 quoted-printable)은 &lt;em&gt;header_encoding&lt;/em&gt; 속성을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="5f3fdc1f795bc115fa25d9a7ee9f014076d623a1" translate="yes" xml:space="preserve">
          <source>The type of file objects supported depends on the platform: on Windows, sockets are supported, but not pipes, whereas on Unix, both are supported (some other types may be supported as well, such as fifos or special file devices).</source>
          <target state="translated">지원되는 파일 객체의 유형은 플랫폼에 따라 다릅니다. Windows에서는 소켓이 지원되지만 파이프는 지원되지 않지만 Unix에서는 둘 다 지원됩니다 (fifo 또는 특수 파일 장치와 같은 다른 유형도 지원 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="3596a6e3c65ed88cc1d8e8b7d814d3dabfd3476a" translate="yes" xml:space="preserve">
          <source>The type of frame objects such as found in &lt;code&gt;tb.tb_frame&lt;/code&gt; if &lt;code&gt;tb&lt;/code&gt; is a traceback object.</source>
          <target state="translated">와 같은 프레임 객체의 유형 &lt;code&gt;tb.tb_frame&lt;/code&gt; &lt;code&gt;tb&lt;/code&gt; 가 트레이스 백 객체 인 경우 tb.tb_frame에 있는 .</target>
        </trans-unit>
        <trans-unit id="75460e66c894ac26297c70dd2c59bf341c1ac5d4" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types and base classes such as &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;object.__init__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;object.__lt__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내장 데이터 유형 및 기본 클래스 (예 : &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;object.__init__()&lt;/code&gt; &lt;/a&gt; 의 메소드 유형 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;object.__lt__()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="802b8bb24f2cee63ab7e9a26db85ba1e69bde6fb" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types such as &lt;a href=&quot;stdtypes#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt; 과 같은 일부 내장 데이터 유형의 메소드 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3d0fea4bd572efbc49d1a1be2c36df840b937e1d" translate="yes" xml:space="preserve">
          <source>The type of methods of user-defined class instances.</source>
          <target state="translated">사용자 정의 클래스 인스턴스의 메소드 유형</target>
        </trans-unit>
        <trans-unit id="d85b5663cf70afd56961d534baa36aa27fa3f1e2" translate="yes" xml:space="preserve">
          <source>The type of objects defined in extension modules with &lt;code&gt;PyGetSetDef&lt;/code&gt;, such as &lt;code&gt;FrameType.f_locals&lt;/code&gt; or &lt;code&gt;array.array.typecode&lt;/code&gt;. This type is used as descriptor for object attributes; it has the same purpose as the &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; type, but for classes defined in extension modules.</source>
          <target state="translated">&lt;code&gt;FrameType.f_locals&lt;/code&gt; 또는 &lt;code&gt;array.array.typecode&lt;/code&gt; 와 같이 &lt;code&gt;PyGetSetDef&lt;/code&gt; 를 사용 하여 확장 모듈에 정의 된 객체 유형입니다 . 이 유형은 객체 속성에 대한 설명 자로 사용됩니다. 그것은 같은 목적을 가지고&lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 유형갖지만 확장 모듈에 정의 된 클래스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65d9791079f3a5f0479b8fc1fe7de9de776be32e" translate="yes" xml:space="preserve">
          <source>The type of objects defined in extension modules with &lt;code&gt;PyMemberDef&lt;/code&gt;, such as &lt;code&gt;datetime.timedelta.days&lt;/code&gt;. This type is used as descriptor for simple C data members which use standard conversion functions; it has the same purpose as the &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; type, but for classes defined in extension modules.</source>
          <target state="translated">함께 확장 모듈에 정의 된 오브젝트의 유형 &lt;code&gt;PyMemberDef&lt;/code&gt; 같은, &lt;code&gt;datetime.timedelta.days&lt;/code&gt; . 이 유형은 표준 변환 함수를 사용하는 간단한 C 데이터 멤버의 설명 자로 사용됩니다. &lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 유형 과 동일한 목적을 갖지만 확장 모듈에 정의 된 클래스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af9c2c83b8c60dabd2c034b33bbb7fdb10e6d512" translate="yes" xml:space="preserve">
          <source>The type of socket used by the server; &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;socket.SOCK_STREAM&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt;&lt;/a&gt; are two common values.</source>
          <target state="translated">서버가 사용하는 소켓의 유형. &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;socket.SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt; &lt;/a&gt; 은 두 가지 공통 값입니다.</target>
        </trans-unit>
        <trans-unit id="be204b93125e9374a47e9c0607ad154bb8bb9d7d" translate="yes" xml:space="preserve">
          <source>The type of the connection is determined by &lt;em&gt;family&lt;/em&gt; argument, but this can generally be omitted since it can usually be inferred from the format of &lt;em&gt;address&lt;/em&gt;. (See &lt;a href=&quot;#multiprocessing-address-formats&quot;&gt;Address Formats&lt;/a&gt;)</source>
          <target state="translated">연결 유형은 &lt;em&gt;family&lt;/em&gt; 인수에 의해 결정 되지만 일반적으로 &lt;em&gt;address&lt;/em&gt; 형식에서 유추 할 수 있으므로 일반적으로 생략 할 수 있습니다 . (보다&lt;a href=&quot;#multiprocessing-address-formats&quot;&gt; 주소 형식&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="bd30a5963bbcf91e157911dfc75bf91da7146bda" translate="yes" xml:space="preserve">
          <source>The type of the objects returned by &lt;a href=&quot;#parser.expr&quot;&gt;&lt;code&gt;expr()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parser.suite&quot;&gt;&lt;code&gt;suite()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parser.sequence2st&quot;&gt;&lt;code&gt;sequence2st()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#parser.expr&quot;&gt; &lt;code&gt;expr()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#parser.suite&quot;&gt; &lt;code&gt;suite()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#parser.sequence2st&quot;&gt; &lt;code&gt;sequence2st()&lt;/code&gt; &lt;/a&gt; 반환 한 객체의 유형 .</target>
        </trans-unit>
        <trans-unit id="2415aa71d53e852131b074eb25a6c6db74a53fb6" translate="yes" xml:space="preserve">
          <source>The type of the return values from the &lt;a href=&quot;#xml.parsers.expat.ParserCreate&quot;&gt;&lt;code&gt;ParserCreate()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.ParserCreate&quot;&gt; &lt;code&gt;ParserCreate()&lt;/code&gt; &lt;/a&gt; 의 반환 값 유형 함수 .</target>
        </trans-unit>
        <trans-unit id="f1e00a1edd876419fe2ebe3767b0aed891735220" translate="yes" xml:space="preserve">
          <source>The type of the time value sequence returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;. It is an object with a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; interface: values can be accessed by index and by attribute name. The following values are present:</source>
          <target state="translated">&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 반환 한 시간 값 시퀀스의 유형입니다 . &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플&lt;/a&gt; 인터페이스 가있는 객체입니다. 색인과 속성 이름으로 값에 액세스 할 수 있습니다. 다음과 같은 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17a09ba982dc1f24bfd7bfea4ab6a3ce49113c82" translate="yes" xml:space="preserve">
          <source>The type of traceback objects such as found in &lt;code&gt;sys.exc_info()[2]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sys.exc_info()[2]&lt;/code&gt; 있는 것과 같은 추적 오브젝트의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="14fb1882a83121d6512420b73ddf7c6df4b29e08" translate="yes" xml:space="preserve">
          <source>The type of user-defined functions and functions created by &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#lambda&quot;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#lambda&quot;&gt; &lt;code&gt;lambda&lt;/code&gt; &lt;/a&gt; 식으로 작성된 사용자 정의 함수 및 함수의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="845e42910aebf464f039df10da42d715e332ff1d" translate="yes" xml:space="preserve">
          <source>The type system of the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module is extensible in two ways: you can store additional Python types in a SQLite database via object adaptation, and you can let the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module convert SQLite types to different Python types via converters.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈 의 타입 시스템은 두 가지 방법으로 확장 할 수 있습니다. 객체 적응을 통해 추가 Python 유형을 SQLite 데이터베이스에 저장하고 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈이 변환기를 통해 SQLite 유형을 다른 Python 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a6af98017fdeff071bf353e1479e07931b4d2f" translate="yes" xml:space="preserve">
          <source>The typecode character used to create the array.</source>
          <target state="translated">배열을 만드는 데 사용되는 형식 코드 문자</target>
        </trans-unit>
        <trans-unit id="0c959abb200e6f216cd6c46680afae3d3493423d" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;short int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, and &lt;code&gt;boolean&lt;/code&gt; all map to Python integer objects.</source>
          <target state="translated">유형 &lt;code&gt;short int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; 및 &lt;code&gt;boolean&lt;/code&gt; 파이썬 정수 객체에 대한 모든지도.</target>
        </trans-unit>
        <trans-unit id="4d560d8f900eca6af7a86605d169b14ce3732718" translate="yes" xml:space="preserve">
          <source>The typical programming style using condition variables uses the lock to synchronize access to some shared state; threads that are interested in a particular change of state call &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; repeatedly until they see the desired state, while threads that modify the state call &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; when they change the state in such a way that it could possibly be a desired state for one of the waiters. For example, the following code is a generic producer-consumer situation with unlimited buffer capacity:</source>
          <target state="translated">조건 변수를 사용하는 일반적인 프로그래밍 스타일은 잠금을 사용하여 일부 공유 상태에 대한 액세스를 동기화합니다. 국가 통화의 특정 변화에 관심이있는 스레드 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 그들이 원하는 상태를 볼 때까지 반복, 상태 호출을 수정 스레드가 동시에 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 그들은 같은 방법으로 상태를 변경하는 때 가능성이 될 수 있다고 웨이터 중 하나에 대한 원하는 상태. 예를 들어 다음 코드는 버퍼 용량이 무제한 인 일반적인 생산자 소비자 상황입니다.</target>
        </trans-unit>
        <trans-unit id="6cce4ca16ef59a2c9a6e26b00995455dbe5b43db" translate="yes" xml:space="preserve">
          <source>The typical usage to break into the debugger from a running program is to insert</source>
          <target state="translated">실행중인 프로그램에서 디버거에 침입하는 일반적인 사용법은 삽입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="312b8c5e06e9b508c2dc3394df6f8c328dcdd28f" translate="yes" xml:space="preserve">
          <source>The typical usage to inspect a crashed program is:</source>
          <target state="translated">충돌 한 프로그램을 검사하는 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19aaa16d46a9088205f8b111d28555cd6514b9f9" translate="yes" xml:space="preserve">
          <source>The typical use is:</source>
          <target state="translated">일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f88d8816221987271260ee8ea49f5b5d7cf3e10" translate="yes" xml:space="preserve">
          <source>The uid and gid items are integers, all others are strings. &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised if the entry asked for cannot be found.</source>
          <target state="translated">uid 및 gid 항목은 정수이고 다른 항목은 모두 문자열입니다. 요청한 항목을 찾을 수 없으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f5c1273b1d4b80fefb18a2d5748785e0ad812ac" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;sqlite3&lt;/code&gt; library operates in &lt;code&gt;autocommit&lt;/code&gt; mode by default, but the Python &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module by default does not.</source>
          <target state="translated">기본 &lt;code&gt;sqlite3&lt;/code&gt; 라이브러리는 기본적으로 &lt;code&gt;autocommit&lt;/code&gt; 모드 에서 작동 하지만 기본적으로 Python &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="692c81225394c94ff32b84438ec4aa9ac22b33ab" translate="yes" xml:space="preserve">
          <source>The underlying Readline library API may be implemented by the &lt;code&gt;libedit&lt;/code&gt; library instead of GNU readline. On macOS the &lt;a href=&quot;#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module detects which library is being used at run time.</source>
          <target state="translated">기본 Readline 라이브러리 API는 GNU readline 대신 &lt;code&gt;libedit&lt;/code&gt; 라이브러리 로 구현 될 수 있습니다 . macOS에서 &lt;a href=&quot;#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈은 런타임에 사용중인 라이브러리를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="cbd3a217e06ecf1e9ba395c9d3b83ea44a75be37" translate="yes" xml:space="preserve">
          <source>The underlying binary buffer (a &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; instance) that &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt; deals with. This is not part of the &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt; API and may not exist in some implementations.</source>
          <target state="translated">&lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; 가&lt;/a&gt; 처리 하는 기본 이진 버퍼 ( &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; 인스턴스) 이것은 &lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; 의&lt;/a&gt; 일부가 아닙니다 API의 일부 구현에는 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c099cf6d6c9538690a044409fa62678eb6541891" translate="yes" xml:space="preserve">
          <source>The underlying mappings are stored in a list. That list is public and can be accessed or updated using the &lt;em&gt;maps&lt;/em&gt; attribute. There is no other state.</source>
          <target state="translated">기본 매핑은 목록에 저장됩니다. 이 목록은 공개이며 &lt;em&gt;maps&lt;/em&gt; 속성을 사용하여 액세스하거나 업데이트 할 수 있습니다 . 다른 상태는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8ed57a843f0b2c56ec32e93f7034f9d564cc770" translate="yes" xml:space="preserve">
          <source>The underlying object of the memoryview:</source>
          <target state="translated">memoryview의 기본 객체 :</target>
        </trans-unit>
        <trans-unit id="74ffc7561de47c1ca7be4db22d58088aa8da9469" translate="yes" xml:space="preserve">
          <source>The underlying process creation and management in this module is handled by the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; class. It offers a lot of flexibility so that developers are able to handle the less common cases not covered by the convenience functions.</source>
          <target state="translated">이 모듈의 기본 프로세스 생성 및 관리는 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 클래스에서. 개발자가 편의 기능으로 다루지 않는 덜 일반적인 경우를 처리 할 수 ​​있도록 유연성이 매우 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="ba3e655d8ac47240c2d2f5980db91a3ca2ecc86b" translate="yes" xml:space="preserve">
          <source>The underlying raw stream (a &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; instance) that &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; deals with. This is not part of the &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; API and may not exist on some implementations.</source>
          <target state="translated">&lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; 가 수행&lt;/a&gt; 하는 기본 원시 스트림 ( &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 인스턴스) 처리이것은 &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; 의&lt;/a&gt; 일부가 아닙니다 API의 일부 구현에는 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1573d571c13d16324a3c741bed96fa34d92b283" translate="yes" xml:space="preserve">
          <source>The unformatted error message.</source>
          <target state="translated">형식화되지 않은 오류 메시지</target>
        </trans-unit>
        <trans-unit id="05f3ae582f0c0636a61039860a85ef0508aa13e0" translate="yes" xml:space="preserve">
          <source>The unittest module can be used from the command line to run tests from modules, classes or even individual test methods:</source>
          <target state="translated">명령 행에서 unittest 모듈을 사용하여 모듈, 클래스 또는 개별 테스트 방법에서 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dde9ab65dc4b9f7975e19a23a1127cf92b2b035" translate="yes" xml:space="preserve">
          <source>The uppercase letters &lt;code&gt;'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt;. This value is not locale-dependent and will not change.</source>
          <target state="translated">대문자 &lt;code&gt;'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt; 입니다. 이 값은 로캘에 따라 다르지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0854cdf9ca6554793143fab76b0e342cda85438d" translate="yes" xml:space="preserve">
          <source>The uppercasing algorithm used is described in section 3.13 of the Unicode Standard.</source>
          <target state="translated">사용 된 대문자 알고리즘은 유니 코드 표준의 3.13 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9b9af9c2a1fd50996417214bffd38cd04caabd4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;%Z&lt;/code&gt; is now deprecated, but the &lt;code&gt;%z&lt;/code&gt; escape that expands to the preferred hour/minute offset is not supported by all ANSI C libraries. Also, a strict reading of the original 1982 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; standard calls for a two-digit year (%y rather than %Y), but practice moved to 4-digit years long before the year 2000. After that, &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; became obsolete and the 4-digit year has been first recommended by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 1123&lt;/strong&gt;&lt;/a&gt; and then mandated by &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%Z&lt;/code&gt; 사용은 더 이상 사용되지 않지만 원하는 시간 / 분 오프셋으로 확장 되는 &lt;code&gt;%z&lt;/code&gt; 이스케이프가 모든 ANSI C 라이브러리에서 지원되는 것은 아닙니다. 또한, 엄격한 원래 1982 년 독서 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; 두 자리 연도의 표준 호출 (% y를 오히려 % Y에 비해), 그러나 실제로는 그 후 2000 년 전에 4 자리 연도 긴 이동, &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 822은&lt;/strong&gt;&lt;/a&gt; 폐기되었고, 4 자리 연도는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 1123에&lt;/strong&gt;&lt;/a&gt; 의해 처음 추천 된 후 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 에 의해 위임되었습니다 .</target>
        </trans-unit>
        <trans-unit id="818e1de1ee279a3d12fd00fd42609c4b0aa39222" translate="yes" xml:space="preserve">
          <source>The use of a &lt;code&gt;CDATASection&lt;/code&gt; node does not indicate that the node represents a complete CDATA marked section, only that the content of the node was part of a CDATA section. A single CDATA section may be represented by more than one node in the document tree. There is no way to determine whether two adjacent &lt;code&gt;CDATASection&lt;/code&gt; nodes represent different CDATA marked sections.</source>
          <target state="translated">&lt;code&gt;CDATASection&lt;/code&gt; 노드를 사용 한다고해서 노드가 완전한 CDATA 표시 섹션을 나타내는 것은 아니며 노드의 컨텐츠가 CDATA 섹션의 일부일뿐입니다. 단일 CDATA 섹션은 문서 트리에서 둘 이상의 노드로 표시 될 수 있습니다. 인접한 두 &lt;code&gt;CDATASection&lt;/code&gt; 노드가 서로 다른 CDATA 표시 섹션을 나타내는 지 여부를 확인할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e59fb5d1424421341c7c08cd960ce1c43d8cae74" translate="yes" xml:space="preserve">
          <source>The use of a bounded semaphore reduces the chance that a programming error which causes the semaphore to be released more than it&amp;rsquo;s acquired will go undetected.</source>
          <target state="translated">제한된 세마포어를 사용하면 세마포어가 획득 한 것보다 더 많이 해제되는 프로그래밍 오류가 감지되지 않을 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="503e039e7a7945e22e53e684cd41c8ddeb2296c8" translate="yes" xml:space="preserve">
          <source>The use of decimal floating point eliminates decimal representation error (making it possible to represent &lt;code&gt;0.1&lt;/code&gt; exactly); however, some operations can still incur round-off error when non-zero digits exceed the fixed precision.</source>
          <target state="translated">10 진수 부동 소수점을 사용하면 10 진수 표현 오류가 제거됩니다 ( &lt;code&gt;0.1&lt;/code&gt; 을 정확하게 나타낼 수 있음). 그러나 0이 아닌 숫자가 고정 정밀도를 초과하면 일부 연산에서 여전히 반올림 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef05d3a555addffe6383bb0c2ceb5c3b10ece3a4" translate="yes" xml:space="preserve">
          <source>The use of dynamic dispatching by &lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt;&lt;code&gt;Repr.repr1()&lt;/code&gt;&lt;/a&gt; allows subclasses of &lt;a href=&quot;#reprlib.Repr&quot;&gt;&lt;code&gt;Repr&lt;/code&gt;&lt;/a&gt; to add support for additional built-in object types or to modify the handling of types already supported. This example shows how special support for file objects could be added:</source>
          <target state="translated">&lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt; &lt;code&gt;Repr.repr1()&lt;/code&gt; &lt;/a&gt; 에서 동적 디스패치를 ​​사용 하면 &lt;a href=&quot;#reprlib.Repr&quot;&gt; &lt;code&gt;Repr&lt;/code&gt; 의&lt;/a&gt; 서브 클래스가 추가 내장 오브젝트 유형에 대한 지원을 추가하거나 이미 지원되는 유형의 처리를 수정할 수 있습니다. 이 예제는 파일 객체에 대한 특별한 지원을 추가하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52d05a35e93648db761f9430668b0f890705b58d" translate="yes" xml:space="preserve">
          <source>The useful mapping keys in a &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; are given in the section on &lt;a href=&quot;#logrecord-attributes&quot;&gt;LogRecord attributes&lt;/a&gt;.</source>
          <target state="translated">유용한 매핑 키 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#logrecord-attributes&quot;&gt; LogRecord 속성&lt;/a&gt; 섹션에있습니다.</target>
        </trans-unit>
        <trans-unit id="61191e6c79c749cd7aba4196b38f6b9a262afba8" translate="yes" xml:space="preserve">
          <source>The user does not instantiate a transport directly; they call a utility function, passing it a protocol factory and other information necessary to create the transport and protocol.</source>
          <target state="translated">사용자는 전송을 직접 인스턴스화하지 않습니다. 그들은 유틸리티 기능을 호출하여 프로토콜 팩토리와 전송 및 프로토콜을 작성하는 데 필요한 기타 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="799492a2bc4f8c18e914c5fd6750e59de66fb8b8" translate="yes" xml:space="preserve">
          <source>The user of &lt;a href=&quot;#tempfile.mkdtemp&quot;&gt;&lt;code&gt;mkdtemp()&lt;/code&gt;&lt;/a&gt; is responsible for deleting the temporary directory and its contents when done with it.</source>
          <target state="translated">의 사용자 &lt;a href=&quot;#tempfile.mkdtemp&quot;&gt; &lt;code&gt;mkdtemp()&lt;/code&gt; &lt;/a&gt;임시 디렉토리와 디렉토리 디렉토리의 내용을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee129ab0f90820dc953cf701d4d07af6a6196607" translate="yes" xml:space="preserve">
          <source>The user-provided request handler class; an instance of this class is created for each request.</source>
          <target state="translated">사용자 제공 요청 핸들러 클래스. 이 클래스의 인스턴스는 각 요청마다 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="72b7902f1383f94a27baa827eb01bca89cc62cbc" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;queue#queue.Empty&quot;&gt;&lt;code&gt;queue.Empty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;queue#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; exceptions from the standard library&amp;rsquo;s &lt;a href=&quot;queue#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt; module are raised to signal timeouts.</source>
          <target state="translated">일반적인 &lt;a href=&quot;queue#queue.Empty&quot;&gt; &lt;code&gt;queue.Empty&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;queue#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt; 표준 라이브러리 대기열 의 &lt;a href=&quot;queue#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; &lt;/a&gt; 예외 모듈 가 발생하여 시간 초과를 .</target>
        </trans-unit>
        <trans-unit id="4fb214e67950bddad6409524a77147f01c797d75" translate="yes" xml:space="preserve">
          <source>The usual approach to working with decimals is to create &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instances and then apply arithmetic operations which take place within the current context for the active thread. An alternative approach is to use context methods for calculating within a specific context. The methods are similar to those for the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; class and are only briefly recounted here.</source>
          <target state="translated">소수 자릿수 작업에 대한 일반적인 접근 방식은 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스를 만든 다음 현재 스레드 내에서 활성 스레드에 대해 수행되는 산술 연산을 적용하는 것입니다. 다른 방법은 특정 컨텍스트 내에서 계산하기 위해 컨텍스트 메소드를 사용하는 것입니다. 방법은 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 과 유사합니다. 클래스 여기서 간단히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="7e0cd4e412d5835966f4133590beac72566aa7f2" translate="yes" xml:space="preserve">
          <source>The usual dictionary methods are available for &lt;a href=&quot;#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt; objects except for two which work differently for counters.</source>
          <target state="translated">&lt;a href=&quot;#collections.Counter&quot;&gt; &lt;code&gt;Counter&lt;/code&gt; &lt;/a&gt; 일반적인 사전 방법을 사용할 수 있습니다 대해 다르게 작동하는 두 가지를 제외하고 개체에 .</target>
        </trans-unit>
        <trans-unit id="fc3dad1947c78cee7834b38256f73aa158a2e66a" translate="yes" xml:space="preserve">
          <source>The usual fix is to either await the coroutine or call the &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">일반적인 수정은 코 루틴을 기다리거나 &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; 호출하는 것입니다. 함수를 .</target>
        </trans-unit>
        <trans-unit id="ab66de48e5569d8b04e6ed1de85c17b699cb8d3c" translate="yes" xml:space="preserve">
          <source>The usual restrictions for pickling apply: picklable enums must be defined in the top level of a module, since unpickling requires them to be importable from that module.</source>
          <target state="translated">피클 링에 대한 일반적인 제한 사항이 적용됩니다. 피클 링 가능 열거 형은 해당 모듈에서 가져올 수 있어야하므로 모듈의 최상위 레벨에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e12393a3161a5ffd9c52bf6911f34c236e2c9953" translate="yes" xml:space="preserve">
          <source>The usual start to using decimals is importing the module, viewing the current context with &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; and, if necessary, setting new values for precision, rounding, or enabled traps:</source>
          <target state="translated">십진수를 사용하는 일반적인 시작은 모듈을 가져오고 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 현재 컨텍스트를보고 필요한 경우 정밀도, 반올림 또는 사용 가능한 트랩에 대한 새 값을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2008881e3db430ce4e534a59aaba96d96406f254" translate="yes" xml:space="preserve">
          <source>The valid options/values are:</source>
          <target state="translated">유효한 옵션 / 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="833f8e1091d762b7c244ed494067360a08b6e65e" translate="yes" xml:space="preserve">
          <source>The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in base 16). &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;em&gt;i&lt;/em&gt; is outside that range.</source>
          <target state="translated">인수의 유효한 범위는 0-1,114,111입니다 (16 진의 0x10FFFF). &lt;em&gt;i&lt;/em&gt; 가 해당 범위를 벗어나 면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3f14b8f02287106623bf0b009141cb29a66c076" translate="yes" xml:space="preserve">
          <source>The value &lt;em&gt;n&lt;/em&gt; is an integer, or an object implementing &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt;. Zero and negative values of &lt;em&gt;n&lt;/em&gt; clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for &lt;code&gt;s * n&lt;/code&gt; under &lt;a href=&quot;#typesseq-common&quot;&gt;Common Sequence Operations&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 값 은 정수이거나 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; 구현하는 객체 입니다. &lt;em&gt;n의&lt;/em&gt; 0과 음수 값은 시퀀스를 지 웁니다. 시퀀스의 항목은 복사되지 않습니다. &lt;a href=&quot;#typesseq-common&quot;&gt;공통 시퀀스 연산&lt;/a&gt; 에서 &lt;code&gt;s * n&lt;/code&gt; 에 대해 설명 된대로 여러 번 참조 됩니다.</target>
        </trans-unit>
        <trans-unit id="9f91839dd752530537b6fc14cfb59cfb821e2678" translate="yes" xml:space="preserve">
          <source>The value conversion will use the &amp;ldquo;alternate form&amp;rdquo; (where defined below).</source>
          <target state="translated">값 변환은 &quot;대체 형식&quot;(아래 정의 된 경우)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dfd7f69b5373d9254a89d97b317bed89c36400a6" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;endpos&lt;/em&gt; which was passed to the &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;#re-objects&quot;&gt;regex object&lt;/a&gt;. This is the index into the string beyond which the RE engine will not go.</source>
          <target state="translated">&lt;a href=&quot;#re-objects&quot;&gt;정규식 객체&lt;/a&gt; 의 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 메소드에 전달 된 &lt;em&gt;endpos&lt;/em&gt; 의 값 . 이것은 RE 엔진이 가지 않을 문자열에 대한 색인입니다.</target>
        </trans-unit>
        <trans-unit id="4d524ce944ce6faac364cea7cad2143666016939" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;pos&lt;/em&gt; which was passed to the &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;#re-objects&quot;&gt;regex object&lt;/a&gt;. This is the index into the string at which the RE engine started looking for a match.</source>
          <target state="translated">&lt;a href=&quot;#re-objects&quot;&gt;정규식 객체&lt;/a&gt; 의 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 메소드에 전달 된 &lt;em&gt;pos&lt;/em&gt; 의 값 . 이것은 RE 엔진이 일치를 찾기 시작한 문자열의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="2e998dbaff3bb1395e14cf6d02ecba7f97ecf5de" translate="yes" xml:space="preserve">
          <source>The value of each item is either a string, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if not present.</source>
          <target state="translated">각 항목의 값은 문자열이거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 존재하지 않는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="894da0d8a1deaf4025187c213b697678d4d8eea2" translate="yes" xml:space="preserve">
          <source>The value of the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; reporting flags in effect before the function was called is returned by the function.</source>
          <target state="translated">&lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 의 가치함수가 호출되기 전에 유효한 보고 플래그 함수에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b6f6af5fd914e4e1977bd8812ad275e173d35e" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;start&lt;/em&gt; parameter (or &lt;code&gt;0&lt;/code&gt; if the parameter was not supplied)</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 매개 변수 의 값 (또는 &lt;code&gt;0&lt;/code&gt; 매개 변수가 제공되지 않은 경우 )</target>
        </trans-unit>
        <trans-unit id="9ee46e1de13205f2274d5b605d7f91d5eb44066d" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;step&lt;/em&gt; parameter (or &lt;code&gt;1&lt;/code&gt; if the parameter was not supplied)</source>
          <target state="translated">&lt;em&gt;단계&lt;/em&gt; 매개 변수 의 값 (또는 매개 변수가 제공되지 않은 경우 &lt;code&gt;1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3effb996f3fdf8925f1c3f71f6aef7653bb530e1" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;stop&lt;/em&gt; parameter</source>
          <target state="translated">&lt;em&gt;정지&lt;/em&gt; 매개 변수 의 값</target>
        </trans-unit>
        <trans-unit id="b6df41c014faa1a95a93823c98dc9147024275f4" translate="yes" xml:space="preserve">
          <source>The value of the cookie.</source>
          <target state="translated">쿠키의 가치.</target>
        </trans-unit>
        <trans-unit id="c946fe7e22930d8d97dd543837147d8b1bce64ca" translate="yes" xml:space="preserve">
          <source>The value of the registry item.</source>
          <target state="translated">레지스트리 항목의 값입니다.</target>
        </trans-unit>
        <trans-unit id="88e44b4995d1d06c008be0ccf6fee3422ea4e070" translate="yes" xml:space="preserve">
          <source>The value of this variable can be changed before calling &lt;a href=&quot;#xml.dom.pulldom.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; and the new value will take effect.</source>
          <target state="translated">이 변수의 값은 &lt;a href=&quot;#xml.dom.pulldom.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 변경 될 수 있으며 새 값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bde8c85afabd3e8125721b1ff7d5b17f9d9dee96" translate="yes" xml:space="preserve">
          <source>The value resulting from &lt;code&gt;Context.power(x, y, modulo)&lt;/code&gt; is equal to the value that would be obtained by computing &lt;code&gt;(x**y)
% modulo&lt;/code&gt; with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;modulo&lt;/code&gt;. The result is always exact.</source>
          <target state="translated">인한 값 &lt;code&gt;Context.power(x, y, modulo)&lt;/code&gt; 계산함으로써 획득 될 값과 동일하다 &lt;code&gt;(x**y) % modulo&lt;/code&gt; 바운드 정밀도를하지만, 더 효율적으로 계산된다. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;modulo&lt;/code&gt; 의 지수에 관계없이 결과 지수는 0입니다. 입니다. 결과는 항상 정확합니다.</target>
        </trans-unit>
        <trans-unit id="c59b0eb2c27f951fa0cace7c837f6202b755a295" translate="yes" xml:space="preserve">
          <source>The value returned is a named tuple of type &lt;a href=&quot;os#os.terminal_size&quot;&gt;&lt;code&gt;os.terminal_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 &lt;a href=&quot;os#os.terminal_size&quot;&gt; &lt;code&gt;os.terminal_size&lt;/code&gt; &lt;/a&gt; 유형의 명명 된 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="7bc5693e6a9c72e20f0575057dd4ee5bc74f98db" translate="yes" xml:space="preserve">
          <source>The value returned may be larger than the &lt;em&gt;item&lt;/em&gt; added. If that isn&amp;rsquo;t desired, consider using &lt;a href=&quot;#heapq.heappushpop&quot;&gt;&lt;code&gt;heappushpop()&lt;/code&gt;&lt;/a&gt; instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap.</source>
          <target state="translated">반환 된 값이 추가 된 &lt;em&gt;항목&lt;/em&gt; 보다 클 수 있습니다 . 원하지 않는 경우 &lt;a href=&quot;#heapq.heappushpop&quot;&gt; &lt;code&gt;heappushpop()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오. 푸시 / 팝 조합은 두 값 중 작은 값을 반환하여 힙에 큰 값을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="d795005d4b340675bfb305f1568f0d0d9ec61967" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.multiprocess&lt;/code&gt; environment variable. It defaults to true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but may have a different default (or be set by the constructor) in the other subclasses.</source>
          <target state="translated">&lt;code&gt;wsgi.multiprocess&lt;/code&gt; 환경 변수에 사용될 값 입니다. &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 에서 기본값은 true입니다 . 이지만 다른 서브 클래스에서 다른 기본값 (또는 생성자가 설정)을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90b6e14952af2c1c7e8dc26e1fb8bc2a1a91cdc" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.multithread&lt;/code&gt; environment variable. It defaults to true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but may have a different default (or be set by the constructor) in the other subclasses.</source>
          <target state="translated">&lt;code&gt;wsgi.multithread&lt;/code&gt; 환경 변수에 사용될 값 입니다. &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 의&lt;/a&gt; 기본값은 true 이지만 다른 서브 클래스에서 다른 기본값 (또는 생성자가 설정)을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16e4c0519d360e3b8f5f9b274c196a4c6f3d4db2" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.run_once&lt;/code&gt; environment variable. It defaults to false in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt; sets it to true by default.</source>
          <target state="translated">&lt;code&gt;wsgi.run_once&lt;/code&gt; 환경 변수에 사용될 값 입니다. &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 의&lt;/a&gt; 기본값은 false 이지만 &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; 는 기본적으로 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="78bd89035d6220ea534538c62645a0424951cebd" translate="yes" xml:space="preserve">
          <source>The value used to indicate that no namespace is associated with a node in the DOM. This is typically found as the &lt;code&gt;namespaceURI&lt;/code&gt; of a node, or used as the &lt;em&gt;namespaceURI&lt;/em&gt; parameter to a namespaces-specific method.</source>
          <target state="translated">네임 스페이스가 DOM의 노드와 연결되어 있지 않음을 나타내는 데 사용되는 값입니다. 이것은 일반적으로 노드 의 &lt;code&gt;namespaceURI&lt;/code&gt; 로 발견 되거나 &lt;em&gt;namespaceURI&lt;/em&gt; 로 사용됩니다.&lt;em&gt;&lt;/em&gt; 네임 특정 메소드 파라미터.</target>
        </trans-unit>
        <trans-unit id="64a84954e88a246f210c2cf21b6b1dd5abec1148" translate="yes" xml:space="preserve">
          <source>The values are chosen by &lt;code&gt;_generate_next_value_()&lt;/code&gt;, which can be overridden:</source>
          <target state="translated">값은 &lt;code&gt;_generate_next_value_()&lt;/code&gt; 에 의해 선택되며 이는 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9db8f1c845539b8dab56c95400b090e5768cb33d" translate="yes" xml:space="preserve">
          <source>The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then &lt;em&gt;literal_text&lt;/em&gt; will be a zero-length string. If there is no replacement field, then the values of &lt;em&gt;field_name&lt;/em&gt;, &lt;em&gt;format_spec&lt;/em&gt; and &lt;em&gt;conversion&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">튜플의 값은 개념적으로 리터럴 텍스트의 범위와 단일 대체 필드를 나타냅니다. 리터럴 텍스트가없는 경우 (두 개의 대체 필드가 ​​연속적으로 발생하는 경우 발생할 수 있음) &lt;em&gt;literal_text&lt;/em&gt; 는 길이가 0 인 문자열입니다. 대체 필드의 다음 값이없는 경우 &lt;em&gt;FIELD_NAME&lt;/em&gt; , &lt;em&gt;format_spec&lt;/em&gt; 및 &lt;em&gt;변환은&lt;/em&gt; 없을 것 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d52d8d3fc67f68d8f2426d8c8de4306ccc1f8e09" translate="yes" xml:space="preserve">
          <source>The values of the first two fields are constants defined in the &lt;a href=&quot;#module-xml.parsers.expat.model&quot;&gt;&lt;code&gt;xml.parsers.expat.model&lt;/code&gt;&lt;/a&gt; module. These constants can be collected in two groups: the model type group and the quantifier group.</source>
          <target state="translated">처음 두 필드의 값은 &lt;a href=&quot;#module-xml.parsers.expat.model&quot;&gt; &lt;code&gt;xml.parsers.expat.model&lt;/code&gt; 에&lt;/a&gt; 정의 된 상수입니다. 모듈에 입니다. 이러한 상수는 모델 유형 그룹과 수량 자 그룹의 두 그룹으로 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1cd2108af5c3d292a414e185f45717815413a4" translate="yes" xml:space="preserve">
          <source>The variables below define the flags used in the &lt;a href=&quot;#stat.ST_MODE&quot;&gt;&lt;code&gt;ST_MODE&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">아래 변수는 &lt;a href=&quot;#stat.ST_MODE&quot;&gt; &lt;code&gt;ST_MODE&lt;/code&gt; &lt;/a&gt; 필드 에서 사용되는 플래그를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="570a00c886bbaa011554650d24fe55f6f0971a79" translate="yes" xml:space="preserve">
          <source>The variables defined in the &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module are:</source>
          <target state="translated">&lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 변수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee64058d781eef751c586d91741d6ad13c91889d" translate="yes" xml:space="preserve">
          <source>The variants which include a &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.execlp&quot;&gt;&lt;code&gt;execlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execlpe&quot;&gt;&lt;code&gt;execlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execvp&quot;&gt;&lt;code&gt;execvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execvpe&quot;&gt;&lt;code&gt;execvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-26&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;execl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execle&quot;&gt;&lt;code&gt;execle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">끝 부분에&amp;ldquo;p&amp;rdquo;가 포함 된 변형 ( &lt;a href=&quot;#os.execlp&quot;&gt; &lt;code&gt;execlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execlpe&quot;&gt; &lt;code&gt;execlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execvp&quot;&gt; &lt;code&gt;execvp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execvpe&quot;&gt; &lt;code&gt;execvpe()&lt;/code&gt; &lt;/a&gt; )은 &lt;code id=&quot;index-26&quot;&gt;PATH&lt;/code&gt; 환경 변수를 사용 하여 프로그램 &lt;em&gt;파일&lt;/em&gt; 을 찾습니다 . 다음 단락에서 설명 하는 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*e&lt;/code&gt; &lt;/a&gt; 변형 중 하나를 사용하여 환경을 교체 할 때 새 환경이 &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; 변수 의 소스로 사용됩니다 . 다른 변형 인 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;execl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execle&quot;&gt; &lt;code&gt;execle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execv&quot;&gt; &lt;code&gt;execv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 는 &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; 변수를 사용 하여 실행 파일을 찾지 않습니다 .&lt;em&gt;통로&lt;/em&gt; 적절한 절대 또는 상대 경로를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="9193f1ef76fbd673e45f1225a537e38ac8bf4170" translate="yes" xml:space="preserve">
          <source>The variants which include a second &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnlpe&quot;&gt;&lt;code&gt;spawnlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnvp&quot;&gt;&lt;code&gt;spawnvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-32&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-33&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawnl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnle&quot;&gt;&lt;code&gt;spawnle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnv&quot;&gt;&lt;code&gt;spawnv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnve&quot;&gt;&lt;code&gt;spawnve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">끝 부분에 두 번째 &quot;p&quot;를 포함하는 변형 ( &lt;a href=&quot;#os.spawnlp&quot;&gt; &lt;code&gt;spawnlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnlpe&quot;&gt; &lt;code&gt;spawnlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnvp&quot;&gt; &lt;code&gt;spawnvp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnvpe&quot;&gt; &lt;code&gt;spawnvpe()&lt;/code&gt; &lt;/a&gt; )은 &lt;code id=&quot;index-32&quot;&gt;PATH&lt;/code&gt; 환경 변수를 사용 하여 프로그램 &lt;em&gt;파일&lt;/em&gt; 을 찾습니다 . 환경이 교체 될 때 ( 다음 단락에서 설명 된 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*e&lt;/code&gt; &lt;/a&gt; 변형 중 하나를 사용하여 ) 새 환경이 &lt;code id=&quot;index-33&quot;&gt;PATH&lt;/code&gt; 변수 의 소스로 사용됩니다 . 다른 변형 인 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawnl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnle&quot;&gt; &lt;code&gt;spawnle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnv&quot;&gt; &lt;code&gt;spawnv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnve&quot;&gt; &lt;code&gt;spawnve()&lt;/code&gt; &lt;/a&gt; 는 &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; 변수를 사용 하여 실행 파일을 찾지 않습니다 . &lt;em&gt;통로&lt;/em&gt; 적절한 절대 또는 상대 경로를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f460136362370229598b52a9bcbe0209c61fd006" translate="yes" xml:space="preserve">
          <source>The various &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*&lt;/code&gt;&lt;/a&gt; functions take a list of arguments for the new program loaded into the process. In each case, the first of these arguments is passed to the new program as its own name rather than as an argument a user may have typed on a command line. For the C programmer, this is the &lt;code&gt;argv[0]&lt;/code&gt; passed to a program&amp;rsquo;s &lt;code&gt;main()&lt;/code&gt;. For example, &lt;code&gt;os.execv('/bin/echo',
['foo', 'bar'])&lt;/code&gt; will only print &lt;code&gt;bar&lt;/code&gt; on standard output; &lt;code&gt;foo&lt;/code&gt; will seem to be ignored.</source>
          <target state="translated">다양한 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*&lt;/code&gt; &lt;/a&gt; 함수는 프로세스에로드 된 새 프로그램에 대한 인수 목록을 가져옵니다. 각각의 경우, 이러한 인수 중 첫 번째 인수는 사용자가 명령 행에 입력 한 인수가 아닌 자체 이름으로 새 프로그램에 전달됩니다. C 프로그래머의 경우 이는 프로그램의 &lt;code&gt;main()&lt;/code&gt; 전달 된 &lt;code&gt;argv[0]&lt;/code&gt; 입니다. 예를 들어, &lt;code&gt;os.execv('/bin/echo', ['foo', 'bar'])&lt;/code&gt; 는 표준 출력 에서만 &lt;code&gt;bar&lt;/code&gt; 를 인쇄 합니다 . &lt;code&gt;foo&lt;/code&gt; 는 무시되는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="39516d842ad2ebf0ccc0148be3b60ceb8e23f56b" translate="yes" xml:space="preserve">
          <source>The various named parameters found in &lt;em&gt;Set-Cookie&lt;/em&gt; and &lt;em&gt;Set-Cookie2&lt;/em&gt; headers (eg. &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;expires&lt;/code&gt;) are conventionally referred to as &lt;em&gt;attributes&lt;/em&gt;. To distinguish them from Python attributes, the documentation for this module uses the term &lt;em&gt;cookie-attribute&lt;/em&gt; instead.</source>
          <target state="translated">&lt;em&gt;Set-Cookie&lt;/em&gt; 및 &lt;em&gt;Set-Cookie2&lt;/em&gt; 헤더 (예 : &lt;code&gt;domain&lt;/code&gt; 및 &lt;code&gt;expires&lt;/code&gt; )에 있는 다양한 명명 된 매개 변수 는 일반적으로 &lt;em&gt;속성&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 파이썬 속성과 구별하기 위해이 모듈의 문서는 대신 &lt;em&gt;쿠키 속성&lt;/em&gt; 이라는 용어를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a9102cf75be9fce05b52770c18e9074f93ffc76b" translate="yes" xml:space="preserve">
          <source>The version number as a string, with any whitespace and/or comments removed.</source>
          <target state="translated">공백 및 / 또는 주석이 제거 된 문자열의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="609eb97fd5216df593e456b08820fbdecce59af0" translate="yes" xml:space="preserve">
          <source>The version number encoded as a single integer. This is guaranteed to increase with each version, including proper support for non-production releases. For example, to test that the Python interpreter is at least version 1.5.2, use:</source>
          <target state="translated">단일 정수로 인코딩 된 버전 번호입니다. 이것은 비 프로덕션 릴리스에 대한 적절한 지원을 포함하여 각 버전마다 증가 할 것입니다. 예를 들어 Python 인터프리터가 버전 1.5.2 이상인지 테스트하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d8b4cf55cc9ba4af98dcfd2188bb39d0808a2000" translate="yes" xml:space="preserve">
          <source>The version number of the run-time SQLite library, as a string.</source>
          <target state="translated">런타임 SQLite 라이브러리의 버전 번호입니다 (문자열).</target>
        </trans-unit>
        <trans-unit id="83cfbef62783b9adbc5d82cbd03374d9ffac04a3" translate="yes" xml:space="preserve">
          <source>The version number of the run-time SQLite library, as a tuple of integers.</source>
          <target state="translated">정수의 튜플 인 런타임 SQLite 라이브러리의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="82ad32d0ec3913612c3c798f838cb1d4b90e0ca4" translate="yes" xml:space="preserve">
          <source>The version number of this module, as a string. This is not the version of the SQLite library.</source>
          <target state="translated">이 모듈의 버전 번호입니다 (문자열). 이것은 SQLite 라이브러리의 버전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b2bf9e254a8f2ed1bc7d1d04b5316dcc3367de2d" translate="yes" xml:space="preserve">
          <source>The version number of this module, as a tuple of integers. This is not the version of the SQLite library.</source>
          <target state="translated">이 모듈의 버전 번호는 정수 튜플입니다. 이것은 SQLite 라이브러리의 버전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e547ed29557b93784e133bf96efb332e811697d" translate="yes" xml:space="preserve">
          <source>The version number used to form registry keys on Windows platforms. This is stored as string resource 1000 in the Python DLL. The value is normally the first three characters of &lt;a href=&quot;#sys.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt;. It is provided in the &lt;a href=&quot;#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; module for informational purposes; modifying this value has no effect on the registry keys used by Python.</source>
          <target state="translated">Windows 플랫폼에서 레지스트리 키를 형성하는 데 사용되는 버전 번호입니다. 이것은 파이썬 DLL에서 문자열 리소스 1000으로 저장됩니다. 값은 일반적으로 &lt;a href=&quot;#sys.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 의 처음 세 문자입니다 . 그것은에서 제공 &lt;a href=&quot;#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; 정보를 제공하기위한 모듈; 이 값을 수정해도 Python에서 사용하는 레지스트리 키에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd9dddc1a822657d560f74f81863263cdf639a3e" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt;&lt;code&gt;BUILD_MAP&lt;/code&gt;&lt;/a&gt; specialized for constant keys. &lt;em&gt;count&lt;/em&gt; values are consumed from the stack. The top element on the stack contains a tuple of keys.</source>
          <target state="translated">상수 키에 특화된 &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt; &lt;code&gt;BUILD_MAP&lt;/code&gt; &lt;/a&gt; 버전 . &lt;em&gt;카운트&lt;/em&gt; 값은 스택에서 소비됩니다. 스택의 맨 위 요소에는 튜플 키가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bb4e85c9ec212eecd8d18482a8624ea4b9d922a" translate="yes" xml:space="preserve">
          <source>The version of the Unicode database used in this module.</source>
          <target state="translated">이 모듈에서 사용 된 유니 코드 데이터베이스의 버전.</target>
        </trans-unit>
        <trans-unit id="056761a5a01ae0e3f3f5bb2776ef234db9b6782e" translate="yes" xml:space="preserve">
          <source>The version string of the OpenSSL library loaded by the interpreter:</source>
          <target state="translated">인터프리터가로드 한 OpenSSL 라이브러리의 버전 문자열 :</target>
        </trans-unit>
        <trans-unit id="68f2bb2ab063964d03cb7301ec9bedfef871e189" translate="yes" xml:space="preserve">
          <source>The version string of the zlib library actually loaded by the interpreter.</source>
          <target state="translated">인터프리터가 실제로로드 한 zlib 라이브러리의 버전 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="66895485e5b6e2239606f9c0e8f020dc482fd6aa" translate="yes" xml:space="preserve">
          <source>The version string of the zlib library that was used for building the module. This may be different from the zlib library actually used at runtime, which is available as &lt;a href=&quot;#zlib.ZLIB_RUNTIME_VERSION&quot;&gt;&lt;code&gt;ZLIB_RUNTIME_VERSION&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈을 빌드하는 데 사용 된 zlib 라이브러리의 버전 문자열입니다. &lt;a href=&quot;#zlib.ZLIB_RUNTIME_VERSION&quot;&gt; &lt;code&gt;ZLIB_RUNTIME_VERSION&lt;/code&gt; &lt;/a&gt; 으로 사용 가능한 런타임에 실제로 사용되는 zlib 라이브러리와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a928dd1d5b35bf2574f665823c8388fc665c61e" translate="yes" xml:space="preserve">
          <source>The virtual screen may be updated by a &lt;a href=&quot;#curses.window.noutrefresh&quot;&gt;&lt;code&gt;noutrefresh()&lt;/code&gt;&lt;/a&gt; call after write operations such as &lt;a href=&quot;#curses.window.addstr&quot;&gt;&lt;code&gt;addstr()&lt;/code&gt;&lt;/a&gt; have been performed on a window. The normal &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; call is simply &lt;code&gt;noutrefresh()&lt;/code&gt; followed by &lt;code&gt;doupdate()&lt;/code&gt;; if you have to update multiple windows, you can speed performance and perhaps reduce screen flicker by issuing &lt;code&gt;noutrefresh()&lt;/code&gt; calls on all windows, followed by a single &lt;code&gt;doupdate()&lt;/code&gt;.</source>
          <target state="translated">가상 화면은 다음 과 같은 쓰기 작업 후 &lt;a href=&quot;#curses.window.noutrefresh&quot;&gt; &lt;code&gt;noutrefresh()&lt;/code&gt; &lt;/a&gt; 호출 로 업데이트 될 수 있습니다.&lt;a href=&quot;#curses.window.addstr&quot;&gt; &lt;code&gt;addstr()&lt;/code&gt; &lt;/a&gt; 윈도우에서 수행되었다. 일반적인 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 호출은 단순히 &lt;code&gt;noutrefresh()&lt;/code&gt; 다음에 &lt;code&gt;doupdate()&lt;/code&gt; . 여러 개의 창을 업데이트해야하는 경우 모든 창에서 &lt;code&gt;noutrefresh()&lt;/code&gt; 호출을 실행 한 &lt;code&gt;doupdate()&lt;/code&gt; 단일 doupdate () 를 실행하여 성능을 높이고 화면 깜박임을 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe10e8128cec2a8b853d046a9f0502bfff7b4b2b" translate="yes" xml:space="preserve">
          <source>The warnings filter controls whether warnings are ignored, displayed, or turned into errors (raising an exception).</source>
          <target state="translated">경고 필터는 경고를 무시, 표시 또는 오류로 전환할지 여부를 제어합니다 (예외 발생).</target>
        </trans-unit>
        <trans-unit id="81d6c008939066a9c786b974f1a35df744af57e8" translate="yes" xml:space="preserve">
          <source>The warnings filter is initialized by &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; options passed to the Python interpreter command line and the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt; environment variable. The interpreter saves the arguments for all supplied entries without interpretation in &lt;a href=&quot;sys#sys.warnoptions&quot;&gt;&lt;code&gt;sys.warnoptions&lt;/code&gt;&lt;/a&gt;; the &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module parses these when it is first imported (invalid options are ignored, after printing a message to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경고 필터는 Python 인터프리터 명령 행에 전달 된 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 옵션과&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt; &lt;code&gt;PYTHONWARNINGS&lt;/code&gt; 에&lt;/a&gt; 환경 변수에 . 인터프리터는 &lt;a href=&quot;sys#sys.warnoptions&quot;&gt; &lt;code&gt;sys.warnoptions&lt;/code&gt; &lt;/a&gt; 에서 해석하지 않고 제공된 모든 항목에 대한 인수를 저장합니다 . &lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 가 처음 가져올 때 모듈 (유효하지 않은 옵션에 대한 메시지를 인쇄 한 후, 무시하는 이러한 구문 분석 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 를을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f2742895327f8f1c5d2fcfda5a226fa7f537c878" translate="yes" xml:space="preserve">
          <source>The watcher avoids disrupting other code spawning processes by polling every process explicitly on a &lt;code&gt;SIGCHLD&lt;/code&gt; signal.</source>
          <target state="translated">감시자는 모든 프로세스를 &lt;code&gt;SIGCHLD&lt;/code&gt; 신호 에 명시 적으로 폴링하여 다른 코드 생성 프로세스를 방해하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10a8f59f5f02b63085e6b7ff709cd3f0f1ce5558" translate="yes" xml:space="preserve">
          <source>The way &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; are recorded means that where nested calls are made, the parameters of ancestor calls are not recorded and so will always compare equal:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; 가 기록 되는 방식 은 중첩 된 호출이 수행되는 경우 상위 호출의 매개 변수가 기록되지 않으므로 항상 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="07fd27b7e683afd9d6a2777d2e2bc0e02e57826f" translate="yes" xml:space="preserve">
          <source>The widget state is a bitmap of independent state flags.</source>
          <target state="translated">위젯 상태는 독립 상태 플래그의 비트 맵입니다.</target>
        </trans-unit>
        <trans-unit id="ad9e57f84a79be5923c4fad7f02f67bfce0d0138" translate="yes" xml:space="preserve">
          <source>The widget&amp;rsquo;s value is invalid</source>
          <target state="translated">위젯 값이 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7a5decf7ad4f9356a33597c56799bfaaba97e9ea" translate="yes" xml:space="preserve">
          <source>The width of the column in pixels.</source>
          <target state="translated">열 너비 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="f13a55fc25371355d16c8ccfbb2ea8fb626f5b8b" translate="yes" xml:space="preserve">
          <source>The zero-based Julian day (0 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). Leap days are counted, and it is possible to refer to February 29.</source>
          <target state="translated">0부터 시작하는 율리우스 일 (0 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). 윤일이 계산되며 2 월 29 일을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a94f537c497bc41758e7de7dc18b5dc9e5aa4b" translate="yes" xml:space="preserve">
          <source>The zip file format allows arbitrary data to be prepended to a zip file. The zip application format uses this ability to prepend a standard POSIX &amp;ldquo;shebang&amp;rdquo; line to the file (&lt;code&gt;#!/path/to/interpreter&lt;/code&gt;).</source>
          <target state="translated">zip 파일 형식을 사용하면 임의의 데이터를 zip 파일 앞에 추가 할 수 있습니다. zip 애플리케이션 형식은이 기능을 사용하여 표준 POSIX&amp;ldquo;shebang&amp;rdquo;행을 파일 앞에 추가합니다 ( &lt;code&gt;#!/path/to/interpreter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e0f5450f31911228fbdcb1860dad56d3814c81e" translate="yes" xml:space="preserve">
          <source>The zlib library home page.</source>
          <target state="translated">zlib 라이브러리 홈페이지.</target>
        </trans-unit>
        <trans-unit id="8affd2d9f0cad819c09a176405cd6b5206cef756" translate="yes" xml:space="preserve">
          <source>The zlib manual explains the semantics and usage of the library&amp;rsquo;s many functions.</source>
          <target state="translated">zlib 매뉴얼은 라이브러리의 많은 기능의 의미와 사용법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="190b6a003d5b9ea453b301c3e6ce588721c176be" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; gets a chance. If it accepts &lt;code&gt;a&lt;/code&gt;, all is well.</source>
          <target state="translated">그러면 &lt;code&gt;B&lt;/code&gt; 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 가 기회를 얻습니다. 그것이 받아들이 &lt;code&gt;a&lt;/code&gt; , 모두 잘 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f3cfe2af54d2f5c805181fe58a7558eae8452c" translate="yes" xml:space="preserve">
          <source>Then an interactive Python session may look like this:</source>
          <target state="translated">그런 다음 대화 형 Python 세션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c575aa8053687837f8a56e8486b23babe4c92cdd" translate="yes" xml:space="preserve">
          <source>Then follows a blank line signifying the end of the headers, and then the contents of the file are output. If the file&amp;rsquo;s MIME type starts with &lt;code&gt;text/&lt;/code&gt; the file is opened in text mode; otherwise binary mode is used.</source>
          <target state="translated">그런 다음 헤더의 끝을 나타내는 빈 줄을 따라 가면 파일의 내용이 출력됩니다. 파일의 MIME 형식이 &lt;code&gt;text/&lt;/code&gt; 시작하는 경우 하면 파일이 텍스트 모드로 열립니다. 그렇지 않으면 이진 모드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f553f569d6ec90354bbb3b909858d32b9e9096" translate="yes" xml:space="preserve">
          <source>Then the following version-specific directories are added to &lt;code&gt;sys.path&lt;/code&gt;, in this order:</source>
          <target state="translated">그런 다음 다음 버전 별 디렉토리가 &lt;code&gt;sys.path&lt;/code&gt; 에 추가됩니다. 에이 순서대로 .</target>
        </trans-unit>
        <trans-unit id="82f978014fab5239e5ba8297d9634d6b6d533b89" translate="yes" xml:space="preserve">
          <source>Then use &lt;em&gt;code&lt;/em&gt; as the encoding for &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;str.encode()&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;str.encode()&lt;/code&gt; &lt;/a&gt; 의 인코딩으로 &lt;em&gt;코드&lt;/em&gt; 를 사용하십시오. 호출 .</target>
        </trans-unit>
        <trans-unit id="e5799d48128610654dfc6147c53f4b2206c78fb2" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll read data from the &lt;code&gt;connstream&lt;/code&gt; and do something with it till you are finished with the client (or the client is finished with you):</source>
          <target state="translated">그런 다음 &lt;code&gt;connstream&lt;/code&gt; 에서 데이터를 읽습니다. 클라이언트가 끝날 때까지 (또는 클라이언트가 끝났을 때까지) 무언가를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="5b1e898fc07d61e53c63f3002ef704c95490010b" translate="yes" xml:space="preserve">
          <source>Theory</source>
          <target state="translated">Theory</target>
        </trans-unit>
        <trans-unit id="7fa259f892d2f161a72fca4bf8158be9adf1787b" translate="yes" xml:space="preserve">
          <source>There are 5 different cases for a mixed-type operation on subclasses of &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt;. I&amp;rsquo;ll refer to all of the above code that doesn&amp;rsquo;t refer to &lt;code&gt;MyIntegral&lt;/code&gt; and &lt;code&gt;OtherTypeIKnowAbout&lt;/code&gt; as &amp;ldquo;boilerplate&amp;rdquo;. &lt;code&gt;a&lt;/code&gt; will be an instance of &lt;code&gt;A&lt;/code&gt;, which is a subtype of &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;a : A &amp;lt;: Complex&lt;/code&gt;), and &lt;code&gt;b : B &amp;lt;:
Complex&lt;/code&gt;. I&amp;rsquo;ll consider &lt;code&gt;a + b&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; 의&lt;/a&gt; 서브 클래스에서 혼합 유형 연산에 대한 5 가지 경우가 있습니다 . &lt;code&gt;MyIntegral&lt;/code&gt; 및 &lt;code&gt;OtherTypeIKnowAbout&lt;/code&gt; 을 &quot;boilerplate&quot;로 언급하지 않는 위의 모든 코드를 참조 하겠습니다 . &lt;code&gt;a&lt;/code&gt; 는 &lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;a : A &amp;lt;: Complex&lt;/code&gt; ) 및 &lt;code&gt;b : B &amp;lt;: Complex&lt;/code&gt; 의 하위 유형 인 &lt;code&gt;A&lt;/code&gt; 의 인스턴스입니다 . 나는 &lt;code&gt;a + b&lt;/code&gt; 고려할 것이다 .</target>
        </trans-unit>
        <trans-unit id="3f8916b69856c2223ef6abca8e6fa0e94754e630" translate="yes" xml:space="preserve">
          <source>There are a couple of useful utilities provided in the &lt;a href=&quot;#module-email.utils&quot;&gt;&lt;code&gt;email.utils&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-email.utils&quot;&gt; &lt;code&gt;email.utils&lt;/code&gt; &lt;/a&gt; 에는 몇 가지 유용한 유틸리티가 있습니다. 모듈 .</target>
        </trans-unit>
        <trans-unit id="db73f983c1ef412f0f0bf991d5c7b1526f785874" translate="yes" xml:space="preserve">
          <source>There are a few different ways of resolving this problem. The easiest, but not necessarily the least annoying, way is to simply set the required attributes on the mock after creation. Just because &lt;em&gt;autospec&lt;/em&gt; doesn&amp;rsquo;t allow you to fetch attributes that don&amp;rsquo;t exist on the spec it doesn&amp;rsquo;t prevent you setting them:</source>
          <target state="translated">이 문제를 해결하는 방법에는 몇 가지가 있습니다. 가장 성 가시지는 않지만 가장 성가신 방법은 생성 후 모의에 필요한 속성을 간단히 설정하는 것입니다. &lt;em&gt;자동 사양&lt;/em&gt; 때문에&lt;em&gt;&lt;/em&gt; 은 스펙에 존재하지 않는 속성을 가져올 수 설정을 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3aeadae92ca7f5170f43648b0bf091b7291fb4d" translate="yes" xml:space="preserve">
          <source>There are a few extra restriction which don&amp;rsquo;t apply to the &lt;em&gt;fork&lt;/em&gt; start method.</source>
          <target state="translated">&lt;em&gt;포크&lt;/em&gt; 스타트 방법 에는 적용되지 않는 몇 가지 추가 제한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d38135d96a58a5ba6397af560568ea76e6c5aa3e" translate="yes" xml:space="preserve">
          <source>There are a few things to note about this module which are important to making use of the data structures created. This is not a tutorial on editing the parse trees for Python code, but some examples of using the &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module are presented.</source>
          <target state="translated">생성 된 데이터 구조를 사용하는 데 중요한이 모듈에 대해 유의해야 할 사항이 몇 가지 있습니다. 이것은 파이썬 코드를위한 파싱 트리 편집에 대한 튜토리얼은 아니지만 &lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 몇 가지 예가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6fd0b5587b688c222bcb3323758db69747ea41" translate="yes" xml:space="preserve">
          <source>There are a few tools to extract the strings meant for translation. The original GNU &lt;strong&gt;gettext&lt;/strong&gt; only supported C or C++ source code but its extended version &lt;strong&gt;xgettext&lt;/strong&gt; scans code written in a number of languages, including Python, to find strings marked as translatable. &lt;a href=&quot;http://babel.pocoo.org/&quot;&gt;Babel&lt;/a&gt; is a Python internationalization library that includes a &lt;code&gt;pybabel&lt;/code&gt; script to extract and compile message catalogs. Fran&amp;ccedil;ois Pinard&amp;rsquo;s program called &lt;strong&gt;xpot&lt;/strong&gt; does a similar job and is available as part of his &lt;a href=&quot;https://github.com/pinard/po-utils&quot;&gt;po-utils package&lt;/a&gt;.</source>
          <target state="translated">번역을위한 문자열을 추출하는 몇 가지 도구가 있습니다. 원래 GNU &lt;strong&gt;gettext&lt;/strong&gt; 는 C 또는 C ++ 소스 코드 만 지원했지만 확장 버전 &lt;strong&gt;xgettext&lt;/strong&gt; 는 Python을 포함하여 여러 언어로 작성된 코드를 스캔하여 번역 가능으로 표시된 문자열을 찾습니다. &lt;a href=&quot;http://babel.pocoo.org/&quot;&gt;Babel&lt;/a&gt; 은 메시지 카탈로그를 추출하고 컴파일 하는 &lt;code&gt;pybabel&lt;/code&gt; 스크립트를 포함하는 Python 국제화 라이브러리입니다 . 프랑수아 Pinard의 프로그램이라고 &lt;strong&gt;xpot은&lt;/strong&gt; 비슷한 일을 자신의 일부로 볼 수 있습니다 &lt;a href=&quot;https://github.com/pinard/po-utils&quot;&gt;포 - 유틸 패키지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26f97faaa25467594fb9160eb8740b560db6b4f9" translate="yes" xml:space="preserve">
          <source>There are a few utility functions for framework authors to enable control-c handling functionality within test frameworks.</source>
          <target state="translated">프레임 워크 작성자가 테스트 프레임 워크 내에서 control-c 처리 기능을 사용할 수 있도록하는 몇 가지 유틸리티 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0bb7e25ceb0ffba66ad1c049f198424ce2c3808" translate="yes" xml:space="preserve">
          <source>There are a number of built-in exceptions that represent warning categories. This categorization is useful to be able to filter out groups of warnings.</source>
          <target state="translated">경고 범주를 나타내는 여러 가지 기본 제공 예외가 있습니다. 이 분류는 경고 그룹을 필터링하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ab4deb2b4c65697178a9e91e651f82ce32bff537" translate="yes" xml:space="preserve">
          <source>There are a number of other caveats:</source>
          <target state="translated">다른 여러 가지 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="740a6e1a370e644b8acad66b626c4251477d08b6" translate="yes" xml:space="preserve">
          <source>There are a number of uses for the &lt;em&gt;func&lt;/em&gt; argument. It can be set to &lt;a href=&quot;functions#min&quot;&gt;&lt;code&gt;min()&lt;/code&gt;&lt;/a&gt; for a running minimum, &lt;a href=&quot;functions#max&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt; for a running maximum, or &lt;a href=&quot;operator#operator.mul&quot;&gt;&lt;code&gt;operator.mul()&lt;/code&gt;&lt;/a&gt; for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot;&gt;recurrence relations&lt;/a&gt; can be modeled by supplying the initial value in the iterable and using only the accumulated total in &lt;em&gt;func&lt;/em&gt; argument:</source>
          <target state="translated">&lt;em&gt;func&lt;/em&gt; 인수 에는 여러 가지 용도가 있습니다. 이 설정 될 수 &lt;a href=&quot;functions#min&quot;&gt; &lt;code&gt;min()&lt;/code&gt; &lt;/a&gt; 실행 최소, &lt;a href=&quot;functions#max&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt; 주행 최대 또는 대한 &lt;a href=&quot;operator#operator.mul&quot;&gt; &lt;code&gt;operator.mul()&lt;/code&gt; &lt;/a&gt; 실행 제품. 상각 표는이자를 누적하고 지불을 적용하여 구축 할 수 있습니다. 1 차 &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot;&gt;재귀 관계&lt;/a&gt; 는 iterable에 초기 값을 제공하고 &lt;em&gt;func&lt;/em&gt; 인수 에서 누적 된 합계 만 사용하여 모델링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d2c1754d16fc36acf6343a01e5a606d44c91330" translate="yes" xml:space="preserve">
          <source>There are actually two parser interfaces available for use, the &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; API and the incremental &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; API. The &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; API is most useful if you have the entire text of the message in memory, or if the entire message lives in a file on the file system. &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; is more appropriate when you are reading the message from a stream which might block waiting for more input (such as reading an email message from a socket). The &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; can consume and parse the message incrementally, and only returns the root object when you close the parser.</source>
          <target state="translated">실제로 사용 가능한 두 가지 구문 분석기 인터페이스 인 &lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; API와 증분 &lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt; API가 있습니다. &lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; API를 사용하면 메모리에 메시지의 전체 텍스트가있는 경우에 가장 유용, 또는 파일 시스템에있는 파일의 전체 메시지의 삶 경우. &lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt; 는 스트림에서 메시지를 읽을 때 소켓에서 전자 메일 메시지를 읽는 것과 같이 더 많은 입력 대기를 차단할 수있는 경우에 더 적합합니다. &lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; 는&lt;/a&gt; 소비 점진적으로 메시지를 구문 분석하고 파서을 닫을 경우에만 루트 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039266eeef2dff97e5e5130bed399d4f0600c2da" translate="yes" xml:space="preserve">
          <source>There are all kinds of additional metadata available on the &lt;code&gt;Distribution&lt;/code&gt; instance:</source>
          <target state="translated">&lt;code&gt;Distribution&lt;/code&gt; 인스턴스 에서 사용 가능한 모든 추가 메타 데이터가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddebb36a5d0bbfeddcd3da60a21d96401142db63" translate="yes" xml:space="preserve">
          <source>There are also experimental methods that give this class more mapping behavior. You can use them or you can use the standardized &lt;code&gt;getAttribute*()&lt;/code&gt; family of methods on the &lt;code&gt;Element&lt;/code&gt; objects.</source>
          <target state="translated">이 클래스에 더 많은 매핑 동작을 제공하는 실험적인 방법도 있습니다. 그것들을 사용하거나 &lt;code&gt;Element&lt;/code&gt; 객체 에 표준화 된 &lt;code&gt;getAttribute*()&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bc97db34ca865c4f6e13f984f32b85cf0430a9c" translate="yes" xml:space="preserve">
          <source>There are also other methods used to perform more specific checks, such as:</source>
          <target state="translated">보다 구체적인 검사를 수행하는 데 사용되는 다른 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd66bff89abb178647e31e8d7b36f2b277e325f3" translate="yes" xml:space="preserve">
          <source>There are also several readonly attributes available:</source>
          <target state="translated">사용 가능한 몇 가지 읽기 전용 속성도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dbe98b62c6ac402e4adf807336479d380787150" translate="yes" xml:space="preserve">
          <source>There are also specific options for tabs:</source>
          <target state="translated">탭에 대한 특정 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="64b4683225cbfb5d8247369d9cbda217bda79fc7" translate="yes" xml:space="preserve">
          <source>There are also variants of these methods that simply return a string instead of printing it:</source>
          <target state="translated">문자열을 인쇄하는 대신 단순히 반환하는 이러한 메소드의 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c959f4df3c12c67509677745222747e6ef2cf83a" translate="yes" xml:space="preserve">
          <source>There are cases, however, when applications need to use prefixes in character data or in attribute values, where they cannot safely be expanded automatically; the &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt;&lt;code&gt;startPrefixMapping()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt;&lt;code&gt;endPrefixMapping()&lt;/code&gt;&lt;/a&gt; events supply the information to the application to expand prefixes in those contexts itself, if necessary.</source>
          <target state="translated">그러나 응용 프로그램이 문자 데이터 나 속성 값에 접 두부를 사용해야하는 경우 자동으로 안전하게 확장 할 수없는 경우가 있습니다. &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt; &lt;code&gt;startPrefixMapping()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt; &lt;code&gt;endPrefixMapping()&lt;/code&gt; &lt;/a&gt; 이벤트가 필요한 경우, 그 상황에서 자신을 접두사를 확장하는 응용 프로그램에 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ba631db31ee48915b3b121db2e36c181d8ccc00" translate="yes" xml:space="preserve">
          <source>There are certain guidelines and idioms which should be adhered to when using &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 을 사용할 때 준수해야하는 특정 지침 및 관용구가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="827dd66505bcf022799f1772f83bac7872cd90a3" translate="yes" xml:space="preserve">
          <source>There are currently 6 different protocols which can be used for pickling. The higher the protocol used, the more recent the version of Python needed to read the pickle produced.</source>
          <target state="translated">현재 산세에 사용할 수있는 6 가지 프로토콜이 있습니다. 사용 된 프로토콜이 높을수록 생성 된 피클을 읽는 데 필요한 최신 버전의 Python이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ead616e7256dcb5719abe40d028e6090d64aa306" translate="yes" xml:space="preserve">
          <source>There are currently two built-in set types, &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; type is mutable &amp;mdash; the contents can be changed using methods like &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt;. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; type is immutable and &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; &amp;mdash; its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</source>
          <target state="translated">있다 현재이 내장 된 세트 유형, &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 의&lt;/a&gt;. &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 유형 변경 가능한 - 콘텐츠 추천 방법은 사용하여 변경할 수 &lt;code&gt;add()&lt;/code&gt; 및 &lt;code&gt;remove()&lt;/code&gt; . 변경 가능하기 때문에 해시 값이 없으며 사전 키 또는 다른 세트의 요소로 사용할 수 없습니다. &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 의&lt;/a&gt; 유형이 불변 인&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt; 해쉬&lt;/a&gt; -가 생성 된 후, 그 내용이 변경 될 수 없다; 따라서 사전 키 또는 다른 세트의 요소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e48ec5af476b663fb0695c8e11aa6c35b465db" translate="yes" xml:space="preserve">
          <source>There are default adapters for the date and datetime types in the datetime module. They will be sent as ISO dates/ISO timestamps to SQLite.</source>
          <target state="translated">datetime 모듈에는 날짜 및 날짜 / 시간 유형에 대한 기본 어댑터가 있습니다. SQL 날짜에는 ISO 날짜 / ISO 타임 스탬프로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f000a68af366a9a5eefed22b9b119e2b234e96" translate="yes" xml:space="preserve">
          <source>There are eight built-in, named bitmaps: &lt;code&gt;'error'&lt;/code&gt;, &lt;code&gt;'gray25'&lt;/code&gt;, &lt;code&gt;'gray50'&lt;/code&gt;, &lt;code&gt;'hourglass'&lt;/code&gt;, &lt;code&gt;'info'&lt;/code&gt;, &lt;code&gt;'questhead'&lt;/code&gt;, &lt;code&gt;'question'&lt;/code&gt;, &lt;code&gt;'warning'&lt;/code&gt;. To specify an X bitmap filename, give the full path to the file, preceded with an &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;&quot;@/usr/contrib/bitmap/gumby.bit&quot;&lt;/code&gt;.</source>
          <target state="translated">8 개의 내장 비트 맵이 있습니다 : &lt;code&gt;'error'&lt;/code&gt; , &lt;code&gt;'gray25'&lt;/code&gt; , &lt;code&gt;'gray50'&lt;/code&gt; , &lt;code&gt;'hourglass'&lt;/code&gt; , &lt;code&gt;'info'&lt;/code&gt; , &lt;code&gt;'questhead'&lt;/code&gt; , &lt;code&gt;'question'&lt;/code&gt; , &lt;code&gt;'warning'&lt;/code&gt; 있습니다. X 비트 맵 파일 이름을 지정하려면 &lt;code&gt;&quot;@/usr/contrib/bitmap/gumby.bit&quot;&lt;/code&gt; 에서 와 같이 &lt;code&gt;@&lt;/code&gt; 앞에 파일의 전체 경로를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdfda48041a9be25615bc1e181ea720f1ed03d01" translate="yes" xml:space="preserve">
          <source>There are eight comparison operations in Python. They all have the same priority (which is higher than that of the Boolean operations). Comparisons can be chained arbitrarily; for example, &lt;code&gt;x &amp;lt; y &amp;lt;= z&lt;/code&gt; is equivalent to &lt;code&gt;x &amp;lt; y and
y &amp;lt;= z&lt;/code&gt;, except that &lt;em&gt;y&lt;/em&gt; is evaluated only once (but in both cases &lt;em&gt;z&lt;/em&gt; is not evaluated at all when &lt;code&gt;x &amp;lt; y&lt;/code&gt; is found to be false).</source>
          <target state="translated">파이썬에는 8 가지 비교 연산이 있습니다. 모두 동일한 우선 순위를 갖습니다 (부울 연산보다 우선 순위가 높음). 비교는 임의로 연결될 수 있습니다. 예를 들어, &lt;code&gt;x &amp;lt; y &amp;lt;= z&lt;/code&gt; 는 &lt;em&gt;y&lt;/em&gt; 가 한 번만 평가 된다는 점을 제외하고 &lt;code&gt;x &amp;lt; y and y &amp;lt;= z&lt;/code&gt; 같습니다 (두 경우 모두 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 false 인 경우 &lt;em&gt;z&lt;/em&gt; 는 전혀 평가되지 않음 ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9237bbf2789014dc169fd8c3d198b4953c139" translate="yes" xml:space="preserve">
          <source>There are five classes in an inheritance diagram, four of which represent synchronous servers of four types:</source>
          <target state="translated">상속 다이어그램에는 5 개의 클래스가 있으며 그 중 4 개는 4 가지 유형의 동기 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="121f7346d52a69a5317d8485ce670ca978d629c2" translate="yes" xml:space="preserve">
          <source>There are four basic concrete server classes:</source>
          <target state="translated">다음과 같은 네 가지 기본 구체적 서버 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28d84994e74ad89bc8bd10dab4568463a23f06e4" translate="yes" xml:space="preserve">
          <source>There are four keyword arguments in &lt;em&gt;kwargs&lt;/em&gt; which are inspected: &lt;em&gt;exc_info&lt;/em&gt;, &lt;em&gt;stack_info&lt;/em&gt;, &lt;em&gt;stacklevel&lt;/em&gt; and &lt;em&gt;extra&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;kwargs&lt;/em&gt; 에는 4 가지 키워드 인수가 있습니다 .&lt;em&gt; exc_info&lt;/em&gt; , &lt;em&gt;stack_info&lt;/em&gt; , &lt;em&gt;stacklevel&lt;/em&gt; 및 &lt;em&gt;extra&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c8904775f6163564a009e440caf9e4700413f210" translate="yes" xml:space="preserve">
          <source>There are four main kinds of services provided by this module: type checking, getting source code, inspecting classes and functions, and examining the interpreter stack.</source>
          <target state="translated">이 모듈에서 제공하는 4 가지 주요 서비스 유형은 유형 검사, 소스 코드 가져 오기, 클래스 및 함수 검사 및 인터프리터 스택 검사입니다.</target>
        </trans-unit>
        <trans-unit id="607a56c6d25a7712202e05cdfe56d0f4635a21c9" translate="yes" xml:space="preserve">
          <source>There are functions that read/write files as well as functions operating on bytes-like objects.</source>
          <target state="translated">바이트와 ​​유사한 객체에서 작동하는 기능뿐만 아니라 파일을 읽고 쓰는 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa3669afb266251babb0404fcc0d929459102f0" translate="yes" xml:space="preserve">
          <source>There are fundamental differences between the pickle protocols and &lt;a href=&quot;http://json.org&quot;&gt;JSON (JavaScript Object Notation)&lt;/a&gt;:</source>
          <target state="translated">피클 프로토콜과 &lt;a href=&quot;http://json.org&quot;&gt;JSON (JavaScript Object Notation)&lt;/a&gt; 사이에는 근본적인 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eff3e0b7d4ac0260b5fcec0fd569b30b6694a180" translate="yes" xml:space="preserve">
          <source>There are many useful subclasses of Variable already defined: &lt;code&gt;StringVar&lt;/code&gt;, &lt;code&gt;IntVar&lt;/code&gt;, &lt;code&gt;DoubleVar&lt;/code&gt;, and &lt;code&gt;BooleanVar&lt;/code&gt;. To read the current value of such a variable, call the &lt;code&gt;get()&lt;/code&gt; method on it, and to change its value you call the &lt;code&gt;set()&lt;/code&gt; method. If you follow this protocol, the widget will always track the value of the variable, with no further intervention on your part.</source>
          <target state="translated">&lt;code&gt;StringVar&lt;/code&gt; , &lt;code&gt;IntVar&lt;/code&gt; , &lt;code&gt;DoubleVar&lt;/code&gt; 및 &lt;code&gt;BooleanVar&lt;/code&gt; 와 같이 이미 정의 된 변수의 유용한 하위 클래스가 많이 있습니다 . 이러한 변수의 현재 값을 읽으려면 &lt;code&gt;get()&lt;/code&gt; 메소드를 호출하고 값을 변경하려면 &lt;code&gt;set()&lt;/code&gt; 메소드 를 호출하십시오 . 이 프로토콜을 따르는 경우 위젯은 사용자의 추가 개입없이 항상 변수 값을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="bf2f9d53cf6bf41d410d3108dd0294a79a931d55" translate="yes" xml:space="preserve">
          <source>There are nearly as many INI format variants as there are applications using it. &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; goes a long way to provide support for the largest sensible set of INI styles available. The default functionality is mainly dictated by historical background and it&amp;rsquo;s very likely that you will want to customize some of the features.</source>
          <target state="translated">INI 형식 변형은 응용 프로그램을 사용하는 것만큼이나 많습니다. &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 는 사용 가능한 가장 큰 INI 스타일 세트를 지원하기 위해 먼 길을갑니다. 기본 기능은 주로 역사적 배경에 의해 결정되며 일부 기능을 사용자 정의하려는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="3265267da2983bf14017aa5df9e7283accfab3d4" translate="yes" xml:space="preserve">
          <source>There are only two ways to have a program on a single processor do &amp;ldquo;more than one thing at a time.&amp;rdquo; Multi-threaded programming is the simplest and most popular way to do it, but there is another very different technique, that lets you have nearly all the advantages of multi-threading, without actually using multiple threads. It&amp;rsquo;s really only practical if your program is largely I/O bound. If your program is processor bound, then pre-emptive scheduled threads are probably what you really need. Network servers are rarely processor bound, however.</source>
          <target state="translated">단일 프로세서에서 한 번에 하나 이상의 프로그램을 수행하는 방법은 두 가지뿐입니다. 멀티 스레드 프로그래밍은 가장 단순하고 가장 널리 사용되는 방법이지만 실제로는 여러 스레드를 사용하지 않고도 멀티 스레딩의 거의 모든 이점을 얻을 수있는 매우 다른 기술이 있습니다. 프로그램이 주로 I / O 바운드 인 경우에만 실용적입니다. 프로그램이 프로세서 바운드 인 경우 선점 예약 된 스레드가 실제로 필요한 것일 수 있습니다. 그러나 네트워크 서버는 프로세서에 거의 묶이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="634f390469439c342320f71f9c406a991d40d6d4" translate="yes" xml:space="preserve">
          <source>There are others, but you get the idea.</source>
          <target state="translated">다른 사람들도 있지만 아이디어를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1134b66828043dd74bbedfe812d93fef9cb20d28" translate="yes" xml:space="preserve">
          <source>There are really two flavors of function objects: built-in functions and user-defined functions. Both support the same operation (to call the function), but the implementation is different, hence the different object types.</source>
          <target state="translated">내장 함수와 사용자 정의 함수라는 두 가지 기능 개체가 있습니다. 둘 다 동일한 함수 (함수 호출)를 지원하지만 구현 방식이 다르므로 객체 유형이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c6e44b629dc613ba239924b475b903b7f82838d4" translate="yes" xml:space="preserve">
          <source>There are several equivalent ways to specify IP network masks. A &lt;em&gt;prefix&lt;/em&gt;&lt;code&gt;/&amp;lt;nbits&amp;gt;&lt;/code&gt; is a notation that denotes how many high-order bits are set in the network mask. A &lt;em&gt;net mask&lt;/em&gt; is an IP address with some number of high-order bits set. Thus the prefix &lt;code&gt;/24&lt;/code&gt; is equivalent to the net mask &lt;code&gt;255.255.255.0&lt;/code&gt; in IPv4, or &lt;code&gt;ffff:ff00::&lt;/code&gt; in IPv6. In addition, a &lt;em&gt;host mask&lt;/em&gt; is the logical inverse of a &lt;em&gt;net mask&lt;/em&gt;, and is sometimes used (for example in Cisco access control lists) to denote a network mask. The host mask equivalent to &lt;code&gt;/24&lt;/code&gt; in IPv4 is &lt;code&gt;0.0.0.255&lt;/code&gt;.</source>
          <target state="translated">IP 네트워크 마스크를 지정하는 몇 가지 동등한 방법이 있습니다. &lt;em&gt;접두어 &lt;/em&gt; &lt;code&gt;/&amp;lt;nbits&amp;gt;&lt;/code&gt; 인 것을 나타내고 표기 많은 상위 비트가 네트워크 마스크 설정 방법. &lt;em&gt;네트 마스크&lt;/em&gt; 설정 상위 일부 비트 번호와 IP 주소이다. 따라서 접두사 &lt;code&gt;/24&lt;/code&gt; 는 IPv4 의 네트 마스크 &lt;code&gt;255.255.255.0&lt;/code&gt; 또는 IPv6의 &lt;code&gt;ffff:ff00::&lt;/code&gt; 와 같습니다 . 또한 &lt;em&gt;호스트 마스크&lt;/em&gt; 는 &lt;em&gt;네트 마스크&lt;/em&gt; 의 논리적 역수이며 네트워크 마스크를 나타내는 데 (예 : Cisco 액세스 제어 목록에서) 사용되기도합니다. IPv4에서 &lt;code&gt;/24&lt;/code&gt; 에 해당하는 호스트 마스크 는 &lt;code&gt;0.0.0.255&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3033320704915eae39fe9125e77acd8933f72624" translate="yes" xml:space="preserve">
          <source>There are several ways to enable asyncio debug mode:</source>
          <target state="translated">asyncio 디버그 모드를 활성화하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3b8d5ccd917cf795ff7b17c62847945d840d34" translate="yes" xml:space="preserve">
          <source>There are several ways to load shared libraries into the Python process. One way is to instantiate one of the following classes:</source>
          <target state="translated">공유 라이브러리를 Python 프로세스에로드하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 다음 클래스 중 하나를 인스턴스화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3558a0588ae9ae9394f53aa612b4c8aa871ac418" translate="yes" xml:space="preserve">
          <source>There are some edges in &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; where you might expect something other than what actually happens.</source>
          <target state="translated">&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 에는 실제로 발생하는 것 이외의 것을 기대할 수있는 몇 가지 모서리 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="672b298f2b28f05dcbc4d251f921b55fca7bb3d1" translate="yes" xml:space="preserve">
          <source>There are some limitations to the process of bundling your application into a single file. In most, if not all, cases they can be addressed without needing major changes to your application.</source>
          <target state="translated">응용 프로그램을 단일 파일로 묶는 프로세스에는 몇 가지 제한이 있습니다. 전부는 아니더라도 대부분의 경우 응용 프로그램을 크게 변경하지 않고도 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8efcbf8ecf4671c1e1fcda5c45fbcf4a0ffec20" translate="yes" xml:space="preserve">
          <source>There are some more variants of the tar format which can be read, but not created:</source>
          <target state="translated">읽을 수는 있지만 만들 수없는 tar 형식의 변형이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="14e72aad41ffed86193f1ed0cab701906fad72ac" translate="yes" xml:space="preserve">
          <source>There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator &lt;code&gt;%&lt;/code&gt; is applied to Decimal objects, the sign of the result is the sign of the &lt;em&gt;dividend&lt;/em&gt; rather than the sign of the divisor:</source>
          <target state="translated">Decimal 객체의 산술과 ​​정수 및 부동 소수점의 산술에는 약간의 차이가 있습니다. 나머지 연산자 &lt;code&gt;%&lt;/code&gt; 가 Decimal 객체에 적용되면 결과 의 부호는 제수의 부호가 아닌 &lt;em&gt;배당&lt;/em&gt; 의 부호입니다.</target>
        </trans-unit>
        <trans-unit id="b9b322cbdf6ae8c9c74fcf1ab35d16b9dd8646b3" translate="yes" xml:space="preserve">
          <source>There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of &lt;a href=&quot;#binaryseq&quot;&gt;binary data&lt;/a&gt; and &lt;a href=&quot;#textseq&quot;&gt;text strings&lt;/a&gt; are described in dedicated sections.</source>
          <target state="translated">기본 시퀀스 유형에는 목록, 튜플 및 범위 객체의 세 가지가 있습니다. &lt;a href=&quot;#binaryseq&quot;&gt;이진 데이터&lt;/a&gt; 및 &lt;a href=&quot;#textseq&quot;&gt;텍스트 문자열&lt;/a&gt; 처리에 적합한 추가 시퀀스 유형 은 전용 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b817f8bcc6d4362e55e4611c3d0e8efda6956674" translate="yes" xml:space="preserve">
          <source>There are three different ways to call this function:</source>
          <target state="translated">이 함수를 호출하는 방법에는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b0c875a78b7f62cbc06fe3fdf0cb3be83425f3f" translate="yes" xml:space="preserve">
          <source>There are three distinct numeric types: &lt;em&gt;integers&lt;/em&gt;, &lt;em&gt;floating point numbers&lt;/em&gt;, and &lt;em&gt;complex numbers&lt;/em&gt;. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating point numbers are usually implemented using &lt;code&gt;double&lt;/code&gt; in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in &lt;a href=&quot;sys#sys.float_info&quot;&gt;&lt;code&gt;sys.float_info&lt;/code&gt;&lt;/a&gt;. Complex numbers have a real and imaginary part, which are each a floating point number. To extract these parts from a complex number &lt;em&gt;z&lt;/em&gt;, use &lt;code&gt;z.real&lt;/code&gt; and &lt;code&gt;z.imag&lt;/code&gt;. (The standard library includes the additional numeric types &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt;, for rationals, and &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt;, for floating-point numbers with user-definable precision.)</source>
          <target state="translated">&lt;em&gt;정수&lt;/em&gt; , &lt;em&gt;부동 소수점 수&lt;/em&gt; 및 &lt;em&gt;복소수의&lt;/em&gt; 세 가지 고유 한 숫자 유형이 &lt;em&gt;있습니다&lt;/em&gt; . 또한 부울은 정수의 하위 유형입니다. 정수는 무제한 정밀도를 갖습니다. 부동 소수점 숫자는 일반적으로 C에서 &lt;code&gt;double&lt;/code&gt; 을 사용하여 구현됩니다 . 프로그램이 실행중인 머신의 부동 소수점 숫자의 정밀도 및 내부 표현에 대한 정보는 &lt;a href=&quot;sys#sys.float_info&quot;&gt; &lt;code&gt;sys.float_info&lt;/code&gt; 에&lt;/a&gt; 있습니다. 복소수에는 실수 부와 허수 부가 있으며, 각각 부동 소수점입니다. 복소수에서 이러한 부분을 추출 &lt;em&gt;Z&lt;/em&gt; 사용 &lt;code&gt;z.real&lt;/code&gt; 및 &lt;code&gt;z.imag&lt;/code&gt; . (표준 라이브러리에는 추가 숫자 유형이 포함됩니다&lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt; , rationals 및&lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; , 사용자 정의 가능 정밀도를 갖는 부동 소수점 숫자)</target>
        </trans-unit>
        <trans-unit id="333c521b638ab05e83b6cf3986fc6b02269383b6" translate="yes" xml:space="preserve">
          <source>There are three keyword arguments in &lt;em&gt;kwargs&lt;/em&gt; which are inspected: &lt;em&gt;exc_info&lt;/em&gt; which, if it does not evaluate as false, causes exception information to be added to the logging message. If an exception tuple (in the format returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;) or an exception instance is provided, it is used; otherwise, &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt; is called to get the exception information.</source>
          <target state="translated">&lt;em&gt;kwargs&lt;/em&gt; 에는 3 개의 키워드 인수가 있습니다 . &lt;em&gt;exc_info&lt;/em&gt; 는 false로 평가되지 않으면 예외 정보가 로깅 메시지에 추가됩니다. 예외 튜플 ( &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 반환 한 형식 ) 또는 예외 인스턴스가 제공되면 사용됩니다. 그렇지 않으면 예외 정보를 얻기 위해 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d04821ea3634b3338603d35f9ecfca678dbd808" translate="yes" xml:space="preserve">
          <source>There are three main types of &lt;em&gt;awaitable&lt;/em&gt; objects: &lt;strong&gt;coroutines&lt;/strong&gt;, &lt;strong&gt;Tasks&lt;/strong&gt;, and &lt;strong&gt;Futures&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;대기 가능한&lt;/em&gt; 객체에는 &lt;strong&gt;코 루틴&lt;/strong&gt; , &lt;strong&gt;작업&lt;/strong&gt; 및 &lt;strong&gt;미래&lt;/strong&gt; 의 세 가지 주요 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe52cdc5c5e174e3a2732474be4c6eb0d0cd83e" translate="yes" xml:space="preserve">
          <source>There are three tar formats that can be created with the &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈로 작성할 수있는 tar 형식에는 세 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f8a6f9ebe421ba57fcfb4b59357400f94e96a60" translate="yes" xml:space="preserve">
          <source>There are times where a configuration needs to refer to objects external to the configuration, for example &lt;code&gt;sys.stderr&lt;/code&gt;. If the configuration dict is constructed using Python code, this is straightforward, but a problem arises when the configuration is provided via a text file (e.g. JSON, YAML). In a text file, there is no standard way to distinguish &lt;code&gt;sys.stderr&lt;/code&gt; from the literal string &lt;code&gt;'sys.stderr'&lt;/code&gt;. To facilitate this distinction, the configuration system looks for certain special prefixes in string values and treat them specially. For example, if the literal string &lt;code&gt;'ext://sys.stderr'&lt;/code&gt; is provided as a value in the configuration, then the &lt;code&gt;ext://&lt;/code&gt; will be stripped off and the remainder of the value processed using normal import mechanisms.</source>
          <target state="translated">구성이 구성 외부의 오브젝트를 참조해야하는 경우가 있습니다 (예 : &lt;code&gt;sys.stderr&lt;/code&gt; ) . 구성 코드가 Python 코드를 사용하여 구성된 경우 이는 간단하지만 구성이 텍스트 파일 (예 : JSON, YAML)을 통해 제공 될 때 문제가 발생합니다. 텍스트 파일에는 &lt;code&gt;sys.stderr&lt;/code&gt; 을 리터럴 문자열 &lt;code&gt;'sys.stderr'&lt;/code&gt; 과 구별하는 표준 방법이 없습니다 . 이 구별을 용이하게하기 위해 구성 시스템은 문자열 값에서 특정 특수 접 두부를 찾고 특수하게 처리합니다. 예를 들어, 리터럴 문자열 &lt;code&gt;'ext://sys.stderr'&lt;/code&gt; 이 구성에서 값으로 제공되는 경우 &lt;code&gt;ext://&lt;/code&gt; 가 제거되고 나머지 값은 일반 가져 오기 메커니즘을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b952a5fd1b6e29bf7f14c99f1285b4bf5b966ccf" translate="yes" xml:space="preserve">
          <source>There are two &lt;code&gt;MagicMock&lt;/code&gt; variants: &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.NonCallableMagicMock&quot;&gt;&lt;code&gt;NonCallableMagicMock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 가지가 있습니다 &lt;code&gt;MagicMock&lt;/code&gt; 가 : 변형 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.NonCallableMagicMock&quot;&gt; &lt;code&gt;NonCallableMagicMock&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1e5423c30972002ca80c24e40aa5624a40bd0af" translate="yes" xml:space="preserve">
          <source>There are two common ways to use this function. In both approaches, you use the fd to wake up when a signal arrives, but then they differ in how they determine &lt;em&gt;which&lt;/em&gt; signal or signals have arrived.</source>
          <target state="translated">이 기능을 사용하는 일반적인 두 가지 방법이 있습니다. 두 방법 모두 fd를 사용하여 신호가 도착하면 깨어나지 만 도착한 신호를 결정 &lt;em&gt;하는&lt;/em&gt; 방법이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9a9936ddf454d83f25fcc05dfb55a4648a3db888" translate="yes" xml:space="preserve">
          <source>There are two exceptions that may be raised by &lt;a href=&quot;#doctest.DebugRunner&quot;&gt;&lt;code&gt;DebugRunner&lt;/code&gt;&lt;/a&gt; instances:</source>
          <target state="translated">&lt;a href=&quot;#doctest.DebugRunner&quot;&gt; &lt;code&gt;DebugRunner&lt;/code&gt; &lt;/a&gt; 인스턴스에서 발생할 수있는 두 가지 예외가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d6e02d2cfc3072839fb97bd9bedd2f8db9ebdbd" translate="yes" xml:space="preserve">
          <source>There are two interfaces provided by this module. The modern interface supports encoding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; to ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, and decoding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; or strings containing ASCII to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Both base-64 alphabets defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548&lt;/strong&gt;&lt;/a&gt; (normal, and URL- and filesystem-safe) are supported.</source>
          <target state="translated">이 모듈은 두 가지 인터페이스를 제공합니다. 최신 인터페이스는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 를 ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 인코딩 하고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 또는 ASCII를 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 포함하는 문자열의 디코딩 을 지원 합니다 . &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548에&lt;/strong&gt;&lt;/a&gt; 정의 된 기본 64 자 (일반 및 URL 및 파일 시스템 안전)가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fa8ad7fa0c084245a8ddab7ad38f2502a86776e1" translate="yes" xml:space="preserve">
          <source>There are two main functions for creating &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; instances from text files and modules with doctests:</source>
          <target state="translated">텍스트 파일 및 doctest가있는 모듈에서 &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스 를 작성하는 주요 기능은 두 가지입니다 .</target>
        </trans-unit>
        <trans-unit id="e0fdb9b9b06f75f219fccefe4c88b64af94e44fb" translate="yes" xml:space="preserve">
          <source>There are two optional keyword-only arguments. The &lt;em&gt;key&lt;/em&gt; argument specifies a one-argument ordering function like that used for &lt;a href=&quot;stdtypes#list.sort&quot;&gt;&lt;code&gt;list.sort()&lt;/code&gt;&lt;/a&gt;. The &lt;em&gt;default&lt;/em&gt; argument specifies an object to return if the provided iterable is empty. If the iterable is empty and &lt;em&gt;default&lt;/em&gt; is not provided, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">두 개의 선택적 키워드 전용 인수가 있습니다. &lt;em&gt;키&lt;/em&gt; 인수 한 인수 순서화 기능에 사용되는 것과 같이 지정 &lt;a href=&quot;stdtypes#list.sort&quot;&gt; &lt;code&gt;list.sort()&lt;/code&gt; &lt;/a&gt; . &lt;em&gt;기본&lt;/em&gt; (가) 반복자가 비어 제공하는 경우 인수 지정은 객체가 돌아갑니다. iterable이 비어 있고 &lt;em&gt;기본값&lt;/em&gt; 이 제공되지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40e73167bc2dd539e8cb18681323426ef95edb7e" translate="yes" xml:space="preserve">
          <source>There are two parts to this job:</source>
          <target state="translated">이 작업에는 두 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f617732163ef9ffd09291d0e0a3a8c64bfdd701" translate="yes" xml:space="preserve">
          <source>There are two stages in warning control: first, each time a warning is issued, a determination is made whether a message should be issued or not; next, if a message is to be issued, it is formatted and printed using a user-settable hook.</source>
          <target state="translated">경고 제어에는 두 가지 단계가 있습니다. 첫째, 경고가 발행 될 때마다 메시지의 발행 여부가 결정됩니다. 다음으로, 메시지가 발행 될 경우, 사용자 설정 가능 후크를 사용하여 형식화되고 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="bcfdafc8223a5b68a92a7d9394d696f0c5a9a642" translate="yes" xml:space="preserve">
          <source>There are two typical use cases for &lt;em&gt;super&lt;/em&gt;. In a class hierarchy with single inheritance, &lt;em&gt;super&lt;/em&gt; can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of &lt;em&gt;super&lt;/em&gt; in other programming languages.</source>
          <target state="translated">&lt;em&gt;super의&lt;/em&gt; 일반적인 사용 사례는 두 가지 입니다. 단일 상속이있는 클래스 계층 구조에서 &lt;em&gt;super&lt;/em&gt; 를 사용하면 명시 적으로 이름을 지정하지 않고 부모 클래스를 참조 할 수 있으므로 코드를 유지 관리하기가 더 쉽습니다. 이 사용 은 다른 프로그래밍 언어에서 의 &lt;em&gt;super&lt;/em&gt; 사용과 밀접한 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00afd891065ebece62243a2dd46e14fbe49e11f8" translate="yes" xml:space="preserve">
          <source>There are two ways to enable the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module to adapt a custom Python type to one of the supported ones.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈이 사용자 정의 파이썬 유형을 지원되는 유형 중 하나에 적용 할 수 있도록하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0dd5354b3d81e371357acf3a005a58e85ee468a" translate="yes" xml:space="preserve">
          <source>There are various server methods that can be overridden by subclasses of base server classes like &lt;a href=&quot;#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt;; these methods aren&amp;rsquo;t useful to external users of the server object.</source>
          <target state="translated">&lt;a href=&quot;#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt; 와 같은 기본 서버 클래스의 서브 클래스로 대체 할 수있는 다양한 서버 메소드가 있습니다 . 이러한 메소드는 서버 오브젝트의 외부 사용자에게는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b102f0e1bd4efb4a95d03bb36b1a10aab39e47d" translate="yes" xml:space="preserve">
          <source>There are, however, enough ways to crash Python with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;, so you should be careful anyway. The &lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt;&lt;code&gt;faulthandler&lt;/code&gt;&lt;/a&gt; module can be helpful in debugging crashes (e.g. from segmentation faults produced by erroneous C library calls).</source>
          <target state="translated">그러나 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 로 Python을 크래시하는 충분한 방법이 있으므로 어쨌든 조심해야합니다. &lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt; &lt;code&gt;faulthandler&lt;/code&gt; &lt;/a&gt; 모듈 충돌 디버깅하는데 도움이 될 수있다 (예를 들어 잘못된 C 라이브러리 호출에 의해 생성 세그멘테이션 오류부터).</target>
        </trans-unit>
        <trans-unit id="60e879387c2e07da69183eca12d6268a65a716b3" translate="yes" xml:space="preserve">
          <source>There are, of course, more possible ABCs for numbers, and this would be a poor hierarchy if it precluded the possibility of adding those. You can add &lt;code&gt;MyFoo&lt;/code&gt; between &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numbers.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; with:</source>
          <target state="translated">물론 숫자에 대해 더 많은 ABC가있을 수 있으며이를 추가 할 수없는 경우 계층 구조가 좋지 않습니다. &lt;code&gt;MyFoo&lt;/code&gt; 하여 &lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#numbers.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 사이 에 MyFoo 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e142c652134bf8d6bf541d434c33320b8252989" translate="yes" xml:space="preserve">
          <source>There can be a &lt;code&gt;turtle.cfg&lt;/code&gt; file in the directory where &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; is stored and an additional one in the current working directory. The latter will override the settings of the first one.</source>
          <target state="translated">&lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 이 저장된 디렉토리에 &lt;code&gt;turtle.cfg&lt;/code&gt; 파일 이 있고 현재 작업 디렉토리에 추가 파일 이있을 수 있습니다 . 후자는 첫 번째 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1a4413a268d4ebd32ee4dba0e329af575a824d1b" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;main thread&amp;rdquo; object; this corresponds to the initial thread of control in the Python program. It is not a daemon thread.</source>
          <target state="translated">&quot;주 스레드&quot;개체가 있습니다. 이것은 파이썬 프로그램의 초기 제어 스레드에 해당합니다. 데몬 스레드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1e29d6e10b2c6956c33cb943f01fb5492ba9c5d5" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; flag to set, in order to prevent this, &lt;code&gt;socket.SO_REUSEADDR&lt;/code&gt;:</source>
          <target state="translated">이를 방지하기 위해 설정 하는 &lt;a href=&quot;#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 플래그가 있습니다. &lt;code&gt;socket.SO_REUSEADDR&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e47e83e62ae2ee4ea0b5b657d1278fc1527f7e36" translate="yes" xml:space="preserve">
          <source>There is a backport of &lt;a href=&quot;#module-unittest.mock&quot;&gt;&lt;code&gt;unittest.mock&lt;/code&gt;&lt;/a&gt; for earlier versions of Python, available as &lt;a href=&quot;https://pypi.org/project/mock&quot;&gt;mock on PyPI&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/mock&quot;&gt;PyPI에서 mock으로&lt;/a&gt; 사용할 수있는 이전 버전의 Python에 대한 &lt;a href=&quot;#module-unittest.mock&quot;&gt; &lt;code&gt;unittest.mock&lt;/code&gt; &lt;/a&gt; 의 백 포트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab37ed1de9956ad2db535992c1cb4eab9ce74122" translate="yes" xml:space="preserve">
          <source>There is a certain baseline overhead associated with executing a pass statement. The code here doesn&amp;rsquo;t try to hide it, but you should be aware of it. The baseline overhead can be measured by invoking the program without arguments, and it might differ between Python versions.</source>
          <target state="translated">pass 문 실행과 관련된 특정 기준 오버 헤드가 있습니다. 여기 코드는 숨기려고하지 않지만 알고 있어야합니다. 기본 오버 헤드는 인수없이 프로그램을 호출하여 측정 할 수 있으며 Python 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="482dc1fc316fb8aa025fb46e7933e55a2e4fe842" translate="yes" xml:space="preserve">
          <source>There is a default policy used by all classes in the email package. For all of the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; classes and the related convenience functions, and for the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; class, this is the &lt;a href=&quot;#email.policy.Compat32&quot;&gt;&lt;code&gt;Compat32&lt;/code&gt;&lt;/a&gt; policy, via its corresponding pre-defined instance &lt;a href=&quot;#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt;. This policy provides for complete backward compatibility (in some cases, including bug compatibility) with the pre-Python3.3 version of the email package.</source>
          <target state="translated">이메일 패키지의 모든 클래스에서 사용되는 기본 정책이 있습니다. 모든 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 클래스 및 관련 편의 기능 및 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 클래스의 경우, 해당 사전 정의 된 인스턴스 &lt;a href=&quot;#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; 를 통한 &lt;a href=&quot;#email.policy.Compat32&quot;&gt; &lt;code&gt;Compat32&lt;/code&gt; &lt;/a&gt; 정책 입니다. 이 정책은 Python3.3 이전 버전의 전자 메일 패키지와 완전한 역 호환성 (일부 경우 버그 호환성 포함)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55d1a9e95df13365d139013a6923e69a48124ab1" translate="yes" xml:space="preserve">
          <source>There is a more aggressive version of both &lt;em&gt;spec&lt;/em&gt; and &lt;em&gt;autospec&lt;/em&gt; that &lt;em&gt;does&lt;/em&gt; prevent you setting non-existent attributes. This is useful if you want to ensure your code only &lt;em&gt;sets&lt;/em&gt; valid attributes too, but obviously it prevents this particular scenario:</source>
          <target state="translated">모두의보다 적극적인 버전이 &lt;em&gt;사양&lt;/em&gt; 및 &lt;em&gt;autospec &lt;/em&gt;&lt;em&gt;않는&lt;/em&gt; 존재하지 않는 속성을 설정하지 못하도록은. 이것은 코드 &lt;em&gt;가&lt;/em&gt; 유효한 속성 만 &lt;em&gt;설정&lt;/em&gt; 하도록하려는 경우에 유용 하지만 분명히이 특정 시나리오를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1beb9533846807b3cddb163730145908edcba46e" translate="yes" xml:space="preserve">
          <source>There is a tiny performance penalty when using &lt;code&gt;frozen=True&lt;/code&gt;: &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; cannot use simple assignment to initialize fields, and must use &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;object.__setattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;frozen=True&lt;/code&gt; 사용시 성능이 약간 저하됩니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 은 간단한 할당을 사용하여 필드를 초기화 할 수 없으며 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;object.__setattr__()&lt;/code&gt; &lt;/a&gt; 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="45b27f43395afb40755c882e8f8377026ef5693d" translate="yes" xml:space="preserve">
          <source>There is a utility to create a dictionary the keys of which are the method names and the values of which are the docstrings of the public methods of the classes Screen and Turtle.</source>
          <target state="translated">키가 메소드 이름이고 값이 Screen 및 Turtle 클래스의 공용 메소드의 docstring 인 사전을 작성하는 유틸리티가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7eae78a69e9371dbae0111468f3b5d1fc309bfa" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt;&lt;code&gt;patch.dict()&lt;/code&gt;&lt;/a&gt; for setting values in a dictionary just during a scope and restoring the dictionary to its original state when the test ends:</source>
          <target state="translated">또한 스코프 도중 사전에 값을 설정하고 테스트가 끝나면 사전을 원래 상태로 복원하기위한 &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt; &lt;code&gt;patch.dict()&lt;/code&gt; &lt;/a&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e684d0160793e96041b51aa12fbbadc464d12889" translate="yes" xml:space="preserve">
          <source>There is also a command line shortcut for running &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt;. You can instruct the Python interpreter to run the doctest module directly from the standard library and pass the file name(s) on the command line:</source>
          <target state="translated">&lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 실행을위한 명령 줄 단축키도 있습니다 . Python 인터프리터가 표준 라이브러리에서 직접 doctest 모듈을 실행하고 명령 행에서 파일 이름을 전달하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d111a6794d7726b882e407d115339caecd4e6077" translate="yes" xml:space="preserve">
          <source>There is also a command line shortcut for running &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;. You can instruct the Python interpreter to run the doctest module directly from the standard library and pass the module name(s) on the command line:</source>
          <target state="translated">&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 를 실행하기위한 명령 줄 바로 가기도 있습니다 . Python 인터프리터가 표준 라이브러리에서 직접 doctest 모듈을 실행하고 명령 행에서 모듈 이름을 전달하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d79a9d980254c0558deebdb3ff6a0c81b5f4f60f" translate="yes" xml:space="preserve">
          <source>There is also a module-level convenience function:</source>
          <target state="translated">모듈 수준의 편의 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb180552aa6e02363503fb5c4bb76b55eebe73da" translate="yes" xml:space="preserve">
          <source>There is also a way to register new option flag names, though this isn&amp;rsquo;t useful unless you intend to extend &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; internals via subclassing:</source>
          <target state="translated">새로운 옵션 플래그 이름을 등록하는 방법도 있지만 서브 클래 싱을 통해 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 내부를 확장하지 않는 한 유용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2907b710c13ff58245f3fab419cf0626710f8bc4" translate="yes" xml:space="preserve">
          <source>There is also no mutable string type, but &lt;a href=&quot;#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; can be used to efficiently construct strings from multiple fragments.</source>
          <target state="translated">또한 변경 가능한 문자열 유형은 없지만 &lt;a href=&quot;#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 를 사용하여 여러 조각에서 문자열을 효율적으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67e4f42d4de885a7414466b8f08bd4f8bc181d8" translate="yes" xml:space="preserve">
          <source>There is always a 1:1 relationship between transport and protocol objects: the protocol calls transport methods to send data, while the transport calls protocol methods to pass it data that has been received.</source>
          <target state="translated">전송과 프로토콜 개체 간에는 항상 1 : 1 관계가 있습니다. 프로토콜은 데이터를 전송하기 위해 전송 메서드를 호출하고 전송은 수신 된 데이터를 전달하기 위해 프로토콜 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3e56625ac1cadac7545d7b1c51dea55a42570abf" translate="yes" xml:space="preserve">
          <source>There is an additional mode character permitted, &lt;code&gt;'U'&lt;/code&gt;, which no longer has any effect, and is considered deprecated. It previously enabled &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; in text mode, which became the default behaviour in Python 3.0. Refer to the documentation of the &lt;a href=&quot;#open-newline-parameter&quot;&gt;newline&lt;/a&gt; parameter for further details.</source>
          <target state="translated">추가 모드 문자 &lt;code&gt;'U'&lt;/code&gt; 가 더 이상 적용되지 않으며 더 이상 사용되지 않으며 더 이상 사용되지 않는 것으로 간주됩니다. 이전 에는 텍스트 모드에서 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용 줄 바꿈&lt;/a&gt; 을 사용 하여 Python 3.0에서 기본 동작이되었습니다. 자세한 내용 은 &lt;a href=&quot;#open-newline-parameter&quot;&gt;개행&lt;/a&gt; 매개 변수 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="935265d6d70dd5bf2f00c18ebafbd01ee2301fae" translate="yes" xml:space="preserve">
          <source>There is an alternative, more powerful interface to the coder and decoder, see the source for details.</source>
          <target state="translated">코더 및 디코더에 대한보다 강력한 대안 인터페이스가 있습니다. 자세한 내용은 소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74c4518e8428116ce41d38c6760bba0be948a71b" translate="yes" xml:space="preserve">
          <source>There is an obsolete function &lt;code&gt;warn&lt;/code&gt; which is functionally identical to &lt;code&gt;warning&lt;/code&gt;. As &lt;code&gt;warn&lt;/code&gt; is deprecated, please do not use it - use &lt;code&gt;warning&lt;/code&gt; instead.</source>
          <target state="translated">노후된 기능 &lt;code&gt;warn&lt;/code&gt; 가 있으며 기능적으로 &lt;code&gt;warning&lt;/code&gt; 동일합니다 . 로 &lt;code&gt;warn&lt;/code&gt; 되지 않습니다, 그것을 사용하지 마십시오 - 사용 &lt;code&gt;warning&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="c9565a2b6830f7e297c9c91221ecf38feac62a37" translate="yes" xml:space="preserve">
          <source>There is an obsolete method &lt;code&gt;warn&lt;/code&gt; which is functionally identical to &lt;code&gt;warning&lt;/code&gt;. As &lt;code&gt;warn&lt;/code&gt; is deprecated, please do not use it - use &lt;code&gt;warning&lt;/code&gt; instead.</source>
          <target state="translated">기능적으로 &lt;code&gt;warning&lt;/code&gt; 과 동일한 사용되지 않는 &lt;code&gt;warn&lt;/code&gt; 방법 이 있습니다 . 로 &lt;code&gt;warn&lt;/code&gt; 되지 않습니다, 그것을 사용하지 마십시오 - 사용 &lt;code&gt;warning&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="a894765372946cbd728f24442f80a275c531295d" translate="yes" xml:space="preserve">
          <source>There is data to read</source>
          <target state="translated">읽을 데이터가 있습니다</target>
        </trans-unit>
        <trans-unit id="e75c6cbe07532d2502dde4b485373249588d95da" translate="yes" xml:space="preserve">
          <source>There is less temptation to change test code to fit the code it tests without a good reason.</source>
          <target state="translated">적절한 이유없이 테스트 코드를 변경하기 위해 테스트 코드를 변경하려는 유혹이 적습니다.</target>
        </trans-unit>
        <trans-unit id="4bd88caba77eb2e0f96b475391a639aa16965d22" translate="yes" xml:space="preserve">
          <source>There is no &lt;em&gt;do_handshake_on_connect&lt;/em&gt; machinery. You must always manually call &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;do_handshake()&lt;/code&gt;&lt;/a&gt; to start the handshake.</source>
          <target state="translated">&lt;em&gt;do_handshake_on_connect&lt;/em&gt; 기계 는 없습니다 . 핸드 셰이크를 시작 하려면 항상 수동으로 &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;do_handshake()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="17646ebf84b2cc6d3d2aa087f8fe20aa0ea84904" translate="yes" xml:space="preserve">
          <source>There is no command-line option to control the optimization level used by the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function, because the Python interpreter itself already provides the option: &lt;strong&gt;python -O -m compileall&lt;/strong&gt;.</source>
          <target state="translated">파이썬 인터프리터 자체가 이미 &lt;strong&gt;python -O -m compileall&lt;/strong&gt; 옵션을 제공하기 때문에 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 함수가 사용하는 최적화 레벨을 제어하는 ​​명령 행 옵션이 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a339402e2c08e68357d4607ca200a87f81869499" translate="yes" xml:space="preserve">
          <source>There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor:</source>
          <target state="translated">bytearray 객체에 대한 전용 리터럴 구문은 없지만 생성자를 호출하여 항상 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ab1e290a57c9a8c7c0ca47e3789793780590484a" translate="yes" xml:space="preserve">
          <source>There is no default implementation</source>
          <target state="translated">기본 구현이 없습니다</target>
        </trans-unit>
        <trans-unit id="4cfcfdb7a55717a78c7053ebb53cb164835e6d05" translate="yes" xml:space="preserve">
          <source>There is no handling of &lt;em&gt;suppress_ragged_eofs&lt;/em&gt;. All end-of-file conditions that are in violation of the protocol are reported via the &lt;a href=&quot;#ssl.SSLEOFError&quot;&gt;&lt;code&gt;SSLEOFError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;em&gt;suppress_ragged_eofs를&lt;/em&gt; 처리하지 않습니다 . 프로토콜을 위반 한 모든 파일 끝 조건은 &lt;a href=&quot;#ssl.SSLEOFError&quot;&gt; &lt;code&gt;SSLEOFError&lt;/code&gt; &lt;/a&gt; 예외 를 통해보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="354d47c9f2be30d4225e6edd3dac13f743ff4c56" translate="yes" xml:space="preserve">
          <source>There is no limitation for running subprocesses from different threads once the watcher is installed.</source>
          <target state="translated">감시자가 설치되면 다른 스레드에서 하위 프로세스를 실행하는 데 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="78052c50fd1ad0400209b2cf6aa7fbfab4c2eea6" translate="yes" xml:space="preserve">
          <source>There is no method to obtain the POSIX timestamp directly from a naive &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance representing UTC time. If your application uses this convention and your system timezone is not set to UTC, you can obtain the POSIX timestamp by supplying &lt;code&gt;tzinfo=timezone.utc&lt;/code&gt;:</source>
          <target state="translated">UTC 시간을 나타내는 순진한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 POSIX 타임 스탬프를 직접 얻는 방법은 없습니다 . 애플리케이션이이 규칙을 사용하고 시스템 시간대가 UTC로 설정되지 않은 경우 &lt;code&gt;tzinfo=timezone.utc&lt;/code&gt; 를 제공하여 POSIX 타임 스탬프를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ccc659c3dddb17a0d08925d775d9c79df47ca5e" translate="yes" xml:space="preserve">
          <source>There is no module-level &lt;code&gt;wrap_bio()&lt;/code&gt; call like there is for &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; is always created via an &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어떤 모듈 수준 없습니다 &lt;code&gt;wrap_bio()&lt;/code&gt; 에 대한이 같은 호출이 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; 는&lt;/a&gt; 항상을 통해 생성 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="979783c6e7664e6582aa3da703198e886d977840" translate="yes" xml:space="preserve">
          <source>There is no need to install the default policy manually. asyncio is configured to use the default policy automatically.</source>
          <target state="translated">기본 정책을 수동으로 설치할 필요가 없습니다. asyncio는 기본 정책을 자동으로 사용하도록 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84f726f27659d6fc6e9b60e5ca57b5dfa4b12f91" translate="yes" xml:space="preserve">
          <source>There is no noticeable overhead when handling a big number of children (&lt;em&gt;O(1)&lt;/em&gt; each time a child terminates), but stating a thread per process requires extra memory.</source>
          <target state="translated">많은 수의 자식 ( 자식이 종료 될 때마다 &lt;em&gt;O (1))을&lt;/em&gt; 처리 할 때 눈에 띄는 오버 헤드는 없지만 프로세스 당 스레드를 지정하려면 추가 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eb98ad1710a337cd30d3185a62ee9740d3de4bde" translate="yes" xml:space="preserve">
          <source>There is no noticeable overhead when handling a big number of children (&lt;em&gt;O(1)&lt;/em&gt; each time a child terminates).</source>
          <target state="translated">많은 수의 자식을 처리 할 때 눈에 띄는 오버 헤드가 없습니다 ( 자녀가 종료 할 때마다 &lt;em&gt;O (1)&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="7ea5b79c20fda2d876e2837855af83a60a9f3d1e" translate="yes" xml:space="preserve">
          <source>There is no requirement that &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instances be used to represent messages retrieved using &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instances. In some situations, the time and memory required to generate &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; representations might not be acceptable. For such situations, &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instances also offer string and file-like representations, and a custom message factory may be specified when a &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance is initialized.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 검색된 메시지를 나타 내기 위해 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용할 필요는 없습니다 . 경우에 따라 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 표현 을 생성하는 데 필요한 시간과 메모리 가 허용되지 않을 수 있습니다. 이러한 상황에서 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스는 문자열 및 파일과 유사한 표현을 제공하며 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스가 초기화 될 때 사용자 지정 메시지 팩토리를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3ae3451c579ac5b5dbb261bd25097c72e8278dd" translate="yes" xml:space="preserve">
          <source>There is no requirement that the tools in this module are used to create application archives - the module is a convenience, but archives in the above format created by any means are acceptable to Python.</source>
          <target state="translated">이 모듈의 도구를 사용하여 응용 프로그램 아카이브를 만들 필요는 없습니다.이 모듈은 편리하지만 위와 같은 형식의 아카이브는 Python에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f4cb2262ca8f74431c7529f7caba934501312915" translate="yes" xml:space="preserve">
          <source>There is no return value.</source>
          <target state="translated">반환 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6755c18f7a4a50204cd008eb3d1159aadb9e5a90" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 속성에 대한 런타임 검사는 없습니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59014a17300c50cea45a4a6358e449e5248694af" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 속성에 대한 런타임 검사는 없습니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93d266ba42289c7350fb4e3a1db7c80f501f09db" translate="yes" xml:space="preserve">
          <source>There is no syntax to indicate optional or keyword arguments; such function types are rarely used as callback types. &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; (literal ellipsis) can be used to type hint a callable taking any number of arguments and returning &lt;code&gt;ReturnType&lt;/code&gt;. A plain &lt;a href=&quot;#typing.Callable&quot;&gt;&lt;code&gt;Callable&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;code&gt;Callable[..., Any]&lt;/code&gt;, and in turn to &lt;a href=&quot;collections.abc#collections.abc.Callable&quot;&gt;&lt;code&gt;collections.abc.Callable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 또는 키워드 인수를 나타내는 구문은 없습니다. 이러한 함수 유형은 콜백 유형으로 거의 사용되지 않습니다. &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; (리터럴 줄임표)을 사용하여 여러 인수를 &lt;code&gt;ReturnType&lt;/code&gt; 반환하는 호출 가능 힌트를 입력 할 수 있습니다 . 일반 &lt;a href=&quot;#typing.Callable&quot;&gt; &lt;code&gt;Callable&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Callable[..., Any]&lt;/code&gt; 와 동일하며 &lt;a href=&quot;collections.abc#collections.abc.Callable&quot;&gt; &lt;code&gt;collections.abc.Callable&lt;/code&gt; 과 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b473b64f202d7735b92adfb4667a5ab7ed7dcc5" translate="yes" xml:space="preserve">
          <source>There is no way for CGI code to tell whether the option was set, so a separate handler class is provided. It is used in the same way as &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;, i.e., by calling &lt;code&gt;IISCGIHandler().run(app)&lt;/code&gt;, where &lt;code&gt;app&lt;/code&gt; is the WSGI application object you wish to invoke.</source>
          <target state="translated">CGI 코드가 옵션 설정 여부를 알 수있는 방법이 없으므로 별도의 핸들러 클래스가 제공됩니다. &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; 와 같은 방식으로 , 즉 &lt;code&gt;IISCGIHandler().run(app)&lt;/code&gt; 를 호출하여 사용됩니다. 여기서 &lt;code&gt;app&lt;/code&gt; 은 호출하려는 WSGI 응용 프로그램 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d0fe2afc95bd9dd12af3411b4ecc87fbcc97df95" translate="yes" xml:space="preserve">
          <source>There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of &lt;code&gt;'&amp;lt;'&lt;/code&gt; or &lt;code&gt;'&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">비원시 바이트 순서를 표시하는 방법은 없습니다 (강제 바이트 스와핑). &lt;code&gt;'&amp;lt;'&lt;/code&gt; 또는 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 중 적절한 선택을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d70cda3946eb643babc8c8abe059a00b30a0a0e3" translate="yes" xml:space="preserve">
          <source>There is no way to perform case conversions and character classifications according to the locale. For (Unicode) text strings these are done according to the character value only, while for byte strings, the conversions and classifications are done according to the ASCII value of the byte, and bytes whose high bit is set (i.e., non-ASCII bytes) are never converted or considered part of a character class such as letter or whitespace.</source>
          <target state="translated">로케일에 따라 대소 문자 변환 및 문자 분류를 수행 할 수있는 방법이 없습니다. (유니 코드) 텍스트 문자열의 경우 문자 값으로 만 수행되는 반면 바이트 문자열의 경우 바이트의 ASCII 값과 높은 비트가 설정된 바이트 (예 : 비 ASCII 바이트)에 따라 변환 및 분류가 수행됩니다. )는 문자 나 공백과 같은 문자 클래스의 일부로 변환되거나 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b9cc71dc4ff206cec212895ed53756aab2a7764" translate="yes" xml:space="preserve">
          <source>There is no way to say &amp;ldquo;python X.Y or later&amp;rdquo;, so be careful of using an exact version like &amp;ldquo;/usr/bin/env python3.4&amp;rdquo; as you will need to change your shebang line for users of Python 3.5, for example.</source>
          <target state="translated">&amp;ldquo;python XY or later&amp;rdquo;라고 말할 방법이 없으므로, 예를 들어&amp;ldquo;/ usr / bin / env python3.4&amp;rdquo;와 같은 정확한 버전을 사용하도록주의하십시오. 예를 들어 Python 3.5 사용자의 shebang 라인을 변경해야합니다. .</target>
        </trans-unit>
        <trans-unit id="d2369966e324eb7a0bb66ca53d7e0b8023f09ca6" translate="yes" xml:space="preserve">
          <source>There is no way to unregister a function.</source>
          <target state="translated">기능을 등록 취소 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3dd0e13bda3ae598cc30ece116faadf286e65f28" translate="yes" xml:space="preserve">
          <source>There is one class defined for each left-hand side symbol in the abstract grammar (for example, &lt;code&gt;ast.stmt&lt;/code&gt; or &lt;code&gt;ast.expr&lt;/code&gt;). In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees. For example, &lt;code&gt;ast.BinOp&lt;/code&gt; inherits from &lt;code&gt;ast.expr&lt;/code&gt;. For production rules with alternatives (aka &amp;ldquo;sums&amp;rdquo;), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.</source>
          <target state="translated">추상 문법의 각 왼쪽 기호에 대해 하나의 클래스가 정의되어 있습니다 (예 : &lt;code&gt;ast.stmt&lt;/code&gt; 또는 &lt;code&gt;ast.expr&lt;/code&gt; ). 또한 오른쪽에는 각 생성자에 대해 하나의 클래스가 정의되어 있습니다. 이 클래스는 왼쪽 트리의 클래스에서 상속됩니다. 예를 들어, &lt;code&gt;ast.BinOp&lt;/code&gt; 는 상속 &lt;code&gt;ast.expr&lt;/code&gt; . 대안 (일명&amp;ldquo;합계&amp;rdquo;)이있는 생산 규칙의 경우 왼쪽 클래스는 추상입니다. 특정 생성자 노드의 인스턴스 만 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="8aabd37fa9d78fbac35e4cc9ca691f0871edeeca" translate="yes" xml:space="preserve">
          <source>There is one classmethod to make a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance for a filesystem file:</source>
          <target state="translated">파일 시스템 파일 의 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스 를 만드는 클래스 방법이 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="0412fae0e9a520771b5fcb2cddecf67855d8aff1" translate="yes" xml:space="preserve">
          <source>There is one constructor method named for each type of &lt;em&gt;hash&lt;/em&gt;. All return a hash object with the same simple interface. For example: use &lt;code&gt;sha256()&lt;/code&gt; to create a SHA-256 hash object. You can now feed this object with &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; (normally &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) using the &lt;code&gt;update()&lt;/code&gt; method. At any point you can ask it for the &lt;em&gt;digest&lt;/em&gt; of the concatenation of the data fed to it so far using the &lt;code&gt;digest()&lt;/code&gt; or &lt;code&gt;hexdigest()&lt;/code&gt; methods.</source>
          <target state="translated">각 유형의 &lt;em&gt;해시&lt;/em&gt; 마다 이름이 지정된 생성자 메소드가 있습니다 . 모두 동일한 간단한 인터페이스로 해시 객체를 반환합니다. 예를 들면 다음과 같습니다. &lt;code&gt;sha256()&lt;/code&gt; 을 사용하여 SHA-256 해시 객체를 만듭니다. 이제 &lt;code&gt;update()&lt;/code&gt; 메소드를 사용 하여이 객체에 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; (일반적으로 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; )를 공급할 수 있습니다 . 언제든지 지금까지 &lt;code&gt;digest()&lt;/code&gt; 또는 &lt;code&gt;hexdigest()&lt;/code&gt; 메소드를 사용하여 지금까지 제공된 데이터의 연결 &lt;em&gt;요약&lt;/em&gt; 을 요청할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8120f8e5075cd93d0d190c702aaa96797cb5168" translate="yes" xml:space="preserve">
          <source>There is one more &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; method that a subclass may wish to override:</source>
          <target state="translated">서브 클래스가 재정의하고자하는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 메소드 가 하나 더 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fe629198154ae18d59378c3ddd10ff8afbe6fa19" translate="yes" xml:space="preserve">
          <source>There is really only one valid value for the &lt;em&gt;MIME-Version&lt;/em&gt; header, and that is &lt;code&gt;1.0&lt;/code&gt;. For future proofing, this header class supports other valid version numbers. If a version number has a valid value per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;, then the header object will have non-&lt;code&gt;None&lt;/code&gt; values for the following attributes:</source>
          <target state="translated">실제로 &lt;em&gt;MIME-Version&lt;/em&gt; 헤더 에는 유효한 값이 하나만 있으며 이는 &lt;code&gt;1.0&lt;/code&gt; 입니다. 향후 교정을 위해이 헤더 클래스는 다른 유효한 버전 번호를 지원합니다. 버전 번호가 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; 당 유효한 값 을 갖는 경우 헤더 오브젝트는 다음 속성에 대해 &lt;code&gt;None&lt;/code&gt; 이외의 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="453b4f6d9769fd9f210579ed35f0b45ec2a4f635" translate="yes" xml:space="preserve">
          <source>There is the possibility that &amp;ldquo;dummy thread objects&amp;rdquo; are created. These are thread objects corresponding to &amp;ldquo;alien threads&amp;rdquo;, which are threads of control started outside the threading module, such as directly from C code. Dummy thread objects have limited functionality; they are always considered alive and daemonic, and cannot be &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;ed. They are never deleted, since it is impossible to detect the termination of alien threads.</source>
          <target state="translated">&quot;더미 스레드 개체&quot;가 생성 될 수 있습니다. 이들은 &quot;외국 스레드&quot;에 해당하는 스레드 객체로, C 코드에서 직접 스레딩 모듈 외부에서 시작된 제어 스레드입니다. 더미 스레드 객체는 기능이 제한적입니다. 그것들은 항상 살아 있고 데몬으로 간주되며 &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 될 수 없습니다 . 외계인 스레드의 종료를 감지하는 것이 불가능하므로 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29a71b710bb3b88050806003b5991d9687cac929" translate="yes" xml:space="preserve">
          <source>There is urgent data to read</source>
          <target state="translated">읽을 긴급한 데이터가 있습니다</target>
        </trans-unit>
        <trans-unit id="268075deb39485d79f07bf18d036ea245830ce43" translate="yes" xml:space="preserve">
          <source>There should be a function to query whether a particular URL is in the cache.</source>
          <target state="translated">특정 URL이 캐시에 있는지 여부를 쿼리하는 기능이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e6e797c6f8f25641f56be38527a8196278af7bbb" translate="yes" xml:space="preserve">
          <source>There was an error parsing a text declaration in an external entity.</source>
          <target state="translated">외부 엔티티에서 텍스트 선언을 구문 분석하는 중에 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d17e4f0895a59fce0176b492223bf84fc53d1057" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a subclass for secure connections:</source>
          <target state="translated">안전한 연결을위한 서브 클래스도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="04529db9fc59784d175f6c070f6a41e39f0d9ba0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another encoding that is able to encoding the full range of Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two parts: marker bits (the most significant bits) and payload bits. The marker bits are a sequence of zero to four &lt;code&gt;1&lt;/code&gt; bits followed by a &lt;code&gt;0&lt;/code&gt; bit. Unicode characters are encoded like this (with x being payload bits, which when concatenated give the Unicode character):</source>
          <target state="translated">유니 코드 문자의 전체 범위를 UTF-8로 인코딩 할 수있는 또 다른 인코딩이 있습니다. UTF-8은 8 비트 인코딩으로, UTF-8에서 바이트 순서에 문제가 없음을 의미합니다. UTF-8 바이트 시퀀스의 각 바이트는 마커 비트 (가장 중요한 비트)와 페이로드 비트의 두 부분으로 구성됩니다. 마커 비트는 0에서 4까지의 &lt;code&gt;1&lt;/code&gt; 비트와 &lt;code&gt;0&lt;/code&gt; 비트 의 시퀀스입니다 . 유니 코드 문자는 다음과 같이 인코딩됩니다 (x는 페이로드 비트이며 연결된 경우 유니 코드 문자를 나타냄).</target>
        </trans-unit>
        <trans-unit id="0bacbeb7a867039aeb31684676f8649929ec6809" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another group of encodings (the so called charmap encodings) that choose a different subset of all Unicode code points and how these code points are mapped to the bytes &lt;code&gt;0x0&lt;/code&gt;&amp;ndash;&lt;code&gt;0xff&lt;/code&gt;. To see how this is done simply open e.g. &lt;code&gt;encodings/cp1252.py&lt;/code&gt; (which is an encoding that is used primarily on Windows). There&amp;rsquo;s a string constant with 256 characters that shows you which character is mapped to which byte value.</source>
          <target state="translated">모든 유니 코드 코드 포인트의 다른 서브 세트를 선택하고 이러한 코드 포인트가 바이트 &lt;code&gt;0x0&lt;/code&gt; &amp;ndash; &lt;code&gt;0xff&lt;/code&gt; 에 매핑되는 방식을 선택하는 또 다른 인코딩 그룹 (소위 charmap 인코딩)이 있습니다 . 이 작업을 수행하는 방법을 보려면 &lt;code&gt;encodings/cp1252.py&lt;/code&gt; (Windows에서 주로 사용되는 인코딩)를 간단히 엽니 다 . 어떤 문자가 어떤 바이트 값에 매핑되는지를 나타내는 256 개의 문자열 상수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17e73f60746e10f8033ef47e930f87715709ed8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no output! That&amp;rsquo;s normal, and it means all the examples worked. Pass &lt;code&gt;-v&lt;/code&gt; to the script, and &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; prints a detailed log of what it&amp;rsquo;s trying, and prints a summary at the end:</source>
          <target state="translated">출력이 없습니다! 그것은 정상이며 모든 예제가 작동했음을 의미합니다. 패스 &lt;code&gt;-v&lt;/code&gt; 스크립트에, 그리고 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; 가&lt;/a&gt; 인쇄가 노력하고 있는지에 대한 자세한 로그를, 그리고 마지막에 요약을 인쇄 :</target>
        </trans-unit>
        <trans-unit id="5107e764cbcf99be3db8a02a597dc9e0dfb5249e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one important rule: if you invoke an external program (via the &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;os.popen()&lt;/code&gt;&lt;/a&gt; functions. or others with similar functionality), make very sure you don&amp;rsquo;t pass arbitrary strings received from the client to the shell. This is a well-known security hole whereby clever hackers anywhere on the Web can exploit a gullible CGI script to invoke arbitrary shell commands. Even parts of the URL or field names cannot be trusted, since the request doesn&amp;rsquo;t have to come from your form!</source>
          <target state="translated">중요한 규칙이 하나 있습니다 : &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;os.popen()&lt;/code&gt; &lt;/a&gt; 함수 또는 유사한 기능을 가진 다른 프로그램을 통해 외부 프로그램을 호출하는 경우 클라이언트에서 수신 한 임의의 문자열을 전달하지 마십시오. 껍질. 이것은 잘 알려진 보안 허점으로, 웹의 어느 곳에서나 영리한 해커가 gullible CGI 스크립트를 사용하여 임의의 쉘 명령을 호출 할 수 있습니다. 요청은 양식에서 올 필요가 없으므로 URL 또는 필드 이름의 일부조차도 신뢰할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="465b85dd3cb1dcf881030f6e1facbd759bc882ac" translate="yes" xml:space="preserve">
          <source>Therefore it is probably best to only consider using &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate&lt;/code&gt;&lt;/a&gt; on processes which never use any shared resources.</source>
          <target state="translated">따라서 공유 리소스를 사용하지 않는 프로세스 에서만 &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6d7ac873aab905d0d19416bd5a2e507b4093a46a" translate="yes" xml:space="preserve">
          <source>Therefore, the appropriate way to read form data values was to always use the code which checks whether the obtained value is a single value or a list of values. That&amp;rsquo;s annoying and leads to less readable scripts.</source>
          <target state="translated">따라서 양식 데이터 값을 읽는 적절한 방법은 항상 얻은 값이 단일 값인지 또는 값 목록인지 확인하는 코드를 사용하는 것입니다. 그것은 성가 시며 읽기 어려운 스크립트로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="ee0e8bc4ddad651cd810b740467094854c86f22f" translate="yes" xml:space="preserve">
          <source>Therefore, the same rules apply as with &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;: The lock must be held when called and is re-acquired on return. The predicate is evaluated with the lock held.</source>
          <target state="translated">따라서 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 와 동일한 규칙이 적용됩니다 . 잠금은 호출 될 때 유지되어야하며 리턴시 다시 획득됩니다. 술어는 잠금을 보유한 상태로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7837e5032c97f9de99277b75a2524a30220ac2b0" translate="yes" xml:space="preserve">
          <source>Therefore, unless the connection object was produced using &lt;code&gt;Pipe()&lt;/code&gt; you should only use the &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.connection.Connection.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; methods after performing some sort of authentication. See &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;Authentication keys&lt;/a&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;Pipe()&lt;/code&gt; 를 사용하여 연결 오브젝트를 작성하지 않은 경우 일종의 인증을 수행 한 후에 &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#multiprocessing.connection.Connection.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 메소드 만 사용해야 합니다. &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;인증 키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96533ee7558cd28344275b7b6faa62d8e6b52b05" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;#socketserver.BaseRequestHandler&quot;&gt;&lt;code&gt;BaseRequestHandler&lt;/code&gt;&lt;/a&gt; subclasses override the &lt;a href=&quot;#socketserver.BaseRequestHandler.setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socketserver.BaseRequestHandler.finish&quot;&gt;&lt;code&gt;finish()&lt;/code&gt;&lt;/a&gt; methods, and provide &lt;code&gt;self.rfile&lt;/code&gt; and &lt;code&gt;self.wfile&lt;/code&gt; attributes. The &lt;code&gt;self.rfile&lt;/code&gt; and &lt;code&gt;self.wfile&lt;/code&gt; attributes can be read or written, respectively, to get the request data or return data to the client.</source>
          <target state="translated">이 &lt;a href=&quot;#socketserver.BaseRequestHandler&quot;&gt; &lt;code&gt;BaseRequestHandler&lt;/code&gt; &lt;/a&gt; 서브 클래스는 &lt;a href=&quot;#socketserver.BaseRequestHandler.setup&quot;&gt; &lt;code&gt;setup()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socketserver.BaseRequestHandler.finish&quot;&gt; &lt;code&gt;finish()&lt;/code&gt; &lt;/a&gt; 메소드를 &lt;code&gt;self.rfile&lt;/code&gt; 하고 &lt;code&gt;self.wfile&lt;/code&gt; 및 self.wfile 속성을 제공 합니다. &lt;code&gt;self.rfile&lt;/code&gt; 및 &lt;code&gt;self.wfile&lt;/code&gt; 속성은 읽기 또는 클라이언트에 요청 데이터 또는 반환 데이터를 얻기 위해 각각 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43420a1e7f2d338a26313b513562211f7c319bad" translate="yes" xml:space="preserve">
          <source>These ABCs allow us to ask classes or instances if they provide particular functionality, for example:</source>
          <target state="translated">이러한 ABC를 통해 클래스 나 인스턴스에 특정 기능을 제공하는지 문의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79eb154c9b38c333e433efadc74ad44c819279e7" translate="yes" xml:space="preserve">
          <source>These RFCs together define a protocol to support non-ASCII characters in domain names. A domain name containing non-ASCII characters (such as &lt;code&gt;www.Alliancefran&amp;ccedil;aise.nu&lt;/code&gt;) is converted into an ASCII-compatible encoding (ACE, such as &lt;code&gt;www.xn--alliancefranaise-npb.nu&lt;/code&gt;). The ACE form of the domain name is then used in all places where arbitrary characters are not allowed by the protocol, such as DNS queries, HTTP &lt;em&gt;Host&lt;/em&gt; fields, and so on. This conversion is carried out in the application; if possible invisible to the user: The application should transparently convert Unicode domain labels to IDNA on the wire, and convert back ACE labels to Unicode before presenting them to the user.</source>
          <target state="translated">이러한 RFC는 함께 도메인 이름에서 비 ASCII 문자를 지원하는 프로토콜을 정의합니다. 비 ASCII 문자를 포함하는 도메인 이름 (예 : &lt;code&gt;www.Alliancefran&amp;ccedil;aise.nu&lt;/code&gt; )은 ASCII 호환 인코딩 (ACE, 예 : &lt;code&gt;www.xn--alliancefranaise-npb.nu&lt;/code&gt; ) 으로 변환 됩니다. 도메인 이름의 ACE 형식은 DNS 쿼리, HTTP &lt;em&gt;호스트&lt;/em&gt; 필드 등과 같이 프로토콜에 의해 임의의 문자가 허용되지 않는 모든 위치에서 사용 됩니다. 이 변환은 응용 프로그램에서 수행됩니다. 가능한 경우 사용자에게 보이지 않는 경우 : 응용 프로그램은 유선으로 유니 코드 도메인 레이블을 투명하게 IDNA로 변환하고 사용자에게 표시하기 전에 ACE 레이블을 다시 유니 코드로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae0960be459bc3a6043cacd2025edb486fd19f0b" translate="yes" xml:space="preserve">
          <source>These are available only after &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">이들은 &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 이 호출 된 후에 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f5c32d3a29bd1ff89416b3ae09cf4c6ae4a7c9d" translate="yes" xml:space="preserve">
          <source>These are string constants containing Bluetooth addresses with special meanings. For example, &lt;a href=&quot;#socket.BDADDR_ANY&quot;&gt;&lt;code&gt;BDADDR_ANY&lt;/code&gt;&lt;/a&gt; can be used to indicate any address when specifying the binding socket with &lt;code&gt;BTPROTO_RFCOMM&lt;/code&gt;.</source>
          <target state="translated">이것은 특별한 의미를 가진 Bluetooth 주소를 포함하는 문자열 상수입니다. 예를 들어 &lt;a href=&quot;#socket.BDADDR_ANY&quot;&gt; &lt;code&gt;BDADDR_ANY&lt;/code&gt; &lt;/a&gt; 함께 결합 소켓 지정할 때 모든 어드레스를 나타내는데 이용 될 수 &lt;code&gt;BTPROTO_RFCOMM&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="6e329deebb0b200060e6eef68196fa813fcd6a7c" translate="yes" xml:space="preserve">
          <source>These are the Boolean operations, ordered by ascending priority:</source>
          <target state="translated">다음은 오름차순으로 정렬되는 부울 연산입니다.</target>
        </trans-unit>
        <trans-unit id="257015f45893c1795d9d847c44cd903ea49c2017" translate="yes" xml:space="preserve">
          <source>These are the fundamental ctypes data types:</source>
          <target state="translated">다음은 기본 ctypes 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="26144cb516a5e752da5774e85f8525ae1b490465" translate="yes" xml:space="preserve">
          <source>These are the operations that dictionaries support (and therefore, custom mapping types should support too):</source>
          <target state="translated">다음은 사전이 지원하는 조작입니다. 따라서 사용자 정의 맵핑 유형도 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e52dbf7f9d96621e5053b5b96e01b2cb4d2ddd1" translate="yes" xml:space="preserve">
          <source>These are the possible values for &lt;code&gt;si_code&lt;/code&gt; in the result returned by &lt;a href=&quot;#os.waitid&quot;&gt;&lt;code&gt;waitid()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#os.waitid&quot;&gt; &lt;code&gt;waitid()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 결과에서 &lt;code&gt;si_code&lt;/code&gt; 에 가능한 값입니다. .</target>
        </trans-unit>
        <trans-unit id="33d6686360d4d96617294fd588956382c26c1e0b" translate="yes" xml:space="preserve">
          <source>These are the possible values for &lt;em&gt;idtype&lt;/em&gt; in &lt;a href=&quot;#os.waitid&quot;&gt;&lt;code&gt;waitid()&lt;/code&gt;&lt;/a&gt;. They affect how &lt;em&gt;id&lt;/em&gt; is interpreted.</source>
          <target state="translated">이러한 가능한 값이다 &lt;em&gt;idtype&lt;/em&gt; 에 &lt;a href=&quot;#os.waitid&quot;&gt; &lt;code&gt;waitid()&lt;/code&gt; &lt;/a&gt; . 그들은 어떻게 &lt;em&gt;ID에&lt;/em&gt; 영향을 미칩니다&lt;em&gt;&lt;/em&gt; 해석 .</target>
        </trans-unit>
        <trans-unit id="869f56b514f44bafe3fe22e39f703595a56c9bf4" translate="yes" xml:space="preserve">
          <source>These are useful if you want more control, or if you want to employ some of the algorithms implemented in this module in other circumstances.</source>
          <target state="translated">더 많은 제어를 원하거나 다른 환경에서이 모듈에 구현 된 일부 알고리즘을 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="01bf0efec17a4834e0a6b4b11da2c6d1b42d7b04" translate="yes" xml:space="preserve">
          <source>These attribute is true for the network as a whole if it is true for both the network address and the broadcast address.</source>
          <target state="translated">이 속성은 네트워크 주소와 브로드 캐스트 주소 모두에 해당되는 경우 네트워크 전체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="181a67606af87af42c5d3ffd8630c69cbabfe1e4" translate="yes" xml:space="preserve">
          <source>These attributes are deleted at the context manager exit.</source>
          <target state="translated">이 속성은 컨텍스트 관리자 엑시트에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7b417bf2efa43f13fc4f3e2f96d7bb14f2e3d8" translate="yes" xml:space="preserve">
          <source>These attributes are true for the network as a whole if they are true for both the network address and the broadcast address.</source>
          <target state="translated">이러한 속성은 네트워크 주소와 브로드 캐스트 주소 모두에 해당되는 경우 네트워크 전체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe7aee32b05e735896ae2f06ad4b1db866432e5" translate="yes" xml:space="preserve">
          <source>These attributes can be used to hold additional data associated with the element. Their values are usually strings but may be any application-specific object. If the element is created from an XML file, the &lt;em&gt;text&lt;/em&gt; attribute holds either the text between the element&amp;rsquo;s start tag and its first child or end tag, or &lt;code&gt;None&lt;/code&gt;, and the &lt;em&gt;tail&lt;/em&gt; attribute holds either the text between the element&amp;rsquo;s end tag and the next tag, or &lt;code&gt;None&lt;/code&gt;. For the XML data</source>
          <target state="translated">이 속성은 요소와 연관된 추가 데이터를 보유하는 데 사용될 수 있습니다. 해당 값은 일반적으로 문자열이지만 응용 프로그램 별 객체 일 수 있습니다. 요소는 XML 파일에서 생성되는 경우, &lt;em&gt;텍스트&lt;/em&gt; 속성은 두 요소의 시작 태그와 첫 번째 자식이나 끝 태그 또는 사이에있는 텍스트 보유 &lt;code&gt;None&lt;/code&gt; , 그리고 &lt;em&gt;꼬리&lt;/em&gt; 속성은 어느 요소의 종료 태그와 다음 태그 사이의 텍스트를 보유하고 또는 &lt;code&gt;None&lt;/code&gt; . XML 데이터</target>
        </trans-unit>
        <trans-unit id="6fd5033e1290cc940ad7cf71f9886488f34ab1aa" translate="yes" xml:space="preserve">
          <source>These bytes can be used to seed user-space random number generators or for cryptographic purposes.</source>
          <target state="translated">이 바이트는 사용자 공간 난수 생성기를 시드하거나 암호화 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44ca4afebbdb6d250b9740f34fbdbf566762d631" translate="yes" xml:space="preserve">
          <source>These calls are only made if control is expected to return to the Python interpreter. A typical &lt;a href=&quot;subprocess#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; launch will not trigger them as the child is not going to re-enter the interpreter.</source>
          <target state="translated">이러한 호출은 제어가 Python 인터프리터로 리턴 될 것으로 예상되는 경우에만 수행됩니다. 자식이 인터프리터에 다시 들어 가지 않을 것이기 때문에 일반적인 &lt;a href=&quot;subprocess#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 실행은 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="853ef506dfaaa56fab906e6007dbe61b8f184b47" translate="yes" xml:space="preserve">
          <source>These classes are pre-defined using the mix-in classes.</source>
          <target state="translated">이 클래스는 믹스 인 클래스를 사용하여 미리 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="429a7cf26e573ef062098c538c098cd4acba2cab" translate="yes" xml:space="preserve">
          <source>These classes are provided for the purposes of organizing certain functions under one namespace. They aren&amp;rsquo;t meant to be instantiated independently.</source>
          <target state="translated">이러한 클래스는 하나의 네임 스페이스에서 특정 기능을 구성하기 위해 제공됩니다. 독립적으로 인스턴스화되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae47495c57f5eaa0f0f8df13652cd694013c4578" translate="yes" xml:space="preserve">
          <source>These classes extend the above classes to serve HTML documentation in response to HTTP GET requests. Servers can either be free standing, using &lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt;&lt;code&gt;DocXMLRPCServer&lt;/code&gt;&lt;/a&gt;, or embedded in a CGI environment, using &lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt;&lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 클래스는 HTTP GET 요청에 대한 응답으로 HTML 문서를 제공하기 위해 위의 클래스를 확장합니다. 서버는 &lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt; &lt;code&gt;DocXMLRPCServer&lt;/code&gt; 를&lt;/a&gt; 사용하여 독립형 이거나 &lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt; &lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt; 를&lt;/a&gt; 사용하여 CGI 환경에 임베드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="771117257d089fde13c49bce5d82474423521fb2" translate="yes" xml:space="preserve">
          <source>These collections are provided for automatic introspection of bytecode instructions:</source>
          <target state="translated">이 컬렉션은 바이트 코드 명령어의 자동 검사를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bb46852d445b6630c8fabc91fcd9b4c4b7f185c5" translate="yes" xml:space="preserve">
          <source>These commands and their arguments will be passed to a C function in the &lt;code&gt;_tkinter&lt;/code&gt; - note the underscore - extension module.</source>
          <target state="translated">이 명령과 인수는 &lt;code&gt;_tkinter&lt;/code&gt; - 밑줄-확장 모듈 에있는 C 함수에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cc8a232ffec17a0509c73cdc3cc5da82cc0c3b0" translate="yes" xml:space="preserve">
          <source>These constants are used as parameters for &lt;a href=&quot;#time.clock_getres&quot;&gt;&lt;code&gt;clock_getres()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.clock_gettime&quot;&gt;&lt;code&gt;clock_gettime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#time.clock_getres&quot;&gt; &lt;code&gt;clock_getres()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.clock_gettime&quot;&gt; &lt;code&gt;clock_gettime()&lt;/code&gt; &lt;/a&gt; 매개 변수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f706a07e280b246aec2eb24a7a6cf4e80c4fad0" translate="yes" xml:space="preserve">
          <source>These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams to indicate the byte order used, and in UTF-8 as a Unicode signature. &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt;&lt;code&gt;BOM_UTF16&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt;&lt;code&gt;BOM_UTF16_BE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt;&lt;code&gt;BOM_UTF16_LE&lt;/code&gt;&lt;/a&gt; depending on the platform&amp;rsquo;s native byte order, &lt;a href=&quot;#codecs.BOM&quot;&gt;&lt;code&gt;BOM&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt;&lt;code&gt;BOM_UTF16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codecs.BOM_LE&quot;&gt;&lt;code&gt;BOM_LE&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt;&lt;code&gt;BOM_UTF16_LE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.BOM_BE&quot;&gt;&lt;code&gt;BOM_BE&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt;&lt;code&gt;BOM_UTF16_BE&lt;/code&gt;&lt;/a&gt;. The others represent the BOM in UTF-8 and UTF-32 encodings.</source>
          <target state="translated">이 상수는 여러 인코딩에 대한 유니 코드 바이트 순서 표시 (BOM) 인 다양한 바이트 시퀀스를 정의합니다. UTF-16 및 UTF-32 데이터 스트림에서 사용 된 바이트 순서를 나타내며 UTF-8에서 유니 코드 서명으로 사용됩니다. &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt; &lt;code&gt;BOM_UTF16&lt;/code&gt; &lt;/a&gt; 은 플랫폼의 기본 바이트 순서에 따라 &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt; &lt;code&gt;BOM_UTF16_BE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt; &lt;code&gt;BOM_UTF16_LE&lt;/code&gt; &lt;/a&gt; 이며 &lt;a href=&quot;#codecs.BOM&quot;&gt; &lt;code&gt;BOM&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt; &lt;code&gt;BOM_UTF16&lt;/code&gt; &lt;/a&gt; 의 별칭 , &lt;a href=&quot;#codecs.BOM_LE&quot;&gt; &lt;code&gt;BOM_LE&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt; &lt;code&gt;BOM_UTF16_LE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.BOM_BE&quot;&gt; &lt;code&gt;BOM_BE&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt; &lt;code&gt;BOM_UTF16_BE&lt;/code&gt; &lt;/a&gt; 입니다. 다른 것은 BOM을 UTF-8 및 UTF-32 인코딩으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11075a028b89f1287b800e88d2a70525b45b0b3e" translate="yes" xml:space="preserve">
          <source>These constants represent the address (and protocol) families, used for the first argument to &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;. If the &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; constant is not defined then this protocol is unsupported. More constants may be available depending on the system.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수에 사용되는 주소 (및 프로토콜) 패밀리를 나타냅니다 . &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; 인&lt;/a&gt; 경우 상수가 정의되지 않은이 프로토콜은 지원되지 않습니다. 시스템에 따라 더 많은 상수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3636a3cbc66bf8adda778cce9b23ca921f64aa56" translate="yes" xml:space="preserve">
          <source>These constants represent the socket types, used for the second argument to &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;. More constants may be available depending on the system. (Only &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/a&gt; appear to be generally useful.)</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수에 사용되는 소켓 유형을 나타냅니다 . 시스템에 따라 더 많은 상수를 사용할 수 있습니다. ( &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;SOCK_DGRAM&lt;/code&gt; &lt;/a&gt; 만 일반적으로 유용한 것으로 보입니다.)</target>
        </trans-unit>
        <trans-unit id="3850a5b66faf07220246584613141a4ed6ecd46e" translate="yes" xml:space="preserve">
          <source>These context managers may suppress exceptions just as they normally would if used directly as part of a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">이러한 컨텍스트 관리자는 일반적으로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; 의&lt;/a&gt; 일부로 직접 사용되는 것처럼 예외를 억제 할 수 있습니다 문의 .</target>
        </trans-unit>
        <trans-unit id="2dd856ad1addbac2083c18edada1fee2ecb93a1c" translate="yes" xml:space="preserve">
          <source>These flags can be passed to &lt;a href=&quot;#os.memfd_create&quot;&gt;&lt;code&gt;memfd_create()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;#os.memfd_create&quot;&gt; &lt;code&gt;memfd_create()&lt;/code&gt; &lt;/a&gt; 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d893a5018493b1ad1f01b4884c32e1257195fdf" translate="yes" xml:space="preserve">
          <source>These four classes process requests &lt;em&gt;synchronously&lt;/em&gt;; each request must be completed before the next request can be started. This isn&amp;rsquo;t suitable if each request takes a long time to complete, because it requires a lot of computation, or because it returns a lot of data which the client is slow to process. The solution is to create a separate process or thread to handle each request; the &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt;&lt;code&gt;ForkingMixIn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; mix-in classes can be used to support asynchronous behaviour.</source>
          <target state="translated">이 네 클래스는 요청을 &lt;em&gt;동 기적으로&lt;/em&gt; 처리합니다 . 다음 요청을 시작하기 전에 각 요청을 완료해야합니다. 계산이 많이 필요하거나 클라이언트가 처리하는 속도가 느린 데이터를 많이 반환하기 때문에 각 요청을 완료하는 데 시간이 오래 걸리는 경우 적합하지 않습니다. 해결책은 각 요청을 처리하기 위해 별도의 프로세스 또는 스레드를 작성하는 것입니다. &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt; &lt;code&gt;ForkingMixIn&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt; -에 믹스 클래스 비동기 동작을 지원하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72acb5b09128de39b246ae899d12597305851702" translate="yes" xml:space="preserve">
          <source>These functions accept either integers or single-character strings; when the argument is a string, it is first converted using the built-in function &lt;a href=&quot;functions#ord&quot;&gt;&lt;code&gt;ord()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 정수 또는 단일 문자 문자열을 허용합니다. 인수가 문자열 인 경우 내장 함수 &lt;a href=&quot;functions#ord&quot;&gt; &lt;code&gt;ord()&lt;/code&gt; &lt;/a&gt; 사용하여 먼저 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="15117243b94d605b572f5691b43a112efe192336" translate="yes" xml:space="preserve">
          <source>These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">이 함수들은 모두 현재 프로세스를 대체하여 새로운 프로그램을 실행합니다. 그들은 돌아 오지 않습니다. 유닉스에서는 새로운 실행 파일이 현재 프로세스에로드되고 호출자와 동일한 프로세스 ID를 갖습니다. 오류는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외 로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b6139927d660d5e1dad5ec0f32107d8c628a1f2" translate="yes" xml:space="preserve">
          <source>These functions and data items provide information and operate on the current process and user.</source>
          <target state="translated">이러한 기능 및 데이터 항목은 정보를 제공하고 현재 프로세스 및 사용자에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="65b2f130f9e56bca14a7379055f6e9bfc0f55b6b" translate="yes" xml:space="preserve">
          <source>These functions are all available on Linux only.</source>
          <target state="translated">이 기능은 모두 Linux에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4b7ea423186e1ad3686c673479b4eab2cfb592f4" translate="yes" xml:space="preserve">
          <source>These functions are described in &lt;a href=&quot;#os-file-dir&quot;&gt;Files and Directories&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 &lt;a href=&quot;#os-file-dir&quot;&gt;파일 및 디렉토리에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b95d0027dd729f2509f2876394ae457eb98ec95" translate="yes" xml:space="preserve">
          <source>These functions are used to retrieve resource usage information:</source>
          <target state="translated">이 함수는 자원 사용 정보를 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13a1f4f79e7d240a9400f9b84efbdcb7fe5617a9" translate="yes" xml:space="preserve">
          <source>These functions calculate a measure of how much the population or sample tends to deviate from the typical or average values.</source>
          <target state="translated">이 함수는 모집단 또는 표본이 일반적인 값 또는 평균 값에서 벗어나는 정도를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="c7e658bb4b32599c516696e577ad91941fcdf933" translate="yes" xml:space="preserve">
          <source>These functions calculate an average or typical value from a population or sample.</source>
          <target state="translated">이 함수는 모집단 또는 표본에서 평균 또는 일반 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a0ae98a3415f470fd255b1fc3b22d36ac3e83e02" translate="yes" xml:space="preserve">
          <source>These functions cannot be used with complex numbers; use the functions of the same name from the &lt;a href=&quot;cmath#module-cmath&quot;&gt;&lt;code&gt;cmath&lt;/code&gt;&lt;/a&gt; module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don&amp;rsquo;t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.</source>
          <target state="translated">이 함수는 복소수와 함께 사용할 수 없습니다. 복소수를 지원해야하는 경우 &lt;a href=&quot;cmath#module-cmath&quot;&gt; &lt;code&gt;cmath&lt;/code&gt; &lt;/a&gt; 모듈 과 동일한 이름의 함수를 사용하십시오 . 대부분의 사용자는 복소수를 이해하는 데 필요한만큼 많은 수학을 배우기를 원하지 않기 때문에 복소수를 지원하는 함수와 그렇지 않은 함수의 구별. 복소수 결과 대신 예외를 수신하면 매개 변수로 사용 된 예상치 못한 복소수를 조기에 감지 할 수 있으므로 프로그래머는 처음에 생성 된 방법과 이유를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54bc89086a46bb862ee0519c0f004dabc70edbc5" translate="yes" xml:space="preserve">
          <source>These functions control how a process is allocated CPU time by the operating system. They are only available on some Unix platforms. For more detailed information, consult your Unix manpages.</source>
          <target state="translated">이 기능은 운영 체제가 프로세스에 CPU 시간을 할당하는 방법을 제어합니다. 일부 유닉스 플랫폼에서만 사용할 수 있습니다. 자세한 내용은 Unix 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9d98b250a452db69c03659fe4d2049d567fb07a" translate="yes" xml:space="preserve">
          <source>These functions create new &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. (See also &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; for opening file descriptors.)</source>
          <target state="translated">이 함수는 새로운 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 만듭니다 . (또한 &lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 참조파일 디스크립터를 을 .</target>
        </trans-unit>
        <trans-unit id="a9b3e1b34cce84fdb913bf10862151ad4e21d563" translate="yes" xml:space="preserve">
          <source>These functions expose the Windows registry API to Python. Instead of using an integer as the registry handle, a &lt;a href=&quot;#handle-object&quot;&gt;handle object&lt;/a&gt; is used to ensure that the handles are closed correctly, even if the programmer neglects to explicitly close them.</source>
          <target state="translated">이 함수는 Windows 레지스트리 API를 Python에 노출시킵니다. 레지스트리 핸들로 정수를 사용하는 대신 , 프로그래머가 명시 적으로 닫는 것을 무시하더라도 &lt;a href=&quot;#handle-object&quot;&gt;핸들 오브젝트&lt;/a&gt; 가 핸들을 올바르게 닫는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="64ca6341c263d0eee46813e38f713dafca73d87a" translate="yes" xml:space="preserve">
          <source>These functions may be used to create and manage processes.</source>
          <target state="translated">이 기능들은 프로세스를 생성하고 관리하는데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e8df50f0bf89eb9f4d3f60786c6448bf4847aa" translate="yes" xml:space="preserve">
          <source>These functions operate on I/O streams referenced using file descriptors.</source>
          <target state="translated">이 함수는 파일 디스크립터를 사용하여 참조 된 I / O 스트림에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="62bfedde268bc00986bbe311ebb5f0786bf6963c" translate="yes" xml:space="preserve">
          <source>These functions provide access to some useful capabilities on Windows platforms. Some higher-level modules use these functions to build the Windows implementations of their services. For example, the &lt;a href=&quot;getpass#module-getpass&quot;&gt;&lt;code&gt;getpass&lt;/code&gt;&lt;/a&gt; module uses this in the implementation of the &lt;a href=&quot;getpass#module-getpass&quot;&gt;&lt;code&gt;getpass()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이러한 기능을 통해 Windows 플랫폼의 유용한 기능에 액세스 할 수 있습니다. 일부 상위 레벨 모듈은이 기능을 사용하여 서비스의 Windows 구현을 빌드합니다. 예를 들어, &lt;a href=&quot;getpass#module-getpass&quot;&gt; &lt;code&gt;getpass&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;a href=&quot;getpass#module-getpass&quot;&gt; &lt;code&gt;getpass()&lt;/code&gt; &lt;/a&gt; 함수 구현에서이를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0280d48461c7d32aa95410598911229c46dae797" translate="yes" xml:space="preserve">
          <source>These functions return the corresponding hash objects for calculating BLAKE2b or BLAKE2s. They optionally take these general parameters:</source>
          <target state="translated">이 함수는 BLAKE2b 또는 BLAKE2를 계산하기위한 해당 해시 개체를 반환합니다. 선택적으로 다음과 같은 일반 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="228f30ca6935d93886c690db3fc546e4320724bb" translate="yes" xml:space="preserve">
          <source>These functions should be avoided in Python 3, because they return encoded bytes. It&amp;rsquo;s much better to use alternatives which return Unicode strings instead, since most Python applications will want to manipulate human readable text as strings instead of bytes. Further, it&amp;rsquo;s possible that you may get unexpected Unicode-related exceptions if there are encoding problems with the translated strings.</source>
          <target state="translated">이 함수는 인코딩 된 바이트를 반환하므로 Python 3에서는 피해야합니다. 대부분의 Python 응용 프로그램은 사람이 읽을 수있는 텍스트를 바이트 대신 문자열로 조작하기를 원하므로 유니 코드 문자열을 반환하는 대안을 사용하는 것이 훨씬 좋습니다. 또한 번역 된 문자열에 인코딩 문제가있는 경우 예기치 않은 유니 코드 관련 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="152b061e5d33249f6e76f6fd12669c7d70fbc3d2" translate="yes" xml:space="preserve">
          <source>These interfaces extend the &lt;code&gt;Node&lt;/code&gt; interface. They cannot have child nodes.</source>
          <target state="translated">이러한 인터페이스는 &lt;code&gt;Node&lt;/code&gt; 인터페이스를 확장합니다 . 자식 노드를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="799c1f5dbfcbd19d6e5bb337ef29e540c95dfa79" translate="yes" xml:space="preserve">
          <source>These junk-filtering functions speed up matching to find differences and do not cause any differing lines or characters to be ignored. Read the description of the &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt;&lt;code&gt;find_longest_match()&lt;/code&gt;&lt;/a&gt; method&amp;rsquo;s &lt;em&gt;isjunk&lt;/em&gt; parameter for an explanation.</source>
          <target state="translated">이러한 정크 필터링 기능은 차이점을 찾기 위해 일치 속도를 높이고 다른 줄이나 문자를 무시하지 않습니다. &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt; &lt;code&gt;find_longest_match()&lt;/code&gt; &lt;/a&gt; 메소드의 &lt;em&gt;isjunk&lt;/em&gt; 매개 변수에 대한 설명을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="364d64d52986eda4fa8d78b737587ffa8380e1f3" translate="yes" xml:space="preserve">
          <source>These may not be available on all platforms when used with the &lt;code&gt;strftime()&lt;/code&gt; method. The ISO 8601 year and ISO 8601 week directives are not interchangeable with the year and week number directives above. Calling &lt;code&gt;strptime()&lt;/code&gt; with incomplete or ambiguous ISO 8601 directives will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;strftime()&lt;/code&gt; 메소드 와 함께 사용하면 일부 플랫폼에서 사용하지 못할 수 있습니다 . ISO 8601 연도 및 ISO 8601 주 지침은 위의 연도 및 주 번호 지침과 호환되지 않습니다. 불완전하거나 모호한 ISO 8601 지시문으로 &lt;code&gt;strptime()&lt;/code&gt; 을 호출 하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2cefa5663c6968d98cda435b00eb0b38f51c7e77" translate="yes" xml:space="preserve">
          <source>These methods are available on &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt;&lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">이러한 메소드는 &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt; &lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt; &lt;/a&gt; 오브젝트 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5911df52a37a2f5a8a67b79ea06a439077506bd9" translate="yes" xml:space="preserve">
          <source>These methods are called by a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object, in response to their methods of the same names. A &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object passes itself as the argument, and a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object passes &lt;code&gt;None&lt;/code&gt; as the argument. A &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass&amp;rsquo;s methods should therefore be prepared to accept a &lt;em&gt;dt&lt;/em&gt; argument of &lt;code&gt;None&lt;/code&gt;, or of class &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 메소드는 동일한 이름의 메소드에 대한 응답으로 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 오브젝트에 의해 호출됩니다 . &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체는 인수 자체를 전달하고, &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체는 통과하지 &lt;code&gt;None&lt;/code&gt; 인수로합니다. 따라서 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드는 &lt;code&gt;None&lt;/code&gt; 또는 class &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;dt&lt;/em&gt; 인수 를 허용하도록 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="18aea1bbbb44bf54322bd21581fcc7fef2dcc544" translate="yes" xml:space="preserve">
          <source>These methods generate unique file names based upon the current process ID. When using multiple threads, undetected name clashes may occur and cause corruption of the mailbox unless threads are coordinated to avoid using these methods to manipulate the same mailbox simultaneously.</source>
          <target state="translated">이러한 메소드는 현재 프로세스 ID를 기반으로 고유 한 파일 이름을 생성합니다. 여러 스레드를 사용하는 경우 이러한 방법을 사용하여 동일한 사서함을 동시에 조작하지 않도록 스레드를 조정하지 않으면 감지되지 않은 이름 충돌이 발생하여 사서함이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a460e54883612c01c96877b5d32c7a52f41e8cec" translate="yes" xml:space="preserve">
          <source>These methods immediately delete the message. The MH convention of marking a message for deletion by prepending a comma to its name is not used.</source>
          <target state="translated">이러한 방법은 메시지를 즉시 삭제합니다. 이름 앞에 쉼표를 붙여서 메시지를 삭제하도록 표시하는 MH 규칙은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5940fc3a6f4d0793d0ba67cd0795eb41381f9f36" translate="yes" xml:space="preserve">
          <source>These methods should be avoided in Python 3. See the warning for the &lt;a href=&quot;#gettext.lgettext&quot;&gt;&lt;code&gt;lgettext()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 메소드는 Python 3에서 피해야 합니다. &lt;a href=&quot;#gettext.lgettext&quot;&gt; &lt;code&gt;lgettext()&lt;/code&gt; &lt;/a&gt; 함수에 대한 경고를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b48daa7e8c1e0cff066d2e0a4920c8cbfbcd31c" translate="yes" xml:space="preserve">
          <source>These modified docstrings are created automatically together with the function definitions that are derived from the methods at import time.</source>
          <target state="translated">이러한 수정 된 docstring은 가져 오기시 메소드에서 파생 된 함수 정의와 함께 자동으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="37a911174119b81cc68b901672ebc6a9480f0a44" translate="yes" xml:space="preserve">
          <source>These more infrequently used classes are similar to the TCP and UDP classes, but use Unix domain sockets; they&amp;rsquo;re not available on non-Unix platforms. The parameters are the same as for &lt;a href=&quot;#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이처럼 자주 사용되지 않는 클래스는 TCP 및 UDP 클래스와 비슷하지만 Unix 도메인 소켓을 사용합니다. Unix 이외의 플랫폼에서는 사용할 수 없습니다. 매개 변수는 &lt;a href=&quot;#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1a0feedd3b398644d890b41707a8d3ab57269dc3" translate="yes" xml:space="preserve">
          <source>These must be implemented as class methods:</source>
          <target state="translated">이들은 클래스 메소드로 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7cbdf0b741bfed107869c8df02810045e53d52c4" translate="yes" xml:space="preserve">
          <source>These objects also support being used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will automatically close them when done.</source>
          <target state="translated">이러한 객체는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 사용되도록 지원하며 완료되면 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7ad08a7358df1d2a66eb1de7e37514f52255da7a" translate="yes" xml:space="preserve">
          <source>These objects contain the original values of &lt;code&gt;breakpointhook&lt;/code&gt;, &lt;code&gt;displayhook&lt;/code&gt;, &lt;code&gt;excepthook&lt;/code&gt;, and &lt;code&gt;unraisablehook&lt;/code&gt; at the start of the program. They are saved so that &lt;code&gt;breakpointhook&lt;/code&gt;, &lt;code&gt;displayhook&lt;/code&gt; and &lt;code&gt;excepthook&lt;/code&gt;, &lt;code&gt;unraisablehook&lt;/code&gt; can be restored in case they happen to get replaced with broken or alternative objects.</source>
          <target state="translated">이러한 객체에는 프로그램 시작시 &lt;code&gt;breakpointhook&lt;/code&gt; , &lt;code&gt;displayhook&lt;/code&gt; , &lt;code&gt;excepthook&lt;/code&gt; 및 &lt;code&gt;unraisablehook&lt;/code&gt; 의 원래 값이 포함 됩니다. &lt;code&gt;breakpointhook&lt;/code&gt; , &lt;code&gt;displayhook&lt;/code&gt; 및 &lt;code&gt;excepthook&lt;/code&gt; , &lt;code&gt;unraisablehook&lt;/code&gt; 이 깨지거나 대체 된 객체로 교체되는 경우 복원 할 수 있도록 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ca96d692b02c7b885bfcd6a1ee8049c02cbf749" translate="yes" xml:space="preserve">
          <source>These objects contain the original values of &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; at the start of the program. They are used during finalization, and could be useful to print to the actual standard stream no matter if the &lt;code&gt;sys.std*&lt;/code&gt; object has been redirected.</source>
          <target state="translated">이 오브젝트에는 프로그램 시작시 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; 및 &lt;code&gt;stdout&lt;/code&gt; 의 원래 값이 포함 됩니다. 이들은 마무리 과정에서 사용되며 &lt;code&gt;sys.std*&lt;/code&gt; 객체가 리디렉션 되더라도 실제 표준 스트림으로 인쇄하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c79b4fd295e293df8d67f19b3b67a6719463f333" translate="yes" xml:space="preserve">
          <source>These options can be passed to &lt;a href=&quot;#mmap.mmap.madvise&quot;&gt;&lt;code&gt;mmap.madvise()&lt;/code&gt;&lt;/a&gt;. Not every option will be present on every system.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;#mmap.mmap.madvise&quot;&gt; &lt;code&gt;mmap.madvise()&lt;/code&gt; &lt;/a&gt; 로 전달할 수 있습니다 . 모든 옵션이 모든 시스템에 존재하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9926e9592428ba78a5e1b23082749828067c3a4d" translate="yes" xml:space="preserve">
          <source>These options may be repeated multiple times.</source>
          <target state="translated">이러한 옵션은 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d457330f80a34e6080d306cadcb1e3ad2dc2766" translate="yes" xml:space="preserve">
          <source>These options, along with all of the other options, are described in more detail in the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor documentation.</source>
          <target state="translated">이러한 옵션은 다른 모든 옵션과 함께 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 생성자 설명서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc76ffa679003835a09fce6bfd595ccfec9bd93" translate="yes" xml:space="preserve">
          <source>These parsers do not support all the argparse features, and will raise exceptions if unsupported features are used. In particular, subparsers, &lt;code&gt;argparse.REMAINDER&lt;/code&gt;, and mutually exclusive groups that include both optionals and positionals are not supported.</source>
          <target state="translated">이 파서는 모든 argparse 기능을 지원하지 않으며 지원되지 않는 기능이 사용되는 경우 예외를 발생시킵니다. 특히, 하위 구문 분석기, &lt;code&gt;argparse.REMAINDER&lt;/code&gt; 및 선택적 및 위치를 모두 포함하는 상호 배타적 인 그룹은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22dba5743cf8255132f82cfb61a9e3e78ed086d7" translate="yes" xml:space="preserve">
          <source>These prefabricated library loaders are available:</source>
          <target state="translated">이 조립식 라이브러리 로더는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eef266eadbe60582ab001bde9ad9c46caee2dc9f" translate="yes" xml:space="preserve">
          <source>These restrictions are why picklable functions and classes must be defined in the top level of a module.</source>
          <target state="translated">이러한 제한 때문에 선택 가능한 함수와 클래스를 모듈의 최상위 수준에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="35bc8bcd8d7bb38d5e825c33344aa3d246936c4a" translate="yes" xml:space="preserve">
          <source>These semantic differences are intentional and are biased toward convenience in the most common use cases.</source>
          <target state="translated">이러한 의미 적 차이는 의도적이며 가장 일반적인 사용 사례에서 편의를 위해 편향되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9d492a24219c745ba294aeae2b21be77edbc2b" translate="yes" xml:space="preserve">
          <source>These semantic differences are intentional and are biased toward maximal convenience.</source>
          <target state="translated">이러한 의미 적 차이는 의도적이며 최대한의 편의를 위해 편향되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="390560ef8845b8bdb712a7c8bf8f16cdd1ae320d" translate="yes" xml:space="preserve">
          <source>These should be implemented as functions:</source>
          <target state="translated">이들은 함수로 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ceca439cc106eb947129c153f66b43d43dadf38e" translate="yes" xml:space="preserve">
          <source>These sizes are available as module &lt;a href=&quot;#constants&quot;&gt;constants&lt;/a&gt; described below.</source>
          <target state="translated">이 크기는 아래 설명 된 모듈 &lt;a href=&quot;#constants&quot;&gt;상수&lt;/a&gt; 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="2800725d5ea46f65c695489e6472f9a85853adeb" translate="yes" xml:space="preserve">
          <source>These streams are regular &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-file&quot;&gt;text files&lt;/a&gt; like those returned by the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. Their parameters are chosen as follows:</source>
          <target state="translated">이 스트림은 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환되는 것과 같은 일반 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-file&quot;&gt;텍스트 파일&lt;/a&gt; 입니다. 매개 변수는 다음과 같이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e34d0790d235872a36ccb0f116d30f629c65d5a7" translate="yes" xml:space="preserve">
          <source>These symbols define resources whose consumption can be controlled using the &lt;a href=&quot;#resource.setrlimit&quot;&gt;&lt;code&gt;setrlimit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#resource.getrlimit&quot;&gt;&lt;code&gt;getrlimit()&lt;/code&gt;&lt;/a&gt; functions described below. The values of these symbols are exactly the constants used by C programs.</source>
          <target state="translated">이 기호 는 아래 설명 된 &lt;a href=&quot;#resource.setrlimit&quot;&gt; &lt;code&gt;setrlimit()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#resource.getrlimit&quot;&gt; &lt;code&gt;getrlimit()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 소비를 제어 할 수있는 자원을 정의 합니다. 이 기호의 값은 C 프로그램에서 사용하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="32d519f5749336b639a376599af558d7266a105d" translate="yes" xml:space="preserve">
          <source>These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback. Their intended use is to allow an interactive user to import a debugger module and engage in post-mortem debugging without having to re-execute the command that caused the error. (Typical use is &lt;code&gt;import pdb; pdb.pm()&lt;/code&gt; to enter the post-mortem debugger; see &lt;a href=&quot;pdb#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; module for more information.)</source>
          <target state="translated">이 세 변수가 항상 정의 된 것은 아닙니다. 예외가 처리되지 않고 인터프리터가 오류 메시지와 스택 추적을 인쇄 할 때 설정됩니다. 의도 된 용도는 대화식 사용자가 디버거 모듈을 가져오고 오류를 일으킨 명령을 다시 실행하지 않고도 사후 디버깅에 참여할 수 있도록하는 것입니다. 사후 디버거에 들어가기 위해 일반적으로 &lt;code&gt;import pdb; pdb.pm()&lt;/code&gt; 을 사용합니다 . 자세한 내용 은 &lt;a href=&quot;pdb#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b700f59257d82022d76d6670b95dd0556a5db8f6" translate="yes" xml:space="preserve">
          <source>These tools and their built-in counterparts also work well with the high-speed functions in the &lt;a href=&quot;operator#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module. For example, the multiplication operator can be mapped across two vectors to form an efficient dot-product: &lt;code&gt;sum(map(operator.mul, vector1, vector2))&lt;/code&gt;.</source>
          <target state="translated">이 툴들과 내장 된 툴들은 &lt;a href=&quot;operator#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt; 모듈의 고속 기능과도 잘 작동 합니다. 예를 들어, 곱셈 연산자는 두 벡터에 걸쳐 매핑되어 효율적인 내적을 형성 할 수 있습니다 : &lt;code&gt;sum(map(operator.mul, vector1, vector2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e77fbc4d220030bbcd6181d10d369921bab3851a" translate="yes" xml:space="preserve">
          <source>These tuples correspond to the C library &lt;code&gt;posix_spawn_file_actions_addopen()&lt;/code&gt;, &lt;code&gt;posix_spawn_file_actions_addclose()&lt;/code&gt;, and &lt;code&gt;posix_spawn_file_actions_adddup2()&lt;/code&gt; API calls used to prepare for the &lt;code&gt;posix_spawn()&lt;/code&gt; call itself.</source>
          <target state="translated">이 튜플 은 &lt;code&gt;posix_spawn()&lt;/code&gt; 호출 자체 를 준비하는 데 사용되는 C 라이브러리 &lt;code&gt;posix_spawn_file_actions_addopen()&lt;/code&gt; , &lt;code&gt;posix_spawn_file_actions_addclose()&lt;/code&gt; 및 &lt;code&gt;posix_spawn_file_actions_adddup2()&lt;/code&gt; API 호출에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="dbf6e0e647e0d38489bb73abd84ff4677afacaad" translate="yes" xml:space="preserve">
          <source>These two approaches both output:</source>
          <target state="translated">이 두 가지 방법 모두 출력에 접근합니다.</target>
        </trans-unit>
        <trans-unit id="7c080ba8814228ce441c13011c88627af47951fe" translate="yes" xml:space="preserve">
          <source>These two constants, if defined, can be combined with the socket types and allow you to set some flags atomically (thus avoiding possible race conditions and the need for separate calls).</source>
          <target state="translated">이 두 상수는 정의 된 경우 소켓 유형과 결합하여 일부 플래그를 원자 적으로 설정할 수 있습니다 (따라서 경쟁 조건과 별도의 호출이 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="3a39e6e21e19b9d8817c24d832895a8746655153" translate="yes" xml:space="preserve">
          <source>These two make it possible to view the heap as a regular Python list without surprises: &lt;code&gt;heap[0]&lt;/code&gt; is the smallest item, and &lt;code&gt;heap.sort()&lt;/code&gt; maintains the heap invariant!</source>
          <target state="translated">이 두 가지를 사용하면 힙을 놀라지 않고 일반 파이썬 목록으로 볼 수 있습니다. &lt;code&gt;heap[0]&lt;/code&gt; 은 가장 작은 항목이며 &lt;code&gt;heap.sort()&lt;/code&gt; 는 힙을 불변으로 유지합니다!</target>
        </trans-unit>
        <trans-unit id="164431ebbd6018da434ddafc8673fa593bda252e" translate="yes" xml:space="preserve">
          <source>These two values (measured in number of bytes) control when the protocol&amp;rsquo;s &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt;&lt;code&gt;protocol.pause_writing()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt;&lt;code&gt;protocol.resume_writing()&lt;/code&gt;&lt;/a&gt; methods are called. If specified, the low watermark must be less than or equal to the high watermark. Neither &lt;em&gt;high&lt;/em&gt; nor &lt;em&gt;low&lt;/em&gt; can be negative.</source>
          <target state="translated">이 두 값 (바이트 수로 측정)은 프로토콜의 &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt; &lt;code&gt;protocol.pause_writing()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt; &lt;code&gt;protocol.resume_writing()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 될 때 제어합니다 . 지정된 경우 하위 워터 마크는 상위 워터 마크보다 작거나 같아야합니다. 둘 다&lt;em&gt; 높은&lt;/em&gt; 이나 &lt;em&gt;낮은&lt;/em&gt; 음수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="574630dc61934cf9f92e574ac1641bd851cae54b" translate="yes" xml:space="preserve">
          <source>These type aliases correspond to the return types from &lt;a href=&quot;re#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;re#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt;. These types (and the corresponding functions) are generic in &lt;code&gt;AnyStr&lt;/code&gt; and can be made specific by writing &lt;code&gt;Pattern[str]&lt;/code&gt;, &lt;code&gt;Pattern[bytes]&lt;/code&gt;, &lt;code&gt;Match[str]&lt;/code&gt;, or &lt;code&gt;Match[bytes]&lt;/code&gt;.</source>
          <target state="translated">이 유형 별명은 &lt;a href=&quot;re#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;re#re.match&quot;&gt; &lt;code&gt;re.match()&lt;/code&gt; &lt;/a&gt; 의 리턴 유형에 해당합니다 . 이러한 유형 (및 해당 기능)은 &lt;code&gt;AnyStr&lt;/code&gt; 에서 일반적 이며 &lt;code&gt;Pattern[str]&lt;/code&gt; , &lt;code&gt;Pattern[bytes]&lt;/code&gt; , &lt;code&gt;Match[str]&lt;/code&gt; 를 작성하여 구체적으로 만들 수 있습니다 . 또는 &lt;code&gt;Match[bytes]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1dff30429da744e3abeb83ca67b97f13e80951a" translate="yes" xml:space="preserve">
          <source>These uses have different requirements, and it is important to distinguish them. In particular, filling your docstrings with obscure test cases makes for bad documentation.</source>
          <target state="translated">이러한 용도에는 요구 사항이 다르므로 구별해야합니다. 특히 문서 문자열을 모호한 테스트 사례로 채우면 문서가 잘못 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="04f38c67d7afb9e3ad667bc8f7a956cfa60d4f17" translate="yes" xml:space="preserve">
          <source>They are written as &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt;, respectively.</source>
          <target state="translated">그것들은 &lt;code&gt;False&lt;/code&gt; 과 &lt;code&gt;True&lt;/code&gt; 쓰여집니다.각각 .</target>
        </trans-unit>
        <trans-unit id="90b1fe661130f08bec50f79a318e33e031b7d747" translate="yes" xml:space="preserve">
          <source>They must have since the parser can&amp;rsquo;t tell the type of the operands.</source>
          <target state="translated">파서는 피연산자의 유형을 알 수 없으므로 반드시 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="560fa1e47346eab1954f144c298efe7129116f9d" translate="yes" xml:space="preserve">
          <source>Third-party event loops can use their own subclass of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; for interoperability. In this case, the result type is a subclass of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">타사 이벤트 루프는 상호 운용성을 위해 자체 하위 클래스 &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 . 이 경우 결과 유형은 &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="6885413c3edcf4b3482d003002d40466d1c7529c" translate="yes" xml:space="preserve">
          <source>Third-party event loops implementations might not support custom child watchers. For such event loops, using &lt;a href=&quot;#asyncio.set_child_watcher&quot;&gt;&lt;code&gt;set_child_watcher()&lt;/code&gt;&lt;/a&gt; might be prohibited or have no effect.</source>
          <target state="translated">써드 파티 이벤트 루프 구현은 사용자 정의 하위 감시자를 지원하지 않을 수 있습니다. 이러한 이벤트 루프의 경우 &lt;a href=&quot;#asyncio.set_child_watcher&quot;&gt; &lt;code&gt;set_child_watcher()&lt;/code&gt; &lt;/a&gt; 사용 이 금지되거나 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d33edc8f37f7925e4e4194d0d68db3b29628f3" translate="yes" xml:space="preserve">
          <source>Third-party library with expanded time zone and parsing support.</source>
          <target state="translated">시간대 및 구문 분석 지원이 확장 된 써드 파티 라이브러리.</target>
        </trans-unit>
        <trans-unit id="537a50311943cfeb994000528b2810d2698fd99b" translate="yes" xml:space="preserve">
          <source>Third-party unittest framework with a lighter-weight syntax for writing tests. For example, &lt;code&gt;assert func(10) == 42&lt;/code&gt;.</source>
          <target state="translated">테스트 작성을 위해 더 가벼운 구문의 타사 unittest 프레임 워크 예를 들어, &lt;code&gt;assert func(10) == 42&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3b9ee4043cb6de20c067db3fc4ab5a88de0e0da" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; class method returns bytearray object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored.</source>
          <target state="translated">이 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 클래스 메서드는 주어진 문자열 객체를 디코딩하여 bytearray 객체를 반환합니다. 문자열은 바이트 당 2 개의 16 진수를 포함해야하며 ASCII 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9f39db7a12ab223e5060700f28e89f71e712b838" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; class method returns a bytes object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored.</source>
          <target state="translated">이 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 클래스 메서드는 지정된 문자열 객체를 디코딩하여 bytes 객체를 반환합니다. 문자열은 바이트 당 2 개의 16 진수를 포함해야하며 ASCII 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="25c5a3603bbf6dde0a60e8a1166341e81b90d9ce" translate="yes" xml:space="preserve">
          <source>This C function is able to make calls into other C modules, including the C functions that make up the Tk library. Tk is implemented in C and some Tcl. The Tcl part of the Tk widgets is used to bind certain default behaviors to widgets, and is executed once at the point where the Python &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; package is imported. (The user never sees this stage).</source>
          <target state="translated">이 C 함수는 Tk 라이브러리를 구성하는 C 함수를 포함하여 다른 C 모듈을 호출 할 수 있습니다. Tk는 C와 일부 Tcl에서 구현됩니다. Tk 위젯의 Tcl 부분은 특정 기본 동작을 위젯에 바인딩하는 데 사용되며 Python &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; 가&lt;/a&gt; 있는 지점에서 한 번 실행됩니다. 패키지를 가져 오는 됩니다. 사용자는이 단계를 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d6579a392f5cf7ff657ccc443a5878443ad506e" translate="yes" xml:space="preserve">
          <source>This ExampleService demo can be invoked from the command line:</source>
          <target state="translated">이 ExampleService 데모는 명령 행에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66603e0f2e17db55d8047fa37dc46cc24b89b2cc" translate="yes" xml:space="preserve">
          <source>This Life Preserver was written by Matt Conway at the University of Virginia.</source>
          <target state="translated">이 생명 구명은 버지니아 대학교의 Matt Conway에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff67911a0956c12902ae446cfb25b06222d6404b" translate="yes" xml:space="preserve">
          <source>This RFC defined the encoding of data which was XDR at the time this module was originally written. It has apparently been obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1832.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1832&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">이 RFC는이 모듈이 처음 작성된 시점의 XDR 인 데이터 인코딩을 정의했습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc1832.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1832에&lt;/strong&gt;&lt;/a&gt; 의해 사용되지 않는 것 같습니다 .</target>
        </trans-unit>
        <trans-unit id="842c2f73983d293e723e4d1bf4e9d2c64a72c57e" translate="yes" xml:space="preserve">
          <source>This Request For Comments includes the rules for joining an absolute and a relative URL, including a fair number of &amp;ldquo;Abnormal Examples&amp;rdquo; which govern the treatment of border cases.</source>
          <target state="translated">이 의견 요청에는 국경 사건의 처리를 통제하는 공정한 수의 &quot;비정상적인 예&quot;를 포함하여 절대 및 상대 URL에 참여하기위한 규칙이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="135088776289217c28423276fa3c4b5d93458f2e" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;clearscreen&lt;/code&gt;. The global function &lt;code&gt;clear&lt;/code&gt; is a different one derived from the Turtle method &lt;code&gt;clear&lt;/code&gt;.</source>
          <target state="translated">이 TurtleScreen 방법은 이름에서 전역 함수로 사용할 수 있습니다 &lt;code&gt;clearscreen&lt;/code&gt; . 전역 함수 &lt;code&gt;clear&lt;/code&gt; 는 Turtle 메소드 &lt;code&gt;clear&lt;/code&gt; 에서 파생 된 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9a5c7fbfb12e64e80a50cd253b77207e3f8d1c22" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;onscreenclick&lt;/code&gt;. The global function &lt;code&gt;onclick&lt;/code&gt; is another one derived from the Turtle method &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">이 TurtleScreen 방법은 이름에서 전역 함수로 사용할 수 있습니다 &lt;code&gt;onscreenclick&lt;/code&gt; . 전역 함수 &lt;code&gt;onclick&lt;/code&gt; 은 Turtle 메서드 &lt;code&gt;onclick&lt;/code&gt; 에서 파생 된 또 다른 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="cbcf70844f55515130094216c6263e62345d52b8" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;resetscreen&lt;/code&gt;. The global function &lt;code&gt;reset&lt;/code&gt; is another one derived from the Turtle method &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">이 TurtleScreen 방법은 이름 &lt;code&gt;resetscreen&lt;/code&gt; 에서만 전역 기능으로 사용할 수 있습니다 . 전역 함수 &lt;code&gt;reset&lt;/code&gt; 은 Turtle 메소드 &lt;code&gt;reset&lt;/code&gt; 에서 파생 된 또 다른 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="4f4aceb05d95d7a494f76ab4488a09282ba3d5bb" translate="yes" xml:space="preserve">
          <source>This activates a special exception handler that will display detailed reports in the Web browser if any errors occur. If you&amp;rsquo;d rather not show the guts of your program to users of your script, you can have the reports saved to files instead, with code like this:</source>
          <target state="translated">이렇게하면 오류가 발생할 경우 웹 브라우저에 자세한 보고서를 표시하는 특수 예외 처리기가 활성화됩니다. 스크립트 사용자에게 프로그램의 장을 표시하지 않으려면 다음과 같은 코드를 사용하여 보고서를 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="943d36d8edb0b61bc7c78f04ba488758674799cf" translate="yes" xml:space="preserve">
          <source>This affects &lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt;&lt;code&gt;getTestCaseNames()&lt;/code&gt;&lt;/a&gt; and all the &lt;code&gt;loadTestsFrom*()&lt;/code&gt; methods.</source>
          <target state="translated">이는 &lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt; &lt;code&gt;getTestCaseNames()&lt;/code&gt; &lt;/a&gt; 및 모든 &lt;code&gt;loadTestsFrom*()&lt;/code&gt; 메소드에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="4c629e7d2eb45c1763b440d04e7b2f6f6d1af0f0" translate="yes" xml:space="preserve">
          <source>This affects all the &lt;code&gt;loadTestsFrom*()&lt;/code&gt; methods.</source>
          <target state="translated">이것은 모든 &lt;code&gt;loadTestsFrom*()&lt;/code&gt; 메소드에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="7e1a9d70f32008ed3c96c0e9a74a6e82daf6f746" translate="yes" xml:space="preserve">
          <source>This allows applications to get a suspend-aware monotonic clock without having to deal with the complications of &lt;a href=&quot;#time.CLOCK_REALTIME&quot;&gt;&lt;code&gt;CLOCK_REALTIME&lt;/code&gt;&lt;/a&gt;, which may have discontinuities if the time is changed using &lt;code&gt;settimeofday()&lt;/code&gt; or similar.</source>
          <target state="translated">이를 통해 응용 프로그램은 &lt;a href=&quot;#time.CLOCK_REALTIME&quot;&gt; &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; &lt;/a&gt; 의 합병증을 처리하지 않고도 일시 중단 인식 단조로운 시계를 얻을 수 있습니다 . &lt;code&gt;settimeofday()&lt;/code&gt; 또는 이와 유사한 방법을 사용하여 시간이 변경되면 불연속성이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dc2bd0016562761a167a94107ea18ecde7bcee3" translate="yes" xml:space="preserve">
          <source>This allows one to have properties active on an instance, and have virtual attributes on the class with the same name (see Enum for an example).</source>
          <target state="translated">이를 통해 인스턴스에서 속성을 활성화하고 클래스에서 동일한 이름을 가진 가상 속성을 가질 수 있습니다 (예제 Enum 참조).</target>
        </trans-unit>
        <trans-unit id="f35eea3e328469bbb9e12d321786f404340c6df4" translate="yes" xml:space="preserve">
          <source>This allows the intended cleanup up behaviour to be made explicit up front, rather than requiring a separate flag variable.</source>
          <target state="translated">이를 통해 별도의 플래그 변수를 요구하지 않고 의도 된 정리 동작을 미리 명시 적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fca28bc4acec436ecfcdadf8513fc13af190b783" translate="yes" xml:space="preserve">
          <source>This allows the newly spawned Python interpreter to safely import the module and then run the module&amp;rsquo;s &lt;code&gt;foo()&lt;/code&gt; function.</source>
          <target state="translated">이렇게하면 새로 생성 된 Python 인터프리터가 모듈을 안전하게 가져오고 모듈의 &lt;code&gt;foo()&lt;/code&gt; 함수 를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57868094fc52a1cd6c9af993bb993a3e5544da0a" translate="yes" xml:space="preserve">
          <source>This allows you to use the shell filename completion to specify the test module. The file specified must still be importable as a module. The path is converted to a module name by removing the &amp;lsquo;.py&amp;rsquo; and converting path separators into &amp;lsquo;.&amp;rsquo;. If you want to execute a test file that isn&amp;rsquo;t importable as a module you should execute the file directly instead.</source>
          <target state="translated">쉘 파일 이름 완성을 사용하여 테스트 모듈을 지정할 수 있습니다. 지정된 파일은 여전히 ​​모듈로 가져올 수 있어야합니다. 경로는 '.py'를 제거하고 경로 구분 기호를 '.'로 변환하여 모듈 이름으로 변환됩니다. 모듈로 가져올 수없는 테스트 파일을 실행하려면 파일을 직접 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="38d1a626d9c7a8c9eaba4801730692cd5ed50152" translate="yes" xml:space="preserve">
          <source>This also means that it is not possible to create a subtype of &lt;code&gt;Derived&lt;/code&gt; since it is an identity function at runtime, not an actual type:</source>
          <target state="translated">이는 또한 실제 유형이 아닌 런타임시 ID 함수이므로 &lt;code&gt;Derived&lt;/code&gt; 의 하위 유형을 작성할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="80557a359ae07843f1afe80a27523489463324a4" translate="yes" xml:space="preserve">
          <source>This applies to &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt;&lt;code&gt;assert_called_with()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.mock.Mock.assert_has_calls&quot;&gt;&lt;code&gt;assert_has_calls()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.assert_any_call&quot;&gt;&lt;code&gt;assert_any_call()&lt;/code&gt;&lt;/a&gt;. When &lt;a href=&quot;#auto-speccing&quot;&gt;Autospeccing&lt;/a&gt;, it will also apply to method calls on the mock object.</source>
          <target state="translated">이는 &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt; &lt;code&gt;assert_called_with()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#unittest.mock.Mock.assert_has_calls&quot;&gt; &lt;code&gt;assert_has_calls()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.assert_any_call&quot;&gt; &lt;code&gt;assert_any_call()&lt;/code&gt; &lt;/a&gt; 됩니다. &lt;a href=&quot;#auto-speccing&quot;&gt;Autospeccing&lt;/a&gt; 일 때 모의 객체의 메소드 호출에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="537b430af62b891eeb9751af6b5c80e259818d26" translate="yes" xml:space="preserve">
          <source>This approach has been first presented in &lt;a href=&quot;https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader%241208?mode=topic&quot;&gt;a discussion on xmlrpc.com&lt;/a&gt;.</source>
          <target state="translated">이 접근 방식은 &lt;a href=&quot;https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader%241208?mode=topic&quot;&gt;xmlrpc.com&lt;/a&gt; 에 대한 토론에서 처음 제시되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fb8573037230d3969561b2945452190c58711f18" translate="yes" xml:space="preserve">
          <source>This approach is perhaps less convenient than employing nested &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt; for most use cases but also demonstrates a level of control over the synchronization.</source>
          <target state="translated">이 방법은 대부분의 사용 사례에 중첩 된 &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;프록시 객체&lt;/a&gt; 를 사용하는 것보다 편리하지 않을 수도 있지만 동기화에 대한 제어 수준을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a12a4abb0591cce4c8aa99900d108da46a55a5b6" translate="yes" xml:space="preserve">
          <source>This arranges for a &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception to be thrown into the wrapped coroutine on the next cycle of the event loop.</source>
          <target state="translated">이렇게 하면 이벤트 루프의 다음주기 에서 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외가 랩핑 된 코 루틴에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e81de60ddc5e6cb663061f6459f34a67618bb9be" translate="yes" xml:space="preserve">
          <source>This asks the thread to terminate, and then waits for it to do so. Note that if you don&amp;rsquo;t call this before your application exits, there may be some records still left on the queue, which won&amp;rsquo;t be processed.</source>
          <target state="translated">스레드를 종료하도록 요청한 다음 대기합니다. 응용 프로그램이 종료되기 전에 이것을 호출하지 않으면 대기열에 일부 레코드가 남아있을 수 있으며 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d862b47fe45aa6e17de78d8754a167b3ff452f1d" translate="yes" xml:space="preserve">
          <source>This attribute contains a mapping of error code integers to two-element tuples containing a short and long message. For example, &lt;code&gt;{code: (shortmessage,
longmessage)}&lt;/code&gt;. The &lt;em&gt;shortmessage&lt;/em&gt; is usually used as the &lt;em&gt;message&lt;/em&gt; key in an error response, and &lt;em&gt;longmessage&lt;/em&gt; as the &lt;em&gt;explain&lt;/em&gt; key. It is used by &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_response_only&quot;&gt;&lt;code&gt;send_response_only()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_error&quot;&gt;&lt;code&gt;send_error()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이 속성에는 오류 코드 정수를 짧고 긴 메시지를 포함하는 두 요소 튜플에 대한 맵핑이 포함됩니다. 예를 들면 &lt;code&gt;{code: (shortmessage, longmessage)}&lt;/code&gt; 입니다. &lt;em&gt;하는 ShortMessage는&lt;/em&gt; 일반적으로 사용되는 &lt;em&gt;메시지&lt;/em&gt; 오류 응답 키를 &lt;em&gt;longmessage&lt;/em&gt; 는 AS &lt;em&gt;설명&lt;/em&gt; 키를 누릅니다. 그것은 의해 사용 &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_response_only&quot;&gt; &lt;code&gt;send_response_only()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_error&quot;&gt; &lt;code&gt;send_error()&lt;/code&gt; &lt;/a&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="3265ec6de83e09f5a858d9d1321fb30470037593" translate="yes" xml:space="preserve">
          <source>This attribute contains the actual value of the instance. For integer and pointer types, it is an integer, for character types, it is a single character bytes object or string, for character pointer types it is a Python bytes object or string.</source>
          <target state="translated">이 속성은 인스턴스의 실제 값을 포함합니다. 정수 및 포인터 유형의 경우 정수이며 문자 유형의 경우 단일 문자 바이트 오브젝트 또는 문자열이며 문자 포인터 유형의 경우 Python 바이트 오브젝트 또는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ce1d216ac33ce7f92dd6899eec472d3df9018600" translate="yes" xml:space="preserve">
          <source>This attribute controls the maximum length of diffs output by assert methods that report diffs on failure. It defaults to 80*8 characters. Assert methods affected by this attribute are &lt;a href=&quot;#unittest.TestCase.assertSequenceEqual&quot;&gt;&lt;code&gt;assertSequenceEqual()&lt;/code&gt;&lt;/a&gt; (including all the sequence comparison methods that delegate to it), &lt;a href=&quot;#unittest.TestCase.assertDictEqual&quot;&gt;&lt;code&gt;assertDictEqual()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.TestCase.assertMultiLineEqual&quot;&gt;&lt;code&gt;assertMultiLineEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성은 실패시 diff를보고하는 assert 메소드로 최대 diff 출력 길이를 제어합니다. 기본값은 80 * 8 자입니다. 이 속성의 영향을받는 Assert 메소드는 &lt;a href=&quot;#unittest.TestCase.assertSequenceEqual&quot;&gt; &lt;code&gt;assertSequenceEqual()&lt;/code&gt; &lt;/a&gt; (위임하는 모든 시퀀스 비교 메소드 포함), &lt;a href=&quot;#unittest.TestCase.assertDictEqual&quot;&gt; &lt;code&gt;assertDictEqual()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.TestCase.assertMultiLineEqual&quot;&gt; &lt;code&gt;assertMultiLineEqual()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b756a9463a6c4c6c113805675dfcd1ed425d592" translate="yes" xml:space="preserve">
          <source>This attribute has no effect if the traceback limit is &lt;code&gt;1&lt;/code&gt;. See the &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; function and &lt;a href=&quot;#tracemalloc.Snapshot.traceback_limit&quot;&gt;&lt;code&gt;Snapshot.traceback_limit&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">역 추적 한계가 &lt;code&gt;1&lt;/code&gt; 인 경우이 속성은 적용되지 않습니다 . &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt; 함수 및 &lt;a href=&quot;#tracemalloc.Snapshot.traceback_limit&quot;&gt; &lt;code&gt;Snapshot.traceback_limit&lt;/code&gt; &lt;/a&gt; 참조하십시오. 속성을 .</target>
        </trans-unit>
        <trans-unit id="efb0d29d4166e46dd3615e90c15f7c9725a59567" translate="yes" xml:space="preserve">
          <source>This attribute is &lt;code&gt;None&lt;/code&gt; by default. If you assign a string to it, that string will be recognized as a lexical-level inclusion request similar to the &lt;code&gt;source&lt;/code&gt; keyword in various shells. That is, the immediately following token will be opened as a filename and input will be taken from that stream until EOF, at which point the &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method of that stream will be called and the input source will again become the original input stream. Source requests may be stacked any number of levels deep.</source>
          <target state="translated">이 속성은 기본적으로 &lt;code&gt;None&lt;/code&gt; 입니다. 문자열을 할당하면 해당 문자열은 다양한 쉘 의 &lt;code&gt;source&lt;/code&gt; 키워드 와 유사한 어휘 수준 포함 요청으로 인식됩니다 . 즉, 바로 다음 토큰이 파일 이름으로 열리고 입력이 EOF까지 해당 스트림에서 가져옵니다.이 시점에서 &lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출되고 입력 소스가 다시 원래 입력 스트림이됩니다. 소스 요청은 여러 수준의 깊이에 쌓일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2994dd43b52b07e7e69d05397ea676fc07397b4c" translate="yes" xml:space="preserve">
          <source>This attribute is a flag which controls the interpretation of blanks in the window. When it is on, trailing blanks on each line are ignored; any cursor motion that would land the cursor on a trailing blank goes to the end of that line instead, and trailing blanks are stripped when the window contents are gathered.</source>
          <target state="translated">이 속성은 창의 공백 해석을 제어하는 ​​플래그입니다. 켜져 있으면 각 줄의 후행 공백이 무시됩니다. 후행 공백에 커서를 놓는 커서 동작은 대신 해당 줄의 끝으로 이동하고 창 내용이 수집 될 때 후행 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="df0657bd69ee21a9f9148b59c9e8f837030cf6e4" translate="yes" xml:space="preserve">
          <source>This attribute is a tuple of classes that are considered when looking for base classes during method resolution.</source>
          <target state="translated">이 속성은 메소드 분석 중에 기본 클래스를 찾을 때 고려되는 클래스의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="78c2006f554cfe40d6509a13774214ddca5bbec4" translate="yes" xml:space="preserve">
          <source>This attribute is not available unless the ssl module is compiled with OpenSSL 1.1.0g or newer.</source>
          <target state="translated">ssl 모듈이 OpenSSL 1.1.0g 이상으로 컴파일되지 않으면이 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="166affef6e28f80e71c9ea85c86be9204124b32a" translate="yes" xml:space="preserve">
          <source>This attribute is not available unless the ssl module is compiled with OpenSSL 1.1.1 or newer.</source>
          <target state="translated">ssl 모듈이 OpenSSL 1.1.1 이상으로 컴파일되지 않으면이 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d549f5791df423d3f994ffbd043feb8576e017c0" translate="yes" xml:space="preserve">
          <source>This attribute is used by the &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; method; it is initialized from the first argument to the constructor, if present, or to &lt;code&gt;None&lt;/code&gt;, if absent.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 메소드 에서 사용됩니다 . 첫 번째 인수에서 생성자 (있는 경우)로, 또는 없는 경우 &lt;code&gt;None&lt;/code&gt; 으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="779ab2149480aad2f6fe229a1b14fecb93369fd5" translate="yes" xml:space="preserve">
          <source>This attribute should be set to a true value if the handler&amp;rsquo;s &lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt;&lt;code&gt;_write()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.BaseHandler._flush&quot;&gt;&lt;code&gt;_flush()&lt;/code&gt;&lt;/a&gt; are being used to communicate directly to the client, rather than via a CGI-like gateway protocol that wants the HTTP status in a special &lt;code&gt;Status:&lt;/code&gt; header.</source>
          <target state="translated">핸들러의 &lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt; &lt;code&gt;_write()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.BaseHandler._flush&quot;&gt; &lt;code&gt;_flush()&lt;/code&gt; &lt;/a&gt; 를 사용하여 특수한 &lt;code&gt;Status:&lt;/code&gt; 의 HTTP 상태를 원하는 CGI와 같은 게이트웨이 프로토콜을 통하지 않고 클라이언트와 직접 통신 하는 경우이 속성을 true로 설정해야합니다 . 헤더 .</target>
        </trans-unit>
        <trans-unit id="81e7c664cabc787942b1a455028793b2341024c0" translate="yes" xml:space="preserve">
          <source>This attribute&amp;rsquo;s default value is true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but false in &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt;&lt;code&gt;BaseCGIHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성의 기본값은 &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 에서 true 이지만 &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt; &lt;code&gt;BaseCGIHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; 에서 false입니다 .</target>
        </trans-unit>
        <trans-unit id="f563e489bccd3156ff8203cb8818c4bd46df456e" translate="yes" xml:space="preserve">
          <source>This base class defines the following read-only properties:</source>
          <target state="translated">이 기본 클래스는 다음과 같은 읽기 전용 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5540e595f1d0ce1ff248b688c117efa9d0c46875" translate="yes" xml:space="preserve">
          <source>This base class raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;. Subclasses may leave this method unimplemented.</source>
          <target state="translated">이 기본 클래스는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생시킵니다.&lt;/a&gt; 시킵니다. 서브 클래스는이 메소드를 구현하지 않은 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a8a8b933d05fd353efb75eb303a3e9a79cadd5" translate="yes" xml:space="preserve">
          <source>This behaves exactly like &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;, except that it yields a 4-tuple &lt;code&gt;(dirpath, dirnames, filenames, dirfd)&lt;/code&gt;, and it supports &lt;code&gt;dir_fd&lt;/code&gt;.</source>
          <target state="translated">이것은 4 튜플 &lt;code&gt;(dirpath, dirnames, filenames, dirfd)&lt;/code&gt; 을 생성하고 &lt;code&gt;dir_fd&lt;/code&gt; 를 지원 한다는 점을 제외하고는 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 와 똑같이 작동 합니다 . .</target>
        </trans-unit>
        <trans-unit id="f89ee084a5c3fb6a9b18d5de21c78508c481f569" translate="yes" xml:space="preserve">
          <source>This behavior allows &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; to be used as an &lt;em&gt;escape hatch&lt;/em&gt; when you need to mix dynamically and statically typed code.</source>
          <target state="translated">이 동작을 사용하면 동적 및 정적 형식의 코드를 혼합해야 할 때 &lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 를 &lt;em&gt;이스케이프 해치로&lt;/em&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b455e95c88343559228644a42667890d61597cf" translate="yes" xml:space="preserve">
          <source>This behavior can be customized by assigning to special attributes of the foreign function object.</source>
          <target state="translated">외부 함수 오브젝트의 특수 속성에 지정하여이 동작을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7379b341b2ba41615597b4e4d0b80854cab35ed" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the following handler attributes:</source>
          <target state="translated">이 동작은 다음 핸들러 속성에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="957754b3567b9946eb2150398bc70e91ad0ce381" translate="yes" xml:space="preserve">
          <source>This behaviour may be overridden by setting &lt;em&gt;text&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt;, or &lt;em&gt;universal_newlines&lt;/em&gt; to &lt;code&gt;True&lt;/code&gt; as described in &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt; and &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;#frequently-used-arguments&quot;&gt;자주 사용되는 인수&lt;/a&gt; 및 &lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 설명 된대로 &lt;em&gt;text&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; , &lt;em&gt;errors&lt;/em&gt; 또는 &lt;em&gt;universal_newlines&lt;/em&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e39c78a1690e05498b30b508c8ee358893459e4" translate="yes" xml:space="preserve">
          <source>This brings up another issue. It is relatively common to provide a default value of &lt;code&gt;None&lt;/code&gt; for members that will later be an object of a different type. &lt;code&gt;None&lt;/code&gt; would be useless as a spec because it wouldn&amp;rsquo;t let you access &lt;em&gt;any&lt;/em&gt; attributes or methods on it. As &lt;code&gt;None&lt;/code&gt; is &lt;em&gt;never&lt;/em&gt; going to be useful as a spec, and probably indicates a member that will normally of some other type, autospec doesn&amp;rsquo;t use a spec for members that are set to &lt;code&gt;None&lt;/code&gt;. These will just be ordinary mocks (well - MagicMocks):</source>
          <target state="translated">이것은 또 다른 문제를 일으킨다. 나중에 다른 유형의 오브젝트가되는 멤버에 대해 기본값 &lt;code&gt;None&lt;/code&gt; 을 제공하는 것이 일반적 입니다. &lt;code&gt;None&lt;/code&gt; 당신이 액세스 할 수없는 것 때문에 사양 쓸모 없을 것입니다 &lt;em&gt;어떤&lt;/em&gt; 그것에 속성이나 방법을. 마찬가지로 &lt;code&gt;None&lt;/code&gt; 있다 &lt;em&gt;결코&lt;/em&gt; 스펙으로 유용 할 것없고, 아마 일반적으로 다른 유형, autospec로 설정되어 회원에 대한 스펙을 사용하지 않는 것 구성원을 나타냅니다 &lt;code&gt;None&lt;/code&gt; . 이것들은 평범한 모의 일 것입니다 (잘-MagicMocks) :</target>
        </trans-unit>
        <trans-unit id="a01ade15639ca8f0fb9908b5bc15eb94fe21614a" translate="yes" xml:space="preserve">
          <source>This call (say, for example, creating a button widget), is implemented in the &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; package, which is written in Python. This Python function will parse the commands and the arguments and convert them into a form that makes them look as if they had come from a Tk script instead of a Python script.</source>
          <target state="translated">이 호출 (예 : 버튼 위젯 작성)은 Python으로 작성된 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 패키지로 구현됩니다 . 이 Python 함수는 명령과 인수를 구문 분석하여 Python 스크립트 대신 Tk 스크립트에서 온 것처럼 보이게하는 형태로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2a3932daa8300dd15eb1238ca7766ace7be0b25b" translate="yes" xml:space="preserve">
          <source>This call decodes uuencoded file &lt;em&gt;in_file&lt;/em&gt; placing the result on file &lt;em&gt;out_file&lt;/em&gt;. If &lt;em&gt;out_file&lt;/em&gt; is a pathname, &lt;em&gt;mode&lt;/em&gt; is used to set the permission bits if the file must be created. Defaults for &lt;em&gt;out_file&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt; are taken from the uuencode header. However, if the file specified in the header already exists, a &lt;a href=&quot;#uu.Error&quot;&gt;&lt;code&gt;uu.Error&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">이 호출은 uuencoded 파일 &lt;em&gt;in_file을&lt;/em&gt; 해독 하여 결과를 &lt;em&gt;out_file&lt;/em&gt; 파일에 배치합니다 . 경우 &lt;em&gt;out_file로 쓰기는&lt;/em&gt; 경로 이름입니다 &lt;em&gt;모드는&lt;/em&gt; 파일이 생성해야하는 경우 권한 비트를 설정하는 데 사용됩니다. &lt;em&gt;out_file&lt;/em&gt; 및 &lt;em&gt;mode의&lt;/em&gt; 기본값 은 uuencode 헤더에서 가져옵니다. 그러나 헤더에 지정된 파일이 이미 존재하면 &lt;a href=&quot;#uu.Error&quot;&gt; &lt;code&gt;uu.Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c674f16cfd26246b43950a59f15b8c54770ceded" translate="yes" xml:space="preserve">
          <source>This call will print in the standard output the information returned by &lt;a href=&quot;#sysconfig.get_platform&quot;&gt;&lt;code&gt;get_platform()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sysconfig.get_python_version&quot;&gt;&lt;code&gt;get_python_version()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sysconfig.get_path&quot;&gt;&lt;code&gt;get_path()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt;&lt;code&gt;get_config_vars()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 호출은 &lt;a href=&quot;#sysconfig.get_platform&quot;&gt; &lt;code&gt;get_platform()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#sysconfig.get_python_version&quot;&gt; &lt;code&gt;get_python_version()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#sysconfig.get_path&quot;&gt; &lt;code&gt;get_path()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt; &lt;code&gt;get_config_vars()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 정보를 표준 출력으로 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="a6469546206837a94e51f0f2845bca660667742c" translate="yes" xml:space="preserve">
          <source>This can be achieved from the &lt;a href=&quot;#python-interface&quot;&gt;Python Interface&lt;/a&gt; with:</source>
          <target state="translated">이것은 다음을 사용하여 &lt;a href=&quot;#python-interface&quot;&gt;Python 인터페이스&lt;/a&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d1d697fe2b31a15d36e206e65de28f58571ea8c" translate="yes" xml:space="preserve">
          <source>This can be called multiple times.</source>
          <target state="translated">여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b67e671a1c54666dadf6cd890333be68c8592ef" translate="yes" xml:space="preserve">
          <source>This can be especially problematic for the user to see if she&amp;rsquo;s using a proportional font to edit the file. That is why when your application does not need values with empty lines, you should consider disallowing them. This will make empty lines split keys every time. In the example above, it would produce two keys, &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">이것은 사용자가 비례 글꼴을 사용하여 파일을 편집하고 있는지 확인하는 데 특히 문제가 될 수 있습니다. 따라서 응용 프로그램에 빈 줄이있는 값이 필요하지 않으면 허용하지 않는 것이 좋습니다. 이렇게하면 빈 줄이 매번 키를 분리됩니다. 위의 예에서는 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;this&lt;/code&gt; 의 두 키를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="a82ddd14e1f001ea8311d0bd0c24af21a7865d61" translate="yes" xml:space="preserve">
          <source>This can be used for safely evaluating strings containing Python values from untrusted sources without the need to parse the values oneself. It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.</source>
          <target state="translated">값을 직접 구문 분석 할 필요없이 신뢰할 수없는 소스의 Python 값을 포함하는 문자열을 안전하게 평가하는 데 사용할 수 있습니다. 연산자 나 인덱싱과 같은 임의의 복잡한 식을 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a97c97150e89825c650323ea068e2c86fe1ae6b9" translate="yes" xml:space="preserve">
          <source>This can be used to build a shell for SQLite, as in the following example:</source>
          <target state="translated">다음 예제와 같이 SQLite 용 셸을 빌드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9fd3ddc0879e99d9c02d07c898720ba4d93e0c4" translate="yes" xml:space="preserve">
          <source>This can be used to decode a JSON document from a string that may have extraneous data at the end.</source>
          <target state="translated">마지막에 외부 데이터가있을 수있는 문자열에서 JSON 문서를 디코딩하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0497025141b27c807ca46930213e57d7c9800435" translate="yes" xml:space="preserve">
          <source>This can be used to make triple-quoted strings line up with the left edge of the display, while still presenting them in the source code in indented form.</source>
          <target state="translated">이것은 삼중 인용 문자열을 디스플레이의 왼쪽 가장자리에 맞추면서 소스 코드에 들여 쓰기 된 형태로 표시하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62fbb7012806d21eb05599eae86ce39d18cddf93" translate="yes" xml:space="preserve">
          <source>This can be useful where you want to make a series of assertions that reuse the same object. Note that &lt;a href=&quot;#unittest.mock.Mock.reset_mock&quot;&gt;&lt;code&gt;reset_mock()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; clear the return value, &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; or any child attributes you have set using normal assignment by default. In case you want to reset &lt;em&gt;return_value&lt;/em&gt; or &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt;, then pass the corresponding parameter as &lt;code&gt;True&lt;/code&gt;. Child mocks and the return value mock (if any) are reset as well.</source>
          <target state="translated">동일한 객체를 재사용하는 일련의 어설 션을 만들려는 경우에 유용 할 수 있습니다. 그 주 &lt;a href=&quot;#unittest.mock.Mock.reset_mock&quot;&gt; &lt;code&gt;reset_mock()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 하지 않습니다&lt;/em&gt; 반환 값을 취소 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 또는 아이가 당신이 기본적으로 정상 할당을 사용하여 설정 한 속성을. &lt;em&gt;return_value&lt;/em&gt; 또는 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 를 재설정하려는 경우 해당 매개 변수를 &lt;code&gt;True&lt;/code&gt; 로 전달하십시오. . 자식 모의 및 반환 값 모의 (있는 경우)도 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc685bbf811c69a67bb2bc60d0369711e84128df" translate="yes" xml:space="preserve">
          <source>This can either be a function to be called when the mock is called, an iterable or an exception (class or instance) to be raised.</source>
          <target state="translated">이것은 mock이 호출 될 때 호출되는 함수, iterable 또는 예외 (클래스 또는 인스턴스)가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66804a317957a21867ce8e32ff07c321923752e6" translate="yes" xml:space="preserve">
          <source>This causes the module to behave as it does when initially imported. For example, &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; will be called on the first &lt;a href=&quot;#module-syslog&quot;&gt;&lt;code&gt;syslog()&lt;/code&gt;&lt;/a&gt; call (if &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; hasn&amp;rsquo;t already been called), and &lt;em&gt;ident&lt;/em&gt; and other &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; parameters are reset to defaults.</source>
          <target state="translated">그러면 모듈을 처음 가져올 때와 같이 작동합니다. 예를 들어, &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 는 첫 번째 &lt;a href=&quot;#module-syslog&quot;&gt; &lt;code&gt;syslog()&lt;/code&gt; &lt;/a&gt; 호출에서 호출되고 ( &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 가 아직 호출되지 않은 경우 ) &lt;em&gt;ident&lt;/em&gt; 및 기타 &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 매개 변수는 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="17a078e1ca7ba133e471917a29a6b9a67bd6369b" translate="yes" xml:space="preserve">
          <source>This change is just syntactic sugar for any construct of the following form:</source>
          <target state="translated">이 변화는 다음과 같은 형태의 구문에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="20f0e4e7771296269c67abcb6e85f794dfe25cba" translate="yes" xml:space="preserve">
          <source>This class &lt;strong&gt;only&lt;/strong&gt; works with loaders that define &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; as control over what module type is used for the module is required. For those same reasons, the loader&amp;rsquo;s &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;create_module()&lt;/code&gt;&lt;/a&gt; method must return &lt;code&gt;None&lt;/code&gt; or a type for which its &lt;code&gt;__class__&lt;/code&gt; attribute can be mutated along with not using &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-slots&quot;&gt;slots&lt;/a&gt;. Finally, modules which substitute the object placed into &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; will not work as there is no way to properly replace the module references throughout the interpreter safely; &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if such a substitution is detected.</source>
          <target state="translated">이 클래스 는 필요한 모듈 유형에 대한 제어로 &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;exec_module()&lt;/code&gt; &lt;/a&gt; 을 정의하는 로더 &lt;strong&gt;에서만&lt;/strong&gt; 작동 합니다. 같은 이유로 로더의 &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;create_module()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;code&gt;None&lt;/code&gt; 이나 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-slots&quot;&gt;slots를&lt;/a&gt; 사용하지 않고 &lt;code&gt;__class__&lt;/code&gt; 속성을 변경할 수 있는 유형을 반환해야합니다 . 마지막으로 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 배치 된 객체 를 대체하는 모듈은 인터프리터 전체에서 모듈 참조를 안전하게 대체 할 수있는 방법이 없으므로 작동하지 않습니다. 이러한 대체가 감지되면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e680d4b2bbf72f285c1df68c923cf072d3a40f63" translate="yes" xml:space="preserve">
          <source>This class acts as a wrapper around list objects. It is a useful base class for your own list-like classes which can inherit from them and override existing methods or add new ones. In this way, one can add new behaviors to lists.</source>
          <target state="translated">이 클래스는 목록 객체 주위의 래퍼 역할을합니다. 자신의 목록과 같은 클래스에 대해 유용한 기본 클래스로, 클래스에서 상속하고 기존 메소드를 대체하거나 새 메소드를 추가 할 수 있습니다. 이런 식으로 목록에 새로운 동작을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1370cfdacaa0f9c4d0d1e1fcd0d6c3556803396d" translate="yes" xml:space="preserve">
          <source>This class attribute determines what happens when a custom failure message is passed as the msg argument to an assertXYY call that fails. &lt;code&gt;True&lt;/code&gt; is the default value. In this case, the custom message is appended to the end of the standard failure message. When set to &lt;code&gt;False&lt;/code&gt;, the custom message replaces the standard message.</source>
          <target state="translated">이 클래스 속성은 사용자 정의 실패 메시지가 실패한 assertXYY 호출에 msg 인수로 전달 될 때 발생하는 상황을 결정합니다. 기본값은 &lt;code&gt;True&lt;/code&gt; 입니다. 이 경우 사용자 정의 메시지가 표준 실패 메시지의 끝에 추가됩니다. &lt;code&gt;False&lt;/code&gt; 로 설정 하면 사용자 정의 메시지가 표준 메시지를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3288c0e4b6772fb834239a23818e745ac39e3d7b" translate="yes" xml:space="preserve">
          <source>This class attribute gives the exception raised by the test method. If a test framework needs to use a specialized exception, possibly to carry additional information, it must subclass this exception in order to &amp;ldquo;play fair&amp;rdquo; with the framework. The initial value of this attribute is &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스 속성은 테스트 메소드에서 발생한 예외를 제공합니다. 테스트 프레임 워크가 추가 정보를 전달하기 위해 특수한 예외를 사용해야하는 경우 프레임 워크와 &quot;공정한 플레이&quot;를 위해이 예외를 서브 클래 싱해야합니다. 이 속성의 초기 값은 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="786df7dd07465af2e7bc8b322a7dd7be2995de77" translate="yes" xml:space="preserve">
          <source>This class builds on the &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt; class by storing the server address as instance variables named &lt;code&gt;server_name&lt;/code&gt; and &lt;code&gt;server_port&lt;/code&gt;. The server is accessible by the handler, typically through the handler&amp;rsquo;s &lt;code&gt;server&lt;/code&gt; instance variable.</source>
          <target state="translated">이 클래스 는 서버 주소를 &lt;code&gt;server_name&lt;/code&gt; 및 &lt;code&gt;server_port&lt;/code&gt; 인스턴스 변수로 저장 하여 &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt; 클래스를 빌드합니다 . 핸들러는 일반적으로 핸들러의 &lt;code&gt;server&lt;/code&gt; 인스턴스 변수를 통해 서버에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a61b50fa9056bcc99d4dfaa7d5cc4c9f738f3886" translate="yes" xml:space="preserve">
          <source>This class can be used to create an HTML table (or a complete HTML file containing the table) showing a side by side, line by line comparison of text with inter-line and intra-line change highlights. The table can be generated in either full or contextual difference mode.</source>
          <target state="translated">이 클래스를 사용하면 텍스트를 줄 단위로 변경하고 줄 내부 변경 강조 표시를 한 줄씩 비교하여 표시하는 HTML 테이블 (또는 테이블을 포함하는 완전한 HTML 파일)을 만들 수 있습니다. 테이블은 전체 또는 상황 별 차이 모드로 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a485c6be944a5121095f4313a2ac49f87922ce2" translate="yes" xml:space="preserve">
          <source>This class can be used to generate HTML calendars.</source>
          <target state="translated">이 클래스는 HTML 달력을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24117e29e79a5bae324849b9f5e3b8f11a5140c9" translate="yes" xml:space="preserve">
          <source>This class can be used to generate plain text calendars.</source>
          <target state="translated">이 클래스는 일반 텍스트 달력을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a69c7233ae85db1ae66cdbf46d18176f63d3a972" translate="yes" xml:space="preserve">
          <source>This class can then be used as follows:</source>
          <target state="translated">이 클래스는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11039fec5c3d2704158aa1016ef70969433af2d0" translate="yes" xml:space="preserve">
          <source>This class constructor creates an instance of a &amp;ldquo;statistics object&amp;rdquo; from a &lt;em&gt;filename&lt;/em&gt; (or list of filenames) or from a &lt;code&gt;Profile&lt;/code&gt; instance. Output will be printed to the stream specified by &lt;em&gt;stream&lt;/em&gt;.</source>
          <target state="translated">이 클래스 생성자는 &lt;em&gt;파일 이름&lt;/em&gt; (또는 파일 이름 목록) 또는 &lt;code&gt;Profile&lt;/code&gt; 인스턴스 에서 &quot;통계 개체&quot;의 인스턴스를 만듭니다 . 출력에 의해 지정된 스트림에 인쇄됩니다 &lt;em&gt;스트림&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="997df475040ccebecaae3cb4fcd72a5ae6e0b056" translate="yes" xml:space="preserve">
          <source>This class deals with parsing and interpreter state (the user&amp;rsquo;s namespace); it does not deal with input buffering or prompting or input file naming (the filename is always passed in explicitly). The optional &lt;em&gt;locals&lt;/em&gt; argument specifies the dictionary in which code will be executed; it defaults to a newly created dictionary with key &lt;code&gt;'__name__'&lt;/code&gt; set to &lt;code&gt;'__console__'&lt;/code&gt; and key &lt;code&gt;'__doc__'&lt;/code&gt; set to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 파싱 및 인터프리터 상태 (사용자 네임 스페이스)를 처리합니다. 입력 버퍼링 또는 프롬 프팅 또는 입력 파일 이름 지정을 처리하지 않습니다 (파일 이름은 항상 명시 적으로 전달됨). 선택적 &lt;em&gt;locals&lt;/em&gt; 인수는 코드가 실행될 사전을 지정합니다. &lt;code&gt;'__name__'&lt;/code&gt; 키 가 &lt;code&gt;'__console__'&lt;/code&gt; &lt;code&gt;'__doc__'&lt;/code&gt; 설정되고 '__doc__' 키 가 &lt;code&gt;None&lt;/code&gt; 으로 설정된 새로 작성된 사전이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="ea6ff78f901f2fc6ecc7723c952f97db4d6143dc" translate="yes" xml:space="preserve">
          <source>This class defines the following properties, and thus values for the following may be passed in the constructor of any policy class:</source>
          <target state="translated">이 클래스는 다음과 같은 속성을 정의하므로 모든 정책 클래스의 생성자에 다음 값이 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62521481dfb6022d4e3553654487427b9e7ec310" translate="yes" xml:space="preserve">
          <source>This class derives from &lt;a href=&quot;#http.cookies.BaseCookie&quot;&gt;&lt;code&gt;BaseCookie&lt;/code&gt;&lt;/a&gt; and overrides &lt;code&gt;value_decode()&lt;/code&gt; and &lt;code&gt;value_encode()&lt;/code&gt;. SimpleCookie supports strings as cookie values. When setting the value, SimpleCookie calls the builtin &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; to convert the value to a string. Values received from HTTP are kept as strings.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#http.cookies.BaseCookie&quot;&gt; &lt;code&gt;BaseCookie&lt;/code&gt; &lt;/a&gt; 에서 파생되며 value_decode &lt;code&gt;value_decode()&lt;/code&gt; 및 &lt;code&gt;value_encode()&lt;/code&gt; 재정의 합니다. SimpleCookie는 문자열을 쿠키 값으로 지원합니다. 값을 설정할 때 SimpleCookie는 내장 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 값을 문자열로 변환합니다. HTTP에서받은 값은 문자열로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="31f80205c6eb10e35876f4bf787d88c5b1b59257" translate="yes" xml:space="preserve">
          <source>This class does not transparently handle inputs containing multiple compressed streams, unlike &lt;a href=&quot;#bz2.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;. If you need to decompress a multi-stream input with &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt;&lt;code&gt;BZ2Decompressor&lt;/code&gt;&lt;/a&gt;, you must use a new decompressor for each stream.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#bz2.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 과 달리 여러 압축 스트림을 포함하는 입력을 투명하게 처리하지 않습니다 . &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt; &lt;code&gt;BZ2Decompressor&lt;/code&gt; &lt;/a&gt; 로 멀티 스트림 입력을 압축 해제해야하는 경우 각 스트림에 대해 새로운 압축 해제 기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd0facb251a427869a35ff99157b4dc88e7a7c37" translate="yes" xml:space="preserve">
          <source>This class does not transparently handle inputs containing multiple compressed streams, unlike &lt;a href=&quot;#lzma.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt;. To decompress a multi-stream input with &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt;&lt;code&gt;LZMADecompressor&lt;/code&gt;&lt;/a&gt;, you must create a new decompressor for each stream.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#lzma.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 과 달리 여러 압축 스트림을 포함하는 입력을 투명하게 처리하지 않습니다 . &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt; &lt;code&gt;LZMADecompressor&lt;/code&gt; &lt;/a&gt; 로 멀티 스트림 입력을 압축 해제하려면 각 스트림에 대해 새로운 압축 해제 기를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa75e4118b76769ba47ad4be121a41b62ae457bf" translate="yes" xml:space="preserve">
          <source>This class has many &lt;code&gt;read_*()&lt;/code&gt; methods. Note that some of them raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; when the end of the connection is read, because they can return an empty string for other reasons. See the individual descriptions below.</source>
          <target state="translated">이 클래스에는 많은 &lt;code&gt;read_*()&lt;/code&gt; 메소드가 있습니다. 다른 이유로 인해 빈 문자열을 반환 할 수 있으므로 연결 끝을 읽을 때 일부는 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다. 아래의 개별 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="80f48affba28f3bca43510cbebf5f583a8d03e11" translate="yes" xml:space="preserve">
          <source>This class has no public constructor. An &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance must be created using the &lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt;&lt;code&gt;wrap_bio()&lt;/code&gt;&lt;/a&gt; method. This method will create the &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance and bind it to a pair of BIOs. The &lt;em&gt;incoming&lt;/em&gt; BIO is used to pass data from Python to the SSL protocol instance, while the &lt;em&gt;outgoing&lt;/em&gt; BIO is used to pass data the other way around.</source>
          <target state="translated">이 클래스에는 공개 생성자가 없습니다. &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 사용하여 작성해야합니다&lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt; &lt;code&gt;wrap_bio()&lt;/code&gt; &lt;/a&gt; 방법. 이 메소드는&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성하여한 쌍의 BIO에 바인딩합니다. &lt;em&gt;들어오는&lt;/em&gt; 그동안 BIO는 SSL 프로토콜 인스턴스에 파이썬에서 데이터를 전달하는 데 사용됩니다&lt;em&gt; 나가는&lt;/em&gt; BIO는 주위의 데이터를 다른 방법으로 전달하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d597fa762f6194a350ab0c738e09d5a34ddc0834" translate="yes" xml:space="preserve">
          <source>This class implements an interface on top of a low-level SSL object as implemented by OpenSSL. This object captures the state of an SSL connection but does not provide any network IO itself. IO needs to be performed through separate &amp;ldquo;BIO&amp;rdquo; objects which are OpenSSL&amp;rsquo;s IO abstraction layer.</source>
          <target state="translated">이 클래스는 OpenSSL에 의해 구현 된 하위 레벨 SSL 객체 위에 인터페이스를 구현합니다. 이 오브젝트는 SSL 연결 상태를 캡처하지만 네트워크 IO 자체는 제공하지 않습니다. IO는 OpenSSL의 IO 추상화 계층 인 별도의 &quot;BIO&quot;객체를 통해 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="914712e8832275f17564086e782d3f6685437de0" translate="yes" xml:space="preserve">
          <source>This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread.</source>
          <target state="translated">이 클래스는 조건 변수 객체를 구현합니다. 조건 변수를 사용하면 하나 이상의 스레드가 다른 스레드에 의해 통지 될 때까지 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="878bdcd121b4b294dea82e17949c61b8c083f5ce" translate="yes" xml:space="preserve">
          <source>This class implements reentrant lock objects. A reentrant lock must be released by the thread that acquired it. Once a thread has acquired a reentrant lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.</source>
          <target state="translated">이 클래스는 재진입 잠금 개체를 구현합니다. 재진입 잠금은 획득 한 스레드에서 해제해야합니다. 스레드가 재진입 잠금을 획득하면 동일한 스레드가 차단하지 않고 다시 스레드를 획득 할 수 있습니다. 스레드는 획득 할 때마다 한 번씩 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="f24265f6cb6b6c3d8739448c1ec326c1945fc991" translate="yes" xml:space="preserve">
          <source>This class implements semaphore objects. A semaphore manages an atomic counter representing the number of &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; calls minus the number of &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; calls, plus an initial value. The &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method blocks if necessary until it can return without making the counter negative. If not given, &lt;em&gt;value&lt;/em&gt; defaults to 1.</source>
          <target state="translated">이 클래스는 세마포어 객체를 구현합니다. 세마포어는 &lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 수에서 &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 호출 수에 초기 값을 더한 원자 카운터를 관리합니다 . 그만큼&lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 메소드 블록은 카운터 마이너스 않고 리턴 할 때까지 필요한 경우. 주어진하지 않으면&lt;em&gt; 값&lt;/em&gt; 1 기본값.</target>
        </trans-unit>
        <trans-unit id="06f375996fb5283c367303d6d557ff26404aa722" translate="yes" xml:space="preserve">
          <source>This class implements temporary breakpoints, ignore counts, disabling and (re-)enabling, and conditionals.</source>
          <target state="translated">이 클래스는 임시 중단 점을 구현하고, 카운트 무시, 비활성화 및 (재) 활성화 및 조건을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ef8ab9b1f017689b8221855e12ddfb98f5fab5ae" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;a href=&quot;xml.sax.handler#xml.sax.handler.ContentHandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; interface by writing SAX events back into an XML document. In other words, using an &lt;a href=&quot;#xml.sax.saxutils.XMLGenerator&quot;&gt;&lt;code&gt;XMLGenerator&lt;/code&gt;&lt;/a&gt; as the content handler will reproduce the original document being parsed. &lt;em&gt;out&lt;/em&gt; should be a file-like object which will default to &lt;em&gt;sys.stdout&lt;/em&gt;. &lt;em&gt;encoding&lt;/em&gt; is the encoding of the output stream which defaults to &lt;code&gt;'iso-8859-1'&lt;/code&gt;. &lt;em&gt;short_empty_elements&lt;/em&gt; controls the formatting of elements that contain no content: if &lt;code&gt;False&lt;/code&gt; (the default) they are emitted as a pair of start/end tags, if set to &lt;code&gt;True&lt;/code&gt; they are emitted as a single self-closed tag.</source>
          <target state="translated">이 클래스는 SAX 이벤트를 XML 문서에 다시 써서 &lt;a href=&quot;xml.sax.handler#xml.sax.handler.ContentHandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . 즉, &lt;a href=&quot;#xml.sax.saxutils.XMLGenerator&quot;&gt; &lt;code&gt;XMLGenerator&lt;/code&gt; &lt;/a&gt; 를 컨텐츠 핸들러로 사용하면 구문 분석중인 원본 문서가 재생성됩니다. &lt;em&gt;out&lt;/em&gt; 은 파일과 같은 객체 여야하며 기본값은 &lt;em&gt;sys.stdout&lt;/em&gt; 입니다. &lt;em&gt;encoding&lt;/em&gt; 은 출력 스트림의 인코딩이며 기본값은 &lt;code&gt;'iso-8859-1'&lt;/code&gt; 입니다. &lt;em&gt;short_empty_elements&lt;/em&gt; 는 내용을 포함하지 않는 요소의 형식을 제어합니다. &lt;code&gt;False&lt;/code&gt; (기본값) 인 경우 시작 / 종료 태그 쌍으로 생성되며 &lt;code&gt;True&lt;/code&gt; 로 설정 하면 단일 자체 닫힘 태그로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c98a08502c61e88276fa107a306b9bc8b9b51f82" translate="yes" xml:space="preserve">
          <source>This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If &lt;em&gt;host&lt;/em&gt; is not specified, &lt;code&gt;''&lt;/code&gt; (the local host) is used. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard IMAP4 port (143) is used.</source>
          <target state="translated">이 클래스는 실제 IMAP4 프로토콜을 구현합니다. 연결이 작성되고 인스턴스가 초기화 될 때 프로토콜 버전 (IMAP4 또는 IMAP4rev1)이 결정됩니다. 경우 &lt;em&gt;호스트가&lt;/em&gt; 지정되지 않은, &lt;code&gt;''&lt;/code&gt; (로컬 호스트)가 사용됩니다. 경우 &lt;em&gt;포트는&lt;/em&gt; 생략 표준 IMAP4 포트 (143)가 사용된다.</target>
        </trans-unit>
        <trans-unit id="0180b25a093580d58646f91f83b8f7e9cbab599d" translate="yes" xml:space="preserve">
          <source>This class implements the actual POP3 protocol. The connection is created when the instance is initialized. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard POP3 port (110) is used. The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for the connection attempt (if not specified, the global default timeout setting will be used).</source>
          <target state="translated">이 클래스는 실제 POP3 프로토콜을 구현합니다. 인스턴스가 초기화되면 연결이 생성됩니다. 경우 &lt;em&gt;포트는&lt;/em&gt; 생략 표준 POP3 포트 (110)가 사용된다. 선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수는 연결 시도에 대한 시간 초과를 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간 초과 설정이 사용됨).</target>
        </trans-unit>
        <trans-unit id="3a79142561e96a9c93e4a6f25d9a885ccc0ed19a" translate="yes" xml:space="preserve">
          <source>This class implements the portion of the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; interface which allows the test runner to drive the test, but does not provide the methods which test code can use to check and report errors. This is used to create test cases using legacy test code, allowing it to be integrated into a &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;-based test framework.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 인터페이스 의 일부를 구현하여 테스트 실행자가 테스트를 수행 할 수 있도록하지만 테스트 코드가 오류를 확인하고보고하는 데 사용할 수있는 메소드는 제공하지 않습니다. 레거시 테스트 코드를 사용하여 테스트 사례를 생성하는 데 사용됩니다.&lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 기반의 테스트 프레임 워크.</target>
        </trans-unit>
        <trans-unit id="1b5d0a87fabd812ddac703c4acba87065679d185" translate="yes" xml:space="preserve">
          <source>This class is &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;not thread safe&lt;/a&gt;.</source>
          <target state="translated">이 수업은 &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt; 스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99bb71c8691256ec79b26eef0240bf9f20850bd6" translate="yes" xml:space="preserve">
          <source>This class is a dictionary-like object whose keys are strings and whose values are &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt; instances. Note that upon setting a key to a value, the value is first converted to a &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt; containing the key and the value.</source>
          <target state="translated">이 클래스는 키가 문자열이고 값이 &lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt; 인스턴스 인 사전과 유사한 객체입니다 . 키를 값으로 설정하면 값은 먼저 키와 값을 포함 하는 &lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0ca616b29a0013c8896bdb2f5eebfbd623fd044" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#asyncio.Handle&quot;&gt;&lt;code&gt;Handle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#asyncio.Handle&quot;&gt; &lt;code&gt;Handle&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="bc1a4fba51c4143a764de9b3702c6dad4e57616d" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt;&lt;code&gt;BaseCGIHandler&lt;/code&gt;&lt;/a&gt; that sets &lt;code&gt;wsgi.run_once&lt;/code&gt; to true, &lt;code&gt;wsgi.multithread&lt;/code&gt; to false, and &lt;code&gt;wsgi.multiprocess&lt;/code&gt; to true, and always uses &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; to obtain the necessary CGI streams and environment.</source>
          <target state="translated">이 클래스는 하위 클래스입니다 &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt; &lt;code&gt;BaseCGIHandler&lt;/code&gt; &lt;/a&gt; 세트 것을 &lt;code&gt;wsgi.run_once&lt;/code&gt; true로, &lt;code&gt;wsgi.multithread&lt;/code&gt; false로, 그리고 &lt;code&gt;wsgi.multiprocess&lt;/code&gt; true로, 항상 사용 &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; 하고&lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; CGI 스트림과 환경에 필요한를 얻을.</target>
        </trans-unit>
        <trans-unit id="8380c0b548cc2e264460ea64612afb578b6a25a2" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;. It overrides the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;get_stdin()&lt;/code&gt;, &lt;code&gt;get_stderr()&lt;/code&gt;, &lt;code&gt;add_cgi_vars()&lt;/code&gt;, &lt;code&gt;_write()&lt;/code&gt;, and &lt;code&gt;_flush()&lt;/code&gt; methods to support explicitly setting the environment and streams via the constructor. The supplied environment and streams are stored in the &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt;, and &lt;code&gt;environ&lt;/code&gt; attributes.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 . 이 재정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;get_stdin()&lt;/code&gt; , &lt;code&gt;get_stderr()&lt;/code&gt; , &lt;code&gt;add_cgi_vars()&lt;/code&gt; , &lt;code&gt;_write()&lt;/code&gt; 및 &lt;code&gt;_flush()&lt;/code&gt; 생성자를 통해 환경 설정을 명시 적 흐름을 지원하는 방법. 제공된 환경 및 스트림은 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; 및 &lt;code&gt;environ&lt;/code&gt; 속성에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9e951623508bbecd101c96001b60f6dffab7df5d" translate="yes" xml:space="preserve">
          <source>This class is a subclass of &lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt;&lt;code&gt;SimpleHandler&lt;/code&gt;&lt;/a&gt; intended for use with software other than HTTP &amp;ldquo;origin servers&amp;rdquo;. If you are writing a gateway protocol implementation (such as CGI, FastCGI, SCGI, etc.) that uses a &lt;code&gt;Status:&lt;/code&gt; header to send an HTTP status, you probably want to subclass this instead of &lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt;&lt;code&gt;SimpleHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 HTTP &quot;원본 서버&quot;이외의 소프트웨어와 함께 사용하기위한 &lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt; &lt;code&gt;SimpleHandler&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . &lt;code&gt;Status:&lt;/code&gt; 헤더를 사용 하여 HTTP 상태를 전송하는 게이트웨이 프로토콜 구현 (예 : CGI, FastCGI, SCGI 등)을 작성하는 경우이 클래스 대신 서브 클래스를 작성하려고합니다.&lt;a href=&quot;#wsgiref.handlers.SimpleHandler&quot;&gt; &lt;code&gt;SimpleHandler&lt;/code&gt; 하려고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c92ecd5d85f70cf680d95261e8d2ae49751975a2" translate="yes" xml:space="preserve">
          <source>This class is an abstract subclass of &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt;. To make practical use of the code you must subclass &lt;a href=&quot;#asynchat.async_chat&quot;&gt;&lt;code&gt;async_chat&lt;/code&gt;&lt;/a&gt;, providing meaningful &lt;a href=&quot;#asynchat.async_chat.collect_incoming_data&quot;&gt;&lt;code&gt;collect_incoming_data()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; methods. The &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt; methods can be used, although not all make sense in a message/response context.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt; 의 추상 서브 클래스입니다 . 코드를 실제로 사용하려면 의미있는 &lt;a href=&quot;#asynchat.async_chat.collect_incoming_data&quot;&gt; &lt;code&gt;collect_incoming_data()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt; 메소드를 제공하여 &lt;a href=&quot;#asynchat.async_chat&quot;&gt; &lt;code&gt;async_chat&lt;/code&gt; 을&lt;/a&gt; 서브 클래 싱해야합니다 . 그만큼&lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; 의&lt;/a&gt; 방법이 이용 될 수있는 메시지 / 응답 컨텍스트에서 모든 화장 감지 않는다.</target>
        </trans-unit>
        <trans-unit id="087906235606c3c8fcaffe0693c559a88547f320" translate="yes" xml:space="preserve">
          <source>This class is an abstraction of a URL request.</source>
          <target state="translated">이 클래스는 URL 요청의 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="0c6a034b6a98360f469f65a28d42a14f807ea562" translate="yes" xml:space="preserve">
          <source>This class is deliberately simple, just an &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; subclass with a readable string representation. If you prefer to have dict-like view of the attributes, you can use the standard Python idiom, &lt;a href=&quot;functions#vars&quot;&gt;&lt;code&gt;vars()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 클래스는 의도적으로 단순 하며 읽을 수있는 문자열 표현이있는 &lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 서브 클래스 일뿐 입니다. 속성에 대한 dict-like보기를 선호하는 경우 표준 Python 관용구 &lt;a href=&quot;functions#vars&quot;&gt; &lt;code&gt;vars()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5fcd1581caf40e9e0df5f205f111b1168737d46" translate="yes" xml:space="preserve">
          <source>This class is designed to have a similar API to the &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt; class, but there are some notable differences:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 클래스 와 유사한 API를 갖도록 설계 되었지만 몇 가지 눈에 띄는 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="548e5fba14e42ef23c63d6ed78e4af70b26ae4c7" translate="yes" xml:space="preserve">
          <source>This class is designed to sit between an &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt; and the client application&amp;rsquo;s event handlers. By default, it does nothing but pass requests up to the reader and events on to the handlers unmodified, but subclasses can override specific methods to modify the event stream or the configuration requests as they pass through.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt; 와 클라이언트 응용 프로그램의 이벤트 처리기 사이에 위치하도록 설계되었습니다 . 기본적으로 요청을 리더에게 전달하고 이벤트를 수정되지 않은 처리기로 전달하지만 서브 클래스는 특정 메소드를 대체하여 이벤트 스트림 또는 구성 요청이 전달 될 때이를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efbe53f191c0337a6044ecda5cb8ff2affeb594f" translate="yes" xml:space="preserve">
          <source>This class is identical to HTTPServer but uses threads to handle requests by using the &lt;a href=&quot;socketserver#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt;. This is useful to handle web browsers pre-opening sockets, on which &lt;a href=&quot;#http.server.HTTPServer&quot;&gt;&lt;code&gt;HTTPServer&lt;/code&gt;&lt;/a&gt; would wait indefinitely.</source>
          <target state="translated">이 클래스는 HTTPServer와 동일하지만 스레드를 사용하여 &lt;a href=&quot;socketserver#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt; 을 사용하여 요청을 처리합니다 . 이것은 &lt;a href=&quot;#http.server.HTTPServer&quot;&gt; &lt;code&gt;HTTPServer&lt;/code&gt; &lt;/a&gt; 에서 웹 브라우저 사전 열기 소켓을 처리하는 데 유용합니다 가 무기한 대기 합니다.</target>
        </trans-unit>
        <trans-unit id="782b34777524d6fe446584f87d0601af4116f199" translate="yes" xml:space="preserve">
          <source>This class is meant to be subclassed, with the subclass adding visitor methods.</source>
          <target state="translated">이 클래스는 서브 클래스에 방문자 메소드를 추가하여 서브 클래 싱됩니다.</target>
        </trans-unit>
        <trans-unit id="f0df1f01557aa8ffb4f27cded6abda03c3defe24" translate="yes" xml:space="preserve">
          <source>This class is normally only used if more precise control over profiling is needed than what the &lt;code&gt;cProfile.run()&lt;/code&gt; function provides.</source>
          <target state="translated">이 클래스는 일반적으로 &lt;code&gt;cProfile.run()&lt;/code&gt; 함수가 제공 하는 것보다 프로파일 링에 대한보다 정확한 제어가 필요한 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dedbc6f4178266f9137c0a6e0806aaa414d428e9" translate="yes" xml:space="preserve">
          <source>This class is parallel to &lt;a href=&quot;#email.parser.BytesParser&quot;&gt;&lt;code&gt;BytesParser&lt;/code&gt;&lt;/a&gt;, but handles string input.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#email.parser.BytesParser&quot;&gt; &lt;code&gt;BytesParser&lt;/code&gt; &lt;/a&gt; 와 병렬 이지만 문자열 입력을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="27e7cca9674c69cbae553d2787cd0068cccf6b1d" translate="yes" xml:space="preserve">
          <source>This class is rarely used as emitting a warning about a possible upcoming deprecation is unusual, and &lt;a href=&quot;#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt; is preferred for already active deprecations.</source>
          <target state="translated">이 클래스는 앞으로의 지원 중단에 대한 경고를 표시하는 데 거의 사용되지 않으며, 이미 활성화 된 지원 중단에 대해 &lt;a href=&quot;#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; &lt;/a&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="d95705b4a873383b5806c6228d0f0b76c0192a86" translate="yes" xml:space="preserve">
          <source>This class is responsible for deciding whether each cookie should be accepted from / returned to the server.</source>
          <target state="translated">이 클래스는 각 쿠키가 서버에서 수락 / 서버로 반환되어야하는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3fa43e85129f543fb2802d9d69d28e5ae356d069" translate="yes" xml:space="preserve">
          <source>This class is the low-level building block of the module. It uses &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; for efficient, event-based parsing of XML. It can be fed XML data incrementally with the &lt;a href=&quot;#xml.etree.ElementTree.XMLParser.feed&quot;&gt;&lt;code&gt;feed()&lt;/code&gt;&lt;/a&gt; method, and parsing events are translated to a push API - by invoking callbacks on the &lt;em&gt;target&lt;/em&gt; object. If &lt;em&gt;target&lt;/em&gt; is omitted, the standard &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt;&lt;code&gt;TreeBuilder&lt;/code&gt;&lt;/a&gt; is used. If &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id8&quot;&gt;1&lt;/a&gt; is given, the value overrides the encoding specified in the XML file.</source>
          <target state="translated">이 클래스는 모듈의 하위 레벨 빌딩 블록입니다. 효율적인 이벤트 기반 XML 구문 분석을 위해 &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; &lt;/a&gt; 를 사용합니다 . &lt;a href=&quot;#xml.etree.ElementTree.XMLParser.feed&quot;&gt; &lt;code&gt;feed()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 XML 데이터를 점진적으로 공급할 수 있으며 구문 분석 이벤트는 &lt;em&gt;대상&lt;/em&gt; 오브젝트 에서 콜백을 호출하여 푸시 API로 변환됩니다 . 경우 &lt;em&gt;타겟&lt;/em&gt; 생략 표준&lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt; &lt;code&gt;TreeBuilder&lt;/code&gt; 가&lt;/a&gt; 사용된다. 경우&lt;em&gt; 인코딩 &lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id8&quot;&gt;한 것은&lt;/a&gt; 주어, 값은 XML 파일에 지정된 인코딩을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a8d4e4a2b443c0328627e07d8942450df6f9acd5" translate="yes" xml:space="preserve">
          <source>This class is used to compile information about which tests have succeeded and which have failed.</source>
          <target state="translated">이 클래스는 성공한 테스트와 실패한 테스트 정보를 컴파일하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19c6d25e7d0520fa3fa0d6f7f3496202c2b9609d" translate="yes" xml:space="preserve">
          <source>This class is used to declare a new Context Variable, e.g.:</source>
          <target state="translated">이 클래스는 다음과 같은 새로운 컨텍스트 변수를 선언하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea543c836937291f06020a0688e606be1c234c21" translate="yes" xml:space="preserve">
          <source>This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; it must be subclassed to handle each request method (e.g. GET or POST). &lt;a href=&quot;#http.server.BaseHTTPRequestHandler&quot;&gt;&lt;code&gt;BaseHTTPRequestHandler&lt;/code&gt;&lt;/a&gt; provides a number of class and instance variables, and methods for use by subclasses.</source>
          <target state="translated">이 클래스는 서버에 도착하는 HTTP 요청을 처리하는 데 사용됩니다. 그 자체로는 실제 HTTP 요청에 응답 할 수 없습니다. 각 요청 메소드 (예 : GET 또는 POST)를 처리하려면 서브 클래 싱되어야합니다.&lt;a href=&quot;#http.server.BaseHTTPRequestHandler&quot;&gt; &lt;code&gt;BaseHTTPRequestHandler&lt;/code&gt; &lt;/a&gt; 는 많은 클래스 및 인스턴스 변수와 서브 클래스가 사용할 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6403a1c9fef53db5449f8e3ec933899d44b75e13" translate="yes" xml:space="preserve">
          <source>This class is used to manipulate the style database.</source>
          <target state="translated">이 클래스는 스타일 데이터베이스를 조작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae41f6c700530ae3123c6899bdeb790bf978c70d" translate="yes" xml:space="preserve">
          <source>This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in &lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt;&lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 현재 디렉토리와 그 아래에서 CGI 스크립트의 파일 또는 출력을 제공하는 데 사용됩니다. HTTP 계층 구조를 로컬 디렉토리 구조에 맵핑하는 것은&lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt; &lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt; &lt;/a&gt;합니다.</target>
        </trans-unit>
        <trans-unit id="d73a28b6898088641cae4d2fb4ef19cb14030dc9" translate="yes" xml:space="preserve">
          <source>This class may be initialized from bytes data (which may include NULs). The primary access to the content of a &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt;&lt;code&gt;Binary&lt;/code&gt;&lt;/a&gt; object is provided by an attribute:</source>
          <target state="translated">이 클래스는 바이트 데이터 (NUL 포함)에서 초기화 될 수 있습니다. &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt; &lt;code&gt;Binary&lt;/code&gt; &lt;/a&gt; 객체 의 내용에 대한 기본 액세스 는 속성에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e153045d5ef230e03be4d8fd269f06139bac488b" translate="yes" xml:space="preserve">
          <source>This class may be initialized with seconds since the epoch, a time tuple, an ISO 8601 time/date string, or a &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; instance. It has the following methods, supported mainly for internal use by the marshalling/unmarshalling code:</source>
          <target state="translated">이 클래스는 에포크 이후의 초, 시간 튜플, ISO 8601 시간 / 날짜 문자열 또는 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; 이후에 초기화 될 수 있습니다. 인스턴스 . 마샬링 / 비 정렬 화 코드에서 주로 내부 용으로 지원되는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e518e965c65cd6eb618dfd9b0ac0288dcc5ef8d9" translate="yes" xml:space="preserve">
          <source>This class may include information about the public identifier, system identifier, byte stream (possibly with character encoding information) and/or the character stream of an entity.</source>
          <target state="translated">이 클래스는 공개 식별자, 시스템 식별자, 바이트 스트림 (문자 인코딩 정보와 함께) 및 / 또는 엔티티의 문자 스트림에 대한 정보를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="274d480a865d7adb6c54dc75d212c4d48857918f" translate="yes" xml:space="preserve">
          <source>This class method constructs a &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; representing the exact value of &lt;em&gt;dec&lt;/em&gt;, which must be a &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">이 클래스의 방법은 구축 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 의 정확한 값을 나타내는 &lt;em&gt;십이&lt;/em&gt; 해야합니다, &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; 을&lt;/a&gt; 인스턴스 합니다.</target>
        </trans-unit>
        <trans-unit id="3fd368dae9da5194b728f020cb469d8249732946" translate="yes" xml:space="preserve">
          <source>This class method constructs a &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; representing the exact value of &lt;em&gt;flt&lt;/em&gt;, which must be a &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Beware that &lt;code&gt;Fraction.from_float(0.3)&lt;/code&gt; is not the same value as &lt;code&gt;Fraction(3, 10)&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 방법은 구축 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 의 정확한 값을 나타내는 &lt;em&gt;FLT&lt;/em&gt; 해야합니다, &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . 그주의 &lt;code&gt;Fraction.from_float(0.3)&lt;/code&gt; 같은 값이 아닌 &lt;code&gt;Fraction(3, 10)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c95eb91a808c54e72687a20b7b718fbb74eea5b6" translate="yes" xml:space="preserve">
          <source>This class method is not implemented for &lt;a href=&quot;#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">이 클래스 메서드는 &lt;a href=&quot;#collections.Counter&quot;&gt; &lt;code&gt;Counter&lt;/code&gt; &lt;/a&gt; 개체에 대해 구현되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="748288d24682412f0009c250de2e85bbeb99569b" translate="yes" xml:space="preserve">
          <source>This class provides &lt;a href=&quot;#modulefinder.ModuleFinder.run_script&quot;&gt;&lt;code&gt;run_script()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#modulefinder.ModuleFinder.report&quot;&gt;&lt;code&gt;report()&lt;/code&gt;&lt;/a&gt; methods to determine the set of modules imported by a script. &lt;em&gt;path&lt;/em&gt; can be a list of directories to search for modules; if not specified, &lt;code&gt;sys.path&lt;/code&gt; is used. &lt;em&gt;debug&lt;/em&gt; sets the debugging level; higher values make the class print debugging messages about what it&amp;rsquo;s doing. &lt;em&gt;excludes&lt;/em&gt; is a list of module names to exclude from the analysis. &lt;em&gt;replace_paths&lt;/em&gt; is a list of &lt;code&gt;(oldpath, newpath)&lt;/code&gt; tuples that will be replaced in module paths.</source>
          <target state="translated">이 클래스는 스크립트에서 가져온 모듈 세트를 판별하기 위한 &lt;a href=&quot;#modulefinder.ModuleFinder.run_script&quot;&gt; &lt;code&gt;run_script()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#modulefinder.ModuleFinder.report&quot;&gt; &lt;code&gt;report()&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다 . &lt;em&gt;path&lt;/em&gt; 는 모듈을 검색 할 디렉토리 목록 일 수 있습니다. 지정하지 않으면 &lt;code&gt;sys.path&lt;/code&gt; 가 사용됩니다. &lt;em&gt;디버그&lt;/em&gt; 는 디버깅 수준을 설정합니다. 값이 클수록 클래스는 수행중인 작업에 대한 디버깅 메시지를 인쇄합니다. &lt;em&gt;제외&lt;/em&gt; 는 분석에서 제외 할 모듈 이름 목록입니다. &lt;em&gt;replace_paths&lt;/em&gt; 는 모듈 경로에서 대체 될 &lt;code&gt;(oldpath, newpath)&lt;/code&gt; 튜플 의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="d834a754ee71425bdd757a24acd21616bac9cee6" translate="yes" xml:space="preserve">
          <source>This class provides a simple synchronization primitive for use by a fixed number of threads that need to wait for each other. Each of the threads tries to pass the barrier by calling the &lt;a href=&quot;#threading.Barrier.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method and will block until all of the threads have made their &lt;a href=&quot;#threading.Barrier.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; calls. At this point, the threads are released simultaneously.</source>
          <target state="translated">이 클래스는 서로를 기다려야하는 고정 된 수의 스레드에서 사용할 간단한 동기화 기본을 제공합니다. 각 스레드는 &lt;a href=&quot;#threading.Barrier.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 장벽을 통과하려고 시도하고 모든 스레드가 &lt;a href=&quot;#threading.Barrier.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출을 수행 할 때까지 차단 합니다. 이 시점에서 스레드가 동시에 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="08dad0580cbeaccad622fabb4161de4b7fe561bf" translate="yes" xml:space="preserve">
          <source>This class provides an API similar to &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; and also accepts coroutines as test functions.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 와 유사한 API를 제공하며 코 루틴을 테스트 함수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c276e1c0e7d656e7cea1025636063d50ff0ad285" translate="yes" xml:space="preserve">
          <source>This class provides empty abstract implementations for many methods that derived classes can override selectively; the default implementations represent a file that cannot be read, written or seeked.</source>
          <target state="translated">이 클래스는 파생 클래스가 선택적으로 재정의 할 수있는 많은 메서드에 대해 빈 추상 구현을 제공합니다. 기본 구현은 읽거나 쓰거나 검색 할 수없는 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d70311a21c8bcd74dcf12663d62377b18ed78824" translate="yes" xml:space="preserve">
          <source>This class provides information about the requirements imposed on email for a specific character set. It also provides convenience routines for converting between character sets, given the availability of the applicable codecs. Given a character set, it will do its best to provide information on how to use that character set in an email message in an RFC-compliant way.</source>
          <target state="translated">이 클래스는 특정 문자 집합에 대한 전자 메일에 요구되는 요구 사항에 대한 정보를 제공합니다. 또한 해당 코덱이 사용 가능한 경우 문자 세트 간 변환을위한 편리한 루틴을 제공합니다. 문자 집합이 주어지면 RFC 호환 방식으로 전자 메일 메시지에서 해당 문자 집합을 사용하는 방법에 대한 정보를 제공하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ea7cddb548da1e6410ebeae8791fca85fc47a9ba" translate="yes" xml:space="preserve">
          <source>This class provides methods for creating and returning &lt;a href=&quot;#multiprocessing.managers.SharedMemoryManager.SharedMemory&quot;&gt;&lt;code&gt;SharedMemory&lt;/code&gt;&lt;/a&gt; instances and for creating a list-like object (&lt;a href=&quot;#multiprocessing.managers.SharedMemoryManager.ShareableList&quot;&gt;&lt;code&gt;ShareableList&lt;/code&gt;&lt;/a&gt;) backed by shared memory.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#multiprocessing.managers.SharedMemoryManager.SharedMemory&quot;&gt; &lt;code&gt;SharedMemory&lt;/code&gt; &lt;/a&gt; 인스턴스 를 작성 및 리턴 하고 공유 메모리가 지원 하는 목록 유사 오브젝트 ( &lt;a href=&quot;#multiprocessing.managers.SharedMemoryManager.ShareableList&quot;&gt; &lt;code&gt;ShareableList&lt;/code&gt; &lt;/a&gt; ) 를 작성하기위한 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="193f5372ace98009161fcd09d57d781b73d181ef" translate="yes" xml:space="preserve">
          <source>This class provides methods to read, parse and answer questions about the &lt;code&gt;robots.txt&lt;/code&gt; file at &lt;em&gt;url&lt;/em&gt;.</source>
          <target state="translated">이 클래스는 &lt;em&gt;url&lt;/em&gt; 의 &lt;code&gt;robots.txt&lt;/code&gt; 파일에 대한 질문을 읽고 구문 분석하고 답변하는 메소드를 제공합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6028a52d014cdefa926e7af0fc1f466c66ee3def" translate="yes" xml:space="preserve">
          <source>This class represents Netscape, &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; cookies. It is not expected that users of &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; construct their own &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; instances. Instead, if necessary, call &lt;code&gt;make_cookies()&lt;/code&gt; on a &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">이 클래스는 Netscape, &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 쿠키를 나타냅니다 . &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; 사용자가 자신의 &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 인스턴스를 구성 하지는 않습니다 . 대신 필요한 경우 &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 &lt;code&gt;make_cookies()&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3fd2d200eb5006dc61a4b31bac6c557561c951b" translate="yes" xml:space="preserve">
          <source>This class represents a MIME-types database. By default, it provides access to the same database as the rest of this module. The initial database is a copy of that provided by the module, and may be extended by loading additional &lt;code&gt;mime.types&lt;/code&gt;-style files into the database using the &lt;a href=&quot;#mimetypes.MimeTypes.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mimetypes.MimeTypes.readfp&quot;&gt;&lt;code&gt;readfp()&lt;/code&gt;&lt;/a&gt; methods. The mapping dictionaries may also be cleared before loading additional data if the default data is not desired.</source>
          <target state="translated">이 클래스는 MIME 유형 데이터베이스를 나타냅니다. 기본적으로이 모듈의 나머지와 동일한 데이터베이스에 대한 액세스를 제공합니다. 초기 데이터베이스는 모듈이 제공 한 것의 사본이며 &lt;a href=&quot;#mimetypes.MimeTypes.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#mimetypes.MimeTypes.readfp&quot;&gt; &lt;code&gt;readfp()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 데이터베이스에 추가 &lt;code&gt;mime.types&lt;/code&gt; 스타일 파일을 로드하여 확장 할 수 있습니다 . 기본 데이터가 바람직하지 않은 경우 추가 데이터를로드하기 전에 매핑 사전을 지울 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16f2fa4e9ca1f4b04f678175a55e8942c49241a" translate="yes" xml:space="preserve">
          <source>This class represents a subpart of a MIME message. It is identical to &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt;, except that no &lt;em&gt;MIME-Version&lt;/em&gt; headers are added when &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; is called, since sub-parts do not need their own &lt;em&gt;MIME-Version&lt;/em&gt; headers.</source>
          <target state="translated">이 클래스는 MIME 메시지의 하위 부분을 나타냅니다. 그것은 동일 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 없는 것을 제외하고, &lt;em&gt;MIME-버전의&lt;/em&gt; 경우 헤더가 추가되지 않습니다 &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 호출 하위 부분이 자신의 필요로하지 않기 때문에, &lt;em&gt;MIME-버전&lt;/em&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="22f8e65bf7b5a8eada37fbd323ba83523d329661" translate="yes" xml:space="preserve">
          <source>This class represents an action that should be run only after a certain amount of time has passed &amp;mdash; a timer. &lt;a href=&quot;#threading.Timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;#threading.Thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; and as such also functions as an example of creating custom threads.</source>
          <target state="translated">이 클래스는 일정 시간이 지난 후에 만 ​​수행해야하는 작업 (타이머)을 나타냅니다. &lt;a href=&quot;#threading.Timer&quot;&gt; &lt;code&gt;Timer&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#threading.Thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 의 서브 클래스이며 사용자 정의 스레드를 만드는 예제로도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="932c82e2e83abbd41e3929520e8f112fd5c73fbd" translate="yes" xml:space="preserve">
          <source>This class represents an aggregation of individual test cases and test suites. The class presents the interface needed by the test runner to allow it to be run as any other test case. Running a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; instance is the same as iterating over the suite, running each test individually.</source>
          <target state="translated">이 클래스는 개별 테스트 사례 및 테스트 스위트의 집합을 나타냅니다. 이 클래스는 다른 테스트 사례로 실행할 수 있도록 테스트 러너에 필요한 인터페이스를 제공합니다. &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스를 실행하는 것은 스위트를 반복하는 것과 동일하며 각 테스트를 개별적으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="29e097cd340803b24a612fe148a5a39528edd250" translate="yes" xml:space="preserve">
          <source>This class represents tunable scheduling parameters used in &lt;a href=&quot;#os.sched_setparam&quot;&gt;&lt;code&gt;sched_setparam()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.sched_setscheduler&quot;&gt;&lt;code&gt;sched_setscheduler()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.sched_getparam&quot;&gt;&lt;code&gt;sched_getparam()&lt;/code&gt;&lt;/a&gt;. It is immutable.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#os.sched_setparam&quot;&gt; &lt;code&gt;sched_setparam()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.sched_setscheduler&quot;&gt; &lt;code&gt;sched_setscheduler()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.sched_getparam&quot;&gt; &lt;code&gt;sched_getparam()&lt;/code&gt; &lt;/a&gt; 에서 사용되는 조정 가능한 스케줄링 매개 변수를 나타냅니다 . 불변입니다.</target>
        </trans-unit>
        <trans-unit id="73e7a16f5e1d0b8f46a771fc3488a73fef21a8e9" translate="yes" xml:space="preserve">
          <source>This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests.</source>
          <target state="translated">이 클래스는 디렉토리 구조를 HTTP 요청에 직접 맵핑하여 현재 디렉토리 및 그 이하의 파일을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8f4d59250a2949ebcdb2c5415b61ebd0d2b8d4b7" translate="yes" xml:space="preserve">
          <source>This class takes care of the details of the trace facility; a derived class should implement user interaction. The standard debugger class (&lt;a href=&quot;pdb#pdb.Pdb&quot;&gt;&lt;code&gt;pdb.Pdb&lt;/code&gt;&lt;/a&gt;) is an example.</source>
          <target state="translated">이 클래스는 추적 기능의 세부 사항을 처리합니다. 파생 클래스는 사용자 상호 작용을 구현해야합니다. 표준 디버거 클래스 ( &lt;a href=&quot;pdb#pdb.Pdb&quot;&gt; &lt;code&gt;pdb.Pdb&lt;/code&gt; &lt;/a&gt; )가 예입니다.</target>
        </trans-unit>
        <trans-unit id="f37ba959190077672d1f15b3db66d2d7d1c6ff73" translate="yes" xml:space="preserve">
          <source>This class&amp;rsquo;s functionality requires a functioning shared semaphore implementation on the host operating system. Without one, the functionality in this class will be disabled, and attempts to instantiate a &lt;a href=&quot;#multiprocessing.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; will result in an &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;https://bugs.python.org/issue3770&quot;&gt;bpo-3770&lt;/a&gt; for additional information. The same holds true for any of the specialized queue types listed below.</source>
          <target state="translated">이 클래스의 기능에는 호스트 운영 체제에서 작동하는 공유 세마포어 구현이 필요합니다. 하나가 없으면이 클래스의 기능이 비활성화되고 &lt;a href=&quot;#multiprocessing.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 를 인스턴스화하려고 하면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 추가 정보는 &lt;a href=&quot;https://bugs.python.org/issue3770&quot;&gt;bpo-3770&lt;/a&gt; 을 참조하십시오 . 아래 나열된 특수 대기열 유형에 대해서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="a41d8654ea90612b336c64ac521c0b59963c7ad7" translate="yes" xml:space="preserve">
          <source>This client which interacts with the demo XMLRPC server can be invoked as:</source>
          <target state="translated">데모 XMLRPC 서버와 상호 작용하는이 클라이언트는 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d83a870c39ddf30740d2e358c4cdbc65c6a91d89" translate="yes" xml:space="preserve">
          <source>This closes the database connection. Note that this does not automatically call &lt;a href=&quot;#sqlite3.Connection.commit&quot;&gt;&lt;code&gt;commit()&lt;/code&gt;&lt;/a&gt;. If you just close your database connection without calling &lt;a href=&quot;#sqlite3.Connection.commit&quot;&gt;&lt;code&gt;commit()&lt;/code&gt;&lt;/a&gt; first, your changes will be lost!</source>
          <target state="translated">데이터베이스 연결이 닫힙니다. 이것은 &lt;a href=&quot;#sqlite3.Connection.commit&quot;&gt; &lt;code&gt;commit()&lt;/code&gt; &lt;/a&gt; 자동으로 호출하지 않습니다 . &lt;a href=&quot;#sqlite3.Connection.commit&quot;&gt; &lt;code&gt;commit()&lt;/code&gt; &lt;/a&gt; 먼저 호출하지 않고 데이터베이스 연결을 종료하면 변경 사항이 손실됩니다!</target>
        </trans-unit>
        <trans-unit id="b748ec83f84e7fc5c00bf2adb54dcda5003a9203" translate="yes" xml:space="preserve">
          <source>This code is actually automatically run when Python is run in &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt; (see &lt;a href=&quot;site#rlcompleter-config&quot;&gt;Readline configuration&lt;/a&gt;).</source>
          <target state="translated">이 코드는 실제로 Python이 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;대화식 모드&lt;/a&gt; 에서 실행될 때 자동으로 실행됩니다 ( &lt;a href=&quot;site#rlcompleter-config&quot;&gt;Readline 구성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="188ba6fbc8e6fe291e33a72f0675afd9594eb52a" translate="yes" xml:space="preserve">
          <source>This code is equivalent to:</source>
          <target state="translated">이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20b1f6a9a16308d3cf1b57b7bfba034f0203ec1e" translate="yes" xml:space="preserve">
          <source>This code is exactly equivalent to the first example. Be sure to give the additional functions the same name as the original property (&lt;code&gt;x&lt;/code&gt; in this case.)</source>
          <target state="translated">이 코드는 첫 번째 예제와 정확히 동일합니다. 추가 기능에 원래 속성과 동일한 이름을 지정하십시오 ( 이 경우 &lt;code&gt;x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7a72ea94a4bab4b14c20d25cdf441f6b5ef6aabf" translate="yes" xml:space="preserve">
          <source>This code pattern allows the testing suite to be run by &lt;code&gt;test.regrtest&lt;/code&gt;, on its own as a script that supports the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; CLI, or via the &lt;code&gt;python -m unittest&lt;/code&gt; CLI.</source>
          <target state="translated">이 코드 패턴을 사용하면 &lt;code&gt;test.regrtest&lt;/code&gt; 가 테스트 스위트를 단독으로 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; CLI 를 지원하는 스크립트로 또는 &lt;code&gt;python -m unittest&lt;/code&gt; CLI 를 통해 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="754e9cb8c3e6e8e331a6ffc92da78e28bd75069a" translate="yes" xml:space="preserve">
          <source>This code was contributed by Lance Ellinghouse, and modified by Jack Jansen.</source>
          <target state="translated">이 코드는 Lance Ellinghouse가 제공했으며 Jack Jansen이 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="7cc17a1a45954846e0e7ca436ab70cd34d59503c" translate="yes" xml:space="preserve">
          <source>This command can return very large results, especially if &lt;em&gt;group_pattern&lt;/em&gt; is not specified. It is best to cache the results offline unless you really need to refresh them.</source>
          <target state="translated">이 명령은 특히 &lt;em&gt;group_pattern을&lt;/em&gt; 지정하지 않은 경우 매우 큰 결과를 반환 할 수 있습니다 . 실제로 새로 고치지 않으면 결과를 오프라인으로 캐시하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0eb035f79d945c28dca579096d5869dcd935eb24" translate="yes" xml:space="preserve">
          <source>This command is frequently disabled by NNTP server administrators.</source>
          <target state="translated">이 명령은 NNTP 서버 관리자가 자주 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5dbea069ae4115ecbc17706143c788302a103ca5" translate="yes" xml:space="preserve">
          <source>This common limitation means that it is generally advisable to create context managers directly in the header of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement where they are used (as shown in all of the usage examples above).</source>
          <target state="translated">이 공통 제한 사항은 일반적으로 사용되는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 헤더에 컨텍스트 관리자를 직접 작성하는 것이 좋습니다 (위의 모든 사용 예제에 표시됨).</target>
        </trans-unit>
        <trans-unit id="61c2e658f60d1390cfe7ca8803a3ad8e80e90d95" translate="yes" xml:space="preserve">
          <source>This concrete &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt; is the backward compatibility policy. It replicates the behavior of the email package in Python 3.2. The &lt;a href=&quot;#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; module also defines an instance of this class, &lt;a href=&quot;#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt;, that is used as the default policy. Thus the default behavior of the email package is to maintain compatibility with Python 3.2.</source>
          <target state="translated">이 구체적인 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 은 이전 버전과의 호환성 정책입니다. Python 3.2에서 전자 메일 패키지의 동작을 복제합니다. &lt;a href=&quot;#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 모듈은이 클래스의 인스턴스를 정의 &lt;a href=&quot;#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; 기본 정책으로 사용됩니다. 따라서 전자 메일 패키지의 기본 동작은 Python 3.2와의 호환성을 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92d19da16d5a8553c7cb7e0f68f04a827f9e7f61" translate="yes" xml:space="preserve">
          <source>This concrete &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt; provides behavior that is intended to be fully compliant with the current email RFCs. These include (but are not limited to) &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt;, and the current MIME RFCs.</source>
          <target state="translated">이 구체적인 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 은 현재 전자 메일 RFC를 완전히 준수하기위한 동작을 제공합니다. 여기에는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 및 현재 MIME RFC 가 포함되지만 이에 국한되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="80e6fc8925c6c5e7eaca5a6ad0a4fd81fd994085" translate="yes" xml:space="preserve">
          <source>This constant contains a boolean value which indicates if IPv6 is supported on this platform.</source>
          <target state="translated">이 상수에는이 플랫폼에서 IPv6가 지원되는지 여부를 나타내는 부울 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3e2858f91cb9186fa1ca376fd637bf7c9e6e52d8" translate="yes" xml:space="preserve">
          <source>This constant is documented in the Linux documentation.</source>
          <target state="translated">이 상수는 Linux 설명서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe32614311b23ebbbdfc9132f699e5b6f9f4ab2e" translate="yes" xml:space="preserve">
          <source>This constant is meant to be used with the &lt;em&gt;detect_types&lt;/em&gt; parameter of the &lt;a href=&quot;#sqlite3.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 함수 의 &lt;em&gt;detect_types&lt;/em&gt; 매개 변수 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="85870d23cfed7a7265f4ba24695196830564152b" translate="yes" xml:space="preserve">
          <source>This constant is true if Python was not started with an &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; option. See also the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#assert&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">이 상수는 Python이 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 옵션으로 시작되지 않은 경우에 해당됩니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#assert&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt; 문도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8db8774c7221bac7ad7292b78b6b055382d44cb4" translate="yes" xml:space="preserve">
          <source>This constraint can be eschewed if both the &lt;em&gt;provider&lt;/em&gt; (the implementation of the object types to be transferred) and the &lt;em&gt;consumer&lt;/em&gt; (the implementation of the communications system) support the out-of-band transfer facilities provided by pickle protocol 5 and higher.</source>
          <target state="translated">&lt;em&gt;공급자&lt;/em&gt; (전송 될 객체 유형의 구현)와 &lt;em&gt;소비자&lt;/em&gt; (통신 시스템의 구현)가 피클 프로토콜 5 이상에서 제공하는 대역 외 전송 기능을 지원하는 경우이 제약 조건을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e50b3a4fe127122b1c1be9fb32f8d7c4e9891d68" translate="yes" xml:space="preserve">
          <source>This constructor should always be called with keyword arguments. Arguments are:</source>
          <target state="translated">이 생성자는 항상 키워드 인수와 함께 호출해야합니다. 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eee83f35dcf09cd6810b2ed6630fade00f668e02" translate="yes" xml:space="preserve">
          <source>This content manager provides only a minimum interface beyond that provided by &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; itself: it deals only with text, raw byte strings, and &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; objects. Nevertheless, it provides significant advantages compared to the base API: &lt;code&gt;get_content&lt;/code&gt; on a text part will return a unicode string without the application needing to manually decode it, &lt;code&gt;set_content&lt;/code&gt; provides a rich set of options for controlling the headers added to a part and controlling the content transfer encoding, and it enables the use of the various &lt;code&gt;add_&lt;/code&gt; methods, thereby simplifying the creation of multipart messages.</source>
          <target state="translated">이 컨텐츠 관리자는 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 자체 가 제공하는 것 이상의 최소 인터페이스 만 제공 합니다. 텍스트, 원시 바이트 문자열 및 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 오브젝트 만 처리합니다. 그럼에도 불구하고 기본 API와 비교하여 상당한 이점을 제공합니다 . 텍스트 부분의 &lt;code&gt;get_content&lt;/code&gt; 는 응용 프로그램에서 수동으로 디코딩하지 않고도 유니 코드 문자열을 반환하며, &lt;code&gt;set_content&lt;/code&gt; 는 부분에 추가 된 헤더를 제어하고 내용을 제어하기위한 다양한 옵션을 제공합니다. 전송 인코딩을 통해 다양한 &lt;code&gt;add_&lt;/code&gt; 메소드를 사용할 수 있으므로 멀티 파트 메시지 작성이 단순 해집니다.</target>
        </trans-unit>
        <trans-unit id="e3f7dceef060c97974b4e4226c16041d9314af78" translate="yes" xml:space="preserve">
          <source>This context is most useful in multi-threaded environments. Changing one of the fields before threads are started has the effect of setting system-wide defaults. Changing the fields after threads have started is not recommended as it would require thread synchronization to prevent race conditions.</source>
          <target state="translated">이 컨텍스트는 다중 스레드 환경에서 가장 유용합니다. 스레드가 시작되기 전에 필드 중 하나를 변경하면 시스템 전체 기본값을 설정하는 효과가 있습니다. 스레드가 시작된 후 필드를 변경하는 것은 경쟁 조건을 방지하기 위해 스레드 동기화가 필요하므로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="056192954bc171b8b9375158ba2f55065c788c8e" translate="yes" xml:space="preserve">
          <source>This context is used by the &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; constructor as a prototype for new contexts. Changing a field (such a precision) has the effect of changing the default for new contexts created by the &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 컨텍스트는 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 생성자가 새 컨텍스트의 프로토 타입으로 사용합니다. 필드 (정밀도)를 변경하면 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 생성자가 만든 새 컨텍스트의 기본값을 변경하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="adfa9fe3b0226da7aaf4ee9312f722dce55e612a" translate="yes" xml:space="preserve">
          <source>This context manager is &lt;a href=&quot;#reentrant-cms&quot;&gt;reentrant&lt;/a&gt;.</source>
          <target state="translated">이 컨텍스트 관리자는 &lt;a href=&quot;#reentrant-cms&quot;&gt;재진입&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="587a63de629bfa8dd59dc368a12d35c0c91ebfc9" translate="yes" xml:space="preserve">
          <source>This convenience is provided to encourage &lt;a href=&quot;#module-shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; users to generate error messages in the standard, parseable format understood by Emacs and other Unix tools.</source>
          <target state="translated">이 편리함은 &lt;a href=&quot;#module-shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 사용자가 Emacs 및 기타 Unix 도구가 이해하는 표준의 구문 분석 가능한 형식으로 오류 메시지를 생성 하도록 장려 합니다.</target>
        </trans-unit>
        <trans-unit id="812edcca58e65f791d72238eb59be8a7fc8c8bb3" translate="yes" xml:space="preserve">
          <source>This copy is done without the additional cost of transferring data from the kernel to user space and then back into the kernel. Additionally, some filesystems could implement extra optimizations. The copy is done as if both files are opened as binary.</source>
          <target state="translated">이 복사는 커널에서 사용자 공간으로 데이터를 전송 한 다음 다시 커널로 전송하는 추가 비용없이 수행됩니다. 또한 일부 파일 시스템은 추가 최적화를 구현할 수 있습니다. 복사는 두 파일이 모두 바이너리로 열린 것처럼 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="951c20bdc9ca8ee62daa8ad49c6f7fb15c561414" translate="yes" xml:space="preserve">
          <source>This decorator enables legacy generator-based coroutines to be compatible with async/await code:</source>
          <target state="translated">이 데코레이터를 사용하면 레거시 생성기 기반 코 루틴이 비동기 / 대기 코드와 호환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9992dac3f3dff13b2f0ac6d879fbe3eae7add96f" translate="yes" xml:space="preserve">
          <source>This decorator is itself not available at runtime. It is mainly intended to mark classes that are defined in type stub files if an implementation returns an instance of a private class:</source>
          <target state="translated">이 데코레이터는 런타임에 사용할 수 없습니다. 구현이 개인 클래스의 인스턴스를 리턴하는 경우 유형 스텁 파일에 정의 된 클래스를 표시하는 데 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc1ff93c67faa61e74eb3e2bda4297a01530896c" translate="yes" xml:space="preserve">
          <source>This decorator requires that the &lt;code&gt;__dict__&lt;/code&gt; attribute on each instance be a mutable mapping. This means it will not work with some types, such as metaclasses (since the &lt;code&gt;__dict__&lt;/code&gt; attributes on type instances are read-only proxies for the class namespace), and those that specify &lt;code&gt;__slots__&lt;/code&gt; without including &lt;code&gt;__dict__&lt;/code&gt; as one of the defined slots (as such classes don&amp;rsquo;t provide a &lt;code&gt;__dict__&lt;/code&gt; attribute at all).</source>
          <target state="translated">이 데코레이터는 각 인스턴스 의 &lt;code&gt;__dict__&lt;/code&gt; 속성이 변경 가능한 매핑이어야합니다. 이는 메타 클래스 ( 유형 인스턴스 의 &lt;code&gt;__dict__&lt;/code&gt; 속성이 클래스 네임 스페이스에 대한 읽기 전용 프록시이므로) 및 일부 정의 된 슬롯 중 하나로 &lt;code&gt;__dict__&lt;/code&gt; 를 포함하지 않고 &lt;code&gt;__slots__&lt;/code&gt; 를 지정하는 메타 클래스와 같은 일부 유형에서는 작동하지 않음을 의미합니다. &lt;code&gt;__dict__&lt;/code&gt; 속성을 전혀 제공하지 마십시오 ).</target>
        </trans-unit>
        <trans-unit id="c300d0d694010854de5f7492ad74271773977803" translate="yes" xml:space="preserve">
          <source>This decorator should not be used for &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; coroutines.</source>
          <target state="translated">이 데코레이터는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 코 루틴에 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b7ac610500209606a0a0139f3b647a4e463cfcb" translate="yes" xml:space="preserve">
          <source>This default value for the &lt;em&gt;policy&lt;/em&gt; keyword to &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicy&lt;/code&gt;&lt;/a&gt; policy, via its pre-defined instance &lt;a href=&quot;#email.policy.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 대한이 기본 값 &lt;em&gt;정책&lt;/em&gt; 에 키워드 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 이&lt;/a&gt; 는 IS &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicy&lt;/code&gt; 의&lt;/a&gt; 의 미리 정의 된 인스턴스를 통해 정책 &lt;a href=&quot;#email.policy.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e21702e7206b1540ec13499c73a1d346fc076d6f" translate="yes" xml:space="preserve">
          <source>This defaults to &lt;code&gt;['/cgi-bin', '/htbin']&lt;/code&gt; and describes directories to treat as containing CGI scripts.</source>
          <target state="translated">기본값은 &lt;code&gt;['/cgi-bin', '/htbin']&lt;/code&gt; 이며 CGI 스크립트를 포함하는 것으로 취급 할 디렉토리를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b5df6ab6eb381dc8f1c26576661cf9cf458d811a" translate="yes" xml:space="preserve">
          <source>This demonstrates how similar derived enumerations can be defined; for example a &lt;code&gt;StrEnum&lt;/code&gt; that mixes in &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 유사한 파생 열거를 정의 할 수있는 방법을 보여줍니다. 예를 들어, &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 에&lt;/a&gt; 혼합 되는 &lt;code&gt;StrEnum&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="85da0637f33c740513754e7c543cab4e3c5fd9df" translate="yes" xml:space="preserve">
          <source>This dictionary can be used as argument for a subsequent call to &lt;a href=&quot;#turtle.pen&quot;&gt;&lt;code&gt;pen()&lt;/code&gt;&lt;/a&gt; to restore the former pen-state. Moreover one or more of these attributes can be provided as keyword-arguments. This can be used to set several pen attributes in one statement.</source>
          <target state="translated">이 사전은 이전 펜 상태를 복원 하기 위해 &lt;a href=&quot;#turtle.pen&quot;&gt; &lt;code&gt;pen()&lt;/code&gt; &lt;/a&gt; 에 대한 후속 호출에 대한 인수로 사용될 수 있습니다 . 또한 이러한 속성 중 하나 이상을 키워드 인수로 제공 할 수 있습니다. 한 문장에서 여러 펜 속성을 설정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce89b5732743cb6bcf141dd8012b3ff6141f9e13" translate="yes" xml:space="preserve">
          <source>This dictionary maps the HTTP 1.1 status codes to the W3C names.</source>
          <target state="translated">이 사전은 HTTP 1.1 상태 코드를 W3C 이름에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="9ddd1f324c17578c73e1a32273ebd7f0cdc6accd" translate="yes" xml:space="preserve">
          <source>This differs from the behaviour of &lt;a href=&quot;threading#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; where SIGINT will be ignored while the equivalent blocking calls are in progress.</source>
          <target state="translated">이는 동등한 차단 호출이 진행되는 동안 SIGINT가 무시되는 &lt;a href=&quot;threading#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3068ba406f985162f6ef582ac392d3ccc0bfca5a" translate="yes" xml:space="preserve">
          <source>This document describes the behavior under the default (for &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt;) policy &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;Compat32&lt;/code&gt;&lt;/a&gt;. If you are going to use another policy, you should be using the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; class instead.</source>
          <target state="translated">이 문서는 기본 ( &lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; ) 정책 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;Compat32&lt;/code&gt; 에&lt;/a&gt; 따른 동작을 설명합니다 . 다른 정책을 사용하려는 경우 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 클래스를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="32a3cafdce538e5b18df61742dfb8d4b171f69c3" translate="yes" xml:space="preserve">
          <source>This document explains how the theme engine works</source>
          <target state="translated">이 문서는 테마 엔진의 작동 방식을 설명합니다</target>
        </trans-unit>
        <trans-unit id="6ea1780a291c39bade61c609ec38121b00edd92b" translate="yes" xml:space="preserve">
          <source>This documentation page contains the following sections:</source>
          <target state="translated">이 설명서 페이지에는 다음 섹션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3cd91e868bb20379048d1e01a95c878e0816d7" translate="yes" xml:space="preserve">
          <source>This documentation page covers both &lt;a href=&quot;#transports&quot;&gt;Transports&lt;/a&gt; and &lt;a href=&quot;#protocols&quot;&gt;Protocols&lt;/a&gt;.</source>
          <target state="translated">이 문서 페이지는 &lt;a href=&quot;#transports&quot;&gt;전송&lt;/a&gt; 및 &lt;a href=&quot;#protocols&quot;&gt;프로토콜을&lt;/a&gt; 모두 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="92bab0d11dc1fe34db31a7fa119d6a0aad2dfb5b" translate="yes" xml:space="preserve">
          <source>This does &lt;em&gt;not&lt;/em&gt; support parsing arbitrary ISO 8601 strings - it is only intended as the inverse operation of &lt;a href=&quot;#datetime.datetime.isoformat&quot;&gt;&lt;code&gt;datetime.isoformat()&lt;/code&gt;&lt;/a&gt;. A more full-featured ISO 8601 parser, &lt;code&gt;dateutil.parser.isoparse&lt;/code&gt; is available in the third-party package &lt;a href=&quot;https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.isoparse&quot;&gt;dateutil&lt;/a&gt;.</source>
          <target state="translated">이것은 임의의 ISO 8601 문자열 구문 분석을 지원 하지 &lt;em&gt;않으며 &lt;/em&gt;&lt;a href=&quot;#datetime.datetime.isoformat&quot;&gt; &lt;code&gt;datetime.isoformat()&lt;/code&gt; &lt;/a&gt; 의 역연 산만을 목적으로합니다 . 보다 완전한 기능을 갖춘 ISO 8601 파서 인 &lt;code&gt;dateutil.parser.isoparse&lt;/code&gt; 는 타사 패키지 &lt;a href=&quot;https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.isoparse&quot;&gt;dateutil&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d39cfcf67975976ed6d0852105f14c7bbd179606" translate="yes" xml:space="preserve">
          <source>This does &lt;em&gt;not&lt;/em&gt; support parsing arbitrary ISO 8601 strings. It is only intended as the inverse operation of &lt;a href=&quot;#datetime.time.isoformat&quot;&gt;&lt;code&gt;time.isoformat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임의의 ISO 8601 문자열 구문 분석 은 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; . &lt;a href=&quot;#datetime.time.isoformat&quot;&gt; &lt;code&gt;time.isoformat()&lt;/code&gt; &lt;/a&gt; 의 역연 산만을 목적으로합니다 .</target>
        </trans-unit>
        <trans-unit id="a8d96811345bfb9f1ce5d798a0568d8c1532106c" translate="yes" xml:space="preserve">
          <source>This does nothing; it doesn&amp;rsquo;t even set the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header.</source>
          <target state="translated">이것은 아무것도하지 않습니다. 심지어 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 설정하지도 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0f118286f16ac96c73365a27b4b2e8dc31597b52" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually modify the message&amp;rsquo;s payload, but it does set the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header to either &lt;code&gt;7bit&lt;/code&gt; or &lt;code&gt;8bit&lt;/code&gt; as appropriate, based on the payload data.</source>
          <target state="translated">이것은 실제로 메시지의 페이로드를 수정하지는 않지만 페이로드 데이터를 기반으로 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 &lt;code&gt;7bit&lt;/code&gt; 또는 &lt;code&gt;8bit&lt;/code&gt; 비트로 적절하게 설정합니다.</target>
        </trans-unit>
        <trans-unit id="dc9c32bbd592532e00cbc38e674970da7b46499a" translate="yes" xml:space="preserve">
          <source>This elides the response code from the server. If the response code is needed, use &lt;a href=&quot;#nntplib.NNTP.descriptions&quot;&gt;&lt;code&gt;descriptions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 서버에서 응답 코드를 제거합니다. 응답 코드가 필요한 경우 &lt;a href=&quot;#nntplib.NNTP.descriptions&quot;&gt; &lt;code&gt;descriptions()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b98cf0f954a93782cde0031b12229cb211f39e9" translate="yes" xml:space="preserve">
          <source>This encoding is always ASCII-compatible.</source>
          <target state="translated">이 인코딩은 항상 ASCII 호환입니다.</target>
        </trans-unit>
        <trans-unit id="b2e9101400ad7ee4e55ed42180277b67f8cf0f57" translate="yes" xml:space="preserve">
          <source>This ensures that your mocks will fail in the same way as your production code if they are used incorrectly:</source>
          <target state="translated">이렇게하면 모의 객체가 잘못 사용될 경우 프로덕션 코드와 같은 방식으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84405dc340963074580e6158c072ba0de9baaf30" translate="yes" xml:space="preserve">
          <source>This error is mapped to the exception &lt;a href=&quot;exceptions#InterruptedError&quot;&gt;&lt;code&gt;InterruptedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 &lt;a href=&quot;exceptions#InterruptedError&quot;&gt; &lt;code&gt;InterruptedError&lt;/code&gt; &lt;/a&gt; 예외에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="782f94ac91ca671c983c4102c829d80211c23fb1" translate="yes" xml:space="preserve">
          <source>This example calls both functions with a &lt;code&gt;NULL&lt;/code&gt; pointer (&lt;code&gt;None&lt;/code&gt; should be used as the &lt;code&gt;NULL&lt;/code&gt; pointer):</source>
          <target state="translated">이 예는와 두 함수 호출 &lt;code&gt;NULL&lt;/code&gt; 의 포인터 ( &lt;code&gt;None&lt;/code&gt; 으로 사용되어서는 안 &lt;code&gt;NULL&lt;/code&gt; 의 포인터를)</target>
        </trans-unit>
        <trans-unit id="a09c84b9d7833c97dd614df7daea0247b0acfc92" translate="yes" xml:space="preserve">
          <source>This example compares two strings, considering blanks to be &amp;ldquo;junk&amp;rdquo;:</source>
          <target state="translated">이 예는 공백을 &quot;정크&quot;로 간주하여 두 문자열을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="044525c1b0f02f0079887e5bc92a57b5bc8aee0f" translate="yes" xml:space="preserve">
          <source>This example compares two texts. First we set up the texts, sequences of individual single-line strings ending with newlines (such sequences can also be obtained from the &lt;code&gt;readlines()&lt;/code&gt; method of file-like objects):</source>
          <target state="translated">이 예제는 두 개의 텍스트를 비교합니다. 먼저 개행으로 끝나는 개별 단일 행 문자열의 시퀀스 인 텍스트를 설정합니다 (이러한 시퀀스는 파일과 같은 객체 의 &lt;code&gt;readlines()&lt;/code&gt; 메서드 에서 얻을 수도 있음 ).</target>
        </trans-unit>
        <trans-unit id="4b2905cb398396cba10263a63f13db7111f72408" translate="yes" xml:space="preserve">
          <source>This example creates a Future object, creates and schedules an asynchronous Task to set result for the Future, and waits until the Future has a result:</source>
          <target state="translated">이 예에서는 Future 개체를 만들고 비동기 작업을 만들어 예약하여 Future에 대한 결과를 설정하고 Future에 결과가 나타날 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="018978f4b59649c07ce86602d1484e00501f5987" translate="yes" xml:space="preserve">
          <source>This example creates a SSL context with the recommended security settings for client sockets, including automatic certificate verification:</source>
          <target state="translated">이 예제는 자동 인증서 확인을 포함하여 클라이언트 소켓에 권장되는 보안 설정으로 SSL 컨텍스트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="39ba95039e07988bb739e58971213fbb994f0bcc" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to wrap the Windows &lt;code&gt;MessageBoxW&lt;/code&gt; function so that it supports default parameters and named arguments. The C declaration from the windows header file is this:</source>
          <target state="translated">이 예 는 기본 매개 변수와 명명 된 인수를 지원하도록 Windows &lt;code&gt;MessageBoxW&lt;/code&gt; 함수 를 래핑하는 방법을 보여줍니다 . Windows 헤더 파일의 C 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa58ef83147938371c0a379ed8dc30747eca3d72" translate="yes" xml:space="preserve">
          <source>This example displays the number of bytes taken by non-directory files in each directory under the starting directory, except that it doesn&amp;rsquo;t look under any CVS subdirectory:</source>
          <target state="translated">이 예제는 CVS 서브 디렉토리를 보지 않는 것을 제외하고 시작 디렉토리 아래의 각 디렉토리에서 비 디렉토리 파일이 차지하는 바이트 수를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="13a5a113117f57607a533f5a8bed89cd81731c96" translate="yes" xml:space="preserve">
          <source>This example gets the python.org main page and displays the first 300 bytes of it.</source>
          <target state="translated">이 예제는 python.org 메인 페이지를 가져 와서 첫 300 바이트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f0c973599ef6d6281b47995acbaf5fa790a8c858" translate="yes" xml:space="preserve">
          <source>This example illustrates how to open a URL using your Netscape, Mozilla, or Lynx cookies (assumes Unix/Netscape convention for location of the cookies file):</source>
          <target state="translated">이 예제는 Netscape, Mozilla 또는 Lynx 쿠키를 사용하여 URL을 여는 방법을 보여줍니다 (쿠키 파일의 위치는 Unix / Netscape 규칙으로 가정).</target>
        </trans-unit>
        <trans-unit id="beb0e848071a51f42c8de87c4c5b82271cd652b5" translate="yes" xml:space="preserve">
          <source>This example is limited by the fact that &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; allocates its own memory: you cannot create a &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; instance that is backed by another object&amp;rsquo;s memory. However, third-party datatypes such as NumPy arrays do not have this limitation, and allow use of zero-copy pickling (or making as few copies as possible) when transferring between distinct processes or systems.</source>
          <target state="translated">이 예제는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 가 자체 메모리를 할당 한다는 사실에 의해 제한됩니다 . 다른 객체의 메모리가 지원 하는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 인스턴스를 만들 수 없습니다 . 그러나 NumPy 어레이와 같은 타사 데이터 유형에는 이러한 제한이 없으며 별도의 프로세스 또는 시스템간에 전송할 때 무 복사 산세를 사용하거나 가능한 적은 사본을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="026ec75fb1b97ca54f747abca8eb5568018e6f79" translate="yes" xml:space="preserve">
          <source>This example is the implementation of the &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt; function, described above, with the docstring omitted. It demonstrates many of the other functions provided by this module.</source>
          <target state="translated">이 예제는 docstring이 생략 된, 위에서 설명한 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 함수 의 구현입니다 . 이 모듈에서 제공하는 다른 많은 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="817efcdabbed81fd5a8d7128157922b1290e74ae" translate="yes" xml:space="preserve">
          <source>This example looks for a word following a hyphen:</source>
          <target state="translated">이 예는 하이픈 다음에 나오는 단어를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="bc8fd01e0952c36a02e5bec07eb86980d4050c06" translate="yes" xml:space="preserve">
          <source>This example program is a fairly realistic example of a simple program. In this particular case, we do not take much advantage of the flexibility of the DOM.</source>
          <target state="translated">이 예제 프로그램은 간단한 프로그램의 상당히 현실적인 예입니다. 이 특별한 경우에 우리는 DOM의 유연성을 크게 활용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="602035184a663fa6ac77e2c6161bb89ea08510cc" translate="yes" xml:space="preserve">
          <source>This example prompts the user for addresses needed in the message envelope (&amp;lsquo;To&amp;rsquo; and &amp;lsquo;From&amp;rsquo; addresses), and the message to be delivered. Note that the headers to be included with the message must be included in the message as entered; this example doesn&amp;rsquo;t do any processing of the &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; headers. In particular, the &amp;lsquo;To&amp;rsquo; and &amp;lsquo;From&amp;rsquo; addresses must be included in the message headers explicitly.</source>
          <target state="translated">이 예에서는 메시지 봉투에 필요한 주소 ( '받는 사람'및 '보낸 사람'주소)와 메시지를 전달하라는 메시지를 표시합니다. 메시지에 포함 할 헤더는 입력 한대로 메시지에 포함되어야합니다. 이 예제는 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; 헤더를 처리하지 않습니다 . 특히 '받는 사람'및 '보낸 사람'주소는 메시지 헤더에 명시 적으로 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d372344db0a88b9a62331f1afecea14cbc5e21cd" translate="yes" xml:space="preserve">
          <source>This example replaces the default &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt;&lt;code&gt;ProxyHandler&lt;/code&gt;&lt;/a&gt; with one that uses programmatically-supplied proxy URLs, and adds proxy authorization support with &lt;a href=&quot;#urllib.request.ProxyBasicAuthHandler&quot;&gt;&lt;code&gt;ProxyBasicAuthHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 예제는 기본 &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt; &lt;code&gt;ProxyHandler&lt;/code&gt; &lt;/a&gt; 를 프로그래밍 방식으로 제공되는 프록시 URL을 사용하는 것으로 &lt;a href=&quot;#urllib.request.ProxyBasicAuthHandler&quot;&gt; &lt;code&gt;ProxyBasicAuthHandler&lt;/code&gt; &lt;/a&gt; 하여 프록시 권한 부여 지원을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="199f5f9a1a221f41ad61ef405ac46477978bb064" translate="yes" xml:space="preserve">
          <source>This example sets the date header to the current time and date using the current timezone offset.</source>
          <target state="translated">이 예에서는 현재 시간대 오프셋을 사용하여 날짜 헤더를 현재 시간 및 날짜로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="149d4f5895c99a4046ae6fe26db4a50dcbbe5da1" translate="yes" xml:space="preserve">
          <source>This example shows a simple way of using &lt;a href=&quot;#mmap.mmap&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 예는 &lt;a href=&quot;#mmap.mmap&quot;&gt; &lt;code&gt;mmap&lt;/code&gt; &lt;/a&gt; 을 사용하는 간단한 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="2c2e84d68d5adbd7f566f2d6ceb02815d482de30" translate="yes" xml:space="preserve">
          <source>This example shows how a subclass of &lt;a href=&quot;#weakref.ref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; can be used to store additional information about an object and affect the value that&amp;rsquo;s returned when the referent is accessed:</source>
          <target state="translated">이 예제는 &lt;a href=&quot;#weakref.ref&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 의 서브 클래스가 오브젝트에 대한 추가 정보를 저장하고 참조에 액세스 할 때 리턴되는 값에 영향을주는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4877278717bc43a6502484400cc4fee0faeb0e64" translate="yes" xml:space="preserve">
          <source>This example shows how to get a (hex-encoded) 128-bit authentication code for message &lt;code&gt;b'message data'&lt;/code&gt; with key &lt;code&gt;b'pseudorandom key'&lt;/code&gt;:</source>
          <target state="translated">이 예제는 &lt;code&gt;b'pseudorandom key'&lt;/code&gt; 키를 사용 하여 메시지 &lt;code&gt;b'message data'&lt;/code&gt; 에 대한 (16 진 인코딩 된) 128 비트 인증 코드를 얻는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="60cba076ed0f689a795d5c4df38be8c57a334080" translate="yes" xml:space="preserve">
          <source>This example shows how to remove a directory tree on Windows where some of the files have their read-only bit set. It uses the onerror callback to clear the readonly bit and reattempt the remove. Any subsequent failure will propagate.</source>
          <target state="translated">이 예는 일부 파일에 읽기 전용 비트가 설정된 Windows에서 디렉토리 트리를 제거하는 방법을 보여줍니다. 읽기 전용 비트를 지우고 제거를 다시 시도하기 위해 onerror 콜백을 사용합니다. 후속 실패는 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="c874d767b57899eb18aae7c1b3e35304836e0ba1" translate="yes" xml:space="preserve">
          <source>This example shows how to use difflib to create a &lt;code&gt;diff&lt;/code&gt;-like utility. It is also contained in the Python source distribution, as &lt;code&gt;Tools/scripts/diff.py&lt;/code&gt;.</source>
          <target state="translated">이 예는 difflib를 사용하여 &lt;code&gt;diff&lt;/code&gt; 유사 유틸리티 를 작성하는 방법을 보여줍니다 . 또한 Python 소스 배포에도 &lt;code&gt;Tools/scripts/diff.py&lt;/code&gt; 로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="794f21932d1f601d70b331b1eb4caf3dbbb36379" translate="yes" xml:space="preserve">
          <source>This example sorts mail from several mailing lists into different mailboxes, being careful to avoid mail corruption due to concurrent modification by other programs, mail loss due to interruption of the program, or premature termination due to malformed messages in the mailbox:</source>
          <target state="translated">이 예에서는 여러 메일 그룹의 메일을 다른 사서함으로 분류하여 다른 프로그램에 의한 동시 수정, 프로그램 중단으로 인한 메일 손실 또는 메일 박스의 잘못된 메시지로 인한 조기 종료로 인한 메일 손상을 방지하기 위해주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="ae1a261bc1a23bc317bfbe070ca5019f36eaaca8" translate="yes" xml:space="preserve">
          <source>This example uses 64-byte internal digests, and returns the 32-byte final digest:</source>
          <target state="translated">이 예는 64 바이트 내부 다이제스트를 사용하고 32 바이트 최종 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f178cedeeecdf46a16a56bca9ff1c21e113376f" translate="yes" xml:space="preserve">
          <source>This example uses the iterator form:</source>
          <target state="translated">이 예제는 반복자 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="756a7f6039de09d51d751e231a05b92875ae2f1b" translate="yes" xml:space="preserve">
          <source>This example will print all file names in the current directory with the extension &lt;code&gt;.txt&lt;/code&gt;:</source>
          <target state="translated">이 예제는 현재 디렉토리의 확장자가 &lt;code&gt;.txt&lt;/code&gt; 인 모든 파일 이름을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="cb5551e6bcc3809b3b5a499fdf51a6ac5f52fa14" translate="yes" xml:space="preserve">
          <source>This exception can be caught to perform custom operations when asyncio Tasks are cancelled. In almost all situations the exception must be re-raised.</source>
          <target state="translated">이 예외는 asyncio 작업이 취소 될 때 사용자 지정 작업을 수행하도록 잡힐 수 있습니다. 거의 모든 상황에서 예외를 다시 제기해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2245ad8aaf85394acf3919fb1083c95fc2c5f50" translate="yes" xml:space="preserve">
          <source>This exception collects exceptions that are raised during a multi-file operation. For &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt;, the exception argument is a list of 3-tuples (&lt;em&gt;srcname&lt;/em&gt;, &lt;em&gt;dstname&lt;/em&gt;, &lt;em&gt;exception&lt;/em&gt;).</source>
          <target state="translated">이 예외는 다중 파일 작업 중에 발생한 예외를 수집합니다. 들면 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; , 예외 인수 3- 튜플 (목록이다 &lt;em&gt;srcname&lt;/em&gt; , &lt;em&gt;dstname&lt;/em&gt; , &lt;em&gt;예외&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="04ff319a12f67cfca8f5f539906ec49ee19dae8b" translate="yes" xml:space="preserve">
          <source>This exception is a subclass of &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 예외는 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="e7736c85cc53a35d004f8b52b5afbc5eaaff8f8e" translate="yes" xml:space="preserve">
          <source>This exception is derived from &lt;a href=&quot;#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;. In user defined base classes, abstract methods should raise this exception when they require derived classes to override the method, or while the class is being developed to indicate that the real implementation still needs to be added.</source>
          <target state="translated">이 예외는 &lt;a href=&quot;#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 에서 파생됩니다 . 사용자 정의 기본 클래스에서 추상 메소드는 메소드를 대체하기 위해 파생 클래스가 필요할 때 또는 실제 구현을 계속 추가해야 함을 나타 내기 위해 클래스를 개발할 때이 예외를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="c66b9d77cb46fec7211670e8e7cd4edf77c01cb2" translate="yes" xml:space="preserve">
          <source>This exception is derived from &lt;a href=&quot;#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;. It is raised when the interpreter detects that the maximum recursion depth (see &lt;a href=&quot;sys#sys.getrecursionlimit&quot;&gt;&lt;code&gt;sys.getrecursionlimit()&lt;/code&gt;&lt;/a&gt;) is exceeded.</source>
          <target state="translated">이 예외는 &lt;a href=&quot;#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 에서 파생됩니다 . 인터프리터가 최대 재귀 깊이 ( &lt;a href=&quot;sys#sys.getrecursionlimit&quot;&gt; &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt; &lt;/a&gt; 참조 )가 초과 되었음을 감지하면 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="3e9bf7a89c436eb9519f1ccd1f17934763da1eb1" translate="yes" xml:space="preserve">
          <source>This exception is different from the builtin &lt;a href=&quot;exceptions#TimeoutError&quot;&gt;&lt;code&gt;TimeoutError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">이 예외는 내장 &lt;a href=&quot;exceptions#TimeoutError&quot;&gt; &lt;code&gt;TimeoutError&lt;/code&gt; &lt;/a&gt; 예외 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="5abfaa7cb1b6df31569bd73bec0753febb5ef38a" translate="yes" xml:space="preserve">
          <source>This exception is raised by the &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt; function. It inherits from &lt;a href=&quot;#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; so that it is not accidentally caught by code that catches &lt;a href=&quot;#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;. This allows the exception to properly propagate up and cause the interpreter to exit. When it is not handled, the Python interpreter exits; no stack traceback is printed. The constructor accepts the same optional argument passed to &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt;. If the value is an integer, it specifies the system exit status (passed to C&amp;rsquo;s &lt;code&gt;exit()&lt;/code&gt; function); if it is &lt;code&gt;None&lt;/code&gt;, the exit status is zero; if it has another type (such as a string), the object&amp;rsquo;s value is printed and the exit status is one.</source>
          <target state="translated">이 예외는 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 함수에 의해 발생 합니다. 그것은 상속 &lt;a href=&quot;#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 가 실수로 코드가 어획량에 의해 체포되지 않도록 &lt;a href=&quot;#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; . 이를 통해 예외가 제대로 전파되어 인터프리터가 종료됩니다. 처리되지 않으면 Python 인터프리터가 종료됩니다. 스택 트레이스 백이 인쇄되지 않습니다. 생성자는 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 전달 된 것과 동일한 선택적 인수를 허용합니다 . 값이 정수이면 시스템 종료 상태를 지정합니다 (C의 &lt;code&gt;exit()&lt;/code&gt; 함수로 전달됨 ). 이 없을 경우 &lt;code&gt;None&lt;/code&gt; , 종료 상태는 0이다; 다른 유형 (예 : 문자열)이있는 경우 객체 값이 인쇄되고 종료 상태는 1입니다.</target>
        </trans-unit>
        <trans-unit id="5d36d890204d231c3db5ed28f13b407944350b88" translate="yes" xml:space="preserve">
          <source>This exception is raised if source and destination in &lt;a href=&quot;#shutil.copyfile&quot;&gt;&lt;code&gt;copyfile()&lt;/code&gt;&lt;/a&gt; are the same file.</source>
          <target state="translated">&lt;a href=&quot;#shutil.copyfile&quot;&gt; &lt;code&gt;copyfile()&lt;/code&gt; &lt;/a&gt; 소스와 대상 이 동일한 파일 인 경우이 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="8566ba7bb494d8af7e0fe1d383f3ef91ec51f1bd" translate="yes" xml:space="preserve">
          <source>This exception is raised on all errors, such as unknown number of bytes per sample, etc.</source>
          <target state="translated">이 예외는 샘플 당 알 수없는 바이트 수와 같은 모든 오류에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b644672ef25e1f525a78a441c53893d63755b91a" translate="yes" xml:space="preserve">
          <source>This exception is raised on certain errors. The argument is a string describing what went wrong.</source>
          <target state="translated">이 예외는 특정 오류에서 발생합니다. 인수는 무엇이 잘못되었는지 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2cc85694ad091b3a955d9c3bd409e50ebf522e46" translate="yes" xml:space="preserve">
          <source>This exception is raised to skip a test.</source>
          <target state="translated">이 예외는 테스트를 건너 뛰기 위해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="58cc721a5d45f6183858fe989cca9698e1cc1fbe" translate="yes" xml:space="preserve">
          <source>This exception is raised when a foreign function call cannot convert one of the passed arguments.</source>
          <target state="translated">외부 함수 호출이 전달 된 인수 중 하나를 변환 할 수없는 경우이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9404360bffa18ed1bd67ec88d6463042c13d79a5" translate="yes" xml:space="preserve">
          <source>This exception is raised when a string parameter contains a character that is not permitted in the context it&amp;rsquo;s being used in by the XML 1.0 recommendation. For example, attempting to create an &lt;code&gt;Element&lt;/code&gt; node with a space in the element type name will cause this error to be raised.</source>
          <target state="translated">이 예외는 문자열 매개 변수에 XML 1.0 권장 사항에서 사용중인 컨텍스트에서 허용되지 않는 문자가 포함 된 경우 발생합니다. 예를 들어, 요소 유형 이름에 공백이 있는 &lt;code&gt;Element&lt;/code&gt; 노드 를 작성하려고 하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ff9a579e9d83d01444b2f8d5100e032fc4e7952" translate="yes" xml:space="preserve">
          <source>This exception is raised when a system function returns a system-related error, including I/O failures such as &amp;ldquo;file not found&amp;rdquo; or &amp;ldquo;disk full&amp;rdquo; (not for illegal argument types or other incidental errors).</source>
          <target state="translated">이 예외는 시스템 함수가 &quot;파일을 찾을 수 없음&quot;또는 &quot;디스크가 가득 참&quot;과 같은 I / O 오류를 포함하여 시스템 관련 오류를 반환 할 때 발생합니다 (잘못된 인수 유형 또는 기타 부수적 인 오류는 해당되지 않음).</target>
        </trans-unit>
        <trans-unit id="1bc3c86de29d12b90a882aff98c2eec07bc27573" translate="yes" xml:space="preserve">
          <source>This exception is raised when a weak reference proxy, created by the &lt;a href=&quot;weakref#weakref.proxy&quot;&gt;&lt;code&gt;weakref.proxy()&lt;/code&gt;&lt;/a&gt; function, is used to access an attribute of the referent after it has been garbage collected. For more information on weak references, see the &lt;a href=&quot;weakref#module-weakref&quot;&gt;&lt;code&gt;weakref&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;weakref#weakref.proxy&quot;&gt; &lt;code&gt;weakref.proxy()&lt;/code&gt; &lt;/a&gt; 함수로 작성된 약한 참조 프록시를 사용하여 참조가 가비지 수집 된 후 참조의 속성에 액세스하는 경우이 예외가 발생 합니다. 약한 참조에 대한 자세한 내용은 &lt;a href=&quot;weakref#module-weakref&quot;&gt; &lt;code&gt;weakref&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fc1681a2f2c890252c17685b7d4e33e329d940d" translate="yes" xml:space="preserve">
          <source>This exception is raised when a writable mailbox has its status changed by the server. This is a sub-class of &lt;a href=&quot;#imaplib.IMAP4.error&quot;&gt;&lt;code&gt;IMAP4.error&lt;/code&gt;&lt;/a&gt;. Some other client now has write permission, and the mailbox will need to be re-opened to re-obtain write permission.</source>
          <target state="translated">쓰기 가능한 사서함의 상태가 서버에 의해 변경된 경우이 예외가 발생합니다. 이것은 &lt;a href=&quot;#imaplib.IMAP4.error&quot;&gt; &lt;code&gt;IMAP4.error&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . 다른 클라이언트에는 쓰기 권한이 있으며 쓰기 권한을 다시 얻으려면 사서함을 다시 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d6ecff71782ef8d9e93a241e475f2b20a701dab" translate="yes" xml:space="preserve">
          <source>This exception is raised when an error occurs during compression or decompression, or while initializing the compressor/decompressor state.</source>
          <target state="translated">이 예외는 압축 또는 압축 해제 중 또는 압축기 / 압축 해제 기 상태를 초기화하는 동안 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2409514ae954bb0af533c244afcfa71dbd523cc2" translate="yes" xml:space="preserve">
          <source>This exception is raised when the &lt;a href=&quot;#asyncio.Queue.get_nowait&quot;&gt;&lt;code&gt;get_nowait()&lt;/code&gt;&lt;/a&gt; method is called on an empty queue.</source>
          <target state="translated">빈 큐 에서 &lt;a href=&quot;#asyncio.Queue.get_nowait&quot;&gt; &lt;code&gt;get_nowait()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되면이 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="5102cc5a79e08a7c0452cc141b9537b61373b612" translate="yes" xml:space="preserve">
          <source>This exception is raised when the &lt;a href=&quot;urllib.request#urllib.request.urlretrieve&quot;&gt;&lt;code&gt;urlretrieve()&lt;/code&gt;&lt;/a&gt; function detects that the amount of the downloaded data is less than the expected amount (given by the &lt;em&gt;Content-Length&lt;/em&gt; header). The &lt;code&gt;content&lt;/code&gt; attribute stores the downloaded (and supposedly truncated) data.</source>
          <target state="translated">이 예외는 &lt;a href=&quot;urllib.request#urllib.request.urlretrieve&quot;&gt; &lt;code&gt;urlretrieve()&lt;/code&gt; &lt;/a&gt; 함수가 다운로드 된 데이터의 양이 &lt;em&gt;Content-Length&lt;/em&gt; 헤더 에서 제공 한 예상 양보다 적은 것을 감지하면 발생합니다 . &lt;code&gt;content&lt;/code&gt; 속성을 저장하여 데이터를 다운로드 (및 아마도 절단).</target>
        </trans-unit>
        <trans-unit id="bdfe4875d5ba1070e830332816dd12241af8086e" translate="yes" xml:space="preserve">
          <source>This exception is raised when the server unexpectedly disconnects, or when an attempt is made to use the &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt; instance before connecting it to a server.</source>
          <target state="translated">이 예외는 서버 연결이 갑자기 끊어 지거나 서버에 연결하기 전에 &lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; &lt;/a&gt; 인스턴스 를 사용하려고 할 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="542841d41f063cbb018245ada2a57db1142f7ad3" translate="yes" xml:space="preserve">
          <source>This exception may be raised by user code to indicate that an attempted operation on an object is not supported, and is not meant to be. If an object is meant to support a given operation but has not yet provided an implementation, &lt;a href=&quot;#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; is the proper exception to raise.</source>
          <target state="translated">이 예외는 사용자 코드에 의해 발생되어 개체에 대한 시도 된 작업이 지원되지 않으며 의도되지 않았 음을 나타냅니다. 개체가 지정된 작업을 지원하지만 아직 구현을 제공하지 않은 경우 &lt;a href=&quot;#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt; 가 발생하는 적절한 예외입니다.</target>
        </trans-unit>
        <trans-unit id="7a08b02abca8718c7204bf9f673ee79551dbb60d" translate="yes" xml:space="preserve">
          <source>This exception, a subclass of &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;, is raised when the &lt;a href=&quot;#threading.Barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; object is reset or broken.</source>
          <target state="translated">&lt;a href=&quot;#threading.Barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt; 객체가 재설정되거나 깨질 때 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 인이 예외 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="1c1aa14e9619480ad86d082fd229c59c6cd9c32c" translate="yes" xml:space="preserve">
          <source>This expression evaluates to &lt;code&gt;True&lt;/code&gt; if &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;os.access()&lt;/code&gt;&lt;/a&gt; supports &lt;code&gt;effective_ids=True&lt;/code&gt; on the local platform:</source>
          <target state="translated">&lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;os.access()&lt;/code&gt; &lt;/a&gt; 가 로컬 플랫폼에서 &lt;code&gt;effective_ids=True&lt;/code&gt; 를 지원 하면 이 표현식은 &lt;code&gt;True&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="633ac41847f4e119da8fe6e2c132acd3ad7d6a6a" translate="yes" xml:space="preserve">
          <source>This factory function creates a function that can be used as a callable for &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;em&gt;ignore&lt;/em&gt; argument, ignoring files and directories that match one of the glob-style &lt;em&gt;patterns&lt;/em&gt; provided. See the example below.</source>
          <target state="translated">이 팩토리 함수는 제공된 glob 스타일 &lt;em&gt;패턴&lt;/em&gt; 중 하나와 일치하는 파일과 디렉토리를 무시하고 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;ignore&lt;/em&gt; 인수에 대한 호출 가능 함수로 사용할 수있는 함수를 작성합니다 . 아래 예를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8163d2b1312f6d8e2b608937718b193c1bd6dec6" translate="yes" xml:space="preserve">
          <source>This factory function creates and returns a new ctypes pointer type. Pointer types are cached and reused internally, so calling this function repeatedly is cheap. &lt;em&gt;type&lt;/em&gt; must be a ctypes type.</source>
          <target state="translated">이 팩토리 함수는 새 ctypes 포인터 유형을 작성하고 리턴합니다. 포인터 유형은 내부적으로 캐시되어 재사용되므로이 함수를 반복해서 호출하는 것이 저렴합니다. &lt;em&gt;type&lt;/em&gt; 은 ctypes &lt;em&gt;유형&lt;/em&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="91c8c475d8b0ce7014c0cef96a207a73500c7165" translate="yes" xml:space="preserve">
          <source>This feature can be disabled by setting &lt;code&gt;allow_abbrev&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;allow_abbrev&lt;/code&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정 하여이 기능을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c7a0557b8a57ee027564f2bc023efbef1ba46a1" translate="yes" xml:space="preserve">
          <source>This feature is not available on Windows.</source>
          <target state="translated">이 기능은 Windows에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="88bd30c5ce87bf5e4843b4151adf98e7bf9c98c1" translate="yes" xml:space="preserve">
          <source>This features requires OpenSSL 0.9.8f or newer.</source>
          <target state="translated">이 기능에는 OpenSSL 0.9.8f 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="140c6b2dbf9a419843c07939e4cad112713e18f4" translate="yes" xml:space="preserve">
          <source>This features requires OpenSSL 1.1.1 or newer.</source>
          <target state="translated">이 기능에는 OpenSSL 1.1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3a49f557a9e7cd87ce6aae19a5ed6c4bfa6e3ab7" translate="yes" xml:space="preserve">
          <source>This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;(?:&lt;/code&gt; or &lt;code&gt;(?P&amp;lt;...&amp;gt;&lt;/code&gt;. When a line contains a &lt;code&gt;#&lt;/code&gt; that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such &lt;code&gt;#&lt;/code&gt; through the end of the line are ignored.</source>
          <target state="translated">이 플래그를 사용하면 패턴의 논리적 섹션을 시각적으로 분리하고 주석을 추가 할 수있어 더보기 좋고 읽기 쉬운 정규식을 작성할 수 있습니다. 문자 클래스에 있거나 이스케이프 처리되지 않은 백 슬래시가 앞에 있거나 &lt;code&gt;*?&lt;/code&gt; 와 같은 토큰 내에있는 경우를 제외하고 패턴 내의 공백은 무시됩니다 . , &lt;code&gt;(?:&lt;/code&gt; 또는 &lt;code&gt;(?P&amp;lt;...&amp;gt;&lt;/code&gt; . 행 에 문자 클래스에없고 &lt;code&gt;#&lt;/code&gt; 이스케이프되지 않은 백 슬래시가없는 # 을 포함하는 경우 가장 왼쪽에서 &lt;code&gt;#&lt;/code&gt; 까지의 모든 문자 는 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="6776e1560b68f5240a1ba4435437a318443994f3" translate="yes" xml:space="preserve">
          <source>This flag can be OR&amp;rsquo;ed with any other scheduling policy. When a process with this flag set forks, its child&amp;rsquo;s scheduling policy and priority are reset to the default.</source>
          <target state="translated">이 플래그는 다른 스케줄링 정책과 함께 OR 될 수 있습니다. 이 플래그가 설정된 프로세스가 분기되면 하위의 스케줄링 정책 및 우선 순위가 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4bb5e8bac1bee574b48e95ad1269a90a6d72a2ab" translate="yes" xml:space="preserve">
          <source>This flag is ignored if &lt;a href=&quot;#subprocess.CREATE_NEW_CONSOLE&quot;&gt;&lt;code&gt;CREATE_NEW_CONSOLE&lt;/code&gt;&lt;/a&gt; is specified.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.CREATE_NEW_CONSOLE&quot;&gt; &lt;code&gt;CREATE_NEW_CONSOLE&lt;/code&gt; &lt;/a&gt; 이 지정된 경우이 플래그는 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a75f6aece8739456749d49d943dcd827dfddcd0" translate="yes" xml:space="preserve">
          <source>This flag is not supported on modern Windows platforms.</source>
          <target state="translated">이 플래그는 최신 Windows 플랫폼에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43e3d95482fafc51295e5f9b744822dacdde2901" translate="yes" xml:space="preserve">
          <source>This follows the US convention of &lt;code&gt;DAY_1&lt;/code&gt; being Sunday, not the international convention (ISO 8601) that Monday is the first day of the week.</source>
          <target state="translated">이는 월요일 &lt;code&gt;DAY_1&lt;/code&gt; 의 첫 번째 요일 인 국제 규칙 (ISO 8601)이 아니라 일요일 DAY_1 의 미국 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="b283665a2e4addf0f4b94b565264877c7b695f5f" translate="yes" xml:space="preserve">
          <source>This format is more limited than &lt;code&gt;.xz&lt;/code&gt; &amp;ndash; it does not support integrity checks or multiple filters.</source>
          <target state="translated">이 형식은 &lt;code&gt;.xz&lt;/code&gt; 보다 제한적이며 무결성 검사 또는 다중 필터를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="416c204cc1d425d9fead84292efcc4e9beda33c5" translate="yes" xml:space="preserve">
          <source>This format specifier does not support integrity checks, and requires that you always specify a custom filter chain (for both compression and decompression). Additionally, data compressed in this manner cannot be decompressed using &lt;code&gt;FORMAT_AUTO&lt;/code&gt; (see &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt;&lt;code&gt;LZMADecompressor&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 형식 지정자는 무결성 검사를 지원하지 않으며 항상 사용자 지정 필터 체인 (압축 및 압축 해제 모두)을 지정해야합니다. 또한 이러한 방식으로 압축 된 데이터는 &lt;code&gt;FORMAT_AUTO&lt;/code&gt; 를 사용하여 압축 해제 할 수 없습니다 ( &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt; &lt;code&gt;LZMADecompressor&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="989faedbf517851e250011a0c82fce8ac57f5b92" translate="yes" xml:space="preserve">
          <source>This function accepts a parse tree represented as a sequence and builds an internal representation if possible. If it can validate that the tree conforms to the Python grammar and all nodes are valid node types in the host version of Python, an ST object is created from the internal representation and returned to the called. If there is a problem creating the internal representation, or if the tree cannot be validated, a &lt;a href=&quot;#parser.ParserError&quot;&gt;&lt;code&gt;ParserError&lt;/code&gt;&lt;/a&gt; exception is raised. An ST object created this way should not be assumed to compile correctly; normal exceptions raised by compilation may still be initiated when the ST object is passed to &lt;a href=&quot;#parser.compilest&quot;&gt;&lt;code&gt;compilest()&lt;/code&gt;&lt;/a&gt;. This may indicate problems not related to syntax (such as a &lt;a href=&quot;exceptions#MemoryError&quot;&gt;&lt;code&gt;MemoryError&lt;/code&gt;&lt;/a&gt; exception), but may also be due to constructs such as the result of parsing &lt;code&gt;del f(0)&lt;/code&gt;, which escapes the Python parser but is checked by the bytecode compiler.</source>
          <target state="translated">이 함수는 시퀀스로 표시된 구문 분석 트리를 허용하고 가능한 경우 내부 표현을 작성합니다. 트리가 Python 문법을 준수하는지 검증 할 수 있고 모든 노드가 Python 호스트 버전에서 유효한 노드 유형 인 경우 ST 오브젝트가 내부 표현에서 작성되어 호출 된 것으로 리턴됩니다. 내부 표현을 작성하는 데 문제가 있거나 트리를 검증 할 수없는 경우 &lt;a href=&quot;#parser.ParserError&quot;&gt; &lt;code&gt;ParserError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 이 방법으로 작성된 ST 오브젝트는 올바르게 컴파일되는 것으로 가정해서는 안됩니다. ST 오브젝트가 &lt;a href=&quot;#parser.compilest&quot;&gt; &lt;code&gt;compilest()&lt;/code&gt; &lt;/a&gt; 전달 될 때 컴파일에 의해 발생 된 일반 예외는 여전히 시작될 수 있습니다 . 구문과 관련이없는 문제 (예 : &lt;a href=&quot;exceptions#MemoryError&quot;&gt; &lt;code&gt;MemoryError&lt;/code&gt; )&lt;/a&gt; 를 나타낼 수 있습니다.예외)), 그러나 파싱 &lt;code&gt;del f(0)&lt;/code&gt; 의 결과와 같은 구문으로 인해 발생할 수 있습니다.이 구문 은 파이썬 파서를 이스케이프하지만 바이트 코드 컴파일러에서 확인합니다.</target>
        </trans-unit>
        <trans-unit id="67cbaeac62e982b846f73d97f9e9a2e46abe862c" translate="yes" xml:space="preserve">
          <source>This function accepts an ST object from the caller in &lt;em&gt;st&lt;/em&gt; and returns a Python list representing the equivalent parse tree. The resulting list representation can be used for inspection or the creation of a new parse tree in list form. This function does not fail so long as memory is available to build the list representation. If the parse tree will only be used for inspection, &lt;a href=&quot;#parser.st2tuple&quot;&gt;&lt;code&gt;st2tuple()&lt;/code&gt;&lt;/a&gt; should be used instead to reduce memory consumption and fragmentation. When the list representation is required, this function is significantly faster than retrieving a tuple representation and converting that to nested lists.</source>
          <target state="translated">이 함수는 &lt;em&gt;st&lt;/em&gt; 의 호출자로부터 ST 객체를 받아 동등한 구문 분석 트리를 나타내는 Python 목록을 반환합니다. 결과 목록 표현은 검사 또는 목록 형식으로 새 구문 분석 트리 작성에 사용할 수 있습니다. 메모리가 목록 표현을 빌드 할 수있는 한이 기능은 실패하지 않습니다. 구문 분석 트리가 검사에만 사용되는 경우 메모리 소비 및 조각화를 줄이기 위해 &lt;a href=&quot;#parser.st2tuple&quot;&gt; &lt;code&gt;st2tuple()&lt;/code&gt; &lt;/a&gt; 을 대신 사용해야합니다. 리스트 표현이 필요한 경우,이 함수는 튜플 표현을 검색하여 중첩 된리스트로 변환하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e9a7e450b07e96b8d37598fb40a161b3ec8ab42a" translate="yes" xml:space="preserve">
          <source>This function accepts an ST object from the caller in &lt;em&gt;st&lt;/em&gt; and returns a Python tuple representing the equivalent parse tree. Other than returning a tuple instead of a list, this function is identical to &lt;a href=&quot;#parser.st2list&quot;&gt;&lt;code&gt;st2list()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;st&lt;/em&gt; 의 호출자로부터 ST 객체를 받아 동등한 구문 분석 트리를 나타내는 Python 튜플을 반환합니다. 리스트 대신 튜플을 반환하는 것 &lt;a href=&quot;#parser.st2list&quot;&gt; &lt;code&gt;st2list()&lt;/code&gt; &lt;/a&gt; 함수는 st2list ()와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="321d86afeb1999f005b4db61414e6c09451e8851" translate="yes" xml:space="preserve">
          <source>This function allows for partial sends, which can happen when the network is busy.</source>
          <target state="translated">이 기능은 네트워크가 바쁠 때 발생할 수있는 부분 전송을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fe899672dab1e5e73d8fb72fca72c949a0360195" translate="yes" xml:space="preserve">
          <source>This function always creates a new event loop and closes it at the end. It should be used as a main entry point for asyncio programs, and should ideally only be called once.</source>
          <target state="translated">이 함수는 항상 새로운 이벤트 루프를 생성하고 마지막에 닫습니다. asyncio 프로그램의 기본 진입 점으로 사용해야하며 이상적으로 한 번만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e046b276c5e0f6ce872efb15eac2bd1f19828574" translate="yes" xml:space="preserve">
          <source>This function always returns an object which can work as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; and has methods such as</source>
          <target state="translated">이 기능은 항상 같이 작업 할 수있는 객체를 반환 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;컨텍스트 매니저를&lt;/a&gt; 하고 다음과 같은 방법이있다</target>
        </trans-unit>
        <trans-unit id="afd0d330dff663f3dc120c9eb1f87d37d23d40ac" translate="yes" xml:space="preserve">
          <source>This function always supports &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt; and &lt;a href=&quot;#follow-symlinks&quot;&gt;not following symlinks&lt;/a&gt;. Note however that, unlike other functions, the &lt;a href=&quot;#os.fwalk&quot;&gt;&lt;code&gt;fwalk()&lt;/code&gt;&lt;/a&gt; default value for &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">이 함수는 항상 &lt;a href=&quot;#follow-symlinks&quot;&gt;심볼릭 링크를 따르지 않고 &lt;/a&gt;&lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 디스크립터&lt;/a&gt; 와 관련된 경로를 지원 합니다 . 다른 기능과는 달리, 것을 그러나 참고 &lt;a href=&quot;#os.fwalk&quot;&gt; &lt;code&gt;fwalk()&lt;/code&gt; &lt;/a&gt; 에 대한 기본값 &lt;em&gt;follow_symlinks이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed1efc12979920dcd6c776bcfcdcc27d24754b6f" translate="yes" xml:space="preserve">
          <source>This function attempts to guess which of the several simple database modules available &amp;mdash; &lt;a href=&quot;#module-dbm.gnu&quot;&gt;&lt;code&gt;dbm.gnu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#module-dbm.ndbm&quot;&gt;&lt;code&gt;dbm.ndbm&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#module-dbm.dumb&quot;&gt;&lt;code&gt;dbm.dumb&lt;/code&gt;&lt;/a&gt; &amp;mdash; should be used to open a given file.</source>
          <target state="translated">이 함수 는 주어진 파일을 여는 데 사용할 수있는 몇 가지 간단한 데이터베이스 모듈 ( &lt;a href=&quot;#module-dbm.gnu&quot;&gt; &lt;code&gt;dbm.gnu&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#module-dbm.ndbm&quot;&gt; &lt;code&gt;dbm.ndbm&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#module-dbm.dumb&quot;&gt; &lt;code&gt;dbm.dumb&lt;/code&gt; )&lt;/a&gt; 을 추측하려고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="8ab5d1e1419c1e6e527c5b28e58d7f204d5d5901" translate="yes" xml:space="preserve">
          <source>This function calls &lt;a href=&quot;#plistlib.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; to do the actual work, see the documentation of &lt;a href=&quot;#plistlib.load&quot;&gt;&lt;code&gt;that function&lt;/code&gt;&lt;/a&gt; for an explanation of the keyword arguments.</source>
          <target state="translated">이 함수 는 실제 작업을 수행하기 위해 &lt;a href=&quot;#plistlib.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 를 호출합니다 . 키워드 인수에 대한 설명은 &lt;a href=&quot;#plistlib.load&quot;&gt; &lt;code&gt;that function&lt;/code&gt; &lt;/a&gt; 의 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7643b642de54efb09acb94ff349ac141f3740543" translate="yes" xml:space="preserve">
          <source>This function can also be used to execute arbitrary code objects (such as those created by &lt;a href=&quot;#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;). In this case pass a code object instead of a string. If the code object has been compiled with &lt;code&gt;'exec'&lt;/code&gt; as the &lt;em&gt;mode&lt;/em&gt; argument, &lt;a href=&quot;#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s return value will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 함수는 또한 임의의 코드 객체 (예 : &lt;a href=&quot;#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 생성 된 객체)를 실행하는 데 사용될 수 있습니다 . 이 경우 문자열 대신 코드 객체를 전달하십시오. 코드 오브젝트가 &lt;em&gt;모드&lt;/em&gt; 인수 로 &lt;code&gt;'exec'&lt;/code&gt; 를 사용하여 컴파일 된 경우 &lt;a href=&quot;#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 의 리턴 값은 &lt;code&gt;None&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c83a78a81f4633ef210bfad83d65ad3ed569eed4" translate="yes" xml:space="preserve">
          <source>This function can also support &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 디스크립터와 관련된 경로&lt;/a&gt; 도 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="246288c265a4e1776c81f6798f272763d36779b3" translate="yes" xml:space="preserve">
          <source>This function can also support &lt;a href=&quot;#path-fd&quot;&gt;specifying a file descriptor&lt;/a&gt;; the file descriptor must refer to a directory.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#path-fd&quot;&gt;파일 디스크립터 지정&lt;/a&gt; 을 지원할 수도 있습니다 . 파일 디스크립터는 디렉토리를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb38baa42674aa3420a5ba84abf298951b8d79bb" translate="yes" xml:space="preserve">
          <source>This function can fail with the new directory structure made if you lack permissions needed to remove the leaf directory or file.</source>
          <target state="translated">리프 디렉토리 또는 파일을 제거하는 데 필요한 권한이없는 경우 작성된 ​​새 디렉토리 구조로 인해이 기능이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24201f2bcec067a0cadef86b16eb4b56ccf09408" translate="yes" xml:space="preserve">
          <source>This function can raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; and subclasses such as &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#PermissionError&quot;&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;exceptions#NotADirectoryError&quot;&gt;&lt;code&gt;NotADirectoryError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능을 높일 수 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 과 같은 서브 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#PermissionError&quot;&gt; &lt;code&gt;PermissionError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#NotADirectoryError&quot;&gt; &lt;code&gt;NotADirectoryError&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84dc07fa2ed11ef2486edb31b54936913c119158" translate="yes" xml:space="preserve">
          <source>This function can support &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt; with the &lt;em&gt;dir_fd&lt;/em&gt; parameter.</source>
          <target state="translated">이 함수는 &lt;em&gt;dir_fd&lt;/em&gt; 매개 변수를 사용하여 &lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 디스크립터&lt;/a&gt; 와 관련된 경로 를 지원할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b68d682873763be0740e66ddb99f09801a4806ea" translate="yes" xml:space="preserve">
          <source>This function can support &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 디스크립터와 관련된 경로&lt;/a&gt; 를 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a372fc0e1775faa2f765a46dcfe627ccc5b0b02" translate="yes" xml:space="preserve">
          <source>This function can support &lt;a href=&quot;#follow-symlinks&quot;&gt;not following symlinks&lt;/a&gt;.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;#follow-symlinks&quot;&gt;심볼릭 링크를&lt;/a&gt; 지원 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ba43daecc37b3b1b1aaa02be05b7cbcd978d90b9" translate="yes" xml:space="preserve">
          <source>This function can support &lt;a href=&quot;#path-fd&quot;&gt;specifying a file descriptor&lt;/a&gt; and &lt;a href=&quot;#follow-symlinks&quot;&gt;not following symlinks&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#path-fd&quot;&gt;파일 디스크립터 지정&lt;/a&gt; 을 지원 하고 &lt;a href=&quot;#follow-symlinks&quot;&gt;심볼릭 링크를 따르지 않을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a1de8b6398b0c357406d8ca517cc6964f787838" translate="yes" xml:space="preserve">
          <source>This function can support &lt;a href=&quot;#path-fd&quot;&gt;specifying a file descriptor&lt;/a&gt;, &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt; and &lt;a href=&quot;#follow-symlinks&quot;&gt;not following symlinks&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#path-fd&quot;&gt;파일 디스크립터&lt;/a&gt; , &lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 디스크립터&lt;/a&gt; 와 관련된 경로 및 &lt;a href=&quot;#follow-symlinks&quot;&gt;심볼릭 링크를 따르지 않는 &lt;/a&gt;경로 지정 을 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2d794dbe904f4089dea7a0681a102aab31ead7a" translate="yes" xml:space="preserve">
          <source>This function can support &lt;a href=&quot;#path-fd&quot;&gt;specifying a file descriptor&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#path-fd&quot;&gt;파일 디스크립터 지정&lt;/a&gt; 을 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="080173ce67b107ec521fc1ec6fed9977e31919b9" translate="yes" xml:space="preserve">
          <source>This function can support &lt;a href=&quot;#path-fd&quot;&gt;specifying a file descriptor&lt;/a&gt;. The descriptor must refer to an opened directory, not an open file.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#path-fd&quot;&gt;파일 디스크립터 지정&lt;/a&gt; 을 지원할 수 있습니다 . 디스크립터는 열린 파일이 아니라 열린 디렉토리를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb5e909c57dce7b157370491ade31ffad496f482" translate="yes" xml:space="preserve">
          <source>This function can support specifying &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt; and &lt;a href=&quot;#follow-symlinks&quot;&gt;not following symlinks&lt;/a&gt;.</source>
          <target state="translated">이 기능은 지정 지원할 수있는 &lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 설명에 상대 경로&lt;/a&gt; 와 &lt;a href=&quot;#follow-symlinks&quot;&gt;심볼릭 링크를 따라하지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b687afc2a9b6992774dda2ac6ff5383d0e794ce7" translate="yes" xml:space="preserve">
          <source>This function can support specifying &lt;em&gt;src_dir_fd&lt;/em&gt; and/or &lt;em&gt;dst_dir_fd&lt;/em&gt; to supply &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt;, and &lt;a href=&quot;#follow-symlinks&quot;&gt;not following symlinks&lt;/a&gt;.</source>
          <target state="translated">이 기능은 지정 지원할 수 &lt;em&gt;src_dir_fd&lt;/em&gt; 및 / 또는 &lt;em&gt;dst_dir_fd을&lt;/em&gt; 공급에 &lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 설명에 상대 경로&lt;/a&gt; 와 &lt;a href=&quot;#follow-symlinks&quot;&gt;심볼릭 링크를 따라하지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f41ff7dbc91012c3c5b04b05b34a937ef7d76bc" translate="yes" xml:space="preserve">
          <source>This function can support specifying &lt;em&gt;src_dir_fd&lt;/em&gt; and/or &lt;em&gt;dst_dir_fd&lt;/em&gt; to supply &lt;a href=&quot;#dir-fd&quot;&gt;paths relative to directory descriptors&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#dir-fd&quot;&gt;디렉토리 디스크립터에 상대적인 경로&lt;/a&gt; 를 제공하기 위해 &lt;em&gt;src_dir_fd&lt;/em&gt; 및 / 또는 &lt;em&gt;dst_dir_fd&lt;/em&gt; 지정을 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb07224e25025b731bf2f81e5c6d8118346c44be" translate="yes" xml:space="preserve">
          <source>This function cannot be called when another asyncio event loop is running in the same thread.</source>
          <target state="translated">다른 asyncio 이벤트 루프가 동일한 스레드에서 실행 중이면이 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2b26c04e5c0956fc2606ac8c6a99fe5f3d8eb37" translate="yes" xml:space="preserve">
          <source>This function causes the &lt;a href=&quot;#module-cgitb&quot;&gt;&lt;code&gt;cgitb&lt;/code&gt;&lt;/a&gt; module to take over the interpreter&amp;rsquo;s default handling for exceptions by setting the value of &lt;a href=&quot;sys#sys.excepthook&quot;&gt;&lt;code&gt;sys.excepthook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#module-cgitb&quot;&gt; &lt;code&gt;cgitb&lt;/code&gt; &lt;/a&gt; 모듈이 &lt;a href=&quot;sys#sys.excepthook&quot;&gt; &lt;code&gt;sys.excepthook&lt;/code&gt; &lt;/a&gt; 값을 설정하여 예외에 대한 인터프리터의 기본 처리를 인계합니다 .</target>
        </trans-unit>
        <trans-unit id="c529d55efe484171205ace1eaae0be4ead749532" translate="yes" xml:space="preserve">
          <source>This function checks the environment variables &lt;code id=&quot;index-0&quot;&gt;LOGNAME&lt;/code&gt;, &lt;code id=&quot;index-1&quot;&gt;USER&lt;/code&gt;, &lt;code id=&quot;index-2&quot;&gt;LNAME&lt;/code&gt; and &lt;code id=&quot;index-3&quot;&gt;USERNAME&lt;/code&gt;, in order, and returns the value of the first one which is set to a non-empty string. If none are set, the login name from the password database is returned on systems which support the &lt;a href=&quot;pwd#module-pwd&quot;&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/a&gt; module, otherwise, an exception is raised.</source>
          <target state="translated">이 함수는 환경 변수 &lt;code id=&quot;index-0&quot;&gt;LOGNAME&lt;/code&gt; , &lt;code id=&quot;index-1&quot;&gt;USER&lt;/code&gt; , &lt;code id=&quot;index-2&quot;&gt;LNAME&lt;/code&gt; 및 &lt;code id=&quot;index-3&quot;&gt;USERNAME&lt;/code&gt; 을 순서대로 확인하고 비어 있지 않은 문자열로 설정된 첫 번째 값을 리턴합니다. 설정하지 않으면 비밀번호 데이터베이스의 로그인 이름이 &lt;a href=&quot;pwd#module-pwd&quot;&gt; &lt;code&gt;pwd&lt;/code&gt; &lt;/a&gt; 모듈 을 지원하는 시스템에서 리턴됩니다 . 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6efae03f969812467873fc7c658e4f8c65206e8" translate="yes" xml:space="preserve">
          <source>This function creates a mutable character buffer. The returned object is a ctypes array of &lt;a href=&quot;#ctypes.c_char&quot;&gt;&lt;code&gt;c_char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 가변 문자 버퍼를 만듭니다. 반환 된 객체는 &lt;a href=&quot;#ctypes.c_char&quot;&gt; &lt;code&gt;c_char&lt;/code&gt; &lt;/a&gt; 의 ctypes 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="d85e1f7c1c7feb43831c932856b41d843b092294" translate="yes" xml:space="preserve">
          <source>This function creates a mutable unicode character buffer. The returned object is a ctypes array of &lt;a href=&quot;#ctypes.c_wchar&quot;&gt;&lt;code&gt;c_wchar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 가변 유니 코드 문자 버퍼를 만듭니다. 반환 된 객체는 &lt;a href=&quot;#ctypes.c_wchar&quot;&gt; &lt;code&gt;c_wchar&lt;/code&gt; &lt;/a&gt; 의 ctypes 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="cc1bfdda8af45c4752ba7931dbfd50a06388950a" translate="yes" xml:space="preserve">
          <source>This function creates a new pointer instance, pointing to &lt;em&gt;obj&lt;/em&gt;. The returned object is of the type &lt;code&gt;POINTER(type(obj))&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;obj를&lt;/em&gt; 가리키는 새 포인터 인스턴스를 만듭니다 . 리턴 된 오브젝트는 &lt;code&gt;POINTER(type(obj))&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="660ffac77bae61fa75e6d1bc0e35c474820d48c8" translate="yes" xml:space="preserve">
          <source>This function does not attempt to verify that you have passed the actual mean as &lt;em&gt;xbar&lt;/em&gt;. Using arbitrary values for &lt;em&gt;xbar&lt;/em&gt; can lead to invalid or impossible results.</source>
          <target state="translated">이 함수는 실제 평균을 &lt;em&gt;xbar&lt;/em&gt; 로 전달했는지 확인하지 않습니다 . &lt;em&gt;xbar에&lt;/em&gt; 임의의 값을 사용하면 유효하지 않거나 불가능한 결과가 &lt;em&gt;발생할&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35888f80b9cb879ee93d24c03d6a6db8aa2d710a" translate="yes" xml:space="preserve">
          <source>This function does not check whether the data points are at least &lt;em&gt;interval&lt;/em&gt; apart.</source>
          <target state="translated">이 기능은 데이터 포인트가 최소한 &lt;em&gt;간격을두고&lt;/em&gt; 있는지 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c86a6e9fac8ee8c7c704554bc8964eb5395d74d" translate="yes" xml:space="preserve">
          <source>This function does nothing if the root logger already has handlers configured, unless the keyword argument &lt;em&gt;force&lt;/em&gt; is set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">키워드 인수 &lt;em&gt;force&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 설정되어 있지 않으면 루트 로거에 이미 핸들러가 구성된 경우이 함수는 아무 작업도 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="514c10027e6febd0ca9b4e0e8abae20168e49aa7" translate="yes" xml:space="preserve">
          <source>This function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; syntax. &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt; does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.</source>
          <target state="translated">이 기능은 실제 서식 작업을 수행합니다. &lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kwargs&lt;/code&gt; 구문을 사용하여 사전을 개별 인수로 풀고 다시 압축하는 대신 사전 정의 된 인수 사전을 전달하려는 경우 별도의 함수로 표시됩니다 . &lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt; 은 형식 문자열을 문자 데이터와 대체 필드로 분리하는 작업을 수행합니다. 아래에 설명 된 다양한 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1957f99cb00cac22539008ce3672f35c832dcd45" translate="yes" xml:space="preserve">
          <source>This function drops you into the debugger at the call site. Specifically, it calls &lt;a href=&quot;sys#sys.breakpointhook&quot;&gt;&lt;code&gt;sys.breakpointhook()&lt;/code&gt;&lt;/a&gt;, passing &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kws&lt;/code&gt; straight through. By default, &lt;code&gt;sys.breakpointhook()&lt;/code&gt; calls &lt;a href=&quot;pdb#pdb.set_trace&quot;&gt;&lt;code&gt;pdb.set_trace()&lt;/code&gt;&lt;/a&gt; expecting no arguments. In this case, it is purely a convenience function so you don&amp;rsquo;t have to explicitly import &lt;a href=&quot;pdb#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; or type as much code to enter the debugger. However, &lt;a href=&quot;sys#sys.breakpointhook&quot;&gt;&lt;code&gt;sys.breakpointhook()&lt;/code&gt;&lt;/a&gt; can be set to some other function and &lt;a href=&quot;#breakpoint&quot;&gt;&lt;code&gt;breakpoint()&lt;/code&gt;&lt;/a&gt; will automatically call that, allowing you to drop into the debugger of choice.</source>
          <target state="translated">이 함수는 호출 사이트의 디버거로 이동합니다. 특히 &lt;a href=&quot;sys#sys.breakpointhook&quot;&gt; &lt;code&gt;sys.breakpointhook()&lt;/code&gt; &lt;/a&gt; 호출 하여 &lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;kws&lt;/code&gt; 를 직접 전달합니다. 기본적으로 &lt;code&gt;sys.breakpointhook()&lt;/code&gt; 은 &lt;a href=&quot;pdb#pdb.set_trace&quot;&gt; &lt;code&gt;pdb.set_trace()&lt;/code&gt; &lt;/a&gt; 없는 pdb.set_trace ()를 호출합니다 . 이 경우 순전히 편의 기능이므로 디버거에 들어가기 위해 &lt;a href=&quot;pdb#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 를 명시 적으로 가져 오거나 많은 코드를 입력 할 필요가 없습니다 . 그러나 &lt;a href=&quot;sys#sys.breakpointhook&quot;&gt; &lt;code&gt;sys.breakpointhook()&lt;/code&gt; &lt;/a&gt; 을 다른 함수로 설정할 수 있으며 &lt;a href=&quot;#breakpoint&quot;&gt; &lt;code&gt;breakpoint()&lt;/code&gt; &lt;/a&gt; 가 자동으로이를 호출하여 선택한 디버거로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10780002f9c2d93187c1df77ca7ace00a3742b52" translate="yes" xml:space="preserve">
          <source>This function expands XInclude directives. &lt;em&gt;elem&lt;/em&gt; is the root element. &lt;em&gt;loader&lt;/em&gt; is an optional resource loader. If omitted, it defaults to &lt;a href=&quot;#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader&quot;&gt;&lt;code&gt;default_loader()&lt;/code&gt;&lt;/a&gt;. If given, it should be a callable that implements the same interface as &lt;a href=&quot;#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader&quot;&gt;&lt;code&gt;default_loader()&lt;/code&gt;&lt;/a&gt;. Returns the expanded resource. If the parse mode is &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, this is an ElementTree instance. If the parse mode is &amp;ldquo;text&amp;rdquo;, this is a Unicode string. If the loader fails, it can return None or raise an exception.</source>
          <target state="translated">이 함수는 XInclude 지시문을 확장합니다. &lt;em&gt;elem&lt;/em&gt; 은 루트 요소입니다. &lt;em&gt;로더&lt;/em&gt; 는 선택적 자원 로더입니다. 생략하면 기본값은 &lt;a href=&quot;#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader&quot;&gt; &lt;code&gt;default_loader()&lt;/code&gt; &lt;/a&gt; 입니다. 주어진 경우, &lt;a href=&quot;#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader&quot;&gt; &lt;code&gt;default_loader()&lt;/code&gt; &lt;/a&gt; 와 동일한 인터페이스를 구현하는 호출 가능해야합니다 . 확장 된 리소스를 반환합니다. 구문 분석 모드가 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; 인 경우 ElementTree 인스턴스입니다. 구문 분석 모드가 &quot;텍스트&quot;인 경우 이것은 유니 코드 문자열입니다. 로더가 실패하면 None을 리턴하거나 예외를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d183e0b0a1996b7d266deb457bb1c39a308cf71" translate="yes" xml:space="preserve">
          <source>This function handles UNC paths correctly.</source>
          <target state="translated">이 기능은 UNC 경로를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="39d613e79eca353689d0e33384eef7ca7c8b978f" translate="yes" xml:space="preserve">
          <source>This function handles an exception using the default settings (that is, show a report in the browser, but don&amp;rsquo;t log to a file). This can be used when you&amp;rsquo;ve caught an exception and want to report it using &lt;a href=&quot;#module-cgitb&quot;&gt;&lt;code&gt;cgitb&lt;/code&gt;&lt;/a&gt;. The optional &lt;em&gt;info&lt;/em&gt; argument should be a 3-tuple containing an exception type, exception value, and traceback object, exactly like the tuple returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;. If the &lt;em&gt;info&lt;/em&gt; argument is not supplied, the current exception is obtained from &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 기본 설정을 사용하여 예외를 처리합니다 (즉, 브라우저에 보고서를 표시하지만 파일에 기록하지는 않음). 예외를 발견하고 &lt;a href=&quot;#module-cgitb&quot;&gt; &lt;code&gt;cgitb&lt;/code&gt; 를&lt;/a&gt; 사용하여보고하려는 경우에 사용할 수 있습니다 . 선택적 &lt;em&gt;info&lt;/em&gt; 인수는 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 반환 한 튜플과 똑같이 예외 유형, 예외 값 및 트레이스 백 객체를 포함하는 3- 튜플이어야합니다 . 상기 중간 &lt;em&gt;정보&lt;/em&gt; 인수가 제공되지 않고, 현재의 예외로부터 얻어진다 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95c638b427c88a31a4b477cb0d745500c128a308" translate="yes" xml:space="preserve">
          <source>This function handles the exception described by &lt;em&gt;info&lt;/em&gt; (a 3-tuple containing the result of &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;), formatting its traceback as HTML and returning the result as a string. The optional argument &lt;em&gt;context&lt;/em&gt; is the number of lines of context to display around the current line of source code in the traceback; this defaults to &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;info&lt;/em&gt; ( &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 의 결과를 포함하는 3 개의 튜플)에 의해 설명 된 예외를 처리하고 , 그 추적을 HTML로 형식화하고 결과를 문자열로 리턴합니다. 선택적 인수 &lt;em&gt;컨텍스트&lt;/em&gt; 는 트레이스 백에서 현재 소스 코드 행 주위에 표시 할 컨텍스트 행 수입니다. 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ecec700fa8113f48e6cc0d41277de9fd36d4792" translate="yes" xml:space="preserve">
          <source>This function handles the exception described by &lt;em&gt;info&lt;/em&gt; (a 3-tuple containing the result of &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;), formatting its traceback as text and returning the result as a string. The optional argument &lt;em&gt;context&lt;/em&gt; is the number of lines of context to display around the current line of source code in the traceback; this defaults to &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;info&lt;/em&gt; ( &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 의 결과를 포함하는 3 개의 튜플)에 의해 설명 된 예외를 처리하고 , 그 추적을 텍스트로 형식화하고 결과를 문자열로 리턴합니다. 선택적 인수 &lt;em&gt;컨텍스트&lt;/em&gt; 는 트레이스 백에서 현재 소스 코드 행 주위에 표시 할 컨텍스트 행 수입니다. 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e68a59cb55c5c08ef9ff6ef164187eb8c36720fa" translate="yes" xml:space="preserve">
          <source>This function has been &lt;strong&gt;added in Python 3.7&lt;/strong&gt;. Prior to Python 3.7, the low-level &lt;a href=&quot;asyncio-future#asyncio.ensure_future&quot;&gt;&lt;code&gt;asyncio.ensure_future()&lt;/code&gt;&lt;/a&gt; function can be used instead:</source>
          <target state="translated">이 함수는 &lt;strong&gt;Python 3.7에서 추가되었습니다&lt;/strong&gt; . Python 3.7 이전에는 저수준 &lt;a href=&quot;asyncio-future#asyncio.ensure_future&quot;&gt; &lt;code&gt;asyncio.ensure_future()&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c966fb5bb08388dce4957a9885cbfef7ae831e47" translate="yes" xml:space="preserve">
          <source>This function has been added on a provisional basis (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">이 기능은 임시로 추가되었습니다 (자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="fc3352bd7899627742c5d818912f6834e1c6bd22" translate="yes" xml:space="preserve">
          <source>This function has been added on a provisional basis (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; for details.) Use it only for debugging purposes.</source>
          <target state="translated">이 기능은 임시로 추가되었습니다 (자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; 참조 ). 디버깅 목적으로 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f611ccb8e78599647e771c2dd3f8be5177e91535" translate="yes" xml:space="preserve">
          <source>This function has been added on a provisional basis (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-28&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">이 기능은 임시로 추가되었습니다 (자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-28&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="ea1d284a0ca301e5f36ffb15fa62803f51745cd9" translate="yes" xml:space="preserve">
          <source>This function has been added on a provisional basis (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-29&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; for details.) Use it only for debugging purposes.</source>
          <target state="translated">이 기능은 임시로 추가되었습니다 (자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0411&quot; id=&quot;index-29&quot;&gt;&lt;strong&gt;PEP 411&lt;/strong&gt;&lt;/a&gt; 참조 ). 디버깅 목적으로 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef87984f54425c7e20ecc28f19c814ccf05ac527" translate="yes" xml:space="preserve">
          <source>This function implements the standard &lt;code&gt;.mo&lt;/code&gt; file search algorithm. It takes a &lt;em&gt;domain&lt;/em&gt;, identical to what &lt;a href=&quot;#gettext.textdomain&quot;&gt;&lt;code&gt;textdomain()&lt;/code&gt;&lt;/a&gt; takes. Optional &lt;em&gt;localedir&lt;/em&gt; is as in &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt;&lt;code&gt;bindtextdomain()&lt;/code&gt;&lt;/a&gt;. Optional &lt;em&gt;languages&lt;/em&gt; is a list of strings, where each string is a language code.</source>
          <target state="translated">이 기능은 표준 &lt;code&gt;.mo&lt;/code&gt; 파일 검색 알고리즘을 구현합니다 . 그것은 소요 &lt;em&gt;도메인&lt;/em&gt; 무엇 동일을, &lt;a href=&quot;#gettext.textdomain&quot;&gt; &lt;code&gt;textdomain()&lt;/code&gt; &lt;/a&gt; 합니다. 선택적 &lt;em&gt;localedir&lt;/em&gt; 은 &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt; &lt;code&gt;bindtextdomain()&lt;/code&gt; &lt;/a&gt; . 선택적 &lt;em&gt;언어&lt;/em&gt; 는 문자열 목록이며 각 문자열은 언어 코드입니다.</target>
        </trans-unit>
        <trans-unit id="172dadb9dc85c7a090d62a6f27fdb75709950244" translate="yes" xml:space="preserve">
          <source>This function imports and returns a fresh copy of the named Python module by removing the named module from &lt;code&gt;sys.modules&lt;/code&gt; before doing the import. Note that unlike &lt;code&gt;reload()&lt;/code&gt;, the original module is not affected by this operation.</source>
          <target state="translated">이 함수 는 가져 오기를 수행하기 전에 &lt;code&gt;sys.modules&lt;/code&gt; 에서 명명 된 모듈을 제거하여 명명 된 Python 모듈의 새로운 사본을 가져오고 리턴합니다 . &lt;code&gt;reload()&lt;/code&gt; 와 달리 원래 모듈은이 작업의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e85250eaece03f8dc4805c01a0978aa0691dd7c0" translate="yes" xml:space="preserve">
          <source>This function imports and returns the named module. Unlike a normal import, this function raises &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt;&lt;code&gt;unittest.SkipTest&lt;/code&gt;&lt;/a&gt; if the module cannot be imported.</source>
          <target state="translated">이 함수는 명명 된 모듈을 가져오고 반환합니다. 일반 가져 오기와 달리이 함수 는 모듈을 가져올 수없는 경우 &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt; &lt;code&gt;unittest.SkipTest&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fe663ee4d39048854bb84cb63b91ff780333b588" translate="yes" xml:space="preserve">
          <source>This function is Unix specific.</source>
          <target state="translated">이 기능은 유닉스 전용입니다.</target>
        </trans-unit>
        <trans-unit id="9e01cbde143f3e80838cbf4287afc5bd594fa7e9" translate="yes" xml:space="preserve">
          <source>This function is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt; that can be used to define a factory function for &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement asynchronous context managers, without needing to create a class or separate &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aenter__&quot;&gt;&lt;code&gt;__aenter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt;&lt;code&gt;__aexit__()&lt;/code&gt;&lt;/a&gt; methods. It must be applied to an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;asynchronous generator&lt;/a&gt; function.</source>
          <target state="translated">이 함수는 클래스를 만들거나 별도의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aenter__&quot;&gt; &lt;code&gt;__aenter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt; &lt;code&gt;__aexit__()&lt;/code&gt; &lt;/a&gt; 메서드 를 만들 필요없이 명령문 비동기 컨텍스트 관리자 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 대한 팩토리 함수를 정의하는 데 사용할 수 있는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;데코레이터&lt;/a&gt; 입니다 . &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;비동기 생성기&lt;/a&gt; 기능에 적용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="149b80885bdd0b63fad9b906d671077767527f43" translate="yes" xml:space="preserve">
          <source>This function is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt; that can be used to define a factory function for &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement context managers, without needing to create a class or separate &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이 함수는 클래스 또는 별도의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메서드 를 만들 필요없이 명령문 컨텍스트 관리자 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 팩토리 함수를 정의하는 데 사용할 수 있는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;데코레이터&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0c899e79e3c0eabc9cc8a8a015050464bb0041cf" translate="yes" xml:space="preserve">
          <source>This function is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt; that is used to add generated &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-special-method&quot;&gt;special method&lt;/a&gt;s to classes, as described below.</source>
          <target state="translated">이 함수는 아래와 같이 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-special-method&quot;&gt;특수 메소드&lt;/a&gt; 를 클래스 에 추가하는 데 사용되는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;데코레이터&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="faffa47c08d7418284e943db0a2194e64073b3a1" translate="yes" xml:space="preserve">
          <source>This function is a small but complete WSGI application that returns a text page containing the message &amp;ldquo;Hello world!&amp;rdquo; and a list of the key/value pairs provided in the &lt;em&gt;environ&lt;/em&gt; parameter. It&amp;rsquo;s useful for verifying that a WSGI server (such as &lt;a href=&quot;#module-wsgiref.simple_server&quot;&gt;&lt;code&gt;wsgiref.simple_server&lt;/code&gt;&lt;/a&gt;) is able to run a simple WSGI application correctly.</source>
          <target state="translated">이 함수는 작지만 완전한 WSGI 응용 프로그램으로 &quot;Hello world!&quot;메시지가 포함 된 텍스트 페이지를 반환합니다. 및 &lt;em&gt;environ&lt;/em&gt; 매개 변수에 제공된 키 / 값 쌍의 목록 . WSGI 서버 (예 : &lt;a href=&quot;#module-wsgiref.simple_server&quot;&gt; &lt;code&gt;wsgiref.simple_server&lt;/code&gt; &lt;/a&gt; )가 간단한 WSGI 애플리케이션을 올바르게 실행할 수 있는지 확인하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="d515f195df4ddcf5d5033ae67b93ed67290c7488" translate="yes" xml:space="preserve">
          <source>This function is added to the built-in namespace by the &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 모듈에 의해 내장 네임 스페이스에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="64628f06fee9b7aeeaa8847c7406b08c68a6b088" translate="yes" xml:space="preserve">
          <source>This function is analogous to &lt;a href=&quot;#inspect.getgeneratorlocals&quot;&gt;&lt;code&gt;getgeneratorlocals()&lt;/code&gt;&lt;/a&gt;, but works for coroutine objects created by &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#inspect.getgeneratorlocals&quot;&gt; &lt;code&gt;getgeneratorlocals()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 함수로 작성된 코 루틴 오브젝트에 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="03648b49b7e97f2705e79f86b31e7423f5f4b8ad" translate="yes" xml:space="preserve">
          <source>This function is called if the &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt;&lt;code&gt;handle()&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;#socketserver.BaseServer.RequestHandlerClass&quot;&gt;&lt;code&gt;RequestHandlerClass&lt;/code&gt;&lt;/a&gt; instance raises an exception. The default action is to print the traceback to standard error and continue handling further requests.</source>
          <target state="translated">&lt;a href=&quot;#socketserver.BaseServer.RequestHandlerClass&quot;&gt; &lt;code&gt;RequestHandlerClass&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt; &lt;code&gt;handle()&lt;/code&gt; &lt;/a&gt; 메소드 에서 예외가 발생 하면이 함수가 호출됩니다 . 기본 조치는 추적을 표준 오류로 인쇄하고 추가 요청을 계속 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="25f184942d28c9f4cf30b9129690c3f39a8da58c" translate="yes" xml:space="preserve">
          <source>This function is called unconditionally after &lt;code&gt;tearDownModule()&lt;/code&gt;, or after &lt;code&gt;setUpModule()&lt;/code&gt; if &lt;code&gt;setUpModule()&lt;/code&gt; raises an exception.</source>
          <target state="translated">이 함수는 이후 무조건 호출 &lt;code&gt;tearDownModule()&lt;/code&gt; 또는 후 &lt;code&gt;setUpModule()&lt;/code&gt; 경우 &lt;code&gt;setUpModule()&lt;/code&gt; 예외를 제기한다.</target>
        </trans-unit>
        <trans-unit id="00dac4aa5f98112430b5f2dcd53d84ccb136fadf" translate="yes" xml:space="preserve">
          <source>This function is called when the &lt;a href=&quot;#socketserver.BaseServer.timeout&quot;&gt;&lt;code&gt;timeout&lt;/code&gt;&lt;/a&gt; attribute has been set to a value other than &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and the timeout period has passed with no requests being received. The default action for forking servers is to collect the status of any child processes that have exited, while in threading servers this method does nothing.</source>
          <target state="translated">&lt;a href=&quot;#socketserver.BaseServer.timeout&quot;&gt; &lt;code&gt;timeout&lt;/code&gt; &lt;/a&gt; 속성이 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이외의 값으로 설정 되고 요청이 수신되지 않고 제한 시간이 경과 한 경우이 함수가 호출됩니다 . 서버를 포크하기위한 기본 조치는 종료 된 모든 하위 프로세스의 상태를 수집하는 반면 서버 스레딩에서는이 방법으로 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ca63d1075eb1aceb700174dca580627844286b7" translate="yes" xml:space="preserve">
          <source>This function is identical to the &lt;a href=&quot;#fcntl.fcntl&quot;&gt;&lt;code&gt;fcntl()&lt;/code&gt;&lt;/a&gt; function, except that the argument handling is even more complicated.</source>
          <target state="translated">이 함수는 인수 처리가 더 복잡하다는 점을 제외하고 &lt;a href=&quot;#fcntl.fcntl&quot;&gt; &lt;code&gt;fcntl()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="58ba7af41df3064b3d3f217ed825d3dd8ed01388" translate="yes" xml:space="preserve">
          <source>This function is implemented using a watchdog thread.</source>
          <target state="translated">이 기능은 워치 독 스레드를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="64cad07e3c93c343820394a2eee72ae7a507e0bd" translate="yes" xml:space="preserve">
          <source>This function is installed as the trace function of debugged frames. Its return value is the new trace function (in most cases, that is, itself).</source>
          <target state="translated">이 기능은 디버그 된 프레임의 추적 기능으로 설치됩니다. 리턴 값은 새로운 추적 기능 (대부분의 경우 자체)입니다.</target>
        </trans-unit>
        <trans-unit id="d0b78e0190c2580f2856b7455b5b0eafaf4ddb3d" translate="yes" xml:space="preserve">
          <source>This function is intended for low-level I/O and must be applied to a file descriptor as returned by &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;os.open()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.pipe&quot;&gt;&lt;code&gt;pipe()&lt;/code&gt;&lt;/a&gt;. To close a &amp;ldquo;file object&amp;rdquo; returned by the built-in function &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; or by &lt;a href=&quot;#os.popen&quot;&gt;&lt;code&gt;popen()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.fdopen&quot;&gt;&lt;code&gt;fdopen()&lt;/code&gt;&lt;/a&gt;, use its &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 함수는 저수준 I / O를위한 것이며 &lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;os.open()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.pipe&quot;&gt; &lt;code&gt;pipe()&lt;/code&gt; &lt;/a&gt; 반환 한 파일 설명자에 적용되어야합니다 . 상기 내장 함수에 의해 반환 된 &quot;파일 객체&quot;닫으려면 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 또는으로 &lt;a href=&quot;#os.popen&quot;&gt; &lt;code&gt;popen()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.fdopen&quot;&gt; &lt;code&gt;fdopen()&lt;/code&gt; &lt;/a&gt; , 사용에 &lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="ade6f6e290e3dc96f0eb9460be14368d6afe280c" translate="yes" xml:space="preserve">
          <source>This function is intended for low-level I/O and must be applied to a file descriptor as returned by &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;os.open()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.pipe&quot;&gt;&lt;code&gt;pipe()&lt;/code&gt;&lt;/a&gt;. To read a &amp;ldquo;file object&amp;rdquo; returned by the built-in function &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; or by &lt;a href=&quot;#os.popen&quot;&gt;&lt;code&gt;popen()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.fdopen&quot;&gt;&lt;code&gt;fdopen()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt;, use its &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;readline()&lt;/code&gt; methods.</source>
          <target state="translated">이 함수는 저수준 I / O를위한 것이며 &lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;os.open()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.pipe&quot;&gt; &lt;code&gt;pipe()&lt;/code&gt; &lt;/a&gt; 반환 한 파일 설명자에 적용되어야합니다 . 상기 내장 함수에 의해 반환 된 &quot;파일 객체&quot;읽으려면 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 또는으로 &lt;a href=&quot;#os.popen&quot;&gt; &lt;code&gt;popen()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.fdopen&quot;&gt; &lt;code&gt;fdopen()&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; 를&lt;/a&gt; 사용, &lt;code&gt;read()&lt;/code&gt; 또는 &lt;code&gt;readline()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="2c704116a76ce54c12e05f3b6967028eb14b6cc5" translate="yes" xml:space="preserve">
          <source>This function is intended for low-level I/O and must be applied to a file descriptor as returned by &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;os.open()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.pipe&quot;&gt;&lt;code&gt;pipe()&lt;/code&gt;&lt;/a&gt;. To write a &amp;ldquo;file object&amp;rdquo; returned by the built-in function &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; or by &lt;a href=&quot;#os.popen&quot;&gt;&lt;code&gt;popen()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.fdopen&quot;&gt;&lt;code&gt;fdopen()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;, use its &lt;code&gt;write()&lt;/code&gt; method.</source>
          <target state="translated">이 함수는 저수준 I / O를위한 것이며 &lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;os.open()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.pipe&quot;&gt; &lt;code&gt;pipe()&lt;/code&gt; &lt;/a&gt; 반환 한 파일 설명자에 적용되어야합니다 . 상기 내장 함수에 의해 반환 된 &quot;파일 객체&quot;작성하려면 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 또는로 &lt;a href=&quot;#os.popen&quot;&gt; &lt;code&gt;popen()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.fdopen&quot;&gt; &lt;code&gt;fdopen()&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 를을&lt;/a&gt; , 그것의 사용 &lt;code&gt;write()&lt;/code&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="bacd28868867d67c5d6723d7c3178c25e186f11d" translate="yes" xml:space="preserve">
          <source>This function is intended for low-level I/O. For normal usage, use the built-in function &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, which returns a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; with &lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; methods (and many more). To wrap a file descriptor in a file object, use &lt;a href=&quot;#os.fdopen&quot;&gt;&lt;code&gt;fdopen()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 저수준 I / O를위한 것입니다. 일반적인 사용의 경우, 내장 기능의 사용 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 반환, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 함께 &lt;code&gt;read()&lt;/code&gt; 와 &lt;code&gt;write()&lt;/code&gt; 메소드 (그리고 더 많은). 파일 디스크립터를 파일 오브젝트로 랩하려면 &lt;a href=&quot;#os.fdopen&quot;&gt; &lt;code&gt;fdopen()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60efcb44e54e053b402648036b9dc38b2898562c" translate="yes" xml:space="preserve">
          <source>This function is invoked by the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement. It can be replaced (by importing the &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; module and assigning to &lt;code&gt;builtins.__import__&lt;/code&gt;) in order to change semantics of the &lt;code&gt;import&lt;/code&gt; statement, but doing so is &lt;strong&gt;strongly&lt;/strong&gt; discouraged as it is usually simpler to use import hooks (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of &lt;a href=&quot;#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; is also discouraged in favor of &lt;a href=&quot;importlib#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문에 의해 호출됩니다 . (수입으로 대체 될 수 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 모듈에 할당 &lt;code&gt;builtins.__import__&lt;/code&gt; 의 변화를 의미하기 위해) &lt;code&gt;import&lt;/code&gt; 되는 문,하지만 그렇게 &lt;strong&gt;강력하게&lt;/strong&gt; 그것을 사용 가져 오기 후크 (참조 보통 간단로 낙담 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; )을 달성하기 위해 동일한 목표를 가지고 있으며 기본 가져 오기 구현이 사용 중이라고 가정하는 코드에 문제가 발생하지 않습니다. &lt;a href=&quot;importlib#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 직접 사용 하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="51460bb18486d76dae169e7512a607a5c185a142" translate="yes" xml:space="preserve">
          <source>This function is meant to be called from a different OS thread than the one where the event loop is running. Example:</source>
          <target state="translated">이 함수는 이벤트 루프가 실행되는 것과 다른 OS 스레드에서 호출되도록되어 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="6474c1567381e3873ebbeca05d51f7ab42d23453" translate="yes" xml:space="preserve">
          <source>This function is not available on MacOS.</source>
          <target state="translated">MacOS에서는이 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="62d7cf1ebeba361fc0a928442d4acc718cf42922" translate="yes" xml:space="preserve">
          <source>This function is not strictly required, because any Python mechanism for creating a new class with &lt;code&gt;__annotations__&lt;/code&gt; can then apply the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; function to convert that class to a dataclass. This function is provided as a convenience. For example:</source>
          <target state="translated">&lt;code&gt;__annotations__&lt;/code&gt; 로 새 클래스를 만드는 모든 Python 메커니즘 은 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 함수를 적용하여 해당 클래스를 데이터 클래스로 변환 할 수 있으므로이 함수는 꼭 필요한 것은 아닙니다 . 이 기능은 편의상 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8105687cf78676b920dca7d0135677e8cf83f7b7" translate="yes" xml:space="preserve">
          <source>This function is preferred over &lt;a href=&quot;#datetime.datetime.today&quot;&gt;&lt;code&gt;today()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.datetime.utcnow&quot;&gt;&lt;code&gt;utcnow()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#datetime.datetime.today&quot;&gt; &lt;code&gt;today()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.datetime.utcnow&quot;&gt; &lt;code&gt;utcnow()&lt;/code&gt; &lt;/a&gt; 보다 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="2534bb784a341d57cb3cfff1ca73e4950b0ffd8e" translate="yes" xml:space="preserve">
          <source>This function is preferred over using &lt;a href=&quot;types#types.ModuleType&quot;&gt;&lt;code&gt;types.ModuleType&lt;/code&gt;&lt;/a&gt; to create a new module as &lt;strong&gt;spec&lt;/strong&gt; is used to set as many import-controlled attributes on the module as possible.</source>
          <target state="translated">이 기능을 이용하여 선호되는 &lt;a href=&quot;types#types.ModuleType&quot;&gt; &lt;code&gt;types.ModuleType&lt;/code&gt; 을&lt;/a&gt; 같은 새로운 모듈을 만들 &lt;strong&gt;스펙&lt;/strong&gt; 가능한 모듈 많은 수입 제어 특성으로서 설정하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="80d7cd1acc5c70b379682dbabb5d9e05ff3a4fdd" translate="yes" xml:space="preserve">
          <source>This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory:</source>
          <target state="translated">이 함수는 실제 구현이 메모리에 중간 결과를 작성하지 않는다는 점을 제외하고 다음 코드와 대략 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f913c0b361e7ba9728f0f9afaaf9d1c422afa44d" translate="yes" xml:space="preserve">
          <source>This function is semantically identical to &lt;a href=&quot;#os.unlink&quot;&gt;&lt;code&gt;unlink()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 의미 적으로 &lt;a href=&quot;#os.unlink&quot;&gt; &lt;code&gt;unlink()&lt;/code&gt; &lt;/a&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0d2662aab731484f469e5d0941ebd213855793da" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;#profile.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, with added arguments to supply the globals and locals dictionaries for the &lt;em&gt;command&lt;/em&gt; string. This routine executes:</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#profile.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 과 유사 하며 &lt;em&gt;명령&lt;/em&gt; 문자열에 대한 전역 및 지역 사전을 제공하기위한 인수가 추가되었습니다 . 이 루틴은 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fc117a48981b83bb2298193271331492a011693b" translate="yes" xml:space="preserve">
          <source>This function is similar to the cast operator in C. It returns a new instance of &lt;em&gt;type&lt;/em&gt; which points to the same memory block as &lt;em&gt;obj&lt;/em&gt;. &lt;em&gt;type&lt;/em&gt; must be a pointer type, and &lt;em&gt;obj&lt;/em&gt; must be an object that can be interpreted as a pointer.</source>
          <target state="translated">이 함수는 C의 캐스트 연산자와 유사합니다 . &lt;em&gt;obj&lt;/em&gt; 와 동일한 메모리 블록을 가리키는 새로운 &lt;em&gt;유형의&lt;/em&gt; 인스턴스를 반환합니다 . &lt;em&gt;type&lt;/em&gt; 은 포인터 유형 이어야 하고 &lt;em&gt;obj&lt;/em&gt; 는 포인터로 해석 될 수있는 객체 여야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c21cc18b67d5b59058325f10549a9243c64acf72" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;a href=&quot;#tabnanny.check&quot;&gt;&lt;code&gt;check()&lt;/code&gt;&lt;/a&gt; to process tokens generated by the &lt;a href=&quot;tokenize#module-tokenize&quot;&gt;&lt;code&gt;tokenize&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#tabnanny.check&quot;&gt; &lt;code&gt;check()&lt;/code&gt; &lt;/a&gt; 에서 토큰 &lt;a href=&quot;tokenize#module-tokenize&quot;&gt; &lt;code&gt;tokenize&lt;/code&gt; &lt;/a&gt; 모듈에 의해 생성 된 토큰을 처리 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f38d1e6f628d8e4e90ac779c811e7c28a0d89f12" translate="yes" xml:space="preserve">
          <source>This function is used internally by other functions (see below), but can also be useful when you want to transform an interactive Python session into a Python script.</source>
          <target state="translated">이 함수는 다른 함수에서 내부적으로 사용되지만 (아래 참조) 대화식 Python 세션을 Python 스크립트로 변환하려는 경우에도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f42493be0aa8250eeba0fe74603ddafd1c1e22" translate="yes" xml:space="preserve">
          <source>This function is used to turn the capture of warnings by logging on and off.</source>
          <target state="translated">이 기능은 로그온하여 로그 캡처를 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e291635b8b9e6f792c79b608f8ce39c024f95cf" translate="yes" xml:space="preserve">
          <source>This function is useful for programs that want to emulate Python&amp;rsquo;s interpreter main loop (a.k.a. the read-eval-print loop). The tricky part is to determine when the user has entered an incomplete command that can be completed by entering more text (as opposed to a complete command or a syntax error). This function &lt;em&gt;almost&lt;/em&gt; always makes the same decision as the real interpreter main loop.</source>
          <target state="translated">이 함수는 파이썬의 인터프리터 메인 루프 (일명 read-eval-print 루프)를 에뮬레이트하려는 프로그램에 유용합니다. 까다로운 부분은 사용자가 완료된 명령 또는 구문 오류와 달리 더 많은 텍스트를 입력하여 완료 할 수있는 불완전한 명령을 입력 한시기를 결정하는 것입니다. 이 함수는 &lt;em&gt;거의&lt;/em&gt; 항상 실제 인터프리터 메인 루프와 같은 결정을합니다.</target>
        </trans-unit>
        <trans-unit id="4346431163cf39d1256a2486c282563a29187752" translate="yes" xml:space="preserve">
          <source>This function is useful when creating a gateway that wraps CGI or a CGI-like protocol such as FastCGI. Typically, servers providing such protocols will include a &lt;code&gt;HTTPS&lt;/code&gt; variable with a value of &amp;ldquo;1&amp;rdquo;, &amp;ldquo;yes&amp;rdquo;, or &amp;ldquo;on&amp;rdquo; when a request is received via SSL. So, this function returns &amp;ldquo;https&amp;rdquo; if such a value is found, and &amp;ldquo;http&amp;rdquo; otherwise.</source>
          <target state="translated">이 기능은 CGI 또는 FastCGI와 같은 CGI 유사 프로토콜을 래핑하는 게이트웨이를 만들 때 유용합니다. 일반적으로 이러한 프로토콜을 제공하는 서버에는 SSL을 통해 요청이 수신 될 때 값이 &quot;1&quot;, &quot;yes&quot;또는 &quot;on&quot;인 &lt;code&gt;HTTPS&lt;/code&gt; 변수 가 포함됩니다 . 따라서이 함수는 값이 있으면 &quot;https&quot;를, 그렇지 않으면 &quot;http&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5407416b354a3a637ec255aca17cebdd4a5f0bcb" translate="yes" xml:space="preserve">
          <source>This function is useful when generating attribute values for HTML or any SGML using the reference concrete syntax.</source>
          <target state="translated">이 함수는 참조 구문을 사용하여 HTML 또는 SGML에 대한 속성 값을 생성 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="60d507fa2bc53284a2d250ec94185652719e0652" translate="yes" xml:space="preserve">
          <source>This function looks for items in &lt;em&gt;bases&lt;/em&gt; that are not instances of &lt;a href=&quot;functions#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, and returns a tuple where each such object that has an &lt;code&gt;__mro_entries__&lt;/code&gt; method is replaced with an unpacked result of calling this method. If a &lt;em&gt;bases&lt;/em&gt; item is an instance of &lt;a href=&quot;functions#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, or it doesn&amp;rsquo;t have an &lt;code&gt;__mro_entries__&lt;/code&gt; method, then it is included in the return tuple unchanged.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;functions#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 아닌 &lt;em&gt;베이스&lt;/em&gt; 에서 항목을 찾고 &lt;code&gt;__mro_entries__&lt;/code&gt; 메소드가 있는 각 오브젝트 가이 메소드 호출의 압축되지 않은 결과로 대체 되는 튜플을 리턴합니다 . 경우 &lt;em&gt;염기&lt;/em&gt; 항목의 인스턴스 &lt;a href=&quot;functions#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; , 또는 그것은없는 &lt;code&gt;__mro_entries__&lt;/code&gt; 된 후는 그대로 리턴 터플에 포함되는, 방법.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f333259d8228afee74ea63cb8cf96d3f815a21d2" translate="yes" xml:space="preserve">
          <source>This function may return invalid paths because it works a character at a time. To obtain a valid path, see &lt;a href=&quot;#os.path.commonpath&quot;&gt;&lt;code&gt;commonpath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 한 번에 한 문자 씩 작동하므로 유효하지 않은 경로를 반환 할 수 있습니다. 유효한 경로를 얻으려면 &lt;a href=&quot;#os.path.commonpath&quot;&gt; &lt;code&gt;commonpath()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a01d7176187eda18b9374489bf46391852e732ec" translate="yes" xml:space="preserve">
          <source>This function mirrors &lt;a href=&quot;#parser.isexpr&quot;&gt;&lt;code&gt;isexpr()&lt;/code&gt;&lt;/a&gt; in that it reports whether an ST object represents an &lt;code&gt;'exec'&lt;/code&gt; form, commonly known as a &amp;ldquo;suite.&amp;rdquo; It is not safe to assume that this function is equivalent to &lt;code&gt;not isexpr(st)&lt;/code&gt;, as additional syntactic fragments may be supported in the future.</source>
          <target state="translated">이 함수 는 ST 객체가 일반적으로 &quot;스위트&quot;라고 알려진 &lt;code&gt;'exec'&lt;/code&gt; 형식을 나타내는 지 여부를보고한다는 점에서 &lt;a href=&quot;#parser.isexpr&quot;&gt; &lt;code&gt;isexpr()&lt;/code&gt; &lt;/a&gt; 을 미러링 합니다 . 향후 추가적인 구문 조각이 지원 될 수 &lt;code&gt;not isexpr(st)&lt;/code&gt; 함수가 isexpr (st) 와 같지 않다고 가정하는 것은 안전 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c38aaa319da4fa690e529cb8f63297f25c44ad44" translate="yes" xml:space="preserve">
          <source>This function must do all the work required to service a request. The default implementation does nothing. Several instance attributes are available to it; the request is available as &lt;code&gt;self.request&lt;/code&gt;; the client address as &lt;code&gt;self.client_address&lt;/code&gt;; and the server instance as &lt;code&gt;self.server&lt;/code&gt;, in case it needs access to per-server information.</source>
          <target state="translated">이 기능은 요청을 처리하는 데 필요한 모든 작업을 수행해야합니다. 기본 구현은 아무 것도 수행하지 않습니다. 몇 가지 인스턴스 속성을 사용할 수 있습니다. 요청은 &lt;code&gt;self.request&lt;/code&gt; 로 가능합니다 . &lt;code&gt;self.client_address&lt;/code&gt; 와 같은 클라이언트 주소 ; 서버 별 정보에 액세스해야하는 경우 서버 인스턴스는 &lt;code&gt;self.server&lt;/code&gt; 로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0fe82f383fe8455cd84dddbd167e438d74db76" translate="yes" xml:space="preserve">
          <source>This function must not be used for the replacement string in &lt;a href=&quot;#re.sub&quot;&gt;&lt;code&gt;sub()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#re.subn&quot;&gt;&lt;code&gt;subn()&lt;/code&gt;&lt;/a&gt;, only backslashes should be escaped. For example:</source>
          <target state="translated">&lt;a href=&quot;#re.sub&quot;&gt; &lt;code&gt;sub()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#re.subn&quot;&gt; &lt;code&gt;subn()&lt;/code&gt; &lt;/a&gt; 의 대체 문자열에는이 함수를 사용 해서는 안되며 백 슬래시 만 이스케이프해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50da3b2b1a3e4d5d04267b56a098ab7684af854a" translate="yes" xml:space="preserve">
          <source>This function normally follows symlinks; to stat a symlink add the argument &lt;code&gt;follow_symlinks=False&lt;/code&gt;, or use &lt;a href=&quot;#os.lstat&quot;&gt;&lt;code&gt;lstat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 일반적으로 심볼릭 링크를 따릅니다. 심볼릭 링크를 통계하려면 &lt;code&gt;follow_symlinks=False&lt;/code&gt; 인수를 추가 하거나 &lt;a href=&quot;#os.lstat&quot;&gt; &lt;code&gt;lstat()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d52d4a6b72fa52058f61845c53226f55f2864d31" translate="yes" xml:space="preserve">
          <source>This function operates exactly as &lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt;&lt;code&gt;TemporaryFile()&lt;/code&gt;&lt;/a&gt; does, except that data is spooled in memory until the file size exceeds &lt;em&gt;max_size&lt;/em&gt;, or until the file&amp;rsquo;s &lt;code&gt;fileno()&lt;/code&gt; method is called, at which point the contents are written to disk and operation proceeds as with &lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt;&lt;code&gt;TemporaryFile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 파일 크기가 &lt;em&gt;max_size를&lt;/em&gt; 초과 할 때까지 또는 파일의 &lt;code&gt;fileno()&lt;/code&gt; 메소드가 호출 될 때까지 데이터가 메모리에 스풀링되는 것을 제외하고 &lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt; &lt;code&gt;TemporaryFile()&lt;/code&gt; &lt;/a&gt; 과 동일하게 작동합니다 .이 시점에서 컨텐츠는 디스크에 기록되고 &lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt; &lt;code&gt;TemporaryFile()&lt;/code&gt; &lt;/a&gt; 과 같이 작업이 진행됩니다 () .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b28cf0adbd47beaf5136380c661ee70913d0243" translate="yes" xml:space="preserve">
          <source>This function operates exactly as &lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt;&lt;code&gt;TemporaryFile()&lt;/code&gt;&lt;/a&gt; does, except that the file is guaranteed to have a visible name in the file system (on Unix, the directory entry is not unlinked). That name can be retrieved from the &lt;code&gt;name&lt;/code&gt; attribute of the returned file-like object. Whether the name can be used to open the file a second time, while the named temporary file is still open, varies across platforms (it can be so used on Unix; it cannot on Windows NT or later). If &lt;em&gt;delete&lt;/em&gt; is true (the default), the file is deleted as soon as it is closed. The returned object is always a file-like object whose &lt;code&gt;file&lt;/code&gt; attribute is the underlying true file object. This file-like object can be used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, just like a normal file.</source>
          <target state="translated">이 함수는 파일이 파일 시스템에서 보이는 이름을 가지고 있다는 것을 제외하고 &lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt; &lt;code&gt;TemporaryFile()&lt;/code&gt; &lt;/a&gt; 과 동일하게 작동 합니다 (UNIX에서는 디렉토리 항목이 링크되지 않음). 해당 이름은 리턴 된 파일 유사 오브젝트 의 &lt;code&gt;name&lt;/code&gt; 속성 에서 검색 할 수 있습니다 . 명명 된 임시 파일이 여전히 열려있는 동안 이름을 사용하여 파일을 두 번째로 열 수 있는지 여부는 플랫폼에 따라 다릅니다 (유닉스에서 사용할 수 있으며 Windows NT 이상에서는 사용할 수 없음). 경우 &lt;em&gt;삭제가&lt;/em&gt; true (디폴트), 파일은 즉시이 종료 될 때 삭제됩니다. 리턴 된 오브젝트는 항상 &lt;code&gt;file&lt;/code&gt; 속성이 기본 실제 파일 오브젝트 인 파일 과 유사한 오브젝트입니다 . 이 파일 - 류의 객체는 사용할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 일반 파일과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8a66c48b929d610e3db559cb30cbb31ccc42d7ac" translate="yes" xml:space="preserve">
          <source>This function passes &lt;code&gt;NULL&lt;/code&gt; for &lt;em&gt;security_attributes&lt;/em&gt; to the API.</source>
          <target state="translated">이 함수는 &lt;em&gt;security_attributes&lt;/em&gt; 에 대해 &lt;code&gt;NULL&lt;/code&gt; 을 API에 전달 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fde6b92d954d144ab8d68479a8fd1eafae433701" translate="yes" xml:space="preserve">
          <source>This function performs a call to &lt;a href=&quot;#multiprocessing.get_logger&quot;&gt;&lt;code&gt;get_logger()&lt;/code&gt;&lt;/a&gt; but in addition to returning the logger created by get_logger, it adds a handler which sends output to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt; using format &lt;code&gt;'[%(levelname)s/%(processName)s] %(message)s'&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#multiprocessing.get_logger&quot;&gt; &lt;code&gt;get_logger()&lt;/code&gt; &lt;/a&gt; 대한 호출을 수행 하지만 get_logger에 의해 작성된 로거를 리턴하는 것 외에도 &lt;code&gt;'[%(levelname)s/%(processName)s] %(message)s'&lt;/code&gt; 형식 (%)을 사용하여 출력을 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 로&lt;/a&gt; 보내는 핸들러를 추가 합니다. ) 's .</target>
        </trans-unit>
        <trans-unit id="d8bfadefc08d236f47565d11a8850b9788ddd116" translate="yes" xml:space="preserve">
          <source>This function prints out a given traceback and exception to &lt;code&gt;sys.stderr&lt;/code&gt;.</source>
          <target state="translated">이 함수는 주어진 트레이스 &lt;code&gt;sys.stderr&lt;/code&gt; 예외를 sys.stderr에 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="ce4c56e9ebaef2be95f933821a82b6250096cf20" translate="yes" xml:space="preserve">
          <source>This function raises &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; if the compiled source is invalid, and &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if the source contains null bytes.</source>
          <target state="translated">이 함수 는 컴파일 된 소스가 유효하지 않은 경우 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 를&lt;/a&gt; 발생시키고 소스에 널 바이트가 포함 된 경우 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8387f182301769ffb4d541325ec84e9397a2e7d8" translate="yes" xml:space="preserve">
          <source>This function raises an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;open&lt;/code&gt; with arguments &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt;. The &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; arguments may have been modified or inferred from the original call.</source>
          <target state="translated">이 함수 는 인수 &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 로 &lt;code&gt;open&lt;/code&gt; &lt;a href=&quot;sys#auditing&quot;&gt;감사 이벤트를 발생&lt;/a&gt; 시킵니다. &lt;code&gt;mode&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 인수를 수정하거나 원래 통화에서 추정되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78e94a989e8572d53e6ff1d156dde94e63d8cdf5" translate="yes" xml:space="preserve">
          <source>This function requires that the codec accept &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects to decode. Therefore it does not support text-to-text encoders such as &lt;code&gt;rot_13&lt;/code&gt;, although &lt;code&gt;rot_13&lt;/code&gt; may be used equivalently with &lt;a href=&quot;#codecs.iterencode&quot;&gt;&lt;code&gt;iterencode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능을 사용하려면 코덱 에서 디코딩 할 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 받아 들여야 합니다 . 따라서 같은 텍스트 - 텍스트 인코더 지원하지 않는 &lt;code&gt;rot_13&lt;/code&gt; 를 있지만 &lt;code&gt;rot_13&lt;/code&gt; 가 함께 동등하게 사용될 수있다 &lt;a href=&quot;#codecs.iterencode&quot;&gt; &lt;code&gt;iterencode()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed7e6a53326800e0c99a24c7943af3979b042021" translate="yes" xml:space="preserve">
          <source>This function requires that the codec accept text &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects to encode. Therefore it does not support bytes-to-bytes encoders such as &lt;code&gt;base64_codec&lt;/code&gt;.</source>
          <target state="translated">이 기능을 사용하려면 코덱 에서 인코딩 할 텍스트 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체를 수락해야합니다 . 따라서 &lt;code&gt;base64_codec&lt;/code&gt; 와 같은 바이트 대 바이트 인코더는 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca7b19d20b3fc70fd4a06f6eaf9f2609ffde0a21" translate="yes" xml:space="preserve">
          <source>This function resizes the internal memory buffer of &lt;em&gt;obj&lt;/em&gt;, which must be an instance of a ctypes type. It is not possible to make the buffer smaller than the native size of the objects type, as given by &lt;code&gt;sizeof(type(obj))&lt;/code&gt;, but it is possible to enlarge the buffer.</source>
          <target state="translated">이 함수 는 ctypes 유형의 인스턴스 여야하는 &lt;em&gt;obj&lt;/em&gt; 의 내부 메모리 버퍼 크기 를 조정합니다. &lt;code&gt;sizeof(type(obj))&lt;/code&gt; 의해 주어진 것처럼 객체 유형의 기본 크기보다 버퍼를 작게 만들 수는 없지만 버퍼를 확대 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7666a23252f123adf92ecbb5fd3b070801019d8" translate="yes" xml:space="preserve">
          <source>This function returns &lt;em&gt;func&lt;/em&gt;, which makes it possible to use it as a decorator.</source>
          <target state="translated">이 함수는 &lt;em&gt;func를&lt;/em&gt; 반환 하여 데코레이터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db7474465da4003217948e1553874c4a2c0f3b3" translate="yes" xml:space="preserve">
          <source>This function returns a &lt;code&gt;typing.TextIO&lt;/code&gt; instance, a text I/O stream open for reading.</source>
          <target state="translated">이 함수는 &lt;code&gt;typing.TextIO&lt;/code&gt; 인스턴스, 읽기 위해 열린 텍스트 I / O 스트림을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="11586ef5462bc5cc9bafb350e47c109a73f45482" translate="yes" xml:space="preserve">
          <source>This function returns a list of &lt;code&gt;(decoded_string, charset)&lt;/code&gt; pairs containing each of the decoded parts of the header. &lt;em&gt;charset&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; for non-encoded parts of the header, otherwise a lower case string containing the name of the character set specified in the encoded string.</source>
          <target state="translated">이 함수는 헤더의 디코딩 된 각 부분을 포함하는 &lt;code&gt;(decoded_string, charset)&lt;/code&gt; 쌍 의 목록을 반환합니다 . &lt;em&gt;charset&lt;/em&gt; 은 헤더의 인코딩되지 않은 부분에 대해서는 &lt;code&gt;None&lt;/code&gt; 이며, 그렇지 않으면 인코딩 된 문자열에 지정된 문자 세트의 이름을 포함하는 소문자 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c6b5a760d5b2d7a0cdc6a46768cb3ddd798abf48" translate="yes" xml:space="preserve">
          <source>This function returns a tuple of three values that give information about the exception that is currently being handled. The information returned is specific both to the current thread and to the current stack frame. If the current stack frame is not handling an exception, the information is taken from the calling stack frame, or its caller, and so on until a stack frame is found that is handling an exception. Here, &amp;ldquo;handling an exception&amp;rdquo; is defined as &amp;ldquo;executing an except clause.&amp;rdquo; For any stack frame, only information about the exception being currently handled is accessible.</source>
          <target state="translated">이 함수는 현재 처리중인 예외에 대한 정보를 제공하는 세 가지 값의 튜플을 반환합니다. 반환 된 정보는 현재 스레드와 현재 스택 프레임에 모두 해당됩니다. 현재 스택 프레임이 예외를 처리하지 않는 경우 예외를 처리하는 스택 프레임이 발견 될 때까지 호출 스택 프레임 또는 해당 호출자 등에서 정보를 가져옵니다. 여기서 &quot;예외 처리&quot;는 &quot;예외 조항 실행&quot;으로 정의됩니다. 모든 스택 프레임의 경우 현재 처리중인 예외에 대한 정보 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8119a5093d30b11cd9b05ae9690966f552c52002" translate="yes" xml:space="preserve">
          <source>This function returns an instance of &lt;code&gt;http.client.HTTPMessage&lt;/code&gt; that holds the header fields, but no payload (the same as &lt;a href=&quot;#http.client.HTTPResponse.msg&quot;&gt;&lt;code&gt;HTTPResponse.msg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http.server#http.server.BaseHTTPRequestHandler.headers&quot;&gt;&lt;code&gt;http.server.BaseHTTPRequestHandler.headers&lt;/code&gt;&lt;/a&gt;). After returning, the file pointer &lt;em&gt;fp&lt;/em&gt; is ready to read the HTTP body.</source>
          <target state="translated">이 함수는 &lt;code&gt;http.client.HTTPMessage&lt;/code&gt; 헤더 필드를 보유하지만 페이로드는 포함하지 않는 http.client.HTTPMessage ( &lt;a href=&quot;#http.client.HTTPResponse.msg&quot;&gt; &lt;code&gt;HTTPResponse.msg&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http.server#http.server.BaseHTTPRequestHandler.headers&quot;&gt; &lt;code&gt;http.server.BaseHTTPRequestHandler.headers&lt;/code&gt; &lt;/a&gt; 와 동일 ). 돌아온 후 파일 포인터 &lt;em&gt;fp&lt;/em&gt; 는 HTTP 본문을 읽을 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="9310ca486b065ef93bb150015e5c6c85fc6241cc" translate="yes" xml:space="preserve">
          <source>This function returns an object that describes the resources consumed by either the current process or its children, as specified by the &lt;em&gt;who&lt;/em&gt; parameter. The &lt;em&gt;who&lt;/em&gt; parameter should be specified using one of the &lt;code&gt;RUSAGE_*&lt;/code&gt; constants described below.</source>
          <target state="translated">이 함수는 &lt;em&gt;who&lt;/em&gt; 매개 변수에 지정된대로 현재 프로세스 또는 해당 하위 프로세스가 소비 한 자원을 설명하는 오브젝트를 리턴합니다 . &lt;em&gt;사람&lt;/em&gt; 파라미터들 중 하나를 사용하여 지정한다 &lt;code&gt;RUSAGE_*&lt;/code&gt; 상수에 대하여 설명한다.</target>
        </trans-unit>
        <trans-unit id="3389bceb4f4b217616df6b1450bc7411416e8c32" translate="yes" xml:space="preserve">
          <source>This function returns random bytes from an OS-specific randomness source. The returned data should be unpredictable enough for cryptographic applications, though its exact quality depends on the OS implementation.</source>
          <target state="translated">이 함수는 OS 별 임의 소스에서 임의 바이트를 반환합니다. 정확한 품질은 OS 구현에 따라 다르지만 반환 된 데이터는 암호화 응용 프로그램에 충분히 예측할 수 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1b5c9eb8a860c921596d08ec2b539e7ca036ef7" translate="yes" xml:space="preserve">
          <source>This function returns the C string starting at memory address &lt;em&gt;address&lt;/em&gt; as a bytes object. If size is specified, it is used as size, otherwise the string is assumed to be zero-terminated.</source>
          <target state="translated">이 함수는 메모리 주소 &lt;em&gt;주소&lt;/em&gt; 에서 시작하는 C 문자열을 바이트 객체로 반환합니다. size가 지정되면 size로 사용되며, 그렇지 않으면 문자열이 0으로 끝나는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0275e415bdf66c562ae0a9793115bf8d4692dd28" translate="yes" xml:space="preserve">
          <source>This function returns the wide character string starting at memory address &lt;em&gt;address&lt;/em&gt; as a string. If &lt;em&gt;size&lt;/em&gt; is specified, it is used as the number of characters of the string, otherwise the string is assumed to be zero-terminated.</source>
          <target state="translated">이 함수는 메모리 주소에서 시작하는 넓은 문자열을 반환합니다 &lt;em&gt; 주소&lt;/em&gt; 합니다. 경우 &lt;em&gt;크기가&lt;/em&gt; 지정되어, 그렇지 않으면 문자열이 제로 종료로 가정, 문자열의 문자 수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26b6d13d8eeee602e191f75458ddf599459f7ad" translate="yes" xml:space="preserve">
          <source>This function runs the passed coroutine, taking care of managing the asyncio event loop and &lt;em&gt;finalizing asynchronous generators&lt;/em&gt;.</source>
          <target state="translated">이 함수는 전달 된 코 루틴을 실행하여 asyncio 이벤트 루프를 관리하고 &lt;em&gt;비동기 생성기를 마무리&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4771703fc1ce559310da22e7cd6065d893c64e7e" translate="yes" xml:space="preserve">
          <source>This function securely creates a temporary directory using the same rules as &lt;a href=&quot;#tempfile.mkdtemp&quot;&gt;&lt;code&gt;mkdtemp()&lt;/code&gt;&lt;/a&gt;. The resulting object can be used as a context manager (see &lt;a href=&quot;#tempfile-examples&quot;&gt;Examples&lt;/a&gt;). On completion of the context or destruction of the temporary directory object the newly created temporary directory and all its contents are removed from the filesystem.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#tempfile.mkdtemp&quot;&gt; &lt;code&gt;mkdtemp()&lt;/code&gt; &lt;/a&gt; 와 동일한 규칙을 사용하여 임시 디렉토리를 안전하게 만듭니다. . 결과 객체는 컨텍스트 관리자로 사용할 수 있습니다 ( &lt;a href=&quot;#tempfile-examples&quot;&gt;예&lt;/a&gt; 참조 ). 임시 디렉토리 오브젝트의 컨텍스트 또는 파괴가 완료되면 새로 작성된 임시 디렉토리 및 모든 컨텐츠가 파일 시스템에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a3d02be868af88937c3058959c00f7f17a0f84b0" translate="yes" xml:space="preserve">
          <source>This function should be called from the main thread before other threads are started. In versions of Python prior to 2.7.1 and 3.2, if this function is called from multiple threads, it is possible (in rare circumstances) that a handler will be added to the root logger more than once, leading to unexpected results such as messages being duplicated in the log.</source>
          <target state="translated">다른 스레드가 시작되기 전에 기본 스레드에서이 함수를 호출해야합니다. 2.7.1 및 3.2 이전의 Python 버전에서이 함수가 여러 스레드에서 호출되는 경우 (드문 경우) 핸들러가 루트 로거에 두 번 이상 추가되어 메시지와 같은 예기치 않은 결과가 발생할 수 있습니다. 로그에 복제되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d20e60dd1d63a521945c30323e6b6bf138f6832" translate="yes" xml:space="preserve">
          <source>This function should be used for internal and specialized purposes only.</source>
          <target state="translated">이 기능은 내부 및 특수 목적으로 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="749a08b5be8d75cfdf7f3f1e09a35adb78c01024" translate="yes" xml:space="preserve">
          <source>This function supports dynamic execution of Python code. &lt;em&gt;object&lt;/em&gt; must be either a string or a code object. If it is a string, the string is parsed as a suite of Python statements which is then executed (unless a syntax error occurs). &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; If it is a code object, it is simply executed. In all cases, the code that&amp;rsquo;s executed is expected to be valid as file input (see the section &amp;ldquo;File input&amp;rdquo; in the Reference Manual). Be aware that the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; statements may not be used outside of function definitions even within the context of code passed to the &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; function. The return value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 함수는 Python 코드의 동적 실행을 지원합니다. &lt;em&gt;object&lt;/em&gt; 는 문자열 또는 코드 &lt;em&gt;개체&lt;/em&gt; 여야합니다. 문자열 인 경우 문자열은 Python 문으로 구문 분석되어 구문 오류가 발생하지 않는 한 실행됩니다. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 코드 객체 인 경우 간단히 실행됩니다. 모든 경우에 실행되는 코드는 파일 입력으로 유효합니다 (참조 매뉴얼의 &quot;파일 입력&quot;섹션 참조). 주의하십시오 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; 문은 함수 정의의 사용 외부에도 전달 코드의 컨텍스트 내에서하지 않을 수 있습니다 &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 함수입니다. 반환 값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="086ca74667d6bc1899c60ca7f2435203fff0e70a" translate="yes" xml:space="preserve">
          <source>This function takes a single argument that can be passed to the &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; function, and an optional file name. In all cases this routine executes:</source>
          <target state="translated">이 함수는 &lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 전달할 수있는 단일 인수를 사용합니다. 함수에 와 선택적 파일 이름을 사용합니다. 모든 경우에이 루틴은 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a8b457aa45063f9aaf0a8c9f77a5b594016e5868" translate="yes" xml:space="preserve">
          <source>This function takes an XML data string (&lt;em&gt;xml_data&lt;/em&gt;) or a file path or file-like object (&lt;em&gt;from_file&lt;/em&gt;) as input, converts it to the canonical form, and writes it out using the &lt;em&gt;out&lt;/em&gt; file(-like) object, if provided, or returns it as a text string if not. The output file receives text, not bytes. It should therefore be opened in text mode with &lt;code&gt;utf-8&lt;/code&gt; encoding.</source>
          <target state="translated">이 함수는 XML 데이터 문자열 ( &lt;em&gt;xml_data&lt;/em&gt; ) 또는 파일 경로 또는 파일과 유사한 객체 ( &lt;em&gt;from_file&lt;/em&gt; )를 입력으로 가져 와서 정식 형식으로 변환하고 제공된 경우 &lt;em&gt;출력&lt;/em&gt; 파일과 같은 객체를 사용하여 작성합니다. 그렇지 않으면 텍스트 문자열로 반환합니다. 출력 파일은 바이트가 아닌 텍스트를받습니다. 따라서 &lt;code&gt;utf-8&lt;/code&gt; 인코딩으로 텍스트 모드에서 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="00c9ccc2e6efc7cdd2787a047411daf9d2586338" translate="yes" xml:space="preserve">
          <source>This function takes an input source and an optional base URL and returns a fully resolved &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; object ready for reading. The input source can be given as a string, a file-like object, or an &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; object; parsers will use this function to implement the polymorphic &lt;em&gt;source&lt;/em&gt; argument to their &lt;code&gt;parse()&lt;/code&gt; method.</source>
          <target state="translated">이 함수는 입력 소스와 선택적 기본 URL을 가져 와서 해석 할 수있는 완전히 해결 된 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 입력 소스는 문자열, 파일과 같은 객체 또는 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt; 객체 로 제공 될 수 있습니다 . 파서는이 함수를 사용 하여 &lt;code&gt;parse()&lt;/code&gt; 메소드에 다형성 &lt;em&gt;소스&lt;/em&gt; 인수를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ed291263129461634749d085a422476c646a04fe" translate="yes" xml:space="preserve">
          <source>This function takes one of those sequence of pairs and returns a &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; instance. Optional &lt;em&gt;maxlinelen&lt;/em&gt;, &lt;em&gt;header_name&lt;/em&gt;, and &lt;em&gt;continuation_ws&lt;/em&gt; are as in the &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 함수는 이러한 일련의 쌍 중 하나를 사용하여 &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다. 선택적 &lt;em&gt;maxlinelen&lt;/em&gt; , &lt;em&gt;header_name&lt;/em&gt; 및 &lt;em&gt;continuation_ws&lt;/em&gt; 는 &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 생성자와 같습니다.</target>
        </trans-unit>
        <trans-unit id="aaefda6e8f08981b1040b46ed1a5b3313e13419a" translate="yes" xml:space="preserve">
          <source>This function transforms a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; function into a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine-function&quot;&gt;coroutine function&lt;/a&gt; which returns a generator-based coroutine. The generator-based coroutine is still a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator-iterator&quot;&gt;generator iterator&lt;/a&gt;, but is also considered to be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; object and is &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-awaitable&quot;&gt;awaitable&lt;/a&gt;. However, it may not necessarily implement the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt;&lt;code&gt;__await__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; 함수를 생성기 기반 코 루틴을 반환하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine-function&quot;&gt;코 루틴&lt;/a&gt; 함수로 변환합니다 . 제너레이터 기반 코 루틴은 여전히 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator-iterator&quot;&gt;제너레이터 이터레이터&lt;/a&gt; 이지만 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 객체로 간주되며 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-awaitable&quot;&gt;기다릴 수&lt;/a&gt; 있습니다. 그러나 반드시 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt; &lt;code&gt;__await__()&lt;/code&gt; &lt;/a&gt; 구현할 필요는 없습니다. 메서드를 .</target>
        </trans-unit>
        <trans-unit id="dec68208c32ce4bef49692aaae7babc6b72520b3" translate="yes" xml:space="preserve">
          <source>This function uses a cache for past comparisons and the results, with cache entries invalidated if the &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; information for the file changes. The entire cache may be cleared using &lt;a href=&quot;#filecmp.clear_cache&quot;&gt;&lt;code&gt;clear_cache()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 파일 의 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 정보가 변경 되면 캐시 항목이 무효화 된 상태에서 과거 비교 및 ​​결과에 캐시를 사용합니다 . &lt;a href=&quot;#filecmp.clear_cache&quot;&gt; &lt;code&gt;clear_cache()&lt;/code&gt; &lt;/a&gt; 사용하여 전체 캐시를 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67621df8c29ab36ef48a10c6d3a54a11a295362f" translate="yes" xml:space="preserve">
          <source>This function uses a user-configurable function to convert the creation time to a tuple. By default, &lt;a href=&quot;time#time.localtime&quot;&gt;&lt;code&gt;time.localtime()&lt;/code&gt;&lt;/a&gt; is used; to change this for a particular formatter instance, set the &lt;code&gt;converter&lt;/code&gt; attribute to a function with the same signature as &lt;a href=&quot;time#time.localtime&quot;&gt;&lt;code&gt;time.localtime()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;time#time.gmtime&quot;&gt;&lt;code&gt;time.gmtime()&lt;/code&gt;&lt;/a&gt;. To change it for all formatters, for example if you want all logging times to be shown in GMT, set the &lt;code&gt;converter&lt;/code&gt; attribute in the &lt;code&gt;Formatter&lt;/code&gt; class.</source>
          <target state="translated">이 기능은 사용자가 구성 할 수있는 기능을 사용하여 생성 시간을 튜플로 변환합니다. 기본적으로 &lt;a href=&quot;time#time.localtime&quot;&gt; &lt;code&gt;time.localtime()&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 특정 포맷터 인스턴스에 대해이를 변경하려면 &lt;code&gt;converter&lt;/code&gt; 속성을 &lt;a href=&quot;time#time.localtime&quot;&gt; &lt;code&gt;time.localtime()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;time#time.gmtime&quot;&gt; &lt;code&gt;time.gmtime()&lt;/code&gt; &lt;/a&gt; 과 동일한 서명을 가진 함수 로 설정하십시오 . 모든 로깅 시간은 GMT에 표시하려는 경우 예를 들어, 모든 포매터를 위해 그것을 변경하려면 설정 &lt;code&gt;converter&lt;/code&gt; 의 속성 &lt;code&gt;Formatter&lt;/code&gt; 클래스 .</target>
        </trans-unit>
        <trans-unit id="c7d4a1b7043855edd960d108a4b03c2c7f26f78e" translate="yes" xml:space="preserve">
          <source>This function uses the same search technique as &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 와 동일한 검색 기술을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dcc0f796b37da4661e9e567b1d70beab1a789887" translate="yes" xml:space="preserve">
          <source>This function was inadvertently marked as deprecated in Python 3.5.</source>
          <target state="translated">이 함수는 실수로 Python 3.5에서 더 이상 사용되지 않는 것으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="fde76138b876f19a331c04c16e7173bc40335dae" translate="yes" xml:space="preserve">
          <source>This function will raise &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; if the named module cannot be imported.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다명명 된 모듈을 가져올 수없는 경우이 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="695e7aa3774a50e5d41215db0f861e34960b2541" translate="yes" xml:space="preserve">
          <source>This function will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if an invalid &lt;em&gt;who&lt;/em&gt; parameter is specified. It may also raise &lt;a href=&quot;#resource.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; exception in unusual circumstances.</source>
          <target state="translated">유효하지 않은 &lt;em&gt;who&lt;/em&gt; 매개 변수가 지정된 경우이 함수는 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다. &lt;a href=&quot;#resource.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 수도 있습니다&lt;em&gt;&lt;/em&gt;비정상적인 상황에서 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f82931ab2a0fc2142776ea98ebb1c0e233a5e9" translate="yes" xml:space="preserve">
          <source>This function will raise the first exception raised by any hook. In general, these errors should not be handled and should terminate the process as quickly as possible.</source>
          <target state="translated">이 함수는 모든 후크에서 발생한 첫 번째 예외를 발생시킵니다. 일반적으로 이러한 오류는 처리하지 않아야하며 가능한 빨리 프로세스를 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2f4a44ea4f4781c9ded6135bf54221ca4868d84" translate="yes" xml:space="preserve">
          <source>This function works best with Mark Hammond&amp;rsquo;s &lt;code&gt;win32all&lt;/code&gt; package installed, but also on Python 2.3 and later (support for this was added in Python 2.6). It obviously only runs on Win32 compatible platforms.</source>
          <target state="translated">이 함수는 Mark Hammond의 &lt;code&gt;win32all&lt;/code&gt; 패키지가 설치되어 있지만 Python 2.3 이상에서 가장 잘 작동합니다 (Python 2.6 에서 지원됨 ). 분명히 Win32 호환 플랫폼에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cdfe78946dbc3eb876b9e7ddc8990bd5dab0055a" translate="yes" xml:space="preserve">
          <source>This function works for ranges spanning a century change.</source>
          <target state="translated">이 기능은 세기 변화에 걸친 범위에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6d4a6aeb5830677c42af3b67d316903d7b69a1cf" translate="yes" xml:space="preserve">
          <source>This function works like &lt;a href=&quot;#module-getopt&quot;&gt;&lt;code&gt;getopt()&lt;/code&gt;&lt;/a&gt;, except that GNU style scanning mode is used by default. This means that option and non-option arguments may be intermixed. The &lt;a href=&quot;#module-getopt&quot;&gt;&lt;code&gt;getopt()&lt;/code&gt;&lt;/a&gt; function stops processing options as soon as a non-option argument is encountered.</source>
          <target state="translated">이 함수는 GNU 스타일 스캐닝 모드가 기본적으로 사용된다는 점을 제외하고 &lt;a href=&quot;#module-getopt&quot;&gt; &lt;code&gt;getopt()&lt;/code&gt; &lt;/a&gt; 와 같이 작동합니다 . 이것은 옵션 인수와 비 옵션 인수가 혼합 될 수 있음을 의미합니다. &lt;a href=&quot;#module-getopt&quot;&gt; &lt;code&gt;getopt()&lt;/code&gt; &lt;/a&gt; 함수는 즉시 비 - 옵션 인수가 발생 될 때 옵션을 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="c53c65a872781ee36da0b6344b195ca8579a2152" translate="yes" xml:space="preserve">
          <source>This function wraps the Win32 &lt;code&gt;GetVersionEx()&lt;/code&gt; function; see the Microsoft documentation on &lt;code&gt;OSVERSIONINFOEX()&lt;/code&gt; for more information about these fields.</source>
          <target state="translated">이 함수는 Win32 &lt;code&gt;GetVersionEx()&lt;/code&gt; 함수를 래핑합니다 . 이러한 필드에 대한 자세한 내용은 &lt;code&gt;OSVERSIONINFOEX()&lt;/code&gt; 대한 Microsoft 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fa1f0ee315ee71ef09519d3983d61008b818bf1" translate="yes" xml:space="preserve">
          <source>This functionality can be used to inject your own values into a &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; at creation time. You can use the following pattern:</source>
          <target state="translated">이 기능은 생성시 고유 한 값을 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 에 주입하는 데 사용할 수 있습니다 . 다음 패턴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0ca610375353cdc0d5c751741d7a392b2aded01" translate="yes" xml:space="preserve">
          <source>This functionality is provisional and may deviate from the usual version semantics of the standard library.</source>
          <target state="translated">이 기능은 잠정적이며 표준 라이브러리의 일반적인 버전 의미에서 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f325c661123592c2ffbf04844b8b46e0e85687b6" translate="yes" xml:space="preserve">
          <source>This generator function uses the &lt;code&gt;co_firstlineno&lt;/code&gt; and &lt;code&gt;co_lnotab&lt;/code&gt; attributes of the code object &lt;em&gt;code&lt;/em&gt; to find the offsets which are starts of lines in the source code. They are generated as &lt;code&gt;(offset, lineno)&lt;/code&gt; pairs. See &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Objects/lnotab_notes.txt&quot;&gt;Objects/lnotab_notes.txt&lt;/a&gt; for the &lt;code&gt;co_lnotab&lt;/code&gt; format and how to decode it.</source>
          <target state="translated">이 생성기 함수는 코드 객체 &lt;em&gt;코드&lt;/em&gt; 의 &lt;code&gt;co_firstlineno&lt;/code&gt; 및 &lt;code&gt;co_lnotab&lt;/code&gt; 속성을 사용 하여 소스 코드에서 행의 시작 인 오프셋을 찾습니다. 그것들은 &lt;code&gt;(offset, lineno)&lt;/code&gt; 쌍 으로 생성됩니다 . &lt;code&gt;co_lnotab&lt;/code&gt; 형식 및 디코딩 방법 은 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Objects/lnotab_notes.txt&quot;&gt;Objects / lnotab_notes.txt&lt;/a&gt; 를 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31e7ec1a6118bb6f4c7d19cb31c4eb16dbcf0646" translate="yes" xml:space="preserve">
          <source>This gives the same ordering as a series of &lt;a href=&quot;stdtypes#dict.update&quot;&gt;&lt;code&gt;dict.update()&lt;/code&gt;&lt;/a&gt; calls starting with the last mapping:</source>
          <target state="translated">이것은 마지막 매핑으로 시작 하는 일련의 &lt;a href=&quot;stdtypes#dict.update&quot;&gt; &lt;code&gt;dict.update()&lt;/code&gt; &lt;/a&gt; 호출과 동일한 순서를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="358cfff4da4236e735a011c08d723d2e34737515" translate="yes" xml:space="preserve">
          <source>This handler is not appropriate for use under Windows, because under Windows open log files cannot be moved or renamed - logging opens the files with exclusive locks - and so there is no need for such a handler. Furthermore, &lt;em&gt;ST_INO&lt;/em&gt; is not supported under Windows; &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt; always returns zero for this value.</source>
          <target state="translated">이 핸들러는 Windows에서 로그 파일을 이동하거나 이름을 바꿀 수 없기 때문에 Windows에서 사용하기에 적합하지 않습니다. 로깅은 독점 잠금으로 파일을 열므로 이러한 핸들러가 필요하지 않습니다. 또한 &lt;em&gt;ST_INO&lt;/em&gt; 는 Windows에서 지원되지 않습니다. &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 는이 값에 대해 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2e794ef0fce7d4a030d7833706ed98762c476d0" translate="yes" xml:space="preserve">
          <source>This has a different meaning for each node type; see the DOM specification for details. The situation is similar to that with &lt;a href=&quot;#xml.dom.Node.nodeName&quot;&gt;&lt;code&gt;nodeName&lt;/code&gt;&lt;/a&gt;. The value is a string or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이는 각 노드 유형마다 다른 의미를 갖습니다. 자세한 내용은 DOM 사양을 참조하십시오. 상황은 &lt;a href=&quot;#xml.dom.Node.nodeName&quot;&gt; &lt;code&gt;nodeName&lt;/code&gt; &lt;/a&gt; 과 유사합니다 . 값은 문자열 또는 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7cbbcfa82c4924ad5e9ced671d2f1dd378b2b19" translate="yes" xml:space="preserve">
          <source>This has a different meaning for each node type; see the DOM specification for details. You can always get the information you would get here from another property such as the &lt;code&gt;tagName&lt;/code&gt; property for elements or the &lt;code&gt;name&lt;/code&gt; property for attributes. For all node types, the value of this attribute will be either a string or &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">이는 각 노드 유형마다 다른 의미를 갖습니다. 자세한 내용은 DOM 사양을 참조하십시오. 요소 의 &lt;code&gt;tagName&lt;/code&gt; 속성 또는 속성 의 &lt;code&gt;name&lt;/code&gt; 속성 과 같은 다른 속성에서 항상 여기에있는 정보를 얻을 수 있습니다 . 모든 노드 유형에서이 속성의 값은 문자열 또는 &lt;code&gt;None&lt;/code&gt; 입니다. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="d49f6a32c691ba4c1b6204e2157adf71d435017f" translate="yes" xml:space="preserve">
          <source>This has implications both for recursive objects and object sharing. Recursive objects are objects that contain references to themselves. These are not handled by marshal, and in fact, attempting to marshal recursive objects will crash your Python interpreter. Object sharing happens when there are multiple references to the same object in different places in the object hierarchy being serialized. &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; stores such objects only once, and ensures that all other references point to the master copy. Shared objects remain shared, which can be very important for mutable objects.</source>
          <target state="translated">이것은 재귀 객체와 객체 공유 모두에 영향을 미칩니다. 재귀 객체는 자신에 대한 참조를 포함하는 객체입니다. 이것은 마샬링에 의해 처리되지 않으며 실제로 재귀 객체를 마샬링하려고하면 Python 인터프리터가 충돌합니다. 객체 공유는 직렬화되는 객체 계층의 다른 위치에 동일한 객체에 대한 여러 참조가있을 때 발생합니다. &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 은 이러한 오브젝트를 한 번만 저장하고 다른 모든 참조가 마스터 사본을 가리 키도록합니다. 공유 객체는 공유 상태를 유지하므로 변경 가능한 객체에 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1399ebc54c4c88eebed882277416783d2785e8e3" translate="yes" xml:space="preserve">
          <source>This has the direct benefit of using the new widgets which gives a better look and feel across platforms; however, the replacement widgets are not completely compatible. The main difference is that widget options such as &amp;ldquo;fg&amp;rdquo;, &amp;ldquo;bg&amp;rdquo; and others related to widget styling are no longer present in Ttk widgets. Instead, use the &lt;code&gt;ttk.Style&lt;/code&gt; class for improved styling effects.</source>
          <target state="translated">이는 새로운 위젯을 사용하는 직접적인 이점을 제공하여 여러 플랫폼에서 더 나은 모양과 느낌을 제공합니다. 그러나 교체 위젯은 완전히 호환되지 않습니다. 주요 차이점은 &quot;fg&quot;, &quot;bg&quot;와 같은 위젯 옵션 및 위젯 스타일과 관련된 기타 옵션이 더 이상 Ttk 위젯에 존재하지 않는다는 것입니다. 대신 스타일링 효과를 개선 하려면 &lt;code&gt;ttk.Style&lt;/code&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e87d7da41d7ad71206613b0e5e393ce4a5a42bd" translate="yes" xml:space="preserve">
          <source>This has the same issue as the original example using class &lt;code&gt;C&lt;/code&gt;. That is, two instances of class &lt;code&gt;D&lt;/code&gt; that do not specify a value for &lt;code&gt;x&lt;/code&gt; when creating a class instance will share the same copy of &lt;code&gt;x&lt;/code&gt;. Because dataclasses just use normal Python class creation they also share this behavior. There is no general way for Data Classes to detect this condition. Instead, dataclasses will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if it detects a default parameter of type &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, or &lt;code&gt;set&lt;/code&gt;. This is a partial solution, but it does protect against many common errors.</source>
          <target state="translated">이것은 클래스 &lt;code&gt;C&lt;/code&gt; 사용하는 원래 예제와 동일한 문제가 있습니다. 즉, 클래스 인스턴스를 만들 때 &lt;code&gt;x&lt;/code&gt; 값을 지정하지 않은 클래스 &lt;code&gt;D&lt;/code&gt; 의 두 인스턴스 는 동일한 &lt;code&gt;x&lt;/code&gt; 복사본을 공유합니다 . 데이터 클래스는 일반적인 Python 클래스 생성을 사용하기 때문에이 동작도 공유합니다. 데이터 클래스가이 조건을 감지하는 일반적인 방법은 없습니다. 대신, 데이터 클래스는 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;dict&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 유형의 기본 매개 변수를 감지하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다. 이것은 부분적인 해결책이지만 많은 일반적인 오류로부터 보호합니다.</target>
        </trans-unit>
        <trans-unit id="15fd1d9b07f7514f7cf5eb3c49b420f63b3b5f83" translate="yes" xml:space="preserve">
          <source>This header type provides no additional attributes.</source>
          <target state="translated">이 헤더 유형은 추가 속성을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8a8c30ab87345447e975d80dc8bc170b1bc77f0" translate="yes" xml:space="preserve">
          <source>This header type provides the following additional attributes:</source>
          <target state="translated">이 헤더 유형은 다음과 같은 추가 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9f71ac2855dc5cb60a48f538bcab9c6cdf2af6c3" translate="yes" xml:space="preserve">
          <source>This helper function returns a dictionary of scheme to proxy server URL mappings. It scans the environment for variables named &lt;code&gt;&amp;lt;scheme&amp;gt;_proxy&lt;/code&gt;, in a case insensitive approach, for all operating systems first, and when it cannot find it, looks for proxy information from Mac OSX System Configuration for Mac OS X and Windows Systems Registry for Windows. If both lowercase and uppercase environment variables exist (and disagree), lowercase is preferred.</source>
          <target state="translated">이 헬퍼 함수는 스키마 사전을 프록시 서버 URL 맵핑으로 리턴합니다. 모든 운영 체제에 대해 대소 문자를 구분하지 않는 접근 &lt;code&gt;&amp;lt;scheme&amp;gt;_proxy&lt;/code&gt; 라는 변수를 환경에서 스캔하고 찾을 수없는 경우 Mac OS X 용 Mac OSX 시스템 구성 및 Windows 용 Windows 시스템 레지스트리에서 프록시 정보를 찾습니다. . 소문자 및 대문자 환경 변수가 모두 존재하고 동의하지 않는 경우 소문자가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="53a5ee201fe7aa42751eeb86e24842797e265154" translate="yes" xml:space="preserve">
          <source>This hook function is called by built-in &lt;a href=&quot;functions#breakpoint&quot;&gt;&lt;code&gt;breakpoint()&lt;/code&gt;&lt;/a&gt;. By default, it drops you into the &lt;a href=&quot;pdb#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; debugger, but it can be set to any other function so that you can choose which debugger gets used.</source>
          <target state="translated">이 후크 함수는 내장 &lt;a href=&quot;functions#breakpoint&quot;&gt; &lt;code&gt;breakpoint()&lt;/code&gt; &lt;/a&gt; 에 의해 호출됩니다 . 기본적으로 &lt;a href=&quot;pdb#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 디버거로 이동하지만 다른 함수로 설정하여 사용할 디버거를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b43c40f486c2ec49629b4760fedb3dc28cd7fac" translate="yes" xml:space="preserve">
          <source>This hook is exposed so that you can use it to implement directory search paths, addition of file extensions, and other namespace hacks. There is no corresponding &amp;lsquo;close&amp;rsquo; hook, but a shlex instance will call the &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method of the sourced input stream when it returns EOF.</source>
          <target state="translated">이 후크는 노출되어 디렉토리 검색 경로, 파일 확장자 추가 및 기타 네임 스페이스 해킹을 구현하는 데 사용할 수 있습니다. 해당 '닫기'후크는 없지만 소스 인스턴스 는 EOF를 반환 할 때 소스 입력 스트림 의 &lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="14a8a4310f49249faa0c97df760d4f86f9f20bfd" translate="yes" xml:space="preserve">
          <source>This idiom would be unsafe:</source>
          <target state="translated">이 관용구는 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3712ae89c928266d43f7b324f245cd2bd71916f9" translate="yes" xml:space="preserve">
          <source>This implementation just returns the passed-in record. You may want to override this method if you need to do any custom marshalling or manipulation of the record before passing it to the handlers.</source>
          <target state="translated">이 구현은 전달 된 레코드를 반환합니다. 레코드를 핸들러로 전달하기 전에 레코드를 사용자 정의 마샬링 또는 조작해야하는 경우이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="777834ae53352a725347928a6858bafea05f6ec0" translate="yes" xml:space="preserve">
          <source>This implementation reaps every terminated processes by calling &lt;code&gt;os.waitpid(-1)&lt;/code&gt; directly, possibly breaking other code spawning processes and waiting for their termination.</source>
          <target state="translated">이 구현은 &lt;code&gt;os.waitpid(-1)&lt;/code&gt; 직접 호출 하여 다른 코드 생성 프로세스를 중단하고 종료를 기다리는 방식으로 종료 된 모든 프로세스를 거칩니다 .</target>
        </trans-unit>
        <trans-unit id="e66f626d3049620372cb155540f6631b45554cd8" translate="yes" xml:space="preserve">
          <source>This implementation registers a &lt;code&gt;SIGCHLD&lt;/code&gt; signal handler on instantiation. That can break third-party code that installs a custom handler for &lt;code&gt;SIGCHLD&lt;/code&gt;. signal).</source>
          <target state="translated">이 구현 은 인스턴스화시 &lt;code&gt;SIGCHLD&lt;/code&gt; 신호 핸들러를 등록합니다 . &lt;code&gt;SIGCHLD&lt;/code&gt; 에 대한 사용자 지정 처리기를 설치하는 타사 코드를 손상시킬 수 있습니다 . 신호).</target>
        </trans-unit>
        <trans-unit id="edd393e2fc27d7014d2911d6a54565f5099ffca5" translate="yes" xml:space="preserve">
          <source>This implementation starts a new waiting thread for every subprocess spawn.</source>
          <target state="translated">이 구현은 모든 서브 프로세스 스폰에 대해 새로운 대기 스레드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ef609bd0f65de7996847176aad6c4872816f0096" translate="yes" xml:space="preserve">
          <source>This implementation uses active event loop from the main thread to handle &lt;code&gt;SIGCHLD&lt;/code&gt; signal. If the main thread has no running event loop another thread cannot spawn a subprocess (&lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised).</source>
          <target state="translated">이 구현은 메인 스레드의 활성 이벤트 루프를 사용하여 &lt;code&gt;SIGCHLD&lt;/code&gt; 신호 를 처리 합니다. 메인 스레드에 실행중인 이벤트 루프가 없으면 다른 스레드가 하위 프로세스를 생성 할 수 없습니다 ( &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 발생).</target>
        </trans-unit>
        <trans-unit id="b9fd2d3b23621ed74495b3c520170639252c1cb8" translate="yes" xml:space="preserve">
          <source>This installs the function &lt;code&gt;_()&lt;/code&gt; in Python&amp;rsquo;s builtins namespace, based on &lt;em&gt;domain&lt;/em&gt;, &lt;em&gt;localedir&lt;/em&gt;, and &lt;em&gt;codeset&lt;/em&gt; which are passed to the function &lt;a href=&quot;#gettext.translation&quot;&gt;&lt;code&gt;translation()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수 는 &lt;em&gt;domain&lt;/em&gt; , &lt;em&gt;localedir&lt;/em&gt; 및 함수 &lt;a href=&quot;#gettext.translation&quot;&gt; &lt;code&gt;translation()&lt;/code&gt; &lt;/a&gt; 전달 된 &lt;em&gt;코드 세트&lt;/em&gt; 를 기반으로 Python의 내장 네임 스페이스에 &lt;code&gt;_()&lt;/code&gt; 함수를 설치합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c2e2c274c1f4f231ffb4b3c188adf438144d914" translate="yes" xml:space="preserve">
          <source>This interface is a subtype of the &lt;code&gt;Attributes&lt;/code&gt; interface (see section &lt;a href=&quot;#attributes-objects&quot;&gt;The Attributes Interface&lt;/a&gt;). All methods supported by that interface are also available on &lt;code&gt;AttributesNS&lt;/code&gt; objects.</source>
          <target state="translated">이 인터페이스는 &lt;code&gt;Attributes&lt;/code&gt; 인터페이스 의 하위 유형입니다 (섹션 &lt;a href=&quot;#attributes-objects&quot;&gt;속성 인터페이스&lt;/a&gt; 참조 ). 해당 인터페이스에서 지원하는 모든 메소드는 &lt;code&gt;AttributesNS&lt;/code&gt; 객체 에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69e1f3c707f5dccfcafc540b279aa49c7ac7c0b2" translate="yes" xml:space="preserve">
          <source>This interface specifies only those DTD events required for basic parsing (unparsed entities and attributes).</source>
          <target state="translated">이 인터페이스는 기본 구문 분석에 필요한 DTD 이벤트 (구문 분석되지 않은 엔티티 및 속성) 만 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4bfef769a5c6fd1c3d4f6d5ae1a3d088e11a2056" translate="yes" xml:space="preserve">
          <source>This invocation will install &lt;code&gt;pip&lt;/code&gt; if it is not already installed, but otherwise does nothing. To ensure the installed version of &lt;code&gt;pip&lt;/code&gt; is at least as recent as the one bundled with &lt;code&gt;ensurepip&lt;/code&gt;, pass the &lt;code&gt;--upgrade&lt;/code&gt; option:</source>
          <target state="translated">이 호출은 &lt;code&gt;pip&lt;/code&gt; 가 아직 설치되지 않은 경우 pip 를 설치 하지만 그렇지 않으면 아무것도 수행하지 않습니다. &lt;code&gt;pip&lt;/code&gt; 의 설치된 버전이 &lt;code&gt;ensurepip&lt;/code&gt; 와 함께 제공된 버전 보다 최신 버전인지 확인하려면 &lt;code&gt;--upgrade&lt;/code&gt; 옵션을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb20184489faa55d2426651ba4b6f1ea8d80ec92" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;NamedNodeMap&lt;/code&gt; giving the definitions of external entities. For entity names defined more than once, only the first definition is provided (others are ignored as required by the XML recommendation). This may be &lt;code&gt;None&lt;/code&gt; if the information is not provided by the parser, or if no entities are defined.</source>
          <target state="translated">이것은 &lt;code&gt;NamedNodeMap&lt;/code&gt; 입니다외부 엔티티의 정의를 제공 입니다. 엔티티 이름이 두 번 이상 정의 된 경우 첫 번째 정의 만 제공됩니다 (XML 권장 사항에 따라 다른 정의는 무시 됨). 파서가 정보를 제공하지 않거나 정의 된 엔터티가없는 경우 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ccd5839ee601e99f6f394c59c1c5d21a1f62f7d" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;NamedNodeMap&lt;/code&gt; giving the definitions of notations. For notation names defined more than once, only the first definition is provided (others are ignored as required by the XML recommendation). This may be &lt;code&gt;None&lt;/code&gt; if the information is not provided by the parser, or if no notations are defined.</source>
          <target state="translated">이것은 표기법의 정의를 제공 하는 &lt;code&gt;NamedNodeMap&lt;/code&gt; 입니다. 표기법 이름이 두 번 이상 정의 된 경우 첫 번째 정의 만 제공됩니다 (XML 권장 사항에 따라 다른 정의는 무시 됨). 이것은 아마도 &lt;code&gt;None&lt;/code&gt; 파서가 정보를 제공하지 않거나 표기법이 정의되지 않은 경우 None .</target>
        </trans-unit>
        <trans-unit id="3b5208e374d58ef0d15cd53fa00dca754440a5fc" translate="yes" xml:space="preserve">
          <source>This is a Python type object that represents the socket object type. It is the same as &lt;code&gt;type(socket(...))&lt;/code&gt;.</source>
          <target state="translated">소켓 객체 유형을 나타내는 Python 유형 객체입니다. &lt;code&gt;type(socket(...))&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1dee36bf4f5451b3dde8adb8abdefc1876d4de9e" translate="yes" xml:space="preserve">
          <source>This is a backwards compatibility wrapper around &lt;a href=&quot;importlib#importlib.util.find_spec&quot;&gt;&lt;code&gt;importlib.util.find_spec()&lt;/code&gt;&lt;/a&gt; that converts most failures to &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; and only returns the loader rather than the full &lt;code&gt;ModuleSpec&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;importlib#importlib.util.find_spec&quot;&gt; &lt;code&gt;importlib.util.find_spec()&lt;/code&gt; &lt;/a&gt; 주위의 역 호환성 래퍼 로 대부분의 오류를 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 로 변환 하고 전체 로더가 아닌 로더 만 반환합니다. &lt;code&gt;ModuleSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4853227db3f995082df7ac50dcf7aaaf84b7041" translate="yes" xml:space="preserve">
          <source>This is a class for comparing sequences of lines of text, and producing human-readable differences or deltas. Differ uses &lt;a href=&quot;#difflib.SequenceMatcher&quot;&gt;&lt;code&gt;SequenceMatcher&lt;/code&gt;&lt;/a&gt; both to compare sequences of lines, and to compare sequences of characters within similar (near-matching) lines.</source>
          <target state="translated">텍스트 줄의 순서를 비교하고 사람이 읽을 수있는 차이나 델타를 생성하는 클래스입니다. 다른 용도&lt;a href=&quot;#difflib.SequenceMatcher&quot;&gt; &lt;code&gt;SequenceMatcher&lt;/code&gt; 를&lt;/a&gt;하여 줄 시퀀스를 비교하고 비슷한 (가까운) 줄 내의 문자 시퀀스를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a8fa4665c3a9797ed6410afb94e30d45735e5a34" translate="yes" xml:space="preserve">
          <source>This is a compatibility alias for the builtin &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">이것은 내장의 호환성 별칭입니다 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 예외에.</target>
        </trans-unit>
        <trans-unit id="37837f0ec1ef400d3ebf35665f34cf4e36eefe80" translate="yes" xml:space="preserve">
          <source>This is a convenience function for invoking &lt;a href=&quot;#functools.update_wrapper&quot;&gt;&lt;code&gt;update_wrapper()&lt;/code&gt;&lt;/a&gt; as a function decorator when defining a wrapper function. It is equivalent to &lt;code&gt;partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)&lt;/code&gt;. For example:</source>
          <target state="translated">랩퍼 함수를 ​​정의 할 때 &lt;a href=&quot;#functools.update_wrapper&quot;&gt; &lt;code&gt;update_wrapper()&lt;/code&gt; &lt;/a&gt; 를 함수 데코레이터로 호출하기위한 편리한 함수입니다 . 그것은 &lt;code&gt;partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67ef0177e990584ce72a8564cff23e66f1dd9f9a" translate="yes" xml:space="preserve">
          <source>This is a convenience function that calls &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt; repeatedly so that the total time &amp;gt;= 0.2 second, returning the eventual (number of loops, time taken for that number of loops). It calls &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt; with increasing numbers from the sequence 1, 2, 5, 10, 20, 50, &amp;hellip; until the time taken is at least 0.2 second.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 반복적으로 호출 하여 총 시간&amp;gt; = 0.2 초가되도록하여 최종 횟수 (루프 수, 해당 루프 수에 걸린 시간)를 반환합니다. &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 호출 걸리는 시간은 0.2 초 이상이 될 때까지, ... 순서 1, 2, 5, 10, 20, 50 참조 증가한다.</target>
        </trans-unit>
        <trans-unit id="938872e7160a22a30969daf820e4a0b8ebd24e14" translate="yes" xml:space="preserve">
          <source>This is a convenience function that calls the &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt; repeatedly, returning a list of results. The first argument specifies how many times to call &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt;. The second argument specifies the &lt;em&gt;number&lt;/em&gt; argument for &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 반복적으로 호출하여 결과 목록을 반환 하는 편리한 함수입니다 . 첫 번째 인수는 &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 호출 횟수를 지정합니다 . 두 번째 인수 는 &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;숫자&lt;/em&gt; 인수를 지정합니다. .</target>
        </trans-unit>
        <trans-unit id="cf3d30edfa064a563ec303c042f7eac8623ee99e" translate="yes" xml:space="preserve">
          <source>This is a convenience method for calling &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;sendmail()&lt;/code&gt;&lt;/a&gt; with the message represented by an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; object. The arguments have the same meaning as for &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;sendmail()&lt;/code&gt;&lt;/a&gt;, except that &lt;em&gt;msg&lt;/em&gt; is a &lt;code&gt;Message&lt;/code&gt; object.</source>
          <target state="translated">&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; &lt;/a&gt; 객체로 표시되는 메시지로 &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;sendmail()&lt;/code&gt; &lt;/a&gt; 을 호출하는 편리한 방법입니다 . 인수는 &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;sendmail()&lt;/code&gt; &lt;/a&gt; 과 동일한 의미 를 &lt;em&gt;갖지만 msg&lt;/em&gt; 는 &lt;code&gt;Message&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt; 객체 .</target>
        </trans-unit>
        <trans-unit id="980d084f94f1a1f05dbcfb9a33957714c6c2fb1a" translate="yes" xml:space="preserve">
          <source>This is a convenience wrapper around many of the functions listed below, most notably &lt;a href=&quot;#dis.get_instructions&quot;&gt;&lt;code&gt;get_instructions()&lt;/code&gt;&lt;/a&gt;, as iterating over a &lt;a href=&quot;#dis.Bytecode&quot;&gt;&lt;code&gt;Bytecode&lt;/code&gt;&lt;/a&gt; instance yields the bytecode operations as &lt;a href=&quot;#dis.Instruction&quot;&gt;&lt;code&gt;Instruction&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">이것은 &lt;a href=&quot;#dis.Bytecode&quot;&gt; &lt;code&gt;Bytecode&lt;/code&gt; &lt;/a&gt; 인스턴스 를 반복 하여 바이트 코드 연산을 &lt;a href=&quot;#dis.Instruction&quot;&gt; &lt;code&gt;Instruction&lt;/code&gt; &lt;/a&gt; 인스턴스 로 생성하므로 아래에 나열된 많은 함수, 특히 &lt;a href=&quot;#dis.get_instructions&quot;&gt; &lt;code&gt;get_instructions()&lt;/code&gt; &lt;/a&gt; 주위의 편리한 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="498284187cd398ea132a44f93919c4008100e92c" translate="yes" xml:space="preserve">
          <source>This is a convenient shorthand for &lt;code&gt;print(code_info(x), file=file)&lt;/code&gt;, intended for interactive exploration at the interpreter prompt.</source>
          <target state="translated">인터프리터 프롬프트에서 대화식으로 탐색하기위한 &lt;code&gt;print(code_info(x), file=file)&lt;/code&gt; 단축형입니다 .</target>
        </trans-unit>
        <trans-unit id="8edf4f348b71a4a03b0b1fe5e2efdd8e50b78e09" translate="yes" xml:space="preserve">
          <source>This is a descriptor, used to define attributes that act differently when accessed through an instance and through a class. Instance access remains normal, but access to an attribute through a class will be routed to the class&amp;rsquo;s __getattr__ method; this is done by raising AttributeError.</source>
          <target state="translated">설명자이며 인스턴스와 클래스를 통해 액세스 할 때 다르게 작동하는 속성을 정의하는 데 사용됩니다. 인스턴스 액세스는 정상적으로 유지되지만 클래스를 통한 속성 액세스는 클래스의 __getattr__ 메소드로 라우팅됩니다. 이는 AttributeError를 발생시켜 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="af3bb3689f2aed5ed632d859ff4360df92b4652f" translate="yes" xml:space="preserve">
          <source>This is a dictionary that maps module names to modules which have already been loaded. This can be manipulated to force reloading of modules and other tricks. However, replacing the dictionary will not necessarily work as expected and deleting essential items from the dictionary may cause Python to fail.</source>
          <target state="translated">이것은 이미로드 된 모듈에 모듈 이름을 매핑하는 사전입니다. 모듈 및 기타 트릭을 강제로 다시로드하도록 조작 할 수 있습니다. 그러나 사전을 바꾸는 것이 예상대로 작동하지는 않으며 사전에서 필수 항목을 삭제하면 Python이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8e1dd0c6a91e83f3589db589be616dad107d0a" translate="yes" xml:space="preserve">
          <source>This is a factory method which allows subclasses to define the precise type of socket they want. The default implementation creates a TCP socket (&lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;socket.SOCK_STREAM&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이것은 서브 클래스가 원하는 정확한 소켓 유형을 정의 할 수있게하는 팩토리 메소드입니다. 기본 구현은 TCP 소켓 ( &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;socket.SOCK_STREAM&lt;/code&gt; &lt;/a&gt; )을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="b26ec592d29731c63ae2c68e17de8b091431aaea" translate="yes" xml:space="preserve">
          <source>This is a factory method which can be overridden in subclasses to create specialized &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">특수한 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 인스턴스 를 만들기 위해 서브 클래스에서 재정의 할 수있는 팩토리 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="5843574bbe9da7d6b6838eb28296d0456a38c5fb" translate="yes" xml:space="preserve">
          <source>This is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980&amp;rsquo;s by Ratcliff and Obershelp under the hyperbolic name &amp;ldquo;gestalt pattern matching.&amp;rdquo; The idea is to find the longest contiguous matching subsequence that contains no &amp;ldquo;junk&amp;rdquo; elements; these &amp;ldquo;junk&amp;rdquo; elements are ones that are uninteresting in some sense, such as blank lines or whitespace. (Handling junk is an extension to the Ratcliff and Obershelp algorithm.) The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that &amp;ldquo;look right&amp;rdquo; to people.</source>
          <target state="translated">시퀀스 요소가 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;해시&lt;/a&gt; 가능한 한 모든 유형의 시퀀스 쌍을 비교할 수있는 유연한 클래스입니다. . 기본 알고리즘은 1980 년대 후반 Ratcliff와 Obershelp가 하이퍼 볼릭 이름 인 &quot;gestalt pattern matching&quot;으로 발표 한 알고리즘보다 오래되었으며, 그보다 더 멋진 알고리즘입니다. 아이디어는 &quot;정크&quot;요소가 포함되지 않은 가장 긴 연속 일치 하위 시퀀스를 찾는 것입니다. 이러한 &quot;정크&quot;요소는 빈 줄이나 공백과 같이 어떤 의미에서는 흥미롭지 않은 요소입니다. 정크 처리는 Ratcliff 및 Obershelp 알고리즘의 확장입니다. 그런 다음 동일한 아이디어가 일치하는 하위 시퀀스의 왼쪽과 오른쪽에있는 시퀀스 조각에 재귀 적으로 적용됩니다. 이것은 최소한의 편집 시퀀스를 산출하지는 않지만 사람들에게&amp;ldquo;올바로 보이는&amp;rdquo;일치를 산출하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e62d716ed9ec49d64591a2d7f599e917d029d8" translate="yes" xml:space="preserve">
          <source>This is a flow control method that interacts with the underlying IO write buffer. When the size of the buffer reaches the high watermark, &lt;em&gt;drain()&lt;/em&gt; blocks until the size of the buffer is drained down to the low watermark and writing can be resumed. When there is nothing to wait for, the &lt;a href=&quot;#asyncio.StreamWriter.drain&quot;&gt;&lt;code&gt;drain()&lt;/code&gt;&lt;/a&gt; returns immediately.</source>
          <target state="translated">기본 IO 쓰기 버퍼와 상호 작용하는 흐름 제어 방법입니다. 버퍼의 크기가 높은 워터 마크에 도달하면, 버퍼 크기가 낮은 워터 마크로 배수되고 쓰기가 재개 될 때까지 &lt;em&gt;drain ()이&lt;/em&gt; 차단됩니다. 기다릴 것이 없으면 &lt;a href=&quot;#asyncio.StreamWriter.drain&quot;&gt; &lt;code&gt;drain()&lt;/code&gt; &lt;/a&gt; 이 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee578e8a96ae7b79e56215ce0608af10bb1a6d51" translate="yes" xml:space="preserve">
          <source>This is a generic method; for specific types, specialized methods are provided.</source>
          <target state="translated">이것은 일반적인 방법입니다. 특정 유형의 경우 특수한 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c70fb04836ec95e115ea761b0a42390505b21010" translate="yes" xml:space="preserve">
          <source>This is a good approach if you write the class yourself. Let&amp;rsquo;s suppose you have a class like this:</source>
          <target state="translated">수업을 직접 작성하는 경우 좋은 방법입니다. 다음과 같은 클래스가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="3fd22d2ebc9d1630fe3251b581127c5fa25ec2ef" translate="yes" xml:space="preserve">
          <source>This is a legacy API retained for backwards compatibility. When possible, you should use &lt;a href=&quot;#ssl.SSLContext.sni_callback&quot;&gt;&lt;code&gt;sni_callback&lt;/code&gt;&lt;/a&gt; instead. The given &lt;em&gt;server_name_callback&lt;/em&gt; is similar to &lt;em&gt;sni_callback&lt;/em&gt;, except that when the server hostname is an IDN-encoded internationalized domain name, the &lt;em&gt;server_name_callback&lt;/em&gt; receives a decoded U-label (&lt;code&gt;&quot;pyth&amp;ouml;n.org&quot;&lt;/code&gt;).</source>
          <target state="translated">이전 버전과의 호환성을 위해 유지되는 레거시 API입니다. 가능하면 &lt;a href=&quot;#ssl.SSLContext.sni_callback&quot;&gt; &lt;code&gt;sni_callback&lt;/code&gt; 을&lt;/a&gt; 대신 사용해야 합니다. 지정된 &lt;em&gt;server_name_callback&lt;/em&gt; 은 서버 호스트 이름이 IDN으로 인코딩 된 국제화 된 도메인 이름 인 경우 &lt;em&gt;server_name_callback&lt;/em&gt; 이 디코딩 된 U- 라벨 ( &lt;code&gt;&quot;pyth&amp;ouml;n.org&quot;&lt;/code&gt; )을 수신 한다는 점을 제외하고는 &lt;em&gt;sni_callback&lt;/em&gt; 과 유사합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="928b464bfb8b1d3da5461ee431b2aebe894ae69d" translate="yes" xml:space="preserve">
          <source>This is a legacy method. On the &lt;code&gt;EmailMessage&lt;/code&gt; class it always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이것은 레거시 방법입니다. 온 &lt;code&gt;EmailMessage&lt;/code&gt; 의 클래스는 항상 반환 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="560364aea437ea98e565fe17e2a387401b67f453" translate="yes" xml:space="preserve">
          <source>This is a legacy method. On the &lt;code&gt;EmailMessage&lt;/code&gt; class its functionality is replaced by &lt;a href=&quot;email.message#email.message.EmailMessage.get_content&quot;&gt;&lt;code&gt;get_content()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt;&lt;code&gt;iter_parts()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 레거시 방법입니다. 온 &lt;code&gt;EmailMessage&lt;/code&gt; 클래스의 기능에 의해 대체된다 &lt;a href=&quot;email.message#email.message.EmailMessage.get_content&quot;&gt; &lt;code&gt;get_content()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt; &lt;code&gt;iter_parts()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0adf6390e428a55bd96ef1ee56b56b179f8271a9" translate="yes" xml:space="preserve">
          <source>This is a legacy method. On the &lt;code&gt;EmailMessage&lt;/code&gt; class its functionality is replaced by &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; and the related &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; methods.</source>
          <target state="translated">이것은 레거시 방법입니다. 온 &lt;code&gt;EmailMessage&lt;/code&gt; 의 클래스의 기능은로 대체 &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 및 관련 &lt;code&gt;make&lt;/code&gt; 및 &lt;code&gt;add&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="63b9d63fb4198d07361b2b2c61a42bbefcb8d10e" translate="yes" xml:space="preserve">
          <source>This is a legacy method. On the &lt;code&gt;EmailMessage&lt;/code&gt; class its functionality is replaced by &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 레거시 방법입니다. 온 &lt;code&gt;EmailMessage&lt;/code&gt; 클래스의 기능은로 대체 &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27a2aa515d5423d4affd0779521e3b5fafa11340" translate="yes" xml:space="preserve">
          <source>This is a legacy method. On the &lt;code&gt;EmailMessage&lt;/code&gt; class its functionality is replaced by the &lt;code&gt;make_&lt;/code&gt; and &lt;code&gt;add_&lt;/code&gt; methods.</source>
          <target state="translated">이것은 레거시 방법입니다. 온 &lt;code&gt;EmailMessage&lt;/code&gt; 클래스의 기능에 의해 대체된다 &lt;code&gt;make_&lt;/code&gt; 와 &lt;code&gt;add_&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="dfc629871289e0e65b56c5cbfe2f4ace662c8ec2" translate="yes" xml:space="preserve">
          <source>This is a legacy method. On the &lt;code&gt;EmailMessage&lt;/code&gt; class its functionality is replaced by the &lt;em&gt;charset&lt;/em&gt; parameter of the &lt;code&gt;email.emailmessage.EmailMessage.set_content()&lt;/code&gt; method.</source>
          <target state="translated">이것은 레거시 방법입니다. 온 &lt;code&gt;EmailMessage&lt;/code&gt; 의 클래스는 그 기능으로 대체 &lt;em&gt;캐릭터 세트&lt;/em&gt; 의 파라미터 &lt;code&gt;email.emailmessage.EmailMessage.set_content()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="a6fae13c077a979f25a3a7f031bc51558b673c47" translate="yes" xml:space="preserve">
          <source>This is a legacy method. On the &lt;code&gt;EmailMessage&lt;/code&gt; class its functionality is replaced by the &lt;em&gt;params&lt;/em&gt; property of the individual header objects returned by the header access methods.</source>
          <target state="translated">이것은 레거시 방법입니다. 온 &lt;code&gt;EmailMessage&lt;/code&gt; 의 클래스의 기능은로 대체 &lt;em&gt;PARAMS의&lt;/em&gt; 헤더 접근 방법에 의해 반환 된 객체 개별 헤더의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="a99c5dcc9ab288704491edaec84b894542f3acf7" translate="yes" xml:space="preserve">
          <source>This is a list of all the awaits made to the mock object in sequence (so the length of the list is the number of times it has been awaited). Before any awaits have been made it is an empty list.</source>
          <target state="translated">이것은 모의 객체에 대한 모든 대기 목록을 순서대로 나열한 것입니다 (따라서 목록의 길이는 대기 한 횟수입니다). 기다리기 전에 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1b902cf8994e14c83ab2966f3101a37cf2ebc6f1" translate="yes" xml:space="preserve">
          <source>This is a list of all the calls made to the mock object in sequence (so the length of the list is the number of times it has been called). Before any calls have been made it is an empty list. The &lt;a href=&quot;#unittest.mock.call&quot;&gt;&lt;code&gt;call&lt;/code&gt;&lt;/a&gt; object can be used for conveniently constructing lists of calls to compare with &lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt;&lt;code&gt;call_args_list&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 모의 객체에 대한 모든 호출의 순서대로 나열됩니다 (따라서 목록의 길이는 호출 된 횟수입니다). 전화를 걸기 전에 빈 목록입니다. &lt;a href=&quot;#unittest.mock.call&quot;&gt; &lt;code&gt;call&lt;/code&gt; &lt;/a&gt; 객체 편리하게 비교 대상 통화 목록 구성에 사용할 수 있습니다 &lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt; &lt;code&gt;call_args_list&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc997d8da827766226a9a1b8cbef46aa4082f5c7" translate="yes" xml:space="preserve">
          <source>This is a low-level interface to the functionality of &lt;a href=&quot;#warnings.warn&quot;&gt;&lt;code&gt;warn()&lt;/code&gt;&lt;/a&gt;, passing in explicitly the message, category, filename and line number, and optionally the module name and the registry (which should be the &lt;code&gt;__warningregistry__&lt;/code&gt; dictionary of the module). The module name defaults to the filename with &lt;code&gt;.py&lt;/code&gt; stripped; if no registry is passed, the warning is never suppressed. &lt;em&gt;message&lt;/em&gt; must be a string and &lt;em&gt;category&lt;/em&gt; a subclass of &lt;a href=&quot;exceptions#Warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; or &lt;em&gt;message&lt;/em&gt; may be a &lt;a href=&quot;exceptions#Warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; instance, in which case &lt;em&gt;category&lt;/em&gt; will be ignored.</source>
          <target state="translated">이것은 &lt;a href=&quot;#warnings.warn&quot;&gt; &lt;code&gt;warn()&lt;/code&gt; &lt;/a&gt; 기능에 대한 저수준 인터페이스로, 메시지, 카테고리, 파일 이름 및 줄 번호 및 선택적으로 모듈 이름과 레지스트리 ( 모듈 의 &lt;code&gt;__warningregistry__&lt;/code&gt; 사전 이어야 함 )를 전달합니다. 모듈 이름의 기본값은 &lt;code&gt;.py&lt;/code&gt; 가 제거 된 파일 이름입니다 . 레지스트리가 전달되지 않으면 경고가 표시되지 않습니다. &lt;em&gt;메시지&lt;/em&gt; 는 문자열 및 &lt;em&gt;범주&lt;/em&gt; 여야하며 &lt;a href=&quot;exceptions#Warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 이거나 &lt;em&gt;메시지&lt;/em&gt; 는 &lt;a href=&quot;exceptions#Warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; 인스턴스 일 수 있으며이 경우 &lt;em&gt;범주&lt;/em&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a073c4a90d19a2d3d955e9d04e18a32015661680" translate="yes" xml:space="preserve">
          <source>This is a measure of the power in an audio signal.</source>
          <target state="translated">이것은 오디오 신호의 전력을 측정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4320eee4f82e48a26f22142603adb9abf481fd04" translate="yes" xml:space="preserve">
          <source>This is a mixin class that helps with HTTP authentication, both to the remote host and to a proxy. &lt;em&gt;password_mgr&lt;/em&gt;, if given, should be something that is compatible with &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt;; refer to section &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr Objects&lt;/a&gt; for information on the interface that must be supported.</source>
          <target state="translated">원격 호스트와 프록시 모두에서 HTTP 인증을 돕는 믹스 인 클래스입니다. &lt;em&gt;password_mgr&lt;/em&gt; 이 지정된 경우 &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt; 과 호환 가능한 것이어야합니다 . 지원해야하는 인터페이스에 대한 정보는 &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr 오브젝트&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94093b21ff1d5ab0d668c6a7f43229fb8ec28b23" translate="yes" xml:space="preserve">
          <source>This is a mixin class that helps with HTTP authentication, both to the remote host and to a proxy. &lt;em&gt;password_mgr&lt;/em&gt;, if given, should be something that is compatible with &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt;; refer to section &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr Objects&lt;/a&gt; for information on the interface that must be supported. If &lt;em&gt;passwd_mgr&lt;/em&gt; also provides &lt;code&gt;is_authenticated&lt;/code&gt; and &lt;code&gt;update_authenticated&lt;/code&gt; methods (see &lt;a href=&quot;#http-password-mgr-with-prior-auth&quot;&gt;HTTPPasswordMgrWithPriorAuth Objects&lt;/a&gt;), then the handler will use the &lt;code&gt;is_authenticated&lt;/code&gt; result for a given URI to determine whether or not to send authentication credentials with the request. If &lt;code&gt;is_authenticated&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt; for the URI, credentials are sent. If &lt;code&gt;is_authenticated&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, credentials are not sent, and then if a &lt;code&gt;401&lt;/code&gt; response is received the request is re-sent with the authentication credentials. If authentication succeeds, &lt;code&gt;update_authenticated&lt;/code&gt; is called to set &lt;code&gt;is_authenticated&lt;/code&gt;&lt;code&gt;True&lt;/code&gt; for the URI, so that subsequent requests to the URI or any of its super-URIs will automatically include the authentication credentials.</source>
          <target state="translated">원격 호스트와 프록시 모두에서 HTTP 인증을 돕는 믹스 인 클래스입니다. &lt;em&gt;password_mgr&lt;/em&gt; 이 지정된 경우 &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt; 과 호환 가능한 것이어야합니다 . 지원해야하는 인터페이스에 대한 정보는 &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr 오브젝트&lt;/a&gt; 섹션을 참조하십시오 . &lt;em&gt;passwd_mgr이 &lt;/em&gt; &lt;code&gt;is_authenticated&lt;/code&gt; 및 &lt;code&gt;update_authenticated&lt;/code&gt; 메소드 도 제공하는 경우 ( &lt;a href=&quot;#http-password-mgr-with-prior-auth&quot;&gt;HTTPPasswordMgrWithPriorAuth 오브젝트&lt;/a&gt; 참조 ) 핸들러는 지정된 URI에 대해 &lt;code&gt;is_authenticated&lt;/code&gt; 결과를 사용하여 요청과 함께 인증 신임 정보를 보낼지 여부를 판별합니다. &lt;code&gt;is_authenticated&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 를 반환하는 경우URI의 경우 자격 증명이 전송됩니다. 경우 &lt;code&gt;is_authenticated&lt;/code&gt; 가 있다 &lt;code&gt;False&lt;/code&gt; , 인증 정보가 전송되지 않고, 그 후 경우에 &lt;code&gt;401&lt;/code&gt; 응답이 요청을 수신 재전송 인증 자격 증명이다. 인증에 성공하면 URI에 대해 &lt;code&gt;is_authenticated&lt;/code&gt; &lt;code&gt;True&lt;/code&gt; 를 설정하기 위해 &lt;code&gt;update_authenticated&lt;/code&gt; 가 호출 되므로 URI 또는 ​​해당 수퍼 URI에 대한 후속 요청에 인증 자격 증명이 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="996f13e7670dd2a8817147764b715d5a9ebb7999" translate="yes" xml:space="preserve">
          <source>This is a module-global setting, and affects all future doctests run by module &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;: the &lt;code&gt;runTest()&lt;/code&gt; method of &lt;code&gt;DocTestCase&lt;/code&gt; looks at the option flags specified for the test case when the &lt;code&gt;DocTestCase&lt;/code&gt; instance was constructed. If no reporting flags were specified (which is the typical and expected case), &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; reporting flags are &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;bitwise ORed&lt;/a&gt; into the option flags, and the option flags so augmented are passed to the &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt; instance created to run the doctest. If any reporting flags were specified when the &lt;code&gt;DocTestCase&lt;/code&gt; instance was constructed, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; reporting flags are ignored.</source>
          <target state="translated">이것은 모듈 전역 설정이며, 모듈 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; 에&lt;/a&gt; 의해 실행되는 모든 향후 doctest에 영향을줍니다 . &lt;code&gt;DocTestCase&lt;/code&gt; 의 &lt;code&gt;runTest()&lt;/code&gt; 메소드 는 &lt;code&gt;DocTestCase&lt;/code&gt; 인스턴스가 생성 될 때 테스트 케이스에 지정된 옵션 플래그를 확인합니다 . 보고 플래그가 지정되지 않은 경우 (일반적이고 예상되는 경우), &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 의 단위 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 보고 플래그는 옵션 플래그에 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;비트 OR&lt;/a&gt; 로 OR 되고, 이렇게 보강 된 옵션 플래그 는 doctest를 실행하기 위해 작성된 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 인스턴스 로 전달됩니다 . 때 어떤보고 플래그가 지정된 경우 &lt;code&gt;DocTestCase&lt;/code&gt; 의 인스턴스가, 건설되었다 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; 가&lt;/a&gt; 의&lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 보고 플래그는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bd579c90746112b0e9a715bf70500cdbf4cb8b4c" translate="yes" xml:space="preserve">
          <source>This is a nonstandard convenience method for executing multiple SQL statements at once. It issues a &lt;code&gt;COMMIT&lt;/code&gt; statement first, then executes the SQL script it gets as a parameter.</source>
          <target state="translated">이는 여러 SQL 문을 한 번에 실행하기위한 비표준 편의 방법입니다. 먼저 &lt;code&gt;COMMIT&lt;/code&gt; 문을 발행 한 다음 매개 변수로 가져 오는 SQL 스크립트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f25f408676466832f9ff8f647196311789c1a7ad" translate="yes" xml:space="preserve">
          <source>This is a nonstandard shortcut that creates a cursor object by calling the &lt;a href=&quot;#sqlite3.Connection.cursor&quot;&gt;&lt;code&gt;cursor()&lt;/code&gt;&lt;/a&gt; method, calls the cursor&amp;rsquo;s &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt;&lt;code&gt;execute()&lt;/code&gt;&lt;/a&gt; method with the &lt;em&gt;parameters&lt;/em&gt; given, and returns the cursor.</source>
          <target state="translated">이것은 비표준 단축키로 &lt;a href=&quot;#sqlite3.Connection.cursor&quot;&gt; &lt;code&gt;cursor()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 커서 객체를 만들고 지정된 &lt;em&gt;매개 변수를 사용&lt;/em&gt; 하여 커서의 &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt; &lt;code&gt;execute()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 한 다음 커서 를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f026b3fde6844ad7ddf3c6cb9c30cb2c9296424" translate="yes" xml:space="preserve">
          <source>This is a nonstandard shortcut that creates a cursor object by calling the &lt;a href=&quot;#sqlite3.Connection.cursor&quot;&gt;&lt;code&gt;cursor()&lt;/code&gt;&lt;/a&gt; method, calls the cursor&amp;rsquo;s &lt;a href=&quot;#sqlite3.Cursor.executemany&quot;&gt;&lt;code&gt;executemany()&lt;/code&gt;&lt;/a&gt; method with the &lt;em&gt;parameters&lt;/em&gt; given, and returns the cursor.</source>
          <target state="translated">이것은 &lt;a href=&quot;#sqlite3.Connection.cursor&quot;&gt; &lt;code&gt;cursor()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 커서 객체를 만들고 지정된 &lt;em&gt;매개 변수를 사용&lt;/em&gt; 하여 커서의 &lt;a href=&quot;#sqlite3.Cursor.executemany&quot;&gt; &lt;code&gt;executemany()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 한 다음 커서 를 반환 하는 비표준 바로 가기입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f07d18339dec09d14b91f6da8c999bb831d41d7" translate="yes" xml:space="preserve">
          <source>This is a nonstandard shortcut that creates a cursor object by calling the &lt;a href=&quot;#sqlite3.Connection.cursor&quot;&gt;&lt;code&gt;cursor()&lt;/code&gt;&lt;/a&gt; method, calls the cursor&amp;rsquo;s &lt;a href=&quot;#sqlite3.Cursor.executescript&quot;&gt;&lt;code&gt;executescript()&lt;/code&gt;&lt;/a&gt; method with the given &lt;em&gt;sql_script&lt;/em&gt;, and returns the cursor.</source>
          <target state="translated">이것은 &lt;a href=&quot;#sqlite3.Connection.cursor&quot;&gt; &lt;code&gt;cursor()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 커서 객체를 만들고 지정된 &lt;em&gt;sql_script로&lt;/em&gt; 커서의 &lt;a href=&quot;#sqlite3.Cursor.executescript&quot;&gt; &lt;code&gt;executescript()&lt;/code&gt; &lt;/a&gt; 메서드를 호출 한 다음 커서 를 반환 하는 비표준 바로 가기입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ac73b34e4853d2c7555adf61229da0b29863e37" translate="yes" xml:space="preserve">
          <source>This is a possible value for the flags argument in &lt;a href=&quot;#os.setxattr&quot;&gt;&lt;code&gt;setxattr()&lt;/code&gt;&lt;/a&gt;. It indicates the operation must create an attribute.</source>
          <target state="translated">이것은 &lt;a href=&quot;#os.setxattr&quot;&gt; &lt;code&gt;setxattr()&lt;/code&gt; &lt;/a&gt; 의 flags 인자에 가능한 값입니다 . 조작이 속성을 작성해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96540e48fc82860097be205c93b6abd3606e07c1" translate="yes" xml:space="preserve">
          <source>This is a possible value for the flags argument in &lt;a href=&quot;#os.setxattr&quot;&gt;&lt;code&gt;setxattr()&lt;/code&gt;&lt;/a&gt;. It indicates the operation must replace an existing attribute.</source>
          <target state="translated">이것은 &lt;a href=&quot;#os.setxattr&quot;&gt; &lt;code&gt;setxattr()&lt;/code&gt; &lt;/a&gt; 의 flags 인자에 가능한 값입니다 . 작업이 기존 속성을 대체해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6e80deb781542d74711015086c8206e50356e00" translate="yes" xml:space="preserve">
          <source>This is a purely lexical operation, hence the following behaviour:</source>
          <target state="translated">이것은 순전히 어휘 연산이므로 다음과 같은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="79b9ada7f8d4fc3182b2d3f64af63694e2a47bf2" translate="yes" xml:space="preserve">
          <source>This is a relative of &lt;a href=&quot;#setattr&quot;&gt;&lt;code&gt;setattr()&lt;/code&gt;&lt;/a&gt;. The arguments are an object and a string. The string must be the name of one of the object&amp;rsquo;s attributes. The function deletes the named attribute, provided the object allows it. For example, &lt;code&gt;delattr(x, 'foobar')&lt;/code&gt; is equivalent to &lt;code&gt;del x.foobar&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#setattr&quot;&gt; &lt;code&gt;setattr()&lt;/code&gt; &lt;/a&gt; 의 친척입니다 . 인수는 객체와 문자열입니다. 문자열은 객체 속성 중 하나의 이름이어야합니다. 객체가 허용하는 경우 함수는 명명 된 속성을 삭제합니다. 예를 들어 &lt;code&gt;delattr(x, 'foobar')&lt;/code&gt; 는 &lt;code&gt;del x.foobar&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9715e416b1df859f446f99f56d2aa08145ae5cce" translate="yes" xml:space="preserve">
          <source>This is a relatively low level API that takes care of the details of correctly unwinding the stack of exit callbacks. It provides a suitable foundation for higher level context managers that manipulate the exit stack in application specific ways.</source>
          <target state="translated">엑시트 콜백 스택을 올바르게 해제하는 세부 정보를 처리하는 비교적 낮은 수준의 API입니다. 애플리케이션 특정 방식으로 엑시트 스택을 조작하는 상위 레벨 컨텍스트 관리자에게 적합한 기반을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2dbf3692d221f94721c68226699f011fa8c60193" translate="yes" xml:space="preserve">
          <source>This is a short tutorial for using &lt;a href=&quot;#module-xml.etree.ElementTree&quot;&gt;&lt;code&gt;xml.etree.ElementTree&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;ET&lt;/code&gt; in short). The goal is to demonstrate some of the building blocks and basic concepts of the module.</source>
          <target state="translated">이것은 &lt;a href=&quot;#module-xml.etree.ElementTree&quot;&gt; &lt;code&gt;xml.etree.ElementTree&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;ET&lt;/code&gt; ) 를 사용하기위한 간단한 자습서입니다 . 목표는 모듈의 일부 빌딩 블록과 기본 개념을 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa365b626b798e07b34b9f21c141cb183f10539a" translate="yes" xml:space="preserve">
          <source>This is a short-circuit operator, so it only evaluates the second argument if the first one is false.</source>
          <target state="translated">이것은 단락 연산자이므로 첫 번째 인수가 false 인 경우 두 번째 인수 만 평가합니다.</target>
        </trans-unit>
        <trans-unit id="dc5e590500f62fbd4dc8ebdd79a793c1c71615c0" translate="yes" xml:space="preserve">
          <source>This is a short-circuit operator, so it only evaluates the second argument if the first one is true.</source>
          <target state="translated">이것은 단락 연산자이므로 첫 번째 인수 만 참이면 두 번째 인수 만 평가합니다.</target>
        </trans-unit>
        <trans-unit id="9f41bbe9d27e4a677b830d37db3fb2b9e6f876eb" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &lt;code&gt;print_exception(*sys.exc_info(), limit, file,
chain)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;print_exception(*sys.exc_info(), limit, file, chain)&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="a9296be127dc4a3b4f48abe6df80c8c1d08c7d67" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &lt;code&gt;print_exception(sys.last_type, sys.last_value,
sys.last_traceback, limit, file, chain)&lt;/code&gt;. In general it will work only after an exception has reached an interactive prompt (see &lt;a href=&quot;sys#sys.last_type&quot;&gt;&lt;code&gt;sys.last_type&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;print_exception(sys.last_type, sys.last_value, sys.last_traceback, limit, file, chain)&lt;/code&gt; 의 약어입니다 . 일반적으로 예외가 대화 형 프롬프트에 도달 한 후에 만 ​​작동합니다 ( &lt;a href=&quot;sys#sys.last_type&quot;&gt; &lt;code&gt;sys.last_type&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4e593684971c7ffd714930ffa9422d5c50b3b1cf" translate="yes" xml:space="preserve">
          <source>This is a standard context defined by the General Decimal Arithmetic Specification. Precision is set to nine. Rounding is set to &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt;&lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt;&lt;/a&gt;. All flags are cleared. No traps are enabled (so that exceptions are not raised during computations).</source>
          <target state="translated">이것은 일반 십진 산술 사양에 의해 정의 된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 반올림은 &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt; &lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt; &lt;/a&gt; 으로 설정됩니다 . 모든 플래그가 지워집니다. 트랩이 활성화되어 있지 않으므로 계산 중에 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2da625cd53289b672f7014ba22ac20aee7685a56" translate="yes" xml:space="preserve">
          <source>This is a standard context defined by the General Decimal Arithmetic Specification. Precision is set to nine. Rounding is set to &lt;a href=&quot;#decimal.ROUND_HALF_UP&quot;&gt;&lt;code&gt;ROUND_HALF_UP&lt;/code&gt;&lt;/a&gt;. All flags are cleared. All traps are enabled (treated as exceptions) except &lt;a href=&quot;#decimal.Inexact&quot;&gt;&lt;code&gt;Inexact&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.Rounded&quot;&gt;&lt;code&gt;Rounded&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#decimal.Subnormal&quot;&gt;&lt;code&gt;Subnormal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반 십진 산술 사양에 의해 정의 된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 반올림이 &lt;a href=&quot;#decimal.ROUND_HALF_UP&quot;&gt; &lt;code&gt;ROUND_HALF_UP&lt;/code&gt; &lt;/a&gt; 으로 설정되었습니다 . 모든 플래그가 지워집니다. &lt;a href=&quot;#decimal.Inexact&quot;&gt; &lt;code&gt;Inexact&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.Rounded&quot;&gt; &lt;code&gt;Rounded&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.Subnormal&quot;&gt; &lt;code&gt;Subnormal&lt;/code&gt; 을&lt;/a&gt; 제외한 모든 트랩이 활성화됩니다 (예외로 처리됨) .</target>
        </trans-unit>
        <trans-unit id="cd336ee085cbeef7c437546cd6c8582a726fd7e2" translate="yes" xml:space="preserve">
          <source>This is a straightforward interface to the Unix &lt;code&gt;select()&lt;/code&gt; system call. The first three arguments are sequences of &amp;lsquo;waitable objects&amp;rsquo;: either integers representing file descriptors or objects with a parameterless method named &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; returning such an integer:</source>
          <target state="translated">이것은 Unix &lt;code&gt;select()&lt;/code&gt; 시스템 호출에 대한 간단한 인터페이스 입니다. 처음 세 개의 인수는 '대기 가능한 객체'의 시퀀스입니다. 파일 디스크립터를 나타내는 정수 또는 &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 라는 매개 변수가없는 메소드를 가진 객체는 이러한 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a9653a53929c37a27ca2d3608cb98481b962cc2f" translate="yes" xml:space="preserve">
          <source>This is a string of the form &lt;code&gt;widthxheight&lt;/code&gt;, where width and height are measured in pixels for most widgets (in characters for widgets displaying text). For example: &lt;code&gt;fred[&quot;geometry&quot;] = &quot;200x100&quot;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;widthxheight&lt;/code&gt; 형식의 문자열이며 너비와 높이는 대부분의 위젯에 대해 픽셀 단위로 측정됩니다 (텍스트를 표시하는 위젯의 문자). 예를 들어 : &lt;code&gt;fred[&quot;geometry&quot;] = &quot;200x100&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d23b43b3d9f7e926c09069e36030aeb6308947" translate="yes" xml:space="preserve">
          <source>This is a string with four space-delimited elements, each of which is a legal distance (see above). For example: &lt;code&gt;&quot;2 3 4 5&quot;&lt;/code&gt; and &lt;code&gt;&quot;3i 2i 4.5i 2i&quot;&lt;/code&gt; and &lt;code&gt;&quot;3c 2c 4c 10.43c&quot;&lt;/code&gt; are all legal regions.</source>
          <target state="translated">이것은 공백으로 구분 된 4 개의 요소가있는 문자열이며 각각은 법적인 거리입니다 (위 참조). 예 : &lt;code&gt;&quot;2 3 4 5&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;3i 2i 4.5i 2i&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;3c 2c 4c 10.43c&quot;&lt;/code&gt; 는 모두 합법적 인 지역입니다.</target>
        </trans-unit>
        <trans-unit id="505a14132b19d890d214ba81ac33505c98cfb289" translate="yes" xml:space="preserve">
          <source>This is a subclass derived from &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt; that connects over an SSL encrypted socket (to use this class you need a socket module that was compiled with SSL support). If &lt;em&gt;host&lt;/em&gt; is not specified, &lt;code&gt;''&lt;/code&gt; (the local host) is used. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard IMAP4-over-SSL port (993) is used. &lt;em&gt;ssl_context&lt;/em&gt; is a &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. Please read &lt;a href=&quot;ssl#ssl-security&quot;&gt;Security considerations&lt;/a&gt; for best practices.</source>
          <target state="translated">이것은 SSL 암호화 소켓을 통해 연결 되는 &lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; &lt;/a&gt; 에서 파생 된 서브 클래스입니다 (이 클래스를 사용하려면 SSL 지원으로 컴파일 된 소켓 모듈이 필요합니다). 경우 &lt;em&gt;호스트가&lt;/em&gt; 지정되지 않은, &lt;code&gt;''&lt;/code&gt; (로컬 호스트)가 사용됩니다. 경우 &lt;em&gt;포트가&lt;/em&gt; 생략 된 표준 IMAP4 - 이상 - SSL 포트 (993)가 사용됩니다. &lt;em&gt;ssl_context&lt;/em&gt; 는 SSL 구성 옵션, 인증서 및 개인 키를 단일 (잠재적으로 오래 지속되는) 구조로 묶을 수 있는 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 객체입니다. 모범 사례는 &lt;a href=&quot;ssl#ssl-security&quot;&gt;보안 고려 사항&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="764f94ad39faf8459a1f96a15f7dd2ebd680f57d" translate="yes" xml:space="preserve">
          <source>This is a subclass derived from &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt; that connects to the &lt;code&gt;stdin/stdout&lt;/code&gt; file descriptors created by passing &lt;em&gt;command&lt;/em&gt; to &lt;code&gt;subprocess.Popen()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;subprocess.Popen()&lt;/code&gt; &lt;em&gt;명령&lt;/em&gt; 을 전달 하여 생성 된 &lt;code&gt;stdin/stdout&lt;/code&gt; 파일 디스크립터에 연결하는 &lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; &lt;/a&gt; 에서 파생 된 서브 클래스 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7dccb247bf4ce42730d244a4bcedb9e3a1d6f4a8" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;#poplib.POP3&quot;&gt;&lt;code&gt;POP3&lt;/code&gt;&lt;/a&gt; that connects to the server over an SSL encrypted socket. If &lt;em&gt;port&lt;/em&gt; is not specified, 995, the standard POP3-over-SSL port is used. &lt;em&gt;timeout&lt;/em&gt; works as in the &lt;a href=&quot;#poplib.POP3&quot;&gt;&lt;code&gt;POP3&lt;/code&gt;&lt;/a&gt; constructor. &lt;em&gt;context&lt;/em&gt; is an optional &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. Please read &lt;a href=&quot;ssl#ssl-security&quot;&gt;Security considerations&lt;/a&gt; for best practices.</source>
          <target state="translated">SSL 암호화 소켓을 통해 서버에 연결하는 &lt;a href=&quot;#poplib.POP3&quot;&gt; &lt;code&gt;POP3&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 . 경우 &lt;em&gt;포트가&lt;/em&gt; 지정되지 않은, 995, 표준 POP3 - 이상 - SSL 포트가 사용됩니다. &lt;em&gt;제한 시간&lt;/em&gt; 은 &lt;a href=&quot;#poplib.POP3&quot;&gt; &lt;code&gt;POP3&lt;/code&gt; &lt;/a&gt; 생성자 와 같이 작동합니다 . &lt;em&gt;context&lt;/em&gt; 는 선택적 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 객체로 SSL 구성 옵션, 인증서 및 개인 키를 단일 (잠재적으로 오래 지속되는) 구조로 번들링 할 수 있습니다. 모범 사례는 &lt;a href=&quot;ssl#ssl-security&quot;&gt;보안 고려 사항&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ef9776734c2d67729c4aaf01a2cd2a9bbb54ab5e" translate="yes" xml:space="preserve">
          <source>This is a subclassable type rather than a factory function.</source>
          <target state="translated">이것은 팩토리 함수가 아닌 서브 클래스 가능 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9765ce9944ccb97a9358dad6c89e4504fdbd8f6e" translate="yes" xml:space="preserve">
          <source>This is a symbolic constant used for different values returned by &lt;a href=&quot;#locale.localeconv&quot;&gt;&lt;code&gt;localeconv()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#locale.localeconv&quot;&gt; &lt;code&gt;localeconv()&lt;/code&gt; &lt;/a&gt; 반환 한 다른 값에 사용되는 기호 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="cc8d2a984c67cda6fb3471c60192bee35875336f" translate="yes" xml:space="preserve">
          <source>This is a useful example for subclassing Enum to add or change other behaviors as well as disallowing aliases. If the only desired change is disallowing aliases, the &lt;a href=&quot;#enum.unique&quot;&gt;&lt;code&gt;unique()&lt;/code&gt;&lt;/a&gt; decorator can be used instead.</source>
          <target state="translated">이것은 Enum을 서브 클래 싱하여 다른 동작을 추가하거나 변경하고 별칭을 허용하지 않는 유용한 예입니다. 원하는 변경 사항이 별칭을 허용하지 않는 경우 &lt;a href=&quot;#enum.unique&quot;&gt; &lt;code&gt;unique()&lt;/code&gt; &lt;/a&gt; 데코레이터를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f095373c041f749d13f3b152d79425bbe538a11" translate="yes" xml:space="preserve">
          <source>This is a working &amp;ldquo;Hello World&amp;rdquo; WSGI application:</source>
          <target state="translated">작동중인 &quot;Hello World&quot;WSGI 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="ed30072f4605977c71fd7205e1fd018e0d972eea" translate="yes" xml:space="preserve">
          <source>This is a wrapper for the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt;&lt;a href=&quot;importlib#importlib.abc.ResourceLoader.get_data&quot;&gt;&lt;code&gt;get_data&lt;/code&gt;&lt;/a&gt; API. The &lt;em&gt;package&lt;/em&gt; argument should be the name of a package, in standard module format (&lt;code&gt;foo.bar&lt;/code&gt;). The &lt;em&gt;resource&lt;/em&gt; argument should be in the form of a relative filename, using &lt;code&gt;/&lt;/code&gt; as the path separator. The parent directory name &lt;code&gt;..&lt;/code&gt; is not allowed, and nor is a rooted name (starting with a &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">이것은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더 &lt;/a&gt;&lt;a href=&quot;importlib#importlib.abc.ResourceLoader.get_data&quot;&gt; &lt;code&gt;get_data&lt;/code&gt; &lt;/a&gt; API 의 랩퍼입니다 . &lt;em&gt;패키지&lt;/em&gt; 인수는 표준 모듈 형식 (에, 패키지의 이름이어야합니다 &lt;code&gt;foo.bar&lt;/code&gt; ). &lt;em&gt;자원&lt;/em&gt; 인수하여, 상대의 이름 형식이어야 &lt;code&gt;/&lt;/code&gt; 를 경로 분리한다. 부모 디렉토리 이름 &lt;code&gt;..&lt;/code&gt; 은 허용되지 않으며 루트 이름도 아닙니다 ( &lt;code&gt;/&lt;/code&gt; 로 시작 ).</target>
        </trans-unit>
        <trans-unit id="fbe8df11a8943e8d9f9b85f47cfd605f5644d080" translate="yes" xml:space="preserve">
          <source>This is almost always the &lt;code&gt;set()&lt;/code&gt; method of some scrollbar widget, but can be any widget method that takes a single argument.</source>
          <target state="translated">거의 항상 일부 스크롤 막대 위젯 의 &lt;code&gt;set()&lt;/code&gt; 메소드이지만 단일 인수를 사용하는 모든 위젯 메소드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2555e7bf342a503beae512a726ce26265cc5be14" translate="yes" xml:space="preserve">
          <source>This is also the value returned by &lt;code&gt;str(addr)&lt;/code&gt; for IPv6 addresses.</source>
          <target state="translated">이는 IPv6 주소에 대해 &lt;code&gt;str(addr)&lt;/code&gt; 리턴 한 값이기도 합니다.</target>
        </trans-unit>
        <trans-unit id="7d5496a2a6eb94af65673cb0d50ad6bafe0ea28b" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;IMAP4rev1&lt;/code&gt; extension command.</source>
          <target state="translated">이것은 &lt;code&gt;IMAP4rev1&lt;/code&gt; 확장 명령입니다.</target>
        </trans-unit>
        <trans-unit id="7b34ee508bd103c5e0b8626cf2d804764b1677d4" translate="yes" xml:space="preserve">
          <source>This is an abstract base class for running WSGI applications. Each instance will handle a single HTTP request, although in principle you could create a subclass that was reusable for multiple requests.</source>
          <target state="translated">이것은 WSGI 응용 프로그램을 실행하기위한 추상 기본 클래스입니다. 각 인스턴스는 단일 HTTP 요청을 처리하지만 원칙적으로 여러 요청에 재사용 가능한 서브 클래스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7592b3f4af1c675ae0461bbd0cd882d434a1f23" translate="yes" xml:space="preserve">
          <source>This is an abstract base class, meaning that this class should not be instantiated directly. Define a subclass of &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; to capture information about a particular time zone.</source>
          <target state="translated">이것은 추상 기본 클래스이므로이 클래스를 직접 인스턴스화해서는 안됩니다. 특정 시간대에 대한 정보를 캡처하려면 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 의 서브 클래스를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fe0477da04d468c9bd5e5b663db76e9e220f768" translate="yes" xml:space="preserve">
          <source>This is an advanced function that is not needed in everyday Python programming, unlike &lt;a href=&quot;importlib#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;importlib#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt; 과 달리 일상적인 Python 프로그래밍에는 필요하지 않은 고급 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="5d2b4b1396ba18b3d152dc46f2f7110e19305e7b" translate="yes" xml:space="preserve">
          <source>This is an alias for the builtin &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이것은 내장 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="2571e080d51d3b25b3470f01c190104b66dd3c80" translate="yes" xml:space="preserve">
          <source>This is an extension notation (a &lt;code&gt;'?'&lt;/code&gt; following a &lt;code&gt;'('&lt;/code&gt; is not meaningful otherwise). The first character after the &lt;code&gt;'?'&lt;/code&gt; determines what the meaning and further syntax of the construct is. Extensions usually do not create a new group; &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; is the only exception to this rule. Following are the currently supported extensions.</source>
          <target state="translated">이 확장 표기법 (인 &lt;code&gt;'?'&lt;/code&gt; 다음은 &lt;code&gt;'('&lt;/code&gt; ) 그렇지 않으면 이후 첫 번째 문자 의미가 없다. &lt;code&gt;'?'&lt;/code&gt; 구조물의 의미와 더 구문이 무엇인지를 결정 확장은 일반적으로 새로운 그룹을 생성하지 않습니다.; &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 은이 규칙에 대한 유일한 예외입니다. 다음은 현재 지원되는 확장명입니다.</target>
        </trans-unit>
        <trans-unit id="8f2d1a3f7686213bcb3e68f37c26e08de32ed2cd" translate="yes" xml:space="preserve">
          <source>This is an implementation detail of the warnings framework; do not modify this value. Refer to the &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module for more information on the warnings framework.</source>
          <target state="translated">이것은 경고 프레임 워크의 구현 세부 사항입니다. 이 값을 수정하지 마십시오. 경고 프레임 워크에 대한 자세한 정보 는 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c538fda17e935aeeea92bf67a676d3e1bc51efb" translate="yes" xml:space="preserve">
          <source>This is an implementation of the &lt;code&gt;Attributes&lt;/code&gt; interface (see section &lt;a href=&quot;#attributes-objects&quot;&gt;The Attributes Interface&lt;/a&gt;). This is a dictionary-like object which represents the element attributes in a &lt;code&gt;startElement()&lt;/code&gt; call. In addition to the most useful dictionary operations, it supports a number of other methods as described by the interface. Objects of this class should be instantiated by readers; &lt;em&gt;attrs&lt;/em&gt; must be a dictionary-like object containing a mapping from attribute names to attribute values.</source>
          <target state="translated">이것은 &lt;code&gt;Attributes&lt;/code&gt; 인터페이스 의 구현입니다 (섹션 &lt;a href=&quot;#attributes-objects&quot;&gt;속성 인터페이스&lt;/a&gt; 참조 ). 이것은 &lt;code&gt;startElement()&lt;/code&gt; 호출 에서 요소 속성을 나타내는 사전과 유사한 객체입니다 . 가장 유용한 사전 작업 외에도 인터페이스에서 설명하는 여러 가지 다른 방법을 지원합니다. 이 클래스의 객체는 독자가 인스턴스화해야합니다. &lt;em&gt;attrs&lt;/em&gt; 는 속성 이름에서 속성 값으로의 맵핑을 포함하는 사전과 유사한 오브젝트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="00330212cc541703cd5ff8aa5689877b2be61306" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;a href=&quot;#reprlib.Repr&quot;&gt;&lt;code&gt;Repr&lt;/code&gt;&lt;/a&gt; which is used to provide the &lt;a href=&quot;#reprlib.repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; function described below. Changing the attributes of this object will affect the size limits used by &lt;a href=&quot;#reprlib.repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; and the Python debugger.</source>
          <target state="translated">아래에 설명 된 &lt;a href=&quot;#reprlib.repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 함수 를 제공하는 데 사용되는 &lt;a href=&quot;#reprlib.Repr&quot;&gt; &lt;code&gt;Repr&lt;/code&gt; &lt;/a&gt; 의 인스턴스입니다 . 이 객체의 속성을 변경하면 &lt;a href=&quot;#reprlib.repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 및 Python 디버거에서 사용하는 크기 제한에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="bc9d7efe1e111f4a3038022efcda5621f6b2ed82" translate="yes" xml:space="preserve">
          <source>This is an object that has the same methods as the entire module, but uses the Unicode database version 3.2 instead, for applications that require this specific version of the Unicode database (such as IDNA).</source>
          <target state="translated">이는 전체 모듈과 동일한 방법을 사용하지만이 특정 버전의 유니 코드 데이터베이스 (예 : IDNA)가 필요한 응용 프로그램에는 대신 유니 코드 데이터베이스 버전 3.2를 사용하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="11c3ea74a96f83696c34a897e968eb0226a1d9a9" translate="yes" xml:space="preserve">
          <source>This is another standard signal handler, which will simply ignore the given signal.</source>
          <target state="translated">이것은 주어진 표준 신호를 무시하는 또 다른 표준 신호 처리기입니다.</target>
        </trans-unit>
        <trans-unit id="28def8bed8d2bdaa1f2c7697b00c97beb3107dd0" translate="yes" xml:space="preserve">
          <source>This is any Python function that takes no arguments. For example:</source>
          <target state="translated">이것은 인수를 취하지 않는 파이썬 함수입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffe483266124d79a1a3157bbb4f1955342c8c1af" translate="yes" xml:space="preserve">
          <source>This is based on a proposed DOM Level 3 API which is still in the &amp;ldquo;working draft&amp;rdquo; stage, but this particular interface appears uncontroversial. Changes from the W3C will not necessarily affect this method in the Python DOM interface (though any new W3C API for this would also be supported).</source>
          <target state="translated">이것은 여전히&amp;ldquo;작업 초안&amp;rdquo;단계에있는 제안 된 DOM 레벨 3 API를 기반으로하지만이 특정 인터페이스는 논란의 여지가없는 것으로 보입니다. W3C의 변경 사항이 Python DOM 인터페이스에서이 메소드에 반드시 영향을 미치는 것은 아닙니다 (이에 대한 새 W3C API도 지원됨).</target>
        </trans-unit>
        <trans-unit id="81372bd6ddf513a4aff4ec4908ff400e30f799f8" translate="yes" xml:space="preserve">
          <source>This is because the previous execution has left the socket in a &lt;code&gt;TIME_WAIT&lt;/code&gt; state, and can&amp;rsquo;t be immediately reused.</source>
          <target state="translated">이는 이전 실행에서 소켓을 &lt;code&gt;TIME_WAIT&lt;/code&gt; 상태로 두었 기 때문에 즉시 재사용 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4147f1a73ee64438aeb3d78ac0d958d8e52248aa" translate="yes" xml:space="preserve">
          <source>This is called &lt;code&gt;hexversion&lt;/code&gt; since it only really looks meaningful when viewed as the result of passing it to the built-in &lt;a href=&quot;functions#hex&quot;&gt;&lt;code&gt;hex()&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;a href=&quot;#sys.version_info&quot;&gt;&lt;code&gt;sys.version_info&lt;/code&gt;&lt;/a&gt; may be used for a more human-friendly encoding of the same information.</source>
          <target state="translated">내장 &lt;a href=&quot;functions#hex&quot;&gt; &lt;code&gt;hex()&lt;/code&gt; &lt;/a&gt; 함수 에 전달한 결과로 볼 때 실제로 의미가 있기 때문에 &lt;code&gt;hexversion&lt;/code&gt; 이라고 합니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;라는 튜플 &lt;/a&gt;&lt;a href=&quot;#sys.version_info&quot;&gt; &lt;code&gt;sys.version_info&lt;/code&gt; 은&lt;/a&gt; 동일한 내용의 더욱 인간 친화적 인 인코딩을 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="7247eb7669c97fb110d163145704fe837c46400f" translate="yes" xml:space="preserve">
          <source>This is called automatically when the connection is garbage collected.</source>
          <target state="translated">연결이 가비지 수집 될 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5d3174cacbda7afe783d9c63633b1c116ccef9ac" translate="yes" xml:space="preserve">
          <source>This is called automatically when the iterator is exhausted or garbage collected, or when an error happens during iterating. However it is advisable to call it explicitly or use the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">반복자가 소진되거나 가비지 수집되거나 반복 중에 오류가 발생하면 자동으로 호출됩니다. 그러나 명시 적으로 호출하거나 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5999a3dc3b574752f1df7627f793ed276ddc5431" translate="yes" xml:space="preserve">
          <source>This is called from the default &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt;&lt;code&gt;datetime.astimezone()&lt;/code&gt;&lt;/a&gt; implementation. When called from that, &lt;code&gt;dt.tzinfo&lt;/code&gt; is &lt;em&gt;self&lt;/em&gt;, and &lt;em&gt;dt&lt;/em&gt;&amp;rsquo;s date and time data are to be viewed as expressing a UTC time. The purpose of &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt;&lt;code&gt;fromutc()&lt;/code&gt;&lt;/a&gt; is to adjust the date and time data, returning an equivalent datetime in &lt;em&gt;self&lt;/em&gt;&amp;rsquo;s local time.</source>
          <target state="translated">이것은 기본 &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt; &lt;code&gt;datetime.astimezone()&lt;/code&gt; &lt;/a&gt; 구현 에서 호출됩니다 . 그에서 호출 할 때, &lt;code&gt;dt.tzinfo&lt;/code&gt; 는 이다 &lt;em&gt;자체&lt;/em&gt; , 그리고 &lt;em&gt;DT&lt;/em&gt; 의 날짜 및 시간 데이터는 UTC 시간을 표현으로 볼 수 있습니다. &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt; &lt;code&gt;fromutc()&lt;/code&gt; &lt;/a&gt; 의 목적은 날짜 및 시간 데이터를 조정하여 해당 날짜 시간을 &lt;em&gt;자체&lt;/em&gt; 의 현지 시간으로 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f45a7baf47bfb2b113381808c519faae7853a34e" translate="yes" xml:space="preserve">
          <source>This is called in the &lt;a href=&quot;#socketserver.BaseServer.serve_forever&quot;&gt;&lt;code&gt;serve_forever()&lt;/code&gt;&lt;/a&gt; loop. This method can be overridden by subclasses or mixin classes to perform actions specific to a given service, such as cleanup actions.</source>
          <target state="translated">&lt;a href=&quot;#socketserver.BaseServer.serve_forever&quot;&gt; &lt;code&gt;serve_forever()&lt;/code&gt; &lt;/a&gt; 루프 에서 호출됩니다 . 이 메소드는 서브 클래스 또는 mixin 클래스로 대체되어 정리 조치와 같이 지정된 서비스에 특정한 조치를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5fc5d96310a3ced5b6cfd3ab67361662a6f8278" translate="yes" xml:space="preserve">
          <source>This is called when an exception occurs and no exception handler is set. This can be called by a custom exception handler that wants to defer to the default handler behavior.</source>
          <target state="translated">예외가 발생하고 예외 핸들러가 설정되지 않은 경우에 호출됩니다. 이것은 기본 핸들러 동작을 지연시키려는 사용자 정의 예외 핸들러에 의해 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0faadeef90e30191e68184d130440c2fd9562e5a" translate="yes" xml:space="preserve">
          <source>This is designed to be used with &lt;code&gt;@unittest.skipIf()&lt;/code&gt; to annotate tests that need to use an &lt;code&gt;assert_python*()&lt;/code&gt; function to launch an isolated mode (&lt;code&gt;-I&lt;/code&gt;) or no environment mode (&lt;code&gt;-E&lt;/code&gt;) sub-interpreter process.</source>
          <target state="translated">&lt;code&gt;@unittest.skipIf()&lt;/code&gt; 와 함께 &lt;code&gt;assert_python*()&lt;/code&gt; 함수를 사용하여 격리 모드 ( &lt;code&gt;-I&lt;/code&gt; ) 또는 환경 모드 없음 ( &lt;code&gt;-E&lt;/code&gt; ) 하위 인터프리터 프로세스 를 시작 해야하는 테스트에 주석을 달도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bfa80b779a073dbddfb027c4551bacdf6e96317a" translate="yes" xml:space="preserve">
          <source>This is easy to use but not much good if you are expecting megabytes to be uploaded &amp;mdash; in that case, use the &lt;code&gt;FieldStorage&lt;/code&gt; class instead which is much more flexible.</source>
          <target state="translated">메가 바이트가 업로드 될 것으로 예상하는 경우 사용하기 &lt;code&gt;FieldStorage&lt;/code&gt; 는 않습니다.이 경우 훨씬 유연한 FieldStorage 클래스를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a46664cff1edb9374b98b2675a73183f1e05af0" translate="yes" xml:space="preserve">
          <source>This is either &lt;code&gt;None&lt;/code&gt; (if the mock hasn&amp;rsquo;t been awaited), or the arguments that the mock was last awaited with. Functions the same as &lt;a href=&quot;#unittest.mock.Mock.call_args&quot;&gt;&lt;code&gt;Mock.call_args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 중 하나입니다 &lt;code&gt;None&lt;/code&gt; (모의가 기다려온되지 않은 경우), 또는 모의가 마지막으로 기다렸던 것을 인수. &lt;a href=&quot;#unittest.mock.Mock.call_args&quot;&gt; &lt;code&gt;Mock.call_args&lt;/code&gt; &lt;/a&gt; 와 동일하게 기능합니다 .</target>
        </trans-unit>
        <trans-unit id="8ee7c7bddc5bfce27b7479c43c2e7d01522714be" translate="yes" xml:space="preserve">
          <source>This is either &lt;code&gt;None&lt;/code&gt; (if the mock hasn&amp;rsquo;t been called), or the arguments that the mock was last called with. This will be in the form of a tuple: the first member, which can also be accessed through the &lt;code&gt;args&lt;/code&gt; property, is any ordered arguments the mock was called with (or an empty tuple) and the second member, which can also be accessed through the &lt;code&gt;kwargs&lt;/code&gt; property, is any keyword arguments (or an empty dictionary).</source>
          <target state="translated">이 중 하나입니다 &lt;code&gt;None&lt;/code&gt; (모의가 호출되지 않은 경우), 또는 모의가 마지막으로 호출 된 것을 인수. 이것은 튜플의 형태입니다 : &lt;code&gt;args&lt;/code&gt; 속성을 통해 액세스 할 수있는 첫 번째 멤버 는 mock이 호출 한 (또는 빈 튜플) 순서가 지정된 인수이며 두 번째 멤버는이를 통해 액세스 할 수 있습니다. &lt;code&gt;kwargs&lt;/code&gt; 로의 속성은 키워드 인수 (또는 빈 사전)이다.</target>
        </trans-unit>
        <trans-unit id="01e02c69372dc79d00a36b7f2f02229c79989833" translate="yes" xml:space="preserve">
          <source>This is either the string &lt;code&gt;quoted-printable&lt;/code&gt; or &lt;code&gt;base64&lt;/code&gt; depending on the encoding used, or it is a function, in which case you should call the function with a single argument, the Message object being encoded. The function should then set the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header itself to whatever is appropriate.</source>
          <target state="translated">이것은 사용 된 인코딩에 따라 &lt;code&gt;quoted-printable&lt;/code&gt; 거나 인쇄 할 수있는 문자열 이거나 &lt;code&gt;base64&lt;/code&gt; 이거나 함수입니다.이 경우 인코딩되는 Message 객체 인 단일 인수로 함수를 호출해야합니다. 그러면 함수는 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더 자체를 적절한 것으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c6bb8e0c84066f126935cee989b98ba5d876c60f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;BaseSelector.unregister(fileobj)()&lt;/code&gt; followed by &lt;code&gt;BaseSelector.register(fileobj, events, data)()&lt;/code&gt;, except that it can be implemented more efficiently.</source>
          <target state="translated">이는 보다 효율적으로 구현할 수 있다는 점을 제외하고 &lt;code&gt;BaseSelector.unregister(fileobj)()&lt;/code&gt; 뒤에 &lt;code&gt;BaseSelector.register(fileobj, events, data)()&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3319b448c1c6cbefa269d764020c1e9cc96a2779" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;date.fromtimestamp(time.time())&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;date.fromtimestamp(time.time())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa06639c9dada4d0f5953fda0a5c6997357afb40" translate="yes" xml:space="preserve">
          <source>This is equivalent to checking &lt;code&gt;socket.gettimeout() == 0&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;socket.gettimeout() == 0&lt;/code&gt; 확인과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f60b0b66a93a2faa96a56fea405d2e1c3db7f538" translate="yes" xml:space="preserve">
          <source>This is equivalent to defining the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONLEGACYWINDOWSFSENCODING&quot; id=&quot;index-30&quot;&gt;&lt;code&gt;PYTHONLEGACYWINDOWSFSENCODING&lt;/code&gt;&lt;/a&gt; environment variable before launching Python.</source>
          <target state="translated">이는 Python을 시작하기 전에 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONLEGACYWINDOWSFSENCODING&quot; id=&quot;index-30&quot;&gt; &lt;code&gt;PYTHONLEGACYWINDOWSFSENCODING&lt;/code&gt; &lt;/a&gt; 환경 변수 를 정의하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dae21f956e04a558bc35743abc58b55502e439ff" translate="yes" xml:space="preserve">
          <source>This is equivalent to iterating over &lt;em&gt;tests&lt;/em&gt;, calling &lt;a href=&quot;#unittest.TestSuite.addTest&quot;&gt;&lt;code&gt;addTest()&lt;/code&gt;&lt;/a&gt; for each element.</source>
          <target state="translated">이것은 각 요소에 대해 &lt;a href=&quot;#unittest.TestSuite.addTest&quot;&gt; &lt;code&gt;addTest()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;em&gt;tests&lt;/em&gt; 반복 &lt;em&gt;테스트&lt;/em&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46af01db1ebbcf9280ef7a5d2036bb35ee1e92bc" translate="yes" xml:space="preserve">
          <source>This is essentially a wrapper around the &lt;a href=&quot;#fcntl.fcntl&quot;&gt;&lt;code&gt;fcntl()&lt;/code&gt;&lt;/a&gt; locking calls. &lt;em&gt;fd&lt;/em&gt; is the file descriptor (file objects providing a &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method are accepted as well) of the file to lock or unlock, and &lt;em&gt;cmd&lt;/em&gt; is one of the following values:</source>
          <target state="translated">이것은 본질적으로 &lt;a href=&quot;#fcntl.fcntl&quot;&gt; &lt;code&gt;fcntl()&lt;/code&gt; &lt;/a&gt; 잠금 호출을 둘러싼 래퍼 입니다. &lt;em&gt;fd&lt;/em&gt; 는 잠금 또는 잠금 해제 할 파일의 파일 디스크립터 ( &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 메소드를 제공하는 파일 오브젝트 도 허용됨)이며 &lt;em&gt;cmd&lt;/em&gt; 는 다음 값 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1262e4d29623b67080bb0c2cf94682b57cb12bfd" translate="yes" xml:space="preserve">
          <source>This is exact and cannot overflow.</source>
          <target state="translated">이것은 정확하며 넘칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc74c5855f1c0d1c6999828120e71dcfa9e0e308" translate="yes" xml:space="preserve">
          <source>This is exact but may overflow.</source>
          <target state="translated">이것은 정확하지만 넘칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6111a25eb387e271fc95a7e8286968c73da0202" translate="yes" xml:space="preserve">
          <source>This is exact, and cannot overflow. timedelta.seconds and timedelta.microseconds are 0, and date2 + timedelta == date1 after.</source>
          <target state="translated">이것은 정확하며 넘칠 수 없습니다. timedelta.seconds 및 timedelta.microseconds는 0이며 date2 + timedelta == date1 이후입니다.</target>
        </trans-unit>
        <trans-unit id="dcf5c506f0484cee378d4114bf8d9c3d093323cc" translate="yes" xml:space="preserve">
          <source>This is expensive to compute if &lt;a href=&quot;#difflib.SequenceMatcher.get_matching_blocks&quot;&gt;&lt;code&gt;get_matching_blocks()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#difflib.SequenceMatcher.get_opcodes&quot;&gt;&lt;code&gt;get_opcodes()&lt;/code&gt;&lt;/a&gt; hasn&amp;rsquo;t already been called, in which case you may want to try &lt;a href=&quot;#difflib.SequenceMatcher.quick_ratio&quot;&gt;&lt;code&gt;quick_ratio()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#difflib.SequenceMatcher.real_quick_ratio&quot;&gt;&lt;code&gt;real_quick_ratio()&lt;/code&gt;&lt;/a&gt; first to get an upper bound.</source>
          <target state="translated">&lt;a href=&quot;#difflib.SequenceMatcher.get_matching_blocks&quot;&gt; &lt;code&gt;get_matching_blocks()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#difflib.SequenceMatcher.get_opcodes&quot;&gt; &lt;code&gt;get_opcodes()&lt;/code&gt; &lt;/a&gt; 가 아직 호출되지 않은 경우 계산하는 데 비용이 많이 들며 ,이 경우 먼저 상한을 얻기 위해 &lt;a href=&quot;#difflib.SequenceMatcher.quick_ratio&quot;&gt; &lt;code&gt;quick_ratio()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#difflib.SequenceMatcher.real_quick_ratio&quot;&gt; &lt;code&gt;real_quick_ratio()&lt;/code&gt; &lt;/a&gt; 를 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a244913a01960d26b2ef91db13b57007d2d6acc" translate="yes" xml:space="preserve">
          <source>This is how SQLite types are converted to Python types by default:</source>
          <target state="translated">다음은 SQLite 유형이 기본적으로 Python 유형으로 변환되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1b3e8d5208ddfd0f7c07e80cfbdba372f7f6082f" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;code&gt;m.group(g)&lt;/code&gt;. This allows easier access to an individual group from a match:</source>
          <target state="translated">이것은 &lt;code&gt;m.group(g)&lt;/code&gt; 동일합니다 . 이렇게하면 경기에서 개별 그룹에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e19e27afede528b8b1ac1b39ae6eb0b912701ac" translate="yes" xml:space="preserve">
          <source>This is identical to the creation of a normal socket, and will use the same options for creation. Refer to the &lt;a href=&quot;socket#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; documentation for information on creating sockets.</source>
          <target state="translated">이것은 일반 소켓 생성과 동일하며 생성시 동일한 옵션을 사용합니다. &lt;a href=&quot;socket#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 작성에 대한 정보 는 소켓 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="318285d2e289fe33dad1c5808834712129e2974a" translate="yes" xml:space="preserve">
          <source>This is implemented using &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;; see that class&amp;rsquo;s documentation for more powerful ways to manage and communicate with subprocesses.</source>
          <target state="translated">이것은 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; 을&lt;/a&gt; 사용하여 구현됩니다 . 하위 프로세스를 관리하고 통신하는보다 강력한 방법은 해당 클래스의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e38dda8d9da39d64ec212271ef2e75c3501c8100" translate="yes" xml:space="preserve">
          <source>This is like &lt;a href=&quot;#datetime.datetime.now&quot;&gt;&lt;code&gt;now()&lt;/code&gt;&lt;/a&gt;, but returns the current UTC date and time, as a naive &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object. An aware current UTC datetime can be obtained by calling &lt;code&gt;datetime.now(timezone.utc)&lt;/code&gt;. See also &lt;a href=&quot;#datetime.datetime.now&quot;&gt;&lt;code&gt;now()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#datetime.datetime.now&quot;&gt; &lt;code&gt;now()&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 현재 UTC 날짜 및 시간을 순진한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 로 반환 합니다. &lt;code&gt;datetime.now(timezone.utc)&lt;/code&gt; 호출하여 현재 UTC 날짜 시간을 알 수 있습니다 . &lt;a href=&quot;#datetime.datetime.now&quot;&gt; &lt;code&gt;now()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="169690a3743933d399ba7724490b8c5dc773a8be" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;print_exc(limit)&lt;/code&gt; but returns a string instead of printing to a file.</source>
          <target state="translated">이것은 &lt;code&gt;print_exc(limit)&lt;/code&gt; 와 비슷 하지만 파일로 인쇄하는 대신 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="16a6c6328d73a547359435cc278b71a11fcab094" translate="yes" xml:space="preserve">
          <source>This is like calling &lt;a href=&quot;#pathlib.Path.glob&quot;&gt;&lt;code&gt;Path.glob()&lt;/code&gt;&lt;/a&gt; with &amp;ldquo;&lt;code&gt;**/&lt;/code&gt;&amp;rdquo; added in front of the given relative &lt;em&gt;pattern&lt;/em&gt;:</source>
          <target state="translated">이것은 주어진 상대 &lt;em&gt;패턴&lt;/em&gt; 앞에 &amp;ldquo; &lt;code&gt;**/&lt;/code&gt; &amp;rdquo;를 추가 하여 &lt;a href=&quot;#pathlib.Path.glob&quot;&gt; &lt;code&gt;Path.glob()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03a0036c10d923d16a01721d2b94dc096c0c58c8" translate="yes" xml:space="preserve">
          <source>This is like function &lt;a href=&quot;#doctest.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt; above, except that a string containing doctest examples is specified directly, via the &lt;em&gt;src&lt;/em&gt; argument.</source>
          <target state="translated">doctest 예제를 포함하는 문자열이 &lt;em&gt;src&lt;/em&gt; 인수 를 통해 직접 지정된다는 점을 제외하면 위의 함수 &lt;a href=&quot;#doctest.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0e58e2745c0e6f9d952d1bcb528a5a4aef91c49" translate="yes" xml:space="preserve">
          <source>This is most useful for debugging deadlock: this function does not require the deadlocked threads&amp;rsquo; cooperation, and such threads&amp;rsquo; call stacks are frozen for as long as they remain deadlocked. The frame returned for a non-deadlocked thread may bear no relationship to that thread&amp;rsquo;s current activity by the time calling code examines the frame.</source>
          <target state="translated">교착 상태 디버깅에 가장 유용합니다.이 함수는 교착 상태 스레드 협력을 필요로하지 않으며 이러한 스레드의 호출 스택은 교착 상태를 유지하는 한 정지됩니다. 교착 상태가 아닌 스레드에 대해 리턴 된 프레임은 호출 코드가 프레임을 검사 할 때까지 해당 스레드의 현재 활동과 관련이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78939d394c86630532b9214b845b5f630569e297" translate="yes" xml:space="preserve">
          <source>This is nice and fine, but how would one access the additional elements contained in this array? Since the type still only knows about 4 elements, we get errors accessing other elements:</source>
          <target state="translated">이것은 좋고 훌륭하지만 어떻게이 배열에 포함 된 추가 요소에 액세스합니까? 타입은 여전히 ​​4 가지 요소 만 알고 있기 때문에 다른 요소에 액세스하는 중에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1d69acd3115aceb80f8c64013384f31d9c19385" translate="yes" xml:space="preserve">
          <source>This is not a general &amp;ldquo;persistence&amp;rdquo; module. For general persistence and transfer of Python objects through RPC calls, see the modules &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;shelve#module-shelve&quot;&gt;&lt;code&gt;shelve&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt; module exists mainly to support reading and writing the &amp;ldquo;pseudo-compiled&amp;rdquo; code for Python modules of &lt;code&gt;.pyc&lt;/code&gt; files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If you&amp;rsquo;re serializing and de-serializing Python objects, use the &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module instead &amp;ndash; the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal.</source>
          <target state="translated">이것은 일반적인 &quot;지속성&quot;모듈이 아닙니다. RPC 호출을 통한 Python 객체의 일반적인 지속성 및 전송에 대해서는 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;shelve#module-shelve&quot;&gt; &lt;code&gt;shelve&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 . &lt;a href=&quot;#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 모듈은 읽기의 파이썬 모듈에 대한 &quot;의사 컴파일&quot;코드 작성 지원하기 위해 주로 존재 &lt;code&gt;.pyc&lt;/code&gt; 파일을. 따라서 파이썬 관리자는 필요에 따라 마샬 형식을 이전 버전과 호환되지 않는 방식으로 수정할 권리를 보유합니다. Python 객체를 직렬화 및 역 직렬화하는 경우 대신 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오. 성능이 비슷하고 버전 독립성이 보장되며 pickle은 마샬보다 훨씬 넓은 범위의 객체를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="14c34954803449e8b6ca12236775c11a28756231" translate="yes" xml:space="preserve">
          <source>This is not really an opcode. It identifies the dividing line between opcodes which don&amp;rsquo;t use their argument and those that do (&lt;code&gt;&amp;lt; HAVE_ARGUMENT&lt;/code&gt; and &lt;code&gt;&amp;gt;= HAVE_ARGUMENT&lt;/code&gt;, respectively).</source>
          <target state="translated">이것은 실제로 opcode가 아닙니다. 인수를 사용하지 않는 opcode와 사용하지 않는 opcode 사이의 구분선을 식별합니다 (각각 &lt;code&gt;&amp;lt; HAVE_ARGUMENT&lt;/code&gt; 및 &lt;code&gt;&amp;gt;= HAVE_ARGUMENT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8311c7ab3b4f6d1243c8202d9f68fbbacfaddec8" translate="yes" xml:space="preserve">
          <source>This is often the same as &lt;code&gt;obj.__annotations__&lt;/code&gt;. In addition, forward references encoded as string literals are handled by evaluating them in &lt;code&gt;globals&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt; namespaces. If necessary, &lt;code&gt;Optional[t]&lt;/code&gt; is added for function and method annotations if a default value equal to &lt;code&gt;None&lt;/code&gt; is set. For a class &lt;code&gt;C&lt;/code&gt;, return a dictionary constructed by merging all the &lt;code&gt;__annotations__&lt;/code&gt; along &lt;code&gt;C.__mro__&lt;/code&gt; in reverse order.</source>
          <target state="translated">이것은 종종 &lt;code&gt;obj.__annotations__&lt;/code&gt; 와 동일 합니다. 또한 문자열 리터럴로 인코딩 된 정방향 참조는 &lt;code&gt;globals&lt;/code&gt; 및 &lt;code&gt;locals&lt;/code&gt; 네임 스페이스 에서이를 평가하여 처리됩니다 . 필요한 경우, 기본값이 &lt;code&gt;None&lt;/code&gt; 과 같은 경우 함수 및 메소드 어노테이션에 &lt;code&gt;Optional[t]&lt;/code&gt; 이 추가 됩니다. &lt;code&gt;C&lt;/code&gt; 클래스의 경우 모든 &lt;code&gt;__annotations__&lt;/code&gt; 와 &lt;code&gt;C.__mro__&lt;/code&gt; 을 역순 으로 병합하여 생성 된 사전을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="55f456f6150c016abb37654a92afed0dd5930c55" translate="yes" xml:space="preserve">
          <source>This is one of the oldest synchronization primitives in the history of computer science, invented by the early Dutch computer scientist Edsger W. Dijkstra (he used the names &lt;code&gt;P()&lt;/code&gt; and &lt;code&gt;V()&lt;/code&gt; instead of &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이것은 초기 네덜란드 컴퓨터 과학자 Edsger W. Dijkstra가 발명 한 컴퓨터 과학 역사상 가장 오래된 동기화 기본 요소 중 하나입니다 (그는 &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 대신 &lt;code&gt;P()&lt;/code&gt; 및 &lt;code&gt;V()&lt;/code&gt; 라는 이름을 사용했습니다 ).</target>
        </trans-unit>
        <trans-unit id="8ca326cbb935374f0ae3d5c7f95cf7afce128acc" translate="yes" xml:space="preserve">
          <source>This is one of the simplest mechanisms for communication between threads: one thread signals an event and other threads wait for it.</source>
          <target state="translated">이것은 스레드 간 통신을위한 가장 간단한 메커니즘 중 하나입니다. 하나의 스레드는 이벤트를 알리고 다른 스레드는이를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="86ba83444c95b331e504dbbe33363d01f2d21c52" translate="yes" xml:space="preserve">
          <source>This is one of two standard signal handling options; it will simply perform the default function for the signal. For example, on most systems the default action for &lt;code&gt;SIGQUIT&lt;/code&gt; is to dump core and exit, while the default action for &lt;code&gt;SIGCHLD&lt;/code&gt; is to simply ignore it.</source>
          <target state="translated">이것은 두 가지 표준 신호 처리 옵션 중 하나입니다. 단순히 신호의 기본 기능을 수행합니다. 예를 들어, 대부분의 시스템에서 &lt;code&gt;SIGQUIT&lt;/code&gt; 의 기본 조치 는 코어 덤프 및 종료이고 &lt;code&gt;SIGCHLD&lt;/code&gt; 의 기본 조치 는 단순히 무시합니다.</target>
        </trans-unit>
        <trans-unit id="0277b7fe4737cfb83edc05d2ac0b1e99b8eb5b48" translate="yes" xml:space="preserve">
          <source>This is provided so that a custom filename can be provided.</source>
          <target state="translated">사용자 정의 파일 이름을 제공 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="155e858c9f2971e28ff3407e7b9934beb0e04e92" translate="yes" xml:space="preserve">
          <source>This is raised if data is specified for a node which does not support data.</source>
          <target state="translated">데이터를 지원하지 않는 노드에 대해 데이터가 지정된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="51ba11e2172daf21cf5dc1ec1c1df58005922e37" translate="yes" xml:space="preserve">
          <source>This is raised when an unrecognized option is found in the argument list or when an option requiring an argument is given none. The argument to the exception is a string indicating the cause of the error. For long options, an argument given to an option which does not require one will also cause this exception to be raised. The attributes &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;opt&lt;/code&gt; give the error message and related option; if there is no specific option to which the exception relates, &lt;code&gt;opt&lt;/code&gt; is an empty string.</source>
          <target state="translated">인식 할 수없는 옵션이 인수 목록에 있거나 인수가 필요한 옵션이없는 경우에 발생합니다. 예외에 대한 인수는 오류의 원인을 나타내는 문자열입니다. 긴 옵션의 경우 옵션을 요구하지 않는 옵션에 대한 인수도이 예외를 발생시킵니다. &lt;code&gt;msg&lt;/code&gt; 및 &lt;code&gt;opt&lt;/code&gt; 속성 은 오류 메시지 및 관련 옵션을 제공합니다. 예외와 관련된 특정 옵션이 없으면 &lt;code&gt;opt&lt;/code&gt; 는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="76312b639346c9f0ed81f7029a1eb2df8cf32e26" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#email.charset.Charset.header_encode&quot;&gt;&lt;code&gt;header_encode()&lt;/code&gt;&lt;/a&gt; except that the string is fit into maximum line lengths as given by the argument &lt;em&gt;maxlengths&lt;/em&gt;, which must be an iterator: each element returned from this iterator will provide the next maximum line length.</source>
          <target state="translated">문자열이 &lt;em&gt;maxlengths&lt;/em&gt; 인수에 의해 주어진 최대 행 길이에 맞는다는 점을 제외하고 &lt;a href=&quot;#email.charset.Charset.header_encode&quot;&gt; &lt;code&gt;header_encode()&lt;/code&gt; &lt;/a&gt; 와 유사합니다.이 길이 는 반복자 여야합니다.이 반복자에서 리턴 된 각 요소는 다음 최대 행 길이를 제공합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b615c7ad20b9138e70d1eb8b4dc44b2eb332b517" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#opcode-BUILD_MAP_UNPACK&quot;&gt;&lt;code&gt;BUILD_MAP_UNPACK&lt;/code&gt;&lt;/a&gt;, but is used for &lt;code&gt;f(**x, **y, **z)&lt;/code&gt; call syntax. The stack item at position &lt;code&gt;count + 2&lt;/code&gt; should be the corresponding callable &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#opcode-BUILD_MAP_UNPACK&quot;&gt; &lt;code&gt;BUILD_MAP_UNPACK&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;code&gt;f(**x, **y, **z)&lt;/code&gt; 호출 구문에 사용됩니다. 위치 &lt;code&gt;count + 2&lt;/code&gt; 의 스택 항목 은 해당 호출 가능 &lt;code&gt;f&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="520c63df4ff805ac58b532a712ba8836cd814f03" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#opcode-BUILD_TUPLE_UNPACK&quot;&gt;&lt;code&gt;BUILD_TUPLE_UNPACK&lt;/code&gt;&lt;/a&gt;, but is used for &lt;code&gt;f(*x, *y, *z)&lt;/code&gt; call syntax. The stack item at position &lt;code&gt;count + 1&lt;/code&gt; should be the corresponding callable &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#opcode-BUILD_TUPLE_UNPACK&quot;&gt; &lt;code&gt;BUILD_TUPLE_UNPACK&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;code&gt;f(*x, *y, *z)&lt;/code&gt; 호출 구문에 사용됩니다. 위치 &lt;code&gt;count + 1&lt;/code&gt; 의 스택 항목 은 해당 호출 가능 &lt;code&gt;f&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f0f001bdc4e257d8aab7e66c626f10b79ecf0cce" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#opcode-BUILD_TUPLE_UNPACK&quot;&gt;&lt;code&gt;BUILD_TUPLE_UNPACK&lt;/code&gt;&lt;/a&gt;, but pushes a list instead of tuple. Implements iterable unpacking in list displays &lt;code&gt;[*x, *y, *z]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#opcode-BUILD_TUPLE_UNPACK&quot;&gt; &lt;code&gt;BUILD_TUPLE_UNPACK&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 튜플 대신 목록을 푸시합니다. 목록 표시 &lt;code&gt;[*x, *y, *z]&lt;/code&gt; 에서 반복 가능한 압축 풀기를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b3848d91dc2ff50aa1e4c02a35fac1c890e31626" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#opcode-BUILD_TUPLE_UNPACK&quot;&gt;&lt;code&gt;BUILD_TUPLE_UNPACK&lt;/code&gt;&lt;/a&gt;, but pushes a set instead of tuple. Implements iterable unpacking in set displays &lt;code&gt;{*x, *y, *z}&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#opcode-BUILD_TUPLE_UNPACK&quot;&gt; &lt;code&gt;BUILD_TUPLE_UNPACK&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 튜플 대신 세트를 푸시합니다. 세트 디스플레이 &lt;code&gt;{*x, *y, *z}&lt;/code&gt; 에서 반복 가능한 언 패킹을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="8a5ede386bb9b2612cf30934e9da4810b0bc33ed" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt;, but does not split the params from the URL. This should generally be used instead of &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt; if the more recent URL syntax allowing parameters to be applied to each segment of the &lt;em&gt;path&lt;/em&gt; portion of the URL (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2396.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2396&lt;/strong&gt;&lt;/a&gt;) is wanted. A separate function is needed to separate the path segments and parameters. This function returns a 5-item &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 매개 변수를 URL에서 분리하지 않습니다. URL의 &lt;em&gt;경로&lt;/em&gt; 부분 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2396.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2396&lt;/strong&gt;&lt;/a&gt; 참조)의 각 세그먼트에 매개 변수를 적용 할 수있는 최신 URL 구문 이 필요한 경우 일반적으로 &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다 . 경로 세그먼트와 매개 변수를 분리하려면 별도의 기능이 필요합니다. 이 함수는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;tuple이라는 이름&lt;/a&gt; 의 5 개 항목을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="155c14dfe42c8135f201e1eba12ead1b14a1d498" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;sorted(iterable)&lt;/code&gt;, but unlike &lt;a href=&quot;functions#sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt;, this implementation is not stable.</source>
          <target state="translated">이것은 &lt;code&gt;sorted(iterable)&lt;/code&gt; 과 비슷 하지만 &lt;a href=&quot;functions#sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 와 달리이 구현은 안정적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="812a1f27c6c6d735c8d382bf216664f1474b94fa" translate="yes" xml:space="preserve">
          <source>This is similar to the standard library &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt; class called with &lt;code&gt;shell=False&lt;/code&gt; and the list of strings passed as the first argument; however, where &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; takes a single argument which is list of strings, &lt;em&gt;subprocess_exec&lt;/em&gt; takes multiple string arguments.</source>
          <target state="translated">이것은 &lt;code&gt;shell=False&lt;/code&gt; 로 호출 된 표준 라이브러리 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 클래스와 첫 번째 인수로 전달 된 문자열 목록과 유사합니다 . 그러나 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 이 문자열 목록 인 단일 인수를 사용하는 경우 &lt;em&gt;subprocess_exec&lt;/em&gt; 는 여러 문자열 인수를 사용합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b7e21c8133751241f1c19a21ebb0193ee2ef677" translate="yes" xml:space="preserve">
          <source>This is similar to the standard library &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt; class called with &lt;code&gt;shell=True&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;shell=True&lt;/code&gt; 로 호출 된 표준 라이브러리 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 클래스 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="cc5e49afeac866714bcab289ccdfaf9524cbc412" translate="yes" xml:space="preserve">
          <source>This is suited for when your data is discrete, and you don&amp;rsquo;t mind that the median may not be an actual data point.</source>
          <target state="translated">이것은 데이터가 분리 된 경우에 적합하며 중앙값이 실제 데이터 포인트가 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b3510355c1fe9570b7071cc51a3472da435031" translate="yes" xml:space="preserve">
          <source>This is the &lt;a href=&quot;#reprlib.Repr.repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;aRepr&lt;/code&gt;. It returns a string similar to that returned by the built-in function of the same name, but with limits on most sizes.</source>
          <target state="translated">이것은 &lt;code&gt;aRepr&lt;/code&gt; 의 &lt;a href=&quot;#reprlib.Repr.repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 메소드입니다 . 동일한 이름의 내장 함수가 리턴 한 문자열과 유사하지만 대부분의 크기에 제한이있는 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ddba4b7153571fdf5c33ce2d048ae2ec9e729ec1" translate="yes" xml:space="preserve">
          <source>This is the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt; for all policy classes. It provides default implementations for a couple of trivial methods, as well as the implementation of the immutability property, the &lt;a href=&quot;#email.policy.Policy.clone&quot;&gt;&lt;code&gt;clone()&lt;/code&gt;&lt;/a&gt; method, and the constructor semantics.</source>
          <target state="translated">모든 정책 클래스 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스&lt;/a&gt; 입니다. 불변 속성, &lt;a href=&quot;#email.policy.Policy.clone&quot;&gt; &lt;code&gt;clone()&lt;/code&gt; &lt;/a&gt; 메소드 및 생성자 시맨틱 의 구현뿐만 아니라 몇 가지 간단한 메소드에 대한 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d1107a365663105be7dfc2b72bf4a3c2259c5eeb" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;output_charset&lt;/em&gt; attribute if that is not &lt;code&gt;None&lt;/code&gt;, otherwise it is &lt;em&gt;input_charset&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , &lt;em&gt;output_charset&lt;/em&gt; 속성이고 , 그렇지 않으면 &lt;em&gt;input_charset&lt;/em&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a564908887b5551964c19be7d4e0a0b8f3d1b0a1" translate="yes" xml:space="preserve">
          <source>This is the XML file that is going to be manipulated:</source>
          <target state="translated">이것은 조작 될 XML 파일입니다.</target>
        </trans-unit>
        <trans-unit id="7b01232b0fadd275694c8fe9a0cfcf63469b298d" translate="yes" xml:space="preserve">
          <source>This is the base class for all exceptions that the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package can raise. It is derived from the standard &lt;a href=&quot;exceptions#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; class and defines no additional methods.</source>
          <target state="translated">&lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지에서 발생할 수 있는 모든 예외의 기본 클래스입니다 . 표준 &lt;a href=&quot;exceptions#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 클래스 에서 파생되며 추가 메소드를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09a9c78f4b499866988037952e3b3e1103098b3f" translate="yes" xml:space="preserve">
          <source>This is the base class for all registered handlers &amp;mdash; and handles only the simple mechanics of registration.</source>
          <target state="translated">이것은 등록 된 모든 처리기의 기본 클래스이며 단순한 등록 메커니즘 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c702066b03625bc85fc0ff9e93c36c1a9f5f2451" translate="yes" xml:space="preserve">
          <source>This is the base class for all the MIME-specific subclasses of &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt;. Ordinarily you won&amp;rsquo;t create instances specifically of &lt;a href=&quot;#email.mime.base.MIMEBase&quot;&gt;&lt;code&gt;MIMEBase&lt;/code&gt;&lt;/a&gt;, although you could. &lt;a href=&quot;#email.mime.base.MIMEBase&quot;&gt;&lt;code&gt;MIMEBase&lt;/code&gt;&lt;/a&gt; is provided primarily as a convenient base class for more specific MIME-aware subclasses.</source>
          <target state="translated">이것은 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; 의&lt;/a&gt; 모든 MIME 고유의 서브 클래스의 기본 클래스입니다 . 일반적으로 &lt;a href=&quot;#email.mime.base.MIMEBase&quot;&gt; &lt;code&gt;MIMEBase&lt;/code&gt; 에&lt;/a&gt; 대한 인스턴스를 만들지는 않지만 일반적으로 만들 수는 없습니다 . &lt;a href=&quot;#email.mime.base.MIMEBase&quot;&gt; &lt;code&gt;MIMEBase&lt;/code&gt; &lt;/a&gt; 는 기본적으로보다 구체적인 MIME 인식 하위 클래스를위한 편리한 기본 클래스로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="63c3452ed9f479b409885d526d1d2f473fc0b1e6" translate="yes" xml:space="preserve">
          <source>This is the base class for exceptions raised by the &lt;a href=&quot;email.parser#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; class. It is derived from &lt;a href=&quot;#email.errors.MessageError&quot;&gt;&lt;code&gt;MessageError&lt;/code&gt;&lt;/a&gt;. This class is also used internally by the parser used by &lt;a href=&quot;email.headerregistry#module-email.headerregistry&quot;&gt;&lt;code&gt;headerregistry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;email.parser#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; 클래스에서 발생한 예외의 기본 클래스입니다 . &lt;a href=&quot;#email.errors.MessageError&quot;&gt; &lt;code&gt;MessageError&lt;/code&gt; &lt;/a&gt; 에서 파생됩니다 . 이 클래스는 &lt;a href=&quot;email.headerregistry#module-email.headerregistry&quot;&gt; &lt;code&gt;headerregistry&lt;/code&gt; 가&lt;/a&gt; 사용하는 파서에서도 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="12d993cc451ecc15f464dda6a51ac3528a894f72" translate="yes" xml:space="preserve">
          <source>This is the base class for the other SAX exception classes.</source>
          <target state="translated">이것은 다른 SAX 예외 클래스의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="54578a7a3c812d9e6bd0a1b7b8c51329ad6f90a7" translate="yes" xml:space="preserve">
          <source>This is the base class of all warning category classes. It is a subclass of &lt;a href=&quot;exceptions#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 모든 경고 범주 클래스의 기본 클래스입니다. &lt;a href=&quot;exceptions#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="63a93b41a0b6373507338eb5d949f5335b6b3ddd" translate="yes" xml:space="preserve">
          <source>This is the base of all AST node classes. The actual node classes are derived from the &lt;code&gt;Parser/Python.asdl&lt;/code&gt; file, which is reproduced &lt;a href=&quot;#abstract-grammar&quot;&gt;below&lt;/a&gt;. They are defined in the &lt;code&gt;_ast&lt;/code&gt; C module and re-exported in &lt;a href=&quot;#module-ast&quot;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 모든 AST 노드 클래스의 기본입니다. 실제 노드 클래스는 &lt;code&gt;Parser/Python.asdl&lt;/code&gt; 파일 에서 파생되며 &lt;a href=&quot;#abstract-grammar&quot;&gt;아래에서&lt;/a&gt; 재현 됩니다 . 그것들은 &lt;code&gt;_ast&lt;/code&gt; C 모듈에 정의되어 있으며 &lt;a href=&quot;#module-ast&quot;&gt; &lt;code&gt;ast&lt;/code&gt; 로&lt;/a&gt; 다시 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="8538deb00176d8d84916528140d7f030e4cc4f43" translate="yes" xml:space="preserve">
          <source>This is the client side:</source>
          <target state="translated">이것은 클라이언트 쪽입니다.</target>
        </trans-unit>
        <trans-unit id="0995326a8a1a9b41b5401cc1a2e33ab049dd8d3d" translate="yes" xml:space="preserve">
          <source>This is the counterpart of &lt;a href=&quot;#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt;. The arguments are an object, a string and an arbitrary value. The string may name an existing attribute or a new attribute. The function assigns the value to the attribute, provided the object allows it. For example, &lt;code&gt;setattr(x, 'foobar', 123)&lt;/code&gt; is equivalent to &lt;code&gt;x.foobar = 123&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 의 대응입니다 . 인수는 객체, 문자열 및 임의의 값입니다. 문자열은 기존 속성 또는 새 속성의 이름을 지정할 수 있습니다. 객체가 허용하는 경우 함수는 값을 속성에 할당합니다. 예를 들어 &lt;code&gt;setattr(x, 'foobar', 123)&lt;/code&gt; 은 &lt;code&gt;x.foobar = 123&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a0dcb8d939a5adb04c7d789dbf2733cb3107c014" translate="yes" xml:space="preserve">
          <source>This is the current standard (STD66). Any changes to urllib.parse module should conform to this. Certain deviations could be observed, which are mostly for backward compatibility purposes and for certain de-facto parsing requirements as commonly observed in major browsers.</source>
          <target state="translated">이것이 현재 표준 (STD66)입니다. urllib.parse 모듈에 대한 모든 변경 사항은이를 준수해야합니다. 특정 편차는 관찰 될 수 있는데, 이는 대부분 이전 버전과의 호환성 목적과 주요 브라우저에서 일반적으로 관찰되는 사실상의 파싱 요구 사항에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="66c8088759f9087b738e1b70d1cf37c8a1aae852" translate="yes" xml:space="preserve">
          <source>This is the default format.</source>
          <target state="translated">이것이 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="38e2d748255fc3c02a104699832e8769048dc2cf" translate="yes" xml:space="preserve">
          <source>This is the entry point you will normally use. It accepts editing keystrokes until one of the termination keystrokes is entered. If &lt;em&gt;validator&lt;/em&gt; is supplied, it must be a function. It will be called for each keystroke entered with the keystroke as a parameter; command dispatch is done on the result. This method returns the window contents as a string; whether blanks in the window are included is affected by the &lt;a href=&quot;#curses.textpad.Textbox.stripspaces&quot;&gt;&lt;code&gt;stripspaces&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">이것이 일반적으로 사용하는 진입 점입니다. 종료 키 입력 중 하나를 입력 할 때까지 키 입력 편집을 허용합니다. 경우 &lt;em&gt;유효성 검사기가&lt;/em&gt; 공급되고,이 함수해야합니다. 키 입력을 매개 변수로 입력 한 각 키 입력에 대해 호출됩니다. 명령 디스패치가 결과에서 수행됩니다. 이 메소드는 창 내용을 문자열로 리턴합니다. 창의 공백이 포함되는지 여부는 &lt;a href=&quot;#curses.textpad.Textbox.stripspaces&quot;&gt; &lt;code&gt;stripspaces&lt;/code&gt; &lt;/a&gt; 속성의 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="79959507c8268ef58c50a5dc61525d5211978203" translate="yes" xml:space="preserve">
          <source>This is the factory used by &lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicy&lt;/code&gt;&lt;/a&gt; by default. &lt;code&gt;HeaderRegistry&lt;/code&gt; builds the class used to create a header instance dynamically, using &lt;em&gt;base_class&lt;/em&gt; and a specialized class retrieved from a registry that it holds. When a given header name does not appear in the registry, the class specified by &lt;em&gt;default_class&lt;/em&gt; is used as the specialized class. When &lt;em&gt;use_default_map&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), the standard mapping of header names to classes is copied in to the registry during initialization. &lt;em&gt;base_class&lt;/em&gt; is always the last class in the generated class&amp;rsquo;s &lt;code&gt;__bases__&lt;/code&gt; list.</source>
          <target state="translated">이것은 기본적 으로 &lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicy&lt;/code&gt; 에서&lt;/a&gt; 사용되는 팩토리 입니다. &lt;code&gt;HeaderRegistry&lt;/code&gt; 는 &lt;em&gt;base_class&lt;/em&gt; 및 보유한 레지스트리에서 검색된 특수 클래스를 사용하여 헤더 인스턴스를 동적으로 작성하는 데 사용되는 클래스를 빌드합니다 . 지정된 헤더 이름이 레지스트리에 나타나지 않으면 &lt;em&gt;default_class&lt;/em&gt; 로 지정된 클래스가 특수 클래스로 사용됩니다. 때 &lt;em&gt;use_default_map가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; (기본값), 클래스 헤더 이름의 표준 매핑은 초기화하는 동안 레지스트리에 복사됩니다. &lt;em&gt;base_class&lt;/em&gt; 는 항상 생성 된 클래스의 &lt;code&gt;__bases__&lt;/code&gt; 목록 에서 마지막 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="051f8529efd087892a2a4ff0d6f02ba8048fe846" translate="yes" xml:space="preserve">
          <source>This is the full module API reference&amp;mdash;for an overview and introduction, see &lt;a href=&quot;https://docs.python.org/3.8/howto/ipaddress.html#ipaddress-howto&quot;&gt;An introduction to the ipaddress module&lt;/a&gt;.</source>
          <target state="translated">이것은 전체 모듈 API 참조입니다. 개요 및 소개 &lt;a href=&quot;https://docs.python.org/3.8/howto/ipaddress.html#ipaddress-howto&quot;&gt;는 ipaddress 모듈 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27cb2703cef928a010aa684a1cb6a3321bec9d97" translate="yes" xml:space="preserve">
          <source>This is the full set of data types supported by XML-RPC. Method calls may also raise a special &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt;&lt;code&gt;Fault&lt;/code&gt;&lt;/a&gt; instance, used to signal XML-RPC server errors, or &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt;&lt;code&gt;ProtocolError&lt;/code&gt;&lt;/a&gt; used to signal an error in the HTTP/HTTPS transport layer. Both &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt;&lt;code&gt;Fault&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt;&lt;code&gt;ProtocolError&lt;/code&gt;&lt;/a&gt; derive from a base class called &lt;code&gt;Error&lt;/code&gt;. Note that the xmlrpc client module currently does not marshal instances of subclasses of built-in types.</source>
          <target state="translated">XML-RPC가 지원하는 전체 데이터 유형입니다. 또한 메소드 호출은 XML-RPC 서버 오류를 알리는 데 사용되는 특수 &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt; &lt;code&gt;Fault&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 HTTP / HTTPS 전송 계층의 오류를 알리는 데 사용되는 &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt; &lt;code&gt;ProtocolError&lt;/code&gt; &lt;/a&gt; 를 발생시킬 수 있습니다. &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt; &lt;code&gt;Fault&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt; &lt;code&gt;ProtocolError&lt;/code&gt; 는&lt;/a&gt; 모두 &lt;code&gt;Error&lt;/code&gt; 라는 기본 클래스에서 파생됩니다 . xmlrpc 클라이언트 모듈은 현재 내장 유형의 서브 클래스 인스턴스를 마샬링하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d83bc29fd516747de82e555ef075ed666ec7ae21" translate="yes" xml:space="preserve">
          <source>This is the inverse function of &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;. Its argument is the &lt;a href=&quot;#time.struct_time&quot;&gt;&lt;code&gt;struct_time&lt;/code&gt;&lt;/a&gt; or full 9-tuple (since the dst flag is needed; use &lt;code&gt;-1&lt;/code&gt; as the dst flag if it is unknown) which expresses the time in &lt;em&gt;local&lt;/em&gt; time, not UTC. It returns a floating point number, for compatibility with &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt;. If the input value cannot be represented as a valid time, either &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised (which depends on whether the invalid value is caught by Python or the underlying C libraries). The earliest date for which it can generate a time is platform-dependent.</source>
          <target state="translated">이것은 &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 의 역함수 입니다. 인수는 &lt;a href=&quot;#time.struct_time&quot;&gt; &lt;code&gt;struct_time&lt;/code&gt; &lt;/a&gt; 또는 전체 9- 튜플 (dst 플래그가 필요하기 때문에 알 수없는 경우 dst 플래그로 &lt;code&gt;-1&lt;/code&gt; 사용 )이므로 UTC가 아닌 &lt;em&gt;현지&lt;/em&gt; 시간으로 시간을 표시합니다 . &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 과의 호환성을 위해 부동 소수점 숫자를 반환합니다 . 입력 값을 유효한 시간으로 표현할 수 없으면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 (Python 또는 기본 C 라이브러리에서 유효하지 않은 값을 잡는 지 여부에 따라 다름). 시간을 생성 할 수있는 가장 빠른 날짜는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="25952ff7c192298062c7c94fb2fb49d4252ac899" translate="yes" xml:space="preserve">
          <source>This is the inverse of &lt;a href=&quot;#datetime.date.fromisoformat&quot;&gt;&lt;code&gt;date.fromisoformat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#datetime.date.fromisoformat&quot;&gt; &lt;code&gt;date.fromisoformat()&lt;/code&gt; &lt;/a&gt; 의 역입니다 .</target>
        </trans-unit>
        <trans-unit id="45477d6b414816ee23b1e85292dcc9da8541a2e5" translate="yes" xml:space="preserve">
          <source>This is the inverse of &lt;a href=&quot;#datetime.date.isoformat&quot;&gt;&lt;code&gt;date.isoformat()&lt;/code&gt;&lt;/a&gt;. It only supports the format &lt;code&gt;YYYY-MM-DD&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#datetime.date.isoformat&quot;&gt; &lt;code&gt;date.isoformat()&lt;/code&gt; &lt;/a&gt; 의 반대입니다 . &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 형식 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="cf97c2d88f89ba640b2d05161edb12e8643013b9" translate="yes" xml:space="preserve">
          <source>This is the main callback interface in SAX, and the one most important to applications. The order of events in this interface mirrors the order of the information in the document.</source>
          <target state="translated">이것은 SAX의 기본 콜백 인터페이스이며 응용 프로그램에 가장 중요한 인터페이스입니다. 이 인터페이스의 이벤트 순서는 문서의 정보 순서를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="25c2af90efa3d54dc8077cc4e5001b757ee862ce" translate="yes" xml:space="preserve">
          <source>This is the name that could be used for performing a PTR lookup, not the resolved hostname itself.</source>
          <target state="translated">이 이름은 확인 된 호스트 이름 자체가 아니라 PTR 조회를 수행하는 데 사용할 수있는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="387c82f524a84cb4d970741adb7a53c2b55ca754" translate="yes" xml:space="preserve">
          <source>This is the object passed to the constructor&amp;rsquo;s &lt;em&gt;template&lt;/em&gt; argument. In general, you shouldn&amp;rsquo;t change it, but read-only access is not enforced.</source>
          <target state="translated">생성자의 &lt;em&gt;템플릿&lt;/em&gt; 인수에 전달 된 객체 입니다. 일반적으로 변경해서는 안되지만 읽기 전용 액세스는 적용되지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
