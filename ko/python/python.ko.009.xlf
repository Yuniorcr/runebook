<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="4fd668988fb53bd9a053b46077c87d876ac3dd0c" translate="yes" xml:space="preserve">
          <source>EHLO</source>
          <target state="translated">EHLO</target>
        </trans-unit>
        <trans-unit id="b5f455d3e9fdf793b9ed474569d144a430f4fed1" translate="yes" xml:space="preserve">
          <source>EOF is signaled with a &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; value;</source>
          <target state="translated">EOF는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 값으로 시그널링됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c49f83b052d9fd32537298873b9355036344465" translate="yes" xml:space="preserve">
          <source>EOF is signaled with an empty string (&lt;code&gt;''&lt;/code&gt;);</source>
          <target state="translated">EOF는 빈 문자열 ( &lt;code&gt;''&lt;/code&gt; )로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7b9e6e531c95a34720d1a8d1d5a2c5f1c560afeb" translate="yes" xml:space="preserve">
          <source>EOFError</source>
          <target state="translated">EOFError</target>
        </trans-unit>
        <trans-unit id="8664dc00e7190b6b4bc1b4c25bf22f56acbe19cd" translate="yes" xml:space="preserve">
          <source>EXPN</source>
          <target state="translated">EXPN</target>
        </trans-unit>
        <trans-unit id="3f257ef4deeb38d39d7c23f398e671c79834f42f" translate="yes" xml:space="preserve">
          <source>Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. Example:</source>
          <target state="translated">각 클래스는 직계 서브 클래스에 대한 약한 참조 목록을 유지합니다. 이 메소드는 여전히 존재하는 모든 참조 목록을 리턴합니다. 예:</target>
        </trans-unit>
        <trans-unit id="49b3d8c715909f41cc320395540e3e23f0c84cef" translate="yes" xml:space="preserve">
          <source>Each codec has to define four interfaces to make it usable as codec in Python: stateless encoder, stateless decoder, stream reader and stream writer. The stream reader and writers typically reuse the stateless encoder/decoder to implement the file protocols. Codec authors also need to define how the codec will handle encoding and decoding errors.</source>
          <target state="translated">각 코덱은 파이썬에서 코덱으로 사용할 수 있도록 상태 비 저장 인코더, 상태 비 저장 디코더, 스트림 판독기 및 스트림 기록기의 네 가지 인터페이스를 정의해야합니다. 스트림 리더 및 기록기는 일반적으로 상태 비 저장 인코더 / 디코더를 재사용하여 파일 프로토콜을 구현합니다. 코덱 작성자도 코덱에서 인코딩 및 디코딩 오류를 처리하는 방법을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="282f17f731792f16d9273e6a347f472556b09b25" translate="yes" xml:space="preserve">
          <source>Each command returns a tuple: &lt;code&gt;(type, [data, ...])&lt;/code&gt; where &lt;em&gt;type&lt;/em&gt; is usually &lt;code&gt;'OK'&lt;/code&gt; or &lt;code&gt;'NO'&lt;/code&gt;, and &lt;em&gt;data&lt;/em&gt; is either the text from the command response, or mandated results from the command. Each &lt;em&gt;data&lt;/em&gt; is either a string, or a tuple. If a tuple, then the first part is the header of the response, and the second part contains the data (ie: &amp;lsquo;literal&amp;rsquo; value).</source>
          <target state="translated">각 명령은 tuple : &lt;code&gt;(type, [data, ...])&lt;/code&gt; 반환합니다. 여기서 &lt;em&gt;type&lt;/em&gt; 은 일반적으로 &lt;code&gt;'OK'&lt;/code&gt; 또는 &lt;code&gt;'NO'&lt;/code&gt; 이며 &lt;em&gt;data&lt;/em&gt; 는 명령 응답의 텍스트이거나 명령의 명령 결과입니다. 각 &lt;em&gt;데이터&lt;/em&gt; 는 문자열 또는 튜플입니다. 튜플 인 경우 첫 번째 부분은 응답의 머리글이고 두 번째 부분은 데이터 (예 : 'literal'값)를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b1fc694bb45d480ca1940a2e1064ce8c21ebc647" translate="yes" xml:space="preserve">
          <source>Each concrete class has an attribute &lt;a href=&quot;#ast.AST._fields&quot;&gt;&lt;code&gt;_fields&lt;/code&gt;&lt;/a&gt; which gives the names of all child nodes.</source>
          <target state="translated">각 구체적 클래스에는 모든 하위 노드의 이름을 제공하는 &lt;a href=&quot;#ast.AST._fields&quot;&gt; &lt;code&gt;_fields&lt;/code&gt; &lt;/a&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a50347d1587b9181be5b21c8a4401ebdc590f5" translate="yes" xml:space="preserve">
          <source>Each element of &lt;em&gt;pathsegments&lt;/em&gt; can be either a string representing a path segment, an object implementing the &lt;a href=&quot;os#os.PathLike&quot;&gt;&lt;code&gt;os.PathLike&lt;/code&gt;&lt;/a&gt; interface which returns a string, or another path object:</source>
          <target state="translated">각 요소 &lt;em&gt;pathsegments는&lt;/em&gt; 경로 세그먼트는 구현 객체를 나타내는 문자열, &lt;a href=&quot;os#os.PathLike&quot;&gt; &lt;code&gt;os.PathLike&lt;/code&gt; 의&lt;/a&gt; 캐릭터 또는 다른 경로 객체를 반환 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="7d47bd7e76e37961a2c232d0d7b5ad58b1d23e40" translate="yes" xml:space="preserve">
          <source>Each element of the sequences returned by &lt;a href=&quot;#parser.st2list&quot;&gt;&lt;code&gt;st2list()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#parser.st2tuple&quot;&gt;&lt;code&gt;st2tuple()&lt;/code&gt;&lt;/a&gt; has a simple form. Sequences representing non-terminal elements in the grammar always have a length greater than one. The first element is an integer which identifies a production in the grammar. These integers are given symbolic names in the C header file &lt;code&gt;Include/graminit.h&lt;/code&gt; and the Python module &lt;a href=&quot;symbol#module-symbol&quot;&gt;&lt;code&gt;symbol&lt;/code&gt;&lt;/a&gt;. Each additional element of the sequence represents a component of the production as recognized in the input string: these are always sequences which have the same form as the parent. An important aspect of this structure which should be noted is that keywords used to identify the parent node type, such as the keyword &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; in an &lt;code&gt;if_stmt&lt;/code&gt;, are included in the node tree without any special treatment. For example, the &lt;code&gt;if&lt;/code&gt; keyword is represented by the tuple &lt;code&gt;(1, 'if')&lt;/code&gt;, where &lt;code&gt;1&lt;/code&gt; is the numeric value associated with all &lt;code&gt;NAME&lt;/code&gt; tokens, including variable and function names defined by the user. In an alternate form returned when line number information is requested, the same token might be represented as &lt;code&gt;(1, 'if', 12)&lt;/code&gt;, where the &lt;code&gt;12&lt;/code&gt; represents the line number at which the terminal symbol was found.</source>
          <target state="translated">&lt;a href=&quot;#parser.st2list&quot;&gt; &lt;code&gt;st2list()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#parser.st2tuple&quot;&gt; &lt;code&gt;st2tuple()&lt;/code&gt; &lt;/a&gt; 의해 리턴되는 시퀀스의 각 요소 는 간단한 형식을 갖습니다. 문법에서 비 터미널 요소를 나타내는 시퀀스의 길이는 항상 1보다 큽니다. 첫 번째 요소는 문법에서 생산을 식별하는 정수입니다. 이 정수는 C 헤더 파일 &lt;code&gt;Include/graminit.h&lt;/code&gt; 및 Python 모듈 &lt;a href=&quot;symbol#module-symbol&quot;&gt; &lt;code&gt;symbol&lt;/code&gt; 에&lt;/a&gt; 기호 이름이 지정 됩니다. 시퀀스의 각 추가 요소는 입력 문자열에서 인식되는 프로덕션 구성 요소를 나타냅니다. 이들은 항상 부모와 동일한 형식의 시퀀스입니다. 주목해야이 구조의 중요한 부분은 키워드와 부모 노드의 타입을 식별하기 위해 사용 된 키워드 인 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;if_stmt&lt;/code&gt; 는 특별한 처리없이 노드 트리에 포함됩니다. 예를 들어 &lt;code&gt;if&lt;/code&gt; 키워드는 튜플 &lt;code&gt;(1, 'if')&lt;/code&gt; 로 표시되며, 여기서 &lt;code&gt;1&lt;/code&gt; 은 사용자가 정의한 변수 및 함수 이름을 포함하여 모든 &lt;code&gt;NAME&lt;/code&gt; 토큰 과 연관된 숫자 값 입니다. 행 번호 정보가 요청 될 때 리턴되는 대체 양식에서 동일한 토큰은 &lt;code&gt;(1, 'if', 12)&lt;/code&gt; 로 표시 될 수 있습니다 . 여기서 &lt;code&gt;12&lt;/code&gt; 는 터미널 기호가 발견 된 행 번호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fbbb92dbc3b8b3f3d23474fa6aec35d50a033430" translate="yes" xml:space="preserve">
          <source>Each instance maintains a stack of registered callbacks that are called in reverse order when the instance is closed (either explicitly or implicitly at the end of a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement). Note that callbacks are &lt;em&gt;not&lt;/em&gt; invoked implicitly when the context stack instance is garbage collected.</source>
          <target state="translated">각 인스턴스는 인스턴스가 닫힐 때 ( &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 끝에서 명시 적 또는 암시 적으로) 역순으로 호출되는 등록 된 콜백 스택을 유지 관리합니다 . 컨텍스트 스택 인스턴스가 가비지 수집 될 때 콜백은 암시 적으로 호출 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8de95ec9ac0b515be6306a38072974d2399457c5" translate="yes" xml:space="preserve">
          <source>Each instance of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; will run a single base method: the method named &lt;em&gt;methodName&lt;/em&gt;. In most uses of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt;, you will neither change the &lt;em&gt;methodName&lt;/em&gt; nor reimplement the default &lt;code&gt;runTest()&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; 의&lt;/a&gt; 각 인스턴스는 단일 기본 메소드 인 &lt;em&gt;methodName&lt;/em&gt; 이라는 메소드를 실행합니다 . 대부분의 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 사용에서는 &lt;em&gt;methodName을&lt;/em&gt; 변경 하거나 기본 &lt;code&gt;runTest()&lt;/code&gt; 메소드를 다시 구현하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d4adfaccfd02783f72f1bf5a8a740336421c2115" translate="yes" xml:space="preserve">
          <source>Each instance of a concrete class has one attribute for each child node, of the type as defined in the grammar. For example, &lt;code&gt;ast.BinOp&lt;/code&gt; instances have an attribute &lt;code&gt;left&lt;/code&gt; of type &lt;code&gt;ast.expr&lt;/code&gt;.</source>
          <target state="translated">구체적 클래스의 각 인스턴스에는 각 하위 노드에 대해 문법에 정의 된 유형의 속성이 하나씩 있습니다. 예를 들어, &lt;code&gt;ast.BinOp&lt;/code&gt; 의 인스턴스는 속성이 &lt;code&gt;left&lt;/code&gt; 타입의 &lt;code&gt;ast.expr&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="13ea0b080ba9b453721cead18f47d5cd873c0211" translate="yes" xml:space="preserve">
          <source>Each item also has a list of tags, which can be used to associate event bindings with individual items and control the appearance of the item.</source>
          <target state="translated">각 항목에는 이벤트 바인딩을 개별 항목과 연관시키고 항목의 모양을 제어하는 ​​데 사용할 수있는 태그 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e44e01ec262fcc06e2c821c79bd1b985a39335e0" translate="yes" xml:space="preserve">
          <source>Each item in the list will be a string which is the value of the &lt;code&gt;charset&lt;/code&gt; parameter in the &lt;em&gt;Content-Type&lt;/em&gt; header for the represented subpart. However, if the subpart has no &lt;em&gt;Content-Type&lt;/em&gt; header, no &lt;code&gt;charset&lt;/code&gt; parameter, or is not of the &lt;em&gt;text&lt;/em&gt; main MIME type, then that item in the returned list will be &lt;em&gt;failobj&lt;/em&gt;.</source>
          <target state="translated">목록의 각 항목은 표시된 &lt;code&gt;charset&lt;/code&gt; 에 대한 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 의 charset 매개 변수 값인 문자열입니다 . 그러나 &lt;em&gt;서브 파트에 &lt;/em&gt;&lt;em&gt;Content-Type&lt;/em&gt; 헤더가 없거나 &lt;code&gt;charset&lt;/code&gt; 매개 변수가 없거나 &lt;em&gt;텍스트&lt;/em&gt; 기본 MIME 유형 이 아닌 경우 리턴 된 목록의 해당 항목은 &lt;em&gt;failobj&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf9f8e6f669080eee75ae9dc5a75b7bbd4c47d81" translate="yes" xml:space="preserve">
          <source>Each item in the list will be a string which is the value of the &lt;code&gt;charset&lt;/code&gt; parameter in the &lt;em&gt;Content-Type&lt;/em&gt; header for the represented subpart. If the subpart has no &lt;em&gt;Content-Type&lt;/em&gt; header, no &lt;code&gt;charset&lt;/code&gt; parameter, or is not of the &lt;em&gt;text&lt;/em&gt; main MIME type, then that item in the returned list will be &lt;em&gt;failobj&lt;/em&gt;.</source>
          <target state="translated">목록의 각 항목은 표시된 &lt;code&gt;charset&lt;/code&gt; 에 대한 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 의 charset 매개 변수 값인 문자열입니다 . 하부 파트로 더가없는 경우 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더, 아니 &lt;code&gt;charset&lt;/code&gt; 파라미터를, 또는이 아닌 &lt;em&gt;텍스트&lt;/em&gt; 의 주요 MIME 타입, 다음 반환 된 목록에서 해당 항목이 될 것입니다 &lt;em&gt;failobj을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="da0ee9fd3f992367055d3f5837dcc4a138a402ce" translate="yes" xml:space="preserve">
          <source>Each item in this tuple contains further information about a parameter, it must be a tuple containing one, two, or three items.</source>
          <target state="translated">이 튜플의 각 항목에는 매개 변수에 대한 추가 정보가 포함되며 1, 2 또는 3 개의 항목을 포함하는 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="77e53c8c02a8a57ebc4ed20d807d943b6ff96866" translate="yes" xml:space="preserve">
          <source>Each item is identified by a unique name. The widget will generate item IDs if they are not supplied by the caller. There is a distinguished root item, named &lt;code&gt;{}&lt;/code&gt;. The root item itself is not displayed; its children appear at the top level of the hierarchy.</source>
          <target state="translated">각 항목은 고유 한 이름으로 식별됩니다. 호출자가 제공하지 않으면 위젯은 항목 ID를 생성합니다. &lt;code&gt;{}&lt;/code&gt; 라는 구별 된 루트 항목이 있습니다 . 루트 항목 자체는 표시되지 않습니다. 하위는 계층 구조의 최상위 수준에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4bce3597203de7edee0f57b19d4a2d5cbffdf95e" translate="yes" xml:space="preserve">
          <source>Each item should have the same number of values as the widget option columns. If there are fewer values than columns, the remaining values are assumed empty. If there are more values than columns, the extra values are ignored.</source>
          <target state="translated">각 항목은 위젯 옵션 열과 동일한 수의 값을 가져야합니다. 열보다 적은 값이 있으면 나머지 값은 비어 있다고 가정합니다. 열보다 많은 값이 있으면 추가 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e78be99b38a7a6e8f05f339ced460b87f7c2eaf4" translate="yes" xml:space="preserve">
          <source>Each iteration yields a tuple as specified by the format string.</source>
          <target state="translated">각 반복은 형식 문자열에 지정된대로 튜플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2f826346b31818133756fc3c73c82e215e0c9cf5" translate="yes" xml:space="preserve">
          <source>Each key in &lt;em&gt;kw&lt;/em&gt; is an option and each value is a string identifying the value for that option.</source>
          <target state="translated">&lt;em&gt;kw의&lt;/em&gt; 각 키 는 옵션이며 각 값은 해당 옵션의 값을 식별하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="39b11157702a1c985e2f006a001b5fee4627520f" translate="yes" xml:space="preserve">
          <source>Each key in &lt;em&gt;kw&lt;/em&gt; is an option and each value should be a list or a tuple (usually) containing statespecs grouped in tuples, lists, or some other preference. A statespec is a compound of one or more states and then a value.</source>
          <target state="translated">&lt;em&gt;kw의&lt;/em&gt; 각 키 는 옵션이며 각 값은 목록 또는 튜플, 목록 또는 기타 기본 설정으로 그룹화 된 상태 사양을 포함하는 튜플 (일반적으로)이어야합니다. statespec은 하나 이상의 상태를 혼합 한 다음 값입니다.</target>
        </trans-unit>
        <trans-unit id="3e8597bf6453e280e6bc0fb06128abdc83d25df7" translate="yes" xml:space="preserve">
          <source>Each key in &lt;em&gt;settings&lt;/em&gt; is a style and each value may contain the keys &amp;lsquo;configure&amp;rsquo;, &amp;lsquo;map&amp;rsquo;, &amp;lsquo;layout&amp;rsquo; and &amp;lsquo;element create&amp;rsquo; and they are expected to have the same format as specified by the methods &lt;a href=&quot;#tkinter.ttk.Style.configure&quot;&gt;&lt;code&gt;Style.configure()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.ttk.Style.map&quot;&gt;&lt;code&gt;Style.map()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.ttk.Style.layout&quot;&gt;&lt;code&gt;Style.layout()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Style.element_create&quot;&gt;&lt;code&gt;Style.element_create()&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;em&gt;설정의&lt;/em&gt; 각 키 는 스타일이며 각 값에는 'configure', 'map', 'layout'및 'element create'키가 포함될 수 있으며 &lt;a href=&quot;#tkinter.ttk.Style.configure&quot;&gt; &lt;code&gt;Style.configure()&lt;/code&gt; &lt;/a&gt; 메소드에서 지정한 것과 동일한 형식을 갖습니다 . &lt;a href=&quot;#tkinter.ttk.Style.map&quot;&gt; &lt;code&gt;Style.map()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.ttk.Style.layout&quot;&gt; &lt;code&gt;Style.layout()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Style.element_create&quot;&gt; &lt;code&gt;Style.element_create()&lt;/code&gt; &lt;/a&gt; 각각</target>
        </trans-unit>
        <trans-unit id="87388fd6d132977913179af099110ca3324339a0" translate="yes" xml:space="preserve">
          <source>Each line of a &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ&lt;/code&gt;&lt;/a&gt; delta begins with a two-letter code:</source>
          <target state="translated">&lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ&lt;/code&gt; &lt;/a&gt; 델타 의 각 줄은 두 글자 코드로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e42a08c19ff6f318b0b306e48a39eabc2c06f3ef" translate="yes" xml:space="preserve">
          <source>Each line of the traceback stack (if present) must be indented further than the first line of the example, &lt;em&gt;or&lt;/em&gt; start with a non-alphanumeric character. The first line following the traceback header indented the same and starting with an alphanumeric is taken to be the start of the exception detail. Of course this does the right thing for genuine tracebacks.</source>
          <target state="translated">역 추적 스택의 각 행 (있는 경우)은 예제의 첫 번째 행보다 들여 쓰기 &lt;em&gt;되거나&lt;/em&gt; 영숫자가 아닌 문자로 시작해야합니다. 역 추적 헤더 다음에 오는 첫 행은 동일하게 들여 쓰기되고 영숫자로 시작하는 예외 세부 사항의 시작으로 간주됩니다. 물론 이것은 진정한 역 추적에 올바른 일을합니다.</target>
        </trans-unit>
        <trans-unit id="966983a00fbe34b47c3c999bd9e9a31fd05e66a8" translate="yes" xml:space="preserve">
          <source>Each module in the &lt;a href=&quot;#module-test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; package whose name starts with &lt;code&gt;test_&lt;/code&gt; is a testing suite for a specific module or feature. All new tests should be written using the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; module. Some older tests are written using a &amp;ldquo;traditional&amp;rdquo; testing style that compares output printed to &lt;code&gt;sys.stdout&lt;/code&gt;; this style of test is considered deprecated.</source>
          <target state="translated">이름이 &lt;code&gt;test_&lt;/code&gt; 로 시작 하는 &lt;a href=&quot;#module-test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 패키지의 각 모듈은 특정 모듈 또는 기능에 대한 테스트 스위트입니다. 모든 새로운 테스트는 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 작성해야합니다 . 일부 오래된 테스트는 &lt;code&gt;sys.stdout&lt;/code&gt; 에 인쇄 된 출력을 비교하는 &quot;전통적인&quot;테스트 스타일을 사용하여 작성됩니다 . 이 스타일의 테스트는 더 이상 사용되지 않는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="570d43e41fd016220171b8d9766922e2767c092c" translate="yes" xml:space="preserve">
          <source>Each of the authentication methods supported by &lt;a href=&quot;#module-smtplib&quot;&gt;&lt;code&gt;smtplib&lt;/code&gt;&lt;/a&gt; are tried in turn if they are advertised as supported by the server. See &lt;a href=&quot;#smtplib.SMTP.auth&quot;&gt;&lt;code&gt;auth()&lt;/code&gt;&lt;/a&gt; for a list of supported authentication methods. &lt;em&gt;initial_response_ok&lt;/em&gt; is passed through to &lt;a href=&quot;#smtplib.SMTP.auth&quot;&gt;&lt;code&gt;auth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-smtplib&quot;&gt; &lt;code&gt;smtplib&lt;/code&gt; 에서&lt;/a&gt; 지원하는 각 인증 방법 은 서버에서 지원하는 것으로 보급되면 차례로 시도됩니다. 지원되는 인증 방법 목록은 &lt;a href=&quot;#smtplib.SMTP.auth&quot;&gt; &lt;code&gt;auth()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . &lt;em&gt;initial_response_ok&lt;/em&gt; 가 &lt;a href=&quot;#smtplib.SMTP.auth&quot;&gt; &lt;code&gt;auth()&lt;/code&gt; &lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0be42f64114c87525015606161dd516884beee6" translate="yes" xml:space="preserve">
          <source>Each of the following constants defines a tar archive format that the &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module is able to create. See section &lt;a href=&quot;#tar-formats&quot;&gt;Supported tar formats&lt;/a&gt; for details.</source>
          <target state="translated">다음 각 상수는 &lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈이 작성할 수 있는 tar 아카이브 형식을 정의합니다 . 자세한 내용은 &lt;a href=&quot;#tar-formats&quot;&gt;지원되는 tar 형식&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8eacfcf105bb64fff8fabb452ae84f33e7ee8ec" translate="yes" xml:space="preserve">
          <source>Each of the methods &lt;a href=&quot;#venv.EnvBuilder.ensure_directories&quot;&gt;&lt;code&gt;ensure_directories()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#venv.EnvBuilder.create_configuration&quot;&gt;&lt;code&gt;create_configuration()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#venv.EnvBuilder.setup_python&quot;&gt;&lt;code&gt;setup_python()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#venv.EnvBuilder.setup_scripts&quot;&gt;&lt;code&gt;setup_scripts()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#venv.EnvBuilder.post_setup&quot;&gt;&lt;code&gt;post_setup()&lt;/code&gt;&lt;/a&gt; can be overridden.</source>
          <target state="translated">방법의 각 &lt;a href=&quot;#venv.EnvBuilder.ensure_directories&quot;&gt; &lt;code&gt;ensure_directories()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#venv.EnvBuilder.create_configuration&quot;&gt; &lt;code&gt;create_configuration()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#venv.EnvBuilder.setup_python&quot;&gt; &lt;code&gt;setup_python()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#venv.EnvBuilder.setup_scripts&quot;&gt; &lt;code&gt;setup_scripts()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#venv.EnvBuilder.post_setup&quot;&gt; &lt;code&gt;post_setup()&lt;/code&gt; &lt;/a&gt; 무시 될 수있다.</target>
        </trans-unit>
        <trans-unit id="7dc6ae0f9750e9fa2a785125e5f9d0d801c4c29a" translate="yes" xml:space="preserve">
          <source>Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed unless the &lt;code&gt;QUOTE_NONNUMERIC&lt;/code&gt; format option is specified (in which case unquoted fields are transformed into floats).</source>
          <target state="translated">csv 파일에서 읽은 각 행은 문자열 목록으로 반환됩니다. &lt;code&gt;QUOTE_NONNUMERIC&lt;/code&gt; 형식 옵션이 지정되지 않은 경우 (인용되지 않은 필드가 부동 소수점으로 변환 됨) 자동 데이터 유형 변환이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="39af9c24f6267667f16c1f8937c3f68cebb65cc8" translate="yes" xml:space="preserve">
          <source>Each scheme is itself composed of a series of paths and each path has a unique identifier. Python currently uses eight paths:</source>
          <target state="translated">각 체계 자체는 일련의 경로로 구성되며 각 경로에는 고유 식별자가 있습니다. 파이썬은 현재 8 가지 경로를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="d6be844de18e8ac1c0c125847ea509ec8672f2af" translate="yes" xml:space="preserve">
          <source>Each sequence must contain individual single-line strings ending with newlines. Such sequences can be obtained from the &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;readlines()&lt;/code&gt;&lt;/a&gt; method of file-like objects. The delta generated also consists of newline-terminated strings, ready to be printed as-is via the &lt;a href=&quot;io#io.IOBase.writelines&quot;&gt;&lt;code&gt;writelines()&lt;/code&gt;&lt;/a&gt; method of a file-like object.</source>
          <target state="translated">각 시퀀스에는 개행으로 끝나는 개별 단일 행 문자열이 포함되어야합니다. 이러한 시퀀스는 파일과 같은 객체 의 &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;readlines()&lt;/code&gt; &lt;/a&gt; 메서드 에서 얻을 수 있습니다 . 생성 된 델타는 줄 바꿈으로 끝나는 문자열로 구성되어 파일과 같은 객체 의 &lt;a href=&quot;io#io.IOBase.writelines&quot;&gt; &lt;code&gt;writelines()&lt;/code&gt; &lt;/a&gt; 메소드를 통해 그대로 인쇄 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6fea372c2e6910286f3770084c74f69f7479d39" translate="yes" xml:space="preserve">
          <source>Each statement in &lt;code&gt;__future__.py&lt;/code&gt; is of the form:</source>
          <target state="translated">&lt;code&gt;__future__.py&lt;/code&gt; 의 각 문장 은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9e29db3d8e94a8e1eddfab4dff35fd962a74e06a" translate="yes" xml:space="preserve">
          <source>Each string is limited to 500 characters.</source>
          <target state="translated">각 문자열은 500 자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="170cfb863712b473cc75fb950f928a5a8285210f" translate="yes" xml:space="preserve">
          <source>Each thread has its own current context which is accessed or changed using the &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decimal.setcontext&quot;&gt;&lt;code&gt;setcontext()&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">각 스레드에는 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.setcontext&quot;&gt; &lt;code&gt;setcontext()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 액세스하거나 변경되는 고유 한 현재 컨텍스트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d777ac10aa65cebbc73a8b54c83325611989663" translate="yes" xml:space="preserve">
          <source>Each time a telnet option is read on the input flow, this &lt;em&gt;callback&lt;/em&gt; (if set) is called with the following parameters: callback(telnet socket, command (DO/DONT/WILL/WONT), option). No other action is done afterwards by telnetlib.</source>
          <target state="translated">입력 흐름에서 텔넷 옵션을 읽을 때마다 콜백 (텔넷 소켓, 명령 (DO / DONT / WILL / WONT), 옵션) 매개 변수를 사용 하여이 &lt;em&gt;콜백&lt;/em&gt; (설정된 경우)이 호출됩니다. telnetlib에 의해 다른 조치는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfad8ccc8a211d61d36409d0bf2f14aa35ee256d" translate="yes" xml:space="preserve">
          <source>Each type variable argument to &lt;a href=&quot;#typing.Generic&quot;&gt;&lt;code&gt;Generic&lt;/code&gt;&lt;/a&gt; must be distinct. This is thus invalid:</source>
          <target state="translated">&lt;a href=&quot;#typing.Generic&quot;&gt; &lt;code&gt;Generic&lt;/code&gt; 에&lt;/a&gt; 대한 각 유형 변수 인수 는 고유해야합니다. 따라서 이것은 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="c84331c7ef4d85ab05cce6fed746ac676d4e101d" translate="yes" xml:space="preserve">
          <source>Each widget in &lt;code&gt;ttk&lt;/code&gt; is assigned a style, which specifies the set of elements making up the widget and how they are arranged, along with dynamic and default settings for element options. By default the style name is the same as the widget&amp;rsquo;s class name, but it may be overridden by the widget&amp;rsquo;s style option. If you don&amp;rsquo;t know the class name of a widget, use the method &lt;code&gt;Misc.winfo_class()&lt;/code&gt; (somewidget.winfo_class()).</source>
          <target state="translated">&lt;code&gt;ttk&lt;/code&gt; 의 각 위젯 에는 스타일이 지정되는데, 이는 위젯을 구성하는 요소 세트와 요소 옵션의 동적 및 기본 설정과 함께 위젯을 구성하는 요소 세트 및 배열 방식을 지정합니다. 기본적으로 스타일 이름은 위젯의 클래스 이름과 동일하지만 위젯의 스타일 옵션으로 대체 될 수 있습니다. 위젯의 클래스 이름을 모르는 경우 &lt;code&gt;Misc.winfo_class()&lt;/code&gt; 메소드 (somewidget.winfo_class ())를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac6958e8c84c43dc505ed0bc0da9c2ae587471df" translate="yes" xml:space="preserve">
          <source>Edge and Level Trigger Polling (epoll) Objects</source>
          <target state="translated">에지 및 레벨 트리거 폴링 (epoll) 오브젝트</target>
        </trans-unit>
        <trans-unit id="5583cdff4d4a6580ea0a38b30db66be0866f671a" translate="yes" xml:space="preserve">
          <source>Edit menu (Shell and Editor)</source>
          <target state="translated">편집 메뉴 (쉘 및 편집기)</target>
        </trans-unit>
        <trans-unit id="185ea171b3d3bde051ea325fee7b199751c8574b" translate="yes" xml:space="preserve">
          <source>Editable text widget for curses supporting &lt;strong&gt;Emacs&lt;/strong&gt;-like bindings.</source>
          <target state="translated">&lt;strong&gt;Emacs&lt;/strong&gt; 와 같은 바인딩을 지원하는 curses를위한 편집 가능한 텍스트 위젯 .</target>
        </trans-unit>
        <trans-unit id="938a52ac689dd4874b63cf940ebb77391725c7d1" translate="yes" xml:space="preserve">
          <source>Editing and navigation</source>
          <target state="translated">편집 및 탐색</target>
        </trans-unit>
        <trans-unit id="90f14ba0b6909fa15eb3284afbcd0982f6764f14" translate="yes" xml:space="preserve">
          <source>Editor windows</source>
          <target state="translated">에디터 창</target>
        </trans-unit>
        <trans-unit id="0efd6762e1cf2a894e742725c6e1de2bd3237193" translate="yes" xml:space="preserve">
          <source>Editor windows also have breakpoint functions. Lines with a breakpoint set are specially marked. Breakpoints only have an effect when running under the debugger. Breakpoints for a file are saved in the user&amp;rsquo;s &lt;code&gt;.idlerc&lt;/code&gt; directory.</source>
          <target state="translated">편집기 창에는 중단 점 기능도 있습니다. 중단 점이 설정된 줄은 특별히 표시됩니다. 중단 점은 디버거에서 실행할 때만 영향을 미칩니다. 파일의 중단 점은 사용자의 &lt;code&gt;.idlerc&lt;/code&gt; 디렉토리에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a9ba193ecdd6f264d6c16c5e8ae467c10e10059" translate="yes" xml:space="preserve">
          <source>Either &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;disabled&amp;rdquo; or &amp;ldquo;hidden&amp;rdquo;. If &amp;ldquo;disabled&amp;rdquo;, then the tab is not selectable. If &amp;ldquo;hidden&amp;rdquo;, then the tab is not shown.</source>
          <target state="translated">&amp;ldquo;정상&amp;rdquo;,&amp;ldquo;비활성화&amp;rdquo;또는&amp;ldquo;숨김&amp;rdquo;입니다. &quot;비활성화&quot;되면 탭을 선택할 수 없습니다. &quot;숨겨진&quot;경우 탭이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abd9d70a96769f378e601ed03a344c72fddacf4f" translate="yes" xml:space="preserve">
          <source>Either &lt;em&gt;action&lt;/em&gt; or &lt;em&gt;delayfunc&lt;/em&gt; can raise an exception. In either case, the scheduler will maintain a consistent state and propagate the exception. If an exception is raised by &lt;em&gt;action&lt;/em&gt;, the event will not be attempted in future calls to &lt;a href=&quot;#sched.scheduler.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어느 &lt;em&gt;행동&lt;/em&gt; 이나 &lt;em&gt;delayfunc는&lt;/em&gt; 예외를 발생시킬 수 있습니다. 두 경우 모두 스케줄러는 일관성있는 상태를 유지하고 예외를 전파합니다. &lt;em&gt;action으로&lt;/em&gt; 예외가 발생하면 나중에 &lt;a href=&quot;#sched.scheduler.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 호출에서 이벤트가 시도되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="85c84f61f57bea218ff74b0e009533443082981e" translate="yes" xml:space="preserve">
          <source>Either escapes special characters (permitting you to match characters like &lt;code&gt;'*'&lt;/code&gt;, &lt;code&gt;'?'&lt;/code&gt;, and so forth), or signals a special sequence; special sequences are discussed below.</source>
          <target state="translated">특수 문자를 이스케이프하거나 ( &lt;code&gt;'*'&lt;/code&gt; , &lt;code&gt;'?'&lt;/code&gt; 등과 같은 문자와 일치하도록 허용 함 ) 특수 시퀀스를 표시합니다. 특별한 순서는 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eee7c7fedc41829e794e6532414686d341b604b" translate="yes" xml:space="preserve">
          <source>Either this method or &lt;a href=&quot;#test.support.bind_port&quot;&gt;&lt;code&gt;bind_port()&lt;/code&gt;&lt;/a&gt; should be used for any tests where a server socket needs to be bound to a particular port for the duration of the test. Which one to use depends on whether the calling code is creating a Python socket, or if an unused port needs to be provided in a constructor or passed to an external program (i.e. the &lt;code&gt;-accept&lt;/code&gt; argument to openssl&amp;rsquo;s s_server mode). Always prefer &lt;a href=&quot;#test.support.bind_port&quot;&gt;&lt;code&gt;bind_port()&lt;/code&gt;&lt;/a&gt; over &lt;a href=&quot;#test.support.find_unused_port&quot;&gt;&lt;code&gt;find_unused_port()&lt;/code&gt;&lt;/a&gt; where possible. Using a hard coded port is discouraged since it can make multiple instances of the test impossible to run simultaneously, which is a problem for buildbots.</source>
          <target state="translated">테스트 기간 동안 서버 소켓을 특정 포트에 바인딩해야하는 테스트에는 이 메소드 또는 &lt;a href=&quot;#test.support.bind_port&quot;&gt; &lt;code&gt;bind_port()&lt;/code&gt; &lt;/a&gt; 사용해야합니다. 사용할 코드는 호출 코드가 Python 소켓을 작성하는지 또는 사용되지 않는 포트를 생성자에 제공 &lt;code&gt;-accept&lt;/code&gt; 또는 외부 프로그램에 전달 해야하는지 (즉, openssl의 s_server 모드에 대한 -accept 인수)에 따라 다릅니다 . 가능하면 &lt;a href=&quot;#test.support.bind_port&quot;&gt; &lt;code&gt;bind_port()&lt;/code&gt; &lt;/a&gt; 보다 &lt;a href=&quot;#test.support.find_unused_port&quot;&gt; &lt;code&gt;find_unused_port()&lt;/code&gt; &lt;/a&gt; 항상 선호 하십시오. 하드 코딩 된 포트를 사용하면 테스트의 여러 인스턴스를 동시에 실행할 수 없으므로 빌드 봇에 문제가 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="595af9f0b2bd2f1aad5e8a611a6b67dcd9fdb296" translate="yes" xml:space="preserve">
          <source>Either type of image is created through either the &lt;code&gt;file&lt;/code&gt; or the &lt;code&gt;data&lt;/code&gt; option (other options are available as well).</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 또는 &lt;code&gt;data&lt;/code&gt; 옵션 중 하나를 통해 이미지 유형이 생성됩니다 (다른 옵션도 사용 가능).</target>
        </trans-unit>
        <trans-unit id="359218794b7e55476802d4e7b22031fcdc11a904" translate="yes" xml:space="preserve">
          <source>Element Objects</source>
          <target state="translated">요소 객체</target>
        </trans-unit>
        <trans-unit id="49534abd221be130bf26afdaca69c9d22709f868" translate="yes" xml:space="preserve">
          <source>Element class. This class defines the Element interface, and provides a reference implementation of this interface.</source>
          <target state="translated">요소 클래스. 이 클래스는 Element 인터페이스를 정의하고이 인터페이스의 참조 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef0b2c7a0b2591de8486cfbe012dd3bf013c9430" translate="yes" xml:space="preserve">
          <source>Element nodes in the document hierarchy.</source>
          <target state="translated">문서 계층의 요소 노드</target>
        </trans-unit>
        <trans-unit id="f4648a38161abf7ec412ca53076e6858990db678" translate="yes" xml:space="preserve">
          <source>ElementTree Objects</source>
          <target state="translated">ElementTree 객체</target>
        </trans-unit>
        <trans-unit id="4f2ce384320f7363ad9b94cc0a546bdae1eab4d4" translate="yes" xml:space="preserve">
          <source>ElementTree wrapper class. This class represents an entire element hierarchy, and adds some extra support for serialization to and from standard XML.</source>
          <target state="translated">ElementTree 랩퍼 클래스. 이 클래스는 전체 요소 계층 구조를 나타내며 표준 XML과의 직렬화에 대한 추가 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e24a4bf20d22559c7e5a0526dfebb54f5104a66b" translate="yes" xml:space="preserve">
          <source>Elements are counted from an &lt;em&gt;iterable&lt;/em&gt; or added-in from another &lt;em&gt;mapping&lt;/em&gt; (or counter). Like &lt;a href=&quot;stdtypes#dict.update&quot;&gt;&lt;code&gt;dict.update()&lt;/code&gt;&lt;/a&gt; but adds counts instead of replacing them. Also, the &lt;em&gt;iterable&lt;/em&gt; is expected to be a sequence of elements, not a sequence of &lt;code&gt;(key, value)&lt;/code&gt; pairs.</source>
          <target state="translated">요소는 &lt;em&gt;반복 가능&lt;/em&gt; 하거나 추가 된 다른 &lt;em&gt;매핑&lt;/em&gt; (또는 카운터) 에서 계산됩니다 . &lt;a href=&quot;stdtypes#dict.update&quot;&gt; &lt;code&gt;dict.update()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 개수를 바꾸지 않고 추가합니다. 또한 &lt;em&gt;iterable&lt;/em&gt; 은 일련의 &lt;code&gt;(key, value)&lt;/code&gt; 쌍이 아닌 일련의 요소 일 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5957fa1f33f3be4329508a3d81ddf845cff5498" translate="yes" xml:space="preserve">
          <source>Elements are counted from an &lt;em&gt;iterable&lt;/em&gt; or initialized from another &lt;em&gt;mapping&lt;/em&gt; (or counter):</source>
          <target state="translated">요소는 &lt;em&gt;iterable&lt;/em&gt; 에서 계산 되거나 다른 &lt;em&gt;매핑&lt;/em&gt; (또는 카운터) 에서 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e16188e6c59f02f989fa3685c7fd0fc9c19161c4" translate="yes" xml:space="preserve">
          <source>Elements are subtracted from an &lt;em&gt;iterable&lt;/em&gt; or from another &lt;em&gt;mapping&lt;/em&gt; (or counter). Like &lt;a href=&quot;stdtypes#dict.update&quot;&gt;&lt;code&gt;dict.update()&lt;/code&gt;&lt;/a&gt; but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative.</source>
          <target state="translated">&lt;em&gt;반복 가능한&lt;/em&gt; 요소 나 다른 &lt;em&gt;매핑&lt;/em&gt; (또는 카운터) 에서 요소를 뺍니다 . &lt;a href=&quot;stdtypes#dict.update&quot;&gt; &lt;code&gt;dict.update()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 개수를 교체하는 대신 빼기합니다. 입력과 출력 모두 0이거나 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0143fc64324e3d8e5c44dbc294959eb5a7104759" translate="yes" xml:space="preserve">
          <source>Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique.</source>
          <target state="translated">요소는 가치가 아닌 위치에 따라 고유 한 것으로 취급됩니다. 따라서 입력 요소가 고유 한 경우 생성 된 조합도 고유합니다.</target>
        </trans-unit>
        <trans-unit id="11dcc2ac3f506948cc124bda3adca41a062af817" translate="yes" xml:space="preserve">
          <source>Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination.</source>
          <target state="translated">요소는 가치가 아닌 위치에 따라 고유 한 것으로 취급됩니다. 따라서 입력 요소가 고유 한 경우 각 조합에 반복 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7b6e8e82fdfd17809cefa633bda0e009bcc17f5" translate="yes" xml:space="preserve">
          <source>Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation.</source>
          <target state="translated">요소는 가치가 아닌 위치에 따라 고유 한 것으로 취급됩니다. 따라서 입력 요소가 고유하면 각 순열에 반복 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="34a8d1deb6f308a56f56218b6f5d343ef934119f" translate="yes" xml:space="preserve">
          <source>Elements which are declared to be &lt;code&gt;EMPTY&lt;/code&gt; have this model type.</source>
          <target state="translated">&lt;code&gt;EMPTY&lt;/code&gt; 로 선언 된 요소 는이 모델 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="10f74c250875f4d100fff5cde5ff0835190404c1" translate="yes" xml:space="preserve">
          <source>Elimination of PYO files</source>
          <target state="translated">PYO 파일 제거</target>
        </trans-unit>
        <trans-unit id="6ff0f4a868ef59be803181103a0f8dacda1099dd" translate="yes" xml:space="preserve">
          <source>Ellipsis</source>
          <target state="translated">Ellipsis</target>
        </trans-unit>
        <trans-unit id="ed17628a4f82dc8f7f14625d39bd363df62db888" translate="yes" xml:space="preserve">
          <source>Else &lt;em&gt;MandatoryRelease&lt;/em&gt; records when the feature became part of the language; in releases at or after that, modules no longer need a future statement to use the feature in question, but may continue to use such imports.</source>
          <target state="translated">다른 &lt;em&gt;필수&lt;/em&gt; 기능이 언어의 일부가 된 시점을 기록합니다. 그 이후 또는 이후 릴리스에서 모듈은 더 이상 해당 기능을 사용하기 위해 미래의 진술이 필요하지 않지만 그러한 수입을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84add5b2952787581cb9a8851eef63d1ec75d22b" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="translated">Email</target>
        </trans-unit>
        <trans-unit id="da824744005afe1d0c34eee098eaf67872e3d742" translate="yes" xml:space="preserve">
          <source>Emit a short attention sound.</source>
          <target state="translated">짧은주의 소리를 내십시오.</target>
        </trans-unit>
        <trans-unit id="712fe37c31ba2210e87e7f7f3b1bf5e14d866d27" translate="yes" xml:space="preserve">
          <source>Empties the cell contained in slot &lt;em&gt;i&lt;/em&gt; of the cell and free variable storage. Used by the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt;&lt;code&gt;del&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">셀의 슬롯 &lt;em&gt;i&lt;/em&gt; 에 포함 된 셀과 비어있는 가변 스토리지를 비 웁니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt; &lt;code&gt;del&lt;/code&gt; &lt;/a&gt; 문에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f66f8ef5d271d13742c0b875e964787e7b320e6" translate="yes" xml:space="preserve">
          <source>Empty files are opened and immediately closed; the only time their presence in the list of filenames is noticeable at all is when the last file opened is empty.</source>
          <target state="translated">빈 파일이 열리고 즉시 닫힙니다. 파일 이름 목록에 존재하는 유일한 시간은 마지막으로 열린 파일이 비어있을 때입니다.</target>
        </trans-unit>
        <trans-unit id="96fc58d87dcfa6680714e0fc0a204c20e1bc2122" translate="yes" xml:space="preserve">
          <source>Empty matches for the pattern split the string only when not adjacent to a previous empty match.</source>
          <target state="translated">패턴에 대한 빈 일치는 이전 빈 일치에 인접하지 않은 경우에만 문자열을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="6eb0779fd09c16502ebd15fb0795bd1835ade77f" translate="yes" xml:space="preserve">
          <source>Empty sequences are allowed, but acceptance of three empty sequences is platform-dependent. (It is known to work on Unix but not on Windows.) The optional &lt;em&gt;timeout&lt;/em&gt; argument specifies a time-out as a floating point number in seconds. When the &lt;em&gt;timeout&lt;/em&gt; argument is omitted the function blocks until at least one file descriptor is ready. A time-out value of zero specifies a poll and never blocks.</source>
          <target state="translated">빈 시퀀스는 허용되지만 3 개의 빈 시퀀스는 플랫폼에 따라 다릅니다. (그것은 유닉스에서 작동하는 것으로 알려져 있지만 Windows에 있습니다.) 옵션 &lt;em&gt;타임 아웃&lt;/em&gt; 인수가 초 부동 소수점 숫자로 시간 제한을 지정합니다. 때 &lt;em&gt;타임 아웃&lt;/em&gt; 인수가 함수 블록을 생략 적어도 하나 개의 파일 기술자가 준비 될 때까지. 시간 제한 값이 0이면 폴링을 지정하고 절대로 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9ca147c86f3511f63e922200d892933735a3ce7" translate="yes" xml:space="preserve">
          <source>Enable &amp;ldquo;passive&amp;rdquo; mode if &lt;em&gt;val&lt;/em&gt; is true, otherwise disable passive mode. Passive mode is on by default.</source>
          <target state="translated">&lt;em&gt;val&lt;/em&gt; 이 true이면 &quot;수동&quot;모드를 활성화 하고, 그렇지 않으면 수동 모드를 비활성화하십시오. 수동 모드는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a1830a9ad6b230d4772920b444e77e892a7b2c0" translate="yes" xml:space="preserve">
          <source>Enable &lt;em&gt;capability&lt;/em&gt; (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5161.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 5161&lt;/strong&gt;&lt;/a&gt;). Most capabilities do not need to be enabled. Currently only the &lt;code&gt;UTF8=ACCEPT&lt;/code&gt; capability is supported (see &lt;a href=&quot;https://tools.ietf.org/html/rfc6855.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 6855&lt;/strong&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;기능을&lt;/em&gt; 활성화 &lt;em&gt;합니다&lt;/em&gt; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5161.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 5161&lt;/strong&gt;&lt;/a&gt; 참조 ). 대부분의 기능을 활성화 할 필요는 없습니다. 현재 &lt;code&gt;UTF8=ACCEPT&lt;/code&gt; 기능 만 지원됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc6855.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 6855&lt;/strong&gt;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e64969c2a478b0193d345f61f0278bb04e5a5c3d" translate="yes" xml:space="preserve">
          <source>Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is disabled by default and a server can only request a TLS client certificate during the initial handshake. When enabled, a server may request a TLS client certificate at any time after the handshake.</source>
          <target state="translated">TLS 1.3 사후 핸드 셰이크 클라이언트 인증을 사용하십시오. 핸드 셰이크 후 인증은 기본적으로 비활성화되어 있으며 서버는 초기 핸드 셰이크 중 TLS 클라이언트 인증서 만 요청할 수 있습니다. 사용 가능한 경우, 서버는 핸드 셰이크 후 언제라도 TLS 클라이언트 인증서를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b01e8ffd8306cea3683a91d93d4207b25a77ccd" translate="yes" xml:space="preserve">
          <source>Enable a server to accept connections. If &lt;em&gt;backlog&lt;/em&gt; is specified, it must be at least 0 (if it is lower, it is set to 0); it specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen.</source>
          <target state="translated">서버가 연결을 수락하도록합니다. &lt;em&gt;백 로그&lt;/em&gt; 가 지정된 경우 최소 0이어야합니다 (낮 으면 0으로 설정 됨). 새 연결을 거부하기 전에 시스템에서 허용 할 수없는 허용 연결 수를 지정합니다. 지정하지 않으면 적절한 기본 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="971896ffb7e3ebd15d517c1f88efeb1e585f6fb1" translate="yes" xml:space="preserve">
          <source>Enable automatic garbage collection.</source>
          <target state="translated">자동 가비지 콜렉션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eacc85becdea9d34a7f0f87cf3c7f4659f303bdb" translate="yes" xml:space="preserve">
          <source>Enable keyboard traversal for a toplevel window containing this notebook.</source>
          <target state="translated">이 노트북이 포함 된 최상위 창에 키보드 탐색을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eeb17b55c47c064f0c885ac6edcfc504029b5711" translate="yes" xml:space="preserve">
          <source>Enable or disable automatic calls to &lt;code&gt;add_history()&lt;/code&gt; when reading input via readline. The &lt;em&gt;enabled&lt;/em&gt; argument should be a Boolean value that when true, enables auto history, and that when false, disables auto history.</source>
          <target state="translated">readline을 통해 입력을 읽을 때 &lt;code&gt;add_history()&lt;/code&gt; 자동 호출을 활성화 또는 비활성화합니다 . &lt;em&gt;활성화&lt;/em&gt; 인수는 사실, 자동 기록을 가능하게하는 부울 값, 그리고 그 때 거짓, 비활성화 자동 기록한다.</target>
        </trans-unit>
        <trans-unit id="26a73bd72aa4da39ed18ebf87aa69760fe6a344f" translate="yes" xml:space="preserve">
          <source>Enable or disable the debug mode.</source>
          <target state="translated">디버그 모드를 활성화 또는 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="befd2646a620e600335d49ff83a819d286b6b876" translate="yes" xml:space="preserve">
          <source>Enable stricter semantics for mixing floats and Decimals.</source>
          <target state="translated">float와 Decimals를 혼합하기 위해 더 엄격한 의미를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9377cf43de0047335652dca6650eb8fd8f870ef" translate="yes" xml:space="preserve">
          <source>Enable the breakpoints specified.</source>
          <target state="translated">지정된 중단 점을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78484a7c1326bcc3e5583395ac67b8a7c9642313" translate="yes" xml:space="preserve">
          <source>Enable the fault handler: install handlers for the &lt;code&gt;SIGSEGV&lt;/code&gt;, &lt;code&gt;SIGFPE&lt;/code&gt;, &lt;code&gt;SIGABRT&lt;/code&gt;, &lt;code&gt;SIGBUS&lt;/code&gt; and &lt;code&gt;SIGILL&lt;/code&gt; signals to dump the Python traceback. If &lt;em&gt;all_threads&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, produce tracebacks for every running thread. Otherwise, dump only the current thread.</source>
          <target state="translated">오류 처리기를 활성화하십시오. &lt;code&gt;SIGSEGV&lt;/code&gt; , &lt;code&gt;SIGFPE&lt;/code&gt; , &lt;code&gt;SIGABRT&lt;/code&gt; , &lt;code&gt;SIGBUS&lt;/code&gt; 및 &lt;code&gt;SIGILL&lt;/code&gt; 신호에 대한 처리기를 설치 하여 Python 추적 백을 덤프하십시오. &lt;em&gt;all_threads&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 실행중인 모든 스레드에 대해 역 추적을 생성하십시오. 그렇지 않으면 현재 스레드 만 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="00219e9a1b9ff26ad0b40fd3c6c39fe8683fdcc9" translate="yes" xml:space="preserve">
          <source>Enables CAN FD support in a CAN_RAW socket. This is disabled by default. This allows your application to send both CAN and CAN FD frames; however, you must accept both CAN and CAN FD frames when reading from the socket.</source>
          <target state="translated">CAN_RAW 소켓에서 CAN FD 지원을 활성화합니다. 기본적으로 비활성화되어 있습니다. 이를 통해 어플리케이션은 CAN 및 CAN FD 프레임을 모두 전송할 수 있습니다. 그러나 소켓에서 읽을 때는 CAN 및 CAN FD 프레임을 모두 수용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b48d635867970782604405e57297e025f0d6a89c" translate="yes" xml:space="preserve">
          <source>Enables workarounds for various bugs present in other SSL implementations. This option is set by default. It does not necessarily set the same flags as OpenSSL&amp;rsquo;s &lt;code&gt;SSL_OP_ALL&lt;/code&gt; constant.</source>
          <target state="translated">다른 SSL 구현에 존재하는 다양한 버그에 대한 해결 방법을 활성화합니다. 이 옵션은 기본적으로 설정되어 있습니다. 반드시 OpenSSL의 &lt;code&gt;SSL_OP_ALL&lt;/code&gt; 상수 와 동일한 플래그를 설정하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cdca8499ba0f0ffddfe7036f37fdfd9bd58cea9" translate="yes" xml:space="preserve">
          <source>Enabling debug mode</source>
          <target state="translated">디버그 모드 활성화</target>
        </trans-unit>
        <trans-unit id="07af2f6e3bb3a4e462e895058fcbc45334a604b2" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;em&gt;allow_dotted_names&lt;/em&gt; option allows intruders to access your module&amp;rsquo;s global variables and may allow intruders to execute arbitrary code on your machine. Only use this example only within a secure, closed network.</source>
          <target state="translated">&lt;em&gt;allow_dotted_names&lt;/em&gt; 옵션을 활성화 하면 침입자가 모듈의 전역 변수에 액세스 할 수 있으며 침입자가 컴퓨터에서 임의의 코드를 실행할 수 있습니다. 이 예제는 안전하고 폐쇄 된 네트워크 내에서만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b1af61e74fb0fcb6656cb2909de6d3c9f228d8" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;em&gt;allow_dotted_names&lt;/em&gt; option allows intruders to access your module&amp;rsquo;s global variables and may allow intruders to execute arbitrary code on your machine. Only use this option on a secure, closed network.</source>
          <target state="translated">&lt;em&gt;allow_dotted_names&lt;/em&gt; 옵션을 활성화 하면 침입자가 모듈의 전역 변수에 액세스 할 수 있으며 침입자가 컴퓨터에서 임의의 코드를 실행할 수 있습니다. 안전한 비공개 네트워크에서만이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a19099a826dd8a9592dea4c03d95ca189ffd83fd" translate="yes" xml:space="preserve">
          <source>Encapsulate an XML error or warning. This class can contain basic error or warning information from either the XML parser or the application: it can be subclassed to provide additional functionality or to add localization. Note that although the handlers defined in the &lt;a href=&quot;xml.sax.handler#xml.sax.handler.ErrorHandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; interface receive instances of this exception, it is not required to actually raise the exception &amp;mdash; it is also useful as a container for information.</source>
          <target state="translated">XML 오류 또는 경고를 캡슐화하십시오. 이 클래스에는 XML 파서 또는 응용 프로그램의 기본 오류 또는 경고 정보가 포함될 수 있습니다. 추가 기능을 제공하거나 지역화를 추가하기 위해 서브 클래 싱 될 수 있습니다. &lt;a href=&quot;xml.sax.handler#xml.sax.handler.ErrorHandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; 인터페이스에 정의 된 핸들러 는이 예외의 인스턴스를 수신 하지만 실제로 예외를 발생시킬 필요는 없습니다. 또한 정보의 컨테이너로도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7b89d059b48fe1d6ce07ae4ebf8b9b1f65d5439b" translate="yes" xml:space="preserve">
          <source>Encapsulates the asynchronous execution of a callable. &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; instances are created by &lt;a href=&quot;#concurrent.futures.Executor.submit&quot;&gt;&lt;code&gt;Executor.submit()&lt;/code&gt;&lt;/a&gt; and should not be created directly except for testing.</source>
          <target state="translated">호출 가능 항목의 비동기 실행을 캡슐화합니다. &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;#concurrent.futures.Executor.submit&quot;&gt; &lt;code&gt;Executor.submit()&lt;/code&gt; &lt;/a&gt; 의해 생성되며 테스트를 제외하고 직접 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc3b238ce3cff3109f5fca3d21d66f397859fba" translate="yes" xml:space="preserve">
          <source>Encapsulation of the information needed by the &lt;a href=&quot;#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt; to read entities.</source>
          <target state="translated">엔티티를 읽기 위해 &lt;a href=&quot;#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt; 에 필요한 정보를 캡슐화합니다 .</target>
        </trans-unit>
        <trans-unit id="14f77877197d80a81f16a011d2af74a80b57468e" translate="yes" xml:space="preserve">
          <source>Enclosing characters in quotes preserve the literal value of all characters within the quotes;</source>
          <target state="translated">따옴표로 묶는 문자는 따옴표 안에있는 모든 문자의 리터럴 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="88ad97909485c7dd6989f04a4e8fcd2dc6f0fac1" translate="yes" xml:space="preserve">
          <source>Enclosing characters in quotes which are not part of &lt;a href=&quot;#shlex.shlex.escapedquotes&quot;&gt;&lt;code&gt;escapedquotes&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;&quot;'&quot;&lt;/code&gt;) preserve the literal value of all characters within the quotes;</source>
          <target state="translated">&lt;a href=&quot;#shlex.shlex.escapedquotes&quot;&gt; &lt;code&gt;escapedquotes&lt;/code&gt; &lt;/a&gt; 된 따옴표의 일부가 아닌 따옴표로 묶는 문자 (예 : &lt;code&gt;&quot;'&quot;&lt;/code&gt; )는 따옴표 안에있는 모든 문자의 리터럴 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d4821252d35584af9326a6e7f60f1d73b77d48c3" translate="yes" xml:space="preserve">
          <source>Enclosing characters in quotes which are part of &lt;a href=&quot;#shlex.shlex.escapedquotes&quot;&gt;&lt;code&gt;escapedquotes&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;'&quot;'&lt;/code&gt;) preserves the literal value of all characters within the quotes, with the exception of the characters mentioned in &lt;a href=&quot;#shlex.shlex.escape&quot;&gt;&lt;code&gt;escape&lt;/code&gt;&lt;/a&gt;. The escape characters retain its special meaning only when followed by the quote in use, or the escape character itself. Otherwise the escape character will be considered a normal character.</source>
          <target state="translated">&lt;a href=&quot;#shlex.shlex.escapedquotes&quot;&gt; &lt;code&gt;escapedquotes&lt;/code&gt; 의&lt;/a&gt; 일부인 따옴표로 묶은 문자 (예 : &lt;code&gt;'&quot;'&lt;/code&gt; )는 &lt;a href=&quot;#shlex.shlex.escape&quot;&gt; &lt;code&gt;escape&lt;/code&gt; &lt;/a&gt; 에서 언급 된 문자를 제외하고 따옴표 내 모든 문자의 리터럴 값을 유지합니다 . 이스케이프 문자는 따옴표 뒤에 오는 경우에만 특별한 의미를 유지합니다. 또는 이스케이프 문자 자체를 사용하지 않으면 이스케이프 문자가 일반 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8e3ef7fb5bbf1067d36ca7d114791bb1ecfe2094" translate="yes" xml:space="preserve">
          <source>Encode &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;s&lt;/em&gt; using the URL- and filesystem-safe alphabet, which substitutes &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;_&lt;/code&gt; instead of &lt;code&gt;/&lt;/code&gt; in the standard Base64 alphabet, and return the encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. The result can still contain &lt;code&gt;=&lt;/code&gt;.</source>
          <target state="translated">인코딩은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;객체 같은 바이트 &lt;/a&gt;&lt;em&gt;들&lt;/em&gt; URL- 및 파일 시스템 안전 알파벳, 대체품을 사용 &lt;code&gt;-&lt;/code&gt; 대신 &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;_&lt;/code&gt; 대신 &lt;code&gt;/&lt;/code&gt; 표준을 Base64 알파벳 및 부호화 반환 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; . 결과에는 여전히 &lt;code&gt;=&lt;/code&gt; 가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfbd8dc1abad46fd0071384996480ac840443421" translate="yes" xml:space="preserve">
          <source>Encode &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;s&lt;/em&gt; using the standard Base64 alphabet and return the encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인코딩은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체 &lt;/a&gt;&lt;em&gt;의이&lt;/em&gt; 표준 Base64로 알파벳을 사용하여 인코딩 된 반환 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84e671106e5fd09bcba9090332501ac45ae84724" translate="yes" xml:space="preserve">
          <source>Encode &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt;&lt;em&gt;filename&lt;/em&gt; to the filesystem encoding with &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler, or &lt;code&gt;'strict'&lt;/code&gt; on Windows; return &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; unchanged.</source>
          <target state="translated">인코딩 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은 &lt;/a&gt;&lt;em&gt;이름&lt;/em&gt; 을 가진 파일 시스템 인코딩 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기, 또는 &lt;code&gt;'strict'&lt;/code&gt; Windows에서; &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 변경하지 않고 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="ffdf7198a76c3276541a5db4c0b0209534929dca" translate="yes" xml:space="preserve">
          <source>Encode &lt;em&gt;s&lt;/em&gt; using the &lt;code&gt;ASCII&lt;/code&gt; codec and the &lt;code&gt;surrogateescape&lt;/code&gt; error handler, and pass it to the &lt;em&gt;write&lt;/em&gt; method of the &lt;em&gt;outfp&lt;/em&gt; passed to the &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s constructor.</source>
          <target state="translated">인코딩 &lt;em&gt;S&lt;/em&gt; 은 USING &lt;code&gt;ASCII&lt;/code&gt; 의 코덱과 &lt;code&gt;surrogateescape&lt;/code&gt; 의 오류 처리기 및로 패스 &lt;em&gt;기록&lt;/em&gt; 의 방법 &lt;em&gt;outfp&lt;/em&gt; 받는 전달 &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 의 생성자.</target>
        </trans-unit>
        <trans-unit id="6e685faa81657b0e3f36d4d3a4f45234790e538f" translate="yes" xml:space="preserve">
          <source>Encode a message header into an RFC-compliant format, possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings.</source>
          <target state="translated">메시지 헤더를 RFC 호환 형식으로 인코딩하여 긴 행을 래핑하고 비 ASCII 부분을 base64 또는 인용 인쇄 가능 인코딩으로 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba9ada320fca1e8cb2142e1346d247f9f806f542" translate="yes" xml:space="preserve">
          <source>Encode and decode MIME base64 data</source>
          <target state="translated">MIME base64 데이터 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="7ab581d597f3bf448a02f8351b29151a923e6e6f" translate="yes" xml:space="preserve">
          <source>Encode the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;b&lt;/em&gt; using Ascii85 and return the encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인 코드 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 형 객체 &lt;/a&gt;&lt;em&gt;b를&lt;/em&gt; ASCII85를 사용하여 인코딩 된 반환 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d11216cbf678c1763da91fd2fb9b0f745134c5fd" translate="yes" xml:space="preserve">
          <source>Encode the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;b&lt;/em&gt; using base85 (as used in e.g. git-style binary diffs) and return the encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">base85를 사용하여 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체 &lt;/a&gt;&lt;em&gt;b&lt;/em&gt; 를 인코딩하고 (예 : git-style binary diffs에 사용) 인코딩 된 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bf1fdba47a42f7a6afd6ab89d4bca80118d00ef3" translate="yes" xml:space="preserve">
          <source>Encode the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;s&lt;/em&gt; using Base16 and return the encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인 코드 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체 &lt;/a&gt;&lt;em&gt;의&lt;/em&gt; 사용을 Base16 인코딩 된 반환 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d56aa77069a6187dbe9ae10ef72b7abeab315a8e" translate="yes" xml:space="preserve">
          <source>Encode the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;s&lt;/em&gt; using Base32 and return the encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인 코드 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체 &lt;/a&gt;&lt;em&gt;의&lt;/em&gt; 사용을 Base32 인코딩 된 반환 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="635ad9b339c141c690488f6ac82847a524ee904f" translate="yes" xml:space="preserve">
          <source>Encode the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;s&lt;/em&gt; using Base64 and return the encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인 코드 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체 &lt;/a&gt;&lt;em&gt;의&lt;/em&gt; 사용가 base64 인코딩 된 반환 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83850d70b6021bfeec0e6a1e79a7dc069defb565" translate="yes" xml:space="preserve">
          <source>Encode the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;s&lt;/em&gt;, which can contain arbitrary binary data, and return &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; containing the base64-encoded data, with newlines (&lt;code&gt;b'\n'&lt;/code&gt;) inserted after every 76 bytes of output, and ensuring that there is a trailing newline, as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; (MIME).</source>
          <target state="translated">인 코드 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 형 객체 &lt;/a&gt;&lt;em&gt;들&lt;/em&gt; 임의의 이진 데이터를 포함하고, 복귀 할 수있는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 바꿈과 함께 base64 인코딩 된 데이터를 포함하는 ( &lt;code&gt;b'\n'&lt;/code&gt; )에 삽입 출력마다 76 바이트 후에 후행 개행 있다는 것을 보장 같은 당 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; (MIME).</target>
        </trans-unit>
        <trans-unit id="ae13ec2bd5725d886fbbd75e44ed1df1c2ae02ed" translate="yes" xml:space="preserve">
          <source>Encode the contents of the &lt;em&gt;input&lt;/em&gt; file and write the resulting quoted-printable data to the &lt;em&gt;output&lt;/em&gt; file. &lt;em&gt;input&lt;/em&gt; and &lt;em&gt;output&lt;/em&gt; must be &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;binary file objects&lt;/a&gt;. &lt;em&gt;quotetabs&lt;/em&gt;, a non-optional flag which controls whether to encode embedded spaces and tabs; when true it encodes such embedded whitespace, and when false it leaves them unencoded. Note that spaces and tabs appearing at the end of lines are always encoded, as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1521.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1521&lt;/strong&gt;&lt;/a&gt;. &lt;em&gt;header&lt;/em&gt; is a flag which controls if spaces are encoded as underscores as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1522.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 1522&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;입력&lt;/em&gt; 파일 의 내용을 인코딩하고 인용 된 인쇄 가능한 결과 데이터를 &lt;em&gt;출력&lt;/em&gt; 파일에 씁니다 . &lt;em&gt;입력&lt;/em&gt; 및 &lt;em&gt;출력&lt;/em&gt; 은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;이진 파일 객체&lt;/a&gt; 여야 합니다 . &lt;em&gt;인용&lt;/em&gt; 공간 (embedded spaces)과 탭 (tab)의 인코딩 여부를 제어하는 ​​비 선택적 플래그 인 &lt;em&gt;quotetabs&lt;/em&gt; true이면 이러한 포함 된 공백을 인코딩하고 false이면 인코딩되지 않은 상태로 둡니다. 줄 끝에 나타나는 공백과 탭은 항상 &lt;a href=&quot;https://tools.ietf.org/html/rfc1521.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1521에&lt;/strong&gt;&lt;/a&gt; 따라 인코딩됩니다 . &lt;em&gt;헤더&lt;/em&gt; 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1522.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 1522에&lt;/strong&gt;&lt;/a&gt; 따라 공백이 밑줄로 인코딩되는지 여부를 제어하는 ​​플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="6b1af585911b3e2c2490aef5a95b4109bcbec15d" translate="yes" xml:space="preserve">
          <source>Encode the contents of the binary &lt;em&gt;input&lt;/em&gt; file and write the resulting base64 encoded data to the &lt;em&gt;output&lt;/em&gt; file. &lt;em&gt;input&lt;/em&gt; and &lt;em&gt;output&lt;/em&gt; must be &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. &lt;em&gt;input&lt;/em&gt; will be read until &lt;code&gt;input.read()&lt;/code&gt; returns an empty bytes object. &lt;a href=&quot;#base64.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; inserts a newline character (&lt;code&gt;b'\n'&lt;/code&gt;) after every 76 bytes of the output, as well as ensuring that the output always ends with a newline, as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; (MIME).</source>
          <target state="translated">이진 &lt;em&gt;입력&lt;/em&gt; 파일 의 내용을 인코딩하고 결과 base64로 인코딩 된 데이터를 &lt;em&gt;출력&lt;/em&gt; 파일에 씁니다 . &lt;em&gt;입력&lt;/em&gt; 및 &lt;em&gt;출력&lt;/em&gt; 은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 여야 합니다 . &lt;code&gt;input.read()&lt;/code&gt; 가 빈 바이트 객체를 반환 할 때까지 &lt;em&gt;입력&lt;/em&gt; 을 읽습니다 . &lt;a href=&quot;#base64.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; 는 출력의 76 바이트마다 줄 바꿈 문자 ( &lt;code&gt;b'\n'&lt;/code&gt; )를 삽입 할 뿐만 아니라 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; (MIME)에 따라 출력이 항상 줄 바꿈으로 끝나도록합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ece4908e842d1a57462d3e13321736479cca5fc" translate="yes" xml:space="preserve">
          <source>Encode the given object, &lt;em&gt;o&lt;/em&gt;, and yield each string representation as available. For example:</source>
          <target state="translated">지정된 객체 &lt;em&gt;o를&lt;/em&gt; 인코딩하고 사용 가능한 각 문자열 표현을 생성합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4edd62a7f69a53a1d9591005cca6ad7e417e11cf" translate="yes" xml:space="preserve">
          <source>Encode the string &lt;em&gt;s&lt;/em&gt; according to &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;. Optional &lt;em&gt;charset&lt;/em&gt; and &lt;em&gt;language&lt;/em&gt;, if given is the character set name and language name to use. If neither is given, &lt;em&gt;s&lt;/em&gt; is returned as-is. If &lt;em&gt;charset&lt;/em&gt; is given but &lt;em&gt;language&lt;/em&gt; is not, the string is encoded using the empty string for &lt;em&gt;language&lt;/em&gt;.</source>
          <target state="translated">문자열 인코딩 &lt;em&gt;들&lt;/em&gt; 에 따라 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; . 선택적 &lt;em&gt;문자 세트&lt;/em&gt; 및 &lt;em&gt;언어 (&lt;/em&gt; 제공된 경우 사용할 문자 세트 이름 및 언어 이름) 둘 다 지정하지 않으면 &lt;em&gt;s&lt;/em&gt; 는있는 그대로 반환됩니다. 경우 &lt;em&gt;캐릭터 세트가&lt;/em&gt; 주어 있지만 &lt;em&gt;언어가&lt;/em&gt; 아닌, 문자열에 대한 빈 문자열을 사용하여 인코딩되는 &lt;em&gt;언어를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e8df3651ff60e834a39b4df93aa682f9e7023628" translate="yes" xml:space="preserve">
          <source>Encoder / decoder</source>
          <target state="translated">인코더 / 디코더</target>
        </trans-unit>
        <trans-unit id="0b2560b8670c5d6b00522cd4ae4b4d4307d0b2be" translate="yes" xml:space="preserve">
          <source>Encoders and Decoders</source>
          <target state="translated">인코더 및 디코더</target>
        </trans-unit>
        <trans-unit id="d71cfe7f4cafe8422a37c04504b23989f4687ef0" translate="yes" xml:space="preserve">
          <source>Encodes &lt;em&gt;obj&lt;/em&gt; using the codec registered for &lt;em&gt;encoding&lt;/em&gt;.</source>
          <target state="translated">인코딩에 등록 된 코덱을 사용하여 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;인코딩&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5a0794f1f14ae2870d08446eefc407ddf1f0233a" translate="yes" xml:space="preserve">
          <source>Encodes &lt;em&gt;object&lt;/em&gt; (taking the current state of the encoder into account) and returns the resulting encoded object. If this is the last call to &lt;a href=&quot;#codecs.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;final&lt;/em&gt; must be true (the default is false).</source>
          <target state="translated">&lt;em&gt;객체를&lt;/em&gt; 인코딩 하고 (엔코더의 현재 상태를 고려하여) 결과 인코딩 된 객체를 반환합니다. 이것이 &lt;a href=&quot;#codecs.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; final에&lt;/em&gt; 대한 마지막 호출 인 경우 true 여야합니다 (기본값은 false).</target>
        </trans-unit>
        <trans-unit id="43b6fc9174410620829b5e6f78b9b2c8513e41c1" translate="yes" xml:space="preserve">
          <source>Encodes the facility and priority into an integer. You can pass in strings or integers - if strings are passed, internal mapping dictionaries are used to convert them to integers.</source>
          <target state="translated">기능과 우선 순위를 정수로 인코딩합니다. 문자열이나 정수를 전달할 수 있습니다. 문자열이 전달되면 내부 매핑 사전을 사용하여 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="378f8c352c46252bbb75391a25357f76d573bd74" translate="yes" xml:space="preserve">
          <source>Encodes the object &lt;em&gt;input&lt;/em&gt; and returns a tuple (output object, length consumed). For instance, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encoding&lt;/a&gt; converts a string object to a bytes object using a particular character set encoding (e.g., &lt;code&gt;cp1252&lt;/code&gt; or &lt;code&gt;iso-8859-1&lt;/code&gt;).</source>
          <target state="translated">객체 &lt;em&gt;입력을&lt;/em&gt; 인코딩하고 튜플 (출력 객체, 소비 된 길이)을 반환합니다. 예를 들어, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 은 특정 문자 세트 인코딩 (예 : &lt;code&gt;cp1252&lt;/code&gt; 또는 &lt;code&gt;iso-8859-1&lt;/code&gt; )을 사용하여 문자열 객체를 바이트 객체로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="fc1b7b9683d09c85651ce4de2401dc8d304b150a" translate="yes" xml:space="preserve">
          <source>Encodes the payload into base64 form and sets the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header to &lt;code&gt;base64&lt;/code&gt;. This is a good encoding to use when most of your payload is unprintable data since it is a more compact form than quoted-printable. The drawback of base64 encoding is that it renders the text non-human readable.</source>
          <target state="translated">페이로드를 base64 형식 &lt;em&gt;으로 인코딩&lt;/em&gt; 하고 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 &lt;code&gt;base64&lt;/code&gt; 로 설정 합니다. 이것은 페이로드가 대부분 인쇄 할 수없는 데이터 일 때 사용하기에 좋은 인코딩입니다. 따옴표로 인쇄 할 수있는 것보다 더 간결한 형식이기 때문입니다. base64 인코딩의 단점은 텍스트를 사람이 읽을 수 없도록 렌더링한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="95c8e0549c3213a2dda1d9312f81c01e867a1e92" translate="yes" xml:space="preserve">
          <source>Encodes the payload into quoted-printable form and sets the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header to &lt;code&gt;quoted-printable&lt;/code&gt;&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. This is a good encoding to use when most of your payload is normal printable data, but contains a few unprintable characters.</source>
          <target state="translated">페이로드를 인용 인쇄 가능한 양식 &lt;em&gt;으로 인코딩&lt;/em&gt; 하고 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 &lt;code&gt;quoted-printable&lt;/code&gt; &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1로 설정&lt;/a&gt; 합니다. 이것은 대부분의 페이로드가 인쇄 가능한 일반 데이터이지만 인쇄 할 수없는 문자가 몇 개있을 때 사용하기에 적합한 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="596bb52694c422af5f31e595be194a5b80ef5824" translate="yes" xml:space="preserve">
          <source>Encoding basic Python object hierarchies:</source>
          <target state="translated">기본 파이썬 객체 계층 인코딩 :</target>
        </trans-unit>
        <trans-unit id="e01623560da289b520db5d6a7d88c0bbc24861ce" translate="yes" xml:space="preserve">
          <source>Encoding of PalmOS 3.5.</source>
          <target state="translated">PalmOS 3.5 인코딩.</target>
        </trans-unit>
        <trans-unit id="b04bd66c21e22fbff9114ec0c6134bbca1a0b6a8" translate="yes" xml:space="preserve">
          <source>Encoding suitable as the contents of a Unicode literal in ASCII-encoded Python source code, except that quotes are not escaped. Decode from Latin-1 source code. Beware that Python source code actually uses UTF-8 by default.</source>
          <target state="translated">따옴표가 이스케이프되지 않는 것을 제외하고 ASCII로 인코딩 된 Python 소스 코드의 유니 코드 리터럴 내용으로 적합한 인코딩. Latin-1 소스 코드에서 디코딩하십시오. 파이썬 소스 코드는 실제로 기본적으로 UTF-8을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7aec5e156e6be9b6aed99321306edff96823d8f5" translate="yes" xml:space="preserve">
          <source>Encoding used to encode method arguments (Unicode strings and characters). The encoding attribute is inherited from the parent window when a subwindow is created, for example with &lt;a href=&quot;#curses.window.subwin&quot;&gt;&lt;code&gt;window.subwin()&lt;/code&gt;&lt;/a&gt;. By default, the locale encoding is used (see &lt;a href=&quot;locale#locale.getpreferredencoding&quot;&gt;&lt;code&gt;locale.getpreferredencoding()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">메소드 인수를 인코딩하는 데 사용되는 인코딩 (유니 코드 문자열 및 문자). 인코딩 속성은 하위 창을 만들 때 부모 창에서 상속됩니다 &lt;a href=&quot;#curses.window.subwin&quot;&gt; &lt;code&gt;window.subwin()&lt;/code&gt; &lt;/a&gt; 예 : window.subwin ()) . 기본적으로 로케일 인코딩이 사용됩니다 ( &lt;a href=&quot;locale#locale.getpreferredencoding&quot;&gt; &lt;code&gt;locale.getpreferredencoding()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1a47ec39576a907fb4fc37fec210dc585edad95c" translate="yes" xml:space="preserve">
          <source>Encodings and Unicode</source>
          <target state="translated">인코딩 및 유니 코드</target>
        </trans-unit>
        <trans-unit id="edf16238133674f34dc062d2161f4e728de8384b" translate="yes" xml:space="preserve">
          <source>Encodings are first looked up in the registry&amp;rsquo;s cache. If not found, the list of registered search functions is scanned. If no &lt;a href=&quot;#codecs.CodecInfo&quot;&gt;&lt;code&gt;CodecInfo&lt;/code&gt;&lt;/a&gt; object is found, a &lt;a href=&quot;exceptions#LookupError&quot;&gt;&lt;code&gt;LookupError&lt;/code&gt;&lt;/a&gt; is raised. Otherwise, the &lt;a href=&quot;#codecs.CodecInfo&quot;&gt;&lt;code&gt;CodecInfo&lt;/code&gt;&lt;/a&gt; object is stored in the cache and returned to the caller.</source>
          <target state="translated">인코딩은 먼저 레지스트리 캐시에서 조회됩니다. 찾을 수 없으면 등록 된 검색 기능 목록이 스캔됩니다. &lt;a href=&quot;#codecs.CodecInfo&quot;&gt; &lt;code&gt;CodecInfo&lt;/code&gt; &lt;/a&gt; 개체가 없으면 &lt;a href=&quot;exceptions#LookupError&quot;&gt; &lt;code&gt;LookupError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 그렇지 않으면 &lt;a href=&quot;#codecs.CodecInfo&quot;&gt; &lt;code&gt;CodecInfo&lt;/code&gt; &lt;/a&gt; 개체가 캐시에 저장되어 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="630b425d9a00bb04751b2932f13d862908b045cf" translate="yes" xml:space="preserve">
          <source>Encrypted password</source>
          <target state="translated">암호화 된 비밀번호</target>
        </trans-unit>
        <trans-unit id="a2bb9d34b8a1a79665858d354585cf147e0dee4e" translate="yes" xml:space="preserve">
          <source>End</source>
          <target state="translated">End</target>
        </trans-unit>
        <trans-unit id="1922f8549c83f9841a0a3a96665a811403626eb9" translate="yes" xml:space="preserve">
          <source>End of medium</source>
          <target state="translated">매체의 끝</target>
        </trans-unit>
        <trans-unit id="4de459b167bc17b3a0e6bbfc5dba938d1d966746" translate="yes" xml:space="preserve">
          <source>End of text</source>
          <target state="translated">텍스트 끝</target>
        </trans-unit>
        <trans-unit id="8c7f307345f3f9f062b9e039589289044820b04a" translate="yes" xml:space="preserve">
          <source>End of transmission</source>
          <target state="translated">전송 끝</target>
        </trans-unit>
        <trans-unit id="b750001d7ab130d7ac487cd2ca42bd5cd9f92224" translate="yes" xml:space="preserve">
          <source>End the scope of a prefix-URI mapping.</source>
          <target state="translated">접두사 URI 매핑 범위를 끝냅니다.</target>
        </trans-unit>
        <trans-unit id="96a5fa3659b07bd3bd2f4d5beb5509f96a53c4a4" translate="yes" xml:space="preserve">
          <source>End transmission block</source>
          <target state="translated">전송 블록 종료</target>
        </trans-unit>
        <trans-unit id="e7a088c0208f7d8311fb5b3d1e0349a153b3d9ab" translate="yes" xml:space="preserve">
          <source>Engineering notation has an exponent which is a multiple of 3. This can leave up to 3 digits to the left of the decimal place and may require the addition of either one or two trailing zeros.</source>
          <target state="translated">공학 표기법에는 지수의 배수가 3의 배수입니다. 소수점 이하 자릿수 왼쪽에 최대 3 자리 숫자를 남길 수 있으며 하나 또는 두 개의 후행 0을 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="649df08a448ee3fa90f3746baaf6b0907df42c91" translate="yes" xml:space="preserve">
          <source>English</source>
          <target state="translated">English</target>
        </trans-unit>
        <trans-unit id="dcb1a009593a59322d64d1a3b6206a794460cc47" translate="yes" xml:space="preserve">
          <source>Enqueues the record on the queue using &lt;code&gt;put_nowait()&lt;/code&gt;; you may want to override this if you want to use blocking behaviour, or a timeout, or a customized queue implementation.</source>
          <target state="translated">put_nowait &lt;code&gt;put_nowait()&lt;/code&gt; 사용하여 큐의 레코드를 큐에 넣습니다 . 블로킹 동작 또는 시간 종료 또는 사용자 정의 된 큐 구현을 사용하려는 경우이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2888af4186691fc661359ab6d5971e729720db66" translate="yes" xml:space="preserve">
          <source>Enqueues the result of preparing the LogRecord. Should an exception occur (e.g. because a bounded queue has filled up), the &lt;a href=&quot;logging#logging.Handler.handleError&quot;&gt;&lt;code&gt;handleError()&lt;/code&gt;&lt;/a&gt; method is called to handle the error. This can result in the record silently being dropped (if &lt;code&gt;logging.raiseExceptions&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;) or a message printed to &lt;code&gt;sys.stderr&lt;/code&gt; (if &lt;code&gt;logging.raiseExceptions&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;).</source>
          <target state="translated">LogRecord 준비 결과를 큐에 넣습니다. 예외가 발생하면 (예 : 경계 큐가 가득 차서) 오류를 처리하기 위해 &lt;a href=&quot;logging#logging.Handler.handleError&quot;&gt; &lt;code&gt;handleError()&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 이로 인해 레코드가 자동으로 삭제 되거나 ( &lt;code&gt;logging.raiseExceptions&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 ) &lt;code&gt;sys.stderr&lt;/code&gt; 에 메시지가 인쇄 될 수 &lt;code&gt;logging.raiseExceptions&lt;/code&gt; ( logging.raiseExceptions 가 &lt;code&gt;True&lt;/code&gt; 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="aa2754429737b3533e1ef0357b5a96fb4a6836c9" translate="yes" xml:space="preserve">
          <source>Enquiry, goes with &lt;code&gt;ACK&lt;/code&gt; flow control</source>
          <target state="translated">문의, &lt;code&gt;ACK&lt;/code&gt; 흐름 제어 와 함께</target>
        </trans-unit>
        <trans-unit id="ae5b77717b5f7a8d678dfc4e7f6ca1d4b33f96da" translate="yes" xml:space="preserve">
          <source>Ensure all logging output has been flushed. This version does nothing and is intended to be implemented by subclasses.</source>
          <target state="translated">모든 로깅 출력이 플러시되었는지 확인하십시오. 이 버전은 아무것도하지 않으며 서브 클래스에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="97cf15e5a9cea6dea99ae04c2ca52a01855adc4b" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;em&gt;item&lt;/em&gt; is visible.</source>
          <target state="translated">&lt;em&gt;항목&lt;/em&gt; 이 보이는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9aa26e76cdc98319b44465edafcf37d57d6abbaa" translate="yes" xml:space="preserve">
          <source>Ensure that all arguments to &lt;code&gt;Process.__init__()&lt;/code&gt; are picklable. Also, if you subclass &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; then make sure that instances will be picklable when the &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;Process.start&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">&lt;code&gt;Process.__init__()&lt;/code&gt; 대한 모든 인수가 선택 가능한지 확인하십시오 . 또한 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱 하는 경우 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;Process.start&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 때 인스턴스를 선택할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3c36c2f4b34cceda516e9a8a5706327c94c9ce7" translate="yes" xml:space="preserve">
          <source>Ensure that the arguments to the methods of proxies are picklable.</source>
          <target state="translated">프록시 메소드에 대한 인수가 선택 가능한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="762ec42796d5195f94b6f19b0a871c17688f7448" translate="yes" xml:space="preserve">
          <source>Ensures that enough disk space is allocated for the file specified by &lt;em&gt;fd&lt;/em&gt; starting from &lt;em&gt;offset&lt;/em&gt; and continuing for &lt;em&gt;len&lt;/em&gt; bytes.</source>
          <target state="translated">&lt;em&gt;fd에&lt;/em&gt; 의해 지정된 파일에 대해 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작 하여 &lt;em&gt;len&lt;/em&gt; 바이트 동안 계속되는 충분한 디스크 공간이 할당되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="b7eb63354554772150750f9cedad21f70a5cb44a" translate="yes" xml:space="preserve">
          <source>Ensuring unique enumeration values</source>
          <target state="translated">고유 한 열거 형 값 보장</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="8fa2a05b9d6104dc8feb95f4c534efae63c8fab5" translate="yes" xml:space="preserve">
          <source>Enter &lt;em&gt;string&lt;/em&gt; in the table of &amp;ldquo;interned&amp;rdquo; strings and return the interned string &amp;ndash; which is &lt;em&gt;string&lt;/em&gt; itself or a copy. Interning strings is useful to gain a little performance on dictionary lookup &amp;ndash; if the keys in a dictionary are interned, and the lookup key is interned, the key comparisons (after hashing) can be done by a pointer compare instead of a string compare. Normally, the names used in Python programs are automatically interned, and the dictionaries used to hold module, class or instance attributes have interned keys.</source>
          <target state="translated">&quot;interned&quot;문자열 표에 &lt;em&gt;문자열&lt;/em&gt; 을 입력 하고 &lt;em&gt;문자열&lt;/em&gt; 자체 또는 사본 인 interned 문자열을 반환합니다 . 인터 닝 문자열은 사전 룩업에서 약간의 성능을 얻는 데 유용합니다. 딕셔너리의 키가 인터 닝되고 룩업 키가 인터 론 인 경우, 문자열 비교 대신 포인터 비교를 통해 키 비교 (해시 후)를 수행 할 수 있습니다. 일반적으로 Python 프로그램에서 사용되는 이름은 자동으로 인터 닝되며 모듈, 클래스 또는 인스턴스 속성을 보유하는 데 사용되는 사전에는 인터 턴 된 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b663cf4347cd84e7bc69f1115cc575cfd52e6845" translate="yes" xml:space="preserve">
          <source>Enter a polling loop that terminates after count passes or all open channels have been closed. All arguments are optional. The &lt;em&gt;count&lt;/em&gt; parameter defaults to &lt;code&gt;None&lt;/code&gt;, resulting in the loop terminating only when all channels have been closed. The &lt;em&gt;timeout&lt;/em&gt; argument sets the timeout parameter for the appropriate &lt;a href=&quot;select#select.select&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;select#select.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; call, measured in seconds; the default is 30 seconds. The &lt;em&gt;use_poll&lt;/em&gt; parameter, if true, indicates that &lt;a href=&quot;select#select.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;select#select.select&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; (the default is &lt;code&gt;False&lt;/code&gt;).</source>
          <target state="translated">카운트 통과 또는 모든 열린 채널이 닫힌 후 종료되는 폴링 루프를 입력하십시오. 모든 인수는 선택 사항입니다. &lt;em&gt;카운트&lt;/em&gt; , 파라미터 디폴트 &lt;code&gt;None&lt;/code&gt; 모든 채널이 폐쇄되었을 때에 만 종료 루프 결과. &lt;em&gt;초과&lt;/em&gt; 인자는 적절한 타임 아웃 파라미터 세트 &lt;a href=&quot;select#select.select&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;select#select.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt; 초 단위로 측정 호출; 기본값은 30 초입니다. &lt;em&gt;use_poll의&lt;/em&gt; 매개 변수가 true의 경우, 그 표시 &lt;a href=&quot;select#select.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt; 에 우선 사용되어야한다 &lt;a href=&quot;select#select.select&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; (기본값은 &lt;code&gt;False&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf6ee635905c79fc10776a891aacc8f8db536c1a" translate="yes" xml:space="preserve">
          <source>Enter a recursive debugger that steps through the code argument (which is an arbitrary expression or statement to be executed in the current environment).</source>
          <target state="translated">코드 인수 (현재 환경에서 실행될 임의의 표현식 또는 명령문)를 단계별로 수행하는 순환 디버거를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="06cda8081b0c699a9ae8156111f134ffc77e8bf8" translate="yes" xml:space="preserve">
          <source>Enter cbreak mode. In cbreak mode (sometimes called &amp;ldquo;rare&amp;rdquo; mode) normal tty line buffering is turned off and characters are available to be read one by one. However, unlike raw mode, special characters (interrupt, quit, suspend, and flow control) retain their effects on the tty driver and calling program. Calling first &lt;a href=&quot;#curses.raw&quot;&gt;&lt;code&gt;raw()&lt;/code&gt;&lt;/a&gt; then &lt;a href=&quot;#curses.cbreak&quot;&gt;&lt;code&gt;cbreak()&lt;/code&gt;&lt;/a&gt; leaves the terminal in cbreak mode.</source>
          <target state="translated">파단 모드로 들어갑니다. cbreak 모드 ( &quot;희귀&quot;모드라고도 함)에서는 일반 tty 라인 버퍼링이 해제되고 문자를 하나씩 읽을 수 있습니다. 그러나 원시 모드와 달리 특수 문자 (인터럽트, 종료, 일시 중단 및 흐름 제어)는 tty 드라이버 및 호출 프로그램에 영향을 미칩니다. 먼저 &lt;a href=&quot;#curses.raw&quot;&gt; &lt;code&gt;raw()&lt;/code&gt; &lt;/a&gt; 를 호출 한 다음 &lt;a href=&quot;#curses.cbreak&quot;&gt; &lt;code&gt;cbreak()&lt;/code&gt; &lt;/a&gt;() 를 호출 하면 터미널이 중단 모드로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f8cea7d09a31360054e9f869e3c5d795b0458192" translate="yes" xml:space="preserve">
          <source>Enter converters.</source>
          <target state="translated">변환기를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="602385ef4a72988bf782bf33f06a8f646ad69432" translate="yes" xml:space="preserve">
          <source>Enter echo mode. In echo mode, each character input is echoed to the screen as it is entered.</source>
          <target state="translated">에코 모드로 들어갑니다. 에코 모드에서는 각 문자 입력이 입력 될 때 화면에 에코됩니다.</target>
        </trans-unit>
        <trans-unit id="429905251e2a3e543f489797d59b5a24f9ef97db" translate="yes" xml:space="preserve">
          <source>Enter newline mode. This mode translates the return key into newline on input, and translates newline into return and line-feed on output. Newline mode is initially on.</source>
          <target state="translated">개행 모드로 들어갑니다. 이 모드는 입력시 리턴 키를 줄 바꾸기로 변환하고 출력에서 ​​줄 바꾸기를 리턴 및 줄 바꿈으로 변환합니다. 개행 모드는 처음에 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b90800a714a8a3e0ab43e272c0b938df50c7db" translate="yes" xml:space="preserve">
          <source>Enter or send (unreliable)</source>
          <target state="translated">입력 또는 발송 (신뢰할 수 없음)</target>
        </trans-unit>
        <trans-unit id="7b32a1a4ed5b14160b995b3b5225adbecd8b0343" translate="yes" xml:space="preserve">
          <source>Enter post-mortem debugging of the given &lt;em&gt;traceback&lt;/em&gt; object. If no &lt;em&gt;traceback&lt;/em&gt; is given, it uses the one of the exception that is currently being handled (an exception must be being handled if the default is to be used).</source>
          <target state="translated">주어진 &lt;em&gt;역 추적&lt;/em&gt; 객체 의 사후 디버깅을 입력하십시오 . &lt;em&gt;역 추적&lt;/em&gt; 이 제공 되지 않으면 현재 처리중인 예외 중 하나를 사용합니다 (기본값을 사용하려면 예외를 처리해야합니다).</target>
        </trans-unit>
        <trans-unit id="f097b04746b05b7586d964276b16901fd65c113d" translate="yes" xml:space="preserve">
          <source>Enter post-mortem debugging of the traceback found in &lt;a href=&quot;sys#sys.last_traceback&quot;&gt;&lt;code&gt;sys.last_traceback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.last_traceback&quot;&gt; &lt;code&gt;sys.last_traceback&lt;/code&gt; &lt;/a&gt; 에있는 트레이스 백의 사후 디버깅을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ccc9469aa0d39ac8b4ae0c50a90919c84871d0d" translate="yes" xml:space="preserve">
          <source>Enter raw mode. In raw mode, normal line buffering and processing of interrupt, quit, suspend, and flow control keys are turned off; characters are presented to curses input functions one by one.</source>
          <target state="translated">원시 모드로 들어갑니다. 원시 모드에서는 일반 회선 버퍼링 및 인터럽트, 종료, 일시 중단 및 흐름 제어 키 처리가 해제됩니다. 입력 기능을 하나씩 저주하기 위해 문자가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a0dbd0b641f4836b322a1ad352c0e6127776e34d" translate="yes" xml:space="preserve">
          <source>Enter the debugger at the calling stack frame. This is useful to hard-code a breakpoint at a given point in a program, even if the code is not otherwise being debugged (e.g. when an assertion fails). If given, &lt;em&gt;header&lt;/em&gt; is printed to the console just before debugging begins.</source>
          <target state="translated">호출 스택 프레임에 디버거를 입력하십시오. 이는 코드가 달리 디버깅되지 않는 경우에도 (예 : 어설 션이 실패한 경우) 프로그램의 특정 지점에서 중단 점을 하드 코딩하는 데 유용합니다. 주어진 경우, 디버깅이 시작되기 직전에 &lt;em&gt;헤더&lt;/em&gt; 가 콘솔에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c2390d15b9f37ee098a11e644788934b4602939e" translate="yes" xml:space="preserve">
          <source>Enter the runtime context and return either this object or another object related to the runtime context. The value returned by this method is bound to the identifier in the &lt;code&gt;as&lt;/code&gt; clause of &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements using this context manager.</source>
          <target state="translated">런타임 컨텍스트를 입력하고이 오브젝트 또는 런타임 컨텍스트와 관련된 다른 오브젝트를 리턴하십시오. 이 메소드에 의해 리턴 된 값은 이 컨텍스트 관리자를 사용 하는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 &lt;code&gt;as&lt;/code&gt; 절 에서 식별자에 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a3ea35903eb24e2439f6a0e520d488eeda6c731" translate="yes" xml:space="preserve">
          <source>Entering a blank line repeats the last command entered. Exception: if the last command was a &lt;a href=&quot;#pdbcommand-list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; command, the next 11 lines are listed.</source>
          <target state="translated">빈 줄을 입력하면 마지막으로 입력 한 명령이 반복됩니다. 예외 : 마지막 명령이 &lt;a href=&quot;#pdbcommand-list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 명령 인 경우 다음 11 행이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="611a51f214fed567158739312e45abb78fbe33de" translate="yes" xml:space="preserve">
          <source>Enters a new context manager and adds its &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method to the callback stack. The return value is the result of the context manager&amp;rsquo;s own &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">새로운 컨텍스트 관리자를 시작하고 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메소드를 콜백 스택에 추가합니다. 리턴 값은 컨텍스트 관리자 자체의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 메소드 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="bd5d52ebfda30bf0319952ff2a299cea17d4e30d" translate="yes" xml:space="preserve">
          <source>Entity declarations can contain more than just text for replacement. They can also point to external resources or local files. The XML parser accesses the resource and embeds the content into the XML document.</source>
          <target state="translated">엔터티 선언에는 대체 할 텍스트 이상이 포함될 수 있습니다. 외부 리소스 나 로컬 파일을 가리킬 수도 있습니다. XML 파서는 리소스에 액세스하여 내용을 XML 문서에 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="2dbd6d3f83290ba9348b436b12d8b7daf2635aa9" translate="yes" xml:space="preserve">
          <source>EntityResolver Objects</source>
          <target state="translated">EntityResolver 객체</target>
        </trans-unit>
        <trans-unit id="953bd861b8d839338c4a580a2b0b5c9b37af0e5f" translate="yes" xml:space="preserve">
          <source>Entries are typically tuples of the form &lt;code&gt;(priority_number, data)&lt;/code&gt;.</source>
          <target state="translated">엔트리는 일반적으로 &lt;code&gt;(priority_number, data)&lt;/code&gt; 형식의 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="087b9e0aeb254cf0e900ba213fa1da3a8e9d24f1" translate="yes" xml:space="preserve">
          <source>Entries which cannot be determined are set to &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">확인할 수없는 항목은 &lt;code&gt;''&lt;/code&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="53705f2e3b68f3633d75ceaf05413bb3ba654a56" translate="yes" xml:space="preserve">
          <source>Entries which cannot be determined are set to &lt;code&gt;''&lt;/code&gt;. All tuple entries are strings.</source>
          <target state="translated">확인할 수없는 항목은 &lt;code&gt;''&lt;/code&gt; 로 설정되어 있습니다. 모든 튜플 항목은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="18f73528d44427047489bb703aa3ca755342dbbb" translate="yes" xml:space="preserve">
          <source>Entry points</source>
          <target state="translated">진입 점</target>
        </trans-unit>
        <trans-unit id="d4d3e8a2c230f83aa0e684d966714d49817aea3f" translate="yes" xml:space="preserve">
          <source>Entry widget indexes (index, view index, etc.)</source>
          <target state="translated">엔트리 위젯 인덱스 (인덱스, 뷰 인덱스 등)</target>
        </trans-unit>
        <trans-unit id="ef8f90b6c36e96a8f3138956ecec46b1d2f89b29" translate="yes" xml:space="preserve">
          <source>Entry widgets have options that refer to character positions in the text being displayed. You can use these &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; functions to access these special points in text widgets:</source>
          <target state="translated">입력 위젯에는 표시되는 텍스트에서 문자 위치를 참조하는 옵션이 있습니다. 이 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 함수를 사용 하여 텍스트 위젯에서 이러한 특수 지점에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35748b339b75707aa86eccdc826e9c484f210273" translate="yes" xml:space="preserve">
          <source>Enum Classes</source>
          <target state="translated">열거 형 클래스</target>
        </trans-unit>
        <trans-unit id="bd214812f74614a175b9a557097bf69a0bea623e" translate="yes" xml:space="preserve">
          <source>Enum Members (aka instances)</source>
          <target state="translated">열거 형 멤버 (일명 인스턴스)</target>
        </trans-unit>
        <trans-unit id="5b06633b47e3b3d368410e3fcb03bd07f5b3d58c" translate="yes" xml:space="preserve">
          <source>Enum Name</source>
          <target state="translated">열거 형 이름</target>
        </trans-unit>
        <trans-unit id="74cee2f76b2f08d1d822a0ac94ba9d489a4bdb9e" translate="yes" xml:space="preserve">
          <source>Enum class decorator that ensures only one name is bound to any one value.</source>
          <target state="translated">하나의 이름 만 하나의 값에 바인딩되도록하는 Enum 클래스 데코레이터.</target>
        </trans-unit>
        <trans-unit id="4a5bc6fdb389a921b77691f1ae62efd63242c0e2" translate="yes" xml:space="preserve">
          <source>Enum member values</source>
          <target state="translated">열거 형 멤버 값</target>
        </trans-unit>
        <trans-unit id="3d0a2cd7fcbb6a833c1876f5c6fae7bafe7f2441" translate="yes" xml:space="preserve">
          <source>Enum members also have a property that contains just their item name:</source>
          <target state="translated">열거 형 멤버에는 항목 이름 만 포함 된 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8abe6035a83a26f86fc58e8f94b33a048f67de" translate="yes" xml:space="preserve">
          <source>Enumerate the children of the current directory.</source>
          <target state="translated">현재 디렉토리의 자식을 열거합니다.</target>
        </trans-unit>
        <trans-unit id="d908e41face2db6aa2e63d82a5d94ab42f2201db" translate="yes" xml:space="preserve">
          <source>Enumerates subkeys of an open registry key, returning a string.</source>
          <target state="translated">열린 레지스트리 키의 하위 키를 열거하고 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="672127fd3527f8fc48242253b35034acf2091efe" translate="yes" xml:space="preserve">
          <source>Enumerates values of an open registry key, returning a tuple.</source>
          <target state="translated">열린 레지스트리 키의 값을 열거하고 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3fb14da66a56415bff0ad761c36d594d42bedbae" translate="yes" xml:space="preserve">
          <source>Enumeration members are compared by identity:</source>
          <target state="translated">열거 멤버는 ID로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="1178a57aa7859712c54c6114945255e34205b1e4" translate="yes" xml:space="preserve">
          <source>Enumeration members are hashable, so they can be used in dictionaries and sets:</source>
          <target state="translated">열거 형 멤버는 해시 가능하므로 사전 및 세트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e472257922d05bccf3578137ac9fc6b17ee1a5f2" translate="yes" xml:space="preserve">
          <source>Enumeration members have human readable string representations:</source>
          <target state="translated">열거 형 멤버에는 사람이 읽을 수있는 문자열 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0a466f4da4a792ee601c1958443d6ace0821a6" translate="yes" xml:space="preserve">
          <source>Enumerations are Python classes, and can have methods and special methods as usual. If we have this enumeration:</source>
          <target state="translated">열거 형은 Python 클래스이며 평소와 같이 메서드와 특수 메서드를 가질 수 있습니다. 이 열거 형이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="40f561f88b2257b63cb2fb13e1fe24beff58df37" translate="yes" xml:space="preserve">
          <source>Enumerations are created using the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; syntax, which makes them easy to read and write. An alternative creation method is described in &lt;a href=&quot;#functional-api&quot;&gt;Functional API&lt;/a&gt;. To define an enumeration, subclass &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">열거는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt; &lt;code&gt;class&lt;/code&gt; &lt;/a&gt; 구문을 사용하여 작성 되므로 쉽게 읽고 쓸 수 있습니다. 대체 작성 방법은 &lt;a href=&quot;#functional-api&quot;&gt;Functional API에&lt;/a&gt; 설명되어 있습니다. 열거를 정의하려면 다음과 같이 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 을 서브 클래스로 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="916080f51e0a1e47a17a417292d676be5cdcc6c5" translate="yes" xml:space="preserve">
          <source>Enumerations can be pickled and unpickled:</source>
          <target state="translated">열거는 피클 링 및 피클 링 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa830c866023673c4f9348a0f95ab021df8ef05" translate="yes" xml:space="preserve">
          <source>Enumerations support iteration, in definition order:</source>
          <target state="translated">열거는 정의 순서로 반복을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="922ed09b766daccfca53d5df49778614ae54ae66" translate="yes" xml:space="preserve">
          <source>Enums have a custom metaclass that affects many aspects of both derived Enum classes and their instances (members).</source>
          <target state="translated">열거 형에는 파생 된 열거 형 클래스와 해당 인스턴스 (멤버)의 여러 측면에 영향을주는 사용자 지정 메타 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="52290975d27191c5718cc3c19935ef179fd55b88" translate="yes" xml:space="preserve">
          <source>Environment example:</source>
          <target state="translated">환경 예 :</target>
        </trans-unit>
        <trans-unit id="7acfb9859940856ef732a50aabb8e6e5a634d65f" translate="yes" xml:space="preserve">
          <source>EnvironmentError</source>
          <target state="translated">EnvironmentError</target>
        </trans-unit>
        <trans-unit id="7a9900d84e1403f9c455cfd34c5bb3f62971e633" translate="yes" xml:space="preserve">
          <source>Equality</source>
          <target state="translated">Equality</target>
        </trans-unit>
        <trans-unit id="0ea9631890f3c3ddadbb49be5feb1a38c4f675ab" translate="yes" xml:space="preserve">
          <source>Equality comparisons are defined though:</source>
          <target state="translated">평등 비교는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bd00d2fa4ce7f9b3799e9324d37d66327650eef7" translate="yes" xml:space="preserve">
          <source>Equality tests between &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; objects are order-sensitive and are implemented as &lt;code&gt;list(od1.items())==list(od2.items())&lt;/code&gt;. Equality tests between &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; objects and other &lt;a href=&quot;collections.abc#collections.abc.Mapping&quot;&gt;&lt;code&gt;Mapping&lt;/code&gt;&lt;/a&gt; objects are order-insensitive like regular dictionaries. This allows &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; objects to be substituted anywhere a regular dictionary is used.</source>
          <target state="translated">&lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; &lt;/a&gt; 객체 간의 동일성 테스트 는 순서에 민감하며 &lt;code&gt;list(od1.items())==list(od2.items())&lt;/code&gt; 됩니다. &lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; &lt;/a&gt; 객체와 다른 &lt;a href=&quot;collections.abc#collections.abc.Mapping&quot;&gt; &lt;code&gt;Mapping&lt;/code&gt; &lt;/a&gt; 객체 간의 동일성 테스트는 일반 사전과 같이 순서에 영향을받지 않습니다. 이를 통해 &lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; &lt;/a&gt; 객체를 일반 사전이 사용되는 모든 위치로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ce4cfe7855e867407978f9c2806aa92588f0fa" translate="yes" xml:space="preserve">
          <source>Equivalent to 0 (ie. all of the above Netscape domain strictness flags switched off).</source>
          <target state="translated">0과 같습니다 (즉, 위의 모든 Netscape 도메인 엄격 플래그가 꺼져 있음).</target>
        </trans-unit>
        <trans-unit id="3e1a831f3885fcf01724787c32f8ff7381b26db1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#email.message.EmailMessage.as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt;. Allows &lt;code&gt;bytes(msg)&lt;/code&gt; to produce a bytes object containing the serialized message.</source>
          <target state="translated">&lt;a href=&quot;#email.message.EmailMessage.as_bytes&quot;&gt; &lt;code&gt;as_bytes()&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 허용 &lt;code&gt;bytes(msg)&lt;/code&gt; 바이트 직렬화 된 메시지를 포함하는 오브젝트를 생성한다.</target>
        </trans-unit>
        <trans-unit id="d9cce4bbb04162f7733d5750ecd4d39c58ff074b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#email.message.Message.as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt;. Allows &lt;code&gt;bytes(msg)&lt;/code&gt; to produce a bytes object containing the formatted message.</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message.as_bytes&quot;&gt; &lt;code&gt;as_bytes()&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 수 &lt;code&gt;bytes(msg)&lt;/code&gt; 바이트는 형식의 메시지를 포함하는 객체를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59158a5ff65138652445ed251a27dc21a6e9150e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#email.message.Message.as_string&quot;&gt;&lt;code&gt;as_string()&lt;/code&gt;&lt;/a&gt;. Allows &lt;code&gt;str(msg)&lt;/code&gt; to produce a string containing the formatted message.</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message.as_string&quot;&gt; &lt;code&gt;as_string()&lt;/code&gt; &lt;/a&gt; 같습니다 . 수 &lt;code&gt;str(msg)&lt;/code&gt; 형식화 된 메시지를 포함하는 문자열을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f56c313d1897cc5bd915d14d383918de3b15796" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#gettext.GNUTranslations.gettext&quot;&gt;&lt;code&gt;gettext()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#gettext.GNUTranslations.ngettext&quot;&gt;&lt;code&gt;ngettext()&lt;/code&gt;&lt;/a&gt;, but the translation is returned as a byte string encoded in the preferred system encoding if no encoding was explicitly set with &lt;a href=&quot;#gettext.NullTranslations.set_output_charset&quot;&gt;&lt;code&gt;set_output_charset()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동등 &lt;a href=&quot;#gettext.GNUTranslations.gettext&quot;&gt; &lt;code&gt;gettext()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#gettext.GNUTranslations.ngettext&quot;&gt; &lt;code&gt;ngettext()&lt;/code&gt; &lt;/a&gt; 되지만 부호화가 명시 적으로 설정하지 않았다면 번역이 바람직한 시스템 인코딩으로 인코딩 된 바이트의 문자열로 반환 &lt;a href=&quot;#gettext.NullTranslations.set_output_charset&quot;&gt; &lt;code&gt;set_output_charset()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b929dcdf93e833942100bcfd2521eb537f4575c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#gettext.NullTranslations.gettext&quot;&gt;&lt;code&gt;gettext()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#gettext.NullTranslations.ngettext&quot;&gt;&lt;code&gt;ngettext()&lt;/code&gt;&lt;/a&gt;, but the translation is returned as a byte string encoded in the preferred system encoding if no encoding was explicitly set with &lt;a href=&quot;#gettext.NullTranslations.set_output_charset&quot;&gt;&lt;code&gt;set_output_charset()&lt;/code&gt;&lt;/a&gt;. Overridden in derived classes.</source>
          <target state="translated">동등 &lt;a href=&quot;#gettext.NullTranslations.gettext&quot;&gt; &lt;code&gt;gettext()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#gettext.NullTranslations.ngettext&quot;&gt; &lt;code&gt;ngettext()&lt;/code&gt; &lt;/a&gt; 되지만 부호화가 명시 적으로 설정하지 않았다면 번역이 바람직한 시스템 인코딩으로 인코딩 된 바이트의 문자열로 반환 &lt;a href=&quot;#gettext.NullTranslations.set_output_charset&quot;&gt; &lt;code&gt;set_output_charset()&lt;/code&gt; &lt;/a&gt; . 파생 클래스에서 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="02563697a0fa57e5ce1168a5733d29d5e6f44a1a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#winreg.KEY_READ&quot;&gt;&lt;code&gt;KEY_READ&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#winreg.KEY_READ&quot;&gt; &lt;code&gt;KEY_READ&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="69dff8b0d9537ee5a976ee7fb9f22df6af014657" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;'grouping'&lt;/code&gt;, used for monetary values.</source>
          <target state="translated">화폐 가치에 사용되는 &lt;code&gt;'grouping'&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6fd5ba978072c7d2a6ca1194f41377f2f6c02509" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;DomainStrictNoDots|DomainStrictNonDomain&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DomainStrictNoDots|DomainStrictNonDomain&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d9577878c711c65c19c4d1a6b45fc26fa77f1b8c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;EPOLLIN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EPOLLIN&lt;/code&gt; 과 동일</target>
        </trans-unit>
        <trans-unit id="2443801768eb95d9756d03d866b00db3da79813a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;EPOLLOUT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EPOLLOUT&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="5c75de4891c94ac80ca2797e5676efa9d38daabd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;as_string(policy=self.policy.clone(utf8=True))&lt;/code&gt;. Allows &lt;code&gt;str(msg)&lt;/code&gt; to produce a string containing the serialized message in a readable format.</source>
          <target state="translated">상당 &lt;code&gt;as_string(policy=self.policy.clone(utf8=True))&lt;/code&gt; . 허용 &lt;code&gt;str(msg)&lt;/code&gt; 읽을 수있는 형식으로 직렬화 된 메시지를 포함하는 문자열을 생성한다.</target>
        </trans-unit>
        <trans-unit id="498f574627ce47a8c97257efb3e593bf179bd84b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;get(False)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get(False)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="882d9b2b409ad6b7450f6c950c6fa3b50fddd662" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;not key in d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not key in d&lt;/code&gt; 를 입력 하지 않는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1411dd558ed3d5c3b0e3e1943566fb197cdb665f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;pencolor(colorstring1)&lt;/code&gt; and &lt;code&gt;fillcolor(colorstring2)&lt;/code&gt; and analogously if the other input format is used.</source>
          <target state="translated">상당 &lt;code&gt;pencolor(colorstring1)&lt;/code&gt; 과 &lt;code&gt;fillcolor(colorstring2)&lt;/code&gt; 과 유사하게, 다른 입력 형식을 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="d3e0663e7f56bca65438c71c5ecf53a3ac03e471" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;put(item)&lt;/code&gt;, provided for compatibility with &lt;a href=&quot;#queue.Queue.put_nowait&quot;&gt;&lt;code&gt;Queue.put_nowait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">등가 &lt;code&gt;put(item)&lt;/code&gt; 과의 호환성을 위해 제공 &lt;a href=&quot;#queue.Queue.put_nowait&quot;&gt; &lt;code&gt;Queue.put_nowait()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cf151630145678e1c1abceeac6eb7289eb99e6b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;put(item, False)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;put(item, False)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2c64df04b46764b2b3b68b2579acfafb0a714f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;put(obj, False)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;put(obj, False)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fa7377fb4a7fcc696f633b01dc35eb725c5ff01c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;tputs(str, 1, putchar)&lt;/code&gt;; emit the value of a specified terminfo capability for the current terminal. Note that the output of &lt;a href=&quot;#curses.putp&quot;&gt;&lt;code&gt;putp()&lt;/code&gt;&lt;/a&gt; always goes to standard output.</source>
          <target state="translated">&lt;code&gt;tputs(str, 1, putchar)&lt;/code&gt; 와 동일합니다 . 현재 터미널에 대해 지정된 terminfo 기능의 값을 내 보냅니다. &lt;a href=&quot;#curses.putp&quot;&gt; &lt;code&gt;putp()&lt;/code&gt; &lt;/a&gt; 의 출력은 항상 표준 출력으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1e63fcd5fb787d4a3c6b9d9ed88dfe3dca78e6d4" translate="yes" xml:space="preserve">
          <source>Equivalent to the corresponding functions without the &lt;code&gt;l&lt;/code&gt; prefix (&lt;a href=&quot;#gettext.gettext&quot;&gt;&lt;code&gt;gettext()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#gettext.dgettext&quot;&gt;&lt;code&gt;dgettext()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#gettext.ngettext&quot;&gt;&lt;code&gt;ngettext()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#gettext.dngettext&quot;&gt;&lt;code&gt;dngettext()&lt;/code&gt;&lt;/a&gt;), but the translation is returned as a byte string encoded in the preferred system encoding if no other encoding was explicitly set with &lt;a href=&quot;#gettext.bind_textdomain_codeset&quot;&gt;&lt;code&gt;bind_textdomain_codeset()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; 접두사 ( &lt;a href=&quot;#gettext.gettext&quot;&gt; &lt;code&gt;gettext()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#gettext.dgettext&quot;&gt; &lt;code&gt;dgettext()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#gettext.ngettext&quot;&gt; &lt;code&gt;ngettext()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#gettext.dngettext&quot;&gt; &lt;code&gt;dngettext()&lt;/code&gt; &lt;/a&gt; )가 없는 해당 함수 와 동일 하지만 다른 인코딩을 사용하여 명시 적으로 설정하지 않은 경우 기본 시스템 인코딩에서 인코딩 된 바이트 문자열로 변환이 리턴됩니다. &lt;a href=&quot;#gettext.bind_textdomain_codeset&quot;&gt; &lt;code&gt;bind_textdomain_codeset()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="315728e0990367d75d40e64feff3d637283509e1" translate="yes" xml:space="preserve">
          <source>Erase from cursor to the end of the line.</source>
          <target state="translated">커서에서 줄 끝까지 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="4619259d1590500b34cdd053102b2bb5cb08a27d" translate="yes" xml:space="preserve">
          <source>Erase from cursor to the end of the window: all lines below the cursor are deleted, and then the equivalent of &lt;a href=&quot;#curses.window.clrtoeol&quot;&gt;&lt;code&gt;clrtoeol()&lt;/code&gt;&lt;/a&gt; is performed.</source>
          <target state="translated">커서에서 창 끝까지 지우기 : 커서 아래의 모든 행이 삭제 된 다음 &lt;a href=&quot;#curses.window.clrtoeol&quot;&gt; &lt;code&gt;clrtoeol()&lt;/code&gt; &lt;/a&gt; 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="d3e856491e1bc6fd30d79529b1024eb08ed1e4e9" translate="yes" xml:space="preserve">
          <source>Error Handlers</source>
          <target state="translated">오류 처리기</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="4c6986de1c86cf9ac917927e4adfec8f6bfe5614" translate="yes" xml:space="preserve">
          <source>Error Handling API</source>
          <target state="translated">오류 처리 API</target>
        </trans-unit>
        <trans-unit id="9e8a18bdf1224aba7c5640dca2752cb0f27bda94" translate="yes" xml:space="preserve">
          <source>Error condition happened on the assoc. fd</source>
          <target state="translated">Assoc에서 오류 조건이 발생했습니다. fd</target>
        </trans-unit>
        <trans-unit id="c06a4667ab2007b00a3679ad01f2c2deae43bffe" translate="yes" xml:space="preserve">
          <source>Error condition of some sort</source>
          <target state="translated">어떤 종류의 오류 조건</target>
        </trans-unit>
        <trans-unit id="e4a425fe29ba88e41be9834c2976e81cdd62ab0e" translate="yes" xml:space="preserve">
          <source>Error handling is done in the same way as defined for the stream readers and writers.</source>
          <target state="translated">오류 처리는 스트림 판독기 및 기록기에 정의 된 것과 같은 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0ce0e9091d4c585a750b4f74ffd57e53b22799a3" translate="yes" xml:space="preserve">
          <source>Error occurred during establishment of a connection with the server.</source>
          <target state="translated">서버와의 연결을 설정하는 동안 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2aad66e5d2aeba2dd907b4c02fdd7536e059af24" translate="yes" xml:space="preserve">
          <source>Error raised when an unpicklable object is encountered by &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt;. It inherits &lt;a href=&quot;#pickle.PickleError&quot;&gt;&lt;code&gt;PickleError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 가 피클 링 할 수없는 객체를 발견하면 오류가 발생했습니다 . &lt;a href=&quot;#pickle.PickleError&quot;&gt; &lt;code&gt;PickleError&lt;/code&gt; 를&lt;/a&gt; 상속 받습니다 .</target>
        </trans-unit>
        <trans-unit id="700cc5c8bc3311f1f7de53ead5e890a4d6df4103" translate="yes" xml:space="preserve">
          <source>Error raised when there is a problem unpickling an object, such as a data corruption or a security violation. It inherits &lt;a href=&quot;#pickle.PickleError&quot;&gt;&lt;code&gt;PickleError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터 손상 또는 보안 위반과 같은 개체를 언 클링하는 데 문제가있을 때 발생하는 오류입니다. &lt;a href=&quot;#pickle.PickleError&quot;&gt; &lt;code&gt;PickleError&lt;/code&gt; 를&lt;/a&gt; 상속 받습니다 .</target>
        </trans-unit>
        <trans-unit id="1bd7165001d6a8de56949614e8427bb6f024f601" translate="yes" xml:space="preserve">
          <source>ErrorHandler Objects</source>
          <target state="translated">ErrorHandler 객체</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="9777fd6046fd2b79471201c70d64c950708d6028" translate="yes" xml:space="preserve">
          <source>Errors are reported as exceptions; the usual exceptions are given for type errors, while errors reported by the system calls raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오류는 예외로보고됩니다. 시스템 오류에 의해보고 된 오류는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 를 발생시키는 동안 유형 오류에 대한 일반적인 예외가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="a3ca63fcb126584c7cbc69cb44097bc0a98431f5" translate="yes" xml:space="preserve">
          <source>Escape &lt;code&gt;'&amp;amp;'&lt;/code&gt;, &lt;code&gt;'&amp;lt;'&lt;/code&gt;, and &lt;code&gt;'&amp;gt;'&lt;/code&gt; in a string of data.</source>
          <target state="translated">데이터 문자열에서 &lt;code&gt;'&amp;amp;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; 및 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 이스케이프</target>
        </trans-unit>
        <trans-unit id="87b0bd467ee85b7f8847d9eb3649852161ccbc0c" translate="yes" xml:space="preserve">
          <source>Escape all special characters (&lt;code&gt;'?'&lt;/code&gt;, &lt;code&gt;'*'&lt;/code&gt; and &lt;code&gt;'['&lt;/code&gt;). This is useful if you want to match an arbitrary literal string that may have special characters in it. Special characters in drive/UNC sharepoints are not escaped, e.g. on Windows &lt;code&gt;escape('//?/c:/Quo vadis?.txt')&lt;/code&gt; returns &lt;code&gt;'//?/c:/Quo vadis[?].txt'&lt;/code&gt;.</source>
          <target state="translated">모든 특수 문자 ( &lt;code&gt;'?'&lt;/code&gt; , &lt;code&gt;'*'&lt;/code&gt; 및 &lt;code&gt;'['&lt;/code&gt; )를 이스케이프하십시오 . 특수 문자가 포함 된 임의의 리터럴 문자열과 일치시키려는 경우에 유용합니다. 드라이브 / UNC 공유 점의 특수 문자는 이스케이프되지 않습니다. 예를 들어 Windows &lt;code&gt;escape('//?/c:/Quo vadis?.txt')&lt;/code&gt; 는 &lt;code&gt;'//?/c:/Quo vadis[?].txt'&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="645fe693ac8b623ab59ba5a913fa56e06ea5cf34" translate="yes" xml:space="preserve">
          <source>Escape characters are not recognized;</source>
          <target state="translated">이스케이프 문자는 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c8ea8bc4f65d5bfd8546e074c6c3ed1833a24b0" translate="yes" xml:space="preserve">
          <source>Escape special characters in &lt;em&gt;pattern&lt;/em&gt;. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example:</source>
          <target state="translated">&lt;em&gt;패턴&lt;/em&gt; 에서 특수 문자를 이스케이프 처리하십시오 . 정규 표현식 메타 문자가있을 수있는 임의의 리터럴 문자열을 일치시키려는 경우에 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d0a36d2b4f6f39c281a11428ee518d9f087808c" translate="yes" xml:space="preserve">
          <source>Esperanto, Maltese</source>
          <target state="translated">에스페란토, 몰타어</target>
        </trans-unit>
        <trans-unit id="b9603ee7bcecaa495cbf6687553a3756c705570d" translate="yes" xml:space="preserve">
          <source>Essentially, transports and protocols should only be used in libraries and frameworks and never in high-level asyncio applications.</source>
          <target state="translated">기본적으로 전송 및 프로토콜은 라이브러리 및 프레임 워크에서만 사용해야하며 고급 asyncio 애플리케이션에서는 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0946aa68f0bba7f1fbe4c3793c30db49bbee67bd" translate="yes" xml:space="preserve">
          <source>Establish a TCP connection.</source>
          <target state="translated">TCP 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d2d166fb4f8060af809ab3750f0779c96f2c2772" translate="yes" xml:space="preserve">
          <source>Establish a Unix socket connection and return a pair of &lt;code&gt;(reader, writer)&lt;/code&gt;.</source>
          <target state="translated">유닉스 소켓 연결을 설정하고 &lt;code&gt;(reader, writer)&lt;/code&gt; 쌍을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f41b06a3c2e0f7210c8c5ea4a7a815d0f61f476" translate="yes" xml:space="preserve">
          <source>Establish a Unix socket connection.</source>
          <target state="translated">유닉스 소켓 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="27ddc90aba864b61e63ca9fcab375d32046e5f68" translate="yes" xml:space="preserve">
          <source>Establish a network connection and return a pair of &lt;code&gt;(reader, writer)&lt;/code&gt; objects.</source>
          <target state="translated">네트워크 연결을 설정하고 한 쌍의 &lt;code&gt;(reader, writer)&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b33dfb090a73f3e7fa9ec19387939863ce9a9697" translate="yes" xml:space="preserve">
          <source>Establishes a connection to a predefined registry handle on another computer, and returns a &lt;a href=&quot;#handle-object&quot;&gt;handle object&lt;/a&gt;.</source>
          <target state="translated">다른 컴퓨터에서 사전 정의 된 레지스트리 핸들에 연결하고 &lt;a href=&quot;#handle-object&quot;&gt;핸들 오브젝트를&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="46eac8641b41a554c4af978ac95022766230c363" translate="yes" xml:space="preserve">
          <source>Establishes an arbitrary timer</source>
          <target state="translated">임의 타이머 설정</target>
        </trans-unit>
        <trans-unit id="387507d9043a48f9895cfaa2673836fe0752cb7a" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;em&gt;expression&lt;/em&gt; (given as a string or a code object) under debugger control. When &lt;a href=&quot;#pdb.runeval&quot;&gt;&lt;code&gt;runeval()&lt;/code&gt;&lt;/a&gt; returns, it returns the value of the expression. Otherwise this function is similar to &lt;a href=&quot;#pdb.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">디버거 제어 에서 &lt;em&gt;표현식&lt;/em&gt; (문자열 또는 코드 오브젝트로 제공)을 평가하십시오 . 때 &lt;a href=&quot;#pdb.runeval&quot;&gt; &lt;code&gt;runeval()&lt;/code&gt; &lt;/a&gt; 반환 할 때 식의 값을 반환합니다. 그렇지 않으면이 함수는 &lt;a href=&quot;#pdb.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="bbd8f1d5e5391f6492fcec6625b513a0bb874fcf" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;em&gt;expression&lt;/em&gt; in the current context and print its value.</source>
          <target state="translated">현재 컨텍스트에서 &lt;em&gt;표현식&lt;/em&gt; 을 평가하고 해당 값을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="2e025428974165b15278efafd9c9b0d22a029d83" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;n! / (k! * (n - k)!)&lt;/code&gt; when &lt;code&gt;k &amp;lt;= n&lt;/code&gt; and evaluates to zero when &lt;code&gt;k &amp;gt; n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n! / (k! * (n - k)!)&lt;/code&gt; 평가합니다 ! / (K * (N! - K)!) &lt;code&gt;k &amp;lt;= n&lt;/code&gt; 과 평가하여 제로 &lt;code&gt;k &amp;gt; n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db06d1f9400c9b6f59b6bcb16845f15ee0707af4" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;n! / (n - k)!&lt;/code&gt; when &lt;code&gt;k &amp;lt;= n&lt;/code&gt; and evaluates to zero when &lt;code&gt;k &amp;gt; n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n! / (n - k)!&lt;/code&gt; 평가합니다 ! / (n-k)! 경우 &lt;code&gt;k &amp;lt;= n&lt;/code&gt; 제로하고 평가하여 &lt;code&gt;k &amp;gt; n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b97d45e2e76a4e66439f778565d0ee17e1fde472" translate="yes" xml:space="preserve">
          <source>Even if two unicode strings are normalized and look the same to a human reader, if one has combining characters and the other doesn&amp;rsquo;t, they may not compare equal.</source>
          <target state="translated">두 개의 유니 코드 문자열이 정규화되어 인간의 독자와 동일하게 보이지만 하나는 결합 문자가 있고 다른 하나는 그렇지 않은 경우 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2371ef0b3d2525f10074eb1b01da734606274be" translate="yes" xml:space="preserve">
          <source>Even the higher-level file copying functions (&lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;shutil.copy()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;shutil.copy2()&lt;/code&gt;&lt;/a&gt;) cannot copy all file metadata.</source>
          <target state="translated">고급 파일 복사 기능 ( &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;shutil.copy()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;shutil.copy2()&lt;/code&gt; &lt;/a&gt; ) 조차도 모든 파일 메타 데이터를 복사 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="499bbe4b0828963aced093b14a412aa05bcf8a05" translate="yes" xml:space="preserve">
          <source>Even though &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; does not declare &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;write()&lt;/code&gt; because their signatures will vary, implementations and clients should consider those methods part of the interface. Also, implementations may raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#io.UnsupportedOperation&quot;&gt;&lt;code&gt;UnsupportedOperation&lt;/code&gt;&lt;/a&gt;) when operations they do not support are called.</source>
          <target state="translated">비록 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 선언하지 않습니다 &lt;code&gt;read()&lt;/code&gt; 또는 &lt;code&gt;write()&lt;/code&gt; 자신의 서명이 달라질 수 있기 때문에, 구현 및 클라이언트는 인터페이스의 이러한 메소드 부분을 고려해야한다. 또한 구현이 지원하지 않는 작업이 호출 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 구현시 ValueError (또는 &lt;a href=&quot;#io.UnsupportedOperation&quot;&gt; &lt;code&gt;UnsupportedOperation&lt;/code&gt; &lt;/a&gt; )가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7263b2f6cfc43f8cba961ab3031692280b00432" translate="yes" xml:space="preserve">
          <source>Even though &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt;&lt;code&gt;FunctionTestCase&lt;/code&gt;&lt;/a&gt; can be used to quickly convert an existing test base over to a &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;-based system, this approach is not recommended. Taking the time to set up proper &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; subclasses will make future test refactorings infinitely easier.</source>
          <target state="translated">비록 &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt; &lt;code&gt;FunctionTestCase&lt;/code&gt; 이&lt;/a&gt; 빠르게에 걸쳐 기존의 테스트 기반으로 변환하는 데 사용할 수있는 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 기반 시스템을,이 방법은 사용하지 않는 것이 좋습니다. 적절한 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 서브 클래스 를 설정하기 위해 시간을 내면 향후 테스트 리팩토링이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="ff19b36ae0ff27e7c6b431a5884cd7d3d669658d" translate="yes" xml:space="preserve">
          <source>Even though there&amp;rsquo;s a native keyed hashing mode, BLAKE2 can, of course, be used in HMAC construction with &lt;a href=&quot;hmac#module-hmac&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">기본 키 해싱 모드가 있더라도 BLAKE2는 물론 &lt;a href=&quot;hmac#module-hmac&quot;&gt; &lt;code&gt;hmac&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 HMAC 구성에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7f036ced6014aec397327a4880396286c4f3e4e" translate="yes" xml:space="preserve">
          <source>Even though we use the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; syntax to create Enums, Enums are not normal Python classes. See &lt;a href=&quot;#how-are-enums-different&quot;&gt;How are Enums different?&lt;/a&gt; for more details.</source>
          <target state="translated">비록 우리가 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt; &lt;code&gt;class&lt;/code&gt; &lt;/a&gt; 구문을 사용하여 Enum을 생성 하더라도 Enum은 일반적인 Python 클래스가 아닙니다. &lt;a href=&quot;#how-are-enums-different&quot;&gt;열거 형&lt;/a&gt; 은 어떻게 다릅니 까? 상세 사항은.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="16cdaf23858a23440a22c418d4c6b612df6fdb46" translate="yes" xml:space="preserve">
          <source>Event Loop</source>
          <target state="translated">이벤트 루프</target>
        </trans-unit>
        <trans-unit id="5576dbff159fec8a46dbd0a52a25671fa3b9372e" translate="yes" xml:space="preserve">
          <source>Event Loop Implementations</source>
          <target state="translated">이벤트 루프 구현</target>
        </trans-unit>
        <trans-unit id="77a9a7549edf389a9cb37745d2e54aceacf3da51" translate="yes" xml:space="preserve">
          <source>Event Loop Methods</source>
          <target state="translated">이벤트 루프 방법</target>
        </trans-unit>
        <trans-unit id="a67706b3e7508f740414461219436fc9a73e214a" translate="yes" xml:space="preserve">
          <source>Event Loop Policies</source>
          <target state="translated">이벤트 루프 정책</target>
        </trans-unit>
        <trans-unit id="6c2ed30703b4deb10039f26a41c46d82ade3869e" translate="yes" xml:space="preserve">
          <source>Event Objects</source>
          <target state="translated">이벤트 객체</target>
        </trans-unit>
        <trans-unit id="440fcc4d594dae931e312babd2de1b9b3d2a28fc" translate="yes" xml:space="preserve">
          <source>Event loop provides mechanisms to schedule callback functions to be called at some point in the future. Event loop uses monotonic clocks to track time.</source>
          <target state="translated">이벤트 루프는 향후 어느 시점에서 콜백 함수가 호출되도록 예약하는 메커니즘을 제공합니다. 이벤트 루프는 단조로운 시계를 사용하여 시간을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="62e71e6548032c1c325d64816dbf74d764e0c929" translate="yes" xml:space="preserve">
          <source>Event loops have &lt;strong&gt;low-level&lt;/strong&gt; APIs for the following:</source>
          <target state="translated">이벤트 루프에는 다음에 대한 &lt;strong&gt;저수준&lt;/strong&gt; API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="517d8715e77155c962befa306539460c53898616" translate="yes" xml:space="preserve">
          <source>Event loops use cooperative scheduling: an event loop runs one Task at a time. While a Task awaits for the completion of a Future, the event loop runs other Tasks, callbacks, or performs IO operations.</source>
          <target state="translated">이벤트 루프는 협력 스케줄링을 사용합니다. 이벤트 루프는 한 번에 하나의 작업을 실행합니다. 작업이 미래의 완료를 기다리는 동안 이벤트 루프는 다른 작업을 실행하거나 콜백하거나 IO 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ced38f1f5acc3782ecfa5e0a5049aac2064b7102" translate="yes" xml:space="preserve">
          <source>Event methods, such as &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_server&quot;&gt;&lt;code&gt;loop.create_unix_server()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_connection&quot;&gt;&lt;code&gt;loop.create_unix_connection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_accepted_socket&quot;&gt;&lt;code&gt;loop.connect_accepted_socket()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt;&lt;code&gt;loop.connect_read_pipe()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;loop.connect_write_pipe()&lt;/code&gt;&lt;/a&gt; accept factories that return streaming protocols.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_server&quot;&gt; &lt;code&gt;loop.create_unix_server()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_connection&quot;&gt; &lt;code&gt;loop.create_unix_connection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_accepted_socket&quot;&gt; &lt;code&gt;loop.connect_accepted_socket()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt; &lt;code&gt;loop.connect_read_pipe()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;loop.connect_write_pipe()&lt;/code&gt; &lt;/a&gt; 와 같은 이벤트 메소드 는 스트리밍 프로토콜을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2666c7b871ccb15924b349d18cdc53f00b1b05d" translate="yes" xml:space="preserve">
          <source>Event port.</source>
          <target state="translated">이벤트 포트.</target>
        </trans-unit>
        <trans-unit id="c09e1c6446bbff501e408ad68773effacce68f7c" translate="yes" xml:space="preserve">
          <source>Events provided in a previous call to &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.read_events&quot;&gt;&lt;code&gt;read_events()&lt;/code&gt;&lt;/a&gt; will not be yielded again. Events are consumed from the internal queue only when they are retrieved from the iterator, so multiple readers iterating in parallel over iterators obtained from &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.read_events&quot;&gt;&lt;code&gt;read_events()&lt;/code&gt;&lt;/a&gt; will have unpredictable results.</source>
          <target state="translated">&lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.read_events&quot;&gt; &lt;code&gt;read_events()&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출에서 제공된 이벤트 는 다시 생성되지 않습니다. 이벤트가 반복자에서 검색 될 때만 내부 큐에서 이벤트가 소비되므로 &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.read_events&quot;&gt; &lt;code&gt;read_events()&lt;/code&gt; &lt;/a&gt; 에서 얻은 반복자에 대해 병렬로 반복되는 여러 독자 가 예측할 수없는 결과를 갖게됩니다.</target>
        </trans-unit>
        <trans-unit id="87f71e1dc2cd3d8c17bb5319ed639fa3a8cf8f61" translate="yes" xml:space="preserve">
          <source>Events that must be waited for on this file object.</source>
          <target state="translated">이 파일 객체에서 기다려야하는 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="adeeb9efa131202d0465b43c1ad89c9661314fa7" translate="yes" xml:space="preserve">
          <source>Ever since the SSL module was introduced in Python 2.6, the &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; class has provided two related but distinct areas of functionality:</source>
          <target state="translated">SSL 2.6이 Python 2.6에 도입 된 이후로 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 클래스는 두 가지 관련이 있지만 고유 한 기능 영역을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="3c376cc3b04f0eda118d988e7f66f6dd0fa1fb91" translate="yes" xml:space="preserve">
          <source>Every distribution includes some metadata, which you can extract using the &lt;code&gt;metadata()&lt;/code&gt; function:</source>
          <target state="translated">모든 배포에는 &lt;code&gt;metadata()&lt;/code&gt; 함수를 사용하여 추출 할 수있는 일부 메타 데이터가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="5790b30b90561d5789c25e94ba42cf2105a4a907" translate="yes" xml:space="preserve">
          <source>Every handler with a method named like &lt;code&gt;&amp;lt;protocol&amp;gt;_request()&lt;/code&gt; has that method called to pre-process the request.</source>
          <target state="translated">&lt;code&gt;&amp;lt;protocol&amp;gt;_request()&lt;/code&gt; 와 같은 메소드를 가진 모든 핸들러 에는 요청을 사전 처리하기 위해 해당 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="87dd6abe2d83be9ac05336f5766d67cec0efbdc0" translate="yes" xml:space="preserve">
          <source>Every handler with a method named like &lt;code&gt;&amp;lt;protocol&amp;gt;_response()&lt;/code&gt; has that method called to post-process the response.</source>
          <target state="translated">&lt;code&gt;&amp;lt;protocol&amp;gt;_response()&lt;/code&gt; 와 같은 이름의 메소드를 가진 모든 핸들러 에는 응답 후 처리를 위해 해당 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="023f8d53f12bb3daad0277efc4c3662d502e1d1f" translate="yes" xml:space="preserve">
          <source>Every new component that is installed using &lt;a href=&quot;distutils#module-distutils&quot;&gt;&lt;code&gt;distutils&lt;/code&gt;&lt;/a&gt; or a Distutils-based system will follow the same scheme to copy its file in the right places.</source>
          <target state="translated">&lt;a href=&quot;distutils#module-distutils&quot;&gt; &lt;code&gt;distutils&lt;/code&gt; &lt;/a&gt; 또는 Distutils 기반 시스템을 사용하여 설치되는 모든 새 구성 요소 는 동일한 구성표에 따라 파일을 올바른 위치에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="986fbc42665dc91f40f77aea3b95a8ca43c093c4" translate="yes" xml:space="preserve">
          <source>Every type is compatible with &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 유형은 &lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 와 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="53b7884e98183ceb9b4cfd1d011ac92d5357e2a0" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#email.parser.BytesParser&quot;&gt;&lt;code&gt;BytesParser&lt;/code&gt;&lt;/a&gt;, except that &lt;em&gt;headersonly&lt;/em&gt; defaults to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#email.parser.BytesParser&quot;&gt; &lt;code&gt;BytesParser&lt;/code&gt; &lt;/a&gt; 와 정확히 동일하지만 &lt;em&gt;헤더 만&lt;/em&gt; 기본값이 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="46f25aeba7b5a83d7186802db481749d4e234b64" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt;, except that &lt;em&gt;headersonly&lt;/em&gt; defaults to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;헤더 만&lt;/em&gt; 기본값이 &lt;code&gt;True&lt;/code&gt; 인 것을 제외하고는 &lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; 와 정확히 같습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efd3fcb68660d6ddc801f3d5fff097ef21ad1001" translate="yes" xml:space="preserve">
          <source>Exactly one of &lt;em&gt;hex&lt;/em&gt;, &lt;em&gt;bytes&lt;/em&gt;, &lt;em&gt;bytes_le&lt;/em&gt;, &lt;em&gt;fields&lt;/em&gt;, or &lt;em&gt;int&lt;/em&gt; must be given. The &lt;em&gt;version&lt;/em&gt; argument is optional; if given, the resulting UUID will have its variant and version number set according to &lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 4122&lt;/strong&gt;&lt;/a&gt;, overriding bits in the given &lt;em&gt;hex&lt;/em&gt;, &lt;em&gt;bytes&lt;/em&gt;, &lt;em&gt;bytes_le&lt;/em&gt;, &lt;em&gt;fields&lt;/em&gt;, or &lt;em&gt;int&lt;/em&gt;.</source>
          <target state="translated">정확히 &lt;em&gt;hex&lt;/em&gt; , &lt;em&gt;bytes&lt;/em&gt; , &lt;em&gt;bytes_le&lt;/em&gt; , &lt;em&gt;fields&lt;/em&gt; 또는 &lt;em&gt;int&lt;/em&gt; 중 하나를 제공해야합니다. &lt;em&gt;버전&lt;/em&gt; 인수는 선택 사항입니다; 주어진 경우 결과 UUID는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 4122&lt;/strong&gt;&lt;/a&gt; 에 따라 변형 및 버전 번호가 설정 되어 지정된 &lt;em&gt;16 진&lt;/em&gt; , &lt;em&gt;바이트&lt;/em&gt; , &lt;em&gt;bytes_le&lt;/em&gt; , &lt;em&gt;필드&lt;/em&gt; 또는 &lt;em&gt;int의&lt;/em&gt; 비트를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="065d263ca721579032051461d0f85c251cda8d94" translate="yes" xml:space="preserve">
          <source>Examine the set of signals that are pending for delivery to the calling thread (i.e., the signals which have been raised while blocked). Return the set of the pending signals.</source>
          <target state="translated">호출 스레드로 전달 대기중인 신호 세트 (예 : 차단 된 상태에서 발생 된 신호)를 검사하십시오. 보류중인 신호 세트를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="8140c9559ead396556a69cb7c13870d100e23e12" translate="yes" xml:space="preserve">
          <source>Examining Symbol Tables</source>
          <target state="translated">심볼 테이블 검사</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="ba64059d54ecf2e4f58095e4ffbe78024c708b65" translate="yes" xml:space="preserve">
          <source>Example 1, copy an existing database into another:</source>
          <target state="translated">예 1, 기존 데이터베이스를 다른 데이터베이스에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="137645e6411b45ecbf0303ef253386e5ec8dcb85" translate="yes" xml:space="preserve">
          <source>Example 2, copy an existing database into a transient copy:</source>
          <target state="translated">예 2, 기존 데이터베이스를 임시 사본으로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="c37bc538c5bc9675c11e37a0307e34b3f0c1f015" translate="yes" xml:space="preserve">
          <source>Example HTML Parser Application</source>
          <target state="translated">HTML 파서 응용 프로그램 예</target>
        </trans-unit>
        <trans-unit id="0debb52aa0d853532835e594e85ae883978d8199" translate="yes" xml:space="preserve">
          <source>Example Objects</source>
          <target state="translated">예제 객체</target>
        </trans-unit>
        <trans-unit id="d73338318be14a2ee00fe61b468ee7e6b4519df6" translate="yes" xml:space="preserve">
          <source>Example call to enable tracing with &lt;em&gt;skip&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;skip&lt;/em&gt; 을 사용하여 추적을 사용하기위한 호출 예제 :</target>
        </trans-unit>
        <trans-unit id="a6887178fdbaf756ad1659904ae754f41804ae6d" translate="yes" xml:space="preserve">
          <source>Example for a TurtleScreen instance named &lt;code&gt;screen&lt;/code&gt; and a Turtle instance named turtle:</source>
          <target state="translated">&lt;code&gt;screen&lt;/code&gt; 이라는 TurtleScreen 인스턴스 와 turtle이라는 Turtle 인스턴스의 예 :</target>
        </trans-unit>
        <trans-unit id="865e4a8d44043cfd9cf400e7ea38cc03278129a8" translate="yes" xml:space="preserve">
          <source>Example for a context with one CA cert and one other cert:</source>
          <target state="translated">하나의 CA 인증서와 다른 하나의 인증서가있는 컨텍스트의 예 :</target>
        </trans-unit>
        <trans-unit id="fef9a506f6a96368c854bbe7b4f86e06f07d8682" translate="yes" xml:space="preserve">
          <source>Example of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bootstrapping_(statistics)&quot;&gt;statistical bootstrapping&lt;/a&gt; using resampling with replacement to estimate a confidence interval for the mean of a sample of size five:</source>
          <target state="translated">크기가 5 인 표본의 평균에 대한 신뢰 구간을 추정하기 위해 대체로 리샘플링을 사용 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bootstrapping_(statistics)&quot;&gt;통계 부트 스트랩 핑의&lt;/a&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="86c7e42216c745a3820b86e8839c09c2adbf656f" translate="yes" xml:space="preserve">
          <source>Example of &lt;code&gt;ContextDecorator&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ContextDecorator&lt;/code&gt; 의 예 :</target>
        </trans-unit>
        <trans-unit id="8357286354d7663d68a111084817ddfbcaa5aee9" translate="yes" xml:space="preserve">
          <source>Example of Client Usage</source>
          <target state="translated">클라이언트 사용 예</target>
        </trans-unit>
        <trans-unit id="5440db91bbed4c909b616c48187fbe4347314229" translate="yes" xml:space="preserve">
          <source>Example of Client and Server Usage</source>
          <target state="translated">클라이언트 및 서버 사용 예</target>
        </trans-unit>
        <trans-unit id="8c2d5ec44c12d9ff6754b9395d719e20a220c4a2" translate="yes" xml:space="preserve">
          <source>Example of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests&quot;&gt;resampling permutation test&lt;/a&gt; to determine the statistical significance or &lt;a href=&quot;https://en.wikipedia.org/wiki/P-value&quot;&gt;p-value&lt;/a&gt; of an observed difference between the effects of a drug versus a placebo:</source>
          <target state="translated">약물의 효과와 위약 사이의 관찰 된 차이 의 통계적 유의성 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/P-value&quot;&gt;p- 값&lt;/a&gt; 을 결정하기 위한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Resampling_(statistics)#Permutation_tests&quot;&gt;리샘플링 순열 테스트의&lt;/a&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="f554a16636435edbf30d67f304f055459fe1f648" translate="yes" xml:space="preserve">
          <source>Example of a WSGI application serving the current directory, accept optional directory and port number (default: 8000) on the command line:</source>
          <target state="translated">현재 디렉토리를 제공하는 WSGI 애플리케이션의 예, 명령 행에서 선택적 디렉토리 및 포트 번호 (기본값 : 8000)를 승인하십시오.</target>
        </trans-unit>
        <trans-unit id="b39c929319837464183a66a188d5a4b74c358856" translate="yes" xml:space="preserve">
          <source>Example of a script rewriter that transforms float literals into Decimal objects:</source>
          <target state="translated">부동 리터럴을 Decimal 객체로 변환하는 스크립트 재 작성기의 예 :</target>
        </trans-unit>
        <trans-unit id="3df4e542b42fe51861f15425bec08c9e581be4f2" translate="yes" xml:space="preserve">
          <source>Example of a segmentation fault on Linux with and without enabling the fault handler:</source>
          <target state="translated">결함 핸들러를 사용하거나 사용하지 않는 Linux의 세그먼트 결함 예 :</target>
        </trans-unit>
        <trans-unit id="8494eb293c63909857aec1796f431b7a0bcbfea9" translate="yes" xml:space="preserve">
          <source>Example of an LRU cache for static web content:</source>
          <target state="translated">정적 웹 컨텐츠에 대한 LRU 캐시의 예 :</target>
        </trans-unit>
        <trans-unit id="34595c8b7423a2763fbbca8c42af8ea2cc5eda5c" translate="yes" xml:space="preserve">
          <source>Example of an unhandled exception:</source>
          <target state="translated">처리되지 않은 예외의 예 :</target>
        </trans-unit>
        <trans-unit id="a3bc5b7aba328df1e407aaf62166c8f472d2c871" translate="yes" xml:space="preserve">
          <source>Example of changing the attribute &amp;ldquo;target&amp;rdquo; of every link in first paragraph:</source>
          <target state="translated">첫 번째 단락에서 모든 링크의 &quot;대상&quot;속성을 변경하는 예 :</target>
        </trans-unit>
        <trans-unit id="c8cc5adbc6bda92d954c23713e40bb147c821ac5" translate="yes" xml:space="preserve">
          <source>Example of coroutine displaying the current date every second for 5 seconds:</source>
          <target state="translated">5 초 동안 1 초마다 현재 날짜를 표시하는 코 루틴의 예 :</target>
        </trans-unit>
        <trans-unit id="ace7964881fa427c9b955e08733877f771e2256c" translate="yes" xml:space="preserve">
          <source>Example of counting days to an event:</source>
          <target state="translated">이벤트 일수 계산의 예 :</target>
        </trans-unit>
        <trans-unit id="36b3976e8dd6454c66e771264b482ca8db8300d9" translate="yes" xml:space="preserve">
          <source>Example of efficiently computing &lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_number&quot;&gt;Fibonacci numbers&lt;/a&gt; using a cache to implement a &lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_programming&quot;&gt;dynamic programming&lt;/a&gt; technique:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_programming&quot;&gt;동적 프로그래밍&lt;/a&gt; 기술 을 구현하기 위해 캐시를 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_number&quot;&gt;피보나치 수&lt;/a&gt; 를 효율적으로 계산하는 예 :</target>
        </trans-unit>
        <trans-unit id="92e63a15b16a1e3592e498eb90ae1c50fad07a68" translate="yes" xml:space="preserve">
          <source>Example of how to GZIP compress a binary string:</source>
          <target state="translated">이진 문자열을 GZIP 압축하는 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="1474ae500b5a001a9b1d649894b172c8f216da9b" translate="yes" xml:space="preserve">
          <source>Example of how to GZIP compress an existing file:</source>
          <target state="translated">기존 파일을 GZIP 압축하는 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="85dc75b483cd6ca6d07c566852cffb63738c9c78" translate="yes" xml:space="preserve">
          <source>Example of how to create a compressed GZIP file:</source>
          <target state="translated">압축 된 GZIP 파일을 작성하는 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="4dd12dcc603cf2780656fa2a8bb16e8d59559b18" translate="yes" xml:space="preserve">
          <source>Example of how to read a compressed file:</source>
          <target state="translated">압축 파일을 읽는 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="6f2cfef200873444a0503cb83516d7f97f10d111" translate="yes" xml:space="preserve">
          <source>Example of how to wait for enqueued tasks to be completed:</source>
          <target state="translated">대기중인 작업이 완료되기를 기다리는 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="279156ed9b71d7424658bef303f91a5f62b81e6a" translate="yes" xml:space="preserve">
          <source>Example of letting user specified command-line arguments take precedence over environment variables which in turn take precedence over default values:</source>
          <target state="translated">사용자 지정 명령 줄 인수가 환경 변수보다 우선하도록하는 예 : 기본값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="626096412640de8c129ec606e725bbd326ee4695" translate="yes" xml:space="preserve">
          <source>Example of output before/after running some tests of the Python test suite:</source>
          <target state="translated">Python 테스트 스위트의 일부 테스트를 실행하기 전 / 후의 출력 예 :</target>
        </trans-unit>
        <trans-unit id="c591df6074ed0fe5e6bf8dc7b32c667a8e5dba71" translate="yes" xml:space="preserve">
          <source>Example of output of the Python test suite (traceback limited to 25 frames):</source>
          <target state="translated">Python 테스트 스위트의 출력 예 (트레이스 백이 25 프레임으로 제한됨) :</target>
        </trans-unit>
        <trans-unit id="baf8308b40270c8e949acaa0e52904b087b78869" translate="yes" xml:space="preserve">
          <source>Example of output of the Python test suite:</source>
          <target state="translated">Python 테스트 스위트의 출력 예 :</target>
        </trans-unit>
        <trans-unit id="41696aeac4c168c952d61557ba52d98acdc47f3b" translate="yes" xml:space="preserve">
          <source>Example of simulating Python&amp;rsquo;s internal lookup chain:</source>
          <target state="translated">Python의 내부 조회 체인을 시뮬레이션하는 예 :</target>
        </trans-unit>
        <trans-unit id="d13f5ff947b45e47e249594d1bd333d3fdd19f37" translate="yes" xml:space="preserve">
          <source>Example of tokenizing from the command line. The script:</source>
          <target state="translated">명령 행에서 토큰 화의 예. 스크립트 :</target>
        </trans-unit>
        <trans-unit id="ec1136270e452edec85ece96cdcd819465f02495" translate="yes" xml:space="preserve">
          <source>Example of usage:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="ff254b80ff4deddde105df533b4ecf09cb09b4b9" translate="yes" xml:space="preserve">
          <source>Example of using &lt;a href=&quot;#operator.itemgetter&quot;&gt;&lt;code&gt;itemgetter()&lt;/code&gt;&lt;/a&gt; to retrieve specific fields from a tuple record:</source>
          <target state="translated">&lt;a href=&quot;#operator.itemgetter&quot;&gt; &lt;code&gt;itemgetter()&lt;/code&gt; &lt;/a&gt; 를 사용하여 튜플 레코드에서 특정 필드를 검색 하는 예 :</target>
        </trans-unit>
        <trans-unit id="1f16a763880498f7b430c362f22c1b3f123bbad9" translate="yes" xml:space="preserve">
          <source>Example patterns for using the &lt;a href=&quot;#collections.ChainMap&quot;&gt;&lt;code&gt;ChainMap&lt;/code&gt;&lt;/a&gt; class to simulate nested contexts:</source>
          <target state="translated">중첩 된 컨텍스트를 시뮬레이션하기 위해 &lt;a href=&quot;#collections.ChainMap&quot;&gt; &lt;code&gt;ChainMap&lt;/code&gt; &lt;/a&gt; 클래스를 사용하는 예제 패턴 :</target>
        </trans-unit>
        <trans-unit id="b57fbbce3024226f494b8c9f6b74c9e0f9482dfe" translate="yes" xml:space="preserve">
          <source>Example usage of ModuleFinder</source>
          <target state="translated">ModuleFinder 사용 예</target>
        </trans-unit>
        <trans-unit id="97e958b379493045126047344a14c53561a623ed" translate="yes" xml:space="preserve">
          <source>Example usage of some of the methods of &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일부 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 메소드의 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="60f284f90e62dd3c3da0a06cd83c63a0a2636e6f" translate="yes" xml:space="preserve">
          <source>Example usage of the binary objects. We&amp;rsquo;re going to transfer an image over XMLRPC:</source>
          <target state="translated">이진 객체의 사용 예 우리는 XMLRPC를 통해 이미지를 전송할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="c7a9f6edde5b90563dc590480ce2c19b3ceb8c4c" translate="yes" xml:space="preserve">
          <source>Example use with input stream:</source>
          <target state="translated">입력 스트림과 함께 사용 예 :</target>
        </trans-unit>
        <trans-unit id="40207c8cfe3dfb26f745fedfb1e280021e268b08" translate="yes" xml:space="preserve">
          <source>Example use with output streams:</source>
          <target state="translated">출력 스트림과 함께 사용 예 :</target>
        </trans-unit>
        <trans-unit id="23f9d603e16f8ef16b61cb7dd71733745d6dc774" translate="yes" xml:space="preserve">
          <source>Example use:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a53066aab3018c902feba5bb8428b1e0c0ca3f41" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Tuple[T1, T2]&lt;/code&gt; is a tuple of two elements corresponding to type variables T1 and T2. &lt;code&gt;Tuple[int, float, str]&lt;/code&gt; is a tuple of an int, a float and a string.</source>
          <target state="translated">예 : &lt;code&gt;Tuple[T1, T2]&lt;/code&gt; 은 유형 변수 T1 및 T2에 해당하는 두 요소의 튜플입니다. &lt;code&gt;Tuple[int, float, str]&lt;/code&gt; 은 int, float 및 string의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="d5ff9b1ca76cd267a4d86feb025b24f6e8e44e83" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;http.client.responses[http.client.NOT_FOUND]&lt;/code&gt; is &lt;code&gt;'Not Found'&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;http.client.responses[http.client.NOT_FOUND]&lt;/code&gt; 는 &lt;code&gt;'Not Found'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3bac6bf28038e84740e2a40be66e3c0eab528c1a" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;quote('/El Ni&amp;ntilde;o/')&lt;/code&gt; yields &lt;code&gt;'/El%20Ni%C3%B1o/'&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;quote('/El Ni&amp;ntilde;o/')&lt;/code&gt; 수율 &lt;code&gt;'/El%20Ni%C3%B1o/'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11fef01fb5ea38d0eca370802e6deeb2a2aace34" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;quote_from_bytes(b'a&amp;amp;\xef')&lt;/code&gt; yields &lt;code&gt;'a%26%EF'&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;quote_from_bytes(b'a&amp;amp;\xef')&lt;/code&gt; &lt;code&gt;'a%26%EF'&lt;/code&gt; 산출 합니다.</target>
        </trans-unit>
        <trans-unit id="51cdde3985a7fb4acf75fc1fdc43cf98aa4d7fb8" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;quote_plus('/El Ni&amp;ntilde;o/')&lt;/code&gt; yields &lt;code&gt;'%2FEl+Ni%C3%B1o%2F'&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;quote_plus('/El Ni&amp;ntilde;o/')&lt;/code&gt; 수율 &lt;code&gt;'%2FEl+Ni%C3%B1o%2F'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8c50fbefe3d09e28519b8ae7c691cb75894a1fd" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;unquote('/El%20Ni%C3%B1o/')&lt;/code&gt; yields &lt;code&gt;'/El Ni&amp;ntilde;o/'&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;unquote('/El%20Ni%C3%B1o/')&lt;/code&gt; &lt;code&gt;'/El Ni&amp;ntilde;o/'&lt;/code&gt; 산출 합니다.</target>
        </trans-unit>
        <trans-unit id="b8d066e789bc4b0e4ff9e3d86d53595cc3ee6e29" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;unquote_plus('/El+Ni%C3%B1o/')&lt;/code&gt; yields &lt;code&gt;'/El Ni&amp;ntilde;o/'&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;unquote_plus('/El+Ni%C3%B1o/')&lt;/code&gt; &lt;code&gt;'/El Ni&amp;ntilde;o/'&lt;/code&gt; 산출 합니다.</target>
        </trans-unit>
        <trans-unit id="9e1ac2893d1259af6f482135918cb008646b0886" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;unquote_to_bytes('a%26%EF')&lt;/code&gt; yields &lt;code&gt;b'a&amp;amp;\xef'&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;unquote_to_bytes('a%26%EF')&lt;/code&gt; 산출 &lt;code&gt;b'a&amp;amp;\xef'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c3aa7e06017e8ff98680df27fbdea1b412f07ad" translate="yes" xml:space="preserve">
          <source>Example: Emulation of compile()</source>
          <target state="translated">예 : compile () 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="b26c82a6a778161b5bdbdbe192421089f6e5017f" translate="yes" xml:space="preserve">
          <source>Example: Given the function &lt;code&gt;myfunc()&lt;/code&gt;:</source>
          <target state="translated">예 : &lt;code&gt;myfunc()&lt;/code&gt; 함수가 주어 졌을 때 :</target>
        </trans-unit>
        <trans-unit id="0fa10e8510aad6feea266e052f24f7f689f84c23" translate="yes" xml:space="preserve">
          <source>Example: print all descriptions of arguments:</source>
          <target state="translated">예 : 인수에 대한 모든 설명을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="70c3542949a842ba3f647de478464545ff410014" translate="yes" xml:space="preserve">
          <source>Example: print all keyword-only arguments without default values:</source>
          <target state="translated">예 : 기본값없이 모든 키워드 전용 인수를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="6d082aaac0220b28f2b8c187674d4fc1ad5d01c2" translate="yes" xml:space="preserve">
          <source>Examples (all on a SVR4 compliant system):</source>
          <target state="translated">예 (모두 SVR4 호환 시스템에서) :</target>
        </trans-unit>
        <trans-unit id="ba7cb01919ec9e725d24d29be0234801f58640ba" translate="yes" xml:space="preserve">
          <source>Examples and Recipes</source>
          <target state="translated">예와 요리법</target>
        </trans-unit>
        <trans-unit id="a361faee4c8e9d15d95654bf795e643a84fc895c" translate="yes" xml:space="preserve">
          <source>Examples containing both expected output and an exception are not supported. Trying to guess where one ends and the other begins is too error-prone, and that also makes for a confusing test.</source>
          <target state="translated">예상 출력과 예외가 모두 포함 된 예는 지원되지 않습니다. 어느 쪽이 끝나고 다른 쪽이 시작되는지 추측하려고하면 오류가 발생하기 쉬우므로 혼동되는 테스트가됩니다.</target>
        </trans-unit>
        <trans-unit id="86ce654eab3bc677fad0231965f3321413be76f0" translate="yes" xml:space="preserve">
          <source>Examples of &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; arithmetic:</source>
          <target state="translated">&lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 산술의 예 :</target>
        </trans-unit>
        <trans-unit id="a9cb2f8191f0236461789853c793fe43887124be" translate="yes" xml:space="preserve">
          <source>Examples of Usage: &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">사용 예 : &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f53aa95370601fa81bc3dadc1f65b4708e63a4cd" translate="yes" xml:space="preserve">
          <source>Examples of Usage: &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">사용 예 : &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec3db14421f66f5032b9ec5cc4a9289b18017179" translate="yes" xml:space="preserve">
          <source>Examples of Usage: &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">사용 예 : &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="217609f8d539d8fd74dde985eae19ac4f03520a8" translate="yes" xml:space="preserve">
          <source>Examples of returned values:</source>
          <target state="translated">반환 값의 예 :</target>
        </trans-unit>
        <trans-unit id="259aa5fcfc60a59c500052a700193e18835bd2e4" translate="yes" xml:space="preserve">
          <source>Examples of these sections in the file are given below.</source>
          <target state="translated">파일에서 이러한 섹션의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6854cb6d7461f271239ae6431fef4bbfb9d0849f" translate="yes" xml:space="preserve">
          <source>Examples of usage</source>
          <target state="translated">사용법의 예</target>
        </trans-unit>
        <trans-unit id="91fc4c486785c00452b26ce872ca765962ee129b" translate="yes" xml:space="preserve">
          <source>Examples of usage: &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">사용 예 : &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7140845a3bb12ad8574343147a832baa55c8d7e8" translate="yes" xml:space="preserve">
          <source>Examples of working with &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 작업의 예 :</target>
        </trans-unit>
        <trans-unit id="f129f0c85e501b41344120925f5197433ede1e8c" translate="yes" xml:space="preserve">
          <source>Examples of working with a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">&lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 로 작업하는 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="cc3ff6324e8eebbf50e9554bcdd2e7c7a2cbc65b" translate="yes" xml:space="preserve">
          <source>Exceeding limitations on different file systems can cause decompression failed. Such as allowable characters in the directory entries, length of the file name, length of the pathname, size of a single file, and number of files, etc.</source>
          <target state="translated">다른 파일 시스템에 대한 제한을 초과하면 압축 해제에 실패 할 수 있습니다. 디렉토리 항목에 허용되는 문자, 파일 이름 길이, 경로 이름 길이, 단일 파일 크기 및 파일 수 등</target>
        </trans-unit>
        <trans-unit id="1f7913834e700496b52dad8f01ac19616ff774c6" translate="yes" xml:space="preserve">
          <source>Except for the code &lt;code&gt;'C'&lt;/code&gt;, the language code corresponds to &lt;a href=&quot;https://tools.ietf.org/html/rfc1766.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 1766&lt;/strong&gt;&lt;/a&gt;. &lt;em&gt;language code&lt;/em&gt; and &lt;em&gt;encoding&lt;/em&gt; may be &lt;code&gt;None&lt;/code&gt; if their values cannot be determined.</source>
          <target state="translated">코드 &lt;code&gt;'C'&lt;/code&gt; 를 제외하고 언어 코드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1766.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 1766에&lt;/strong&gt;&lt;/a&gt; 해당합니다 . 값을 판별 할 수없는 경우 &lt;em&gt;언어 코드&lt;/em&gt; 및 &lt;em&gt;인코딩&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80904ba25a9e3243ed632e1ff1cc6a03a8d1747e" translate="yes" xml:space="preserve">
          <source>Except for the code &lt;code&gt;'C'&lt;/code&gt;, the language code corresponds to &lt;a href=&quot;https://tools.ietf.org/html/rfc1766.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 1766&lt;/strong&gt;&lt;/a&gt;. &lt;em&gt;language code&lt;/em&gt; and &lt;em&gt;encoding&lt;/em&gt; may be &lt;code&gt;None&lt;/code&gt; if their values cannot be determined.</source>
          <target state="translated">코드 &lt;code&gt;'C'&lt;/code&gt; 를 제외하고 언어 코드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1766.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 1766에&lt;/strong&gt;&lt;/a&gt; 해당합니다 . 값을 판별 할 수없는 경우 &lt;em&gt;언어 코드&lt;/em&gt; 및 &lt;em&gt;인코딩&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="0748cd739094a93fe7da05e30469096aa55c80e4" translate="yes" xml:space="preserve">
          <source>Exception classes</source>
          <target state="translated">예외 클래스</target>
        </trans-unit>
        <trans-unit id="312428d3e8acfd1d42aeb467b6b1c11802d7c8c2" translate="yes" xml:space="preserve">
          <source>Exception failing because of &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; invalidity: incorrect attributes, incorrect &lt;em&gt;Set-Cookie&lt;/em&gt; header, etc.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 무효 성으로 인한 예외 실패 : 잘못된 속성, 잘못된 &lt;em&gt;Set-Cookie&lt;/em&gt; 헤더 등</target>
        </trans-unit>
        <trans-unit id="209011554fcfc911dcec7eb38e42eca35be08388" translate="yes" xml:space="preserve">
          <source>Exception hierarchy</source>
          <target state="translated">예외 계층</target>
        </trans-unit>
        <trans-unit id="8b676f0d2de85f0abc2af15f19b9c6a83a75d753" translate="yes" xml:space="preserve">
          <source>Exception raised by &lt;code&gt;Connection.recv_bytes_into()&lt;/code&gt; when the supplied buffer object is too small for the message read.</source>
          <target state="translated">제공된 버퍼 오브젝트가 메시지 읽기에 비해 너무 작은 경우 &lt;code&gt;Connection.recv_bytes_into()&lt;/code&gt; 의해 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="8e9814d47307c441f0f179379aabd00fa81be39a" translate="yes" xml:space="preserve">
          <source>Exception raised by strict parsers if a single option appears twice during reading from a single file, string or dictionary. This catches misspellings and case sensitivity-related errors, e.g. a dictionary may have two keys representing the same case-insensitive configuration key.</source>
          <target state="translated">단일 파일, 문자열 또는 사전에서 읽는 동안 단일 옵션이 두 번 나타나는 경우 엄격한 파서에서 예외가 발생합니다. 이 경우 맞춤법 오류와 대소 문자 구분 관련 오류가 발생합니다. 예를 들어 사전에는 대소 문자를 구분하지 않는 동일한 구성 키를 나타내는 두 개의 키가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be211047c69b5d08f64a29ebebc88eb78862e7f" translate="yes" xml:space="preserve">
          <source>Exception raised by the &lt;a href=&quot;#bdb.Bdb&quot;&gt;&lt;code&gt;Bdb&lt;/code&gt;&lt;/a&gt; class for quitting the debugger.</source>
          <target state="translated">디버거를 종료하기 위해 &lt;a href=&quot;#bdb.Bdb&quot;&gt; &lt;code&gt;Bdb&lt;/code&gt; &lt;/a&gt; 클래스에서 예외가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="f74f98c16d92d1f665535f7524cabfe2c83a8b61" translate="yes" xml:space="preserve">
          <source>Exception raised by the &lt;a href=&quot;#netrc.netrc&quot;&gt;&lt;code&gt;netrc&lt;/code&gt;&lt;/a&gt; class when syntactical errors are encountered in source text. Instances of this exception provide three interesting attributes: &lt;code&gt;msg&lt;/code&gt; is a textual explanation of the error, &lt;code&gt;filename&lt;/code&gt; is the name of the source file, and &lt;code&gt;lineno&lt;/code&gt; gives the line number on which the error was found.</source>
          <target state="translated">소스 텍스트에서 구문 오류가 발생 하면 &lt;a href=&quot;#netrc.netrc&quot;&gt; &lt;code&gt;netrc&lt;/code&gt; &lt;/a&gt; 클래스 에서 예외 가 발생했습니다. 이 예외의 인스턴스는 세 가지 흥미로운 속성을 제공합니다. &lt;code&gt;msg&lt;/code&gt; 는 오류에 대한 텍스트 설명, &lt;code&gt;filename&lt;/code&gt; 은 소스 파일 이름, &lt;code&gt;lineno&lt;/code&gt; 는 오류가 발견 된 행 번호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72225b97067acb514db053e3737009c2206a61fb" translate="yes" xml:space="preserve">
          <source>Exception raised by zipimporter objects. It&amp;rsquo;s a subclass of &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt;, so it can be caught as &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt;, too.</source>
          <target state="translated">zipimporter 객체에 의해 예외가 발생했습니다. 그것은의 서브 클래스의 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를&lt;/a&gt; 이 같이 잡을 수 있도록, &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를&lt;/a&gt; 도.</target>
        </trans-unit>
        <trans-unit id="326de5ee01a9691f56ba64beec39fbde19b7e2b8" translate="yes" xml:space="preserve">
          <source>Exception raised for errors that are related to the database&amp;rsquo;s operation and not necessarily under the control of the programmer, e.g. an unexpected disconnect occurs, the data source name is not found, a transaction could not be processed, etc. It is a subclass of &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt;&lt;code&gt;DatabaseError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 작동과 관련이 있고 프로그래머가 반드시 제어 할 필요는없는 오류 (예 : 예기치 않은 연결 끊기 발생, 데이터 소스 이름을 찾을 수 없음, 트랜잭션을 처리 할 수 ​​없음 등)에 대한 예외가 발생했습니다. 이는 &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt; &lt;code&gt;DatabaseError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다. .</target>
        </trans-unit>
        <trans-unit id="ee960a200e08a9cd1318594ffd8b99e35250caec" translate="yes" xml:space="preserve">
          <source>Exception raised for errors that are related to the database.</source>
          <target state="translated">데이터베이스와 관련된 오류에 대한 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="01200d3d284b1e6dc53e60c9884b2ad8119aa369" translate="yes" xml:space="preserve">
          <source>Exception raised for programming errors, e.g. table not found or already exists, syntax error in the SQL statement, wrong number of parameters specified, etc. It is a subclass of &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt;&lt;code&gt;DatabaseError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로그래밍 오류 (예 : 테이블을 찾을 수 없거나 이미 존재 함), SQL 문의 구문 오류, 지정된 매개 변수 수가 잘못됨에 대한 예외가 발생했습니다. 이는 &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt; &lt;code&gt;DatabaseError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="4271bf7a06917b05a5d1384e0893d9d319bbe0ab" translate="yes" xml:space="preserve">
          <source>Exception raised if &lt;code&gt;add_section()&lt;/code&gt; is called with the name of a section that is already present or in strict parsers when a section if found more than once in a single input file, string or dictionary.</source>
          <target state="translated">단일 입력 파일, 문자열 또는 사전에서 섹션을 두 번 이상 찾은 경우 이미 존재하는 섹션의 이름으로 엄격한 구문 분석기에서 &lt;code&gt;add_section()&lt;/code&gt; 을 호출 하면 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="057a471983601bd66f25f0c5286e874cf7e33a0b" translate="yes" xml:space="preserve">
          <source>Exception raised in case a method or database API was used which is not supported by the database, e.g. calling the &lt;a href=&quot;#sqlite3.Connection.rollback&quot;&gt;&lt;code&gt;rollback()&lt;/code&gt;&lt;/a&gt; method on a connection that does not support transaction or has transactions turned off. It is a subclass of &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt;&lt;code&gt;DatabaseError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에서 지원하지 않는 메소드 또는 데이터베이스 API가 사용 된 경우 예외 (예 : 트랜잭션을 지원하지 않거나 트랜잭션이 해제 된 연결 에서 &lt;a href=&quot;#sqlite3.Connection.rollback&quot;&gt; &lt;code&gt;rollback()&lt;/code&gt; &lt;/a&gt; 메소드 호출 ) &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt; &lt;code&gt;DatabaseError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="d060797ed8d4ae3223972050fa472e9e83ba86d6" translate="yes" xml:space="preserve">
          <source>Exception raised on any errors from this module (errors from &lt;a href=&quot;socket#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module are not caught). The reason for the exception is passed to the constructor as a string.</source>
          <target state="translated">이 모듈의 오류에 대해 예외가 발생했습니다 ( &lt;a href=&quot;socket#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈의 오류는 포착되지 않습니다). 예외의 이유는 문자열로 생성자에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bd190d9d0aef112603ae20aa4d23969762ddd09b" translate="yes" xml:space="preserve">
          <source>Exception raised on any errors. The reason for the exception is passed to the constructor as a string.</source>
          <target state="translated">오류가 발생하면 예외가 발생합니다. 예외의 이유는 문자열로 생성자에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="add7af7e43c5821985246901960320352b13632a" translate="yes" xml:space="preserve">
          <source>Exception raised on compression and decompression errors.</source>
          <target state="translated">압축 및 압축 해제 오류에서 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="83582aafa9421ade9e11a1c6e9ada45e9240c08e" translate="yes" xml:space="preserve">
          <source>Exception raised on errors. These are usually programming errors.</source>
          <target state="translated">오류로 인해 예외가 발생했습니다. 이들은 대개 프로그래밍 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d89247aeb60c7b476bf711d788fdd3b23f45a545" translate="yes" xml:space="preserve">
          <source>Exception raised on incomplete data. These are usually not programming errors, but may be handled by reading a little more data and trying again.</source>
          <target state="translated">불완전한 데이터에서 예외가 발생했습니다. 일반적으로 프로그래밍 오류는 아니지만 조금 더 많은 데이터를 읽고 다시 시도하면 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee06e8cdc58ec38aa06821b5c570c6ead19e78bf" translate="yes" xml:space="preserve">
          <source>Exception raised on various occasions; argument is a string describing what is wrong.</source>
          <target state="translated">여러 경우에 예외가 발생했다. argument는 무엇이 잘못되었는지 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8aea2f4d93f31bf28c13b84df0443c26570db178" translate="yes" xml:space="preserve">
          <source>Exception raised when a browser control error occurs.</source>
          <target state="translated">브라우저 제어 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d49e7c6044bf1d82135e97b494b41e584ec919ed" translate="yes" xml:space="preserve">
          <source>Exception raised when a curses library function returns an error.</source>
          <target state="translated">curses 라이브러리 함수가 오류를 리턴하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73bd4d3b3c0dbde6b337c936d8c4ddb67a2f15f9" translate="yes" xml:space="preserve">
          <source>Exception raised when a failure occurs within the parser module. This is generally produced for validation failures rather than the built-in &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; raised during normal parsing. The exception argument is either a string describing the reason of the failure or a tuple containing a sequence causing the failure from a parse tree passed to &lt;a href=&quot;#parser.sequence2st&quot;&gt;&lt;code&gt;sequence2st()&lt;/code&gt;&lt;/a&gt; and an explanatory string. Calls to &lt;a href=&quot;#parser.sequence2st&quot;&gt;&lt;code&gt;sequence2st()&lt;/code&gt;&lt;/a&gt; need to be able to handle either type of exception, while calls to other functions in the module will only need to be aware of the simple string values.</source>
          <target state="translated">파서 모듈 내에서 오류가 발생하면 예외가 발생합니다. 일반적으로 일반 구문 분석 중에 발생 하는 기본 제공 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 가&lt;/a&gt; 아닌 유효성 검사 실패에 대해 생성됩니다 . 예외 인수는 실패 이유를 설명하는 문자열이거나 &lt;a href=&quot;#parser.sequence2st&quot;&gt; &lt;code&gt;sequence2st()&lt;/code&gt; &lt;/a&gt; 전달 된 구문 분석 트리에서 실패를 유발하는 시퀀스를 포함하는 튜플 및 설명 문자열입니다. &lt;a href=&quot;#parser.sequence2st&quot;&gt; &lt;code&gt;sequence2st()&lt;/code&gt; &lt;/a&gt; 대한 호출은 두 가지 유형의 예외를 처리 할 수 ​​있어야하지만 모듈의 다른 함수에 대한 호출은 단순한 문자열 값만 인식하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb1412863f6feab0709a71cd7908436a470d95a" translate="yes" xml:space="preserve">
          <source>Exception raised when a proxy object is used but the underlying object has been collected. This is the same as the standard &lt;a href=&quot;exceptions#ReferenceError&quot;&gt;&lt;code&gt;ReferenceError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">프록시 객체가 사용되었지만 기본 객체가 수집 된 경우 예외가 발생했습니다. 이것은 표준 &lt;a href=&quot;exceptions#ReferenceError&quot;&gt; &lt;code&gt;ReferenceError&lt;/code&gt; &lt;/a&gt; 예외 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e3633dc111c05817710e4593aa78a11ceb9920e4" translate="yes" xml:space="preserve">
          <source>Exception raised when a reply is received from the server that does not begin with a digit in the range 1&amp;ndash;5.</source>
          <target state="translated">서버에서 1-5 범위의 숫자로 시작하지 않는 응답을 수신하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b175a0377a3f39fe7da494c1e660375102c528d" translate="yes" xml:space="preserve">
          <source>Exception raised when a reply is received from the server that does not fit the response specifications of the File Transfer Protocol, i.e. begin with a digit in the range 1&amp;ndash;5.</source>
          <target state="translated">파일 전송 프로토콜의 응답 스펙에 맞지 않는 서버로부터 응답을 수신 할 때 (예 : 1-5 범위의 숫자로 시작) 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="178c3d0791275ff5c898f9c8e23a3262f4890471" translate="yes" xml:space="preserve">
          <source>Exception raised when a response code in the range 400&amp;ndash;499 is received.</source>
          <target state="translated">400-499 범위의 응답 코드가 수신되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4313ff412f1b54328f22236a36a88ad719a8f052" translate="yes" xml:space="preserve">
          <source>Exception raised when a response code in the range 500&amp;ndash;599 is received.</source>
          <target state="translated">500-599 범위의 응답 코드가 수신되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b310113af08754064dafc82caa63d5845c17c234" translate="yes" xml:space="preserve">
          <source>Exception raised when a specified option is not found in the specified section.</source>
          <target state="translated">지정된 섹션에서 지정된 옵션을 찾지 못하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1004e9f4741227620239abe10c19ae1f580a13e0" translate="yes" xml:space="preserve">
          <source>Exception raised when a specified section is not found.</source>
          <target state="translated">지정된 섹션을 찾지 못하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d170cc3be4359bff0d1bd6c483fb6593917ddd92" translate="yes" xml:space="preserve">
          <source>Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern. The error instance has the following additional attributes:</source>
          <target state="translated">여기에있는 함수 중 하나로 전달 된 문자열이 유효한 정규식이 아니거나 (예 : 일치하지 않는 괄호를 포함 할 수 있음) 컴파일 또는 일치하는 동안 다른 오류가 발생하면 예외가 발생합니다. 문자열에 패턴과 일치하는 것이 없으면 오류가 아닙니다. 오류 인스턴스에는 다음과 같은 추가 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa4e1d32e4e5cc4617660d479d0e6e738f91e3aa" translate="yes" xml:space="preserve">
          <source>Exception raised when an error code signifying a permanent error (response codes in the range 500&amp;ndash;599) is received.</source>
          <target state="translated">영구 오류를 나타내는 오류 코드 (500-599 범위의 응답 코드)가 수신되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bebdf5cfc60e6b3b7fe1aaa5a65b62566a2f3963" translate="yes" xml:space="preserve">
          <source>Exception raised when an error code signifying a temporary error (response codes in the range 400&amp;ndash;499) is received.</source>
          <target state="translated">일시적 오류 (400-499 범위의 응답 코드)를 나타내는 오류 코드가 수신되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a5694a429c5b81e9ff0998944dfdfe1bb38edae7" translate="yes" xml:space="preserve">
          <source>Exception raised when an error occurs while attempting to compile the file.</source>
          <target state="translated">파일 컴파일을 시도하는 동안 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d2745077fcab3e366892be2556894fde814c021" translate="yes" xml:space="preserve">
          <source>Exception raised when an option referenced from a value does not exist. Subclass of &lt;a href=&quot;#configparser.InterpolationError&quot;&gt;&lt;code&gt;InterpolationError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값에서 참조 된 옵션이 존재하지 않으면 예외가 발생합니다. 하위 클래스 &lt;a href=&quot;#configparser.InterpolationError&quot;&gt; &lt;code&gt;InterpolationError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b7880563336914d732cc4888dbfc1750c2e27d3" translate="yes" xml:space="preserve">
          <source>Exception raised when an unexpected reply is received from the server.</source>
          <target state="translated">서버에서 예기치 않은 응답이 수신되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f4b8fc254e42ccc6740f5732866846a4a570ce88" translate="yes" xml:space="preserve">
          <source>Exception raised when attempting to parse a file which has no section headers.</source>
          <target state="translated">섹션 헤더가없는 파일을 구문 분석 할 때 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c79f27b9a9e561a4cfaa3a6453eb34419222db51" translate="yes" xml:space="preserve">
          <source>Exception raised when errors occur attempting to parse a file.</source>
          <target state="translated">파일 구문 분석 중에 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="631784ac2fbe83dd79545eb9ccb32e5e4637a3f2" translate="yes" xml:space="preserve">
          <source>Exception raised when non-blocking &lt;a href=&quot;#queue.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#queue.Queue.get_nowait&quot;&gt;&lt;code&gt;get_nowait()&lt;/code&gt;&lt;/a&gt;) is called on a &lt;a href=&quot;#queue.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; object which is empty.</source>
          <target state="translated">비 &lt;a href=&quot;#queue.Queue.get_nowait&quot;&gt; &lt;code&gt;get_nowait()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#queue.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; (또는 get_nowait () ) 가 비어 있는 &lt;a href=&quot;#queue.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 객체 에서 호출 되면 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="46b915457295e62b46f8751e8312793a4805b076" translate="yes" xml:space="preserve">
          <source>Exception raised when non-blocking &lt;a href=&quot;#queue.Queue.put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#queue.Queue.put_nowait&quot;&gt;&lt;code&gt;put_nowait()&lt;/code&gt;&lt;/a&gt;) is called on a &lt;a href=&quot;#queue.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; object which is full.</source>
          <target state="translated">비 차단 &lt;a href=&quot;#queue.Queue.put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#queue.Queue.put_nowait&quot;&gt; &lt;code&gt;put_nowait()&lt;/code&gt; &lt;/a&gt; ) 이 가득 찬 &lt;a href=&quot;#queue.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 객체 에서 호출 되면 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c1b955eb00c6914a5e6e63306f665ace77961838" translate="yes" xml:space="preserve">
          <source>Exception raised when something can&amp;rsquo;t be encoded using the binhex format (for example, a filename is too long to fit in the filename field), or when input is not properly encoded binhex data.</source>
          <target state="translated">Binhex 형식을 사용하여 무언가를 인코딩 할 수없는 경우 (예 : 파일 이름이 너무 길어서 파일 이름 필드에 맞지 않음) 또는 입력이 Binhex 데이터를 올바르게 인코딩하지 않은 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c563209ae42fb0b135aae77ecc57a734af366ac5" translate="yes" xml:space="preserve">
          <source>Exception raised when string interpolation cannot be completed because the number of iterations exceeds &lt;a href=&quot;#configparser.MAX_INTERPOLATION_DEPTH&quot;&gt;&lt;code&gt;MAX_INTERPOLATION_DEPTH&lt;/code&gt;&lt;/a&gt;. Subclass of &lt;a href=&quot;#configparser.InterpolationError&quot;&gt;&lt;code&gt;InterpolationError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복 횟수가 &lt;a href=&quot;#configparser.MAX_INTERPOLATION_DEPTH&quot;&gt; &lt;code&gt;MAX_INTERPOLATION_DEPTH&lt;/code&gt; 를&lt;/a&gt; 초과하여 문자열 보간을 완료 할 수없는 경우 예외가 발생합니다 . 하위 클래스 &lt;a href=&quot;#configparser.InterpolationError&quot;&gt; &lt;code&gt;InterpolationError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df8889c1d3d172d311451a8a2ec6064de60c1810" translate="yes" xml:space="preserve">
          <source>Exception raised when the &lt;a href=&quot;#asyncio.Queue.put_nowait&quot;&gt;&lt;code&gt;put_nowait()&lt;/code&gt;&lt;/a&gt; method is called on a queue that has reached its &lt;em&gt;maxsize&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.Queue.put_nowait&quot;&gt; &lt;code&gt;put_nowait()&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;em&gt;maxsize에&lt;/em&gt; 도달 한 큐에서 호출 될 때 예외가 발생 했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba8897a682d567138428408ab9df581f4594f8ab" translate="yes" xml:space="preserve">
          <source>Exception raised when the locale passed to &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; is not recognized.</source>
          <target state="translated">&lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 전달 된 로케일 이 인식되지 않으면 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="bb3faee804f53ff4db6f433e551c2d08c0c32915" translate="yes" xml:space="preserve">
          <source>Exception raised when the relational integrity of the database is affected, e.g. a foreign key check fails. It is a subclass of &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt;&lt;code&gt;DatabaseError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터베이스의 관계 무결성이 영향을받는 경우 예외가 발생합니다 (예 : 외래 키 검사 실패). &lt;a href=&quot;#sqlite3.DatabaseError&quot;&gt; &lt;code&gt;DatabaseError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="04bb87f4130b4180b1ba156d3a51be1dea3bdb9b" translate="yes" xml:space="preserve">
          <source>Exception raised when the source text into which substitutions are made does not conform to the required syntax. Subclass of &lt;a href=&quot;#configparser.InterpolationError&quot;&gt;&lt;code&gt;InterpolationError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대체 할 소스 텍스트가 필수 구문을 준수하지 않는 경우 예외가 발생합니다. 하위 클래스 &lt;a href=&quot;#configparser.InterpolationError&quot;&gt; &lt;code&gt;InterpolationError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="532ac37a2d888c287b65abc3fd3680b66b2ca974" translate="yes" xml:space="preserve">
          <source>Exception raised when there is some error in the response data.</source>
          <target state="translated">응답 데이터에 오류가있을 때 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="224d233b1223bd5e534e4c92fba78ccc504d48bd" translate="yes" xml:space="preserve">
          <source>Exception to be raised when a test fails. This is deprecated in favor of &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;-based tests and &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s assertion methods.</source>
          <target state="translated">테스트가 실패하면 예외가 발생합니다. 이것은 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 기반 테스트 및 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt; 의 어설 션 메소드 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6f961bbc4f35e8d30c38075dc27127e8e39cb1ef" translate="yes" xml:space="preserve">
          <source>Exception tuple (&amp;agrave; la &lt;code&gt;sys.exc_info&lt;/code&gt;) or, if no exception has occurred, &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">예외 튜플 (a la &lt;code&gt;sys.exc_info&lt;/code&gt; ) 또는 예외가 발생하지 않으면 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e151058274b1944e593ebbb920057fb138f7f000" translate="yes" xml:space="preserve">
          <source>Exception when a node does not exist in the referenced context. For example, &lt;code&gt;NamedNodeMap.removeNamedItem()&lt;/code&gt; will raise this if the node passed in does not exist in the map.</source>
          <target state="translated">참조 된 컨텍스트에 노드가 존재하지 않는 경우 예외. 예를 들어, 전달 된 노드가 맵에 없으면 &lt;code&gt;NamedNodeMap.removeNamedItem()&lt;/code&gt; 이이를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="369b35fc723492a4b2012ba48db7d24ca448035c" translate="yes" xml:space="preserve">
          <source>Exceptions and Error Handling</source>
          <target state="translated">예외 및 오류 처리</target>
        </trans-unit>
        <trans-unit id="df71308e3d32ab453e4717e512971ad84660cee6" translate="yes" xml:space="preserve">
          <source>Exceptions defined in this module all inherit from &lt;a href=&quot;#subprocess.SubprocessError&quot;&gt;&lt;code&gt;SubprocessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에 정의 된 예외는 모두 &lt;a href=&quot;#subprocess.SubprocessError&quot;&gt; &lt;code&gt;SubprocessError&lt;/code&gt; &lt;/a&gt; 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="befafc060d7dd8ad7d50727f39e2bf81a426267d" translate="yes" xml:space="preserve">
          <source>Exceptions in this module are coded as class instances:</source>
          <target state="translated">이 모듈의 예외는 클래스 인스턴스로 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="a249548d6691d3290bc9485f451db6dd6febec8a" translate="yes" xml:space="preserve">
          <source>Exceptions raised by finalizer callbacks during garbage collection will be shown on the standard error output, but cannot be propagated. They are handled in the same way as exceptions raised from an object&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; method or a weak reference&amp;rsquo;s callback.</source>
          <target state="translated">가비지 수집 중에 파이널 라이저 콜백에서 발생한 예외는 표준 오류 출력에 표시되지만 전파 할 수는 없습니다. 객체의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; 메소드 또는 약한 참조의 콜백 에서 발생하는 예외와 같은 방식으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8f3eecca356dbdba89502d5f4b7f7be1cd1bf0d" translate="yes" xml:space="preserve">
          <source>Exceptions raised by the callback will be noted on the standard error output, but cannot be propagated; they are handled in exactly the same way as exceptions raised from an object&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">콜백에 의해 발생한 예외는 표준 오류 출력에 표시되지만 전파 될 수는 없습니다. 객체의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; 메소드 에서 발생한 예외와 정확히 같은 방식으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="602a17b7f1d4f59e242e69ecf8bb008f79200e74" translate="yes" xml:space="preserve">
          <source>Exceptions raised in the child process, before the new program has started to execute, will be re-raised in the parent.</source>
          <target state="translated">새 프로그램이 실행되기 전에 자식 프로세스에서 발생한 예외는 부모에서 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a861a497465e6d5e961800a373ccee2f73c3c64" translate="yes" xml:space="preserve">
          <source>Exchange full</source>
          <target state="translated">전체 교환</target>
        </trans-unit>
        <trans-unit id="40111bff621e73a44959a0a4b3c7a85b2711035e" translate="yes" xml:space="preserve">
          <source>Exchanging objects between processes</source>
          <target state="translated">프로세스 간 객체 교환</target>
        </trans-unit>
        <trans-unit id="c31466ffb66056cc1102e73d3e7736f02ea55d33" translate="yes" xml:space="preserve">
          <source>Exclamation</source>
          <target state="translated">Exclamation</target>
        </trans-unit>
        <trans-unit id="08b88e08cae7b5bb1e4110d2f9f58f64e8ddb558" translate="yes" xml:space="preserve">
          <source>Excluded time components are truncated, not rounded.</source>
          <target state="translated">제외 된 시간 구성 요소는 반올림되지 않고 잘립니다.</target>
        </trans-unit>
        <trans-unit id="b63162a783524a1ec5efa41e95fe5121b9b98b72" translate="yes" xml:space="preserve">
          <source>Exec format error</source>
          <target state="translated">실행 형식 오류</target>
        </trans-unit>
        <trans-unit id="61e507592e1b0d9543a474be7a1e6119f6855048" translate="yes" xml:space="preserve">
          <source>Executable documentation / literate testing.</source>
          <target state="translated">실행 가능한 문서 / 리터 레이트 테스트.</target>
        </trans-unit>
        <trans-unit id="05733ba7a5338b29357c9f188c1b0ffe46bb2809" translate="yes" xml:space="preserve">
          <source>Executables named here without a full path will be searched in the directories given in the &lt;code id=&quot;index-3&quot;&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">전체 경로없이 여기에 명명 된 실행 파일은 &lt;code id=&quot;index-3&quot;&gt;PATH&lt;/code&gt; 환경 변수에 지정된 디렉토리에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="286f2d3129a2b679620ae0bdaa405b24e672bf6a" translate="yes" xml:space="preserve">
          <source>Execute &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt; subclasses passed to the function. The function scans the classes for methods starting with the prefix &lt;code&gt;test_&lt;/code&gt; and executes the tests individually.</source>
          <target state="translated">실행 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; 의&lt;/a&gt; 함수에 전달 된 서브 클래스를. 이 함수는 접두어 &lt;code&gt;test_&lt;/code&gt; 로 시작하는 메소드에 대해 클래스를 스캔 하고 테스트를 개별적으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a241e75b43251ba0271bd81025aacaae9b72202b" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;callable(*args, **kwargs)&lt;/code&gt; code in the context object the &lt;em&gt;run&lt;/em&gt; method is called on. Return the result of the execution or propagate an exception if one occurred.</source>
          <target state="translated">실행 &lt;code&gt;callable(*args, **kwargs)&lt;/code&gt; 하여 컨텍스트 오브젝트 코드를 &lt;em&gt;실행&lt;/em&gt; 방법에 호출된다. 실행 결과를 반환하거나 예외가 발생한 경우 예외를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="69ed63c879a440dcfb6d968855ae91e33bf18942" translate="yes" xml:space="preserve">
          <source>Execute a child program in a new process. On POSIX, the class uses &lt;a href=&quot;os#os.execvp&quot;&gt;&lt;code&gt;os.execvp()&lt;/code&gt;&lt;/a&gt;-like behavior to execute the child program. On Windows, the class uses the Windows &lt;code&gt;CreateProcess()&lt;/code&gt; function. The arguments to &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; are as follows.</source>
          <target state="translated">새 프로세스에서 하위 프로그램을 실행하십시오. POSIX에서 클래스는 &lt;a href=&quot;os#os.execvp&quot;&gt; &lt;code&gt;os.execvp()&lt;/code&gt; &lt;/a&gt; 와 유사한 동작을 사용하여 자식 프로그램을 실행합니다. Windows에서 클래스는 Windows &lt;code&gt;CreateProcess()&lt;/code&gt; 함수를 사용합니다. &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; 에&lt;/a&gt; 대한 주장 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6a91ef61eaa929da297d5aebf9277979dbd795f" translate="yes" xml:space="preserve">
          <source>Execute a code object. When an exception occurs, &lt;a href=&quot;#code.InteractiveInterpreter.showtraceback&quot;&gt;&lt;code&gt;showtraceback()&lt;/code&gt;&lt;/a&gt; is called to display a traceback. All exceptions are caught except &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt;, which is allowed to propagate.</source>
          <target state="translated">코드 객체를 실행하십시오. 예외가 발생하면 &lt;a href=&quot;#code.InteractiveInterpreter.showtraceback&quot;&gt; &lt;code&gt;showtraceback()&lt;/code&gt; &lt;/a&gt; 이 호출되어 역 추적을 표시합니다. 전파가 허용되는 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; 를&lt;/a&gt; 제외한 모든 예외가 포착 됩니다.</target>
        </trans-unit>
        <trans-unit id="7e81ce564d602b517c838c91c8da9ba683c00772" translate="yes" xml:space="preserve">
          <source>Execute a readline initialization file. The default filename is the last filename used. This calls &lt;code&gt;rl_read_init_file()&lt;/code&gt; in the underlying library.</source>
          <target state="translated">readline 초기화 파일을 실행하십시오. 기본 파일 이름은 마지막으로 사용한 파일 이름입니다. 기본 라이브러리에서 &lt;code&gt;rl_read_init_file()&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ba07fbeef18083f616ae510801b11d8066bf6eb3" translate="yes" xml:space="preserve">
          <source>Execute command args with messages identified by UID, rather than message number. Returns response appropriate to command. At least one argument must be supplied; if none are provided, the server will return an error and an exception will be raised.</source>
          <target state="translated">메시지 번호가 아닌 UID로 식별 된 메시지를 사용하여 명령 인수를 실행하십시오. 명령에 적합한 응답을 반환합니다. 최소한 하나의 인수가 제공되어야합니다. 아무것도 제공되지 않으면 서버는 오류를 반환하고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="31b06121b9ec4fe8849d3894f93b635bf18f224d" translate="yes" xml:space="preserve">
          <source>Execute the (one-line) &lt;em&gt;statement&lt;/em&gt; in the context of the current stack frame. The exclamation point can be omitted unless the first word of the statement resembles a debugger command. To set a global variable, you can prefix the assignment command with a &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt; statement on the same line, e.g.:</source>
          <target state="translated">현재 스택 프레임의 컨텍스트에서 (한 줄) &lt;em&gt;명령문&lt;/em&gt; 을 실행하십시오 . 명령문의 첫 단어가 디버거 명령과 유사하지 않으면 느낌표를 생략 할 수 있습니다. 전역 변수를 설정하려면 다음과 같이 같은 행에 할당 명령 앞에 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt; 명령문을 붙일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="826334beb56840bb5c7db5683c5e7ca7ddf91968" translate="yes" xml:space="preserve">
          <source>Execute the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt;&lt;em&gt;coro&lt;/em&gt; and return the result.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴 &lt;/a&gt;&lt;em&gt;코로를&lt;/em&gt; 실행하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="993f7355e3e5a673bcbcdb78e35376ca7db42fbf" translate="yes" xml:space="preserve">
          <source>Execute the &lt;em&gt;statement&lt;/em&gt; (given as a string or a code object) under debugger control. The debugger prompt appears before any code is executed; you can set breakpoints and type &lt;a href=&quot;#pdbcommand-continue&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt;, or you can step through the statement using &lt;a href=&quot;#pdbcommand-step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdbcommand-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; (all these commands are explained below). The optional &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; arguments specify the environment in which the code is executed; by default the dictionary of the module &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt; is used. (See the explanation of the built-in &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; functions.)</source>
          <target state="translated">디버거 제어 하에서 &lt;em&gt;명령문&lt;/em&gt; (문자열 또는 코드 오브젝트로 제공됨)을 실행하십시오 . 코드가 실행되기 전에 디버거 프롬프트가 나타납니다. 중단 점을 설정하고 &lt;a href=&quot;#pdbcommand-continue&quot;&gt; &lt;code&gt;continue&lt;/code&gt; 를&lt;/a&gt; 입력 하거나 &lt;a href=&quot;#pdbcommand-step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pdbcommand-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; 를&lt;/a&gt; 사용하여 명령문을 단계별로 실행할 수 있습니다 (이러한 모든 명령은 아래에 설명되어 있음). 선택적 &lt;em&gt;globals&lt;/em&gt; 및 &lt;em&gt;locals&lt;/em&gt; 인수는 코드가 실행되는 환경을 지정합니다. 기본적으로 &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; &lt;/a&gt; 모듈의 사전 이 사용됩니다. 내장 &lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 함수에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="957c0a46c8c5eae402bb66fc52f1f0746167605d" translate="yes" xml:space="preserve">
          <source>Execute the SQL query of the view, through &lt;code&gt;MSIViewExecute()&lt;/code&gt;. If &lt;em&gt;params&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it is a record describing actual values of the parameter tokens in the query.</source>
          <target state="translated">&lt;code&gt;MSIViewExecute()&lt;/code&gt; 통해 뷰의 SQL 쿼리를 실행하십시오 . &lt;em&gt;params&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 쿼리에서 매개 변수 토큰의 실제 값을 설명하는 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="3d06b0236831d9b4a24c24c13a620443b6325555" translate="yes" xml:space="preserve">
          <source>Execute the code at the named filesystem location and return the resulting module globals dictionary. As with a script name supplied to the CPython command line, the supplied path may refer to a Python source file, a compiled bytecode file or a valid sys.path entry containing a &lt;code&gt;__main__&lt;/code&gt; module (e.g. a zipfile containing a top-level &lt;code&gt;__main__.py&lt;/code&gt; file).</source>
          <target state="translated">명명 된 파일 시스템 위치에서 코드를 실행하고 결과 모듈 전역 사전을 반환합니다. CPython 명령 행에 제공된 스크립트 이름과 같이 제공된 경로는 Python 소스 파일, 컴파일 된 바이트 코드 파일 또는 &lt;code&gt;__main__&lt;/code&gt; 모듈을 포함하는 유효한 sys.path 항목 (예 : 최상위 &lt;code&gt;__main__.py&lt;/code&gt; 를 포함하는 zip 파일)을 나타낼 수 있습니다. 파일).</target>
        </trans-unit>
        <trans-unit id="793598dfa7dcb5d5d2f8a7449ed34dd13e3bc919" translate="yes" xml:space="preserve">
          <source>Execute the code of the specified module and return the resulting module globals dictionary. The module&amp;rsquo;s code is first located using the standard import mechanism (refer to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; for details) and then executed in a fresh module namespace.</source>
          <target state="translated">지정된 모듈의 코드를 실행하고 결과 모듈 글로벌 사전을 리턴하십시오. 모듈 코드는 먼저 표준 가져 오기 메커니즘 (자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 참조)을 사용하여 찾은 다음 새로운 모듈 네임 스페이스에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9e21a77bd94392e4d0027b41d97cf1fc40ff6a2e" translate="yes" xml:space="preserve">
          <source>Execute the command (a string) in a subshell. This is implemented by calling the Standard C function &lt;code&gt;system()&lt;/code&gt;, and has the same limitations. Changes to &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt;, etc. are not reflected in the environment of the executed command. If &lt;em&gt;command&lt;/em&gt; generates any output, it will be sent to the interpreter standard output stream.</source>
          <target state="translated">서브 쉘에서 명령 (문자열)을 실행하십시오. 이것은 표준 C 함수 &lt;code&gt;system()&lt;/code&gt; 을 호출하여 구현되며 동일한 제한이 있습니다. &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; 등의 변경 사항 은 실행 된 명령 환경에 반영되지 않습니다. 경우 &lt;em&gt;명령은&lt;/em&gt; 출력을 생성, 그것은 인터프리터 표준 출력 스트림으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2aedf6c540cf5d6012a301638f91c6d689e3a5db" translate="yes" xml:space="preserve">
          <source>Execute the command and gather statistics from the execution with the current tracing parameters, in the defined global and local environments. If not defined, &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; default to empty dictionaries.</source>
          <target state="translated">정의 된 글로벌 및 로컬 환경에서 명령을 실행하고 현재 추적 매개 변수를 사용하여 실행에서 통계를 수집하십시오. 정의되지 않은 경우 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역은&lt;/em&gt; 기본적으로 빈 사전으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="80a05e02bcf359c90586f52db20dad5469639bd2" translate="yes" xml:space="preserve">
          <source>Execute the command and gather statistics from the execution with the current tracing parameters. &lt;em&gt;cmd&lt;/em&gt; must be a string or code object, suitable for passing into &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명령을 실행하고 현재 추적 매개 변수를 사용하여 실행에서 통계를 수집하십시오. &lt;em&gt;cmd&lt;/em&gt; 는 &lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 로 전달하기에 적합한 문자열 또는 코드 객체 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="734e46faf8e21459ae0c946eb0235e32ee99537b" translate="yes" xml:space="preserve">
          <source>Execute the current line, stop at the first possible occasion (either in a function that is called or on the next line in the current function).</source>
          <target state="translated">현재 행을 실행하고 가능한 첫 번째 시점 (현재 함수의 호출 된 함수 또는 다음 행)에서 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="b63fd92562c30795dffe275ecbc6d69bedc43beb" translate="yes" xml:space="preserve">
          <source>Execute the init line provided in the &lt;em&gt;string&lt;/em&gt; argument. This calls &lt;code&gt;rl_parse_and_bind()&lt;/code&gt; in the underlying library.</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 인수에 제공된 init 행을 실행하십시오 . 기본 라이브러리에서 &lt;code&gt;rl_parse_and_bind()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a9a25ececa2495c95f119e64a7b4b8eb079e7b80" translate="yes" xml:space="preserve">
          <source>Execute the program &lt;em&gt;path&lt;/em&gt; in a new process.</source>
          <target state="translated">새로운 프로세스에서 프로그램 &lt;em&gt;경로&lt;/em&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4fc211867504f03ecbc0ba4699cf8ff7d3f11f2" translate="yes" xml:space="preserve">
          <source>Execute the string &lt;em&gt;cmd&lt;/em&gt; in a shell with &lt;code&gt;Popen.check_output()&lt;/code&gt; and return a 2-tuple &lt;code&gt;(exitcode, output)&lt;/code&gt;. The locale encoding is used; see the notes on &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Popen.check_output()&lt;/code&gt; 을 사용하여 쉘에서 문자열 &lt;em&gt;cmd&lt;/em&gt; 를 실행하고 2 튜플 &lt;code&gt;(exitcode, output)&lt;/code&gt; 반환하십시오 . 로케일 인코딩이 사용됩니다. 자세한 내용은 &lt;a href=&quot;#frequently-used-arguments&quot;&gt;자주 사용되는 인수에&lt;/a&gt; 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3e7484258f8f0d962a52cb295082cfc4486e5526" translate="yes" xml:space="preserve">
          <source>Executes an SQL command against all parameter sequences or mappings found in the sequence &lt;em&gt;seq_of_parameters&lt;/em&gt;. The &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module also allows using an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;iterator&lt;/a&gt; yielding parameters instead of a sequence.</source>
          <target state="translated">&lt;em&gt;seq_of_parameters&lt;/em&gt; 시퀀스에있는 모든 매개 변수 시퀀스 또는 매핑에 대해 SQL 명령을 실행합니다 . &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; 를 용&lt;/a&gt; 모듈은 또한 사용 허용 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;반복자&lt;/a&gt; 대신 일련의 파라미터를 산출한다.</target>
        </trans-unit>
        <trans-unit id="5fed61f794b123d4df64a51baba8f0490dd462f4" translate="yes" xml:space="preserve">
          <source>Executes an SQL statement. The SQL statement may be parameterized (i. e. placeholders instead of SQL literals). The &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module supports two kinds of placeholders: question marks (qmark style) and named placeholders (named style).</source>
          <target state="translated">SQL 문을 실행합니다. SQL 문은 매개 변수화 될 수 있습니다 (예 : SQL 리터럴 대신 플레이스 홀더). &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; 를의&lt;/a&gt; 물음표 (qmark 스타일)라는 이름 자리 (이름 첨부 서식) : 모듈은 두 자리의 종류를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c49ddd797cbb0588fd381fc136bcc980a935ae82" translate="yes" xml:space="preserve">
          <source>Executing code in thread or process pools</source>
          <target state="translated">스레드 또는 프로세스 풀에서 코드 실행</target>
        </trans-unit>
        <trans-unit id="de93521cc9f60a060ec9a4429e441b99ed1e28ff" translate="yes" xml:space="preserve">
          <source>Executing the event means executing &lt;code&gt;action(*argument, **kwargs)&lt;/code&gt;. &lt;em&gt;argument&lt;/em&gt; is a sequence holding the positional arguments for &lt;em&gt;action&lt;/em&gt;. &lt;em&gt;kwargs&lt;/em&gt; is a dictionary holding the keyword arguments for &lt;em&gt;action&lt;/em&gt;.</source>
          <target state="translated">이벤트를 실행한다는 것은 &lt;code&gt;action(*argument, **kwargs)&lt;/code&gt; 실행을 의미 합니다. &lt;em&gt;argument&lt;/em&gt; 는 &lt;em&gt;action에&lt;/em&gt; 대한 위치 인수를 보유하는 시퀀스 입니다. &lt;em&gt;kwargs&lt;/em&gt; 는 &lt;em&gt;action에&lt;/em&gt; 대한 키워드 인수를 보유한 사전 입니다.</target>
        </trans-unit>
        <trans-unit id="b44827a87c41a75678cdd5f76bd61447a3fc10f5" translate="yes" xml:space="preserve">
          <source>Execution of Python signal handlers</source>
          <target state="translated">Python 신호 처리기 실행</target>
        </trans-unit>
        <trans-unit id="ed3931e45d9bc3ce577741dbd125810e45a2b826" translate="yes" xml:space="preserve">
          <source>Executor Objects</source>
          <target state="translated">실행자 객체</target>
        </trans-unit>
        <trans-unit id="211c10fefffd8e3b3e355bf1edcb1832fad0f9ca" translate="yes" xml:space="preserve">
          <source>Exhaust as many code paths as possible. Test where branching occurs and thus tailor input to make sure as many different paths through the code are taken.</source>
          <target state="translated">가능한 많은 코드 경로를 소진하십시오. 분기가 발생하는 위치를 테스트하고 코드를 통과하는 여러 경로가 사용되도록 입력을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="222f4735cc04fbb94d3f36bb2ec690b85bf1cebb" translate="yes" xml:space="preserve">
          <source>Existing context managers that already have a base class can be extended by using &lt;code&gt;ContextDecorator&lt;/code&gt; as a mixin class:</source>
          <target state="translated">&lt;code&gt;ContextDecorator&lt;/code&gt; 를 mixin 클래스로 사용하여 이미 기본 클래스가있는 기존 컨텍스트 관리자를 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f83b6fe3aebf13744e866019556d9129cd7a55be" translate="yes" xml:space="preserve">
          <source>Exit</source>
          <target state="translated">Exit</target>
        </trans-unit>
        <trans-unit id="8dc762b6cd999e9e7c339e2a9ffd275e4e6e9d6b" translate="yes" xml:space="preserve">
          <source>Exit Windows</source>
          <target state="translated">Windows 종료</target>
        </trans-unit>
        <trans-unit id="0eb6852fe58ab846e7bbe411d7c5e62bb4d27841" translate="yes" xml:space="preserve">
          <source>Exit code that means a specified host did not exist.</source>
          <target state="translated">지정된 호스트가 존재하지 않음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="7a22f8343aa29394ba70bf5dc7afa73c08926734" translate="yes" xml:space="preserve">
          <source>Exit code that means a specified user did not exist.</source>
          <target state="translated">지정된 사용자가 존재하지 않음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="1e96d47cca855bf6edef7796cdce40087e984555" translate="yes" xml:space="preserve">
          <source>Exit code that means a temporary failure occurred. This indicates something that may not really be an error, such as a network connection that couldn&amp;rsquo;t be made during a retryable operation.</source>
          <target state="translated">일시적인 오류가 발생했음을 나타내는 종료 코드. 다시 시도 가능한 작업 중에 만들 수 없었던 네트워크 연결과 같이 실제로 오류가 아닌 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="130b0662bd564bed3b370b021be7c79e675673ec" translate="yes" xml:space="preserve">
          <source>Exit code that means a user specified output file could not be created.</source>
          <target state="translated">사용자 지정 출력 파일을 작성할 수 없음을 의미하는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="ee6998f7707f8890d572b71f35265321e03105a3" translate="yes" xml:space="preserve">
          <source>Exit code that means an input file did not exist or was not readable.</source>
          <target state="translated">입력 파일이 존재하지 않거나 읽을 수 없음을 의미하는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="9105cdf46e59b903bc936574e1e7533cdf138f82" translate="yes" xml:space="preserve">
          <source>Exit code that means an internal software error was detected.</source>
          <target state="translated">내부 소프트웨어 오류가 감지되었음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="1d74434dbdfc578d821f4318fe90a51b17a17cd4" translate="yes" xml:space="preserve">
          <source>Exit code that means an operating system error was detected, such as the inability to fork or create a pipe.</source>
          <target state="translated">파이프를 포크하거나 만들 수없는 등 운영 체제 오류가 감지되었음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="05d48920a0aebcc6b3c4c2390c6c09782f77ea3e" translate="yes" xml:space="preserve">
          <source>Exit code that means no error occurred.</source>
          <target state="translated">오류가 발생하지 않았다는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="0f7bc1803a4a72d74f632ceb8f951a754f403608" translate="yes" xml:space="preserve">
          <source>Exit code that means some system file did not exist, could not be opened, or had some other kind of error.</source>
          <target state="translated">일부 시스템 파일이 없거나 열 수 없거나 다른 종류의 오류가 발생했음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="873b690550da75d449939d35005ee675abb600c4" translate="yes" xml:space="preserve">
          <source>Exit code that means something like &amp;ldquo;an entry was not found&amp;rdquo;.</source>
          <target state="translated">&quot;항목을 찾을 수 없음&quot;과 같은 종료 코드입니다.</target>
        </trans-unit>
        <trans-unit id="ae632ba3b2d0e464ffc16d4e6f9467aeab63b17f" translate="yes" xml:space="preserve">
          <source>Exit code that means that a protocol exchange was illegal, invalid, or not understood.</source>
          <target state="translated">프로토콜 교환이 불법이거나 유효하지 않거나 이해되지 않았 음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="2236398f4560c2c3270ca6afed0572a5a292e10b" translate="yes" xml:space="preserve">
          <source>Exit code that means that a required service is unavailable.</source>
          <target state="translated">필요한 서비스를 사용할 수 없음을 의미하는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="2769a4e9e329eedb10d1c8259f8c1431a9d913e1" translate="yes" xml:space="preserve">
          <source>Exit code that means that an error occurred while doing I/O on some file.</source>
          <target state="translated">일부 파일에서 I / O를 수행하는 동안 오류가 발생했음을 나타내는 종료 코드입니다.</target>
        </trans-unit>
        <trans-unit id="18fe8007ea03054c8698943a4e0e8de37594ec1d" translate="yes" xml:space="preserve">
          <source>Exit code that means that some kind of configuration error occurred.</source>
          <target state="translated">종료 코드는 일종의 구성 오류가 발생했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c7fbf7f46a8ce37387db819583c55d99b5c0a745" translate="yes" xml:space="preserve">
          <source>Exit code that means that there were insufficient permissions to perform the operation (but not intended for file system problems).</source>
          <target state="translated">종료 코드는 작업을 수행 할 수있는 권한이 충분하지 않음을 의미하지만 파일 시스템 문제를위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0045f24ba4cbea5891945395b979e9d9cf52329e" translate="yes" xml:space="preserve">
          <source>Exit code that means the command was used incorrectly, such as when the wrong number of arguments are given.</source>
          <target state="translated">잘못된 수의 인수가 제공된 경우와 같이 명령이 잘못 사용되었음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="0ab31a146165c6ef2fb3014ef6aa6d6dab33309d" translate="yes" xml:space="preserve">
          <source>Exit code that means the input data was incorrect.</source>
          <target state="translated">입력 데이터가 잘못되었음을 나타내는 종료 코드.</target>
        </trans-unit>
        <trans-unit id="29749cfb9382cb00c435991190794173c3a641de" translate="yes" xml:space="preserve">
          <source>Exit from Python. This is implemented by raising the &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; exception, so cleanup actions specified by finally clauses of &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statements are honored, and it is possible to intercept the exit attempt at an outer level.</source>
          <target state="translated">파이썬에서 빠져 나옵니다. 이는 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 예외 를 발생시켜 구현 되므로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 문의 finally 절에 지정된 정리 조치 가 적용되며 외부 시도에서 종료 시도를 가로 챌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb0d6a92730bf5e1a73f3bfc4f253e7d84022d0" translate="yes" xml:space="preserve">
          <source>Exit insert char mode</source>
          <target state="translated">삽입 문자 모드 종료</target>
        </trans-unit>
        <trans-unit id="031fa31cf206c2ec1cd22ca183b8e96c3c9872e8" translate="yes" xml:space="preserve">
          <source>Exit status of the child process. If the process exited due to a signal, this will be the negative signal number.</source>
          <target state="translated">하위 프로세스의 종료 상태 신호로 인해 프로세스가 종료 된 경우 음의 신호 번호가됩니다.</target>
        </trans-unit>
        <trans-unit id="19adb7c9c5eaa16417045df4e6323c37b803665c" translate="yes" xml:space="preserve">
          <source>Exit status of the child process. Typically, an exit status of 0 indicates that it ran successfully.</source>
          <target state="translated">하위 프로세스의 종료 상태 일반적으로 종료 상태 0은 성공적으로 실행되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="782552048b669f3e29d23655320f5c5ec4a69c8d" translate="yes" xml:space="preserve">
          <source>Exit the process with status &lt;em&gt;n&lt;/em&gt;, without calling cleanup handlers, flushing stdio buffers, etc.</source>
          <target state="translated">정리 핸들러 호출, stdio 버퍼 플러시 등을 수행하지 않고 상태 &lt;em&gt;n으로&lt;/em&gt; 프로세스를 종료하십시오 .</target>
        </trans-unit>
        <trans-unit id="e568f5a9fa1a0a52b3de44fc53325fcc76e97cc0" translate="yes" xml:space="preserve">
          <source>Exit the runtime context and return a Boolean flag indicating if any exception that occurred should be suppressed. If an exception occurred while executing the body of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, the arguments contain the exception type, value and traceback information. Otherwise, all three arguments are &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">런타임 컨텍스트를 종료하고 발생한 예외를 억제해야하는지 여부를 나타내는 부울 플래그를 리턴하십시오. &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 본문을 실행하는 동안 예외가 발생 하면 인수에 예외 유형, 값 및 역 추적 정보가 포함됩니다. 그렇지 않으면 세 인수가 모두 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="813d6a80ed490c32c14fd6b15893f76ab9515615" translate="yes" xml:space="preserve">
          <source>Exiting methods</source>
          <target state="translated">종료 방법</target>
        </trans-unit>
        <trans-unit id="f0545bde9ddc8fa1efb4f51bf8ddc1930ca8a6aa" translate="yes" xml:space="preserve">
          <source>Exiting the context manager cleans up any temporary file created when the resource needs to be extracted from e.g. a zip file.</source>
          <target state="translated">컨텍스트 관리자를 종료하면 zip 파일과 같은 리소스를 추출해야 할 때 생성 된 임시 파일이 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="705912607514938d70ecf589927512f5012e6eed" translate="yes" xml:space="preserve">
          <source>Expand Word</source>
          <target state="translated">단어 확장</target>
        </trans-unit>
        <trans-unit id="4b0fc2127b40c104cccfbdb5737f0aa1b76fc944" translate="yes" xml:space="preserve">
          <source>Expand a prefix you have typed to match a full word in the same window; repeat to get a different expansion.</source>
          <target state="translated">동일한 창에서 전체 단어와 일치하도록 입력 한 접두사를 확장하십시오. 다른 확장을 얻으려면 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="af74b0c485a7e9735a00ba13b8e6543ff0acd03a" translate="yes" xml:space="preserve">
          <source>Expands all children of &lt;em&gt;node&lt;/em&gt; into &lt;em&gt;node&lt;/em&gt;. Example:</source>
          <target state="translated">&lt;em&gt;node의&lt;/em&gt; 모든 하위를 &lt;em&gt;node&lt;/em&gt; 로 확장 &lt;em&gt;합니다&lt;/em&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="b6235ec6054cdf78ee69907b788f865a06567cfe" translate="yes" xml:space="preserve">
          <source>Expands environment variable placeholders &lt;code&gt;%NAME%&lt;/code&gt; in strings like &lt;a href=&quot;#winreg.REG_EXPAND_SZ&quot;&gt;&lt;code&gt;REG_EXPAND_SZ&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#winreg.REG_EXPAND_SZ&quot;&gt; &lt;code&gt;REG_EXPAND_SZ&lt;/code&gt; &lt;/a&gt; 와 같은 문자열에서 환경 변수 자리 표시 자 &lt;code&gt;%NAME%&lt;/code&gt; 을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="1fd1d786684facabead378e367b48b5f9bad65fb" translate="yes" xml:space="preserve">
          <source>Expansion field data. The &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;PKZIP Application Note&lt;/a&gt; contains some comments on the internal structure of the data contained in this &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">확장 필드 데이터. &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;PKZIP 애플리케이션 노트는&lt;/a&gt; 데이터의 내부 구조에 대한 몇 가지 의견이에 포함 된 포함 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="59e2311798f2ce925a5a5bcf558e82fd2f02f1be" translate="yes" xml:space="preserve">
          <source>Expat can optionally do XML namespace processing for you, enabled by providing a value for &lt;em&gt;namespace_separator&lt;/em&gt;. The value must be a one-character string; a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised if the string has an illegal length (&lt;code&gt;None&lt;/code&gt; is considered the same as omission). When namespace processing is enabled, element type names and attribute names that belong to a namespace will be expanded. The element name passed to the element handlers &lt;code&gt;StartElementHandler&lt;/code&gt; and &lt;code&gt;EndElementHandler&lt;/code&gt; will be the concatenation of the namespace URI, the namespace separator character, and the local part of the name. If the namespace separator is a zero byte (&lt;code&gt;chr(0)&lt;/code&gt;) then the namespace URI and the local part will be concatenated without any separator.</source>
          <target state="translated">해외 거주자는 선택적으로 당신을 위해 XML 네임 스페이스 처리를 할 수있는, 값 제공으로 활성화 &lt;em&gt;namespace_separator을&lt;/em&gt; . 값은 한 문자 문자열이어야합니다. &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 문자열 (불법 길이가있는 경우 발생합니다 &lt;code&gt;None&lt;/code&gt; 누락과 동일한 것으로 간주되지 않는다). 네임 스페이스 처리가 활성화되면 네임 스페이스에 속하는 요소 유형 이름 및 속성 이름이 확장됩니다. 요소 처리기 &lt;code&gt;StartElementHandler&lt;/code&gt; 및 &lt;code&gt;EndElementHandler&lt;/code&gt; 에 전달 된 요소 이름 은 네임 스페이스 URI, 네임 스페이스 구분 문자 및 이름의 로컬 부분이 연결됩니다. 네임 스페이스 구분자가 0 바이트 인 경우 ( &lt;code&gt;chr(0)&lt;/code&gt; ) 네임 스페이스 URI와 로컬 부분은 구분 기호없이 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="da8abdeaaae5e01377deae8fb1c50c19174a8ea8" translate="yes" xml:space="preserve">
          <source>Expat error constants</source>
          <target state="translated">국외 오류 상수</target>
        </trans-unit>
        <trans-unit id="08105ec54ec812c08ae7f829e3d2d086acf47b22" translate="yes" xml:space="preserve">
          <source>Expat was not able to allocate memory internally.</source>
          <target state="translated">국외 거주자는 내부적으로 메모리를 할당 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="ae83915ff1e542a4aa9b192c227278e059870679" translate="yes" xml:space="preserve">
          <source>Expat&amp;rsquo;s internal error number for the specific error. The &lt;a href=&quot;#xml.parsers.expat.errors.messages&quot;&gt;&lt;code&gt;errors.messages&lt;/code&gt;&lt;/a&gt; dictionary maps these error numbers to Expat&amp;rsquo;s error messages. For example:</source>
          <target state="translated">특정 오류에 대한 국외 거주자의 내부 오류 번호. 는 &lt;a href=&quot;#xml.parsers.expat.errors.messages&quot;&gt; &lt;code&gt;errors.messages&lt;/code&gt; &lt;/a&gt; 사전 국외 거주자의 오류 메시지에 이러한 오류 번호를 매핑합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49b412a0f51820f38bfe44b5bc6f73f29177ee5e" translate="yes" xml:space="preserve">
          <source>ExpatError Exceptions</source>
          <target state="translated">ExpatError 예외</target>
        </trans-unit>
        <trans-unit id="247dde85da683c7c073b9190b1453ace6096f3d3" translate="yes" xml:space="preserve">
          <source>Expected failures use the &lt;a href=&quot;#unittest.expectedFailure&quot;&gt;&lt;code&gt;expectedFailure()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">예상되는 실패는 &lt;a href=&quot;#unittest.expectedFailure&quot;&gt; &lt;code&gt;expectedFailure()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="78647db73123cd8372fb4f4bbcc9f2105592afba" translate="yes" xml:space="preserve">
          <source>Expected output cannot contain an all-whitespace line, since such a line is taken to signal the end of expected output. If expected output does contain a blank line, put &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; in your doctest example each place a blank line is expected.</source>
          <target state="translated">예상 출력은 모두 공백 라인을 포함 할 수 없습니다. 이러한 라인은 예상 출력의 끝을 알리기 위해 사용되기 때문입니다. 예상 출력에 빈 줄이 포함 되어 있으면 doctest 예제에 &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; 을 빈 줄이 예상되는 각 위치에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="93617b006b3706f8adecd6a3c8aad6df6b3318d3" translate="yes" xml:space="preserve">
          <source>Expected output:</source>
          <target state="translated">예상 출력 :</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="4521cb9e86ffb37d381aebe8d8ce8956c54915a1" translate="yes" xml:space="preserve">
          <source>Explicitly close the audio device. When you are done writing to or reading from an audio device, you should explicitly close it. A closed device cannot be used again.</source>
          <target state="translated">오디오 장치를 명시 적으로 닫습니다. 오디오 장치에 쓰거나 읽은 후에는 명시 적으로 닫아야합니다. 닫힌 장치는 다시 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4bbffebc70065656746756e2001956fe84cdef41" translate="yes" xml:space="preserve">
          <source>Explicitly pass resources to child processes</source>
          <target state="translated">자식 프로세스에 리소스를 명시 적으로 전달</target>
        </trans-unit>
        <trans-unit id="6c8f65243d9f006f8c6c4439bd8b8a6b5dfac7c9" translate="yes" xml:space="preserve">
          <source>Explicitly via the column name</source>
          <target state="translated">열 이름을 통해 명시 적으로</target>
        </trans-unit>
        <trans-unit id="8a330a9c7957095585f0e465fcc1e74ca875851e" translate="yes" xml:space="preserve">
          <source>Exponent notation. Prints the number in scientific notation using the letter &amp;lsquo;e&amp;rsquo; to indicate the exponent. The default precision is &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">지수 표기법. 지수를 나타 내기 위해 문자 'e'를 사용하여 과학적 표기법으로 숫자를 인쇄합니다. 기본 정밀도는 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13a4114eb5527628350c89f4e332e24a8b6adaf7" translate="yes" xml:space="preserve">
          <source>Exponent notation. Same as &lt;code&gt;'e'&lt;/code&gt; except it uses an upper case &amp;lsquo;E&amp;rsquo; as the separator character.</source>
          <target state="translated">지수 표기법. 구분 문자로 대문자 'E'를 사용한다는 점을 제외하고 &lt;code&gt;'e'&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3237bbd0fba00be230671cc5c9f06d02aebed723" translate="yes" xml:space="preserve">
          <source>Exponent was lower than &lt;code&gt;Emin&lt;/code&gt; prior to rounding.</source>
          <target state="translated">반올림하기 전에 지수가 &lt;code&gt;Emin&lt;/code&gt; 보다 낮았습니다 .</target>
        </trans-unit>
        <trans-unit id="dbc59c1ddea13a6824ca57d6407a1a5c5633bc43" translate="yes" xml:space="preserve">
          <source>Exponential distribution. &lt;em&gt;lambd&lt;/em&gt; is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called &amp;ldquo;lambda&amp;rdquo;, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if &lt;em&gt;lambd&lt;/em&gt; is positive, and from negative infinity to 0 if &lt;em&gt;lambd&lt;/em&gt; is negative.</source>
          <target state="translated">지수 분포. &lt;em&gt;lambd&lt;/em&gt; 는 1.0을 원하는 평균으로 나눈 &lt;em&gt;값&lt;/em&gt; 입니다. 0이 아니어야합니다. (파라미터가 '람다'이라하지만 파이썬 예약어 될 것이다.)가 리턴 값은 0에서 무한대까지의 범위 &lt;em&gt;lambd이&lt;/em&gt; 긍정적이고, 음의 무한대에서 0으로하는 경우 &lt;em&gt;lambd는&lt;/em&gt; 제외이다.</target>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="ffae2a0dbff1d55c82d5123af3372ea49a2b14bb" translate="yes" xml:space="preserve">
          <source>Expressing a percentage:</source>
          <target state="translated">백분율 표현 :</target>
        </trans-unit>
        <trans-unit id="be18dee812522c6b5b7a76e5832b6a8e4ca2b812" translate="yes" xml:space="preserve">
          <source>Extend the left side of the deque by appending elements from &lt;em&gt;iterable&lt;/em&gt;. Note, the series of left appends results in reversing the order of elements in the iterable argument.</source>
          <target state="translated">&lt;em&gt;iterable의&lt;/em&gt; 요소를 추가하여 deque의 왼쪽을 확장하십시오 . 일련의 왼쪽 추가는 반복 가능한 인수에서 요소의 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="f6c82ec936c20f92c0eaa0ffe5c71b79d6e553a1" translate="yes" xml:space="preserve">
          <source>Extend the right side of the deque by appending elements from the iterable argument.</source>
          <target state="translated">반복 가능한 인수에서 요소를 추가하여 deque의 오른쪽을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="ffb6a2c58a4241d2ba27231ce784eb5eb15764da" translate="yes" xml:space="preserve">
          <source>Extend the search path for the modules which comprise a package. Intended use is to place the following code in a package&amp;rsquo;s &lt;code&gt;__init__.py&lt;/code&gt;:</source>
          <target state="translated">패키지를 구성하는 모듈의 검색 경로를 확장하십시오. 의도 된 용도는 패키지의 &lt;code&gt;__init__.py&lt;/code&gt; 에 다음 코드를 배치하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8d3082bbd7153cdb35672556257cd022495b60e6" translate="yes" xml:space="preserve">
          <source>Extended header setting. This method is similar to &lt;a href=&quot;#email.message.EmailMessage.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt; except that additional header parameters can be provided as keyword arguments. &lt;em&gt;_name&lt;/em&gt; is the header field to add and &lt;em&gt;_value&lt;/em&gt; is the &lt;em&gt;primary&lt;/em&gt; value for the header.</source>
          <target state="translated">확장 된 헤더 설정. 이 메소드는 추가 헤더 매개 변수를 키워드 인수로 제공 할 수 있다는 점을 제외하고 &lt;a href=&quot;#email.message.EmailMessage.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; 과 유사합니다 . &lt;em&gt;_name&lt;/em&gt; 은 추가 할 헤더 필드이고 &lt;em&gt;_value&lt;/em&gt; 는 헤더 의 &lt;em&gt;기본&lt;/em&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="a223abaf54dc8e1ab3eeaa89f4cd896ed498bd79" translate="yes" xml:space="preserve">
          <source>Extended header setting. This method is similar to &lt;a href=&quot;#email.message.Message.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt; except that additional header parameters can be provided as keyword arguments. &lt;em&gt;_name&lt;/em&gt; is the header field to add and &lt;em&gt;_value&lt;/em&gt; is the &lt;em&gt;primary&lt;/em&gt; value for the header.</source>
          <target state="translated">확장 된 헤더 설정. 이 메소드는 추가 헤더 매개 변수를 키워드 인수로 제공 할 수 있다는 점을 제외하고 &lt;a href=&quot;#email.message.Message.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; 과 유사합니다 . &lt;em&gt;_name&lt;/em&gt; 은 추가 할 헤더 필드이고 &lt;em&gt;_value&lt;/em&gt; 는 헤더 의 &lt;em&gt;기본&lt;/em&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="8e0502094d27643a7e46ac113e2ec9103e1bc071" translate="yes" xml:space="preserve">
          <source>Extending &lt;a href=&quot;#json.JSONEncoder&quot;&gt;&lt;code&gt;JSONEncoder&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#json.JSONEncoder&quot;&gt; &lt;code&gt;JSONEncoder&lt;/code&gt; &lt;/a&gt; 확장 :</target>
        </trans-unit>
        <trans-unit id="3afaf5c09876f5a31aa15d2a3378f3f6a609a66e" translate="yes" xml:space="preserve">
          <source>Extending the search algorithm</source>
          <target state="translated">검색 알고리즘 확장</target>
        </trans-unit>
        <trans-unit id="d14fa83017c01db06e1c086ad2b398b643736e71" translate="yes" xml:space="preserve">
          <source>Extends this array with data from the given unicode string. The array must be a type &lt;code&gt;'u'&lt;/code&gt; array; otherwise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. Use &lt;code&gt;array.frombytes(unicodestring.encode(enc))&lt;/code&gt; to append Unicode data to an array of some other type.</source>
          <target state="translated">지정된 유니 코드 문자열의 데이터로이 배열을 확장합니다. 배열은 유형 &lt;code&gt;'u'&lt;/code&gt; 배열이어야합니다 . 그렇지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 사용 &lt;code&gt;array.frombytes(unicodestring.encode(enc))&lt;/code&gt; 어떤 다른 유형의 어레이를 유니 코드 데이터를 추가한다.</target>
        </trans-unit>
        <trans-unit id="d17e683a4537ea32b7744d3fc9435748a13093cb" translate="yes" xml:space="preserve">
          <source>Extensible JSON encoder for Python data structures.</source>
          <target state="translated">Python 데이터 구조를위한 확장 가능한 JSON 인코더</target>
        </trans-unit>
        <trans-unit id="4c367fb4974a67cae0c760962b58c3b9529d4ac9" translate="yes" xml:space="preserve">
          <source>Extension modules should never call &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt;, except to find out what the current locale is. But since the return value can only be used portably to restore it, that is not very useful (except perhaps to find out whether or not the locale is &lt;code&gt;C&lt;/code&gt;).</source>
          <target state="translated">확장 모듈은 현재 로케일이 무엇인지 알아내는 것을 제외하고 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 호출해서는 안됩니다 . 그러나 반환 값은 이식하기 위해 이식 가능하게 사용될 수 있기 때문에 그다지 유용하지 않습니다 (로케일이 &lt;code&gt;C&lt;/code&gt; 인지 아닌지 여부는 제외 ).</target>
        </trans-unit>
        <trans-unit id="ba4c6b9afff6a08f053cba5afe9f2c4f782f677a" translate="yes" xml:space="preserve">
          <source>Extension types can easily be made to support weak references; see &lt;a href=&quot;https://docs.python.org/3.8/extending/newtypes.html#weakref-support&quot;&gt;Weak Reference Support&lt;/a&gt;.</source>
          <target state="translated">약한 참조를 지원하기 위해 확장 유형을 쉽게 만들 수 있습니다. &lt;a href=&quot;https://docs.python.org/3.8/extending/newtypes.html#weakref-support&quot;&gt;약한 참조 지원을 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="6c4a75205736caa4d532e632bbb923d90e882d92" translate="yes" xml:space="preserve">
          <source>Extensions peculiar to a particular operating system are also available through the &lt;a href=&quot;#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module, but using them is of course a threat to portability.</source>
          <target state="translated">특정 운영 체제에 맞는 확장 기능도 &lt;a href=&quot;#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈을 통해 사용할 수 있지만이를 사용하는 것은 물론 이식성에 위협이됩니다.</target>
        </trans-unit>
        <trans-unit id="59a8e4193969041eb8a334bce8673971dd5ac36d" translate="yes" xml:space="preserve">
          <source>Extensive tutorial plus friendlier widget pages for some of the widgets.</source>
          <target state="translated">일부 위젯에 대한 광범위한 자습서 및 더 친숙한 위젯 페이지</target>
        </trans-unit>
        <trans-unit id="c970654c58357168192acf4ccb045a4ec563e56d" translate="yes" xml:space="preserve">
          <source>External file attributes.</source>
          <target state="translated">외부 파일 속성</target>
        </trans-unit>
        <trans-unit id="2dfc8906bc4cd8f73d660501349acb60a736207e" translate="yes" xml:space="preserve">
          <source>Extract a member from the archive as a file object. &lt;em&gt;member&lt;/em&gt; may be a filename or a &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt; object. If &lt;em&gt;member&lt;/em&gt; is a regular file or a link, an &lt;a href=&quot;io#io.BufferedReader&quot;&gt;&lt;code&gt;io.BufferedReader&lt;/code&gt;&lt;/a&gt; object is returned. Otherwise, &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">아카이브에서 멤버를 파일 오브젝트로 추출하십시오. &lt;em&gt;member&lt;/em&gt; 는 파일 이름이거나 &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다 . 경우 &lt;em&gt;회원이&lt;/em&gt; 일반 파일 또는 링크입니다, &lt;a href=&quot;io#io.BufferedReader&quot;&gt; &lt;code&gt;io.BufferedReader&lt;/code&gt; 의&lt;/a&gt; 객체가 돌려 주어집니다. 그렇지 않으면 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7153d56eaff624dd418e50a12f92bf3a17f36bf7" translate="yes" xml:space="preserve">
          <source>Extract a member from the archive to the current working directory, using its full name. Its file information is extracted as accurately as possible. &lt;em&gt;member&lt;/em&gt; may be a filename or a &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt; object. You can specify a different directory using &lt;em&gt;path&lt;/em&gt;. &lt;em&gt;path&lt;/em&gt; may be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;. File attributes (owner, mtime, mode) are set unless &lt;em&gt;set_attrs&lt;/em&gt; is false.</source>
          <target state="translated">전체 이름을 사용하여 아카이브에서 현재 작업 디렉토리로 멤버를 추출하십시오. 파일 정보가 최대한 정확하게 추출됩니다. &lt;em&gt;member&lt;/em&gt; 는 파일 이름이거나 &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다 . &lt;em&gt;path를&lt;/em&gt; 사용하여 다른 디렉토리를 지정할 수 있습니다 . &lt;em&gt;path&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은 객체&lt;/a&gt; 일 수 있습니다 . &lt;em&gt;set_attrs&lt;/em&gt; 가 false가 아니면 파일 속성 (소유자, mtime, 모드)이 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="49bf42b59323ef5711d695a532178f9f50306eed" translate="yes" xml:space="preserve">
          <source>Extract a member from the archive to the current working directory; &lt;em&gt;member&lt;/em&gt; must be its full name or a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; object. Its file information is extracted as accurately as possible. &lt;em&gt;path&lt;/em&gt; specifies a different directory to extract to. &lt;em&gt;member&lt;/em&gt; can be a filename or a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; object. &lt;em&gt;pwd&lt;/em&gt; is the password used for encrypted files.</source>
          <target state="translated">아카이브에서 현재 작업 디렉토리로 멤버를 추출하십시오. &lt;em&gt;member&lt;/em&gt; 는 전체 이름이거나 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 객체 여야 합니다. 파일 정보가 최대한 정확하게 추출됩니다. &lt;em&gt;path&lt;/em&gt; 는 추출 할 다른 디렉토리를 지정합니다. &lt;em&gt;member&lt;/em&gt; 는 파일 이름 또는 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다 . &lt;em&gt;pwd&lt;/em&gt; 는 암호화 된 파일에 사용되는 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="544c78afc0b0d1b40f8be394b534ce094d439335" translate="yes" xml:space="preserve">
          <source>Extract all doctest examples from the given string, and collect them into a &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">주어진 문자열에서 모든 doctest 예제를 추출하여 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 객체 로 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="cce34faeb7495a0b53c8fa130ee26d2cc6aa07f2" translate="yes" xml:space="preserve">
          <source>Extract all doctest examples from the given string, and return them as a list of &lt;a href=&quot;#doctest.Example&quot;&gt;&lt;code&gt;Example&lt;/code&gt;&lt;/a&gt; objects. Line numbers are 0-based. The optional argument &lt;em&gt;name&lt;/em&gt; is a name identifying this string, and is only used for error messages.</source>
          <target state="translated">주어진 문자열에서 모든 doctest 예제를 추출하여 &lt;a href=&quot;#doctest.Example&quot;&gt; &lt;code&gt;Example&lt;/code&gt; &lt;/a&gt; 개체 목록으로 반환합니다 . 줄 번호는 0부터 시작합니다. 선택적 인수 &lt;em&gt;이름&lt;/em&gt; 은이 문자열을 식별하는 이름이며 오류 메시지에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c9c93f9c15436e53bdd54ee82b7378dd38a0185" translate="yes" xml:space="preserve">
          <source>Extract all members from the archive to the current working directory or directory &lt;em&gt;path&lt;/em&gt;. If optional &lt;em&gt;members&lt;/em&gt; is given, it must be a subset of the list returned by &lt;a href=&quot;#tarfile.TarFile.getmembers&quot;&gt;&lt;code&gt;getmembers()&lt;/code&gt;&lt;/a&gt;. Directory information like owner, modification time and permissions are set after all members have been extracted. This is done to work around two problems: A directory&amp;rsquo;s modification time is reset each time a file is created in it. And, if a directory&amp;rsquo;s permissions do not allow writing, extracting files to it will fail.</source>
          <target state="translated">아카이브에서 현재 작업 디렉토리 또는 디렉토리 &lt;em&gt;경로로&lt;/em&gt; 모든 멤버를 추출하십시오 . 선택적 &lt;em&gt;멤버&lt;/em&gt; 가 제공되면 &lt;a href=&quot;#tarfile.TarFile.getmembers&quot;&gt; &lt;code&gt;getmembers()&lt;/code&gt; &lt;/a&gt; 리턴 한 목록의 서브 세트 여야합니다 . 소유자, 수정 시간 및 권한과 같은 디렉토리 정보는 모든 구성원이 추출 된 후에 설정됩니다. 이것은 두 가지 문제를 해결하기 위해 수행됩니다. 디렉토리의 수정 시간은 파일이 생성 될 때마다 재설정됩니다. 또한 디렉토리의 권한이 쓰기를 허용하지 않으면 파일 추출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae6c5957177f81679444f51641f06f6286ee4707" translate="yes" xml:space="preserve">
          <source>Extract all members from the archive to the current working directory. &lt;em&gt;path&lt;/em&gt; specifies a different directory to extract to. &lt;em&gt;members&lt;/em&gt; is optional and must be a subset of the list returned by &lt;a href=&quot;#zipfile.ZipFile.namelist&quot;&gt;&lt;code&gt;namelist()&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;pwd&lt;/em&gt; is the password used for encrypted files.</source>
          <target state="translated">아카이브에서 현재 작업 디렉토리로 모든 멤버를 추출하십시오. &lt;em&gt;path&lt;/em&gt; 는 추출 할 다른 디렉토리를 지정합니다. &lt;em&gt;member&lt;/em&gt; 는 선택 사항이며 &lt;a href=&quot;#zipfile.ZipFile.namelist&quot;&gt; &lt;code&gt;namelist()&lt;/code&gt; &lt;/a&gt; 리턴 한 목록 의 서브 세트 여야합니다 . &lt;em&gt;pwd&lt;/em&gt; 는 암호화 된 파일에 사용되는 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="10ff4d347f866ccd5f2a70db8425173e5abbb3e1" translate="yes" xml:space="preserve">
          <source>Extract cookies from HTTP &lt;em&gt;response&lt;/em&gt; and store them in the &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt;, where allowed by policy.</source>
          <target state="translated">HTTP &lt;em&gt;응답&lt;/em&gt; 에서 쿠키를 추출 하여 정책에서 허용하는 경우 &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; 에&lt;/a&gt; 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="7762c8d14b070a61912e484ba2fc6db8aad38059" translate="yes" xml:space="preserve">
          <source>Extract tarfile into the current directory if &lt;em&gt;output_dir&lt;/em&gt; is not specified.</source>
          <target state="translated">&lt;em&gt;output_dir&lt;/em&gt; 이 지정되지 않은 경우 tarfile을 현재 디렉토리로 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee747f17d62300fd6c830b297f78009d8493b4da" translate="yes" xml:space="preserve">
          <source>Extract the device major number from a raw device number (usually the &lt;code&gt;st_dev&lt;/code&gt; or &lt;code&gt;st_rdev&lt;/code&gt; field from &lt;code&gt;stat&lt;/code&gt;).</source>
          <target state="translated">원시 장치 번호 (일반적으로 &lt;code&gt;stat&lt;/code&gt; 의 &lt;code&gt;st_dev&lt;/code&gt; 또는 &lt;code&gt;st_rdev&lt;/code&gt; 필드)에서 장치 주 번호를 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="5de253fc01d8caa12b19702c93bce330b8060401" translate="yes" xml:space="preserve">
          <source>Extract the device minor number from a raw device number (usually the &lt;code&gt;st_dev&lt;/code&gt; or &lt;code&gt;st_rdev&lt;/code&gt; field from &lt;code&gt;stat&lt;/code&gt;).</source>
          <target state="translated">원시 장치 번호 (일반적으로 &lt;code&gt;stat&lt;/code&gt; 의 &lt;code&gt;st_dev&lt;/code&gt; 또는 &lt;code&gt;st_rdev&lt;/code&gt; 필드)에서 장치 부 번호를 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="3546e06d76818c1a64fd63ff46d39da1c08c38e7" translate="yes" xml:space="preserve">
          <source>Extract the raw traceback from the current stack frame. The return value has the same format as for &lt;a href=&quot;#traceback.extract_tb&quot;&gt;&lt;code&gt;extract_tb()&lt;/code&gt;&lt;/a&gt;. The optional &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;limit&lt;/em&gt; arguments have the same meaning as for &lt;a href=&quot;#traceback.print_stack&quot;&gt;&lt;code&gt;print_stack()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 스택 프레임에서 원시 역 추출을 추출하십시오. 리턴 값은 &lt;a href=&quot;#traceback.extract_tb&quot;&gt; &lt;code&gt;extract_tb()&lt;/code&gt; &lt;/a&gt; 와 형식이 동일합니다 . 선택적 &lt;em&gt;f&lt;/em&gt; 및 &lt;em&gt;limit&lt;/em&gt; 인수는 &lt;a href=&quot;#traceback.print_stack&quot;&gt; &lt;code&gt;print_stack()&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="e90fa4052b0c2e280e5fd99db0fbdd283520863d" translate="yes" xml:space="preserve">
          <source>Extract the url from a wrapped URL (that is, a string formatted as &lt;code&gt;&amp;lt;URL:scheme://host/path&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;scheme://host/path&amp;gt;&lt;/code&gt;, &lt;code&gt;URL:scheme://host/path&lt;/code&gt; or &lt;code&gt;scheme://host/path&lt;/code&gt;). If &lt;em&gt;url&lt;/em&gt; is not a wrapped URL, it is returned without changes.</source>
          <target state="translated">랩핑 된 URL에서 URL을 추출하십시오 (즉, &lt;code&gt;&amp;lt;URL:scheme://host/path&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;scheme://host/path&amp;gt;&lt;/code&gt; , &lt;code&gt;URL:scheme://host/path&lt;/code&gt; 또는 &lt;code&gt;scheme://host/path&lt;/code&gt; ). &lt;em&gt;url&lt;/em&gt; 이 랩핑 된 URL이 아닌 경우 변경없이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="80f14583713f04ef76e155d25c0906636fb553b4" translate="yes" xml:space="preserve">
          <source>Extract zipfile into target directory.</source>
          <target state="translated">zip 파일을 대상 디렉토리로 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="7a127fcb19d14c22958f0b2767119f711a5ee7e4" translate="yes" xml:space="preserve">
          <source>F flag</source>
          <target state="translated">F 플래그</target>
        </trans-unit>
        <trans-unit id="07c257b16606b468b4287bbfd069963fcb6c04a5" translate="yes" xml:space="preserve">
          <source>FIFO</source>
          <target state="translated">FIFO</target>
        </trans-unit>
        <trans-unit id="0e2b10e415755511239c761ec49ff29c9352b3b0" translate="yes" xml:space="preserve">
          <source>FIFO.</source>
          <target state="translated">FIFO.</target>
        </trans-unit>
        <trans-unit id="e47e8f6fd115bffcf60d2af9abb109a1fa0925c8" translate="yes" xml:space="preserve">
          <source>FIFOs are pipes that can be accessed like regular files. FIFOs exist until they are deleted (for example with &lt;a href=&quot;#os.unlink&quot;&gt;&lt;code&gt;os.unlink()&lt;/code&gt;&lt;/a&gt;). Generally, FIFOs are used as rendezvous between &amp;ldquo;client&amp;rdquo; and &amp;ldquo;server&amp;rdquo; type processes: the server opens the FIFO for reading, and the client opens it for writing. Note that &lt;a href=&quot;#os.mkfifo&quot;&gt;&lt;code&gt;mkfifo()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t open the FIFO &amp;mdash; it just creates the rendezvous point.</source>
          <target state="translated">FIFO는 일반 파일처럼 액세스 할 수있는 파이프입니다. FIFO는 삭제 될 때까지 존재합니다 (예 : &lt;a href=&quot;#os.unlink&quot;&gt; &lt;code&gt;os.unlink()&lt;/code&gt; &lt;/a&gt; ). 일반적으로 FIFO는 &quot;클라이언트&quot;와 &quot;서버&quot;유형 프로세스 사이의 랑데부로 사용됩니다. 서버는 읽기 위해 FIFO를 열고 클라이언트는 쓰기 위해 FIFO를 엽니 다. 참고 것으로 &lt;a href=&quot;#os.mkfifo&quot;&gt; &lt;code&gt;mkfifo()&lt;/code&gt; &lt;/a&gt; FIFO에 열리지 않습니다 - 그냥 랑데부 지점을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="73792fb55d9abc9e92d1d3ebcd41bd7ba0f108d2" translate="yes" xml:space="preserve">
          <source>FILTER_DIR</source>
          <target state="translated">FILTER_DIR</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="fff53c283733fcf57487666af2c11072c9f49c9f" translate="yes" xml:space="preserve">
          <source>FTP Objects</source>
          <target state="translated">FTP 객체</target>
        </trans-unit>
        <trans-unit id="d290164b6f9f0f0391591dd5f84256b1aa55a88a" translate="yes" xml:space="preserve">
          <source>FTPHandler Objects</source>
          <target state="translated">FTPHandler 객체</target>
        </trans-unit>
        <trans-unit id="aa3185ffb8ddcb7e8518130ce5be3ff6a65da6ca" translate="yes" xml:space="preserve">
          <source>FTP_TLS Objects</source>
          <target state="translated">FTP_TLS 객체</target>
        </trans-unit>
        <trans-unit id="a1c787ee1263352ed63b1407e8cc20b772ec3981" translate="yes" xml:space="preserve">
          <source>Facilities:</source>
          <target state="translated">Facilities:</target>
        </trans-unit>
        <trans-unit id="6f7d036abe80e350d83c5c2ef79b8d3dffb2724d" translate="yes" xml:space="preserve">
          <source>Fails if either of &lt;em&gt;first&lt;/em&gt; or &lt;em&gt;second&lt;/em&gt; does not have a &lt;code&gt;set.difference()&lt;/code&gt; method.</source>
          <target state="translated">&lt;em&gt;첫 번째&lt;/em&gt; 또는 &lt;em&gt;두 번째&lt;/em&gt; 중 하나에 &lt;code&gt;set.difference()&lt;/code&gt; 메서드 가 없으면 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="e8dee02f91d0dedd9886f02de920cf9df2f8dc44" translate="yes" xml:space="preserve">
          <source>Fairly portable uname interface. Returns a &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple()&lt;/code&gt;&lt;/a&gt; containing six attributes: &lt;a href=&quot;#platform.system&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#platform.node&quot;&gt;&lt;code&gt;node&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#platform.release&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#platform.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#platform.machine&quot;&gt;&lt;code&gt;machine&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#platform.processor&quot;&gt;&lt;code&gt;processor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">휴대 성이 뛰어난 uname 인터페이스. &lt;a href=&quot;#platform.system&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#platform.node&quot;&gt; &lt;code&gt;node&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#platform.release&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#platform.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#platform.machine&quot;&gt; &lt;code&gt;machine&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#platform.processor&quot;&gt; &lt;code&gt;processor&lt;/code&gt; 의&lt;/a&gt; 여섯 가지 속성이 포함 된 &lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple()&lt;/code&gt; &lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="294d81f34aa607f6b9a4fa9aa3bd6b4ade4054e3" translate="yes" xml:space="preserve">
          <source>Fallback Values</source>
          <target state="translated">대체 값</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="ac137ed5a5d51689e8820aa48b3c1f650954ec51" translate="yes" xml:space="preserve">
          <source>Fast, floating point arithmetic mean.</source>
          <target state="translated">부동 소수점 산술 평균.</target>
        </trans-unit>
        <trans-unit id="c85baec0392432a2c74935a26751b47a0c953558" translate="yes" xml:space="preserve">
          <source>Fault Objects</source>
          <target state="translated">결함 객체</target>
        </trans-unit>
        <trans-unit id="91f8cc8b15d01ea4c886759792d8b779dea3eea4" translate="yes" xml:space="preserve">
          <source>Fault handler state</source>
          <target state="translated">결함 핸들러 상태</target>
        </trans-unit>
        <trans-unit id="4d5f2566e2cbc8bd29a99af73a71daeccdfbc018" translate="yes" xml:space="preserve">
          <source>Feature Table</source>
          <target state="translated">기능 표</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="12c5a78b3238d1421e12eecf4ddf3ff8b1e448d5" translate="yes" xml:space="preserve">
          <source>Feed some text to the parser. It is processed insofar as it consists of complete elements; incomplete data is buffered until more data is fed or &lt;a href=&quot;#html.parser.HTMLParser.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; is called. &lt;em&gt;data&lt;/em&gt; must be &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파서에 텍스트를 공급하십시오. 완전한 요소로 구성되는 한 처리됩니다. 불완전한 데이터는 더 많은 데이터가 제공되거나 &lt;a href=&quot;#html.parser.HTMLParser.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때까지 버퍼링 됩니다. &lt;em&gt;데이터&lt;/em&gt; 는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f6658ca774a02313850f8d0282b532ca38865c5" translate="yes" xml:space="preserve">
          <source>Feed the given bytes data to the parser.</source>
          <target state="translated">주어진 바이트 데이터를 파서에 공급합니다.</target>
        </trans-unit>
        <trans-unit id="387b29142d787ced69aeae549492449687987c43" translate="yes" xml:space="preserve">
          <source>Feed the parser some more data. &lt;em&gt;data&lt;/em&gt; should be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; containing one or more lines. The lines can be partial and the parser will stitch such partial lines together properly. The lines can have any of the three common line endings: carriage return, newline, or carriage return and newline (they can even be mixed).</source>
          <target state="translated">파서에 더 많은 데이터를 공급하십시오. &lt;em&gt;데이터&lt;/em&gt; 는 하나 이상의 행을 포함 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 여야합니다 . 선은 부분적 일 수 있으며 파서는 그러한 부분적 선을 올바르게 연결합니다. 줄은 캐리지 리턴, 줄 바꿈 또는 캐리지 리턴과 줄 바꿈의 세 가지 공통 줄 끝을 가질 수 있습니다 (혼합 가능).</target>
        </trans-unit>
        <trans-unit id="a50061ac9428ad8cb79bfb2c8ac329810e31e666" translate="yes" xml:space="preserve">
          <source>FeedParser API</source>
          <target state="translated">FeedParser API</target>
        </trans-unit>
        <trans-unit id="4b2cf2461de886a6ab48362af6c696c99b94d007" translate="yes" xml:space="preserve">
          <source>Feeding incomplete chunks to &lt;a href=&quot;#html.parser.HTMLParser.feed&quot;&gt;&lt;code&gt;feed()&lt;/code&gt;&lt;/a&gt; works, but &lt;a href=&quot;#html.parser.HTMLParser.handle_data&quot;&gt;&lt;code&gt;handle_data()&lt;/code&gt;&lt;/a&gt; might be called more than once (unless &lt;em&gt;convert_charrefs&lt;/em&gt; is set to &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">불완전한 청크를 &lt;a href=&quot;#html.parser.HTMLParser.feed&quot;&gt; &lt;code&gt;feed()&lt;/code&gt; &lt;/a&gt; 에 공급하는 것은 작동하지만 &lt;a href=&quot;#html.parser.HTMLParser.handle_data&quot;&gt; &lt;code&gt;handle_data()&lt;/code&gt; &lt;/a&gt; 가 두 번 이상 호출 될 수 있습니다 ( &lt;em&gt;convert_charrefs&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 설정 되지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="8c798e0422da17ca64b8b53da08c916bb2d4dba5" translate="yes" xml:space="preserve">
          <source>Feeding string objects into &lt;code&gt;update()&lt;/code&gt; is not supported, as hashes work on bytes, not on characters.</source>
          <target state="translated">해시가 문자가 아닌 바이트에서 작동하므로 문자열 객체를 &lt;code&gt;update()&lt;/code&gt; 에 공급하는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3cb49dc70c7bb4c8ba2aa9114340fbd11566992" translate="yes" xml:space="preserve">
          <source>Feeds data to the parser. &lt;em&gt;data&lt;/em&gt; is encoded data.</source>
          <target state="translated">파서에 데이터를 공급합니다. &lt;em&gt;데이터&lt;/em&gt; 는 인코딩 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="63da3e374ffa9eea709999e80cff37c228002165" translate="yes" xml:space="preserve">
          <source>Fetch (parts of) messages. &lt;em&gt;message_parts&lt;/em&gt; should be a string of message part names enclosed within parentheses, eg: &lt;code&gt;&quot;(UID BODY[TEXT])&quot;&lt;/code&gt;. Returned data are tuples of message part envelope and data.</source>
          <target state="translated">메시지를 가져옵니다 (일부). &lt;em&gt;message_parts&lt;/em&gt; 는 괄호로 묶인 메시지 부분 이름의 문자열이어야합니다 &lt;code&gt;&quot;(UID BODY[TEXT])&quot;&lt;/code&gt; 예 : &quot;(UID BODY [TEXT])&quot;) . 반환 된 데이터는 메시지 부분 봉투와 데이터의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="a353d7de52e3d80c0d9c5a4d72ac4dc117b1a277" translate="yes" xml:space="preserve">
          <source>Fetch and/or change the signal mask of the calling thread. The signal mask is the set of signals whose delivery is currently blocked for the caller. Return the old signal mask as a set of signals.</source>
          <target state="translated">호출 스레드의 신호 마스크를 가져 오거나 변경합니다. 신호 마스크는 발신자가 현재 배달이 차단 된 신호 세트입니다. 이전 신호 마스크를 신호 세트로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="cc3b211a4b23d07ed59e5660c59a281f7c520d6e" translate="yes" xml:space="preserve">
          <source>Fetch truncated part of a message. Returned data is a tuple of message part envelope and data.</source>
          <target state="translated">메시지의 잘린 부분을 가져옵니다. 반환 된 데이터는 메시지 부분 봉투와 데이터의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="41a014822c374f4dc32ed7c3bb8b27a133b416fe" translate="yes" xml:space="preserve">
          <source>Fetches all (remaining) rows of a query result, returning a list. Note that the cursor&amp;rsquo;s arraysize attribute can affect the performance of this operation. An empty list is returned when no rows are available.</source>
          <target state="translated">쿼리 결과의 모든 (남은) 행을 가져오고 목록을 반환합니다. 커서의 arraysize 속성은이 작업의 성능에 영향을 줄 수 있습니다. 사용 가능한 행이 없으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b5c8387f5e5b6662fa105e9b5dc36427bb6cda63" translate="yes" xml:space="preserve">
          <source>Fetches the next row of a query result set, returning a single sequence, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; when no more data is available.</source>
          <target state="translated">하나의 시퀀스 또는 반환, 쿼리 결과 집합의 다음 행을 꺼냅니다 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 더 이상 데이터를 사용할 수 없을 때.</target>
        </trans-unit>
        <trans-unit id="e2a8b384625d9b783eb012a6161ee49d504b3ea1" translate="yes" xml:space="preserve">
          <source>Fetches the next set of rows of a query result, returning a list. An empty list is returned when no more rows are available.</source>
          <target state="translated">쿼리 결과의 다음 행 집합을 가져 와서 목록을 반환합니다. 더 이상 사용할 수있는 행이 없으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="82d6a64de9a0838fcf2235d8ad49a6d8855b7d1d" translate="yes" xml:space="preserve">
          <source>Fetching a &lt;a href=&quot;#unittest.mock.PropertyMock&quot;&gt;&lt;code&gt;PropertyMock&lt;/code&gt;&lt;/a&gt; instance from an object calls the mock, with no args. Setting it calls the mock with the value being set.</source>
          <target state="translated">객체에서 &lt;a href=&quot;#unittest.mock.PropertyMock&quot;&gt; &lt;code&gt;PropertyMock&lt;/code&gt; &lt;/a&gt; 인스턴스를 가져 오면 인수없이 mock을 호출합니다. 설정하면 설정된 값으로 모의를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d54dbc3819945e4ef1e4f3d81c00a574445b7866" translate="yes" xml:space="preserve">
          <source>Fetching a header value from a &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; results in that header being parsed and a header object created and returned.</source>
          <target state="translated">&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 에서 헤더 값을 가져 오면 해당 헤더가 구문 분석되고 헤더 오브젝트가 작성되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7fdf343dc9e81798f45e8297c11c3eb775196edb" translate="yes" xml:space="preserve">
          <source>Fetching attributes statically</source>
          <target state="translated">정적으로 속성 가져 오기</target>
        </trans-unit>
        <trans-unit id="c326a4660b674d2f6ea82687a1e1abae2337541f" translate="yes" xml:space="preserve">
          <source>Field</source>
          <target state="translated">Field</target>
        </trans-unit>
        <trans-unit id="2dc913c8c6f4ce49af0f66f51e4ef93d71f78ea2" translate="yes" xml:space="preserve">
          <source>Field &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;descriptor&lt;/a&gt;s can be retrieved from the &lt;em&gt;class&lt;/em&gt;, they are useful for debugging because they can provide useful information:</source>
          <target state="translated">필드 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;디스크립터&lt;/a&gt; 는 &lt;em&gt;클래스&lt;/em&gt; 에서 검색 할 수 있으며 유용한 정보를 제공 할 수 있으므로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a9ad8121718f3a086e20f1b811bdb35613fea58f" translate="yes" xml:space="preserve">
          <source>Field names must be unique within one structure or union. This is not checked, only one field can be accessed when names are repeated.</source>
          <target state="translated">필드 이름은 하나의 구조 또는 공용체 내에서 고유해야합니다. 이것은 확인되지 않으며 이름이 반복 될 때 하나의 필드에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aebfd4803965d0fd4af25c185165627060d49d6" translate="yes" xml:space="preserve">
          <source>Field values can be ints, strings, or instances of the Binary class.</source>
          <target state="translated">필드 값은 정수, 문자열 또는 이진 클래스의 인스턴스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2529071dd608545d05e8531aeb3706a1791075" translate="yes" xml:space="preserve">
          <source>Fields with a default value must come after any fields without a default.</source>
          <target state="translated">기본값이있는 필드는 기본값이없는 필드 뒤에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="d19959803c490a8117d9f8eafb258f26113cfeed" translate="yes" xml:space="preserve">
          <source>File &amp;amp; Directory Access</source>
          <target state="translated">파일 및 디렉토리 액세스</target>
        </trans-unit>
        <trans-unit id="d63d873dbd7f480c6ba1f630266ff8116e6cfb7e" translate="yes" xml:space="preserve">
          <source>File Descriptor Operations</source>
          <target state="translated">파일 디스크립터 조작</target>
        </trans-unit>
        <trans-unit id="0d12a3f0ea99ebe85fe967431fc2aa6a3e0fd02b" translate="yes" xml:space="preserve">
          <source>File Formats</source>
          <target state="translated">파일 형식</target>
        </trans-unit>
        <trans-unit id="4bade3d77b57056d9a51c2d50dd4f03f30abeec7" translate="yes" xml:space="preserve">
          <source>File Handlers</source>
          <target state="translated">파일 핸들러</target>
        </trans-unit>
        <trans-unit id="e6e2940ee51b2dfd01e2af1d2390a9c616642912" translate="yes" xml:space="preserve">
          <source>File Names, Command Line Arguments, and Environment Variables</source>
          <target state="translated">파일 이름, 명령 줄 인수 및 환경 변수</target>
        </trans-unit>
        <trans-unit id="6dec3d0c4b79541a012c7baa6831c7a5ed83666c" translate="yes" xml:space="preserve">
          <source>File Object Creation</source>
          <target state="translated">파일 객체 생성</target>
        </trans-unit>
        <trans-unit id="a726cab0d7c518573e2f7003375fc21599153b1b" translate="yes" xml:space="preserve">
          <source>File Operations</source>
          <target state="translated">파일 작업</target>
        </trans-unit>
        <trans-unit id="fb6199fbca045175a16aa44e72c21f07a4b53d94" translate="yes" xml:space="preserve">
          <source>File Selectors</source>
          <target state="translated">파일 선택기</target>
        </trans-unit>
        <trans-unit id="14692faa66db9ad4f6b25ac054c61284fcee9f47" translate="yes" xml:space="preserve">
          <source>File Separator</source>
          <target state="translated">파일 구분자</target>
        </trans-unit>
        <trans-unit id="65d2775d2856db4e2072563cba39b4d84c4b88b1" translate="yes" xml:space="preserve">
          <source>File System limitations</source>
          <target state="translated">파일 시스템 제한</target>
        </trans-unit>
        <trans-unit id="ba50e3ff10f69bbcd78d2b51aa445f4bc91949b8" translate="yes" xml:space="preserve">
          <source>File and Directory Access</source>
          <target state="translated">파일 및 디렉토리 액세스</target>
        </trans-unit>
        <trans-unit id="f706e474058c3454a43a75c49c2b8118348979e4" translate="yes" xml:space="preserve">
          <source>File descriptor in bad state</source>
          <target state="translated">잘못된 상태의 파일 디스크립터</target>
        </trans-unit>
        <trans-unit id="a95112fa18cc4f2138e56a1ce528b00f3ae2af02" translate="yes" xml:space="preserve">
          <source>File descriptors are small integers corresponding to a file that has been opened by the current process. For example, standard input is usually file descriptor 0, standard output is 1, and standard error is 2. Further files opened by a process will then be assigned 3, 4, 5, and so forth. The name &amp;ldquo;file descriptor&amp;rdquo; is slightly deceptive; on Unix platforms, sockets and pipes are also referenced by file descriptors.</source>
          <target state="translated">파일 디스크립터는 현재 프로세스에서 열린 파일에 해당하는 작은 정수입니다. 예를 들어, 표준 입력은 일반적으로 파일 디스크립터 0이고 표준 출력은 1이며 표준 오류는 2입니다. 프로세스에 의해 열린 추가 파일에는 3, 4, 5 등이 할당됩니다. &amp;ldquo;파일 설명자&amp;rdquo;라는 이름은 약간 기만적입니다. 유닉스 플랫폼에서 소켓과 파이프는 파일 디스크립터에 의해 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">파일이 존재</target>
        </trans-unit>
        <trans-unit id="cb5afff2713b6247dbc93cc5a2a8350787630318" translate="yes" xml:space="preserve">
          <source>File generation number.</source>
          <target state="translated">파일 생성 번호</target>
        </trans-unit>
        <trans-unit id="3e8a264d601e926718226415b8aea5f39c39c77a" translate="yes" xml:space="preserve">
          <source>File locking deadlock error</source>
          <target state="translated">파일 잠금 교착 상태 오류</target>
        </trans-unit>
        <trans-unit id="a753126c02a7cdcf2329de8b6f0184b625a67089" translate="yes" xml:space="preserve">
          <source>File menu (Shell and Editor)</source>
          <target state="translated">파일 메뉴 (쉘 및 편집기)</target>
        </trans-unit>
        <trans-unit id="6ec4b4ae68331f38e8eb79a30a03536a294a8f5c" translate="yes" xml:space="preserve">
          <source>File mode: file type and file mode bits (permissions).</source>
          <target state="translated">파일 모드 : 파일 유형 및 파일 모드 비트 (권한).</target>
        </trans-unit>
        <trans-unit id="8a87b64cae5a39a0265ada62f19e089c25fa123c" translate="yes" xml:space="preserve">
          <source>File name too long</source>
          <target state="translated">파일 이름이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="42f4b294f545a51be6ba48389e180aadbe58f642" translate="yes" xml:space="preserve">
          <source>File object registered.</source>
          <target state="translated">파일 객체가 등록되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8840fb4bc3b477275dcdcfe4e561235b1db91f8" translate="yes" xml:space="preserve">
          <source>File objects on Windows are not acceptable, but sockets are. On Windows, the underlying &lt;code&gt;select()&lt;/code&gt; function is provided by the WinSock library, and does not handle file descriptors that don&amp;rsquo;t originate from WinSock.</source>
          <target state="translated">Windows의 파일 오브젝트는 허용되지 않지만 소켓은 허용됩니다. Windows에서 기본 &lt;code&gt;select()&lt;/code&gt; 함수는 WinSock 라이브러리에서 제공되며 WinSock에서 생성되지 않은 파일 디스크립터를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="600941bc483d702b3e6700aa5c9df8eaacfc769f" translate="yes" xml:space="preserve">
          <source>File separator</source>
          <target state="translated">파일 구분자</target>
        </trans-unit>
        <trans-unit id="f61db49fc791da76e7a4fae457554297e80648e3" translate="yes" xml:space="preserve">
          <source>File system calls on reserved paths can fail mysteriously or have unintended effects.</source>
          <target state="translated">예약 된 경로의 파일 시스템 호출은 신비하게 실패하거나 의도하지 않은 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c59929bfdd3ce1a14ecda0c9b3a704ea61f8d0" translate="yes" xml:space="preserve">
          <source>File system path representation: &lt;code&gt;__fspath__&lt;/code&gt;</source>
          <target state="translated">파일 시스템 경로 표현 : &lt;code&gt;__fspath__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bca9e4b99c52f14bead7db3f4a025c74ea71611" translate="yes" xml:space="preserve">
          <source>File table overflow</source>
          <target state="translated">파일 테이블 오버 플로우</target>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">파일이 너무 큽니다</target>
        </trans-unit>
        <trans-unit id="51583aa4b17cb383a15403102b60604e1ffe68c3" translate="yes" xml:space="preserve">
          <source>File type.</source>
          <target state="translated">파일 형식</target>
        </trans-unit>
        <trans-unit id="e0343558dc440a496930dadd39dd8387c3ef8a09" translate="yes" xml:space="preserve">
          <source>File type. &lt;em&gt;type&lt;/em&gt; is usually one of these constants: &lt;code&gt;REGTYPE&lt;/code&gt;, &lt;code&gt;AREGTYPE&lt;/code&gt;, &lt;code&gt;LNKTYPE&lt;/code&gt;, &lt;code&gt;SYMTYPE&lt;/code&gt;, &lt;code&gt;DIRTYPE&lt;/code&gt;, &lt;code&gt;FIFOTYPE&lt;/code&gt;, &lt;code&gt;CONTTYPE&lt;/code&gt;, &lt;code&gt;CHRTYPE&lt;/code&gt;, &lt;code&gt;BLKTYPE&lt;/code&gt;, &lt;code&gt;GNUTYPE_SPARSE&lt;/code&gt;. To determine the type of a &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt; object more conveniently, use the &lt;code&gt;is*()&lt;/code&gt; methods below.</source>
          <target state="translated">파일 형식 &lt;em&gt;type&lt;/em&gt; 은 일반적으로 &lt;code&gt;REGTYPE&lt;/code&gt; , &lt;code&gt;AREGTYPE&lt;/code&gt; , &lt;code&gt;LNKTYPE&lt;/code&gt; , &lt;code&gt;SYMTYPE&lt;/code&gt; , &lt;code&gt;DIRTYPE&lt;/code&gt; , &lt;code&gt;FIFOTYPE&lt;/code&gt; , &lt;code&gt;CONTTYPE&lt;/code&gt; , &lt;code&gt;CHRTYPE&lt;/code&gt; , &lt;code&gt;BLKTYPE&lt;/code&gt; , &lt;code&gt;GNUTYPE_SPARSE&lt;/code&gt; 상수 중 하나입니다 . &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; &lt;/a&gt; 객체 의 유형을 보다 편리하게 결정하려면 아래 의 &lt;code&gt;is*()&lt;/code&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc6610cbbc8b48db2b32dc4cea18d4eb726c9792" translate="yes" xml:space="preserve">
          <source>FileCookieJar subclasses and co-operation with web browsers</source>
          <target state="translated">FileCookieJar 서브 클래스 및 웹 브라우저와의 협력</target>
        </trans-unit>
        <trans-unit id="f383b8e9b99251c23741b31d5cc53abb63e20cdc" translate="yes" xml:space="preserve">
          <source>FileExistsError</source>
          <target state="translated">FileExistsError</target>
        </trans-unit>
        <trans-unit id="0ac6dbee4d8f540761408e72685ba06c2b71eae5" translate="yes" xml:space="preserve">
          <source>FileHandler</source>
          <target state="translated">FileHandler</target>
        </trans-unit>
        <trans-unit id="badf54288fb507d144cec214315538aa33ce8145" translate="yes" xml:space="preserve">
          <source>FileHandler Objects</source>
          <target state="translated">FileHandler 객체</target>
        </trans-unit>
        <trans-unit id="58c4fa0a0ae8dd1958950cee046cf91990f7447f" translate="yes" xml:space="preserve">
          <source>FileNotFoundError</source>
          <target state="translated">FileNotFoundError</target>
        </trans-unit>
        <trans-unit id="08f576d210cb57554632ff4a6560f019db2aebb7" translate="yes" xml:space="preserve">
          <source>FileType objects</source>
          <target state="translated">FileType 객체</target>
        </trans-unit>
        <trans-unit id="1327b5f2d09eccc6cf4ed8241ec999e6fd23b758" translate="yes" xml:space="preserve">
          <source>FileType objects understand the pseudo-argument &lt;code&gt;'-'&lt;/code&gt; and automatically convert this into &lt;code&gt;sys.stdin&lt;/code&gt; for readable &lt;a href=&quot;#argparse.FileType&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt; objects and &lt;code&gt;sys.stdout&lt;/code&gt; for writable &lt;a href=&quot;#argparse.FileType&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">FileType 객체는 의사 인수 &lt;code&gt;'-'&lt;/code&gt; 를 이해하고 읽을 수있는 &lt;a href=&quot;#argparse.FileType&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt; 객체의 경우 &lt;code&gt;sys.stdin&lt;/code&gt; 으로 , 그리고 쓰기 가능한 &lt;a href=&quot;#argparse.FileType&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt; 객체의 경우 &lt;code&gt;sys.stdout&lt;/code&gt; 으로 자동 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="40393ad111e27bcc683ee72e707bba890145c9d7" translate="yes" xml:space="preserve">
          <source>Filename (&lt;code&gt;str&lt;/code&gt;).</source>
          <target state="translated">파일 이름 ( &lt;code&gt;str&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="87a4cc2de20c7671ca65638a2d02e9365422f798" translate="yes" xml:space="preserve">
          <source>Filename of default file in which to keep cookies. This attribute may be assigned to.</source>
          <target state="translated">쿠키를 보관할 기본 파일의 파일 이름입니다. 이 속성은 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c43544dfb2a45f1802d1c763e2a6dc8daaa754" translate="yes" xml:space="preserve">
          <source>Filename pattern of the filter (&lt;code&gt;str&lt;/code&gt;). Read-only property.</source>
          <target state="translated">필터의 파일 이름 패턴 ( &lt;code&gt;str&lt;/code&gt; ). 읽기 전용 속성</target>
        </trans-unit>
        <trans-unit id="68d63bdb6592b17bfb046f862f466553bd3f6720" translate="yes" xml:space="preserve">
          <source>Filename portion of &lt;code&gt;pathname&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pathname&lt;/code&gt; 의 파일 이름 부분 .</target>
        </trans-unit>
        <trans-unit id="003505cb00a80d1f2f5ea93d0f9242196378636c" translate="yes" xml:space="preserve">
          <source>Files and Directories</source>
          <target state="translated">파일과 디렉토리</target>
        </trans-unit>
        <trans-unit id="759a6920d195b7ce8672f19ab41d440633e44c8b" translate="yes" xml:space="preserve">
          <source>Files and subdirectories in &lt;em&gt;a&lt;/em&gt;, filtered by &lt;em&gt;hide&lt;/em&gt; and &lt;em&gt;ignore&lt;/em&gt;.</source>
          <target state="translated">의 파일 및 하위 디렉토리 , 필터링 &lt;em&gt;숨기기&lt;/em&gt; 와 &lt;em&gt;무시&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a3936a42ac96b8925399b319d5a7d796d3d8db8" translate="yes" xml:space="preserve">
          <source>Files and subdirectories in &lt;em&gt;b&lt;/em&gt;, filtered by &lt;em&gt;hide&lt;/em&gt; and &lt;em&gt;ignore&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;b의&lt;/em&gt; 파일 및 하위 디렉토리로 , &lt;em&gt;hide&lt;/em&gt; 및 &lt;em&gt;ignore로&lt;/em&gt; 필터링됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8b6fbc3a2273d1bb7466dae95464866701031f5" translate="yes" xml:space="preserve">
          <source>Files and subdirectories in both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">모두의 파일 및 하위 디렉토리 와 &lt;em&gt;B&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed0be31e2bc597af493e72f4f33679b95df48ed6" translate="yes" xml:space="preserve">
          <source>Files and subdirectories only in &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">파일 및에서만 하위 디렉토리 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ac464055e749e1e5b207f242390a2ba0bfdade9" translate="yes" xml:space="preserve">
          <source>Files and subdirectories only in &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">파일 및에서만 하위 디렉토리 &lt;em&gt;나&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ae626010c4822a53276953b22090762c22ac3e" translate="yes" xml:space="preserve">
          <source>Files are an example of effectively single use context managers, since the first &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement will close the file, preventing any further IO operations using that file object.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문은 파일을 닫아 해당 파일 객체를 사용하는 추가 IO 작업을 막기 때문에 파일 은 효과적으로 단일 사용 컨텍스트 관리자의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4cd878bcefca3ec6e629466dc58bb31702253a22" translate="yes" xml:space="preserve">
          <source>Files in both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">모두의 파일 와 &lt;em&gt;B&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea2f41f1c05642d27cd04535fc0e6f3df0c5954b" translate="yes" xml:space="preserve">
          <source>Files which are identical in both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, using the class&amp;rsquo;s file comparison operator.</source>
          <target state="translated">클래스의 파일 비교 연산자를 사용하여 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 에서 동일한 파일.</target>
        </trans-unit>
        <trans-unit id="749d478161c9a248300f584a3f2f59df027d8b21" translate="yes" xml:space="preserve">
          <source>Files which are in both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, but could not be compared.</source>
          <target state="translated">&lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 모두 있지만 비교할 수없는 파일 .</target>
        </trans-unit>
        <trans-unit id="633f984cfb9a0ec3e74e412efec54a2603e5069c" translate="yes" xml:space="preserve">
          <source>Files which are in both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, whose contents differ according to the class&amp;rsquo;s file comparison operator.</source>
          <target state="translated">클래스의 파일 비교 연산자에 따라 내용이 다른 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 모두에 &lt;em&gt;있는&lt;/em&gt; 파일.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d1ee9e004d27605af6eb217be8809442c35a541" translate="yes" xml:space="preserve">
          <source>Fill the shape drawn after the last call to &lt;a href=&quot;#turtle.begin_fill&quot;&gt;&lt;code&gt;begin_fill()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#turtle.begin_fill&quot;&gt; &lt;code&gt;begin_fill()&lt;/code&gt; &lt;/a&gt; 을 마지막으로 호출 한 후 그린 모양을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="98325be45e57b01ea42841fb2dc63e31875877c1" translate="yes" xml:space="preserve">
          <source>Filling</source>
          <target state="translated">Filling</target>
        </trans-unit>
        <trans-unit id="3310f43302c999c8492a42df42ea6b5b288e9557" translate="yes" xml:space="preserve">
          <source>Filling an &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; with information about program arguments is done by making calls to the &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; method. Generally, these calls tell the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; how to take the strings on the command line and turn them into objects. This information is stored and used when &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; is called. For example:</source>
          <target state="translated">프로그램 인수에 대한 정보 로 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 를 채우는 것은 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 수행됩니다 . 일반적으로 이러한 호출은 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 에 명령 줄에서 문자열을 가져 와서 객체로 만드는 방법을 알려줍니다 . 이 정보는 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 저장되고 사용됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="a912d88c08a6e2310110ffbd20aa2b37095a730a" translate="yes" xml:space="preserve">
          <source>Filter Objects</source>
          <target state="translated">필터 객체</target>
        </trans-unit>
        <trans-unit id="a2d118fb1199e7aba611e82fb161d544d1eac75d" translate="yes" xml:space="preserve">
          <source>Filter action.</source>
          <target state="translated">필터 동작.</target>
        </trans-unit>
        <trans-unit id="40f168dc65ac13c1d458eb61d8d66634ac1a3375" translate="yes" xml:space="preserve">
          <source>Filter on traces of memory blocks.</source>
          <target state="translated">미량의 메모리 블록을 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="46599895c7cc0e31d2f5baffff2b94f7c4930832" translate="yes" xml:space="preserve">
          <source>Filter specific EOF condition</source>
          <target state="translated">필터 별 EOF 조건</target>
        </trans-unit>
        <trans-unit id="46c8bfb7a3178cfafcd4b07b975d5792a4676ea6" translate="yes" xml:space="preserve">
          <source>Filter specific data.</source>
          <target state="translated">특정 데이터를 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="9ac71d86bc0dc3c87565de360f8c150dfeaa3a12" translate="yes" xml:space="preserve">
          <source>Filter specific flags.</source>
          <target state="translated">특정 플래그를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="f615ce4691db8194f5e5c00719b0315f74011927" translate="yes" xml:space="preserve">
          <source>Filter traces of memory blocks by their address space (domain).</source>
          <target state="translated">주소 공간 (도메인)별로 메모리 블록의 흔적을 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="2353cd812767e6ab918c30790318afb782c94439" translate="yes" xml:space="preserve">
          <source>Filters provide a finer grained facility for determining which log records to output.</source>
          <target state="translated">필터는 출력 할 로그 레코드를 결정하기위한보다 세분화 된 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91234c54704fa45cc1c28452be237689e3afdac5" translate="yes" xml:space="preserve">
          <source>Finalizer Objects</source>
          <target state="translated">파이널 라이저 객체</target>
        </trans-unit>
        <trans-unit id="b4a9f27a229332b0ddb9b525d8627f1feae36bc7" translate="yes" xml:space="preserve">
          <source>Finally send the headers to the output stream and flush the internal headers buffer.</source>
          <target state="translated">마지막으로 헤더를 출력 스트림으로 보내고 내부 헤더 버퍼를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="5340045eb569806018888d3e6ca8151bb31425b6" translate="yes" xml:space="preserve">
          <source>Finally the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; provides the following methods and attributes:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 메소드와 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ac7a70a71bee49fd5902a24b61b093fc56eeefe4" translate="yes" xml:space="preserve">
          <source>Finally, developers of interactive shells that run user code in a namespace other than &lt;code&gt;__main__&lt;/code&gt; are advised to ensure that &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt; messages are made visible by default, using code like the following (where &lt;code&gt;user_ns&lt;/code&gt; is the module used to execute code entered interactively):</source>
          <target state="translated">마지막으로 &lt;code&gt;__main__&lt;/code&gt; 이외의 네임 스페이스에서 사용자 코드를 실행하는 대화식 쉘 개발자는 다음과 같은 코드를 사용하여 &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; &lt;/a&gt; 메시지가 기본적으로 표시 되도록하는 것이 좋습니다 (여기서 &lt;code&gt;user_ns&lt;/code&gt; 는 대화식으로 입력 된 코드를 실행하는 데 사용되는 모듈입니다).</target>
        </trans-unit>
        <trans-unit id="54483631603508ccb6eef71317df3b382f7a7d0f" translate="yes" xml:space="preserve">
          <source>Finally, it provides some additional type-related utility classes and functions that are not fundamental enough to be builtins.</source>
          <target state="translated">마지막으로, 내장에 충분하지 않은 몇 가지 추가 유형 관련 유틸리티 클래스 및 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4cc1441649b921d6fdae0ab41c8bf613ba751dc2" translate="yes" xml:space="preserve">
          <source>Finally, split each entry into a list with first name, last name, telephone number, and address. We use the &lt;code&gt;maxsplit&lt;/code&gt; parameter of &lt;a href=&quot;#re.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; because the address has spaces, our splitting pattern, in it:</source>
          <target state="translated">마지막으로 각 항목을 이름, 성, 전화 번호 및 주소가있는 목록으로 분할하십시오. 우리 는 &lt;a href=&quot;#re.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;maxsplit&lt;/code&gt; 매개 변수를 사용합니다 . 주소에는 분리 패턴 인 공백이 있기 때문입니다 :</target>
        </trans-unit>
        <trans-unit id="ca29ccfc698632fd34f8bef6c54a4c7594301bca" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;em&gt;type&lt;/em&gt; determines how the data should be presented.</source>
          <target state="translated">마지막으로 &lt;em&gt;유형에&lt;/em&gt; 따라 데이터 표시 방법이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6e412b4e5a4b243814ad83cb939463fbbfcd9073" translate="yes" xml:space="preserve">
          <source>Finally, the last line makes &lt;code&gt;Foo&lt;/code&gt; a virtual subclass of &lt;code&gt;MyIterable&lt;/code&gt;, even though it does not define an &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt; method (it uses the old-style iterable protocol, defined in terms of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt;&lt;code&gt;__len__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;). Note that this will not make &lt;code&gt;get_iterator&lt;/code&gt; available as a method of &lt;code&gt;Foo&lt;/code&gt;, so it is provided separately.</source>
          <target state="translated">마지막으로, &lt;code&gt;Foo&lt;/code&gt; 는 &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 메소드를 정의하지 않더라도 Foo 를 &lt;code&gt;MyIterable&lt;/code&gt; 의 가상 서브 클래스로 만듭니다 ( &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt; &lt;code&gt;__len__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 관점에서 정의 된 구식 반복 가능 프로토콜 사용 ). 이렇게하면 &lt;code&gt;get_iterator&lt;/code&gt; 를 &lt;code&gt;Foo&lt;/code&gt; 의 메소드로 사용할 수 없으므로 별도로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="90e60f8d4aa2795892376f060e02bfac6967dbef" translate="yes" xml:space="preserve">
          <source>Finally, the module defines the following functions:</source>
          <target state="translated">마지막으로 모듈은 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4802b5d7cd86363b824fd0ca9a616c0d0c5ad299" translate="yes" xml:space="preserve">
          <source>Finally, we compare the two:</source>
          <target state="translated">마지막으로 두 가지를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="df251b06eefdaa932e97b54fbe9a74d3e606fa61" translate="yes" xml:space="preserve">
          <source>Find</source>
          <target state="translated">Find</target>
        </trans-unit>
        <trans-unit id="e22d01c9a1cff7d8d85bf94c081d389c7cb45c44" translate="yes" xml:space="preserve">
          <source>Find Again</source>
          <target state="translated">다시 찾기</target>
        </trans-unit>
        <trans-unit id="fee9d437c96f424d55cbaea346f0b4c8fcac6cb5" translate="yes" xml:space="preserve">
          <source>Find Selection</source>
          <target state="translated">선택 찾기</target>
        </trans-unit>
        <trans-unit id="ef1f9108191ec94e03062bd8ad91db6782be5303" translate="yes" xml:space="preserve">
          <source>Find all the test modules by recursing into subdirectories from the specified start directory, and return a TestSuite object containing them. Only test files that match &lt;em&gt;pattern&lt;/em&gt; will be loaded. (Using shell style pattern matching.) Only module names that are importable (i.e. are valid Python identifiers) will be loaded.</source>
          <target state="translated">지정된 시작 디렉토리에서 서브 디렉토리로 반복하여 모든 테스트 모듈을 찾아서이를 포함하는 TestSuite 오브젝트를 리턴하십시오. &lt;em&gt;패턴&lt;/em&gt; 과 일치하는 테스트 파일 만 로드됩니다. (쉘 스타일 패턴 일치 사용) 가져올 수있는 (즉, 유효한 Python 식별자) 모듈 이름 만로드됩니다.</target>
        </trans-unit>
        <trans-unit id="5c62bc8f6363fb9566dfbefc3e5e304573710820" translate="yes" xml:space="preserve">
          <source>Find in Files&amp;hellip;</source>
          <target state="translated">파일에서 찾기&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="e1a3407ce9c645e9293a18e98df208634d5b0fd6" translate="yes" xml:space="preserve">
          <source>Find longest matching block in &lt;code&gt;a[alo:ahi]&lt;/code&gt; and &lt;code&gt;b[blo:bhi]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a[alo:ahi]&lt;/code&gt; 및 &lt;code&gt;b[blo:bhi]&lt;/code&gt; 에서 가장 긴 일치 블록을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="88973852d34b548cba7442351fe7931983f58261" translate="yes" xml:space="preserve">
          <source>Find the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;spec&lt;/a&gt; for a module, optionally relative to the specified &lt;strong&gt;package&lt;/strong&gt; name. If the module is in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;sys.modules[name].__spec__&lt;/code&gt; is returned (unless the spec would be &lt;code&gt;None&lt;/code&gt; or is not set, in which case &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised). Otherwise a search using &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt; is done. &lt;code&gt;None&lt;/code&gt; is returned if no spec is found.</source>
          <target state="translated">선택적으로 지정된 &lt;strong&gt;패키지&lt;/strong&gt; 이름을 기준으로 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;스펙&lt;/a&gt; 을 찾으십시오 . 모듈 인 경우 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 다음 &lt;code&gt;sys.modules[name].__spec__&lt;/code&gt; (사양이 없을 것이다 않는 리턴 &lt;code&gt;None&lt;/code&gt; 하거나하는 경우, 설정되지 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를가&lt;/a&gt; 상승한다). 그렇지 않으면 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; 를&lt;/a&gt; 사용한 검색 이 수행됩니다. &lt;code&gt;None&lt;/code&gt; 어떤 스펙이 발견되지 않으면 반환되지 않습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb323e03785be602bcba83db798ce16c9bf59cc4" translate="yes" xml:space="preserve">
          <source>Find the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quartile&quot;&gt;quartiles&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Decile&quot;&gt;deciles&lt;/a&gt; for the SAT scores:</source>
          <target state="translated">SAT 점수에 대한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Quartile&quot;&gt;사 분위수&lt;/a&gt; 와 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decile&quot;&gt;십 &lt;/a&gt;분위수를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="54727e2ae4fbfa9a1379603de62399cc1ea08e5c" translate="yes" xml:space="preserve">
          <source>Find the loader for a module, optionally within the specified &lt;em&gt;path&lt;/em&gt;. If the module is in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;sys.modules[name].__loader__&lt;/code&gt; is returned (unless the loader would be &lt;code&gt;None&lt;/code&gt; or is not set, in which case &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised). Otherwise a search using &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt; is done. &lt;code&gt;None&lt;/code&gt; is returned if no loader is found.</source>
          <target state="translated">선택적으로 지정된 &lt;em&gt;경로&lt;/em&gt; 내에서 모듈의 로더를 찾으십시오 . 모듈 인 경우 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 다음 &lt;code&gt;sys.modules[name].__loader__&lt;/code&gt; (로더는 없을 것이다 않는 리턴 &lt;code&gt;None&lt;/code&gt; 하거나하는 경우, 설정되지 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를가&lt;/a&gt; 상승한다). 그렇지 않으면 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; 를&lt;/a&gt; 사용한 검색 이 수행됩니다. &lt;code&gt;None&lt;/code&gt; 어떤 로더가 발견되지 않으면 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="466bd9c283ada3a2104411c5b7cd20bcb47f3b3e" translate="yes" xml:space="preserve">
          <source>Find&amp;hellip;</source>
          <target state="translated">Find&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="cf4be453d54751062a87b79b8d32be07d8baa9ca" translate="yes" xml:space="preserve">
          <source>Finding all Adverbs</source>
          <target state="translated">모든 부사 찾기</target>
        </trans-unit>
        <trans-unit id="b721c6da8e2db8fb2ef1a1be90eac8dd41d6f9e7" translate="yes" xml:space="preserve">
          <source>Finding all Adverbs and their Positions</source>
          <target state="translated">모든 부사와 그 위치 찾기</target>
        </trans-unit>
        <trans-unit id="0a2099ef6eb29e011a3b48632c5a2afdec3ee58e" translate="yes" xml:space="preserve">
          <source>Finding interesting elements</source>
          <target state="translated">흥미로운 요소 찾기</target>
        </trans-unit>
        <trans-unit id="f7bb5e00680fccf4dcccd7c41b77a19932915851" translate="yes" xml:space="preserve">
          <source>Finding shared libraries</source>
          <target state="translated">공유 라이브러리 찾기</target>
        </trans-unit>
        <trans-unit id="8e54a9c2cec2bb117d48536f67fc88db48ee2cec" translate="yes" xml:space="preserve">
          <source>Finds all matching subelements, by tag name or &lt;a href=&quot;#elementtree-xpath&quot;&gt;path&lt;/a&gt;. Returns a list containing all matching elements in document order. &lt;em&gt;namespaces&lt;/em&gt; is an optional mapping from namespace prefix to full name. Pass &lt;code&gt;''&lt;/code&gt; as prefix to move all unprefixed tag names in the expression into the given namespace.</source>
          <target state="translated">태그 이름 또는 &lt;a href=&quot;#elementtree-xpath&quot;&gt;경로&lt;/a&gt; 별로 일치하는 모든 하위 요소를 찾습니다 . 일치하는 모든 요소가 포함 된 목록을 문서 순서로 반환합니다. &lt;em&gt;네임 스페이스&lt;/em&gt; 는 네임 스페이스 접두사에서 전체 이름으로의 선택적 매핑입니다. 패스 &lt;code&gt;''&lt;/code&gt; 주어진 공간에 표현의 모든 접두어가 태그 이름을 이동하는 접두사로.</target>
        </trans-unit>
        <trans-unit id="d859b654af5ed61880223a7226d7e7e1d3483231" translate="yes" xml:space="preserve">
          <source>Finds all matching subelements, by tag name or &lt;a href=&quot;#elementtree-xpath&quot;&gt;path&lt;/a&gt;. Returns an iterable yielding all matching elements in document order. &lt;em&gt;namespaces&lt;/em&gt; is an optional mapping from namespace prefix to full name.</source>
          <target state="translated">태그 이름 또는 &lt;a href=&quot;#elementtree-xpath&quot;&gt;경로&lt;/a&gt; 별로 일치하는 모든 하위 요소를 찾습니다 . 일치하는 모든 요소를 ​​문서 순서로 반환하는 반복 가능을 리턴합니다. &lt;em&gt;네임 스페이스&lt;/em&gt; 는 네임 스페이스 접두사에서 전체 이름으로의 선택적 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="5b27a1b5e4d00faec99659152610aca79a1d8fdf" translate="yes" xml:space="preserve">
          <source>Finds and returns the closest &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;self&lt;/code&gt; that has denominator at most max_denominator. This method is useful for finding rational approximations to a given floating-point number:</source>
          <target state="translated">분모가 최대 max_denominator 인 &lt;code&gt;self&lt;/code&gt; 가장 가까운 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 를 찾아 반환합니다 . 이 방법은 주어진 부동 소수점 수에 대한 합리적인 근사치를 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d10a60a0eaf8db436783842ebe25ff70039b0d06" translate="yes" xml:space="preserve">
          <source>Finds text for the first subelement matching &lt;em&gt;match&lt;/em&gt;. &lt;em&gt;match&lt;/em&gt; may be a tag name or a &lt;a href=&quot;#elementtree-xpath&quot;&gt;path&lt;/a&gt;. Returns the text content of the first matching element, or &lt;em&gt;default&lt;/em&gt; if no element was found. Note that if the matching element has no text content an empty string is returned. &lt;em&gt;namespaces&lt;/em&gt; is an optional mapping from namespace prefix to full name. Pass &lt;code&gt;''&lt;/code&gt; as prefix to move all unprefixed tag names in the expression into the given namespace.</source>
          <target state="translated">첫 번째 하위 요소에 일치하는 텍스트를 찾습니다 &lt;em&gt;일치&lt;/em&gt; . &lt;em&gt;match&lt;/em&gt; 는 태그 이름 또는 &lt;a href=&quot;#elementtree-xpath&quot;&gt;경로&lt;/a&gt; 일 수 있습니다 . 일치하는 첫 번째 요소의 텍스트 컨텐츠를 리턴하거나 요소가없는 경우 &lt;em&gt;기본값을&lt;/em&gt; 리턴합니다 . 일치하는 요소에 텍스트 내용이 없으면 빈 문자열이 반환됩니다. &lt;em&gt;네임 스페이스&lt;/em&gt; 는 네임 스페이스 접두사에서 전체 이름으로의 선택적 매핑입니다. 패스 &lt;code&gt;''&lt;/code&gt; 주어진 공간에 표현의 모든 접두어가 태그 이름을 이동하는 접두사로.</target>
        </trans-unit>
        <trans-unit id="da452c485a924a8c6950daa3d141c59442b42e7b" translate="yes" xml:space="preserve">
          <source>Finds the caller&amp;rsquo;s source filename and line number. Returns the filename, line number, function name and stack information as a 4-element tuple. The stack information is returned as &lt;code&gt;None&lt;/code&gt; unless &lt;em&gt;stack_info&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">발신자의 소스 파일 이름과 줄 번호를 찾습니다. 파일 이름, 줄 번호, 함수 이름 및 스택 정보를 4 요소 튜플로 반환합니다. &lt;em&gt;stack_info&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 가 아니면 스택 정보는 &lt;code&gt;None&lt;/code&gt; 으로 반환됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef05bb45a66bea7421c281f5a43ff7fb8a6ea316" translate="yes" xml:space="preserve">
          <source>Finds the first subelement matching &lt;em&gt;match&lt;/em&gt;. &lt;em&gt;match&lt;/em&gt; may be a tag name or a &lt;a href=&quot;#elementtree-xpath&quot;&gt;path&lt;/a&gt;. Returns an element instance or &lt;code&gt;None&lt;/code&gt;. &lt;em&gt;namespaces&lt;/em&gt; is an optional mapping from namespace prefix to full name. Pass &lt;code&gt;''&lt;/code&gt; as prefix to move all unprefixed tag names in the expression into the given namespace.</source>
          <target state="translated">첫 번째 하위 요소 일치 찾습니다 &lt;em&gt;일치&lt;/em&gt; . &lt;em&gt;match&lt;/em&gt; 는 태그 이름 또는 &lt;a href=&quot;#elementtree-xpath&quot;&gt;경로&lt;/a&gt; 일 수 있습니다 . 요소 인스턴스 또는 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 . &lt;em&gt;네임 스페이스&lt;/em&gt; 는 네임 스페이스 접두사에서 전체 이름으로의 선택적 매핑입니다. 패스 &lt;code&gt;''&lt;/code&gt; 주어진 공간에 표현의 모든 접두어가 태그 이름을 이동하는 접두사로.</target>
        </trans-unit>
        <trans-unit id="383b6f69481b14ce56e9a9c5c3e3db37deae4310" translate="yes" xml:space="preserve">
          <source>Finds the value &lt;em&gt;x&lt;/em&gt; of the random variable &lt;em&gt;X&lt;/em&gt; such that the probability of the variable being less than or equal to that value equals the given probability &lt;em&gt;p&lt;/em&gt;.</source>
          <target state="translated">변수가 해당 값보다 작거나 같은 확률이 주어진 확률 &lt;em&gt;p&lt;/em&gt; 와 같도록 랜덤 변수 &lt;em&gt;X&lt;/em&gt; 의 값 &lt;em&gt;x&lt;/em&gt; 를 찾습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04d5bbaf630e544c5dc9e758ee6e372783543ff0" translate="yes" xml:space="preserve">
          <source>Finer Points</source>
          <target state="translated">더 좋은 포인트</target>
        </trans-unit>
        <trans-unit id="432bdfa8572e3f54d5ae893d2654804bc7796b03" translate="yes" xml:space="preserve">
          <source>Finish the compression process, returning a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object containing any data stored in the compressor&amp;rsquo;s internal buffers.</source>
          <target state="translated">압축 과정을 마치고 컴프레서의 내부 버퍼에 저장된 데이터를 포함 하는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="baed4062148e238b2036d98ee1192d5e5bac6f1c" translate="yes" xml:space="preserve">
          <source>Finish the compression process. Returns the compressed data left in internal buffers.</source>
          <target state="translated">압축 프로세스를 완료하십시오. 내부 버퍼에 남아있는 압축 된 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6b9354378ed8f6903d12116f4cc1f005f0095a5" translate="yes" xml:space="preserve">
          <source>Finishes cleaning up the stack when a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement block exits.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 블록이 종료 되면 스택 정리를 완료 합니다.</target>
        </trans-unit>
        <trans-unit id="321b3d472ac84279a6e6dbb1bf70264bbbfa42e3" translate="yes" xml:space="preserve">
          <source>Finishes feeding data to the parser. Returns the result of calling the &lt;code&gt;close()&lt;/code&gt; method of the &lt;em&gt;target&lt;/em&gt; passed during construction; by default, this is the toplevel document element.</source>
          <target state="translated">파서에 데이터 공급을 완료합니다. 생성하는 동안 전달 된 &lt;em&gt;대상&lt;/em&gt; 의 &lt;code&gt;close()&lt;/code&gt; 메서드 를 호출 한 결과를 반환합니다 . 기본적으로 이것이 최상위 문서 요소입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41b7c3042f5a197e5d2450646a9d85e745f8b93c" translate="yes" xml:space="preserve">
          <source>First of all, check for trivial installation errors &amp;mdash; reading the section above on installing your CGI script carefully can save you a lot of time. If you wonder whether you have understood the installation procedure correctly, try installing a copy of this module file (&lt;code&gt;cgi.py&lt;/code&gt;) as a CGI script. When invoked as a script, the file will dump its environment and the contents of the form in HTML form. Give it the right mode etc, and send it a request. If it&amp;rsquo;s installed in the standard &lt;code&gt;cgi-bin&lt;/code&gt; directory, it should be possible to send it a request by entering a URL into your browser of the form:</source>
          <target state="translated">우선, 사소한 설치 오류를 확인하십시오. CGI 스크립트 설치에 관한 위의 섹션을주의 깊게 읽으면 많은 시간을 절약 할 수 있습니다. 설치 절차를 올바르게 이해했는지 궁금하다면이 모듈 파일 ( &lt;code&gt;cgi.py&lt;/code&gt; ) 사본을 CGI 스크립트로 설치하십시오. 스크립트로 호출되면 파일은 해당 환경과 양식의 내용을 HTML 양식으로 덤프합니다. 올바른 모드 등을 제공하고 요청을 보내십시오. 표준 &lt;code&gt;cgi-bin&lt;/code&gt; 디렉토리에 설치 되어 있으면 브라우저에 다음 형식의 URL을 입력하여 요청을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebb675d8053ea8a8ebe83ac6094160e6e0071a71" translate="yes" xml:space="preserve">
          <source>First the problem specific to &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt; has two assert methods that are extremely handy: &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt;&lt;code&gt;assert_called_with()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; 과&lt;/a&gt; 관련된 문제 입니다. &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt; &lt;code&gt;assert_called_with()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt;라는 매우 편리한 두 가지 assert 메소드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98a58557fac74f7c207b0b17436f5fa6565e938f" translate="yes" xml:space="preserve">
          <source>First the whitespace in &lt;em&gt;text&lt;/em&gt; is collapsed (all whitespace is replaced by single spaces). If the result fits in the &lt;em&gt;width&lt;/em&gt;, it is returned. Otherwise, enough words are dropped from the end so that the remaining words plus the &lt;code&gt;placeholder&lt;/code&gt; fit within &lt;code&gt;width&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;em&gt;텍스트&lt;/em&gt; 의 공백 이 축소됩니다 (모든 공백이 단일 공백으로 바)). 결과가 &lt;em&gt;width에&lt;/em&gt; 맞으면 반환됩니다. 그렇지 않으면 나머지 단어와 &lt;code&gt;placeholder&lt;/code&gt; &lt;code&gt;width&lt;/code&gt; 맞도록 충분한 단어가 끝에서 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="60176e770782809052d5a4eae68bdf54ef2f18da" translate="yes" xml:space="preserve">
          <source>First, here is the input. Normally it may come from a file, here we are using triple-quoted string syntax</source>
          <target state="translated">먼저 여기에 입력이 있습니다. 일반적으로 파일에서 올 수 있습니다. 여기에서 삼중 인용 문자열 구문을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac8683471df447adf6eda69155e038372dd0b95" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s see how to create and send a simple text message (both the text content and the addresses may contain unicode characters):</source>
          <target state="translated">먼저 간단한 문자 메시지를 작성하고 보내는 방법을 살펴 보겠습니다 (문자 내용과 주소에 유니 코드 문자가 포함될 수 있음).</target>
        </trans-unit>
        <trans-unit id="4920efe102a0e3e17da7a48214b1bdd90e8c1783" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll define a converter function that accepts the string as a parameter and constructs a &lt;code&gt;Point&lt;/code&gt; object from it.</source>
          <target state="translated">먼저 문자열을 매개 변수로 받아들이고 그로부터 &lt;code&gt;Point&lt;/code&gt; 객체를 생성하는 변환기 함수를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="93012090d3ab01bc45208ed0ff57920fc70eb692" translate="yes" xml:space="preserve">
          <source>First, you must create a class for the callback function. The class knows the calling convention, the return type, and the number and types of arguments this function will receive.</source>
          <target state="translated">먼저 콜백 함수를위한 클래스를 만들어야합니다. 클래스는 호출 규칙, 반환 유형 및이 함수가받을 인수의 수와 유형을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d07384c1c8d9575109c37bcf20f13d8dfa38fc1" translate="yes" xml:space="preserve">
          <source>Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a &lt;code&gt;b&lt;/code&gt; prefix is added:</source>
          <target state="translated">첫째, 바이트 리터럴 구문은 &lt;code&gt;b&lt;/code&gt; 접두사가 추가 된 것을 제외하고는 문자열 리터럴 구문과 거의 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="cae6d93dfa09be89bb26051b385df24aec65afc3" translate="yes" xml:space="preserve">
          <source>Fixed-point notation. Displays the number as a fixed-point number. The default precision is &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">고정 소수점 표기법. 숫자를 고정 소수점 숫자로 표시합니다. 기본 정밀도는 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33dac53d2b4a4305f7f3bd7b3790965764d3b777" translate="yes" xml:space="preserve">
          <source>Fixed-point notation. Same as &lt;code&gt;'f'&lt;/code&gt;, but converts &lt;code&gt;nan&lt;/code&gt; to &lt;code&gt;NAN&lt;/code&gt; and &lt;code&gt;inf&lt;/code&gt; to &lt;code&gt;INF&lt;/code&gt;.</source>
          <target state="translated">고정 소수점 표기법. &lt;code&gt;'f'&lt;/code&gt; 와 동일 하지만 &lt;code&gt;nan&lt;/code&gt; 을 &lt;code&gt;NAN&lt;/code&gt; 으로 , &lt;code&gt;inf&lt;/code&gt; 를 &lt;code&gt;INF&lt;/code&gt; 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="53c31b9a84b3e76a8d130dc88d836771394313f6" translate="yes" xml:space="preserve">
          <source>Fixers</source>
          <target state="translated">Fixers</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="7c9da9ff0cbbea2040b17e92a80753515d34a4d1" translate="yes" xml:space="preserve">
          <source>Flag indicating whether or not the global data structures have been initialized. This is set to &lt;code&gt;True&lt;/code&gt; by &lt;a href=&quot;#mimetypes.init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">글로벌 데이터 구조가 초기화되었는지 여부를 나타내는 플래그. &lt;a href=&quot;#mimetypes.init&quot;&gt; &lt;code&gt;init()&lt;/code&gt; &lt;/a&gt; 의해 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c927012d2c39be22f56b1f50daa3abb8534258b8" translate="yes" xml:space="preserve">
          <source>Flag indicating whether to print only the filenames of files containing whitespace related problems. This is set to true by the &lt;code&gt;-q&lt;/code&gt; option if called as a script.</source>
          <target state="translated">공백 관련 문제가 포함 된 파일의 파일 이름 만 인쇄할지 여부를 나타내는 플래그입니다. 스크립트로 호출되면 &lt;code&gt;-q&lt;/code&gt; 옵션에 의해 true로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="040ef0b73190ae184815b93c35518c7d638c9bfa" translate="yes" xml:space="preserve">
          <source>Flag indicating whether to print verbose messages. This is incremented by the &lt;code&gt;-v&lt;/code&gt; option if called as a script.</source>
          <target state="translated">자세한 메시지를 인쇄할지 여부를 나타내는 플래그입니다. 스크립트로 호출 된 경우 &lt;code&gt;-v&lt;/code&gt; 옵션으로 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="b827eb1ab4608b80fa780507f686619a8640bde9" translate="yes" xml:space="preserve">
          <source>Flag message number &lt;em&gt;which&lt;/em&gt; for deletion. On most servers deletions are not actually performed until QUIT (the major exception is Eudora QPOP, which deliberately violates the RFCs by doing pending deletes on any disconnect).</source>
          <target state="translated">신고 메시지 수 &lt;em&gt;있는&lt;/em&gt; 삭제. 대부분의 서버에서 삭제는 실제로 QUIT가 될 때까지 실제로 수행되지 않습니다 (주요 예외는 Eudora QPOP이며, 연결이 끊어 질 때 보류중인 삭제를 수행하여 의도적으로 RFC를 위반 함).</target>
        </trans-unit>
        <trans-unit id="b2c7e2cd1de9bde763ad0040d719d08ce2bcd792" translate="yes" xml:space="preserve">
          <source>Flag showing the status of the user site-packages directory. &lt;code&gt;True&lt;/code&gt; means that it is enabled and was added to &lt;code&gt;sys.path&lt;/code&gt;. &lt;code&gt;False&lt;/code&gt; means that it was disabled by user request (with &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-s&quot;&gt;&lt;code&gt;-s&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONNOUSERSITE&quot; id=&quot;index-8&quot;&gt;&lt;code&gt;PYTHONNOUSERSITE&lt;/code&gt;&lt;/a&gt;). &lt;code&gt;None&lt;/code&gt; means it was disabled for security reasons (mismatch between user or group id and effective id) or by an administrator.</source>
          <target state="translated">사용자 사이트 패키지 디렉토리의 상태를 나타내는 플래그. &lt;code&gt;True&lt;/code&gt; 는 활성화되어 &lt;code&gt;sys.path&lt;/code&gt; 에 추가되었음을 의미합니다 . &lt;code&gt;False&lt;/code&gt; 는 사용자 요청 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-s&quot;&gt; &lt;code&gt;-s&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONNOUSERSITE&quot; id=&quot;index-8&quot;&gt; &lt;code&gt;PYTHONNOUSERSITE&lt;/code&gt; 사용&lt;/a&gt; )에 의해 비활성화되었음을 의미합니다 . &lt;code&gt;None&lt;/code&gt; 은 보안상의 이유로 (사용자 또는 그룹 ID와 유효 ID가 일치하지 않음) 또는 관리자가 비활성화 했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="250420fa54c4474c1a02e4a0675c7b67e4859b14" translate="yes" xml:space="preserve">
          <source>Flag to use as &lt;em&gt;mode&lt;/em&gt; parameter. On platforms where this flag is not available, it is defined as the integer zero.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수 로 사용할 플래그 입니다. 이 플래그를 사용할 수없는 플랫폼에서는 정수 0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="27da8f9d92b7abf1907ea7a26ca4441a58763537" translate="yes" xml:space="preserve">
          <source>Flag to use as &lt;em&gt;mode&lt;/em&gt; parameter. On platforms where this is not available, it is the same as &lt;em&gt;RTLD_GLOBAL&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수 로 사용할 플래그 입니다. 이를 사용할 수없는 플랫폼에서는 &lt;em&gt;RTLD_GLOBAL&lt;/em&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f8db8a172be6fab179a39aa7dee85e1f7afcbd56" translate="yes" xml:space="preserve">
          <source>Flagged</source>
          <target state="translated">Flagged</target>
        </trans-unit>
        <trans-unit id="1f07acd047ff4da9984807d5f9663de56e86b6b0" translate="yes" xml:space="preserve">
          <source>Flags for use with the &lt;a href=&quot;sys#sys.setdlopenflags&quot;&gt;&lt;code&gt;setdlopenflags()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.getdlopenflags&quot;&gt;&lt;code&gt;getdlopenflags()&lt;/code&gt;&lt;/a&gt; functions. See the Unix manual page &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/dlopen(3)&quot;&gt;dlopen(3)&lt;/a&gt;&lt;/em&gt; for what the different flags mean.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.setdlopenflags&quot;&gt; &lt;code&gt;setdlopenflags()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.getdlopenflags&quot;&gt; &lt;code&gt;getdlopenflags()&lt;/code&gt; &lt;/a&gt; 함수 와 함께 사용할 플래그입니다 . 다른 플래그의 의미 는 Unix 매뉴얼 페이지 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/dlopen(3)&quot;&gt;dlopen (3)&lt;/a&gt;&lt;/em&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd24040b0de304246d5aae1e83cfc89a9def0cfd" translate="yes" xml:space="preserve">
          <source>Flags indicating how strict to be with domain-matching rules for Netscape cookies. See below for acceptable values.</source>
          <target state="translated">Netscape 쿠키에 대한 도메인 일치 규칙이 얼마나 엄격한지를 나타내는 플래그입니다. 허용 가능한 값은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c56c51fdb9503b6e8d9353fdc1a8910b2b26f96b" translate="yes" xml:space="preserve">
          <source>Flags that can be used in &lt;em&gt;advice&lt;/em&gt; in &lt;a href=&quot;#os.posix_fadvise&quot;&gt;&lt;code&gt;posix_fadvise()&lt;/code&gt;&lt;/a&gt; that specify the access pattern that is likely to be used.</source>
          <target state="translated">&lt;a href=&quot;#os.posix_fadvise&quot;&gt; &lt;code&gt;posix_fadvise()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 조언&lt;/em&gt; 에 사용될 수있는 액세스 패턴을 지정하는 플래그 .</target>
        </trans-unit>
        <trans-unit id="4b29537980e35e6955e907c0423783c7fd5421c9" translate="yes" xml:space="preserve">
          <source>Flags that can be used in &lt;em&gt;options&lt;/em&gt; in &lt;a href=&quot;#os.waitid&quot;&gt;&lt;code&gt;waitid()&lt;/code&gt;&lt;/a&gt; that specify what child signal to wait for.</source>
          <target state="translated">대기 할 자식 신호를 지정하는 &lt;a href=&quot;#os.waitid&quot;&gt; &lt;code&gt;waitid()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 옵션&lt;/em&gt; 에서 사용할 수있는 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="be03f41ac820d005e351ffd4e5eca83d99f28dd1" translate="yes" xml:space="preserve">
          <source>Flags that specify what action &lt;a href=&quot;#os.lockf&quot;&gt;&lt;code&gt;lockf()&lt;/code&gt;&lt;/a&gt; will take.</source>
          <target state="translated">&lt;a href=&quot;#os.lockf&quot;&gt; &lt;code&gt;lockf()&lt;/code&gt; &lt;/a&gt; 수행 할 조치를 지정하는 플래그 .</target>
        </trans-unit>
        <trans-unit id="6b378e0209f751bf8ed04ced4462379afd4e9bee" translate="yes" xml:space="preserve">
          <source>Flash the screen. That is, change it to reverse-video and then change it back in a short interval. Some people prefer such as &amp;lsquo;visible bell&amp;rsquo; to the audible attention signal produced by &lt;a href=&quot;#curses.beep&quot;&gt;&lt;code&gt;beep()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">화면을 깜박입니다. 즉, 반전 비디오로 변경 한 다음 짧은 간격으로 다시 변경하십시오. 어떤 사람들은 &lt;a href=&quot;#curses.beep&quot;&gt; &lt;code&gt;beep()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 가청주의 신호보다 '보이는 벨'과 같은 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="0ef0237069aeed94495fee21d06b8dfebec5e725" translate="yes" xml:space="preserve">
          <source>Flattening the message may trigger changes to the &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; if defaults need to be filled in to complete the transformation to a string (for example, MIME boundaries may be generated or modified).</source>
          <target state="translated">문자열로 변환을 완료하기 위해 기본값을 채워야하는 경우 메시지를 병합하면 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 에 대한 변경이 트리거 될 수 있습니다 (예 : MIME 경계가 생성 또는 수정 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="6338fe9d3c497dd27f17da5bf52b9bad1bcb9779" translate="yes" xml:space="preserve">
          <source>Flattening the message may trigger changes to the &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; if defaults need to be filled in to complete the transformation to a string (for example, MIME boundaries may be generated or modified).</source>
          <target state="translated">메시지를 평탄화하는 것은 변경 트리거 할 &lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 기본값 문자열로 변환을 수행하여 충전 될 필요가 있다면 (예를 들어, MIME 경계가 생성되거나 수정 될 수있다).</target>
        </trans-unit>
        <trans-unit id="683dbea5f7e1b5080e1ef7590ab4063b4f6510c0" translate="yes" xml:space="preserve">
          <source>Float value. If set, this is the maximum value to which the increment button will increment.</source>
          <target state="translated">부동 값. 설정된 경우 이것은 증가 버튼이 증가 할 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="7afaf725c9b3acf299192e4694d4dfeb71640eb3" translate="yes" xml:space="preserve">
          <source>Float value. If set, this is the minimum value to which the decrement button will decrement. Must be spelled as &lt;code&gt;from_&lt;/code&gt; when used as an argument, since &lt;code&gt;from&lt;/code&gt; is a Python keyword.</source>
          <target state="translated">부동 값. 설정하면 감소 버튼이 감소하는 최소값입니다. &lt;code&gt;from&lt;/code&gt; 은 Python 키워드 이므로 인수로 사용될 때는 &lt;code&gt;from_&lt;/code&gt; 로 철자를 입력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="33b570f9eefd74d9957d763fc0f22770675a13a7" translate="yes" xml:space="preserve">
          <source>Float value. Specifies the amount which the increment/decrement buttons change the value. Defaults to 1.0.</source>
          <target state="translated">부동 값. 증분 / 감소 버튼이 값을 변경하는 양을 지정합니다. 기본값은 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="1e1efdbc9f8f5ce44c24fc5643ba097cac8e6daf" translate="yes" xml:space="preserve">
          <source>Floating Point Notes</source>
          <target state="translated">부동 소수점</target>
        </trans-unit>
        <trans-unit id="73d93d27d9be83ac0e1af6809845bb8b3e09dbf0" translate="yes" xml:space="preserve">
          <source>Floating point decimal format.</source>
          <target state="translated">부동 소수점 10 진수 형식.</target>
        </trans-unit>
        <trans-unit id="2b8008eef2f18bcf702847524bbc3d7f4c157eeb" translate="yes" xml:space="preserve">
          <source>Floating point exponential format (lowercase).</source>
          <target state="translated">부동 소수점 지수 형식 (소문자).</target>
        </trans-unit>
        <trans-unit id="3c529f15e6525e1ea8a92bc5c4f6df6089d52413" translate="yes" xml:space="preserve">
          <source>Floating point exponential format (uppercase).</source>
          <target state="translated">부동 소수점 지수 형식 (대문자).</target>
        </trans-unit>
        <trans-unit id="da386ed9df0e1a298956f76f008527bba636b22b" translate="yes" xml:space="preserve">
          <source>Floating point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise.</source>
          <target state="translated">부동 소수점 형식 지수가 -4보다 작거나 정밀도보다 작 으면 소문자 지수 형식을 사용하고, 그렇지 않으면 10 진수 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ef7899b795de9435e853c0f84ac89f21e7eb5224" translate="yes" xml:space="preserve">
          <source>Floating point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise.</source>
          <target state="translated">부동 소수점 형식 지수가 -4보다 작거나 정밀도보다 작 으면 대문자 지수 형식을 사용하고, 그렇지 않으면 10 진수 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="394f073446cec66b8aa90a4344a4ceaf8429ec3d" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are also subject to small output variations across platforms, because Python defers to the platform C library for float formatting, and C libraries vary widely in quality here.</source>
          <target state="translated">파이썬은 부동 형식화를 위해 플랫폼 C 라이브러리를 연기하고 여기에서 C 라이브러리의 품질이 매우 다양하기 때문에 부동 소수점 숫자는 플랫폼마다 약간의 출력 변형이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f798cc28676aec8b10ead1c825d53504590834d" translate="yes" xml:space="preserve">
          <source>Floating-point positive infinity. Equivalent to &lt;code&gt;float('inf')&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 양의 무한대. &lt;code&gt;float('inf')&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5e9add85e668caad4a6328b8f15ea6541b73c6c7" translate="yes" xml:space="preserve">
          <source>FloatingPointError</source>
          <target state="translated">FloatingPointError</target>
        </trans-unit>
        <trans-unit id="0693c8a5c8ecb50a7a38a20549795a6f793dc1be" translate="yes" xml:space="preserve">
          <source>Flow Control Callbacks</source>
          <target state="translated">흐름 제어 콜백</target>
        </trans-unit>
        <trans-unit id="71ba0aeeee03560a33571599cba3282543b48123" translate="yes" xml:space="preserve">
          <source>Flow control callbacks can be called by transports to pause or resume writing performed by the protocol.</source>
          <target state="translated">흐름 제어 콜백은 전송에 의해 호출되어 프로토콜에 의해 수행 된 쓰기를 일시 중지하거나 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ecb5d4d4053c9b879e8913cfbedf4f7978220bc" translate="yes" xml:space="preserve">
          <source>Flush all input buffers. This throws away any typeahead that has been typed by the user and has not yet been processed by the program.</source>
          <target state="translated">모든 입력 버퍼를 플러시하십시오. 이렇게하면 사용자가 입력했지만 아직 프로그램에서 처리하지 않은 자동 완성 기능이 모두 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="39b8d0deff165745e1650b86238a87db9a3d861a" translate="yes" xml:space="preserve">
          <source>Flush and close this stream. This method has no effect if the file is already closed. Once the file is closed, any operation on the file (e.g. reading or writing) will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스트림을 플러시하고 닫습니다. 파일이 이미 닫힌 경우이 방법은 효과가 없습니다. 파일이 닫히면 파일에 대한 모든 작업 (예 : 읽기 또는 쓰기)은 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f25b943d17f0a4cc96966f6ad97127f3bd8ce97b" translate="yes" xml:space="preserve">
          <source>Flush the mailbox, unlock it if necessary, and close any open files. For some &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; subclasses, this method does nothing.</source>
          <target state="translated">우편함을 비우고 필요한 경우 잠금을 해제 한 다음 열려있는 파일을 모두 닫으십시오. 일부 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 서브 클래스의 경우이 메소드는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0a42975d0bcde8b733a94ac57ae99d81da7fcc2" translate="yes" xml:space="preserve">
          <source>Flush the write buffers of the stream if applicable. This does nothing for read-only and non-blocking streams.</source>
          <target state="translated">해당되는 경우 스트림의 쓰기 버퍼를 비 웁니다. 이것은 읽기 전용 및 비 블로킹 스트림에 대해서는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4039231f6971b19f5762909fe4049214cea03da4" translate="yes" xml:space="preserve">
          <source>Flushes and resets the codec buffers used for keeping state.</source>
          <target state="translated">상태를 유지하는 데 사용되는 코덱 버퍼를 플러시하고 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="78c377fb030c4de02734cba213327ba32b5fd57a" translate="yes" xml:space="preserve">
          <source>Flushes changes made to the in-memory copy of a file back to disk. Without use of this call there is no guarantee that changes are written back before the object is destroyed. If &lt;em&gt;offset&lt;/em&gt; and &lt;em&gt;size&lt;/em&gt; are specified, only changes to the given range of bytes will be flushed to disk; otherwise, the whole extent of the mapping is flushed. &lt;em&gt;offset&lt;/em&gt; must be a multiple of the &lt;code&gt;PAGESIZE&lt;/code&gt; or &lt;code&gt;ALLOCATIONGRANULARITY&lt;/code&gt;.</source>
          <target state="translated">파일의 메모리 내 사본에 대한 변경 사항을 디스크로 플러시합니다. 이 호출을 사용하지 않으면 오브젝트가 소멸되기 전에 변경 사항이 다시 기록된다는 보장이 없습니다. 경우 &lt;em&gt;오프셋&lt;/em&gt; 과 &lt;em&gt;크기가&lt;/em&gt; 지정되어, 전용 디스크로 플러시됩니다 바이트의 주어진 범위에 대한 변경; 그렇지 않으면 매핑의 전체 범위가 플러시됩니다. &lt;em&gt;오프셋&lt;/em&gt; 은 &lt;code&gt;PAGESIZE&lt;/code&gt; 또는 &lt;code&gt;ALLOCATIONGRANULARITY&lt;/code&gt; 의 배수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="41986902b98edde6379cd94cf6c7f023e70d0fe6" translate="yes" xml:space="preserve">
          <source>Flushes the builder buffers, and returns the toplevel document element. Returns an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">빌더 버퍼를 플러시하고 최상위 문서 요소를 리턴합니다. &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="dc210bf30127cac653beb084658fda0da6f45889" translate="yes" xml:space="preserve">
          <source>Flushes the stream by calling its &lt;a href=&quot;#logging.StreamHandler.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; method. Note that the &lt;code&gt;close()&lt;/code&gt; method is inherited from &lt;a href=&quot;logging#logging.Handler&quot;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt; and so does no output, so an explicit &lt;a href=&quot;#logging.StreamHandler.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; call may be needed at times.</source>
          <target state="translated">&lt;a href=&quot;#logging.StreamHandler.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 스트림을 플러시합니다 . 있습니다 &lt;code&gt;close()&lt;/code&gt; 메서드가에서 상속됩니다 &lt;a href=&quot;logging#logging.Handler&quot;&gt; &lt;code&gt;Handler&lt;/code&gt; &lt;/a&gt; 명시 적 그래서 그렇게하고, 어떤 출력을하지 않습니다 &lt;a href=&quot;#logging.StreamHandler.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 호출이 시간에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4020d665d9a15a4d0ab442217ea3d38ffe31911" translate="yes" xml:space="preserve">
          <source>Folders of the style introduced by the Courier mail transfer agent are also supported. Any subdirectory of the main mailbox is considered a folder if &lt;code&gt;'.'&lt;/code&gt; is the first character in its name. Folder names are represented by &lt;a href=&quot;#mailbox.Maildir&quot;&gt;&lt;code&gt;Maildir&lt;/code&gt;&lt;/a&gt; without the leading &lt;code&gt;'.'&lt;/code&gt;. Each folder is itself a Maildir mailbox but should not contain other folders. Instead, a logical nesting is indicated using &lt;code&gt;'.'&lt;/code&gt; to delimit levels, e.g., &amp;ldquo;Archived.2005.07&amp;rdquo;.</source>
          <target state="translated">Courier 메일 전송 에이전트가 도입 한 스타일의 폴더도 지원됩니다. &lt;code&gt;'.'&lt;/code&gt; 인 경우 기본 메일 함의 하위 디렉토리는 폴더로 간주됩니다 . 이름의 첫 번째 문자입니다. 폴더 이름은 &lt;a href=&quot;#mailbox.Maildir&quot;&gt; &lt;code&gt;Maildir&lt;/code&gt; &lt;/a&gt; &lt;code&gt;'.'&lt;/code&gt; 없이 Maildir 로 표시됩니다 . . 각 폴더 자체는 Maildir 사서함이지만 다른 폴더를 포함해서는 안됩니다. 대신 논리 중첩은 &lt;code&gt;'.'&lt;/code&gt; 를 사용하여 표시됩니다 . 예를 들어 &quot;Archived.2005.07&quot;과 같이 레벨을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="e0afbb547de77db1371251680e81a10a8521c254" translate="yes" xml:space="preserve">
          <source>Follow &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-18&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; rules on unverifiable transactions (usually, an unverifiable transaction is one resulting from a redirect or a request for an image hosted on another site). If this is false, cookies are &lt;em&gt;never&lt;/em&gt; blocked on the basis of verifiability</source>
          <target state="translated">확인할 수 없는 트랜잭션에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-18&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 규칙을 따릅니다 (일반적으로 확인할 수없는 트랜잭션은 다른 사이트에서 호스팅되는 이미지에 대한 리디렉션 또는 요청으로 인해 발생합니다). 이것이 거짓이면, 검증 가능성에 근거하여 쿠키가 차단 &lt;em&gt;되지 않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="46a2e0da6005d5c7eddb823accb719141d484e5c" translate="yes" xml:space="preserve">
          <source>Following the syntax specifications in &lt;a href=&quot;https://tools.ietf.org/html/rfc1808.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1808&lt;/strong&gt;&lt;/a&gt;, urlparse recognizes a netloc only if it is properly introduced by &amp;lsquo;//&amp;rsquo;. Otherwise the input is presumed to be a relative URL and thus to start with a path component.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc1808.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1808&lt;/strong&gt;&lt;/a&gt; 의 구문 사양에 따라 urlparse는 '//'에 의해 올바르게 도입 된 경우에만 netloc을 인식합니다. 그렇지 않으면 입력은 상대 URL 인 것으로 간주되므로 경로 구성 요소로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f67ed379569ddcc92ff738fa2c112d30bd25f249" translate="yes" xml:space="preserve">
          <source>Following those is a set of examples of using the fundamental parts of the APIs covered in the preceding sections.</source>
          <target state="translated">다음은 이전 섹션에서 다룬 API의 기본 부분을 사용하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="e52f0c6de209dfb773b81a5673b25d8bbc8e41eb" translate="yes" xml:space="preserve">
          <source>For 200 error codes, the response object is returned immediately.</source>
          <target state="translated">200 오류 코드의 경우 응답 오브젝트가 즉시 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="86ecf6649b6cf50b465714b6d4be9d666f6c9256" translate="yes" xml:space="preserve">
          <source>For 8-bit (bytes) patterns:</source>
          <target state="translated">8 비트 (바이트) 패턴의 경우 :</target>
        </trans-unit>
        <trans-unit id="364fc032d2ac2d86022ecf240a005c499b0e698c" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; objects, the format codes for hours, minutes, seconds, and microseconds should not be used, as &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; objects have no such values. If they&amp;rsquo;re used anyway, &lt;code&gt;0&lt;/code&gt; is substituted for them.</source>
          <target state="translated">들어 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 물체, 시간, 분, 초 및 마이크로에 대한 형식 코드는 사용하지 않아야 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 객체가 그러한 값이 없습니다. 어쨌든 사용되면 &lt;code&gt;0&lt;/code&gt; 이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="21d045e0f9184298bfc8cd53780d2b8799a0cad1" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects, the format codes for year, month, and day should not be used, as &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects have no such values. If they&amp;rsquo;re used anyway, &lt;code&gt;1900&lt;/code&gt; is substituted for the year, and &lt;code&gt;1&lt;/code&gt; for the month and day.</source>
          <target state="translated">들어 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 물체, 년, 월, 일에 대한 형식 코드는 사용하지 않아야 &lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체가 그러한 값이 없습니다. 어쨌든 &lt;code&gt;1900&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 년, 1 은 월과 일로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="7908bd03afc2ba909165e823ebd06ea57784d13a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; operands &lt;em&gt;base&lt;/em&gt; and &lt;em&gt;exp&lt;/em&gt;, if &lt;em&gt;mod&lt;/em&gt; is present, &lt;em&gt;mod&lt;/em&gt; must also be of integer type and &lt;em&gt;mod&lt;/em&gt; must be nonzero. If &lt;em&gt;mod&lt;/em&gt; is present and &lt;em&gt;exp&lt;/em&gt; is negative, &lt;em&gt;base&lt;/em&gt; must be relatively prime to &lt;em&gt;mod&lt;/em&gt;. In that case, &lt;code&gt;pow(inv_base, -exp, mod)&lt;/code&gt; is returned, where &lt;em&gt;inv_base&lt;/em&gt; is an inverse to &lt;em&gt;base&lt;/em&gt; modulo &lt;em&gt;mod&lt;/em&gt;.</source>
          <target state="translated">들면 &lt;a href=&quot;#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 피연산자 &lt;em&gt;베이스&lt;/em&gt; 및 &lt;em&gt;EXP&lt;/em&gt; 경우 &lt;em&gt;개조가&lt;/em&gt; 존재, &lt;em&gt;개조는&lt;/em&gt; 또한 정수 타입이어야하고 &lt;em&gt;개조은&lt;/em&gt; 제로이어야한다. 경우 &lt;em&gt;모드가&lt;/em&gt; 존재하고 &lt;em&gt;경험치가&lt;/em&gt; 부의 경우, &lt;em&gt;기본은&lt;/em&gt; 상대적으로 소수해야합니다 &lt;em&gt;모드&lt;/em&gt; . 이 경우, &lt;code&gt;pow(inv_base, -exp, mod)&lt;/code&gt; 가 리턴됩니다. 여기서 &lt;em&gt;inv_base&lt;/em&gt; 는 &lt;em&gt;기본&lt;/em&gt; 모듈로 &lt;em&gt;mod&lt;/em&gt; 의 역수 입니다.</target>
        </trans-unit>
        <trans-unit id="704b75eae7e4709ca3714d6d7d487a58699927fc" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#os.execle&quot;&gt;&lt;code&gt;execle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execlpe&quot;&gt;&lt;code&gt;execlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execvpe&quot;&gt;&lt;code&gt;execvpe()&lt;/code&gt;&lt;/a&gt; (note that these all end in &amp;ldquo;e&amp;rdquo;), the &lt;em&gt;env&lt;/em&gt; parameter must be a mapping which is used to define the environment variables for the new process (these are used instead of the current process&amp;rsquo; environment); the functions &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;execl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execlp&quot;&gt;&lt;code&gt;execlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execvp&quot;&gt;&lt;code&gt;execvp()&lt;/code&gt;&lt;/a&gt; all cause the new process to inherit the environment of the current process.</source>
          <target state="translated">대한 &lt;a href=&quot;#os.execle&quot;&gt; &lt;code&gt;execle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execlpe&quot;&gt; &lt;code&gt;execlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#os.execvpe&quot;&gt; &lt;code&gt;execvpe()&lt;/code&gt; &lt;/a&gt; 는 ( &quot;E&quot;이러한 모든 끝이 있다는 주) &lt;em&gt;ENV의&lt;/em&gt; 매개 변수는 새로운 프로세스에 대한 환경 변수를 정의하는 데 사용되는 매핑을해야합니다 (이 현재 프로세스 환경 대신 사용됨) &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;execl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execlp&quot;&gt; &lt;code&gt;execlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execv&quot;&gt; &lt;code&gt;execv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execvp&quot;&gt; &lt;code&gt;execvp()&lt;/code&gt; &lt;/a&gt; 함수는 모두 새 프로세스가 현재 프로세스의 환경을 상속하도록합니다.</target>
        </trans-unit>
        <trans-unit id="51157755c0e076cf72d6ba4f3983e0a2ccf80593" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt; on some platforms, &lt;em&gt;path&lt;/em&gt; may also be specified as an open file descriptor. This functionality may not be supported on your platform; you can check whether or not it is available using &lt;a href=&quot;#os.supports_fd&quot;&gt;&lt;code&gt;os.supports_fd&lt;/code&gt;&lt;/a&gt;. If it is unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">들어 &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 일부 플랫폼, &lt;em&gt;경로는&lt;/em&gt; 또한 열려있는 파일 기술자로 지정할 수 있습니다. 이 기능은 플랫폼에서 지원되지 않을 수 있습니다. &lt;a href=&quot;#os.supports_fd&quot;&gt; &lt;code&gt;os.supports_fd&lt;/code&gt; 를&lt;/a&gt; 사용하여 사용 가능한지 여부를 확인할 수 있습니다 . 사용할 수 없으면 사용하면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1d87b8bebbe6ef625c185669fd69bb1d18a46801" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#os.spawnle&quot;&gt;&lt;code&gt;spawnle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnlpe&quot;&gt;&lt;code&gt;spawnlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnve&quot;&gt;&lt;code&gt;spawnve()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt; (note that these all end in &amp;ldquo;e&amp;rdquo;), the &lt;em&gt;env&lt;/em&gt; parameter must be a mapping which is used to define the environment variables for the new process (they are used instead of the current process&amp;rsquo; environment); the functions &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawnl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnv&quot;&gt;&lt;code&gt;spawnv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnvp&quot;&gt;&lt;code&gt;spawnvp()&lt;/code&gt;&lt;/a&gt; all cause the new process to inherit the environment of the current process. Note that keys and values in the &lt;em&gt;env&lt;/em&gt; dictionary must be strings; invalid keys or values will cause the function to fail, with a return value of &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">대한 &lt;a href=&quot;#os.spawnle&quot;&gt; &lt;code&gt;spawnle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnlpe&quot;&gt; &lt;code&gt;spawnlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnve&quot;&gt; &lt;code&gt;spawnve()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#os.spawnvpe&quot;&gt; &lt;code&gt;spawnvpe()&lt;/code&gt; &lt;/a&gt; 는 ( &quot;E&quot;이러한 모든 끝이 있다는 주) &lt;em&gt;ENV의&lt;/em&gt; 매개 변수는 새로운 프로세스에 대한 환경 변수를 정의하는 데 사용되는 매핑을해야한다 (그들은 현재 프로세스 환경 대신 사용됨) 기능 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawnl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnlp&quot;&gt; &lt;code&gt;spawnlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnv&quot;&gt; &lt;code&gt;spawnv()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#os.spawnvp&quot;&gt; &lt;code&gt;spawnvp()&lt;/code&gt; &lt;/a&gt; 모든 원인은 새로운 프로세스는 현재의 프로세스의 환경을 상속합니다. &lt;em&gt;env&lt;/em&gt; 사전 의 키와 값은 문자열이어야합니다. 유효하지 않은 키 또는 값은 &lt;code&gt;127&lt;/code&gt; 의 리턴 값으로 기능에 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="746248eefab63f81cdbec88cd9be8cc5d5b23761" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt; address family, a four-tuple &lt;code&gt;(host, port, flowinfo,
scopeid)&lt;/code&gt; is used, where &lt;em&gt;flowinfo&lt;/em&gt; and &lt;em&gt;scopeid&lt;/em&gt; represent the &lt;code&gt;sin6_flowinfo&lt;/code&gt; and &lt;code&gt;sin6_scope_id&lt;/code&gt; members in &lt;code&gt;struct sockaddr_in6&lt;/code&gt; in C. For &lt;a href=&quot;#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module methods, &lt;em&gt;flowinfo&lt;/em&gt; and &lt;em&gt;scopeid&lt;/em&gt; can be omitted just for backward compatibility. Note, however, omission of &lt;em&gt;scopeid&lt;/em&gt; can cause problems in manipulating scoped IPv6 addresses.</source>
          <target state="translated">들면 &lt;a href=&quot;#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; 의&lt;/a&gt; 어드레스 가족 네 튜플 &lt;code&gt;(host, port, flowinfo, scopeid)&lt;/code&gt; 사용되며, 여기서 &lt;em&gt;flowinfo을&lt;/em&gt; 하고 &lt;em&gt;경우 ScopeId&lt;/em&gt; 나타내는 &lt;code&gt;sin6_flowinfo&lt;/code&gt; 및 &lt;code&gt;sin6_scope_id&lt;/code&gt; 의 부재 &lt;code&gt;struct sockaddr_in6&lt;/code&gt; 들어 C.에서 &lt;a href=&quot;#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈 방법 &lt;em&gt;flowinfo&lt;/em&gt; 및 &lt;em&gt;경우 ScopeId는&lt;/em&gt; 단지 생략 될 수있다 하위 호환성. 그러나 &lt;em&gt;scopeid를&lt;/em&gt; 생략 하면 범위가 지정된 IPv6 주소를 조작 할 때 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9da99637d2b1c64e4ed1882a40516fbe0a31c50" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#sqlite3.Cursor.executemany&quot;&gt;&lt;code&gt;executemany()&lt;/code&gt;&lt;/a&gt; statements, the number of modifications are summed up into &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt;&lt;code&gt;rowcount&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">들면 &lt;a href=&quot;#sqlite3.Cursor.executemany&quot;&gt; &lt;code&gt;executemany()&lt;/code&gt; &lt;/a&gt; 문, 변형의 개수로 표현되는 &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt; &lt;code&gt;rowcount&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="044a69c03975985c860eaab5b4db37d8f0049429" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt;&lt;code&gt;PAX_FORMAT&lt;/code&gt;&lt;/a&gt; archives (the default), &lt;em&gt;encoding&lt;/em&gt; is generally not needed because all the metadata is stored using &lt;em&gt;UTF-8&lt;/em&gt;. &lt;em&gt;encoding&lt;/em&gt; is only used in the rare cases when binary pax headers are decoded or when strings with surrogate characters are stored.</source>
          <target state="translated">들면 &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt; &lt;code&gt;PAX_FORMAT&lt;/code&gt; 의&lt;/a&gt; 아카이브 (기본), &lt;em&gt;인코딩은&lt;/em&gt; 모든 메타 데이터를 이용하여 저장되기 때문에, 일반적으로 필요하지 않다 &lt;em&gt;UTF-8&lt;/em&gt; . &lt;em&gt;인코딩&lt;/em&gt; 은 이진 pax 헤더가 디코딩되거나 서로 게이트 문자가있는 문자열이 저장되는 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c741a7a338bdc3db896807bbb8de8af96ed97b6e" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; instances, this will always be an instance of &lt;a href=&quot;#unittest.TestResult&quot;&gt;&lt;code&gt;TestResult&lt;/code&gt;&lt;/a&gt;; subclasses of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; should override this as necessary.</source>
          <target state="translated">대한 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 경우, 이것은 항상의 인스턴스가 될 것입니다 &lt;a href=&quot;#unittest.TestResult&quot;&gt; &lt;code&gt;TestResult&lt;/code&gt; &lt;/a&gt; ; &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; 의&lt;/a&gt; 서브 클래스는 필요에 따라 이것을 오버라이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="96b39f0e4ba7d9beef69677abc38d33b84b3af65" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt;&lt;code&gt;urldefrag()&lt;/code&gt;&lt;/a&gt; results, only empty fragment identifiers will be removed. For &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt;&lt;code&gt;urlsplit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt; results, all noted changes will be made to the URL returned by this method.</source>
          <target state="translated">들면 &lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt; &lt;code&gt;urldefrag()&lt;/code&gt; &lt;/a&gt; 결과 만 빈 단편 식별자를 제거한다. 들어 &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt; &lt;code&gt;urlsplit()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt; 결과, 모든 기록 변경은이 방법에 의해 반환되는 URL로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="52c94526432badb979362f78eb056d0acef67e5b" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt;&lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt;&lt;/a&gt; objects, the realm &lt;code&gt;None&lt;/code&gt; will be searched if the given &lt;em&gt;realm&lt;/em&gt; has no matching user/password.</source>
          <target state="translated">들어 &lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt; &lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt; 이&lt;/a&gt; 객체의 영역 &lt;code&gt;None&lt;/code&gt; 주어진 경우 검색되지 않습니다 &lt;em&gt;영역이&lt;/em&gt; 일치하는 사용자 / 암호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7066446b04ee84f2ee63e0715496c2416b380408" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; objects, set the maintype to &lt;code&gt;message&lt;/code&gt;, and set the subtype to &lt;em&gt;subtype&lt;/em&gt; if it is specified or &lt;code&gt;rfc822&lt;/code&gt; if it is not. If &lt;em&gt;subtype&lt;/em&gt; is &lt;code&gt;partial&lt;/code&gt;, raise an error (&lt;code&gt;bytes&lt;/code&gt; objects must be used to construct &lt;code&gt;message/partial&lt;/code&gt; parts).</source>
          <target state="translated">들어 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 는&lt;/a&gt; 객체,에 maintype 설정 &lt;code&gt;message&lt;/code&gt; , 그리고의 하위 유형 설정 &lt;em&gt;하위 유형&lt;/em&gt; 이 지정된 경우 또는 &lt;code&gt;rfc822&lt;/code&gt; 그렇지 않은 경우. 경우 &lt;em&gt;서브 타입&lt;/em&gt; 인 &lt;code&gt;partial&lt;/code&gt; (오류를 발생 &lt;code&gt;bytes&lt;/code&gt; 개체 구성체에 사용되어야 &lt;code&gt;message/partial&lt;/code&gt; 부분).</target>
        </trans-unit>
        <trans-unit id="cd93e3e6c8c66a14f077add7bc3e55825954f4f2" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt;, per &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt;, raise an error if a &lt;em&gt;cte&lt;/em&gt; of &lt;code&gt;quoted-printable&lt;/code&gt; or &lt;code&gt;base64&lt;/code&gt; is requested for &lt;em&gt;subtype&lt;/em&gt;&lt;code&gt;rfc822&lt;/code&gt;, and for any &lt;em&gt;cte&lt;/em&gt; other than &lt;code&gt;7bit&lt;/code&gt; for &lt;em&gt;subtype&lt;/em&gt;&lt;code&gt;external-body&lt;/code&gt;. For &lt;code&gt;message/rfc822&lt;/code&gt;, use &lt;code&gt;8bit&lt;/code&gt; if &lt;em&gt;cte&lt;/em&gt; is not specified. For all other values of &lt;em&gt;subtype&lt;/em&gt;, use &lt;code&gt;7bit&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; , 당 &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt; 하는 경우 오류가 발생 &lt;em&gt;CTE&lt;/em&gt; 의 &lt;code&gt;quoted-printable&lt;/code&gt; 또는 &lt;code&gt;base64&lt;/code&gt; 에 대한 요청 &lt;em&gt;서브 타입 &lt;/em&gt; &lt;code&gt;rfc822&lt;/code&gt; , 어떤을위한 &lt;em&gt;CTE&lt;/em&gt; 이외의 &lt;code&gt;7bit&lt;/code&gt; 에 대한 &lt;em&gt;하위 &lt;/em&gt; &lt;code&gt;external-body&lt;/code&gt; . 들어 &lt;code&gt;message/rfc822&lt;/code&gt; , 사용 &lt;code&gt;8bit&lt;/code&gt; 경우 &lt;em&gt;CTE가&lt;/em&gt; 지정되어 있지 않습니다. 다른 모든 &lt;em&gt;하위 유형&lt;/em&gt; 값에는 &lt;code&gt;7bit&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e398629d7cbca4cecc106052af8eb8c0b30b221f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;bytes&lt;/code&gt;, use the specified &lt;em&gt;maintype&lt;/em&gt; and &lt;em&gt;subtype&lt;/em&gt;, or raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if they are not specified.</source>
          <target state="translated">들어 &lt;code&gt;bytes&lt;/code&gt; , 지정된 사용 &lt;em&gt;maintype&lt;/em&gt; 및 &lt;em&gt;하위 유형을&lt;/em&gt; , 또는 인상 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 그들이 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="e1f46e2291fcafabd14f10bb29e1002c75bd19e3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;str&lt;/code&gt; objects, if &lt;em&gt;cte&lt;/em&gt; is not set use heuristics to determine the most compact encoding.</source>
          <target state="translated">들어 &lt;code&gt;str&lt;/code&gt; 경우 객체, &lt;em&gt;CTE가&lt;/em&gt; 없는 세트를 사용 추론은 가장 컴팩트 한 인코딩을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="18c573f79e1045ebe735b20b3288da0ea510cc71" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;str&lt;/code&gt;, set the MIME &lt;code&gt;maintype&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt;, and set the subtype to &lt;em&gt;subtype&lt;/em&gt; if it is specified, or &lt;code&gt;plain&lt;/code&gt; if it is not.</source>
          <target state="translated">들어 &lt;code&gt;str&lt;/code&gt; 의 MIME 세트 &lt;code&gt;maintype&lt;/code&gt; 에 &lt;code&gt;text&lt;/code&gt; 와의 하위 유형 설정 &lt;em&gt;하위 유형&lt;/em&gt; 이 지정된 경우, 또는 &lt;code&gt;plain&lt;/code&gt; 그렇지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="d35d91a13b57ac41755a8fa618e750f4c5244931" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;stdin&lt;/em&gt;, line ending characters &lt;code&gt;'\n'&lt;/code&gt; in the input will be converted to the default line separator &lt;a href=&quot;os#os.linesep&quot;&gt;&lt;code&gt;os.linesep&lt;/code&gt;&lt;/a&gt;. For &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt;, all line endings in the output will be converted to &lt;code&gt;'\n'&lt;/code&gt;. For more information see the documentation of the &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; class when the &lt;em&gt;newline&lt;/em&gt; argument to its constructor is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;stdin의&lt;/em&gt; 경우 &lt;em&gt;입력&lt;/em&gt; 의 줄 끝 문자 &lt;code&gt;'\n'&lt;/code&gt; 은 기본 줄 구분자 &lt;a href=&quot;os#os.linesep&quot;&gt; &lt;code&gt;os.linesep&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 . 들어 &lt;em&gt;표준 출력&lt;/em&gt; 과 &lt;em&gt;표준 에러&lt;/em&gt; 출력의 모든 라인 엔딩으로 변환됩니다 &lt;code&gt;'\n'&lt;/code&gt; . 자세한 정보 는 생성자에 대한 &lt;em&gt;개행&lt;/em&gt; 인수가 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; 클래스 의 문서를 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aefa0554df66d0c278cf83b6f6f16cd31c184d5a" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;client use&lt;/strong&gt;, if you don&amp;rsquo;t have any special requirements for your security policy, it is highly recommended that you use the &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; function to create your SSL context. It will load the system&amp;rsquo;s trusted CA certificates, enable certificate validation and hostname checking, and try to choose reasonably secure protocol and cipher settings.</source>
          <target state="translated">들어 &lt;strong&gt;클라이언트를 사용&lt;/strong&gt; 하면 보안 정책에 대한 특별한 요구 사항이없는 경우, 매우 당신이 사용하는 것이 좋습니다 &lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 당신의 SSL 컨텍스트를 생성하는 기능. 시스템의 신뢰할 수있는 CA 인증서를로드하고 인증서 유효성 검사 및 호스트 이름 확인을 활성화하며 합리적으로 안전한 프로토콜 및 암호 설정을 선택하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8c2e9f6d535c3b5a4230508df199bceaf128b328" translate="yes" xml:space="preserve">
          <source>For FTP, file, and data URLs and requests explicitly handled by legacy &lt;a href=&quot;#urllib.request.URLopener&quot;&gt;&lt;code&gt;URLopener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt; classes, this function returns a &lt;code&gt;urllib.response.addinfourl&lt;/code&gt; object.</source>
          <target state="translated">레거시 &lt;a href=&quot;#urllib.request.URLopener&quot;&gt; &lt;code&gt;URLopener&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 클래스 가 명시 적으로 처리하는 FTP, 파일 및 데이터 URL 및 요청의 경우이 함수는 &lt;code&gt;urllib.response.addinfourl&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c7aa24779d0a082d5416d92f04e7e88d8105145b" translate="yes" xml:space="preserve">
          <source>For HTTP and HTTPS URLs, this function returns a &lt;a href=&quot;http.client#http.client.HTTPResponse&quot;&gt;&lt;code&gt;http.client.HTTPResponse&lt;/code&gt;&lt;/a&gt; object slightly modified. In addition to the three new methods above, the msg attribute contains the same information as the &lt;a href=&quot;http.client#http.client.HTTPResponse.reason&quot;&gt;&lt;code&gt;reason&lt;/code&gt;&lt;/a&gt; attribute &amp;mdash; the reason phrase returned by server &amp;mdash; instead of the response headers as it is specified in the documentation for &lt;a href=&quot;http.client#http.client.HTTPResponse&quot;&gt;&lt;code&gt;HTTPResponse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP 및 HTTPS URL의 경우이 함수는 약간 수정 된 &lt;a href=&quot;http.client#http.client.HTTPResponse&quot;&gt; &lt;code&gt;http.client.HTTPResponse&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 위의 세 가지 새로운 메소드 외에도 msg 속성에는 &lt;a href=&quot;http.client#http.client.HTTPResponse&quot;&gt; &lt;code&gt;HTTPResponse&lt;/code&gt; &lt;/a&gt; 문서에 지정된대로 응답 헤더 대신 &lt;a href=&quot;http.client#http.client.HTTPResponse.reason&quot;&gt; &lt;code&gt;reason&lt;/code&gt; &lt;/a&gt; 속성 (서버에서 리턴 한 이유 문구) 과 동일한 정보 가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bc75bf88ecf83b55f007797a7a4602b34f12e08" translate="yes" xml:space="preserve">
          <source>For IPv4 addresses, two special forms are accepted instead of a host address: &lt;code&gt;''&lt;/code&gt; represents &lt;code&gt;INADDR_ANY&lt;/code&gt;, which is used to bind to all interfaces, and the string &lt;code&gt;'&amp;lt;broadcast&amp;gt;'&lt;/code&gt; represents &lt;code&gt;INADDR_BROADCAST&lt;/code&gt;. This behavior is not compatible with IPv6, therefore, you may want to avoid these if you intend to support IPv6 with your Python programs.</source>
          <target state="translated">IPv4 주소의 경우 호스트 주소 대신 두 가지 특수 형식이 허용됩니다. &lt;code&gt;''&lt;/code&gt; 는 모든 인터페이스에 바인딩하는 데 사용되는 &lt;code&gt;INADDR_ANY&lt;/code&gt; 를 나타내고 문자열 &lt;code&gt;'&amp;lt;broadcast&amp;gt;'&lt;/code&gt; 는 &lt;code&gt;INADDR_BROADCAST&lt;/code&gt; 를 나타 냅니다 . 이 동작은 IPv6과 호환되지 않으므로 Python 프로그램에서 IPv6을 지원하려는 경우이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd76cf073a90da47328543f5df73c1501f64885" translate="yes" xml:space="preserve">
          <source>For IPv6 addresses, &lt;code&gt;%scope&lt;/code&gt; is appended to the host part if &lt;em&gt;sockaddr&lt;/em&gt; contains meaningful &lt;em&gt;scopeid&lt;/em&gt;. Usually this happens for multicast addresses.</source>
          <target state="translated">IPv6 주소의 경우 &lt;em&gt;sockaddr&lt;/em&gt; 에 의미있는 &lt;em&gt;scopeid&lt;/em&gt; 가 포함되어 있으면 &lt;code&gt;%scope&lt;/code&gt; 가 호스트 부분에 추가됩니다 . 일반적으로 이것은 멀티 캐스트 주소에서 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f84204498b40046cf3d5c8d670e1b6f64404196" translate="yes" xml:space="preserve">
          <source>For Python 2.x users: In the Python 2.x series, a variety of implicit conversions between 8-bit strings (the closest thing 2.x offers to a built-in binary data type) and Unicode strings were permitted. This was a backwards compatibility workaround to account for the fact that Python originally only supported 8-bit text, and Unicode text was a later addition. In Python 3.x, those implicit conversions are gone - conversions between 8-bit binary data and Unicode text must be explicit, and bytes and string objects will always compare unequal.</source>
          <target state="translated">Python 2.x 사용자의 경우 : Python 2.x 시리즈에서 8 비트 문자열 (2.x가 내장 이진 데이터 유형에 가장 가까운 것)과 유니 코드 문자열 간의 다양한 암시 적 변환이 허용되었습니다. 이것은 파이썬이 원래 8 비트 텍스트 만 지원했고 유니 코드 텍스트는 나중에 추가되었다는 사실을 설명하기 위해 이전 버전과의 호환성 해결 방법이었습니다. Python 3.x에서는 이러한 암시 적 변환이 사라졌습니다. 8 비트 이진 데이터와 유니 코드 텍스트 간의 변환은 명시 적이어야하며 바이트와 문자열 개체는 항상 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07a7aa5b50fd70b489ae7356b6020b2730b425a6" translate="yes" xml:space="preserve">
          <source>For SyntaxError tracebacks, the normal &amp;lsquo;^&amp;rsquo; marking where the error was detected is replaced by coloring the text with an error highlight. When code run from a file causes other exceptions, one may right click on a traceback line to jump to the corresponding line in an IDLE editor. The file will be opened if necessary.</source>
          <target state="translated">SyntaxError 역 추적의 경우, 오류가 감지 된 일반적인 '^'표시는 오류 강조 표시로 텍스트를 색칠하는 것으로 대체됩니다. 파일에서 코드를 실행하면 다른 예외가 발생하면 역 추적 라인을 마우스 오른쪽 단추로 클릭하여 IDLE 편집기의 해당 라인으로 이동할 수 있습니다. 필요한 경우 파일이 열립니다.</target>
        </trans-unit>
        <trans-unit id="b334d98feb81f2472f7fcf772413a175e76a7be9" translate="yes" xml:space="preserve">
          <source>For Unicode (str) patterns:</source>
          <target state="translated">유니 코드 (str) 패턴의 경우 :</target>
        </trans-unit>
        <trans-unit id="cc5ee7549356196b75a26243082dbc16cceea4e1" translate="yes" xml:space="preserve">
          <source>For Unix systems, except on Linux and AIX, this is the lowercased OS name as returned by &lt;code&gt;uname -s&lt;/code&gt; with the first part of the version as returned by &lt;code&gt;uname -r&lt;/code&gt; appended, e.g. &lt;code&gt;'sunos5'&lt;/code&gt; or &lt;code&gt;'freebsd8'&lt;/code&gt;, &lt;em&gt;at the time when Python was built&lt;/em&gt;. Unless you want to test for a specific system version, it is therefore recommended to use the following idiom:</source>
          <target state="translated">리눅스와 AIX 제외 유닉스 시스템의 경우,이에 의해 반환되는 소문자 OS 이름 &lt;code&gt;uname -s&lt;/code&gt; 에서 반환 된 버전의 첫 번째 부분 &lt;code&gt;uname -r&lt;/code&gt; , 예를 들어 추가 &lt;code&gt;'sunos5'&lt;/code&gt; 또는 &lt;code&gt;'freebsd8'&lt;/code&gt; , &lt;em&gt;시간 때에는 파이썬이 만들어졌습니다&lt;/em&gt; . 특정 시스템 버전을 테스트하지 않으려면 다음 관용구를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1b3f52ba18e9bb6bfd8b64d0e44b233de339b632" translate="yes" xml:space="preserve">
          <source>For XML with namespaces, use the usual qualified &lt;code&gt;{namespace}tag&lt;/code&gt; notation:</source>
          <target state="translated">네임 스페이스가있는 XML의 경우 일반적인 정규화 된 &lt;code&gt;{namespace}tag&lt;/code&gt; 표기법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="386bae46469352b3dcedf77c3f3e3e04ed9b6a94" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance &lt;em&gt;d&lt;/em&gt;, &lt;code&gt;str(d)&lt;/code&gt; is equivalent to &lt;code&gt;d.isoformat(' ')&lt;/code&gt;.</source>
          <target state="translated">A에 대한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스 &lt;em&gt;D&lt;/em&gt; , &lt;code&gt;str(d)&lt;/code&gt; 동등 &lt;code&gt;d.isoformat(' ')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32f810518819bb3ad019a20e713df5e193f8f9b1" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;#logging.handlers.MemoryHandler&quot;&gt;&lt;code&gt;MemoryHandler&lt;/code&gt;&lt;/a&gt;, flushing means just sending the buffered records to the target, if there is one. The buffer is also cleared when this happens. Override if you want different behavior.</source>
          <target state="translated">A에 대한 &lt;a href=&quot;#logging.handlers.MemoryHandler&quot;&gt; &lt;code&gt;MemoryHandler&lt;/code&gt; &lt;/a&gt; 가있는 경우, 플러싱 수단은, 대상에 버퍼링 기록을 전송. 이 경우 버퍼도 지워집니다. 다른 동작을 원하면 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="1dff9931aa7d0ed5d45d70af53cd2aed0fd4dfb1" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt; number &lt;code&gt;z&lt;/code&gt;, the hash values of the real and imaginary parts are combined by computing &lt;code&gt;hash(z.real) +
sys.hash_info.imag * hash(z.imag)&lt;/code&gt;, reduced modulo &lt;code&gt;2**sys.hash_info.width&lt;/code&gt; so that it lies in &lt;code&gt;range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width -
1))&lt;/code&gt;. Again, if the result is &lt;code&gt;-1&lt;/code&gt;, it&amp;rsquo;s replaced with &lt;code&gt;-2&lt;/code&gt;.</source>
          <target state="translated">A에 대한 &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; 번호 &lt;code&gt;z&lt;/code&gt; 의 실수 및 허수 부분의 해시 값을 계산하여 결합 &lt;code&gt;hash(z.real) + sys.hash_info.imag * hash(z.imag)&lt;/code&gt; , 모듈러 감소 &lt;code&gt;2**sys.hash_info.width&lt;/code&gt; 그래서 그것은에 있다고 &lt;code&gt;range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))&lt;/code&gt; . 다시 결과가 &lt;code&gt;-1&lt;/code&gt; 이면 &lt;code&gt;-2&lt;/code&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="115b45a6292b21abd1fa97a5ef3ba9bc8ab15b01" translate="yes" xml:space="preserve">
          <source>For a call object that represents multiple calls, &lt;a href=&quot;#unittest.mock.call.call_list&quot;&gt;&lt;code&gt;call_list()&lt;/code&gt;&lt;/a&gt; returns a list of all the intermediate calls as well as the final call.</source>
          <target state="translated">여러 호출을 나타내는 호출 객체의 경우 &lt;a href=&quot;#unittest.mock.call.call_list&quot;&gt; &lt;code&gt;call_list()&lt;/code&gt; &lt;/a&gt; 는 모든 중간 호출 목록과 최종 호출 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4712f20402a7ed1bfb0c0d4a6cfbb07523688d8c" translate="yes" xml:space="preserve">
          <source>For a complete explanation of a given option and its behavior, see the Tk man pages for the widget in question.</source>
          <target state="translated">주어진 옵션과 그 동작에 대한 자세한 설명은 해당 위젯에 대한 Tk 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e3266049648ef06aea068c545a02b2015f4133b" translate="yes" xml:space="preserve">
          <source>For a date &lt;em&gt;d&lt;/em&gt;, &lt;code&gt;str(d)&lt;/code&gt; is equivalent to &lt;code&gt;d.isoformat()&lt;/code&gt;.</source>
          <target state="translated">날짜 &lt;em&gt;d의&lt;/em&gt; 경우 &lt;code&gt;str(d)&lt;/code&gt; 는 &lt;code&gt;d.isoformat()&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4f58bc806b154de327f318c6ac5ff546bf7bd2fe" translate="yes" xml:space="preserve">
          <source>For a demonstration of these concepts, look at this example ABC definition:</source>
          <target state="translated">이러한 개념을 시연하려면 다음 ABC 정의 예를보십시오.</target>
        </trans-unit>
        <trans-unit id="8f0dc2746ae7c369836b36523343036355346489" translate="yes" xml:space="preserve">
          <source>For a description of the flag and mode values, see the C run-time documentation; flag constants (like &lt;a href=&quot;#os.O_RDONLY&quot;&gt;&lt;code&gt;O_RDONLY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.O_WRONLY&quot;&gt;&lt;code&gt;O_WRONLY&lt;/code&gt;&lt;/a&gt;) are defined in the &lt;a href=&quot;#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module. In particular, on Windows adding &lt;a href=&quot;#os.O_BINARY&quot;&gt;&lt;code&gt;O_BINARY&lt;/code&gt;&lt;/a&gt; is needed to open files in binary mode.</source>
          <target state="translated">플래그 및 모드 값에 대한 설명은 C 런타임 설명서를 참조하십시오. 플래그 상수 ( &lt;a href=&quot;#os.O_RDONLY&quot;&gt; &lt;code&gt;O_RDONLY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.O_WRONLY&quot;&gt; &lt;code&gt;O_WRONLY&lt;/code&gt; &lt;/a&gt; 와 같은 )는 &lt;a href=&quot;#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈 에서 정의됩니다 . 특히 Windows 에서는 이진 모드로 파일을 열려면 &lt;a href=&quot;#os.O_BINARY&quot;&gt; &lt;code&gt;O_BINARY&lt;/code&gt; 를&lt;/a&gt; 추가 해야합니다.</target>
        </trans-unit>
        <trans-unit id="00fd7a5300104795ce153d199d268c66cb6aaf56" translate="yes" xml:space="preserve">
          <source>For a detailed example, see &lt;a href=&quot;#reducer-override&quot;&gt;Custom Reduction for Types, Functions, and Other Objects&lt;/a&gt;.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;#reducer-override&quot;&gt;유형, 함수 및 기타 객체에 대한 사용자 정의 축소를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3db5c5c5b4bd614cce7d0ac3fee3e85c0cd62de9" translate="yes" xml:space="preserve">
          <source>For a full table of logging levels, see the &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">로깅 레벨의 전체 테이블은 &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65c24ec47684ed26cbc7c9636834c71915522b1e" translate="yes" xml:space="preserve">
          <source>For a fully standalone distribution, you can distribute the launcher with your application appended, bundled with the Python &amp;ldquo;embedded&amp;rdquo; distribution. This will run on any PC with the appropriate architecture (32 bit or 64 bit).</source>
          <target state="translated">완전 독립형 배포의 경우 응용 프로그램이 추가 된 상태에서 시작 프로그램을 배포하고 Python &quot;임베디드&quot;배포와 함께 배포 할 수 있습니다. 적절한 아키텍처 (32 비트 또는 64 비트)를 가진 모든 PC에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="aa126f00739d88b9aa90e6f3e2a802cb5c763327" translate="yes" xml:space="preserve">
          <source>For a general Python object &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; delegates to &lt;code&gt;number.__round__&lt;/code&gt;.</source>
          <target state="translated">일반적인 파이썬 객체의 경우 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; 대표단에 &lt;code&gt;number.__round__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a28d39399a4b667034ddd93b313ca4ada834489a" translate="yes" xml:space="preserve">
          <source>For a general Python object &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;complex(x)&lt;/code&gt; delegates to &lt;code&gt;x.__complex__()&lt;/code&gt;. If &lt;code&gt;__complex__()&lt;/code&gt; is not defined then it falls back to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__float__&quot;&gt;&lt;code&gt;__float__()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;__float__()&lt;/code&gt; is not defined then it falls back to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 파이썬 객체 &lt;code&gt;x&lt;/code&gt; 의 경우 &lt;code&gt;complex(x)&lt;/code&gt; 는 &lt;code&gt;x.__complex__()&lt;/code&gt; 위임합니다 . &lt;code&gt;__complex__()&lt;/code&gt; 가 정의되지 않은 경우 __float __ () 로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__float__&quot;&gt; &lt;code&gt;__float__()&lt;/code&gt; &lt;/a&gt; 됩니다. &lt;code&gt;__float__()&lt;/code&gt; 이 정의되지 않은 경우 __index __ () 로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="fdf496741ae444039bcbd0cff2de28e69e24051c" translate="yes" xml:space="preserve">
          <source>For a general Python object &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;float(x)&lt;/code&gt; delegates to &lt;code&gt;x.__float__()&lt;/code&gt;. If &lt;code&gt;__float__()&lt;/code&gt; is not defined then it falls back to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 파이썬 객체 &lt;code&gt;x&lt;/code&gt; 의 경우 &lt;code&gt;float(x)&lt;/code&gt; 는 &lt;code&gt;x.__float__()&lt;/code&gt; 위임합니다 . &lt;code&gt;__float__()&lt;/code&gt; 이 정의되지 않은 경우 __index __ () 로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b71ded6b644e163ed5a22c84a52332ed36162733" translate="yes" xml:space="preserve">
          <source>For a given seed, the &lt;a href=&quot;#random.choices&quot;&gt;&lt;code&gt;choices()&lt;/code&gt;&lt;/a&gt; function with equal weighting typically produces a different sequence than repeated calls to &lt;a href=&quot;#random.choice&quot;&gt;&lt;code&gt;choice()&lt;/code&gt;&lt;/a&gt;. The algorithm used by &lt;a href=&quot;#random.choices&quot;&gt;&lt;code&gt;choices()&lt;/code&gt;&lt;/a&gt; uses floating point arithmetic for internal consistency and speed. The algorithm used by &lt;a href=&quot;#random.choice&quot;&gt;&lt;code&gt;choice()&lt;/code&gt;&lt;/a&gt; defaults to integer arithmetic with repeated selections to avoid small biases from round-off error.</source>
          <target state="translated">주어진 시드에 대해 동일한 가중치를 사용 하는 &lt;a href=&quot;#random.choices&quot;&gt; &lt;code&gt;choices()&lt;/code&gt; &lt;/a&gt; 함수는 일반적으로 &lt;a href=&quot;#random.choice&quot;&gt; &lt;code&gt;choice()&lt;/code&gt; &lt;/a&gt; 반복 호출과 다른 순서를 생성합니다 . &lt;a href=&quot;#random.choices&quot;&gt; &lt;code&gt;choices()&lt;/code&gt; &lt;/a&gt; 사용 하는 알고리즘 은 내부 일관성 및 속도를 위해 부동 소수점 산술을 사용합니다. &lt;a href=&quot;#random.choice&quot;&gt; &lt;code&gt;choice()&lt;/code&gt; &lt;/a&gt; 의해 사용되는 알고리즘 은 반올림 오차로 인한 작은 바이어스를 피하기 위해 반복 선택을 통해 정수 산술로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="05f7b184da73f1934bbc9129b218aedbb998c7d7" translate="yes" xml:space="preserve">
          <source>For a higher-level wrapper of &lt;a href=&quot;#os.sendfile&quot;&gt;&lt;code&gt;sendfile()&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;socket#socket.socket.sendfile&quot;&gt;&lt;code&gt;socket.socket.sendfile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">높은 수준의 랩퍼 &lt;a href=&quot;#os.sendfile&quot;&gt; &lt;code&gt;sendfile()&lt;/code&gt; &lt;/a&gt; 를 참조 &lt;a href=&quot;socket#socket.socket.sendfile&quot;&gt; &lt;code&gt;socket.socket.sendfile()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0d6c126a57019cfaa59c16f6bbb2a1d78c4228c" translate="yes" xml:space="preserve">
          <source>For a list of all the command-line options:</source>
          <target state="translated">모든 명령 행 옵션 목록 :</target>
        </trans-unit>
        <trans-unit id="87fd2a57950af3c9c3165d392564b7fc19902f06" translate="yes" xml:space="preserve">
          <source>For a list of handlers included as standard, see &lt;a href=&quot;logging.handlers#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준으로 포함 된 핸들러 목록은 &lt;a href=&quot;logging.handlers#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c623ac8e2dbdb44b77f887d6638659eaf4c8074e" translate="yes" xml:space="preserve">
          <source>For a list of the files in a ZIP archive, use the &lt;a href=&quot;#cmdoption-zipfile-l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">ZIP 아카이브의 파일 목록을 보려면 &lt;a href=&quot;#cmdoption-zipfile-l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce33415db4c123c62bd6366476d7eb3fd7814ac8" translate="yes" xml:space="preserve">
          <source>For a list of the files in a tar archive, use the &lt;a href=&quot;#cmdoption-tarfile-l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">tar 아카이브의 파일 목록을 보려면 &lt;a href=&quot;#cmdoption-tarfile-l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f31a2e7a2b7ef74a465b4d5322ee2c30d359d16" translate="yes" xml:space="preserve">
          <source>For a literal match, wrap the meta-characters in brackets. For example, &lt;code&gt;'[?]'&lt;/code&gt; matches the character &lt;code&gt;'?'&lt;/code&gt;.</source>
          <target state="translated">리터럴 일치의 경우 메타 문자를 대괄호로 묶습니다. 예를 들어, &lt;code&gt;'[?]'&lt;/code&gt; 는 문자 &lt;code&gt;'?'&lt;/code&gt; 와 일치합니다. .</target>
        </trans-unit>
        <trans-unit id="c21d07a4b7809c16f34f5ad89fa8da95d75a44e6" translate="yes" xml:space="preserve">
          <source>For a match &lt;em&gt;m&lt;/em&gt;, return the 2-tuple &lt;code&gt;(m.start(group), m.end(group))&lt;/code&gt;. Note that if &lt;em&gt;group&lt;/em&gt; did not contribute to the match, this is &lt;code&gt;(-1, -1)&lt;/code&gt;. &lt;em&gt;group&lt;/em&gt; defaults to zero, the entire match.</source>
          <target state="translated">일치하는 &lt;em&gt;m의&lt;/em&gt; 경우 2 튜플 &lt;code&gt;(m.start(group), m.end(group))&lt;/code&gt; 반환합니다 . &lt;em&gt;그룹&lt;/em&gt; 이 경기에 참여하지 않은 경우 이는 &lt;code&gt;(-1, -1)&lt;/code&gt; 입니다. &lt;em&gt;그룹은&lt;/em&gt; 기본적으로 전체 일치하는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="666246b0e205cb965fefc705620932f2b5673bdc" translate="yes" xml:space="preserve">
          <source>For a more convenient way of compressing a single chunk of data, see &lt;a href=&quot;#lzma.compress&quot;&gt;&lt;code&gt;compress()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 데이터 청크를 압축하는보다 편리한 방법은 &lt;a href=&quot;#lzma.compress&quot;&gt; &lt;code&gt;compress()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43d8561201f10a9aece268d98ecf18b08da3fa5d" translate="yes" xml:space="preserve">
          <source>For a more convenient way of decompressing an entire compressed stream at once, see &lt;a href=&quot;#lzma.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전체 압축 스트림을 한 번에 압축 해제하는보다 편리한 방법은 &lt;a href=&quot;#lzma.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca9cb8f02ce650a16c34e931a114a4f3a4fa00e0" translate="yes" xml:space="preserve">
          <source>For a naive object, the &lt;code&gt;%z&lt;/code&gt; and &lt;code&gt;%Z&lt;/code&gt; format codes are replaced by empty strings.</source>
          <target state="translated">순진한 개체의 경우 &lt;code&gt;%z&lt;/code&gt; 및 &lt;code&gt;%Z&lt;/code&gt; 형식 코드는 빈 문자열로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="30621260251d8be3cc3042163396cd1230567f5d" translate="yes" xml:space="preserve">
          <source>For a negative &lt;em&gt;step&lt;/em&gt;, the contents of the range are still determined by the formula &lt;code&gt;r[i] = start + step*i&lt;/code&gt;, but the constraints are &lt;code&gt;i &amp;gt;= 0&lt;/code&gt; and &lt;code&gt;r[i] &amp;gt; stop&lt;/code&gt;.</source>
          <target state="translated">음수 &lt;em&gt;단계&lt;/em&gt; 의 경우 범위의 내용은 여전히 ​​공식 &lt;code&gt;r[i] = start + step*i&lt;/code&gt; 로 결정되지만 제약 조건은 &lt;code&gt;i &amp;gt;= 0&lt;/code&gt; 및 &lt;code&gt;r[i] &amp;gt; stop&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b78e93c1f5bc6ada550d464265f45c45e160b33" translate="yes" xml:space="preserve">
          <source>For a nonzero number, return the adjusted exponent of its operand as a &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance. If the operand is a zero then &lt;code&gt;Decimal('-Infinity')&lt;/code&gt; is returned and the &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt; flag is raised. If the operand is an infinity then &lt;code&gt;Decimal('Infinity')&lt;/code&gt; is returned.</source>
          <target state="translated">0이 아닌 숫자의 경우, 피연산자의 조정 된 지수를 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스 로 리턴하십시오 . 피연산자가 0이면 &lt;code&gt;Decimal('-Infinity')&lt;/code&gt; 이 반환되고 &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; &lt;/a&gt; 플래그가 발생합니다. 피연산자가 무한대이면 &lt;code&gt;Decimal('Infinity')&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8d50bedea444e5cc9430e30600bab5cd97f24f9c" translate="yes" xml:space="preserve">
          <source>For a package, the same effect can be achieved by including a &lt;code&gt;__main__.py&lt;/code&gt; module, the contents of which will be executed when the module is run with &lt;code&gt;-m&lt;/code&gt;.</source>
          <target state="translated">패키지의 경우 &lt;code&gt;__main__.py&lt;/code&gt; 모듈 을 포함 시키면 동일한 효과를 얻을 수 있습니다 . 그 내용은 &lt;code&gt;-m&lt;/code&gt; 으로 모듈을 실행할 때 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8bcd8e2e8d9e09e1932e1712a87977c634a4d946" translate="yes" xml:space="preserve">
          <source>For a positive &lt;em&gt;step&lt;/em&gt;, the contents of a range &lt;code&gt;r&lt;/code&gt; are determined by the formula &lt;code&gt;r[i] = start + step*i&lt;/code&gt; where &lt;code&gt;i &amp;gt;= 0&lt;/code&gt; and &lt;code&gt;r[i] &amp;lt; stop&lt;/code&gt;.</source>
          <target state="translated">양수 &lt;em&gt;단계의 경우&lt;/em&gt; , 범위 &lt;code&gt;r&lt;/code&gt; 의 내용은 공식 &lt;code&gt;r[i] = start + step*i&lt;/code&gt; ( &lt;code&gt;i &amp;gt;= 0&lt;/code&gt; 및 &lt;code&gt;r[i] &amp;lt; stop&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf3aa39c7cc3dda44d966630b1c09cfb3205e2ce" translate="yes" xml:space="preserve">
          <source>For a simple script, the specified code is simply executed in a fresh module namespace. For a valid sys.path entry (typically a zipfile or directory), the entry is first added to the beginning of &lt;code&gt;sys.path&lt;/code&gt;. The function then looks for and executes a &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt; module using the updated path. Note that there is no special protection against invoking an existing &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt; entry located elsewhere on &lt;code&gt;sys.path&lt;/code&gt; if there is no such module at the specified location.</source>
          <target state="translated">간단한 스크립트의 경우 지정된 코드는 새로운 모듈 네임 스페이스에서 간단하게 실행됩니다. 유효한 sys.path 항목 (일반적으로 zip 파일 또는 디렉토리)의 경우 항목이 먼저 &lt;code&gt;sys.path&lt;/code&gt; 의 시작 부분에 추가됩니다 . 그런 다음 함수 는 업데이트 된 경로를 사용하여 &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; &lt;/a&gt; 모듈 을 찾아 실행합니다 . 지정된 위치에 해당 모듈이없는 경우 &lt;code&gt;sys.path&lt;/code&gt; 의 다른 위치에 있는 기존 &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; &lt;/a&gt; 항목을 호출하는 데 대한 특별한 보호 기능 은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6baeee723ea1f301c86883b2af994d3639d55d54" translate="yes" xml:space="preserve">
          <source>For a time &lt;em&gt;t&lt;/em&gt;, &lt;code&gt;str(t)&lt;/code&gt; is equivalent to &lt;code&gt;t.isoformat()&lt;/code&gt;.</source>
          <target state="translated">시간 &lt;em&gt;t의&lt;/em&gt; 경우 &lt;code&gt;str(t)&lt;/code&gt; 는 &lt;code&gt;t.isoformat()&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1e518769f3b680be2e2b473fb9aff3c8ff0902ac" translate="yes" xml:space="preserve">
          <source>For a two dimensional point &lt;code&gt;(x, y)&lt;/code&gt;, this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, &lt;code&gt;sqrt(x*x + y*y)&lt;/code&gt;.</source>
          <target state="translated">2 차원 점 &lt;code&gt;(x, y)&lt;/code&gt; 경우 피타고라스 정리 &lt;code&gt;sqrt(x*x + y*y)&lt;/code&gt; 사용하여 직각 삼각형의 빗변을 계산하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="df6335500739b50d131f2bfca3e93aa377a0b672" translate="yes" xml:space="preserve">
          <source>For a typing object of the form &lt;code&gt;X[Y, Z, ...]&lt;/code&gt; these functions return &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;(Y, Z, ...)&lt;/code&gt;. If &lt;code&gt;X&lt;/code&gt; is a generic alias for a builtin or &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; class, it gets normalized to the original class. For unsupported objects return &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt; correspondingly. Examples:</source>
          <target state="translated">&lt;code&gt;X[Y, Z, ...]&lt;/code&gt; 형식의 입력 객체의 경우이 함수는 &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;(Y, Z, ...)&lt;/code&gt; 반환 합니다. 경우 &lt;code&gt;X&lt;/code&gt; 는 내장 명령 또는에 대한 일반적인 별칭 &lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 클래스, 그것은 원래의 클래스에 정상화됩니다. 지원되지 않는 개체의 경우 해당 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;()&lt;/code&gt; 를 반환 합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="1ee64b9ff441d0b6a5cef41090e49445fc0a5d11" translate="yes" xml:space="preserve">
          <source>For accessing the C Python api directly, a ready-to-use Python shared library object is available:</source>
          <target state="translated">C Python API에 직접 액세스하기 위해 즉시 사용 가능한 Python 공유 라이브러리 객체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d7a1f81d73cb959d5e3b45930e44df60ee064e1" translate="yes" xml:space="preserve">
          <source>For additional numeric operations see the &lt;a href=&quot;math#module-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmath#module-cmath&quot;&gt;&lt;code&gt;cmath&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">추가적인 수치 연산은 &lt;a href=&quot;math#module-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;cmath#module-cmath&quot;&gt; &lt;code&gt;cmath&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ec4af7df109ce92f9ea30f1681eaa99c7fccae1" translate="yes" xml:space="preserve">
          <source>For addresses that appear to be 6to4 addresses (starting with &lt;code&gt;2002::/16&lt;/code&gt;) as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3056.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 3056&lt;/strong&gt;&lt;/a&gt;, this property will report the embedded IPv4 address. For any other address, this property will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3056.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 3056에&lt;/strong&gt;&lt;/a&gt; 의해 정의 된 &lt;strong&gt;대로&lt;/strong&gt; 6to4 주소 ( &lt;code&gt;2002::/16&lt;/code&gt; 시작) 인 것으로 보이는 주소의 경우이 특성은 임베디드 IPv4 주소를보고합니다. 다른 주소의 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f900a30d92e1d3f296841c46ad25d2efeb2f007" translate="yes" xml:space="preserve">
          <source>For addresses that appear to be IPv4 mapped addresses (starting with &lt;code&gt;::FFFF/96&lt;/code&gt;), this property will report the embedded IPv4 address. For any other address, this property will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;::FFFF/96&lt;/code&gt; 으로 시작하는 IPv4 매핑 주소로 보이는 주소의 경우이 속성은 내장 IPv4 주소를보고합니다. 다른 주소의 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6a8569f2aecd3660a5a2055585eeda04864338d" translate="yes" xml:space="preserve">
          <source>For addresses that appear to be Teredo addresses (starting with &lt;code&gt;2001::/32&lt;/code&gt;) as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4380.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4380&lt;/strong&gt;&lt;/a&gt;, this property will report the embedded &lt;code&gt;(server, client)&lt;/code&gt; IP address pair. For any other address, this property will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc4380.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4380에&lt;/strong&gt;&lt;/a&gt; 의해 정의 된 Teredo 주소 ( &lt;code&gt;2001::/32&lt;/code&gt; 시작) 인 주소의 경우이 특성은 임베디드 &lt;code&gt;(server, client)&lt;/code&gt; IP 주소 쌍을보고합니다. 다른 주소의 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caebc9e5ce8fd833a18841ee1d3aa8ceb3472904" translate="yes" xml:space="preserve">
          <source>For all of the &lt;a href=&quot;#opcode-SET_ADD&quot;&gt;&lt;code&gt;SET_ADD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#opcode-LIST_APPEND&quot;&gt;&lt;code&gt;LIST_APPEND&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#opcode-MAP_ADD&quot;&gt;&lt;code&gt;MAP_ADD&lt;/code&gt;&lt;/a&gt; instructions, while the added value or key/value pair is popped off, the container object remains on the stack so that it is available for further iterations of the loop.</source>
          <target state="translated">&lt;a href=&quot;#opcode-SET_ADD&quot;&gt; &lt;code&gt;SET_ADD&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#opcode-LIST_APPEND&quot;&gt; &lt;code&gt;LIST_APPEND&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#opcode-MAP_ADD&quot;&gt; &lt;code&gt;MAP_ADD&lt;/code&gt; &lt;/a&gt; 명령어 모두에 대해 추가 된 값 또는 키 / 값 쌍이 튀어 나오는 동안 컨테이너 객체는 스택에 남아 루프의 추가 반복에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17bb1e02a3a8c9756702891333f2fa0f4afa3d16" translate="yes" xml:space="preserve">
          <source>For all other comparisons (such as &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;), when a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object is compared to an object of a different type, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">다른 모든 비교 (예 : &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; )에서 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체를 다른 유형의 객체와 비교하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0f58f3dbfd004ab8257354adb01c260a0fe1222" translate="yes" xml:space="preserve">
          <source>For all other response codes, the method &lt;code&gt;http_error_default()&lt;/code&gt; is called which you can override in subclasses to handle the error appropriately.</source>
          <target state="translated">다른 모든 응답 코드의 경우, 오류를 적절하게 처리하기 위해 서브 클래스에서 대체 할 수있는 &lt;code&gt;http_error_default()&lt;/code&gt; 메소드 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b17df6417af18c05b98134b149d8706f2d0a67" translate="yes" xml:space="preserve">
          <source>For almost all applications &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt; is preferable.</source>
          <target state="translated">거의 모든 응용 프로그램에서 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; 이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="d1688519c95e30c3a0fdf1a44a0c337b8e5d237f" translate="yes" xml:space="preserve">
          <source>For an HTTP POST request method, &lt;em&gt;data&lt;/em&gt; should be a buffer in the standard &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt; format. The &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt;&lt;code&gt;urllib.parse.urlencode()&lt;/code&gt;&lt;/a&gt; function takes a mapping or sequence of 2-tuples and returns an ASCII string in this format. It should be encoded to bytes before being used as the &lt;em&gt;data&lt;/em&gt; parameter.</source>
          <target state="translated">HTTP POST 요청 방법의 경우 &lt;em&gt;데이터&lt;/em&gt; 는 표준 &lt;em&gt;application / x-www-form-urlencoded&lt;/em&gt; 형식 의 버퍼 여야 합니다. &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt; &lt;code&gt;urllib.parse.urlencode()&lt;/code&gt; &lt;/a&gt; 함수는 2 튜플의 매핑 또는 시퀀스를 받아 형식으로 ASCII 문자열을 반환합니다. &lt;em&gt;data&lt;/em&gt; 매개 변수 로 사용되기 전에 바이트로 인코딩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="321d130154df7221dd2710f2b1317833db709e42" translate="yes" xml:space="preserve">
          <source>For an aware object:</source>
          <target state="translated">인식 객체의 경우 :</target>
        </trans-unit>
        <trans-unit id="a17d72681c41e653cbffdc470a5ce38780a11b46" translate="yes" xml:space="preserve">
          <source>For an example of the usage of queues for interprocess communication see &lt;a href=&quot;#multiprocessing-examples&quot;&gt;Examples&lt;/a&gt;.</source>
          <target state="translated">프로세스 간 통신보기위한 큐의 사용의 예는 &lt;a href=&quot;#multiprocessing-examples&quot;&gt;예&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0b68182f78976cfa947bfc7e82fd8771f13f5a0" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#cookbook-rotator-namer&quot;&gt;Using a rotator and namer to customize log rotation processing&lt;/a&gt;.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#cookbook-rotator-namer&quot;&gt;로테이터 및 네임 러를 사용하여 로그 회전 처리 사용자 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="465235f896ee45a5706af0e616381fac9cdc77a3" translate="yes" xml:space="preserve">
          <source>For an explanation of why the &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; part is necessary, see &lt;a href=&quot;#multiprocessing-programming&quot;&gt;Programming guidelines&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 부분이 필요한 이유에 대한 설명 은 &lt;a href=&quot;#multiprocessing-programming&quot;&gt;프로그래밍 지침을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d87221a5f8993883fc9acf9eba35bccbcbdbcf3" translate="yes" xml:space="preserve">
          <source>For an introduction to socket programming (in C), see the following papers:</source>
          <target state="translated">소켓 프로그래밍 (C)에 대한 소개는 다음 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4537c0799d30818387a1778e0690fa078b4b7e06" translate="yes" xml:space="preserve">
          <source>For any &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object &lt;em&gt;d&lt;/em&gt;, &lt;code&gt;d == datetime.combine(d.date(), d.time(), d.tzinfo)&lt;/code&gt;. If date is a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object, its time components and &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes are ignored.</source>
          <target state="translated">어떤 옵션 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 오브젝트 &lt;em&gt;D&lt;/em&gt; , &lt;code&gt;d == datetime.combine(d.date(), d.time(), d.tzinfo)&lt;/code&gt; . date가 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체이면 해당 시간 구성 요소 및 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b37d67d8e0a8eb8e77a72044792b8805d3ba57e4" translate="yes" xml:space="preserve">
          <source>For any of methods of this class, a &lt;em&gt;resource&lt;/em&gt; argument is expected to be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt; which represents conceptually just a file name. This means that no subdirectory paths should be included in the &lt;em&gt;resource&lt;/em&gt; argument. This is because the location of the package the reader is for, acts as the &amp;ldquo;directory&amp;rdquo;. Hence the metaphor for directories and file names is packages and resources, respectively. This is also why instances of this class are expected to directly correlate to a specific package (instead of potentially representing multiple packages or a module).</source>
          <target state="translated">이 클래스의 모든 메소드에서 &lt;em&gt;자원&lt;/em&gt; 인수는 개념적으로 파일 이름 만 나타내는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한 오브젝트&lt;/a&gt; 일 것으로 예상됩니다 . 이는 하위 디렉토리 경로가 &lt;em&gt;자원&lt;/em&gt; 인수에 포함되지 않아야 함을 의미합니다 . 독자의 패키지 위치가 &quot;디렉토리&quot;의 역할을하기 때문입니다. 따라서 디렉토리와 파일 이름에 대한 은유는 각각 패키지와 리소스입니다. 이것은 또한이 클래스의 인스턴스가 잠재적으로 여러 패키지 또는 모듈을 나타내는 대신 특정 패키지와 직접적으로 연관 될 것으로 예상되는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="a1460d090c4d9e2f5c93e1dbae17ba143ffe2103" translate="yes" xml:space="preserve">
          <source>For applications requiring aware objects, &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects have an optional time zone information attribute, &lt;code&gt;tzinfo&lt;/code&gt;, that can be set to an instance of a subclass of the abstract &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; class. These &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; objects capture information about the offset from UTC time, the time zone name, and whether daylight saving time is in effect.</source>
          <target state="translated">인식 객체를 필요로하는 응용 프로그램의 경우, &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체에는 선택적 &lt;code&gt;tzinfo&lt;/code&gt; 클래스가 있으며 추상 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 클래스 의 하위 클래스 인스턴스로 설정할 수 있습니다 . 이 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 객체는 UTC 시간, 표준 시간대 이름 및 일광 절약 시간의 적용 여부에 대한 오프셋 정보를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="7075e97b30b77fd32e75248fdd1404e81f84a7b9" translate="yes" xml:space="preserve">
          <source>For applications that require data compression, the functions in this module allow compression and decompression, using the zlib library. The zlib library has its own home page at &lt;a href=&quot;http://www.zlib.net&quot;&gt;http://www.zlib.net&lt;/a&gt;. There are known incompatibilities between the Python module and versions of the zlib library earlier than 1.1.3; 1.1.3 has a security vulnerability, so we recommend using 1.1.4 or later.</source>
          <target state="translated">데이터 압축이 필요한 응용 프로그램의 경우이 모듈의 기능은 zlib 라이브러리를 사용하여 압축 및 압축 해제를 허용합니다. zlib 라이브러리는 &lt;a href=&quot;http://www.zlib.net&quot;&gt;http://www.zlib.net에&lt;/a&gt; 자체 홈페이지가 있습니다. Python 모듈과 1.1.3 이전의 zlib 라이브러리 버전 간에는 비 호환성이 알려져 있습니다. 1.1.3에는 보안 취약점이 있으므로 1.1.4 이상을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ff1b3bfa6942db35ceecc9803ef62bbeadf15677" translate="yes" xml:space="preserve">
          <source>For aware &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instances, the return value is computed as:</source>
          <target state="translated">&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스 를 인식 하는 경우 반환 값은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="69e80030e91a06f7b29e8bec9734b8962acbb95f" translate="yes" xml:space="preserve">
          <source>For backward compatibility, a &lt;a href=&quot;#os.stat_result&quot;&gt;&lt;code&gt;stat_result&lt;/code&gt;&lt;/a&gt; instance is also accessible as a tuple of at least 10 integers giving the most important (and portable) members of the &lt;code&gt;stat&lt;/code&gt; structure, in the order &lt;a href=&quot;#os.stat_result.st_mode&quot;&gt;&lt;code&gt;st_mode&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_ino&quot;&gt;&lt;code&gt;st_ino&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_dev&quot;&gt;&lt;code&gt;st_dev&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_nlink&quot;&gt;&lt;code&gt;st_nlink&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_uid&quot;&gt;&lt;code&gt;st_uid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_gid&quot;&gt;&lt;code&gt;st_gid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_size&quot;&gt;&lt;code&gt;st_size&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_atime&quot;&gt;&lt;code&gt;st_atime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_mtime&quot;&gt;&lt;code&gt;st_mtime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_ctime&quot;&gt;&lt;code&gt;st_ctime&lt;/code&gt;&lt;/a&gt;. More items may be added at the end by some implementations. For compatibility with older Python versions, accessing &lt;a href=&quot;#os.stat_result&quot;&gt;&lt;code&gt;stat_result&lt;/code&gt;&lt;/a&gt; as a tuple always returns integers.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;a href=&quot;#os.stat_result&quot;&gt; &lt;code&gt;stat_result&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;#os.stat_result.st_mode&quot;&gt; &lt;code&gt;st_mode&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_ino&quot;&gt; &lt;code&gt;st_ino&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_dev&quot;&gt; &lt;code&gt;st_dev&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_nlink&quot;&gt; &lt;code&gt;st_nlink&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_uid&quot;&gt; &lt;code&gt;st_uid&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_gid&quot;&gt; &lt;code&gt;st_gid&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_size&quot;&gt; &lt;code&gt;st_size&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_atime&quot;&gt; &lt;code&gt;st_atime&lt;/code&gt; &lt;/a&gt; 순서로 &lt;code&gt;stat&lt;/code&gt; 구조 의 가장 중요한 (및 휴대용) 멤버를 제공하는 10 개 이상의 정수 튜플로 액세스 할 수도 있습니다 , &lt;a href=&quot;#os.stat_result.st_mtime&quot;&gt; &lt;code&gt;st_mtime&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_ctime&quot;&gt; &lt;code&gt;st_ctime&lt;/code&gt; &lt;/a&gt; 입니다. 일부 구현에 의해 더 많은 항목이 끝에 추가 될 수 있습니다. 이전 Python 버전과의 호환성을 위해 튜플로 &lt;a href=&quot;#os.stat_result&quot;&gt; &lt;code&gt;stat_result&lt;/code&gt; &lt;/a&gt; 에 액세스 하면 항상 정수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="94838bf3b4aae58e91441f1c91f1f6be8d90eaa0" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if a URL appears to point to a local file but the file can&amp;rsquo;t be opened, the URL is re-interpreted using the FTP protocol. This can sometimes cause confusing error messages.</source>
          <target state="translated">이전 버전과의 호환성을 위해 URL이 로컬 파일을 가리키는 것처럼 보이지만 파일을 열 수없는 경우 FTP 프로토콜을 사용하여 URL을 다시 해석합니다. 때때로 혼란스러운 오류 메시지가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7f0d29acf08384be36faa207c5e9370c618e6b" translate="yes" xml:space="preserve">
          <source>For backward compatibility, the return value is also accessible as a tuple of 16 elements.</source>
          <target state="translated">이전 버전과의 호환성을 위해 반환 값은 16 개 요소의 튜플로 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a38050f0e441305ea9ba925711dc3533b5ef150" translate="yes" xml:space="preserve">
          <source>For backward-compatibility reasons, the numeric arguments &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;2&lt;/code&gt; are permitted. They are interpreted as &lt;code&gt;'stdname'&lt;/code&gt;, &lt;code&gt;'calls'&lt;/code&gt;, &lt;code&gt;'time'&lt;/code&gt;, and &lt;code&gt;'cumulative'&lt;/code&gt; respectively. If this old style format (numeric) is used, only one sort key (the numeric key) will be used, and additional arguments will be silently ignored.</source>
          <target state="translated">이전 버전과의 호환성을 위해 숫자 인수 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;2&lt;/code&gt; 가 허용됩니다. 그것들은 각각 &lt;code&gt;'stdname'&lt;/code&gt; , &lt;code&gt;'calls'&lt;/code&gt; , &lt;code&gt;'time'&lt;/code&gt; , &lt;code&gt;'cumulative'&lt;/code&gt; 로 해석됩니다 . 이 이전 스타일 형식 (숫자)을 사용하는 경우 하나의 정렬 키 (숫자 키) 만 사용되며 추가 인수는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0c7787dd6bfccda7252bf5bc8abe1b1d20c558" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, this object also behaves like a five-tuple containing &lt;code&gt;user&lt;/code&gt;, &lt;a href=&quot;#os.system&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;children_user&lt;/code&gt;, &lt;code&gt;children_system&lt;/code&gt;, and &lt;code&gt;elapsed&lt;/code&gt; in that order.</source>
          <target state="translated">이전 버전과의 호환성을 위해이 객체도 포함하는 다섯 튜플처럼 동작 &lt;code&gt;user&lt;/code&gt; , &lt;a href=&quot;#os.system&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;children_user&lt;/code&gt; , &lt;code&gt;children_system&lt;/code&gt; 을 하고, &lt;code&gt;elapsed&lt;/code&gt; 순으로.</target>
        </trans-unit>
        <trans-unit id="e6d662f7f0e619f7fd899a33a726a33b3d3aa333" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, this object is also iterable, behaving like a five-tuple containing &lt;code&gt;sysname&lt;/code&gt;, &lt;code&gt;nodename&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt;, &lt;code&gt;version&lt;/code&gt;, and &lt;code&gt;machine&lt;/code&gt; in that order.</source>
          <target state="translated">이전 버전과의 호환성을 위해이 객체는 반복 가능하며 &lt;code&gt;sysname&lt;/code&gt; , &lt;code&gt;nodename&lt;/code&gt; , &lt;code&gt;release&lt;/code&gt; , &lt;code&gt;version&lt;/code&gt; 및 &lt;code&gt;machine&lt;/code&gt; 을 순서대로 포함하는 5 개의 튜플처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="c076823bfb846c5c4fa30837cd3e7ee0ac98b02c" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Calls the &lt;a href=&quot;#bdb.Bdb.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이전 버전과의 호환성을 위해. &lt;a href=&quot;#bdb.Bdb.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4d4b7c1d4649a90bdbfd3d547d5116f1c45cbb20" translate="yes" xml:space="preserve">
          <source>For best effect, &lt;code&gt;punctuation_chars&lt;/code&gt; should be set in conjunction with &lt;code&gt;posix=True&lt;/code&gt;. (Note that &lt;code&gt;posix=False&lt;/code&gt; is the default for &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">최상의 효과를 얻으 &lt;code&gt;punctuation_chars&lt;/code&gt; 를 &lt;code&gt;posix=True&lt;/code&gt; 와 함께 설정해야합니다 . (참고 &lt;code&gt;posix=False&lt;/code&gt; 기본값입니다 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="09a68d06773736017bdeccd7f26b271b58e54a95" translate="yes" xml:space="preserve">
          <source>For best match with hardware and network realities, the value of &lt;em&gt;bufsize&lt;/em&gt; should be a relatively small power of 2, for example, 4096.</source>
          <target state="translated">하드웨어 및 네트워크 현실과 가장 잘 어울리려면 &lt;em&gt;bufsize&lt;/em&gt; 의 값이 비교적 작은 2의 힘 (예 : 4096)이어야합니다.</target>
        </trans-unit>
        <trans-unit id="06927785954ec46b795462603c00974a450a299b" translate="yes" xml:space="preserve">
          <source>For better multithreading performance, the Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-gil&quot;&gt;GIL&lt;/a&gt; is released for data larger than 2047 bytes at object creation or on update.</source>
          <target state="translated">멀티 스레딩 성능 향상을 위해 Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-gil&quot;&gt;GIL&lt;/a&gt; 은 객체 생성 또는 업데이트시 2047 바이트보다 큰 데이터에 대해 릴리스됩니다.</target>
        </trans-unit>
        <trans-unit id="da8cc65e7c52fba0eeb0fc711cfc59557d96bb18" translate="yes" xml:space="preserve">
          <source>For binary mode, this function is equivalent to the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; constructor: &lt;code&gt;BZ2File(filename, mode, compresslevel=compresslevel)&lt;/code&gt;. In this case, the &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt; and &lt;em&gt;newline&lt;/em&gt; arguments must not be provided.</source>
          <target state="translated">이진 모드의 경우이 함수는 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 생성자 인 &lt;code&gt;BZ2File(filename, mode, compresslevel=compresslevel)&lt;/code&gt; . 이 경우 &lt;em&gt;인코딩&lt;/em&gt; , &lt;em&gt;오류&lt;/em&gt; 및 &lt;em&gt;줄 바꾸기&lt;/em&gt; 인수를 제공하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="016717dd0da4a662468b6aa33cb19230e658d853" translate="yes" xml:space="preserve">
          <source>For binary mode, this function is equivalent to the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; constructor: &lt;code&gt;GzipFile(filename, mode, compresslevel)&lt;/code&gt;. In this case, the &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt; and &lt;em&gt;newline&lt;/em&gt; arguments must not be provided.</source>
          <target state="translated">이진 모드의 경우이 함수는 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 생성자 인 &lt;code&gt;GzipFile(filename, mode, compresslevel)&lt;/code&gt; . 이 경우 &lt;em&gt;인코딩&lt;/em&gt; , &lt;em&gt;오류&lt;/em&gt; 및 &lt;em&gt;줄 바꾸기&lt;/em&gt; 인수를 제공하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7ae5d93f3434b21f6c2561db832de52706b4ce5b" translate="yes" xml:space="preserve">
          <source>For binary mode, this function is equivalent to the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; constructor: &lt;code&gt;LZMAFile(filename, mode, ...)&lt;/code&gt;. In this case, the &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt; and &lt;em&gt;newline&lt;/em&gt; arguments must not be provided.</source>
          <target state="translated">이진 모드의 경우이 함수는 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 생성자 인 &lt;code&gt;LZMAFile(filename, mode, ...)&lt;/code&gt; . 이 경우 &lt;em&gt;인코딩&lt;/em&gt; , &lt;em&gt;오류&lt;/em&gt; 및 &lt;em&gt;줄 바꾸기&lt;/em&gt; 인수를 제공하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7469b7ce9347b3ee71427a4976aa9d8f229bd748" translate="yes" xml:space="preserve">
          <source>For both Unix and Windows, an object can appear in &lt;em&gt;object_list&lt;/em&gt; if it is</source>
          <target state="translated">Unix와 Windows의 경우 &lt;em&gt;object_list에&lt;/em&gt; 객체가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29f254f6cf3b4106b5e9b4c01fbfa8691dcc3d4" translate="yes" xml:space="preserve">
          <source>For both the Unix and Windows versions of the constructor, &lt;em&gt;access&lt;/em&gt; may be specified as an optional keyword parameter. &lt;em&gt;access&lt;/em&gt; accepts one of four values: &lt;code&gt;ACCESS_READ&lt;/code&gt;, &lt;code&gt;ACCESS_WRITE&lt;/code&gt;, or &lt;code&gt;ACCESS_COPY&lt;/code&gt; to specify read-only, write-through or copy-on-write memory respectively, or &lt;code&gt;ACCESS_DEFAULT&lt;/code&gt; to defer to &lt;em&gt;prot&lt;/em&gt;. &lt;em&gt;access&lt;/em&gt; can be used on both Unix and Windows. If &lt;em&gt;access&lt;/em&gt; is not specified, Windows mmap returns a write-through mapping. The initial memory values for all three access types are taken from the specified file. Assignment to an &lt;code&gt;ACCESS_READ&lt;/code&gt; memory map raises a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception. Assignment to an &lt;code&gt;ACCESS_WRITE&lt;/code&gt; memory map affects both memory and the underlying file. Assignment to an &lt;code&gt;ACCESS_COPY&lt;/code&gt; memory map affects memory but does not update the underlying file.</source>
          <target state="translated">생성자의 Unix 및 Windows 버전 모두에 대해 선택적 키워드 매개 변수로 &lt;em&gt;액세스를&lt;/em&gt; 지정할 수 있습니다. &lt;em&gt;access&lt;/em&gt; 는 읽기 전용, write-through 또는 copy-on-write 메모리를 각각 지정하는 &lt;code&gt;ACCESS_READ&lt;/code&gt; , &lt;code&gt;ACCESS_WRITE&lt;/code&gt; 또는 &lt;code&gt;ACCESS_COPY&lt;/code&gt; 값 중 하나 를 받거나 &lt;em&gt;prot&lt;/em&gt; 를 연기하기 위해 &lt;code&gt;ACCESS_DEFAULT&lt;/code&gt; 를 허용 합니다. Unix와 Windows에서 모두 &lt;em&gt;액세스&lt;/em&gt; 할 수 있습니다. 경우 &lt;em&gt;액세스가&lt;/em&gt; 지정되지 않은, 윈도우의 mmap은 쓰기를 통해 매핑을 반환합니다. 세 가지 액세스 유형 모두에 대한 초기 메모리 값은 지정된 파일에서 가져옵니다. &lt;code&gt;ACCESS_READ&lt;/code&gt; 메모리 맵에 할당 하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다&lt;/a&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;예외. &lt;code&gt;ACCESS_WRITE&lt;/code&gt; 메모리 맵에 할당하면 메모리와 기본 파일 모두에 영향을줍니다. &lt;code&gt;ACCESS_COPY&lt;/code&gt; 메모리 맵에 지정하면 메모리에 영향을 주지만 기본 파일은 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b791b625837852700bed40630b7e80160696da6" translate="yes" xml:space="preserve">
          <source>For both use cases, a typical superclass call looks like this:</source>
          <target state="translated">두 경우 모두 일반적인 슈퍼 클래스 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d3e6b2d087066e748150284d960b4cd1ce9e119" translate="yes" xml:space="preserve">
          <source>For cases where you want passive introspection, like documentation tools, this can be inconvenient. &lt;a href=&quot;#inspect.getattr_static&quot;&gt;&lt;code&gt;getattr_static()&lt;/code&gt;&lt;/a&gt; has the same signature as &lt;a href=&quot;functions#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt; but avoids executing code when it fetches attributes.</source>
          <target state="translated">문서화 도구와 같은 수동적 인 검사를 원하는 경우에는 불편할 수 있습니다. &lt;a href=&quot;#inspect.getattr_static&quot;&gt; &lt;code&gt;getattr_static()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;functions#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 과 동일한 서명을 갖지만 속성을 가져올 때 코드 실행을 피합니다.</target>
        </trans-unit>
        <trans-unit id="8ddc27817b8adbae140b3bfe11bf584c974a746a" translate="yes" xml:space="preserve">
          <source>For client-side sockets, the context construction is lazy; if the underlying socket isn&amp;rsquo;t connected yet, the context construction will be performed after &lt;code&gt;connect()&lt;/code&gt; is called on the socket. For server-side sockets, if the socket has no remote peer, it is assumed to be a listening socket, and the server-side SSL wrapping is automatically performed on client connections accepted via the &lt;code&gt;accept()&lt;/code&gt; method. The method may raise &lt;a href=&quot;#ssl.SSLError&quot;&gt;&lt;code&gt;SSLError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클라이언트 측 소켓의 경우 컨텍스트 구성이 게으 릅니다. 기본 소켓이 아직 연결되지 않은 경우 소켓에서 &lt;code&gt;connect()&lt;/code&gt; 가 호출 된 후 컨텍스트 구성이 수행됩니다 . 서버 측 소켓의 경우, 소켓에 원격 피어가없는 경우 청취 소켓 인 것으로 가정하고 &lt;code&gt;accept()&lt;/code&gt; 메소드 를 통해 승인 된 클라이언트 연결에서 서버 측 SSL 랩핑이 자동으로 수행됩니다 . 이 메소드는 &lt;a href=&quot;#ssl.SSLError&quot;&gt; &lt;code&gt;SSLError&lt;/code&gt; 를&lt;/a&gt; 일으킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85865a7d79dbbf1d365d44b34b62ed727d6e7547" translate="yes" xml:space="preserve">
          <source>For code which doesn&amp;rsquo;t use type annotations, the appropriate type argument can be passed explicitly to the decorator itself:</source>
          <target state="translated">타입 주석을 사용하지 않는 코드의 경우 적절한 타입 인수를 데코레이터 자체에 명시 적으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bfd91557db31a101da93b9f75a0634e810c53a1" translate="yes" xml:space="preserve">
          <source>For common and simple use cases, no other functionality is required. There are, however, some dataclass features that require additional per-field information. To satisfy this need for additional information, you can replace the default field value with a call to the provided &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt; function. For example:</source>
          <target state="translated">일반적이고 간단한 사용 사례의 경우 다른 기능이 필요하지 않습니다. 그러나 추가 필드 당 정보가 필요한 일부 데이터 클래스 기능이 있습니다. 추가 정보에 대한 이러한 요구를 충족시키기 위해 기본 필드 값을 제공된 &lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt; 함수에 대한 호출로 바꿀 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87705f106118f19bf390f2a77a7cb271a9b8c917" translate="yes" xml:space="preserve">
          <source>For comparison, &lt;code&gt;split('\n')&lt;/code&gt; gives:</source>
          <target state="translated">비교를 위해 &lt;code&gt;split('\n')&lt;/code&gt; 은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f0cff29498c4ef122a86c33568b064156568a59a" translate="yes" xml:space="preserve">
          <source>For compatibility with this older module, the function &lt;code&gt;Catalog()&lt;/code&gt; is an alias for the &lt;a href=&quot;#gettext.translation&quot;&gt;&lt;code&gt;translation()&lt;/code&gt;&lt;/a&gt; function described above.</source>
          <target state="translated">이 이전 모듈과의 호환성을 위해 &lt;code&gt;Catalog()&lt;/code&gt; &lt;a href=&quot;#gettext.translation&quot;&gt; &lt;code&gt;translation()&lt;/code&gt; &lt;/a&gt; 함수는 위에서 설명한 translation () 함수 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="8dd5c7731e7c03d28553d024eb738419b5d7feec" translate="yes" xml:space="preserve">
          <source>For compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.</source>
          <target state="translated">복합 필드 이름의 경우이 함수는 필드 이름의 첫 번째 구성 요소에 대해서만 호출됩니다. 후속 구성 요소는 일반 특성 및 인덱싱 작업을 통해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1c274cab06d9630687c3dabb1a223e791637c64c" translate="yes" xml:space="preserve">
          <source>For convenience, if the &lt;em&gt;value&lt;/em&gt; passed to &lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt;&lt;code&gt;collapse_rfc2231_value()&lt;/code&gt;&lt;/a&gt; is not a tuple, it should be a string and it is returned unquoted.</source>
          <target state="translated">편의상 &lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt; &lt;code&gt;collapse_rfc2231_value()&lt;/code&gt; &lt;/a&gt; 전달 된 &lt;em&gt;값&lt;/em&gt; 이 튜플이 아닌 경우 문자열이어야하며 따옴표가없는 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="de926a3a0ae98ea1fe4e0f3b5685a3731bae1603" translate="yes" xml:space="preserve">
          <source>For convenience, you want the &lt;code&gt;_()&lt;/code&gt; function to be installed in Python&amp;rsquo;s builtins namespace, so it is easily accessible in all modules of your application.</source>
          <target state="translated">편의상 &lt;code&gt;_()&lt;/code&gt; 함수를 Python의 내장 네임 스페이스에 설치하면 응용 프로그램의 모든 모듈에서 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="210ca2c9386211164bf808be67ab50aac45b5cfd" translate="yes" xml:space="preserve">
          <source>For deep customizations of import, you typically want to implement an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-importer&quot;&gt;importer&lt;/a&gt;. This means managing both the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; side of things. For finders there are two flavours to choose from depending on your needs: a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-meta-path-finder&quot;&gt;meta path finder&lt;/a&gt; or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry-finder&quot;&gt;path entry finder&lt;/a&gt;. The former is what you would put on &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt; while the latter is what you create using a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry-hook&quot;&gt;path entry hook&lt;/a&gt; on &lt;a href=&quot;sys#sys.path_hooks&quot;&gt;&lt;code&gt;sys.path_hooks&lt;/code&gt;&lt;/a&gt; which works with &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; entries to potentially create a finder. This example will show you how to register your own importers so that import will use them (for creating an importer for yourself, read the documentation for the appropriate classes defined within this package):</source>
          <target state="translated">수입의 깊은 사용자 정의의 경우, 일반적으로 구현하려는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-importer&quot;&gt;수입을&lt;/a&gt; . 이는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;파인더&lt;/a&gt; 와 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 측면을 모두 관리하는 것을 의미 합니다. 파인더의 경우 필요에 따라 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-meta-path-finder&quot;&gt;메타 경로 파인더&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry-finder&quot;&gt;경로 항목 파인더&lt;/a&gt; 두 가지를 선택할 수 있습니다 . 전자는 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; 에&lt;/a&gt; 배치 하고 후자는 &lt;a href=&quot;sys#sys.path_hooks&quot;&gt; &lt;code&gt;sys.path_hooks&lt;/code&gt; &lt;/a&gt; 와 작동하는 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; _hooks&lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry-hook&quot;&gt;경로 입력 후크&lt;/a&gt; 를 사용하여 생성하는 것입니다.잠재적으로 파인더를 작성하기위한 항목. 이 예제는 수입업자가 수입업자를 사용하도록 수입업자를 등록하는 방법을 보여줍니다 (수입업자를 직접 만들려면이 패키지에 정의 된 적절한 클래스의 문서를 읽으십시오).</target>
        </trans-unit>
        <trans-unit id="0c7f0d88ba41bf3eb9635ed30d7c7babf6caf663" translate="yes" xml:space="preserve">
          <source>For each argument, if the value is not found, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">각 인수에 대해 값을 찾을 수 없으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ac0a10e6ce55d9d18d13c0fc23d96ba811fa6c93" translate="yes" xml:space="preserve">
          <source>For each character, there are two normal forms: normal form C and normal form D. Normal form D (NFD) is also known as canonical decomposition, and translates each character into its decomposed form. Normal form C (NFC) first applies a canonical decomposition, then composes pre-combined characters again.</source>
          <target state="translated">각 문자마다 정규 형식 C와 일반 형식 D의 두 가지 정규 형식이 있습니다. 정규 형식 D (NFD)는 정식 분해라고도하며 각 문자를 분해 형식으로 변환합니다. 일반 형식 C (NFC)는 먼저 표준 분해를 적용한 다음 사전 조합 된 문자를 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5fd45e0da93f8a3a502662f383317adb8f1a3088" translate="yes" xml:space="preserve">
          <source>For each item in the keyword argument dictionary &lt;em&gt;_params&lt;/em&gt;, the key is taken as the parameter name, with underscores converted to dashes (since dashes are illegal in Python identifiers). Normally, the parameter will be added as &lt;code&gt;key=&quot;value&quot;&lt;/code&gt; unless the value is &lt;code&gt;None&lt;/code&gt;, in which case only the key will be added.</source>
          <target state="translated">키워드 인수 사전 &lt;em&gt;_params&lt;/em&gt; 의 각 항목에 대해 키는 매개 변수 이름으로 사용되며 밑줄은 대시로 변환됩니다 (대시 &lt;em&gt;문자&lt;/em&gt; 는 파이썬 식별자에서 &lt;em&gt;유효하지&lt;/em&gt; 않기 때문에). 일반적으로 값이 &lt;code&gt;None&lt;/code&gt; 이 아니면 매개 변수는 &lt;code&gt;key=&quot;value&quot;&lt;/code&gt; 로 추가됩니다.이 경우 키만 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d736bcd37b51fd426b74cb1fc89bc382bb0f2684" translate="yes" xml:space="preserve">
          <source>For each item in the keyword argument dictionary &lt;em&gt;_params&lt;/em&gt;, the key is taken as the parameter name, with underscores converted to dashes (since dashes are illegal in Python identifiers). Normally, the parameter will be added as &lt;code&gt;key=&quot;value&quot;&lt;/code&gt; unless the value is &lt;code&gt;None&lt;/code&gt;, in which case only the key will be added. If the value contains non-ASCII characters, it can be specified as a three tuple in the format &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt;, where &lt;code&gt;CHARSET&lt;/code&gt; is a string naming the charset to be used to encode the value, &lt;code&gt;LANGUAGE&lt;/code&gt; can usually be set to &lt;code&gt;None&lt;/code&gt; or the empty string (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; for other possibilities), and &lt;code&gt;VALUE&lt;/code&gt; is the string value containing non-ASCII code points. If a three tuple is not passed and the value contains non-ASCII characters, it is automatically encoded in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; format using a &lt;code&gt;CHARSET&lt;/code&gt; of &lt;code&gt;utf-8&lt;/code&gt; and a &lt;code&gt;LANGUAGE&lt;/code&gt; of &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">키워드 인수 사전 &lt;em&gt;_params&lt;/em&gt; 의 각 항목에 대해 키는 매개 변수 이름으로 사용되며 밑줄은 대시로 변환됩니다 (대표는 파이썬 식별자에서 &lt;em&gt;유효하지&lt;/em&gt; 않기 때문에). 일반적으로 값이 &lt;code&gt;None&lt;/code&gt; 이 아니면 매개 변수는 &lt;code&gt;key=&quot;value&quot;&lt;/code&gt; 로 추가됩니다.이 경우 키만 추가됩니다. 값에 ASCII가 아닌 문자가 포함 된 경우 &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt; 형식으로 3 개의 튜플로 지정할 수 있습니다 . 여기서 &lt;code&gt;CHARSET&lt;/code&gt; 은 값을 인코딩하는 데 사용되는 문자 세트의 이름을 지정하는 문자열이며 &lt;code&gt;LANGUAGE&lt;/code&gt; 는 일반적으로 &lt;code&gt;None&lt;/code&gt; 또는 빈 문자열 ( 다른 가능성 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 참조 ) 및 &lt;code&gt;VALUE&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt;비 ASCII 코드 포인트를 포함하는 문자열 값입니다. 세 튜플이 통과하고 값이 비 ASCII 문자가 포함되어 있지 않은 경우, 자동으로 인코딩 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 사용하여 형식 &lt;code&gt;CHARSET&lt;/code&gt; 의 &lt;code&gt;utf-8&lt;/code&gt; 과 &lt;code&gt;LANGUAGE&lt;/code&gt; 의 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="056b6b17fe21a908443c2aef27973cb1a8a225e3" translate="yes" xml:space="preserve">
          <source>For each of the two dimensions, the environment variable, &lt;code&gt;COLUMNS&lt;/code&gt; and &lt;code&gt;LINES&lt;/code&gt; respectively, is checked. If the variable is defined and the value is a positive integer, it is used.</source>
          <target state="translated">두 가지 차원 각각에 대해 환경 변수 &lt;code&gt;COLUMNS&lt;/code&gt; 및 &lt;code&gt;LINES&lt;/code&gt; 가 각각 확인됩니다. 변수가 정의되고 값이 양의 정수이면 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="322ab30d52718f1547b8e17f1897a238688c4ba6" translate="yes" xml:space="preserve">
          <source>For each signal there is a flag and a trap enabler. When a signal is encountered, its flag is set to one, then, if the trap enabler is set to one, an exception is raised. Flags are sticky, so the user needs to reset them before monitoring a calculation.</source>
          <target state="translated">각 신호에는 플래그와 트랩 인 에이 블러가 있습니다. 신호가 발생하면 플래그가 1로 설정되고, 트랩 작동기가 1로 설정되면 예외가 발생합니다. 플래그는 고정되어 있으므로 사용자는 계산을 모니터링하기 전에 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="06f9e39145b4348109479e7f9f896d505ac8e519" translate="yes" xml:space="preserve">
          <source>For encoding, &lt;em&gt;error_handler&lt;/em&gt; will be called with a &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt;&lt;code&gt;UnicodeEncodeError&lt;/code&gt;&lt;/a&gt; instance, which contains information about the location of the error. The error handler must either raise this or a different exception, or return a tuple with a replacement for the unencodable part of the input and a position where encoding should continue. The replacement may be either &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. If the replacement is bytes, the encoder will simply copy them into the output buffer. If the replacement is a string, the encoder will encode the replacement. Encoding continues on original input at the specified position. Negative position values will be treated as being relative to the end of the input string. If the resulting position is out of bound an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">인코딩의 경우 &lt;em&gt;error_handler&lt;/em&gt; 는 오류 위치에 대한 정보가 포함 된 &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt; &lt;code&gt;UnicodeEncodeError&lt;/code&gt; &lt;/a&gt; 인스턴스 와 함께 호출됩니다 . 오류 처리기는이 예외 또는 다른 예외를 발생 시키거나 입력 할 수없는 입력 부분과 인코딩이 계속되는 위치를 대체하여 튜플을 반환해야합니다. 대체는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 . 대체가 바이트 인 경우 인코더는이를 단순히 출력 버퍼에 복사합니다. 교체가 문자열 인 경우 인코더는 교체를 인코딩합니다. 지정된 위치에서 원래 입력으로 인코딩이 계속됩니다. 음수 위치 값은 입력 문자열의 끝을 기준으로 처리됩니다. 결과 위치가 경계를 벗어난 경우&lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="21600918467446226ee8a32f480178bbdbb3fcd4" translate="yes" xml:space="preserve">
          <source>For ensuring that the mock objects in your tests have the same api as the objects they are replacing, you can use &lt;a href=&quot;#auto-speccing&quot;&gt;auto-speccing&lt;/a&gt;. Auto-speccing can be done through the &lt;em&gt;autospec&lt;/em&gt; argument to patch, or the &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt;&lt;code&gt;create_autospec()&lt;/code&gt;&lt;/a&gt; function. Auto-speccing creates mock objects that have the same attributes and methods as the objects they are replacing, and any functions and methods (including constructors) have the same call signature as the real object.</source>
          <target state="translated">테스트의 모의 객체가 대체하는 객체와 동일한 API를 &lt;a href=&quot;#auto-speccing&quot;&gt;갖도록 자동 지정&lt;/a&gt; 을 사용할 수 있습니다 . 자동 speccing는 통해 수행 할 수 있습니다 &lt;em&gt;autospec&lt;/em&gt; 패치에 인수, 또는 &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt; &lt;code&gt;create_autospec()&lt;/code&gt; &lt;/a&gt; 함수입니다. 자동 지정은 대체하는 객체와 동일한 속성 및 메소드를 갖는 모의 객체를 생성하며, 생성자를 포함한 모든 함수 및 메소드는 실제 객체와 동일한 호출 서명을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="15fc0d7566d96f6001912c52d120cbb3c0026454" translate="yes" xml:space="preserve">
          <source>For equality comparison (&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;), both the IP address and network must be the same for the objects to be equal. An interface will not compare equal to any address or network object.</source>
          <target state="translated">동등 비교 ( &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; )의 경우, 오브젝트가 동일하도록 IP 주소와 네트워크가 동일해야합니다. 인터페이스는 주소 또는 네트워크 객체와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="9f92850155d4633eac2a36ebb33b8f03c14d5123" translate="yes" xml:space="preserve">
          <source>For example usage, see the implementation of the &lt;a href=&quot;test#module-test&quot;&gt;&lt;code&gt;test()&lt;/code&gt;&lt;/a&gt; function invocation in the &lt;a href=&quot;#module-http.server&quot;&gt;&lt;code&gt;http.server&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">사용 예 는 &lt;a href=&quot;#module-http.server&quot;&gt; &lt;code&gt;http.server&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;a href=&quot;test#module-test&quot;&gt; &lt;code&gt;test()&lt;/code&gt; &lt;/a&gt; 함수 호출 구현을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="6cd51af621b973c244416c286e704a84b26141f1" translate="yes" xml:space="preserve">
          <source>For example, 2004 begins on a Thursday, so the first week of ISO year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004:</source>
          <target state="translated">예를 들어 2004 년은 목요일에 시작되므로 2004 년 ISO 연도의 첫 번째주는 2003 년 12 월 29 일 월요일에 시작하여 2004 년 1 월 4 일 일요일에 끝납니다.</target>
        </trans-unit>
        <trans-unit id="399622d81e44a5a0690710d1c52927972596121e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-k foo&lt;/code&gt; matches &lt;code&gt;foo_tests.SomeTest.test_something&lt;/code&gt;, &lt;code&gt;bar_tests.SomeTest.test_foo&lt;/code&gt;, but not &lt;code&gt;bar_tests.FooTest.test_something&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;-k foo&lt;/code&gt; 일치 &lt;code&gt;foo_tests.SomeTest.test_something&lt;/code&gt; , &lt;code&gt;bar_tests.SomeTest.test_foo&lt;/code&gt; 있지만 &lt;code&gt;bar_tests.FooTest.test_something&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0d14f109212981d9e9018a7e899a21c38af527e7" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;cmpfiles('a', 'b', ['c', 'd/e'])&lt;/code&gt; will compare &lt;code&gt;a/c&lt;/code&gt; with &lt;code&gt;b/c&lt;/code&gt; and &lt;code&gt;a/d/e&lt;/code&gt; with &lt;code&gt;b/d/e&lt;/code&gt;. &lt;code&gt;'c'&lt;/code&gt; and &lt;code&gt;'d/e'&lt;/code&gt; will each be in one of the three returned lists.</source>
          <target state="translated">예를 들어 &lt;code&gt;cmpfiles('a', 'b', ['c', 'd/e'])&lt;/code&gt; 는 &lt;code&gt;a/c&lt;/code&gt; 와 &lt;code&gt;b/c&lt;/code&gt; 를 비교 하고 &lt;code&gt;a/d/e&lt;/code&gt; 와 &lt;code&gt;b/d/e&lt;/code&gt; 를 비교 합니다. &lt;code&gt;'c'&lt;/code&gt; 와 &lt;code&gt;'d/e'&lt;/code&gt; 는 각각 3 개의 반환 된 목록 중 하나에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a95470c1be0b3663fdee2e3d3b9777cc1e0d9fa2" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;signal.pthread_sigmask(signal.SIG_BLOCK, [])&lt;/code&gt; reads the signal mask of the calling thread.</source>
          <target state="translated">예를 들어 &lt;code&gt;signal.pthread_sigmask(signal.SIG_BLOCK, [])&lt;/code&gt; 는 호출 스레드의 신호 마스크를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f0f5080e6265a4c4411bd9b24c300325fec45e78" translate="yes" xml:space="preserve">
          <source>For example, CD quality audio has a sample size of two bytes (16 bits), uses two channels (stereo) and has a frame rate of 44,100 frames/second. This gives a frame size of 4 bytes (2*2), and a second&amp;rsquo;s worth occupies 2*2*44100 bytes (176,400 bytes).</source>
          <target state="translated">예를 들어, CD 품질 오디오의 샘플 크기는 2 바이트 (16 비트)이고 2 채널 (스테레오)을 사용하며 초당 프레임 속도는 44,100 프레임입니다. 이것은 4 바이트 (2 * 2)의 프레임 크기를 제공하고 초의 가치는 2 * 2 * 44100 바이트 (176,400 바이트)를 차지합니다.</target>
        </trans-unit>
        <trans-unit id="5704afb176cb5333d5bd0ec1e89e920326a56e42" translate="yes" xml:space="preserve">
          <source>For example, a group of files can be opened as an &amp;ldquo;all or nothing&amp;rdquo; operation as follows:</source>
          <target state="translated">예를 들어, 파일 그룹을 다음과 같이 &quot;전부 또는 전무&quot;작업으로 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e2f1b9586e1e059827e751c317d7ee5e2879b3" translate="yes" xml:space="preserve">
          <source>For example, a set of files may easily be handled in a single with statement as follows:</source>
          <target state="translated">예를 들어, 파일 세트는 다음과 같이 단일 with 문으로 쉽게 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70d481802ecd969c892c69fa7f05b8bba9e4b621" translate="yes" xml:space="preserve">
          <source>For example, a subclass of &lt;code&gt;DictConfigurator&lt;/code&gt; could call &lt;code&gt;DictConfigurator.__init__()&lt;/code&gt; in its own &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;, then set up custom prefixes which would be usable in the subsequent &lt;code&gt;configure()&lt;/code&gt; call. &lt;code&gt;dictConfigClass&lt;/code&gt; would be bound to this new subclass, and then &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; could be called exactly as in the default, uncustomized state.</source>
          <target state="translated">예를 들어,의 서브 클래스 &lt;code&gt;DictConfigurator&lt;/code&gt; 가 호출 할 수 &lt;code&gt;DictConfigurator.__init__()&lt;/code&gt; 자신의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; , 그 이후에 가능한 것입니다 사용자 정의 접두사 설정 &lt;code&gt;configure()&lt;/code&gt; 호출. &lt;code&gt;dictConfigClass&lt;/code&gt; 는이 새 서브 클래스에 바인드 된 후 사용자 정의되지 않은 기본 상태에서와 동일하게 &lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f511873d3631a9f41e0087f05beaf56c5c7a1720" translate="yes" xml:space="preserve">
          <source>For example, consider a directory containing the following files: &lt;code&gt;1.gif&lt;/code&gt;, &lt;code&gt;2.txt&lt;/code&gt;, &lt;code&gt;card.gif&lt;/code&gt; and a subdirectory &lt;code&gt;sub&lt;/code&gt; which contains only the file &lt;code&gt;3.txt&lt;/code&gt;. &lt;a href=&quot;#module-glob&quot;&gt;&lt;code&gt;glob()&lt;/code&gt;&lt;/a&gt; will produce the following results. Notice how any leading components of the path are preserved.</source>
          <target state="translated">예를 들어, 다음과 같은 파일이 들어있는 디렉토리 고려 &lt;code&gt;1.gif&lt;/code&gt; , &lt;code&gt;2.txt&lt;/code&gt; , &lt;code&gt;card.gif&lt;/code&gt; 및 하위 디렉토리 &lt;code&gt;sub&lt;/code&gt; 에만 파일이 들어 &lt;code&gt;3.txt&lt;/code&gt; 를 . &lt;a href=&quot;#module-glob&quot;&gt; &lt;code&gt;glob()&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 결과를 생성합니다. 경로의 주요 구성 요소가 어떻게 보존되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a8116b8e84beaa829f95a74354e47e686f4f65c2" translate="yes" xml:space="preserve">
          <source>For example, given &lt;a href=&quot;https://blog.prepscholar.com/sat-standard-deviation&quot;&gt;historical data for SAT exams&lt;/a&gt; showing that scores are normally distributed with a mean of 1060 and a standard deviation of 192, determine the percentage of students with test scores between 1100 and 1200, after rounding to the nearest whole number:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;https://blog.prepscholar.com/sat-standard-deviation&quot;&gt;SAT 시험의 과거 데이터에서&lt;/a&gt; 점수가 보통 평균 1060이고 표준 편차가 192로 분포되어 있음을 보여 주면 가장 가까운 정수로 반올림 한 후 시험 점수가 1100에서 1200 사이 인 학생의 비율을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="f059697aa8708c124c5ca5ed69598445d650d373" translate="yes" xml:space="preserve">
          <source>For example, here is how you would use the &lt;a href=&quot;smtplib#smtplib.SMTP&quot;&gt;&lt;code&gt;smtplib.SMTP&lt;/code&gt;&lt;/a&gt; class to create a trusted, secure connection to a SMTP server:</source>
          <target state="translated">예를 들어 다음은 &lt;a href=&quot;smtplib#smtplib.SMTP&quot;&gt; &lt;code&gt;smtplib.SMTP&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 SMTP 서버에 대한 신뢰할 수있는 보안 연결을 만드는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4cd64048d86f14def679c676cd5c8b195e60a3d7" translate="yes" xml:space="preserve">
          <source>For example, if &lt;a href=&quot;stdtypes#class.__mro__&quot;&gt;&lt;code&gt;__mro__&lt;/code&gt;&lt;/a&gt; of &lt;em&gt;object-or-type&lt;/em&gt; is &lt;code&gt;D -&amp;gt; B -&amp;gt; C -&amp;gt; A -&amp;gt; object&lt;/code&gt; and the value of &lt;em&gt;type&lt;/em&gt; is &lt;code&gt;B&lt;/code&gt;, then &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; searches &lt;code&gt;C -&amp;gt; A -&amp;gt; object&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;stdtypes#class.__mro__&quot;&gt; &lt;code&gt;__mro__&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;개체 또는 유형이&lt;/em&gt; 있다 &lt;code&gt;D -&amp;gt; B -&amp;gt; C -&amp;gt; A -&amp;gt; object&lt;/code&gt; 및 값 &lt;em&gt;유형&lt;/em&gt; 인 &lt;code&gt;B&lt;/code&gt; , 다음 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 검색 &lt;code&gt;C -&amp;gt; A -&amp;gt; object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc7ebb76fef1bf5301bb1689de9385336d50d062" translate="yes" xml:space="preserve">
          <source>For example, if &lt;em&gt;namespace_separator&lt;/em&gt; is set to a space character (&lt;code&gt;' '&lt;/code&gt;) and the following document is parsed:</source>
          <target state="translated">예를 들어 &lt;em&gt;namespace_separator&lt;/em&gt; 가 공백 문자 ( &lt;code&gt;' '&lt;/code&gt; )로 설정되고 다음 문서가 구문 분석되는 경우 :</target>
        </trans-unit>
        <trans-unit id="61bccf6891322558e7f0a44662ff24780b7e5f8f" translate="yes" xml:space="preserve">
          <source>For example, if you have a module &lt;code&gt;SampleTests&lt;/code&gt; containing a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt;-derived class &lt;code&gt;SampleTestCase&lt;/code&gt; with three test methods (&lt;code&gt;test_one()&lt;/code&gt;, &lt;code&gt;test_two()&lt;/code&gt;, and &lt;code&gt;test_three()&lt;/code&gt;), the specifier &lt;code&gt;'SampleTests.SampleTestCase'&lt;/code&gt; would cause this method to return a suite which will run all three test methods. Using the specifier &lt;code&gt;'SampleTests.SampleTestCase.test_two'&lt;/code&gt; would cause it to return a test suite which will run only the &lt;code&gt;test_two()&lt;/code&gt; test method. The specifier can refer to modules and packages which have not been imported; they will be imported as a side-effect.</source>
          <target state="translated">예를 들어, 세 가지 테스트 메소드 ( &lt;code&gt;test_one()&lt;/code&gt; , &lt;code&gt;test_two()&lt;/code&gt; 및 &lt;code&gt;test_three()&lt;/code&gt; ) 가있는 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 파생 클래스 &lt;code&gt;SampleTestCase&lt;/code&gt; 를 포함 하는 모듈 &lt;code&gt;SampleTests&lt;/code&gt; 가있는 경우 지정자 &lt;code&gt;'SampleTests.SampleTestCase'&lt;/code&gt; 는이 메소드가 스위트를 리턴하게합니다. 세 가지 테스트 방법을 모두 실행합니다. 지정자 &lt;code&gt;'SampleTests.SampleTestCase.test_two'&lt;/code&gt; 를 사용하면 &lt;code&gt;test_two()&lt;/code&gt; 테스트 메소드 만 실행하는 테스트 스위트가 리턴됩니다 . 지정자는 가져 오지 않은 모듈 및 패키지를 참조 할 수 있습니다. 그들은 부작용으로 수입 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="d96a9ad58f887553f3d83a9670b407c13d2d7fee" translate="yes" xml:space="preserve">
          <source>For example, if you have a number of large binary image objects, you may wish to associate a name with each. If you used a Python dictionary to map names to images, or images to names, the image objects would remain alive just because they appeared as values or keys in the dictionaries. The &lt;a href=&quot;#weakref.WeakKeyDictionary&quot;&gt;&lt;code&gt;WeakKeyDictionary&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#weakref.WeakValueDictionary&quot;&gt;&lt;code&gt;WeakValueDictionary&lt;/code&gt;&lt;/a&gt; classes supplied by the &lt;a href=&quot;#module-weakref&quot;&gt;&lt;code&gt;weakref&lt;/code&gt;&lt;/a&gt; module are an alternative, using weak references to construct mappings that don&amp;rsquo;t keep objects alive solely because they appear in the mapping objects. If, for example, an image object is a value in a &lt;a href=&quot;#weakref.WeakValueDictionary&quot;&gt;&lt;code&gt;WeakValueDictionary&lt;/code&gt;&lt;/a&gt;, then when the last remaining references to that image object are the weak references held by weak mappings, garbage collection can reclaim the object, and its corresponding entries in weak mappings are simply deleted.</source>
          <target state="translated">예를 들어, 큰 이진 이미지 객체가 여러 개인 경우 이름을 각 객체와 연결할 수 있습니다. Python 사전을 사용하여 이름을 이미지에 매핑하거나 이미지를 이름에 매핑하는 경우 이미지 개체는 사전에 값 또는 키로 표시 되었기 때문에 활성 상태로 유지됩니다. &lt;a href=&quot;#weakref.WeakKeyDictionary&quot;&gt; &lt;code&gt;WeakKeyDictionary&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#weakref.WeakValueDictionary&quot;&gt; &lt;code&gt;WeakValueDictionary&lt;/code&gt; &lt;/a&gt; 에 의해 제공되는 클래스 &lt;a href=&quot;#module-weakref&quot;&gt; &lt;code&gt;weakref&lt;/code&gt; &lt;/a&gt; 모듈은 살아 전적으로 그들이 매핑 객체에 표시하기 때문에 개체를 유지하지 않는 매핑을 구성하기 위해 약한 참조를 사용하여, 대안입니다. 예를 들어 이미지 객체가 &lt;a href=&quot;#weakref.WeakValueDictionary&quot;&gt; &lt;code&gt;WeakValueDictionary&lt;/code&gt; &lt;/a&gt; 의 값인 경우그런 다음 해당 이미지 객체에 대한 마지막 남은 참조가 약한 매핑이 보유한 약한 참조 인 경우 가비지 수집은 객체를 회수 할 수 있으며 약한 매핑의 해당 항목은 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f8ddfc4247d70e8198d393848e8a880bb9e365df" translate="yes" xml:space="preserve">
          <source>For example, if you want to pass several items to the constructor, but only want one of them to be the value:</source>
          <target state="translated">예를 들어, 여러 항목을 생성자에 전달하고 싶지만 그 중 하나만 값이되도록하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f2d533d473fe1f989a25757c7b31086d2cd9c1ac" translate="yes" xml:space="preserve">
          <source>For example, it is sometimes useful to wrap functions or groups of statements with a logger that can track the time of entry and time of exit. Rather than writing both a function decorator and a context manager for the task, inheriting from &lt;a href=&quot;#contextlib.ContextDecorator&quot;&gt;&lt;code&gt;ContextDecorator&lt;/code&gt;&lt;/a&gt; provides both capabilities in a single definition:</source>
          <target state="translated">예를 들어, 입력 시간 및 종료 시간을 추적 할 수있는 로거로 함수 또는 명령문 그룹을 랩핑하는 것이 유용한 경우가 있습니다. 작업에 대한 함수 데코레이터와 컨텍스트 관리자를 모두 작성하는 대신 &lt;a href=&quot;#contextlib.ContextDecorator&quot;&gt; &lt;code&gt;ContextDecorator&lt;/code&gt; &lt;/a&gt; 에서 상속 하면 두 가지 기능을 단일 정의로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66a503d37db3c1946c897c9a00ca7f6c3c4c2802" translate="yes" xml:space="preserve">
          <source>For example, restart the Shell and enter &lt;code&gt;itertools.count(&lt;/code&gt;. A calltip appears because Idle imports itertools into the user process for its own use. (This could change.) Enter &lt;code&gt;turtle.write(&lt;/code&gt; and nothing appears. Idle does not import turtle. The menu or shortcut do nothing either. Enter &lt;code&gt;import turtle&lt;/code&gt; and then &lt;code&gt;turtle.write(&lt;/code&gt; will work.</source>
          <target state="translated">예를 들어, 셸을 다시 시작하고 입력 &lt;code&gt;itertools.count(&lt;/code&gt; . calltip가 나타납니다 때문에 자신의 사용을 위해 사용자 프로세스에 유휴 수입 itertools. (이 변경 될 수 있습니다.)를 입력 &lt;code&gt;turtle.write(&lt;/code&gt; 및 아무것도 나타납니다. 유휴 수입 거북이를하지 않습니다. 메뉴 또는 바로 가기는 아무 것도 수행하지 않습니다. &lt;code&gt;import turtle&lt;/code&gt; 을 입력 하면 &lt;code&gt;turtle.write(&lt;/code&gt; 가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a2f3276b5fec797554722a3f1fcfe9772ea5689b" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;sys.prefix&lt;/code&gt; and &lt;code&gt;sys.exec_prefix&lt;/code&gt; are set to &lt;code&gt;/usr/local&lt;/code&gt;. The Python X.Y library is then installed in &lt;code&gt;/usr/local/lib/python&lt;em&gt;X.Y&lt;/em&gt;&lt;/code&gt;. Suppose this has a subdirectory &lt;code&gt;/usr/local/lib/python&lt;em&gt;X.Y&lt;/em&gt;/site-packages&lt;/code&gt; with three subsubdirectories, &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;spam&lt;/code&gt;, and two path configuration files, &lt;code&gt;foo.pth&lt;/code&gt; and &lt;code&gt;bar.pth&lt;/code&gt;. Assume &lt;code&gt;foo.pth&lt;/code&gt; contains the following:</source>
          <target state="translated">예를 들어 &lt;code&gt;sys.prefix&lt;/code&gt; 및 &lt;code&gt;sys.exec_prefix&lt;/code&gt; 가 &lt;code&gt;/usr/local&lt;/code&gt; 로 설정되어 있다고 가정 하십시오 . 그런 다음 Python XY 라이브러리가 &lt;code&gt;/usr/local/lib/python&lt;em&gt;X.Y&lt;/em&gt;&lt;/code&gt; 됩니다. 여기에 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;spam&lt;/code&gt; 이라는 세 개의 서브 &lt;code&gt;foo.pth&lt;/code&gt; 및 &lt;code&gt;bar.pth&lt;/code&gt; 및 bar.pth 라는 두 개의 경로 구성 파일 이있는 서브 디렉토리 &lt;code&gt;/usr/local/lib/python&lt;em&gt;X.Y&lt;/em&gt;/site-packages&lt;/code&gt; 가 있다고 가정하십시오 . &lt;code&gt;foo.pth&lt;/code&gt; 에 다음이 포함되어 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="160f54e15b188263020cd678b4cbe6d3dca29d19" translate="yes" xml:space="preserve">
          <source>For example, suppose a field will be initialized from a database, if a value is not provided when creating the class:</source>
          <target state="translated">예를 들어 클래스를 만들 때 값이 제공되지 않으면 데이터베이스에서 필드가 초기화된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2a51dc8b68006b3628c501bc888381f13603f3d6" translate="yes" xml:space="preserve">
          <source>For example, the comment &lt;code&gt;&amp;lt;!-- comment --&amp;gt;&lt;/code&gt; will cause this method to be called with the argument &lt;code&gt;' comment '&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 주석 &lt;code&gt;&amp;lt;!-- comment --&amp;gt;&lt;/code&gt; 는이 메소드가 &lt;code&gt;' comment '&lt;/code&gt; 인수와 함께 호출되게합니다 .</target>
        </trans-unit>
        <trans-unit id="276a7355d8a4db76578148be24d829dc758d2a8b" translate="yes" xml:space="preserve">
          <source>For example, the configuration specified above with basic interpolation, would look like this with extended interpolation:</source>
          <target state="translated">예를 들어 기본 보간으로 위에서 지정한 구성은 확장 보간으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01938a5c60c9e8969e85c6eb8d12360855033dd2" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;em&gt;address&lt;/em&gt; specifications are equivalent: &lt;code&gt;192.168.1.0/24&lt;/code&gt;, &lt;code&gt;192.168.1.0/255.255.255.0&lt;/code&gt; and &lt;code&gt;192.168.1.0/0.0.0.255&lt;/code&gt;.</source>
          <target state="translated">예를 들어 다음 &lt;em&gt;주소&lt;/em&gt; 사양은 &lt;code&gt;192.168.1.0/24&lt;/code&gt; , &lt;code&gt;192.168.1.0/255.255.255.0&lt;/code&gt; 및 &lt;code&gt;192.168.1.0/0.0.0.255&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9ffd76d4d6a2b6fecddb9a2b16cb189c0703deb8" translate="yes" xml:space="preserve">
          <source>For example, the following calls all create instances that connect to the server at the same host and port:</source>
          <target state="translated">예를 들어 다음 호출은 모두 동일한 호스트 및 포트에서 서버에 연결하는 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6485b8e2ead7470cce6b6fb9ebac6270d6c44f71" translate="yes" xml:space="preserve">
          <source>For example, the following code attempts to get the underlying socket object of the transport:</source>
          <target state="translated">예를 들어 다음 코드는 전송의 기본 소켓 객체를 가져 오려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="926dd3d39286ea9ea8589b6ed6457274558a4a7f" translate="yes" xml:space="preserve">
          <source>For example, the following code sets the current decimal precision to 42 places, performs a calculation, and then automatically restores the previous context:</source>
          <target state="translated">예를 들어 다음 코드는 현재 10 진수 정밀도를 42 자리로 설정하고 계산을 수행 한 다음 이전 컨텍스트를 자동으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="a2a9900581cad4336c270134295c4643fc13d30c" translate="yes" xml:space="preserve">
          <source>For example, the following test:</source>
          <target state="translated">예를 들어 다음 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f57d48010d7b1e551e32df4d311a231a6c7759da" translate="yes" xml:space="preserve">
          <source>For example, the output of &lt;a href=&quot;functions#help&quot;&gt;&lt;code&gt;help()&lt;/code&gt;&lt;/a&gt; normally is sent to &lt;em&gt;sys.stdout&lt;/em&gt;. You can capture that output in a string by redirecting the output to an &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;functions#help&quot;&gt; &lt;code&gt;help()&lt;/code&gt; &lt;/a&gt; 의 출력은 일반적으로 &lt;em&gt;sys.stdout&lt;/em&gt; 으로 전송됩니다 . 출력을 &lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 객체 로 리디렉션하여 해당 출력을 문자열로 캡처 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afad8674d1b9f21e340e687b0cc6f14661e4f3de" translate="yes" xml:space="preserve">
          <source>For example, the statement &lt;code&gt;import spam&lt;/code&gt; results in bytecode resembling the following code:</source>
          <target state="translated">예를 들어 &lt;code&gt;import spam&lt;/code&gt; 문 은 다음 코드와 유사한 바이트 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9d664aefd1120a74c2a2186e509cdcbbe1065acb" translate="yes" xml:space="preserve">
          <source>For example, this converts &lt;code&gt;Decimal('123E+1')&lt;/code&gt; to &lt;code&gt;Decimal('1.23E+3')&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;Decimal('123E+1')&lt;/code&gt; 을 &lt;code&gt;Decimal('1.23E+3')&lt;/code&gt; 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="03dfeb0eabcdcb6bb3dc21ab58b033a4c633e25f" translate="yes" xml:space="preserve">
          <source>For example, this feature is used by the &lt;a href=&quot;#unittest.TextTestRunner&quot;&gt;&lt;code&gt;TextTestRunner&lt;/code&gt;&lt;/a&gt; class to stop the test framework when the user signals an interrupt from the keyboard. Interactive tools which provide &lt;code&gt;TestRunner&lt;/code&gt; implementations can use this in a similar manner.</source>
          <target state="translated">예를 들어,이 기능은 &lt;a href=&quot;#unittest.TextTestRunner&quot;&gt; &lt;code&gt;TextTestRunner&lt;/code&gt; &lt;/a&gt; 클래스에서 사용자가 키보드에서 인터럽트 신호를 보낼 때 테스트 프레임 워크를 중지하는 데 사용됩니다 . &lt;code&gt;TestRunner&lt;/code&gt; 구현 을 제공하는 대화식 도구 는 이와 유사한 방식으로이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="444e569164443b54baf03a91490c78b883818c99" translate="yes" xml:space="preserve">
          <source>For example, this test passes:</source>
          <target state="translated">예를 들어,이 테스트는 다음을 통과합니다.</target>
        </trans-unit>
        <trans-unit id="a8b68f8307ec7291b449dc75f9eea0977aaefaaa" translate="yes" xml:space="preserve">
          <source>For example, to change every default button to be a flat button with some padding and a different background color:</source>
          <target state="translated">예를 들어, 모든 기본 버튼을 패딩과 배경색이 다른 플랫 버튼으로 변경하려면 :</target>
        </trans-unit>
        <trans-unit id="01e96359683d8998b2f48987f38d7a5a0c7de1ba" translate="yes" xml:space="preserve">
          <source>For example, to create and populate an &lt;code&gt;ast.UnaryOp&lt;/code&gt; node, you could use</source>
          <target state="translated">예를 들어, &lt;code&gt;ast.UnaryOp&lt;/code&gt; 노드 를 작성하고 채우려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a38ad6a815b7c3a6d5e35ad360441c5a233d74d" translate="yes" xml:space="preserve">
          <source>For example, to obtain the digest of the byte string &lt;code&gt;b'Nobody inspects the
spammish repetition'&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 바이트 문자열의 요약을 얻으려면 &lt;code&gt;b'Nobody inspects the spammish repetition'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="48a28f5d3517c11de3bb06bb6b263ccb6b5647c5" translate="yes" xml:space="preserve">
          <source>For example, to pack a list of integers, the code might appear like this:</source>
          <target state="translated">예를 들어 정수 목록을 묶기 위해 코드는 다음과 같이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50f637ca45f01bd80a886a7d8d9112bcffe4464" translate="yes" xml:space="preserve">
          <source>For example, to set the delete flag on all messages:</source>
          <target state="translated">예를 들어, 모든 메시지에서 삭제 플래그를 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b93ac1384be7b98f164f6c81fd59de15e924427b" translate="yes" xml:space="preserve">
          <source>For example, to support arbitrary iterators, you could implement default like this:</source>
          <target state="translated">예를 들어, 임의 반복자를 지원하기 위해 다음과 같이 기본값을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0951e83479d161eaed251abaa06a68585eb3120d" translate="yes" xml:space="preserve">
          <source>For example, to tunnel through a HTTPS proxy server running locally on port 8080, we would pass the address of the proxy to the &lt;a href=&quot;#http.client.HTTPSConnection&quot;&gt;&lt;code&gt;HTTPSConnection&lt;/code&gt;&lt;/a&gt; constructor, and the address of the host that we eventually want to reach to the &lt;a href=&quot;#http.client.HTTPConnection.set_tunnel&quot;&gt;&lt;code&gt;set_tunnel()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">예를 들어 포트 8080에서 로컬로 실행되는 HTTPS 프록시 서버를 통해 터널링하려면 프록시 주소를 &lt;a href=&quot;#http.client.HTTPSConnection&quot;&gt; &lt;code&gt;HTTPSConnection&lt;/code&gt; &lt;/a&gt; 생성자에 전달하고 최종적으로 &lt;a href=&quot;#http.client.HTTPConnection.set_tunnel&quot;&gt; &lt;code&gt;set_tunnel()&lt;/code&gt; &lt;/a&gt; 메소드 에 도달하려는 호스트의 주소를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="7b3b978bfbe527f2a3a323f97ed4b69e27575629" translate="yes" xml:space="preserve">
          <source>For example, using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start method running the following module would fail with a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">예를 들어, 다음 모듈을 실행 하는 &lt;em&gt;스폰&lt;/em&gt; 또는 &lt;em&gt;forkserver&lt;/em&gt; start 메소드를 사용하면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="df42ad7c32da867212db01c727dfc03b20284141" translate="yes" xml:space="preserve">
          <source>For example, with a tuple &lt;code&gt;(1, 2)&lt;/code&gt; pickled in file &lt;code&gt;x.pickle&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;x.pickle&lt;/code&gt; 파일에서 튜플 &lt;code&gt;(1, 2)&lt;/code&gt; 절인 경우 :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5d290d09e8b8601522cec0c016dec6107bd8c07" translate="yes" xml:space="preserve">
          <source>For exceptions that involve a file system path (such as &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.unlink&quot;&gt;&lt;code&gt;os.unlink()&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;#OSError.filename&quot;&gt;&lt;code&gt;filename&lt;/code&gt;&lt;/a&gt; is the file name passed to the function. For functions that involve two file system paths (such as &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;#OSError.filename2&quot;&gt;&lt;code&gt;filename2&lt;/code&gt;&lt;/a&gt; corresponds to the second file name passed to the function.</source>
          <target state="translated">파일 시스템 경로 (예 : &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.unlink&quot;&gt; &lt;code&gt;os.unlink()&lt;/code&gt; &lt;/a&gt; ) 와 관련된 예외의 경우 &lt;a href=&quot;#OSError.filename&quot;&gt; &lt;code&gt;filename&lt;/code&gt; &lt;/a&gt; 은 함수에 전달 된 파일 이름입니다. 두 파일 시스템 경로 (예 : &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; ) 와 관련된 함수의 경우 &lt;a href=&quot;#OSError.filename2&quot;&gt; &lt;code&gt;filename2&lt;/code&gt; &lt;/a&gt; 는 함수에 전달 된 두 번째 파일 이름에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="986e94f272815e62ab45e31fc596a0bf2e5dba42" translate="yes" xml:space="preserve">
          <source>For existing code calling &lt;a href=&quot;#configparser.ConfigParser.readfp&quot;&gt;&lt;code&gt;readfp()&lt;/code&gt;&lt;/a&gt; with arguments which don&amp;rsquo;t support iteration, the following generator may be used as a wrapper around the file-like object:</source>
          <target state="translated">반복을 지원하지 않는 인수와 함께 &lt;a href=&quot;#configparser.ConfigParser.readfp&quot;&gt; &lt;code&gt;readfp()&lt;/code&gt; &lt;/a&gt; 를 호출하는 기존 코드의 경우 다음 생성기가 파일과 같은 객체를 감싸는 래퍼로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b79f9eae26ef65a2afacf2f54b2b0b95f4250af" translate="yes" xml:space="preserve">
          <source>For extension writers and programs that embed Python</source>
          <target state="translated">Python을 포함하는 확장 프로그램 및 프로그램의 경우</target>
        </trans-unit>
        <trans-unit id="49236a3024681c0e3e5df13b1f0ff226ce5765af" translate="yes" xml:space="preserve">
          <source>For external entities to be parsed, this handler must be implemented. It is responsible for creating the sub-parser using &lt;code&gt;ExternalEntityParserCreate(context)&lt;/code&gt;, initializing it with the appropriate callbacks, and parsing the entity. This handler should return an integer; if it returns &lt;code&gt;0&lt;/code&gt;, the parser will raise an &lt;code&gt;XML_ERROR_EXTERNAL_ENTITY_HANDLING&lt;/code&gt; error, otherwise parsing will continue.</source>
          <target state="translated">외부 엔티티를 구문 분석하려면이 핸들러를 구현해야합니다. &lt;code&gt;ExternalEntityParserCreate(context)&lt;/code&gt; 사용하여 하위 파서를 작성 하고 적절한 콜백으로 초기화하고 엔티티를 구문 분석합니다. 이 핸들러는 정수를 반환해야합니다. &lt;code&gt;0&lt;/code&gt; 을 반환 하면 파서는 &lt;code&gt;XML_ERROR_EXTERNAL_ENTITY_HANDLING&lt;/code&gt; 오류를 발생 시키고 그렇지 않으면 파싱이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e2ea4728652ede8436b63008dcbd2ab29b3396" translate="yes" xml:space="preserve">
          <source>For further discussion and two alternative approaches, see the &lt;a href=&quot;https://code.activestate.com/recipes/393090/&quot;&gt;ASPN cookbook recipes for accurate floating point summation&lt;/a&gt;.</source>
          <target state="translated">추가 토론과 두 가지 대안 &lt;a href=&quot;https://code.activestate.com/recipes/393090/&quot;&gt;은 정확한 부동 소수점 합산을위한 ASPN 요리 책 레시피를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6522f23e1fead3deb4b5395a57a64fa42ca1cdb" translate="yes" xml:space="preserve">
          <source>For further information, please consult the &lt;a href=&quot;#socket-timeouts&quot;&gt;notes on socket timeouts&lt;/a&gt;.</source>
          <target state="translated">자세한 정보 &lt;a href=&quot;#socket-timeouts&quot;&gt;는 소켓 제한 시간에&lt;/a&gt; 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aece9ac1b71ac6c335d8931e16fc332fda8d8599" translate="yes" xml:space="preserve">
          <source>For heterogeneous collections of data where access by name is clearer than access by index, &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;collections.namedtuple()&lt;/code&gt;&lt;/a&gt; may be a more appropriate choice than a simple tuple object.</source>
          <target state="translated">이름 별 액세스가 인덱스 별 액세스보다 명확한 이기종 데이터 콜렉션의 경우, &lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;collections.namedtuple()&lt;/code&gt; &lt;/a&gt; 이 간단한 튜플 오브젝트보다 더 적합한 선택 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359d6faefa3d11791af43a44d2be377ce987f362" translate="yes" xml:space="preserve">
          <source>For historical reasons, some of the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; methods had one or more aliases that are now deprecated. The following table lists the correct names along with their deprecated aliases:</source>
          <target state="translated">역사적인 이유로 일부 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 메소드에는 더 이상 사용되지 않는 하나 이상의 별명이 있습니다. 다음 표는 더 이상 사용되지 않는 별명과 함께 올바른 이름을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="70e949f6da3f1a592f5b2a48629e000e95eccb0b" translate="yes" xml:space="preserve">
          <source>For immutable targets such as strings, numbers, and tuples, the updated value is computed, but not assigned back to the input variable:</source>
          <target state="translated">문자열, 숫자 및 튜플과 같은 변경 불가능한 대상의 경우 업데이트 된 값이 계산되지만 입력 변수에 다시 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd5568fb042e52612b4e07795a6d976a99da1fd0" translate="yes" xml:space="preserve">
          <source>For in-place operations such as &lt;code&gt;c[key] += 1&lt;/code&gt;, the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for &lt;a href=&quot;#collections.Counter.update&quot;&gt;&lt;code&gt;update()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#collections.Counter.subtract&quot;&gt;&lt;code&gt;subtract()&lt;/code&gt;&lt;/a&gt; which allow negative and zero values for both inputs and outputs.</source>
          <target state="translated">&lt;code&gt;c[key] += 1&lt;/code&gt; 과 같은 인플레 이스 연산의 경우 값 유형은 덧셈과 뺄셈 만 지원하면됩니다. 따라서 분수, 부동 소수점 및 소수가 작동하고 음수 값이 지원됩니다. 입력과 출력 모두에 대해 음수 값과 0 값을 허용하는 &lt;a href=&quot;#collections.Counter.update&quot;&gt; &lt;code&gt;update()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#collections.Counter.subtract&quot;&gt; &lt;code&gt;subtract()&lt;/code&gt; &lt;/a&gt; 도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="c430cecf18c6228ad80e21ff36d9ceb073b9e28e" translate="yes" xml:space="preserve">
          <source>For incremental compression, use a &lt;a href=&quot;#bz2.BZ2Compressor&quot;&gt;&lt;code&gt;BZ2Compressor&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">증분 압축의 경우 &lt;a href=&quot;#bz2.BZ2Compressor&quot;&gt; &lt;code&gt;BZ2Compressor&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a21755ab38d63f0daf62822c3d38c163c737dea4" translate="yes" xml:space="preserve">
          <source>For incremental decompression, use a &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt;&lt;code&gt;BZ2Decompressor&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">증분 압축 해제의 경우 &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt; &lt;code&gt;BZ2Decompressor&lt;/code&gt; &lt;/a&gt; 압축 해제 기를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cbff89a2f5f52c2e55ca2c9d27010a14badd978f" translate="yes" xml:space="preserve">
          <source>For information about the constructor parameters and methods, see the documentation for &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt; in section &lt;a href=&quot;#doctest-advanced-api&quot;&gt;Advanced API&lt;/a&gt;.</source>
          <target state="translated">생성자 매개 변수 및 메소드에 대한 정보는 &lt;a href=&quot;#doctest-advanced-api&quot;&gt;고급 API&lt;/a&gt; 섹션의 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccc3814ef62ef3e032cafe9cf247e4c042f7bd05" translate="yes" xml:space="preserve">
          <source>For inputs that do not have trailing newlines, set the &lt;em&gt;lineterm&lt;/em&gt; argument to &lt;code&gt;&quot;&quot;&lt;/code&gt; so that the output will be uniformly newline free.</source>
          <target state="translated">후행 줄 바꿈이없는 입력의 경우 출력에 균일 한 줄 바꿈이 없도록 &lt;em&gt;lineterm&lt;/em&gt; 인수를 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="963201ecdae08f04bf36171e54bffac97056f991" translate="yes" xml:space="preserve">
          <source>For instance, SML provides a tabulation tool: &lt;code&gt;tabulate(f)&lt;/code&gt; which produces a sequence &lt;code&gt;f(0), f(1), ...&lt;/code&gt;. The same effect can be achieved in Python by combining &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#itertools.count&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt; to form &lt;code&gt;map(f, count())&lt;/code&gt;.</source>
          <target state="translated">예를 들어 SML은 tabulation 도구를 제공합니다. &lt;code&gt;tabulate(f)&lt;/code&gt; 는 시퀀스 &lt;code&gt;f(0), f(1), ...&lt;/code&gt; 합니다. &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#itertools.count&quot;&gt; &lt;code&gt;count()&lt;/code&gt; &lt;/a&gt; 를 결합하여 &lt;code&gt;map(f, count())&lt;/code&gt; 를 형성 하여 파이썬에서 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45242015fdb9fb952b9daa1d8d086e0f23b3b509" translate="yes" xml:space="preserve">
          <source>For instance, Shell never throws away output. A program that sends unlimited output to Shell will eventually fill memory, resulting in a memory error. In contrast, some system text windows only keep the last n lines of output. A Windows console, for instance, keeps a user-settable 1 to 9999 lines, with 300 the default.</source>
          <target state="translated">예를 들어, Shell은 절대로 출력을 버리지 않습니다. 셸에 무제한 출력을 보내는 프로그램은 결국 메모리를 채우므로 메모리 오류가 발생합니다. 반대로 일부 시스템 텍스트 창은 마지막 n 줄의 출력 만 유지합니다. 예를 들어, Windows 콘솔은 사용자가 1-9999 행을 유지할 수 있으며 기본값은 300입니다.</target>
        </trans-unit>
        <trans-unit id="a68abe1e9fe976d53a8a6657db86db9f80bc6ae9" translate="yes" xml:space="preserve">
          <source>For instance, for the tag &lt;code&gt;&amp;lt;A HREF=&quot;https://www.cwi.nl/&quot;&amp;gt;&lt;/code&gt;, this method would be called as &lt;code&gt;handle_starttag('a', [('href', 'https://www.cwi.nl/')])&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;&amp;lt;A HREF=&quot;https://www.cwi.nl/&quot;&amp;gt;&lt;/code&gt; 태그의 경우이 메소드는 &lt;code&gt;handle_starttag('a', [('href', 'https://www.cwi.nl/')])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="826a7a4eb1b82ca394e40c781115bfce3bd511a6" translate="yes" xml:space="preserve">
          <source>For instance, the following code (which assumes that the &lt;em&gt;Content-Type&lt;/em&gt; header and blank line have already been printed) checks that the fields &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;addr&lt;/code&gt; are both set to a non-empty string:</source>
          <target state="translated">예를 들어, 다음 코드 ( &lt;em&gt;Content-Type&lt;/em&gt; 헤더와 빈 줄이 이미 인쇄되었다고 가정)는 필드 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;addr&lt;/code&gt; 이 모두 비어 있지 않은 문자열로 설정되어 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="2fa125984e38d3e02a7f0fb70915cc3d02caa868" translate="yes" xml:space="preserve">
          <source>For integer type fields like &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt;, a third optional item can be given. It must be a small positive integer defining the bit width of the field.</source>
          <target state="translated">&lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; &lt;/a&gt; 와 같은 정수 유형 필드의 경우 세 번째 선택적 항목을 제공 할 수 있습니다. 필드의 비트 너비를 정의하는 작은 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f7503225ff38260dec07fdc637319dd83d951773" translate="yes" xml:space="preserve">
          <source>For integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.</source>
          <target state="translated">정수의 경우 범위에서 균일 한 선택이 있습니다. 시퀀스의 경우 무작위 요소의 균일 한 선택, 목록의 임의 순열을 생성하는 기능 및 대체하지 않고 무작위 샘플링을위한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eff0fdcbc3569990bbd16db9fa5a5df5aae7685" translate="yes" xml:space="preserve">
          <source>For loggers other than the root logger, some additional information is required. This is illustrated by the following example.</source>
          <target state="translated">루트 로거 이외의 로거의 경우 추가 정보가 필요합니다. 이것은 다음 예에 의해 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="fca00032925597b5dc8a9f16bf3a7909732bbcbb" translate="yes" xml:space="preserve">
          <source>For long options (options with names longer than a single character), the option and value can also be passed as a single command-line argument, using &lt;code&gt;=&lt;/code&gt; to separate them:</source>
          <target state="translated">긴 옵션 (단일 문자보다 긴 이름을 가진 옵션)의 경우 옵션과 값을 &lt;code&gt;=&lt;/code&gt; 를 사용하여 단일 명령 줄 인수로 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99265f8edbfb9e7d7b596dec842776023c0a9e56" translate="yes" xml:space="preserve">
          <source>For long sequences of the same frame and line, the first few repetitions are shown, followed by a summary line stating the exact number of further repetitions.</source>
          <target state="translated">동일한 프레임과 라인의 긴 시퀀스의 경우 처음 몇 번의 반복이 표시되고 그 뒤에 정확한 반복 횟수를 나타내는 요약 선이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2e50576c0df1f3411e96df78baa4b95f76497c46" translate="yes" xml:space="preserve">
          <source>For low-level path manipulation on strings, you can also use the &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">문자열에서 저수준 경로 조작을 위해 &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 모듈을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="780e353ee5e0eadf57f7fb0b0eb414afc840b40c" translate="yes" xml:space="preserve">
          <source>For mathematical operations on multisets and their use cases, see &lt;em&gt;Knuth, Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise 19&lt;/em&gt;.</source>
          <target state="translated">다중 집합과 그 사용 사례에 대한 수학 연산은 &lt;em&gt;Knuth, Donald를&lt;/em&gt; 참조하십시오 &lt;em&gt;. &lt;/em&gt;&lt;em&gt;컴퓨터 프로그래밍 볼륨 II의 기술, 섹션 4.6.3, 연습 19&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bcc82cf68a5234571647cda5636a95aca3c77d15" translate="yes" xml:space="preserve">
          <source>For modes &lt;code&gt;'w:gz'&lt;/code&gt;, &lt;code&gt;'r:gz'&lt;/code&gt;, &lt;code&gt;'w:bz2'&lt;/code&gt;, &lt;code&gt;'r:bz2'&lt;/code&gt;, &lt;code&gt;'x:gz'&lt;/code&gt;, &lt;code&gt;'x:bz2'&lt;/code&gt;, &lt;a href=&quot;#tarfile.open&quot;&gt;&lt;code&gt;tarfile.open()&lt;/code&gt;&lt;/a&gt; accepts the keyword argument &lt;em&gt;compresslevel&lt;/em&gt; (default &lt;code&gt;9&lt;/code&gt;) to specify the compression level of the file.</source>
          <target state="translated">모드의 경우 &lt;code&gt;'w:gz'&lt;/code&gt; , &lt;code&gt;'r:gz'&lt;/code&gt; , &lt;code&gt;'w:bz2'&lt;/code&gt; , &lt;code&gt;'r:bz2'&lt;/code&gt; , &lt;code&gt;'x:gz'&lt;/code&gt; , &lt;code&gt;'x:bz2'&lt;/code&gt; , &lt;a href=&quot;#tarfile.open&quot;&gt; &lt;code&gt;tarfile.open()&lt;/code&gt; &lt;/a&gt; 키워드 인수 받아 &lt;em&gt;compresslevel을&lt;/em&gt; (기본 &lt;code&gt;9&lt;/code&gt; )를 눌러 파일의 압축 수준을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f7d85143367eaddc8853c2ec6704f9eb4b357718" translate="yes" xml:space="preserve">
          <source>For modules, classes, functions and methods, the displayed documentation is derived from the docstring (i.e. the &lt;code&gt;__doc__&lt;/code&gt; attribute) of the object, and recursively of its documentable members. If there is no docstring, &lt;a href=&quot;#module-pydoc&quot;&gt;&lt;code&gt;pydoc&lt;/code&gt;&lt;/a&gt; tries to obtain a description from the block of comment lines just above the definition of the class, function or method in the source file, or at the top of the module (see &lt;a href=&quot;inspect#inspect.getcomments&quot;&gt;&lt;code&gt;inspect.getcomments()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">모듈, 클래스, 함수 및 메소드의 경우, 표시된 문서는 오브젝트 의 docstring (예 : &lt;code&gt;__doc__&lt;/code&gt; 속성) 및 문서화 가능한 멤버에서 재귀 적으로 파생됩니다 . docstring이 없으면 &lt;a href=&quot;#module-pydoc&quot;&gt; &lt;code&gt;pydoc&lt;/code&gt; &lt;/a&gt; 은 소스 파일의 클래스, 함수 또는 메소드의 정의 바로 위 또는 모듈 맨 위의 주석 행 블록에서 설명을 얻으려고 시도합니다 ( &lt;a href=&quot;inspect#inspect.getcomments&quot;&gt; &lt;code&gt;inspect.getcomments()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="03e6b008c4cde03e3eae01629d439fc517c4dfe9" translate="yes" xml:space="preserve">
          <source>For more about ABCs, see the &lt;a href=&quot;abc#module-abc&quot;&gt;&lt;code&gt;abc&lt;/code&gt;&lt;/a&gt; module and &lt;a href=&quot;https://www.python.org/dev/peps/pep-3119&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3119&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">ABC에 대한 자세한 내용은 &lt;a href=&quot;abc#module-abc&quot;&gt; &lt;code&gt;abc&lt;/code&gt; &lt;/a&gt; 모듈 및 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3119&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3119를&lt;/strong&gt;&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46cae48518bcb3647b4683abb1424d2693286675" translate="yes" xml:space="preserve">
          <source>For more advanced work, it may be useful to create alternate contexts using the Context() constructor. To make an alternate active, use the &lt;a href=&quot;#decimal.setcontext&quot;&gt;&lt;code&gt;setcontext()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">보다 고급 작업을 위해서는 Context () 생성자를 사용하여 대체 컨텍스트를 작성하는 것이 유용 할 수 있습니다. 대체를 활성화하려면 &lt;a href=&quot;#decimal.setcontext&quot;&gt; &lt;code&gt;setcontext()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fcc19ca4e316c086f420b1620de5c145c142b6d" translate="yes" xml:space="preserve">
          <source>For more details and extensive examples, see the documentation string of the &lt;code&gt;_threading_local&lt;/code&gt; module.</source>
          <target state="translated">자세한 내용과 광범위한 예는 &lt;code&gt;_threading_local&lt;/code&gt; 모듈 의 설명서 문자열을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="597d156c6f9b5c546f4c30195be33c24a39b20e0" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;#argparse.Action&quot;&gt;&lt;code&gt;Action&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#argparse.Action&quot;&gt; &lt;code&gt;Action&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36d676c3906f278c209bbc351453c41061805da0" translate="yes" xml:space="preserve">
          <source>For more explicit control of source stacking, use the &lt;a href=&quot;#shlex.shlex.push_source&quot;&gt;&lt;code&gt;push_source()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#shlex.shlex.pop_source&quot;&gt;&lt;code&gt;pop_source()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">소스 스태킹을보다 명시 적으로 제어하려면 &lt;a href=&quot;#shlex.shlex.push_source&quot;&gt; &lt;code&gt;push_source()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#shlex.shlex.pop_source&quot;&gt; &lt;code&gt;pop_source()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dd9913577d878271afdd61232f1fa2cb21697adb" translate="yes" xml:space="preserve">
          <source>For more extensive information on the packer and the options that it can take, see the man pages and page 183 of John Ousterhout&amp;rsquo;s book.</source>
          <target state="translated">패커와 그 옵션에 대한 자세한 내용은 John Ousterhout의 저서 맨 페이지와 183 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8f07e394f58518334837c27b85d4ab9f5730274" translate="yes" xml:space="preserve">
          <source>For more fine-grained usage, it&amp;rsquo;s possible to set a trace function by assigning &lt;code&gt;frame.f_trace = tracefunc&lt;/code&gt; explicitly, rather than relying on it being set indirectly via the return value from an already installed trace function. This is also required for activating the trace function on the current frame, which &lt;a href=&quot;#sys.settrace&quot;&gt;&lt;code&gt;settrace()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t do. Note that in order for this to work, a global tracing function must have been installed with &lt;a href=&quot;#sys.settrace&quot;&gt;&lt;code&gt;settrace()&lt;/code&gt;&lt;/a&gt; in order to enable the runtime tracing machinery, but it doesn&amp;rsquo;t need to be the same tracing function (e.g. it could be a low overhead tracing function that simply returns &lt;code&gt;None&lt;/code&gt; to disable itself immediately on each frame).</source>
          <target state="translated">보다 세분화 된 사용법 을 위해 이미 설치된 추적 함수의 반환 값을 통해 간접적으로 설정되는 것이 아니라 &lt;code&gt;frame.f_trace = tracefunc&lt;/code&gt; 명시 적으로 할당하여 추적 기능을 설정할 수 있습니다. &lt;a href=&quot;#sys.settrace&quot;&gt; &lt;code&gt;settrace()&lt;/code&gt; &lt;/a&gt; 가 수행하지 않는 현재 프레임에서 추적 함수를 활성화하는 데에도 필요합니다 . 이것이 작동 하려면 런타임 추적 기계를 사용하기 위해 전역 추적 기능이 &lt;a href=&quot;#sys.settrace&quot;&gt; &lt;code&gt;settrace()&lt;/code&gt; &lt;/a&gt; 와 함께 설치되어 있어야 하지만 동일한 추적 기능 일 필요는 없습니다 (예 : 오버 헤드가 낮을 수 있음) 각 프레임에서 즉시 비활성화하기 위해 단순히 &lt;code&gt;None&lt;/code&gt; 을 반환하는 추적 기능 ).</target>
        </trans-unit>
        <trans-unit id="b72782cbc8c0b6cf00d613d39cc13696514eeb6e" translate="yes" xml:space="preserve">
          <source>For more flexibility in using shared memory one can use the &lt;a href=&quot;#module-multiprocessing.sharedctypes&quot;&gt;&lt;code&gt;multiprocessing.sharedctypes&lt;/code&gt;&lt;/a&gt; module which supports the creation of arbitrary ctypes objects allocated from shared memory.</source>
          <target state="translated">공유 메모리를보다 유연하게 사용하기 위해 공유 메모리에서 할당 된 임의의 ctypes 객체 생성을 지원하는 &lt;a href=&quot;#module-multiprocessing.sharedctypes&quot;&gt; &lt;code&gt;multiprocessing.sharedctypes&lt;/code&gt; &lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df7e50f9236ec25120197854c2f0993b8af2a486" translate="yes" xml:space="preserve">
          <source>For more information about &lt;a href=&quot;#ttkstyling&quot;&gt;TtkStyling&lt;/a&gt;, see the &lt;a href=&quot;#tkinter.ttk.Style&quot;&gt;&lt;code&gt;Style&lt;/code&gt;&lt;/a&gt; class documentation.</source>
          <target state="translated">&lt;a href=&quot;#ttkstyling&quot;&gt;TtkStyling에&lt;/a&gt; 대한 자세한 내용은 &lt;a href=&quot;#tkinter.ttk.Style&quot;&gt; &lt;code&gt;Style&lt;/code&gt; &lt;/a&gt; 클래스 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db5ca74113cecdf8bd9218769597c1431aee8777" translate="yes" xml:space="preserve">
          <source>For more information about &lt;em&gt;flags&lt;/em&gt; you can consult &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getnameinfo(3)&quot;&gt;getnameinfo(3)&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;플래그에&lt;/em&gt; 대한 자세한 정보는 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getnameinfo(3)&quot;&gt;getnameinfo (3)를&lt;/a&gt;&lt;/em&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="38c9342c817e5011acb54d4ee258a06117119635" translate="yes" xml:space="preserve">
          <source>For more information on &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt;, see section &lt;a href=&quot;#doctest-basic-api&quot;&gt;Basic API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 에 대한 자세한 내용은 &lt;a href=&quot;#doctest-basic-api&quot;&gt;Basic API&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8992739fc0a61b0b25882180db6cdfa7a3570bbd" translate="yes" xml:space="preserve">
          <source>For more information on &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;, see section &lt;a href=&quot;#doctest-basic-api&quot;&gt;Basic API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 에 대한 자세한 내용은 &lt;a href=&quot;#doctest-basic-api&quot;&gt;Basic API&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f4e87cc73e3a41721af3d1c000891584dd27800" translate="yes" xml:space="preserve">
          <source>For more information on class methods, see &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#types&quot;&gt;The standard type hierarchy&lt;/a&gt;.</source>
          <target state="translated">클래스 메소드에 대한 자세한 정보 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#types&quot;&gt;는 표준 유형 계층을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bedf2aa9231c7c1fecdcdb39b3fcf4e879dfae1c" translate="yes" xml:space="preserve">
          <source>For more information on code and frame objects, refer to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#types&quot;&gt;The standard type hierarchy&lt;/a&gt;.</source>
          <target state="translated">코드 및 프레임 객체에 대한 자세한 내용 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#types&quot;&gt;은 표준 유형 계층을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d078607c47fbb41c24940ef7055eb18a9b3d415" translate="yes" xml:space="preserve">
          <source>For more information on static methods, see &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#types&quot;&gt;The standard type hierarchy&lt;/a&gt;.</source>
          <target state="translated">정적 메소드에 대한 자세한 정보 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#types&quot;&gt;는 표준 유형 계층을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="421bf46ac523c580b6d6d6d7806d5f9f6b50d224" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;code&gt;str&lt;/code&gt; class and its methods, see &lt;a href=&quot;#textseq&quot;&gt;Text Sequence Type &amp;mdash; str&lt;/a&gt; and the &lt;a href=&quot;#string-methods&quot;&gt;String Methods&lt;/a&gt; section below. To output formatted strings, see the &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;Formatted string literals&lt;/a&gt; and &lt;a href=&quot;string#formatstrings&quot;&gt;Format String Syntax&lt;/a&gt; sections. In addition, see the &lt;a href=&quot;text#stringservices&quot;&gt;Text Processing Services&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 클래스와 그 메소드 에 대한 자세한 내용 은 &lt;a href=&quot;#textseq&quot;&gt;텍스트 시퀀스 유형 &amp;mdash; str&lt;/a&gt; 및 아래 의 &lt;a href=&quot;#string-methods&quot;&gt;문자열 메소드&lt;/a&gt; 섹션을 참조하십시오. 형식화 된 문자열을 출력하려면 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;형식화 된 문자열 리터럴&lt;/a&gt; 및 &lt;a href=&quot;string#formatstrings&quot;&gt;형식 문자열 구문&lt;/a&gt; 섹션을 참조하십시오 . 또한 &lt;a href=&quot;text#stringservices&quot;&gt;텍스트 처리 서비스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d85a9650ef90a538c7b9637ea250afe03d69723" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://bugs.python.org/issue5155&quot;&gt;bpo-5155&lt;/a&gt;, &lt;a href=&quot;https://bugs.python.org/issue5313&quot;&gt;bpo-5313&lt;/a&gt; and &lt;a href=&quot;https://bugs.python.org/issue5331&quot;&gt;bpo-5331&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://bugs.python.org/issue5155&quot;&gt;bpo-5155&lt;/a&gt; , &lt;a href=&quot;https://bugs.python.org/issue5313&quot;&gt;bpo-5313&lt;/a&gt; 및 &lt;a href=&quot;https://bugs.python.org/issue5331&quot;&gt;bpo-5331을 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad749c484a050c2c7bf1710222fa340076db122c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa384129(v=VS.85).aspx&quot;&gt;Accessing an Alternate Registry View&lt;/a&gt;.</source>
          <target state="translated">자세한 정보 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa384129(v=VS.85).aspx&quot;&gt;는 대체 레지스트리보기 액세스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="119c6fa14fdb5ff135f608e174a237a8d39259df" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724878%28v=VS.85%29.aspx&quot;&gt;Registry Key Security and Access&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724878%28v=VS.85%29.aspx&quot;&gt;레지스트리 키 보안 및 액세스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77fb0351c334f2e98ca82931de22cb7d2c602dca" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724884%28v=VS.85%29.aspx&quot;&gt;Registry Value Types&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724884%28v=VS.85%29.aspx&quot;&gt;레지스트리 값 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5798480c6aa43603ded3d7efeddc544e90f897ab" translate="yes" xml:space="preserve">
          <source>For more sophisticated applications, the &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; class helps manage settings and certificates, which can then be inherited by SSL sockets created through the &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">보다 복잡한 응용 프로그램의 경우 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 클래스는 설정 및 인증서를 관리하는 데 도움이되며 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 생성 된 SSL 소켓에서 상속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bde3739aadce3c7f820930e05b3c8e453753978" translate="yes" xml:space="preserve">
          <source>For most purposes, the &lt;code&gt;SOUND_MIXER_VOLUME&lt;/code&gt; (master volume) and &lt;code&gt;SOUND_MIXER_PCM&lt;/code&gt; controls should suffice&amp;mdash;but code that uses the mixer should be flexible when it comes to choosing mixer controls. On the Gravis Ultrasound, for example, &lt;code&gt;SOUND_MIXER_VOLUME&lt;/code&gt; does not exist.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;SOUND_MIXER_VOLUME&lt;/code&gt; (마스터 볼륨) 및 &lt;code&gt;SOUND_MIXER_PCM&lt;/code&gt; 컨트롤로는 충분하지만 믹서를 사용하는 코드는 믹서 컨트롤을 선택할 때 유연해야합니다. 예를 들어 Gravis Ultrasound에는 &lt;code&gt;SOUND_MIXER_VOLUME&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="81a00f17049a5e9a02f7312cb25779d4bb6c5941" translate="yes" xml:space="preserve">
          <source>For mutable targets such as lists and dictionaries, the in-place method will perform the update, so no subsequent assignment is necessary:</source>
          <target state="translated">목록 및 사전과 같은 변경 가능한 대상의 경우 내부 메소드가 업데이트를 수행하므로 후속 지정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77fbb059375aa28aa73354116772b577d2a77cf7" translate="yes" xml:space="preserve">
          <source>For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node.</source>
          <target state="translated">모든 명령문 노드에 적용되는 명령문 콜렉션의 일부인 노드의 경우 방문자는 단일 노드가 아닌 노드 목록을 리턴 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d250f7a529a8d3c64d6bc6040f6513ae55826602" translate="yes" xml:space="preserve">
          <source>For non-200 error codes, this simply passes the job on to the &lt;code&gt;http_error_&amp;lt;type&amp;gt;()&lt;/code&gt; handler methods, via &lt;a href=&quot;#urllib.request.OpenerDirector.error&quot;&gt;&lt;code&gt;OpenerDirector.error()&lt;/code&gt;&lt;/a&gt;. Eventually, &lt;a href=&quot;#urllib.request.HTTPDefaultErrorHandler&quot;&gt;&lt;code&gt;HTTPDefaultErrorHandler&lt;/code&gt;&lt;/a&gt; will raise an &lt;a href=&quot;urllib.error#urllib.error.HTTPError&quot;&gt;&lt;code&gt;HTTPError&lt;/code&gt;&lt;/a&gt; if no other handler handles the error.</source>
          <target state="translated">200이 아닌 오류 코드의 경우 단순히 &lt;a href=&quot;#urllib.request.OpenerDirector.error&quot;&gt; &lt;code&gt;OpenerDirector.error()&lt;/code&gt; &lt;/a&gt; 를 통해 작업을 &lt;code&gt;http_error_&amp;lt;type&amp;gt;()&lt;/code&gt; 핸들러 메소드로 전달 합니다. 결국, 다른 핸들러가 오류를 처리하지 않으면 &lt;a href=&quot;#urllib.request.HTTPDefaultErrorHandler&quot;&gt; &lt;code&gt;HTTPDefaultErrorHandler&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;urllib.error#urllib.error.HTTPError&quot;&gt; &lt;code&gt;HTTPError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f5517c546993b6b7847fcd0c391c423f3a488157" translate="yes" xml:space="preserve">
          <source>For non-Unix platforms, or when a remote browser is available on Unix, the controlling process will not wait for the user to finish with the browser, but allow the remote browser to maintain its own windows on the display. If remote browsers are not available on Unix, the controlling process will launch a new browser and wait.</source>
          <target state="translated">Unix 이외의 플랫폼 또는 Unix에서 원격 브라우저를 사용할 수있는 경우, 제어 프로세스는 사용자가 브라우저를 끝낼 때까지 기다리지 않고 원격 브라우저가 자체 창을 디스플레이에 유지할 수 있도록합니다. Unix에서 원격 브라우저를 사용할 수없는 경우 제어 프로세스는 새 브라우저를 시작하고 기다립니다.</target>
        </trans-unit>
        <trans-unit id="9b772393e90f36112fe4debf3cd114a12b09518c" translate="yes" xml:space="preserve">
          <source>For non-callable mocks the callable variant will be used (rather than any custom subclass).</source>
          <target state="translated">호출 할 수없는 모의 경우 사용자 정의 서브 클래스 대신 호출 가능 변형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b691e793be115140f38b348f5cebba832f0c4591" translate="yes" xml:space="preserve">
          <source>For non-contiguous arrays the result is equal to the flattened list representation with all elements converted to bytes. &lt;a href=&quot;#memoryview.tobytes&quot;&gt;&lt;code&gt;tobytes()&lt;/code&gt;&lt;/a&gt; supports all format strings, including those that are not in &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module syntax.</source>
          <target state="translated">연속되지 않은 배열의 경우 결과는 모든 요소가 바이트로 변환 된 플랫 화 된 목록 표현과 같습니다. &lt;a href=&quot;#memoryview.tobytes&quot;&gt; &lt;code&gt;tobytes()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 모듈 구문에 없는 문자열을 포함하여 모든 형식 문자열을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="cb6a6ca72e2265be79779f9a6b802b866e0158e9" translate="yes" xml:space="preserve">
          <source>For normal use, you should only require the initialization/connect, &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;sendmail()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#smtplib.SMTP.quit&quot;&gt;&lt;code&gt;SMTP.quit()&lt;/code&gt;&lt;/a&gt; methods. An example is included below.</source>
          <target state="translated">정상적인 사용을 위해서는 초기화 / 연결, &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;sendmail()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#smtplib.SMTP.quit&quot;&gt; &lt;code&gt;SMTP.quit()&lt;/code&gt; &lt;/a&gt; 메소드 만 필요합니다 . 아래에 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="19877769490ea36879f858c9d17af7a4020bd5a5" translate="yes" xml:space="preserve">
          <source>For numbers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, possibly of different types, it&amp;rsquo;s a requirement that &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; whenever &lt;code&gt;x == y&lt;/code&gt; (see the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt;) Python&amp;rsquo;s hash for numeric types is based on a single mathematical function that&amp;rsquo;s defined for any rational number, and hence applies to all instances of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt;, and all finite instances of &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt;. Essentially, this function is given by reduction modulo &lt;code&gt;P&lt;/code&gt; for a fixed prime &lt;code&gt;P&lt;/code&gt;. The value of &lt;code&gt;P&lt;/code&gt; is made available to Python as the &lt;code&gt;modulus&lt;/code&gt; attribute of &lt;a href=&quot;sys#sys.hash_info&quot;&gt;&lt;code&gt;sys.hash_info&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 유형일 수있는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 숫자 의 경우 &lt;code&gt;x == y&lt;/code&gt; 때마다 &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; (자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드 설명서 참조). 다양한 숫자 유형 ( &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; 포함&lt;/a&gt; ) 에서 구현 및 효율성을 쉽게하기 위해 숫자 유형에 대한 Python의 해시는 모든 합리적인 숫자에 대해 정의 된 단일 수학 함수를 기반으로하므로 모든 사람에게 적용됩니다 인스턴스 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt; , 그리고 모든 유한 한 경우 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 와&lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; . 본질적으로,이 함수는고정 소수 &lt;code&gt;P&lt;/code&gt; 에 대한감소 모듈로 &lt;code&gt;P&lt;/code&gt; 에의해 제공됩니다. &lt;code&gt;P&lt;/code&gt; 의 값은&lt;a href=&quot;sys#sys.hash_info&quot;&gt; &lt;code&gt;sys.hash_info&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;modulus&lt;/code&gt; 속성으로Python에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="37098851ccc8634e113e32e8099ef7a2d3579db1" translate="yes" xml:space="preserve">
          <source>For objects with custom &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; methods, note that &lt;a href=&quot;#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; truncates the return value based on the bit width of the host machine. See &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드가있는 객체의 경우 &lt;a href=&quot;#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt; 는 호스트 시스템의 비트 폭에 따라 반환 값을 자릅니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="30462903d9f2f468f46f7edb480c29e83e9dfb0b" translate="yes" xml:space="preserve">
          <source>For optional argument actions, the value of &lt;code&gt;dest&lt;/code&gt; is normally inferred from the option strings. &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; generates the value of &lt;code&gt;dest&lt;/code&gt; by taking the first long option string and stripping away the initial &lt;code&gt;--&lt;/code&gt; string. If no long option strings were supplied, &lt;code&gt;dest&lt;/code&gt; will be derived from the first short option string by stripping the initial &lt;code&gt;-&lt;/code&gt; character. Any internal &lt;code&gt;-&lt;/code&gt; characters will be converted to &lt;code&gt;_&lt;/code&gt; characters to make sure the string is a valid attribute name. The examples below illustrate this behavior:</source>
          <target state="translated">선택적 인수 조치의 경우 일반적으로 &lt;code&gt;dest&lt;/code&gt; 값은 옵션 문자열에서 유추됩니다. &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 는&lt;/a&gt; 값 생성 &lt;code&gt;dest&lt;/code&gt; 첫 번째 긴 옵션 문자열을 복용하고 초기 벗겨 의해 &lt;code&gt;--&lt;/code&gt; 문자열입니다. 더 긴 옵션 문자열이 제공되지 않은 경우, &lt;code&gt;dest&lt;/code&gt; 초기 제거하여 첫 번째 단편 옵션 문자열에서 파생됩니다 &lt;code&gt;-&lt;/code&gt; 문자. 내부 &lt;code&gt;-&lt;/code&gt; 문자로 변환됩니다 &lt;code&gt;_&lt;/code&gt; 문자 확인 문자열을 만드는 것은 유효한 속성 이름입니다. 아래 예제는이 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0f2d0f71428756b986ebaa5435a895c9fa85f213" translate="yes" xml:space="preserve">
          <source>For ordering (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc) the rules are different. Interface and address objects with the same IP version can be compared, and the address objects will always sort before the interface objects. Two interface objects are first compared by their networks and, if those are the same, then by their IP addresses.</source>
          <target state="translated">주문 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 등)의 경우 규칙이 다릅니다. 동일한 IP 버전의 인터페이스 및 주소 개체를 비교할 수 있으며 주소 개체는 항상 인터페이스 개체보다 먼저 정렬됩니다. 두 개의 인터페이스 객체는 먼저 네트워크에서 비교 한 다음 동일한 경우 IP 주소로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="1a78e5fc164b6225aab0e8520457ff6f179c8031" translate="yes" xml:space="preserve">
          <source>For other containers see the built-in &lt;a href=&quot;stdtypes#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; classes, as well as the &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다른 컨테이너에 대해서는 내장 &lt;a href=&quot;stdtypes#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 클래스 와 &lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd75d884bb310e831015ffaf69d74418b45d2e9b" translate="yes" xml:space="preserve">
          <source>For other containers see the built-in &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; classes, as well as the &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다른 컨테이너에 대해서는 내장 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 클래스 와 &lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="806eb52bec9293c5c5e9f3e57a2e9b6409b111da" translate="yes" xml:space="preserve">
          <source>For other containers see the built-in &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; classes, as well as the &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다른 컨테이너에 대해서는 내장 &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 클래스 와 &lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3e3b71d8294ed183632143849e0c5e2186ee11c5" translate="yes" xml:space="preserve">
          <source>For other non-POSIX platforms, currently just returns &lt;a href=&quot;sys#sys.platform&quot;&gt;&lt;code&gt;sys.platform&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX 이외의 다른 플랫폼의 경우 현재 &lt;a href=&quot;sys#sys.platform&quot;&gt; &lt;code&gt;sys.platform&lt;/code&gt; &lt;/a&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="43510e47adddfe2347126cf63725f54b5b8386f0" translate="yes" xml:space="preserve">
          <source>For other systems, the values are:</source>
          <target state="translated">다른 시스템의 경우 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80bfe13e7a83c037584f2ad34a471b944fb57186" translate="yes" xml:space="preserve">
          <source>For packages located in the filesystem, which have already been imported, this is the rough equivalent of:</source>
          <target state="translated">이미 반입 된 파일 시스템에있는 패키지의 경우 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a76a860e58a82ab240c54a9335a87b67ecb80d9" translate="yes" xml:space="preserve">
          <source>For passing messages one can use &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe()&lt;/code&gt;&lt;/a&gt; (for a connection between two processes) or a queue (which allows multiple producers and consumers).</source>
          <target state="translated">메시지를 전달하기 위해 &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe()&lt;/code&gt; &lt;/a&gt; (두 프로세스 간 연결을 위해) 또는 큐 (여러 생산자와 소비자를 허용)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="501f766e72b164e7c677bd88bbc6c17ac2be5b93" translate="yes" xml:space="preserve">
          <source>For performance reasons, &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt;&lt;code&gt;reducer_override()&lt;/code&gt;&lt;/a&gt; may not be called for the following objects: &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt;, and exact instances of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">성능상의 이유로 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;False&lt;/code&gt; 및 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 인스턴스의 &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt; &lt;code&gt;reducer_override()&lt;/code&gt; &lt;/a&gt; 는 호출되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7dc577194da823efb388a7e912288fbb2216f9ea" translate="yes" xml:space="preserve">
          <source>For positional arguments with &lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt; equal to &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;, the &lt;code&gt;default&lt;/code&gt; value is used when no command-line argument was present:</source>
          <target state="translated">&lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt; 가 &lt;code&gt;?&lt;/code&gt; 인 위치 인수의 경우 또는 &lt;code&gt;*&lt;/code&gt; 이면 명령 줄 인수가없는 경우 &lt;code&gt;default&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8b4a550eec3b311ec7c0b5c122c8cd1aa045b2d0" translate="yes" xml:space="preserve">
          <source>For practical suggestions on how to design cooperative classes using &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://rhettinger.wordpress.com/2011/05/26/super-considered-super/&quot;&gt;guide to using super()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 사용하여 협력 클래스를 디자인하는 방법에 대한 실제 제안은 super ()&lt;a href=&quot;https://rhettinger.wordpress.com/2011/05/26/super-considered-super/&quot;&gt; 사용 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6b9cd2e27090d9128abe570d2d9cdaa38c3b4f0" translate="yes" xml:space="preserve">
          <source>For projects where startup time is critical, this class allows for potentially minimizing the cost of loading a module if it is never used. For projects where startup time is not essential then use of this class is &lt;strong&gt;heavily&lt;/strong&gt; discouraged due to error messages created during loading being postponed and thus occurring out of context.</source>
          <target state="translated">시작 시간이 중요한 프로젝트의 경우이 클래스를 사용하면 모듈을 사용하지 않는 경우로드하는 비용을 최소화 할 수 있습니다. 시작 시간은 필수 다음되는이 클래스를 사용하지 않습니다 프로젝트의 경우 &lt;strong&gt;크게&lt;/strong&gt; 로드하는 동안 생성 된 오류 메시지로 인해 낙심 연기되고, 따라서 문맥 발생.</target>
        </trans-unit>
        <trans-unit id="78750474069e0c64d5febba081125312d17b6e79" translate="yes" xml:space="preserve">
          <source>For reading and writing &lt;code&gt;.gz&lt;/code&gt; files see the &lt;a href=&quot;gzip#module-gzip&quot;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;.gz&lt;/code&gt; 파일을 읽고 쓰 려면 &lt;a href=&quot;gzip#module-gzip&quot;&gt; &lt;code&gt;gzip&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51794c9a03db663b665c1244d6fcc6729a11742e" translate="yes" xml:space="preserve">
          <source>For seekable output streams, the &lt;code&gt;wave&lt;/code&gt; header will automatically be updated to reflect the number of frames actually written. For unseekable streams, the &lt;em&gt;nframes&lt;/em&gt; value must be accurate when the first frame data is written. An accurate &lt;em&gt;nframes&lt;/em&gt; value can be achieved either by calling &lt;a href=&quot;#wave.Wave_write.setnframes&quot;&gt;&lt;code&gt;setnframes()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#wave.Wave_write.setparams&quot;&gt;&lt;code&gt;setparams()&lt;/code&gt;&lt;/a&gt; with the number of frames that will be written before &lt;a href=&quot;#wave.Wave_write.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; is called and then using &lt;a href=&quot;#wave.Wave_write.writeframesraw&quot;&gt;&lt;code&gt;writeframesraw()&lt;/code&gt;&lt;/a&gt; to write the frame data, or by calling &lt;a href=&quot;#wave.Wave_write.writeframes&quot;&gt;&lt;code&gt;writeframes()&lt;/code&gt;&lt;/a&gt; with all of the frame data to be written. In the latter case &lt;a href=&quot;#wave.Wave_write.writeframes&quot;&gt;&lt;code&gt;writeframes()&lt;/code&gt;&lt;/a&gt; will calculate the number of frames in the data and set &lt;em&gt;nframes&lt;/em&gt; accordingly before writing the frame data.</source>
          <target state="translated">탐색 가능한 출력 스트림의 경우 실제로 작성된 프레임 수를 반영하도록 &lt;code&gt;wave&lt;/code&gt; 헤더가 자동으로 업데이트됩니다. 사용할 수없는 스트림의 경우 첫 번째 프레임 데이터를 쓸 때 &lt;em&gt;nframe&lt;/em&gt; 값이 정확해야합니다. 정확한 &lt;em&gt;nframes의&lt;/em&gt; 값은 호출하거나 얻을 수 &lt;a href=&quot;#wave.Wave_write.setnframes&quot;&gt; &lt;code&gt;setnframes()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#wave.Wave_write.setparams&quot;&gt; &lt;code&gt;setparams()&lt;/code&gt; &lt;/a&gt; 전에 기록 될 프레임 번호 &lt;a href=&quot;#wave.Wave_write.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 하여 다음 호출 및 &lt;a href=&quot;#wave.Wave_write.writeframesraw&quot;&gt; &lt;code&gt;writeframesraw()&lt;/code&gt; &lt;/a&gt; , 또는 호출하여 프레임 데이터를 작성 &lt;a href=&quot;#wave.Wave_write.writeframes&quot;&gt; &lt;code&gt;writeframes()&lt;/code&gt; &lt;/a&gt; 모든 프레임 데이터가 기록됩니다. 후자의 경우 &lt;a href=&quot;#wave.Wave_write.writeframes&quot;&gt; &lt;code&gt;writeframes()&lt;/code&gt; &lt;/a&gt; 는 데이터의 프레임 수를 계산하고&lt;em&gt;&lt;/em&gt;따라서 프레임 데이터를 쓰기 전에 &lt;em&gt;nframe을 설정&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="04adcba5227396c66c494ff68cad07039f1493f6" translate="yes" xml:space="preserve">
          <source>For server operation, typically you&amp;rsquo;ll need to have a server certificate, and private key, each in a file. You&amp;rsquo;ll first create a context holding the key and the certificate, so that clients can check your authenticity. Then you&amp;rsquo;ll open a socket, bind it to a port, call &lt;code&gt;listen()&lt;/code&gt; on it, and start waiting for clients to connect:</source>
          <target state="translated">서버 작동을 위해서는 일반적으로 파일에 각각 서버 인증서와 개인 키가 있어야합니다. 먼저 클라이언트가 사용자의 진위를 확인할 수 있도록 키와 인증서를 보유한 컨텍스트를 작성합니다. 그런 다음 소켓을 열고 포트에 바인딩 한 다음 &lt;code&gt;listen()&lt;/code&gt; 을 호출 하고 클라이언트가 연결되기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="93d8949164ba6462cf8fdab9836ce0f2c519f424" translate="yes" xml:space="preserve">
          <source>For short options (options only one character long), the option and its value can be concatenated:</source>
          <target state="translated">짧은 옵션 (한 문자 길이 만 옵션)의 경우 옵션과 해당 값을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8894fe625e330e22f451e4d7a6fe84725760ab62" translate="yes" xml:space="preserve">
          <source>For simple text calendars this module provides the following functions.</source>
          <target state="translated">간단한 텍스트 달력의 경우이 모듈은 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f002790c6797d5ebea652915cb6f6647fee569f5" translate="yes" xml:space="preserve">
          <source>For some &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;s, Python displays the character position of the syntax error, using a &lt;code&gt;^&lt;/code&gt; marker:</source>
          <target state="translated">일부 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 의 경우, Python은 &lt;code&gt;^&lt;/code&gt; 마커를 사용하여 구문 오류의 문자 위치를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2a42a868523cbc58a8db9f025c08ecb1cde2a8d5" translate="yes" xml:space="preserve">
          <source>For some applications, it may be more convenient to have the least integer &lt;em&gt;a&lt;/em&gt; such that &lt;em&gt;n&lt;/em&gt; &amp;le; &lt;em&gt;a&lt;/em&gt;&amp;sup2;, or in other words the ceiling of the exact square root of &lt;em&gt;n&lt;/em&gt;. For positive &lt;em&gt;n&lt;/em&gt;, this can be computed using &lt;code&gt;a = 1 + isqrt(n - 1)&lt;/code&gt;.</source>
          <target state="translated">일부 응용의 경우, &lt;em&gt;n&lt;/em&gt; &amp;le; &lt;em&gt;a&lt;/em&gt; &amp;sup2; 또는 다른 말로 &lt;em&gt;n&lt;/em&gt; 의 정확한 제곱근의 천장 과 같은 최소 정수 &lt;em&gt;a&lt;/em&gt; 를 갖는 것이 더 편리 할 수 ​​있습니다 . 양수 &lt;em&gt;n의&lt;/em&gt; 경우 &lt;code&gt;a = 1 + isqrt(n - 1)&lt;/code&gt; 사용하여 계산할 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="648573c91e5f02118dab0f39da9d75637b36572a" translate="yes" xml:space="preserve">
          <source>For some use cases, there are good alternatives to &lt;a href=&quot;#sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;. The preferred, fast way to concatenate a sequence of strings is by calling &lt;code&gt;''.join(sequence)&lt;/code&gt;. To add floating point values with extended precision, see &lt;a href=&quot;math#math.fsum&quot;&gt;&lt;code&gt;math.fsum()&lt;/code&gt;&lt;/a&gt;. To concatenate a series of iterables, consider using &lt;a href=&quot;itertools#itertools.chain&quot;&gt;&lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 유스 케이스의 경우 &lt;a href=&quot;#sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; 대신 좋은 대안이 있습니다 . 일련의 문자열을 연결하는 선호되는 빠른 방법은 &lt;code&gt;''.join(sequence)&lt;/code&gt; 호출하는 것 입니다. 확장 된 정밀도로 부동 소수점 값을 추가하려면 &lt;a href=&quot;math#math.fsum&quot;&gt; &lt;code&gt;math.fsum()&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 일련의 &lt;a href=&quot;itertools#itertools.chain&quot;&gt; &lt;code&gt;itertools.chain()&lt;/code&gt; &lt;/a&gt; 을 연결하려면 itertools.chain () 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="96785c718078e7660a88cdec515cc89c2714da8a" translate="yes" xml:space="preserve">
          <source>For sorting examples and a brief sorting tutorial, see &lt;a href=&quot;https://docs.python.org/3.8/howto/sorting.html#sortinghowto&quot;&gt;Sorting HOW TO&lt;/a&gt;.</source>
          <target state="translated">정렬 예제 및 간단한 정렬 자습서는 &lt;a href=&quot;https://docs.python.org/3.8/howto/sorting.html#sortinghowto&quot;&gt;정렬 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2029c5ee892a94642125539a40e6d42df89f30e" translate="yes" xml:space="preserve">
          <source>For special purposes, there is a second format for &lt;em&gt;mode&lt;/em&gt;: &lt;code&gt;'filemode|[compression]'&lt;/code&gt;. &lt;a href=&quot;#tarfile.open&quot;&gt;&lt;code&gt;tarfile.open()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#tarfile.TarFile&quot;&gt;&lt;code&gt;TarFile&lt;/code&gt;&lt;/a&gt; object that processes its data as a stream of blocks. No random seeking will be done on the file. If given, &lt;em&gt;fileobj&lt;/em&gt; may be any object that has a &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;write()&lt;/code&gt; method (depending on the &lt;em&gt;mode&lt;/em&gt;). &lt;em&gt;bufsize&lt;/em&gt; specifies the blocksize and defaults to &lt;code&gt;20 * 512&lt;/code&gt; bytes. Use this variant in combination with e.g. &lt;code&gt;sys.stdin&lt;/code&gt;, a socket &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; or a tape device. However, such a &lt;a href=&quot;#tarfile.TarFile&quot;&gt;&lt;code&gt;TarFile&lt;/code&gt;&lt;/a&gt; object is limited in that it does not allow random access, see &lt;a href=&quot;#tar-examples&quot;&gt;Examples&lt;/a&gt;. The currently possible modes:</source>
          <target state="translated">특별한 목적을위한 두 번째 형식이 &lt;em&gt;모드&lt;/em&gt; : &lt;code&gt;'filemode|[compression]'&lt;/code&gt; . &lt;a href=&quot;#tarfile.open&quot;&gt; &lt;code&gt;tarfile.open()&lt;/code&gt; &lt;/a&gt; 은 데이터를 블록 스트림으로 처리 하는 &lt;a href=&quot;#tarfile.TarFile&quot;&gt; &lt;code&gt;TarFile&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 파일에서 무작위 검색을 수행하지 않습니다. 주어진 경우, &lt;em&gt;fileobj&lt;/em&gt; 는 &lt;code&gt;read()&lt;/code&gt; 또는 &lt;code&gt;write()&lt;/code&gt; 메소드 가있는 모든 오브젝트 일 수 있습니다 ( &lt;em&gt;mode&lt;/em&gt; 에 따라 다름 ). &lt;em&gt;bufsize&lt;/em&gt; 는 블록 크기를 지정하고 기본값은 &lt;code&gt;20 * 512&lt;/code&gt; 바이트입니다. 이 변형을 &lt;code&gt;sys.stdin&lt;/code&gt; , 소켓 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 또는 테이프 장치 와 함께 사용하십시오 . 그러나 이러한 &lt;a href=&quot;#tarfile.TarFile&quot;&gt; &lt;code&gt;TarFile&lt;/code&gt; &lt;/a&gt;객체는 임의 액세스를 허용하지 않는다는 점에서 제한됩니다 ( &lt;a href=&quot;#tar-examples&quot;&gt;예제&lt;/a&gt; 참조) . 현재 가능한 모드 :</target>
        </trans-unit>
        <trans-unit id="9e724cc7dd34b70754120633fc82a51404b0a117" translate="yes" xml:space="preserve">
          <source>For supported platforms, &lt;em&gt;reuse_port&lt;/em&gt; can be used as a replacement for similar functionality. With &lt;em&gt;reuse_port&lt;/em&gt;, &lt;code&gt;SO_REUSEPORT&lt;/code&gt; is used instead, which specifically prevents processes with differing UIDs from assigning sockets to the same socket address.</source>
          <target state="translated">지원되는 플랫폼의 경우 &lt;em&gt;reuse_port&lt;/em&gt; 를 유사한 기능의 대체품으로 사용할 수 있습니다. 함께 &lt;em&gt;reuse_port&lt;/em&gt; , &lt;code&gt;SO_REUSEPORT&lt;/code&gt; 은 특히 동일한 소켓 소켓 주소로 할당 된 UID와 상이한 프로세스를 차단하는 대신에 사용된다.</target>
        </trans-unit>
        <trans-unit id="5159af1687415ddd28bfc2a1995bd20e96f9261b" translate="yes" xml:space="preserve">
          <source>For syntax errors - the compiler error message.</source>
          <target state="translated">구문 오류의 경우-컴파일러 오류 메시지</target>
        </trans-unit>
        <trans-unit id="b24d7db1fe29e271ea208c62a0cee2d863f7cfbe" translate="yes" xml:space="preserve">
          <source>For syntax errors - the file name where the error occurred.</source>
          <target state="translated">구문 오류의 경우-오류가 발생한 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fb118c31346734709d1426db6d074b4207011e55" translate="yes" xml:space="preserve">
          <source>For syntax errors - the line number where the error occurred.</source>
          <target state="translated">구문 오류의 경우-오류가 발생한 행 번호입니다.</target>
        </trans-unit>
        <trans-unit id="6b624e7edfb4d519a13cd70f09d17bbd81f6bbd3" translate="yes" xml:space="preserve">
          <source>For syntax errors - the offset into the text where the error occurred.</source>
          <target state="translated">구문 오류의 경우-오류가 발생한 텍스트의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="c9aff1846aa222da04f164ff51a044fe126a6c43" translate="yes" xml:space="preserve">
          <source>For syntax errors - the text where the error occurred.</source>
          <target state="translated">구문 오류의 경우-오류가 발생한 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="16bafc4e77e27d861636281e2b19c7e7fd37650e" translate="yes" xml:space="preserve">
          <source>For testcase &lt;em&gt;test&lt;/em&gt;, assert that the &lt;code&gt;sys.getsizeof&lt;/code&gt; for &lt;em&gt;o&lt;/em&gt; plus the GC header size equals &lt;em&gt;size&lt;/em&gt;.</source>
          <target state="translated">테스트 케이스를 들어 &lt;em&gt;테스트&lt;/em&gt; , 어설 것을 &lt;code&gt;sys.getsizeof&lt;/code&gt; 에 대한 &lt;em&gt;오&lt;/em&gt; 플러스 GC 헤더 크기는 동일 &lt;em&gt;크기&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="eedb78895083bc4249b703fbfb11d74b4c08f51f" translate="yes" xml:space="preserve">
          <source>For text encodings and bytes-to-bytes codecs, &lt;em&gt;input&lt;/em&gt; must be a bytes object or one which provides the read-only buffer interface &amp;ndash; for example, buffer objects and memory mapped files.</source>
          <target state="translated">텍스트 인코딩 및 바이트-바이트 바이트 코덱의 경우 &lt;em&gt;입력&lt;/em&gt; 은 바이트 객체이거나 읽기 전용 버퍼 인터페이스 (예 : 버퍼 객체 및 메모리 매핑 파일)를 제공하는 바이트 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4ede7b9bd3827048a9fc41eb186f8c2ae84f6480" translate="yes" xml:space="preserve">
          <source>For text mode, a &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; object is created, and wrapped in an &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; instance with the specified encoding, error handling behavior, and line ending(s).</source>
          <target state="translated">텍스트 모드의 경우 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 객체가 만들어지고 지정된 인코딩, 오류 처리 동작 및 줄 끝으로 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; 인스턴스에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2fd028679f350a23785663a8ce425b5391b8814" translate="yes" xml:space="preserve">
          <source>For text mode, a &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; object is created, and wrapped in an &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; instance with the specified encoding, error handling behavior, and line ending(s).</source>
          <target state="translated">텍스트 모드의 경우 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 객체가 만들어지고 지정된 인코딩, 오류 처리 동작 및 줄 끝으로 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; 인스턴스에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c05c8db2bd0aaaf25d15dba3e01523970a643f1" translate="yes" xml:space="preserve">
          <source>For text mode, a &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; object is created, and wrapped in an &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; instance with the specified encoding, error handling behavior, and line ending(s).</source>
          <target state="translated">텍스트 모드의 경우 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 객체가 만들어지고 지정된 인코딩, 오류 처리 동작 및 줄 끝으로 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; 인스턴스에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="7deee04b6bb5f78a5dbf6565cdba6d3b455b142f" translate="yes" xml:space="preserve">
          <source>For the &lt;a href=&quot;#datetime.datetime.strptime&quot;&gt;&lt;code&gt;datetime.strptime()&lt;/code&gt;&lt;/a&gt; class method, the default value is &lt;code&gt;1900-01-01T00:00:00.000&lt;/code&gt;: any components not specified in the format string will be pulled from the default value. &lt;a href=&quot;#id8&quot; id=&quot;id4&quot;&gt;4&lt;/a&gt;</source>
          <target state="translated">를 들어 &lt;a href=&quot;#datetime.datetime.strptime&quot;&gt; &lt;code&gt;datetime.strptime()&lt;/code&gt; &lt;/a&gt; 클래스 메소드, 기본 값은 &lt;code&gt;1900-01-01T00:00:00.000&lt;/code&gt; : 형식 문자열에 지정되지 않은 모든 구성 요소는 기본 값에서 가져온 것입니다. &lt;a href=&quot;#id8&quot; id=&quot;id4&quot;&gt;4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bb5071a479f35cf824cac2d9cf3dc01818e29a8" translate="yes" xml:space="preserve">
          <source>For the &lt;a href=&quot;#math.ceil&quot;&gt;&lt;code&gt;ceil()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#math.floor&quot;&gt;&lt;code&gt;floor()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#math.modf&quot;&gt;&lt;code&gt;modf()&lt;/code&gt;&lt;/a&gt; functions, note that &lt;em&gt;all&lt;/em&gt; floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float &lt;em&gt;x&lt;/em&gt; with &lt;code&gt;abs(x) &amp;gt;= 2**52&lt;/code&gt; necessarily has no fractional bits.</source>
          <target state="translated">를 들어 &lt;a href=&quot;#math.ceil&quot;&gt; &lt;code&gt;ceil()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#math.floor&quot;&gt; &lt;code&gt;floor()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#math.modf&quot;&gt; &lt;code&gt;modf()&lt;/code&gt; &lt;/a&gt; 함수를 참고 &lt;em&gt;모든&lt;/em&gt; 충분히 큰 크기의 부동 소수점 숫자는 정확한 정수입니다. 파이썬 플로트는 일반적으로 53 비트 이하의 정밀도 (플랫폼 C 더블 타입과 동일)를 가지는데,이 경우 &lt;code&gt;abs(x) &amp;gt;= 2**52&lt;/code&gt; float &lt;em&gt;x&lt;/em&gt; 는 반드시 소수 비트를 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52f764e70635b353f2ccd83e7d601c4b5abba3dd" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;'?'&lt;/code&gt; format character, the return value is either &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. When packing, the truth value of the argument object is used. Either 0 or 1 in the native or standard bool representation will be packed, and any non-zero value will be &lt;code&gt;True&lt;/code&gt; when unpacking.</source>
          <target state="translated">를 들어 &lt;code&gt;'?'&lt;/code&gt; 형식 문자에서 리턴 값은 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 입니다. 패킹 할 때 인수 오브젝트의 실제 값이 사용됩니다. 기본 또는 표준 부울 표현에서 0 또는 1이 압축되고 압축을 풀 때 0이 아닌 값은 &lt;code&gt;True&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="611001d6738e1356ca1e9161015c1526eb451d76" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;'f'&lt;/code&gt;, &lt;code&gt;'d'&lt;/code&gt; and &lt;code&gt;'e'&lt;/code&gt; conversion codes, the packed representation uses the IEEE 754 binary32, binary64 or binary16 format (for &lt;code&gt;'f'&lt;/code&gt;, &lt;code&gt;'d'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt; respectively), regardless of the floating-point format used by the platform.</source>
          <target state="translated">내용은 &lt;code&gt;'f'&lt;/code&gt; , &lt;code&gt;'d'&lt;/code&gt; 및 &lt;code&gt;'e'&lt;/code&gt; 변환 코딩, 압축 된 표현은 IEEE 754 binary32 사용 binary64 또는 binary16 포맷 (위한 &lt;code&gt;'f'&lt;/code&gt; , &lt;code&gt;'d'&lt;/code&gt; 또는 &lt;code&gt;'e'&lt;/code&gt; 에 관계없이 부동의 각각) 플랫폼에서 사용하는 포인트 형식</target>
        </trans-unit>
        <trans-unit id="7f192f51888cd6acd09ccae9c792d0d145d044ae" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;'s'&lt;/code&gt; format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, &lt;code&gt;'10s'&lt;/code&gt; means a single 10-byte string, while &lt;code&gt;'10c'&lt;/code&gt; means 10 characters. If a count is not given, it defaults to 1. For packing, the string is truncated or padded with null bytes as appropriate to make it fit. For unpacking, the resulting bytes object always has exactly the specified number of bytes. As a special case, &lt;code&gt;'0s'&lt;/code&gt; means a single, empty string (while &lt;code&gt;'0c'&lt;/code&gt; means 0 characters).</source>
          <target state="translated">를 들어 &lt;code&gt;'s'&lt;/code&gt; 형식 문자의 수는 바이트의 길이 아닌 다른 형식의 문자와 같은 반복 횟수로 해석됩니다; 예를 들어, &lt;code&gt;'10s'&lt;/code&gt; 는 단일 10 바이트 문자열을 의미 하고 &lt;code&gt;'10c'&lt;/code&gt; 는 10자를 의미합니다. 개수를 지정하지 않으면 기본값은 1로 설정됩니다. 패킹의 경우 문자열이 잘 리도록 문자열이 잘 리거나 널 바이트로 채워집니다. 압축 풀기의 경우 결과 바이트 개체에는 항상 지정된 바이트 수가 있습니다. 특별한 경우 &lt;code&gt;'0s'&lt;/code&gt; 는 하나의 빈 문자열을 의미 하며 &lt;code&gt;'0c'&lt;/code&gt; 는 0자를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7a57bec2e014081dae4b27453586de233679ac55" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;Document&lt;/code&gt; node, an additional keyword argument &lt;em&gt;encoding&lt;/em&gt; can be used to specify the encoding field of the XML header.</source>
          <target state="translated">를 들어 &lt;code&gt;Document&lt;/code&gt; 노드 추가 키워드 인수 &lt;em&gt;인코딩&lt;/em&gt; 은 XML 헤더의 인코딩 필드를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e765b069ab6f4fd670732d7dd9f9ae6b12c9e58d" translate="yes" xml:space="preserve">
          <source>For the &lt;em&gt;isolation_level&lt;/em&gt; parameter, please see the &lt;a href=&quot;#sqlite3.Connection.isolation_level&quot;&gt;&lt;code&gt;isolation_level&lt;/code&gt;&lt;/a&gt; property of &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">를 들어 &lt;em&gt;파라미터 isolation_level&lt;/em&gt; 매개 변수의 참조하시기 바랍니다 &lt;a href=&quot;#sqlite3.Connection.isolation_level&quot;&gt; &lt;code&gt;isolation_level&lt;/code&gt; &lt;/a&gt; 의 특성 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="a8ffbaaffc9a1867b68ff05863b8b09074fd8418" translate="yes" xml:space="preserve">
          <source>For the &lt;em&gt;names&lt;/em&gt; parameter, please see the description of the translation object&amp;rsquo;s &lt;a href=&quot;#gettext.NullTranslations.install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">를 들어 &lt;em&gt;이름&lt;/em&gt; 매개 변수, 번역 객체의 설명을 참조하시기 바랍니다 &lt;a href=&quot;#gettext.NullTranslations.install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="b4c0224e26f9eea1c70ca73fc7698daec9161151" translate="yes" xml:space="preserve">
          <source>For the Python events, specialized functions (see below) are called. For the C events, no action is taken.</source>
          <target state="translated">Python 이벤트의 경우 특수 함수 (아래 참조)가 호출됩니다. C 이벤트의 경우 조치가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13289039e0f8416eb74312f3daa07466ee8be0ee" translate="yes" xml:space="preserve">
          <source>For the above Timezone constants (&lt;a href=&quot;#time.altzone&quot;&gt;&lt;code&gt;altzone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.daylight&quot;&gt;&lt;code&gt;daylight&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.tzname&quot;&gt;&lt;code&gt;tzname&lt;/code&gt;&lt;/a&gt;), the value is determined by the timezone rules in effect at module load time or the last time &lt;a href=&quot;#time.tzset&quot;&gt;&lt;code&gt;tzset()&lt;/code&gt;&lt;/a&gt; is called and may be incorrect for times in the past. It is recommended to use the &lt;code&gt;tm_gmtoff&lt;/code&gt; and &lt;code&gt;tm_zone&lt;/code&gt; results from &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; to obtain timezone information.</source>
          <target state="translated">위의 시간대 상수 ( &lt;a href=&quot;#time.altzone&quot;&gt; &lt;code&gt;altzone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.daylight&quot;&gt; &lt;code&gt;daylight&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.tzname&quot;&gt; &lt;code&gt;tzname&lt;/code&gt; &lt;/a&gt; )의 경우, 값은 모듈로드 시간 또는 &lt;a href=&quot;#time.tzset&quot;&gt; &lt;code&gt;tzset()&lt;/code&gt; &lt;/a&gt; 이 마지막으로 호출 된 시간에 적용되는 시간대 규칙에 의해 결정되며 과거의 시간에는 올바르지 않을 수 있습니다. &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;tm_gmtoff&lt;/code&gt; 및 &lt;code&gt;tm_zone&lt;/code&gt; 결과 를 사용하여 시간대 정보를 얻는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7b9a64815701e952e36b227a62e8302ec1c91dee" translate="yes" xml:space="preserve">
          <source>For the benefit of object persistence, the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module supports the notion of a reference to an object outside the pickled data stream. Such objects are referenced by a persistent ID, which should be either a string of alphanumeric characters (for protocol 0) &lt;a href=&quot;#id11&quot; id=&quot;id6&quot;&gt;5&lt;/a&gt; or just an arbitrary object (for any newer protocol).</source>
          <target state="translated">객체 지속성의 이점을 위해 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 피클 링 된 데이터 스트림 외부의 객체에 대한 참조 개념을 지원합니다. 이러한 객체는 영숫자 문자열 (프로토콜 0의 경우) &lt;a href=&quot;#id11&quot; id=&quot;id6&quot;&gt;5&lt;/a&gt; 또는 임의의 객체 (최신의 프로토콜의 경우) 인 영구 ID로 참조됩니다 .</target>
        </trans-unit>
        <trans-unit id="b045188bbc955a84058e3770ed7a3666adb42d3f" translate="yes" xml:space="preserve">
          <source>For the benefits of packaging tool authors and users seeking a deeper understanding of the details of the current packaging and distribution system, the legacy &lt;a href=&quot;#module-distutils&quot;&gt;&lt;code&gt;distutils&lt;/code&gt;&lt;/a&gt; based user documentation and API reference remain available:</source>
          <target state="translated">패키징 도구 제작자와 현재 패키징 및 배포 시스템의 세부 사항에 대한 심층적 인 이해를 원하는 사용자의 이점을 위해 레거시 &lt;a href=&quot;#module-distutils&quot;&gt; &lt;code&gt;distutils&lt;/code&gt; &lt;/a&gt; 기반 사용자 설명서 및 API 참조를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1462943ac090bb5ad3073f88b1c8562ef1b6a082" translate="yes" xml:space="preserve">
          <source>For the built-in types supporting &lt;a href=&quot;#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt;, values are rounded to the closest multiple of 10 to the power minus &lt;em&gt;ndigits&lt;/em&gt;; if two multiples are equally close, rounding is done toward the even choice (so, for example, both &lt;code&gt;round(0.5)&lt;/code&gt; and &lt;code&gt;round(-0.5)&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;round(1.5)&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;). Any integer value is valid for &lt;em&gt;ndigits&lt;/em&gt; (positive, zero, or negative). The return value is an integer if &lt;em&gt;ndigits&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;. Otherwise the return value has the same type as &lt;em&gt;number&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; 지원하는 내장 유형의 경우 , 값은 10의 가장 가까운 배수에서 10을 뺀 &lt;em&gt;n 자리로 반올림됩니다&lt;/em&gt; . 두 배수가 동일하게 가까운 경우 반올림은 짝수 선택으로 수행됩니다 (예를 들어 &lt;code&gt;round(0.5)&lt;/code&gt; 와 &lt;code&gt;round(-0.5)&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 이고 &lt;code&gt;round(1.5)&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; ). 모든 정수 값은 &lt;em&gt;n 숫자&lt;/em&gt; (양수, 0 또는 음수)에 유효합니다 . &lt;em&gt;ndigits&lt;/em&gt; 가 생략되거나 &lt;code&gt;None&lt;/code&gt; 이면 리턴 값은 정수 입니다. 그렇지 않으면 리턴 값은 &lt;em&gt;number&lt;/em&gt; 와 동일한 유형을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="73a23e456670e90cd6606464d13a857da8671966" translate="yes" xml:space="preserve">
          <source>For the following attributes, see the corresponding documentation of the &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt;&lt;code&gt;IPv4Address&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">다음 속성에 대해서는 해당 &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt; &lt;code&gt;IPv4Address&lt;/code&gt; &lt;/a&gt; 클래스 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2be20c20d73d48c96e4a903fa7ca4c398ed3e7e" translate="yes" xml:space="preserve">
          <source>For the majority of new code, &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; are strongly recommended, since &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; break some semantic promises of an enumeration (by being comparable to integers, and thus by transitivity to other unrelated enumerations). &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; should be used only in cases where &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; will not do; for example, when integer constants are replaced with enumerations, or for interoperability with other systems.</source>
          <target state="translated">&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 는 열거 형에 대한 의미 론적 약속 (정수와 비교 가능하고 따라서 다른 관련없는 열거 형과의 전이에 의해)을 위반하기 때문에 대부분의 새 코드의 경우 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 를 적극 권장 합니다. &lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 가 수행하지 않는 경우에만 사용해야합니다 . 예를 들어 정수 상수가 열거로 대체되거나 다른 시스템과의 상호 운용성을 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71b157ee65429737704fc6d86dc2ce45635ad80d" translate="yes" xml:space="preserve">
          <source>For the same reason, handling of format strings containing Unicode code points that can&amp;rsquo;t be represented in the charset of the current locale is also platform-dependent. On some platforms such code points are preserved intact in the output, while on others &lt;code&gt;strftime&lt;/code&gt; may raise &lt;a href=&quot;exceptions#UnicodeError&quot;&gt;&lt;code&gt;UnicodeError&lt;/code&gt;&lt;/a&gt; or return an empty string instead.</source>
          <target state="translated">같은 이유로 현재 로케일의 문자 세트로 표현할 수없는 유니 코드 코드 포인트를 포함하는 형식 문자열을 처리하는 것도 플랫폼에 따라 다릅니다. 일부 플랫폼에서는 이러한 코드 포인트가 출력에 그대로 유지되고 다른 플랫폼에서는 &lt;code&gt;strftime&lt;/code&gt; 이 &lt;a href=&quot;exceptions#UnicodeError&quot;&gt; &lt;code&gt;UnicodeError&lt;/code&gt; 를 발생&lt;/a&gt; 시키거나 대신 빈 문자열을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a73815f89f761330d046832365445a6b98cdffe" translate="yes" xml:space="preserve">
          <source>For the simplest code, use the &lt;a href=&quot;#pickle.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">가장 간단한 코드의 경우 &lt;a href=&quot;#pickle.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f1e544ac7100874cff048477249bb3ab3c46c877" translate="yes" xml:space="preserve">
          <source>For the string argument, abbreviations can be used for any key names, as long as the abbreviation is unambiguous.</source>
          <target state="translated">문자열 인수의 경우 약어가 명확하지 않은 한 모든 키 이름에 약어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f6887a34bff030cddfd82bd93f8fa6b82b32ef" translate="yes" xml:space="preserve">
          <source>For the subset of &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; format strings currently supported by &lt;a href=&quot;#memoryview.tolist&quot;&gt;&lt;code&gt;tolist()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; are equal if &lt;code&gt;v.tolist() == w.tolist()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#memoryview.tolist&quot;&gt; &lt;code&gt;tolist()&lt;/code&gt; &lt;/a&gt; 에서 현재 지원되는 &lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 형식 문자열 의 하위 집합에 대해 &lt;code&gt;v.tolist() == w.tolist()&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 와 &lt;code&gt;w&lt;/code&gt; 는 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e73a0afbcd4ef09c3f17e9fa247b96c32dcb9705" translate="yes" xml:space="preserve">
          <source>For the time being this module is intended to be called as a script. However it is possible to import it into an IDE and use the function &lt;a href=&quot;#tabnanny.check&quot;&gt;&lt;code&gt;check()&lt;/code&gt;&lt;/a&gt; described below.</source>
          <target state="translated">당분간이 모듈은 스크립트라고 부릅니다. 그러나 IDE로 가져 와서 아래 설명 된 &lt;a href=&quot;#tabnanny.check&quot;&gt; &lt;code&gt;check()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca2089e1b1b8df1c2f032b1f3536ad34cfdfa0f" translate="yes" xml:space="preserve">
          <source>For these cases, the &lt;a href=&quot;#ctypes.cast&quot;&gt;&lt;code&gt;cast()&lt;/code&gt;&lt;/a&gt; function is handy.</source>
          <target state="translated">이 경우 &lt;a href=&quot;#ctypes.cast&quot;&gt; &lt;code&gt;cast()&lt;/code&gt; &lt;/a&gt; 함수가 편리합니다.</target>
        </trans-unit>
        <trans-unit id="38474aedf079e8a0abf4fea4dc3de7267bfeb1eb" translate="yes" xml:space="preserve">
          <source>For these objects, only the interfaces are relevant; they are normally not instantiated by the application itself. Since Python does not have an explicit notion of interface, they are formally introduced as classes, but applications may use implementations which do not inherit from the provided classes. The &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.Locator&quot;&gt;&lt;code&gt;Locator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Attributes&lt;/code&gt;, &lt;code&gt;AttributesNS&lt;/code&gt;, and &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt; interfaces are defined in the module &lt;a href=&quot;xml.sax.reader#module-xml.sax.xmlreader&quot;&gt;&lt;code&gt;xml.sax.xmlreader&lt;/code&gt;&lt;/a&gt;. The handler interfaces are defined in &lt;a href=&quot;xml.sax.handler#module-xml.sax.handler&quot;&gt;&lt;code&gt;xml.sax.handler&lt;/code&gt;&lt;/a&gt;. For convenience, &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; (which is often instantiated directly) and the handler classes are also available from &lt;a href=&quot;#module-xml.sax&quot;&gt;&lt;code&gt;xml.sax&lt;/code&gt;&lt;/a&gt;. These interfaces are described below.</source>
          <target state="translated">이러한 객체의 경우 인터페이스 만 관련됩니다. 일반적으로 응용 프로그램 자체에서 인스턴스화되지 않습니다. 파이썬에는 명시적인 인터페이스 개념이 없기 때문에 공식적으로 클래스로 소개되지만 애플리케이션은 제공된 클래스에서 상속되지 않은 구현을 사용할 수 있습니다. &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; 를&lt;/a&gt; , &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.Locator&quot;&gt; &lt;code&gt;Locator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Attributes&lt;/code&gt; , &lt;code&gt;AttributesNS&lt;/code&gt; 과 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt; 인터페이스 모듈에 정의 &lt;a href=&quot;xml.sax.reader#module-xml.sax.xmlreader&quot;&gt; &lt;code&gt;xml.sax.xmlreader&lt;/code&gt; &lt;/a&gt; . 처리기 인터페이스는 &lt;a href=&quot;xml.sax.handler#module-xml.sax.handler&quot;&gt; &lt;code&gt;xml.sax.handler&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 . 편의상 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt; (종종 직접 인스턴스화 됨) 및 핸들러 클래스도 &lt;a href=&quot;#module-xml.sax&quot;&gt; &lt;code&gt;xml.sax&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .. 이러한 인터페이스는 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee46acf978b898ca00a8f81ccc140323b27a7cf5" translate="yes" xml:space="preserve">
          <source>For this reason, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; also supports a notion of &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; reporting flags specific to &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; support, via this function:</source>
          <target state="translated">이러한 이유로 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 다음 함수를 통해 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 지원에 특정한 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 보고 플래그 개념을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c13f2c1afd203047a3facf9de7c005252d73b85c" translate="yes" xml:space="preserve">
          <source>For this reason, &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; provides a &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt;&lt;code&gt;FunctionTestCase&lt;/code&gt;&lt;/a&gt; class. This subclass of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; can be used to wrap an existing test function. Set-up and tear-down functions can also be provided.</source>
          <target state="translated">이러한 이유로 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt; &lt;code&gt;FunctionTestCase&lt;/code&gt; &lt;/a&gt; 클래스를 제공합니다 . 이 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 서브 클래스 는 기존 테스트 기능을 랩핑하는 데 사용될 수 있습니다. 설정 및 분해 기능도 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a7e5d1693de8c1b6156055b18a67eb702cc5ca" translate="yes" xml:space="preserve">
          <source>For this reason, you may want to control what gets unpickled by customizing &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt;&lt;code&gt;Unpickler.find_class()&lt;/code&gt;&lt;/a&gt;. Unlike its name suggests, &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt;&lt;code&gt;Unpickler.find_class()&lt;/code&gt;&lt;/a&gt; is called whenever a global (i.e., a class or a function) is requested. Thus it is possible to either completely forbid globals or restrict them to a safe subset.</source>
          <target state="translated">이러한 이유로 &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt; &lt;code&gt;Unpickler.find_class()&lt;/code&gt; &lt;/a&gt; 를 사용자 정의하여 피클 링되지 않는 항목을 제어 할 수 있습니다 . 이름에서 알 수 있듯이 전역 (예 : 클래스 또는 함수)이 요청 될 때마다 &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt; &lt;code&gt;Unpickler.find_class()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 따라서 전역을 완전히 금지하거나 안전한 하위 집합으로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e17084e55d94584dbb25c342418d6aac7734b582" translate="yes" xml:space="preserve">
          <source>For those cases, it is possible to subclass from the &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; class and implement a &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt;&lt;code&gt;reducer_override()&lt;/code&gt;&lt;/a&gt; method. This method can return an arbitrary reduction tuple (see &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt;). It can alternatively return &lt;code&gt;NotImplemented&lt;/code&gt; to fallback to the traditional behavior.</source>
          <target state="translated">이러한 경우 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 클래스 에서 서브 클래스를 작성하고 &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt; &lt;code&gt;reducer_override()&lt;/code&gt; &lt;/a&gt; 메소드를 구현할 수 있습니다. 이 메소드는 임의 감소 튜플을 리턴 할 수 있습니다 ( &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 참조 ). 또는 기존의 동작으로 대체하기 위해 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6d2305fa8501efef901d74c92da8478ba9fafef" translate="yes" xml:space="preserve">
          <source>For those who want to manage their own token length, you can explicitly specify how much randomness is used for tokens by giving an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; argument to the various &lt;code&gt;token_*&lt;/code&gt; functions. That argument is taken as the number of bytes of randomness to use.</source>
          <target state="translated">자체 토큰 길이를 관리하려는 경우 다양한 &lt;code&gt;token_*&lt;/code&gt; 함수에 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 인수를 지정하여 토큰에 사용되는 임의의 정도를 명시 적으로 지정할 수 있습니다 . 이 인수는 사용할 임의 바이트 수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bab28f84b72c604f4046046ab996c3eb0c3e68fd" translate="yes" xml:space="preserve">
          <source>For top-level classes, None. For nested classes, the parent.</source>
          <target state="translated">최상위 클래스의 경우 없음 중첩 클래스의 경우 부모입니다.</target>
        </trans-unit>
        <trans-unit id="d182afd5a541d26e3f1ed845af8ddb203dc4413e" translate="yes" xml:space="preserve">
          <source>For top-level functions, None. For nested functions, the parent.</source>
          <target state="translated">최상위 기능의 경우 없음 중첩 함수의 경우 부모입니다.</target>
        </trans-unit>
        <trans-unit id="6a78b493fd8c37102ee3eff14bfd254085325210" translate="yes" xml:space="preserve">
          <source>For use with &lt;code&gt;BTPROTO_HCI&lt;/code&gt;. &lt;a href=&quot;#socket.HCI_FILTER&quot;&gt;&lt;code&gt;HCI_FILTER&lt;/code&gt;&lt;/a&gt; is not available for NetBSD or DragonFlyBSD. &lt;a href=&quot;#socket.HCI_TIME_STAMP&quot;&gt;&lt;code&gt;HCI_TIME_STAMP&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.HCI_DATA_DIR&quot;&gt;&lt;code&gt;HCI_DATA_DIR&lt;/code&gt;&lt;/a&gt; are not available for FreeBSD, NetBSD, or DragonFlyBSD.</source>
          <target state="translated">&lt;code&gt;BTPROTO_HCI&lt;/code&gt; 와 함께 사용 하십시오 . NetBSD 또는 DragonFlyBSD에는 &lt;a href=&quot;#socket.HCI_FILTER&quot;&gt; &lt;code&gt;HCI_FILTER&lt;/code&gt; &lt;/a&gt; 를 사용할 수 없습니다. &lt;a href=&quot;#socket.HCI_TIME_STAMP&quot;&gt; &lt;code&gt;HCI_TIME_STAMP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.HCI_DATA_DIR&quot;&gt; &lt;code&gt;HCI_DATA_DIR&lt;/code&gt; &lt;/a&gt; 은 FreeBSD, NetBSD 또는 DragonFlyBSD에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed2b5ac8be7dacc4312f352c9b986cd446f431b3" translate="yes" xml:space="preserve">
          <source>For variable-keyword arguments (&lt;code&gt;**kwargs&lt;/code&gt;) the default is an empty dict.</source>
          <target state="translated">가변 키워드 인수 ( &lt;code&gt;**kwargs&lt;/code&gt; )의 경우 기본값은 빈 dict입니다.</target>
        </trans-unit>
        <trans-unit id="3dc4384699ee9666f410852cc46018f94c9db172" translate="yes" xml:space="preserve">
          <source>For variable-positional arguments (&lt;code&gt;*args&lt;/code&gt;) the default is an empty tuple.</source>
          <target state="translated">가변 위치 인수 ( &lt;code&gt;*args&lt;/code&gt; )의 경우 기본값은 빈 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="b7c7653bbef7bfc03abec2d286867e64e19e8e90" translate="yes" xml:space="preserve">
          <source>For whole format strings, use &lt;a href=&quot;#locale.format_string&quot;&gt;&lt;code&gt;format_string()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전체 형식 문자열에는 &lt;a href=&quot;#locale.format_string&quot;&gt; &lt;code&gt;format_string()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04d9e9125490dc0b44c13e9f2f792a0f9450932b" translate="yes" xml:space="preserve">
          <source>Force as many objects as possible to be collected. This is needed because timely deallocation is not guaranteed by the garbage collector. This means that &lt;code&gt;__del__&lt;/code&gt; methods may be called later than expected and weakrefs may remain alive for longer than expected.</source>
          <target state="translated">가능한 많은 개체를 수집하도록합니다. 가비지 수집기에서 적시에 할당 해제를 보장하지 않기 때문에이 작업이 필요합니다. 이는 &lt;code&gt;__del__&lt;/code&gt; 메소드가 예상보다 늦게 호출 될 수 있으며 weakref는 예상보다 오래 지속될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6a939f545eb3ce830f616a1a28bc1a63e0fe5ed3" translate="yes" xml:space="preserve">
          <source>Force buffered data to be transmitted to the client. It&amp;rsquo;s okay if this method is a no-op (i.e., if &lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt;&lt;code&gt;_write()&lt;/code&gt;&lt;/a&gt; actually sends the data).</source>
          <target state="translated">버퍼링 된 데이터가 클라이언트로 전송되도록합니다. 이 메소드가 no-op라면 (즉, &lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt; &lt;code&gt;_write()&lt;/code&gt; &lt;/a&gt; 실제로 데이터를 보내는 경우 ) 괜찮습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
