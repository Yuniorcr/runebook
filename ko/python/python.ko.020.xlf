<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="472e6487f68d04bf8fdb5f7c1716adfc521275a9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;memlimit&lt;/em&gt; argument specifies a limit (in bytes) on the amount of memory that the decompressor can use. When this argument is used, decompression will fail with an &lt;a href=&quot;#lzma.LZMAError&quot;&gt;&lt;code&gt;LZMAError&lt;/code&gt;&lt;/a&gt; if it is not possible to decompress the input within the given memory limit.</source>
          <target state="translated">&lt;em&gt;MEMLIMIT의&lt;/em&gt; 인자는 압축 해 제기가 사용할 수있는 메모리의 양 (바이트) 한계를 지정한다. 이 인수를 사용 하면 주어진 메모리 한계 내에서 입력을 압축 해제 할 수없는 경우 &lt;a href=&quot;#lzma.LZMAError&quot;&gt; &lt;code&gt;LZMAError&lt;/code&gt; &lt;/a&gt; 와 함께 압축 해제에 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5ed4f7ee0127a5c81a5c5fe6eca67c71e17a81c7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message_set&lt;/em&gt; options to commands below is a string specifying one or more messages to be acted upon. It may be a simple message number (&lt;code&gt;'1'&lt;/code&gt;), a range of message numbers (&lt;code&gt;'2:4'&lt;/code&gt;), or a group of non-contiguous ranges separated by commas (&lt;code&gt;'1:3,6:9'&lt;/code&gt;). A range can contain an asterisk to indicate an infinite upper bound (&lt;code&gt;'3:*'&lt;/code&gt;).</source>
          <target state="translated">아래의 명령에 대한 &lt;em&gt;message_set&lt;/em&gt; 옵션은 수행 할 하나 이상의 메시지를 지정하는 문자열입니다. 간단한 메시지 번호 ( &lt;code&gt;'1'&lt;/code&gt; ), 메시지 번호 범위 ( &lt;code&gt;'2:4'&lt;/code&gt; ) 또는 쉼표로 구분 된 비 연속 범위 그룹 ( &lt;code&gt;'1:3,6:9'&lt;/code&gt; ) 일 수 있습니다. 범위에는 무한한 상한을 나타내는 별표가 포함될 수 있습니다 ( &lt;code&gt;'3:*'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1ac518a8261cd76e3d572450cd69c2da8d19e734" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;method&lt;/em&gt; for computing quantiles can be varied depending on whether the &lt;em&gt;data&lt;/em&gt; includes or excludes the lowest and highest possible values from the population.</source>
          <target state="translated">&lt;em&gt;방법&lt;/em&gt; 컴퓨팅 분위수 대한이 있는지에 따라 변경 될 수 &lt;em&gt;데이터가&lt;/em&gt; 포함 또는 모집단에서 제외 최저 및 최고 가능한 값.</target>
        </trans-unit>
        <trans-unit id="8ecb6288199428438fe4ea40f2513dfb74080c75" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mock&lt;/em&gt; argument is the mock object to configure. If &lt;code&gt;None&lt;/code&gt; (the default) then a &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; will be created for you, with the API limited to methods or attributes available on standard file handles.</source>
          <target state="translated">&lt;em&gt;모의&lt;/em&gt; 인수는 구성 할 수있는 모의 객체입니다. 경우 &lt;code&gt;None&lt;/code&gt; 다음 (기본값) &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; 이&lt;/a&gt; API를 사용하면 생성됩니다이 방법으로 제한하거나 표준 파일 핸들에 사용할 수 속성.</target>
        </trans-unit>
        <trans-unit id="895803f0fac68124dcdbdc694aeabdf8d07767b7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mod_name&lt;/em&gt; argument should be an absolute module name. If the module name refers to a package rather than a normal module, then that package is imported and the &lt;code&gt;__main__&lt;/code&gt; submodule within that package is then executed and the resulting module globals dictionary returned.</source>
          <target state="translated">&lt;em&gt;mod_name의&lt;/em&gt; 인수는 절대 모듈 이름이어야한다. 모듈 이름이 일반 모듈이 아닌 패키지를 참조하면 해당 패키지를 가져오고 해당 패키지 내의 &lt;code&gt;__main__&lt;/code&gt; 하위 모듈이 실행되고 결과 모듈 전역 사전이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a6df0bfcf373c1c06747418e51fd35f70f7733a3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;&quot;r&quot;&lt;/code&gt;, &lt;code&gt;&quot;rb&quot;&lt;/code&gt;, &lt;code&gt;&quot;w&quot;&lt;/code&gt;, &lt;code&gt;&quot;wb&quot;&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt;, &lt;code&gt;&quot;xb&quot;&lt;/code&gt;, &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt; for binary mode, or &lt;code&gt;&quot;rt&quot;&lt;/code&gt;, &lt;code&gt;&quot;wt&quot;&lt;/code&gt;, &lt;code&gt;&quot;xt&quot;&lt;/code&gt;, or &lt;code&gt;&quot;at&quot;&lt;/code&gt; for text mode. The default is &lt;code&gt;&quot;rb&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수있다 &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;rb&quot;&lt;/code&gt; , &lt;code&gt;&quot;w&quot;&lt;/code&gt; , &lt;code&gt;&quot;wb&quot;&lt;/code&gt; , &lt;code&gt;&quot;x&quot;&lt;/code&gt; , &lt;code&gt;&quot;xb&quot;&lt;/code&gt; , &lt;code&gt;&quot;a&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 이진 모드, 또는 &lt;code&gt;&quot;rt&quot;&lt;/code&gt; , &lt;code&gt;&quot;wt&quot;&lt;/code&gt; 텍스트 모드 인 경우 &lt;code&gt;&quot;xt&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;at&quot;&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;&quot;rb&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d1ad98a2dd540caaea8a1f22878e9101d4e6629" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'xb'&lt;/code&gt; for binary mode, or &lt;code&gt;'rt'&lt;/code&gt;, &lt;code&gt;'at'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, or &lt;code&gt;'xt'&lt;/code&gt; for text mode. The default is &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; , &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'xb'&lt;/code&gt; 바이너리 모드 또는 &lt;code&gt;'rt'&lt;/code&gt; , &lt;code&gt;'at'&lt;/code&gt; 텍스트 모드의 경우 &lt;code&gt;'wt'&lt;/code&gt; 또는 &lt;code&gt;'xt'&lt;/code&gt; 기본값은 &lt;code&gt;'rb'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e823bc32f269eed5bbc36974b6041d7caeefce7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'xb'&lt;/code&gt;, depending on whether the file will be read or written. The default is the mode of &lt;em&gt;fileobj&lt;/em&gt; if discernible; otherwise, the default is &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; , &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , 또는 &lt;code&gt;'xb'&lt;/code&gt; 파일이 판독 또는 기록되는지 여부에 따라, . 식별 가능한 경우 기본값은 &lt;em&gt;fileobj&lt;/em&gt; 의 모드입니다 . 그렇지 않으면 기본값은 &lt;code&gt;'rb'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05f2a9cda1e91039c7b1edb582c41248bba08bd5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, &lt;code&gt;'xb'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'ab'&lt;/code&gt; for binary mode, or &lt;code&gt;'rt'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, &lt;code&gt;'xt'&lt;/code&gt;, or &lt;code&gt;'at'&lt;/code&gt; for text mode. The default is &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , &lt;code&gt;'xb'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'ab'&lt;/code&gt; 바이너리 모드 또는 &lt;code&gt;'rt'&lt;/code&gt; , &lt;code&gt;'wt'&lt;/code&gt; 텍스트 모드의 경우 &lt;code&gt;'xt'&lt;/code&gt; 또는 &lt;code&gt;'at'&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;'rb'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f4dcb1c4c38de2058990b6b6c09d3880a922fe2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be either &lt;code&gt;&quot;r&quot;&lt;/code&gt; for reading (default), &lt;code&gt;&quot;w&quot;&lt;/code&gt; for overwriting, &lt;code&gt;&quot;x&quot;&lt;/code&gt; for exclusive creation, or &lt;code&gt;&quot;a&quot;&lt;/code&gt; for appending. These can equivalently be given as &lt;code&gt;&quot;rb&quot;&lt;/code&gt;, &lt;code&gt;&quot;wb&quot;&lt;/code&gt;, &lt;code&gt;&quot;xb&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab&quot;&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수가 될 수 있습니다 &lt;code&gt;&quot;r&quot;&lt;/code&gt; (기본값)를 읽기위한 &lt;code&gt;&quot;w&quot;&lt;/code&gt; , 덮어 쓰기위한 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 독점 창조를 위해, 또는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 추가합니다. 이들은 각각 &lt;code&gt;&quot;rb&quot;&lt;/code&gt; , &lt;code&gt;&quot;wb&quot;&lt;/code&gt; , &lt;code&gt;&quot;xb&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 로 주어질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3bbeddbe7940e4c0cf370c80c9188d583fa75ae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be either &lt;code&gt;'r'&lt;/code&gt; for reading (default), &lt;code&gt;'w'&lt;/code&gt; for overwriting, &lt;code&gt;'x'&lt;/code&gt; for exclusive creation, or &lt;code&gt;'a'&lt;/code&gt; for appending. These can equivalently be given as &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'xb'&lt;/code&gt; and &lt;code&gt;'ab'&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수가 될 수 있습니다 &lt;code&gt;'r'&lt;/code&gt; (기본값)를 읽기 위해 &lt;code&gt;'w'&lt;/code&gt; , 덮어 쓰기 &lt;code&gt;'x'&lt;/code&gt; 를 독점 창조를 위해, 또는 &lt;code&gt;'a'&lt;/code&gt; 추가하십시오. 이들은 각각 &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'xb'&lt;/code&gt; 및 &lt;code&gt;'ab'&lt;/code&gt; 로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e63d1cb834b1ab465f8f51a8d33b391f5ded1c0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument specifies what kind of code must be compiled; it can be &lt;code&gt;'exec'&lt;/code&gt; if &lt;em&gt;source&lt;/em&gt; consists of a sequence of statements, &lt;code&gt;'eval'&lt;/code&gt; if it consists of a single expression, or &lt;code&gt;'single'&lt;/code&gt; if it consists of a single interactive statement (in the latter case, expression statements that evaluate to something other than &lt;code&gt;None&lt;/code&gt; will be printed).</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 컴파일해야하는 코드의 종류를 인수 지정; 그것은 할 수있다 &lt;code&gt;'exec'&lt;/code&gt; 경우 &lt;em&gt;소스가&lt;/em&gt; 문장의 순서로 구성되어 &lt;code&gt;'eval'&lt;/code&gt; 는 하나의 표현, 또는 구성하는 경우 &lt;code&gt;'single'&lt;/code&gt; 후자의 경우는 단일 대화 형 문장으로 구성되어있는 경우 (표현 문은 뭔가 평가하는 &lt;code&gt;None&lt;/code&gt; 이외 는 인쇄됩니다).</target>
        </trans-unit>
        <trans-unit id="ef0505b4bacc6ef52a11195116452b65f0988586" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; can be &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt; for reading (default), writing, exclusive creation or appending. The file will be created if it doesn&amp;rsquo;t exist when opened for writing or appending; it will be truncated when opened for writing. &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; will be raised if it already exists when opened for creating. Opening a file for creating implies writing, so this mode behaves in a similar way to &lt;code&gt;'w'&lt;/code&gt;. Add a &lt;code&gt;'+'&lt;/code&gt; to the mode to allow simultaneous reading and writing.</source>
          <target state="translated">&lt;em&gt;모드는&lt;/em&gt; 할 수있다 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; (기본값) 읽기 전용 생성을 작성하거나 추가하십시오. 파일을 쓰거나 추가 할 때 파일이 존재하지 않으면 파일이 작성됩니다. 쓰기 위해 열면 잘립니다. &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 는 생성을 위해 열었을 때 이미 존재하면 발생합니다. 작성하기 위해 파일을 여는 것은 쓰기를 의미하므로이 모드는 &lt;code&gt;'w'&lt;/code&gt; 와 유사한 방식으로 작동 합니다. 읽기와 쓰기를 동시에하려면 모드에 &lt;code&gt;'+'&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c36342d9b2cd8356ce1d1833db576291385536ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter can be used to specify how the library is loaded. For details, consult the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/dlopen(3)&quot;&gt;dlopen(3)&lt;/a&gt;&lt;/em&gt; manpage. On Windows, &lt;em&gt;mode&lt;/em&gt; is ignored. On posix systems, RTLD_NOW is always added, and is not configurable.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수는 라이브러리를로드하는 방법을 지정하는 데 사용할 수 있습니다. 자세한 내용은 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/dlopen(3)&quot;&gt;dlopen (3)&lt;/a&gt;&lt;/em&gt; 맨 페이지를 참조하십시오 . Windows에서는 &lt;em&gt;모드&lt;/em&gt; 가 무시됩니다. posix 시스템에서 RTLD_NOW는 항상 추가되며 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9fa2d230db8cbbf537de152e5285ab6acbcd9db" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter defaults to &lt;code&gt;'w+b'&lt;/code&gt; so that the file created can be read and written without being closed. Binary mode is used so that it behaves consistently on all platforms without regard for the data that is stored. &lt;em&gt;buffering&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt; and &lt;em&gt;newline&lt;/em&gt; are interpreted as for &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 에 디폴트 파라미터 &lt;code&gt;'w+b'&lt;/code&gt; 너무없이 읽고 쓸 수 작성된 파일은 폐쇄되고있다. 이진 모드는 저장된 데이터에 관계없이 모든 플랫폼에서 일관되게 작동하도록 사용됩니다. &lt;em&gt;buffering&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; , &lt;em&gt;errors&lt;/em&gt; 및 &lt;em&gt;newline&lt;/em&gt; 은 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="12a05a95436429873a1482da4eed5e970b00fe32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter is passed to &lt;a href=&quot;#os.mkdir&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; for creating the leaf directory; see &lt;a href=&quot;#mkdir-modebits&quot;&gt;the mkdir() description&lt;/a&gt; for how it is interpreted. To set the file permission bits of any newly-created parent directories you can set the umask before invoking &lt;a href=&quot;#os.makedirs&quot;&gt;&lt;code&gt;makedirs()&lt;/code&gt;&lt;/a&gt;. The file permission bits of existing parent directories are not changed.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수로 전달됩니다 &lt;a href=&quot;#os.mkdir&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; 잎 디렉토리를 생성; 해석 방법에 &lt;a href=&quot;#mkdir-modebits&quot;&gt;대해서는 mkdir () 설명&lt;/a&gt; 을 참조하십시오 . 새로 작성된 상위 디렉토리의 파일 권한 비트를 설정하려면 &lt;a href=&quot;#os.makedirs&quot;&gt; &lt;code&gt;makedirs()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 umask를 설정할 수 있습니다 . 기존 상위 디렉토리의 파일 권한 비트는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d337cbd57242ea9761dc2650a1be72d8a8a94e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter should be &lt;code&gt;'r'&lt;/code&gt; to read an existing file, &lt;code&gt;'w'&lt;/code&gt; to truncate and write a new file, &lt;code&gt;'a'&lt;/code&gt; to append to an existing file, or &lt;code&gt;'x'&lt;/code&gt; to exclusively create and write a new file. If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'x'&lt;/code&gt; and &lt;em&gt;file&lt;/em&gt; refers to an existing file, a &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; will be raised. If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'a'&lt;/code&gt; and &lt;em&gt;file&lt;/em&gt; refers to an existing ZIP file, then additional files are added to it. If &lt;em&gt;file&lt;/em&gt; does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as &lt;code&gt;python.exe&lt;/code&gt;). If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'a'&lt;/code&gt; and the file does not exist at all, it is created. If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'r'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;, the file should be seekable.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수는해야한다 &lt;code&gt;'r'&lt;/code&gt; , 기존 파일을 읽기 위해 &lt;code&gt;'w'&lt;/code&gt; 잘라 내기에 새 파일 작성 &lt;code&gt;'a'&lt;/code&gt; 기존 파일에 추가 할를, 또는 &lt;code&gt;'x'&lt;/code&gt; 에 독점적으로 만들고 새 파일을 작성합니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'x'&lt;/code&gt; 와 &lt;em&gt;파일이&lt;/em&gt; 기존 파일을 참조하는 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'a'&lt;/code&gt; 와 &lt;em&gt;파일이&lt;/em&gt; 기존의 ZIP 파일을 참조하고 추가 파일은 추가됩니다. &lt;em&gt;파일 인&lt;/em&gt; 경우&lt;em&gt;&lt;/em&gt;ZIP 파일을 참조하지 않으면 새 ZIP 아카이브가 파일에 추가됩니다. 이는 ZIP 아카이브를 다른 파일 (예 : &lt;code&gt;python.exe&lt;/code&gt; ) 에 추가하기위한 것 입니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'a'&lt;/code&gt; 전혀 존재하지 않고 파일이 작성됩니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'r'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 파일이 시크해야한다.</target>
        </trans-unit>
        <trans-unit id="cd48b9ded8ca0d722432b92316f5d1e26f89e9e8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;module&lt;/em&gt; and &lt;em&gt;name&lt;/em&gt; arguments are the same as for function &lt;a href=&quot;#doctest.testsource&quot;&gt;&lt;code&gt;testsource()&lt;/code&gt;&lt;/a&gt; above. The synthesized Python script for the named object&amp;rsquo;s docstring is written to a temporary file, and then that file is run under the control of the Python debugger, &lt;a href=&quot;pdb#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 및 &lt;em&gt;이름&lt;/em&gt; 인수 함수와 동일 &lt;a href=&quot;#doctest.testsource&quot;&gt; &lt;code&gt;testsource()&lt;/code&gt; &lt;/a&gt; 위에서. 명명 된 객체의 docstring에 대해 합성 된 Python 스크립트는 임시 파일에 기록 된 다음 해당 파일은 Python 디버거 &lt;a href=&quot;pdb#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 의 제어하에 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="517f12b7316c7403a28c06c48d710faa268ca17d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;module&lt;/em&gt; argument takes a module that will be used instead of the module returned when you import &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; whose filter will be protected. This argument exists primarily for testing the &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module itself.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 인수 대신 가져올 때 반환 된 모듈로 사용되는 모듈 걸리는 &lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 그 필터 보호됩니다. 이 인수는 주로 &lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈 자체 를 테스트하기 위해 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="d00f6e8f367001c13e02ed8c348b2926151b62a6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mtime&lt;/em&gt; argument is an optional numeric timestamp to be written to the last modification time field in the stream when compressing. It should only be provided in compression mode. If omitted or &lt;code&gt;None&lt;/code&gt;, the current time is used. See the &lt;a href=&quot;#gzip.GzipFile.mtime&quot;&gt;&lt;code&gt;mtime&lt;/code&gt;&lt;/a&gt; attribute for more details.</source>
          <target state="translated">&lt;em&gt;에 mtime의&lt;/em&gt; 인수는 압축 할 때 스트림의 마지막 수정 시간 필드에 기록 할 선택적 숫자 소인입니다. 압축 모드에서만 제공해야합니다. 생략되거나 &lt;code&gt;None&lt;/code&gt; 이면 현재 시간이 사용됩니다. 자세한 내용은 &lt;a href=&quot;#gzip.GzipFile.mtime&quot;&gt; &lt;code&gt;mtime&lt;/code&gt; &lt;/a&gt; 속성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1d5693119572560e6e6dbcbc1051d1f559f7129" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; argument is optional. If specified it must be a string that will be used as the value returned by the &lt;a href=&quot;#datetime.datetime.tzname&quot;&gt;&lt;code&gt;datetime.tzname()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 인수는 선택 사항입니다. 지정된 경우, &lt;a href=&quot;#datetime.datetime.tzname&quot;&gt; &lt;code&gt;datetime.tzname()&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 값으로 사용될 문자열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa307273ebb313531c87777abdad301164d885b3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; argument specifies the database name that will be copied: it must be a string containing either &lt;code&gt;&quot;main&quot;&lt;/code&gt;, the default, to indicate the main database, &lt;code&gt;&quot;temp&quot;&lt;/code&gt; to indicate the temporary database or the name specified after the &lt;code&gt;AS&lt;/code&gt; keyword in an &lt;code&gt;ATTACH DATABASE&lt;/code&gt; statement for an attached database.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 인수는 복사 할 데이터베이스 이름을 지정합니다 :이 중 하나를 포함하는 문자열이어야합니다 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 기본 데이터베이스를 나타 내기 위해, 기본 &lt;code&gt;&quot;temp&quot;&lt;/code&gt; 애프터 지정된 임시 데이터베이스 또는 이름을 표시하기 위해 &lt;code&gt;AS&lt;/code&gt; 의 에 키워드를 연결된 데이터베이스에 대한 &lt;code&gt;ATTACH DATABASE&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="bfc8b3c755aaf4e07d8b3ad9aeb11f0bb28a5cf0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; can be one of two things:</source>
          <target state="translated">&lt;em&gt;이름은&lt;/em&gt; 두 가지 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fecd24072b185fb1c044fa851a04b4bb4c15cc73" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the name of the element type as a &lt;code&gt;(uri,
localname)&lt;/code&gt; tuple, the &lt;em&gt;qname&lt;/em&gt; parameter contains the raw XML 1.0 name used in the source document, and the &lt;em&gt;attrs&lt;/em&gt; parameter holds an instance of the &lt;code&gt;AttributesNS&lt;/code&gt; interface (see &lt;a href=&quot;xml.sax.reader#attributes-ns-objects&quot;&gt;The AttributesNS Interface&lt;/a&gt;) containing the attributes of the element. If no namespace is associated with the element, the &lt;em&gt;uri&lt;/em&gt; component of &lt;em&gt;name&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;. The object passed as &lt;em&gt;attrs&lt;/em&gt; may be re-used by the parser; holding on to a reference to it is not a reliable way to keep a copy of the attributes. To keep a copy of the attributes, use the &lt;a href=&quot;copy#module-copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; method of the &lt;em&gt;attrs&lt;/em&gt; object.</source>
          <target state="translated">&lt;em&gt;네임&lt;/em&gt; 파라미터는 같은 요소 유형의 이름이 포함 &lt;code&gt;(uri, localname)&lt;/code&gt; 튜플 상기 &lt;em&gt;의 QName&lt;/em&gt; 파라미터는 원시 XML 1.0 소스 문서에 사용 된 이름 및 포함 &lt;em&gt;attrs에&lt;/em&gt; 의 인스턴스 보유 파라미터 &lt;code&gt;AttributesNS&lt;/code&gt; 의 인터페이스 (참조 &lt;a href=&quot;xml.sax.reader#attributes-ns-objects&quot;&gt;AttributesNS 인터페이스&lt;/a&gt; )에 요소의 속성이 포함되어 있습니다. 더 네임 스페이스 요소와 연관되지 않은 경우, &lt;em&gt;URI&lt;/em&gt; 의 구성 요소 &lt;em&gt;이름은&lt;/em&gt; 없을 것 &lt;code&gt;None&lt;/code&gt; . &lt;em&gt;attrs로&lt;/em&gt; 전달 된 객체 는 파서에 의해 재사용 될 수 있습니다. 그것에 대한 참조를 유지하는 것은 속성의 사본을 유지하는 신뢰할 수있는 방법이 아닙니다. 속성의 사본을 유지하려면&lt;a href=&quot;copy#module-copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt;&lt;em&gt;attrs&lt;/em&gt; 객체의 copy () 메서드</target>
        </trans-unit>
        <trans-unit id="5686dcac020c22f354bee25b44d2e503d24cea05" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the name of the element type, just as with the &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt;&lt;code&gt;startElement()&lt;/code&gt;&lt;/a&gt; event.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 매개 변수는 단지와 마찬가지로 요소 유형의 이름을 포함 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt; &lt;code&gt;startElement()&lt;/code&gt; &lt;/a&gt; 이벤트.</target>
        </trans-unit>
        <trans-unit id="4e221dbdf5f7dd9b982f8886d4d96d71dfbcb1e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the name of the element type, just as with the &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElementNS&quot;&gt;&lt;code&gt;startElementNS()&lt;/code&gt;&lt;/a&gt; method, likewise the &lt;em&gt;qname&lt;/em&gt; parameter.</source>
          <target state="translated">&lt;em&gt;네임&lt;/em&gt; 파라미터는 단지와 같은 요소 유형의 이름을 포함 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElementNS&quot;&gt; &lt;code&gt;startElementNS()&lt;/code&gt; &lt;/a&gt; 에있어서, 마찬가지로 &lt;em&gt;본인 QName&lt;/em&gt; 파라미터.</target>
        </trans-unit>
        <trans-unit id="c5dd95780a96ed373c7c08723087bc92012499d7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the raw XML 1.0 name of the element type as a string and the &lt;em&gt;attrs&lt;/em&gt; parameter holds an object of the &lt;code&gt;Attributes&lt;/code&gt; interface (see &lt;a href=&quot;xml.sax.reader#attributes-objects&quot;&gt;The Attributes Interface&lt;/a&gt;) containing the attributes of the element. The object passed as &lt;em&gt;attrs&lt;/em&gt; may be re-used by the parser; holding on to a reference to it is not a reliable way to keep a copy of the attributes. To keep a copy of the attributes, use the &lt;a href=&quot;copy#module-copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; method of the &lt;em&gt;attrs&lt;/em&gt; object.</source>
          <target state="translated">&lt;em&gt;네임&lt;/em&gt; 파라미터는 문자열 요소 유형과의 원시 XML 1.0 명 포함 &lt;em&gt;attrs에&lt;/em&gt; 의 객체 파라미터 보유 &lt;code&gt;Attributes&lt;/code&gt; 인터페이스 (참조 : &lt;a href=&quot;xml.sax.reader#attributes-objects&quot;&gt;(가) Attributes 인터페이스&lt;/a&gt; 요소의 속성을 포함). &lt;em&gt;attrs로&lt;/em&gt; 전달 된 객체 는 파서에 의해 재사용 될 수 있습니다. 그것에 대한 참조를 유지하는 것은 속성의 사본을 유지하는 신뢰할 수있는 방법이 아닙니다. 속성의 사본을 유지하려면 &lt;em&gt;attrs&lt;/em&gt; 객체 의 &lt;a href=&quot;copy#module-copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e827cc072d58a9231eccc94d7418aeb0f39c07c9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name_of_module&lt;/em&gt; argument can specify (as a string or tuple thereof) what module(s) an API could be defined in order to be detected as a public API. One case for this is when &lt;em&gt;module&lt;/em&gt; imports part of its public API from other modules, possibly a C backend (like &lt;code&gt;csv&lt;/code&gt; and its &lt;code&gt;_csv&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;name_of_module의&lt;/em&gt; 인수는 API가 공개 API로 감지하기 위해 정의 될 수있는 것을 모듈 (들) (그 문자열이나 튜플)를 지정할 수있다. 이에 대한 한 가지 사례는 &lt;em&gt;모듈&lt;/em&gt; 이 다른 모듈에서 C 백엔드 (예 : &lt;code&gt;csv&lt;/code&gt; 및 &lt;code&gt;_csv&lt;/code&gt; ) 에서 공용 API의 일부를 가져 오는 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="6a1f53a033eeb2f5efeb8e128aa8a34ec6956a47" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;new_callable&lt;/em&gt; argument is useful where you want to use an alternative class to the default &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; for the created mock. For example, if you wanted a &lt;a href=&quot;#unittest.mock.NonCallableMock&quot;&gt;&lt;code&gt;NonCallableMock&lt;/code&gt;&lt;/a&gt; to be used:</source>
          <target state="translated">&lt;em&gt;new_callable&lt;/em&gt; 기본에 다른 클래스를 사용하려는 인수가 유용 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 생성 된 모의를 위해. 예를 들어 &lt;a href=&quot;#unittest.mock.NonCallableMock&quot;&gt; &lt;code&gt;NonCallableMock&lt;/code&gt; &lt;/a&gt; 을 사용 하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="1c928def7d6f7fec2025663bfc3a4700caf1d2a7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;newline&lt;/em&gt; argument works like that of &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt;. The default is to consider only &lt;code&gt;\n&lt;/code&gt; characters as ends of lines and to do no newline translation. If &lt;em&gt;newline&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt;, newlines are written as &lt;code&gt;\n&lt;/code&gt; on all platforms, but universal newline decoding is still performed when reading.</source>
          <target state="translated">&lt;em&gt;줄 바꿈&lt;/em&gt; 인수의처럼 작동 &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; . 디폴트는 &lt;code&gt;\n&lt;/code&gt; 문자 만을 행의 끝 으로 간주 하고 개행 변환을 수행하지 않는 것입니다. &lt;em&gt;줄 바꿈&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 으로 설정 되면 모든 플랫폼에서 줄 바꿈이 &lt;code&gt;\n&lt;/code&gt; 으로 작성 되지만 범용 줄 바꿈 디코딩은 여전히 ​​읽을 때 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd8453f1fdcfd787ce338a47e0ea718dd8b6c75" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;object-or-type&lt;/em&gt; determines the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-method-resolution-order&quot;&gt;method resolution order&lt;/a&gt; to be searched. The search starts from the class right after the &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;객체 또는 형&lt;/em&gt; 결정 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-method-resolution-order&quot;&gt;방법 확인 순서&lt;/a&gt; 검색 할있다. &lt;em&gt;유형&lt;/em&gt; 바로 다음에 클래스에서 검색이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad83ccab5379d93ec053e2b163a548ae3d4e6b98" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;object_pairs_hook&lt;/em&gt; parameter can be used to alter this behavior.</source>
          <target state="translated">&lt;em&gt;object_pairs_hook의&lt;/em&gt; 매개 변수는이 동작을 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="835096ab0ab29d4008ca14710ddfaea3d6d22ec4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;offset&lt;/em&gt; argument must be specified as a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object representing the difference between the local time and UTC. It must be strictly between &lt;code&gt;-timedelta(hours=24)&lt;/code&gt; and &lt;code&gt;timedelta(hours=24)&lt;/code&gt;, otherwise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;오프셋&lt;/em&gt; 인자는로서 지정해야 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 현지 시간과 UTC의 차이를 나타내는 개체. 이것은 엄격 사이 여야 &lt;code&gt;-timedelta(hours=24)&lt;/code&gt; 및 &lt;code&gt;timedelta(hours=24)&lt;/code&gt; 그렇지 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를가&lt;/a&gt; 상승한다.</target>
        </trans-unit>
        <trans-unit id="ddd25287fdb9896e097a9db9e3706fae6e9da314" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;opener&lt;/em&gt; parameter was added.</source>
          <target state="translated">&lt;em&gt;오프너&lt;/em&gt; 매개 변수는 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="03b092d93249375bcb0323a6702343bfbe9ceae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;openhook&lt;/em&gt;, when given, must be a function that takes two arguments, &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt;, and returns an accordingly opened file-like object. You cannot use &lt;em&gt;inplace&lt;/em&gt; and &lt;em&gt;openhook&lt;/em&gt; together.</source>
          <target state="translated">&lt;em&gt;openhook는&lt;/em&gt; , 주어 졌을 때, 두 개의 인수를 취하는 함수이어야 &lt;em&gt;파일 이름&lt;/em&gt; 과 &lt;em&gt;모드&lt;/em&gt; 및 그에 따라 열린 파일과 같은 개체를 반환합니다. &lt;em&gt;Inplace&lt;/em&gt; 와 &lt;em&gt;Openhook을&lt;/em&gt; 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e5eb496e4b2c0fde320c695eb452f9ff1a917c58" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;optimization&lt;/em&gt; parameter is used to specify the optimization level of the bytecode file. An empty string represents no optimization, so &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; with an &lt;em&gt;optimization&lt;/em&gt; of &lt;code&gt;''&lt;/code&gt; will result in a bytecode path of &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.pyc&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; causes the interpreter&amp;rsquo;s optimization level to be used. Any other value&amp;rsquo;s string representation is used, so &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; with an &lt;em&gt;optimization&lt;/em&gt; of &lt;code&gt;2&lt;/code&gt; will lead to the bytecode path of &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc&lt;/code&gt;. The string representation of &lt;em&gt;optimization&lt;/em&gt; can only be alphanumeric, else &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;최적화&lt;/em&gt; 매개 변수는 바이트 코드 파일의 최적화 레벨을 지정하는 데 사용됩니다. 그래서 빈 문자열, 더 최적화를 표시하지 &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; 와 &lt;em&gt;최적화&lt;/em&gt; 의이 &lt;code&gt;''&lt;/code&gt; 의 바이트 코드 경로가 발생합니다 &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.pyc&lt;/code&gt; . &lt;code&gt;None&lt;/code&gt; 은 인터프리터의 최적화 수준을 사용하도록합니다. 그래서 다른 값의 문자열 표현이 사용되는 &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; 와 &lt;em&gt;최적화&lt;/em&gt; 의 &lt;code&gt;2&lt;/code&gt; 의 바이트 코드 경로로 이어질 것입니다 &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc&lt;/code&gt; . &lt;em&gt;최적화&lt;/em&gt; 의 문자열 표현&lt;em&gt;&lt;/em&gt;영숫자 만 가능하며, 그렇지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aeab2b3e4c0bce06083aef5c507ae9b49420eb23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;password&lt;/em&gt; argument may be a function to call to get the password for decrypting the private key. It will only be called if the private key is encrypted and a password is necessary. It will be called with no arguments, and it should return a string, bytes, or bytearray. If the return value is a string it will be encoded as UTF-8 before using it to decrypt the key. Alternatively a string, bytes, or bytearray value may be supplied directly as the &lt;em&gt;password&lt;/em&gt; argument. It will be ignored if the private key is not encrypted and no password is needed.</source>
          <target state="translated">&lt;em&gt;암호&lt;/em&gt; 인수는 함수가 개인 키를 해독하는 암호를 얻기 위해 호출 할 수 있습니다. 개인 키가 암호화되어 있고 암호가 필요한 경우에만 호출됩니다. 인수없이 호출되며 문자열, 바이트 또는 바이트 배열을 반환해야합니다. 리턴 값이 문자열 인 경우이를 사용하여 키를 해독하기 전에 UTF-8로 인코딩됩니다. 또는 문자열, 바이트 또는 바이트 배열 값이 &lt;em&gt;암호&lt;/em&gt; 인수 로 직접 제공 될 수 있습니다 . 개인 키가 암호화되지 않고 암호가 필요하지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5894a49d9fd67c04eb2502774f6b556f37efb59f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;path&lt;/em&gt; argument is the directory for which the finder is in charge of searching.</source>
          <target state="translated">&lt;em&gt;경로&lt;/em&gt; 인수는 찾기가 검색을 담당하고있는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="b3b64714cf1d89975545a84417ebd84d5e337d0a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;path&lt;/em&gt; parameter is the path to the executable file.The &lt;em&gt;path&lt;/em&gt; should contain a directory.Use &lt;a href=&quot;#os.posix_spawnp&quot;&gt;&lt;code&gt;posix_spawnp()&lt;/code&gt;&lt;/a&gt; to pass an executable file without directory.</source>
          <target state="translated">&lt;em&gt;경로&lt;/em&gt; 매개 변수는 실행] 파일의 경로입니다 &lt;em&gt;경로&lt;/em&gt; directory.Use에 포함해야 &lt;a href=&quot;#os.posix_spawnp&quot;&gt; &lt;code&gt;posix_spawnp()&lt;/code&gt; &lt;/a&gt; 디렉토리없이 실행 파일을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9c46f81dad7b34554c6c2af6f64f9d65570f63a5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;pax_headers&lt;/em&gt; argument is an optional dictionary of strings which will be added as a pax global header if &lt;em&gt;format&lt;/em&gt; is &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt;&lt;code&gt;PAX_FORMAT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;pax_headers의&lt;/em&gt; 인수는 경우 팍스 글로벌 헤더로 추가됩니다 문자열의 선택적 사전입니다 &lt;em&gt;형식&lt;/em&gt; 입니다 &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt; &lt;code&gt;PAX_FORMAT&lt;/code&gt; 가&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="385c9a120811afd54baa69bd7076c1e6f5593f01" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;payload&lt;/em&gt; is either a string or bytes object, in the case of simple message objects, or a list of &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; objects, for MIME container documents such as &lt;em&gt;multipart/*&lt;/em&gt; and &lt;em&gt;message/rfc822&lt;/em&gt; message objects.</source>
          <target state="translated">&lt;em&gt;페이로드&lt;/em&gt; 중 문자열 또는 단순한 메시지 객체의 경우, 객체 바이트 또는 목록 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 는&lt;/a&gt; 같은 MIME 컨테이너 문서 객체 &lt;em&gt;다중 / *&lt;/em&gt; 및 &lt;em&gt;메시지 / RFC822의&lt;/em&gt; 메시지 오브젝트.</target>
        </trans-unit>
        <trans-unit id="ea70b7df974c3fb9e6c0547260aae38aa155e773" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;preamble&lt;/em&gt; attribute contains this leading extra-armor text for MIME documents. When the &lt;a href=&quot;email.parser#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; discovers some text after the headers but before the first boundary string, it assigns this text to the message&amp;rsquo;s &lt;em&gt;preamble&lt;/em&gt; attribute. When the &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is writing out the plain text representation of a MIME message, and it finds the message has a &lt;em&gt;preamble&lt;/em&gt; attribute, it will write this text in the area between the headers and the first boundary. See &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;email.generator&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;em&gt;프리앰블&lt;/em&gt; 속성은 MIME 문서에 대해이 최고의 여분 갑옷 텍스트를 포함합니다. &lt;a href=&quot;email.parser#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; 는 헤더 뒤에서 첫 번째 경계 문자열 이전에 일부 텍스트를 발견 하면 이 텍스트를 메시지의 &lt;em&gt;프리앰블&lt;/em&gt; 속성에 할당 합니다. 때 &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 는 MIME 메시지의 일반 텍스트 표현을 쓰고, 그것이 메시지가있다 발견 &lt;em&gt;프리앰블&lt;/em&gt; 속성을이 헤더와 첫 번째 경계 사이의 영역에서이 텍스트를 작성합니다. 참조 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;email.generator&lt;/code&gt; &lt;/a&gt; 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="1a54fdfb6b6943ecad12822e748b19740f664e27" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;precision&lt;/em&gt; is a decimal number indicating how many digits should be displayed after the decimal point for a floating point value formatted with &lt;code&gt;'f'&lt;/code&gt; and &lt;code&gt;'F'&lt;/code&gt;, or before and after the decimal point for a floating point value formatted with &lt;code&gt;'g'&lt;/code&gt; or &lt;code&gt;'G'&lt;/code&gt;. For non-number types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The &lt;em&gt;precision&lt;/em&gt; is not allowed for integer values.</source>
          <target state="translated">&lt;em&gt;정밀도&lt;/em&gt; 로 포맷 된 부동 소수점 값의 소수점 후에 표시되어야하는 숫자를 나타내는 진수 인 &lt;code&gt;'f'&lt;/code&gt; 와 &lt;code&gt;'F'&lt;/code&gt; , 또는 전으로 포맷 된 부동 소수점 값의 소수점 이후 &lt;code&gt;'g'&lt;/code&gt; 또는 &lt;code&gt;'G'&lt;/code&gt; . 숫자가 아닌 유형의 경우이 필드는 최대 필드 크기, 즉 필드 내용에서 사용될 문자 수를 나타냅니다. 정수 값 에는 &lt;em&gt;정밀도&lt;/em&gt; 가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a42059a7398e0076eb8d110fcba8360dfcfb871" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;preexec_fn&lt;/em&gt; parameter is not safe to use in the presence of threads in your application. The child process could deadlock before exec is called. If you must use it, keep it trivial! Minimize the number of libraries you call into.</source>
          <target state="translated">&lt;em&gt;preexec_fn&lt;/em&gt; 매개 변수는 응용 프로그램에서 스레드의 존재에 사용하는 것이 안전하지 않습니다. exec가 호출되기 전에 자식 프로세스가 교착 상태에 빠질 수 있습니다. 반드시 사용해야한다면 사소한 것이 좋습니다! 호출하는 라이브러리 수를 최소화하십시오.</target>
        </trans-unit>
        <trans-unit id="7c2cc6abdc0befc2720b7ccef1d9ae061ce483f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prefix&lt;/em&gt;, &lt;em&gt;suffix&lt;/em&gt;, and &lt;em&gt;dir&lt;/em&gt; arguments are the same as for &lt;a href=&quot;#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;접두사&lt;/em&gt; , &lt;em&gt;접미사&lt;/em&gt; 및 &lt;em&gt;DIR의&lt;/em&gt; 인자와 동일 &lt;a href=&quot;#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02180b4f716501a7667649b1f96c422fcb8aa64b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;preset&lt;/em&gt; argument (if provided) should be an integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt; (inclusive), optionally OR-ed with the constant &lt;code&gt;PRESET_EXTREME&lt;/code&gt;. If neither &lt;em&gt;preset&lt;/em&gt; nor &lt;em&gt;filters&lt;/em&gt; are given, the default behavior is to use &lt;code&gt;PRESET_DEFAULT&lt;/code&gt; (preset level &lt;code&gt;6&lt;/code&gt;). Higher presets produce smaller output, but make the compression process slower.</source>
          <target state="translated">&lt;em&gt;소정&lt;/em&gt; 인수 (있는 경우)의 정수이어야 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;9&lt;/code&gt; (포함), 상수를 가진 임의 OR 혼성 &lt;code&gt;PRESET_EXTREME&lt;/code&gt; . &lt;em&gt;사전 설정&lt;/em&gt; 이나 &lt;em&gt;필터&lt;/em&gt; 가 제공 되지 않은 경우 기본 동작은 &lt;code&gt;PRESET_DEFAULT&lt;/code&gt; (사전 설정 레벨 &lt;code&gt;6&lt;/code&gt; )를 사용하는 것입니다. 프리셋이 높을수록 출력은 작아 지지만 압축 프로세스는 느려집니다.</target>
        </trans-unit>
        <trans-unit id="9895acc66c3f18475ff9f0db5201b4c6a71ff0e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol_factory&lt;/em&gt; must be a callable returning a subclass of the &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt;&lt;code&gt;SubprocessProtocol&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;em&gt;protocol_factory는&lt;/em&gt; 의 서브 클래스 반환하는 호출해야합니다 &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt; &lt;code&gt;SubprocessProtocol&lt;/code&gt; 의&lt;/a&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="f711c66569fb5d19645c5457dbc47d4d07d6d7c3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol_factory&lt;/em&gt; must be a callable returning a subclass of the &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt;&lt;code&gt;asyncio.SubprocessProtocol&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;em&gt;protocol_factory는&lt;/em&gt; 의 서브 클래스 반환하는 호출해야합니다 &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt; &lt;code&gt;asyncio.SubprocessProtocol&lt;/code&gt; 의&lt;/a&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="401443787918a85da5a18eb500ca9cde85fb13e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;purpose&lt;/em&gt; flag specifies what kind of CA certificates are loaded. The default settings &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt;&lt;code&gt;Purpose.SERVER_AUTH&lt;/code&gt;&lt;/a&gt; loads certificates, that are flagged and trusted for TLS web server authentication (client side sockets). &lt;a href=&quot;#ssl.Purpose.CLIENT_AUTH&quot;&gt;&lt;code&gt;Purpose.CLIENT_AUTH&lt;/code&gt;&lt;/a&gt; loads CA certificates for client certificate verification on the server side.</source>
          <target state="translated">&lt;em&gt;목적의&lt;/em&gt; 어떤 종류의 CA 인증서의 플래그 지정이로드됩니다. 기본 설정 &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt; &lt;code&gt;Purpose.SERVER_AUTH&lt;/code&gt; &lt;/a&gt; 는 TLS 웹 서버 인증 (클라이언트 측 소켓)에 대해 플래그가 지정되고 신뢰할 수있는 인증서를로드합니다. &lt;a href=&quot;#ssl.Purpose.CLIENT_AUTH&quot;&gt; &lt;code&gt;Purpose.CLIENT_AUTH&lt;/code&gt; &lt;/a&gt; 는 서버 측에서 클라이언트 인증서 확인을 위해 CA 인증서를로드합니다.</target>
        </trans-unit>
        <trans-unit id="4dc1ae68be8c928ff8ced55af039b97dee0f266d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;readrc&lt;/em&gt; argument defaults to true and controls whether Pdb will load .pdbrc files from the filesystem.</source>
          <target state="translated">&lt;em&gt;readrc의&lt;/em&gt; 인수 디폴트는 true와 제어한다 Pdb는 파일 시스템에서 파일을 .pdbrc로드할지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="46e14dc3cbadaa634897551ddab605eacd0ed865" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; argument is as documented for &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 인수로 문서화되어 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5524c970b27a1790f26c76be61a832fdb402cb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; object (usually a &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt;&lt;code&gt;urllib.request.Request&lt;/code&gt;&lt;/a&gt; instance) must support the methods &lt;code&gt;get_full_url()&lt;/code&gt;, &lt;code&gt;get_host()&lt;/code&gt;, &lt;code&gt;get_type()&lt;/code&gt;, &lt;code&gt;unverifiable()&lt;/code&gt;, &lt;code&gt;has_header()&lt;/code&gt;, &lt;code&gt;get_header()&lt;/code&gt;, &lt;code&gt;header_items()&lt;/code&gt;, &lt;code&gt;add_unredirected_header()&lt;/code&gt; and &lt;code&gt;origin_req_host&lt;/code&gt; attribute as documented by &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 개체 (일반적 &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt; &lt;code&gt;urllib.request.Request&lt;/code&gt; &lt;/a&gt; 인스턴스) 방법을 지원한다 &lt;code&gt;get_full_url()&lt;/code&gt; , &lt;code&gt;get_host()&lt;/code&gt; , &lt;code&gt;get_type()&lt;/code&gt; , &lt;code&gt;unverifiable()&lt;/code&gt; , &lt;code&gt;has_header()&lt;/code&gt; , &lt;code&gt;get_header()&lt;/code&gt; , &lt;code&gt;header_items()&lt;/code&gt; , &lt;code&gt;add_unredirected_header()&lt;/code&gt; 및 &lt;code&gt;origin_req_host&lt;/code&gt; 을&lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; 에&lt;/a&gt; 의해 문서화 된 속성 .</target>
        </trans-unit>
        <trans-unit id="6076db6f2a9e32f368a89ef0cd834117df42f630" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; object (usually a &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt;&lt;code&gt;urllib.request.Request&lt;/code&gt;&lt;/a&gt; instance) must support the methods &lt;code&gt;get_full_url()&lt;/code&gt;, &lt;code&gt;get_host()&lt;/code&gt;, &lt;code&gt;unverifiable()&lt;/code&gt;, and &lt;code&gt;origin_req_host&lt;/code&gt; attribute, as documented by &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt;. The request is used to set default values for cookie-attributes as well as for checking that the cookie is allowed to be set.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 개체 (일반적 &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt; &lt;code&gt;urllib.request.Request&lt;/code&gt; &lt;/a&gt; 인스턴스) 방법을 지원한다 &lt;code&gt;get_full_url()&lt;/code&gt; , &lt;code&gt;get_host()&lt;/code&gt; , &lt;code&gt;unverifiable()&lt;/code&gt; 및 &lt;code&gt;origin_req_host&lt;/code&gt; 의 속성에 의해 설명 된대로 &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; &lt;/a&gt; . 요청은 쿠키 속성의 기본값을 설정하고 쿠키를 설정할 수 있는지 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f1c2f586a7c581cf5d92cb55cc5d4a2a88d0cd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; parameter is limited to values that can fit in 32-bits. Additional constants of interest for use as the &lt;em&gt;request&lt;/em&gt; argument can be found in the &lt;a href=&quot;termios#module-termios&quot;&gt;&lt;code&gt;termios&lt;/code&gt;&lt;/a&gt; module, under the same names as used in the relevant C header files.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 파라미터는 32 비트에 들어갈 수있는 값으로 제한된다. &lt;em&gt;요청&lt;/em&gt; 인수 로 사용할 추가 상수 는 관련 C 헤더 파일에 사용 된 것과 동일한 이름으로 &lt;a href=&quot;termios#module-termios&quot;&gt; &lt;code&gt;termios&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="249de6ab2421958fe5451ea48601c9e94f9750cb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;response&lt;/em&gt; object (usually the result of a call to &lt;a href=&quot;urllib.request#urllib.request.urlopen&quot;&gt;&lt;code&gt;urllib.request.urlopen()&lt;/code&gt;&lt;/a&gt;, or similar) should support an &lt;code&gt;info()&lt;/code&gt; method, which returns an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;em&gt;응답&lt;/em&gt; 객체 (전화의 일반적 결과는합니다 &lt;a href=&quot;urllib.request#urllib.request.urlopen&quot;&gt; &lt;code&gt;urllib.request.urlopen()&lt;/code&gt; &lt;/a&gt; 지원해야한다, 또는 유사한) &lt;code&gt;info()&lt;/code&gt; 반환 방법, &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; 의&lt;/a&gt; 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="04ce21268d40bc71f1f9a9083f103f2659796911" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;response&lt;/em&gt; that is returned as the first item in the return tuple of almost all methods is the server&amp;rsquo;s response: a string beginning with a three-digit code. If the server&amp;rsquo;s response indicates an error, the method raises one of the above exceptions.</source>
          <target state="translated">&lt;em&gt;응답&lt;/em&gt; 거의 모든 메소드의 반환 튜플의 첫 번째 항목으로 반환되는 서버의 응답입니다 : 문자열이 세 자리 코드로 시작. 서버의 응답에 오류가 있으면 위의 예외 중 하나가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2a08f6a3c82a95e392e1e6e160bcc0d359886a5e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rounding&lt;/em&gt; option is one of the constants listed in the section &lt;a href=&quot;#rounding-modes&quot;&gt;Rounding Modes&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;반올림&lt;/em&gt; 옵션은 섹션에 나열된 상수 중 하나입니다 &lt;a href=&quot;#rounding-modes&quot;&gt;반올림 모드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6d46553ec93f51e386c82746a812fbd9cb5fc2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;safe&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, and &lt;em&gt;errors&lt;/em&gt; parameters are passed down to &lt;em&gt;quote_via&lt;/em&gt; (the &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; parameters are only passed when a query element is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;안전하고&lt;/em&gt; , &lt;em&gt;인코딩&lt;/em&gt; 하고, &lt;em&gt;에러&lt;/em&gt; 파라미터에 전해진다 &lt;em&gt;quote_via&lt;/em&gt; 합니다 ( &lt;em&gt;부호화&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 질의 요소가있는 경우에만 파라미터가 전달되는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45c6ec6d33577622f7757d14f0820e4e75833046" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scheduler&lt;/em&gt; argument must be a tuple containing the (optional) scheduler policy and an instance of &lt;a href=&quot;#os.sched_param&quot;&gt;&lt;code&gt;sched_param&lt;/code&gt;&lt;/a&gt; with the scheduler parameters. A value of &lt;code&gt;None&lt;/code&gt; in the place of the scheduler policy indicates that is not being provided. This argument is a combination of the C library &lt;code&gt;POSIX_SPAWN_SETSCHEDPARAM&lt;/code&gt; and &lt;code&gt;POSIX_SPAWN_SETSCHEDULER&lt;/code&gt; flags.</source>
          <target state="translated">&lt;em&gt;스케줄러&lt;/em&gt; 인수는 (선택) 스케줄러 정책과의 인스턴스가 포함 된 튜플해야 &lt;a href=&quot;#os.sched_param&quot;&gt; &lt;code&gt;sched_param&lt;/code&gt; &lt;/a&gt; 스케줄러 매개 변수를. 스케줄러 정책 대신 &lt;code&gt;None&lt;/code&gt; 값은 제공되지 않음을 나타냅니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETSCHEDPARAM&lt;/code&gt; 및 &lt;code&gt;POSIX_SPAWN_SETSCHEDULER&lt;/code&gt; 플래그 의 조합입니다 .</target>
        </trans-unit>
        <trans-unit id="7ec1f6a11cc0295f4e6de025d3da51e89252d526" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scheme&lt;/em&gt; argument gives the default addressing scheme, to be used only if the URL does not specify one. It should be the same type (text or bytes) as &lt;em&gt;urlstring&lt;/em&gt;, except that the default value &lt;code&gt;''&lt;/code&gt; is always allowed, and is automatically converted to &lt;code&gt;b''&lt;/code&gt; if appropriate.</source>
          <target state="translated">&lt;em&gt;체계의&lt;/em&gt; 인수는 기본 주소 체계를 제공하는 URL이 하나를 지정하지 않는 경우에만 사용되어야한다. 기본값 &lt;code&gt;''&lt;/code&gt; 이 항상 허용되고 필요한 경우 자동으로 &lt;code&gt;b''&lt;/code&gt; 로 변환 된다는 점을 제외하고 &lt;em&gt;urlstring&lt;/em&gt; 과 동일한 유형 (텍스트 또는 바이트) &lt;em&gt;이어야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9c3d14f8574339300c0dd4daab37b014b3b42911" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;server_name_callback&lt;/em&gt; callback passed to &lt;a href=&quot;#ssl.SSLContext.set_servername_callback&quot;&gt;&lt;code&gt;SSLContext.set_servername_callback()&lt;/code&gt;&lt;/a&gt; will get an &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance instead of a &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; instance as its first parameter.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.set_servername_callback&quot;&gt; &lt;code&gt;SSLContext.set_servername_callback()&lt;/code&gt; &lt;/a&gt; 전달 된 &lt;em&gt;server_name_callback&lt;/em&gt; 콜백 은 첫 번째 매개 변수로 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 인스턴스 대신 &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 인스턴스를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9490a29cd2edeaa045d35fc7cad654528add8e39" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;server_side&lt;/em&gt;, &lt;em&gt;server_hostname&lt;/em&gt; and &lt;em&gt;session&lt;/em&gt; parameters have the same meaning as in &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;server_side&lt;/em&gt; , &lt;em&gt;server_hostname&lt;/em&gt; 및 &lt;em&gt;세션&lt;/em&gt; 파라미터와 동일한 의미를 갖는다 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a673e1ab33e5fd9a4b186a8ac8f33a5a9fa4ca7b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;setpgroup&lt;/em&gt; argument will set the process group of the child to the value specified. If the value specified is 0, the child&amp;rsquo;s process group ID will be made the same as its process ID. If the value of &lt;em&gt;setpgroup&lt;/em&gt; is not set, the child will inherit the parent&amp;rsquo;s process group ID. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_SETPGROUP&lt;/code&gt; flag.</source>
          <target state="translated">&lt;em&gt;setpgroup의&lt;/em&gt; 인수는 지정된 값으로 자녀의 프로세스 그룹을 설정합니다. 지정된 값이 0이면 하위 프로세스 그룹 ID는 프로세스 ID와 동일하게됩니다. &lt;em&gt;setpgroup&lt;/em&gt; 의 값이 설정되지 않으면 하위 프로세스는 상위 프로세스 그룹 ID를 상속합니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETPGROUP&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ff1d457cea9007b652c10d501e50abc8a21daa32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;setsigmask&lt;/em&gt; argument will set the signal mask to the signal set specified. If the parameter is not used, then the child inherits the parent&amp;rsquo;s signal mask. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_SETSIGMASK&lt;/code&gt; flag.</source>
          <target state="translated">&lt;em&gt;setsigmask의&lt;/em&gt; 인수 지정 신호 세트의 신호 마스크를 설정한다. 매개 변수를 사용하지 않으면 자식은 부모의 신호 마스크를 상속합니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETSIGMASK&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="a24d31ceaa7c092d726d770a0cf41f125d0aebf5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shallow&lt;/em&gt; parameter has the same meaning and default value as for &lt;a href=&quot;#filecmp.cmp&quot;&gt;&lt;code&gt;filecmp.cmp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;얕은의&lt;/em&gt; 매개 변수와 동일한 의미와 기본 값이 &lt;a href=&quot;#filecmp.cmp&quot;&gt; &lt;code&gt;filecmp.cmp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a80e01db550d1bd3a7bd6ebc74b18d968e849fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shell&lt;/em&gt; argument (which defaults to &lt;code&gt;False&lt;/code&gt;) specifies whether to use the shell as the program to execute. If &lt;em&gt;shell&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, it is recommended to pass &lt;em&gt;args&lt;/em&gt; as a string rather than as a sequence.</source>
          <target state="translated">&lt;em&gt;쉘&lt;/em&gt; 인수 (기본값은 &lt;code&gt;False&lt;/code&gt; ) 실행할 수있는 프로그램으로 쉘을 사용할지 여부를 지정합니다. 경우 &lt;em&gt;쉘&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 그것을 통과하는 것이 좋습니다 &lt;em&gt;인수를&lt;/em&gt; 문자열로보다는 시퀀스로.</target>
        </trans-unit>
        <trans-unit id="64685938fa2858e93dc0ebb23445efd4d0c5e167" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sigdef&lt;/em&gt; argument will reset the disposition of all signals in the set specified. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_SETSIGDEF&lt;/code&gt; flag.</source>
          <target state="translated">&lt;em&gt;sigdef의&lt;/em&gt; 인수는 지정된 세트의 모든 신호의 처리를 다시한다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETSIGDEF&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="6cab8b73313d2d8e8c5f669a403b631d6f400e9f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sign&lt;/em&gt; option is only valid for number types, and can be one of the following:</source>
          <target state="translated">&lt;em&gt;서명&lt;/em&gt; 옵션은 숫자 유형에만 유효하며, 다음 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1b57cb9c563c9860f94c21c54bbaa756fd93cb9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;signed&lt;/em&gt; argument determines whether two&amp;rsquo;s complement is used to represent the integer. If &lt;em&gt;signed&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; and a negative integer is given, an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; is raised. The default value for &lt;em&gt;signed&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;서명&lt;/em&gt; 인수는 2의 보수는 정수를 나타내는 데 사용 여부를 결정합니다. 경우 &lt;em&gt;서명이&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 과 음의 정수가 주어, &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. &lt;em&gt;signed&lt;/em&gt; 의 기본값 은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="371f7246c775e34157c3af19c7e256b43858f6a2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;signed&lt;/em&gt; argument indicates whether two&amp;rsquo;s complement is used to represent the integer.</source>
          <target state="translated">&lt;em&gt;서명&lt;/em&gt; 인수는 2의 보수는 정수를 나타내는 데 사용됩니다 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c1af8aa11bb01ff7639b96a4988e666df7acd3f2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; argument indicates the approximate maximum number of encoded bytes or code points to read for decoding. The decoder can modify this setting as appropriate. The default value -1 indicates to read and decode as much as possible. This parameter is intended to prevent having to decode huge files in one step.</source>
          <target state="translated">&lt;em&gt;크기&lt;/em&gt; 인자는 디코딩 읽을 부호화 바이트 코드 포인트의 대략 최대 수를 나타낸다. 디코더는이 설정을 적절하게 수정할 수 있습니다. 기본값 -1은 가능한 많이 읽고 디코딩 함을 나타냅니다. 이 매개 변수는 한 번에 많은 파일을 디코딩하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d355dd9c76833b2b080632c6620ca9de793f66dc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; argument is normally passed to the decorated test method as an extra argument. If &lt;em&gt;dry_run&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the value passed to the test method may be less than the requested value. If &lt;em&gt;dry_run&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, it means the test doesn&amp;rsquo;t support dummy runs when &lt;code&gt;-M&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;em&gt;크기&lt;/em&gt; 인수는 일반적으로 별도의 인수로 장식 된 시험 방법에 전달됩니다. &lt;em&gt;dry_run&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 테스트 메소드에 전달 된 값이 요청 된 값보다 작을 수 있습니다. 경우 &lt;em&gt;dry_run이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; ,이 때 테스트 더미 실행을 지원하지 않습니다 의미 &lt;code&gt;-M&lt;/code&gt; 이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="151dde5b0ba7cb1869ce8877b126a35442579a25" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;skip&lt;/em&gt; argument, if given, must be an iterable of glob-style module name patterns. The debugger will not step into frames that originate in a module that matches one of these patterns. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;스킵&lt;/em&gt; 인수는, 주어진 경우, 글로브 스타일의 모듈 이름 패턴의 반복 가능한해야합니다. 디버거는 이러한 패턴 중 하나와 일치하는 모듈에서 시작되는 프레임으로 들어 가지 않습니다. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c97b4a14038331f376db5a76543fd70a20e5addc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;skip&lt;/em&gt; argument, if given, must be an iterable of glob-style module name patterns. The debugger will not step into frames that originate in a module that matches one of these patterns. Whether a frame is considered to originate in a certain module is determined by the &lt;code&gt;__name__&lt;/code&gt; in the frame globals.</source>
          <target state="translated">&lt;em&gt;스킵&lt;/em&gt; 인수는, 주어진 경우, 글로브 스타일의 모듈 이름 패턴의 반복 가능한해야합니다. 디버거는 이러한 패턴 중 하나와 일치하는 모듈에서 시작되는 프레임으로 들어 가지 않습니다. 프레임이 특정 모듈에서 시작된 것으로 간주되는지 여부는 프레임 전역 의 &lt;code&gt;__name__&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d44decd9d7b523509313fc74a2d69d1a2b290502" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sleep&lt;/em&gt; argument specifies the number of seconds to sleep by between successive attempts to backup remaining pages, can be specified either as an integer or a floating point value.</source>
          <target state="translated">&lt;em&gt;수면&lt;/em&gt; 인수 지정은 백업 나머지 페이지에 연속 시도 사이에 의해 잠을 초 단위는 정수 또는 부동 소수점 값 중 하나를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166a331e704e3a141fa3c371379efa856fe7128c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sni_callback&lt;/em&gt; function must return &lt;code&gt;None&lt;/code&gt; to allow the TLS negotiation to continue. If a TLS failure is required, a constant &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_*&lt;/code&gt;&lt;/a&gt; can be returned. Other return values will result in a TLS fatal error with &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;sni_callback의&lt;/em&gt; 기능은 반환하지합니다 &lt;code&gt;None&lt;/code&gt; TLS 협상을 계속 할 수 있도록합니다. TLS 실패가 필요한 경우 상수 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_*&lt;/code&gt; &lt;/a&gt; 가 리턴 될 수 있습니다. 다른 반환 값은 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt; &lt;/a&gt; 와 함께 TLS 치명적인 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="955cb7b76408c61d468a2564832812df5fa5e51a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sound&lt;/em&gt; parameter is a sound association name from the registry. If the registry contains no such name, play the system default sound unless &lt;a href=&quot;#winsound.SND_NODEFAULT&quot;&gt;&lt;code&gt;SND_NODEFAULT&lt;/code&gt;&lt;/a&gt; is also specified. If no default sound is registered, raise &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;. Do not use with &lt;a href=&quot;#winsound.SND_FILENAME&quot;&gt;&lt;code&gt;SND_FILENAME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;사운드&lt;/em&gt; 매개 변수는 레지스트리에서 사운드 연결 이름입니다. 레지스트리에 이러한 이름이 없으면 &lt;a href=&quot;#winsound.SND_NODEFAULT&quot;&gt; &lt;code&gt;SND_NODEFAULT&lt;/code&gt; &lt;/a&gt; 도 지정 하지 않은 한 시스템 기본 사운드를 재생하십시오 . 기본 사운드가 등록되어 있지 않으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. &lt;a href=&quot;#winsound.SND_FILENAME&quot;&gt; &lt;code&gt;SND_FILENAME&lt;/code&gt; &lt;/a&gt; 과 함께 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b134798684044ca68a3fcd2a983ed363cbdb1b27" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sound&lt;/em&gt; parameter is the name of a WAV file. Do not use with &lt;a href=&quot;#winsound.SND_ALIAS&quot;&gt;&lt;code&gt;SND_ALIAS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;사운드&lt;/em&gt; 매개 변수는 WAV 파일의 이름입니다. &lt;a href=&quot;#winsound.SND_ALIAS&quot;&gt; &lt;code&gt;SND_ALIAS&lt;/code&gt; &lt;/a&gt; 와 함께 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="494b12ba5734dc2ca9617a8112a2a9a15dd567ac" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sound&lt;/em&gt; parameter to &lt;a href=&quot;#winsound.PlaySound&quot;&gt;&lt;code&gt;PlaySound()&lt;/code&gt;&lt;/a&gt; is a memory image of a WAV file, as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#winsound.PlaySound&quot;&gt; &lt;code&gt;PlaySound()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;사운드&lt;/em&gt; 매개 변수 는 WAV 파일의 메모리 이미지이며 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03f6dce2a0c575617067c550aeaa2aeb5a0a02ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;spawn&lt;/em&gt; and &lt;em&gt;forkserver&lt;/em&gt; start methods</source>
          <target state="translated">&lt;em&gt;산란&lt;/em&gt; 및 &lt;em&gt;forkserver는&lt;/em&gt; 방법을 시작합니다</target>
        </trans-unit>
        <trans-unit id="812f74adf35e9bd9c0a7d57ac0e4adfe7af57bde" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;spec&lt;/em&gt; and &lt;em&gt;spec_set&lt;/em&gt; keyword arguments are passed to the &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; if patch is creating one for you.</source>
          <target state="translated">&lt;em&gt;사양&lt;/em&gt; 및 &lt;em&gt;spec_set&lt;/em&gt; 인수가 전달됩니다 키워드 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 패치가 당신을 위해 하나를 만드는 경우.</target>
        </trans-unit>
        <trans-unit id="bd76eed69117ffe302594bd904142e1af0f14d91" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stacklevel&lt;/em&gt; parameter is passed from code calling the &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt; and other APIs. If greater than 1, the excess is used to skip stack frames before determining the values to be returned. This will generally be useful when calling logging APIs from helper/wrapper code, so that the information in the event log refers not to the helper/wrapper code, but to the code that calls it.</source>
          <target state="translated">&lt;em&gt;stacklevel의&lt;/em&gt; 매개 변수는 호출 코드에서 전달되는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 등의 API를. 1보다 크면 초과는 반환 될 값을 결정하기 전에 스택 프레임을 건너 뛰는 데 사용됩니다. 이는 일반적으로 헬퍼 / 래퍼 코드에서 로깅 API를 호출 할 때 유용하므로 이벤트 로그의 정보는 헬퍼 / 래퍼 코드가 아니라이를 호출하는 코드를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="eee7bb5e1f93d0aa7def4b926657f815b96ba449" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;start_serving&lt;/em&gt; keyword-only parameter to &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt;&lt;code&gt;asyncio.start_server()&lt;/code&gt;&lt;/a&gt; allows creating a Server object that is not accepting connections initially. In this case &lt;code&gt;Server.start_serving()&lt;/code&gt;, or &lt;a href=&quot;#asyncio.Server.serve_forever&quot;&gt;&lt;code&gt;Server.serve_forever()&lt;/code&gt;&lt;/a&gt; can be used to make the Server start accepting connections.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt; &lt;code&gt;asyncio.start_server()&lt;/code&gt; &lt;/a&gt; 대한 &lt;em&gt;start_serving&lt;/em&gt; 키워드 전용 매개 변수를 사용하면 처음에 연결을 수락하지 않는 서버 오브젝트를 작성할 수 있습니다. 이 경우 &lt;code&gt;Server.start_serving()&lt;/code&gt; 또는 &lt;a href=&quot;#asyncio.Server.serve_forever&quot;&gt; &lt;code&gt;Server.serve_forever()&lt;/code&gt; &lt;/a&gt; 를 사용하여 서버가 연결을 수락하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff845514b67e263cd929598b99bd6da9b00014a1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stmt&lt;/em&gt; and &lt;em&gt;setup&lt;/em&gt; parameters can also take objects that are callable without arguments. This will embed calls to them in a timer function that will then be executed by &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt;. Note that the timing overhead is a little larger in this case because of the extra function calls.</source>
          <target state="translated">&lt;em&gt;STMT&lt;/em&gt; 및 &lt;em&gt;설정&lt;/em&gt; 매개 변수는 인수없이 호출 할 수있는 개체를 취할 수 있습니다. 타이머 함수에 호출을 포함시킨 다음 &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 의해 실행됩니다 . 이 경우 추가 함수 호출로 인해 타이밍 오버 헤드가 약간 더 커집니다.</target>
        </trans-unit>
        <trans-unit id="d459734c7b70a35885ce8138ec50017c8cb4923e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stream&lt;/em&gt; argument must be a file-like object open for reading text or binary data, as appropriate for the specific codec.</source>
          <target state="translated">&lt;em&gt;스트림&lt;/em&gt; 인수는 특정 코덱에 적절한 텍스트 또는 이진 데이터를 읽는 파일 - 류의 객체 개방을해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9421205ba92f1959114a601b65062efde304270" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stream&lt;/em&gt; argument must be a file-like object open for writing text or binary data, as appropriate for the specific codec.</source>
          <target state="translated">&lt;em&gt;스트림&lt;/em&gt; 인수는 파일 - 류의 객체 개방 특정 코덱에 적절한 텍스트 또는 이진 데이터를 작성하기위한해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4f9796f885c7ccb144d9aef721b442954ff6936" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stream&lt;/em&gt; argument must be a file-like object.</source>
          <target state="translated">&lt;em&gt;스트림&lt;/em&gt; 인수는 파일 - 류의 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e23660071587e149c908f2b1a9eb0b91e48c3be1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;strict_timestamps&lt;/em&gt; argument, when set to &lt;code&gt;False&lt;/code&gt;, allows to zip files older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. Similar behavior occurs with files newer than 2107-12-31, the timestamp is also set to the limit.</source>
          <target state="translated">는 &lt;em&gt;strict_timestamps&lt;/em&gt; 로 설정 인수, &lt;code&gt;False&lt;/code&gt; 1980년 1월 1일에 타임 스탬프를 설정하는 비용 1980년 1월 1일 이전의 압축 파일을 수 있습니다. 2107-12-31보다 새로운 파일에서도 비슷한 동작이 발생하며 타임 스탬프도 한계로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd056fc144b78ef948e2d71b7ab2d9023d675c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;style&lt;/em&gt; parameter can be one of &amp;lsquo;%&amp;rsquo;, &amp;lsquo;{&amp;lsquo; or &amp;lsquo;$&amp;rsquo; and determines how the format string will be merged with its data: using one of %-formatting, &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#string.Template&quot;&gt;&lt;code&gt;string.Template&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#formatting-styles&quot;&gt;Using particular formatting styles throughout your application&lt;/a&gt; for more information on using {- and $-formatting for log messages.</source>
          <target state="translated">&lt;em&gt;스타일의&lt;/em&gt; 매개 변수는 '{', '%'중 하나가 될 수 있습니다 또는 '$'과는 형식 문자열은 데이터와 통합되는 방법을 결정 %의 -formatting, 중 하나를 사용하여 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;string#string.Template&quot;&gt; &lt;code&gt;string.Template&lt;/code&gt; 을&lt;/a&gt; . 로그 메시지에 {-및 $ -formatting을 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#formatting-styles&quot;&gt;응용 프로그램 전체에서 특정 서식 스타일 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f91bb789f435e7bbe9d7a96d06995f3f8d43b2f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;symbol&lt;/em&gt; argument determines whether &lt;em&gt;source&lt;/em&gt; is compiled as a statement (&lt;code&gt;'single'&lt;/code&gt;, the default) or as an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-expression&quot;&gt;expression&lt;/a&gt; (&lt;code&gt;'eval'&lt;/code&gt;). Any other value will cause &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to be raised.</source>
          <target state="translated">&lt;em&gt;심볼&lt;/em&gt; 인수 여부를 결정 &lt;em&gt;소스가&lt;/em&gt; 성명 (로 컴파일되어 &lt;code&gt;'single'&lt;/code&gt; 기본) 또는 같은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-expression&quot;&gt;표현&lt;/a&gt; ( &lt;code&gt;'eval'&lt;/code&gt; ). 다른 값을 사용하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e44c727c722cd091526a9f92fdf653d13be39f3c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;table&lt;/em&gt; argument must be one of the predefined tables in the MSI schema, e.g. &lt;code&gt;'Feature'&lt;/code&gt;, &lt;code&gt;'File'&lt;/code&gt;, &lt;code&gt;'Component'&lt;/code&gt;, &lt;code&gt;'Dialog'&lt;/code&gt;, &lt;code&gt;'Control'&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;em&gt;테이블&lt;/em&gt; 인수는 MSI 스키마 예에서 미리 정의 된 테이블 중 하나 여야합니다 &lt;code&gt;'Feature'&lt;/code&gt; , &lt;code&gt;'File'&lt;/code&gt; , &lt;code&gt;'Component'&lt;/code&gt; , &lt;code&gt;'Dialog'&lt;/code&gt; , &lt;code&gt;'Control'&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="43e5dbf1eb2f65e62249791eebe2af8f0a85e617" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tag&lt;/em&gt; argument is the name of the tag converted to lower case.</source>
          <target state="translated">&lt;em&gt;태그&lt;/em&gt; 인수는 태그의 이름을 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="678ee0b27d4f67663dcfba5935b84a5a9919a39f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tag&lt;/em&gt; argument is the name of the tag converted to lower case. The &lt;em&gt;attrs&lt;/em&gt; argument is a list of &lt;code&gt;(name, value)&lt;/code&gt; pairs containing the attributes found inside the tag&amp;rsquo;s &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; brackets. The &lt;em&gt;name&lt;/em&gt; will be translated to lower case, and quotes in the &lt;em&gt;value&lt;/em&gt; have been removed, and character and entity references have been replaced.</source>
          <target state="translated">&lt;em&gt;태그&lt;/em&gt; 인수는 태그의 이름을 소문자로 변환됩니다. &lt;em&gt;의 attrs&lt;/em&gt; 인수의 목록 &lt;code&gt;(name, value)&lt;/code&gt; 의 특성을 포함하는 쌍을 태그의 내부에 발견 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 괄호. &lt;em&gt;이름은&lt;/em&gt; 소문자로 변환됩니다,와의 따옴표 &lt;em&gt;값이&lt;/em&gt; 제거 된, 문자 엔티티 참조는 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="8055f97fb11a0ac404880fc21479eb1700734e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tag&lt;/em&gt; values are strings, with these meanings:</source>
          <target state="translated">&lt;em&gt;태그&lt;/em&gt; 값이 의미로, 문자열 :</target>
        </trans-unit>
        <trans-unit id="b20f83bb0150a6498b1b44a47a57fb80da5c5a8a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;target&lt;/em&gt; argument determines where the resulting archive will be written:</source>
          <target state="translated">&lt;em&gt;대상&lt;/em&gt; 인수는 결과 아카이브가 작성 될 위치를 결정합니다 :</target>
        </trans-unit>
        <trans-unit id="1e10c168e7e125b3ad9c496694fc6cf4572a554e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tarinfo&lt;/em&gt; argument can be used to replace the default &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt; class with a different one.</source>
          <target state="translated">&lt;em&gt;tarinfo의&lt;/em&gt; 인수는 기본 대체 할 수 &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; 의&lt;/a&gt; 다른 하나 클래스를.</target>
        </trans-unit>
        <trans-unit id="526fb955ea344b7381f36e74d15dd0727d123ce0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;testLoader&lt;/em&gt; argument has to be a &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; instance, and defaults to &lt;a href=&quot;#unittest.defaultTestLoader&quot;&gt;&lt;code&gt;defaultTestLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;testLoader의&lt;/em&gt; 인수는되어야한다 &lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; 의&lt;/a&gt; 인스턴스 및 기본값 &lt;a href=&quot;#unittest.defaultTestLoader&quot;&gt; &lt;code&gt;defaultTestLoader&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee5fd830ce393d63a0fedec8d6d4ba56b87e218" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;testRunner&lt;/em&gt; argument can either be a test runner class or an already created instance of it. By default &lt;code&gt;main&lt;/code&gt; calls &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt; with an exit code indicating success or failure of the tests run.</source>
          <target state="translated">&lt;em&gt;의 TestRunner&lt;/em&gt; 인수 중 하나를 테스트 러너 클래스 또는 그것의 이미 생성 된 인스턴스가 될 수 있습니다. 기본적으로 &lt;code&gt;main&lt;/code&gt; 은 테스트 실행의 성공 또는 실패를 나타내는 종료 코드와 함께 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f1d67f40b7914af3788448149baeacbe91461387" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;timeout&lt;/em&gt; argument is passed to &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;Popen.communicate()&lt;/code&gt;&lt;/a&gt;. If the timeout expires, the child process will be killed and waited for. The &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt;&lt;code&gt;TimeoutExpired&lt;/code&gt;&lt;/a&gt; exception will be re-raised after the child process has terminated.</source>
          <target state="translated">&lt;em&gt;타임 아웃&lt;/em&gt; 인수가 전달됩니다 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;Popen.communicate()&lt;/code&gt; &lt;/a&gt; . 제한 시간이 만료되면 하위 프로세스가 종료되고 대기합니다. &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt; &lt;code&gt;TimeoutExpired&lt;/code&gt; 의&lt;/a&gt; 예외는 자식 프로세스가 종료 된 후 다시이-발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b693b5b8037c056a4f62f7c7c759475e832507e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transport&lt;/em&gt; argument is the transport representing the connection. The protocol is responsible for storing the reference to its transport.</source>
          <target state="translated">&lt;em&gt;전송&lt;/em&gt; 인수는 연결을 나타내는 전송합니다. 프로토콜은 전송에 대한 참조를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="53c2a3e3b3eb98863bde5d4305376d1fa9980862" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;traps&lt;/em&gt; and &lt;em&gt;flags&lt;/em&gt; fields list any signals to be set. Generally, new contexts should only set traps and leave the flags clear.</source>
          <target state="translated">&lt;em&gt;트랩&lt;/em&gt; 및 &lt;em&gt;플래그&lt;/em&gt; 필드는 어떤 신호가 설정 될 나열. 일반적으로 새 컨텍스트는 트랩을 설정하고 플래그를 비워 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="4c741294182b97a2d1aa5f08589cea85a0af5c1d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tuple&lt;/em&gt; should be &lt;code&gt;(nchannels, sampwidth, framerate, nframes, comptype,
compname)&lt;/code&gt;, with values valid for the &lt;code&gt;set*()&lt;/code&gt; methods. Sets all parameters.</source>
          <target state="translated">&lt;em&gt;튜플&lt;/em&gt; 이어야 &lt;code&gt;(nchannels, sampwidth, framerate, nframes, comptype, compname)&lt;/code&gt; 유효한 값으로 &lt;code&gt;set*()&lt;/code&gt; 메소드. 모든 매개 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b7ee36144f195c06ce56a0eda12cbb5df2802992" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;type&lt;/em&gt; of an enumeration member is the enumeration it belongs to:</source>
          <target state="translated">열거 형 멤버 의 &lt;em&gt;유형&lt;/em&gt; 은 다음과 같은 열거 &lt;em&gt;형&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31f48dd378c2469953b274b9fc49aab7aa53a5d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unraisable&lt;/em&gt; argument has the following attributes:</source>
          <target state="translated">&lt;em&gt;unraisable&lt;/em&gt; 인수는 다음과 같은 특성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="08cc62e6a77cc57a42acffe8d231f2d3231ee2b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;use_errno&lt;/em&gt; parameter, when set to true, enables a ctypes mechanism that allows accessing the system &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; error number in a safe way. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; maintains a thread-local copy of the systems &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; variable; if you call foreign functions created with &lt;code&gt;use_errno=True&lt;/code&gt; then the &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; value before the function call is swapped with the ctypes private copy, the same happens immediately after the function call.</source>
          <target state="translated">&lt;em&gt;use_errno의&lt;/em&gt; true로 설정하면 매개 변수는 시스템에 액세스 할 수 있도록하는 ctypes 메커니즘 수 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 안전한 방법으로 오류 번호. &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 시스템 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 변수 의 스레드 로컬 사본을 유지 합니다. &lt;code&gt;use_errno=True&lt;/code&gt; 로 작성된 외부 함수를 호출 하면 함수 호출 전의 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 값이 ctypes 개인용 사본으로 교체되며 함수 호출 직후에도 동일하게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="86cfed265a7f536800ec9f3650cbd08a05b9bc49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;use_last_error&lt;/em&gt; parameter, when set to true, enables the same mechanism for the Windows error code which is managed by the &lt;a href=&quot;#ctypes.GetLastError&quot;&gt;&lt;code&gt;GetLastError()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;SetLastError()&lt;/code&gt; Windows API functions; &lt;a href=&quot;#ctypes.get_last_error&quot;&gt;&lt;code&gt;ctypes.get_last_error()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ctypes.set_last_error&quot;&gt;&lt;code&gt;ctypes.set_last_error()&lt;/code&gt;&lt;/a&gt; are used to request and change the ctypes private copy of the windows error code.</source>
          <target state="translated">&lt;em&gt;use_last_error의&lt;/em&gt; true로 설정하면 매개 변수는에 의해 관리되는 Windows 오류 코드에 대한 동일한 메커니즘 수 &lt;a href=&quot;#ctypes.GetLastError&quot;&gt; &lt;code&gt;GetLastError()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;SetLastError()&lt;/code&gt; Windows API 함수를; &lt;a href=&quot;#ctypes.get_last_error&quot;&gt; &lt;code&gt;ctypes.get_last_error()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.set_last_error&quot;&gt; &lt;code&gt;ctypes.set_last_error()&lt;/code&gt; &lt;/a&gt; 는 Windows 오류 코드의 ctypes 개인용 사본을 요청하고 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5423d3d6187ddeee811ab8af8e82496d2df3fc15" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;value&lt;/em&gt; argument can be any object, which is then converted to a string.</source>
          <target state="translated">&lt;em&gt;값&lt;/em&gt; 인수가 문자열로 변환되는 모든 객체가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae0ea92bd8512288395f2eac3ca31db0455c95fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;verbose&lt;/em&gt; argument is unused and deprecated.</source>
          <target state="translated">&lt;em&gt;자세한&lt;/em&gt; 인수는 사용되지 않고 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a3d598de8cb43d84c851a82d72602df8acab107" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;version&lt;/em&gt; argument indicates the data format that &lt;code&gt;dump&lt;/code&gt; should use (see below).</source>
          <target state="translated">&lt;em&gt;버전&lt;/em&gt; 인수하는 데이터 형식을 나타냅니다 &lt;code&gt;dump&lt;/code&gt; (아래 참조)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="915638ef494048f3a2b93140ef40d6b653d16e99" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;version&lt;/em&gt; argument indicates the data format that &lt;code&gt;dumps&lt;/code&gt; should use (see below).</source>
          <target state="translated">&lt;em&gt;버전&lt;/em&gt; 인수하는 데이터 형식을 나타냅니다 &lt;code&gt;dumps&lt;/code&gt; (아래 참조)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff231d54e756958842b7640abbcd92fef9fd13fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;warnings&lt;/em&gt; argument specifies the &lt;a href=&quot;warnings#warning-filter&quot;&gt;warning filter&lt;/a&gt; that should be used while running the tests. If it&amp;rsquo;s not specified, it will remain &lt;code&gt;None&lt;/code&gt; if a &lt;code&gt;-W&lt;/code&gt; option is passed to &lt;strong&gt;python&lt;/strong&gt; (see &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#using-on-warnings&quot;&gt;Warning control&lt;/a&gt;), otherwise it will be set to &lt;code&gt;'default'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;경고의&lt;/em&gt; 인수는 지정 &lt;a href=&quot;warnings#warning-filter&quot;&gt;경고 필터&lt;/a&gt; 테스트를 실행하는 동안 사용되어야한다. 지정하지 않으면 &lt;code&gt;-W&lt;/code&gt; 옵션이 &lt;strong&gt;python에&lt;/strong&gt; 전달 되면 &lt;code&gt;None&lt;/code&gt; 으로 유지 되고 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#using-on-warnings&quot;&gt;경고 제어&lt;/a&gt; 참조 ) 그렇지 않으면 &lt;code&gt;'default'&lt;/code&gt; 로 설정됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8821b03c739e7bb5a0c16c56cf4b025ee726fecf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wbits&lt;/em&gt; argument controls the size of the history buffer (or the &amp;ldquo;window size&amp;rdquo;) used when compressing data, and whether a header and trailer is included in the output. It can take several ranges of values, defaulting to &lt;code&gt;15&lt;/code&gt; (MAX_WBITS):</source>
          <target state="translated">&lt;em&gt;wbits의&lt;/em&gt; 인자를 제어 이력 버퍼의 크기 (또는 &quot;창 크기&quot;) 데이터를 압축 할 때 사용되며, 헤더와 트레일러의 여부는 출력에 포함된다. 여러 범위의 값을 사용할 수 있으며 기본값은 &lt;code&gt;15&lt;/code&gt; (MAX_WBITS)입니다.</target>
        </trans-unit>
        <trans-unit id="588d73b4848378951d405715f75f323ade2906e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wbits&lt;/em&gt; parameter controls the size of the history buffer (or &amp;ldquo;window size&amp;rdquo;), and what header and trailer format is expected. It is similar to the parameter for &lt;a href=&quot;#zlib.compressobj&quot;&gt;&lt;code&gt;compressobj()&lt;/code&gt;&lt;/a&gt;, but accepts more ranges of values:</source>
          <target state="translated">&lt;em&gt;wbits&lt;/em&gt; 제어 매개 변수 히스토리 버퍼의 크기 (또는 &quot;창 크기&quot;), 어떤 헤더와 트레일러 형식이 예상된다. &lt;a href=&quot;#zlib.compressobj&quot;&gt; &lt;code&gt;compressobj()&lt;/code&gt; &lt;/a&gt; 의 매개 변수와 유사 하지만 더 많은 범위의 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="56f7b96f1606c2648c328d526d73fc9a757e342f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wbits&lt;/em&gt; parameter controls the size of the history buffer (or the &amp;ldquo;window size&amp;rdquo;), and what header and trailer format is expected. It has the same meaning as &lt;a href=&quot;#decompress-wbits&quot;&gt;described for decompress()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;wbits&lt;/em&gt; 제어 매개 변수 히스토리 버퍼의 크기 (또는 &quot;창 크기&quot;), 어떤 헤더와 트레일러 형식이 예상된다. &lt;a href=&quot;#decompress-wbits&quot;&gt;decompress ()에 대해 설명한&lt;/a&gt; 것과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="a39abfdff05160cffd980e736dec49577cf18f65" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;weightA&lt;/em&gt; and &lt;em&gt;weightB&lt;/em&gt; arguments are parameters for a simple digital filter and default to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;weightA&lt;/em&gt; 및 &lt;em&gt;weightB&lt;/em&gt; 인수에 간이 형 디지털 필터에 대한 디폴트 파라미터들이다 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 을 각각.</target>
        </trans-unit>
        <trans-unit id="2f53b362c6070875065143332b6ab04bce22e663" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;weights&lt;/em&gt; or &lt;em&gt;cum_weights&lt;/em&gt; can use any numeric type that interoperates with the &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; values returned by &lt;a href=&quot;#module-random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative.</source>
          <target state="translated">&lt;em&gt;가중치&lt;/em&gt; 또는 &lt;em&gt;cum_weights가&lt;/em&gt; 와 상호 임의 숫자 형식을 사용하여 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 값에 의해 반환 된 &lt;a href=&quot;#module-random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; (정수, 수레 분수하지만 제외 소수를 포함). 가중치는 음이 아닌 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3c17783948cbf0dc9055cd0a70b59a79f07178e5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;winmode&lt;/em&gt; parameter is used on Windows to specify how the library is loaded (since &lt;em&gt;mode&lt;/em&gt; is ignored). It takes any value that is valid for the Win32 API &lt;code&gt;LoadLibraryEx&lt;/code&gt; flags parameter. When omitted, the default is to use the flags that result in the most secure DLL load to avoiding issues such as DLL hijacking. Passing the full path to the DLL is the safest way to ensure the correct library and dependencies are loaded.</source>
          <target state="translated">&lt;em&gt;winmode의&lt;/em&gt; 매개 변수 (이후 라이브러리를로드하는 방법을 지정하려면 Windows에서 사용되는 &lt;em&gt;모드가&lt;/em&gt; 무시됩니다). Win32 API &lt;code&gt;LoadLibraryEx&lt;/code&gt; 플래그 매개 변수에 유효한 값을 갖습니다 . 생략하면 기본값은 DLL 하이재킹과 같은 문제를 피하기 위해 가장 안전한 DLL로드를 초래하는 플래그를 사용하는 것입니다. DLL에 대한 전체 경로를 전달하는 것이 올바른 라이브러리 및 종속성이로드되도록하는 가장 안전한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d4c56f152b380a49d2010425932c120b11eb953a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;year&lt;/em&gt;, &lt;em&gt;month&lt;/em&gt; and &lt;em&gt;day&lt;/em&gt; arguments are required. &lt;em&gt;tzinfo&lt;/em&gt; may be &lt;code&gt;None&lt;/code&gt;, or an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass. The remaining arguments must be integers in the following ranges:</source>
          <target state="translated">&lt;em&gt;연도&lt;/em&gt; , &lt;em&gt;월&lt;/em&gt; 및 &lt;em&gt;일&lt;/em&gt; 인수가 필요합니다. &lt;em&gt;tzinfo&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 이거나 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 일 수 있습니다 . 나머지 인수는 다음 범위의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d7cce18ab3585b4f15d60b0009c7d580585e27b7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;zdict&lt;/em&gt; parameter specifies a predefined compression dictionary. If provided, this must be the same dictionary as was used by the compressor that produced the data that is to be decompressed.</source>
          <target state="translated">&lt;em&gt;zdict&lt;/em&gt; 파라미터를 지정하는 소정의 압축 사전. 제공되는 경우 압축 해제 할 데이터를 생성 한 압축기에서 사용한 것과 동일한 사전이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fcf90de0cf7d5a594641c5c96a73337eebf219b6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;preferred&lt;/strong&gt; function to get the running event loop.</source>
          <target state="translated">&lt;strong&gt;선호하는&lt;/strong&gt; 기능은 실행중인 이벤트 루프를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f60d956207da8637154e9bb57b31087cb2d4d778" translate="yes" xml:space="preserve">
          <source>The ABC &lt;code&gt;MyIterable&lt;/code&gt; defines the standard iterable method, &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, as an abstract method. The implementation given here can still be called from subclasses. The &lt;code&gt;get_iterator()&lt;/code&gt; method is also part of the &lt;code&gt;MyIterable&lt;/code&gt; abstract base class, but it does not have to be overridden in non-abstract derived classes.</source>
          <target state="translated">ABC &lt;code&gt;MyIterable&lt;/code&gt; 은 표준 반복 가능 메소드 인 &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 를 추상 메소드로 정의합니다 . 여기에 제공된 구현은 여전히 ​​서브 클래스에서 호출 될 수 있습니다. &lt;code&gt;get_iterator()&lt;/code&gt; 메소드는 또한의 일부입니다 &lt;code&gt;MyIterable&lt;/code&gt; 추상 기본 클래스 만이 아닌 추상적 인 파생 클래스에서 재정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="faa22bc6bce0a5e04681e2a974e7cae8acce023c" translate="yes" xml:space="preserve">
          <source>The ADPCM coders have never been tried against other ADPCM coders, only against themselves. It could well be that I misinterpreted the standards in which case they will not be interoperable with the respective standards.</source>
          <target state="translated">ADPCM 코더는 다른 ADPCM 코더에 대해 시도 된 적이 없으며 자신에 대해서만 시도되었습니다. 표준을 잘못 해석 한 경우 해당 표준과 상호 운용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8528587fd89e0952d7a00dbb0e05d60038f18b25" translate="yes" xml:space="preserve">
          <source>The AF_* and SOCK_* constants are now &lt;code&gt;AddressFamily&lt;/code&gt; and &lt;code&gt;SocketKind&lt;/code&gt;&lt;a href=&quot;enum#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; collections.</source>
          <target state="translated">AF_ * 및 SOCK_ * 상수는 이제 &lt;code&gt;AddressFamily&lt;/code&gt; 및 &lt;code&gt;SocketKind&lt;/code&gt; &lt;a href=&quot;enum#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="1afb49999cdc36f38970839ccf0a7b7f6b8216b2" translate="yes" xml:space="preserve">
          <source>The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a &amp;ldquo;min heap&amp;rdquo; in textbooks; a &amp;ldquo;max heap&amp;rdquo; is more common in texts because of its suitability for in-place sorting).</source>
          <target state="translated">아래의 API는 두 가지 측면에서 교과서 힙 알고리즘과 다릅니다. (a) 우리는 0부터 시작하는 색인을 사용합니다. 이것은 노드의 인덱스와 자식의 인덱스 사이의 관계를 조금 덜 분명하게 만들지 만, 파이썬이 0부터 시작하는 인덱스를 사용하기 때문에 더 적합합니다. (b) pop 메소드는 가장 큰 항목이 아닌 가장 작은 항목을 반환합니다 (교과서에서는 &quot;최소 힙&quot;이라고하며 &quot;제자리 정렬에 적합하기 때문에 텍스트에서&quot;최대 힙 &quot;이 더 일반적입니다).</target>
        </trans-unit>
        <trans-unit id="76f3b439a545c7eb9ff445a4bdd93b428bc75166" translate="yes" xml:space="preserve">
          <source>The API provided by this module is likely to change in future releases; such changes may not be backward compatible.</source>
          <target state="translated">이 모듈에서 제공하는 API는 향후 릴리스에서 변경 될 수 있습니다. 이러한 변경 사항은 이전 버전과 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">모든 유형</target>
        </trans-unit>
        <trans-unit id="e1f06186c630db765adc5cb7fa1d1a7415bae3ea" translate="yes" xml:space="preserve">
          <source>The AutoCompleteWindow (ACW) will open after a predefined delay (default is two seconds) after a &amp;lsquo;.&amp;rsquo; or (in a string) an os.sep is typed. If after one of those characters (plus zero or more other characters) a tab is typed the ACW will open immediately if a possible continuation is found.</source>
          <target state="translated">자동 완성 창 (ACW)은 '.'다음에 사전 정의 된 지연 (기본값은 2 초) 후에 열립니다. 또는 (문자열에서) os.sep가 입력됩니다. 해당 문자 중 하나 (및 0 개 이상의 다른 문자) 뒤에 탭이 입력되면 가능한 연속이 발견되면 ACW가 즉시 열립니다.</target>
        </trans-unit>
        <trans-unit id="b2041194f9f02b3ffb833c005cb8c357700fb19a" translate="yes" xml:space="preserve">
          <source>The BCJ filters are intended to be applied to machine code. They convert relative branches, calls and jumps in the code to use absolute addressing, with the aim of increasing the redundancy that can be exploited by the compressor. These filters support one option, &lt;code&gt;start_offset&lt;/code&gt;. This specifies the address that should be mapped to the beginning of the input data. The default is 0.</source>
          <target state="translated">BCJ 필터는 기계 코드에 적용됩니다. 이들은 컴프레서가 이용할 수있는 중복성을 높이기 위해 절대 주소 지정을 사용하도록 코드에서 상대 분기, 호출 및 점프를 변환합니다. 이 필터는 &lt;code&gt;start_offset&lt;/code&gt; 옵션을 지원 합니다. 입력 데이터의 시작 부분에 매핑되어야하는 주소를 지정합니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c2e8e2dc67f7620982af31145da08c3a0edd2e25" translate="yes" xml:space="preserve">
          <source>The BSD name for &lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt;&lt;code&gt;RLIMIT_NOFILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt; &lt;code&gt;RLIMIT_NOFILE&lt;/code&gt; &lt;/a&gt; 의 BSD 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="8bd75df7a2ed31b671b15ba9f2a6053a27354cf7" translate="yes" xml:space="preserve">
          <source>The C API version for this interpreter. Programmers may find this useful when debugging version conflicts between Python and extension modules.</source>
          <target state="translated">이 인터프리터의 C API 버전입니다. 프로그래머는 Python과 확장 모듈 간의 버전 충돌을 디버깅 할 때이 기능이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54c0cca00a30bb23c9c25454179867adcaae900" translate="yes" xml:space="preserve">
          <source>The C code was partly rewritten for Python by &lt;em&gt;Christian Heimes&lt;/em&gt;.</source>
          <target state="translated">C 코드는 &lt;em&gt;Christian Heimes에&lt;/em&gt; 의해 부분적으로 파이썬 용으로 다시 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3987a1d7761e1a27305f1fc4189f71d26993d320" translate="yes" xml:space="preserve">
          <source>The C standard defines the locale as a program-wide property that may be relatively expensive to change. On top of that, some implementation are broken in such a way that frequent locale changes may cause core dumps. This makes the locale somewhat painful to use correctly.</source>
          <target state="translated">C 표준은 로캘을 변경하는 데 비교적 비싼 프로그램 전체 속성으로 정의합니다. 또한 로케일을 자주 변경하면 코어 덤프가 발생할 수있는 방식으로 일부 구현이 중단됩니다. 이것은 로케일을 올바르게 사용하기에 다소 고통 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="8d971f33fa3546c84e58c819f6dfcf232e9c699b" translate="yes" xml:space="preserve">
          <source>The CSS class for a weekday occurring in the previous or coming month.</source>
          <target state="translated">이전 달 또는 다음 달에 발생하는 요일의 CSS 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="504a86218f68cab32113c8eb840de3669681f12d" translate="yes" xml:space="preserve">
          <source>The CSS class for the table head for the whole year (used by &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt;&lt;code&gt;formatyear()&lt;/code&gt;&lt;/a&gt;). The default value is &lt;code&gt;&quot;year&quot;&lt;/code&gt;.</source>
          <target state="translated">일년 내내 테이블 헤드의 CSS 클래스 ( &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt; &lt;code&gt;formatyear()&lt;/code&gt; &lt;/a&gt; ). 기본값은 &lt;code&gt;&quot;year&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ee09fe1f5481a133063a3d6ee9e619dcd1e87e5" translate="yes" xml:space="preserve">
          <source>The CSS class for the whole month&amp;rsquo;s table (used by &lt;a href=&quot;#calendar.HTMLCalendar.formatmonth&quot;&gt;&lt;code&gt;formatmonth()&lt;/code&gt;&lt;/a&gt;). The default value is &lt;code&gt;&quot;month&quot;&lt;/code&gt;.</source>
          <target state="translated">한 달 전체 테이블의 CSS 클래스입니다 ( &lt;a href=&quot;#calendar.HTMLCalendar.formatmonth&quot;&gt; &lt;code&gt;formatmonth()&lt;/code&gt; &lt;/a&gt; ). 기본값은 &lt;code&gt;&quot;month&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="772191c229f3b2e05ab1df0d074ffe18b8d47d83" translate="yes" xml:space="preserve">
          <source>The CSS class for the whole year&amp;rsquo;s table of tables (used by &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt;&lt;code&gt;formatyear()&lt;/code&gt;&lt;/a&gt;). The default value is &lt;code&gt;&quot;year&quot;&lt;/code&gt;.</source>
          <target state="translated">전체 연도 테이블에 대한 CSS 클래스 ( &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt; &lt;code&gt;formatyear()&lt;/code&gt; &lt;/a&gt; 의해 사용됨 ). 기본값은 &lt;code&gt;&quot;year&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7103ea431534ee4b79f98427b6116337e9dc5615" translate="yes" xml:space="preserve">
          <source>The Catalog constructor</source>
          <target state="translated">카탈로그 생성자</target>
        </trans-unit>
        <trans-unit id="96cf03cbb4d0932be4497cf99cf72eade4d3bc41" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 recommendation defines a single exception, &lt;a href=&quot;#xml.dom.DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;, and a number of constants that allow applications to determine what sort of error occurred. &lt;a href=&quot;#xml.dom.DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; instances carry a &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; attribute that provides the appropriate value for the specific exception.</source>
          <target state="translated">DOM 레벨 2 권장 사항은 단일 예외 인 &lt;a href=&quot;#xml.dom.DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 및 애플리케이션이 어떤 종류의 오류가 발생했는지 판별 할 수있는 여러 상수를 정의합니다 . &lt;a href=&quot;#xml.dom.DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 인스턴스 에는 특정 예외에 적절한 값을 제공 하는 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="947495ed5aa7070a06069dcaba8341b2fcdc9d42" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 recommendation defines one method and one attribute for these objects:</source>
          <target state="translated">DOM 레벨 2 권장 사항은 이러한 오브젝트에 대한 하나의 메소드와 하나의 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b5ba2f5f1b68b0824d76ea1829d1ce34696f29a6" translate="yes" xml:space="preserve">
          <source>The DOM is extremely useful for random-access applications. SAX only allows you a view of one bit of the document at a time. If you are looking at one SAX element, you have no access to another. If you are looking at a text node, you have no access to a containing element. When you write a SAX application, you need to keep track of your program&amp;rsquo;s position in the document somewhere in your own code. SAX does not do it for you. Also, if you need to look ahead in the XML document, you are just out of luck.</source>
          <target state="translated">DOM은 랜덤 액세스 응용 프로그램에 매우 유용합니다. SAX에서는 한 번에 한 비트의 문서 만 볼 수 있습니다. 하나의 SAX 요소를보고 있다면 다른 SAX 요소에 액세스 할 수 없습니다. 텍스트 노드를보고 있으면 포함 요소에 액세스 할 수 없습니다. SAX 응용 프로그램을 작성할 때는 문서에서 프로그램의 위치를 ​​자신의 코드 어딘가에 추적해야합니다. SAX는 당신을 위해 그것을하지 않습니다. 또한 XML 문서를 미리보아야한다면 운이 나쁘다.</target>
        </trans-unit>
        <trans-unit id="6f03607955e97fbc57d05556b36ae065c2787ae3" translate="yes" xml:space="preserve">
          <source>The Document Object Model is being defined by the W3C in stages, or &amp;ldquo;levels&amp;rdquo; in their terminology. The Python mapping of the API is substantially based on the DOM Level 2 recommendation.</source>
          <target state="translated">문서 객체 모델은 W3C에 의해 단계적으로 또는 용어 &quot;수준&quot;으로 정의됩니다. API의 Python 매핑은 실질적으로 DOM Level 2 권장 사항을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3e5ece1120688047118eff8518636d6814ff5e85" translate="yes" xml:space="preserve">
          <source>The Document Object Model, or &amp;ldquo;DOM,&amp;rdquo; is a cross-language API from the World Wide Web Consortium (W3C) for accessing and modifying XML documents. A DOM implementation presents an XML document as a tree structure, or allows client code to build such a structure from scratch. It then gives access to the structure through a set of objects which provided well-known interfaces.</source>
          <target state="translated">Document Object Model 또는 &quot;DOM&quot;은 XML 문서에 액세스하고 수정하기위한 W3C (World Wide Web Consortium)의 언어 간 API입니다. DOM 구현은 XML 문서를 트리 구조로 나타내거나 클라이언트 코드가 처음부터 이러한 구조를 빌드 할 수 있도록합니다. 그런 다음 잘 알려진 인터페이스를 제공 한 개체 집합을 통해 구조에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce2ab8c2362dbe23653589b17cfaf7def8ffd50" translate="yes" xml:space="preserve">
          <source>The ElementInclude module replaces the &lt;code&gt;{http://www.w3.org/2001/XInclude}include&lt;/code&gt; element with the root element from the &lt;strong&gt;source.xml&lt;/strong&gt; document. The result might look something like this:</source>
          <target state="translated">ElementInclude 모듈은 &lt;code&gt;{http://www.w3.org/2001/XInclude}include&lt;/code&gt; 요소를 &lt;strong&gt;source.xml&lt;/strong&gt; 문서 의 루트 요소로 바꿉니다 . 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9af5016a363dd95d607deaf0cfed0a4507aba7fa" translate="yes" xml:space="preserve">
          <source>The Ellipsis Object</source>
          <target state="translated">줄임표 개체</target>
        </trans-unit>
        <trans-unit id="f32c4d6597786d2d5b11af91f776181bf1e19cc5" translate="yes" xml:space="preserve">
          <source>The Enum members. This can be a whitespace or comma separated string (values will start at 1 unless otherwise specified):</source>
          <target state="translated">Enum 멤버. 공백 또는 쉼표로 구분 된 문자열 일 수 있습니다 (지정하지 않는 한 값은 1부터 시작 함).</target>
        </trans-unit>
        <trans-unit id="9ea9c857f769b13c24616d563b892a00d4487c4a" translate="yes" xml:space="preserve">
          <source>The Expat XML Parser</source>
          <target state="translated">국외 XML 파서</target>
        </trans-unit>
        <trans-unit id="87d6d8f851f8a21b755e3b2015fc0f3520bceff4" translate="yes" xml:space="preserve">
          <source>The FAQ for the &lt;strong&gt;fetchmail&lt;/strong&gt; POP/IMAP client collects information on POP3 server variations and RFC noncompliance that may be useful if you need to write an application based on the POP protocol.</source>
          <target state="translated">&lt;strong&gt;fetchmail&lt;/strong&gt; POP / IMAP 클라이언트에 대한 FAQ는 POP3 기반 변형 및 RFC 비준수에 대한 정보를 수집하며 이는 POP 프로토콜을 기반으로 애플리케이션을 작성해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b7b076070cfeaac7ce8d6b6005200d5cc7bf13d" translate="yes" xml:space="preserve">
          <source>The FIPS 180-2 publication on Secure Hash Algorithms.</source>
          <target state="translated">Secure Hash 알고리즘에 관한 FIPS 180-2 발행물.</target>
        </trans-unit>
        <trans-unit id="a740e018f19ed6fd64cc21ac3ef422a76d04f855" translate="yes" xml:space="preserve">
          <source>The Future object was designed to mimic &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt;&lt;code&gt;concurrent.futures.Future&lt;/code&gt;&lt;/a&gt;. Key differences include:</source>
          <target state="translated">Future 객체는 &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt; &lt;code&gt;concurrent.futures.Future&lt;/code&gt; &lt;/a&gt; 를 모방하도록 설계되었습니다 . 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8b73749b9403577a859cf4146436530c3030907" translate="yes" xml:space="preserve">
          <source>The GC classifies objects into three generations depending on how many collection sweeps they have survived. New objects are placed in the youngest generation (generation &lt;code&gt;0&lt;/code&gt;). If an object survives a collection it is moved into the next older generation. Since generation &lt;code&gt;2&lt;/code&gt; is the oldest generation, objects in that generation remain there after a collection. In order to decide when to run, the collector keeps track of the number object allocations and deallocations since the last collection. When the number of allocations minus the number of deallocations exceeds &lt;em&gt;threshold0&lt;/em&gt;, collection starts. Initially only generation &lt;code&gt;0&lt;/code&gt; is examined. If generation &lt;code&gt;0&lt;/code&gt; has been examined more than &lt;em&gt;threshold1&lt;/em&gt; times since generation &lt;code&gt;1&lt;/code&gt; has been examined, then generation &lt;code&gt;1&lt;/code&gt; is examined as well. Similarly, &lt;em&gt;threshold2&lt;/em&gt; controls the number of collections of generation &lt;code&gt;1&lt;/code&gt; before collecting generation &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">GC는 얼마나 많은 수집 스위프가 살아남 았는지에 따라 객체를 3 세대로 분류합니다. 가장 어린 세대 ( &lt;code&gt;0&lt;/code&gt; 세대)에 새 개체가 배치됩니다 . 개체가 컬렉션을 유지하면 다음 세대로 이동합니다. &lt;code&gt;2&lt;/code&gt; 세대 가 가장 오래된 세대이므로 해당 세대의 개체는 수집 후에도 남아 있습니다. 실행시기를 결정하기 위해 콜렉터는 마지막 콜렉션 이후의 오브젝트 할당 및 할당 해제 수를 추적합니다. 할당 수에서 할당 취소 수를 뺀 &lt;em&gt;값&lt;/em&gt; 이 &lt;em&gt;threshold0을&lt;/em&gt; 초과하면 수집이 시작됩니다. 처음에는 &lt;code&gt;0&lt;/code&gt; 세대 만 검사합니다. 생성 &lt;code&gt;0&lt;/code&gt; 이 &lt;em&gt;임계 값 1&lt;/em&gt; 이상으로 검사 된 &lt;em&gt;경우&lt;/em&gt; &lt;code&gt;1&lt;/code&gt; 세대 이후로 여러 번 검사 된 다음 &lt;code&gt;1&lt;/code&gt; 세대 도 검사됩니다. 마찬가지로, &lt;em&gt;threshold2&lt;/em&gt; 는 생성 &lt;code&gt;2&lt;/code&gt; 를 수집하기 전에 생성 &lt;code&gt;1&lt;/code&gt; 의 수집 수를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="1ae2bdc70c1e8e7581209a0a31a94868a49311af" translate="yes" xml:space="preserve">
          <source>The GNU tar format (&lt;a href=&quot;#tarfile.GNU_FORMAT&quot;&gt;&lt;code&gt;GNU_FORMAT&lt;/code&gt;&lt;/a&gt;). It supports long filenames and linknames, files bigger than 8 GiB and sparse files. It is the de facto standard on GNU/Linux systems. &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; fully supports the GNU tar extensions for long names, sparse file support is read-only.</source>
          <target state="translated">GNU tar 형식 ( &lt;a href=&quot;#tarfile.GNU_FORMAT&quot;&gt; &lt;code&gt;GNU_FORMAT&lt;/code&gt; &lt;/a&gt; ) 긴 파일 이름 및 링크 이름, 8 GiB보다 큰 파일 및 스파 스 파일을 지원합니다. 이것은 GNU / Linux 시스템에서 사실상 표준입니다. &lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 은 긴 이름에 대한 GNU tar 확장명을 완전히 지원하며 스파 스 파일 지원은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="112e6111d5aee2deded99838bec29a35f5e5765a" translate="yes" xml:space="preserve">
          <source>The HKEY object implements &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; and thus supports the context protocol for the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">HKEY 객체는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 을 구현하므로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 컨텍스트 프로토콜을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c71c33c40ba7395c73110a285fefd5bc28a566e0" translate="yes" xml:space="preserve">
          <source>The HTML rendering, and some liberal editing, was produced from a FrameMaker version by Ken Manheimer.</source>
          <target state="translated">HTML 렌더링 및 일부 자유로운 편집은 Ken Manheimer의 FrameMaker 버전에서 제작되었습니다.</target>
        </trans-unit>
        <trans-unit id="895c87c33e6e85565a15be7d071b5d53c67b0b24" translate="yes" xml:space="preserve">
          <source>The HTTP headers used for error responses. This should be a list of WSGI response headers (&lt;code&gt;(name, value)&lt;/code&gt; tuples), as described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt;. The default list just sets the content type to &lt;code&gt;text/plain&lt;/code&gt;.</source>
          <target state="translated">오류 응답에 사용되는 HTTP 헤더입니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;PEP 3333에&lt;/strong&gt;&lt;/a&gt; 설명 된대로 WSGI 응답 헤더 ( &lt;code&gt;(name, value)&lt;/code&gt; 튜플) 의 목록이어야합니다 . 기본 목록은 컨텐츠 유형을 &lt;code&gt;text/plain&lt;/code&gt; 으로 설정합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc84f6a14e073ef0781e89812bc11bcc21df30a7" translate="yes" xml:space="preserve">
          <source>The HTTP request method to use. By default its value is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, which means that &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt;&lt;code&gt;get_method()&lt;/code&gt;&lt;/a&gt; will do its normal computation of the method to be used. Its value can be set (thus overriding the default computation in &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt;&lt;code&gt;get_method()&lt;/code&gt;&lt;/a&gt;) either by providing a default value by setting it at the class level in a &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; subclass, or by passing a value in to the &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor via the &lt;em&gt;method&lt;/em&gt; argument.</source>
          <target state="translated">사용할 HTTP 요청 방법. 기본적으로 값은 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이며, &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt; &lt;code&gt;get_method()&lt;/code&gt; &lt;/a&gt; 는 사용될 메소드의 정상적인 계산을 수행합니다. &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 서브 클래스의 클래스 레벨에서 값을 설정 하거나 &lt;em&gt;메소드&lt;/em&gt; 인수 를 통해 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 생성자에 값을 전달하여 기본값을 제공하여 값을 설정할 수 있습니다 (따라서 &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt; &lt;code&gt;get_method()&lt;/code&gt; &lt;/a&gt; 의 기본 계산을 재정의 함 ) .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="102e26b238faccf8b9327c868bff78cb340168c8" translate="yes" xml:space="preserve">
          <source>The HTTP response headers for the HTTP request that caused the &lt;a href=&quot;#urllib.error.HTTPError&quot;&gt;&lt;code&gt;HTTPError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#urllib.error.HTTPError&quot;&gt; &lt;code&gt;HTTPError&lt;/code&gt; &lt;/a&gt; 를 일으킨 HTTP 요청에 대한 HTTP 응답 헤더입니다 .</target>
        </trans-unit>
        <trans-unit id="875aaefb3d305183b3f017feb60dceacc6899535" translate="yes" xml:space="preserve">
          <source>The HTTP status used for error responses. This should be a status string as defined in &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt;; it defaults to a 500 code and message.</source>
          <target state="translated">오류 응답에 사용 된 HTTP 상태입니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 3333에&lt;/strong&gt;&lt;/a&gt; 정의 된 상태 문자열이어야합니다 . 기본값은 500 코드 및 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="7ec9df72f5c095b2cb5ecc4f03530853db502b81" translate="yes" xml:space="preserve">
          <source>The I/O mode for the file, either &lt;code&gt;&quot;r&quot;&lt;/code&gt;, &lt;code&gt;&quot;rw&quot;&lt;/code&gt;, or &lt;code&gt;&quot;w&quot;&lt;/code&gt;.</source>
          <target state="translated">는 I / O 파일의 모드 중 하나 &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;rw&quot;&lt;/code&gt; , 또는 &lt;code&gt;&quot;w&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b613d88a17aac3a0fe826d3aec8b07e41aebbb46" translate="yes" xml:space="preserve">
          <source>The ID is a 4-byte string which identifies the type of chunk.</source>
          <target state="translated">ID는 청크 유형을 식별하는 4 바이트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="221f6efb5eebf643c4c6862eda19d65b5773f066" translate="yes" xml:space="preserve">
          <source>The ID of the integrity check used by the input stream. This may be &lt;code&gt;CHECK_UNKNOWN&lt;/code&gt; until enough of the input has been decoded to determine what integrity check it uses.</source>
          <target state="translated">입력 스트림이 사용하는 무결성 검사의 ID입니다. 사용되는 무결성 검사를 결정하기 위해 충분한 입력이 디코딩 될 때까지 &lt;code&gt;CHECK_UNKNOWN&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d699dfb29e673ac9b34d385b78f0cb6477d087f" translate="yes" xml:space="preserve">
          <source>The IDL definitions do not fully embody the requirements of the W3C DOM API, such as the notion of certain objects, such as the return value of &lt;code&gt;getElementsByTagName()&lt;/code&gt;, being &amp;ldquo;live&amp;rdquo;. The Python DOM API does not require implementations to enforce such requirements.</source>
          <target state="translated">IDL 정의는 &lt;code&gt;getElementsByTagName()&lt;/code&gt; 의 반환 값과 같은 특정 객체의 개념과 같이 W3C DOM API의 요구 사항을 완전히 구현하지 않습니다 . Python DOM API는 이러한 요구 사항을 적용하기 위해 구현이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73534adea22ef371fa587b81eb62e33afe03dae6" translate="yes" xml:space="preserve">
          <source>The IDL types used in the DOM specification are mapped to Python types according to the following table.</source>
          <target state="translated">DOM 사양에 사용 된 IDL 유형은 다음 표에 따라 Python 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="9e8e9b8afe37760ceaad6d8ab19fbe4d24ba22a6" translate="yes" xml:space="preserve">
          <source>The IDLE code running in the execution process adds frames to the call stack that would not be there otherwise. IDLE wraps &lt;code&gt;sys.getrecursionlimit&lt;/code&gt; and &lt;code&gt;sys.setrecursionlimit&lt;/code&gt; to reduce the effect of the additional stack frames.</source>
          <target state="translated">실행 프로세스에서 실행중인 IDLE 코드는 그렇지 않은 프레임을 호출 스택에 추가합니다. IDLE은 &lt;code&gt;sys.getrecursionlimit&lt;/code&gt; 및 &lt;code&gt;sys.setrecursionlimit&lt;/code&gt; 를 래핑 하여 추가 스택 프레임의 영향을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="4f9a8214de2797a406bbc420c4dc6181a8c731c9" translate="yes" xml:space="preserve">
          <source>The IEEE 754 binary16 &amp;ldquo;half precision&amp;rdquo; type was introduced in the 2008 revision of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point#IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;. It has a sign bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), and can represent numbers between approximately &lt;code&gt;6.1e-05&lt;/code&gt; and &lt;code&gt;6.5e+04&lt;/code&gt; at full precision. This type is not widely supported by C compilers: on a typical machine, an unsigned short can be used for storage, but not for math operations. See the Wikipedia page on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Half-precision_floating-point_format&quot;&gt;half-precision floating-point format&lt;/a&gt; for more information.</source>
          <target state="translated">IEEE 754 binary16 &quot;반 정밀도&quot;유형은 2008 년 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point#IEEE_754-2008&quot;&gt;IEEE 754 표준&lt;/a&gt; 개정판에 도입되었습니다 . 부호 비트, 5 비트 지수 및 11 비트 정밀도 (10 비트가 명시 적으로 저장 됨)를 가지며 전체 정밀도에서 대략 &lt;code&gt;6.1e-05&lt;/code&gt; 와 &lt;code&gt;6.5e+04&lt;/code&gt; 사이의 숫자를 나타낼 수 있습니다 . 이 유형은 C 컴파일러에서 널리 지원되지 않습니다. 일반적인 컴퓨터에서는 부호없는 short를 저장에 사용할 수 있지만 수학 연산에는 사용할 수 없습니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Half-precision_floating-point_format&quot;&gt;반 정밀도 부동 소수점 형식&lt;/a&gt; 의 Wikipedia 페이지 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b24db9631befbb1d797b6887700ff491fc6cb519" translate="yes" xml:space="preserve">
          <source>The IEEE 754 special values of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, and &lt;code&gt;-inf&lt;/code&gt; will be handled according to IEEE rules. Specifically, &lt;code&gt;NaN&lt;/code&gt; is not considered close to any other value, including &lt;code&gt;NaN&lt;/code&gt;. &lt;code&gt;inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; are only considered close to themselves.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 의 IEEE 754 특수 값은 IEEE 규칙에 따라 처리됩니다. 특히 &lt;code&gt;NaN&lt;/code&gt; 은 &lt;code&gt;NaN&lt;/code&gt; 을 포함하여 다른 값에 근접한 것으로 간주되지 않습니다 . &lt;code&gt;inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 는 자신과 가까운 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2623b34e7e6ad22abb7cc5f224cc233ff2421da0" translate="yes" xml:space="preserve">
          <source>The ISO calendar is a widely used variant of the Gregorian calendar. &lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;</source>
          <target state="translated">ISO 달력은 널리 사용되는 그레고리력 달력입니다. &lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;삼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e5ad6d935091f9e83d009d71f64cd300714d7ea" translate="yes" xml:space="preserve">
          <source>The ISO year consists of 52 or 53 full weeks, and where a week starts on a Monday and ends on a Sunday. The first week of an ISO year is the first (Gregorian) calendar week of a year containing a Thursday. This is called week number 1, and the ISO year of that Thursday is the same as its Gregorian year.</source>
          <target state="translated">ISO 연도는 52 주 또는 53 주로 구성되며주는 월요일에 시작하여 일요일에 끝납니다. ISO 연도의 첫주는 목요일을 포함하는 연도의 첫 번째 (그레고리오)입니다. 이것을 1 주차라고하며 그 목요일의 ISO 연도는 Gregorian 연도와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f9f1f2433b85fce4cb660f34278dfa1065ffa23" translate="yes" xml:space="preserve">
          <source>The JSON document being parsed.</source>
          <target state="translated">구문 분석중인 JSON 문서</target>
        </trans-unit>
        <trans-unit id="9334515a214a3518850a43c548ab10b96e20d520" translate="yes" xml:space="preserve">
          <source>The JSON file to be validated or pretty-printed:</source>
          <target state="translated">검증되거나 인쇄 될 JSON 파일 :</target>
        </trans-unit>
        <trans-unit id="cb1b5cf7601644b9782c510e837b5298f18e72db" translate="yes" xml:space="preserve">
          <source>The JSON format is specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 7159&lt;/strong&gt;&lt;/a&gt; and by &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;ECMA-404&lt;/a&gt;. This section details this module&amp;rsquo;s level of compliance with the RFC. For simplicity, &lt;a href=&quot;#json.JSONEncoder&quot;&gt;&lt;code&gt;JSONEncoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#json.JSONDecoder&quot;&gt;&lt;code&gt;JSONDecoder&lt;/code&gt;&lt;/a&gt; subclasses, and parameters other than those explicitly mentioned, are not considered.</source>
          <target state="translated">JSON 형식은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7159.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 7159&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;ECMA-404에&lt;/a&gt; 의해 지정됩니다 . 이 섹션에서는이 모듈의 RFC 준수 수준에 대해 자세히 설명합니다. 편의상 &lt;a href=&quot;#json.JSONEncoder&quot;&gt; &lt;code&gt;JSONEncoder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#json.JSONDecoder&quot;&gt; &lt;code&gt;JSONDecoder&lt;/code&gt; &lt;/a&gt; 서브 클래스 및 명시 적으로 언급 된 것 이외의 매개 변수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="876e1c3c101a9ec9b7e2f177815520f974d7df87" translate="yes" xml:space="preserve">
          <source>The Julian day &lt;em&gt;n&lt;/em&gt; (1 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). Leap days are not counted, so in all years February 28 is day 59 and March 1 is day 60.</source>
          <target state="translated">율리우스 날 &lt;em&gt;n&lt;/em&gt; (1 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). 윤일은 계산되지 않으므로 모든 연도 2 월 28 일은 59 일이고 3 월 1 일은 60 일입니다.</target>
        </trans-unit>
        <trans-unit id="e536171d6fc7a17689f9e357f627d94a3ea3655f" translate="yes" xml:space="preserve">
          <source>The LMTP protocol, which is very similar to ESMTP, is heavily based on the standard SMTP client. It&amp;rsquo;s common to use Unix sockets for LMTP, so our &lt;code&gt;connect()&lt;/code&gt; method must support that as well as a regular host:port server. The optional arguments local_hostname and source_address have the same meaning as they do in the &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt; class. To specify a Unix socket, you must use an absolute path for &lt;em&gt;host&lt;/em&gt;, starting with a &amp;lsquo;/&amp;rsquo;.</source>
          <target state="translated">ESMTP와 매우 유사한 LMTP 프로토콜은 표준 SMTP 클라이언트를 기반으로합니다. LMTP에 Unix 소켓을 사용하는 것이 일반적이므로 &lt;code&gt;connect()&lt;/code&gt; 메소드는 일반 호스트 : 포트 서버뿐만 아니라이를 지원해야합니다. 선택적 인수 local_hostname 및 source_address는 &lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; &lt;/a&gt; 클래스 에서와 동일한 의미를 갖습니다 . 유닉스 소켓을 지정하려면 '/'로 시작하는 &lt;em&gt;host&lt;/em&gt; 의 절대 경로를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d3fba6ce34a94ace0a97a85e907800f74b784af9" translate="yes" xml:space="preserve">
          <source>The LogRecord has a number of attributes, most of which are derived from the parameters to the constructor. (Note that the names do not always correspond exactly between the LogRecord constructor parameters and the LogRecord attributes.) These attributes can be used to merge data from the record into the format string. The following table lists (in alphabetical order) the attribute names, their meanings and the corresponding placeholder in a %-style format string.</source>
          <target state="translated">LogRecord에는 많은 속성이 있으며 대부분 속성에서 매개 변수에서 생성자로 파생됩니다. 이름이 항상 LogRecord 생성자 매개 변수와 LogRecord 속성간에 정확히 일치하는 것은 아닙니다. 이러한 속성을 사용하여 레코드의 데이터를 형식 문자열로 병합 할 수 있습니다. 다음 표는 속성 이름, 의미 및 해당 자리 표시자를 % 스타일 형식 문자열로 알파벳순으로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="b7fd284826bbd625b7ac5342e8ef0b2f60f602e7" translate="yes" xml:space="preserve">
          <source>The Maildir specification requires the use of a colon (&lt;code&gt;':'&lt;/code&gt;) in certain message file names. However, some operating systems do not permit this character in file names, If you wish to use a Maildir-like format on such an operating system, you should specify another character to use instead. The exclamation point (&lt;code&gt;'!'&lt;/code&gt;) is a popular choice. For example:</source>
          <target state="translated">Maildir 스펙은 특정 메시지 파일 이름에 콜론 ( &lt;code&gt;':'&lt;/code&gt; )을 사용해야 합니다. 그러나 일부 운영 체제에서는 파일 이름으로이 문자를 사용할 수 없습니다. 이러한 운영 체제에서 Maildir과 유사한 형식을 사용하려면 대신 사용할 다른 문자를 지정해야합니다. 느낌표 ( &lt;code&gt;'!'&lt;/code&gt; )가 인기있는 선택입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ca8704e898feadac45b47aecee721d7345b424d" translate="yes" xml:space="preserve">
          <source>The Mock Class</source>
          <target state="translated">모의 클래스</target>
        </trans-unit>
        <trans-unit id="155fcae67f36b1120104c28ff0aa6a2ca6ef2a6c" translate="yes" xml:space="preserve">
          <source>The Namespace object</source>
          <target state="translated">네임 스페이스 객체</target>
        </trans-unit>
        <trans-unit id="c244a1998ff5b9fbc3c32a89fe8abcf93cbcfce5" translate="yes" xml:space="preserve">
          <source>The Netscape protocol with the bugs fixed. Uses &lt;em&gt;Set-Cookie2&lt;/em&gt; in place of &lt;em&gt;Set-Cookie&lt;/em&gt;. Not widely used.</source>
          <target state="translated">버그가 수정 된 Netscape 프로토콜. &lt;em&gt;Set-Cookie&lt;/em&gt; 대신 &lt;em&gt;Set-Cookie2&lt;/em&gt; 를 사용합니다 . 널리 사용되지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e811022cd0aac44894b0fa01dda129f51245480" translate="yes" xml:space="preserve">
          <source>The NotImplemented Object</source>
          <target state="translated">구현되지 않은 객체</target>
        </trans-unit>
        <trans-unit id="2d88e55940ba65789bd478289ba5ef66aaa6476b" translate="yes" xml:space="preserve">
          <source>The Null Object</source>
          <target state="translated">널 객체</target>
        </trans-unit>
        <trans-unit id="d8d19c38b56784ca153a1dfbfff3704006a6f7d7" translate="yes" xml:space="preserve">
          <source>The Numeric Python extension (NumPy) defines another array type; see &lt;a href=&quot;http://www.numpy.org/&quot;&gt;http://www.numpy.org/&lt;/a&gt; for further information about Numerical Python.</source>
          <target state="translated">Numeric Python 확장 (NumPy)은 다른 배열 유형을 정의합니다. Numerical Python에 대한 자세한 내용 은 &lt;a href=&quot;http://www.numpy.org/&quot;&gt;http://www.numpy.org/&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9e2cd6058ec976a36128b743cd36be50deb3c81" translate="yes" xml:space="preserve">
          <source>The Numerical Python Documentation</source>
          <target state="translated">숫자 파이썬 문서</target>
        </trans-unit>
        <trans-unit id="29a8f4d932090adf9fba37b9d15fe98be224e869" translate="yes" xml:space="preserve">
          <source>The PEP to add the import hooks that help this module work.</source>
          <target state="translated">이 모듈의 작동에 도움이되는 가져 오기 후크를 추가하는 PEP.</target>
        </trans-unit>
        <trans-unit id="cd4be1c13c5613f15135d4c42fb4d6960f2b081a" translate="yes" xml:space="preserve">
          <source>The POP3 TOP command this method uses, unlike the RETR command, doesn&amp;rsquo;t set the message&amp;rsquo;s seen flag; unfortunately, TOP is poorly specified in the RFCs and is frequently broken in off-brand servers. Test this method by hand against the POP3 servers you will use before trusting it.</source>
          <target state="translated">RETR 명령과 달리이 방법이 사용하는 POP3 TOP 명령은 메시지의 표시 플래그를 설정하지 않습니다. 불행히도 TOP은 RFC에 제대로 지정되지 않았으며 종종 브랜드 외부 서버에서 손상됩니다. 이 방법을 신뢰하기 전에 사용할 POP3 서버에 대해이 방법을 직접 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="c8a2773313a96e78dc753d28c768a2fee670d084" translate="yes" xml:space="preserve">
          <source>The POSIX.1-1988 ustar format (&lt;a href=&quot;#tarfile.USTAR_FORMAT&quot;&gt;&lt;code&gt;USTAR_FORMAT&lt;/code&gt;&lt;/a&gt;). It supports filenames up to a length of at best 256 characters and linknames up to 100 characters. The maximum file size is 8 GiB. This is an old and limited but widely supported format.</source>
          <target state="translated">POSIX.1-1988 ustar 형식 ( &lt;a href=&quot;#tarfile.USTAR_FORMAT&quot;&gt; &lt;code&gt;USTAR_FORMAT&lt;/code&gt; &lt;/a&gt; ). 최대 256 자 길이의 파일 이름과 최대 100 자 링크 이름을 지원합니다. 최대 파일 크기는 8 GiB입니다. 이것은 오래되고 제한적이지만 널리 지원되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="3a2b7ddf5592736fae745667d84bd41548545653" translate="yes" xml:space="preserve">
          <source>The POSIX.1-2001 pax format (&lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt;&lt;code&gt;PAX_FORMAT&lt;/code&gt;&lt;/a&gt;). It is the most flexible format with virtually no limits. It supports long filenames and linknames, large files and stores pathnames in a portable way. Modern tar implementations, including GNU tar, bsdtar/libarchive and star, fully support extended &lt;em&gt;pax&lt;/em&gt; features; some old or unmaintained libraries may not, but should treat &lt;em&gt;pax&lt;/em&gt; archives as if they were in the universally-supported &lt;em&gt;ustar&lt;/em&gt; format. It is the current default format for new archives.</source>
          <target state="translated">POSIX.1-2001 pax 형식 ( &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt; &lt;code&gt;PAX_FORMAT&lt;/code&gt; &lt;/a&gt; ). 사실상 제한이없는 가장 유연한 형식입니다. 긴 파일 이름과 링크 이름, 큰 파일을 지원하며 경로 이름을 이식 가능한 방식으로 저장합니다. GNU tar, bsdtar / libarchive 및 star를 포함한 최신 tar 구현은 확장 된 &lt;em&gt;pax&lt;/em&gt; 기능을 완전히 지원 합니다. 일부 오래된 라이브러리 나 유지 관리되지 않은 라이브러리는 &lt;em&gt;pax&lt;/em&gt; 아카이브를 마치 보편적으로 지원되는 &lt;em&gt;ustar&lt;/em&gt; 형식 인 것처럼 취급해야 합니다. 새 아카이브의 현재 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="48f55ddcf8c21fcd18b7aab7a650f356e579978f" translate="yes" xml:space="preserve">
          <source>The Packer</source>
          <target state="translated">패커</target>
        </trans-unit>
        <trans-unit id="4d3cbd26cc18d883fce3423f3e8a2d5ef0540f3d" translate="yes" xml:space="preserve">
          <source>The Parser will call this method to report each chunk of character data. SAX parsers may return all contiguous character data in a single chunk, or they may split it into several chunks; however, all of the characters in any single event must come from the same external entity so that the Locator provides useful information.</source>
          <target state="translated">파서는이 방법을 호출하여 각 문자 데이터 청크를보고합니다. SAX 파서는 연속 된 모든 문자 데이터를 단일 청크로 반환하거나 여러 청크로 분할 할 수 있습니다. 그러나 로케이터가 유용한 정보를 제공 할 수 있도록 단일 이벤트의 모든 문자는 동일한 외부 엔티티에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="4ae9d67de63ced48ddf55430725d32dedbe9dfd5" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method once for each entity skipped. Non-validating processors may skip entities if they have not seen the declarations (because, for example, the entity was declared in an external DTD subset). All processors may skip external entities, depending on the values of the &lt;code&gt;feature_external_ges&lt;/code&gt; and the &lt;code&gt;feature_external_pes&lt;/code&gt; properties.</source>
          <target state="translated">파서는 각 엔티티를 건너 뛸 때 마다이 메소드를 한 번 호출합니다. 유효성을 검사하지 않는 프로세서는 선언을 보지 않으면 엔터티를 건너 뛸 수 있습니다 (예 : 엔터티가 외부 DTD 하위 집합에서 선언 되었기 때문에). &lt;code&gt;feature_external_ges&lt;/code&gt; 및 &lt;code&gt;feature_external_pes&lt;/code&gt; 특성 의 값에 따라 모든 프로세서가 외부 엔티티를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc97f14d1c6ed34640e855f6a0e48fc1a501ede" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method once for each processing instruction found: note that processing instructions may occur before or after the main document element.</source>
          <target state="translated">파서는 발견 된 각 처리 명령에 대해이 메소드를 한 번 호출합니다. 처리 명령은 기본 문서 요소 전후에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76bb55a33805478d33597a12af8474cc775cdba2" translate="yes" xml:space="preserve">
          <source>The Plural formula is taken from the catalog header. It is a C or Python expression that has a free variable &lt;em&gt;n&lt;/em&gt;; the expression evaluates to the index of the plural in the catalog. See &lt;a href=&quot;https://www.gnu.org/software/gettext/manual/gettext.html&quot;&gt;the GNU gettext documentation&lt;/a&gt; for the precise syntax to be used in &lt;code&gt;.po&lt;/code&gt; files and the formulas for a variety of languages.</source>
          <target state="translated">복수 공식은 카탈로그 헤더에서 가져옵니다. 자유 변수 &lt;em&gt;n&lt;/em&gt; 을 갖는 C 또는 Python 표현식입니다 . 이 표현은 카탈로그에서 복수의 인덱스로 평가됩니다. &lt;code&gt;.po&lt;/code&gt; 파일 에서 사용되는 정확한 구문 과 다양한 언어의 공식에 대해서는 &lt;a href=&quot;https://www.gnu.org/software/gettext/manual/gettext.html&quot;&gt;GNU gettext 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d85809a7ab1199bed21e4d02a17dc8bc8a8d5f44" translate="yes" xml:space="preserve">
          <source>The Python &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module by default issues a &lt;code&gt;BEGIN&lt;/code&gt; statement implicitly before a Data Modification Language (DML) statement (i.e. &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;/&lt;code&gt;REPLACE&lt;/code&gt;).</source>
          <target state="translated">Python &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈은 기본적으로 DML (Data Modification Language) 명령문 앞에 묵시적 으로 &lt;code&gt;BEGIN&lt;/code&gt; 문을 발행합니다 (예 : &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; / &lt;code&gt;REPLACE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f50658b2df65ef37c2e5e3a28feec3af7c6b2de4" translate="yes" xml:space="preserve">
          <source>The Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-global-interpreter-lock&quot;&gt;global interpreter lock&lt;/a&gt; is released before calling any function exported by these libraries, and reacquired afterwards.</source>
          <target state="translated">이 라이브러리에서 내 보낸 함수를 호출하기 전에 Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-global-interpreter-lock&quot;&gt;전역 인터프리터 잠금&lt;/a&gt; 이 해제되고 나중에 다시 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="2e3b3878e6b1514addea56227281a773c6e515ca" translate="yes" xml:space="preserve">
          <source>The Python DOM API, however, &lt;em&gt;does&lt;/em&gt; require that normal attribute access work. This means that the typical surrogates generated by Python IDL compilers are not likely to work, and wrapper objects may be needed on the client if the DOM objects are accessed via CORBA. While this does require some additional consideration for CORBA DOM clients, the implementers with experience using DOM over CORBA from Python do not consider this a problem. Attributes that are declared &lt;code&gt;readonly&lt;/code&gt; may not restrict write access in all DOM implementations.</source>
          <target state="translated">그러나 Python DOM API 에는 일반 속성 액세스 작업 &lt;em&gt;이&lt;/em&gt; 필요합니다. 이것은 파이썬 IDL 컴파일러에 의해 생성 된 일반적인 대리가 작동하지 않을 수 있으며 DOM 객체가 CORBA를 통해 액세스되는 경우 래퍼 객체가 클라이언트에 필요할 수 있음을 의미합니다. 여기에는 CORBA DOM 클라이언트에 대한 추가 고려 사항이 필요하지만 Python에서 CORBA를 통해 DOM을 사용한 경험이있는 구현자는이 문제를 고려하지 않습니다. &lt;code&gt;readonly&lt;/code&gt; 으로 선언 된 속성 은 모든 DOM 구현에서 쓰기 액세스를 제한하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a206098364b484165e8287cb349dce95f61567a5" translate="yes" xml:space="preserve">
          <source>The Python DOM interface provides the constants, but also expands the set of exceptions so that a specific exception exists for each of the exception codes defined by the DOM. The implementations must raise the appropriate specific exception, each of which carries the appropriate value for the &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Python DOM 인터페이스는 상수를 제공하지만 예외 세트를 확장하여 DOM에 의해 정의 된 각 예외 코드에 대해 특정 예외가 존재하도록합니다. 구현시 적절한 특정 예외를 발생시켜야하며 각 예외는 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 속성에 적절한 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="3623e9f5502ae30e63b6ff1528d1650f4f52886f" translate="yes" xml:space="preserve">
          <source>The Python Enhancement Proposal which proposed this addition to Python.</source>
          <target state="translated">파이썬에이 추가 기능을 제안한 Python Enhancement Proposal.</target>
        </trans-unit>
        <trans-unit id="16a4aad38a3322fd0c7f6a1a39fbd8541bd549de" translate="yes" xml:space="preserve">
          <source>The Python Profilers</source>
          <target state="translated">파이썬 프로파일 러</target>
        </trans-unit>
        <trans-unit id="68c54fa443db89d7ca0f9bbdbd9b7297be40a028" translate="yes" xml:space="preserve">
          <source>The Python Testing Tools Taxonomy</source>
          <target state="translated">파이썬 테스트 도구 분류법</target>
        </trans-unit>
        <trans-unit id="a80a8e5314f2596cc8e38aeb9211edeb47d6195d" translate="yes" xml:space="preserve">
          <source>The Python Tkinter Topic Guide provides a great deal of information on using Tk from Python and links to other sources of information on Tk.</source>
          <target state="translated">Python Tkinter 주제 안내서는 Python에서 Tk를 사용하는 방법에 대한 많은 정보를 제공하고 Tk의 다른 정보 소스에 대한 링크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fc0b7656660df44baec5ab40803f65464e6222e3" translate="yes" xml:space="preserve">
          <source>The Python Zip Application Archive Format</source>
          <target state="translated">Python Zip 응용 프로그램 아카이브 형식</target>
        </trans-unit>
        <trans-unit id="24305685b310d869a7c6bf7e92bb45e946c72628" translate="yes" xml:space="preserve">
          <source>The Python byte compiler can be invoked on an ST object to produce code objects which can be used as part of a call to the built-in &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; functions. This function provides the interface to the compiler, passing the internal parse tree from &lt;em&gt;st&lt;/em&gt; to the parser, using the source file name specified by the &lt;em&gt;filename&lt;/em&gt; parameter. The default value supplied for &lt;em&gt;filename&lt;/em&gt; indicates that the source was an ST object.</source>
          <target state="translated">ST 오브젝트에서 Python 바이트 컴파일러를 호출하여 내장 &lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 함수 호출의 일부로 사용할 수있는 코드 오브젝트를 생성 할 수 있습니다 . 이 함수는 &lt;em&gt;filename&lt;/em&gt; 매개 변수로 지정된 소스 파일 이름을 사용하여 내부 구문 분석 트리를 &lt;em&gt;st&lt;/em&gt; 에서 구문 분석기로 전달하여 컴파일러에 인터페이스를 제공합니다 . &lt;em&gt;filename에&lt;/em&gt; 제공된 기본값 은 소스가 ST 오브젝트임을 나타냅니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9aed821ec2313afc84ef94ac17cfa17e343147d7" translate="yes" xml:space="preserve">
          <source>The Python compiler currently generates the following bytecode instructions.</source>
          <target state="translated">Python 컴파일러는 현재 다음 바이트 코드 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="84bb1ebb68c17bfe88d2ed5dd2f381d99feff246" translate="yes" xml:space="preserve">
          <source>The Python files which contain certificates can contain a sequence of certificates, sometimes called a &lt;em&gt;certificate chain&lt;/em&gt;. This chain should start with the specific certificate for the principal who &amp;ldquo;is&amp;rdquo; the client or server, and then the certificate for the issuer of that certificate, and then the certificate for the issuer of &lt;em&gt;that&lt;/em&gt; certificate, and so on up the chain till you get to a certificate which is &lt;em&gt;self-signed&lt;/em&gt;, that is, a certificate which has the same subject and issuer, sometimes called a &lt;em&gt;root certificate&lt;/em&gt;. The certificates should just be concatenated together in the certificate file. For example, suppose we had a three certificate chain, from our server certificate to the certificate of the certification authority that signed our server certificate, to the root certificate of the agency which issued the certification authority&amp;rsquo;s certificate:</source>
          <target state="translated">인증서를 포함하는 Python 파일에는 &lt;em&gt;인증서 체인&lt;/em&gt; 이라고하는 일련의 인증서가 포함될 수 있습니다 . 이 체인은 클라이언트 또는 서버 및 해당 인증서 발급자에 대한 인증서, 다음의 발행자에 대한 인증서 &quot;는&quot;원금에 대한 특정 인증서로 시작해야 &lt;em&gt;하는&lt;/em&gt; 인증서 등 당신까지 체인까지 않은 인증서에 도착 &lt;em&gt;자체 서명&lt;/em&gt; 이다, 동일한 주제와 발급자가 인증서, 때로는라는 &lt;em&gt;루트 인증서&lt;/em&gt;. 인증서는 인증서 파일에서 함께 연결되어야합니다. 예를 들어, 서버 인증서에서 서버 인증서에 서명 한 인증 기관의 인증서, 인증 기관의 인증서를 발급 한 기관의 루트 인증서에 이르기까지 3 개의 인증서 체인이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d668df70b1012a771ce85c79c768bca15d3a2ee7" translate="yes" xml:space="preserve">
          <source>The Python installers for the Windows platform usually include the entire standard library and often also include many additional components. For Unix-like operating systems Python is normally provided as a collection of packages, so it may be necessary to use the packaging tools provided with the operating system to obtain some or all of the optional components.</source>
          <target state="translated">Windows 플랫폼 용 Python 설치 프로그램에는 일반적으로 전체 표준 라이브러리가 포함되며 종종 추가 구성 요소가 많이 포함됩니다. 유닉스 계열 운영 체제의 경우 일반적으로 Python은 패키지 모음으로 제공되므로 운영 체제와 함께 제공되는 패키징 도구를 사용하여 선택적 구성 요소의 일부 또는 전부를 구해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39381baeb675becc61bfe651b0384d01c0ecc02" translate="yes" xml:space="preserve">
          <source>The Python interface is a straightforward transliteration of the Unix system call and library interface for sockets to Python&amp;rsquo;s object-oriented style: the &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; function returns a &lt;em&gt;socket object&lt;/em&gt; whose methods implement the various socket system calls. Parameter types are somewhat higher-level than in the C interface: as with &lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; operations on Python files, buffer allocation on receive operations is automatic, and buffer length is implicit on send operations.</source>
          <target state="translated">Python 인터페이스는 Unix 시스템 호출과 소켓의 라이브러리 인터페이스를 Python의 객체 지향 스타일로 간단하게 음역합니다. &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 함수는 메소드가 다양한 소켓 시스템 호출을 구현 하는 &lt;em&gt;소켓 객체&lt;/em&gt; 를 반환 합니다. 매개 변수 유형은 C 인터페이스보다 다소 높은 수준 입니다. Python 파일의 &lt;code&gt;read()&lt;/code&gt; 및 &lt;code&gt;write()&lt;/code&gt; 작업 과 마찬가지로 수신 작업의 버퍼 할당은 자동이며 전송 작업에는 버퍼 길이가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c4a529f0722167f2c4ba898392f0015bfae784" translate="yes" xml:space="preserve">
          <source>The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.</source>
          <target state="translated">파이썬 인터프리터에는 항상 사용 가능한 많은 함수와 유형이 내장되어 있습니다. 알파벳 순서로 여기에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="9326ea45f498d239e80ceb0e3060d4907816c0fb" translate="yes" xml:space="preserve">
          <source>The Python module providing secure hash functions.</source>
          <target state="translated">안전한 해시 함수를 제공하는 Python 모듈.</target>
        </trans-unit>
        <trans-unit id="5c70b76112bff8f234c081d6c7a3acbb6832303b" translate="yes" xml:space="preserve">
          <source>The Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc.</source>
          <target state="translated">Python 런타임은 함수 및 변수 유형 주석을 시행하지 않습니다. 유형 검사기, IDE, 린터 등과 같은 타사 도구에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20e932146154996d93ed84e9bb70077634ce4a18" translate="yes" xml:space="preserve">
          <source>The Python standard library provides two different implementations of the same profiling interface:</source>
          <target state="translated">Python 표준 라이브러리는 동일한 프로파일 링 인터페이스의 두 가지 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00c57304482cc2aeefdb4600f8e3ef9b77b1caa7" translate="yes" xml:space="preserve">
          <source>The RFC does not explicitly forbid JSON strings which contain byte sequences that don&amp;rsquo;t correspond to valid Unicode characters (e.g. unpaired UTF-16 surrogates), but it does note that they may cause interoperability problems. By default, this module accepts and outputs (when present in the original &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;) code points for such sequences.</source>
          <target state="translated">RFC는 유효한 유니 코드 문자 (예 : 짝이없는 UTF-16 서로 게이트)에 해당하지 않는 바이트 시퀀스를 포함하는 JSON 문자열을 명시 적으로 금지하지는 않지만 상호 운용성 문제를 일으킬 수 있습니다. 기본적으로이 모듈은 해당 시퀀스에 대한 코드 포인트 ( 원래 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 에있는 경우)를 받아들이고 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="a21611c1abaea76578ca01231f4e34f3cea77291" translate="yes" xml:space="preserve">
          <source>The RFC does not permit the representation of infinite or NaN number values. Despite that, by default, this module accepts and outputs &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; as if they were valid JSON number literal values:</source>
          <target state="translated">RFC는 무한 또는 NaN 숫자 값의 표현을 허용하지 않습니다. 그럼에도 불구하고 기본적으로이 모듈은 &lt;code&gt;Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 을 유효한 JSON 숫자 리터럴 값인 것처럼 받아들이고 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="1d56e81c90cade5d7a8cd14714bd520f16d520a4" translate="yes" xml:space="preserve">
          <source>The RFC prohibits adding a byte order mark (BOM) to the start of a JSON text, and this module&amp;rsquo;s serializer does not add a BOM to its output. The RFC permits, but does not require, JSON deserializers to ignore an initial BOM in their input. This module&amp;rsquo;s deserializer raises a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when an initial BOM is present.</source>
          <target state="translated">RFC는 JSON 텍스트의 시작에 BOM (byte order mark)을 추가하는 것을 금지하며이 모듈의 직렬 변환기는 출력에 BOM을 추가하지 않습니다. RFC는 JSON 디시리얼라이저가 입력에서 초기 BOM을 무시하도록 허용하지만 필수는 아닙니다. 이 모듈의 디시리얼라이저 는 초기 BOM이있을 때 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="28a0c061baaa6d098aea953c60411ddd94747207" translate="yes" xml:space="preserve">
          <source>The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability.</source>
          <target state="translated">RFC에서는 JSON이 UTF-8, UTF-16 또는 UTF-32를 사용하여 표현되어야하며 상호 운용성을 최대화하기 위해 UTF-8이 권장되는 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="23658f6ac2fddbb213f90b08b1d920e9ec72edc0" translate="yes" xml:space="preserve">
          <source>The RFC specifies that the names within a JSON object should be unique, but does not mandate how repeated names in JSON objects should be handled. By default, this module does not raise an exception; instead, it ignores all but the last name-value pair for a given name:</source>
          <target state="translated">RFC는 JSON 객체 내의 이름이 고유해야한다고 지정하지만 JSON 객체의 반복되는 이름을 처리하는 방법을 요구하지는 않습니다. 기본적으로이 모듈은 예외를 발생시키지 않습니다. 대신, 주어진 이름의 성-값 쌍을 제외한 모든 것을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ebb53a0bf22d95c16083195b220ed98dcd13adc1" translate="yes" xml:space="preserve">
          <source>The Rmail manual, with some information on Babyl semantics.</source>
          <target state="translated">Babyl 의미에 대한 정보가 포함 된 Rmail 설명서.</target>
        </trans-unit>
        <trans-unit id="1e7b89846a8ae03eb96b19c9bea0cacf3c76d698" translate="yes" xml:space="preserve">
          <source>The SAX API defines four kinds of handlers: content handlers, DTD handlers, error handlers, and entity resolvers. Applications normally only need to implement those interfaces whose events they are interested in; they can implement the interfaces in a single object or in multiple objects. Handler implementations should inherit from the base classes provided in the module &lt;a href=&quot;#module-xml.sax.handler&quot;&gt;&lt;code&gt;xml.sax.handler&lt;/code&gt;&lt;/a&gt;, so that all methods get default implementations.</source>
          <target state="translated">SAX API는 컨텐츠 핸들러, DTD 핸들러, 오류 핸들러 및 엔티티 분석기의 네 가지 핸들러를 정의합니다. 응용 프로그램은 일반적으로 이벤트에 관심이있는 인터페이스 만 구현하면됩니다. 단일 객체 또는 여러 객체에서 인터페이스를 구현할 수 있습니다. 핸들러 구현은 모든 메소드가 기본 구현을 갖도록 모듈 &lt;a href=&quot;#module-xml.sax.handler&quot;&gt; &lt;code&gt;xml.sax.handler&lt;/code&gt; 에&lt;/a&gt; 제공된 기본 클래스에서 상속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e45a78d79d0524145dc4edd32e06f22f85cede3" translate="yes" xml:space="preserve">
          <source>The SAX parser will ignore this if there is also a character stream specified, but it will use a byte stream in preference to opening a URI connection itself.</source>
          <target state="translated">문자 스트림도 지정된 경우 SAX 구문 분석기는이를 무시하지만 URI 연결 자체를 여는 것보다 바이트 스트림을 우선적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="707dc789f59e976c73fe4ffebb33bc0207ccae0c" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method only once, and it will be the last method invoked during the parse. The parser shall not invoke this method until it has either abandoned parsing (because of an unrecoverable error) or reached the end of input.</source>
          <target state="translated">SAX 구문 분석기는이 메소드를 한 번만 호출하며 구문 분석 중에 마지막으로 호출 된 메소드가됩니다. 구문 분석기는 구문 분석을 포기했거나 (복구 할 수없는 오류로 인해) 입력 끝에 도달 할 때까지이 메소드를 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="12f3a1297e14e9b828efc8bdfb73d80a8d01bec8" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method only once, before any other methods in this interface or in DTDHandler (except for &lt;a href=&quot;#xml.sax.handler.ContentHandler.setDocumentLocator&quot;&gt;&lt;code&gt;setDocumentLocator()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">SAX 구문 분석기는이 인터페이스 또는 DTDHandler의 다른 메소드 ( &lt;a href=&quot;#xml.sax.handler.ContentHandler.setDocumentLocator&quot;&gt; &lt;code&gt;setDocumentLocator()&lt;/code&gt; &lt;/a&gt; 제외)에서이 메소드를 한 번만 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7e8e8330c21b74043b8205ded9ff9a5829bf01f2" translate="yes" xml:space="preserve">
          <source>The SKIP flag can also be used for temporarily &amp;ldquo;commenting out&amp;rdquo; examples.</source>
          <target state="translated">SKIP 플래그는 또한 일시적으로 &quot;주석 작성&quot;예제에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4390f432eb2ffe2df3a4d9609866a7b2b82664d" translate="yes" xml:space="preserve">
          <source>The SMTP server refused to accept the message data.</source>
          <target state="translated">SMTP 서버가 메시지 데이터 수락을 거부했습니다.</target>
        </trans-unit>
        <trans-unit id="963f7e97b0fccc8fe8ffa791fe316f759f135cf9" translate="yes" xml:space="preserve">
          <source>The SQLite web page; the documentation describes the syntax and the available data types for the supported SQL dialect.</source>
          <target state="translated">SQLite 웹 페이지; 이 문서는 지원되는 SQL 언어에 대한 구문 및 사용 가능한 데이터 유형에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="beffeb6dadecb40fadf90c17df812ca7ad08d63c" translate="yes" xml:space="preserve">
          <source>The SSL context created above will only allow TLSv1.2 and later (if supported by your system) connections to a server. &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt; implies certificate validation and hostname checks by default. You have to load certificates into the context.</source>
          <target state="translated">위에서 만든 SSL 컨텍스트는 TLSv1.2 이상 (시스템에서 지원하는 경우) 만 서버에 연결하도록 허용합니다. &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; &lt;/a&gt; 는 기본적으로 인증서 유효성 검사 및 호스트 이름 확인을 의미합니다. 컨텍스트에 인증서를로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0e2d72a60f11662a8e29849a7b2b192660b7e39" translate="yes" xml:space="preserve">
          <source>The SSL handshake itself will be non-blocking: the &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; method has to be retried until it returns successfully. Here is a synopsis using &lt;a href=&quot;select#select.select&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; to wait for the socket&amp;rsquo;s readiness:</source>
          <target state="translated">SSL 핸드 셰이크 자체는 차단되지 않습니다. &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 메소드는 성공적으로 리턴 될 때까지 재 시도해야합니다. 다음은 &lt;a href=&quot;select#select.select&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 소켓의 준비 상태를 기다리는 개요입니다 .</target>
        </trans-unit>
        <trans-unit id="7fb047f21fae24e28383d98ea942a6e80e264d6c" translate="yes" xml:space="preserve">
          <source>The SSL version to use (defaults to &lt;a href=&quot;ssl#ssl.PROTOCOL_SSLv23&quot;&gt;&lt;code&gt;ssl.PROTOCOL_SSLv23&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">사용할 SSL 버전 (기본값은 &lt;a href=&quot;ssl#ssl.PROTOCOL_SSLv23&quot;&gt; &lt;code&gt;ssl.PROTOCOL_SSLv23&lt;/code&gt; &lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="4c7e282a13558a44891e2e101c6cf6d12c13e561" translate="yes" xml:space="preserve">
          <source>The ST objects are not required to support the functionality of this module, but are provided for three purposes: to allow an application to amortize the cost of processing complex parse trees, to provide a parse tree representation which conserves memory space when compared to the Python list or tuple representation, and to ease the creation of additional modules in C which manipulate parse trees. A simple &amp;ldquo;wrapper&amp;rdquo; class may be created in Python to hide the use of ST objects.</source>
          <target state="translated">ST 오브젝트는이 모듈의 기능을 지원할 필요는 없지만 세 가지 목적으로 제공됩니다. 애플리케이션이 복잡한 구문 분석 트리 처리 비용을 상각 할 수 있도록하고, 파이썬과 비교할 때 메모리 공간을 절약하는 구문 분석 트리 표현을 제공합니다. 목록 또는 튜플 표현, 구문 분석 트리를 조작하는 C에서 추가 모듈 작성을 용이하게합니다. ST 객체의 사용을 숨기기 위해 간단한 &quot;래퍼&quot;클래스를 파이썬으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c355f4b21e15033d897535af6a95e51399ced7" translate="yes" xml:space="preserve">
          <source>The Shell window also has an output squeezing facility explained in the &lt;em&gt;Python Shell window&lt;/em&gt; subsection below.</source>
          <target state="translated">Shell 창에는 아래 의 &lt;em&gt;Python Shell 창&lt;/em&gt; 하위 섹션에 설명 된 출력 압착 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea690a46ecf07b29fe276979038395655dc2267" translate="yes" xml:space="preserve">
          <source>The Signature object represents the call signature of a callable object and its return annotation. To retrieve a Signature object, use the &lt;a href=&quot;#inspect.signature&quot;&gt;&lt;code&gt;signature()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Signature 객체는 호출 가능한 객체의 호출 서명과 반환 주석을 나타냅니다. Signature 객체를 검색하려면 &lt;a href=&quot;#inspect.signature&quot;&gt; &lt;code&gt;signature()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f14d6f9e95b7ec47f48e2395c9457f82042675cb" translate="yes" xml:space="preserve">
          <source>The Solaris OS has a &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; timer that attempts to use an optimal hardware source, and may give close to nanosecond resolution. &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; is the nonadjustable, high-resolution clock.</source>
          <target state="translated">Solaris OS에는 최적의 하드웨어 소스를 사용하려고 하는 &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; 타이머가 있으며 나노초 해상도에 가깝습니다. &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; 는 조정 불가능한 고해상도 클록입니다.</target>
        </trans-unit>
        <trans-unit id="cc3eb93ee8c21fc37dd86535f775f5eb431b9c88" translate="yes" xml:space="preserve">
          <source>The Solaris operating system defines its own binary &lt;code&gt;.mo&lt;/code&gt; file format, but since no documentation can be found on this format, it is not supported at this time.</source>
          <target state="translated">Solaris 운영 체제는 자체 바이너리 &lt;code&gt;.mo&lt;/code&gt; 파일 형식을 정의 하지만이 형식에 대한 문서를 찾을 수 없으므로 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0ac37e8315bdb7114c046319dce82f883d628c8" translate="yes" xml:space="preserve">
          <source>The SunOS tar extended format. This format is a variant of the POSIX.1-2001 pax format, but is not compatible.</source>
          <target state="translated">SunOS tar 확장 형식 이 형식은 POSIX.1-2001 pax 형식의 변형이지만 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c6064fcd51da76a4b8688cbb79d85ed3cbe6902" translate="yes" xml:space="preserve">
          <source>The Task is &lt;em&gt;cancelled&lt;/em&gt; when the cancellation was requested with &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; and the wrapped coroutine propagated the &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception thrown into it.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.Task.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 사용하여 취소가 요청되고 랩핑 된 코 루틴이 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외를 전달하면 작업이 &lt;em&gt;취소&lt;/em&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="c832c625e27d27b2df4a2f2747f5f1ffb11ed665" translate="yes" xml:space="preserve">
          <source>The Time Zone Database (often called tz, tzdata or zoneinfo) contains code and data that represent the history of local time for many representative locations around the globe. It is updated periodically to reflect changes made by political bodies to time zone boundaries, UTC offsets, and daylight-saving rules.</source>
          <target state="translated">표준 시간대 데이터베이스 (종종 tz, tzdata 또는 zoneinfo라고 함)에는 전세계 여러 대표 위치의 현지 시간 기록을 나타내는 코드와 데이터가 포함되어 있습니다. 정치 기관이 시간대 경계, UTC 오프셋 및 일광 절약 규칙에 대한 변경 사항을 반영하도록 정기적으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="90e26b26d9a0af28886fde0a18d530daf10ace98" translate="yes" xml:space="preserve">
          <source>The Tk part of the Tk Widgets implement the final mapping to &amp;hellip;</source>
          <target state="translated">Tk 위젯의 Tk 부분은 다음에 대한 최종 매핑을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a8035c8d4a76baa8e0c5f30604affaf05adf9c98" translate="yes" xml:space="preserve">
          <source>The Tk/Tcl development is largely taking place at ActiveState.</source>
          <target state="translated">Tk / Tcl 개발은 주로 ActiveState에서 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2e0c5b0d8a8fbb506b26541482bf9fad625ee9" translate="yes" xml:space="preserve">
          <source>The Treeview widget generates the following virtual events.</source>
          <target state="translated">Treeview 위젯은 다음과 같은 가상 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="197ec35dbcf1ac2c21896fa47f315993bf446dd5" translate="yes" xml:space="preserve">
          <source>The Treeview widget supports horizontal and vertical scrolling, according to the options described in &lt;a href=&quot;#scrollable-widget-options&quot;&gt;Scrollable Widget Options&lt;/a&gt; and the methods &lt;a href=&quot;#tkinter.ttk.Treeview.xview&quot;&gt;&lt;code&gt;Treeview.xview()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Treeview.yview&quot;&gt;&lt;code&gt;Treeview.yview()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Treeview 위젯은 &lt;a href=&quot;#scrollable-widget-options&quot;&gt;스크롤 가능한 위젯 옵션&lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Treeview.xview&quot;&gt; &lt;code&gt;Treeview.xview()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Treeview.yview&quot;&gt; &lt;code&gt;Treeview.yview()&lt;/code&gt; &lt;/a&gt; 메소드에 설명 된 옵션에 따라 가로 및 세로 스크롤을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c6114ecf3800a7be16c1cceda8f0ef24d4070d2d" translate="yes" xml:space="preserve">
          <source>The URI authority, typically a host, but may also contain a port separated by a colon.</source>
          <target state="translated">URI 권한, 일반적으로 호스트이지만 콜론으로 구분 된 포트를 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b94c4c5d2f79c9e8d639c6cdb0ef5a62f7c53c" translate="yes" xml:space="preserve">
          <source>The URI of the XHTML namespace as defined by &lt;a href=&quot;https://www.w3.org/TR/xhtml1/&quot;&gt;XHTML 1.0: The Extensible HyperText Markup Language&lt;/a&gt; (section 3.1.1).</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/xhtml1/&quot;&gt;XHTML 1.0 : Extensible HyperText Markup Language&lt;/a&gt; (섹션 3.1.1)에 의해 정의 된 XHTML 네임 스페이스의 URI .</target>
        </trans-unit>
        <trans-unit id="46e2b896a8750fe169be7a5ca65a3f1110bc2ba4" translate="yes" xml:space="preserve">
          <source>The URI or URL that triggered the error.</source>
          <target state="translated">오류를 트리거 한 URI 또는 ​​URL입니다.</target>
        </trans-unit>
        <trans-unit id="675c281e0cb1795bfbcb6b86336646e2a1113c23" translate="yes" xml:space="preserve">
          <source>The URI path. If the &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; uses a proxy, then selector will be the full URL that is passed to the proxy.</source>
          <target state="translated">URI 경로 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 이 프록시를 사용하는 경우 선택기는 프록시로 전달되는 전체 URL이됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c63ee71e5d56e82a263265f0b8cfef06ac654b" translate="yes" xml:space="preserve">
          <source>The URI scheme.</source>
          <target state="translated">URI 체계.</target>
        </trans-unit>
        <trans-unit id="4a032d6b5843fa436cc4c90b072280e903ed7533" translate="yes" xml:space="preserve">
          <source>The URL parsing functions focus on splitting a URL string into its components, or on combining URL components into a URL string.</source>
          <target state="translated">URL 구문 분석 기능은 URL 문자열을 구성 요소로 분할하거나 URL 구성 요소를 URL 문자열로 결합하는 데 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="0da793b6172e55a10633bab2dfb6db89e488f43e" translate="yes" xml:space="preserve">
          <source>The URL parsing functions were originally designed to operate on character strings only. In practice, it is useful to be able to manipulate properly quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the URL parsing functions in this module all operate on &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; objects in addition to &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">URL 구문 분석 기능은 원래 문자열에서만 작동하도록 설계되었습니다. 실제로 올바르게 인용되고 인코딩 된 URL을 ASCII 바이트 시퀀스로 조작 할 수 있으면 유용합니다. &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 모듈의 URL 구문 분석 기능은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체 외에도 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 바이트 배열 객체에서 모두 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="767746494e5992b19ee4215ca1c553ccc7ef02b6" translate="yes" xml:space="preserve">
          <source>The URL quoting functions focus on taking program data and making it safe for use as URL components by quoting special characters and appropriately encoding non-ASCII text. They also support reversing these operations to recreate the original data from the contents of a URL component if that task isn&amp;rsquo;t already covered by the URL parsing functions above.</source>
          <target state="translated">URL 인용 기능은 특수 문자를 인용하고 비 ASCII 텍스트를 적절하게 인코딩하여 프로그램 데이터를 가져 와서 URL 구성 요소로 안전하게 사용할 수 있도록하는 데 중점을 둡니다. 또한 해당 작업이 위의 URL 구문 분석 기능으로 처리되지 않은 경우 URL 구성 요소의 내용에서 원래 데이터를 다시 작성하기 위해 이러한 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54066892316ef33a7c80c7cc0ef79d07ebc23fea" translate="yes" xml:space="preserve">
          <source>The UTC timezone, &lt;code&gt;timezone(timedelta(0))&lt;/code&gt;.</source>
          <target state="translated">UTC 시간대, &lt;code&gt;timezone(timedelta(0))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="230fce554aaa73006fcdc744072561d1b035264b" translate="yes" xml:space="preserve">
          <source>The UUID as a 128-bit integer.</source>
          <target state="translated">128 비트 정수인 UUID입니다.</target>
        </trans-unit>
        <trans-unit id="ada1c18a51eb3eac79e65818a624c02eaee85742" translate="yes" xml:space="preserve">
          <source>The UUID as a 16-byte string (containing the six integer fields in big-endian byte order).</source>
          <target state="translated">16 바이트 문자열로 된 UUID (빅 엔디안 바이트 순서로 6 개의 정수 필드 포함).</target>
        </trans-unit>
        <trans-unit id="2381ab9006b77ecac0111ea046ff0cb7e8dfd5d1" translate="yes" xml:space="preserve">
          <source>The UUID as a 16-byte string (with &lt;em&gt;time_low&lt;/em&gt;, &lt;em&gt;time_mid&lt;/em&gt;, and &lt;em&gt;time_hi_version&lt;/em&gt; in little-endian byte order).</source>
          <target state="translated">16 바이트 문자열로 UUID입니다 ( little-endian 바이트 순서 로 &lt;em&gt;time_low&lt;/em&gt; , &lt;em&gt;time_mid&lt;/em&gt; 및 &lt;em&gt;time_hi_version 사용&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c6aa8c5331e6dfe4b2198d9e5600b8c7ebfc894" translate="yes" xml:space="preserve">
          <source>The UUID as a 32-character hexadecimal string.</source>
          <target state="translated">32 자 16 진 문자열 인 UUID입니다.</target>
        </trans-unit>
        <trans-unit id="177533cf244a77a50c952f3fbe78b63c34c13f4c" translate="yes" xml:space="preserve">
          <source>The UUID as a URN as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 4122&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 4122에&lt;/strong&gt;&lt;/a&gt; 지정된 URND로서의 UUID .</target>
        </trans-unit>
        <trans-unit id="4ce88db58d1bd2cff41f02584142c4d5b6236bbd" translate="yes" xml:space="preserve">
          <source>The UUID variant, which determines the internal layout of the UUID. This will be one of the constants &lt;a href=&quot;#uuid.RESERVED_NCS&quot;&gt;&lt;code&gt;RESERVED_NCS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#uuid.RFC_4122&quot;&gt;&lt;code&gt;RFC_4122&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#uuid.RESERVED_MICROSOFT&quot;&gt;&lt;code&gt;RESERVED_MICROSOFT&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#uuid.RESERVED_FUTURE&quot;&gt;&lt;code&gt;RESERVED_FUTURE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UUID 변형은 UUID의 내부 레이아웃을 결정합니다. 이것은 &lt;a href=&quot;#uuid.RESERVED_NCS&quot;&gt; &lt;code&gt;RESERVED_NCS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#uuid.RFC_4122&quot;&gt; &lt;code&gt;RFC_4122&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#uuid.RESERVED_MICROSOFT&quot;&gt; &lt;code&gt;RESERVED_MICROSOFT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#uuid.RESERVED_FUTURE&quot;&gt; &lt;code&gt;RESERVED_FUTURE&lt;/code&gt; &lt;/a&gt; 상수 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="c342fe24c4cbcb0d257de674ff4759e57b22adbe" translate="yes" xml:space="preserve">
          <source>The UUID version number (1 through 5, meaningful only when the variant is &lt;a href=&quot;#uuid.RFC_4122&quot;&gt;&lt;code&gt;RFC_4122&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">UUID 버전 번호 (1-5, 변형이 &lt;a href=&quot;#uuid.RFC_4122&quot;&gt; &lt;code&gt;RFC_4122&lt;/code&gt; 인&lt;/a&gt; 경우에만 의미가 있음 )</target>
        </trans-unit>
        <trans-unit id="a51363554bd414c12851cae7faea9edf2a962fd9" translate="yes" xml:space="preserve">
          <source>The UUID was generated by the platform in a multiprocessing-safe way.</source>
          <target state="translated">UUID는 플랫폼에 의해 다중 처리 안전 방식으로 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="47a9a2e59e442cbdb8a457590010b0cf856f5044" translate="yes" xml:space="preserve">
          <source>The UUID was not generated in a multiprocessing-safe way.</source>
          <target state="translated">UUID는 안전한 다중 처리 방식으로 생성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2a47f74b6e550e89792615dcf5953a8088aa9f2e" translate="yes" xml:space="preserve">
          <source>The Unicode standard defines various normalization forms of a Unicode string, based on the definition of canonical equivalence and compatibility equivalence. In Unicode, several characters can be expressed in various way. For example, the character U+00C7 (LATIN CAPITAL LETTER C WITH CEDILLA) can also be expressed as the sequence U+0043 (LATIN CAPITAL LETTER C) U+0327 (COMBINING CEDILLA).</source>
          <target state="translated">유니 코드 표준은 표준 동등성 및 호환성 동등성 정의를 기반으로 유니 코드 문자열의 다양한 정규화 형식을 정의합니다. 유니 코드에서는 여러 문자를 다양한 방식으로 표현할 수 있습니다. 예를 들어, 문자 U + 00C7 (CEDILLA가있는 라틴 대문자 C)은 시퀀스 U + 0043 (라틴 대문자 C) U + 0327 (복합 CEDILLA)로 표현 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c04d63dca6dbfa35a8eb332fbd0e71599ed04307" translate="yes" xml:space="preserve">
          <source>The Unix man page for &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit(2)&lt;/a&gt;&lt;/em&gt; lists the available resources. Note that not all systems use the same symbol or same value to denote the same resource. This module does not attempt to mask platform differences &amp;mdash; symbols not defined for a platform will not be available from this module on that platform.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit (2)&lt;/a&gt;&lt;/em&gt; 의 유닉스 매뉴얼 페이지에 사용 가능한 자원이 나열됩니다. 모든 시스템이 동일한 자원을 나타 내기 위해 동일한 기호 또는 동일한 값을 사용하는 것은 아닙니다. 이 모듈은 플랫폼 차이를 가리려고하지 않습니다. 플랫폼에 대해 정의되지 않은 기호는 해당 플랫폼의이 모듈에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a7c44388893db174e9ea999556cdbef90f21c4a" translate="yes" xml:space="preserve">
          <source>The W3C recommendation for the DOM supported by &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; 에서&lt;/a&gt; 지원하는 DOM에 대한 W3C 권장 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="12834e293d8b743cd66ae767c77319fb9cdda8c3" translate="yes" xml:space="preserve">
          <source>The W3C recommendation for the DOM supported by &lt;a href=&quot;xml.dom.minidom#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xml.dom.minidom#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; 에서&lt;/a&gt; 지원하는 DOM에 대한 W3C 권장 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="31da42b88e14c17335b5f3c69d5530c7bbb076fe" translate="yes" xml:space="preserve">
          <source>The W3C recommendation upon which the Python DOM API is based.</source>
          <target state="translated">Python DOM API의 기반이되는 W3C 권장 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7f9e002ad4780ba707a87e87fd969fb608c7c36f" translate="yes" xml:space="preserve">
          <source>The Warnings Filter</source>
          <target state="translated">경고 필터</target>
        </trans-unit>
        <trans-unit id="10331ee2cc67db663d1588e865683c3ef36476ce" translate="yes" xml:space="preserve">
          <source>The Web Server Gateway Interface (WSGI) is a standard interface between web server software and web applications written in Python. Having a standard interface makes it easy to use an application that supports WSGI with a number of different web servers.</source>
          <target state="translated">WSGI (Web Server Gateway Interface)는 웹 서버 소프트웨어와 Python으로 작성된 웹 응용 프로그램 간의 표준 인터페이스입니다. 표준 인터페이스가 있으면 여러 웹 서버에서 WSGI를 지원하는 응용 프로그램을 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ae5961df21f86344f6e296a655c0d9ff73bdfd3" translate="yes" xml:space="preserve">
          <source>The Window Manager</source>
          <target state="translated">창 관리자</target>
        </trans-unit>
        <trans-unit id="65c6ce80c74663bba1681b82368d9ef75309faf6" translate="yes" xml:space="preserve">
          <source>The XML format for plist files.</source>
          <target state="translated">plist 파일의 XML 형식입니다.</target>
        </trans-unit>
        <trans-unit id="fc2e75c413853f6e04459cc96ca7e162e334c720" translate="yes" xml:space="preserve">
          <source>The XML handling submodules are:</source>
          <target state="translated">XML 처리 서브 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee22895916a9fd9bfc78eca970b52547580e8558" translate="yes" xml:space="preserve">
          <source>The XML modules are not secure against erroneous or maliciously constructed data. If you need to parse untrusted or unauthenticated data see the &lt;a href=&quot;#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt; and &lt;a href=&quot;#defused-packages&quot;&gt;The defusedxml and defusedexpat Packages&lt;/a&gt; sections.</source>
          <target state="translated">XML 모듈은 잘못되었거나 악의적으로 구성된 데이터로부터 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;#xml-vulnerabilities&quot;&gt;XML 취약성&lt;/a&gt; 및 &lt;a href=&quot;#defused-packages&quot;&gt;defusedxml 및 defusedexpat 패키지&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c0f2cf621a14c2bbdbfa819908f6b587d931318" translate="yes" xml:space="preserve">
          <source>The XML processing modules are not secure against maliciously constructed data. An attacker can abuse XML features to carry out denial of service attacks, access local files, generate network connections to other machines, or circumvent firewalls.</source>
          <target state="translated">XML 처리 모듈은 악의적으로 구성된 데이터로부터 안전하지 않습니다. 공격자는 XML 기능을 악용하여 서비스 거부 공격을 수행하고 로컬 파일에 액세스하며 다른 컴퓨터에 대한 네트워크 연결을 생성하거나 방화벽을 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252486bd245ee68d35a40ade01a5e1d9f61f7038" translate="yes" xml:space="preserve">
          <source>The ZIP file format does not support timestamps before 1980.</source>
          <target state="translated">ZIP 파일 형식은 1980 년 이전의 타임 스탬프를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c63b3aee37e3a038e39805f29c23907870ffa3ea" translate="yes" xml:space="preserve">
          <source>The ZIP file format is a common archive and compression standard. This module provides tools to create, read, write, append, and list a ZIP file. Any advanced use of this module will require an understanding of the format, as defined in &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;PKZIP Application Note&lt;/a&gt;.</source>
          <target state="translated">ZIP 파일 형식은 일반적인 아카이브 및 압축 표준입니다. 이 모듈은 ZIP 파일을 작성, 읽기, 쓰기, 추가 및 나열하는 도구를 제공합니다. 이 모듈을 고급으로 사용하려면 &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;PKZIP 애플리케이션 노트에&lt;/a&gt; 정의 된대로 형식을 이해해야합니다. .</target>
        </trans-unit>
        <trans-unit id="442d8cccd431e779c9116f151ef53c174751f57b" translate="yes" xml:space="preserve">
          <source>The ZIP file format specification has included support for bzip2 compression since 2001, and for LZMA compression since 2006. However, some tools (including older Python releases) do not support these compression methods, and may either refuse to process the ZIP file altogether, or fail to extract individual files.</source>
          <target state="translated">ZIP 파일 형식 사양에는 2001 년 이후 bzip2 압축 지원과 2006 년 이후 LZMA 압축 지원이 포함되어 있습니다. 그러나 일부 도구 (이전 Python 릴리스 포함)는 이러한 압축 방법을 지원하지 않으며 ZIP 파일 처리를 완전히 거부하거나 개별 파일을 추출하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="98199ae838f2d5784421f8c9d0b795a0bb8b257d" translate="yes" xml:space="preserve">
          <source>The above &lt;a href=&quot;#module-bisect&quot;&gt;&lt;code&gt;bisect()&lt;/code&gt;&lt;/a&gt; functions are useful for finding insertion points but can be tricky or awkward to use for common searching tasks. The following five functions show how to transform them into the standard lookups for sorted lists:</source>
          <target state="translated">위의 &lt;a href=&quot;#module-bisect&quot;&gt; &lt;code&gt;bisect()&lt;/code&gt; &lt;/a&gt; 함수는 삽입 점을 찾는 데 유용하지만 일반적인 검색 작업에 사용하기 까다 롭거나 어색 할 수 있습니다. 다음 5 가지 함수는 정렬 된 목록에 대한 표준 조회로 변환하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="407e21ba6d5dd1ee8eee311341a7ab707eb91302" translate="yes" xml:space="preserve">
          <source>The above YAML snippet defines three formatters. The first, with id &lt;code&gt;brief&lt;/code&gt;, is a standard &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;logging.Formatter&lt;/code&gt;&lt;/a&gt; instance with the specified format string. The second, with id &lt;code&gt;default&lt;/code&gt;, has a longer format and also defines the time format explicitly, and will result in a &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;logging.Formatter&lt;/code&gt;&lt;/a&gt; initialized with those two format strings. Shown in Python source form, the &lt;code&gt;brief&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; formatters have configuration sub-dictionaries:</source>
          <target state="translated">위의 YAML 스 니펫은 세 가지 포맷터를 정의합니다. 첫 번째 는 &lt;code&gt;brief&lt;/code&gt; 이며 지정된 형식 문자열을 가진 표준 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;logging.Formatter&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. 두 번째는 id &lt;code&gt;default&lt;/code&gt; 이며 더 긴 형식을 가지며 시간 형식을 명시 적으로 정의하며 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;logging.Formatter&lt;/code&gt; &lt;/a&gt; 이 발생 합니다. 두 개의 형식 문자열로 초기화 된 포맷터 입니다. Python 소스 형식으로 표시되는 &lt;code&gt;brief&lt;/code&gt; 및 &lt;code&gt;default&lt;/code&gt; 포맷터에는 구성 하위 사전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62cbf4b6548b919e4fdec7b561bc7cfed74c41b" translate="yes" xml:space="preserve">
          <source>The above action would run &lt;a href=&quot;re#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and print profile results like the following:</source>
          <target state="translated">위의 작업은 &lt;a href=&quot;re#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt; 실행 하고 다음과 같은 프로파일 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="cb5b571b0f55359c686525ade99c560ac76753ed" translate="yes" xml:space="preserve">
          <source>The above code print a series of &lt;code&gt;0 0&lt;/code&gt; lines, because the array contents is initialized to zeros.</source>
          <target state="translated">위의 코드 는 배열 내용이 0으로 초기화되기 때문에 일련의 &lt;code&gt;0 0&lt;/code&gt; 행을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="61e4b2d674d629816be9e5499f8d6280a73b0d50" translate="yes" xml:space="preserve">
          <source>The above constants are available on Unix and Windows.</source>
          <target state="translated">위의 상수는 Unix 및 Windows에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7cdc222bbf8c590edefed4e2c6e102f38a77a0" translate="yes" xml:space="preserve">
          <source>The above constants are extensions and not present if they are not defined by the C library.</source>
          <target state="translated">위 상수는 확장이며 C 라이브러리에 의해 정의되지 않은 경우 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2f9edc72b7c0f0352c1e5c0fd791c1214095743" translate="yes" xml:space="preserve">
          <source>The above constants are only available on Unix.</source>
          <target state="translated">위의 상수는 Unix에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26b1ca703884f216a942e677e3510315043cacee" translate="yes" xml:space="preserve">
          <source>The above constants are only available on Windows.</source>
          <target state="translated">위의 상수는 Windows에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed3f8c425e1cebe6ddfe02fdc52e00207f48926" translate="yes" xml:space="preserve">
          <source>The above example defines a read-only property; you can also define a read-write abstract property by appropriately marking one or more of the underlying methods as abstract:</source>
          <target state="translated">위의 예제는 읽기 전용 속성을 정의합니다. 하나 이상의 기본 메소드를 추상으로 적절하게 표시하여 읽기-쓰기 추상 특성을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d7f78147c227eb5aae0acc97674a01a9ebf658" translate="yes" xml:space="preserve">
          <source>The above examples show the most commonly used &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; features which are sufficient to meet many everyday testing needs. The remainder of the documentation explores the full feature set from first principles.</source>
          <target state="translated">위의 예는 가장 일반적으로 사용되는 단위 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 보여줍니다 많은 일상적인 테스트 요구 사항을 충족하기에 충분한 기능을. 이 문서의 나머지 부분에서는 첫 번째 원칙의 모든 기능을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="74957a5b993467a874f6d190c9036f6da0f9c8fd" translate="yes" xml:space="preserve">
          <source>The above implicitly extends to text files, since the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function will wrap a buffered object inside a &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt;. This includes standard streams and therefore affects the built-in function &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; as well.</source>
          <target state="translated">&lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수는 버퍼링 된 객체를 &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; 안에 래핑하기 때문에 위의 내용은 텍스트 파일로 암시 적으로 확장됩니다 . 여기에는 표준 스트림이 포함되므로 내장 함수 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 에 영향을줍니다. 에도 .</target>
        </trans-unit>
        <trans-unit id="ef1df1ceccbb344550c1134611aa680a6ca57474" translate="yes" xml:space="preserve">
          <source>The above module-level convenience functions, which delegate to the root logger, call &lt;a href=&quot;#logging.basicConfig&quot;&gt;&lt;code&gt;basicConfig()&lt;/code&gt;&lt;/a&gt; to ensure that at least one handler is available. Because of this, they should &lt;em&gt;not&lt;/em&gt; be used in threads, in versions of Python earlier than 2.7.1 and 3.2, unless at least one handler has been added to the root logger &lt;em&gt;before&lt;/em&gt; the threads are started. In earlier versions of Python, due to a thread safety shortcoming in &lt;a href=&quot;#logging.basicConfig&quot;&gt;&lt;code&gt;basicConfig()&lt;/code&gt;&lt;/a&gt;, this can (under rare circumstances) lead to handlers being added multiple times to the root logger, which can in turn lead to multiple messages for the same event.</source>
          <target state="translated">루트 로거에 위임하는 위의 모듈 수준 편의 기능은 &lt;a href=&quot;#logging.basicConfig&quot;&gt; &lt;code&gt;basicConfig()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 하나 이상의 핸들러를 사용할 수 있도록합니다. 이 때문에 스레드가 시작 &lt;em&gt;되기 전에&lt;/em&gt; 적어도 하나의 핸들러가 루트 로거에 추가되지 않은 경우, 2.7.1 및 3.2 이전 버전의 Python에서는 스레드에서 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; . 이전 버전의 Python에서는 &lt;a href=&quot;#logging.basicConfig&quot;&gt; &lt;code&gt;basicConfig()&lt;/code&gt; &lt;/a&gt; 의 스레드 안전성 부족으로 인해 드문 경우 이기는 하지만 처리기가 루트 로거에 여러 번 추가되어 동일한 이벤트에 대해 여러 메시지가 발생할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d8d492094673232d29c1078b172cdc265b56e9a" translate="yes" xml:space="preserve">
          <source>The above snippet indicates that logger named &lt;code&gt;foo.bar.baz&lt;/code&gt; should have two handlers attached to it, which are described by the handler ids &lt;code&gt;h1&lt;/code&gt; and &lt;code&gt;h2&lt;/code&gt;. The formatter for &lt;code&gt;h1&lt;/code&gt; is that described by id &lt;code&gt;brief&lt;/code&gt;, and the formatter for &lt;code&gt;h2&lt;/code&gt; is that described by id &lt;code&gt;precise&lt;/code&gt;.</source>
          <target state="translated">위의 스 니펫은 &lt;code&gt;foo.bar.baz&lt;/code&gt; 라는 로거에 두 개의 핸들러가 첨부되어 있어야하며 핸들러 ID에 의해 설명됩니다. &lt;code&gt;h1&lt;/code&gt; 및 &lt;code&gt;h2&lt;/code&gt; 있습니다. 포맷터 &lt;code&gt;h1&lt;/code&gt; ID의 설명이다 &lt;code&gt;brief&lt;/code&gt; 및 포맷터 &lt;code&gt;h2&lt;/code&gt; 그 ID가 기재되어 &lt;code&gt;precise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5afdd19ff2762aaad15324735d06fbba48a09f88" translate="yes" xml:space="preserve">
          <source>The above will add a header that looks like this:</source>
          <target state="translated">위는 다음과 같은 헤더를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f25ebcb4ed21c461f51c70e01467241e07cea134" translate="yes" xml:space="preserve">
          <source>The above will execute &lt;code&gt;somefile.py&lt;/code&gt; and generate annotated listings of all Python modules imported during the execution into the current directory.</source>
          <target state="translated">위는 &lt;code&gt;somefile.py&lt;/code&gt; 를 실행 하고 실행 중에 현재 디렉토리로 가져온 모든 Python 모듈의 주석이 달린 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ce5bd96b918301cb95de685eaccadac99a16c5c7" translate="yes" xml:space="preserve">
          <source>The abstract base class defining the interface of finder objects on &lt;a href=&quot;#sys.meta_path&quot;&gt;&lt;code&gt;meta_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sys.meta_path&quot;&gt; &lt;code&gt;meta_path&lt;/code&gt; &lt;/a&gt; 에 파인더 객체의 인터페이스를 정의하는 추상 기본 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="cd5f23b2d3c373fb28eef9fa8f1f6d899e6031e2" translate="yes" xml:space="preserve">
          <source>The abstract base class for all I/O classes, acting on streams of bytes. There is no public constructor.</source>
          <target state="translated">바이트 스트림에 작용하는 모든 I / O 클래스의 추상 기본 클래스입니다. 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c659b88cd8236075a43a087f99d1f6f299c2eadd" translate="yes" xml:space="preserve">
          <source>The abstract base classes also provide default implementations of some methods in order to help implementation of concrete stream classes. For example, &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; provides unoptimized implementations of &lt;code&gt;readinto()&lt;/code&gt; and &lt;a href=&quot;#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추상 기본 클래스는 또한 구체적인 스트림 클래스의 구현을 돕기 위해 일부 메소드의 기본 구현을 제공합니다. 예를 들어, &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; 는 최적화되지 않은 &lt;code&gt;readinto()&lt;/code&gt; 및 &lt;a href=&quot;#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt; 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1f9fe10078c0b0af1e6a6803c79431e9d237a736" translate="yes" xml:space="preserve">
          <source>The abstract base classes making up the numeric tower.</source>
          <target state="translated">숫자 탑을 구성하는 추상 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="5433534b54436760d1f4d8f1c5502666c388c4e5" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder&quot;&gt;&lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt;&lt;/a&gt; defines the interface expected of finders by Python&amp;rsquo;s import system. &lt;code&gt;importlib.metadata&lt;/code&gt; extends this protocol by looking for an optional &lt;code&gt;find_distributions&lt;/code&gt; callable on the finders from &lt;code&gt;sys.meta_path&lt;/code&gt; and presents this extended interface as the &lt;code&gt;DistributionFinder&lt;/code&gt; abstract base class, which defines this abstract method:</source>
          <target state="translated">추상 클래스 &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder&quot;&gt; &lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt; &lt;/a&gt; 는 Python의 가져 오기 시스템에서 파인더가 예상하는 인터페이스를 정의합니다. &lt;code&gt;importlib.metadata&lt;/code&gt; 는 선택적 &lt;code&gt;find_distributions&lt;/code&gt; 를 찾아이 프로토콜을 확장합니다. 는 &lt;code&gt;sys.meta_path&lt;/code&gt; 의 파인더에서 호출 확장하고이 확장 된 인터페이스를 &lt;code&gt;DistributionFinder&lt;/code&gt; 추상 기본 클래스로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="997702cd66ff1ee75f7fe9b2315881a481a29682" translate="yes" xml:space="preserve">
          <source>The abstract event loop policy base class is defined as follows:</source>
          <target state="translated">추상 이벤트 루프 정책 기본 클래스는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b822e2129fda13f824b88f911238744a0942dfa9" translate="yes" xml:space="preserve">
          <source>The abstract grammar is currently defined as follows:</source>
          <target state="translated">추상 문법은 현재 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="22685ed5927596fd28d7ba1c6153d574f910d052" translate="yes" xml:space="preserve">
          <source>The abstract method returns an iterable of no items.</source>
          <target state="translated">abstract 메소드는 항목이없는 iterable을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2d8da79b65eb77d7ab2dbbc1e796e48b7e1aa054" translate="yes" xml:space="preserve">
          <source>The abstract methods defined by this class are to add optional bytecode file support. Not implementing these optional methods (or causing them to raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;) causes the loader to only work with source code. Implementing the methods allows the loader to work with source &lt;em&gt;and&lt;/em&gt; bytecode files; it does not allow for &lt;em&gt;sourceless&lt;/em&gt; loading where only bytecode is provided. Bytecode files are an optimization to speed up loading by removing the parsing step of Python&amp;rsquo;s compiler, and so no bytecode-specific API is exposed.</source>
          <target state="translated">이 클래스에 의해 정의 된 추상 메소드는 선택적 바이트 코드 파일 지원을 추가하는 것입니다. 이 선택적 메소드를 구현하지 않으면 (또는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt; 발생) 로더가 소스 코드로만 작동합니다. 메소드를 구현하면 로더가 소스 &lt;em&gt;및&lt;/em&gt; 바이트 코드 파일 로 작업 할 수 있습니다. 그것은 &lt;em&gt;소스리스를&lt;/em&gt; 허용하지 않습니다&lt;em&gt;&lt;/em&gt;바이트 코드 만 제공되는 로드는 . 바이트 코드 파일은 Python 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기위한 최적화이므로 바이트 코드 별 API가 노출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bac918bfaa9fbf1f60536a1f9a285735540a9661" translate="yes" xml:space="preserve">
          <source>The actual messages are inspected to determine which labels exist in the mailbox rather than consulting the list of labels in the Babyl options section, but the Babyl section is updated whenever the mailbox is modified.</source>
          <target state="translated">Babyl 옵션 섹션의 레이블 목록을 참조하지 않고 사서함에 존재하는 레이블을 확인하기 위해 실제 메시지를 검사하지만 사서함을 수정할 때마다 Babyl 섹션이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ec59d57f13dbc7f6e8f220cf7108a96c7845d01c" translate="yes" xml:space="preserve">
          <source>The actual representation of values is determined by the machine architecture (strictly speaking, by the C implementation). The actual size can be accessed through the &lt;code&gt;itemsize&lt;/code&gt; attribute.</source>
          <target state="translated">실제 값 표현은 머신 아키텍처에 의해 결정됩니다 (엄격히 말하면 C 구현에 의해 결정됨). 실제 크기는 &lt;code&gt;itemsize&lt;/code&gt; 를 통해 액세스 할 수 있습니다 속성을 .</target>
        </trans-unit>
        <trans-unit id="8bbd67fedc62d6744e578e383acd313d41f0348f" translate="yes" xml:space="preserve">
          <source>The add_argument() method</source>
          <target state="translated">add_argument () 메소드</target>
        </trans-unit>
        <trans-unit id="6162253165783060c2db0f1fb8a4141706505e29" translate="yes" xml:space="preserve">
          <source>The addition of new required attributes must go through the normal PEP process. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0421&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 421&lt;/strong&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">새로운 필수 속성을 추가하려면 일반 PEP 프로세스를 거쳐야합니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0421&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 421&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55a0169a9941fb11dafda49bd2ffe19ca9ee69cc" translate="yes" xml:space="preserve">
          <source>The address (&lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt;&lt;code&gt;IPv4Address&lt;/code&gt;&lt;/a&gt;) without network information.</source>
          <target state="translated">네트워크 정보가없는 주소 ( &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt; &lt;code&gt;IPv4Address&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="341c8834b822a019f9534dcafa2d84b7b101ecd9" translate="yes" xml:space="preserve">
          <source>The address format required by a particular socket object is automatically selected based on the address family specified when the socket object was created. Socket addresses are represented as follows:</source>
          <target state="translated">특정 소켓 객체에 필요한 주소 형식은 소켓 객체가 생성 될 때 지정된 주소 패밀리를 기반으로 자동 선택됩니다. 소켓 주소는 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4cb6e2569f1a198791a025941f4508602c56ffb5" translate="yes" xml:space="preserve">
          <source>The address from which the last accepted connection came. If this is unavailable then it is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">마지막으로 수락 한 연결이 발생한 주소입니다. 이것이 사용 불가능하면 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9eb11849699377b31e52eceb4abebe16ec4ad447" translate="yes" xml:space="preserve">
          <source>The address of an &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; socket bound to a file system node is represented as a string, using the file system encoding and the &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt;). An address in Linux&amp;rsquo;s abstract namespace is returned as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; with an initial null byte; note that sockets in this namespace can communicate with normal file system sockets, so programs intended to run on Linux may need to deal with both types of address. A string or bytes-like object can be used for either type of address when passing it as an argument.</source>
          <target state="translated">파일 시스템 노드에 바인드 된 &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 소켓 의 주소는 파일 시스템 인코딩 및 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 핸들러를 사용하여 문자열로 표시됩니다 ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt; 참조 ). Linux의 추상 네임 스페이스에있는 주소는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 로 반환됩니다. 는 초기 널 바이트를 가진 로 ; 이 네임 스페이스의 소켓은 일반 파일 시스템 소켓과 통신 할 수 있으므로 Linux에서 실행되는 프로그램은 두 가지 유형의 주소를 모두 처리해야합니다. 문자열 또는 바이트와 유사한 객체를 인수로 전달할 때 주소 유형에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77c6e2e4aa0afd9f0da731748d6868e43cbbddde" translate="yes" xml:space="preserve">
          <source>The address on which the server is listening. The format of addresses varies depending on the protocol family; see the documentation for the &lt;a href=&quot;socket#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module for details. For Internet protocols, this is a tuple containing a string giving the address, and an integer port number: &lt;code&gt;('127.0.0.1', 80)&lt;/code&gt;, for example.</source>
          <target state="translated">서버가 청취중인 주소입니다. 주소 형식은 프로토콜 제품군에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;socket#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조 하십시오. 인터넷 프로토콜의 경우, 이는 주소를 제공하는 문자열과 정수 포트 번호 &lt;code&gt;('127.0.0.1', 80)&lt;/code&gt; 포함하는 튜플 입니다.</target>
        </trans-unit>
        <trans-unit id="caadcf5c749441fdfeb412491158e95d616c65f2" translate="yes" xml:space="preserve">
          <source>The address used by the manager.</source>
          <target state="translated">관리자가 사용하는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="48fc7614dc7d8c1c17cef309edaa19277c62a924" translate="yes" xml:space="preserve">
          <source>The address which is being used by the Listener object.</source>
          <target state="translated">리스너 오브젝트가 사용중인 주소입니다.</target>
        </trans-unit>
        <trans-unit id="0a2d1ad99859dd0fa1ab93fa74d153ed148b3f11" translate="yes" xml:space="preserve">
          <source>The advanced API revolves around two container classes, which are used to store the interactive examples extracted from doctest cases:</source>
          <target state="translated">고급 API는 doctest 사례에서 추출한 대화식 예제를 저장하는 데 사용되는 두 개의 컨테이너 클래스를 중심으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="0fc8b7f68557d45d430eb3ca143cc623a95cbbb8" translate="yes" xml:space="preserve">
          <source>The advantage of the &lt;a href=&quot;#range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; type over a regular &lt;a href=&quot;#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; is that a &lt;a href=&quot;#range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;step&lt;/code&gt; values, calculating individual items and subranges as needed).</source>
          <target state="translated">의 장점 &lt;a href=&quot;#range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 일반 위에 타입 &lt;a href=&quot;#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 이다 &lt;a href=&quot;#range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 에만 점포로 객체가 항상 (더가 나타내는 범위의 크기 문제, 동일한 메모리 (소) 시간이 걸릴 것 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 및 &lt;code&gt;step&lt;/code&gt; 값을 필요에 따라 개별 항목 및 하위 범위를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9d8f4a6fe7a31398136778071ccf8af380a56654" translate="yes" xml:space="preserve">
          <source>The advantage over the standard traceback is that source lines in the compiled template will be displayed. The optional &lt;em&gt;file&lt;/em&gt; argument directs where the traceback is sent; it defaults to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 역 추적에 비해 장점은 컴파일 된 템플릿의 소스 행이 표시된다는 것입니다. 선택적 &lt;em&gt;파일&lt;/em&gt; 인수는 트레이스 백이 전송되는 위치를 지시합니다. 기본값은 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="389d9047d4c01bea441e0465f8bdadf31d1765e6" translate="yes" xml:space="preserve">
          <source>The aggregate class must implement a &lt;code&gt;step&lt;/code&gt; method, which accepts the number of parameters &lt;em&gt;num_params&lt;/em&gt; (if &lt;em&gt;num_params&lt;/em&gt; is -1, the function may take any number of arguments), and a &lt;code&gt;finalize&lt;/code&gt; method which will return the final result of the aggregate.</source>
          <target state="translated">집계 클래스는 &lt;em&gt;num_params&lt;/em&gt; 매개 변수의 수 ( &lt;em&gt;num_params&lt;/em&gt; 가 -1 인 경우 함수가 여러 인수 를 사용할 수 있음)를 허용 하는 &lt;code&gt;step&lt;/code&gt; 메소드 와 집계의 최종 결과를 리턴 하는 &lt;code&gt;finalize&lt;/code&gt; 메소드를 구현해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c81a91b366c2ca5f6e3514aebee395b76c6e737f" translate="yes" xml:space="preserve">
          <source>The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result:</source>
          <target state="translated">이 알고리즘은 단어의 간단한 언어 독립적 정의를 연속 문자 그룹으로 사용합니다. 이 정의는 많은 상황에서 작동하지만 수축과 소유주의 아포스트로피는 단어 경계를 형성하며 이는 원하는 결과가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea76dcb40c4b9fd7e68dc2ee0f71417668bf322" translate="yes" xml:space="preserve">
          <source>The algorithm&amp;rsquo;s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit.</source>
          <target state="translated">알고리즘의 정확도는 IEEE-754 산술 보증과 반올림 모드가 반도 인 일반적인 경우에 따라 다릅니다. 일부 비 Windows 빌드에서 기본 C 라이브러리는 확장 된 정밀도 추가를 사용하며 중간 합계를 두 배 반올림하여 최소 중요 비트에서 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5606a01152f52f4dc81a70ca0b1f2ca9568376be" translate="yes" xml:space="preserve">
          <source>The alternate form causes a leading &lt;code&gt;'0x'&lt;/code&gt; or &lt;code&gt;'0X'&lt;/code&gt; (depending on whether the &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'X'&lt;/code&gt; format was used) to be inserted before the first digit.</source>
          <target state="translated">대체 형식은 첫 번째 숫자 앞에 선행 &lt;code&gt;'0x'&lt;/code&gt; 또는 &lt;code&gt;'0X'&lt;/code&gt; ( &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'X'&lt;/code&gt; 형식 사용 여부에 따라 다름 )가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="d42a4d8ad1a3383ee5320a3a16eb31b75813d0d6" translate="yes" xml:space="preserve">
          <source>The alternate form causes a leading octal specifier (&lt;code&gt;'0o'&lt;/code&gt;) to be inserted before the first digit.</source>
          <target state="translated">대체 형식은 선행 8 진 지정자 ( &lt;code&gt;'0o'&lt;/code&gt; )가 첫 번째 숫자 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="14d9acf2bea379bd058e7c06b2fff1c83daa4669" translate="yes" xml:space="preserve">
          <source>The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be.</source>
          <target state="translated">대체 형식은 결과에 항상 소수점을 포함하며 후행 0은 다른 방식으로 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a98cf5f39210ac846eda4b14e995b3862902ef83" translate="yes" xml:space="preserve">
          <source>The alternate form causes the result to always contain a decimal point, even if no digits follow it.</source>
          <target state="translated">대체 형식은 뒤에 숫자가 없더라도 결과에 항상 소수점이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2b2e794a1178ef7414daa6fc5f835215e754345d" translate="yes" xml:space="preserve">
          <source>The ancient V7 format. This is the first tar format from Unix Seventh Edition, storing only regular files and directories. Names must not be longer than 100 characters, there is no user/group name information. Some archives have miscalculated header checksums in case of fields with non-ASCII characters.</source>
          <target state="translated">고대 V7 형식. 이것은 일반 파일과 디렉토리 만 저장하는 Unix Seventh Edition의 첫 번째 tar 형식입니다. 이름은 100 자 이하 여야합니다. 사용자 / 그룹 이름 정보는 없습니다. ASCII가 아닌 문자가있는 필드의 경우 일부 아카이브에서 헤더 체크섬이 잘못 계산되었습니다.</target>
        </trans-unit>
        <trans-unit id="10c51d8f800517ca58ba2468a6c02fd8a7104b3b" translate="yes" xml:space="preserve">
          <source>The annotation for the parameter. If the parameter has no annotation, this attribute is set to &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt;&lt;code&gt;Parameter.empty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수의 주석입니다. 매개 변수에 주석이없는 경우이 속성은 &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt; &lt;code&gt;Parameter.empty&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="33bada18ff53849b6ee3f7316070d7ee69b27b87" translate="yes" xml:space="preserve">
          <source>The appropriate version number: &lt;code&gt;4&lt;/code&gt; for IPv4, &lt;code&gt;6&lt;/code&gt; for IPv6.</source>
          <target state="translated">적절한 버전 번호 : IPv4의 경우 &lt;code&gt;4&lt;/code&gt; , IPv6의 경우 &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e8292e76576f5b761b335d8aabbcc591cdfb09e" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;bytes&lt;/em&gt; must either be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an iterable producing bytes.</source>
          <target state="translated">인수 &lt;em&gt;bytes&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 이거나 반복 가능한 생성 바이트 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8890dbba084fa181e02072ab15efd96356246f1" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;file&lt;/em&gt; must have three methods, a read() method that takes an integer argument, a readinto() method that takes a buffer argument and a readline() method that requires no arguments, as in the &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt; interface. Thus &lt;em&gt;file&lt;/em&gt; can be an on-disk file opened for binary reading, an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; object, or any other custom object that meets this interface.</source>
          <target state="translated">인수 &lt;em&gt;파일&lt;/em&gt; 에는 정수 인수를 사용하는 read () 메소드, 버퍼 인수를 사용하는 readinto () 메소드 및 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 인터페이스 에서와 같이 인수가 필요없는 readline () 메소드의 세 가지 메소드가 있어야합니다 . 따라서 &lt;em&gt;파일&lt;/em&gt; 은 이진 읽기, &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 개체 또는이 인터페이스를 충족하는 다른 사용자 지정 개체를 위해 열린 디스크상의 &lt;em&gt;파일 일&lt;/em&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41dee21e7ee0cafe46125a9e6fc36855c2f04d0a" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;optimize&lt;/em&gt; specifies the optimization level of the compiler; the default value of &lt;code&gt;-1&lt;/code&gt; selects the optimization level of the interpreter as given by &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; options. Explicit levels are &lt;code&gt;0&lt;/code&gt; (no optimization; &lt;code&gt;__debug__&lt;/code&gt; is true), &lt;code&gt;1&lt;/code&gt; (asserts are removed, &lt;code&gt;__debug__&lt;/code&gt; is false) or &lt;code&gt;2&lt;/code&gt; (docstrings are removed too).</source>
          <target state="translated">&lt;em&gt;optimize&lt;/em&gt; 인수 는 컴파일러의 최적화 수준을 지정합니다. 기본값 &lt;code&gt;-1&lt;/code&gt; 은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 옵션에 의해 제공된대로 인터프리터의 최적화 레벨을 선택합니다 . 명시 적 레벨은 &lt;code&gt;0&lt;/code&gt; (최적화 없음; &lt;code&gt;__debug__&lt;/code&gt; 이 참), &lt;code&gt;1&lt;/code&gt; (어설 션이 제거됨, &lt;code&gt;__debug__&lt;/code&gt; 가 거짓 임) 또는 &lt;code&gt;2&lt;/code&gt; (docstring도 제거됨)입니다.</target>
        </trans-unit>
        <trans-unit id="3deabf3aa9abdc670f9e79ed2b9d15db402ea8d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;workers&lt;/em&gt; specifies how many workers are used to compile files in parallel. The default is to not use multiple workers. If the platform can&amp;rsquo;t use multiple workers and &lt;em&gt;workers&lt;/em&gt; argument is given, then sequential compilation will be used as a fallback. If &lt;em&gt;workers&lt;/em&gt; is 0, the number of cores in the system is used. If &lt;em&gt;workers&lt;/em&gt; is lower than &lt;code&gt;0&lt;/code&gt;, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;em&gt;worker&lt;/em&gt; 인수 는 파일을 병렬로 컴파일하는 데 사용되는 &lt;em&gt;작업자 수를&lt;/em&gt; 지정합니다. 기본값은 여러 작업자를 사용하지 않는 것입니다. 플랫폼이 여러 워커를 사용할 수없고 &lt;em&gt;워커&lt;/em&gt; 인수가 제공되면 순차 컴파일이 폴백으로 사용됩니다. 경우 &lt;em&gt;근로자는&lt;/em&gt; 0, 시스템의 코어 수를 사용한다. 경우 &lt;em&gt;근로자&lt;/em&gt; 보다 낮은 &lt;code&gt;0&lt;/code&gt; 하는 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be43a16008bbf7f5842dd3fda9c5c730dc968fa1" translate="yes" xml:space="preserve">
          <source>The argument is either an exception object or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The latter means a regular EOF is received, or the connection was aborted or closed by this side of the connection.</source>
          <target state="translated">인수는 예외 객체이거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 입니다. 후자는 일반적인 EOF가 수신되었거나 연결의이 쪽에서 연결이 중단 또는 종료되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6a211995914e53c0ffa8f7f501f1d50e2819dbbf" translate="yes" xml:space="preserve">
          <source>The arguments &lt;em&gt;server_side&lt;/em&gt;, &lt;em&gt;do_handshake_on_connect&lt;/em&gt;, and &lt;em&gt;suppress_ragged_eofs&lt;/em&gt; have the same meaning as &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;server_side&lt;/em&gt; , &lt;em&gt;do_handshake_on_connect&lt;/em&gt; 및 &lt;em&gt;suppress_ragged_eofs&lt;/em&gt; 인수 는 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="9c66f3eebc3d176e9c1b552e8a8c2895de8a2a96" translate="yes" xml:space="preserve">
          <source>The arguments are a string and optional globals and locals. If provided, &lt;em&gt;globals&lt;/em&gt; must be a dictionary. If provided, &lt;em&gt;locals&lt;/em&gt; can be any mapping object.</source>
          <target state="translated">인수는 문자열이며 선택적 전역 및 지역입니다. 제공되는 경우 &lt;em&gt;전역&lt;/em&gt; 은 사전이어야합니다. 제공되는 경우 &lt;em&gt;로컬&lt;/em&gt; 은 모든 매핑 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c69cfb296a29db62964592dbb716832142521412" translate="yes" xml:space="preserve">
          <source>The arguments are an object and a string. The result is &lt;code&gt;True&lt;/code&gt; if the string is the name of one of the object&amp;rsquo;s attributes, &lt;code&gt;False&lt;/code&gt; if not. (This is implemented by calling &lt;code&gt;getattr(object, name)&lt;/code&gt; and seeing whether it raises an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; or not.)</source>
          <target state="translated">인수는 객체와 문자열입니다. 문자열이 객체 속성 중 하나의 이름이면 결과는 &lt;code&gt;True&lt;/code&gt; 이고, &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다. ( &lt;code&gt;getattr(object, name)&lt;/code&gt; 을 호출 하여 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 가 발생하는지 여부를 확인하여 구현됩니다 .)</target>
        </trans-unit>
        <trans-unit id="be56149bda6c7546999f067085edf5b3a937c31c" translate="yes" xml:space="preserve">
          <source>The arguments are the components that make up a class definition header: the class name, the base classes (in order) and the keyword arguments (such as &lt;code&gt;metaclass&lt;/code&gt;).</source>
          <target state="translated">인수는 클래스 정의 헤더를 구성하는 구성 요소입니다 (클래스 이름, 기본 클래스 (순서대로) 및 키워드 인수 (예 : &lt;code&gt;metaclass&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="e7c93246599d96c035a94a1928bc7c60c28e3fdf" translate="yes" xml:space="preserve">
          <source>The arguments for the logging message.</source>
          <target state="translated">로깅 메시지의 인수</target>
        </trans-unit>
        <trans-unit id="fa6396e70f630f892434a48120296055f84dd5e2" translate="yes" xml:space="preserve">
          <source>The arguments for this method are the same as those for the &lt;a href=&quot;#difflib.HtmlDiff.make_file&quot;&gt;&lt;code&gt;make_file()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드의 인수는 &lt;a href=&quot;#difflib.HtmlDiff.make_file&quot;&gt; &lt;code&gt;make_file()&lt;/code&gt; &lt;/a&gt; 메소드 의 인수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="fed5e86f10a7fbd166030f1e196e3f269c1fcfc8" translate="yes" xml:space="preserve">
          <source>The arguments must be types and there must be at least one.</source>
          <target state="translated">인수는 유형이어야하고 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f69c3cdc02ca8f80c2baba13a605a2fbc228eaa5" translate="yes" xml:space="preserve">
          <source>The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For &lt;a href=&quot;#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, &lt;code&gt;10**2&lt;/code&gt; returns &lt;code&gt;100&lt;/code&gt;, but &lt;code&gt;10**-2&lt;/code&gt; returns &lt;code&gt;0.01&lt;/code&gt;.</source>
          <target state="translated">인수는 숫자 유형이어야합니다. 피연산자 유형이 혼합 된 경우 이진 산술 연산자에 대한 강제 규칙이 적용됩니다. 들면 &lt;a href=&quot;#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 피연산자 결과 (강제 한 후) 피연산자 번째 인자가 음수가 아니면 같은 형태를 가진다; 이 경우 모든 인수가 float로 변환되고 float 결과가 전달됩니다. 예를 들어, &lt;code&gt;10**2&lt;/code&gt; 는 &lt;code&gt;100&lt;/code&gt; 을 반환 하지만 &lt;code&gt;10**-2&lt;/code&gt; 는 &lt;code&gt;0.01&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ae91bd9ff1ecbb16b6d067052bf6873482f52192" translate="yes" xml:space="preserve">
          <source>The arguments provided (if any) can be used to limit the list down to the significant entries. Initially, the list is taken to be the complete set of profiled functions. Each restriction is either an integer (to select a count of lines), or a decimal fraction between 0.0 and 1.0 inclusive (to select a percentage of lines), or a string that will interpreted as a regular expression (to pattern match the standard name that is printed). If several restrictions are provided, then they are applied sequentially. For example:</source>
          <target state="translated">제공된 인수 (있는 경우)를 사용하여 목록을 중요한 항목으로 제한 할 수 있습니다. 처음에는 목록이 전체 프로파일 링 된 기능 세트로 간주됩니다. 각 제한은 정수 (줄 수 선택) 또는 0.0에서 1.0 사이의 소수 (줄 백분율 선택) 또는 정규식으로 해석되는 문자열 (표준 이름과 패턴 일치)입니다. 인쇄됩니다). 여러 제한 사항이 제공되면 순차적으로 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87f25b82b9642ea89296265907e6ccc346f4cbea" translate="yes" xml:space="preserve">
          <source>The arguments shown above are merely some common ones. The full function signature is largely the same as that of &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; - most arguments are passed directly through to that interface. However, explicitly passing &lt;code&gt;input=None&lt;/code&gt; to inherit the parent&amp;rsquo;s standard input file handle is not supported.</source>
          <target state="translated">위에 표시된 주장은 단지 몇 가지 일반적인 주장입니다. 전체 함수 시그니처는 &lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 의 시그니처와 거의 동일합니다. 대부분의 인수는 해당 인터페이스로 직접 전달됩니다. 그러나 명시 적으로 전달 &lt;code&gt;input=None&lt;/code&gt; 부모의 표준 입력 파일 핸들을 상속하기 위해 input = None 을 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2043e37b5d3a7c056dc2f3ac3ded2b83680185c6" translate="yes" xml:space="preserve">
          <source>The arguments shown above are merely some common ones. The full function signature is the same as that of the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor - this function passes all supplied arguments other than &lt;em&gt;timeout&lt;/em&gt; directly through to that interface.</source>
          <target state="translated">위에 표시된 주장은 단지 몇 가지 일반적인 주장입니다. 전체 기능 서명은 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 의 서명과 동일합니다 생성자 이 함수는 &lt;em&gt;제한 시간&lt;/em&gt; 이외의 모든 제공된 인수 를 해당 인터페이스로 직접 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f78dbd2fcda8d7db784dd89d094ca5c7188a12e9" translate="yes" xml:space="preserve">
          <source>The arguments shown above are merely the most common ones, described below in &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt; (hence the use of keyword-only notation in the abbreviated signature). The full function signature is largely the same as that of the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor - most of the arguments to this function are passed through to that interface. (&lt;em&gt;timeout&lt;/em&gt;, &lt;em&gt;input&lt;/em&gt;, &lt;em&gt;check&lt;/em&gt;, and &lt;em&gt;capture_output&lt;/em&gt; are not.)</source>
          <target state="translated">위에 표시된 인수는 아래에서 &lt;a href=&quot;#frequently-used-arguments&quot;&gt;자주 사용되는 인수&lt;/a&gt; (따라서 약식 서명에 키워드 전용 표기법 사용)에 설명 된 가장 일반적인 인수 입니다. 전체 함수 시그니처는 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 생성자 의 시그니처와 거의 동일 합니다.이 함수에 대한 대부분의 인수는 해당 인터페이스로 전달됩니다. ( &lt;em&gt;타임 아웃&lt;/em&gt; , &lt;em&gt;입력&lt;/em&gt; , &lt;em&gt;확인&lt;/em&gt; 및&lt;em&gt; capture_output&lt;/em&gt; 이 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="a8d3dbfa6a2a64fda3f1f33232ef56b7a73086d5" translate="yes" xml:space="preserve">
          <source>The arguments to the range constructor must be integers (either built-in &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; or any object that implements the &lt;code&gt;__index__&lt;/code&gt; special method). If the &lt;em&gt;step&lt;/em&gt; argument is omitted, it defaults to &lt;code&gt;1&lt;/code&gt;. If the &lt;em&gt;start&lt;/em&gt; argument is omitted, it defaults to &lt;code&gt;0&lt;/code&gt;. If &lt;em&gt;step&lt;/em&gt; is zero, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">범위 생성자에 대한 인수는 정수 여야합니다 (내장 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;__index__&lt;/code&gt; 특수 메소드 를 구현하는 오브젝트 ). 는 IF &lt;em&gt;단계&lt;/em&gt; 인수에 기본값을 생략 &lt;code&gt;1&lt;/code&gt; . 는 IF &lt;em&gt;시작&lt;/em&gt; 인수에 기본값을 생략 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;em&gt;단계는&lt;/em&gt; 제로의 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="392a22c741f2ff789b1aa5cfae6c8530e0bcedb5" translate="yes" xml:space="preserve">
          <source>The arguments used to launch the process. This may be a list or a string.</source>
          <target state="translated">프로세스를 시작하는 데 사용되는 인수 이것은 목록 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eaf471383801c20f082c922e184753ba6eeb675" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the data divided by the number of data points. It is commonly called &amp;ldquo;the average&amp;rdquo;, although it is only one of many different mathematical averages. It is a measure of the central location of the data.</source>
          <target state="translated">산술 평균은 데이터의 합을 데이터 포인트 수로 나눈 값입니다. 많은 수학적 평균 중 하나 일 뿐이지 만 일반적으로 &quot;평균&quot;이라고합니다. 데이터의 중앙 위치를 측정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a4efce9426389d16ea55fb24f2a2130bb207613" translate="yes" xml:space="preserve">
          <source>The assert passes if the mock has &lt;em&gt;ever&lt;/em&gt; been called, unlike &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt;&lt;code&gt;assert_called_with()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt; that only pass if the call is the most recent one, and in the case of &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt; it must also be the only call.</source>
          <target state="translated">모의를 한 경우 어설 통과 &lt;em&gt;이제까지&lt;/em&gt; 와는 달리 호출 된 &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt; &lt;code&gt;assert_called_with()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt; 만 호출이 가장 최근 인 경우 통과, 그리고 경우에 있음을&lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt; 그것은 또한 유일한 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="55baf18423476bc2f5cb22bc735bf84833a2ded6" translate="yes" xml:space="preserve">
          <source>The associated child window will be displayed, and the previously-selected window (if different) is unmapped. If &lt;em&gt;tab_id&lt;/em&gt; is omitted, returns the widget name of the currently selected pane.</source>
          <target state="translated">연결된 자식 창이 표시되고 이전에 선택한 창이 다른 경우 매핑이 해제됩니다. 만약&lt;em&gt; tab_id가&lt;/em&gt; 생략, 현재 선택 창 위젯의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ebc6759ec468be9cd5ca8641b23467e5c0dcc16" translate="yes" xml:space="preserve">
          <source>The asynchronous execution can be performed with threads, using &lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, or separate processes, using &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt;. Both implement the same interface, which is defined by the abstract &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 를&lt;/a&gt; 사용하는 스레드 또는 &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; 를&lt;/a&gt; 사용하는 별도의 프로세스를 사용하여 비동기 실행을 수행 할 수 있습니다 . 둘 다 추상으로 정의 된 동일한 인터페이스를 구현합니다.&lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 클래스에.</target>
        </trans-unit>
        <trans-unit id="3ccad3e454a2b6bbe8bd6d9030a1c9f1ee44f789" translate="yes" xml:space="preserve">
          <source>The asynchronous input buffer size (default &lt;code&gt;4096&lt;/code&gt;).</source>
          <target state="translated">비동기 입력 버퍼 크기 (기본값 &lt;code&gt;4096&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="648cf457811b8fb2322a6e0f67989021d19d68db" translate="yes" xml:space="preserve">
          <source>The asynchronous output buffer size (default &lt;code&gt;4096&lt;/code&gt;).</source>
          <target state="translated">비동기 출력 버퍼 크기 (기본값 &lt;code&gt;4096&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1b3cd46b2d23224528d0f92919781b3cb4fb638a" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;httponly&lt;/code&gt; specifies that the cookie is only transferred in HTTP requests, and is not accessible through JavaScript. This is intended to mitigate some forms of cross-site scripting.</source>
          <target state="translated">&lt;code&gt;httponly&lt;/code&gt; 속성 은 쿠키가 HTTP 요청에서만 전송되고 JavaScript를 통해 액세스 할 수 지정합니다. 이는 일부 형태의 크로스 사이트 스크립팅을 완화하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8edf79b23d57e5bcd86427cee16457915983e577" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;samesite&lt;/code&gt; specifies that the browser is not allowed to send the cookie along with cross-site requests. This helps to mitigate CSRF attacks. Valid values for this attribute are &amp;ldquo;Strict&amp;rdquo; and &amp;ldquo;Lax&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;samesite&lt;/code&gt; 속성 은 브라우저가 사이트 간 요청과 함께 쿠키를 보낼 수 지정합니다. 이것은 CSRF 공격을 완화하는 데 도움이됩니다. 이 속성의 유효한 값은&amp;ldquo;Strict&amp;rdquo;및&amp;ldquo;Lax&amp;rdquo;입니다.</target>
        </trans-unit>
        <trans-unit id="f6ce7ef8307bed2a756ba73ac5ba362e481ae023" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;sys.float_info.dig&lt;/code&gt; needs further explanation. If &lt;code&gt;s&lt;/code&gt; is any string representing a decimal number with at most &lt;code&gt;sys.float_info.dig&lt;/code&gt; significant digits, then converting &lt;code&gt;s&lt;/code&gt; to a float and back again will recover a string representing the same decimal value:</source>
          <target state="translated">&lt;code&gt;sys.float_info.dig&lt;/code&gt; 속성에 대한 추가 설명이 필요합니다. 경우 &lt;code&gt;s&lt;/code&gt; 대부분에서와 진수 나타내는 문자열입니다 &lt;code&gt;sys.float_info.dig&lt;/code&gt; , 다음 변환 유효 숫자 &lt;code&gt;s&lt;/code&gt; 같은 진수 값을 나타내는 문자열을 회복 다시 float로하고 :</target>
        </trans-unit>
        <trans-unit id="80c36253735c07d920791417fa7a7a1a529dab82" translate="yes" xml:space="preserve">
          <source>The attribute name. In a namespace-using document it may include a colon.</source>
          <target state="translated">속성 이름 네임 스페이스를 사용하는 문서에는 콜론이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c7c2faa30f7bd05bfb9c7041417be557d23784" translate="yes" xml:space="preserve">
          <source>The attribute of every character in the window is changed to the new background attribute.</source>
          <target state="translated">창의 모든 문자 속성이 새 배경 속성으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="07392340727348ac2f4a66a50ef8232a5df7f9aa" translate="yes" xml:space="preserve">
          <source>The attributes &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt;&lt;code&gt;maximum_version&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.SSLContext.minimum_version&quot;&gt;&lt;code&gt;minimum_version&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt;&lt;code&gt;SSLContext.options&lt;/code&gt;&lt;/a&gt; all affect the supported SSL and TLS versions of the context. The implementation does not prevent invalid combination. For example a context with &lt;a href=&quot;#ssl.OP_NO_TLSv1_2&quot;&gt;&lt;code&gt;OP_NO_TLSv1_2&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt;&lt;code&gt;options&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt;&lt;code&gt;maximum_version&lt;/code&gt;&lt;/a&gt; set to &lt;a href=&quot;#ssl.TLSVersion.TLSv1_2&quot;&gt;&lt;code&gt;TLSVersion.TLSv1_2&lt;/code&gt;&lt;/a&gt; will not be able to establish a TLS 1.2 connection.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt; &lt;code&gt;maximum_version&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.SSLContext.minimum_version&quot;&gt; &lt;code&gt;minimum_version&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt; &lt;code&gt;SSLContext.options&lt;/code&gt; &lt;/a&gt; 속성은 모두 지원되는 컨텍스트의 SSL 및 TLS 버전에 영향을 줍니다 . 구현은 잘못된 조합을 방지하지 않습니다. 예를 들어 &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt; &lt;code&gt;options&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#ssl.OP_NO_TLSv1_2&quot;&gt; &lt;code&gt;OP_NO_TLSv1_2&lt;/code&gt; &lt;/a&gt; 가 있고 &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt; &lt;code&gt;maximum_version&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#ssl.TLSVersion.TLSv1_2&quot;&gt; &lt;code&gt;TLSVersion.TLSv1_2&lt;/code&gt; 로&lt;/a&gt; 설정된 컨텍스트 에서 TLS 1.2 연결을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d2a6e5c3540f613e4a515b7af1ff266b0046448" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;Color.RED&lt;/code&gt;, &lt;code&gt;Color.GREEN&lt;/code&gt;, etc., are &lt;em&gt;enumeration members&lt;/em&gt; (or &lt;em&gt;enum members&lt;/em&gt;) and are functionally constants.</source>
          <target state="translated">&lt;code&gt;Color.RED&lt;/code&gt; , &lt;code&gt;Color.GREEN&lt;/code&gt; 등 의 속성 은 &lt;em&gt;열거 형 멤버&lt;/em&gt; (또는 &lt;em&gt;열거 형 멤버)입니다.&lt;/em&gt; )이며 기능상 상수입니다.</target>
        </trans-unit>
        <trans-unit id="91a4811aba038c398e725d4c575b44d92daff913" translate="yes" xml:space="preserve">
          <source>The audio device objects returned by &lt;a href=&quot;#ossaudiodev.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; define the following methods and (read-only) attributes:</source>
          <target state="translated">&lt;a href=&quot;#ossaudiodev.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 오디오 장치 객체 는 다음과 같은 메서드와 (읽기 전용) 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="04d9760b94e9697b28062a4f0fcfb4a6a38d064d" translate="yes" xml:space="preserve">
          <source>The authors strongly suggest getting a copy of the Tk man pages. Specifically, the man pages in the &lt;code&gt;manN&lt;/code&gt; directory are most useful. The &lt;code&gt;man3&lt;/code&gt; man pages describe the C interface to the Tk library and thus are not especially helpful for script writers.</source>
          <target state="translated">저자는 Tk 매뉴얼 페이지의 사본을 얻는 것이 좋습니다. 특히 &lt;code&gt;manN&lt;/code&gt; 디렉토리 의 매뉴얼 페이지 가 가장 유용합니다. &lt;code&gt;man3&lt;/code&gt; 사람이 페이지는 Tk의 라이브러리에 C 인터페이스를 설명하고, 따라서 스크립트 작성자에게 특히 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64330833d6daf7d99e3cc896f57c75f2eeab2fd3" translate="yes" xml:space="preserve">
          <source>The available exception and functions in this module are:</source>
          <target state="translated">이 모듈에서 사용 가능한 예외 및 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">사용 가능한 정수 표시 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9c8d6e8588482313d7f2606674509cd39c2ade3" translate="yes" xml:space="preserve">
          <source>The available presentation types for floating point and decimal values are:</source>
          <target state="translated">부동 소수점 및 10 진수 값에 사용 가능한 프리젠 테이션 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf7e6f76bb90144b319d33f3985485d202d127c2" translate="yes" xml:space="preserve">
          <source>The available string presentation types are:</source>
          <target state="translated">사용 가능한 문자열 표시 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1cc522ce200b02d1be94463c7dbc8f36cdd953e" translate="yes" xml:space="preserve">
          <source>The barrier can be reused any number of times for the same number of threads.</source>
          <target state="translated">배리어는 동일한 수의 스레드에 대해 여러 번 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d64881eda8fb439140210f929f502081dc3c6e3" translate="yes" xml:space="preserve">
          <source>The base &lt;code&gt;Codec&lt;/code&gt; class defines these methods which also define the function interfaces of the stateless encoder and decoder:</source>
          <target state="translated">기본 &lt;code&gt;Codec&lt;/code&gt; 클래스는 상태 비 저장 인코더 및 디코더의 기능 인터페이스를 정의하는 이러한 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d36539260f7d520c14f309593d9749c7167bf7a1" translate="yes" xml:space="preserve">
          <source>The base class for all built-in exceptions. It is not meant to be directly inherited by user-defined classes (for that, use &lt;a href=&quot;#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;). If &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; is called on an instance of this class, the representation of the argument(s) to the instance are returned, or the empty string when there were no arguments.</source>
          <target state="translated">모든 내장 예외의 기본 클래스입니다. 사용자 정의 클래스에 의해 직접 상속되는 것은 아닙니다 (그러므로 &lt;a href=&quot;#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 사용 ). 경우 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 이 클래스의 인스턴스에서 호출 인수가 없었다 경우, 인스턴스에 인수 (들)의 표현은 반환 또는 빈 문자열된다.</target>
        </trans-unit>
        <trans-unit id="37d870854fd3e6d86ede1e5e4056a04f59674dcc" translate="yes" xml:space="preserve">
          <source>The base class for implementing datagram (UDP) protocols.</source>
          <target state="translated">데이터 그램 (UDP) 프로토콜을 구현하기위한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e6edb4bd859a927d0a782f77b29c7e76d77dfc75" translate="yes" xml:space="preserve">
          <source>The base class for implementing protocols communicating with child processes (unidirectional pipes).</source>
          <target state="translated">자식 프로세스 (단방향 파이프)와 통신하는 프로토콜을 구현하기위한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="037876c88a29da839e41f411005cef5212fc3b7d" translate="yes" xml:space="preserve">
          <source>The base class for implementing streaming protocols (TCP, Unix sockets, etc).</source>
          <target state="translated">스트리밍 프로토콜 (TCP, Unix 소켓 등)을 구현하기위한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="720a5bb3a4d291051b191f1d34b8551facac8967" translate="yes" xml:space="preserve">
          <source>The base class for the exceptions that are raised when a key or index used on a mapping or sequence is invalid: &lt;a href=&quot;#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;. This can be raised directly by &lt;a href=&quot;codecs#codecs.lookup&quot;&gt;&lt;code&gt;codecs.lookup()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">키 또는 인덱스 매핑 또는 시퀀스에서 사용할 때 발생하는 예외의 기본 클래스가 잘못되었습니다 : &lt;a href=&quot;#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를&lt;/a&gt; . 이것은 &lt;a href=&quot;codecs#codecs.lookup&quot;&gt; &lt;code&gt;codecs.lookup()&lt;/code&gt; &lt;/a&gt; 의해 직접 제기 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91f7435686fb107d68c4bacb73c9970d4f18e58" translate="yes" xml:space="preserve">
          <source>The base class for those built-in exceptions that are raised for various arithmetic errors: &lt;a href=&quot;#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ZeroDivisionError&quot;&gt;&lt;code&gt;ZeroDivisionError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#FloatingPointError&quot;&gt;&lt;code&gt;FloatingPointError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다양한 산술 오류 ( &lt;a href=&quot;#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ZeroDivisionError&quot;&gt; &lt;code&gt;ZeroDivisionError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#FloatingPointError&quot;&gt; &lt;code&gt;FloatingPointError&lt;/code&gt; )에&lt;/a&gt; 대해 발생하는 기본 제공 예외의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="5be1b03a2559b8dbbf5e82b0787d6c7a0613ed82" translate="yes" xml:space="preserve">
          <source>The base class of all &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">모든 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 예외 의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0d598c1c31072f1d5bb7fce71b965147de8b6233" translate="yes" xml:space="preserve">
          <source>The base class of the other exceptions in this module. It is a subclass of &lt;a href=&quot;exceptions#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에있는 다른 예외의 기본 클래스입니다. &lt;a href=&quot;exceptions#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="e9d7127298b4ff6be01bcb830aa1f5c9b7b8e1ea" translate="yes" xml:space="preserve">
          <source>The base exception class. &lt;a href=&quot;#xdrlib.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; has a single public attribute &lt;code&gt;msg&lt;/code&gt; containing the description of the error.</source>
          <target state="translated">기본 예외 클래스 &lt;a href=&quot;#xdrlib.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 설명이 포함 된 단일 공용 속성 &lt;code&gt;msg&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="478754849bb693c84213dee13796bc23b118363e" translate="yes" xml:space="preserve">
          <source>The base implementation formats the record to merge the message, arguments, and exception information, if present. It also removes unpickleable items from the record in-place.</source>
          <target state="translated">기본 구현은 레코드를 형식화하여 메시지, 인수 및 예외 정보가있는 경우이를 병합합니다. 또한 레코드에서 피클 링 불가능한 항목을 제자리에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e08426a91a7035e4c2d72c85c9c7b7cd719829df" translate="yes" xml:space="preserve">
          <source>The base implementation uses &lt;code&gt;get()&lt;/code&gt;. You may want to override this method if you want to use timeouts or work with custom queue implementations.</source>
          <target state="translated">기본 구현은 &lt;code&gt;get()&lt;/code&gt; 사용합니다 . 시간 종료를 사용하거나 사용자 정의 큐 구현에 대해 작업하려는 경우이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb9a116b8103bca120218fe5a882926ba73692a3" translate="yes" xml:space="preserve">
          <source>The based class for all other module-specific exceptions.</source>
          <target state="translated">다른 모든 모듈 별 예외에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d4f200fcdf75b7beb6b2c030a2febabba55c0a7d" translate="yes" xml:space="preserve">
          <source>The basic API is a simple wrapper that&amp;rsquo;s intended to make doctest easy to use. It is fairly flexible, and should meet most users&amp;rsquo; needs; however, if you require more fine-grained control over testing, or wish to extend doctest&amp;rsquo;s capabilities, then you should use the advanced API.</source>
          <target state="translated">기본 API는 doctest를 사용하기 쉽게 만드는 간단한 래퍼입니다. 상당히 유연하며 대부분의 사용자 요구를 충족시켜야합니다. 그러나 테스트에 대한보다 세밀한 제어가 필요하거나 doctest의 기능을 확장하려면 고급 API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c46a98898a854487d370b50e8f5e79d547a5abf6" translate="yes" xml:space="preserve">
          <source>The basic building blocks of unit testing are &lt;em&gt;test cases&lt;/em&gt; &amp;mdash; single scenarios that must be set up and checked for correctness. In &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;, test cases are represented by &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt; instances. To make your own test cases you must write subclasses of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; or use &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt;&lt;code&gt;FunctionTestCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단위 테스트의 기본 구성 요소는 &lt;em&gt;테스트 사례입니다&lt;/em&gt; . 단일 시나리오로 설정하고 정확성을 검사해야합니다. 에서 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; , 테스트 케이스는로 표현됩니다 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; 의&lt;/a&gt; 인스턴스. 자체 테스트 사례를 만들려면 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; 의&lt;/a&gt; 서브 클래스를 작성 하거나 &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt; &lt;code&gt;FunctionTestCase&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1631527b4d4b04ac30516c30c03bdc201a159063" translate="yes" xml:space="preserve">
          <source>The basic classes defined by the module, together with their functions, are listed below.</source>
          <target state="translated">모듈에서 정의한 기본 클래스와 해당 기능이 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0621714f64d694606df173391b93313eeac34756" translate="yes" xml:space="preserve">
          <source>The basic data compression module needed to support the &lt;strong&gt;gzip&lt;/strong&gt; file format.</source>
          <target state="translated">기본 데이터 압축 모듈은 &lt;strong&gt;gzip&lt;/strong&gt; 파일 형식 을 지원해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="f3ea23849e09db81b8cf44483296cfa966e4cf09" translate="yes" xml:space="preserve">
          <source>The basic idea behind both modules is to create one or more network &lt;em&gt;channels&lt;/em&gt;, instances of class &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt;&lt;code&gt;asynchat.async_chat&lt;/code&gt;&lt;/a&gt;. Creating the channels adds them to a global map, used by the &lt;a href=&quot;#asyncore.loop&quot;&gt;&lt;code&gt;loop()&lt;/code&gt;&lt;/a&gt; function if you do not provide it with your own &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">두 모듈의 기본 개념은 하나 이상의 네트워크 &lt;em&gt;채널&lt;/em&gt; , &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt; &lt;code&gt;asynchat.async_chat&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 를 만드는 것 입니다. 채널을 만들면 자신의 &lt;em&gt;map을&lt;/em&gt; 제공하지 않으면 &lt;a href=&quot;#asyncore.loop&quot;&gt; &lt;code&gt;loop()&lt;/code&gt; &lt;/a&gt; 함수가 사용하는 전역 맵에 채널이 추가 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ffd84d87aba9b9e8fc01342a423d56d02dd44a" translate="yes" xml:space="preserve">
          <source>The basic idea for &lt;a href=&quot;#module-tkinter.ttk&quot;&gt;&lt;code&gt;tkinter.ttk&lt;/code&gt;&lt;/a&gt; is to separate, to the extent possible, the code implementing a widget&amp;rsquo;s behavior from the code implementing its appearance.</source>
          <target state="translated">&lt;a href=&quot;#module-tkinter.ttk&quot;&gt; &lt;code&gt;tkinter.ttk&lt;/code&gt; &lt;/a&gt; 의 기본 아이디어 는 위젯의 동작을 구현하는 코드와 모양을 구현하는 코드를 가능한 한 분리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16e9e78405f309044c1b7fe1bffdce4599a86f91" translate="yes" xml:space="preserve">
          <source>The basic principle is that you patch where an object is &lt;em&gt;looked up&lt;/em&gt;, which is not necessarily the same place as where it is defined. A couple of examples will help to clarify this.</source>
          <target state="translated">기본 원칙은 객체를 &lt;em&gt;찾는&lt;/em&gt; 곳을 패치하는 것인데, 반드시 정의 된 곳과 반드시 ​​같은 곳은 아닙니다. 몇 가지 예가이를 명확히하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="35a19f280d80a953c16e49e081b424d6cbff98c0" translate="yes" xml:space="preserve">
          <source>The basic type used for binary data read from or written to a file is &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Other &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; are accepted as method arguments too. Text I/O classes work with &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data.</source>
          <target state="translated">파일에서 읽거나 파일에 쓰는 이진 데이터에 사용되는 기본 유형은 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 입니다. 다른 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 도 메소드 인수로 허용됩니다. 텍스트 I / O 클래스는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 데이터 와 함께 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="1a0089a139acba0f4ef316c21fe484b7943e9402" translate="yes" xml:space="preserve">
          <source>The behavior is same as &lt;a href=&quot;#urllib.request.HTTPErrorProcessor.http_response&quot;&gt;&lt;code&gt;http_response()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동작은 &lt;a href=&quot;#urllib.request.HTTPErrorProcessor.http_response&quot;&gt; &lt;code&gt;http_response()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="509167a2d22d3e262915b45c8a13aa32c0c6f112" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;#mailbox.Mailbox.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt; is unlike that of dictionaries, which iterate over keys.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 의 동작은 키를 반복하는 사전 의 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7ed5e3c6e5fccac07bc7e1871b7a1d111d3de3c4" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt; for floats can be surprising: for example, &lt;code&gt;round(2.675, 2)&lt;/code&gt; gives &lt;code&gt;2.67&lt;/code&gt; instead of the expected &lt;code&gt;2.68&lt;/code&gt;. This is not a bug: it&amp;rsquo;s a result of the fact that most decimal fractions can&amp;rsquo;t be represented exactly as a float. See &lt;a href=&quot;https://docs.python.org/3.8/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;Floating Point Arithmetic: Issues and Limitations&lt;/a&gt; for more information.</source>
          <target state="translated">float에 대한 &lt;a href=&quot;#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; 의 동작은 놀랍습니다. 예를 들어 &lt;code&gt;round(2.675, 2)&lt;/code&gt; 는 예상 &lt;code&gt;2.68&lt;/code&gt; 대신 &lt;code&gt;2.67&lt;/code&gt; 을 제공합니다 . 이것은 버그가 아닙니다. 대부분의 소수는 정확히 부동 소수점으로 표현할 수 없다는 사실의 결과입니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;부동 소수점 산술 : 문제 및 제한 사항&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c9031477af7e15d083a487073bb2d0a4eb97e4c9" translate="yes" xml:space="preserve">
          <source>The behavior of Python&amp;rsquo;s comparison operators can be a little surprising where a &lt;code&gt;NaN&lt;/code&gt; is involved. A test for equality where one of the operands is a quiet or signaling &lt;code&gt;NaN&lt;/code&gt; always returns &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; (even when doing &lt;code&gt;Decimal('NaN')==Decimal('NaN')&lt;/code&gt;), while a test for inequality always returns &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;. An attempt to compare two Decimals using any of the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt; operators will raise the &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt; signal if either operand is a &lt;code&gt;NaN&lt;/code&gt;, and return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; if this signal is not trapped. Note that the General Decimal Arithmetic specification does not specify the behavior of direct comparisons; these rules for comparisons involving a &lt;code&gt;NaN&lt;/code&gt; were taken from the IEEE 854 standard (see Table 3 in section 5.7). To ensure strict standards-compliance, use the &lt;code&gt;compare()&lt;/code&gt; and &lt;code&gt;compare-signal()&lt;/code&gt; methods instead.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 이 관련된 곳에서 파이썬의 비교 연산자의 동작은 약간 놀랍습니다 . 피연산자 중 하나가 조용한 또는 신호 &lt;code&gt;NaN&lt;/code&gt; 인 동등성 검정은 항상 &lt;code&gt;Decimal('NaN')==Decimal('NaN')&lt;/code&gt; 수행하는 경우에도 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환 하지만 부등식 검정은 항상 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자 중 하나를 사용하여 두 Decimal을 비교하려고 하면 피연산자가 &lt;code&gt;NaN&lt;/code&gt; 인 경우 &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; &lt;/a&gt; 신호를 발생 시키고 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환합니다.이 신호가 갇히지 않으면 일반 십진 산술 스펙은 직접 비교의 동작을 지정하지 않습니다. &lt;code&gt;NaN&lt;/code&gt; 과 관련된 비교 규칙 은 IEEE 854 표준에서 취해졌습니다 (섹션 5.7의 표 3 참조). 엄격한 표준 준수를 보장하려면 대신 &lt;code&gt;compare()&lt;/code&gt; 및 &lt;code&gt;compare-signal()&lt;/code&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2cc2a05a47982852d6024377eba4e6d10a25ebe4" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt;&lt;code&gt;is&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is-not&quot;&gt;&lt;code&gt;is not&lt;/code&gt;&lt;/a&gt; operators cannot be customized; also they can be applied to any two objects and never raise an exception.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt; &lt;code&gt;is&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is-not&quot;&gt; &lt;code&gt;is not&lt;/code&gt; &lt;/a&gt; 연산자 의 동작은 사용자 정의 할 수 없습니다. 또한 두 객체에 적용 할 수 있으며 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="544260a58eab8deefccf4a61698b8f81198ba13f" translate="yes" xml:space="preserve">
          <source>The behavior of the call is dependent on the value of &lt;em&gt;how&lt;/em&gt;, as follows.</source>
          <target state="translated">호출 동작은 다음과 같이 &lt;em&gt;how&lt;/em&gt; 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="40956b4e017ec60e6e630696961357aedfdf755a" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be overridden by an earlier call to the &lt;a href=&quot;https://docs.python.org/3.8/c-api/file.html#c.PyFile_SetOpenCodeHook&quot;&gt;&lt;code&gt;PyFile_SetOpenCodeHook()&lt;/code&gt;&lt;/a&gt;, however, it should always be considered interchangeable with &lt;code&gt;open(path, 'rb')&lt;/code&gt;. Overriding the behavior is intended for additional validation or preprocessing of the file.</source>
          <target state="translated">이 함수의 동작은 &lt;a href=&quot;https://docs.python.org/3.8/c-api/file.html#c.PyFile_SetOpenCodeHook&quot;&gt; &lt;code&gt;PyFile_SetOpenCodeHook()&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출로 재정의 될 수 있지만 항상 &lt;code&gt;open(path, 'rb')&lt;/code&gt; 와 상호 교환 가능한 것으로 간주되어야합니다 . 비헤이비어 재정의는 파일의 추가 유효성 검사 또는 사전 처리를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b73eb81df2ab1d8f8cce0693e52a357a71025f62" translate="yes" xml:space="preserve">
          <source>The behaviour described in this section applies only to the URL parsing functions. The URL quoting functions use their own rules when producing or consuming byte sequences as detailed in the documentation of the individual URL quoting functions.</source>
          <target state="translated">이 섹션에서 설명하는 동작은 URL 구문 분석 기능에만 적용됩니다. URL 인용 함수는 개별 URL 인용 함수의 문서에 설명 된대로 바이트 시퀀스를 생성하거나 사용할 때 자체 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fccb0864af618f1eda4209875389b23fdd17be04" translate="yes" xml:space="preserve">
          <source>The best (no more than &lt;em&gt;n&lt;/em&gt;) matches among the possibilities are returned in a list, sorted by similarity score, most similar first.</source>
          <target state="translated">가능성 중 최고 ( &lt;em&gt;n 이하&lt;/em&gt; ) 일치 항목이 유사성 점수로 정렬되어 목록에서 반환되며 가장 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6e16ef4c7892d882d4fb24850f803bc72293e9c1" translate="yes" xml:space="preserve">
          <source>The binary data encapsulated by the &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt;&lt;code&gt;Binary&lt;/code&gt;&lt;/a&gt; instance. The data is provided as a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt; &lt;code&gt;Binary&lt;/code&gt; &lt;/a&gt; 인스턴스로 캡슐화 된 이진 데이터 입니다. 데이터는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b2c516a69d7acb2c687bf6c7fbf1597a2d16d23" translate="yes" xml:space="preserve">
          <source>The binary format for plist files</source>
          <target state="translated">plist 파일의 이진 형식</target>
        </trans-unit>
        <trans-unit id="252ee8840198291e490d998e86244d7d8e35b498" translate="yes" xml:space="preserve">
          <source>The binary representation of this address - a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of the appropriate length (most significant octet first). This is 4 bytes for IPv4 and 16 bytes for IPv6.</source>
          <target state="translated">이 주소의 이진 표현- 적절한 길이 의 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 (가장 중요한 옥텟 우선). IPv4의 경우 4 바이트, IPv6의 경우 16 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="0812f781105763b6ad83547e0dd0926227d1acb3" translate="yes" xml:space="preserve">
          <source>The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">제거 할 바이트 값의 이진 시퀀스는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79985ad5b74e6b2174133e206b38c0aac43f893a" translate="yes" xml:space="preserve">
          <source>The binary stream API is described in detail in the docs of &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이진 스트림 API는 &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; 문서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bbdb4bdfe9695f4a095f27b2e5074bc83e4388e" translate="yes" xml:space="preserve">
          <source>The bind method from the widget command allows you to watch for certain events and to have a callback function trigger when that event type occurs. The form of the bind method is:</source>
          <target state="translated">위젯 명령의 바인드 메소드를 사용하면 특정 이벤트를 감시하고 해당 이벤트 유형이 발생할 때 콜백 함수를 트리거 할 수 있습니다. 바인드 메소드의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e93fbed83a2a6d08231b63e0601395b4e1d9ac92" translate="yes" xml:space="preserve">
          <source>The bootstrapping process has side effects on both &lt;code&gt;sys.path&lt;/code&gt; and &lt;code&gt;os.environ&lt;/code&gt;. Invoking the command line interface in a subprocess instead allows these side effects to be avoided.</source>
          <target state="translated">부트 스트랩 프로세스는 &lt;code&gt;sys.path&lt;/code&gt; 및 &lt;code&gt;os.environ&lt;/code&gt; 모두에 부작용이 있습니다 . 서브 프로세스에서 명령 행 인터페이스를 호출하면 이러한 부작용을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f515285eaaa8a5dd687b8c8d9114206f8ad89259" translate="yes" xml:space="preserve">
          <source>The bootstrapping process may install additional modules required by &lt;code&gt;pip&lt;/code&gt;, but other software should not assume those dependencies will always be present by default (as the dependencies may be removed in a future version of &lt;code&gt;pip&lt;/code&gt;).</source>
          <target state="translated">부트 스트랩 프로세스는 &lt;code&gt;pip&lt;/code&gt; 에 필요한 추가 모듈을 설치할 수 있지만 다른 소프트웨어는 이러한 종속성이 기본적으로 항상 존재한다고 가정하지 않아야합니다 (이후 버전의 &lt;code&gt;pip&lt;/code&gt; 에서는 종속성이 제거 될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="c5d92c927226a7e06bd64aa8058a997143922e20" translate="yes" xml:space="preserve">
          <source>The breakpoint hit count.</source>
          <target state="translated">중단 점 적중 횟수</target>
        </trans-unit>
        <trans-unit id="1cba654c3d7f4efba7391fd33ea1f1150e43af8b" translate="yes" xml:space="preserve">
          <source>The breakpoint number.</source>
          <target state="translated">중단 점 번호</target>
        </trans-unit>
        <trans-unit id="53bf604092d847435ec91583c0ecb4652c552bdb" translate="yes" xml:space="preserve">
          <source>The broadcast address for the network. Packets sent to the broadcast address should be received by every host on the network.</source>
          <target state="translated">네트워크의 브로드 캐스트 주소입니다. 브로드 캐스트 주소로 전송 된 패킷은 네트워크의 모든 호스트가 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d40ac1836068b896d22f880fb080c4129bf0cf8" translate="yes" xml:space="preserve">
          <source>The built in configuration would correspond to the following turtle.cfg:</source>
          <target state="translated">내장 구성은 다음 turtle.cfg에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e7fa923936d6d1b71a2acb45dbdbd4cb369c9d51" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;#sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal &amp;mdash; this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade).</source>
          <target state="translated">내장 &lt;a href=&quot;#sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 함수는 안정적입니다. 동일하게 비교되는 요소의 상대적 순서를 변경하지 않으면 정렬은 안정적입니다. 이는 여러 단계로 정렬하는 데 유용합니다 (예 : 부서별, 급여 등급별).</target>
        </trans-unit>
        <trans-unit id="a0892e50ab43cc568814a6df06313480188876dd" translate="yes" xml:space="preserve">
          <source>The built-in default configuration mimics the appearance and behaviour of the old turtle module in order to retain best possible compatibility with it.</source>
          <target state="translated">내장 된 기본 구성은 기존 거북이 모듈의 모양과 동작을 모방하여 최상의 호환성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="eb1483a41a7a356efe8918b5b9cc6c72b5b93268" translate="yes" xml:space="preserve">
          <source>The built-in exception classes can be subclassed to define new exceptions; programmers are encouraged to derive new exceptions from the &lt;a href=&quot;#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; class or one of its subclasses, and not from &lt;a href=&quot;#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;. More information on defining exceptions is available in the Python Tutorial under &lt;a href=&quot;https://docs.python.org/3.8/tutorial/errors.html#tut-userexceptions&quot;&gt;User-defined Exceptions&lt;/a&gt;.</source>
          <target state="translated">내장 예외 클래스는 새로운 예외를 정의하기 위해 서브 클래 싱 될 수 있습니다. 프로그래머는 &lt;a href=&quot;#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; 이&lt;/a&gt; 아닌 &lt;a href=&quot;#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 클래스 또는 해당 서브 클래스 중 하나 에서 새 예외를 파생시키는 것이 좋습니다 . 예외 정의에 대한 자세한 내용은 Python Tutorial의 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/errors.html#tut-userexceptions&quot;&gt;User-defined Exceptions&lt;/a&gt; 아래에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3828a20aa9a305e843887279463a549fc13bad92" translate="yes" xml:space="preserve">
          <source>The built-in exceptions listed below can be generated by the interpreter or built-in functions. Except where mentioned, they have an &amp;ldquo;associated value&amp;rdquo; indicating the detailed cause of the error. This may be a string or a tuple of several items of information (e.g., an error code and a string explaining the code). The associated value is usually passed as arguments to the exception class&amp;rsquo;s constructor.</source>
          <target state="translated">아래에 나열된 내장 예외는 인터프리터 또는 내장 함수에 의해 생성 될 수 있습니다. 언급 된 경우를 제외하고, 오류의 자세한 원인을 나타내는 &quot;연관된 값&quot;이 있습니다. 이것은 여러 정보 항목의 문자열 또는 튜플 일 수 있습니다 (예 : 오류 코드 및 코드를 설명하는 문자열). 연관된 값은 일반적으로 예외 클래스의 생성자에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ce16b2d882c9465a0733bec038b7dbc1af59c9ba" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;a href=&quot;functions#help&quot;&gt;&lt;code&gt;help()&lt;/code&gt;&lt;/a&gt; invokes the online help system in the interactive interpreter, which uses &lt;a href=&quot;#module-pydoc&quot;&gt;&lt;code&gt;pydoc&lt;/code&gt;&lt;/a&gt; to generate its documentation as text on the console. The same text documentation can also be viewed from outside the Python interpreter by running &lt;strong&gt;pydoc&lt;/strong&gt; as a script at the operating system&amp;rsquo;s command prompt. For example, running</source>
          <target state="translated">내장 함수 &lt;a href=&quot;functions#help&quot;&gt; &lt;code&gt;help()&lt;/code&gt; &lt;/a&gt; 는 대화식 인터프리터에서 &lt;a href=&quot;#module-pydoc&quot;&gt; &lt;code&gt;pydoc&lt;/code&gt; &lt;/a&gt; 을 사용하여 문서를 콘솔에서 텍스트로 텍스트로 생성 하는 온라인 도움말 시스템을 호출합니다 . 운영 체제의 명령 프롬프트에서 &lt;strong&gt;pydoc&lt;/strong&gt; 을 스크립트로 실행하여 Python 인터프리터 외부에서 동일한 텍스트 문서를 볼 수도 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="2032bd3ab7af47f02c71e038cf4e4ffa2d3f7fc7" translate="yes" xml:space="preserve">
          <source>The built-in functions &lt;a href=&quot;#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; return the current global and local dictionary, respectively, which may be useful to pass around for use as the second and third argument to &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내장 함수 &lt;a href=&quot;#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 는 현재 전역 및 로컬 사전을 각각 리턴하므로 &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 의 두 번째 및 세 번째 인수로 사용하기 위해 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5e8010d0807348a7e3e895536079ec4ac5755b" translate="yes" xml:space="preserve">
          <source>The built-in string class provides the ability to do complex variable substitutions and value formatting via the &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; method described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-3101&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3101&lt;/strong&gt;&lt;/a&gt;. The &lt;a href=&quot;#string.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; class in the &lt;a href=&quot;#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">내장 문자열 클래스는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3101&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3101에&lt;/strong&gt;&lt;/a&gt; 설명 된 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 복잡한 변수 대체 및 값 형식화를 수행하는 기능을 제공합니다 . &lt;a href=&quot;#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;a href=&quot;#string.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 클래스를 사용하면 내장 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; 메서드 와 동일한 구현을 사용하여 고유 한 문자열 형식 동작을 만들고 사용자 지정할 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7779d62430e6d828e7796b70c889aebdd5d5b2a7" translate="yes" xml:space="preserve">
          <source>The bytearray version of this method does &lt;em&gt;not&lt;/em&gt; operate in place - it always produces a new object, even if no changes were made.</source>
          <target state="translated">이 메소드의 바이트 배열 버전은 제자리에서 작동 하지 &lt;em&gt;않습니다&lt;/em&gt; . 변경 사항이 없더라도 항상 새 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="825f32039ec2b8c6f1ad7632fe9653dd855a0a80" translate="yes" xml:space="preserve">
          <source>The bytecode analysis API allows pieces of Python code to be wrapped in a &lt;a href=&quot;#dis.Bytecode&quot;&gt;&lt;code&gt;Bytecode&lt;/code&gt;&lt;/a&gt; object that provides easy access to details of the compiled code.</source>
          <target state="translated">바이트 코드 분석 API를 사용 하면 컴파일 된 코드의 세부 정보에 쉽게 액세스 할 수 있는 &lt;a href=&quot;#dis.Bytecode&quot;&gt; &lt;code&gt;Bytecode&lt;/code&gt; &lt;/a&gt; 객체 에 Python 코드 조각을 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4e72ff3f77625381d6ebb85da38770f77d7d8d2" translate="yes" xml:space="preserve">
          <source>The bytes contained in &lt;em&gt;fp&lt;/em&gt; must be formatted as a block of &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; (or, if &lt;code&gt;utf8&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt;) style headers and header continuation lines, optionally preceded by an envelope header. The header block is terminated either by the end of the data or by a blank line. Following the header block is the body of the message (which may contain MIME-encoded subparts, including subparts with a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; of &lt;code&gt;8bit&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;fp에&lt;/em&gt; 포함 된 바이트 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; (또는 &lt;code&gt;utf8&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; ) 스타일 헤더 및 헤더 연속 행 의 블록으로 형식화되어야하며 , 선택적으로 봉투 헤더가 앞에옵니다. 헤더 블록은 데이터 끝이나 빈 줄로 종료됩니다. 헤더 블록 다음에는 메시지 본문이 있습니다 (여기에는 &lt;code&gt;8bit&lt;/code&gt; 의 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 이 있는 서브 파트를 포함하여 MIME로 인코딩 된 서브 파트가 포함될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="72979803b3b76ceaedcd3e763678e9c5bdfe19e9" translate="yes" xml:space="preserve">
          <source>The bytes which represent the bytecode version number. If you need help with loading/writing bytecode then consider &lt;a href=&quot;#importlib.abc.SourceLoader&quot;&gt;&lt;code&gt;importlib.abc.SourceLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">바이트 코드 버전 번호를 나타내는 바이트입니다. 바이트 코드로드 / 쓰기에 도움이 필요하면 &lt;a href=&quot;#importlib.abc.SourceLoader&quot;&gt; &lt;code&gt;importlib.abc.SourceLoader&lt;/code&gt; &lt;/a&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="63b8460a5fd05daeaaaaeca07ed037cc843d40ae" translate="yes" xml:space="preserve">
          <source>The cache (or part of it) can be cleared manually if a rescan of &lt;a href=&quot;sys#sys.path_hooks&quot;&gt;&lt;code&gt;sys.path_hooks&lt;/code&gt;&lt;/a&gt; is necessary.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.path_hooks&quot;&gt; &lt;code&gt;sys.path_hooks&lt;/code&gt; 를&lt;/a&gt; 다시 스캔 해야하는 경우 캐시 (또는 캐시의 일부)를 수동으로 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed9c68f517e26b2e6a3625184bdd623a5e8c02e6" translate="yes" xml:space="preserve">
          <source>The caching feature of &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt;&lt;code&gt;urlretrieve()&lt;/code&gt;&lt;/a&gt; has been disabled until someone finds the time to hack proper processing of Expiration time headers.</source>
          <target state="translated">누군가가 만료 시간 헤더의 적절한 처리를 해킹 할 시간을 찾을 때까지 &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt; &lt;code&gt;urlretrieve()&lt;/code&gt; &lt;/a&gt; 의 캐싱 기능 이 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c502152227f3ef8521b4fb7861c4b965c780d96" translate="yes" xml:space="preserve">
          <source>The calculated size of the struct (and hence of the bytes object produced by the &lt;a href=&quot;#struct.pack&quot;&gt;&lt;code&gt;pack()&lt;/code&gt;&lt;/a&gt; method) corresponding to &lt;a href=&quot;functions#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; 에&lt;/a&gt; 해당하는 struct (및 &lt;a href=&quot;#struct.pack&quot;&gt; &lt;code&gt;pack()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성 된 bytes 객체)의 계산 된 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="c83bb87cd08de64e758cd798a710959973f92aa3" translate="yes" xml:space="preserve">
          <source>The callback function will be called with three arguments; the first being the &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt;, the second is a string that represents the server name that the client is intending to communicate (or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the TLS Client Hello does not contain a server name) and the third argument is the original &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt;. The server name argument is text. For internationalized domain name, the server name is an IDN A-label (&lt;code&gt;&quot;xn--pythn-mua.org&quot;&lt;/code&gt;).</source>
          <target state="translated">콜백 함수는 세 개의 인수로 호출됩니다. 첫 번째는 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; &lt;/a&gt; 이고, 두 번째는 클라이언트가 통신하려는 서버 이름을 나타내는 문자열입니다 (또는 TLS 클라이언트 Hello에 서버 이름이 포함되어 있지 않은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ). 세 번째 인수는 원래 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 입니다. 서버 이름 인수는 텍스트입니다. 국제화 된 도메인 이름의 경우 서버 이름은 IDN A 레이블 ( &lt;code&gt;&quot;xn--pythn-mua.org&quot;&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="cd8e655e9eed9b74bde977375823ab681334e73c" translate="yes" xml:space="preserve">
          <source>The callback will be invoked by &lt;em&gt;loop&lt;/em&gt;, along with other queued callbacks and runnable coroutines of that event loop. Unlike signal handlers registered using &lt;a href=&quot;signal#signal.signal&quot;&gt;&lt;code&gt;signal.signal()&lt;/code&gt;&lt;/a&gt;, a callback registered with this function is allowed to interact with the event loop.</source>
          <target state="translated">콜백은 대기중인 다른 콜백 및 해당 이벤트 루프의 실행 가능한 코 루틴과 함께 &lt;em&gt;loop&lt;/em&gt; 에 의해 호출됩니다 . &lt;a href=&quot;signal#signal.signal&quot;&gt; &lt;code&gt;signal.signal()&lt;/code&gt; &lt;/a&gt; 사용하여 등록 된 신호 처리기와 달리이 함수로 등록 된 콜백은 이벤트 루프와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22bd53399975bb33fc06872aa0715a547b88ac9e" translate="yes" xml:space="preserve">
          <source>The caller may release or mutate &lt;em&gt;b&lt;/em&gt; after this method returns, so the implementation should only access &lt;em&gt;b&lt;/em&gt; during the method call.</source>
          <target state="translated">호출자는 이 메소드가 리턴 된 후 &lt;em&gt;b를&lt;/em&gt; 해제하거나 변경할 수 있으므로 구현은 메소드 호출 중 &lt;em&gt;b&lt;/em&gt; 에만 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eff6d403c84e9dd6cfb7f05890938d3f3448560b" translate="yes" xml:space="preserve">
          <source>The canonical form of the filename which contains the frame.</source>
          <target state="translated">프레임을 포함하는 파일 이름의 표준 형식입니다.</target>
        </trans-unit>
        <trans-unit id="c8533238eda8a62e9128958e4776c77a39312314" translate="yes" xml:space="preserve">
          <source>The canonical name of this HMAC, always lowercase, e.g. &lt;code&gt;hmac-md5&lt;/code&gt;.</source>
          <target state="translated">이 HMAC의 정식 이름은 항상 소문자입니다 (예 : &lt;code&gt;hmac-md5&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="ff8c6491e39ff96156d9120d3205f0365e5d01cf" translate="yes" xml:space="preserve">
          <source>The canonical name of this hash, always lowercase and always suitable as a parameter to &lt;a href=&quot;#hashlib.new&quot;&gt;&lt;code&gt;new()&lt;/code&gt;&lt;/a&gt; to create another hash of this type.</source>
          <target state="translated">이 해시의 정식 이름은 항상 소문자이며 항상 이 유형의 다른 해시를 작성하기위한 &lt;a href=&quot;#hashlib.new&quot;&gt; &lt;code&gt;new()&lt;/code&gt; &lt;/a&gt; 의 매개 변수로 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="86383e1461d35f27675e6567047706ab486a7820" translate="yes" xml:space="preserve">
          <source>The casefolding algorithm is described in section 3.13 of the Unicode Standard.</source>
          <target state="translated">케이스 폴딩 알고리즘은 유니 코드 표준의 3.13 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="09bc2e18042eda7d06b3a19559cc299378be13d8" translate="yes" xml:space="preserve">
          <source>The ceiling for the process&amp;rsquo;s nice level (calculated as 20 - rlim_cur).</source>
          <target state="translated">프로세스의 적정 수준의 상한 (20-rlim_cur로 계산).</target>
        </trans-unit>
        <trans-unit id="8ce6ab2c12963a27ddd741a54afdd9198d059d94" translate="yes" xml:space="preserve">
          <source>The ceiling of the real-time priority.</source>
          <target state="translated">실시간 우선 순위의 한도.</target>
        </trans-unit>
        <trans-unit id="639203ac4f7750e330cf2cd16c6fd78a1b956598" translate="yes" xml:space="preserve">
          <source>The central class in the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package is the &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; class, imported from the &lt;a href=&quot;#module-email.message&quot;&gt;&lt;code&gt;email.message&lt;/code&gt;&lt;/a&gt; module. It is the base class for the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; object model. &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; provides the core functionality for setting and querying header fields, for accessing message bodies, and for creating or modifying structured messages.</source>
          <target state="translated">에서 중앙 클래스 &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는이다 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 으로부터 수입 클래스, &lt;a href=&quot;#module-email.message&quot;&gt; &lt;code&gt;email.message&lt;/code&gt; 의&lt;/a&gt; 모듈. &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 객체 모델 의 기본 클래스입니다 . &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 는 헤더 필드 설정 및 조회, 메시지 본문 액세스 및 구조화 된 메시지 작성 또는 수정을위한 핵심 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e36386588c7d08f4857bc3785fb1d4d5c17d9fa" translate="yes" xml:space="preserve">
          <source>The central component of the package is an &amp;ldquo;object model&amp;rdquo; that represents email messages. An application interacts with the package primarily through the object model interface defined in the &lt;a href=&quot;email.message#module-email.message&quot;&gt;&lt;code&gt;message&lt;/code&gt;&lt;/a&gt; sub-module. The application can use this API to ask questions about an existing email, to construct a new email, or to add or remove email subcomponents that themselves use the same object model interface. That is, following the nature of email messages and their MIME subcomponents, the email object model is a tree structure of objects that all provide the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">패키지의 핵심 구성 요소는 전자 메일 메시지를 나타내는 &quot;개체 모델&quot;입니다. 응용 프로그램은 주로 &lt;a href=&quot;email.message#module-email.message&quot;&gt; &lt;code&gt;message&lt;/code&gt; &lt;/a&gt; 하위 모듈에 정의 된 개체 모델 인터페이스를 통해 패키지와 상호 작용 합니다. 애플리케이션은이 API를 사용하여 기존 이메일에 대한 질문을하거나 새 이메일을 작성하거나 동일한 오브젝트 모델 인터페이스를 사용하는 이메일 하위 구성 요소를 추가 또는 제거 할 수 있습니다. 즉, 전자 메일 메시지 및 해당 MIME 하위 구성 요소의 특성에 따라 전자 메일 개체 모델은 모두 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; API를 제공하는 개체의 트리 구조입니다 .</target>
        </trans-unit>
        <trans-unit id="b8ad1ef8b31c9d3d4272c53dd49dd5587dde6ea9" translate="yes" xml:space="preserve">
          <source>The channel continues to collect data forever</source>
          <target state="translated">채널은 계속해서 데이터를 수집합니다</target>
        </trans-unit>
        <trans-unit id="990b5a1da94f1bd10326a2f8f9f4f2d725871e25" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search path components (as in &lt;code id=&quot;index-44&quot;&gt;PATH&lt;/code&gt;), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX 또는 &lt;code&gt;';'&lt;/code&gt; &lt;code&gt;':'&lt;/code&gt; 경우 ':' 와 같이 검색 경로 구성 요소를 분리하기 위해 운영 체제에서 일반적으로 사용하는 문자입니다 ( &lt;code id=&quot;index-44&quot;&gt;PATH&lt;/code&gt; 와 같이) . Windows 용. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="3d99da8fe6d18c618150889ebc5804acc1de27a2" translate="yes" xml:space="preserve">
          <source>The character encoding is platform-dependent. Non-Windows platforms use the locale encoding (see &lt;a href=&quot;locale#locale.getpreferredencoding&quot;&gt;&lt;code&gt;locale.getpreferredencoding()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자 인코딩은 플랫폼에 따라 다릅니다. Windows 이외의 플랫폼은 로케일 인코딩을 사용합니다 ( &lt;a href=&quot;locale#locale.getpreferredencoding&quot;&gt; &lt;code&gt;locale.getpreferredencoding()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bfc93a686eda7c49ec3507891da13ae0c98e36c9" translate="yes" xml:space="preserve">
          <source>The character set, &lt;a href=&quot;string#string.ascii_letters&quot;&gt;&lt;code&gt;string.ascii_letters&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#string.digits&quot;&gt;&lt;code&gt;string.digits&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;!#$%&amp;amp;'*+-.^_`|~:&lt;/code&gt; denote the set of valid characters allowed by this module in Cookie name (as &lt;a href=&quot;#http.cookies.Morsel.key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자 세트, &lt;a href=&quot;string#string.ascii_letters&quot;&gt; &lt;code&gt;string.ascii_letters&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;string#string.digits&quot;&gt; &lt;code&gt;string.digits&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;!#$%&amp;amp;'*+-.^_`|~:&lt;/code&gt; 는 쿠키 이름에서이 모듈이 허용하는 유효한 문자 세트를 &lt;a href=&quot;#http.cookies.Morsel.key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; 이름으로 나타냅니다 ( 키로 ).</target>
        </trans-unit>
        <trans-unit id="f3c8562e2db6ea59a857d6692fcd05b5595aad09" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components. This is &lt;code&gt;'/'&lt;/code&gt; for POSIX and &lt;code&gt;'\\'&lt;/code&gt; for Windows. Note that knowing this is not sufficient to be able to parse or concatenate pathnames &amp;mdash; use &lt;a href=&quot;os.path#os.path.split&quot;&gt;&lt;code&gt;os.path.split()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt; &amp;mdash; but it is occasionally useful. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로 이름 구성 요소를 구분하기 위해 운영 체제에서 사용하는 문자입니다. 이다 &lt;code&gt;'/'&lt;/code&gt; POSIX 및 대한 &lt;code&gt;'\\'&lt;/code&gt; Windows 용. 이것을 아는 것만으로는 경로명을 구문 분석하거나 연결하기에 충분하지 않습니다 &lt;a href=&quot;os.path#os.path.split&quot;&gt; &lt;code&gt;os.path.split()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt; . 때때로 유용합니다. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="309bb84393dbc6c91d360c133c257980087f7321" translate="yes" xml:space="preserve">
          <source>The character used to draw separator lines under the help-message headers. If empty, no ruler line is drawn. It defaults to &lt;code&gt;'='&lt;/code&gt;.</source>
          <target state="translated">도움말 메시지 헤더 아래에 구분선을 그리는 데 사용되는 문자입니다. 비어 있으면 눈금자 선이 그려지지 않습니다. 기본값은 &lt;code&gt;'='&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ea51325acbd5404b45bf3a9645468bed81b871e" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the &lt;code&gt;'.'&lt;/code&gt; in &lt;code&gt;os.py&lt;/code&gt;. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 파일 이름을 확장자와 구분하는 문자입니다. 예를 들어 &lt;code&gt;'.'&lt;/code&gt; 에 &lt;code&gt;os.py&lt;/code&gt; . &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="f625dcb310956d459da71c49e55907d5aaf7c87f" translate="yes" xml:space="preserve">
          <source>The child process is not killed if the timeout expires, so in order to cleanup properly a well-behaved application should kill the child process and finish communication:</source>
          <target state="translated">제한 시간이 만료되면 하위 프로세스가 종료되지 않으므로 올바르게 정리하려면 올바르게 작동하는 응용 프로그램이 하위 프로세스를 종료하고 통신을 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="6548909ff9d18497967c143ac6e0f73e274ac502" translate="yes" xml:space="preserve">
          <source>The child return code, set by &lt;a href=&quot;#subprocess.Popen.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#subprocess.Popen.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; (and indirectly by &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt;). A &lt;code&gt;None&lt;/code&gt; value indicates that the process hasn&amp;rsquo;t terminated yet.</source>
          <target state="translated">설정 한 자식 리턴 코드, &lt;a href=&quot;#subprocess.Popen.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#subprocess.Popen.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; (간접적으로 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; ). &lt;code&gt;None&lt;/code&gt; 값은 프로세스가 아직 종료되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="249b5d2d494ab6f926a71d2362ead22383753022" translate="yes" xml:space="preserve">
          <source>The child&amp;rsquo;s exit code. This will be &lt;code&gt;None&lt;/code&gt; if the process has not yet terminated. A negative value &lt;em&gt;-N&lt;/em&gt; indicates that the child was terminated by signal &lt;em&gt;N&lt;/em&gt;.</source>
          <target state="translated">자녀의 종료 코드. 이 없을 것 &lt;code&gt;None&lt;/code&gt; 프로세스가 아직 종료되지 않은 경우. 음수 값 &lt;em&gt;-N&lt;/em&gt; 은 자식이 신호 &lt;em&gt;N에&lt;/em&gt; 의해 종료되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0c7e9fdca9f228eaff4bb459dac6747ec6ddefb6" translate="yes" xml:space="preserve">
          <source>The choice of which database package will be used (such as &lt;a href=&quot;dbm#module-dbm.ndbm&quot;&gt;&lt;code&gt;dbm.ndbm&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;dbm#module-dbm.gnu&quot;&gt;&lt;code&gt;dbm.gnu&lt;/code&gt;&lt;/a&gt;) depends on which interface is available. Therefore it is not safe to open the database directly using &lt;a href=&quot;dbm#module-dbm&quot;&gt;&lt;code&gt;dbm&lt;/code&gt;&lt;/a&gt;. The database is also (unfortunately) subject to the limitations of &lt;a href=&quot;dbm#module-dbm&quot;&gt;&lt;code&gt;dbm&lt;/code&gt;&lt;/a&gt;, if it is used &amp;mdash; this means that (the pickled representation of) the objects stored in the database should be fairly small, and in rare cases key collisions may cause the database to refuse updates.</source>
          <target state="translated">사용할 데이터베이스 패키지 ( &lt;a href=&quot;dbm#module-dbm.ndbm&quot;&gt; &lt;code&gt;dbm.ndbm&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;dbm#module-dbm.gnu&quot;&gt; &lt;code&gt;dbm.gnu&lt;/code&gt; 등&lt;/a&gt; )의 선택은 사용 가능한 인터페이스에 따라 다릅니다. 따라서 &lt;a href=&quot;dbm#module-dbm&quot;&gt; &lt;code&gt;dbm&lt;/code&gt; 을&lt;/a&gt; 사용하여 데이터베이스를 직접 여는 것은 안전하지 않습니다 . 데이터베이스는 (불행히도) &lt;a href=&quot;dbm#module-dbm&quot;&gt; &lt;code&gt;dbm&lt;/code&gt; &lt;/a&gt; 이 사용되는 경우 제한 사항에 종속 됩니다. 이는 데이터베이스에 저장된 객체의 (선택된 표현)이 상당히 작아야하며 드물게 키 충돌로 인해 데이터베이스가 손상 될 수 있음을 의미합니다. 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="641b5aed9850d067945c10edf2925a45f43bfb8b" translate="yes" xml:space="preserve">
          <source>The chronological synopsis of the underlying operation is as follows:</source>
          <target state="translated">기본 조작의 시간순으로 시놉시스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5e64182f2236479d6838cc99f8595dca788e504" translate="yes" xml:space="preserve">
          <source>The class &lt;a href=&quot;#msilib.CAB&quot;&gt;&lt;code&gt;CAB&lt;/code&gt;&lt;/a&gt; represents a CAB file. During MSI construction, files will be added simultaneously to the &lt;code&gt;Files&lt;/code&gt; table, and to a CAB file. Then, when all files have been added, the CAB file can be written, then added to the MSI file.</source>
          <target state="translated">&lt;a href=&quot;#msilib.CAB&quot;&gt; &lt;code&gt;CAB&lt;/code&gt; &lt;/a&gt; 클래스 는 CAB 파일을 나타냅니다. MSI 구성 중에 파일은 &lt;code&gt;Files&lt;/code&gt; 테이블과 CAB 파일 에 동시에 추가 됩니다. 그런 다음 모든 파일이 추가되면 CAB 파일을 작성한 다음 MSI 파일에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc389f3d71edbec0527ca0760a3cd2d7c5166d0" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Color&lt;/code&gt; is an &lt;em&gt;enumeration&lt;/em&gt; (or &lt;em&gt;enum&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;Color&lt;/code&gt; 클래스 는 &lt;em&gt;열거 형입니다&lt;/em&gt; (또는 &lt;em&gt;열거 형&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="f9d013c76081da9c5c270257f29700914efbf655" translate="yes" xml:space="preserve">
          <source>The class attribute &lt;code&gt;C.z&lt;/code&gt; will be &lt;code&gt;10&lt;/code&gt;, the class attribute &lt;code&gt;C.t&lt;/code&gt; will be &lt;code&gt;20&lt;/code&gt;, and the class attributes &lt;code&gt;C.x&lt;/code&gt; and &lt;code&gt;C.y&lt;/code&gt; will not be set.</source>
          <target state="translated">클래스 속성 &lt;code&gt;C.z&lt;/code&gt; 는 &lt;code&gt;10&lt;/code&gt; 이고 클래스 속성 &lt;code&gt;C.t&lt;/code&gt; 는 &lt;code&gt;20&lt;/code&gt; 이며 클래스 속성 &lt;code&gt;C.x&lt;/code&gt; 및 &lt;code&gt;C.y&lt;/code&gt; 는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35421f70e067873d5f1e6c9a350a9cd53c04e5f2" translate="yes" xml:space="preserve">
          <source>The class can be used to simulate nested scopes and is useful in templating.</source>
          <target state="translated">이 클래스는 중첩 범위를 시뮬레이션하는 데 사용할 수 있으며 템플릿에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="36961ba5b73fc5b81b86c2c4a82a8030e61ec555" translate="yes" xml:space="preserve">
          <source>The class for reading and writing ZIP files. See section &lt;a href=&quot;#zipfile-objects&quot;&gt;ZipFile Objects&lt;/a&gt; for constructor details.</source>
          <target state="translated">ZIP 파일을 읽고 쓰는 클래스입니다. 생성자 세부 사항은 &lt;a href=&quot;#zipfile-objects&quot;&gt;ZipFile 객체&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d13bab7dac8afe400af05e5ac5c428448bda17c6" translate="yes" xml:space="preserve">
          <source>The class hierarchy for built-in exceptions is:</source>
          <target state="translated">내장 예외의 클래스 계층 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f62ddfd2faaa7f84859ae34b4dabf08d739e4525" translate="yes" xml:space="preserve">
          <source>The class hierarchy looks complicated, but in actual practice, application programmers almost always refer to the classes at the very bottom of the hierarchy.</source>
          <target state="translated">클래스 계층 구조는 복잡해 보이지만 실제로는 응용 프로그램 프로그래머는 거의 항상 계층 구조의 맨 아래에있는 클래스를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="11acc8f9993621da6ab27b43e0137b38b7b7a4a1" translate="yes" xml:space="preserve">
          <source>The class implementing primitive lock objects. Once a thread has acquired a lock, subsequent attempts to acquire it block, until it is released; any thread may release it.</source>
          <target state="translated">기본 잠금 객체를 구현하는 클래스입니다. 스레드가 잠금을 획득하면 이후에 해제 될 때까지 해당 블록을 확보하려고 시도합니다. 실이 풀릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97d60cfb78fc29a2188c1e8e530bba513612e7fc" translate="yes" xml:space="preserve">
          <source>The class must define one of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt;. In addition, the class should supply an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">클래스는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; 중 하나를 정의해야합니다 . 또한 클래스는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 메서드를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a554b687dbf11ba71cc8de41c11ea71e511af98b" translate="yes" xml:space="preserve">
          <source>The class of the original traceback.</source>
          <target state="translated">원래 역 추적의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6f41a7aa24987af381eb3cfdc36177bde5d48ab8" translate="yes" xml:space="preserve">
          <source>The class of the result returned by &lt;a href=&quot;#multiprocessing.pool.Pool.apply_async&quot;&gt;&lt;code&gt;Pool.apply_async()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.pool.Pool.map_async&quot;&gt;&lt;code&gt;Pool.map_async()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool.apply_async&quot;&gt; &lt;code&gt;Pool.apply_async()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#multiprocessing.pool.Pool.map_async&quot;&gt; &lt;code&gt;Pool.map_async()&lt;/code&gt; &lt;/a&gt; 반환 한 결과의 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="f996acfc2842340ff19f3be54d9a7bbdc048eb8b" translate="yes" xml:space="preserve">
          <source>The class provides the following concrete implementations of the abstract methods of &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 의 추상 메소드를 다음과 같이 구체적으로 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="5dccf24c2a64fd1d1642a87c5b4ceefbc8b4548b" translate="yes" xml:space="preserve">
          <source>The class setting can be overridden in individual test methods by assigning an instance attribute, self.longMessage, to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; before calling the assert methods.</source>
          <target state="translated">assert 메소드를 호출하기 전에 인스턴스 속성 self.longMessage를 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 에 지정하여 개별 테스트 메소드에서 클래스 설정을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fb7f174a74b65f3dd94a096df16ea30953a0068" translate="yes" xml:space="preserve">
          <source>The class setting gets reset before each test call.</source>
          <target state="translated">클래스 설정은 각 테스트 호출 전에 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9f589d651376efd47cd3c71b4a534513e314e255" translate="yes" xml:space="preserve">
          <source>The class to which a class instance belongs.</source>
          <target state="translated">클래스 인스턴스가 속한 클래스</target>
        </trans-unit>
        <trans-unit id="355cb42d141ca89adac71b050c3ab2434b32b6ee" translate="yes" xml:space="preserve">
          <source>The class used to represent an address group. The general form of an address group is:</source>
          <target state="translated">주소 그룹을 나타내는 데 사용되는 클래스입니다. 주소 그룹의 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4a0b7dcb2051eb55138851ecdd24023ca364443" translate="yes" xml:space="preserve">
          <source>The class used to represent an email address. The general form of an address is:</source>
          <target state="translated">이메일 주소를 나타내는 데 사용되는 클래스입니다. 주소의 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfa706500f9a8aaf4d9b36f7e8cf2f4edccd139d" translate="yes" xml:space="preserve">
          <source>The class which implements the sequence behavior provided by the module is available for subclassing as well:</source>
          <target state="translated">모듈이 제공하는 시퀀스 동작을 구현하는 클래스는 서브 클래 싱에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aae6ed8b229fce1c1f5a84dd0061e129c39af6d2" translate="yes" xml:space="preserve">
          <source>The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used &amp;mdash; the other common server configuration is to treat special extensions as denoting CGI scripts.</source>
          <target state="translated">그러나 클래스는 CGI 스크립트라고 생각되면 파일로 제공하는 대신 CGI 스크립트를 실행합니다. 디렉토리 기반 CGI 만 사용됩니다. 다른 일반적인 서버 구성은 특수 확장을 CGI 스크립트를 나타내는 것으로 취급하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14895e9455625ea3905a043291b8d94e88a9a62c" translate="yes" xml:space="preserve">
          <source>The class, &lt;a href=&quot;#collections.UserDict&quot;&gt;&lt;code&gt;UserDict&lt;/code&gt;&lt;/a&gt; acts as a wrapper around dictionary objects. The need for this class has been partially supplanted by the ability to subclass directly from &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt;; however, this class can be easier to work with because the underlying dictionary is accessible as an attribute.</source>
          <target state="translated">&lt;a href=&quot;#collections.UserDict&quot;&gt; &lt;code&gt;UserDict&lt;/code&gt; &lt;/a&gt; 클래스는 사전 개체 주위의 래퍼 역할을합니다. 이 클래스의 필요성은 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 에서 직접 서브 클래스 할 수있는 기능으로 부분적으로 대체되었습니다 . 그러나 기본 사전에 속성으로 액세스 할 수 있으므로이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d174a1d7f851da4b93f967fb6954b8658cb60437" translate="yes" xml:space="preserve">
          <source>The class, &lt;a href=&quot;#collections.UserString&quot;&gt;&lt;code&gt;UserString&lt;/code&gt;&lt;/a&gt; acts as a wrapper around string objects. The need for this class has been partially supplanted by the ability to subclass directly from &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;; however, this class can be easier to work with because the underlying string is accessible as an attribute.</source>
          <target state="translated">&lt;a href=&quot;#collections.UserString&quot;&gt; &lt;code&gt;UserString&lt;/code&gt; &lt;/a&gt; 클래스는 문자열 객체의 래퍼 역할을합니다. 이 클래스에 대한 요구는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 에서 직접 서브 클래스 할 수있는 기능으로 부분적으로 대체되었습니다 . 그러나 기본 문자열을 속성으로 액세스 할 수 있으므로이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5500c02e097010b4c8f6204fff9a65578fc826eb" translate="yes" xml:space="preserve">
          <source>The class-based API of the &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module gives you more flexibility and greater convenience than the GNU &lt;strong&gt;gettext&lt;/strong&gt; API. It is the recommended way of localizing your Python applications and modules. &lt;code&gt;gettext&lt;/code&gt; defines a &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt;&lt;code&gt;GNUTranslations&lt;/code&gt;&lt;/a&gt; class which implements the parsing of GNU &lt;code&gt;.mo&lt;/code&gt; format files, and has methods for returning strings. Instances of this class can also install themselves in the built-in namespace as the function &lt;code&gt;_()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈 의 클래스 기반 API 는 GNU &lt;strong&gt;gettext&lt;/strong&gt; API 보다 더 많은 유연성과 편리 성을 제공합니다 . Python 응용 프로그램 및 모듈을 지역화하는 것이 좋습니다. &lt;code&gt;gettext&lt;/code&gt; 는 GNU &lt;code&gt;.mo&lt;/code&gt; 형식 파일 의 구문 분석을 구현하고 문자열을 리턴하는 메소드가 있는 &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt; &lt;code&gt;GNUTranslations&lt;/code&gt; &lt;/a&gt; 클래스를 정의합니다 . 이 클래스의 인스턴스는 내장 네임 스페이스에 &lt;code&gt;_()&lt;/code&gt; 함수로 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c13471f17673e1d2e66bc6085c5a5e90090a6bc9" translate="yes" xml:space="preserve">
          <source>The client code for the preceding server:</source>
          <target state="translated">이전 서버의 클라이언트 코드 :</target>
        </trans-unit>
        <trans-unit id="b1f854376f85fdbc545caa4175dd50a74dcba07c" translate="yes" xml:space="preserve">
          <source>The client gets the image and saves it to a file:</source>
          <target state="translated">클라이언트는 이미지를 가져 와서 파일로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="4ab7c3dd55c07004f21171421d1885b6e9798e35" translate="yes" xml:space="preserve">
          <source>The client that interacts with the above server is included in &lt;code&gt;Lib/xmlrpc/client.py&lt;/code&gt;:</source>
          <target state="translated">위의 서버와 상호 작용하는 클라이언트는 &lt;code&gt;Lib/xmlrpc/client.py&lt;/code&gt; 에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="608024e3b56c218bd3b7db1f81cc2c4367596096" translate="yes" xml:space="preserve">
          <source>The clipboard functions are also available in context menus.</source>
          <target state="translated">클립 보드 기능은 상황에 맞는 메뉴에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60463a3de47534f196bb050046587ea8de1a88f2" translate="yes" xml:space="preserve">
          <source>The code for &lt;a href=&quot;#itertools.combinations&quot;&gt;&lt;code&gt;combinations()&lt;/code&gt;&lt;/a&gt; can be also expressed as a subsequence of &lt;a href=&quot;#itertools.permutations&quot;&gt;&lt;code&gt;permutations()&lt;/code&gt;&lt;/a&gt; after filtering entries where the elements are not in sorted order (according to their position in the input pool):</source>
          <target state="translated">&lt;a href=&quot;#itertools.combinations&quot;&gt; &lt;code&gt;combinations()&lt;/code&gt; &lt;/a&gt; 대한 코드 는 요소가 정렬 된 순서가 아닌 항목을 필터링 한 후 (입력 풀의 위치에 따라 &lt;a href=&quot;#itertools.permutations&quot;&gt; &lt;code&gt;permutations()&lt;/code&gt; &lt;/a&gt; 의 하위 시퀀스로 표현 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42d5eab0dfe9ab9a1feea6f7f8bc6b66cd010c25" translate="yes" xml:space="preserve">
          <source>The code for &lt;a href=&quot;#itertools.combinations_with_replacement&quot;&gt;&lt;code&gt;combinations_with_replacement()&lt;/code&gt;&lt;/a&gt; can be also expressed as a subsequence of &lt;a href=&quot;#itertools.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; after filtering entries where the elements are not in sorted order (according to their position in the input pool):</source>
          <target state="translated">&lt;a href=&quot;#itertools.combinations_with_replacement&quot;&gt; &lt;code&gt;combinations_with_replacement()&lt;/code&gt; &lt;/a&gt; 대한 코드 는 요소가 정렬 된 순서가 아닌 항목을 필터링 한 후 (입력 풀의 위치에 따라 &lt;a href=&quot;#itertools.product&quot;&gt; &lt;code&gt;product()&lt;/code&gt; &lt;/a&gt; 의 하위 시퀀스로 표현 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d24621b4d5417bdfdf2582fa71fca0ab60793e2" translate="yes" xml:space="preserve">
          <source>The code for &lt;a href=&quot;#itertools.permutations&quot;&gt;&lt;code&gt;permutations()&lt;/code&gt;&lt;/a&gt; can be also expressed as a subsequence of &lt;a href=&quot;#itertools.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt;, filtered to exclude entries with repeated elements (those from the same position in the input pool):</source>
          <target state="translated">&lt;a href=&quot;#itertools.permutations&quot;&gt; &lt;code&gt;permutations()&lt;/code&gt; &lt;/a&gt; 대한 코드 는 &lt;a href=&quot;#itertools.product&quot;&gt; &lt;code&gt;product()&lt;/code&gt; &lt;/a&gt; 의 하위 시퀀스로 표현 될 수 있으며 반복되는 요소가있는 항목을 제외하도록 필터링됩니다 (입력 풀의 동일한 위치에있는 항목).</target>
        </trans-unit>
        <trans-unit id="703d509dc902a2797f32a1cd580178bc07de8485" translate="yes" xml:space="preserve">
          <source>The code for the sample CGI used in the above example is:</source>
          <target state="translated">위 예제에서 사용한 샘플 CGI 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85fb1e301318f4a3be03adcd9de36da57823dfa5" translate="yes" xml:space="preserve">
          <source>The code handling the FTP protocol cannot differentiate between a file and a directory. This can lead to unexpected behavior when attempting to read a URL that points to a file that is not accessible. If the URL ends in a &lt;code&gt;/&lt;/code&gt;, it is assumed to refer to a directory and will be handled accordingly. But if an attempt to read a file leads to a 550 error (meaning the URL cannot be found or is not accessible, often for permission reasons), then the path is treated as a directory in order to handle the case when a directory is specified by a URL but the trailing &lt;code&gt;/&lt;/code&gt; has been left off. This can cause misleading results when you try to fetch a file whose read permissions make it inaccessible; the FTP code will try to read it, fail with a 550 error, and then perform a directory listing for the unreadable file. If fine-grained control is needed, consider using the &lt;a href=&quot;ftplib#module-ftplib&quot;&gt;&lt;code&gt;ftplib&lt;/code&gt;&lt;/a&gt; module, subclassing &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt;, or changing &lt;em&gt;_urlopener&lt;/em&gt; to meet your needs.</source>
          <target state="translated">FTP 프로토콜을 처리하는 코드는 파일과 디렉토리를 구별 할 수 없습니다. 액세스 할 수없는 파일을 가리키는 URL을 읽으려고하면 예기치 않은 동작이 발생할 수 있습니다. URL이 &lt;code&gt;/&lt;/code&gt; 로 끝나는 경우 디렉토리를 참조하는 것으로 간주되어 그에 따라 처리됩니다. 그러나 파일을 읽으려고 시도 할 때 550 오류가 발생하는 경우 (URL을 찾을 수 없거나 액세스 권한이없는 경우가 많음) 디렉토리가 지정된 경우를 처리하기 위해 경로가 디렉토리로 처리됩니다. URL을 제외한 후행 &lt;code&gt;/&lt;/code&gt; 중단되었습니다. 읽기 권한이있는 파일을 가져올 수없는 경우 잘못된 결과가 발생할 수 있습니다. FTP 코드가이를 읽으려고 시도하고 550 오류와 함께 실패한 다음 읽을 수없는 파일에 대한 디렉토리 목록을 수행합니다. 세분화 된 제어가 필요한 경우 &lt;a href=&quot;ftplib#module-ftplib&quot;&gt; &lt;code&gt;ftplib&lt;/code&gt; &lt;/a&gt; 모듈 사용, &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 서브 클래 싱 또는 &lt;em&gt;_urlopener&lt;/em&gt; 변경을 &lt;em&gt;고려&lt;/em&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="4fd6893c62a4fe9dae88f1c3b04f9d6d6548dc2b" translate="yes" xml:space="preserve">
          <source>The code object has a variable keyword parameter (&lt;code&gt;**kwargs&lt;/code&gt;-like).</source>
          <target state="translated">코드 객체에는 변수 키워드 매개 변수 ( &lt;code&gt;**kwargs&lt;/code&gt; -like)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0979e7acdfaef407b5b5097fc26f4a26bcb8cdf1" translate="yes" xml:space="preserve">
          <source>The code object has a variable positional parameter (&lt;code&gt;*args&lt;/code&gt;-like).</source>
          <target state="translated">코드 객체에는 가변 위치 매개 변수 ( &lt;code&gt;*args&lt;/code&gt; -like)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="080cac35a0f36ed235e2876fd22854eef029be12" translate="yes" xml:space="preserve">
          <source>The code object is optimized, using fast locals.</source>
          <target state="translated">코드 객체는 빠른 로컬을 사용하여 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="47a377ea1cb4376dfc822cfb1e3d5bc1d7585dd2" translate="yes" xml:space="preserve">
          <source>The code supports &lt;a href=&quot;https://tools.ietf.org/html/rfc5321.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5321&lt;/strong&gt;&lt;/a&gt;, plus the &lt;a href=&quot;https://tools.ietf.org/html/rfc1870.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1870&lt;/strong&gt;&lt;/a&gt; SIZE and &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; SMTPUTF8 extensions.</source>
          <target state="translated">이 코드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5321.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5321&lt;/strong&gt;&lt;/a&gt; 과 &lt;a href=&quot;https://tools.ietf.org/html/rfc1870.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1870&lt;/strong&gt;&lt;/a&gt; SIZE 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; SMTPUTF8 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4817874f40ce2ab856a7cb1cf5cd601ddcb8bfd6" translate="yes" xml:space="preserve">
          <source>The collections module offers the following &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;ABCs&lt;/a&gt;:</source>
          <target state="translated">컬렉션 모듈은 다음 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;ABC를&lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3e84acb27476c2c05eba0a4f4a824cd8ec501c13" translate="yes" xml:space="preserve">
          <source>The column corresponding to &lt;em&gt;pos&lt;/em&gt; (may be &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;pos에&lt;/em&gt; 해당하는 열입니다 ( &lt;code&gt;None&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="a56243341a69d0e12d71b0d910747be9b8112c7b" translate="yes" xml:space="preserve">
          <source>The column corresponding to &lt;em&gt;pos&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;pos에&lt;/em&gt; 해당하는 열 입니다.</target>
        </trans-unit>
        <trans-unit id="52291400b098238a6b1adf88eaf1c290f1adcf33" translate="yes" xml:space="preserve">
          <source>The combobox widgets generates a &lt;strong&gt;&amp;lt;&amp;lt;ComboboxSelected&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user selects an element from the list of values.</source>
          <target state="translated">콤보 박스 위젯 은 사용자가 값 목록에서 요소를 선택할 때 &lt;strong&gt;&amp;lt;&amp;lt; ComboboxSelected &amp;gt;&amp;gt;&lt;/strong&gt; 가상 이벤트를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="0a0ffc5780ada254563235dcef8afc5b94088687" translate="yes" xml:space="preserve">
          <source>The command line can also be used for test discovery, for running all of the tests in a project or just a subset.</source>
          <target state="translated">명령 줄은 프로젝트에서 또는 모든 하위 집합에서 모든 테스트를 실행하기 위해 테스트 검색에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d6a9ddd026e421ebebeb4fd4a12d14a163fea6c" translate="yes" xml:space="preserve">
          <source>The command line interface is invoked using the interpreter&amp;rsquo;s &lt;code&gt;-m&lt;/code&gt; switch.</source>
          <target state="translated">명령 행 인터페이스는 인터프리터의 &lt;code&gt;-m&lt;/code&gt; 스위치를 사용하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ad815c39bd5fc01a37786842578018d08d7a616" translate="yes" xml:space="preserve">
          <source>The command or option attempted is not supported by the server.</source>
          <target state="translated">시도한 명령 또는 옵션이 서버에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b2372b300214e5a9d80b5b465939fec489d9cce" translate="yes" xml:space="preserve">
          <source>The command, if run with &lt;code&gt;-h&lt;/code&gt;, will show the available options:</source>
          <target state="translated">&lt;code&gt;-h&lt;/code&gt; 와 함께 실행하면 명령에 사용 가능한 옵션이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e345e636adf7e9a665df637497de8ab138640b2" translate="yes" xml:space="preserve">
          <source>The commands recognized by the debugger are listed below. Most commands can be abbreviated to one or two letters as indicated; e.g. &lt;code&gt;h(elp)&lt;/code&gt; means that either &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;help&lt;/code&gt; can be used to enter the help command (but not &lt;code&gt;he&lt;/code&gt; or &lt;code&gt;hel&lt;/code&gt;, nor &lt;code&gt;H&lt;/code&gt; or &lt;code&gt;Help&lt;/code&gt; or &lt;code&gt;HELP&lt;/code&gt;). Arguments to commands must be separated by whitespace (spaces or tabs). Optional arguments are enclosed in square brackets (&lt;code&gt;[]&lt;/code&gt;) in the command syntax; the square brackets must not be typed. Alternatives in the command syntax are separated by a vertical bar (&lt;code&gt;|&lt;/code&gt;).</source>
          <target state="translated">디버거가 인식하는 명령은 다음과 같습니다. 대부분의 명령은 표시된대로 한두 글자로 축약 될 수 있습니다. 예를 들어 &lt;code&gt;h(elp)&lt;/code&gt; 는 &lt;code&gt;h&lt;/code&gt; 또는 &lt;code&gt;help&lt;/code&gt; 를 사용하여 help 명령을 입력 할 수 있음을 의미합니다 (단 , &lt;code&gt;he&lt;/code&gt; 또는 &lt;code&gt;hel&lt;/code&gt; 또는 &lt;code&gt;H&lt;/code&gt; 또는 &lt;code&gt;Help&lt;/code&gt; 또는 &lt;code&gt;HELP&lt;/code&gt; 는 아님). 명령에 대한 인수는 공백 (공백 또는 탭)으로 구분해야합니다. 선택적 인수는 명령 구문에서 대괄호 ( &lt;code&gt;[]&lt;/code&gt; )로 묶습니다 . 대괄호는 입력하지 않아야합니다. 명령 구문의 대안은 세로 막대 ( &lt;code&gt;|&lt;/code&gt; ) 로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b0c4e95df2cc092cf548fbafd773a5feced6509" translate="yes" xml:space="preserve">
          <source>The comment associated with the ZIP file as a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. If assigning a comment to a &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; instance created with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;, it should be no longer than 65535 bytes. Comments longer than this will be truncated.</source>
          <target state="translated">ZIP 파일과 연관된 주석은 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체입니다. &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 모드로 작성된 &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; &lt;/a&gt; 인스턴스에 주석을 지정하는 경우 65535 바이트를 넘지 않아야합니다. 이보다 긴 주석은 잘립니다.</target>
        </trans-unit>
        <trans-unit id="c3d4ab182c2db8443dd330fa9a538692f30951a8" translate="yes" xml:space="preserve">
          <source>The comparison between expected outputs and actual outputs is done by an &lt;a href=&quot;#doctest.OutputChecker&quot;&gt;&lt;code&gt;OutputChecker&lt;/code&gt;&lt;/a&gt;. This comparison may be customized with a number of option flags; see section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt; for more information. If the option flags are insufficient, then the comparison may also be customized by passing a subclass of &lt;a href=&quot;#doctest.OutputChecker&quot;&gt;&lt;code&gt;OutputChecker&lt;/code&gt;&lt;/a&gt; to the constructor.</source>
          <target state="translated">예상 출력과 실제 출력 간의 비교는 &lt;a href=&quot;#doctest.OutputChecker&quot;&gt; &lt;code&gt;OutputChecker&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다 . 이 비교는 많은 옵션 플래그로 사용자 정의 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션 을 참조하십시오. 옵션 플래그가 충분하지 않은 경우 &lt;a href=&quot;#doctest.OutputChecker&quot;&gt; &lt;code&gt;OutputChecker&lt;/code&gt; &lt;/a&gt; 의 하위 클래스를 생성자 에 전달하여 비교를 사용자 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79c38cc9654a2b0cf446da2a3b3b6ba57617ee75" translate="yes" xml:space="preserve">
          <source>The comparisons &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;&lt;em&gt;always&lt;/em&gt; return a &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, no matter the type of the compared object:</source>
          <target state="translated">비교 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 는 비교 객체의 유형에 관계없이 &lt;em&gt;항상 &lt;/em&gt;&lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; 을&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8f4b16d657cdc57fcbb86894a1bc1965b3eac791" translate="yes" xml:space="preserve">
          <source>The compiled code object.</source>
          <target state="translated">컴파일 된 코드 객체</target>
        </trans-unit>
        <trans-unit id="cffbd898eeee4166206889c430a7c4f2732ae94c" translate="yes" xml:space="preserve">
          <source>The compiled versions of the most recent format strings passed to &lt;a href=&quot;#struct.Struct&quot;&gt;&lt;code&gt;Struct&lt;/code&gt;&lt;/a&gt; and the module-level functions are cached, so programs that use only a few format strings needn&amp;rsquo;t worry about reusing a single &lt;a href=&quot;#struct.Struct&quot;&gt;&lt;code&gt;Struct&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#struct.Struct&quot;&gt; &lt;code&gt;Struct&lt;/code&gt; 에&lt;/a&gt; 전달 된 최신 형식 문자열 과 모듈 수준 함수 의 컴파일 된 버전 이 캐시되므로 몇 가지 형식 문자열 만 사용하는 프로그램은 단일 &lt;a href=&quot;#struct.Struct&quot;&gt; &lt;code&gt;Struct&lt;/code&gt; &lt;/a&gt; 인스턴스의 재사용에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ab52247f4c90217fe220c0e00be40b43bc3d4ecb" translate="yes" xml:space="preserve">
          <source>The compiled versions of the most recent patterns passed to &lt;a href=&quot;#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and the module-level matching functions are cached, so programs that use only a few regular expressions at a time needn&amp;rsquo;t worry about compiling regular expressions.</source>
          <target state="translated">&lt;a href=&quot;#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt; 전달 된 가장 최근 패턴의 컴파일 된 버전 과 모듈 수준 일치 함수가 캐시되므로 한 번에 몇 개의 정규 표현식 만 사용하는 프로그램은 정규 표현식 컴파일에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a86d93007da3d0cb6dd563da533af1864349897" translate="yes" xml:space="preserve">
          <source>The complete signature is:</source>
          <target state="translated">완전한 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52f0ad2782ff79ba1413d52ccaa72b70245608bf" translate="yes" xml:space="preserve">
          <source>The complex type is described in &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;Numeric Types &amp;mdash; int, float, complex&lt;/a&gt;.</source>
          <target state="translated">복합 유형은 &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;숫자 유형-int, float, complex에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8423b10aee34a14219c852ad4786792dda570ef3" translate="yes" xml:space="preserve">
          <source>The compression settings can be specified either as a preset compression level (with the &lt;em&gt;preset&lt;/em&gt; argument), or in detail as a custom filter chain (with the &lt;em&gt;filters&lt;/em&gt; argument).</source>
          <target state="translated">압축 설정은 사전 설정 압축 수준 ( &lt;em&gt;사전 설정&lt;/em&gt; 인수 포함) 또는 사용자 정의 필터 체인 ( &lt;em&gt;필터&lt;/em&gt; 인수 사용) 으로 자세히 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa97a83ece05b5a0a5d5b194b33927d529e0027e" translate="yes" xml:space="preserve">
          <source>The compressor cannot be used after this method has been called.</source>
          <target state="translated">이 메소드를 호출 한 후에는 압축기를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f2141b3d65ba701015cb35367a7f27ebd2455cf" translate="yes" xml:space="preserve">
          <source>The compressor object may not be used after this method has been called.</source>
          <target state="translated">이 메소드를 호출 한 후에는 압축기 객체를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64c7be1f9a57000f18a2a61a8fefda7d5860289a" translate="yes" xml:space="preserve">
          <source>The concatenation of the &lt;a href=&quot;#string.ascii_lowercase&quot;&gt;&lt;code&gt;ascii_lowercase&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#string.ascii_uppercase&quot;&gt;&lt;code&gt;ascii_uppercase&lt;/code&gt;&lt;/a&gt; constants described below. This value is not locale-dependent.</source>
          <target state="translated">아래에 설명 된 &lt;a href=&quot;#string.ascii_lowercase&quot;&gt; &lt;code&gt;ascii_lowercase&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#string.ascii_uppercase&quot;&gt; &lt;code&gt;ascii_uppercase&lt;/code&gt; &lt;/a&gt; 상수 의 연결 이 값은 로캘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ca85ed6988e6d21605f779695c181fffd7ea4c90" translate="yes" xml:space="preserve">
          <source>The concatenation of the drive and root:</source>
          <target state="translated">드라이브와 루트의 연결 :</target>
        </trans-unit>
        <trans-unit id="e092972f0114d0d2ff37172e3be9c56bde7107c7" translate="yes" xml:space="preserve">
          <source>The conceptual model provided by a &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; object is that of an ordered dictionary of headers with additional methods for accessing both specialized information from the headers, for accessing the payload, for generating a serialized version of the message, and for recursively walking over the object tree. Note that duplicate headers are supported but special methods must be used to access them.</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체가 제공하는 개념적 모델 은 헤더에서 특수화 된 정보에 액세스하고, 페이로드에 액세스하고, 메시지의 직렬화 된 버전을 생성하고, 객체 트리를 재귀 적으로 탐색하기위한 추가 방법이있는 정렬 된 헤더 사전 모델입니다. . 중복 헤더는 지원되지만 특별한 방법을 사용하여 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa9fdff52eeada3a2000fe3606dc76d6f1a9438c" translate="yes" xml:space="preserve">
          <source>The conceptual model provided by an &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object is that of an ordered dictionary of headers coupled with a &lt;em&gt;payload&lt;/em&gt; that represents the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; body of the message, which might be a list of sub-&lt;code&gt;EmailMessage&lt;/code&gt; objects. In addition to the normal dictionary methods for accessing the header names and values, there are methods for accessing specialized information from the headers (for example the MIME content type), for operating on the payload, for generating a serialized version of the message, and for recursively walking over the object tree.</source>
          <target state="translated">&lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 객체가 제공하는 개념적 모델 은 메시지 의 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 본문 을 나타내는 &lt;em&gt;페이로드&lt;/em&gt; 와 연결된 헤더의 정렬 된 사전 사전 모델이며 , 하위 &lt;code&gt;EmailMessage&lt;/code&gt; 객체 목록 일 수 있습니다 . 헤더 이름과 값에 액세스하기위한 일반적인 사전 방법 외에도 페이로드에서 작동하고 메시지의 직렬화 된 버전을 생성하기 위해 헤더에서 특수 정보 (예 : MIME 컨텐츠 유형)에 액세스하는 방법이 있습니다. 객체 트리를 재귀 적으로 걷습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a7ce1e8829b2baa1cee35ef7caa7def938910c0" translate="yes" xml:space="preserve">
          <source>The concrete class which &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder.find_spec&quot;&gt;&lt;code&gt;find_spec()&lt;/code&gt;&lt;/a&gt; should return instances of.</source>
          <target state="translated">&lt;a href=&quot;importlib#importlib.abc.MetaPathFinder.find_spec&quot;&gt; &lt;code&gt;find_spec()&lt;/code&gt; &lt;/a&gt; 의 구체적인 클래스 는 인스턴스를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b47d19d847be464de32c419aa4cb13a86a81fe9" translate="yes" xml:space="preserve">
          <source>The concurrent package</source>
          <target state="translated">동시 패키지</target>
        </trans-unit>
        <trans-unit id="570b777eec02b54837ba5c38cb8c956eb69457cf" translate="yes" xml:space="preserve">
          <source>The condition that causes a break.</source>
          <target state="translated">휴식을 일으키는 조건.</target>
        </trans-unit>
        <trans-unit id="12bf8455ae3938296c7e397895720025d423f807" translate="yes" xml:space="preserve">
          <source>The configuration &lt;em&gt;options&lt;/em&gt; are as follows:</source>
          <target state="translated">구성 &lt;em&gt;옵션&lt;/em&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59c7bb6eed19501d87b1a0d7f39e43f6d3d05ab2" translate="yes" xml:space="preserve">
          <source>The configuration file for &lt;code&gt;libedit&lt;/code&gt; is different from that of GNU readline. If you programmatically load configuration strings you can check for the text &amp;ldquo;libedit&amp;rdquo; in &lt;code&gt;readline.__doc__&lt;/code&gt; to differentiate between GNU readline and libedit.</source>
          <target state="translated">&lt;code&gt;libedit&lt;/code&gt; 의 구성 파일 은 GNU readline 의 구성 파일과 다릅니다 . 프로그래밍 방식으로 구성 문자열을로드하는 경우 &lt;code&gt;readline.__doc__&lt;/code&gt; 에서&amp;ldquo;libedit&amp;rdquo;텍스트를 확인하여 GNU readline과 libedit를 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b52acbb2a777e6ab327fff01a2fbdb919c5154" translate="yes" xml:space="preserve">
          <source>The configuration file format understood by &lt;a href=&quot;#logging.config.fileConfig&quot;&gt;&lt;code&gt;fileConfig()&lt;/code&gt;&lt;/a&gt; is based on &lt;a href=&quot;configparser#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; functionality. The file must contain sections called &lt;code&gt;[loggers]&lt;/code&gt;, &lt;code&gt;[handlers]&lt;/code&gt; and &lt;code&gt;[formatters]&lt;/code&gt; which identify by name the entities of each type which are defined in the file. For each such entity, there is a separate section which identifies how that entity is configured. Thus, for a logger named &lt;code&gt;log01&lt;/code&gt; in the &lt;code&gt;[loggers]&lt;/code&gt; section, the relevant configuration details are held in a section &lt;code&gt;[logger_log01]&lt;/code&gt;. Similarly, a handler called &lt;code&gt;hand01&lt;/code&gt; in the &lt;code&gt;[handlers]&lt;/code&gt; section will have its configuration held in a section called &lt;code&gt;[handler_hand01]&lt;/code&gt;, while a formatter called &lt;code&gt;form01&lt;/code&gt; in the &lt;code&gt;[formatters]&lt;/code&gt; section will have its configuration specified in a section called &lt;code&gt;[formatter_form01]&lt;/code&gt;. The root logger configuration must be specified in a section called &lt;code&gt;[logger_root]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#logging.config.fileConfig&quot;&gt; &lt;code&gt;fileConfig()&lt;/code&gt; &lt;/a&gt; 가 이해하는 구성 파일 형식은 구성 프로그램 기능을 기반으로 &lt;a href=&quot;configparser#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; . 파일에는 파일 에 정의 된 각 유형의 엔티티를 이름으로 식별하는 &lt;code&gt;[loggers]&lt;/code&gt; , &lt;code&gt;[handlers]&lt;/code&gt; 및 &lt;code&gt;[formatters]&lt;/code&gt; 섹션이 포함되어야합니다 . 이러한 각 엔터티에는 해당 엔터티 구성 방법을 식별하는 별도의 섹션이 있습니다. 따라서 &lt;code&gt;[loggers]&lt;/code&gt; 섹션 에서 이름이 &lt;code&gt;log01&lt;/code&gt; 인로거의 경우 관련 구성 세부 사항은 &lt;code&gt;[logger_log01]&lt;/code&gt; 섹션에 보유됩니다 . 마찬가지로 &lt;code&gt;[handlers]&lt;/code&gt; 에서 &lt;code&gt;hand01&lt;/code&gt; 이라는 핸들러섹션 구성이라는 부에 유지 한 것이다 &lt;code&gt;[handler_hand01]&lt;/code&gt; 포맷터 호출 동안 &lt;code&gt;form01&lt;/code&gt; 에서 &lt;code&gt;[formatters]&lt;/code&gt; 구성라는 절에 명시된 것 부 &lt;code&gt;[formatter_form01]&lt;/code&gt; . 루트 로거 구성은 &lt;code&gt;[logger_root]&lt;/code&gt; 라는 섹션에 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9b651af8db79babcce4e20eeaec528de157decc" translate="yes" xml:space="preserve">
          <source>The configuration options in Tk are given in lists of hyphened tags followed by values. In Tkinter, options are specified as keyword-arguments in the instance constructor, and keyword-args for configure calls or as instance indices, in dictionary style, for established instances. See section &lt;a href=&quot;#tkinter-setting-options&quot;&gt;Setting Options&lt;/a&gt; on setting options.</source>
          <target state="translated">Tk의 구성 옵션은 하이픈 태그 목록과 값이 제공됩니다. Tkinter에서 옵션은 인스턴스 생성자에서 키워드 인수로 지정되고, 구성된 호출의 경우 키워드 인수로 설정되거나, 설정된 인스턴스의 경우 사전 스타일로 사전 색인으로 키워드 인덱스로 지정됩니다. &lt;a href=&quot;#tkinter-setting-options&quot;&gt;옵션 설정&lt;/a&gt; 에 대한 설정 옵션 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1a61b4a52925d6e4ff824c49fb0c8d7e73702dc" translate="yes" xml:space="preserve">
          <source>The configuring dict is searched for keys &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;datefmt&lt;/code&gt; (with defaults of &lt;code&gt;None&lt;/code&gt;) and these are used to construct a &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">구성 dict는 키 &lt;code&gt;format&lt;/code&gt; 및 &lt;code&gt;datefmt&lt;/code&gt; (기본값은 &lt;code&gt;None&lt;/code&gt; )를 검색하며 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 인스턴스 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="05ad2ef2a6dd6a0426dfded13d5ea25a19a75ea1" translate="yes" xml:space="preserve">
          <source>The configuring dict is searched for the following keys:</source>
          <target state="translated">구성 dict에서 다음 키를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d6070b1488ec8a72afe1a4161755ca71fa01d4f9" translate="yes" xml:space="preserve">
          <source>The configuring dict is searched for the key &lt;code&gt;name&lt;/code&gt; (defaulting to the empty string) and this is used to construct a &lt;a href=&quot;logging#logging.Filter&quot;&gt;&lt;code&gt;logging.Filter&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">구성 dict에서 키 &lt;code&gt;name&lt;/code&gt; (기본값은 빈 문자열)을 검색하고 &lt;a href=&quot;logging#logging.Filter&quot;&gt; &lt;code&gt;logging.Filter&lt;/code&gt; &lt;/a&gt; 인스턴스 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="22098bdd88d261e748ed7287ce44dd49d82e7d6e" translate="yes" xml:space="preserve">
          <source>The connection is established and a &lt;a href=&quot;asyncio-protocol#asyncio-transport&quot;&gt;transport&lt;/a&gt; is created for it.</source>
          <target state="translated">연결이 설정되고 &lt;a href=&quot;asyncio-protocol#asyncio-transport&quot;&gt;전송&lt;/a&gt; 이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ad28af9c1892c375346d6b75312ea79291b1c88f" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory. This is &lt;code&gt;'.'&lt;/code&gt; for Windows and POSIX. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">운영 체제에서 현재 디렉토리를 참조하기 위해 사용하는 상수 문자열. 이것은 &lt;code&gt;'.'&lt;/code&gt; 입니다Windows 및 POSIX의 경우. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="83f1f1fda282af44b7cfb075ada1e9aaf0f04e93" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory. This is &lt;code&gt;'..'&lt;/code&gt; for Windows and POSIX. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">운영 체제에서 상위 디렉토리를 참조하기 위해 사용하는 상수 문자열. 이다 &lt;code&gt;'..'&lt;/code&gt; Windows 및 POSIX 위해. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="01770734e88c7a4ab5e6980d5f00daa7ef0c1c5f" translate="yes" xml:space="preserve">
          <source>The constants defined in this module are:</source>
          <target state="translated">이 모듈에 정의 된 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b08a2e82bd5dc334f732ff6ab5b3f9da3808da16" translate="yes" xml:space="preserve">
          <source>The constants in the model type group are:</source>
          <target state="translated">모델 유형 그룹의 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddd636a4f621e05ed2865944f1e483ab09fd535" translate="yes" xml:space="preserve">
          <source>The constants in the quantifier group are:</source>
          <target state="translated">수량 자 그룹의 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a15e83ade8de633314e05199e3e1378b4c6379a" translate="yes" xml:space="preserve">
          <source>The constants in this section are only relevant for the C module. They are also included in the pure Python version for compatibility.</source>
          <target state="translated">이 섹션의 상수는 C 모듈에만 관련이 있습니다. 호환성을 위해 순수 Python 버전에도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb2fb40748577c1742ac7584db3943ced5d2257" translate="yes" xml:space="preserve">
          <source>The constructor accepts any object with a truth value.</source>
          <target state="translated">생성자는 true 값을 가진 모든 개체를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="de65c1ef0adbf85286791da99438ac61fbc8f3c0" translate="yes" xml:space="preserve">
          <source>The constructor builds a list whose items are the same and in the same order as &lt;em&gt;iterable&lt;/em&gt;&amp;rsquo;s items. &lt;em&gt;iterable&lt;/em&gt; may be either a sequence, a container that supports iteration, or an iterator object. If &lt;em&gt;iterable&lt;/em&gt; is already a list, a copy is made and returned, similar to &lt;code&gt;iterable[:]&lt;/code&gt;. For example, &lt;code&gt;list('abc')&lt;/code&gt; returns &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; and &lt;code&gt;list( (1, 2, 3) )&lt;/code&gt; returns &lt;code&gt;[1, 2, 3]&lt;/code&gt;. If no argument is given, the constructor creates a new empty list, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">생성자는 &lt;em&gt;반복 가능한&lt;/em&gt; 항목 과 순서가 동일한 항목을 가진 목록을 작성 합니다. &lt;em&gt;iterable&lt;/em&gt; 은 시퀀스, 반복을 지원하는 컨테이너 또는 반복자 객체 일 수 있습니다. 경우 &lt;em&gt;반복 가능한이&lt;/em&gt; 이미 목록, 사본이 만들어지고, 유사 반환 &lt;code&gt;iterable[:]&lt;/code&gt; . 예를 들어 &lt;code&gt;list('abc')&lt;/code&gt; 는 &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; 반환 하고 &lt;code&gt;list( (1, 2, 3) )&lt;/code&gt; 는 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 반환합니다 . 인수가 제공되지 않으면 생성자는 비어있는 새 목록 &lt;code&gt;[]&lt;/code&gt; 을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="29519469d10505e3d049e63dd290612ed49fc46c" translate="yes" xml:space="preserve">
          <source>The constructor builds a tuple whose items are the same and in the same order as &lt;em&gt;iterable&lt;/em&gt;&amp;rsquo;s items. &lt;em&gt;iterable&lt;/em&gt; may be either a sequence, a container that supports iteration, or an iterator object. If &lt;em&gt;iterable&lt;/em&gt; is already a tuple, it is returned unchanged. For example, &lt;code&gt;tuple('abc')&lt;/code&gt; returns &lt;code&gt;('a', 'b', 'c')&lt;/code&gt; and &lt;code&gt;tuple( [1, 2, 3] )&lt;/code&gt; returns &lt;code&gt;(1, 2, 3)&lt;/code&gt;. If no argument is given, the constructor creates a new empty tuple, &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">생성자는 &lt;em&gt;반복 가능한&lt;/em&gt; 항목 과 항목이 동일한 순서로 튜플을 만듭니다 . &lt;em&gt;iterable&lt;/em&gt; 은 시퀀스, 반복을 지원하는 컨테이너 또는 반복자 객체 일 수 있습니다. 경우 &lt;em&gt;반복 가능한이&lt;/em&gt; 이미 터플, 그것은 변화가 반환됩니다. 예를 들어 &lt;code&gt;tuple('abc')&lt;/code&gt; 은 &lt;code&gt;('a', 'b', 'c')&lt;/code&gt; &lt;code&gt;tuple( [1, 2, 3] )&lt;/code&gt; 반환 하고 tuple ([1, 2, 3]) 은 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 반환합니다 . 인수를 지정하지 않으면 생성자는 비어있는 새 튜플 &lt;code&gt;()&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c9dd0eda3540f657a7e0a9a4a8c77a6032885080" translate="yes" xml:space="preserve">
          <source>The constructor creates a &lt;a href=&quot;#io.BufferedReader&quot;&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;/a&gt; for the given readable &lt;em&gt;raw&lt;/em&gt; stream and &lt;em&gt;buffer_size&lt;/em&gt;. If &lt;em&gt;buffer_size&lt;/em&gt; is omitted, &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">생성자 는 지정된 읽을 수있는 &lt;em&gt;원시&lt;/em&gt; 스트림 및 &lt;em&gt;buffer_size에&lt;/em&gt; 대한 &lt;a href=&quot;#io.BufferedReader&quot;&gt; &lt;code&gt;BufferedReader&lt;/code&gt; &lt;/a&gt; 를 작성합니다 . 경우 &lt;em&gt;BUFFER_SIZE은&lt;/em&gt; 생략 &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt; 가&lt;/a&gt; 사용된다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5ff054c7924dc7261d0aed35f217835da758c86" translate="yes" xml:space="preserve">
          <source>The constructor creates a &lt;a href=&quot;#io.BufferedWriter&quot;&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/a&gt; for the given writeable &lt;em&gt;raw&lt;/em&gt; stream. If the &lt;em&gt;buffer_size&lt;/em&gt; is not given, it defaults to &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자 는 지정된 쓰기 가능한 &lt;em&gt;원시&lt;/em&gt; 스트림에 대해 &lt;a href=&quot;#io.BufferedWriter&quot;&gt; &lt;code&gt;BufferedWriter&lt;/code&gt; &lt;/a&gt; 를 작성 합니다. 경우 &lt;em&gt;BUFFER_SIZE는&lt;/em&gt; , 디폴트 주어지지하는 &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt; &lt;/a&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dbdbc1d7bc6e3588721a37331f619e648a20ac7" translate="yes" xml:space="preserve">
          <source>The constructor creates a reader and writer for a seekable raw stream, given in the first argument. If the &lt;em&gt;buffer_size&lt;/em&gt; is omitted it defaults to &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자는 첫 번째 인수에서 주어진 탐색 가능한 원시 스트림에 대한 리더 및 라이터를 작성합니다. &lt;em&gt;buffer_size&lt;/em&gt; 가 생략 되면 기본값은 &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09fba04fdb03d601e27ad6e5c1a62a7c6837bb41" translate="yes" xml:space="preserve">
          <source>The constructor for this class is:</source>
          <target state="translated">이 클래스의 생성자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27d963a1efe9374acd799a7437355a7f128b6742" translate="yes" xml:space="preserve">
          <source>The constructor of a class &lt;code&gt;ast.T&lt;/code&gt; parses its arguments as follows:</source>
          <target state="translated">&lt;code&gt;ast.T&lt;/code&gt; 클래스의 생성자는 다음과 같이 인수를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="bd786e1e93280b6a0e5b1a1fd99c22ce347e8d8f" translate="yes" xml:space="preserve">
          <source>The constructor of a policy class can be passed various keyword arguments. The arguments that may be specified are any non-method properties on this class, plus any additional non-method properties on the concrete class. A value specified in the constructor will override the default value for the corresponding attribute.</source>
          <target state="translated">정책 클래스의 생성자에는 다양한 키워드 인수가 전달 될 수 있습니다. 지정할 수있는 인수는이 클래스의 메소드 이외의 프로퍼티, 그리고 구체적 클래스의 메소드 이외의 프로퍼티입니다. 생성자에 지정된 값은 해당 속성의 기본값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3ee2574b5d9e6bcc9b944e93fc5b27e68e52b42e" translate="yes" xml:space="preserve">
          <source>The constructor often actually returns a subclass of &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;, as described in &lt;a href=&quot;#os-exceptions&quot;&gt;OS exceptions&lt;/a&gt; below. The particular subclass depends on the final &lt;a href=&quot;#OSError.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; value. This behaviour only occurs when constructing &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; directly or via an alias, and is not inherited when subclassing.</source>
          <target state="translated">생성자는 종종 아래 &lt;a href=&quot;#os-exceptions&quot;&gt;OS 예외에&lt;/a&gt; 설명 된대로 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 하위 클래스를 실제로 반환 합니다. 특정 서브 클래스는 최종 &lt;a href=&quot;#OSError.errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 . 이 동작은 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 직접 또는 별명을 통해 구성 할 때만 발생 하며 서브 클래 싱시 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34da053fc68df3d3c1c7315428ce28358a25e31e" translate="yes" xml:space="preserve">
          <source>The constructor parameters have the same meaning as for &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt;, with the exception of &lt;em&gt;return_value&lt;/em&gt; and &lt;em&gt;side_effect&lt;/em&gt; which have no meaning on a non-callable mock.</source>
          <target state="translated">생성자 매개 변수는 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 과 같은 의미를 지니지 만&lt;em&gt; return_value&lt;/em&gt; 및 &lt;em&gt;side_effect&lt;/em&gt; 를 제외하고는 호출 할 수없는 모의에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="92a4c4d75e4bbfdb57df8a0f0ff2b7e566c251f3" translate="yes" xml:space="preserve">
          <source>The constructor parameters have the same meaning as for &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자 매개 변수는 &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="2a6b7b5892a6a7371b6a7eb794526e89b84a8ce7" translate="yes" xml:space="preserve">
          <source>The constructor sets this attribute to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">생성자는이 속성을 &lt;code&gt;True&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="82938dfd4d3b4884cceee3e3895d3aed984dc32f" translate="yes" xml:space="preserve">
          <source>The constructor should always be called with keyword arguments. &lt;em&gt;group&lt;/em&gt; should always be &lt;code&gt;None&lt;/code&gt;; it exists solely for compatibility with &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;target&lt;/em&gt; is the callable object to be invoked by the &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method. It defaults to &lt;code&gt;None&lt;/code&gt;, meaning nothing is called. &lt;em&gt;name&lt;/em&gt; is the process name (see &lt;a href=&quot;#multiprocessing.Process.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; for more details). &lt;em&gt;args&lt;/em&gt; is the argument tuple for the target invocation. &lt;em&gt;kwargs&lt;/em&gt; is a dictionary of keyword arguments for the target invocation. If provided, the keyword-only &lt;em&gt;daemon&lt;/em&gt; argument sets the process &lt;a href=&quot;#multiprocessing.Process.daemon&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; flag to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt; (the default), this flag will be inherited from the creating process.</source>
          <target state="translated">생성자는 항상 키워드 인수로 호출해야합니다. &lt;em&gt;그룹&lt;/em&gt; 은 항상 &lt;code&gt;None&lt;/code&gt; 이어야합니다 . &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 와의 호환성을 위해서만 존재합니다 . &lt;em&gt;target&lt;/em&gt; 은 &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출 될 호출 가능 객체 입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 이며 아무 것도 호출되지 않습니다. &lt;em&gt;name&lt;/em&gt; 은 프로세스 이름입니다 ( 자세한 내용 은 &lt;a href=&quot;#multiprocessing.Process.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 참조). &lt;em&gt;args&lt;/em&gt; 는 대상 호출에 대한 인수 튜플입니다. &lt;em&gt;kwargs&lt;/em&gt; 는 대상 호출을위한 키워드 인수 사전입니다. 제공된 경우 키워드 전용 &lt;em&gt;데몬&lt;/em&gt; 인수는 프로세스 &lt;a href=&quot;#multiprocessing.Process.daemon&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt; 플래그를 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; . 경우 &lt;code&gt;None&lt;/code&gt; (기본값),이 플래그는 프로세스 작성에서 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a46ef7f69310a283260ddb83ad03cfa971b3e1" translate="yes" xml:space="preserve">
          <source>The constructor takes a single argument which is the template string.</source>
          <target state="translated">생성자는 템플릿 문자열 인 단일 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="85fb777e8dbaf45dd04245b451b4e3b6e600f758" translate="yes" xml:space="preserve">
          <source>The constructor takes a statement to be timed, an additional statement used for setup, and a timer function. Both statements default to &lt;code&gt;'pass'&lt;/code&gt;; the timer function is platform-dependent (see the module doc string). &lt;em&gt;stmt&lt;/em&gt; and &lt;em&gt;setup&lt;/em&gt; may also contain multiple statements separated by &lt;code&gt;;&lt;/code&gt; or newlines, as long as they don&amp;rsquo;t contain multi-line string literals. The statement will by default be executed within timeit&amp;rsquo;s namespace; this behavior can be controlled by passing a namespace to &lt;em&gt;globals&lt;/em&gt;.</source>
          <target state="translated">생성자는 시간을 지정할 명령문, 설정에 사용되는 추가 명령문 및 타이머 함수를 사용합니다. 두 명령문 모두 기본값은 &lt;code&gt;'pass'&lt;/code&gt; 입니다 . 타이머 기능은 플랫폼에 따라 다릅니다 (모듈 문서 문자열 참조). &lt;em&gt;stmt&lt;/em&gt; 및 &lt;em&gt;setup&lt;/em&gt; 에는 여러 개의 명령문이 포함되어있을 수도 있습니다 &lt;code&gt;;&lt;/code&gt; 여러 줄 문자열 리터럴을 포함하지 않는 한 줄 바꿈. 명령문은 기본적으로 timeit의 네임 스페이스 내에서 실행됩니다. 네임 스페이스를 &lt;em&gt;전역&lt;/em&gt; 에 전달하여이 동작을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="faeaf3d519344bfb81584ecfbe3e2e030553ca32" translate="yes" xml:space="preserve">
          <source>The constructors for both classes work the same:</source>
          <target state="translated">두 클래스의 생성자는 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="16bddd8e166a7aa3664f7fc3cb9f30d4b8d6972f" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;script&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; elements is returned as is, without further parsing:</source>
          <target state="translated">&lt;code&gt;script&lt;/code&gt; 및 &lt;code&gt;style&lt;/code&gt; 요소 의 내용은 추가 구문 분석없이 그대로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b885742c99fa8fa5d295658e3b1e7a351b43c4b6" translate="yes" xml:space="preserve">
          <source>The content of Internet Explorer conditional comments (condcoms) will also be sent to this method, so, for &lt;code&gt;&amp;lt;!--[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]--&amp;gt;&lt;/code&gt;, this method will receive &lt;code&gt;'[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]'&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer 조건부 주석 (condcom)의 내용도이 방법으로 전송되므로 &lt;code&gt;&amp;lt;!--[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]--&amp;gt;&lt;/code&gt; 의 경우이 방법은 &lt;code&gt;'[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ffbbe2070577e91a7c0b3ac8a7f6a190c051ef3" translate="yes" xml:space="preserve">
          <source>The content of the comment as a string. The attribute contains all characters between the leading &lt;code&gt;&amp;lt;!-&lt;/code&gt;&lt;code&gt;-&lt;/code&gt; and trailing &lt;code&gt;-&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;, but does not include them.</source>
          <target state="translated">주석의 내용을 문자열로 표시합니다. 이 속성은 선도적 인 사이의 모든 문자가 포함 된 &lt;code&gt;&amp;lt;!-&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; 및 후행 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; 하지만, 그들을 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23414cbc9467ed1198fa805e0f5a50cf39d17661" translate="yes" xml:space="preserve">
          <source>The content of the processing instruction following the first whitespace character.</source>
          <target state="translated">첫 번째 공백 문자 다음에 오는 처리 명령의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="c57db44960c79dd27aae70094f1d2c24fd86db14" translate="yes" xml:space="preserve">
          <source>The content of the processing instruction up to the first whitespace character. This is a read-only attribute.</source>
          <target state="translated">첫 번째 공백 문자까지 처리 명령의 내용입니다. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="462b31a1bee4d3987ae97dfe20b6bb46bc905084" translate="yes" xml:space="preserve">
          <source>The content of the text node as a string.</source>
          <target state="translated">텍스트 노드의 내용을 문자열로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="43ad9f96468af5b1c07ea10a5a72713aa31ff0be" translate="yes" xml:space="preserve">
          <source>The content type string, in the form &lt;code&gt;maintype/subtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;maintype/subtype&lt;/code&gt; 형식의 컨텐츠 유형 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="a3b150ca1eb633d638b6149b49714354917314a8" translate="yes" xml:space="preserve">
          <source>The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.</source>
          <target state="translated">이 사전의 내용은 수정해서는 안됩니다. 변경 사항은 인터프리터가 사용하는 로컬 및 자유 변수의 값에 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d72744048e2ef7304cd545255ca3e4d86637d15" translate="yes" xml:space="preserve">
          <source>The context diff format normally has a header for filenames and modification times. Any or all of these may be specified using strings for &lt;em&gt;fromfile&lt;/em&gt;, &lt;em&gt;tofile&lt;/em&gt;, &lt;em&gt;fromfiledate&lt;/em&gt;, and &lt;em&gt;tofiledate&lt;/em&gt;. The modification times are normally expressed in the ISO 8601 format. If not specified, the strings default to blanks.</source>
          <target state="translated">컨텍스트 diff 형식에는 일반적으로 파일 이름 및 수정 시간에 대한 헤더가 있습니다. &lt;em&gt;fromfile&lt;/em&gt; , &lt;em&gt;tofile&lt;/em&gt; , &lt;em&gt;fromfiledate&lt;/em&gt; 및 &lt;em&gt;tofiledate의&lt;/em&gt; 문자열을 사용하여 이들 중 일부 또는 전부를 지정할 수 있습니다 . 수정 시간은 일반적으로 ISO 8601 형식으로 표시됩니다. 지정하지 않으면 문자열이 공백으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ae74fa43390909c47e9bab374fdc0e7d65c183ae" translate="yes" xml:space="preserve">
          <source>The context flag is set whenever the condition is encountered. After the computation, flags may be checked for informational purposes (for instance, to determine whether a computation was exact). After checking the flags, be sure to clear all flags before starting the next computation.</source>
          <target state="translated">컨텍스트 플래그는 조건이 발생할 때마다 설정됩니다. 계산 후에, 정보 목적을 위해 (예를 들어, 계산이 정확한지를 결정하기 위해) 플래그를 검사 할 수있다. 플래그를 확인한 후 다음 계산을 시작하기 전에 모든 플래그를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="09eded2e636fd012ef76bbb3909bd7a364dad9e0" translate="yes" xml:space="preserve">
          <source>The context for arithmetic is an environment specifying precision, rounding rules, limits on exponents, flags indicating the results of operations, and trap enablers which determine whether signals are treated as exceptions. Rounding options include &lt;a href=&quot;#decimal.ROUND_CEILING&quot;&gt;&lt;code&gt;ROUND_CEILING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_DOWN&quot;&gt;&lt;code&gt;ROUND_DOWN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_FLOOR&quot;&gt;&lt;code&gt;ROUND_FLOOR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_HALF_DOWN&quot;&gt;&lt;code&gt;ROUND_HALF_DOWN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt;&lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_HALF_UP&quot;&gt;&lt;code&gt;ROUND_HALF_UP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_UP&quot;&gt;&lt;code&gt;ROUND_UP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#decimal.ROUND_05UP&quot;&gt;&lt;code&gt;ROUND_05UP&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">산술의 맥락은 정밀도, 반올림 규칙, 지수 제한, 연산 결과를 나타내는 플래그 및 신호가 예외로 처리되는지 여부를 결정하는 트랩 인 에이 블러를 지정하는 환경입니다. 반올림 옵션에는 &lt;a href=&quot;#decimal.ROUND_CEILING&quot;&gt; &lt;code&gt;ROUND_CEILING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_DOWN&quot;&gt; &lt;code&gt;ROUND_DOWN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_FLOOR&quot;&gt; &lt;code&gt;ROUND_FLOOR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_HALF_DOWN&quot;&gt; &lt;code&gt;ROUND_HALF_DOWN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt; &lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_HALF_UP&quot;&gt; &lt;code&gt;ROUND_HALF_UP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_UP&quot;&gt; &lt;code&gt;ROUND_UP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.ROUND_05UP&quot;&gt; &lt;code&gt;ROUND_05UP&lt;/code&gt; 이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="bafd7adbe3cc9b05aa5e0e3dcce674dac350bfa8" translate="yes" xml:space="preserve">
          <source>The context management protocol can be used for a similar effect, using the &lt;code&gt;with&lt;/code&gt; statement:</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문을 사용하여 컨텍스트 관리 프로토콜을 비슷한 효과로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ba17141915382244ea967ecdf5422870a5b2122" translate="yes" xml:space="preserve">
          <source>The context manager creates a temporary directory in the current directory with name &lt;em&gt;name&lt;/em&gt; before temporarily changing the current working directory. If &lt;em&gt;name&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the temporary directory is created using &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile.mkdtemp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 관리자 는 현재 작업 디렉토리를 임시로 변경하기 전에 이름 &lt;em&gt;이름으로&lt;/em&gt; 현재 디렉토리에 임시 디렉토리를 작성합니다 . 경우 &lt;em&gt;이름이&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 임시 디렉토리를 사용하여 만들어집니다 &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e83b5b1e4a02d60f54d38e4c14284f0b9e0c2f5" translate="yes" xml:space="preserve">
          <source>The context manager is designed to be used like this:</source>
          <target state="translated">컨텍스트 관리자는 다음과 같이 사용되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="c93372b7d432a94a90013fda0f1e81f91883d191" translate="yes" xml:space="preserve">
          <source>The context manager will store the caught exception object in its &lt;code&gt;exception&lt;/code&gt; attribute. This can be useful if the intention is to perform additional checks on the exception raised:</source>
          <target state="translated">컨텍스트 관리자는 포착 된 예외 오브젝트를 &lt;code&gt;exception&lt;/code&gt; 속성 에 저장 합니다. 이는 발생한 예외에 대해 추가 검사를 수행하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a527687a59be5f54b43bf5cdbcd3a25dd1f0a6" translate="yes" xml:space="preserve">
          <source>The context manager will store the caught warning object in its &lt;code&gt;warning&lt;/code&gt; attribute, and the source line which triggered the warnings in the &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;lineno&lt;/code&gt; attributes. This can be useful if the intention is to perform additional checks on the warning caught:</source>
          <target state="translated">컨텍스트 관리자는 포착 된 경고 오브젝트를 &lt;code&gt;warning&lt;/code&gt; 속성 에 저장하고 경고 를 트리거 한 소스 행을 &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;lineno&lt;/code&gt; 속성에 저장합니다. 이것은 잡힌 경고에 대해 추가 점검을 수행하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1be860097b2ea275b23bb066160fdd50362d1e4" translate="yes" xml:space="preserve">
          <source>The control component is the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; module. Every &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt;, every &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;, and every &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; has an associated &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; object that controls its behavior. Usually an application only needs to specify the policy when an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; is created, either by directly instantiating an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; to create a new email, or by parsing an input stream using a &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt;. But the policy can be changed when the message is serialized using a &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;. This allows, for example, a generic email message to be parsed from disk, but to serialize it using standard SMTP settings when sending it to an email server.</source>
          <target state="translated">제어 구성 요소는 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 모듈입니다. 모든 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; , 모든 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 및 모든 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 에는 해당 동작을 제어 하는 관련 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 개체가 있습니다. 일반적으로 응용 프로그램은 단지 때 정책을 지정해야합니다 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 이&lt;/a&gt; 직접 인스턴스로 인해서 만들어집니다 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 을&lt;/a&gt; 새 전자 메일을 만들거나 사용하여 입력 스트림을 구문 분석하는 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; . 그러나 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 사용하여 메시지를 직렬화하면 정책을 변경할 수 있습니다 . 예를 들어 일반적인 전자 메일 메시지는 디스크에서 파싱되지만 전자 메일 서버로 보낼 때 표준 SMTP 설정을 사용하여 직렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42d9a5e0285e83ad97753c1affe2e30fd3b5c598" translate="yes" xml:space="preserve">
          <source>The control-c handling signal handler attempts to remain compatible with code or tests that install their own &lt;code&gt;signal.SIGINT&lt;/code&gt; handler. If the &lt;code&gt;unittest&lt;/code&gt; handler is called but &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; the installed &lt;code&gt;signal.SIGINT&lt;/code&gt; handler, i.e. it has been replaced by the system under test and delegated to, then it calls the default handler. This will normally be the expected behavior by code that replaces an installed handler and delegates to it. For individual tests that need &lt;code&gt;unittest&lt;/code&gt; control-c handling disabled the &lt;a href=&quot;#unittest.removeHandler&quot;&gt;&lt;code&gt;removeHandler()&lt;/code&gt;&lt;/a&gt; decorator can be used.</source>
          <target state="translated">제어-C 처리 신호 처리기 시도 코드 또는 자신의 설치 검사와 호환성을 유지하는 &lt;code&gt;signal.SIGINT&lt;/code&gt; 의 핸들러를. 는 IF &lt;code&gt;unittest&lt;/code&gt; 핸들러가 호출되지만 &lt;em&gt;아닙니다&lt;/em&gt; 설치된 &lt;code&gt;signal.SIGINT&lt;/code&gt; 의 핸들러는,이 테스트중인 시스템으로 대체하고, 다음 기본 핸들러 호출에 위임 된 즉. 이것은 일반적으로 설치된 핸들러를 대체하고 위임하는 코드에 의해 예상되는 동작입니다. &lt;code&gt;unittest&lt;/code&gt; control-c 처리를 비활성화 해야하는 개별 테스트의 경우 &lt;a href=&quot;#unittest.removeHandler&quot;&gt; &lt;code&gt;removeHandler()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0fec426b51ce6460abf94b5b235156f847e881d" translate="yes" xml:space="preserve">
          <source>The convenience functions are:</source>
          <target state="translated">편의 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56531a899db00e70169892fd06fed6a16f80619f" translate="yes" xml:space="preserve">
          <source>The convention has been adopted that subclasses defining &lt;code&gt;&amp;lt;protocol&amp;gt;_request()&lt;/code&gt; or &lt;code&gt;&amp;lt;protocol&amp;gt;_response()&lt;/code&gt; methods are named &lt;code&gt;*Processor&lt;/code&gt;; all others are named &lt;code&gt;*Handler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;protocol&amp;gt;_request()&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;protocol&amp;gt;_response()&lt;/code&gt; 메소드를 정의하는 서브 클래스의 이름은 &lt;code&gt;*Processor&lt;/code&gt; 라는 규칙이 채택되었습니다 . 다른 모든 이름은 &lt;code&gt;*Handler&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04aed1935d025bbe545d917616fb5a05a7966b05" translate="yes" xml:space="preserve">
          <source>The convention of allowing a special section of default values for other sections or interpolation purposes is a powerful concept of this library, letting users create complex declarative configurations. This section is normally called &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; but this can be customized to point to any other valid section name. Some typical values include: &lt;code&gt;&quot;general&quot;&lt;/code&gt; or &lt;code&gt;&quot;common&quot;&lt;/code&gt;. The name provided is used for recognizing default sections when reading from any source and is used when writing configuration back to a file. Its current value can be retrieved using the &lt;code&gt;parser_instance.default_section&lt;/code&gt; attribute and may be modified at runtime (i.e. to convert files from one format to another).</source>
          <target state="translated">다른 섹션 또는 보간 목적으로 특정 기본값 섹션을 허용하는 규칙은이 라이브러리의 강력한 개념으로, 사용자는 복잡한 선언적 구성을 만들 수 있습니다. 이 섹션은 일반적으로 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; 라고 하지만 다른 유효한 섹션 이름을 가리 키도록 사용자 정의 할 수 있습니다. 일부 일반적인 값은 &lt;code&gt;&quot;general&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;common&quot;&lt;/code&gt; 입니다. 제공된 이름은 모든 소스에서 읽을 때 기본 섹션을 인식하는 데 사용되며 구성을 파일에 다시 쓸 때 사용됩니다. 현재 값은 &lt;code&gt;parser_instance.default_section&lt;/code&gt; 속성을 사용하여 검색 할 수 있으며 런타임시 수정 될 수 있습니다 (예 : 파일을 한 형식에서 다른 형식으로 변환).</target>
        </trans-unit>
        <trans-unit id="04f50c40567ef791799d2985a7c9a953f20d7dc2" translate="yes" xml:space="preserve">
          <source>The conversion flag characters are:</source>
          <target state="translated">변환 플래그 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7662277ad21af100a1d5f044a71168e6f8c38a0" translate="yes" xml:space="preserve">
          <source>The conversion is exact. Raise OverflowError on infinities and ValueError on NaNs.</source>
          <target state="translated">변환은 정확합니다. 인피니티에서는 OverflowError를, NaN에서는 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9a0858db8166719a0548328bc9ef5c570f7cfad8" translate="yes" xml:space="preserve">
          <source>The conversion types are:</source>
          <target state="translated">변환 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="105b71d0f8e9a7689ed5c98aeb32a3a6cbc24366" translate="yes" xml:space="preserve">
          <source>The conversion will be zero padded for numeric values.</source>
          <target state="translated">숫자 값의 경우 변환이 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7703cc3d251bd654ea393b2b50dea7fa2568320d" translate="yes" xml:space="preserve">
          <source>The converted value is left adjusted (overrides the &lt;code&gt;'0'&lt;/code&gt; conversion if both are given).</source>
          <target state="translated">변환 된 값은 조정 된 상태로 유지됩니다 ( 둘 다 제공되는 경우 &lt;code&gt;'0'&lt;/code&gt; 변환을 무시 함 ).</target>
        </trans-unit>
        <trans-unit id="232d6e721f1a28fd8262831489f11e15ce117ac5" translate="yes" xml:space="preserve">
          <source>The core built-in types for manipulating binary data are &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;. They are supported by &lt;a href=&quot;#memoryview&quot;&gt;&lt;code&gt;memoryview&lt;/code&gt;&lt;/a&gt; which uses the &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;buffer protocol&lt;/a&gt; to access the memory of other binary objects without needing to make a copy.</source>
          <target state="translated">이진 데이터를 조작하기위한 기본 내장 유형은 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 입니다. 이들은 지원하는 &lt;a href=&quot;#memoryview&quot;&gt; &lt;code&gt;memoryview&lt;/code&gt; &lt;/a&gt; 용도 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜을&lt;/a&gt; 복사 할 필요없이, 다른 개체의 이진 메모리에 액세스.</target>
        </trans-unit>
        <trans-unit id="dc4d92fe7f0a481b0cfb48417959be4f39e5294d" translate="yes" xml:space="preserve">
          <source>The coroutine then has a chance to clean up or even deny the request by suppressing the exception with a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &amp;hellip; &lt;code&gt;except CancelledError&lt;/code&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; block. Therefore, unlike &lt;a href=&quot;asyncio-future#asyncio.Future.cancel&quot;&gt;&lt;code&gt;Future.cancel()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt;&lt;code&gt;Task.cancel()&lt;/code&gt;&lt;/a&gt; does not guarantee that the Task will be cancelled, although suppressing cancellation completely is not common and is actively discouraged.</source>
          <target state="translated">코 루틴은 다음과 예외를 억제하여 요청을 정리하거나 거부 할 수있는 기회가 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; ... &lt;code&gt;except CancelledError&lt;/code&gt; ... &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 차단합니다. 따라서, 달리 &lt;a href=&quot;asyncio-future#asyncio.Future.cancel&quot;&gt; &lt;code&gt;Future.cancel()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt; &lt;code&gt;Task.cancel()&lt;/code&gt; &lt;/a&gt; 완전히 취소를 억제하는 것이 일반적인하지 않고 적극적으로 권장하지 않습니다 있지만 작업이 취소되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bc1b5bbe66f8d0dac7e549cc0180896743986591" translate="yes" xml:space="preserve">
          <source>The corresponding error message, as provided by the operating system. It is formatted by the C functions &lt;code&gt;perror()&lt;/code&gt; under POSIX, and &lt;code&gt;FormatMessage()&lt;/code&gt; under Windows.</source>
          <target state="translated">운영 체제에서 제공 한 해당 오류 메시지 POSIX 에서 C 함수 &lt;code&gt;perror()&lt;/code&gt; 로, Windows에서 &lt;code&gt;FormatMessage()&lt;/code&gt; 로 형식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="70d5450d9e84a7624d246a14f8334e480e6ee9b1" translate="yes" xml:space="preserve">
          <source>The corresponding simplest possible writing example is:</source>
          <target state="translated">가장 간단한 가능한 쓰기 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99ba8850b932395d55f5c7b65d46a83173ec0e7a" translate="yes" xml:space="preserve">
          <source>The count of unfinished tasks goes up whenever an item is added to the queue. The count goes down whenever a consumer calls &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; to indicate that the item was retrieved and all work on it is complete. When the count of unfinished tasks drops to zero, &lt;a href=&quot;queue#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; unblocks.</source>
          <target state="translated">완료되지 않은 작업의 수는 항목이 대기열에 추가 될 때마다 증가합니다. 소비자가 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 항목이 검색되었고 모든 작업이 완료되었음을 나타내면 카운트가 줄어 듭니다 . 완료되지 않은 작업 수가 0으로 떨어지면 &lt;a href=&quot;queue#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b83253d660a4a6f7f73e5535fc2a5ea3481eca66" translate="yes" xml:space="preserve">
          <source>The count of unfinished tasks goes up whenever an item is added to the queue. The count goes down whenever a consumer coroutine calls &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; to indicate that the item was retrieved and all work on it is complete. When the count of unfinished tasks drops to zero, &lt;a href=&quot;#asyncio.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; unblocks.</source>
          <target state="translated">완료되지 않은 작업의 수는 항목이 대기열에 추가 될 때마다 증가합니다. 소비자 코 루틴이 &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 항목이 검색되었고 해당 항목에 대한 모든 작업이 완료되었음을 나타내면 카운트가 줄어 듭니다 . 완료되지 않은 작업 수가 0으로 떨어지면 &lt;a href=&quot;#asyncio.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="39ba1f2977ddb0979cf75b4e181dad95efd3edcb" translate="yes" xml:space="preserve">
          <source>The count of unfinished tasks goes up whenever an item is added to the queue. The count goes down whenever a consumer thread calls &lt;a href=&quot;#queue.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; to indicate that the item was retrieved and all work on it is complete. When the count of unfinished tasks drops to zero, &lt;a href=&quot;#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; unblocks.</source>
          <target state="translated">완료되지 않은 작업의 수는 항목이 대기열에 추가 될 때마다 증가합니다. 소비자 스레드가 &lt;a href=&quot;#queue.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 항목이 검색되었고 해당 항목에 대한 모든 작업이 완료되었음을 나타낼 때마다 카운트가 줄어 듭니다 . 완료되지 않은 작업 수가 0으로 떨어지면 &lt;a href=&quot;#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="e08e1d045e84c6cb3e0262a5e1278aaaa956caeb" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;pyvenv.cfg&lt;/code&gt; file also includes the &lt;code&gt;include-system-site-packages&lt;/code&gt; key, set to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;venv&lt;/code&gt; is run with the &lt;code&gt;--system-site-packages&lt;/code&gt; option, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">생성 된 &lt;code&gt;pyvenv.cfg&lt;/code&gt; 파일에는 &lt;code&gt;include-system-site-packages&lt;/code&gt; 키 도 포함되어 있으며 --ven &lt;code&gt;--system-site-packages&lt;/code&gt; 옵션으로 &lt;code&gt;venv&lt;/code&gt; 를 실행 하면 &lt;code&gt;true&lt;/code&gt; 로 설정되고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4361350e28309ad8fede5d4bbb572c800f97e105" translate="yes" xml:space="preserve">
          <source>The created transport is an implementation-dependent bidirectional stream.</source>
          <target state="translated">생성 된 전송은 구현에 따른 양방향 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="b42a75b2b3e3e154cd9c1ea1403f52e8177428d0" translate="yes" xml:space="preserve">
          <source>The crux of each test is a call to &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt; to check for an expected result; &lt;a href=&quot;#unittest.TestCase.assertTrue&quot;&gt;&lt;code&gt;assertTrue()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.TestCase.assertFalse&quot;&gt;&lt;code&gt;assertFalse()&lt;/code&gt;&lt;/a&gt; to verify a condition; or &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt; to verify that a specific exception gets raised. These methods are used instead of the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#assert&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; statement so the test runner can accumulate all test results and produce a report.</source>
          <target state="translated">각 테스트의 핵심은 예상 결과를 확인하기 위해 &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것입니다. &lt;a href=&quot;#unittest.TestCase.assertTrue&quot;&gt; &lt;code&gt;assertTrue()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.TestCase.assertFalse&quot;&gt; &lt;code&gt;assertFalse()&lt;/code&gt; &lt;/a&gt; 를 사용하여 조건을 확인합니다. 또는 &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; 를 사용하여 특정 예외가 발생했는지 확인하십시오. 이러한 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#assert&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt; 문 대신 사용 되므로 테스트 실행자는 모든 테스트 결과를 누적하고 보고서를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="029b9273dbb02b6ea7417a3252afee02f4033d0b" translate="yes" xml:space="preserve">
          <source>The current algorithm has an early-out when it encounters a zero in the input. This means that the subsequent inputs are not tested for validity. (This behavior may change in the future.)</source>
          <target state="translated">현재 알고리즘은 입력에서 0을 만나면 조기 종료됩니다. 이는 후속 입력이 유효성을 테스트하지 않았 음을 의미합니다. (이 동작은 나중에 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3d8bb9e42cfd6a06200a85ffbadb0aae65550388" translate="yes" xml:space="preserve">
          <source>The current implementation wakes up exactly &lt;em&gt;n&lt;/em&gt; threads, if at least &lt;em&gt;n&lt;/em&gt; threads are waiting. However, it&amp;rsquo;s not safe to rely on this behavior. A future, optimized implementation may occasionally wake up more than &lt;em&gt;n&lt;/em&gt; threads.</source>
          <target state="translated">최소한 &lt;em&gt;n 개의&lt;/em&gt; 스레드가 대기중인 경우 현재 구현은 정확히 &lt;em&gt;n 개의&lt;/em&gt; 스레드를 깨 웁니다 . 그러나이 동작에 의존하는 것은 안전하지 않습니다. 미래에 최적화 된 구현은 때때로 &lt;em&gt;n&lt;/em&gt; 개 이상의 스레드를 깨울 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52a436678a1020bde214c0d97cdeb64bf8a1589a" translate="yes" xml:space="preserve">
          <source>The current internal state of the generator can also be queried. This is mostly useful for testing purposes, to ensure that internal state is being updated as expected:</source>
          <target state="translated">발전기의 현재 내부 상태도 쿼리 할 수 ​​있습니다. 이는 내부 상태가 예상대로 업데이트되도록 테스트 목적으로 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b161fdbf8f8dfdde9548c335694aae4ea27b9243" translate="yes" xml:space="preserve">
          <source>The current line in the current frame is indicated by &lt;code&gt;-&amp;gt;&lt;/code&gt;. If an exception is being debugged, the line where the exception was originally raised or propagated is indicated by &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, if it differs from the current line.</source>
          <target state="translated">현재 프레임의 현재 라인은 &lt;code&gt;-&amp;gt;&lt;/code&gt; 로 표시됩니다 . 예외를 디버깅하는 경우 예외가 원래 발생했거나 전파 된 행은 현재 행과 다른 경우 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="68241a388af98feb65b13ec5fad01a05b24e1abb" translate="yes" xml:space="preserve">
          <source>The current process is replaced immediately. Open file objects and descriptors are not flushed, so if there may be data buffered on these open files, you should flush them using &lt;code&gt;sys.stdout.flush()&lt;/code&gt; or &lt;a href=&quot;#os.fsync&quot;&gt;&lt;code&gt;os.fsync()&lt;/code&gt;&lt;/a&gt; before calling an &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">현재 프로세스가 즉시 교체됩니다. 열린 파일 객체 및 설명자는 플러시되지 않으므로 이러한 열린 파일에 데이터가 버퍼링 될 수있는 경우 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*&lt;/code&gt; &lt;/a&gt; 함수를 호출하기 전에 &lt;code&gt;sys.stdout.flush()&lt;/code&gt; 또는 &lt;a href=&quot;#os.fsync&quot;&gt; &lt;code&gt;os.fsync()&lt;/code&gt; &lt;/a&gt; 를 사용하여 플러시해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dc9aa1e766143ced63bf297199daa209252dd44e" translate="yes" xml:space="preserve">
          <source>The current value of the progress bar. In &amp;ldquo;determinate&amp;rdquo; mode, this represents the amount of work completed. In &amp;ldquo;indeterminate&amp;rdquo; mode, it is interpreted as modulo &lt;em&gt;maximum&lt;/em&gt;; that is, the progress bar completes one &amp;ldquo;cycle&amp;rdquo; when its value increases by &lt;em&gt;maximum&lt;/em&gt;.</source>
          <target state="translated">진행률 표시 줄의 현재 값입니다. &quot;결정&quot;모드에서 완료된 작업량을 나타냅니다. &quot;불확정&quot;모드에서는 모듈로 &lt;em&gt;최대 값으로&lt;/em&gt; 해석됩니다 . 즉, 진행률 표시 줄의 값이 &lt;em&gt;최대&lt;/em&gt; 증가하면 하나의 &quot;사이클&quot;이 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="44c920e93ea8d45fdfebab1da8fb98b10091f105" translate="yes" xml:space="preserve">
          <source>The current-value setting of some widgets (like text entry widgets) can be connected directly to application variables by using special options. These options are &lt;code&gt;variable&lt;/code&gt;, &lt;code&gt;textvariable&lt;/code&gt;, &lt;code&gt;onvalue&lt;/code&gt;, &lt;code&gt;offvalue&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt;. This connection works both ways: if the variable changes for any reason, the widget it&amp;rsquo;s connected to will be updated to reflect the new value.</source>
          <target state="translated">텍스트 입력 위젯과 같은 일부 위젯의 현재 값 설정은 특수 옵션을 사용하여 애플리케이션 변수에 직접 연결할 수 있습니다. 이러한 옵션은 &lt;code&gt;variable&lt;/code&gt; , &lt;code&gt;textvariable&lt;/code&gt; , &lt;code&gt;onvalue&lt;/code&gt; , &lt;code&gt;offvalue&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 입니다. 이 연결은 두 가지 방식으로 작동합니다. 어떤 이유로 변수가 변경되면 연결된 위젯이 새 값을 반영하도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a44b4e7cf28e49605dc244254c36f226b6f6a70e" translate="yes" xml:space="preserve">
          <source>The curses library does &amp;ldquo;line-breakout optimization&amp;rdquo; by looking for typeahead periodically while updating the screen. If input is found, and it is coming from a tty, the current update is postponed until refresh or doupdate is called again, allowing faster response to commands typed in advance. This function allows specifying a different file descriptor for typeahead checking.</source>
          <target state="translated">curses 라이브러리는 화면을 업데이트하는 동안 정기적으로 자동 검색 기능을 찾아&amp;ldquo;라인 브레이크 아웃 최적화&amp;rdquo;를 수행합니다. 입력이 발견되고 tty에서 오는 경우 새로 고침 또는 doupdate가 다시 호출 될 때까지 현재 업데이트가 연기되어 미리 입력 된 명령에 더 빠르게 응답 할 수 있습니다. 이 기능을 사용하면 자동 검색을 위해 다른 파일 설명자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b01dfa066d22cfd22c2fff03df93dd7ff0910062" translate="yes" xml:space="preserve">
          <source>The cursor method accepts a single optional parameter &lt;em&gt;factory&lt;/em&gt;. If supplied, this must be a callable returning an instance of &lt;a href=&quot;#sqlite3.Cursor&quot;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/a&gt; or its subclasses.</source>
          <target state="translated">커서 메소드는 단일 선택적 매개 변수 &lt;em&gt;팩토리를&lt;/em&gt; 허용합니다 . 제공되는 경우 이는 &lt;a href=&quot;#sqlite3.Cursor&quot;&gt; &lt;code&gt;Cursor&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 해당 서브 클래스를 리턴하는 호출 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b06811008992340fc2dc7c59bbd5693bc9ce0ee4" translate="yes" xml:space="preserve">
          <source>The cursor will be unusable from this point forward; a &lt;a href=&quot;#sqlite3.ProgrammingError&quot;&gt;&lt;code&gt;ProgrammingError&lt;/code&gt;&lt;/a&gt; exception will be raised if any operation is attempted with the cursor.</source>
          <target state="translated">이 시점부터 커서를 사용할 수 없습니다. &lt;a href=&quot;#sqlite3.ProgrammingError&quot;&gt; &lt;code&gt;ProgrammingError&lt;/code&gt; 의&lt;/a&gt; 모든 작업이 커서 시도하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2adfa03e9423251347d2ddec72ca24f15adda1d8" translate="yes" xml:space="preserve">
          <source>The cut points are linearly interpolated from the two nearest data points. For example, if a cut point falls one-third of the distance between two sample values, &lt;code&gt;100&lt;/code&gt; and &lt;code&gt;112&lt;/code&gt;, the cut-point will evaluate to &lt;code&gt;104&lt;/code&gt;.</source>
          <target state="translated">컷 포인트는 가장 가까운 두 개의 데이터 포인트에서 선형 보간됩니다. 예를 들어, 컷 포인트가 두 샘플 값 &lt;code&gt;100&lt;/code&gt; 과 &lt;code&gt;112&lt;/code&gt; 사이의 거리의 1/3에 해당 하면 컷 포인트는 &lt;code&gt;104&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3acee39c7abbab9115fc8f08a2afc5d777a683e" translate="yes" xml:space="preserve">
          <source>The data compression is provided by the &lt;a href=&quot;zlib#module-zlib&quot;&gt;&lt;code&gt;zlib&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">데이터 압축은 &lt;a href=&quot;zlib#module-zlib&quot;&gt; &lt;code&gt;zlib&lt;/code&gt; &lt;/a&gt; 모듈에서 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4732c01492e63cdd9d7c665f57a987ee799fc855" translate="yes" xml:space="preserve">
          <source>The data format used by &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; is Python-specific. This has the advantage that there are no restrictions imposed by external standards such as JSON or XDR (which can&amp;rsquo;t represent pointer sharing); however it means that non-Python programs may not be able to reconstruct pickled Python objects.</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 이 사용하는 데이터 형식 은 Python에 따라 다릅니다. 이는 JSON 또는 XDR (포인터 공유를 나타낼 수 없음)과 같은 외부 표준에 의해 부과 된 제한이 없다는 장점이 있습니다. 그러나 이것은 비 파이썬 프로그램이 피클 링 된 파이썬 객체를 재구성하지 못할 수도 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ad490902b06ce6c474539cea2f88c4d882fde489" translate="yes" xml:space="preserve">
          <source>The data read is buffered in memory, so do not use this method if the data size is large or unlimited.</source>
          <target state="translated">읽은 데이터는 메모리에 버퍼링되므로 데이터 크기가 크거나 무제한 인 경우이 방법을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="381273eadd2ef918438fcbe00869dea87bc7b0ee" translate="yes" xml:space="preserve">
          <source>The data returned by &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt;&lt;code&gt;urlretrieve()&lt;/code&gt;&lt;/a&gt; is the raw data returned by the server. This may be binary data (such as an image), plain text or (for example) HTML. The HTTP protocol provides type information in the reply header, which can be inspected by looking at the &lt;em&gt;Content-Type&lt;/em&gt; header. If the returned data is HTML, you can use the module &lt;a href=&quot;html.parser#module-html.parser&quot;&gt;&lt;code&gt;html.parser&lt;/code&gt;&lt;/a&gt; to parse it.</source>
          <target state="translated">반환하는 데이터 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt; &lt;code&gt;urlretrieve()&lt;/code&gt; &lt;/a&gt; 서버에 의해 반환 된 원시 데이터이다. 이진 데이터 (예 : 이미지), 일반 텍스트 또는 HTML (예 : HTML) 일 수 있습니다. HTTP 프로토콜은 응답 헤더에 유형 정보를 제공하며 이는 &lt;em&gt;Content-Type&lt;/em&gt; 헤더를 보고 검사 할 수 있습니다 . 반환 된 데이터가 HTML 인 경우 &lt;a href=&quot;html.parser#module-html.parser&quot;&gt; &lt;code&gt;html.parser&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb6758afc9485fe5a6fb81c1866b77aa22d9b3e5" translate="yes" xml:space="preserve">
          <source>The data you&amp;rsquo;ve saved is persistent and is available in subsequent sessions:</source>
          <target state="translated">저장 한 데이터는 영구적이며 다음 세션에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07798be371fad61c3fb93bf3ac316396b61294ce" translate="yes" xml:space="preserve">
          <source>The database will contain just the schema and the validation records when this function returns.</source>
          <target state="translated">이 함수가 반환되면 데이터베이스에는 스키마와 유효성 검사 레코드 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d274876e4079ca20009328bf8e5cde4e56d7abf9" translate="yes" xml:space="preserve">
          <source>The debugger is extensible &amp;ndash; it is actually defined as the class &lt;a href=&quot;#pdb.Pdb&quot;&gt;&lt;code&gt;Pdb&lt;/code&gt;&lt;/a&gt;. This is currently undocumented but easily understood by reading the source. The extension interface uses the modules &lt;a href=&quot;bdb#module-bdb&quot;&gt;&lt;code&gt;bdb&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmd#module-cmd&quot;&gt;&lt;code&gt;cmd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">디버거는 확장 가능합니다. 실제로는 &lt;a href=&quot;#pdb.Pdb&quot;&gt; &lt;code&gt;Pdb&lt;/code&gt; &lt;/a&gt; 클래스로 정의됩니다 . 이것은 현재 문서화되어 있지 않지만 소스를 읽으면 쉽게 이해할 수 있습니다. 확장 인터페이스는 &lt;a href=&quot;bdb#module-bdb&quot;&gt; &lt;code&gt;bdb&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;cmd#module-cmd&quot;&gt; &lt;code&gt;cmd&lt;/code&gt; &lt;/a&gt; 모듈을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="095b5670be6e411b1e73958df31e2f6ac1da2d0c" translate="yes" xml:space="preserve">
          <source>The debugger supports &lt;a href=&quot;#debugger-aliases&quot;&gt;aliases&lt;/a&gt;. Aliases can have parameters which allows one a certain level of adaptability to the context under examination.</source>
          <target state="translated">디버거는 &lt;a href=&quot;#debugger-aliases&quot;&gt;별칭을&lt;/a&gt; 지원 합니다 . 별칭에는 검사중인 컨텍스트에 특정 수준의 적응성을 허용하는 매개 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6427247e8f8887424311f6b6d15aa4b617225615" translate="yes" xml:space="preserve">
          <source>The debugger&amp;rsquo;s prompt is &lt;code&gt;(Pdb)&lt;/code&gt;. Typical usage to run a program under control of the debugger is:</source>
          <target state="translated">디버거의 프롬프트는 &lt;code&gt;(Pdb)&lt;/code&gt; 입니다. 디버거의 제어하에 프로그램을 실행하는 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5def3aa4d7a228de01c175df183f95bac9ef0b71" translate="yes" xml:space="preserve">
          <source>The debugging flags necessary for the collector to print information about a leaking program (equal to &lt;code&gt;DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE |
DEBUG_SAVEALL&lt;/code&gt;).</source>
          <target state="translated">콜렉터가 누출 프로그램에 대한 정보를 인쇄하는 데 필요한 디버깅 플래그 ( &lt;code&gt;DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="90287af497864716aa30b5d7a8cbe1542d08cbc7" translate="yes" xml:space="preserve">
          <source>The decimal module incorporates a notion of significant places so that &lt;code&gt;1.30
+ 1.20&lt;/code&gt; is &lt;code&gt;2.50&lt;/code&gt;. The trailing zero is kept to indicate significance. This is the customary presentation for monetary applications. For multiplication, the &amp;ldquo;schoolbook&amp;rdquo; approach uses all the figures in the multiplicands. For instance, &lt;code&gt;1.3 * 1.2&lt;/code&gt; gives &lt;code&gt;1.56&lt;/code&gt; while &lt;code&gt;1.30 *
1.20&lt;/code&gt; gives &lt;code&gt;1.5600&lt;/code&gt;.</source>
          <target state="translated">10 진수 모듈은 &lt;code&gt;1.30 + 1.20&lt;/code&gt; 이 &lt;code&gt;2.50&lt;/code&gt; 이 되도록 중요한 장소 개념을 통합합니다 . 후행 0은 유의성을 나타 내기 위해 유지됩니다. 이것은 화폐 응용 프로그램을위한 일반적인 프레젠테이션입니다. 곱셈을 위해,&amp;ldquo;schoolbook&amp;rdquo;접근법은 곱셈의 모든 숫자를 사용합니다. 예를 들어 &lt;code&gt;1.3 * 1.2&lt;/code&gt; 는 &lt;code&gt;1.56&lt;/code&gt; , &lt;code&gt;1.30 * 1.20&lt;/code&gt; 은 &lt;code&gt;1.5600&lt;/code&gt; 을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="bc5331a4ec577ee10bc6dc4f46c2d0c2800f6ff8" translate="yes" xml:space="preserve">
          <source>The decimal module was designed to support &amp;ldquo;without prejudice, both exact unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and rounded floating-point arithmetic.&amp;rdquo; &amp;ndash; excerpt from the decimal arithmetic specification.</source>
          <target state="translated">decimal 모듈은 &quot;정확한 반올림 십진 산술 (때로는 고정 소수점 산술) 및 둥근 부동 소수점 산술&quot;을 모두 편견없이 지원하도록 설계되었습니다. &amp;ndash; 십진 산술 스펙에서 발췌.</target>
        </trans-unit>
        <trans-unit id="fcd953820c180c8fd51fd721bc40a9145788703c" translate="yes" xml:space="preserve">
          <source>The decoder must be able to handle zero length input and return an empty object of the output object type in this situation.</source>
          <target state="translated">이 상황에서 디코더는 길이가 0 인 입력을 처리하고 출력 객체 유형의 빈 객체를 반환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4370c4771bb3ea3eff3bcc09178bfbdc4274e2bd" translate="yes" xml:space="preserve">
          <source>The decorated method will take in the &lt;strong&gt;name&lt;/strong&gt; of the module to be loaded as expected for a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt;. If the module is not found in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; then a new one is constructed. Regardless of where the module came from, &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__loader__&quot;&gt;&lt;code&gt;__loader__&lt;/code&gt;&lt;/a&gt; set to &lt;strong&gt;self&lt;/strong&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt;&lt;code&gt;__package__&lt;/code&gt;&lt;/a&gt; is set based on what &lt;a href=&quot;#importlib.abc.InspectLoader.is_package&quot;&gt;&lt;code&gt;importlib.abc.InspectLoader.is_package()&lt;/code&gt;&lt;/a&gt; returns (if available). These attributes are set unconditionally to support reloading.</source>
          <target state="translated">데코 레이팅 된 메소드는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더에&lt;/a&gt; 필요한대로로드 될 모듈 의 &lt;strong&gt;이름&lt;/strong&gt; 을 받습니다. &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 모듈이 없으면 새 모듈 이 구성됩니다. 에 관계없이 모듈은, 어디에서 왔는지의 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__loader__&quot;&gt; &lt;code&gt;__loader__&lt;/code&gt; &lt;/a&gt; 로 설정 &lt;strong&gt;자기&lt;/strong&gt; 와 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt; &lt;code&gt;__package__&lt;/code&gt; 가&lt;/a&gt; 무엇을 기반으로 세트되어 &lt;a href=&quot;#importlib.abc.InspectLoader.is_package&quot;&gt; &lt;code&gt;importlib.abc.InspectLoader.is_package()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)으로 돌아갑니다. 이러한 속성은 무조건 재로드를 지원하도록 설정됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5cffc98a45b4b4fc8fac139e7a5b9aef8a25d0d4" translate="yes" xml:space="preserve">
          <source>The decorator also provides a &lt;code&gt;cache_clear()&lt;/code&gt; function for clearing or invalidating the cache.</source>
          <target state="translated">데코레이터는 캐시를 지우거나 무효화하기위한 &lt;code&gt;cache_clear()&lt;/code&gt; 함수 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9241d41c4f3d0d35ed609d927b5431512d3a0115" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete, information:</source>
          <target state="translated">기본 &lt;a href=&quot;#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 메커니즘은 완전한 정보가 아닌 가장 관련성 높은 정보를 생성하려고 시도하므로 다른 유형의 객체와 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d84a97fb732f65d135a8de533f5d2309e5002866" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; iterator iterates over message representations, not keys as the default dictionary iterator does. Moreover, modification of a mailbox during iteration is safe and well-defined. Messages added to the mailbox after an iterator is created will not be seen by the iterator. Messages removed from the mailbox before the iterator yields them will be silently skipped, though using a key from an iterator may result in a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception if the corresponding message is subsequently removed.</source>
          <target state="translated">기본 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 반복기는 기본 사전 반복기와 달리 키가 아니라 메시지 표현을 반복합니다. 또한 반복하는 동안 사서함을 수정하는 것이 안전하고 명확합니다. 반복자가 작성된 후 메일함에 추가 된 메시지는 반복자가 볼 수 없습니다. 반복자가 생성하기 전에 메일 함에서 제거 된 메시지는 자동으로 건너 뛰지 만 반복기에서 키를 사용 하면 해당 메시지가 제거되면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 예외 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f6bd331cdd8851c589608705300fea060ae29b3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;PathFinder&lt;/code&gt; for Python includes a hook that calls into &lt;code&gt;importlib.metadata.MetadataPathFinder&lt;/code&gt; for finding distributions loaded from typical file-system-based paths.</source>
          <target state="translated">Python 의 기본 &lt;code&gt;PathFinder&lt;/code&gt; 에는 일반적인 파일 시스템 기반 경로에서로드 된 배포를 찾기 위해 &lt;code&gt;importlib.metadata.MetadataPathFinder&lt;/code&gt; 를 호출하는 후크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08f1b8ed360aa3fdbcb31fe8c46e2aefb98f856" translate="yes" xml:space="preserve">
          <source>The default &lt;em&gt;format_spec&lt;/em&gt; is an empty string which usually gives the same effect as calling &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str(value)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;em&gt;format_spec&lt;/em&gt; 은 빈 문자열이며 일반적으로 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str(value)&lt;/code&gt; &lt;/a&gt; 호출과 동일한 효과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="916e4b68347b1b5b55f8b8dfbbfb3aa9f77bde33" translate="yes" xml:space="preserve">
          <source>The default &lt;em&gt;locals&lt;/em&gt; act as described for function &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; below: modifications to the default &lt;em&gt;locals&lt;/em&gt; dictionary should not be attempted. Pass an explicit &lt;em&gt;locals&lt;/em&gt; dictionary if you need to see effects of the code on &lt;em&gt;locals&lt;/em&gt; after function &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">기본 &lt;em&gt;지역은&lt;/em&gt; 아래의 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 함수에 대해 설명 된대로 작동 합니다. 기본 &lt;em&gt;지역&lt;/em&gt; 사전을 수정 하지 마십시오. &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 함수가 반환 된 후 코드가 &lt;em&gt;로컬&lt;/em&gt; 에 미치는 영향을 보려면 명시 적 &lt;em&gt;로컬&lt;/em&gt; 사전을 전달하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fcc1fc4b3a3ae0a82e1e9c7f968eba8efba69cd8" translate="yes" xml:space="preserve">
          <source>The default &lt;em&gt;method&lt;/em&gt; is &amp;ldquo;exclusive&amp;rdquo; and is used for data sampled from a population that can have more extreme values than found in the samples. The portion of the population falling below the &lt;em&gt;i-th&lt;/em&gt; of &lt;em&gt;m&lt;/em&gt; sorted data points is computed as &lt;code&gt;i / (m + 1)&lt;/code&gt;. Given nine sample values, the method sorts them and assigns the following percentiles: 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%.</source>
          <target state="translated">기본 &lt;em&gt;방법&lt;/em&gt; 은 &quot;배타적&quot;이며 표본에서 찾은 것보다 더 극단적 인 값을 가질 수있는 모집단에서 샘플링 된 데이터에 사용됩니다. 아래 떨어지는 인구 부분 &lt;em&gt;의 i 번째&lt;/em&gt; 의 &lt;em&gt;m은&lt;/em&gt; 데이터 포인트가 계산된다 정렬 같은 &lt;code&gt;i / (m + 1)&lt;/code&gt; . 9 개의 표본 값이 주어지면이 방법은 값을 정렬하고 10 %, 20 %, 30 %, 40 %, 50 %, 60 %, 70 %, 80 %, 90 % 백분위 수를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="cc26c9794d7c7424fc9e7bc14e214666252c9274" translate="yes" xml:space="preserve">
          <source>The default asyncio event loop implementation on &lt;strong&gt;Windows&lt;/strong&gt; does not support subprocesses. Subprocesses are available for Windows if a &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; is used. See &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;Subprocess Support on Windows&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;Windows&lt;/strong&gt; 에서 기본 asyncio 이벤트 루프 구현은 하위 프로세스를 지원하지 않습니다. &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 가 사용되는 경우 서브 프로세스는 Windows 에 사용 가능합니다. 자세한 내용 &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;은 Windows의 하위 프로세스 지원을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="73f9f71a010dfccdb59de7aba2ccdae124aedfba" translate="yes" xml:space="preserve">
          <source>The default asyncio event loop on &lt;strong&gt;Windows&lt;/strong&gt; does not support subprocesses. See &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;Subprocess Support on Windows&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;Windows&lt;/strong&gt; 의 기본 asyncio 이벤트 루프는 하위 프로세스를 지원하지 않습니다. 자세한 내용 &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;은 Windows의 하위 프로세스 지원을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="320d764d5f91986c0ce197a99b5dafc84e75fdbe" translate="yes" xml:space="preserve">
          <source>The default asyncio policy. Uses &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; on Unix and &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">기본 비동기 정책입니다. Unix에서는 &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 를 사용 하고 Windows에서는 &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99843d8504993a7ac9fb3c4008f6662e1e83ea6f" translate="yes" xml:space="preserve">
          <source>The default category for &lt;a href=&quot;#warnings.warn&quot;&gt;&lt;code&gt;warn()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#warnings.warn&quot;&gt; &lt;code&gt;warn()&lt;/code&gt; &lt;/a&gt; 의 기본 카테고리입니다 .</target>
        </trans-unit>
        <trans-unit id="32f43bb65b67ab4e0064d8679c4a8ed6f5c74251" translate="yes" xml:space="preserve">
          <source>The default character encoding: &lt;code&gt;'utf-8'&lt;/code&gt; on Windows, the value returned by &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">기본 문자 인코딩 : Windows의 경우 &lt;code&gt;'utf-8'&lt;/code&gt; , 그렇지 않으면 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 값</target>
        </trans-unit>
        <trans-unit id="699b9c61ff10c5e5fb972c7c169896f4dd36a566" translate="yes" xml:space="preserve">
          <source>The default converters are registered under the name &amp;ldquo;date&amp;rdquo; for &lt;a href=&quot;datetime#datetime.date&quot;&gt;&lt;code&gt;datetime.date&lt;/code&gt;&lt;/a&gt; and under the name &amp;ldquo;timestamp&amp;rdquo; for &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 컨버터의 이름 &quot;날짜&quot;에 등록되어 &lt;a href=&quot;datetime#datetime.date&quot;&gt; &lt;code&gt;datetime.date&lt;/code&gt; &lt;/a&gt; 와의 이름 &quot;타임 스탬프&quot;에서 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3141ba81acf49f8773568f9b1b5765ab02702638" translate="yes" xml:space="preserve">
          <source>The default environment variables to be included in every request&amp;rsquo;s WSGI environment. By default, this is a copy of &lt;code&gt;os.environ&lt;/code&gt; at the time that &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt;&lt;code&gt;wsgiref.handlers&lt;/code&gt;&lt;/a&gt; was imported, but subclasses can either create their own at the class or instance level. Note that the dictionary should be considered read-only, since the default value is shared between multiple classes and instances.</source>
          <target state="translated">모든 요청의 WSGI 환경에 포함될 기본 환경 변수 기본적 으로 이는 &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt; &lt;code&gt;wsgiref.handlers&lt;/code&gt; &lt;/a&gt; 를 가져올 때 &lt;code&gt;os.environ&lt;/code&gt; 의 사본 이지만 서브 클래스는 클래스 또는 인스턴스 레벨에서 자체적으로 작성할 수 있습니다. 기본값은 여러 클래스와 인스턴스간에 공유되므로 사전은 읽기 전용으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="767891311ec1c9837f1ed84b97b20ded10b66b5a" translate="yes" xml:space="preserve">
          <source>The default exception handler implementation.</source>
          <target state="translated">기본 예외 처리기 구현</target>
        </trans-unit>
        <trans-unit id="3d5425253eafabfc0e77cfbd292665f236078454" translate="yes" xml:space="preserve">
          <source>The default for &lt;em&gt;start&lt;/em&gt; is 0, which means to start at the beginning of the file. The default for &lt;em&gt;len&lt;/em&gt; is 0 which means to lock to the end of the file. The default for &lt;em&gt;whence&lt;/em&gt; is also 0.</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 의 기본값 은 0이며 이는 파일의 시작 부분에서 시작 함을 의미합니다. &lt;em&gt;len&lt;/em&gt; 의 기본값 은 0이며 파일의 끝에 고정됩니다. &lt;em&gt;whence&lt;/em&gt; 의 기본값 도 0입니다.</target>
        </trans-unit>
        <trans-unit id="abe205ba756ba81b25d657d298d23ad7a01daa01" translate="yes" xml:space="preserve">
          <source>The default format for creating archives. This is currently &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt;&lt;code&gt;PAX_FORMAT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아카이브를 만들기위한 기본 형식입니다. 이것은 현재 &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt; &lt;code&gt;PAX_FORMAT&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9c328c8250ee7fbc742006787cb7e770c62bb77" translate="yes" xml:space="preserve">
          <source>The default hook formats &lt;em&gt;err_msg&lt;/em&gt; and &lt;em&gt;object&lt;/em&gt; as: &lt;code&gt;f'{err_msg}: {object!r}'&lt;/code&gt;; use &amp;ldquo;Exception ignored in&amp;rdquo; error message if &lt;em&gt;err_msg&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">기본 후크는 &lt;em&gt;err_msg&lt;/em&gt; 및 &lt;em&gt;오브젝트&lt;/em&gt; 를 다음 과 같이 형식화 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;f'{err_msg}: {object!r}'&lt;/code&gt; ; &lt;em&gt;err_msg&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우&amp;ldquo;예외 무시 됨&amp;rdquo;오류 메시지를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1589b3dd1729a28688aa3d39f228898b217d6cf6" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, formatted_err)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.errors&quot;&gt;&lt;code&gt;errors&lt;/code&gt;&lt;/a&gt; attribute, where &lt;em&gt;formatted_err&lt;/em&gt; is a formatted traceback derived from &lt;em&gt;err&lt;/em&gt;.</source>
          <target state="translated">기본 구현은 튜플 &lt;code&gt;(test, formatted_err)&lt;/code&gt; 을 인스턴스의 &lt;a href=&quot;#unittest.TestResult.errors&quot;&gt; &lt;code&gt;errors&lt;/code&gt; &lt;/a&gt; 속성에 추가합니다. 여기서 &lt;em&gt;formatted_err&lt;/em&gt; 은 &lt;em&gt;err&lt;/em&gt; 에서 파생 된 형식화 된 역 추적 입니다.</target>
        </trans-unit>
        <trans-unit id="b56f4f78eb0697ad959e9a5452169aa756143e2d" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, formatted_err)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.expectedFailures&quot;&gt;&lt;code&gt;expectedFailures&lt;/code&gt;&lt;/a&gt; attribute, where &lt;em&gt;formatted_err&lt;/em&gt; is a formatted traceback derived from &lt;em&gt;err&lt;/em&gt;.</source>
          <target state="translated">기본 구현은 튜플 &lt;code&gt;(test, formatted_err)&lt;/code&gt; 을 인스턴스의 &lt;a href=&quot;#unittest.TestResult.expectedFailures&quot;&gt; &lt;code&gt;expectedFailures&lt;/code&gt; &lt;/a&gt; 속성에 추가합니다. 여기서 &lt;em&gt;formatted_err&lt;/em&gt; 은 &lt;em&gt;err&lt;/em&gt; 에서 파생 된 형식화 된 역 추적 입니다.</target>
        </trans-unit>
        <trans-unit id="21d58dd74e7a05377422bda965cebdafd7e57ccd" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, formatted_err)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.failures&quot;&gt;&lt;code&gt;failures&lt;/code&gt;&lt;/a&gt; attribute, where &lt;em&gt;formatted_err&lt;/em&gt; is a formatted traceback derived from &lt;em&gt;err&lt;/em&gt;.</source>
          <target state="translated">기본 구현은 튜플 &lt;code&gt;(test, formatted_err)&lt;/code&gt; 을 인스턴스의 &lt;a href=&quot;#unittest.TestResult.failures&quot;&gt; &lt;code&gt;failures&lt;/code&gt; &lt;/a&gt; 속성에 추가합니다. 여기서 &lt;em&gt;formatted_err&lt;/em&gt; 은 &lt;em&gt;err&lt;/em&gt; 에서 파생 된 형식화 된 역 추적 입니다.</target>
        </trans-unit>
        <trans-unit id="43823f6cabcd0ef79ab62b973c7aee77f8f732d4" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, reason)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.skipped&quot;&gt;&lt;code&gt;skipped&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">기본 구현 은 인스턴스의 &lt;a href=&quot;#unittest.TestResult.skipped&quot;&gt; &lt;code&gt;skipped&lt;/code&gt; &lt;/a&gt; 속성에 튜플 &lt;code&gt;(test, reason)&lt;/code&gt; 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="a68c1418f74a6200967462b2f59268c9e36ca435" translate="yes" xml:space="preserve">
          <source>The default implementation appends the test to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.unexpectedSuccesses&quot;&gt;&lt;code&gt;unexpectedSuccesses&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">기본 구현은 테스트를 인스턴스의 &lt;a href=&quot;#unittest.TestResult.unexpectedSuccesses&quot;&gt; &lt;code&gt;unexpectedSuccesses&lt;/code&gt; &lt;/a&gt; 속성에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="85209bebc3f90535b12a5ecb3ddcc009e82c4607" translate="yes" xml:space="preserve">
          <source>The default implementation calls the &amp;lsquo;namer&amp;rsquo; attribute of the handler, if it&amp;rsquo;s callable, passing the default name to it. If the attribute isn&amp;rsquo;t callable (the default is &lt;code&gt;None&lt;/code&gt;), the name is returned unchanged.</source>
          <target state="translated">기본 구현은 핸들러의 'namer'속성을 호출 할 수있는 경우 기본 이름을 전달하여 처리기의 'namer'속성을 호출합니다. 속성을 호출 할 수없는 경우 (기본값은 &lt;code&gt;None&lt;/code&gt; ) 이름은 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7fe6b93c4fa5530304a79d65cec6508761d9ab" translate="yes" xml:space="preserve">
          <source>The default implementation calls the &amp;lsquo;rotator&amp;rsquo; attribute of the handler, if it&amp;rsquo;s callable, passing the source and dest arguments to it. If the attribute isn&amp;rsquo;t callable (the default is &lt;code&gt;None&lt;/code&gt;), the source is simply renamed to the destination.</source>
          <target state="translated">기본 구현은 핸들러의 'rotator'속성을 호출 가능하면 소스 및 대상 인수를 전달하여 호출합니다. 속성을 호출 할 수없는 경우 (기본값은 &lt;code&gt;None&lt;/code&gt; ) 소스의 이름 만 대상으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8abbab4876bdfe46805a30d39840791095f498ce" translate="yes" xml:space="preserve">
          <source>The default implementation calls the &lt;code&gt;append&lt;/code&gt; method of the &lt;code&gt;defects&lt;/code&gt; attribute of &lt;em&gt;obj&lt;/em&gt;. When the email package calls &lt;a href=&quot;#email.policy.Policy.handle_defect&quot;&gt;&lt;code&gt;handle_defect&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;obj&lt;/em&gt; will normally have a &lt;code&gt;defects&lt;/code&gt; attribute that has an &lt;code&gt;append&lt;/code&gt; method. Custom object types used with the email package (for example, custom &lt;code&gt;Message&lt;/code&gt; objects) should also provide such an attribute, otherwise defects in parsed messages will raise unexpected errors.</source>
          <target state="translated">기본 구현 은 &lt;em&gt;obj&lt;/em&gt; 의 &lt;code&gt;defects&lt;/code&gt; 속성의 &lt;code&gt;append&lt;/code&gt; 메소드를 호출합니다 . 전자 메일 패키지가 &lt;a href=&quot;#email.policy.Policy.handle_defect&quot;&gt; &lt;code&gt;handle_defect&lt;/code&gt; 를&lt;/a&gt; 호출 하면 &lt;em&gt;obj&lt;/em&gt; 는 일반적으로 &lt;code&gt;append&lt;/code&gt; 메소드 가있는 &lt;code&gt;defects&lt;/code&gt; 속성을 갖습니다 . 전자 메일 패키지와 함께 사용되는 사용자 정의 개체 유형 (예 : 사용자 정의 &lt;code&gt;Message&lt;/code&gt; 개체)도 그러한 속성을 제공해야합니다. 그렇지 않으면 구문 분석 된 메시지의 결함으로 인해 예기치 않은 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd2beae2a9d6bd5ba6ba29d1fa217c82f8717685" translate="yes" xml:space="preserve">
          <source>The default implementation checks the &lt;a href=&quot;#email.policy.Policy.raise_on_defect&quot;&gt;&lt;code&gt;raise_on_defect&lt;/code&gt;&lt;/a&gt; flag. If it is &lt;code&gt;True&lt;/code&gt;, &lt;em&gt;defect&lt;/em&gt; is raised as an exception. If it is &lt;code&gt;False&lt;/code&gt; (the default), &lt;em&gt;obj&lt;/em&gt; and &lt;em&gt;defect&lt;/em&gt; are passed to &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt;&lt;code&gt;register_defect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;#email.policy.Policy.raise_on_defect&quot;&gt; &lt;code&gt;raise_on_defect&lt;/code&gt; &lt;/a&gt; 플래그를 확인합니다 . 이 경우 &lt;code&gt;True&lt;/code&gt; , &lt;em&gt;결함은&lt;/em&gt; 예외로 발생합니다. 이 경우 &lt;code&gt;False&lt;/code&gt; (기본), &lt;em&gt;OBJ&lt;/em&gt; 및 &lt;em&gt;결함&lt;/em&gt; 에 전달되는 &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt; &lt;code&gt;register_defect()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4694874ec5c0e9b8375091742765ef75ea74e946" translate="yes" xml:space="preserve">
          <source>The default implementation decides how to dispatch a frame, depending on the type of event (passed as a string) that is about to be executed. &lt;em&gt;event&lt;/em&gt; can be one of the following:</source>
          <target state="translated">기본 구현은 실행하려고하는 이벤트 유형 (문자열로 전달됨)에 따라 프레임을 디스패치하는 방법을 결정합니다. &lt;em&gt;event&lt;/em&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b526d9bcd0fde98e256c446b3ae46e0b58b532" translate="yes" xml:space="preserve">
          <source>The default implementation defers to &lt;a href=&quot;#io.RawIOBase.readall&quot;&gt;&lt;code&gt;readall()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.RawIOBase.readinto&quot;&gt;&lt;code&gt;readinto()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;#io.RawIOBase.readall&quot;&gt; &lt;code&gt;readall()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.RawIOBase.readinto&quot;&gt; &lt;code&gt;readinto()&lt;/code&gt; &lt;/a&gt; 연기합니다 .</target>
        </trans-unit>
        <trans-unit id="30e7acef377f89e7b6c8ef2a0dae31deb9d115cc" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing when the outcome is a success, and records subtest failures as normal failures.</source>
          <target state="translated">기본 구현은 결과가 성공한 경우 아무 작업도 수행하지 않으며 하위 테스트 실패를 일반 실패로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67df62e256ec06c97f02e23b90b57d437ba78502" translate="yes" xml:space="preserve">
          <source>The default implementation first consults the environment variable &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-2&quot;&gt;&lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt;&lt;/a&gt;. If that is set to &lt;code&gt;&quot;0&quot;&lt;/code&gt; then this function returns immediately; i.e. it is a no-op. If the environment variable is not set, or is set to the empty string, &lt;code&gt;pdb.set_trace()&lt;/code&gt; is called. Otherwise this variable should name a function to run, using Python&amp;rsquo;s dotted-import nomenclature, e.g. &lt;code&gt;package.subpackage.module.function&lt;/code&gt;. In this case, &lt;code&gt;package.subpackage.module&lt;/code&gt; would be imported and the resulting module must have a callable named &lt;code&gt;function()&lt;/code&gt;. This is run, passing in &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kws&lt;/code&gt;, and whatever &lt;code&gt;function()&lt;/code&gt; returns, &lt;code&gt;sys.breakpointhook()&lt;/code&gt; returns to the built-in &lt;a href=&quot;functions#breakpoint&quot;&gt;&lt;code&gt;breakpoint()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">기본 구현은 먼저 환경 변수 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-2&quot;&gt; &lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt; 를 참조&lt;/a&gt; 합니다. 이것이 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 으로 설정되면 이 함수는 즉시 리턴합니다. 즉, 그것은 no-op입니다. 환경 변수가 설정되지 않거나 빈 문자열로 설정된 경우 &lt;code&gt;pdb.set_trace()&lt;/code&gt; 가 호출됩니다. 그렇지 않으면이 변수는 Python의 점으로 불러 오기 된 명명법 (예 : &lt;code&gt;package.subpackage.module.function&lt;/code&gt; )을 사용하여 실행할 함수의 이름을 지정해야 합니다 . 이 경우 &lt;code&gt;package.subpackage.module&lt;/code&gt; 을 가져오고 결과 모듈에는 호출 가능한 이름이 지정된 &lt;code&gt;function()&lt;/code&gt; 이 있어야합니다 . &lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kws&lt;/code&gt; 를 전달하여 실행되며 &lt;code&gt;function()&lt;/code&gt; 반환하는 모든 것이 &lt;code&gt;sys.breakpointhook()&lt;/code&gt; 은 내장 &lt;a href=&quot;functions#breakpoint&quot;&gt; &lt;code&gt;breakpoint()&lt;/code&gt; &lt;/a&gt; 함수로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="f74656a8a819a518271e05ab776cc077ee5133d3" translate="yes" xml:space="preserve">
          <source>The default implementation for both functions will read and return up to 1024 bytes each time the function is called. The &lt;em&gt;master_read&lt;/em&gt; callback is passed the pseudoterminal&amp;rsquo;s master file descriptor to read output from the child process, and &lt;em&gt;stdin_read&lt;/em&gt; is passed file descriptor 0, to read from the parent process&amp;rsquo;s standard input.</source>
          <target state="translated">두 함수의 기본 구현은 함수가 호출 될 때마다 최대 1024 바이트를 읽고 반환합니다. &lt;em&gt;master_read의&lt;/em&gt; 콜백 자식 프로세스의 출력을 읽을 수있는 의사 터의 마스터 파일 기술자를 전달하고, &lt;em&gt;stdin_read는&lt;/em&gt; 부모 프로세스의 표준 입력에서 읽고, 파일 기술자 0을 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b33ae6a6fa76317fab7538fb2a3cca4c005e4023" translate="yes" xml:space="preserve">
          <source>The default implementation just uses the &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_status&quot;&gt;&lt;code&gt;error_status&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_headers&quot;&gt;&lt;code&gt;error_headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_body&quot;&gt;&lt;code&gt;error_body&lt;/code&gt;&lt;/a&gt; attributes to generate an output page. Subclasses can override this to produce more dynamic error output.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_status&quot;&gt; &lt;code&gt;error_status&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_headers&quot;&gt; &lt;code&gt;error_headers&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_body&quot;&gt; &lt;code&gt;error_body&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 출력 페이지를 생성합니다. 서브 클래스가이를 대체하여보다 동적 인 오류 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90a3901aebe023145f5de84c1fe64e79959585c1" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt;&lt;code&gt;dst()&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt; &lt;code&gt;dst()&lt;/code&gt; &lt;/a&gt; 의 기본 구현 은 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="16085cdaef9820e3e043c1b7e4309f2a7ae3234c" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;a href=&quot;#datetime.tzinfo.tzname&quot;&gt;&lt;code&gt;tzname()&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo.tzname&quot;&gt; &lt;code&gt;tzname()&lt;/code&gt; &lt;/a&gt; 의 기본 구현 은 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="eaa2ded4dfd4b8b4517a84086b0a0546ef2a859e" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 기본 구현 &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 제기 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82debffda06a601a8240a52d0811cf0e418c2167" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does not strictly follow &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt;, which says that 301 and 302 responses to &lt;code&gt;POST&lt;/code&gt; requests must not be automatically redirected without confirmation by the user. In reality, browsers do allow automatic redirection of these responses, changing the POST to a &lt;code&gt;GET&lt;/code&gt;, and the default implementation reproduces this behavior.</source>
          <target state="translated">이 방법의 기본 구현은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2616을&lt;/strong&gt;&lt;/a&gt; 엄격하게 따르지 않으며 , 이는 &lt;code&gt;POST&lt;/code&gt; 요청에 대한 301 및 302 응답 이 사용자의 확인없이 자동으로 리디렉션되지 않아야 한다고 말합니다 . 실제로 브라우저는 이러한 응답의 자동 리디렉션을 허용하여 POST를 &lt;code&gt;GET&lt;/code&gt; 으로 변경 하며 기본 구현은이 동작을 재현합니다.</target>
        </trans-unit>
        <trans-unit id="13b55b955e1b08c46172d6efc871c03e0099cb57" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;None&lt;/code&gt; for all header names.</source>
          <target state="translated">기본 구현은 모든 헤더 이름에 대해 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="725d6d53b5cf3c3613770adb4e50064aa80e4e7a" translate="yes" xml:space="preserve">
          <source>The default implementation used by &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt;. It enables values to contain format strings which refer to other values in the same section, or values in the special default section &lt;a href=&quot;#id14&quot; id=&quot;id9&quot;&gt;1&lt;/a&gt;. Additional default values can be provided on initialization.</source>
          <target state="translated">&lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; 가&lt;/a&gt; 사용하는 기본 구현 입니다. 동일한 섹션의 다른 값 또는 특수 기본 섹션 &lt;a href=&quot;#id14&quot; id=&quot;id9&quot;&gt;1의&lt;/a&gt; 값을 참조하는 형식 문자열을 값에 포함 할 수 있습니다 . 초기화시 추가 기본값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd0ce3c256ee146bb362a470cd49483296837acf" translate="yes" xml:space="preserve">
          <source>The default is &amp;ldquo;tree headings&amp;rdquo;, i.e., show all elements.</source>
          <target state="translated">기본값은 &quot;트리 제목&quot;입니다. 즉, 모든 요소를 ​​표시합니다.</target>
        </trans-unit>
        <trans-unit id="4a764b527c8c39c412a231d74d381ecae9e42fbc" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b02b629dda45d997c18db19eedefdbf65477e98" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;long&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="814a9a510f2c1120c69400a1ceca8ba606beab6f" translate="yes" xml:space="preserve">
          <source>The default locale directory is system dependent; for example, on RedHat Linux it is &lt;code&gt;/usr/share/locale&lt;/code&gt;, but on Solaris it is &lt;code&gt;/usr/lib/locale&lt;/code&gt;. The &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module does not try to support these system dependent defaults; instead its default is &lt;code&gt;&lt;em&gt;sys.prefix&lt;/em&gt;/share/locale&lt;/code&gt; (see &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt;). For this reason, it is always best to call &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt;&lt;code&gt;bindtextdomain()&lt;/code&gt;&lt;/a&gt; with an explicit absolute path at the start of your application.</source>
          <target state="translated">기본 로케일 디렉토리는 시스템에 따라 다릅니다. 예를 들어 RedHat Linux에서는 &lt;code&gt;/usr/share/locale&lt;/code&gt; 이지만 Solaris에서는 &lt;code&gt;/usr/lib/locale&lt;/code&gt; 입니다. &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈은 이러한 시스템에 의존 기본값을 지원하지 않습니다 대신 기본값은 &lt;code&gt;&lt;em&gt;sys.prefix&lt;/em&gt;/share/locale&lt;/code&gt; 입니다 ( &lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt; 참조 ). 따라서 항상 응용 프로그램 시작시 명시 적 절대 경로를 사용하여 &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt; &lt;code&gt;bindtextdomain()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="794f48952ceef8edd0efaf6e7f1edca546f6b6ec" translate="yes" xml:space="preserve">
          <source>The default log level is &lt;code&gt;logging.INFO&lt;/code&gt;, which can be easily adjusted:</source>
          <target state="translated">기본 로그 레벨은 &lt;code&gt;logging.INFO&lt;/code&gt; 이며 쉽게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c10a46682ece55208f06ff3244ee92307d192950" translate="yes" xml:space="preserve">
          <source>The default mappings are:</source>
          <target state="translated">기본 매핑은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf79d526fbfe64d1c7da84c2d5bc4927946eb59b" translate="yes" xml:space="preserve">
          <source>The default message can be overridden with the &lt;code&gt;usage=&lt;/code&gt; keyword argument:</source>
          <target state="translated">기본 메시지는 &lt;code&gt;usage=&lt;/code&gt; 키워드 인수 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="141a3d8b5d2695d6fbe0a56d367c38aab3863374" translate="yes" xml:space="preserve">
          <source>The default mode is &lt;code&gt;'r'&lt;/code&gt; (open for reading text, synonym of &lt;code&gt;'rt'&lt;/code&gt;). Modes &lt;code&gt;'w+'&lt;/code&gt; and &lt;code&gt;'w+b'&lt;/code&gt; open and truncate the file. Modes &lt;code&gt;'r+'&lt;/code&gt; and &lt;code&gt;'r+b'&lt;/code&gt; open the file with no truncation.</source>
          <target state="translated">기본 모드는 &lt;code&gt;'r'&lt;/code&gt; (텍스트를 읽기 위해 열리고 &lt;code&gt;'rt'&lt;/code&gt; 와 동의어 임 )입니다. &lt;code&gt;'w+'&lt;/code&gt; 및 &lt;code&gt;'w+b'&lt;/code&gt; 모드 는 파일을 열고 자릅니다. &lt;code&gt;'r+'&lt;/code&gt; 및 &lt;code&gt;'r+b'&lt;/code&gt; 모드 는 파일을 자르지 않고 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="03390741ae3195ccf5b5eb50f31c643c59a729d2" translate="yes" xml:space="preserve">
          <source>The default mode which is used to load shared libraries. On OSX 10.3, this is &lt;em&gt;RTLD_GLOBAL&lt;/em&gt;, otherwise it is the same as &lt;em&gt;RTLD_LOCAL&lt;/em&gt;.</source>
          <target state="translated">공유 라이브러리를로드하는 데 사용되는 기본 모드입니다. OSX 10.3에서는 &lt;em&gt;RTLD_GLOBAL&lt;/em&gt; 이고, 그렇지 않으면 &lt;em&gt;RTLD_LOCAL&lt;/em&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="73d6ea81836b7e091d9707bef84bfc523b16338a" translate="yes" xml:space="preserve">
          <source>The default opener raises an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;urllib.Request&lt;/code&gt; with arguments &lt;code&gt;fullurl&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;headers&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt; taken from the request object.</source>
          <target state="translated">기본 오프너 는 인수 &lt;code&gt;fullurl&lt;/code&gt; , &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;headers&lt;/code&gt; , 요청 객체에서 가져온 &lt;code&gt;method&lt;/code&gt; 와 함께 &lt;code&gt;urllib.Request&lt;/code&gt; &lt;a href=&quot;sys#auditing&quot;&gt;감사 이벤트를 발생 &lt;/a&gt;시킵니다 .</target>
        </trans-unit>
        <trans-unit id="39acba55dd14c83398ea0bbfc6e7d2a50c30c9e7" translate="yes" xml:space="preserve">
          <source>The default ordering of tests created by the unittest test loaders is to group all tests from the same modules and classes together. This will lead to &lt;code&gt;setUpClass&lt;/code&gt; / &lt;code&gt;setUpModule&lt;/code&gt; (etc) being called exactly once per class and module. If you randomize the order, so that tests from different modules and classes are adjacent to each other, then these shared fixture functions may be called multiple times in a single test run.</source>
          <target state="translated">unittest 테스트 로더에 의해 생성 된 테스트의 기본 순서는 동일한 모듈과 클래스의 모든 테스트를 그룹화하는 것입니다. 이로 인해 클래스와 모듈 당 &lt;code&gt;setUpClass&lt;/code&gt; / &lt;code&gt;setUpModule&lt;/code&gt; 등이 정확히 한 번만 호출됩니다. 다른 모듈과 클래스의 테스트가 서로 인접하도록 순서를 무작위로 지정하면 단일 테스트 실행에서 이러한 공유 설비 기능을 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a58a0491ff3eb550980796cd579ce9dfd157abf1" translate="yes" xml:space="preserve">
          <source>The default port for the HTTP protocol (always &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">HTTP 프로토콜의 기본 포트입니다 (항상 &lt;code&gt;80&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="425beadae2e2f6a2971a75d3712f9625b055af90" translate="yes" xml:space="preserve">
          <source>The default port for the HTTPS protocol (always &lt;code&gt;443&lt;/code&gt;).</source>
          <target state="translated">HTTPS 프로토콜의 기본 포트 (항상 &lt;code&gt;443&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="30751022518c3e586bbf05c4dc10e57e1471f76b" translate="yes" xml:space="preserve">
          <source>The default return value is a mock object and you can configure it in the normal way:</source>
          <target state="translated">기본 반환 값은 모의 객체이며 일반적인 방식으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a346496310974b8e67170483456ec9392111fd" translate="yes" xml:space="preserve">
          <source>The default scheduling policy.</source>
          <target state="translated">기본 스케줄링 정책.</target>
        </trans-unit>
        <trans-unit id="c002f3ffcf614b415ab0107e01446f36339d947d" translate="yes" xml:space="preserve">
          <source>The default search path used by &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*p*&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*p*&lt;/code&gt;&lt;/a&gt; if the environment doesn&amp;rsquo;t have a &lt;code&gt;'PATH'&lt;/code&gt; key. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경에 &lt;code&gt;'PATH'&lt;/code&gt; 키 가없는 경우 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*p*&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*p*&lt;/code&gt; &lt;/a&gt; 사용하는 기본 검색 경로 입니다. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="3efa5b275105c170638fc7b7f17c83558f25e9f6" translate="yes" xml:space="preserve">
          <source>The default selector class, using the most efficient implementation available on the current platform. This should be the default choice for most users.</source>
          <target state="translated">현재 플랫폼에서 사용 가능한 가장 효율적인 구현을 사용하는 기본 선택기 클래스입니다. 대부분의 사용자에게 이것이 기본 선택입니다.</target>
        </trans-unit>
        <trans-unit id="3ca70f786f3be38669a0f5f13987139bc5f61d99" translate="yes" xml:space="preserve">
          <source>The default setting is determined by calling &lt;a href=&quot;#locale.getdefaultlocale&quot;&gt;&lt;code&gt;getdefaultlocale()&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;category&lt;/em&gt; defaults to &lt;a href=&quot;#locale.LC_ALL&quot;&gt;&lt;code&gt;LC_ALL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 설정은 &lt;a href=&quot;#locale.getdefaultlocale&quot;&gt; &lt;code&gt;getdefaultlocale()&lt;/code&gt; &lt;/a&gt; 을 호출하여 결정됩니다 . &lt;em&gt;카테고리의&lt;/em&gt; 기본값은 &lt;a href=&quot;#locale.LC_ALL&quot;&gt; &lt;code&gt;LC_ALL&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="043146855b6cd351175d4c3c050e9e53a9299fde" translate="yes" xml:space="preserve">
          <source>The default timer, which is always &lt;a href=&quot;time#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 타이머는 항상 &lt;a href=&quot;time#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e880a55fe07fce5b685fc9b8ca7365567a017ce2" translate="yes" xml:space="preserve">
          <source>The default traceback display code shows these chained exceptions in addition to the traceback for the exception itself. An explicitly chained exception in &lt;code&gt;__cause__&lt;/code&gt; is always shown when present. An implicitly chained exception in &lt;code&gt;__context__&lt;/code&gt; is shown only if &lt;code&gt;__cause__&lt;/code&gt; is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;__suppress_context__&lt;/code&gt; is false.</source>
          <target state="translated">기본 역 추적 표시 코드는 예외 자체에 대한 역 추적 외에도 이러한 체인 예외를 표시합니다. &lt;code&gt;__cause__&lt;/code&gt; 에 명시 적으로 연결된 예외 는 항상 존재합니다. &lt;code&gt;__context__&lt;/code&gt; 의 암시 적으로 연결된 예외는 &lt;code&gt;__cause__&lt;/code&gt; 가 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;__suppress_context__&lt;/code&gt; 가 false 인 경우에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a3e28e031082803bf5f54778e88107b6b7e3956" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;a href=&quot;#email.policy.Policy.message_factory&quot;&gt;&lt;code&gt;message_factory&lt;/code&gt;&lt;/a&gt; attribute is &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#email.policy.Policy.message_factory&quot;&gt; &lt;code&gt;message_factory&lt;/code&gt; &lt;/a&gt; 속성 의 기본값 은 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e2dbad85c6df37fd7251dd032bd384d20f99676" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;em&gt;policy&lt;/em&gt; keyword for the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; classes and the parser convenience functions &lt;strong&gt;will be changing&lt;/strong&gt; in a future version of Python. Therefore you should &lt;strong&gt;always specify explicitly which policy you want to use&lt;/strong&gt; when calling any of the classes and functions described in the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;em&gt;정책&lt;/em&gt; 키워드 및 파서 편의 함수 의 기본값 은 이후 버전의 Python에서 &lt;strong&gt;변경 될 예정&lt;/strong&gt; 입니다. 따라서 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈에 설명 된 클래스와 함수를 호출 할 때 &lt;strong&gt;항상 사용할 정책을 명시 적으로 지정&lt;/strong&gt; 해야 합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="144a7dcfe8a056320c86d88ccef9dfb777d3754c" translate="yes" xml:space="preserve">
          <source>The default value for the parameter. If the parameter has no default value, this attribute is set to &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt;&lt;code&gt;Parameter.empty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수의 기본값입니다. 매개 변수에 기본값이 없으면이 속성은 &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt; &lt;code&gt;Parameter.empty&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa35640f1a27bf8e96f3301b8c8fd0e1450703e6" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;True&lt;/code&gt; if the environment variable &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt;&lt;/a&gt; is set to a non-empty string, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">환경 변수 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt; &lt;/a&gt; 가 비어 있지 않은 문자열로 설정 되면 기본값은 &lt;code&gt;True&lt;/code&gt; 이고 , &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다.</target>
        </trans-unit>
        <trans-unit id="ca3fe88381a2828f01851afbbbb72484af83f4b3" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;True&lt;/code&gt;. If Python is compiled without threads, the C version automatically disables the expensive thread local context machinery. In this case, the value is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;True&lt;/code&gt; 입니다. 파이썬이 스레드없이 컴파일되면 C 버전은 자동으로 비싼 스레드 로컬 컨텍스트 기계를 비활성화합니다. 이 경우 값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e1de354cd457579854e47a6cc794e8c9ac39320" translate="yes" xml:space="preserve">
          <source>The default values are &lt;code&gt;prec&lt;/code&gt;=&lt;code&gt;28&lt;/code&gt;, &lt;code&gt;rounding&lt;/code&gt;=&lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt;&lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt;&lt;/a&gt;, and enabled traps for &lt;a href=&quot;#decimal.Overflow&quot;&gt;&lt;code&gt;Overflow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;prec&lt;/code&gt; = &lt;code&gt;28&lt;/code&gt; , &lt;code&gt;rounding&lt;/code&gt; = &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt; &lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt; &lt;/a&gt; 이며 &lt;a href=&quot;#decimal.Overflow&quot;&gt; &lt;code&gt;Overflow&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; 에&lt;/a&gt; 대해 활성화 된 트랩입니다 .</target>
        </trans-unit>
        <trans-unit id="7299c60092b16e730787f8b6c4a0d4d274cb1509" translate="yes" xml:space="preserve">
          <source>The defaults are implementation-specific. If only the high watermark is given, the low watermark defaults to an implementation-specific value less than or equal to the high watermark. Setting &lt;em&gt;high&lt;/em&gt; to zero forces &lt;em&gt;low&lt;/em&gt; to zero as well, and causes &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt;&lt;code&gt;pause_writing()&lt;/code&gt;&lt;/a&gt; to be called whenever the buffer becomes non-empty. Setting &lt;em&gt;low&lt;/em&gt; to zero causes &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt;&lt;code&gt;resume_writing()&lt;/code&gt;&lt;/a&gt; to be called only once the buffer is empty. Use of zero for either limit is generally sub-optimal as it reduces opportunities for doing I/O and computation concurrently.</source>
          <target state="translated">기본값은 구현에 따라 다릅니다. 상위 워터 마크 만 제공되는 경우 하위 워터 마크는 기본적으로 상위 워터 마크 이하의 구현 별 값으로 설정됩니다. &lt;em&gt;high&lt;/em&gt; 를 0으로 설정하면 &lt;em&gt;low&lt;/em&gt; 도 0이되고 버퍼가 비어 있지 않을 때마다 &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt; &lt;code&gt;pause_writing()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. &lt;em&gt;low&lt;/em&gt; 로 0으로 설정 하면 버퍼가 비었을 때만 &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt; &lt;code&gt;resume_writing()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. I / O 및 계산을 동시에 수행 할 수있는 기회가 줄어들 기 때문에 어느 한 한계에 0을 사용하는 것은 일반적으로 차선책입니다.</target>
        </trans-unit>
        <trans-unit id="221847e9edd5eaa3b267e4d1c2549650caad5b6f" translate="yes" xml:space="preserve">
          <source>The definition of the DOM API for Python is given as part of the &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; module documentation. This section lists the differences between the API and &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 용 DOM API의 정의는 &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt; 모듈 문서의 일부로 제공됩니다 . 이 섹션에는 API와 &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 의 차이점이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="943baea73b814dec74b8d72bb621d33b0bfe1d54" translate="yes" xml:space="preserve">
          <source>The definitive documentation for the DOM is the DOM specification from the W3C.</source>
          <target state="translated">DOM에 대한 결정적인 문서는 W3C의 DOM 사양입니다.</target>
        </trans-unit>
        <trans-unit id="5e673798c7b447103357a31e16119d6dac467057" translate="yes" xml:space="preserve">
          <source>The delta filter stores the differences between bytes, producing more repetitive input for the compressor in certain circumstances. It supports one option, &lt;code&gt;dist&lt;/code&gt;. This indicates the distance between bytes to be subtracted. The default is 1, i.e. take the differences between adjacent bytes.</source>
          <target state="translated">델타 필터는 바이트 간 차이를 저장하여 특정 상황에서 압축기에 대한 반복적 인 입력을 생성합니다. 하나의 옵션 인 &lt;code&gt;dist&lt;/code&gt; 를 지원합니다 . 빼야 할 바이트 사이의 거리를 나타냅니다. 기본값은 1입니다. 즉, 인접 바이트 간 차이를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0b079df41b809fa4419856c946739f02648c68a2" translate="yes" xml:space="preserve">
          <source>The demo scripts are:</source>
          <target state="translated">데모 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf9ee77bb8cddcf823d4f4ddb3095b093bcd8b4a" translate="yes" xml:space="preserve">
          <source>The descriptors returned by these functions are instances of Function and Class classes. Users are not expected to create instances of these classes.</source>
          <target state="translated">이 함수들에 의해 리턴 된 디스크립터는 Function 및 Class 클래스의 인스턴스입니다. 사용자는 이러한 클래스의 인스턴스를 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0da76bef1aa2212782aa0ff026cf66c2f179b048" translate="yes" xml:space="preserve">
          <source>The design is such that one can use the factory functions returned by the &lt;a href=&quot;#codecs.lookup&quot;&gt;&lt;code&gt;lookup()&lt;/code&gt;&lt;/a&gt; function to construct the instance.</source>
          <target state="translated">디자인은 &lt;a href=&quot;#codecs.lookup&quot;&gt; &lt;code&gt;lookup()&lt;/code&gt; &lt;/a&gt; 함수가 반환 한 팩토리 함수를 사용 하여 인스턴스를 구성 할 수 있도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e304666702c62ac9c3cf811c3a927f2350dc8077" translate="yes" xml:space="preserve">
          <source>The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function &lt;code&gt;os.stat(path)&lt;/code&gt; returns stat information about &lt;em&gt;path&lt;/em&gt; in the same format (which happens to have originated with the POSIX interface).</source>
          <target state="translated">내장 된 모든 운영 체제 의존적 파이썬 모듈의 설계는 동일한 기능을 사용할 수있는 한 동일한 인터페이스를 사용합니다. 예를 들어, &lt;code&gt;os.stat(path)&lt;/code&gt; 함수 는 POSIX 인터페이스에서 시작된 동일한 형식의 &lt;em&gt;경로&lt;/em&gt; 에 대한 통계 정보를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="906a6d45a451c5d5583451af0ec9ab63f8309bb8" translate="yes" xml:space="preserve">
          <source>The design of this module is loosely based on Java&amp;rsquo;s threading model. However, where Java makes locks and condition variables basic behavior of every object, they are separate objects in Python. Python&amp;rsquo;s &lt;a href=&quot;#threading.Thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; class supports a subset of the behavior of Java&amp;rsquo;s Thread class; currently, there are no priorities, no thread groups, and threads cannot be destroyed, stopped, suspended, resumed, or interrupted. The static methods of Java&amp;rsquo;s Thread class, when implemented, are mapped to module-level functions.</source>
          <target state="translated">이 모듈의 디자인은 Java의 스레딩 모델을 기반으로합니다. 그러나 Java가 잠금 및 조건 변수를 모든 객체의 기본 동작으로 만드는 경우 Python에서 별도의 객체입니다. Python의 &lt;a href=&quot;#threading.Thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 클래스는 Java의 Thread 클래스 동작의 하위 세트를 지원합니다. 현재 우선 순위가없고 스레드 그룹이 없으며 스레드를 삭제, 중지, 일시 중단, 재개 또는 중단 할 수 없습니다. Java 스레드 클래스의 정적 메소드는 구현시 모듈 레벨 함수에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="c00c1643f45af0e7e9eae104f3f428178b879e63" translate="yes" xml:space="preserve">
          <source>The destination format is restricted to a single element native format in &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; syntax. One of the formats must be a byte format (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;b&amp;rsquo; or &amp;lsquo;c&amp;rsquo;). The byte length of the result must be the same as the original length.</source>
          <target state="translated">대상 형식은 &lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 구문 에서 단일 요소 기본 형식으로 제한됩니다 . 형식 중 하나는 바이트 형식이어야합니다 ( 'B', 'b'또는 'c'). 결과의 바이트 길이는 원래 길이와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="853310cf1caf3d9ea6dbb0a860eb9bb473765452" translate="yes" xml:space="preserve">
          <source>The destination location must be writable; otherwise, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception will be raised. If &lt;em&gt;dst&lt;/em&gt; already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function.</source>
          <target state="translated">대상 위치는 쓰기 가능해야합니다. 그렇지 않으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 경우 &lt;em&gt;DST가&lt;/em&gt; 이미 존재, 그것은 대체됩니다. 문자 또는 블록 장치 및 파이프와 같은 특수 파일은이 기능으로 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="12a01ce48953ff6624ef00113b65baf1192d859c" translate="yes" xml:space="preserve">
          <source>The detailed specification, implementation details and examples.</source>
          <target state="translated">자세한 사양, 구현 세부 사항 및 예</target>
        </trans-unit>
        <trans-unit id="a567d6a1a9be2c908411e43745159c73a975ef4b" translate="yes" xml:space="preserve">
          <source>The details of character conversion in &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; are controlled by the &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; keyword arguments of the &lt;a href=&quot;#tarfile.TarFile&quot;&gt;&lt;code&gt;TarFile&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 의 문자 변환에 대한 세부 사항은 &lt;a href=&quot;#tarfile.TarFile&quot;&gt; &lt;code&gt;TarFile&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 키워드 인수에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="34da012fa9dff8518788c0b3d7cb092045825a91" translate="yes" xml:space="preserve">
          <source>The details of this function differ on Unix and Windows.</source>
          <target state="translated">이 기능의 세부 사항은 Unix와 Windows에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a14d6055539d17fe330c28c0379041872d8cb00d" translate="yes" xml:space="preserve">
          <source>The determination whether to issue a warning message is controlled by the &lt;a href=&quot;#warning-filter&quot;&gt;warning filter&lt;/a&gt;, which is a sequence of matching rules and actions. Rules can be added to the filter by calling &lt;a href=&quot;#warnings.filterwarnings&quot;&gt;&lt;code&gt;filterwarnings()&lt;/code&gt;&lt;/a&gt; and reset to its default state by calling &lt;a href=&quot;#warnings.resetwarnings&quot;&gt;&lt;code&gt;resetwarnings()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경고 메시지를 발행할지 여부 는 규칙 및 조치와 일치하는 &lt;a href=&quot;#warning-filter&quot;&gt;경고 필터에&lt;/a&gt; 의해 제어됩니다 . 규칙 호출하여 필터에 추가 할 수 있습니다 &lt;a href=&quot;#warnings.filterwarnings&quot;&gt; &lt;code&gt;filterwarnings()&lt;/code&gt; &lt;/a&gt; 하고 호출하여 기본 상태로 재설정 &lt;a href=&quot;#warnings.resetwarnings&quot;&gt; &lt;code&gt;resetwarnings()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73dca0bcff737d2d3b02394f5fe723496528dac5" translate="yes" xml:space="preserve">
          <source>The dictionary passed to &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; must contain the following keys:</source>
          <target state="translated">&lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 전달 된 사전 에는 다음 키가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a309b10a0ef1998ea5956b5985c47332b3ca7484" translate="yes" xml:space="preserve">
          <source>The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):</source>
          <target state="translated">얕은 복사와 깊은 복사의 차이점은 복합 객체 (목록 또는 클래스 인스턴스와 같은 다른 객체를 포함하는 객체)에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="f13a9d0f0f57f180befad466255cd497424b6d22" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;code&gt;readline()&lt;/code&gt; call in the second handler will call &lt;code&gt;recv()&lt;/code&gt; multiple times until it encounters a newline character, while the single &lt;code&gt;recv()&lt;/code&gt; call in the first handler will just return what has been sent from the client in one &lt;code&gt;sendall()&lt;/code&gt; call.</source>
          <target state="translated">차이점은 두 번째 핸들러 의 &lt;code&gt;readline()&lt;/code&gt; 호출은 개행 문자가 발생할 때까지 &lt;code&gt;recv()&lt;/code&gt; 여러 번 호출 하는 반면 첫 번째 핸들러 의 단일 &lt;code&gt;recv()&lt;/code&gt; 호출은 클라이언트에서 보낸 것을 하나만 반환한다는 것입니다. &lt;code&gt;sendall()&lt;/code&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="7f4ce614fc3c5ce47e342e7509a9fcd6e2263cba" translate="yes" xml:space="preserve">
          <source>The dircmp class</source>
          <target state="translated">dircmp 클래스</target>
        </trans-unit>
        <trans-unit id="5b186c9536ac444951a67e97a0ba165a32d7d506" translate="yes" xml:space="preserve">
          <source>The directories are allowed to exist (for when an existing environment is being upgraded).</source>
          <target state="translated">기존 환경을 업그레이드 할 때 디렉토리가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed7571611b51b5a7d9d0b2c98a40156f70c51d5" translate="yes" xml:space="preserve">
          <source>The directory &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">디렉토리 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39cd511f81d10b80603aff273f9c039527add995" translate="yes" xml:space="preserve">
          <source>The directory &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">디렉토리 &lt;em&gt;b&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2d510cfc449c5e8636e56f356ec78fb5d4b7cfca" translate="yes" xml:space="preserve">
          <source>The directory can be explicitly cleaned up by calling the &lt;code&gt;cleanup()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;cleanup()&lt;/code&gt; 메소드를 호출하여 디렉토리를 명시 적으로 정리할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6990eba23c2a267e829ead12a6b14c528cdac3d4" translate="yes" xml:space="preserve">
          <source>The directory is opaque when viewed through a union stack.</source>
          <target state="translated">통합 스택을 통해 볼 때 디렉토리가 불투명합니다.</target>
        </trans-unit>
        <trans-unit id="2357d402069095a1d69201172b2c12576d482c6c" translate="yes" xml:space="preserve">
          <source>The directory name can be retrieved from the &lt;code&gt;name&lt;/code&gt; attribute of the returned object. When the returned object is used as a context manager, the &lt;code&gt;name&lt;/code&gt; will be assigned to the target of the &lt;code&gt;as&lt;/code&gt; clause in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, if there is one.</source>
          <target state="translated">리턴 된 오브젝트 의 &lt;code&gt;name&lt;/code&gt; 속성 에서 디렉토리 이름을 검색 할 수 있습니다 . 리턴 된 오브젝트가 컨텍스트 관리자로 사용될 때, &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 &lt;code&gt;as&lt;/code&gt; 절의 대상에 &lt;code&gt;name&lt;/code&gt; 이 지정됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="b35f56c191faad6472c0141b116290aca2391a78" translate="yes" xml:space="preserve">
          <source>The directory named by the &lt;code id=&quot;index-1&quot;&gt;TMPDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-1&quot;&gt;TMPDIR&lt;/code&gt; 환경 변수에 의해 명명 된 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="29814fe7aa509a2b063de5230c93f3cba90feca2" translate="yes" xml:space="preserve">
          <source>The directory named by the &lt;code id=&quot;index-2&quot;&gt;TEMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-2&quot;&gt;TEMP&lt;/code&gt; 환경 변수에 의해 명명 된 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="4f86539184fc4d2d2f0f9bffd91b762cb482c710" translate="yes" xml:space="preserve">
          <source>The directory named by the &lt;code id=&quot;index-3&quot;&gt;TMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-3&quot;&gt;TMP&lt;/code&gt; 환경 변수에 의해 명명 된 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="bd4aec7dd167f631c8a4341121b8d6994d521f9b" translate="yes" xml:space="preserve">
          <source>The disadvantage of a self-signed certificate is that it is its own root certificate, and no one else will have it in their cache of known (and trusted) root certificates.</source>
          <target state="translated">자체 서명 된 인증서의 단점은 자체 루트 인증서이며 다른 누구도 알려진 (및 신뢰할 수있는) 루트 인증서의 캐시에 인증서를 가지고 있지 않다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4d43bffa96f6204d6ae5629ccd514e5d9ce5afe" translate="yes" xml:space="preserve">
          <source>The disassembly is written as text to the supplied &lt;em&gt;file&lt;/em&gt; argument if provided and to &lt;code&gt;sys.stdout&lt;/code&gt; otherwise.</source>
          <target state="translated">디스 어셈블리는 제공된 경우 제공된 &lt;em&gt;파일&lt;/em&gt; 인수 및 다른 경우 에는 &lt;code&gt;sys.stdout&lt;/code&gt; 에 텍스트로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b60e6af892f070f5741292c864890daf4177c61" translate="yes" xml:space="preserve">
          <source>The disk balancing algorithms which are current, nowadays, are more annoying than clever, and this is a consequence of the seeking capabilities of the disks. On devices which cannot seek, like big tape drives, the story was quite different, and one had to be very clever to ensure (far in advance) that each tape movement will be the most effective possible (that is, will best participate at &amp;ldquo;progressing&amp;rdquo; the merge). Some tapes were even able to read backwards, and this was also used to avoid the rewinding time. Believe me, real good tape sorts were quite spectacular to watch! From all times, sorting has always been a Great Art! :-)</source>
          <target state="translated">요즘 최신 디스크 밸런싱 알고리즘은 영리한 것보다 더 성가 시며 이는 디스크의 탐색 기능의 결과입니다. 큰 테이프 드라이브와 같이 구할 수없는 장치에서는 그 이야기가 상당히 달랐으며 각 테이프 움직임이 가장 효과적 일 것임을 보장하기 위해 (훨씬 미리) 매우 똑똑해야했습니다. 진행 중&amp;rdquo;). 일부 테이프는 뒤로 읽을 수도 있었으며 되감기 시간을 피하기 위해 사용되었습니다. 믿어, 진짜 좋은 테이프 종류는 볼 매우 훌륭했습니다! 항상 정렬은 항상 위대한 예술이었습니다! :-)</target>
        </trans-unit>
        <trans-unit id="de4509458b5999b814732a12ee716e1291daa74d" translate="yes" xml:space="preserve">
          <source>The display name portion of the address, if any, with all quoting removed. If the address does not have a display name, this attribute will be an empty string.</source>
          <target state="translated">모든 인용 부호가 제거 된 주소의 표시 이름 부분입니다 (있는 경우). 주소에 표시 이름이 없으면이 속성은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b3ffe664da088c28c4dfb305539a430b26d2cd27" translate="yes" xml:space="preserve">
          <source>The distinction between aware and naive doesn&amp;rsquo;t apply to &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">인식과 순진의 구별은 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a88b02874a2183ab63db978cb3d089c5c1c77714" translate="yes" xml:space="preserve">
          <source>The docstrings of the functions which are derived from methods have a modified form:</source>
          <target state="translated">메소드에서 파생 된 함수의 docstring은 수정 된 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="15a57359f59d33fd95cd9fd1878284e1c5612b40" translate="yes" xml:space="preserve">
          <source>The doctest command line accepts the option &lt;code&gt;-f&lt;/code&gt; as a shorthand for &lt;code&gt;-o
FAIL_FAST&lt;/code&gt;.</source>
          <target state="translated">doctest가 명령 줄 옵션 받아 &lt;code&gt;-f&lt;/code&gt; 위한 속기로 &lt;code&gt;-o FAIL_FAST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7edc27c9b251af25f08e439a5fa1ae563449aee" translate="yes" xml:space="preserve">
          <source>The document attempted to remove the namespace declaration associated with a prefix.</source>
          <target state="translated">문서가 접 두부와 연관된 네임 스페이스 선언을 제거하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="10a2ff25b70c156c1132e77ce7ede7c43d4ef115" translate="yes" xml:space="preserve">
          <source>The document contained no document element at all.</source>
          <target state="translated">문서에는 문서 요소가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b1d05974dee6ddfa33f763e960cb8596c6c89b6" translate="yes" xml:space="preserve">
          <source>The document contains no elements (XML requires all documents to contain exactly one top-level element)..</source>
          <target state="translated">문서에 요소가 없습니다 (XML에는 모든 문서에 정확히 하나의 최상위 요소가 포함되어야 함).</target>
        </trans-unit>
        <trans-unit id="0e022fadcd6ebdd4dce2b1340fd4cc2d36f4effa" translate="yes" xml:space="preserve">
          <source>The document encoding is not supported by Expat.</source>
          <target state="translated">Expat에서는 문서 인코딩을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45eb94f8f738860eeb2b172bec8e84ce78dc6574" translate="yes" xml:space="preserve">
          <source>The documentation for &lt;a href=&quot;https://pypi.org/project/defusedxml/&quot;&gt;defusedxml&lt;/a&gt; on PyPI has further information about all known attack vectors with examples and references.</source>
          <target state="translated">PyPI의 &lt;a href=&quot;https://pypi.org/project/defusedxml/&quot;&gt;defusedxml&lt;/a&gt; 에 대한 설명서 에는 예제와 참조가 포함 된 모든 알려진 공격 경로에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="52d6ee35bc489f9c966545e9c6e4189b68230cec" translate="yes" xml:space="preserve">
          <source>The documentation for the &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;xml.sax#module-xml.sax&quot;&gt;&lt;code&gt;xml.sax&lt;/code&gt;&lt;/a&gt; packages are the definition of the Python bindings for the DOM and SAX interfaces.</source>
          <target state="translated">에 대한 문서 &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;xml.sax#module-xml.sax&quot;&gt; &lt;code&gt;xml.sax&lt;/code&gt; &lt;/a&gt; 패키지는 DOM과 SAX 인터페이스에 대한 파이썬 바인딩의 정의입니다.</target>
        </trans-unit>
        <trans-unit id="98dc23305981bc90fc36fd9227d9b674c345d97d" translate="yes" xml:space="preserve">
          <source>The earlier SAX 1 interface provided by the Python XML Special Interest Group used a more Java-like interface for this method. Since most parsers used from Python did not take advantage of the older interface, the simpler signature was chosen to replace it. To convert old code to the new interface, use &lt;em&gt;content&lt;/em&gt; instead of slicing content with the old &lt;em&gt;offset&lt;/em&gt; and &lt;em&gt;length&lt;/em&gt; parameters.</source>
          <target state="translated">Python XML Special Interest Group에서 제공하는 이전 SAX 1 인터페이스는이 메소드에 대해 더 Java와 유사한 인터페이스를 사용했습니다. 파이썬에서 사용되는 대부분의 파서는 구식 인터페이스를 이용하지 않았기 때문에 더 간단한 서명을 선택했습니다. 새 인터페이스로 이전 코드를 변환하려면, 사용 &lt;em&gt;내용&lt;/em&gt; 대신 이전에 슬라이스 콘텐츠는 &lt;em&gt;오프셋&lt;/em&gt; 및 &lt;em&gt;길이&lt;/em&gt; 매개 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="76ec6d13cceb3b560d2ffecdd1e137e7f039d3d4" translate="yes" xml:space="preserve">
          <source>The earliest representable &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;datetime(MINYEAR, 1, 1,
tzinfo=None)&lt;/code&gt;.</source>
          <target state="translated">가장 빠른 표현 가능한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;datetime(MINYEAR, 1, 1, tzinfo=None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9003e875acf880f08070ec4d1db25f2fc4aa782b" translate="yes" xml:space="preserve">
          <source>The earliest representable &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;time(0, 0, 0, 0)&lt;/code&gt;.</source>
          <target state="translated">가장 빠른 표현 가능한 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;time(0, 0, 0, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47c650a99a648604cd819bc36b58ac25362286da" translate="yes" xml:space="preserve">
          <source>The earliest representable date, &lt;code&gt;date(MINYEAR, 1, 1)&lt;/code&gt;.</source>
          <target state="translated">가장 빠른 표현 가능한 날짜 &lt;code&gt;date(MINYEAR, 1, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bef193c5f3fa08733d4d4cd070fcd5c19da9c977" translate="yes" xml:space="preserve">
          <source>The easiest way to create a binary stream is with &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;'b'&lt;/code&gt; in the mode string:</source>
          <target state="translated">이진 스트림을 만드는 가장 쉬운 방법 은 모드 문자열에서 &lt;code&gt;'b'&lt;/code&gt; 와 함께 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1d8d451e096581c982d771f39ecd4c6c3d239d0" translate="yes" xml:space="preserve">
          <source>The easiest way to create a text stream is with &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, optionally specifying an encoding:</source>
          <target state="translated">텍스트 스트림을 만드는 가장 쉬운 방법은 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 을 사용하여 선택적으로 인코딩을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="78c60cbccd7a51f00d2d498ba443cdd533a6176c" translate="yes" xml:space="preserve">
          <source>The easiest way to provide your own policy is to override this class and call its methods in your overridden implementations before adding your own additional checks:</source>
          <target state="translated">자체 정책을 제공하는 가장 쉬운 방법은 자체 검사를 추가하기 전에이 클래스를 재정의하고 재정의 된 구현에서 해당 메서드를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c33291f3e651294d4ee970ee9b4832d9009fad1" translate="yes" xml:space="preserve">
          <source>The editing features described in previous subsections work when entering code interactively. IDLE&amp;rsquo;s Shell window also responds to the following keys.</source>
          <target state="translated">이전 하위 섹션에서 설명한 편집 기능은 대화식으로 코드를 입력 할 때 작동합니다. IDLE의 쉘 창은 다음 키에도 반응합니다.</target>
        </trans-unit>
        <trans-unit id="08a9deab57a6e87ba13c9cef116a534a382e5487" translate="yes" xml:space="preserve">
          <source>The effects of round-off error can be amplified by the addition or subtraction of nearly offsetting quantities resulting in loss of significance. Knuth provides two instructive examples where rounded floating point arithmetic with insufficient precision causes the breakdown of the associative and distributive properties of addition:</source>
          <target state="translated">반올림 오차의 효과는 거의 상쇄되는 양을 더하거나 빼서 증폭되어 유의미한 손실을 초래할 수 있습니다. Knuth는 정밀도가 불충분 한 둥근 부동 소수점 산술로 인해 연관성과 분배 특성이 추가되는 두 가지 유용한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af646cedcd480fc2845b3a6b4f0d2380953bd50c" translate="yes" xml:space="preserve">
          <source>The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. &lt;em&gt;parent&lt;/em&gt; is the parent element. &lt;em&gt;tag&lt;/em&gt; is the subelement name. &lt;em&gt;attrib&lt;/em&gt; is an optional dictionary, containing element attributes. &lt;em&gt;extra&lt;/em&gt; contains additional attributes, given as keyword arguments. Returns an element instance.</source>
          <target state="translated">요소 이름, 속성 이름 및 속성 값은 바이트 문자열 또는 유니 코드 문자열 일 수 있습니다. &lt;em&gt;parent&lt;/em&gt; 는 부모 요소입니다. &lt;em&gt;tag&lt;/em&gt; 는 하위 요소 이름입니다. &lt;em&gt;attrib&lt;/em&gt; 는 요소 속성을 포함하는 선택적 사전입니다. &lt;em&gt;extra&lt;/em&gt; 는 키워드 인수로 제공된 추가 속성을 포함합니다. 요소 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d0be1524ec53ac85afea89617259f2a7e5f14e4" translate="yes" xml:space="preserve">
          <source>The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. &lt;em&gt;tag&lt;/em&gt; is the element name. &lt;em&gt;attrib&lt;/em&gt; is an optional dictionary, containing element attributes. &lt;em&gt;extra&lt;/em&gt; contains additional attributes, given as keyword arguments.</source>
          <target state="translated">요소 이름, 속성 이름 및 속성 값은 바이트 문자열 또는 유니 코드 문자열 일 수 있습니다. &lt;em&gt;태그&lt;/em&gt; 는 요소 이름입니다. &lt;em&gt;attrib&lt;/em&gt; 는 요소 속성을 포함하는 선택적 사전입니다. &lt;em&gt;extra&lt;/em&gt; 는 키워드 인수로 제공된 추가 속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cdb4dcd901151ab5c9a7f2175c497daa8c2b36c5" translate="yes" xml:space="preserve">
          <source>The element named by the model name was declared to have a content model of &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">모델 이름으로 명명 된 요소는 &lt;code&gt;ANY&lt;/code&gt; 의 컨텐츠 모델을 갖도록 선언되었습니다 .</target>
        </trans-unit>
        <trans-unit id="534871b2bf6d13b459184db326339923a278d5b6" translate="yes" xml:space="preserve">
          <source>The element type name. In a namespace-using document it may have colons in it. The value is a string.</source>
          <target state="translated">요소 유형 이름 네임 스페이스를 사용하는 문서에는 콜론이있을 수 있습니다. 값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="34e66592bc4e2c1b0614156015fd164a4e4c8c82" translate="yes" xml:space="preserve">
          <source>The email package calls this method with a list of strings, each string ending with the line separation characters found in the source being parsed. The first line includes the field header name and separator. All whitespace in the source is preserved. The method should return the &lt;code&gt;(name, value)&lt;/code&gt; tuple that is to be stored in the &lt;code&gt;Message&lt;/code&gt; to represent the parsed header.</source>
          <target state="translated">전자 메일 패키지는 문자열 목록과 함께이 메서드를 호출하며 각 문자열은 구문 분석중인 소스에서 줄 구분 문자로 끝납니다. 첫 번째 줄에는 필드 헤더 이름과 구분 기호가 포함됩니다. 소스의 모든 공백이 유지됩니다. 메소드는 구문 분석 된 헤더를 나타 내기 위해 &lt;code&gt;Message&lt;/code&gt; 에 저장 될 &lt;code&gt;(name, value)&lt;/code&gt; 튜플을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3438c25b441b90b95233d8048c7ba543c03b2ff7" translate="yes" xml:space="preserve">
          <source>The email package calls this method with the &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; currently stored in the &lt;code&gt;Message&lt;/code&gt; for a given header. The method should return a string that represents that header &amp;ldquo;folded&amp;rdquo; correctly (according to the policy settings) by composing the &lt;em&gt;name&lt;/em&gt; with the &lt;em&gt;value&lt;/em&gt; and inserting &lt;a href=&quot;#email.policy.Policy.linesep&quot;&gt;&lt;code&gt;linesep&lt;/code&gt;&lt;/a&gt; characters at the appropriate places. See &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; for a discussion of the rules for folding email headers.</source>
          <target state="translated">전자 메일 패키지 는 지정된 헤더에 대해 현재 &lt;code&gt;Message&lt;/code&gt; 에 저장된 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 으로이 메서드를 호출합니다 . 이 방법은 &lt;em&gt;이름&lt;/em&gt; 을 &lt;em&gt;값&lt;/em&gt; 으로 구성 하고 적절한 위치에 &lt;a href=&quot;#email.policy.Policy.linesep&quot;&gt; &lt;code&gt;linesep&lt;/code&gt; &lt;/a&gt; 문자를 삽입 하여 정책 설정에 따라 헤더가 올바르게 &quot;접힌&quot;것을 나타내는 문자열을 반환해야 합니다. 이메일 헤더 접기 규칙에 대한 설명은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb63a95898c5c4fb4763a2febdcbf523de818d32" translate="yes" xml:space="preserve">
          <source>The email package calls this method with the &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; currently stored in the &lt;code&gt;Message&lt;/code&gt; when that header is requested by the application program, and whatever the method returns is what is passed back to the application as the value of the header being retrieved. Note that there may be more than one header with the same name stored in the &lt;code&gt;Message&lt;/code&gt;; the method is passed the specific name and value of the header destined to be returned to the application.</source>
          <target state="translated">전자 메일 패키지 는 응용 프로그램이 해당 헤더를 요청할 때 &lt;code&gt;Message&lt;/code&gt; 현재 저장된 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 으로이 메서드를 호출 하며, 메서드가 반환하는 것은 검색되는 헤더의 값으로 응용 프로그램에 다시 전달되는 것입니다. &lt;code&gt;Message&lt;/code&gt; 에 같은 이름의 헤더가 두 개 이상 저장되어있을 수 있습니다 . 이 메소드에는 애플리케이션으로 리턴 될 헤더의 특정 이름과 값이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b640d8f2580ab201b636d35ed547ad20d6e09b6b" translate="yes" xml:space="preserve">
          <source>The email package calls this method with the name and value provided by the application program when the application program is modifying a &lt;code&gt;Message&lt;/code&gt; programmatically (as opposed to a &lt;code&gt;Message&lt;/code&gt; created by a parser). The method should return the &lt;code&gt;(name, value)&lt;/code&gt; tuple that is to be stored in the &lt;code&gt;Message&lt;/code&gt; to represent the header.</source>
          <target state="translated">전자 메일 패키지는 응용 프로그램이 &lt;code&gt;Message&lt;/code&gt; 프로그래밍 방식으로 수정하는 경우 (파서가 만든 &lt;code&gt;Message&lt;/code&gt; 아닌) 응용 프로그램이 제공 한 이름과 값으로이 메서드를 호출합니다 . 메소드는 헤더를 나타 내기 위해 &lt;code&gt;Message&lt;/code&gt; 에 저장 될 &lt;code&gt;(name, value)&lt;/code&gt; 튜플을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f240002ee824e034224951554eb1c96d1d49a99" translate="yes" xml:space="preserve">
          <source>The email package does its best to hide the details of the various governing RFCs from the application. Conceptually the application should be able to treat the email message as a structured tree of unicode text and binary attachments, without having to worry about how these are represented when serialized. In practice, however, it is often necessary to be aware of at least some of the rules governing MIME messages and their structure, specifically the names and nature of the MIME &amp;ldquo;content types&amp;rdquo; and how they identify multipart documents. For the most part this knowledge should only be required for more complex applications, and even then it should only be the high level structure in question, and not the details of how those structures are represented. Since MIME content types are used widely in modern internet software (not just email), this will be a familiar concept to many programmers.</source>
          <target state="translated">이메일 패키지는 애플리케이션에서 다양한 관리 RFC의 세부 사항을 숨기도록 최선을 다합니다. 개념적으로 응용 프로그램은 전자 메일 메시지를 직렬화 할 때 어떻게 표현되는지에 대해 걱정할 필요없이 구조화 된 유니 코드 텍스트 및 이진 첨부 파일 트리로 처리 할 수 ​​있어야합니다. 그러나 실제로는 MIME 메시지와 그 구조, 특히 MIME&amp;ldquo;컨텐츠 유형&amp;rdquo;의 이름과 특성, 그리고 여러 부분으로 된 문서를 식별하는 방법을 관리하는 규칙 중 적어도 일부를 알고 있어야합니다. 대부분의 경우이 지식은보다 복잡한 응용 프로그램에만 필요하며, 심지어 이러한 구조가 어떻게 표현되는지에 대한 세부 사항이 아니라 문제가되는 높은 수준의 구조 여야합니다. MIME 콘텐츠 유형은 최신 인터넷 소프트웨어 (이메일뿐만 아니라)에서 널리 사용되므로이것은 많은 프로그래머에게 친숙한 개념이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="101c5ba6b37aa8005a49597770b8d1f23548c119" translate="yes" xml:space="preserve">
          <source>The encoded data will have newlines every 76 characters as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html#section-6.8&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2045 section 6.8&lt;/strong&gt;&lt;/a&gt;, which was the de facto standard base64 specification when the XML-RPC spec was written.</source>
          <target state="translated">인코딩 된 데이터는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html#section-6.8&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2045 섹션 6.8에&lt;/strong&gt;&lt;/a&gt; 따라 76 자마다 줄 바꿈이 있으며 이는 XML-RPC 사양이 작성 될 때 사실상 표준 base64 사양이었습니다.</target>
        </trans-unit>
        <trans-unit id="79fd1f20636ced312cd94cdc52fdef0b7a8bfe16" translate="yes" xml:space="preserve">
          <source>The encoded value of the cookie &amp;mdash; this is what should be sent.</source>
          <target state="translated">쿠키의 인코딩 된 값 &amp;mdash; 전송해야합니다.</target>
        </trans-unit>
        <trans-unit id="96b435363fcdcb22ea2d43ea881834604e657ced" translate="yes" xml:space="preserve">
          <source>The encoder must be able to handle zero length input and return an empty object of the output object type in this situation.</source>
          <target state="translated">이 상황에서 인코더는 길이가 0 인 입력을 처리하고 출력 객체 유형의 빈 객체를 반환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1631cb3d0d8698dbeb4af6cf19ae8b8843f6321c" translate="yes" xml:space="preserve">
          <source>The encoding attribute of the &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; is ignored if the &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; also contains a character stream.</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt; 에 문자 스트림도 포함되어 있으면 &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt; 의 인코딩 속성 이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d5827c34a301ab6bf0ace40ea931ae2aac9ab7c" translate="yes" xml:space="preserve">
          <source>The encoding must be a string acceptable for an XML encoding declaration (see section 4.3.3 of the XML recommendation).</source>
          <target state="translated">인코딩은 XML 인코딩 선언에 허용되는 문자열이어야합니다 (XML 권장 사항의 4.3.3 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="6a2f46957b3ba99c6e50d62370c70192d43b8f63" translate="yes" xml:space="preserve">
          <source>The encoding name included in the XML output should conform to the appropriate standards. For example, &amp;ldquo;UTF-8&amp;rdquo; is valid, but &amp;ldquo;UTF8&amp;rdquo; is not valid in an XML document&amp;rsquo;s declaration, even though Python accepts it as an encoding name. See &lt;a href=&quot;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&quot;&gt;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&lt;/a&gt; and &lt;a href=&quot;https://www.iana.org/assignments/character-sets/character-sets.xhtml&quot;&gt;https://www.iana.org/assignments/character-sets/character-sets.xhtml&lt;/a&gt;.</source>
          <target state="translated">XML 출력에 포함 된 인코딩 이름은 적절한 표준을 준수해야합니다. 예를 들어, &quot;UTF-8&quot;은 유효하지만 Python에서 인코딩 이름으로 &quot;UTF8&quot;을 승인하더라도 XML 문서의 선언에서는 &quot;UTF8&quot;이 유효하지 않습니다. 참조 &lt;a href=&quot;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&quot;&gt;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&lt;/a&gt; 및 &lt;a href=&quot;https://www.iana.org/assignments/character-sets/character-sets.xhtml&quot;&gt;https://www.iana.org/assignments/character-sets/character-sets.xhtml&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0d09476afe905814a4dfa19f625362273705bd" translate="yes" xml:space="preserve">
          <source>The encoding string included in XML output should conform to the appropriate standards. For example, &amp;ldquo;UTF-8&amp;rdquo; is valid, but &amp;ldquo;UTF8&amp;rdquo; is not. See &lt;a href=&quot;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&quot;&gt;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&lt;/a&gt; and &lt;a href=&quot;https://www.iana.org/assignments/character-sets/character-sets.xhtml&quot;&gt;https://www.iana.org/assignments/character-sets/character-sets.xhtml&lt;/a&gt;.</source>
          <target state="translated">XML 출력에 포함 된 인코딩 문자열은 적절한 표준을 준수해야합니다. 예를 들어 &quot;UTF-8&quot;은 유효하지만 &quot;UTF8&quot;은 유효하지 않습니다. 참조 &lt;a href=&quot;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&quot;&gt;https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl&lt;/a&gt; 및 &lt;a href=&quot;https://www.iana.org/assignments/character-sets/character-sets.xhtml&quot;&gt;https://www.iana.org/assignments/character-sets/character-sets.xhtml&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="896c3228e957e8bc5147701e30cd58b086cc96dd" translate="yes" xml:space="preserve">
          <source>The end user guide for installing Python packages</source>
          <target state="translated">Python 패키지 설치를위한 최종 사용자 안내서</target>
        </trans-unit>
        <trans-unit id="d5f67970109087508d1d4050202b6e61741b9f1a" translate="yes" xml:space="preserve">
          <source>The end-point value &lt;code&gt;b&lt;/code&gt; may or may not be included in the range depending on floating-point rounding in the equation &lt;code&gt;a + (b-a) * random()&lt;/code&gt;.</source>
          <target state="translated">종점 값 &lt;code&gt;b&lt;/code&gt; 는 방정식 &lt;code&gt;a + (b-a) * random()&lt;/code&gt; 부동 소수점 반올림에 따라 범위에 포함되거나 포함되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7d3c35f0e85c1a6bf781b776ea72d3b7217b57e" translate="yes" xml:space="preserve">
          <source>The entire Python program exits when no alive non-daemon threads are left.</source>
          <target state="translated">살아있는 비 데몬 스레드가 남아 있지 않으면 전체 Python 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1295da24b6424a5f2becb1d572a40d22568b6040" translate="yes" xml:space="preserve">
          <source>The entire set of key/value pairs are placed into a dictionary and set as the &amp;ldquo;protected&amp;rdquo; &lt;code&gt;_info&lt;/code&gt; instance variable.</source>
          <target state="translated">키 / 값 쌍의 전체 세트가 사전에 배치되고 &quot;protected&quot; &lt;code&gt;_info&lt;/code&gt; 인스턴스 변수 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f626d177c89f813c8672bbbbf5ed6f0e7658688e" translate="yes" xml:space="preserve">
          <source>The entity body for the request, or &lt;code&gt;None&lt;/code&gt; if not specified.</source>
          <target state="translated">요청의 엔터티 본문이거나 지정되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="10c3943f73ea65136af21ded034c30fd235e6dc9" translate="yes" xml:space="preserve">
          <source>The entries &lt;em&gt;exampleturtle&lt;/em&gt; and &lt;em&gt;examplescreen&lt;/em&gt; define the names of these objects as they occur in the docstrings. The transformation of method-docstrings to function-docstrings will delete these names from the docstrings.</source>
          <target state="translated">&lt;em&gt;exampleturtle&lt;/em&gt; 및 &lt;em&gt;examplescreen&lt;/em&gt; 항목 은 이러한 문자열이 문서 문자열에서 발생할 때 해당 이름을 정의합니다. method-docstring을 function-docstring으로 변환하면 이러한 이름이 docstring에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3bf2bcd11a295a8919305fa1689658a574d326" translate="yes" xml:space="preserve">
          <source>The entries are separated by one or more newlines. Now we convert the string into a list with each nonempty line having its own entry:</source>
          <target state="translated">항목은 하나 이상의 줄 바꿈으로 구분됩니다. 이제 문자열을 비어 있지 않은 각 행에 고유 한 항목이있는 목록으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a046690533f2ceb581ea9120c3d79e1cf1efa2ca" translate="yes" xml:space="preserve">
          <source>The entry&amp;rsquo;s base filename, relative to the &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;path&lt;/em&gt; argument.</source>
          <target state="translated">&lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 경로&lt;/em&gt; 인수 와 관련된 항목의 기본 파일 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="85163f028cbe41023b8741f26141bdf866b4ffad" translate="yes" xml:space="preserve">
          <source>The entry&amp;rsquo;s full path name: equivalent to &lt;code&gt;os.path.join(scandir_path,
entry.name)&lt;/code&gt; where &lt;em&gt;scandir_path&lt;/em&gt; is the &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;path&lt;/em&gt; argument. The path is only absolute if the &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;path&lt;/em&gt; argument was absolute. If the &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;path&lt;/em&gt; argument was a &lt;a href=&quot;#path-fd&quot;&gt;file descriptor&lt;/a&gt;, the &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt; attribute is the same as the &lt;a href=&quot;#os.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">항목의 전체 경로 이름 : &lt;code&gt;os.path.join(scandir_path, entry.name)&lt;/code&gt; 과 동일합니다. 여기서 &lt;em&gt;scandir_path&lt;/em&gt; 는 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 경로&lt;/em&gt; 인수입니다. &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 경로&lt;/em&gt; 인수가 절대 &lt;em&gt;경로 인&lt;/em&gt; 경우에만 경로가 절대 경로입니다 . 는 IF &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 경로&lt;/em&gt; 인수가 있었다 &lt;a href=&quot;#path-fd&quot;&gt;파일 기술자&lt;/a&gt; 의 &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 속성은와 동일한 &lt;a href=&quot;#os.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="6af325104c8e57bb1184ac87ae3edda497672155" translate="yes" xml:space="preserve">
          <source>The enum members have &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;values&lt;/em&gt; (the name of &lt;code&gt;Color.RED&lt;/code&gt; is &lt;code&gt;RED&lt;/code&gt;, the value of &lt;code&gt;Color.BLUE&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt;, etc.)</source>
          <target state="translated">열거 형 멤버에는 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값이 있습니다&lt;/em&gt; ( &lt;code&gt;Color.RED&lt;/code&gt; 의 이름 은 &lt;code&gt;RED&lt;/code&gt; , &lt;code&gt;Color.BLUE&lt;/code&gt; 의 값 은 &lt;code&gt;3&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="e4cc568c813d1cdfe613369fc63617a986880d21" translate="yes" xml:space="preserve">
          <source>The equality operation for &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; checks for matching order.</source>
          <target state="translated">&lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; &lt;/a&gt; 의 동등 연산은 일치하는 순서를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cb1db0558f0a93652ed687f8a8a1425bb424eec1" translate="yes" xml:space="preserve">
          <source>The equivalent operation using the &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module is somewhat longer, and allows the intermediate internal parse tree to be retained as an ST object:</source>
          <target state="translated">&lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈을 사용하는 동등한 작업 은 다소 길며 중간 내부 구문 분석 트리를 ST 객체로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20d51c761b7e7fd34e36d41458d9971587168a68" translate="yes" xml:space="preserve">
          <source>The equivalent regular expression would be</source>
          <target state="translated">동등한 정규식은</target>
        </trans-unit>
        <trans-unit id="417fb3947ac5e64f68d7832fa02e6981fc975ca4" translate="yes" xml:space="preserve">
          <source>The equivalent to the built-in &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; that uses the formatting imposed by the instance.</source>
          <target state="translated">인스턴스가 부과 한 형식을 사용 하는 내장 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="140dbe22d5460219ceb93bdba6b9eac6084d4dcb" translate="yes" xml:space="preserve">
          <source>The error code.</source>
          <target state="translated">오류 코드</target>
        </trans-unit>
        <trans-unit id="3387baccbf0f6b7105d8a7d8370887d7ee98efc1" translate="yes" xml:space="preserve">
          <source>The error message or diagnostic string.</source>
          <target state="translated">오류 메시지 또는 진단 문자열</target>
        </trans-unit>
        <trans-unit id="b195b26d47178842e7757e9f55d9d77dfe1a846b" translate="yes" xml:space="preserve">
          <source>The error raised for bad ZIP files.</source>
          <target state="translated">잘못된 ZIP 파일로 인해 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="01d21ac2a73f61496f718d2bb37954e437ac49a3" translate="yes" xml:space="preserve">
          <source>The error raised when a ZIP file would require ZIP64 functionality but that has not been enabled.</source>
          <target state="translated">ZIP 파일에 ZIP64 기능이 필요하지만 활성화되지 않은 경우 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="a2b36dbb8bd95a7886aaee9447c81bc891531ec5" translate="yes" xml:space="preserve">
          <source>The error response body. This should be an HTTP response body bytestring. It defaults to the plain text, &amp;ldquo;A server error occurred. Please contact the administrator.&amp;rdquo;</source>
          <target state="translated">오류 응답 본문 이것은 HTTP 응답 본문 바이트 문자열이어야합니다. 기본적으로&amp;ldquo;서버 오류가 발생했습니다. 관리자에게 문의하십시오.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b073172d27313054835e89372929b95496f3e307" translate="yes" xml:space="preserve">
          <source>The error setting of the decoder or encoder.</source>
          <target state="translated">디코더 또는 인코더의 오류 설정입니다.</target>
        </trans-unit>
        <trans-unit id="052c1e179a0c79f767c6604197b82ab12f14cc1d" translate="yes" xml:space="preserve">
          <source>The event loop is the core of every asyncio application. Event loops run asynchronous tasks and callbacks, perform network IO operations, and run subprocesses.</source>
          <target state="translated">이벤트 루프는 모든 asyncio 응용 프로그램의 핵심입니다. 이벤트 루프는 비동기 작업 및 콜백을 실행하고 네트워크 IO 작업을 수행하며 하위 프로세스를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="20660ae21639a13bb9cdcdb9cc1ae330bad31fc2" translate="yes" xml:space="preserve">
          <source>The events have the following meaning:</source>
          <target state="translated">이벤트의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d8e48b282637e6b7ae111368c295425b248fd49" translate="yes" xml:space="preserve">
          <source>The exact functionality is system dependent.</source>
          <target state="translated">정확한 기능은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="325e0452fd2926eb393f8ebf3681a81d525396d6" translate="yes" xml:space="preserve">
          <source>The exact meaning and resolution of the &lt;a href=&quot;#os.stat_result.st_atime&quot;&gt;&lt;code&gt;st_atime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_mtime&quot;&gt;&lt;code&gt;st_mtime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.stat_result.st_ctime&quot;&gt;&lt;code&gt;st_ctime&lt;/code&gt;&lt;/a&gt; attributes depend on the operating system and the file system. For example, on Windows systems using the FAT or FAT32 file systems, &lt;a href=&quot;#os.stat_result.st_mtime&quot;&gt;&lt;code&gt;st_mtime&lt;/code&gt;&lt;/a&gt; has 2-second resolution, and &lt;a href=&quot;#os.stat_result.st_atime&quot;&gt;&lt;code&gt;st_atime&lt;/code&gt;&lt;/a&gt; has only 1-day resolution. See your operating system documentation for details.</source>
          <target state="translated">&lt;a href=&quot;#os.stat_result.st_atime&quot;&gt; &lt;code&gt;st_atime&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_mtime&quot;&gt; &lt;code&gt;st_mtime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.stat_result.st_ctime&quot;&gt; &lt;code&gt;st_ctime&lt;/code&gt; &lt;/a&gt; 속성 의 정확한 의미와 해결 방법은 운영 체제와 파일 시스템에 따라 다릅니다. 예를 들어 FAT 또는 FAT32 파일 시스템을 사용하는 Windows 시스템에서 &lt;a href=&quot;#os.stat_result.st_mtime&quot;&gt; &lt;code&gt;st_mtime&lt;/code&gt; 의&lt;/a&gt; 해상도는 2 초이고 &lt;a href=&quot;#os.stat_result.st_atime&quot;&gt; &lt;code&gt;st_atime&lt;/code&gt; 의&lt;/a&gt; 해상도 는 1 일입니다. 자세한 내용은 운영 체제 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38f4793ab661ef074bccde7fedd44e2caaaf1c00" translate="yes" xml:space="preserve">
          <source>The exact output format is implementation dependent. In this version, it&amp;rsquo;s written as an ordinary XML file.</source>
          <target state="translated">정확한 출력 형식은 구현에 따라 다릅니다. 이 버전에서는 일반 XML 파일로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="9df7a5622dfa1e314fc973d30f87d7dc1d47ea52" translate="yes" xml:space="preserve">
          <source>The exact token type names can be displayed using the &lt;a href=&quot;#cmdoption-tokenize-e&quot;&gt;&lt;code&gt;-e&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">&lt;a href=&quot;#cmdoption-tokenize-e&quot;&gt; &lt;code&gt;-e&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 정확한 토큰 유형 이름을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4e55e4f1f047d534549d94721436aa9890d2906" translate="yes" xml:space="preserve">
          <source>The exactness carries over into arithmetic. In decimal floating point, &lt;code&gt;0.1
+ 0.1 + 0.1 - 0.3&lt;/code&gt; is exactly equal to zero. In binary floating point, the result is &lt;code&gt;5.5511151231257827e-017&lt;/code&gt;. While near to zero, the differences prevent reliable equality testing and differences can accumulate. For this reason, decimal is preferred in accounting applications which have strict equality invariants.</source>
          <target state="translated">정확성은 산술로 이어집니다. 십진 부동 소수점에서 &lt;code&gt;0.1 + 0.1 + 0.1 - 0.3&lt;/code&gt; 은 정확히 0과 같습니다. 이진 부동 소수점에서 결과는 &lt;code&gt;5.5511151231257827e-017&lt;/code&gt; 입니다. 0에 가까우면서이 차이는 신뢰할 수있는 동등성 테스트를 방해하고 차이가 누적 될 수 있습니다. 이러한 이유로, 엄격한 등변 량을 갖는 회계 응용 프로그램에서는 10 진수가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="368a4f8d51918859c50dacebe141ec8fb33b0cfc" translate="yes" xml:space="preserve">
          <source>The example above shows part of the implementation of &lt;a href=&quot;collections#collections.Counter&quot;&gt;&lt;code&gt;collections.Counter&lt;/code&gt;&lt;/a&gt;. A different &lt;code&gt;__missing__&lt;/code&gt; method is used by &lt;a href=&quot;collections#collections.defaultdict&quot;&gt;&lt;code&gt;collections.defaultdict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위의 예제는 &lt;a href=&quot;collections#collections.Counter&quot;&gt; &lt;code&gt;collections.Counter&lt;/code&gt; &lt;/a&gt; 구현의 일부를 보여줍니다 . &lt;a href=&quot;collections#collections.defaultdict&quot;&gt; &lt;code&gt;collections.defaultdict&lt;/code&gt; &lt;/a&gt; 는 다른 &lt;code&gt;__missing__&lt;/code&gt; 메소드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6c4257b7bd5948bf81998e31354c476d75868ec9" translate="yes" xml:space="preserve">
          <source>The example above uses a very &amp;ldquo;nonrandom&amp;rdquo; stream of data (a stream of &lt;code&gt;b&amp;rdquo;z&amp;rdquo;&lt;/code&gt; chunks). Random data tends to compress poorly, while ordered, repetitive data usually yields a high compression ratio.</source>
          <target state="translated">위의 예는 매우 &quot;비 랜덤&quot;데이터 스트림 ( &lt;code&gt;b&amp;rdquo;z&amp;rdquo;&lt;/code&gt; 청크 스트림 )을 사용합니다. 랜덤 데이터는 압축이 잘되지 않는 반면, 반복적 인 데이터는 일반적으로 압축률이 높습니다.</target>
        </trans-unit>
        <trans-unit id="1267a760796a415fef6f4e4d1d4ca429236931c8" translate="yes" xml:space="preserve">
          <source>The example also includes a basic record and playback facility implemented with the &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt;&lt;code&gt;precmd()&lt;/code&gt;&lt;/a&gt; method which is responsible for converting the input to lowercase and writing the commands to a file. The &lt;code&gt;do_playback()&lt;/code&gt; method reads the file and adds the recorded commands to the &lt;code&gt;cmdqueue&lt;/code&gt; for immediate playback:</source>
          <target state="translated">이 예에는 입력을 소문자로 변환하고 명령을 파일에 쓰는 역할을하는 &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt; &lt;code&gt;precmd()&lt;/code&gt; &lt;/a&gt; 메소드로 구현 된 기본 레코드 및 재생 기능도 포함 됩니다. &lt;code&gt;do_playback()&lt;/code&gt; 메소드는 파일을 읽고에 기록 된 명령을 추가 &lt;code&gt;cmdqueue&lt;/code&gt; 즉시 재생 :</target>
        </trans-unit>
        <trans-unit id="7b737e4581b9ae3288063ada39c5b91ad8523116" translate="yes" xml:space="preserve">
          <source>The example below defines a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass capturing time zone information for Kabul, Afghanistan, which used +4 UTC until 1945 and then +4:30 UTC thereafter:</source>
          <target state="translated">아래 예제는 1945 년까지 +4 UTC를 사용한 후 그 이후 +4 : 30 UTC를 사용하는 아프가니스탄 카불의 시간대 정보를 캡처 하는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="80f9b52354f157c05b33826ceabd33e38abbf32d" translate="yes" xml:space="preserve">
          <source>The example below would like to show how to register a pickle function and how it will be used:</source>
          <target state="translated">아래 예는 피클 기능을 등록하는 방법과 사용 방법을 보여주고 자합니다.</target>
        </trans-unit>
        <trans-unit id="f23e546d4eedcd0835e69c312998d72018282090" translate="yes" xml:space="preserve">
          <source>The example&amp;rsquo;s actual output.</source>
          <target state="translated">예제의 실제 출력.</target>
        </trans-unit>
        <trans-unit id="0e8a68c5bb27e57e61ade020d47d64138b073ee1" translate="yes" xml:space="preserve">
          <source>The example&amp;rsquo;s indentation in the containing string, i.e., the number of space characters that precede the example&amp;rsquo;s first prompt.</source>
          <target state="translated">포함하는 문자열에서 예제의 들여 쓰기 (예 : 예제의 첫 번째 프롬프트 앞에 오는 공백 문자 수)</target>
        </trans-unit>
        <trans-unit id="9bf28d77364e14c64c07990a46b33865cddc4a3c" translate="yes" xml:space="preserve">
          <source>The examples above use integers for enumeration values. Using integers is short and handy (and provided by default by the &lt;a href=&quot;#functional-api&quot;&gt;Functional API&lt;/a&gt;), but not strictly enforced. In the vast majority of use-cases, one doesn&amp;rsquo;t care what the actual value of an enumeration is. But if the value &lt;em&gt;is&lt;/em&gt; important, enumerations can have arbitrary values.</source>
          <target state="translated">위의 예제는 열거 형 값에 정수를 사용합니다. 정수를 사용하는 것은 간단하고 편리 하지만 기본적으로 &lt;a href=&quot;#functional-api&quot;&gt;Functional API에&lt;/a&gt; 의해 제공 되지만 엄격하게 적용되지는 않습니다. 대다수의 유스 케이스에서 열거의 실제 값이 무엇인지 신경 쓰지 않습니다. 그러나 값 &lt;em&gt;이&lt;/em&gt; 중요한 경우 열거 형은 임의의 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc5a1f6e5e16fd1c43d25e60bde4d2913909e68" translate="yes" xml:space="preserve">
          <source>The examples are run in the namespace &lt;code&gt;test.globs&lt;/code&gt;. If &lt;em&gt;clear_globs&lt;/em&gt; is true (the default), then this namespace will be cleared after the test runs, to help with garbage collection. If you would like to examine the namespace after the test completes, then use &lt;em&gt;clear_globs=False&lt;/em&gt;.</source>
          <target state="translated">예제는 네임 스페이스 &lt;code&gt;test.globs&lt;/code&gt; 에서 실행됩니다 . 경우 &lt;em&gt;clear_globs가&lt;/em&gt; true (디폴트),이 네임 스페이스는 가비지 컬렉션에 도움이 테스트가 실행 된 이후에 삭제됩니다. 테스트가 완료된 후 네임 스페이스를 검사하려면 &lt;em&gt;clear_globs = False&lt;/em&gt; 를 사용 &lt;em&gt;하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="823e2bd7f9e34fbe4a8d02393f5bc3f7b60e03c1" translate="yes" xml:space="preserve">
          <source>The exception (or &lt;code&gt;None&lt;/code&gt; if no exception was set) is returned only if the Future is &lt;em&gt;done&lt;/em&gt;.</source>
          <target state="translated">예외 (또는 예외가 설정되지 않은 경우 &lt;code&gt;None&lt;/code&gt; )는 Future가 &lt;em&gt;완료된&lt;/em&gt; 경우에만 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f398fd082f435634395bcad6277043303156476f" translate="yes" xml:space="preserve">
          <source>The exception codes defined in the DOM recommendation map to the exceptions described above according to this table:</source>
          <target state="translated">DOM 권장 사항에 정의 된 예외 코드는이 테이블에 따라 위에서 설명한 예외에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="761f0c94b4f4af1545fc471496949910ccb868b5" translate="yes" xml:space="preserve">
          <source>The exception message generated by the example, if the example is expected to generate an exception; or &lt;code&gt;None&lt;/code&gt; if it is not expected to generate an exception. This exception message is compared against the return value of &lt;a href=&quot;traceback#traceback.format_exception_only&quot;&gt;&lt;code&gt;traceback.format_exception_only()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#doctest.Example.exc_msg&quot;&gt;&lt;code&gt;exc_msg&lt;/code&gt;&lt;/a&gt; ends with a newline unless it&amp;rsquo;s &lt;code&gt;None&lt;/code&gt;. The constructor adds a newline if needed.</source>
          <target state="translated">예제가 예외를 생성 할 것으로 예상되는 경우 예제에 의해 생성 된 예외 메시지; 또는 &lt;code&gt;None&lt;/code&gt; 예외를 생성하는 예상되지 않는 경우. 이 예외 메시지는 &lt;a href=&quot;traceback#traceback.format_exception_only&quot;&gt; &lt;code&gt;traceback.format_exception_only()&lt;/code&gt; &lt;/a&gt; 의 반환 값과 비교 됩니다. &lt;a href=&quot;#doctest.Example.exc_msg&quot;&gt; &lt;code&gt;exc_msg&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 한 개행으로 끝납니다 . 필요한 경우 생성자는 개행을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="16fb466df1ef569cc795696df9b928061a52e60d" translate="yes" xml:space="preserve">
          <source>The exception object has a single attribute &lt;code&gt;value&lt;/code&gt;, which is given as an argument when constructing the exception, and defaults to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예외 객체에는 단일 속성 &lt;code&gt;value&lt;/code&gt; 이 있으며이 속성 값 은 예외를 구성 할 때 인수로 제공되며 기본값은 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="967015b7587a452e7a6969f9fcdf9472b004aa13" translate="yes" xml:space="preserve">
          <source>The exception passed in should never be reraised explicitly - instead, this method should return a false value to indicate that the method completed successfully and does not want to suppress the raised exception. This allows context management code to easily detect whether or not an &lt;a href=&quot;#contextmanager.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method has actually failed.</source>
          <target state="translated">전달 된 예외는 명시 적으로 제기되지 않아야합니다. 대신이 메소드는 메소드가 성공적으로 완료되었으며 발생한 예외를 억제하지 않음을 표시하기 위해 false 값을 리턴해야합니다. 이를 통해 컨텍스트 관리 코드는 &lt;a href=&quot;#contextmanager.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메소드가 실제로 실패 했는지 여부를 쉽게 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb4e339c8d30fe262a428d0d8ad73a99d4beb69c" translate="yes" xml:space="preserve">
          <source>The exception raised when Expat reports an error. See section &lt;a href=&quot;#expaterror-objects&quot;&gt;ExpatError Exceptions&lt;/a&gt; for more information on interpreting Expat errors.</source>
          <target state="translated">Expat가 오류를보고 할 때 예외가 발생했습니다. Expat 오류 해석에 대한 자세한 정보는 &lt;a href=&quot;#expaterror-objects&quot;&gt;ExpatError 예외&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eb7279a402a5d146f2e0d67cb68745febd71c19" translate="yes" xml:space="preserve">
          <source>The exception raised will likely be an &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; but it could be something else.</source>
          <target state="translated">발생한 예외는 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 일 수 있지만 다른 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9439b68fdd4692f623f1d833b070e00895671a64" translate="yes" xml:space="preserve">
          <source>The exception to this is if the mock has a name. This allows you to prevent the &amp;ldquo;parenting&amp;rdquo; if for some reason you don&amp;rsquo;t want it to happen.</source>
          <target state="translated">이에 대한 예외는 모형에 이름이있는 경우입니다. 어떤 이유로 든 원하지 않는 경우 &quot;부모&quot;를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44273158bebd408d0ca1686e330e8221aed6bf91" translate="yes" xml:space="preserve">
          <source>The execution time of &lt;em&gt;setup&lt;/em&gt; is excluded from the overall timed execution run.</source>
          <target state="translated">&lt;em&gt;설정&lt;/em&gt; 실행 시간은 전체 시간 실행 실행에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="8d5a336dad5945abfb44492ff957a88e5c60afa7" translate="yes" xml:space="preserve">
          <source>The execution time of the I/O selector is logged if it takes too long to perform an I/O operation.</source>
          <target state="translated">I / O 작업 수행에 시간이 너무 오래 걸리면 I / O 선택기의 실행 시간이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="056d4e2c3774cbd88921f11b4e8d264ee0e9d283" translate="yes" xml:space="preserve">
          <source>The exit status or error message that is passed to the constructor. (Defaults to &lt;code&gt;None&lt;/code&gt;.)</source>
          <target state="translated">생성자에게 전달되는 종료 상태 또는 오류 메시지입니다. (기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="dc5be0b65bb8c374ab86c659a4b84daa7fc4f814" translate="yes" xml:space="preserve">
          <source>The expected output for an exception must start with a traceback header, which may be either of the following two lines, indented the same as the first line of the example:</source>
          <target state="translated">예외에 대한 예상 출력은 다음 두 행 중 하나 일 수있는 역 추적 헤더로 시작해야합니다 (예제의 첫 번째 행과 동일하게 들여 쓰기 됨).</target>
        </trans-unit>
        <trans-unit id="c46a79830e587beeb1c2d33f69db71dc6d8a9e7f" translate="yes" xml:space="preserve">
          <source>The expected output from running the example&amp;rsquo;s source code (either from stdout, or a traceback in case of exception). &lt;a href=&quot;#doctest.Example.want&quot;&gt;&lt;code&gt;want&lt;/code&gt;&lt;/a&gt; ends with a newline unless no output is expected, in which case it&amp;rsquo;s an empty string. The constructor adds a newline when necessary.</source>
          <target state="translated">예제의 소스 코드를 실행했을 때의 예상 출력 (stdout 또는 예외의 경우 역 추적) 출력이 예상되지 않는 한 개행으로 끝나기를 &lt;a href=&quot;#doctest.Example.want&quot;&gt; &lt;code&gt;want&lt;/code&gt; &lt;/a&gt; 이 경우 빈 문자열입니다. 생성자는 필요할 때 개행을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1dab8d87c095f36844379c2f05305caab6d7338e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;t2 - t3&lt;/code&gt; will always be equal to the expression &lt;code&gt;t2 + (-t3)&lt;/code&gt; except when t3 is equal to &lt;code&gt;timedelta.max&lt;/code&gt;; in that case the former will produce a result while the latter will overflow.</source>
          <target state="translated">발현 &lt;code&gt;t2 - t3&lt;/code&gt; 항상 발현 동일 할 것이다 &lt;code&gt;t2 + (-t3)&lt;/code&gt; T3이 동일한 경우를 제외 &lt;code&gt;timedelta.max&lt;/code&gt; ; 이 경우 전자는 결과를 생성하지만 후자는 오버플로합니다.</target>
        </trans-unit>
        <trans-unit id="8705600e71bb79cd85436c8e2641d3a03b2276dd" translate="yes" xml:space="preserve">
          <source>The expression following &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; must be an exception or &lt;code&gt;None&lt;/code&gt;. It will be set as &lt;code&gt;__cause__&lt;/code&gt; on the raised exception. Setting &lt;code&gt;__cause__&lt;/code&gt; also implicitly sets the &lt;code&gt;__suppress_context__&lt;/code&gt; attribute to &lt;code&gt;True&lt;/code&gt;, so that using &lt;code&gt;raise new_exc from None&lt;/code&gt; effectively replaces the old exception with the new one for display purposes (e.g. converting &lt;a href=&quot;#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;), while leaving the old exception available in &lt;code&gt;__context__&lt;/code&gt; for introspection when debugging.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; 다음에 오는 표현식 은 예외이거나 &lt;code&gt;None&lt;/code&gt; 이어야합니다 . 발생한 예외에서 &lt;code&gt;__cause__&lt;/code&gt; 로 설정됩니다 . 설정 &lt;code&gt;__cause__&lt;/code&gt; 은 암시 적으로 설정 &lt;code&gt;__suppress_context__&lt;/code&gt; 의 에 속성 &lt;code&gt;True&lt;/code&gt; 사용 그래서, &lt;code&gt;raise new_exc from None&lt;/code&gt; 효율적으로 (변환 예를 표시 목적에 대한 새로운 하나 기존의 예외를 대체 &lt;a href=&quot;#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를을&lt;/a&gt; 에게 &lt;a href=&quot;#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 이전 예외를 남기면서,) &lt;code&gt;__context__&lt;/code&gt; 때 디버깅 자기 반성을위한 .</target>
        </trans-unit>
        <trans-unit id="77e08f5c9069670de504969f5f7ccf6331f6b9ce" translate="yes" xml:space="preserve">
          <source>The expression is in the syntax suitable for the &lt;code&gt;regex()&lt;/code&gt; function from the C library, which might differ from the syntax used in &lt;a href=&quot;re#module-re&quot;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표현식은 C 라이브러리 의 &lt;code&gt;regex()&lt;/code&gt; 함수에 적합한 구문에 있으며 &lt;a href=&quot;re#module-re&quot;&gt; &lt;code&gt;re&lt;/code&gt; 에&lt;/a&gt; 사용 된 구문과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c63cc66a535039b3f2bae8483c016e26a4fade05" translate="yes" xml:space="preserve">
          <source>The expression&amp;rsquo;s behaviour can be modified by specifying a &lt;em&gt;flags&lt;/em&gt; value. Values can be any of the following variables, combined using bitwise OR (the &lt;code&gt;|&lt;/code&gt; operator).</source>
          <target state="translated">&lt;em&gt;플래그&lt;/em&gt; 값 을 지정하여 표현식의 동작을 수정할 수 있습니다 . 값은 비트 단위 OR ( &lt;code&gt;|&lt;/code&gt; 연산자)을 사용하여 결합 된 다음 변수 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93fe9e394c294b7387fcfa2d42a16831c1ddb5a7" translate="yes" xml:space="preserve">
          <source>The extended tools offer the same high performance as the underlying toolset. The superior memory performance is kept by processing elements one at a time rather than bringing the whole iterable into memory all at once. Code volume is kept small by linking the tools together in a functional style which helps eliminate temporary variables. High speed is retained by preferring &amp;ldquo;vectorized&amp;rdquo; building blocks over the use of for-loops and &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;s which incur interpreter overhead.</source>
          <target state="translated">확장 도구는 기본 도구 세트와 동일한 고성능을 제공합니다. 전체 iterable을 한 번에 메모리로 가져 오지 않고 한 번에 하나씩 요소를 처리하여 뛰어난 메모리 성능을 유지합니다. 도구를 기능적 스타일로 연결하여 임시 변수를 제거함으로써 코드 볼륨을 작게 유지합니다. 인터프리터 오버 헤드가 발생하는 for 루프 및 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; 보다 &quot;벡터화 된&quot;빌딩 블록을 선호함으로써 고속이 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2e36429012b6a62032d18db64413f54c62b905a" translate="yes" xml:space="preserve">
          <source>The extraction in zipfile module might fail due to some pitfalls listed below.</source>
          <target state="translated">아래 나열된 일부 함정으로 인해 zipfile 모듈에서 추출이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fedb89b337393b16b1bba324c08f1822e44a807" translate="yes" xml:space="preserve">
          <source>The fact that &lt;code&gt;Type[C]&lt;/code&gt; is covariant implies that all subclasses of &lt;code&gt;C&lt;/code&gt; should implement the same constructor signature and class method signatures as &lt;code&gt;C&lt;/code&gt;. The type checker should flag violations of this, but should also allow constructor calls in subclasses that match the constructor calls in the indicated base class. How the type checker is required to handle this particular case may change in future revisions of &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">사실 &lt;code&gt;Type[C]&lt;/code&gt; 공변 인은 모든 서브 클래스 있음을 의미한다 &lt;code&gt;C&lt;/code&gt; 가 같은 생성자 서명 및 클래스 메소드 서명을 구현해야합니다 &lt;code&gt;C&lt;/code&gt; 를 . 타입 체커는 이것에 대한 위반을 표시해야하지만, 지정된 기본 클래스의 생성자 호출과 일치하는 서브 클래스의 생성자 호출도 허용해야합니다. 이 특정 사례를 처리하기 위해 형식 검사기가 필요한 방식은 향후 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; 개정에서 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28ec65a4d201d4d2ca5fe997a58b19245ad33e30" translate="yes" xml:space="preserve">
          <source>The fact that standard Python has a frozen module and a frozen package (indicated by the negative &lt;code&gt;size&lt;/code&gt; member) is not well known, it is only used for testing. Try it out with &lt;code&gt;import __hello__&lt;/code&gt; for example.</source>
          <target state="translated">표준 Python에 고정 모듈과 고정 패키지 (음수 &lt;code&gt;size&lt;/code&gt; 멤버로 표시됨)가 있다는 사실은 잘 알려져 있지 않으며 테스트 용도로만 사용됩니다. 예를 들어 &lt;code&gt;import __hello__&lt;/code&gt; 로 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="9dac46a441d5e72f6712035d99797ee965eb1bab" translate="yes" xml:space="preserve">
          <source>The factory has the following signature:</source>
          <target state="translated">공장의 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d779be886850f3923e598392c5fdf6aff33f4b0" translate="yes" xml:space="preserve">
          <source>The factory method of &lt;a href=&quot;#logging.handlers.SocketHandler&quot;&gt;&lt;code&gt;SocketHandler&lt;/code&gt;&lt;/a&gt; is here overridden to create a UDP socket (&lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt; &lt;/a&gt; ( socket.SOCK_DGRAM ) 를 작성하기 위해 &lt;a href=&quot;#logging.handlers.SocketHandler&quot;&gt; &lt;code&gt;SocketHandler&lt;/code&gt; &lt;/a&gt; 의 팩토리 메소드 가 여기에서 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="77d68cc31e2812d769a8a7e134820d797b4ff412" translate="yes" xml:space="preserve">
          <source>The false value of the &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; type. Assignments to &lt;code&gt;False&lt;/code&gt; are illegal and raise a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형 의 거짓 값입니다 . &lt;code&gt;False&lt;/code&gt; 에 할당하는 것은 불법이며 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="c398d0a8157f47bce0b9136a5d6e426f6c205b0e" translate="yes" xml:space="preserve">
          <source>The family of protocols to which the server&amp;rsquo;s socket belongs. Common examples are &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;socket.AF_INET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt;&lt;code&gt;socket.AF_UNIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서버 소켓이 속한 프로토콜 제품군. 일반적인 예는 &lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;socket.AF_INET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt; &lt;code&gt;socket.AF_UNIX&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7188cd9594911bcd5eab7fcf3154e9fac54fc86a" translate="yes" xml:space="preserve">
          <source>The fault handler is called on catastrophic cases and therefore can only use signal-safe functions (e.g. it cannot allocate memory on the heap). Because of this limitation traceback dumping is minimal compared to normal Python tracebacks:</source>
          <target state="translated">결함 핸들러는 치명적인 경우에 호출되므로 신호 안전 기능 만 사용할 수 있습니다 (예 : 힙에 메모리를 할당 할 수 없음). 이 제한으로 인해 역 추적 덤프는 일반적인 파이썬 역 추적에 비해 최소입니다.</target>
        </trans-unit>
        <trans-unit id="aee0bd171455a1448e4fe84e8a54699f4edda95b" translate="yes" xml:space="preserve">
          <source>The fault handler is compatible with system fault handlers like Apport or the Windows fault handler. The module uses an alternative stack for signal handlers if the &lt;code&gt;sigaltstack()&lt;/code&gt; function is available. This allows it to dump the traceback even on a stack overflow.</source>
          <target state="translated">결함 핸들러는 Apport 또는 Windows 결함 핸들러와 같은 시스템 결함 핸들러와 호환됩니다. &lt;code&gt;sigaltstack()&lt;/code&gt; 함수를 사용할 수있는 경우 모듈은 신호 핸들러에 대체 스택을 사용합니다. 이를 통해 스택 오버플로에서도 역 추적을 덤프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b64a8d474bdfb3f601c33aa7ab1c0f65b1af78" translate="yes" xml:space="preserve">
          <source>The field type must be a &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; type like &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt;, or any other derived &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; type: structure, union, array, pointer.</source>
          <target state="translated">필드 유형은 &lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 유형 이거나 구조, 공용체, 배열, 포인터 등 다른 파생 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="53b6c519d9cc69ec98567c08f6e4fa682bc959ee" translate="yes" xml:space="preserve">
          <source>The fields &lt;code&gt;ru_utime&lt;/code&gt; and &lt;code&gt;ru_stime&lt;/code&gt; of the return value are floating point values representing the amount of time spent executing in user mode and the amount of time spent executing in system mode, respectively. The remaining values are integers. Consult the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrusage(2)&quot;&gt;getrusage(2)&lt;/a&gt;&lt;/em&gt; man page for detailed information about these values. A brief summary is presented here:</source>
          <target state="translated">리턴 값의 &lt;code&gt;ru_utime&lt;/code&gt; 및 &lt;code&gt;ru_stime&lt;/code&gt; 필드 는 각각 사용자 모드에서 실행 된 시간 및 시스템 모드에서 실행 된 시간을 나타내는 부동 소수점 값입니다. 나머지 값은 정수입니다. 상담 호 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrusage(2)&quot;&gt;은 getrusage (2)&lt;/a&gt;&lt;/em&gt; 이 값에 대한 자세한 내용은 man 페이지를. 간략한 요약이 여기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7c0e7a9b930aacec36d9f5dfb5ae8968c5cdb619" translate="yes" xml:space="preserve">
          <source>The fields listed in this variable must be structure or union type fields. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; will create descriptors in the structure type that allows accessing the nested fields directly, without the need to create the structure or union field.</source>
          <target state="translated">이 변수에 나열된 필드는 구조 또는 공용체 유형 필드 여야합니다. &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 구조 또는 공용체 필드를 만들 필요없이 중첩 된 필드에 직접 액세스 할 수있는 설명자를 구조 유형으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="49d3ffb20600ae906d592727228c4b314bf7b93a" translate="yes" xml:space="preserve">
          <source>The fields of the return value each describe how a particular system resource has been used, e.g. amount of time spent running is user mode or number of times the process was swapped out of main memory. Some values are dependent on the clock tick internal, e.g. the amount of memory the process is using.</source>
          <target state="translated">리턴 값의 필드는 각각 특정 시스템 자원이 사용 된 방법을 설명합니다. 예를 들어 실행에 소요 된 시간은 사용자 모드이거나 프로세스가 주 메모리에서 스왑 된 횟수입니다. 일부 값은 클럭 틱 내부 (예 : 프로세스에서 사용중인 메모리 양)에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d4a8d9c00fb9d3badfff43f650201a575fe2a0f4" translate="yes" xml:space="preserve">
          <source>The file extension of the final component, if any:</source>
          <target state="translated">최종 구성 요소의 파일 확장자 (있는 경우) :</target>
        </trans-unit>
        <trans-unit id="d0114120d1c89a385da27d07f78b44e470d40fc6" translate="yes" xml:space="preserve">
          <source>The file is a snapshot file.</source>
          <target state="translated">파일은 스냅 샷 파일입니다.</target>
        </trans-unit>
        <trans-unit id="a6176b9e04bfbfddfce8592a319fadaf7ad306a6" translate="yes" xml:space="preserve">
          <source>The file is now non-inheritable.</source>
          <target state="translated">이제 파일을 상속 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2776c6bc9673d40e5b7bff3091258d276b726028" translate="yes" xml:space="preserve">
          <source>The file is opened and then closed. The optional parameters have the same meaning as in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일이 열리고 닫힙니다. 선택적 매개 변수는 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="cfcbd03a414732fbc2abf88348cc273cba1d3bb2" translate="yes" xml:space="preserve">
          <source>The file is overwritten if it already exists, thus wiping all the cookies it contains. Saved cookies can be restored later using the &lt;a href=&quot;#http.cookiejar.FileCookieJar.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#http.cookiejar.FileCookieJar.revert&quot;&gt;&lt;code&gt;revert()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">파일이 이미 존재하는 경우 파일을 덮어 쓰므로 파일에 포함 된 모든 쿠키를 지 웁니다. 저장된 쿠키는 나중에 &lt;a href=&quot;#http.cookiejar.FileCookieJar.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#http.cookiejar.FileCookieJar.revert&quot;&gt; &lt;code&gt;revert()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca8bc2b3859735a59f7c5727ee833f2c2996847f" translate="yes" xml:space="preserve">
          <source>The file is read and scanned in chunks of &lt;em&gt;chunksize&lt;/em&gt; bytes.</source>
          <target state="translated">이 파일은 읽고 덩어리에 스캔 &lt;em&gt;chunksize 영역의&lt;/em&gt; 바이트.</target>
        </trans-unit>
        <trans-unit id="584531cc428f460d16ee3b493d1ccde738f49bc0" translate="yes" xml:space="preserve">
          <source>The file is stored compressed (Mac OS X 10.6+).</source>
          <target state="translated">파일이 압축되어 저장됩니다 (Mac OS X 10.6+).</target>
        </trans-unit>
        <trans-unit id="2a6be25ba740062f6f2dbf5af7928dcd58c0349b" translate="yes" xml:space="preserve">
          <source>The file may be archived.</source>
          <target state="translated">파일이 보관되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e106002d1dd5d4cf8bd7c146bae64e3ff7f7f8d" translate="yes" xml:space="preserve">
          <source>The file may not be changed.</source>
          <target state="translated">파일이 변경되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ef31fa917154dc071d61c035311872073ab6ed" translate="yes" xml:space="preserve">
          <source>The file may not be renamed or deleted.</source>
          <target state="translated">파일 이름을 바꾸거나 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c7fbbc2ba48b35481b7eda3d7ce8a87c73ded62" translate="yes" xml:space="preserve">
          <source>The file may only be appended to.</source>
          <target state="translated">파일 만 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a32edd222a3bd6c55ca9732d33c575dc042d587" translate="yes" xml:space="preserve">
          <source>The file name of the importer&amp;rsquo;s associated ZIP file, without a possible subpath.</source>
          <target state="translated">가능한 서브 패스가없는 임포터 관련 ZIP 파일의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22d881f57735735b7beb6cd26cea8ae5f33f6cf5" translate="yes" xml:space="preserve">
          <source>The file name. This is the file descriptor of the file when no name is given in the constructor.</source>
          <target state="translated">파일 이름 생성자에 이름이 지정되지 않은 경우 파일의 파일 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="80e34d3d98320355b57f01ca1f7d293ca570add4" translate="yes" xml:space="preserve">
          <source>The file path of the null device. For example: &lt;code&gt;'/dev/null'&lt;/code&gt; for POSIX, &lt;code&gt;'nul'&lt;/code&gt; for Windows. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">널 장치의 파일 경로 예를 들어 POSIX의 경우 &lt;code&gt;'/dev/null'&lt;/code&gt; , Windows의 경우 &lt;code&gt;'nul'&lt;/code&gt; 입니다. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="9db19e8d7b718718ef1be032413eab83e5e95bd6" translate="yes" xml:space="preserve">
          <source>The file selected by the above constructor must have been created by the corresponding version of &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;. To be specific, there is &lt;em&gt;no&lt;/em&gt; file compatibility guaranteed with future versions of this profiler, and there is no compatibility with files produced by other profilers, or the same profiler run on a different operating system. If several files are provided, all the statistics for identical functions will be coalesced, so that an overall view of several processes can be considered in a single report. If additional files need to be combined with data in an existing &lt;a href=&quot;#pstats.Stats&quot;&gt;&lt;code&gt;Stats&lt;/code&gt;&lt;/a&gt; object, the &lt;a href=&quot;#pstats.Stats.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">위의 생성자에 의해 선택된 파일은 해당 버전의 &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; 에&lt;/a&gt; 의해 작성되어야합니다 . 구체적으로,이 없습니다 &lt;em&gt;에는&lt;/em&gt; 이 프로파일의 미래 버전으로 보장 파일 호환성 및 기타 프로파일, 또는 다른 운영 체제에서 실행되는 동일한 프로파일에 의해 생성 된 파일과 호환성이 없다. 여러 파일이 제공되는 경우 동일한 기능에 대한 모든 통계가 통합되므로 여러 프로세스의 전체보기를 단일 보고서에서 고려할 수 있습니다. 추가 파일을 기존 &lt;a href=&quot;#pstats.Stats&quot;&gt; &lt;code&gt;Stats&lt;/code&gt; &lt;/a&gt; 객체의 데이터와 결합해야하는 경우 &lt;a href=&quot;#pstats.Stats.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="713611df88c51a63c43837f66ca9e56dec2977b1" translate="yes" xml:space="preserve">
          <source>The file should not be displayed in a GUI (Mac OS X 10.5+).</source>
          <target state="translated">파일은 GUI (Mac OS X 10.5+)에 표시되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="72a6a7edb309ffffc9ff50c4223a156901528c2e" translate="yes" xml:space="preserve">
          <source>The file system encoding must guarantee to successfully decode all bytes below 128. If the file system encoding fails to provide this guarantee, API functions may raise UnicodeErrors.</source>
          <target state="translated">파일 시스템 인코딩은 128 미만의 모든 바이트를 성공적으로 디코딩하도록 보장해야합니다. 파일 시스템 인코딩이이 보증을 제공하지 못하면 API 함수가 UnicodeErrors를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94792315cec8c9be1d87163086775ef5d07712b0" translate="yes" xml:space="preserve">
          <source>The file upload draft standard entertains the possibility of uploading multiple files from one field (using a recursive &lt;em&gt;multipart/*&lt;/em&gt; encoding). When this occurs, the item will be a dictionary-like &lt;code&gt;FieldStorage&lt;/code&gt; item. This can be determined by testing its &lt;code&gt;type&lt;/code&gt; attribute, which should be &lt;em&gt;multipart/form-data&lt;/em&gt; (or perhaps another MIME type matching &lt;em&gt;multipart/*&lt;/em&gt;). In this case, it can be iterated over recursively just like the top-level form object.</source>
          <target state="translated">파일 업로드 초안 표준은 재귀 &lt;em&gt;멀티 파트 / *&lt;/em&gt; 인코딩을 사용하여 한 필드에서 여러 파일을 업로드 할 수있는 가능성을 제공합니다 . 이 경우 항목은 사전과 유사한 &lt;code&gt;FieldStorage&lt;/code&gt; 항목이됩니다. 이것은 &lt;em&gt;multipart / form-data&lt;/em&gt; (또는 &lt;em&gt;multipart / *와&lt;/em&gt; 일치하는 다른 MIME 형식) 인 &lt;code&gt;type&lt;/code&gt; 속성 을 테스트하여 확인할 수 있습니다 . 이 경우 최상위 폼 개체와 마찬가지로 재귀 적으로 반복 될 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="01c3cef533c6e179cf68ea7712d222e220b7be4d" translate="yes" xml:space="preserve">
          <source>The files &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; can also be invoked as a script to profile another script. For example:</source>
          <target state="translated">&lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 파일을 스크립트로 호출하여 다른 스크립트를 프로파일 링 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a703e11dae059161ce34a8e26e190e5aa60fdce6" translate="yes" xml:space="preserve">
          <source>The files are added to the CAB file in the order they appear in the list. All files are added into a single CAB file, using the MSZIP compression algorithm.</source>
          <target state="translated">파일은 목록에 나타나는 순서대로 CAB 파일에 추가됩니다. 모든 파일은 MSZIP 압축 알고리즘을 사용하여 단일 CAB 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="628200e3be239ea4113714e001538bfc9cba8656" translate="yes" xml:space="preserve">
          <source>The final block shows a simple way to run the tests. &lt;a href=&quot;#unittest.main&quot;&gt;&lt;code&gt;unittest.main()&lt;/code&gt;&lt;/a&gt; provides a command-line interface to the test script. When run from the command line, the above script produces an output that looks like this:</source>
          <target state="translated">마지막 블록은 테스트를 실행하는 간단한 방법을 보여줍니다. &lt;a href=&quot;#unittest.main&quot;&gt; &lt;code&gt;unittest.main()&lt;/code&gt; &lt;/a&gt; 은 테스트 스크립트에 명령 행 인터페이스를 제공합니다. 명령 행에서 실행될 때 위 스크립트는 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cde464fe0dc63abb87ca4aee7a531390b4905635" translate="yes" xml:space="preserve">
          <source>The final list of fields is, in order, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt;. The final type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;, as specified in class &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">마지막 필드 목록은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; 순서 입니다. 클래스 &lt;code&gt;C&lt;/code&gt; 에 지정된 &lt;code&gt;x&lt;/code&gt; 의 최종 유형 은 &lt;code&gt;int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d814d211e8c60b1de47f81cd19922cc90ce77a99" translate="yes" xml:space="preserve">
          <source>The final path component, without its suffix:</source>
          <target state="translated">접미사가없는 최종 경로 구성 요소 :</target>
        </trans-unit>
        <trans-unit id="19a9fd943d48e088d27c035c23e17046cb6ea3d1" translate="yes" xml:space="preserve">
          <source>The final path component.</source>
          <target state="translated">최종 경로 구성 요소</target>
        </trans-unit>
        <trans-unit id="cc0b59ae33b229e5d52ff81dd24e96cfff04266c" translate="yes" xml:space="preserve">
          <source>The final prediction goes to the largest posterior. This is known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation&quot;&gt;maximum a posteriori&lt;/a&gt; or MAP:</source>
          <target state="translated">최종 예측은 가장 큰 사후로 진행됩니다. 이것을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation&quot;&gt;최대 사후&lt;/a&gt; 또는 MAP라고합니다.</target>
        </trans-unit>
        <trans-unit id="80e06e46879bab91c1fc77685094ac909d2a64d5" translate="yes" xml:space="preserve">
          <source>The finalizer can be called directly as well. However the finalizer will invoke the callback at most once.</source>
          <target state="translated">종료자를 직접 호출 할 수도 있습니다. 그러나 종료자는 최대 한 번 콜백을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="324b78c6634c0758c37a7197ebd0b45ebca8cff7" translate="yes" xml:space="preserve">
          <source>The finder will cache the directory contents as necessary, making stat calls for each module search to verify the cache is not outdated. Because cache staleness relies upon the granularity of the operating system&amp;rsquo;s state information of the file system, there is a potential race condition of searching for a module, creating a new file, and then searching for the module the new file represents. If the operations happen fast enough to fit within the granularity of stat calls, then the module search will fail. To prevent this from happening, when you create a module dynamically, make sure to call &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt;&lt;code&gt;importlib.invalidate_caches()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파인더는 필요에 따라 디렉토리 내용을 캐시하여 각 모듈 검색에 대한 통계 호출을 수행하여 캐시가 오래되지 않았는지 확인합니다. 캐시 무효는 파일 시스템의 운영 체제 상태 정보의 세분성에 의존하기 때문에 모듈 검색, 새 파일 작성 및 새 파일이 나타내는 모듈 검색의 잠재적 경쟁 조건이 있습니다. 통계 호출의 세분성에 맞게 작업이 충분히 빠르게 수행되면 모듈 검색이 실패합니다. 이를 방지하려면 모듈을 동적으로 작성할 때 &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt; &lt;code&gt;importlib.invalidate_caches()&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="02b87a907d4c2d81f667613e2387e3b1c465d816" translate="yes" xml:space="preserve">
          <source>The fine print:</source>
          <target state="translated">작은 글씨 :</target>
        </trans-unit>
        <trans-unit id="aa3c351870f273c37e4f66d5a29426ed1177d605" translate="yes" xml:space="preserve">
          <source>The firing of low-level events at certain times or in certain connection states tells the asynchronous loop that certain higher-level events have taken place. For example, if we have asked for a socket to connect to another host, we know that the connection has been made when the socket becomes writable for the first time (at this point you know that you may write to it with the expectation of success). The implied higher-level events are:</source>
          <target state="translated">특정 시간 또는 특정 연결 상태에서 하위 레벨 이벤트가 발생하면 비동기 루프에 특정 상위 레벨 이벤트가 발생했음을 알립니다. 예를 들어, 다른 호스트에 연결하기 위해 소켓을 요청한 경우, 소켓이 처음으로 쓰기 가능할 때 연결되었음을 알 수 있습니다 (이 시점에서 성공을 기대하여 소켓에 쓸 수 있음을 알고 있음) ). 내재 된 상위 레벨 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="feeadec3b2801616fe6a8b3a64c74c94879374e9" translate="yes" xml:space="preserve">
          <source>The first argument is a list of regular expressions, either compiled (&lt;a href=&quot;re#re-objects&quot;&gt;regex objects&lt;/a&gt;) or uncompiled (byte strings). The optional second argument is a timeout, in seconds; the default is to block indefinitely.</source>
          <target state="translated">첫 번째 인수는 컴파일 된 ( &lt;a href=&quot;re#re-objects&quot;&gt;regex objects&lt;/a&gt; ) 또는 컴파일되지 않은 (바이트 문자열) 정규식 목록입니다 . 선택적 두 번째 인수는 초 단위의 시간 초과입니다. 기본값은 무기한 차단하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c6b514b7c6b751da2eb0e1ffc8d72e9f29203f5" translate="yes" xml:space="preserve">
          <source>The first argument provides the initial value for the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; attribute; it defaults to &lt;code&gt;None&lt;/code&gt;. All remaining arguments are treated the same as if they were passed to the &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; constructor, including keyword arguments.</source>
          <target state="translated">첫 번째 인수는 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 속성 의 초기 값을 제공 합니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다. 나머지 모든 인수는 키워드 인수를 포함 하여 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 생성자에 전달 된 것처럼 동일하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="205e58d9499aafe9cdb607f8d35493057d84cfb1" translate="yes" xml:space="preserve">
          <source>The first argument to the callback signifies what kind of operation is to be authorized. The second and third argument will be arguments or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; depending on the first argument. The 4th argument is the name of the database (&amp;ldquo;main&amp;rdquo;, &amp;ldquo;temp&amp;rdquo;, etc.) if applicable. The 5th argument is the name of the inner-most trigger or view that is responsible for the access attempt or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if this access attempt is directly from input SQL code.</source>
          <target state="translated">콜백에 대한 첫 번째 인수는 어떤 종류의 작업이 권한 부여되는지를 나타냅니다. 두 번째 및 세 번째 인수는 첫 번째 인수에 따라 인수이거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 입니다. 네 번째 인수는 해당되는 경우 데이터베이스 이름 ( &quot;main&quot;, &quot;temp&quot;등)입니다. 다섯 번째 인수는 액세스 시도를 담당하는 가장 안쪽 트리거 또는 뷰의 이름이거나이 액세스 시도가 입력 SQL 코드에서 직접 수행 된 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="71a29578a01ad10028e29ebf89ef4d001c2a9cfe" translate="yes" xml:space="preserve">
          <source>The first call will actually sort the list by function name, and the second call will print out the statistics. The following are some interesting calls to experiment with:</source>
          <target state="translated">첫 번째 호출은 실제로 함수 이름별로 목록을 정렬하고 두 번째 호출은 통계를 인쇄합니다. 다음은 몇 가지 흥미로운 실험 호출입니다.</target>
        </trans-unit>
        <trans-unit id="030d76d81608222603d09c4d4d4c94ee206bc1ca" translate="yes" xml:space="preserve">
          <source>The first child of the node, if there are any, or &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">노드의 첫 번째 자식, 어떤, 또는 존재하지 않는 경우는 &lt;code&gt;None&lt;/code&gt; . 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="325d7875dfe1839450d2dfe98a6d36a120b66778" translate="yes" xml:space="preserve">
          <source>The first example shows the most common usage of &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">첫 번째 예는 &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; 의 가장 일반적인 사용법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="385191c7e22d5d00e8c01f733769abf79ae0e9cf" translate="yes" xml:space="preserve">
          <source>The first four lines correspond to the arguments of the &lt;code&gt;Screen.setup()&lt;/code&gt; method.</source>
          <target state="translated">처음 네 줄은 &lt;code&gt;Screen.setup()&lt;/code&gt; 메서드 의 인수에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="42f8632ad7c20d5fdbbd018b653108a6af8d9377" translate="yes" xml:space="preserve">
          <source>The first function notation is supported by all platforms that define &lt;a href=&quot;#os.sendfile&quot;&gt;&lt;code&gt;sendfile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첫 번째 함수 표기법은 &lt;a href=&quot;#os.sendfile&quot;&gt; &lt;code&gt;sendfile()&lt;/code&gt; &lt;/a&gt; 을 정의하는 모든 플랫폼에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="43529dac190a43326357cd2f5a9d21f0ccec3671" translate="yes" xml:space="preserve">
          <source>The first group of options define test semantics, controlling aspects of how doctest decides whether actual output matches an example&amp;rsquo;s expected output:</source>
          <target state="translated">첫 번째 옵션 그룹은 테스트 시맨틱을 정의하여 doctest가 실제 출력이 예제의 예상 출력과 일치하는지 여부를 결정하는 방법의 측면을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a61627c597bc87ccaa5b8516aab05143b8e515c1" translate="yes" xml:space="preserve">
          <source>The first index of invalid data in &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 에서 유효하지 않은 데이터의 첫 번째 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="54ec8104a8dcb6fdc67594e88b1749c9e091d524" translate="yes" xml:space="preserve">
          <source>The first item is an integer containing a combination of direction flags for the parameter:</source>
          <target state="translated">첫 번째 항목은 매개 변수에 방향 플래그 조합이 포함 된 정수입니다.</target>
        </trans-unit>
        <trans-unit id="0ca4b9ef66540ab18c3155d91436466ad9c2f991" translate="yes" xml:space="preserve">
          <source>The first letter can be either of &lt;code&gt;'-'&lt;/code&gt; (which means the command reads its standard input), &lt;code&gt;'f'&lt;/code&gt; (which means the commands reads a given file on the command line) or &lt;code&gt;'.'&lt;/code&gt; (which means the commands reads no input, and hence must be first.)</source>
          <target state="translated">첫 번째 문자는 &lt;code&gt;'-'&lt;/code&gt; (명령이 표준 입력을 읽는 것을 의미), &lt;code&gt;'f'&lt;/code&gt; (명령이 명령 행에서 주어진 파일을 읽는 것을 의미) 또는 &lt;code&gt;'.'&lt;/code&gt; 중 하나 일 수 있습니다.(이것은 명령이 입력을 읽지 않으므로 먼저 입력해야 함을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="71c4ea972d5bdb15f737a2bfb933afebcd39c2f7" translate="yes" xml:space="preserve">
          <source>The first line indicates that 197 calls were monitored. Of those calls, 192 were &lt;em&gt;primitive&lt;/em&gt;, meaning that the call was not induced via recursion. The next line: &lt;code&gt;Ordered by: standard name&lt;/code&gt;, indicates that the text string in the far right column was used to sort the output. The column headings include:</source>
          <target state="translated">첫 번째 줄은 197 개의 통화가 모니터링되었음을 나타냅니다. 이 호출 중 192 개는 &lt;em&gt;원시적&lt;/em&gt; 이므로 호출이 재귀를 통해 유발되지 않았 음을 의미합니다. 다음 줄 : &lt;code&gt;Ordered by: standard name&lt;/code&gt; 은 맨 오른쪽 열의 텍스트 문자열이 출력을 정렬하는 데 사용되었음을 나타냅니다. 열 제목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88b750bdde2a92f041228f07e4bb845b9726c8f5" translate="yes" xml:space="preserve">
          <source>The first parameter, &lt;em&gt;function&lt;/em&gt;, is the function which raised the exception; it depends on the platform and implementation. The second parameter, &lt;em&gt;path&lt;/em&gt;, will be the path name passed to &lt;em&gt;function&lt;/em&gt;. The third parameter, &lt;em&gt;excinfo&lt;/em&gt;, will be the exception information returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;. Exceptions raised by &lt;em&gt;onerror&lt;/em&gt; will not be caught.</source>
          <target state="translated">첫 번째 매개 변수 인 &lt;em&gt;function&lt;/em&gt; 은 예외를 발생시킨 함수입니다. 플랫폼과 구현에 따라 다릅니다. 두 번째 매개 변수 인 &lt;em&gt;path&lt;/em&gt; 는 &lt;em&gt;function에&lt;/em&gt; 전달 된 경로 이름 입니다. 세 번째 매개 변수 &lt;em&gt;excinfo&lt;/em&gt; 는 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 반환 한 예외 정보 입니다. &lt;em&gt;onerror에&lt;/em&gt; 의해 발생한 예외는 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="773640730c7cf1ed138ed10047b4279b77d04ee8" translate="yes" xml:space="preserve">
          <source>The first part of this documentation covers the features of &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt; that defines the features that are common to all policy objects, including &lt;a href=&quot;#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt;. This includes certain hook methods that are called internally by the email package, which a custom policy could override to obtain different behavior. The second part describes the concrete classes &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#email.policy.Compat32&quot;&gt;&lt;code&gt;Compat32&lt;/code&gt;&lt;/a&gt;, which implement the hooks that provide the standard behavior and the backward compatible behavior and features, respectively.</source>
          <target state="translated">이 문서의 첫 번째 부분은 &lt;a href=&quot;#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 를&lt;/a&gt; 포함한 모든 정책 객체에 공통적 인 기능을 정의 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스&lt;/a&gt; 인 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 의 기능을 다룹니다 . 여기에는 이메일 패키지에 의해 내부적으로 호출되는 특정 후크 메소드가 포함되며, 사용자 정의 정책은 다른 동작을 얻기 위해 대체 할 수 있습니다. 두 번째 부분에서는 구체적인 동작 인 &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#email.policy.Compat32&quot;&gt; &lt;code&gt;Compat32&lt;/code&gt; 에&lt;/a&gt; 대해 설명합니다.이 클래스 는 표준 동작과 이전 버전과 호환되는 동작 및 기능을 각각 제공하는 후크를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="260b4cde00c691683b690b8fefbfeb939e1a12af" translate="yes" xml:space="preserve">
          <source>The first seven arguments are (&lt;code&gt;args&lt;/code&gt;, &lt;code&gt;varargs&lt;/code&gt;, &lt;code&gt;varkw&lt;/code&gt;, &lt;code&gt;defaults&lt;/code&gt;, &lt;code&gt;kwonlyargs&lt;/code&gt;, &lt;code&gt;kwonlydefaults&lt;/code&gt;, &lt;code&gt;annotations&lt;/code&gt;).</source>
          <target state="translated">처음 7 개의 인수는 ( &lt;code&gt;args&lt;/code&gt; , &lt;code&gt;varargs&lt;/code&gt; , &lt;code&gt;varkw&lt;/code&gt; , &lt;code&gt;defaults&lt;/code&gt; , &lt;code&gt;kwonlyargs&lt;/code&gt; , &lt;code&gt;kwonlydefaults&lt;/code&gt; , &lt;code&gt;annotations&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="eca277394ed7c2896c7c7d772bf656447668dd51" translate="yes" xml:space="preserve">
          <source>The first source line of the code object (if available)</source>
          <target state="translated">코드 객체의 첫 번째 소스 라인 (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="1b7000eb925b584e4133d7b28aa26d69000c610f" translate="yes" xml:space="preserve">
          <source>The first step in using the &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; is creating an &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">&lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 를 사용하는 첫 번째 단계 는 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 객체를 만드는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9b2e1b9bcae7f1307e5235d867471e2e7c3ddf99" translate="yes" xml:space="preserve">
          <source>The first string specifies the program executable, and the remaining strings specify the arguments. Together, string arguments form the &lt;code&gt;argv&lt;/code&gt; of the program.</source>
          <target state="translated">첫 번째 문자열은 프로그램 실행 파일을 지정하고 나머지 문자열은 인수를 지정합니다. 함께 문자열 인수 는 프로그램 의 &lt;code&gt;argv&lt;/code&gt; 를 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="69c597f00dce4e812c0bf05fd7ab11267fe6c188" translate="yes" xml:space="preserve">
          <source>The first such file name that exists is returned by &lt;a href=&quot;#gettext.find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt;. If no such file is found, then &lt;code&gt;None&lt;/code&gt; is returned. If &lt;em&gt;all&lt;/em&gt; is given, it returns a list of all file names, in the order in which they appear in the languages list or the environment variables.</source>
          <target state="translated">존재하는 첫 번째 파일 이름은 &lt;a href=&quot;#gettext.find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 의해 리턴됩니다 . 그러한 파일이 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 경우 &lt;em&gt;모두&lt;/em&gt; 주어, 그들이 언어 목록 또는 환경 변수에 나타나는 순서대로, 모든 파일 이름의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f15cc87f948ec88467eca7ad326067dfb4d43de2" translate="yes" xml:space="preserve">
          <source>The first three arguments are the components that make up a class definition header: the class name, the base classes (in order), the keyword arguments (such as &lt;code&gt;metaclass&lt;/code&gt;).</source>
          <target state="translated">처음 세 개의 인수는 클래스 정의 헤더를 구성하는 구성 요소입니다. 클래스 이름, 기본 클래스 (순서대로), 키워드 인수 (예 : &lt;code&gt;metaclass&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac9fb53fa591519e788fdff11ee11fadfcffe45f" translate="yes" xml:space="preserve">
          <source>The first two examples support IPv4 only.</source>
          <target state="translated">처음 두 예제는 IPv4 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="154dd11293b4f0a9c622295b949fa0e55da8605a" translate="yes" xml:space="preserve">
          <source>The first variation of &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; that is provided is also a subclass of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. Members of an &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; can be compared to integers; by extension, integer enumerations of different types can also be compared to each other:</source>
          <target state="translated">제공되는 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 의 첫 번째 변형 은 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 의 하위 클래스이기도합니다 . &lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; 의&lt;/a&gt; 멤버는 정수와 비교할 수 있습니다. 확장하여 다른 유형의 정수 열거도 서로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d60dcd520644aae4a51c2783ce939a1618d8cd2" translate="yes" xml:space="preserve">
          <source>The first version requires that &lt;em&gt;numerator&lt;/em&gt; and &lt;em&gt;denominator&lt;/em&gt; are instances of &lt;a href=&quot;numbers#numbers.Rational&quot;&gt;&lt;code&gt;numbers.Rational&lt;/code&gt;&lt;/a&gt; and returns a new &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; instance with value &lt;code&gt;numerator/denominator&lt;/code&gt;. If &lt;em&gt;denominator&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt;, it raises a &lt;a href=&quot;exceptions#ZeroDivisionError&quot;&gt;&lt;code&gt;ZeroDivisionError&lt;/code&gt;&lt;/a&gt;. The second version requires that &lt;em&gt;other_fraction&lt;/em&gt; is an instance of &lt;a href=&quot;numbers#numbers.Rational&quot;&gt;&lt;code&gt;numbers.Rational&lt;/code&gt;&lt;/a&gt; and returns a &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; instance with the same value. The next two versions accept either a &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt; instance, and return a &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; instance with exactly the same value. Note that due to the usual issues with binary floating-point (see &lt;a href=&quot;https://docs.python.org/3.8/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;Floating Point Arithmetic: Issues and Limitations&lt;/a&gt;), the argument to &lt;code&gt;Fraction(1.1)&lt;/code&gt; is not exactly equal to 11/10, and so &lt;code&gt;Fraction(1.1)&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; return &lt;code&gt;Fraction(11, 10)&lt;/code&gt; as one might expect. (But see the documentation for the &lt;a href=&quot;#fractions.Fraction.limit_denominator&quot;&gt;&lt;code&gt;limit_denominator()&lt;/code&gt;&lt;/a&gt; method below.) The last version of the constructor expects a string or unicode instance. The usual form for this instance is:</source>
          <target state="translated">첫 번째 버전에서는 &lt;em&gt;분자&lt;/em&gt; 및 &lt;em&gt;분모&lt;/em&gt; 가 &lt;a href=&quot;numbers#numbers.Rational&quot;&gt; &lt;code&gt;numbers.Rational&lt;/code&gt; &lt;/a&gt; 인스턴스 여야 합니다 .Rational and &lt;code&gt;numerator/denominator&lt;/code&gt; 값을 가진 새 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환합니다 . 경우 &lt;em&gt;분모&lt;/em&gt; 인 &lt;code&gt;0&lt;/code&gt; 을 , 그것은 제기 &lt;a href=&quot;exceptions#ZeroDivisionError&quot;&gt; &lt;code&gt;ZeroDivisionError&lt;/code&gt; 를&lt;/a&gt; . 두 번째 버전에서는 &lt;em&gt;other_fraction&lt;/em&gt; 이 &lt;a href=&quot;numbers#numbers.Rational&quot;&gt; &lt;code&gt;numbers.Rational&lt;/code&gt; &lt;/a&gt; 의 인스턴스 &lt;em&gt;여야&lt;/em&gt; 합니다 &lt;em&gt;.Rational&lt;/em&gt; 은 같은 값을 가진 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다. 다음 두 버전은 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; 허용합니다 .Decimal instance, and a &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;정확히 같은 값을 가진 인스턴스. 때문에 진 부동 소수점과 일반적인 문제 (참조 점에 유의 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;소수점 연산 부동 : 문제 및 제한&lt;/a&gt; )에 인수 &lt;code&gt;Fraction(1.1)&lt;/code&gt; 정확하지 않다 11/10에 동일하고, 그래서 &lt;code&gt;Fraction(1.1)&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 반환 &lt;code&gt;Fraction(11, 10)&lt;/code&gt; 예상대로. (그러나 아래 의 &lt;a href=&quot;#fractions.Fraction.limit_denominator&quot;&gt; &lt;code&gt;limit_denominator()&lt;/code&gt; &lt;/a&gt; 메서드에 대한 설명서를 참조하십시오 .) 생성자의 마지막 버전에는 문자열 또는 유니 코드 인스턴스가 필요합니다. 이 인스턴스의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a66aba6e485ab9f7939b6d026c0abcf553b5f4e" translate="yes" xml:space="preserve">
          <source>The first version returns the nearest &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;self&lt;/code&gt;, rounding half to even. The second version rounds &lt;code&gt;self&lt;/code&gt; to the nearest multiple of &lt;code&gt;Fraction(1, 10**ndigits)&lt;/code&gt; (logically, if &lt;code&gt;ndigits&lt;/code&gt; is negative), again rounding half toward even. This method can also be accessed through the &lt;a href=&quot;functions#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">첫 번째 버전은 가장 가까운 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;self&lt;/code&gt; 로 반환하고 반은 짝수로 반올림합니다. 두 번째 버전 라운드 &lt;code&gt;self&lt;/code&gt; 의 가장 가까운 배수로 &lt;code&gt;Fraction(1, 10**ndigits)&lt;/code&gt; (논리적으로, 경우 &lt;code&gt;ndigits&lt;/code&gt; 는 이다 음은) 다시 심지어으로 절반을 반올림. 이 메소드는 &lt;a href=&quot;functions#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; 함수를 통해 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8469a524945b16d1ec34b200182d5e6c61700cb3" translate="yes" xml:space="preserve">
          <source>The flag is set if there are no free or cell variables.</source>
          <target state="translated">자유 또는 셀 변수가없는 경우 플래그가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed52b2ed227b010284477f61a5a82abcb5746897" translate="yes" xml:space="preserve">
          <source>The flag is set when the code object is a coroutine function. When the code object is executed it returns a coroutine object. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 492&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">코드 객체가 코 루틴 함수일 때 플래그가 설정됩니다. 코드 객체가 실행될 때 코 루틴 객체를 반환합니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 492&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3948c22b1c91f14b44ee0f8962182b1c03b07992" translate="yes" xml:space="preserve">
          <source>The flag is set when the code object is a generator function, i.e. a generator object is returned when the code object is executed.</source>
          <target state="translated">코드 객체가 생성기 함수 인 경우 플래그가 설정됩니다. 즉, 생성 된 객체는 코드 객체가 실행될 때 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0ec5f37142a811991c100249624cda19de5e3ecf" translate="yes" xml:space="preserve">
          <source>The flag is set when the code object is a nested function.</source>
          <target state="translated">플래그는 코드 객체가 중첩 함수일 때 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="67db30428201e8fb3c706e18a40ea74df8dfc9a8" translate="yes" xml:space="preserve">
          <source>The flag is set when the code object is an asynchronous generator function. When the code object is executed it returns an asynchronous generator object. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">코드 오브젝트가 비동기 생성기 함수 인 경우 플래그가 설정됩니다. 코드 객체가 실행되면 비동기 생성기 객체가 반환됩니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="814aa93788cd39271af8f2ff1334ffe907eef62c" translate="yes" xml:space="preserve">
          <source>The flag is used to transform generators into generator-based coroutines. Generator objects with this flag can be used in &lt;code&gt;await&lt;/code&gt; expression, and can &lt;code&gt;yield from&lt;/code&gt; coroutine objects. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 492&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 플래그는 생성기를 생성기 기반 코 루틴으로 변환하는 데 사용됩니다. 이 플래그가있는 생성기 객체는 식 을 &lt;code&gt;await&lt;/code&gt; 데 사용할 수 있으며 코 루틴 객체 &lt;code&gt;yield from&lt;/code&gt; 될 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 492&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="472ef2122f93d92a4d6151f3b1a3fc79dda359ab" translate="yes" xml:space="preserve">
          <source>The flags are specific to CPython, and may not be defined in other Python implementations. Furthermore, the flags are an implementation detail, and can be removed or deprecated in future Python releases. It&amp;rsquo;s recommended to use public APIs from the &lt;a href=&quot;#module-inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; module for any introspection needs.</source>
          <target state="translated">플래그는 CPython에만 해당되며 다른 Python 구현에서는 정의되지 않을 수 있습니다. 또한 플래그는 구현 세부 사항이며 향후 Python 릴리스에서 제거되거나 더 이상 사용되지 않을 수 있습니다. 모든 검사 요구에 대해 &lt;a href=&quot;#module-inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt; 모듈의 공개 API를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7b65eef96d81c5617b228952c6bdd02752ed58a5" translate="yes" xml:space="preserve">
          <source>The flags argument contains a bitwise OR of zero or more of the following flags:</source>
          <target state="translated">flags 인수는 다음 플래그 중 0 이상의 비트 단위 OR을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a4ed5bbe8d763440ed3806e2c210ec422dec4cdd" translate="yes" xml:space="preserve">
          <source>The flags argument is a bit mask that can contain zero or more of the following values ORed together: &lt;a href=&quot;#os.GRND_RANDOM&quot;&gt;&lt;code&gt;os.GRND_RANDOM&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt;&lt;code&gt;GRND_NONBLOCK&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">flags 인자는 &lt;a href=&quot;#os.GRND_RANDOM&quot;&gt; &lt;code&gt;os.GRND_RANDOM&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt; &lt;code&gt;GRND_NONBLOCK&lt;/code&gt; &lt;/a&gt; 과 같이 0 이상의 값을 포함 할 수있는 비트 마스크입니다 .</target>
        </trans-unit>
        <trans-unit id="e42e6fb9b1c8d82e67ecac0f6d6031b833228308" translate="yes" xml:space="preserve">
          <source>The flags for certificate verification operations. You can set flags like &lt;a href=&quot;#ssl.VERIFY_CRL_CHECK_LEAF&quot;&gt;&lt;code&gt;VERIFY_CRL_CHECK_LEAF&lt;/code&gt;&lt;/a&gt; by ORing them together. By default OpenSSL does neither require nor verify certificate revocation lists (CRLs). Available only with openssl version 0.9.8+.</source>
          <target state="translated">인증서 확인 작업을위한 플래그입니다. &lt;a href=&quot;#ssl.VERIFY_CRL_CHECK_LEAF&quot;&gt; &lt;code&gt;VERIFY_CRL_CHECK_LEAF&lt;/code&gt; &lt;/a&gt; 와 같은 플래그를 함께 OR하여 설정할 수 있습니다 . 기본적으로 OpenSSL은 CRL (인증서 해지 목록)을 요구하거나 확인하지 않습니다. openssl 버전 0.9.8 이상에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c7e52a18a4bd1a25b0dadd8f95a2ddf5d9b66f31" translate="yes" xml:space="preserve">
          <source>The float type implements the &lt;a href=&quot;numbers#numbers.Real&quot;&gt;&lt;code&gt;numbers.Real&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt;. float also has the following additional methods.</source>
          <target state="translated">float 형식은 &lt;a href=&quot;numbers#numbers.Real&quot;&gt; &lt;code&gt;numbers.Real&lt;/code&gt; &lt;/a&gt; 구현합니다 . 실제 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스&lt;/a&gt; 입니다. float에는 다음과 같은 추가 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92f2a154936409f6982bec487393509f452999b7" translate="yes" xml:space="preserve">
          <source>The float type is described in &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;Numeric Types &amp;mdash; int, float, complex&lt;/a&gt;.</source>
          <target state="translated">float 유형은 &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;숫자 유형-int, float, complex에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89fb9d615ea00e40317c5f9968a1d62d02815cb3" translate="yes" xml:space="preserve">
          <source>The floor is computed and the remainder (if any) is thrown away. In the second case, an integer is returned. (3)</source>
          <target state="translated">바닥이 계산되고 나머지 부분이 있으면 버려집니다. 두 번째 경우 정수가 반환됩니다. (삼)</target>
        </trans-unit>
        <trans-unit id="cd4f887b55eeea791769598b7071c612e7f2c0e7" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; methods are meant for use in unit tests and &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">다음의 &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 방법은 단위 테스트 및 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 구현 에 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="78d23bc14b87f27435176d1c007b23cff76c66a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt; method is intended to be called by code using the email library to create policy instances with custom settings:</source>
          <target state="translated">다음 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 방법은 전자 메일 라이브러리를 사용하여 코드로 호출하여 사용자 지정 설정으로 정책 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="57447dead23ff464ff3d7bf38606b16eaa9986c7" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; subclasses are provided for reading and writing.</source>
          <target state="translated">읽기 및 쓰기를 위해 다음 &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; &lt;/a&gt; 서브 클래스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="941e9d82eb275d485c825efd74180297955eef50" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;RUSAGE_*&lt;/code&gt; symbols are passed to the &lt;a href=&quot;#resource.getrusage&quot;&gt;&lt;code&gt;getrusage()&lt;/code&gt;&lt;/a&gt; function to specify which processes information should be provided for.</source>
          <target state="translated">다음 &lt;code&gt;RUSAGE_*&lt;/code&gt; 기호는 &lt;a href=&quot;#resource.getrusage&quot;&gt; &lt;code&gt;getrusage()&lt;/code&gt; &lt;/a&gt; 함수로 전달되어 제공 할 프로세스 정보를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8e590fd88205ef9e15a283b79c60eb9e96a14455" translate="yes" xml:space="preserve">
          <source>The following Python code helps explain what &lt;em&gt;tee&lt;/em&gt; does (although the actual implementation is more complex and uses only a single underlying</source>
          <target state="translated">다음의 파이썬 코드 는 &lt;em&gt;티&lt;/em&gt; 가 무엇을하는지 설명하는데 도움이됩니다</target>
        </trans-unit>
        <trans-unit id="e926ba94f9d733ea5f82756a4605d41839945c93" translate="yes" xml:space="preserve">
          <source>The following Python types can thus be sent to SQLite without any problem:</source>
          <target state="translated">따라서 다음 Python 유형을 아무런 문제없이 SQLite로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6784883eb3348f6fc5ea7e327435f77a01ccee1" translate="yes" xml:space="preserve">
          <source>The following W3C document, &lt;a href=&quot;https://www.w3.org/International/O-charset&quot;&gt;https://www.w3.org/International/O-charset&lt;/a&gt;, lists the various ways in which an (X)HTML or an XML document could have specified its encoding information.</source>
          <target state="translated">다음 W3C 문서 인 &lt;a href=&quot;https://www.w3.org/International/O-charset&quot;&gt;https://www.w3.org/International/O-charset&lt;/a&gt; 은 (X) HTML 또는 XML 문서가 인코딩 정보를 지정할 수있는 다양한 방법을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4329043e2577e3e7375d57bbfa47e67713420c76" translate="yes" xml:space="preserve">
          <source>The following additional characters may be appended to the flag to control how the database is opened:</source>
          <target state="translated">다음과 같은 추가 문자가 플래그에 추가되어 데이터베이스를 여는 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04d5255067d8b5087d6c7f2f54cf21788f68331" translate="yes" xml:space="preserve">
          <source>The following applies to all start methods.</source>
          <target state="translated">다음은 모든 시작 방법에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fe0b5f0ab021ddc435da4df2426e3b6a7d64523e" translate="yes" xml:space="preserve">
          <source>The following are defined as class-level attributes of &lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt;&lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt; &lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt; 의&lt;/a&gt; 클래스 레벨 속성으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="493f6ff18fe3ca63e3f57c1cbbddbc4bfdc65230" translate="yes" xml:space="preserve">
          <source>The following are optional NNTP extensions defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2980.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2980&lt;/strong&gt;&lt;/a&gt;. Some of them have been superseded by newer commands in &lt;a href=&quot;https://tools.ietf.org/html/rfc3977.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 3977&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2980.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2980에&lt;/strong&gt;&lt;/a&gt; 정의 된 선택적 NNTP 확장 입니다. 이들 중 일부는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3977.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 3977의&lt;/strong&gt;&lt;/a&gt; 최신 명령으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1dee97e7d46ddeef07ad66ff95b44fdec12cbbff" translate="yes" xml:space="preserve">
          <source>The following are the valid string and SortKey:</source>
          <target state="translated">유효한 문자열과 SortKey는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bb90197cfa182080451d9e4160dcb0640565187" translate="yes" xml:space="preserve">
          <source>The following attribute and methods should only be used by classes derived from &lt;a href=&quot;#urllib.request.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 속성 및 메소드는 &lt;a href=&quot;#urllib.request.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 에서 파생 된 클래스에서만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb23742802da9eb7259b6abdcb456333d0a48b2c" translate="yes" xml:space="preserve">
          <source>The following attributes are also available:</source>
          <target state="translated">다음과 같은 속성도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eceabfa85f58879acaae3fe2f9f8b84e838e470" translate="yes" xml:space="preserve">
          <source>The following attributes are defined on instances of &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 속성은 &lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; &lt;/a&gt; 인스턴스에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="436a20c21ef45203d573ca4aa36d5e1c54e2e851" translate="yes" xml:space="preserve">
          <source>The following attributes are provided for convenience, and are the most useful combinations of the above flags:</source>
          <target state="translated">편의를 위해 다음 속성이 제공되며 위 플래그의 가장 유용한 조합입니다.</target>
        </trans-unit>
        <trans-unit id="e8e6bd955c5c9b643aaae8484e0863b9e6f73b80" translate="yes" xml:space="preserve">
          <source>The following attributes contain values relating to the current parse location in an &lt;code&gt;xmlparser&lt;/code&gt; object. During a callback reporting a parse event they indicate the location of the first of the sequence of characters that generated the event. When called outside of a callback, the position indicated will be just past the last parse event (regardless of whether there was an associated callback).</source>
          <target state="translated">다음 속성은 &lt;code&gt;xmlparser&lt;/code&gt; 객체 의 현재 구문 분석 위치와 관련된 값을 포함 합니다. 구문 분석 이벤트를보고하는 콜백 중에는 이벤트를 생성 한 첫 번째 문자 시퀀스의 위치를 ​​나타냅니다. 콜백 외부에서 호출되면 표시된 콜백은 마지막 구문 분석 이벤트를지나갑니다 (관련 콜백이 있는지 여부에 관계없이).</target>
        </trans-unit>
        <trans-unit id="7113a820fb71237b75638d22c11096a14dea5d8d" translate="yes" xml:space="preserve">
          <source>The following attributes contain values relating to the most recent error encountered by an &lt;code&gt;xmlparser&lt;/code&gt; object, and will only have correct values once a call to &lt;code&gt;Parse()&lt;/code&gt; or &lt;code&gt;ParseFile()&lt;/code&gt; has raised an &lt;a href=&quot;#xml.parsers.expat.ExpatError&quot;&gt;&lt;code&gt;xml.parsers.expat.ExpatError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">다음 속성은 &lt;code&gt;xmlparser&lt;/code&gt; 객체에서 발생한 가장 최근 오류와 관련된 값을 포함 하며 &lt;code&gt;Parse()&lt;/code&gt; 또는 &lt;code&gt;ParseFile()&lt;/code&gt; 호출에서 &lt;a href=&quot;#xml.parsers.expat.ExpatError&quot;&gt; &lt;code&gt;xml.parsers.expat.ExpatError&lt;/code&gt; &lt;/a&gt; 예외 가 발생한 경우 에만 올바른 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b8029e19ee3bc98ea3f739d0b23b2fa8cece911f" translate="yes" xml:space="preserve">
          <source>The following attributes have values that are different from the &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt; default:</source>
          <target state="translated">다음 속성은 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 기본값 과 다른 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="19a7dc07900c158b5f98d8b86469216de3ba29ba" translate="yes" xml:space="preserve">
          <source>The following attributes of a &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; can be configured either by subclassing or assignment on an instance:</source>
          <target state="translated">인스턴스에서 서브 클래 싱 또는 할당을 통해 &lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; &lt;/a&gt; 의 다음 속성을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f46b8f3ca7021134f6fc09e1b3c895db0e323ea" translate="yes" xml:space="preserve">
          <source>The following callbacks are called on &lt;a href=&quot;#asyncio.BufferedProtocol&quot;&gt;&lt;code&gt;BufferedProtocol&lt;/code&gt;&lt;/a&gt; instances:</source>
          <target state="translated">&lt;a href=&quot;#asyncio.BufferedProtocol&quot;&gt; &lt;code&gt;BufferedProtocol&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 다음 콜백이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ce04e341e5b95ab13da3a2b67690a015d59cdcb" translate="yes" xml:space="preserve">
          <source>The following class implements a parser that will be used to illustrate more examples:</source>
          <target state="translated">다음 클래스는 더 많은 예제를 설명하는 데 사용되는 구문 분석기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c1e9e8dbaf83d4bd1b564c338b27a5b8ac01490b" translate="yes" xml:space="preserve">
          <source>The following classes are available:</source>
          <target state="translated">이용 가능한 수업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf77f9e884fd9a2e64c18b91e96221bdac8e8a18" translate="yes" xml:space="preserve">
          <source>The following classes are provided:</source>
          <target state="translated">다음과 같은 클래스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="776ad4b0b1fc73870feeb0df3aa3500c99e92113" translate="yes" xml:space="preserve">
          <source>The following classes are the classes used to represent data parsed from structured headers and can, in general, be used by an application program to construct structured values to assign to specific headers.</source>
          <target state="translated">다음 클래스는 구조화 된 헤더에서 구문 분석 된 데이터를 나타내는 데 사용되는 클래스이며 일반적으로 애플리케이션 프로그램에서 특정 헤더에 지정할 구조화 된 값을 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf852c278240688680230326012f83f01ee8dda" translate="yes" xml:space="preserve">
          <source>The following classes provide the implementations of the parse results when operating on &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">다음 클래스는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 바이트 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 객체 에서 작동 할 때 구문 분석 결과의 구현을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="2a8f9a5fce9e21a0ddb67e16a8bd2016f44c9426" translate="yes" xml:space="preserve">
          <source>The following classes provide the implementations of the structured parse results when operating on &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">다음 클래스는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체에서 작동 할 때 구조화 된 구문 분석 결과의 구현을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="6bc4a1812e683c53af6ce054907acc1948bcc44a" translate="yes" xml:space="preserve">
          <source>The following client code will call the methods made available by the preceding server:</source>
          <target state="translated">다음 클라이언트 코드는 이전 서버에서 사용 가능한 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b9f5855661bc69d1bbc9f188edcc6422538bf453" translate="yes" xml:space="preserve">
          <source>The following code connects to the server and receives some data from the server:</source>
          <target state="translated">다음 코드는 서버에 연결하고 서버에서 일부 데이터를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="68ebfc5f9876cf31f85eec23cbd7606dde463890" translate="yes" xml:space="preserve">
          <source>The following code is a Python program that takes a list of integers and produces either the sum or the max:</source>
          <target state="translated">다음 코드는 정수 목록을 가져와 합계 또는 최대 값을 생성하는 Python 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="33c4f1b9f7868200d82e533f806095ec68f717b3" translate="yes" xml:space="preserve">
          <source>The following code uses &lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; to wait for messages from multiple processes at once:</source>
          <target state="translated">다음 코드는 &lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 여러 프로세스의 메시지를 한 번에 기다립니다.</target>
        </trans-unit>
        <trans-unit id="b52ed289a53f55a282ec7ec617b97682fe024623" translate="yes" xml:space="preserve">
          <source>The following codec provides a text transform: a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; mapping. It is not supported by &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;str.encode()&lt;/code&gt;&lt;/a&gt; (which only produces &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; output).</source>
          <target state="translated">다음 코덱은 텍스트 변환을 제공합니다 . &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; to &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 매핑. &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;str.encode()&lt;/code&gt; &lt;/a&gt; 는 지원하지 않습니다 ( &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 출력 만 생성 함 ).</target>
        </trans-unit>
        <trans-unit id="7e744597dd53841c8c8102ea3b4cc315bd8163a6" translate="yes" xml:space="preserve">
          <source>The following codecs provide &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; encoding and &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; to &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; decoding, similar to the Unicode text encodings.</source>
          <target state="translated">다음 코덱 은 유니 코드 텍스트 인코딩과 유사한 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; to &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 인코딩 및 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;byte-like 객체&lt;/a&gt; to &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 디코딩을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d259fb7cc5745e79d6cd750e440d2f1424078478" translate="yes" xml:space="preserve">
          <source>The following codecs provide binary transforms: &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; mappings. They are not supported by &lt;a href=&quot;stdtypes#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode()&lt;/code&gt;&lt;/a&gt; (which only produces &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; output).</source>
          <target state="translated">다음 코덱은 이진 변환을 제공 합니다. &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt; 유사 객체&lt;/a&gt; 대 바이트 매핑. &lt;a href=&quot;stdtypes#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode()&lt;/code&gt; &lt;/a&gt; 에서는 지원되지 않습니다 ( &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 출력 만 생성 함 ).</target>
        </trans-unit>
        <trans-unit id="434fdf5c9b0ef216b7167b3a268500f99ef7d459" translate="yes" xml:space="preserve">
          <source>The following constant is the only parameter that can be sent to &lt;a href=&quot;#time.clock_settime&quot;&gt;&lt;code&gt;clock_settime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 상수는 &lt;a href=&quot;#time.clock_settime&quot;&gt; &lt;code&gt;clock_settime()&lt;/code&gt; &lt;/a&gt; 으로 보낼 수있는 유일한 매개 변수입니다. .</target>
        </trans-unit>
        <trans-unit id="9ee4a57faca157f748bf6c4be3e1f4055c7770ce" translate="yes" xml:space="preserve">
          <source>The following constants are available at the module level:</source>
          <target state="translated">모듈 수준에서 다음 상수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15620e1a702d8f287c721f0664c56441b8748c38" translate="yes" xml:space="preserve">
          <source>The following constants are available:</source>
          <target state="translated">다음 상수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc75344c855052cd9b4b292032d5d1cfb31f8eab" translate="yes" xml:space="preserve">
          <source>The following constants are defined for use in many &lt;code&gt;_winreg&lt;/code&gt; functions.</source>
          <target state="translated">많은 &lt;code&gt;_winreg&lt;/code&gt; 함수 에서 사용하기 위해 다음 상수가 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b2ba821f4691679e132dc8fb174f36e59b7e4d3" translate="yes" xml:space="preserve">
          <source>The following constants are options for the &lt;em&gt;flags&lt;/em&gt; parameter to the &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. They can be combined using the bitwise OR operator &lt;code&gt;|&lt;/code&gt;. Some of them are not available on all platforms. For descriptions of their availability and use, consult the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/open(2)&quot;&gt;open(2)&lt;/a&gt;&lt;/em&gt; manual page on Unix or &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx&quot;&gt;the MSDN&lt;/a&gt; on Windows.</source>
          <target state="translated">다음 상수는 &lt;em&gt;플래그&lt;/em&gt; 매개 변수가 &lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수에 대한 옵션입니다 . 그들은 비트 OR 연산자를 사용하여 결합 될 수있다 &lt;code&gt;|&lt;/code&gt; . 그들 중 일부는 모든 플랫폼에서 사용 가능하지 않습니다. 사용 가능 여부 및 사용에 대한 설명은 Unix 의 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/open(2)&quot;&gt;open (2)&lt;/a&gt;&lt;/em&gt; 매뉴얼 페이지 또는 Windows &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx&quot;&gt;의 MSDN&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e771abc8230c815b506e59c042235b7c4a6b8e3f" translate="yes" xml:space="preserve">
          <source>The following constants are provided for use with &lt;a href=&quot;#gc.set_debug&quot;&gt;&lt;code&gt;set_debug()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#gc.set_debug&quot;&gt; &lt;code&gt;set_debug()&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기 위해 다음 상수가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb205eca9391cfc2f056a1dbf90721ffe5b16978" translate="yes" xml:space="preserve">
          <source>The following constants are provided in the &lt;a href=&quot;#module-xml.parsers.expat.errors&quot;&gt;&lt;code&gt;xml.parsers.expat.errors&lt;/code&gt;&lt;/a&gt; module. These constants are useful in interpreting some of the attributes of the &lt;code&gt;ExpatError&lt;/code&gt; exception objects raised when an error has occurred. Since for backwards compatibility reasons, the constants&amp;rsquo; value is the error &lt;em&gt;message&lt;/em&gt; and not the numeric error &lt;em&gt;code&lt;/em&gt;, you do this by comparing its &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; attribute with &lt;code&gt;errors.codes[errors.XML_ERROR_&lt;em&gt;CONSTANT_NAME&lt;/em&gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.parsers.expat.errors&quot;&gt; &lt;code&gt;xml.parsers.expat.errors&lt;/code&gt; &lt;/a&gt; 모듈 에는 다음 상수가 제공됩니다 . 이 상수는 오류가 발생했을 때 발생한 &lt;code&gt;ExpatError&lt;/code&gt; 예외 객체 의 일부 속성을 해석하는 데 유용합니다 . 이전 버전과의 호환성을 위해 상수 값은 숫자 오류 &lt;em&gt;코드&lt;/em&gt; 가 아닌 오류 &lt;em&gt;메시지&lt;/em&gt; 이므로 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;errors.codes[errors.XML_ERROR_&lt;em&gt;CONSTANT_NAME&lt;/em&gt;]&lt;/code&gt; &lt;em&gt;CONSTANT_NAME&lt;/em&gt; ] 과 비교하여이를 수행합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5965b72a7c2bdd2aca53ce47e480c9fabe7ebc28" translate="yes" xml:space="preserve">
          <source>The following constitutes a valid IPv4 address:</source>
          <target state="translated">다음은 유효한 IPv4 주소를 구성합니다 :</target>
        </trans-unit>
        <trans-unit id="4e910096327b043ad9d2afa009406429c804c3b3" translate="yes" xml:space="preserve">
          <source>The following constitutes a valid IPv6 address:</source>
          <target state="translated">다음은 유효한 IPv6 주소를 구성합니다 :</target>
        </trans-unit>
        <trans-unit id="b58ccb42402de11fe64b8157bdb31be1accde61b" translate="yes" xml:space="preserve">
          <source>The following convenience methods combine several ioctls, or one ioctl and some simple calculations.</source>
          <target state="translated">다음 편의 방법은 여러 ioctl 또는 하나의 ioctl과 간단한 계산을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="590a13c463d04c026d81a3b0c4e4d9904786e9ba" translate="yes" xml:space="preserve">
          <source>The following data attributes are also available:</source>
          <target state="translated">다음과 같은 데이터 속성도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf053b174bad2ee3cbf65af4b7568faf14c1319" translate="yes" xml:space="preserve">
          <source>The following data items and methods are also supported:</source>
          <target state="translated">다음 데이터 항목 및 방법도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="41a59667c8838599d897ed21cec38179460a4746" translate="yes" xml:space="preserve">
          <source>The following data values are used to support path manipulation operations. These are defined for all platforms.</source>
          <target state="translated">다음 데이터 값은 경로 조작 작업을 지원하는 데 사용됩니다. 이들은 모든 플랫폼에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="040395c6a3618bf3ebfcd5244fdff59b1dda2f42" translate="yes" xml:space="preserve">
          <source>The following decorators and exception implement test skipping and expected failures:</source>
          <target state="translated">다음 데코레이터와 예외는 테스트 건너 뛰기와 예상 실패를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2f67176ca68e7b05b36fe46d06bf8c43a493c901" translate="yes" xml:space="preserve">
          <source>The following dictionary-like methods work on the element attributes.</source>
          <target state="translated">다음과 같은 사전과 유사한 메소드가 요소 속성에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1dc50e2836f9aa579e4b0f696d2f357a755d8b8a" translate="yes" xml:space="preserve">
          <source>The following directives can be embedded in the &lt;em&gt;format&lt;/em&gt; string. They are shown without the optional field width and precision specification, and are replaced by the indicated characters in the &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt; result:</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 문자열 에 다음 지시문을 포함시킬 수 있습니다 . 선택적 필드 너비 및 정밀도 지정없이 표시되며 &lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; 에서 표시된 문자로 대체됩니다. 결과 .</target>
        </trans-unit>
        <trans-unit id="729ba8c5a9bc8860d3a6a359878f9ca2b87f2ec6" translate="yes" xml:space="preserve">
          <source>The following error handlers are only applicable to &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt;:</source>
          <target state="translated">다음 오류 처리기는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 에만 적용됩니다. .</target>
        </trans-unit>
        <trans-unit id="b7712bbe1533b2f2e58112643a78ef6e4d3ffd90" translate="yes" xml:space="preserve">
          <source>The following example achieves the same goal but supports concurrent interactive sessions, by only appending the new history.</source>
          <target state="translated">다음 예는 동일한 목표를 달성하지만 새 기록 만 추가하여 동시 대화식 세션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d4555e1da28cdc40e782dd2248ed5c1ef7fe192f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a practical use of the &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory&quot;&gt;&lt;code&gt;SharedMemory&lt;/code&gt;&lt;/a&gt; class with &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy arrays&lt;/a&gt;, accessing the same &lt;code&gt;numpy.ndarray&lt;/code&gt; from two distinct Python shells:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy 배열&lt;/a&gt; 과 함께 &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory&quot;&gt; &lt;code&gt;SharedMemory&lt;/code&gt; &lt;/a&gt; 클래스를 실제로 사용 하여 두 개의 개별 Python 셸에서 동일한 &lt;code&gt;numpy.ndarray&lt;/code&gt; 에 액세스하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="dd40c9b71705ee03f60f196a9ed9560cf96a2b42" translate="yes" xml:space="preserve">
          <source>The following example demonstrates basic use of a &lt;a href=&quot;#multiprocessing.shared_memory.ShareableList&quot;&gt;&lt;code&gt;ShareableList&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#multiprocessing.shared_memory.ShareableList&quot;&gt; &lt;code&gt;ShareableList&lt;/code&gt; &lt;/a&gt; 인스턴스 의 기본 사용법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="636d7599cc64ae9844d830daf79292dae85c3e9c" translate="yes" xml:space="preserve">
          <source>The following example demonstrates basic use of the &lt;a href=&quot;#urllib.robotparser.RobotFileParser&quot;&gt;&lt;code&gt;RobotFileParser&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#urllib.robotparser.RobotFileParser&quot;&gt; &lt;code&gt;RobotFileParser&lt;/code&gt; &lt;/a&gt; 클래스 의 기본 사용법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ebe02adeb943f0142409336cb1c7fc44d532dbfe" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to use the &lt;a href=&quot;#module-http.cookies&quot;&gt;&lt;code&gt;http.cookies&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#module-http.cookies&quot;&gt; &lt;code&gt;http.cookies&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="184d08b3a3ddcb361e3da601454cd3a57e4847c3" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how to use the &lt;a href=&quot;#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s history reading and writing functions to automatically load and save a history file named &lt;code&gt;.python_history&lt;/code&gt; from the user&amp;rsquo;s home directory. The code below would normally be executed automatically during interactive sessions from the user&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-0&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈의 히스토리 읽기 및 쓰기 기능을 사용하여 사용자의 홈 디렉토리에서 &lt;code&gt;.python_history&lt;/code&gt; 라는 히스토리 파일을 자동으로로드하고 저장하는 방법을 보여줍니다 . 아래 코드는 일반적으로 사용자의 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-0&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; &lt;/a&gt; 에서 대화식 세션 중에 자동으로 실행됩니다. 파일 .</target>
        </trans-unit>
        <trans-unit id="26e6cc83687c3de89725cf30864401269275c60e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates low-level use of &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory&quot;&gt;&lt;code&gt;SharedMemory&lt;/code&gt;&lt;/a&gt; instances:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory&quot;&gt; &lt;code&gt;SharedMemory&lt;/code&gt; &lt;/a&gt; 인스턴스의 저수준 사용을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="db1a4ea3897dc228cbe242e1563fbe5add0d99f9" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the basic mechanisms of a &lt;code&gt;SharedMemoryManager&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 &lt;code&gt;SharedMemoryManager&lt;/code&gt; 의 기본 메커니즘을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ec9664604236f3fb600fa6948a7aacd8381f5a02" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the different ways to print and format the exception and traceback:</source>
          <target state="translated">다음 예제는 예외 및 추적을 인쇄하고 형식을 지정하는 다양한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f11233dbb56229c8fdfe160786d97ca12f552ea0" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of a pool:</source>
          <target state="translated">다음 예제는 풀 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5a60e7418b2653dc05bc9c009baf5076b4b7e356" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this.</source>
          <target state="translated">다음 예제는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3d5ef660ad94efd9bc11f1431691817680e67dd7" translate="yes" xml:space="preserve">
          <source>The following example depicts a potentially more convenient pattern for using &lt;code&gt;SharedMemoryManager&lt;/code&gt; objects via the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement to ensure that all shared memory blocks are released after they are no longer needed:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 를 통해 &lt;code&gt;SharedMemoryManager&lt;/code&gt; 객체를 사용하기위한 잠재적으로 더 편리한 패턴을 보여줍니다. 문을 더 이상 필요하지 않은 모든 공유 메모리 블록이 해제되도록 .</target>
        </trans-unit>
        <trans-unit id="f612736a42a1b32b9815a49d4f5b313138a8a7d1" translate="yes" xml:space="preserve">
          <source>The following example depicts how one, two, or many processes may access the same &lt;a href=&quot;#multiprocessing.shared_memory.ShareableList&quot;&gt;&lt;code&gt;ShareableList&lt;/code&gt;&lt;/a&gt; by supplying the name of the shared memory block behind it:</source>
          <target state="translated">다음 예제는 하나, 둘 또는 많은 프로세스가 뒤에 공유 메모리 블록의 이름을 제공하여 동일한 &lt;a href=&quot;#multiprocessing.shared_memory.ShareableList&quot;&gt; &lt;code&gt;ShareableList&lt;/code&gt; &lt;/a&gt; 에 액세스 할 수있는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0753e44451c3f0b3ee4bcc7279542a665e363cad" translate="yes" xml:space="preserve">
          <source>The following example extends the &lt;a href=&quot;code#code.InteractiveConsole&quot;&gt;&lt;code&gt;code.InteractiveConsole&lt;/code&gt;&lt;/a&gt; class to support history save/restore.</source>
          <target state="translated">다음 예제 는 히스토리 저장 / 복원을 지원 하도록 &lt;a href=&quot;code#code.InteractiveConsole&quot;&gt; &lt;code&gt;code.InteractiveConsole&lt;/code&gt; &lt;/a&gt; 클래스를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="7460e2e46aac0aa0a2a187996f8166def8725bce" translate="yes" xml:space="preserve">
          <source>The following example fetches address information for a hypothetical TCP connection to &lt;code&gt;example.org&lt;/code&gt; on port 80 (results may differ on your system if IPv6 isn&amp;rsquo;t enabled):</source>
          <target state="translated">다음 예제 는 포트 80 에서 &lt;code&gt;example.org&lt;/code&gt; 에 대한 가상 TCP 연결에 대한 주소 정보를 가져옵니다 (IPv6을 사용하지 않으면 시스템마다 결과가 다를 수 있음).</target>
        </trans-unit>
        <trans-unit id="233c2eac45bffe4b40d65d000bc52972a51f3c56" translate="yes" xml:space="preserve">
          <source>The following example illustrates both approaches.</source>
          <target state="translated">다음 예제는 두 가지 접근 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="09c592e8e72f8e8c38f8b29004ae767bc0ce7251" translate="yes" xml:space="preserve">
          <source>The following example illustrates how any arguments besides &lt;em&gt;days&lt;/em&gt;, &lt;em&gt;seconds&lt;/em&gt; and &lt;em&gt;microseconds&lt;/em&gt; are &amp;ldquo;merged&amp;rdquo; and normalized into those three resulting attributes:</source>
          <target state="translated">다음 예는 &lt;em&gt;일&lt;/em&gt; , &lt;em&gt;초&lt;/em&gt; 및 &lt;em&gt;마이크로 &lt;/em&gt;&lt;em&gt;초&lt;/em&gt; 이외의 인수가 어떻게&lt;em&gt;&lt;/em&gt; &quot;합병&quot;되어 세 가지 결과 속성으로 정규화 .</target>
        </trans-unit>
        <trans-unit id="473a235bcb270a8b7bf0781c5cd2588bed3305f5" translate="yes" xml:space="preserve">
          <source>The following example illustrates how coroutines can intercept the cancellation request:</source>
          <target state="translated">다음 예는 코 루틴이 취소 요청을 가로 챌 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5f9f5db6889dd345007e3618d45dca48718d28ec" translate="yes" xml:space="preserve">
          <source>The following example illustrates the most common usage scenario:</source>
          <target state="translated">다음 예는 가장 일반적인 사용 시나리오를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c125f0fb4b508646178c139c8b90c2cd7e59b967" translate="yes" xml:space="preserve">
          <source>The following example included in the &lt;code&gt;Lib/xmlrpc/server.py&lt;/code&gt; module shows a server allowing dotted names and registering a multicall function.</source>
          <target state="translated">&lt;code&gt;Lib/xmlrpc/server.py&lt;/code&gt; 모듈에 포함 된 다음 예제는 점으로 구분 된 이름을 허용하고 다중 호출 기능을 등록하는 서버를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a815f49a1b6e8791aa8e0e5716a50c9445ca6e15" translate="yes" xml:space="preserve">
          <source>The following example reads the resulting pickled data.</source>
          <target state="translated">다음 예는 결과 절인 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e969b44471e10e6ec4169ca5098e2f658d20ed5c" translate="yes" xml:space="preserve">
          <source>The following example records some hostnames and a corresponding title, and then prints out the contents of the database:</source>
          <target state="translated">다음 예제는 일부 호스트 이름과 해당 제목을 기록한 다음 데이터베이스의 내용을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d4f2f9424de8830be3359c54ab8840c0691aa87c" translate="yes" xml:space="preserve">
          <source>The following example shows a custom collation that sorts &amp;ldquo;the wrong way&amp;rdquo;:</source>
          <target state="translated">다음 예제는 &quot;잘못된 방법&quot;으로 정렬하는 사용자 정의 데이터 정렬을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="18fb8bc80d8c8ffdcc48d97894d2b3372d1bb899" translate="yes" xml:space="preserve">
          <source>The following example shows a simple use of &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; to display all the files (excluding directories) in the given &lt;em&gt;path&lt;/em&gt; that don&amp;rsquo;t start with &lt;code&gt;'.'&lt;/code&gt;. The &lt;code&gt;entry.is_file()&lt;/code&gt; call will generally not make an additional system call:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 주어진 &lt;em&gt;경로&lt;/em&gt; 에서 &lt;code&gt;'.'&lt;/code&gt; 시작하지 않는 모든 파일 (디렉토리 제외 ) 을 표시합니다 . . &lt;code&gt;entry.is_file()&lt;/code&gt; 호출은 일반적으로 추가 시스템 호출을하지 않을 것이다 :</target>
        </trans-unit>
        <trans-unit id="974861a110f79768420c0b56aa2cea90629919d4" translate="yes" xml:space="preserve">
          <source>The following example shows how the &lt;a href=&quot;#timeit-command-line-interface&quot;&gt;Command-Line Interface&lt;/a&gt; can be used to compare three different expressions:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#timeit-command-line-interface&quot;&gt;명령 행 인터페이스&lt;/a&gt; 를 사용하여 세 가지 다른 표현식을 비교 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3f24f10a54f470bebf08211935bfc4932125efae" translate="yes" xml:space="preserve">
          <source>The following example shows how the &lt;a href=&quot;#zipapp-command-line-interface&quot;&gt;Command-Line Interface&lt;/a&gt; can be used to create an executable archive from a directory containing Python code. When run, the archive will execute the &lt;code&gt;main&lt;/code&gt; function from the module &lt;code&gt;myapp&lt;/code&gt; in the archive.</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#zipapp-command-line-interface&quot;&gt;명령 행 인터페이스&lt;/a&gt; 를 사용하여 Python 코드가 포함 된 디렉토리에서 실행 가능 아카이브를 작성하는 방법을 보여줍니다 . 실행하면 아카이브가 아카이브의 &lt;code&gt;myapp&lt;/code&gt; 모듈에서 &lt;code&gt;main&lt;/code&gt; 기능을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="5387717e46daa1d1fb09309d90ec9017ac4aeae0" translate="yes" xml:space="preserve">
          <source>The following example shows the difference between &lt;a href=&quot;#argparse.ArgumentParser.parse_known_args&quot;&gt;&lt;code&gt;parse_known_args()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#argparse.ArgumentParser.parse_intermixed_args&quot;&gt;&lt;code&gt;parse_intermixed_args()&lt;/code&gt;&lt;/a&gt;: the former returns &lt;code&gt;['2',
'3']&lt;/code&gt; as unparsed arguments, while the latter collects all the positionals into &lt;code&gt;rest&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;#argparse.ArgumentParser.parse_known_args&quot;&gt; &lt;code&gt;parse_known_args()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#argparse.ArgumentParser.parse_intermixed_args&quot;&gt; &lt;code&gt;parse_intermixed_args()&lt;/code&gt; &lt;/a&gt; 의 차이점을 보여줍니다 . 전자는 구문 분석되지 않은 인수로 &lt;code&gt;['2', '3']&lt;/code&gt; 을 반환 하지만 후자는 모든 위치를 &lt;code&gt;rest&lt;/code&gt; 로 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="09bc38c527d29e07030d23816d50a18331ddce5c" translate="yes" xml:space="preserve">
          <source>The following example shows the different ways to print and format the stack:</source>
          <target state="translated">다음 예제는 스택을 인쇄하고 형식을 지정하는 다양한 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e28ec9102e645592cb8e03af31b2b0218080391d" translate="yes" xml:space="preserve">
          <source>The following example uses an explicitly specified HTTP proxy, overriding environment settings:</source>
          <target state="translated">다음 예제는 명시 적으로 지정된 HTTP 프록시를 사용하여 환경 설정을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="51523232557ef0a616ce3c18bbdfaebe0e359676" translate="yes" xml:space="preserve">
          <source>The following example uses no proxies at all, overriding environment settings:</source>
          <target state="translated">다음 예제는 프록시를 전혀 사용하지 않고 환경 설정을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="36336aa66464423853a80695f8df9ad8c463df59" translate="yes" xml:space="preserve">
          <source>The following example uses the &lt;a href=&quot;os#dir-fd&quot;&gt;dir_fd&lt;/a&gt; parameter of the &lt;a href=&quot;os#os.open&quot;&gt;&lt;code&gt;os.open()&lt;/code&gt;&lt;/a&gt; function to open a file relative to a given directory:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;os#os.open&quot;&gt; &lt;code&gt;os.open()&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;os#dir-fd&quot;&gt;dir_fd&lt;/a&gt; 매개 변수 를 사용합니다. 함수 지정된 디렉토리에 상대적인 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="11a904405145e91622a82db01f34bc213af70e4d" translate="yes" xml:space="preserve">
          <source>The following example uses the &lt;code&gt;POST&lt;/code&gt; method instead. Note that params output from urlencode is encoded to bytes before it is sent to urlopen as data:</source>
          <target state="translated">다음 예제는 &lt;code&gt;POST&lt;/code&gt; 를 사용합니다. 대신 메소드를 사용합니다. urlencode의 출력 매개 변수는 데이터로 urlopen에 전송되기 전에 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="fe0755c15884c78c133b93caaacdb7fc49baca8c" translate="yes" xml:space="preserve">
          <source>The following examples show how to time expressions that contain multiple lines. Here we compare the cost of using &lt;a href=&quot;functions#hasattr&quot;&gt;&lt;code&gt;hasattr()&lt;/code&gt;&lt;/a&gt; vs. &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; to test for missing and present object attributes:</source>
          <target state="translated">다음 예제는 여러 줄을 포함하는 표현식의 시간을 정하는 방법을 보여줍니다. 여기서 우리는 &lt;a href=&quot;functions#hasattr&quot;&gt; &lt;code&gt;hasattr()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; 를 제외 하고 존재하는 객체 속성을 테스트하는 것을 제외하고 비용을 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="07e37073905bea7c4eb74a69c1d1c47655907bae" translate="yes" xml:space="preserve">
          <source>The following exception classes are defined in the &lt;a href=&quot;#module-email.errors&quot;&gt;&lt;code&gt;email.errors&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-email.errors&quot;&gt; &lt;code&gt;email.errors&lt;/code&gt; &lt;/a&gt; 모듈 에는 다음과 같은 예외 클래스가 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4a4983aecf7afdeeb3354953e0b0515cf7a965b" translate="yes" xml:space="preserve">
          <source>The following exception classes are defined in the &lt;a href=&quot;#module-mailbox&quot;&gt;&lt;code&gt;mailbox&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-mailbox&quot;&gt; &lt;code&gt;mailbox&lt;/code&gt; &lt;/a&gt; 모듈 에는 다음과 같은 예외 클래스가 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56731f15f7a9d03e09bf280a271931a72d17e445" translate="yes" xml:space="preserve">
          <source>The following exception is also defined:</source>
          <target state="translated">다음 예외도 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="da86b38f78af4156bc5b283d1b568dd9bea03abc" translate="yes" xml:space="preserve">
          <source>The following exception is defined:</source>
          <target state="translated">다음 예외가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8219e18afa673e0330df877fcabe377a8af796cc" translate="yes" xml:space="preserve">
          <source>The following exceptions are kept for compatibility with previous versions; starting from Python 3.3, they are aliases of &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 다음 예외가 유지됩니다. Python 3.3부터는 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="d9625c47947897978d56fe5ccc3cc2b12128ad44" translate="yes" xml:space="preserve">
          <source>The following exceptions are raised as appropriate:</source>
          <target state="translated">적절하게 다음과 같은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fc99860efaf397b22c0734ca264d2f5c8cebed9" translate="yes" xml:space="preserve">
          <source>The following exceptions are raised by &lt;a href=&quot;#module-urllib.error&quot;&gt;&lt;code&gt;urllib.error&lt;/code&gt;&lt;/a&gt; as appropriate:</source>
          <target state="translated">&lt;a href=&quot;#module-urllib.error&quot;&gt; &lt;code&gt;urllib.error&lt;/code&gt; 에&lt;/a&gt; 의해 다음과 같은 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="919505ce9e2b1eb1bd2317ab625de8404a8f9a85" translate="yes" xml:space="preserve">
          <source>The following exceptions are subclasses of &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;, they get raised depending on the system error code.</source>
          <target state="translated">다음 예외는 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 서브 클래스이며 시스템 오류 코드에 따라 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3234c73e5179ec0bf51b9851151a512eff6798cd" translate="yes" xml:space="preserve">
          <source>The following exceptions are the exceptions that are usually raised.</source>
          <target state="translated">다음 예외는 일반적으로 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="6cac3069b88d1e924825a076fc095f0bc160c839" translate="yes" xml:space="preserve">
          <source>The following exceptions are used as warning categories; see the &lt;a href=&quot;warnings#warning-categories&quot;&gt;Warning Categories&lt;/a&gt; documentation for more details.</source>
          <target state="translated">다음 예외는 경고 범주로 사용됩니다. 자세한 내용은 &lt;a href=&quot;warnings#warning-categories&quot;&gt;경고 범주&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf34ea7d31725235d03d88d5679992bde7777bfe" translate="yes" xml:space="preserve">
          <source>The following exceptions are used mostly as base classes for other exceptions.</source>
          <target state="translated">다음 예외는 주로 다른 예외의 기본 클래스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a03745ebccf67a5017fa4eb4e8afc477e8486f4" translate="yes" xml:space="preserve">
          <source>The following exit codes are defined and can be used with &lt;a href=&quot;#os._exit&quot;&gt;&lt;code&gt;_exit()&lt;/code&gt;&lt;/a&gt;, although they are not required. These are typically used for system programs written in Python, such as a mail server&amp;rsquo;s external command delivery program.</source>
          <target state="translated">다음과 같은 종료 코드가 정의되어 있으며 &lt;a href=&quot;#os._exit&quot;&gt; &lt;code&gt;_exit()&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 있지만 필수는 아니지만 . 일반적으로 메일 서버의 외부 명령 전달 프로그램과 같이 Python으로 작성된 시스템 프로그램에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07a35a3673af42652ef6cc9a9b0cd0d2eb1a9b0f" translate="yes" xml:space="preserve">
          <source>The following flags can also be used in the &lt;em&gt;mode&lt;/em&gt; argument of &lt;a href=&quot;os#os.chmod&quot;&gt;&lt;code&gt;os.chmod()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;os#os.chmod&quot;&gt; &lt;code&gt;os.chmod()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;mode&lt;/em&gt; 인수 에서 다음 플래그를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50fdab17f4c511a2bd981d9f16416d6cbc1642e0" translate="yes" xml:space="preserve">
          <source>The following flags can be used in the &lt;em&gt;flags&lt;/em&gt; argument of &lt;a href=&quot;os#os.chflags&quot;&gt;&lt;code&gt;os.chflags()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;os#os.chflags&quot;&gt; &lt;code&gt;os.chflags()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;flags&lt;/em&gt; 인수에 다음 플래그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d2b677018a5fc91e1c52ff16415ab440b896d28" translate="yes" xml:space="preserve">
          <source>The following format &lt;code&gt;'llh0l'&lt;/code&gt; specifies two pad bytes at the end, assuming longs are aligned on 4-byte boundaries:</source>
          <target state="translated">다음 형식 &lt;code&gt;'llh0l'&lt;/code&gt; 은 long이 4 바이트 경계에 정렬되어 있다고 가정 할 때 끝에 2 개의 패드 바이트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2dd6a0fd41fecfe4d17317d4204e40f9818a4207" translate="yes" xml:space="preserve">
          <source>The following function has been added as a useful debugging tool. It should &lt;em&gt;not&lt;/em&gt; be considered part of the supported public interface for the package.</source>
          <target state="translated">유용한 디버깅 도구로 다음 기능이 추가되었습니다. 패키지에 대해 지원되는 공용 인터페이스의 일부로 간주 해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="da305af26f9cbcbeb6c5f275e457fad8bb285a85" translate="yes" xml:space="preserve">
          <source>The following function is the primary interface of this module:</source>
          <target state="translated">다음 기능은이 모듈의 기본 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="ff45ffb8d9411a36a16d6d809eaa7c1a78d7dbc9" translate="yes" xml:space="preserve">
          <source>The following function sends the list of file descriptors &lt;em&gt;fds&lt;/em&gt; over an &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; socket, on systems which support the &lt;code&gt;SCM_RIGHTS&lt;/code&gt; mechanism. See also &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 함수는 &lt;code&gt;SCM_RIGHTS&lt;/code&gt; 메커니즘 을 지원하는 시스템 에서 &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 소켓을 통해 파일 설명자 &lt;em&gt;fds&lt;/em&gt; 목록을 보냅니다 . &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e3d6b50f1cb6afc139200a4d017ad6f95613306" translate="yes" xml:space="preserve">
          <source>The following function takes either a single-character string or integer value; it returns a string.</source>
          <target state="translated">다음 함수는 단일 문자 문자열 또는 정수 값을 사용합니다. 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13cf5d0144d472efbe8d37582b67d12dc02f8fbc" translate="yes" xml:space="preserve">
          <source>The following functions all create &lt;a href=&quot;#socket-objects&quot;&gt;socket objects&lt;/a&gt;.</source>
          <target state="translated">다음 함수는 모두 &lt;a href=&quot;#socket-objects&quot;&gt;소켓 객체를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a90899ab2a1b3723f7dc7f39dfe8546f510b2db4" translate="yes" xml:space="preserve">
          <source>The following functions and classes are ported from the Python 2 module &lt;code&gt;urllib&lt;/code&gt; (as opposed to &lt;code&gt;urllib2&lt;/code&gt;). They might become deprecated at some point in the future.</source>
          <target state="translated">다음 함수와 클래스는 Python 2 모듈 &lt;code&gt;urllib&lt;/code&gt; 에서 포팅됩니다 ( &lt;code&gt;urllib2&lt;/code&gt; 와 반대 ). 나중에 언젠가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="translated">다음과 같은 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50b9a1d0acd56c19cd33c52597cd720ec528f31a" translate="yes" xml:space="preserve">
          <source>The following functions are defined:</source>
          <target state="translated">다음과 같은 기능이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b90dccda72ce0f29d283b6adf62da389efc25651" translate="yes" xml:space="preserve">
          <source>The following functions are deprecated:</source>
          <target state="translated">다음 기능은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc5bf00bc0ec88b71236977c192f4ac766952ac9" translate="yes" xml:space="preserve">
          <source>The following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.</source>
          <target state="translated">이 모듈에서 제공하는 기능은 다음과 같습니다. 달리 명시되지 않는 한 모든 반환 값은 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="translated">다음과 같은 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="27440c6f6aa8e07ded29a2c00b0e5f21f2502954" translate="yes" xml:space="preserve">
          <source>The following functions can be used to convert from the native rectangular coordinates to polar coordinates and back.</source>
          <target state="translated">다음 함수를 사용하여 기본 직사각형 좌표에서 극좌표로 또는 그 반대로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7138bd79e2aa0cd1f1706edff9a21ee42719a2b2" translate="yes" xml:space="preserve">
          <source>The following functions can be used to get and set the policy for the current process:</source>
          <target state="translated">현재 프로세스에 대한 정책을 가져오고 설정하는 데 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1722423e811c5f2d1e9190b66ddd0937f6d483ea" translate="yes" xml:space="preserve">
          <source>The following functions configure the logging module. They are located in the &lt;a href=&quot;#module-logging.config&quot;&gt;&lt;code&gt;logging.config&lt;/code&gt;&lt;/a&gt; module. Their use is optional &amp;mdash; you can configure the logging module using these functions or by making calls to the main API (defined in &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; itself) and defining handlers which are declared either in &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;logging.handlers#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 기능은 로깅 모듈을 구성합니다. 그것들은 &lt;a href=&quot;#module-logging.config&quot;&gt; &lt;code&gt;logging.config&lt;/code&gt; &lt;/a&gt; 모듈에 있습니다. 사용은 선택 사항입니다. 이러한 기능을 사용하거나 기본 API ( &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 자체에 정의 됨)를 호출하고 &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;logging.handlers#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; &lt;/a&gt; 에 선언 된 핸들러를 정의 하여 로깅 모듈을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="298eed0d1e6e397ae4710411294cadbb3b684a71" translate="yes" xml:space="preserve">
          <source>The following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution&amp;rsquo;s equation, as used in common mathematical practice; most of these equations can be found in any statistics text.</source>
          <target state="translated">다음 함수는 특정 실수 분포를 생성합니다. 함수 매개 변수는 일반적인 수학적 관행에 사용되는 분포 방정식에서 해당 변수의 이름을 따서 명명됩니다. 이러한 방정식의 대부분은 모든 통계 텍스트에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d51dc40e66b7a6cd9fea075650c420c4c2f1ce7" translate="yes" xml:space="preserve">
          <source>The following functions operate on a global history list:</source>
          <target state="translated">다음 기능은 글로벌 히스토리 목록에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7759694e086b90baaa66ee395073e6f07cb02b9f" translate="yes" xml:space="preserve">
          <source>The following functions operate on a history file:</source>
          <target state="translated">다음 기능은 히스토리 파일에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="64789b1037502a079a852b4b2b8db153ea6b7a62" translate="yes" xml:space="preserve">
          <source>The following functions operate on the line buffer:</source>
          <target state="translated">다음 기능은 라인 버퍼에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="43da4d98b6c5375698601c186a476296083ea958" translate="yes" xml:space="preserve">
          <source>The following functions relate to implementing a custom word completion function. This is typically operated by the Tab key, and can suggest and automatically complete a word being typed. By default, Readline is set up to be used by &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt;&lt;code&gt;rlcompleter&lt;/code&gt;&lt;/a&gt; to complete Python identifiers for the interactive interpreter. If the &lt;a href=&quot;#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module is to be used with a custom completer, a different set of word delimiters should be set.</source>
          <target state="translated">다음 기능은 사용자 정의 단어 완성 기능 구현과 관련이 있습니다. 이것은 일반적으로 Tab 키로 작동하며 입력되는 단어를 제안하고 자동으로 완성 할 수 있습니다. 기본적으로 Readline은 &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt; &lt;code&gt;rlcompleter&lt;/code&gt; &lt;/a&gt; 에서 대화식 인터프리터의 Python 식별자를 완성 하는 데 사용되도록 설정되어 있습니다 . 는 IF &lt;a href=&quot;#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈은 사용자 정의 completer에 사용되는 단어 구분 기호의 다른 세트를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="92323350568081e68e83ac2a59f8aae14a2f26c5" translate="yes" xml:space="preserve">
          <source>The following functions relate to the init file and user configuration:</source>
          <target state="translated">다음 기능은 init 파일 및 사용자 구성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fcb3b8d729958b242cb8efd022b8f92cc756aa2" translate="yes" xml:space="preserve">
          <source>The following functions take a process status code as returned by &lt;a href=&quot;#os.system&quot;&gt;&lt;code&gt;system()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#os.waitpid&quot;&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/a&gt; as a parameter. They may be used to determine the disposition of a process.</source>
          <target state="translated">다음 함수는 &lt;a href=&quot;#os.system&quot;&gt; &lt;code&gt;system()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.waitpid&quot;&gt; &lt;code&gt;waitpid()&lt;/code&gt; &lt;/a&gt; 가 매개 변수 로 리턴 한대로 프로세스 상태 코드를 사용 합니다. 프로세스의 처리를 결정하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beb00315a2f748529b36d585bd95fdcf3d54dd82" translate="yes" xml:space="preserve">
          <source>The following functions use the global state created by &lt;a href=&quot;#fileinput.input&quot;&gt;&lt;code&gt;fileinput.input()&lt;/code&gt;&lt;/a&gt;; if there is no active state, &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">다음 함수는 &lt;a href=&quot;#fileinput.input&quot;&gt; &lt;code&gt;fileinput.input()&lt;/code&gt; &lt;/a&gt; 의해 작성된 전역 상태를 사용합니다 . 활성 상태가 없으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="34f703b1e0e9c15c0897a1841ee395a9ceb30302" translate="yes" xml:space="preserve">
          <source>The following image types are recognized, as listed below with the return value from &lt;a href=&quot;#imghdr.what&quot;&gt;&lt;code&gt;what()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#imghdr.what&quot;&gt; &lt;code&gt;what()&lt;/code&gt; &lt;/a&gt; 의 반환 값과 함께 아래에 나열된대로 다음 이미지 유형이 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="280be161783a14c0920bb19c3ae869ff10b8f196" translate="yes" xml:space="preserve">
          <source>The following instances of &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicy&lt;/code&gt;&lt;/a&gt; provide defaults suitable for specific application domains. Note that in the future the behavior of these instances (in particular the &lt;code&gt;HTTP&lt;/code&gt; instance) may be adjusted to conform even more closely to the RFCs relevant to their domains.</source>
          <target state="translated">다음 &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicy&lt;/code&gt; &lt;/a&gt; 인스턴스는 특정 응용 프로그램 도메인에 적합한 기본값을 제공합니다. 앞으로 이러한 인스턴스 (특히 &lt;code&gt;HTTP&lt;/code&gt; 인스턴스) 의 동작은 도메인과 관련된 RFC에 훨씬 더 가깝게 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36786723f378fafa3d1898954065c6c261f994dc" translate="yes" xml:space="preserve">
          <source>The following interfaces have no implementation in &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 인터페이스는 &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 에서 구현되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="a2d16d61637d3640bacadcaa73df4c60909570ae" translate="yes" xml:space="preserve">
          <source>The following is a list of all the format codes that the 1989 C standard requires, and these work on all platforms with a standard C implementation.</source>
          <target state="translated">다음은 1989 C 표준에 필요한 모든 형식 코드 목록이며 표준 C 구현이있는 모든 플랫폼에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9bbcfdfa416ee0a8a6d18043dc1c0fc4e3673e2d" translate="yes" xml:space="preserve">
          <source>The following is an example of using magic methods with the ordinary Mock class:</source>
          <target state="translated">다음은 일반적인 Mock 클래스에서 매직 메소드를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="f2c5d34f2d1e1f79cbe6149cbd185555a4725b75" translate="yes" xml:space="preserve">
          <source>The following item options may be specified for items in the insert and item widget commands.</source>
          <target state="translated">삽입 및 항목 위젯 명령의 항목에 대해 다음 항목 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29a9adf004c9f7ac2d7a89f0143bc9acb153b58" translate="yes" xml:space="preserve">
          <source>The following keyword arguments are supported.</source>
          <target state="translated">다음 키워드 인수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5be2e474d40be9b697f7ce09f1abb8f435b1c3b4" translate="yes" xml:space="preserve">
          <source>The following low-level functions can be used to get, set, or create an event loop:</source>
          <target state="translated">다음과 같은 저수준 함수를 사용하여 이벤트 루프를 가져 오거나 설정하거나 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61e7817f137704c9eeac3b5ade762440604c20d" translate="yes" xml:space="preserve">
          <source>The following method is also provided:</source>
          <target state="translated">다음과 같은 방법도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3c4bd14872b021d62effe80ccc7b6722ce458bfd" translate="yes" xml:space="preserve">
          <source>The following methods MUST be overridden in a subclass:</source>
          <target state="translated">서브 클래스에서 다음 메소드를 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9a3fab840f80e792969e1c6d30487fdf15285a" translate="yes" xml:space="preserve">
          <source>The following methods are also available:</source>
          <target state="translated">다음과 같은 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="translated">다음과 같은 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da18558c268f3b787fcf73b6e36956c31ab86fc" translate="yes" xml:space="preserve">
          <source>The following methods are called when data or markup elements are encountered and they are meant to be overridden in a subclass. The base class implementations do nothing (except for &lt;a href=&quot;#html.parser.HTMLParser.handle_startendtag&quot;&gt;&lt;code&gt;handle_startendtag()&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">다음 메소드는 데이터 또는 마크 업 요소가 발견 될 때 호출되며 서브 클래스에서 대체됩니다. 기본 클래스 구현은 아무것도 수행하지 않습니다 ( &lt;a href=&quot;#html.parser.HTMLParser.handle_startendtag&quot;&gt; &lt;code&gt;handle_startendtag()&lt;/code&gt; &lt;/a&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="e4de795b18dd4b4fd7bcd1a2167543959de3c0cf" translate="yes" xml:space="preserve">
          <source>The following methods are overridden from the base class implementation:</source>
          <target state="translated">기본 클래스 구현에서 다음 메소드가 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="126480cdf2831b1516aa5168ce4b513b07ee9449" translate="yes" xml:space="preserve">
          <source>The following methods are public:</source>
          <target state="translated">다음 방법은 공개입니다.</target>
        </trans-unit>
        <trans-unit id="487dc7006143997609be279701723a8c2465f409" translate="yes" xml:space="preserve">
          <source>The following methods describe &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s public interface, and so all may be overridden in subclasses. It also defines several public attributes that can be used by clients to inspect the parsed request.</source>
          <target state="translated">다음 메소드는 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 의 공용 인터페이스를 설명 하므로 서브 클래스에서 모두 재정의 될 수 있습니다. 또한 클라이언트가 구문 분석 된 요청을 검사하는 데 사용할 수있는 몇 가지 공용 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="63d90593d14145bbb48645d676dbce7a50e1b653" translate="yes" xml:space="preserve">
          <source>The following methods each map to exactly one &lt;code&gt;ioctl()&lt;/code&gt; system call. The correspondence is obvious: for example, &lt;code&gt;setfmt()&lt;/code&gt; corresponds to the &lt;code&gt;SNDCTL_DSP_SETFMT&lt;/code&gt; ioctl, and &lt;code&gt;sync()&lt;/code&gt; to &lt;code&gt;SNDCTL_DSP_SYNC&lt;/code&gt; (this can be useful when consulting the OSS documentation). If the underlying &lt;code&gt;ioctl()&lt;/code&gt; fails, they all raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 메소드는 각각 정확히 하나의 &lt;code&gt;ioctl()&lt;/code&gt; 시스템 호출에 맵핑됩니다 . 예를 들어 &lt;code&gt;setfmt()&lt;/code&gt; 는 &lt;code&gt;SNDCTL_DSP_SETFMT&lt;/code&gt; ioctl에 해당하고 &lt;code&gt;sync()&lt;/code&gt; 는 &lt;code&gt;SNDCTL_DSP_SYNC&lt;/code&gt; 에 해당합니다 (OSS 설명서를 참조 할 때 유용 할 수 있음). 기본 &lt;code&gt;ioctl()&lt;/code&gt; 이 실패하면 모두 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="19638ef10a7443439dd157547b9556e83f68ed56" translate="yes" xml:space="preserve">
          <source>The following methods exist but are &lt;em&gt;not&lt;/em&gt; supported as they are either in use by mock, can&amp;rsquo;t be set dynamically, or can cause problems:</source>
          <target state="translated">다음과 같은 방법이 존재하지만되어 &lt;em&gt;있지&lt;/em&gt; 그들이 모의에서 사용 중입니다으로 지원, 동적으로 설정할 수 없습니다, 또는 문제가 발생할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5ba539dea251194908a930ae6d4de0259644b7c9" translate="yes" xml:space="preserve">
          <source>The following methods implement a mapping-like interface for accessing the message&amp;rsquo;s &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; headers. Note that there are some semantic differences between these methods and a normal mapping (i.e. dictionary) interface. For example, in a dictionary there are no duplicate keys, but here there may be duplicate message headers. Also, in dictionaries there is no guaranteed order to the keys returned by &lt;a href=&quot;#email.message.Message.keys&quot;&gt;&lt;code&gt;keys()&lt;/code&gt;&lt;/a&gt;, but in a &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; object, headers are always returned in the order they appeared in the original message, or were added to the message later. Any header deleted and then re-added are always appended to the end of the header list.</source>
          <target state="translated">다음 메소드는 메시지의 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 헤더 에 액세스하기위한 맵핑 유사 인터페이스를 구현합니다 . 이 메소드들과 노멀 매핑 (즉, 사전) 인터페이스 사이에는 의미상의 차이가 있습니다. 예를 들어, 사전에는 중복 키가 없지만 여기에는 중복 메시지 헤더가있을 수 있습니다. 또한 사전에서는 &lt;a href=&quot;#email.message.Message.keys&quot;&gt; &lt;code&gt;keys()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 키 의 순서가 보장되지 않지만 &lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체에서 헤더는 항상 원래 메시지에 나타난 순서대로 반환되거나 나중에 메시지에 추가됩니다. 삭제 한 다음 다시 추가 한 헤더는 항상 헤더 목록의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2bcb89a371cdba7f9ba387d3a82557337285cf40" translate="yes" xml:space="preserve">
          <source>The following methods implement the mapping-like interface for accessing the message&amp;rsquo;s headers. Note that there are some semantic differences between these methods and a normal mapping (i.e. dictionary) interface. For example, in a dictionary there are no duplicate keys, but here there may be duplicate message headers. Also, in dictionaries there is no guaranteed order to the keys returned by &lt;a href=&quot;#email.message.EmailMessage.keys&quot;&gt;&lt;code&gt;keys()&lt;/code&gt;&lt;/a&gt;, but in an &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object, headers are always returned in the order they appeared in the original message, or in which they were added to the message later. Any header deleted and then re-added is always appended to the end of the header list.</source>
          <target state="translated">다음 메소드는 메시지 헤더에 액세스하기위한 맵핑 유사 인터페이스를 구현합니다. 이 메소드들과 노멀 매핑 (즉, 사전) 인터페이스 사이에는 의미상의 차이가 있습니다. 예를 들어, 사전에는 중복 키가 없지만 여기에는 중복 메시지 헤더가있을 수 있습니다. 또한 사전에서는 &lt;a href=&quot;#email.message.EmailMessage.keys&quot;&gt; &lt;code&gt;keys()&lt;/code&gt; &lt;/a&gt; 반환 한 키 의 순서가 보장되지 않지만 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 객체에서는 헤더가 항상 원래 메시지에 나타난 순서대로 또는 나중에 메시지에 추가 된 순서대로 반환됩니다. 삭제 한 후 다시 추가 한 헤더는 항상 헤더 목록의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a03fef5945c0da211457269f86e4849454bed953" translate="yes" xml:space="preserve">
          <source>The following methods of &lt;a href=&quot;#bdb.Bdb&quot;&gt;&lt;code&gt;Bdb&lt;/code&gt;&lt;/a&gt; normally don&amp;rsquo;t need to be overridden.</source>
          <target state="translated">일반적으로 다음 &lt;a href=&quot;#bdb.Bdb&quot;&gt; &lt;code&gt;Bdb&lt;/code&gt; &lt;/a&gt; 방법은 재정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="37c544609e6c6a5d1717ba9961dd7becb0ee90d3" translate="yes" xml:space="preserve">
          <source>The following methods of the &lt;a href=&quot;#unittest.TestResult&quot;&gt;&lt;code&gt;TestResult&lt;/code&gt;&lt;/a&gt; class are used to maintain the internal data structures, and may be extended in subclasses to support additional reporting requirements. This is particularly useful in building tools which support interactive reporting while tests are being run.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestResult&quot;&gt; &lt;code&gt;TestResult&lt;/code&gt; &lt;/a&gt; 클래스 의 다음 메소드는 내부 데이터 구조를 유지 보수하는 데 사용되며 추가보고 요구 사항을 지원하기 위해 서브 클래스로 확장 될 수 있습니다. 이는 테스트가 실행되는 동안 대화식보고를 지원하는 도구를 빌드 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6fc4c0cac153b54cd58567b6bf639a9e7367be81" translate="yes" xml:space="preserve">
          <source>The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do &lt;em&gt;not&lt;/em&gt; operate in place, and instead produce new objects.</source>
          <target state="translated">바이트 및 바이트 배열 객체에 대한 다음 방법은 ASCII 호환 이진 형식을 사용한다고 가정하므로 임의의 이진 데이터에 적용해서는 안됩니다. 이 섹션의 모든 바이트 배열 방법 은 제자리에서 작동 하지 &lt;em&gt;않고&lt;/em&gt; 대신 새 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="84d88c6a5fdc3d75ff22b7df602b0699287c51d7" translate="yes" xml:space="preserve">
          <source>The following methods on bytes and bytearray objects can be used with arbitrary binary data.</source>
          <target state="translated">바이트 및 바이트 배열 객체에 대한 다음 방법은 임의의 이진 데이터와 함께 사용할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
