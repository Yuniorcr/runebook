<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="9d6f7b60f53b56af7a399af55e0827b6d4cfd445" translate="yes" xml:space="preserve">
          <source>On Windows, the directories &lt;code&gt;C:\TEMP&lt;/code&gt;, &lt;code&gt;C:\TMP&lt;/code&gt;, &lt;code&gt;\TEMP&lt;/code&gt;, and &lt;code&gt;\TMP&lt;/code&gt;, in that order.</source>
          <target state="translated">Windows에서 &lt;code&gt;C:\TEMP&lt;/code&gt; , &lt;code&gt;C:\TMP&lt;/code&gt; , &lt;code&gt;\TEMP&lt;/code&gt; 및 &lt;code&gt;\TMP&lt;/code&gt; 디렉토리 는 순서대로 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e0eb52cbdbb1158e147637462f36af394569b1" translate="yes" xml:space="preserve">
          <source>On Windows, the drive letter is not reset when an absolute path component (e.g., &lt;code&gt;r'\foo'&lt;/code&gt;) is encountered. If a component contains a drive letter, all previous components are thrown away and the drive letter is reset. Note that since there is a current directory for each drive, &lt;code&gt;os.path.join(&quot;c:&quot;, &quot;foo&quot;)&lt;/code&gt; represents a path relative to the current directory on drive &lt;code&gt;C:&lt;/code&gt; (&lt;code&gt;c:foo&lt;/code&gt;), not &lt;code&gt;c:\foo&lt;/code&gt;.</source>
          <target state="translated">Windows에서 절대 경로 구성 요소 (예 : &lt;code&gt;r'\foo'&lt;/code&gt; )가 발생 하면 드라이브 문자가 재설정되지 않습니다 . 구성 요소에 드라이브 문자가 포함되어 있으면 이전의 모든 구성 요소가 버리고 드라이브 문자가 재설정됩니다. 각 드라이브에 대한 현재 디렉토리가 있으므로 &lt;code&gt;os.path.join(&quot;c:&quot;, &quot;foo&quot;)&lt;/code&gt; 는 &lt;code&gt;c:\foo&lt;/code&gt; 아니라 &lt;code&gt;C:&lt;/code&gt; 드라이브의 현재 디렉토리에 상대적인 경로를 나타냅니다 ( &lt;code&gt;c:foo&lt;/code&gt; ) . .</target>
        </trans-unit>
        <trans-unit id="c3df504605e52e9837e62d0e690a03b408496ac1" translate="yes" xml:space="preserve">
          <source>On Windows, the encoding may be &lt;code&gt;'utf-8'&lt;/code&gt; or &lt;code&gt;'mbcs'&lt;/code&gt;, depending on user configuration.</source>
          <target state="translated">Windows 에서 사용자 구성에 따라 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 또는 &lt;code&gt;'mbcs'&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f58003eb530e09c101d14120e7527b154308b9" translate="yes" xml:space="preserve">
          <source>On Windows, the file-like object created by &lt;a href=&quot;#socket.socket.makefile&quot;&gt;&lt;code&gt;makefile()&lt;/code&gt;&lt;/a&gt; cannot be used where a file object with a file descriptor is expected, such as the stream arguments of &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서, &lt;a href=&quot;#socket.socket.makefile&quot;&gt; &lt;code&gt;makefile()&lt;/code&gt; &lt;/a&gt; 작성된 파일 유사 오브젝트 는 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen()&lt;/code&gt; &lt;/a&gt; 의 스트림 인수와 같이 파일 디스크립터가있는 파일 오브젝트가 필요한 위치에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0d2f852baab8a06d37a6a99be399f20b228e0595" translate="yes" xml:space="preserve">
          <source>On Windows, the following constants are available for comparing against the &lt;code&gt;st_reparse_tag&lt;/code&gt; member returned by &lt;a href=&quot;os#os.lstat&quot;&gt;&lt;code&gt;os.lstat()&lt;/code&gt;&lt;/a&gt;. These are well-known constants, but are not an exhaustive list.</source>
          <target state="translated">Windows에서 다음 상수는에 대해 비교 가능한 &lt;code&gt;st_reparse_tag&lt;/code&gt; 에 의해 반환 된 멤버 &lt;a href=&quot;os#os.lstat&quot;&gt; &lt;code&gt;os.lstat()&lt;/code&gt; &lt;/a&gt; . 이것들은 잘 알려진 상수이지만 완전한 목록은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="548033f4f74edd90159967683a7e43861d78a74e" translate="yes" xml:space="preserve">
          <source>On Windows, the following file attribute constants are available for use when testing bits in the &lt;code&gt;st_file_attributes&lt;/code&gt; member returned by &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;Windows API documentation&lt;/a&gt; for more detail on the meaning of these constants.</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 리턴 한 &lt;code&gt;st_file_attributes&lt;/code&gt; 멤버 에서 비트를 테스트 할 때 다음 파일 속성 상수를 사용할 수 있습니다 . 이러한 상수의 의미에 대한 자세한 내용은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;Windows API 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c96823b6f593e3c93fa502eb83c4b5bb1b5a0af" translate="yes" xml:space="preserve">
          <source>On Windows, the return value is that returned by the system shell after running &lt;em&gt;command&lt;/em&gt;. The shell is given by the Windows environment variable &lt;code id=&quot;index-35&quot;&gt;COMSPEC&lt;/code&gt;: it is usually &lt;strong&gt;cmd.exe&lt;/strong&gt;, which returns the exit status of the command run; on systems using a non-native shell, consult your shell documentation.</source>
          <target state="translated">Windows에서 리턴 값은 &lt;em&gt;command&lt;/em&gt; 를 실행 한 후 시스템 쉘이 리턴 한 값입니다 . 셸은 Windows 환경 변수 &lt;code id=&quot;index-35&quot;&gt;COMSPEC&lt;/code&gt; 에 의해 제공됩니다. 일반적으로 &lt;strong&gt;cmd.exe&lt;/strong&gt; 이며 명령 실행의 종료 상태를 반환합니다. 비원시 쉘을 사용하는 시스템에서는 쉘 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1b0007f46b6c5205cec2ccc2367335b248f69b" translate="yes" xml:space="preserve">
          <source>On Windows, therefore, it is often preferable to create an executable from the zipapp. This is relatively easy, although it does require a C compiler. The basic approach relies on the fact that zipfiles can have arbitrary data prepended, and Windows exe files can have arbitrary data appended. So by creating a suitable launcher and tacking the &lt;code&gt;.pyz&lt;/code&gt; file onto the end of it, you end up with a single-file executable that runs your application.</source>
          <target state="translated">따라서 Windows에서는 종종 zipapp에서 실행 파일을 작성하는 것이 좋습니다. C 컴파일러가 필요하지만 비교적 쉽습니다. 기본 접근 방식은 zip 파일에 임의의 데이터가 추가되고 Windows exe 파일에 임의의 데이터가 추가 될 수 있다는 사실에 의존합니다. 따라서 적절한 런처를 만들고 &lt;code&gt;.pyz&lt;/code&gt; 파일을 그 끝에 붙임 으로써 응용 프로그램을 실행하는 단일 파일 실행 파일 이 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="37dc40ac402c8823d0b71dfd8517ae8bdca2012b" translate="yes" xml:space="preserve">
          <source>On Windows, this is an OS handle usable with the &lt;code&gt;WaitForSingleObject&lt;/code&gt; and &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; family of API calls. On Unix, this is a file descriptor usable with primitives from the &lt;a href=&quot;select#module-select&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Windows에서 이는 API 호출 의 &lt;code&gt;WaitForSingleObject&lt;/code&gt; 및 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; 제품군에서 사용할 수있는 OS 핸들 입니다. 유닉스에서 이것은 &lt;a href=&quot;select#module-select&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 모듈의 프리미티브와 함께 사용할 수있는 파일 디스크립터 입니다.</target>
        </trans-unit>
        <trans-unit id="97e0c647fa3b8fd69df5ae6d02b841041c7dc102" translate="yes" xml:space="preserve">
          <source>On Windows, when a foreign function call raises a system exception (for example, due to an access violation), it will be captured and replaced with a suitable Python exception. Further, an auditing event &lt;code&gt;ctypes.seh_exception&lt;/code&gt; with argument &lt;code&gt;code&lt;/code&gt; will be raised, allowing an audit hook to replace the exception with its own.</source>
          <target state="translated">Windows에서 외부 함수 호출로 인해 시스템 예외 (예 : 액세스 위반으로 인해)가 발생하면이를 캡처하여 적합한 Python 예외로 대체합니다. 또한 인수 &lt;code&gt;code&lt;/code&gt; 와 함께 감사 이벤트 &lt;code&gt;ctypes.seh_exception&lt;/code&gt; 이 발생하여 감사 후크가 예외를 자체로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10b5f3f739606c767f0a53174c343344eb123b63" translate="yes" xml:space="preserve">
          <source>On Windows, when duplicating a standard stream (0: stdin, 1: stdout, 2: stderr), the new file descriptor is &lt;a href=&quot;#fd-inheritance&quot;&gt;inheritable&lt;/a&gt;.</source>
          <target state="translated">Windows에서 표준 스트림 (0 : stdin, 1 : stdout, 2 : stderr)을 복제 할 때 새 파일 디스크립터는 &lt;a href=&quot;#fd-inheritance&quot;&gt;상속 가능&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fb6115c799330ee3de4f9e4a92324f487e44ec5f" translate="yes" xml:space="preserve">
          <source>On Windows: Wait for completion of a process given by process handle &lt;em&gt;pid&lt;/em&gt;, and return a tuple containing &lt;em&gt;pid&lt;/em&gt;, and its exit status shifted left by 8 bits (shifting makes cross-platform use of the function easier). A &lt;em&gt;pid&lt;/em&gt; less than or equal to &lt;code&gt;0&lt;/code&gt; has no special meaning on Windows, and raises an exception. The value of integer &lt;em&gt;options&lt;/em&gt; has no effect. &lt;em&gt;pid&lt;/em&gt; can refer to any process whose id is known, not necessarily a child process. The &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; functions called with &lt;a href=&quot;#os.P_NOWAIT&quot;&gt;&lt;code&gt;P_NOWAIT&lt;/code&gt;&lt;/a&gt; return suitable process handles.</source>
          <target state="translated">Windows의 경우 : 프로세스 핸들에 의해 주어진 프로세스가 완료 될 때까지 기다립니다 &lt;em&gt;PID&lt;/em&gt; 및 튜플 포함 반환 &lt;em&gt;PID를&lt;/em&gt; , 그 종료 상태 8 비트 (이동 쉽게 함수의 크로스 플랫폼을 사용합니다) 왼쪽으로 시프트. A는 &lt;em&gt;PID&lt;/em&gt; 보다 작거나 같음 &lt;code&gt;0&lt;/code&gt; Windows에서 특별한 의미가없는, 예외를 발생시킵니다. 정수 &lt;em&gt;옵션&lt;/em&gt; 의 값은 영향을 미치지 않습니다. &lt;em&gt;pid&lt;/em&gt; 는 반드시 자식 프로세스 일 필요는 없지만 id가 알려진 프로세스를 가리킬 수 있습니다. &lt;a href=&quot;#os.P_NOWAIT&quot;&gt; &lt;code&gt;P_NOWAIT&lt;/code&gt; &lt;/a&gt; 로 호출 된 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수는 적절한 프로세스 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f12c3a4544b46b4dcf9f6fec778669f13f9f9d3" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, random bytes are read from the &lt;code&gt;/dev/urandom&lt;/code&gt; device. If the &lt;code&gt;/dev/urandom&lt;/code&gt; device is not available or not readable, the &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">유닉스 계열 시스템에서는 &lt;code&gt;/dev/urandom&lt;/code&gt; 장치 에서 임의 바이트를 읽습니다 . 경우 &lt;code&gt;/dev/urandom&lt;/code&gt; 장치를 읽을 가능 여부되지는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2601d2cefa3f396475ef76603408eb2f24b04bbb" translate="yes" xml:space="preserve">
          <source>On all other platforms, the directories &lt;code&gt;/tmp&lt;/code&gt;, &lt;code&gt;/var/tmp&lt;/code&gt;, and &lt;code&gt;/usr/tmp&lt;/code&gt;, in that order.</source>
          <target state="translated">다른 모든 플랫폼에서는 &lt;code&gt;/tmp&lt;/code&gt; , &lt;code&gt;/var/tmp&lt;/code&gt; 및 &lt;code&gt;/usr/tmp&lt;/code&gt; 디렉토리 가 순서대로 있습니다.</target>
        </trans-unit>
        <trans-unit id="46dbf9b949c04044ffab0fab48aba4115d7ca33a" translate="yes" xml:space="preserve">
          <source>On both platforms, the old value is restored by &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 플랫폼 모두에서 이전 값은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 의해 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e7006d98db74f1849b0b0e7ef365ada8d73e13e" translate="yes" xml:space="preserve">
          <source>On client connections, the optional parameter &lt;em&gt;server_hostname&lt;/em&gt; specifies the hostname of the service which we are connecting to. This allows a single server to host multiple SSL-based services with distinct certificates, quite similarly to HTTP virtual hosts. Specifying &lt;em&gt;server_hostname&lt;/em&gt; will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;server_side&lt;/em&gt; is true.</source>
          <target state="translated">클라이언트 연결에서 선택적 매개 변수 &lt;em&gt;server_hostname&lt;/em&gt; 은 연결중인 서비스의 호스트 이름을 지정합니다. 이를 통해 단일 서버는 HTTP 가상 호스트와 매우 유사한 고유 한 인증서로 여러 SSL 기반 서비스를 호스팅 할 수 있습니다. &lt;em&gt;server_side&lt;/em&gt; 가 true 인 경우 &lt;em&gt;server_hostname&lt;/em&gt; 을 지정 하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67540c72da6a0c69935598617862e3eb3b0268da" translate="yes" xml:space="preserve">
          <source>On decoding, replace byte with individual surrogate code ranging from &lt;code&gt;U+DC80&lt;/code&gt; to &lt;code&gt;U+DCFF&lt;/code&gt;. This code will then be turned back into the same byte when the &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler is used when encoding the data. (See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt; for more.)</source>
          <target state="translated">복호에 이르기까지 각각의 대리 바이트 코드 교체 &lt;code&gt;U+DC80&lt;/code&gt; 에 &lt;code&gt;U+DCFF&lt;/code&gt; . 이 코드는 데이터를 인코딩 할 때 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기가 사용될 때 동일한 바이트로 다시 변환 됩니다. (자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="40a675dc2422036bd8b6d3953dd22e9373dc65f0" translate="yes" xml:space="preserve">
          <source>On encountering an invalid cookie, &lt;a href=&quot;#http.cookies.CookieError&quot;&gt;&lt;code&gt;CookieError&lt;/code&gt;&lt;/a&gt; is raised, so if your cookie data comes from a browser you should always prepare for invalid data and catch &lt;a href=&quot;#http.cookies.CookieError&quot;&gt;&lt;code&gt;CookieError&lt;/code&gt;&lt;/a&gt; on parsing.</source>
          <target state="translated">유효하지 않은 쿠키가 발생하면 &lt;a href=&quot;#http.cookies.CookieError&quot;&gt; &lt;code&gt;CookieError&lt;/code&gt; &lt;/a&gt; 가 발생하므로 쿠키 데이터가 브라우저에서 제공되면 항상 유효하지 않은 데이터를 준비 하고 구문 분석시 &lt;a href=&quot;#http.cookies.CookieError&quot;&gt; &lt;code&gt;CookieError&lt;/code&gt; &lt;/a&gt; 를 잡아야 합니다.</target>
        </trans-unit>
        <trans-unit id="34f29889fea4fa5095b6af09d7ca99a6568ae898" translate="yes" xml:space="preserve">
          <source>On entry to the context manager, a &lt;code&gt;WarningRecorder&lt;/code&gt; instance is returned. The underlying warnings list from &lt;a href=&quot;warnings#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings()&lt;/code&gt;&lt;/a&gt; is available via the recorder object&amp;rsquo;s &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; attribute. As a convenience, the attributes of the object representing the most recent warning can also be accessed directly through the recorder object (see example below). If no warning has been raised, then any of the attributes that would otherwise be expected on an object representing a warning will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 관리자에 진입하면 &lt;code&gt;WarningRecorder&lt;/code&gt; 인스턴스가 리턴됩니다. &lt;a href=&quot;warnings#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings()&lt;/code&gt; &lt;/a&gt; 의 기본 경고 목록 은 레코더 개체의 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 속성을 통해 사용할 수 있습니다 . 편의상 가장 최근 경고를 나타내는 객체의 속성은 레코더 객체를 통해 직접 액세스 할 수도 있습니다 (아래 예 참조). 경고가 발생하지 않으면 경고를 나타내는 객체에서 예상되는 속성은 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="689aca40c906c0122884f520ca113dd2d097568c" translate="yes" xml:space="preserve">
          <source>On large-file-capable Linux systems, this might work:</source>
          <target state="translated">대용량 파일 가능 Linux 시스템에서는 다음과 같이 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b7b3c25b067b29ff568eb64dceface5effcedb6" translate="yes" xml:space="preserve">
          <source>On macOS 10.6, 10.7 and 10.8, the default event loop uses &lt;a href=&quot;selectors#selectors.KqueueSelector&quot;&gt;&lt;code&gt;selectors.KqueueSelector&lt;/code&gt;&lt;/a&gt;, which does not support character devices on these versions. The &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; can be manually configured to use &lt;a href=&quot;selectors#selectors.SelectSelector&quot;&gt;&lt;code&gt;SelectSelector&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selectors#selectors.PollSelector&quot;&gt;&lt;code&gt;PollSelector&lt;/code&gt;&lt;/a&gt; to support character devices on these older versions of macOS. Example:</source>
          <target state="translated">macOS 10.6, 10.7 및 10.8에서 기본 이벤트 루프는 &lt;a href=&quot;selectors#selectors.KqueueSelector&quot;&gt; &lt;code&gt;selectors.KqueueSelector&lt;/code&gt; 를&lt;/a&gt; 사용 하며이 버전에서는 문자 장치를 지원하지 않습니다. &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; 은&lt;/a&gt; 수동으로 사용하도록 구성 할 수 있습니다 &lt;a href=&quot;selectors#selectors.SelectSelector&quot;&gt; &lt;code&gt;SelectSelector&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selectors#selectors.PollSelector&quot;&gt; &lt;code&gt;PollSelector&lt;/code&gt; 를&lt;/a&gt; 맥 OS의 이러한 이전 버전에서 지원 문자 장치. 예:</target>
        </trans-unit>
        <trans-unit id="59711c87f37f48c6b5ca1ccbf181736677303198" translate="yes" xml:space="preserve">
          <source>On macOS &lt;a href=&quot;http://www.manpagez.com/man/3/copyfile/&quot;&gt;fcopyfile&lt;/a&gt; is used to copy the file content (not metadata).</source>
          <target state="translated">macOS에서는 &lt;a href=&quot;http://www.manpagez.com/man/3/copyfile/&quot;&gt;fcopyfile&lt;/a&gt; 을 사용하여 메타 데이터가 아닌 파일 내용을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="e0095f6ed60d065349c04b6eefb4d5ebe1925719" translate="yes" xml:space="preserve">
          <source>On macOS, the encoding is &lt;code&gt;'utf-8'&lt;/code&gt;.</source>
          <target state="translated">macOS에서 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce1208192f171228b4901a07d6b02cdddfc85990" translate="yes" xml:space="preserve">
          <source>On macOS, there is one application menu. It dynamically changes according to the window currently selected. It has an IDLE menu, and some entries described below are moved around to conform to Apple guidelines.</source>
          <target state="translated">macOS에는 하나의 응용 프로그램 메뉴가 있습니다. 현재 선택된 창에 따라 동적으로 변경됩니다. 유휴 메뉴가 있으며 아래 설명 된 일부 항목은 Apple 지침에 따라 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="d215bf1c5b7b0def948c235e18bfe40621e88451" translate="yes" xml:space="preserve">
          <source>On many Unix systems (including *BSD, Linux, Solaris, and Darwin), it is more convenient to use the system&amp;rsquo;s zoneinfo (&lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/tzfile(5)&quot;&gt;tzfile(5)&lt;/a&gt;&lt;/em&gt;) database to specify the timezone rules. To do this, set the &lt;code id=&quot;index-18&quot;&gt;TZ&lt;/code&gt; environment variable to the path of the required timezone datafile, relative to the root of the systems &amp;lsquo;zoneinfo&amp;rsquo; timezone database, usually located at &lt;code&gt;/usr/share/zoneinfo&lt;/code&gt;. For example, &lt;code&gt;'US/Eastern'&lt;/code&gt;, &lt;code&gt;'Australia/Melbourne'&lt;/code&gt;, &lt;code&gt;'Egypt'&lt;/code&gt; or &lt;code&gt;'Europe/Amsterdam'&lt;/code&gt;.</source>
          <target state="translated">많은 Unix 시스템 (* BSD, Linux, Solaris 및 Darwin 포함)에서 시스템의 zoneinfo ( &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/tzfile(5)&quot;&gt;tzfile (5)&lt;/a&gt;&lt;/em&gt; ) 데이터베이스를 사용하여 시간대 규칙을 지정하는 것이 더 편리합니다 . 이렇게하려면 &lt;code id=&quot;index-18&quot;&gt;TZ&lt;/code&gt; 환경 변수를 시스템 'zoneinfo'시간대 데이터베이스의 루트 (일반적으로 &lt;code&gt;/usr/share/zoneinfo&lt;/code&gt; 에 있음)를 기준으로 필요한 시간대 데이터 파일의 경로로 설정하십시오 . 예를 들어, &lt;code&gt;'US/Eastern'&lt;/code&gt; , &lt;code&gt;'Australia/Melbourne'&lt;/code&gt; , &lt;code&gt;'Egypt'&lt;/code&gt; 또는 &lt;code&gt;'Europe/Amsterdam'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04ba6be7d13c87b73b6437d8a6f57d4cef94efc0" translate="yes" xml:space="preserve">
          <source>On newer versions of Windows 10, unprivileged accounts can create symlinks if Developer Mode is enabled. When Developer Mode is not available/enabled, the &lt;em&gt;SeCreateSymbolicLinkPrivilege&lt;/em&gt; privilege is required, or the process must be run as an administrator.</source>
          <target state="translated">최신 버전의 Windows 10에서 개발자 모드를 사용하면 권한이없는 계정이 심볼릭 링크를 만들 수 있습니다. 개발자 모드를 사용할 수 없거나 사용할 수없는 경우 &lt;em&gt;SeCreateSymbolicLinkPrivilege&lt;/em&gt; 권한이 필요하거나 프로세스를 관리자로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7bf663d20ba88f3d3779656c2de6b087faad7b7" translate="yes" xml:space="preserve">
          <source>On other Unix systems (such as FreeBSD), the following attributes may be available (but may be only filled out if root tries to use them):</source>
          <target state="translated">다른 Unix 시스템 (예 : FreeBSD)에서는 다음과 같은 속성을 사용할 수 있습니다 (그러나 루트가이를 사용하려는 경우에만 채워질 수 있음).</target>
        </trans-unit>
        <trans-unit id="06c0e7561753d8281468dc3f168c40f9e9b2351d" translate="yes" xml:space="preserve">
          <source>On other platforms, the generic &lt;a href=&quot;fcntl#fcntl.fcntl&quot;&gt;&lt;code&gt;fcntl.fcntl()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fcntl#fcntl.ioctl&quot;&gt;&lt;code&gt;fcntl.ioctl()&lt;/code&gt;&lt;/a&gt; functions may be used; they accept a socket object as their first argument.</source>
          <target state="translated">다른 플랫폼에서는 일반 &lt;a href=&quot;fcntl#fcntl.fcntl&quot;&gt; &lt;code&gt;fcntl.fcntl()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fcntl#fcntl.ioctl&quot;&gt; &lt;code&gt;fcntl.ioctl()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다. 소켓 객체를 첫 번째 인수로 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="30fe0b6f68fa261e54a2b916d494101fac571654" translate="yes" xml:space="preserve">
          <source>On output, if &lt;em&gt;doublequote&lt;/em&gt; is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; and no &lt;em&gt;escapechar&lt;/em&gt; is set, &lt;a href=&quot;#csv.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; is raised if a &lt;em&gt;quotechar&lt;/em&gt; is found in a field.</source>
          <target state="translated">경우 출력에서 &lt;em&gt;doublequote이&lt;/em&gt; 있다 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 과 더 &lt;em&gt;escapechar이&lt;/em&gt; 설정되어 있지 않은, &lt;a href=&quot;#csv.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 경우 발생 &lt;em&gt;quotechar이&lt;/em&gt; 필드에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0af5b92888c4dc7ffac3572dfa0d442dabf0ede" translate="yes" xml:space="preserve">
          <source>On platforms that do not support symbolic links, this is an alias for &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기호 링크를 지원하지 않는 플랫폼에서 이는 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="835888031d7cef42de83709eee1579e07f8ea020" translate="yes" xml:space="preserve">
          <source>On platforms that support the necessary fd-based functions a symlink attack resistant version of &lt;a href=&quot;#shutil.rmtree&quot;&gt;&lt;code&gt;rmtree()&lt;/code&gt;&lt;/a&gt; is used by default. On other platforms, the &lt;a href=&quot;#shutil.rmtree&quot;&gt;&lt;code&gt;rmtree()&lt;/code&gt;&lt;/a&gt; implementation is susceptible to a symlink attack: given proper timing and circumstances, attackers can manipulate symlinks on the filesystem to delete files they wouldn&amp;rsquo;t be able to access otherwise. Applications can use the &lt;a href=&quot;#shutil.rmtree.avoids_symlink_attacks&quot;&gt;&lt;code&gt;rmtree.avoids_symlink_attacks&lt;/code&gt;&lt;/a&gt; function attribute to determine which case applies.</source>
          <target state="translated">필요한 fd 기반 함수를 지원하는 플랫폼에서는 기본적으로 &lt;a href=&quot;#shutil.rmtree&quot;&gt; &lt;code&gt;rmtree()&lt;/code&gt; &lt;/a&gt; 의 symlink 공격 방지 버전 이 사용됩니다. 다른 플랫폼에서는 &lt;a href=&quot;#shutil.rmtree&quot;&gt; &lt;code&gt;rmtree()&lt;/code&gt; &lt;/a&gt; 구현이 심볼릭 링크 공격에 취약합니다. 적절한 타이밍과 상황에 따라 공격자는 파일 시스템에서 심볼릭 링크를 조작하여 다른 방법으로는 액세스 할 수없는 파일을 삭제할 수 있습니다. 애플리케이션은 &lt;a href=&quot;#shutil.rmtree.avoids_symlink_attacks&quot;&gt; &lt;code&gt;rmtree.avoids_symlink_attacks&lt;/code&gt; &lt;/a&gt; 함수 속성을 사용하여 적용되는 케이스를 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2539c27ac2c42d14e6d76946d07ef981a8cc60c" translate="yes" xml:space="preserve">
          <source>On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced.</source>
          <target state="translated">IEEE 754 이진 부동 소수점을 사용하는 플랫폼에서이 작업의 결과는 항상 정확하게 표현 가능합니다. 반올림 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0f67e7089bb8910b4e4fda4cf6b72e3df1c3c94" translate="yes" xml:space="preserve">
          <source>On platforms where some or all of this functionality is unavailable, when asked to modify a symbolic link, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; will copy everything it can. &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; never returns failure.</source>
          <target state="translated">이 기능 중 일부 또는 전부를 사용할 수없는 플랫폼에서 심볼릭 링크를 수정하라는 요청을 &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 가 가능한 모든 것을 복사합니다. &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 는 실패를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c6b1f69887e623bddc661e6cae08b9b00d43caf" translate="yes" xml:space="preserve">
          <source>On platforms with hardware and system-level support for signed zeros, functions involving branch cuts are continuous on &lt;em&gt;both&lt;/em&gt; sides of the branch cut: the sign of the zero distinguishes one side of the branch cut from the other. On platforms that do not support signed zeros the continuity is as specified below.</source>
          <target state="translated">서명 제로를위한 하드웨어 및 시스템 수준의 지원 플랫폼, 지점 삭감을 포함하는 기능에 연속 &lt;em&gt;모두&lt;/em&gt; 다른에서 분기 컷의 제로 구별하는 한쪽의 부호 : 분기 컷의 측면. 부호있는 0을 지원하지 않는 플랫폼에서 연속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cea002554b75820329fc15191d1a6a71d5584562" translate="yes" xml:space="preserve">
          <source>On platforms without &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Completer&lt;/code&gt; class defined by this module can still be used for custom purposes.</source>
          <target state="translated">없이 플랫폼 &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;Completer&lt;/code&gt; 의 이 모듈에 의해 정의 된 클래스는 여전히 사용자 정의 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6a777251164aea8999f437ba7c8d0b926184ae" translate="yes" xml:space="preserve">
          <source>On some Unix platforms, many of these functions support one or more of these features:</source>
          <target state="translated">일부 Unix 플랫폼에서 이러한 기능 중 다수는 다음 기능 중 하나 이상을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="eaba699b79f7765281c28b47b3e0ec7e21c3ec5c" translate="yes" xml:space="preserve">
          <source>On some Unix systems (such as Linux), the following attributes may also be available:</source>
          <target state="translated">일부 Unix 시스템 (예 : Linux)에서는 다음 속성을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0ae39c0ac3f68172a6d225258c4c362c47d6748" translate="yes" xml:space="preserve">
          <source>On some platforms, an optional field width and precision specification can immediately follow the initial &lt;code&gt;'%'&lt;/code&gt; of a directive in the following order; this is also not portable. The field width is normally 2 except for &lt;code&gt;%j&lt;/code&gt; where it is 3.</source>
          <target state="translated">일부 플랫폼에서 선택적 필드 너비 및 정밀도 사양은 지시문 의 초기 &lt;code&gt;'%'&lt;/code&gt; 를 다음 순서로 즉시 따를 수 있습니다 . 이것은 또한 휴대용이 아닙니다. 필드 너비는 일반적으로 2이며 &lt;code&gt;%j&lt;/code&gt; 는 3입니다.</target>
        </trans-unit>
        <trans-unit id="49846f91b44b9eabca7917db8a10258a1a0b35cf" translate="yes" xml:space="preserve">
          <source>On some platforms, including FreeBSD and Mac OS X, setting &lt;code&gt;environ&lt;/code&gt; may cause memory leaks. Refer to the system documentation for &lt;code&gt;putenv()&lt;/code&gt;.</source>
          <target state="translated">FreeBSD 및 Mac OS X를 포함한 일부 플랫폼에서 &lt;code&gt;environ&lt;/code&gt; 설정 하면 메모리 누수가 발생할 수 있습니다. &lt;code&gt;putenv()&lt;/code&gt; 시스템 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58e337bb68a53e0e0fdf875e3f9a3ba499302b95" translate="yes" xml:space="preserve">
          <source>On some platforms, including FreeBSD and Mac OS X, setting &lt;code&gt;environ&lt;/code&gt; may cause memory leaks. Refer to the system documentation for putenv.</source>
          <target state="translated">FreeBSD 및 Mac OS X를 포함한 일부 플랫폼에서 &lt;code&gt;environ&lt;/code&gt; 설정 하면 메모리 누수가 발생할 수 있습니다. putenv에 대한 시스템 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce939615baf6b4e6e43bf427856a8f1921f68d68" translate="yes" xml:space="preserve">
          <source>On some systems, &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt;&lt;code&gt;sendmsg()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; can be used to pass file descriptors between processes over an &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; socket. When this facility is used (it is often restricted to &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; sockets), &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; will return, in its ancillary data, items of the form &lt;code&gt;(socket.SOL_SOCKET,
socket.SCM_RIGHTS, fds)&lt;/code&gt;, where &lt;em&gt;fds&lt;/em&gt; is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object representing the new file descriptors as a binary array of the native C &lt;code&gt;int&lt;/code&gt; type. If &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; raises an exception after the system call returns, it will first attempt to close any file descriptors received via this mechanism.</source>
          <target state="translated">일부 시스템에서는 &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt; &lt;code&gt;sendmsg()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 소켓을 통해 프로세스간에 파일 설명자를 전달할 수 있습니다 . 이 기능은 (이 종종 제한된다 사용될 때 &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; 의&lt;/a&gt; 소켓) &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; 그 보조 데이터 형태의 항목에서, 반환 &lt;code&gt;(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)&lt;/code&gt; , &lt;em&gt;FDS는&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 나타내는 객체 네이티브 C &lt;code&gt;int&lt;/code&gt; 형 의 바이너리 배열로서의 새로운 파일 기술자 시스템 호출이 리턴 된 후 &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; 에서 예외가 발생 하면 먼저이 메커니즘을 통해 수신 된 파일 디스크립터를 닫으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0854fe514f9f478ef9200189533ba9f76d283b6e" translate="yes" xml:space="preserve">
          <source>On some systems, &lt;em&gt;mode&lt;/em&gt; is ignored. Where it is used, the current umask value is first masked out. If bits other than the last 9 (i.e. the last 3 digits of the octal representation of the &lt;em&gt;mode&lt;/em&gt;) are set, their meaning is platform-dependent. On some platforms, they are ignored and you should call &lt;a href=&quot;#os.chmod&quot;&gt;&lt;code&gt;chmod()&lt;/code&gt;&lt;/a&gt; explicitly to set them.</source>
          <target state="translated">일부 시스템에서는 &lt;em&gt;모드&lt;/em&gt; 가 무시됩니다. 사용되는 경우 현재 umask 값이 먼저 마스킹됩니다. 마지막 9 이외의 비트 (즉, &lt;em&gt;모드&lt;/em&gt; 의 8 진 표현의 마지막 3 자리 )가 설정되면 그 의미는 플랫폼에 따라 다릅니다. 일부 플랫폼에서는 무시되며 &lt;a href=&quot;#os.chmod&quot;&gt; &lt;code&gt;chmod()&lt;/code&gt; &lt;/a&gt; 명시 적으로 호출 하여 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="91c09add15e3897cc71e4285cad983d35ae19c62" translate="yes" xml:space="preserve">
          <source>On some systems, it is necessary to invoke &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; to obtain the user preferences, so this function is not thread-safe. If invoking setlocale is not necessary or desired, &lt;em&gt;do_setlocale&lt;/em&gt; should be set to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">일부 시스템에서는 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 사용자 기본 설정을 가져와야 하므로이 함수는 스레드로부터 안전하지 않습니다. setlocale을 호출하지 않아도되거나 &lt;em&gt;do_setlocale&lt;/em&gt; 을 &lt;code&gt;False&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c6110a82223307cc8967bdb9b6a267ed5e823067" translate="yes" xml:space="preserve">
          <source>On success, the data and separator will be removed from the internal buffer (consumed). Returned data will include the separator at the end.</source>
          <target state="translated">성공하면 데이터와 구분 기호가 내부 버퍼에서 제거됩니다 (소비 됨). 반환 된 데이터는 끝에 구분 기호를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="81d3e77503079dc680941880acaf81e6572cb402" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, this module will also import and configure the &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt;&lt;code&gt;rlcompleter&lt;/code&gt;&lt;/a&gt; module, if Python is started in &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt; and without the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; option. The default behavior is enable tab-completion and to use &lt;code&gt;~/.python_history&lt;/code&gt; as the history save file. To disable it, delete (or override) the &lt;a href=&quot;sys#sys.__interactivehook__&quot;&gt;&lt;code&gt;sys.__interactivehook__&lt;/code&gt;&lt;/a&gt; attribute in your &lt;code&gt;sitecustomize&lt;/code&gt; or &lt;code&gt;usercustomize&lt;/code&gt; module or your &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">&lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 을 지원하는 시스템 에서이 모듈은 Python이 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;대화식 모드&lt;/a&gt; 에서 시작되고 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 옵션 없이 시작되면 &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt; &lt;code&gt;rlcompleter&lt;/code&gt; &lt;/a&gt; 모듈을 가져오고 구성합니다 . 기본 동작은 탭 완성 활성화이며 &lt;code&gt;~/.python_history&lt;/code&gt; 를 기록 저장 파일로 사용하는 것입니다. 그것을 사용하지 않으려면 삭제 (또는 오버라이드) &lt;a href=&quot;sys#sys.__interactivehook__&quot;&gt; &lt;code&gt;sys.__interactivehook__&lt;/code&gt; &lt;/a&gt; 당신의 속성 &lt;code&gt;sitecustomize&lt;/code&gt; 또는 &lt;code&gt;usercustomize&lt;/code&gt; 의 모듈 또는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; 의&lt;/a&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="4ce3a4c7161faf6a2733a2da667b68f080fb9ebe" translate="yes" xml:space="preserve">
          <source>On systems which support the &lt;code&gt;SCM_RIGHTS&lt;/code&gt; mechanism, the following function will receive up to &lt;em&gt;maxfds&lt;/em&gt; file descriptors, returning the message data and a list containing the descriptors (while ignoring unexpected conditions such as unrelated control messages being received). See also &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt;&lt;code&gt;sendmsg()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SCM_RIGHTS&lt;/code&gt; 메커니즘 을 지원하는 시스템 에서 다음 함수는 최대 &lt;em&gt;maxfds&lt;/em&gt; 파일 디스크립터 를 수신 하여 메시지 데이터 및 디스크립터가 포함 된 목록을 리턴합니다 (관련되지 않은 제어 메시지 수신과 같은 예상치 못한 조건은 무시 함). &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt; &lt;code&gt;sendmsg()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="170fe28c30f87352badfea6a1b0adfa7979f0455" translate="yes" xml:space="preserve">
          <source>On the Font tab, see the text sample for the effect of font face and size on multiple characters in multiple languages. Edit the sample to add other characters of personal interest. Use the sample to select monospaced fonts. If particular characters have problems in Shell or an editor, add them to the top of the sample and try changing first size and then font.</source>
          <target state="translated">서체 탭에서 여러 언어로 된 여러 문자의 서체 및 크기 효과에 대한 텍스트 샘플을 참조하십시오. 관심있는 다른 문자를 추가하려면 샘플을 편집하십시오. 샘플을 사용하여 고정 폭 글꼴을 선택하십시오. Shell이나 편집기에서 특정 문자에 문제가있는 경우 샘플 상단에 해당 문자를 추가하고 첫 번째 크기를 변경 한 다음 글꼴을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0b329dc6e9c4b674641af665ee59096dbcd8c046" translate="yes" xml:space="preserve">
          <source>On the Highlights and Keys tab, select a built-in or custom color theme and key set. To use a newer built-in color theme or key set with older IDLEs, save it as a new custom theme or key set and it well be accessible to older IDLEs.</source>
          <target state="translated">강조 표시 및 키 탭에서 내장 또는 사용자 정의 색상 테마 및 키 세트를 선택하십시오. 이전 IDLE과 함께 최신 내장 색상 테마 또는 키 세트를 사용하려면 새 ID를 테마로 저장하거나 이전 IDLE에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9fb9ccc44f0f6638fed1a987aa33ae9f6959c6" translate="yes" xml:space="preserve">
          <source>On the POSIX compliant platforms, it is equivalent to the following expression:</source>
          <target state="translated">POSIX 호환 플랫폼에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8718a6ecfb2948f94e8214f2c029ea186b4fea26" translate="yes" xml:space="preserve">
          <source>On the consumer side, we can pickle those objects the usual way, which when unserialized will give us a copy of the original object:</source>
          <target state="translated">소비자 측에서는 일반적인 방법으로 해당 객체를 피클 할 수 있습니다. 직렬화를 해제하면 원래 객체의 사본이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="491abdd927ace9b614d81c92dc19845f26b3d2e7" translate="yes" xml:space="preserve">
          <source>On the first, uncached call, a system call is required on Windows but not on Unix.</source>
          <target state="translated">캐시되지 않은 첫 번째 호출에서는 Windows에서는 시스템 호출이 필요하지만 Unix에서는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cd90c0c17f384bfaab3cff8f5c166412c102c98" translate="yes" xml:space="preserve">
          <source>On the first, uncached call, no system call is required in most cases. Specifically, for non-symlinks, neither Windows or Unix require a system call, except on certain Unix file systems, such as network file systems, that return &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt;. If the entry is a symlink, a system call will be required to follow the symlink unless &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">캐시되지 않은 첫 번째 통화에서는 대부분의 경우 시스템 호출이 필요하지 않습니다. 특히 심볼릭 링크가 아닌 경우, Windows 또는 Unix는 네트워크 파일 시스템과 같은 특정 Unix 파일 시스템을 제외하고 &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt; 을 반환하는 시스템 호출을 요구하지 않습니다 . 항목이 symlink 인 경우 &lt;em&gt;follow_symlinks&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 가 아닌 한 시스템 호출은 symlink를 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9dac8ead05b600f65bb3a1c6b260cbf7bc2b51d" translate="yes" xml:space="preserve">
          <source>On the first, uncached call, no system call is required in most cases. Specifically, neither Windows or Unix require a system call, except on certain Unix file systems, such as network file systems, that return &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt;.</source>
          <target state="translated">캐시되지 않은 첫 번째 통화에서는 대부분의 경우 시스템 호출이 필요하지 않습니다. 특히, Windows 또는 Unix는 &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt; 을 리턴하는 네트워크 파일 시스템과 같은 특정 Unix 파일 시스템을 제외하고 시스템 호출이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e84ca525861c9e265cab3b438b32f029594120f" translate="yes" xml:space="preserve">
          <source>On the other hand, if an explicit value of &lt;code&gt;None&lt;/code&gt; is allowed, the use of &lt;code&gt;Optional&lt;/code&gt; is appropriate, whether the argument is optional or not. For example:</source>
          <target state="translated">반면에 명시적인 &lt;code&gt;None&lt;/code&gt; 값 이 허용되는 경우 인수의 선택 여부에 관계없이 &lt;code&gt;Optional&lt;/code&gt; 을 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf9973b9d57271129427560d24c59bd726fbd904" translate="yes" xml:space="preserve">
          <source>On the other hand, if you are building an HTTP server where all data is stored externally (for instance, in the file system), a synchronous class will essentially render the service &amp;ldquo;deaf&amp;rdquo; while one request is being handled &amp;ndash; which may be for a very long time if a client is slow to receive all the data it has requested. Here a threading or forking server is appropriate.</source>
          <target state="translated">반면에 모든 데이터가 외부 (예 : 파일 시스템)에 저장된 HTTP 서버를 구축하는 경우 동기 클래스는 하나의 요청이 처리되는 동안 서비스를 &quot;청각 장애&quot;로 렌더링합니다. 클라이언트가 요청한 모든 데이터를 느리게받는 경우 매우 오랜 시간. 여기에는 스레딩 또는 포크 서버가 적합합니다.</target>
        </trans-unit>
        <trans-unit id="9d9537632dbfd5ce7c3381fb8473c75296dfa687" translate="yes" xml:space="preserve">
          <source>On the other hand, the precision of &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; is better than their Unix equivalents: times are expressed as floating point numbers, &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; returns the most accurate time available (using Unix &lt;code&gt;gettimeofday()&lt;/code&gt; where available), and &lt;a href=&quot;#time.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; will accept a time with a nonzero fraction (Unix &lt;code&gt;select()&lt;/code&gt; is used to implement this, where available).</source>
          <target state="translated">반면 &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 의 정밀도는 유닉스에 해당하는 것보다 낫습니다. 시간은 부동 소수점 숫자로 표현되고 &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 은 사용 가능한 가장 정확한 시간을 반환합니다 (사용 가능한 경우 Unix &lt;code&gt;gettimeofday()&lt;/code&gt; 사용). &lt;a href=&quot;#time.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 은 0이 아닌 분수를 가진 시간을 받아들입니다 (사용 가능한 경우 유닉스 &lt;code&gt;select()&lt;/code&gt; 가 이것을 구현하는 데 사용됩니다).</target>
        </trans-unit>
        <trans-unit id="2b4270c26ef431be82a119288026b915740bbad6" translate="yes" xml:space="preserve">
          <source>On the other hand, the statement &lt;code&gt;from spam.ham import eggs, sausage as
saus&lt;/code&gt; results in</source>
          <target state="translated">다른 한편으로, &lt;code&gt;from spam.ham import eggs, sausage as saus&lt;/code&gt; 진술 은 saus 결과</target>
        </trans-unit>
        <trans-unit id="302064ecd83cf854ce5daa489ae06236b2f77d49" translate="yes" xml:space="preserve">
          <source>On the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.</source>
          <target state="translated">실제 라인에는 균일, 정규 (가우시안), 로그 정규, 음의 지수, 감마 및 베타 분포를 계산하는 함수가 있습니다. 각도 분포를 생성하기 위해 von Mises 분포를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="021f9c86cdcc2f4cf15e28ff86eb4c57b0b3ffd0" translate="yes" xml:space="preserve">
          <source>On the receiving side, it needs to pass a &lt;em&gt;buffers&lt;/em&gt; argument to &lt;a href=&quot;#pickle.Unpickler&quot;&gt;&lt;code&gt;Unpickler&lt;/code&gt;&lt;/a&gt; (or to the &lt;a href=&quot;#pickle.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pickle.loads&quot;&gt;&lt;code&gt;loads()&lt;/code&gt;&lt;/a&gt; function), which is an iterable of the buffers which were passed to &lt;em&gt;buffer_callback&lt;/em&gt;. That iterable should produce buffers in the same order as they were passed to &lt;em&gt;buffer_callback&lt;/em&gt;. Those buffers will provide the data expected by the reconstructors of the objects whose pickling produced the original &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt;&lt;code&gt;PickleBuffer&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">수신 측에서는 &lt;em&gt;버퍼&lt;/em&gt; 인수를 &lt;a href=&quot;#pickle.Unpickler&quot;&gt; &lt;code&gt;Unpickler&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pickle.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pickle.loads&quot;&gt; &lt;code&gt;loads()&lt;/code&gt; &lt;/a&gt; 함수)에 전달해야 &lt;em&gt;합니다&lt;/em&gt; . 이 &lt;em&gt;인수는 buffer_callback&lt;/em&gt; 에 전달 된 버퍼의 반복 가능입니다 . iterable은 &lt;em&gt;buffer_callback&lt;/em&gt; 에 전달 된 순서와 동일한 순서로 버퍼를 생성해야합니다 . 이러한 버퍼는 피클 링에서 원래 &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt; &lt;code&gt;PickleBuffer&lt;/code&gt; &lt;/a&gt; 객체를 생성 한 객체의 재구성자가 예상 한 데이터를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="66db2c4de162079fa6ad1e56a412af6e40b12ff3" translate="yes" xml:space="preserve">
          <source>On the sending side, it needs to pass a &lt;em&gt;buffer_callback&lt;/em&gt; argument to &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; (or to the &lt;a href=&quot;#pickle.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pickle.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; function), which will be called with each &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt;&lt;code&gt;PickleBuffer&lt;/code&gt;&lt;/a&gt; generated while pickling the object graph. Buffers accumulated by the &lt;em&gt;buffer_callback&lt;/em&gt; will not see their data copied into the pickle stream, only a cheap marker will be inserted.</source>
          <target state="translated">송신 측에서는 객체 그래프를 산세하는 동안 생성 된 각 &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt; &lt;code&gt;PickleBuffer&lt;/code&gt; &lt;/a&gt; 와 함께 호출 되는 &lt;em&gt;buffer_callback&lt;/em&gt; 인수를 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pickle.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pickle.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt; 함수)에 전달 해야합니다. &lt;em&gt;buffer_callback에&lt;/em&gt; 의해 누적 된 버퍼 는 자신의 데이터가 피클 스트림으로 복사되는 것을 보지 않고 저렴한 마커 만 삽입됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfc3524ee9c52842ac68b4cbfd63f42ac55c13bf" translate="yes" xml:space="preserve">
          <source>On top of the core functionality, &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; supports interpolation. This means values can be preprocessed before returning them from &lt;code&gt;get()&lt;/code&gt; calls.</source>
          <target state="translated">핵심 기능 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; &lt;/a&gt; 는 보간을 지원합니다. 즉, &lt;code&gt;get()&lt;/code&gt; 호출 에서 값을 반환하기 전에 값을 사전 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0a89fb92ab1b6c953761430059ee14bf39ac4f" translate="yes" xml:space="preserve">
          <source>On unsupported Windows versions, &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지원되지 않는 Windows 버전에서는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7af216ac764a8e05fdb02285dd1f73ff0b4bf41" translate="yes" xml:space="preserve">
          <source>On-line reference material.</source>
          <target state="translated">온라인 참조 자료.</target>
        </trans-unit>
        <trans-unit id="7ee9b6bbcd3fc003f8c514b8359b3b3d847b5991" translate="yes" xml:space="preserve">
          <source>On-line version of the man pages and reference material.</source>
          <target state="translated">온라인 설명서 페이지 및 참조 자료.</target>
        </trans-unit>
        <trans-unit id="6aeb9a0eecc81b131da11166dd168337677c0196" translate="yes" xml:space="preserve">
          <source>On-line version of the programmer&amp;rsquo;s reference material.</source>
          <target state="translated">프로그래머 참조 자료의 온라인 버전.</target>
        </trans-unit>
        <trans-unit id="d68ef1995b7e1837b6328a4152bbf582900b7c03" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#itertools.tee&quot;&gt;&lt;code&gt;tee()&lt;/code&gt;&lt;/a&gt; has made a split, the original &lt;em&gt;iterable&lt;/em&gt; should not be used anywhere else; otherwise, the &lt;em&gt;iterable&lt;/em&gt; could get advanced without the tee objects being informed.</source>
          <target state="translated">일단 &lt;a href=&quot;#itertools.tee&quot;&gt; &lt;code&gt;tee()&lt;/code&gt; &lt;/a&gt; 분할, 원래했다 &lt;em&gt;반복자는&lt;/em&gt; 다른 곳에서는 사용하지 않아야을; 그렇지 않으면 티 개체에 대한 정보를 제공하지 않고 &lt;em&gt;iterable&lt;/em&gt; 이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13355ef156e37b7df46841221634670e6bd21bf1" translate="yes" xml:space="preserve">
          <source>Once a thread object is created, its activity must be started by calling the thread&amp;rsquo;s &lt;a href=&quot;#threading.Thread.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. This invokes the &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method in a separate thread of control.</source>
          <target state="translated">스레드 객체가 생성되면 스레드의 &lt;a href=&quot;#threading.Thread.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 해당 활동을 시작해야합니다 . 이것은 별도의 제어 스레드에서 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="207c91dde7ce754af70d86e35ca18a8bfb78b4b4" translate="yes" xml:space="preserve">
          <source>Once a virtual environment has been created, it can be &amp;ldquo;activated&amp;rdquo; using a script in the virtual environment&amp;rsquo;s binary directory. The invocation of the script is platform-specific (&lt;code&gt;&amp;lt;venv&amp;gt;&lt;/code&gt; must be replaced by the path of the directory containing the virtual environment):</source>
          <target state="translated">가상 환경이 만들어지면 가상 환경의 이진 디렉터리에있는 스크립트를 사용하여 &quot;활성화&quot;될 수 있습니다. 스크립트 호출은 플랫폼마다 다릅니다 ( &lt;code&gt;&amp;lt;venv&amp;gt;&lt;/code&gt; 는 가상 환경을 포함하는 디렉토리의 경로로 바꿔야합니다).</target>
        </trans-unit>
        <trans-unit id="889abf09b206885a298b4b0048c82881bd8294ef" translate="yes" xml:space="preserve">
          <source>Once an iterator&amp;rsquo;s &lt;a href=&quot;#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt; method raises &lt;a href=&quot;exceptions#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt;, it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken.</source>
          <target state="translated">반복자의 &lt;a href=&quot;#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;exceptions#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 을 발생 시키면 후속 호출에서 계속 수행해야합니다. 이 속성에 따르지 않는 구현은 고장난 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c8954a531e8e55ebee2fcb88a5f5f25aa89c78a2" translate="yes" xml:space="preserve">
          <source>Once constructed, &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; objects are immutable.</source>
          <target state="translated">일단 생성되면 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 객체는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="16be74f5902bbdc230632d054aabd873de1dda59" translate="yes" xml:space="preserve">
          <source>Once created one should call &lt;a href=&quot;#multiprocessing.managers.BaseManager.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;get_server().serve_forever()&lt;/code&gt; to ensure that the manager object refers to a started manager process.</source>
          <target state="translated">일단 작성되면 &lt;a href=&quot;#multiprocessing.managers.BaseManager.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;get_server().serve_forever()&lt;/code&gt; 를 호출 하여 관리자 오브젝트가 시작된 관리자 프로세스를 참조하도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ccc2cd016213a015dfbf70d995a4eef4403a9624" translate="yes" xml:space="preserve">
          <source>Once created, an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; object may be manipulated by directly changing its fields (such as &lt;a href=&quot;#xml.etree.ElementTree.Element.text&quot;&gt;&lt;code&gt;Element.text&lt;/code&gt;&lt;/a&gt;), adding and modifying attributes (&lt;a href=&quot;#xml.etree.ElementTree.Element.set&quot;&gt;&lt;code&gt;Element.set()&lt;/code&gt;&lt;/a&gt; method), as well as adding new children (for example with &lt;a href=&quot;#xml.etree.ElementTree.Element.append&quot;&gt;&lt;code&gt;Element.append()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">일단 생성 된 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 객체는 필드 (예 : &lt;a href=&quot;#xml.etree.ElementTree.Element.text&quot;&gt; &lt;code&gt;Element.text&lt;/code&gt; &lt;/a&gt; ) 를 직접 변경하고 속성 ( &lt;a href=&quot;#xml.etree.ElementTree.Element.set&quot;&gt; &lt;code&gt;Element.set()&lt;/code&gt; &lt;/a&gt; 메서드)을 추가 및 수정 하고 새 자식 (예 : &lt;a href=&quot;#xml.etree.ElementTree.Element.append&quot;&gt; &lt;code&gt;Element.append()&lt;/code&gt; &lt;/a&gt; 하여)을 조작하여 조작 할 수 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="d98f7cd89572d4bbe43871efa04dc25f912f9367" translate="yes" xml:space="preserve">
          <source>Once created, the pathname to the widget becomes a new command. This new &lt;em&gt;widget command&lt;/em&gt; is the programmer&amp;rsquo;s handle for getting the new widget to perform some &lt;em&gt;action&lt;/em&gt;. In C, you&amp;rsquo;d express this as someAction(fred, someOptions), in C++, you would express this as fred.someAction(someOptions), and in Tk, you say:</source>
          <target state="translated">일단 작성되면 위젯의 경로 이름이 새 명령이됩니다. 이 새 &lt;em&gt;위젯 명령&lt;/em&gt; 은 새 위젯이 일부 &lt;em&gt;조치&lt;/em&gt; 를 수행하도록하는 프로그래머의 핸들입니다 . C에서는 이것을 someAction (fred, someOptions)으로 표현하고, C ++에서는 이것을 fred.someAction (someOptions)로 표현하고 Tk에서는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="b88e8436dc34ad8ecac85ed9098e7930bd406ff6" translate="yes" xml:space="preserve">
          <source>Once executed the &lt;a href=&quot;#module-gzip&quot;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt; module keeps the input file(s).</source>
          <target state="translated">일단 실행되면 &lt;a href=&quot;#module-gzip&quot;&gt; &lt;code&gt;gzip&lt;/code&gt; &lt;/a&gt; 모듈은 입력 파일을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="59bd0557426d252898ba83d74b3d08da5feeacce" translate="yes" xml:space="preserve">
          <source>Once spawned, worker threads call the semaphore&amp;rsquo;s acquire and release methods when they need to connect to the server:</source>
          <target state="translated">일단 생성 된 작업자 스레드는 서버에 연결해야 할 때 세마포어의 획득 및 해제 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9dc52253ba5d16f68a3458bf5594be6616430d42" translate="yes" xml:space="preserve">
          <source>Once the context manager exits, the warnings filter is restored to its state when the context was entered. This prevents tests from changing the warnings filter in unexpected ways between tests and leading to indeterminate test results. The &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt; function in the module is also restored to its original value. Note: this can only be guaranteed in a single-threaded application. If two or more threads use the &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; context manager at the same time, the behavior is undefined.</source>
          <target state="translated">컨텍스트 관리자가 종료되면 컨텍스트를 입력했을 때 경고 필터가 상태로 복원됩니다. 이렇게하면 테스트간에 경고 필터가 예기치 않은 방식으로 변경되어 테스트 결과가 불확실 해지지 않습니다. 모듈 의 &lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt; 함수도 원래 값으로 복원됩니다. 참고 : 이것은 단일 스레드 응용 프로그램에서만 보장 될 수 있습니다. 둘 이상의 스레드가 &lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; &lt;/a&gt; 컨텍스트 관리자를 동시에 사용하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d5043f40e3990a632ef7cf48ff135c75a7ff554" translate="yes" xml:space="preserve">
          <source>Once the headers have been read, if the request is of type POST (indicating that further data are present in the input stream) then the &lt;code&gt;Content-Length:&lt;/code&gt; header is used to set a numeric terminator to read the right amount of data from the channel.</source>
          <target state="translated">헤더를 읽은 후 요청이 POST 유형 인 경우 (입력 스트림에 추가 데이터가 있음을 나타내는) &lt;code&gt;Content-Length:&lt;/code&gt; 헤더를 사용하여 채널에서 올바른 양의 데이터를 읽도록 숫자 종결자를 설정합니다. .</target>
        </trans-unit>
        <trans-unit id="3625bd42b562728df6287438cfb43f246eb75f17" translate="yes" xml:space="preserve">
          <source>Once the initial channel(s) is(are) created, calling the &lt;a href=&quot;#asyncore.loop&quot;&gt;&lt;code&gt;loop()&lt;/code&gt;&lt;/a&gt; function activates channel service, which continues until the last channel (including any that have been added to the map during asynchronous service) is closed.</source>
          <target state="translated">초기 채널이 생성되면 &lt;a href=&quot;#asyncore.loop&quot;&gt; &lt;code&gt;loop()&lt;/code&gt; &lt;/a&gt; 함수를 호출하면 채널 서비스가 활성화되어 마지막 서비스 (비동기 서비스 중 맵에 추가 된 채널 포함)가 닫힐 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="4a2546b8a5097fd780cdeb2adc6d3eb6f8ec8d23" translate="yes" xml:space="preserve">
          <source>Once the thread&amp;rsquo;s activity is started, the thread is considered &amp;lsquo;alive&amp;rsquo;. It stops being alive when its &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method terminates &amp;ndash; either normally, or by raising an unhandled exception. The &lt;a href=&quot;#threading.Thread.is_alive&quot;&gt;&lt;code&gt;is_alive()&lt;/code&gt;&lt;/a&gt; method tests whether the thread is alive.</source>
          <target state="translated">스레드 활동이 시작되면 스레드는 '작동 중'으로 간주됩니다. 일반적으로 또는 처리되지 않은 예외를 발생시켜 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드가 종료 되면 작동 이 중지됩니다 . &lt;a href=&quot;#threading.Thread.is_alive&quot;&gt; &lt;code&gt;is_alive()&lt;/code&gt; &lt;/a&gt; 메소드 테스트 실 살아 있는지 여부.</target>
        </trans-unit>
        <trans-unit id="a235b9ded0ea3a43927ac13de68434d28c8fa6ae" translate="yes" xml:space="preserve">
          <source>Once you have a &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, you can create a &lt;a href=&quot;#sqlite3.Cursor&quot;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/a&gt; object and call its &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt;&lt;code&gt;execute()&lt;/code&gt;&lt;/a&gt; method to perform SQL commands:</source>
          <target state="translated">당신은 일단 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , 당신은 만들 수 &lt;a href=&quot;#sqlite3.Cursor&quot;&gt; &lt;code&gt;Cursor&lt;/code&gt; &lt;/a&gt; 오브젝트를하고 전화를 &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt; &lt;code&gt;execute()&lt;/code&gt; &lt;/a&gt; SQL 명령을 수행하는 방법 :</target>
        </trans-unit>
        <trans-unit id="81002ef1c052dbc9b87479ed00026cc46e6b7f55" translate="yes" xml:space="preserve">
          <source>Once you have a DOM document object, you can access the parts of your XML document through its properties and methods. These properties are defined in the DOM specification. The main property of the document object is the &lt;code&gt;documentElement&lt;/code&gt; property. It gives you the main element in the XML document: the one that holds all others. Here is an example program:</source>
          <target state="translated">DOM 문서 객체가 있으면 속성 및 메서드를 통해 XML 문서의 일부에 액세스 할 수 있습니다. 이러한 속성은 DOM 사양에 정의되어 있습니다. 문서 객체의 주요 속성은 &lt;code&gt;documentElement&lt;/code&gt; 속성입니다. XML 문서의 주요 요소 인 다른 모든 요소를 ​​포함합니다. 예제 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="570eb1dd3b2dc9c9893e632a6855fcb1892d470f" translate="yes" xml:space="preserve">
          <source>Once you have a DOM document object, you can access the parts of your XML document through its properties and methods. These properties are defined in the DOM specification; this portion of the reference manual describes the interpretation of the specification in Python.</source>
          <target state="translated">DOM 문서 객체가 있으면 속성 및 메서드를 통해 XML 문서의 일부에 액세스 할 수 있습니다. 이러한 속성은 DOM 사양에 정의되어 있습니다. 참조 매뉴얼의이 부분은 파이썬 사양의 해석을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="50a39d682c8b293bc2c1a0cd3988cb1316472ae2" translate="yes" xml:space="preserve">
          <source>Once you have the file, you can also read its contents:</source>
          <target state="translated">파일이 있으면 내용을 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f7ff6936f08d9dafa27c2a7c0ea9ece2945b6a" translate="yes" xml:space="preserve">
          <source>One can also cause all warnings to be exceptions by using &lt;code&gt;error&lt;/code&gt; instead of &lt;code&gt;always&lt;/code&gt;. One thing to be aware of is that if a warning has already been raised because of a &lt;code&gt;once&lt;/code&gt;/&lt;code&gt;default&lt;/code&gt; rule, then no matter what filters are set the warning will not be seen again unless the warnings registry related to the warning has been cleared.</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 대신 &lt;code&gt;error&lt;/code&gt; 를 사용하여 모든 경고를 예외로 만들 수도 있습니다 . 주의해야 할 한 가지 경고가 이미 때문에로 제기되고있는 경우입니다 &lt;code&gt;once&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 규칙, 다음에는 경고가 해제 된 경고에 관련된 레지스트리를 제외 필터는 경고가 다시 볼 수 없습니다 설정 무슨 상관.</target>
        </trans-unit>
        <trans-unit id="412f97dfac468fe3c85abdccb1436f3c6754c211" translate="yes" xml:space="preserve">
          <source>One can create a pool of processes which will carry out tasks submitted to it with the &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 클래스로 제출 된 작업을 수행 할 프로세스 풀을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ad735603768448e20a288aa471831e1d3bf88e6" translate="yes" xml:space="preserve">
          <source>One class, &lt;a href=&quot;#http.server.HTTPServer&quot;&gt;&lt;code&gt;HTTPServer&lt;/code&gt;&lt;/a&gt;, is a &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt;&lt;code&gt;socketserver.TCPServer&lt;/code&gt;&lt;/a&gt; subclass. It creates and listens at the HTTP socket, dispatching the requests to a handler. Code to create and run the server looks like this:</source>
          <target state="translated">하나의 클래스 인 &lt;a href=&quot;#http.server.HTTPServer&quot;&gt; &lt;code&gt;HTTPServer&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt; &lt;code&gt;socketserver.TCPServer&lt;/code&gt; &lt;/a&gt; 서브 클래스입니다. HTTP 소켓을 작성하고 청취하여 요청을 핸들러로 디스패치합니다. 서버를 만들고 실행하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7087184633e7181831a047d644ec560eea655368" translate="yes" xml:space="preserve">
          <source>One client can access the server as follows:</source>
          <target state="translated">한 클라이언트가 다음과 같이 서버에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d4ef3d17dad8ff1ba572aeda5566878ba2d3416" translate="yes" xml:space="preserve">
          <source>One difference between this module and Henstridge&amp;rsquo;s: his catalog objects supported access through a mapping API, but this appears to be unused and so is not currently supported.</source>
          <target state="translated">이 모듈과 Henstridge와의 한 가지 차이점 : 카탈로그 객체는 매핑 API를 통한 액세스를 지원했지만 사용되지 않은 것으로 보이므로 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5763c2d1a6c833df6c8067ce7085ffa547578913" translate="yes" xml:space="preserve">
          <source>One downside of these convenience functions is that the need to handle both IPv4 and IPv6 formats means that error messages provide minimal information on the precise error, as the functions don&amp;rsquo;t know whether the IPv4 or IPv6 format was intended. More detailed error reporting can be obtained by calling the appropriate version specific class constructors directly.</source>
          <target state="translated">이러한 편의 기능 중 하나의 단점은 IPv4 및 IPv6 형식을 모두 처리해야한다는 것은 오류 메시지가 정확한 오류에 대한 정보를 최소한으로 제공한다는 것을 의미합니다. 기능은 IPv4 또는 IPv6 형식의 의도 여부를 알 수 없기 때문입니다. 적절한 버전 별 클래스 생성자를 직접 호출하여보다 자세한 오류보고를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3b96d4bd51e1e6c79ce329a792e822561bb377" translate="yes" xml:space="preserve">
          <source>One exception is defined as an attribute of the &lt;a href=&quot;#module-poplib&quot;&gt;&lt;code&gt;poplib&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-poplib&quot;&gt; &lt;code&gt;poplib&lt;/code&gt; &lt;/a&gt; 모듈 의 속성으로 한 가지 예외가 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="a72557fcbc3e55ff795f503fb908c1ad3cb3e7c3" translate="yes" xml:space="preserve">
          <source>One limitation has to do with accuracy of timing information. There is a fundamental problem with deterministic profilers involving accuracy. The most obvious restriction is that the underlying &amp;ldquo;clock&amp;rdquo; is only ticking at a rate (typically) of about .001 seconds. Hence no measurements will be more accurate than the underlying clock. If enough measurements are taken, then the &amp;ldquo;error&amp;rdquo; will tend to average out. Unfortunately, removing this first error induces a second source of error.</source>
          <target state="translated">타이밍 정보의 정확성과 관련하여 한 가지 제한이 있습니다. 정확성과 관련된 결정 론적 프로파일 러에는 근본적인 문제가 있습니다. 가장 명백한 제한은 기본 &quot;시계&quot;가 (일반적으로) 약 .001 초의 속도로만 똑딱 거리는 것입니다. 따라서 기본 클럭보다 더 정확한 측정은 없습니다. 충분한 측정을 수행하면 &quot;오류&quot;가 평균이되는 경향이 있습니다. 불행히도이 첫 번째 오류를 제거하면 두 번째 오류 원인이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d30662d8771fa11b0017b4d40f87263cc12f04c" translate="yes" xml:space="preserve">
          <source>One method needs to be defined for container objects to provide iteration support:</source>
          <target state="translated">반복 지원을 제공하기 위해 컨테이너 객체에 대해 한 가지 방법을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c275e97c9c5002e886d7fe72ea350785b0233d2a" translate="yes" xml:space="preserve">
          <source>One more support function is also defined:</source>
          <target state="translated">지원 기능이 하나 더 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c0248d0f5b644a8ee6869c9c83e50620e88604" translate="yes" xml:space="preserve">
          <source>One more than the number of the highest signal number.</source>
          <target state="translated">가장 높은 신호 번호보다 하나 더.</target>
        </trans-unit>
        <trans-unit id="b14b841456d54340be37e877cf490ede6a8dc178" translate="yes" xml:space="preserve">
          <source>One more thing to be aware of is that the parser-level &lt;code&gt;get()&lt;/code&gt; method provides a custom, more complex interface, maintained for backwards compatibility. When using this method, a fallback value can be provided via the &lt;code&gt;fallback&lt;/code&gt; keyword-only argument:</source>
          <target state="translated">알아 두어야 할 또 다른 사항은 파서 레벨 &lt;code&gt;get()&lt;/code&gt; 메소드가 이전 버전과의 호환성을 위해 유지되는보다 복잡한 사용자 정의 인터페이스를 제공한다는 것입니다. 이 방법을 사용할 때 &lt;code&gt;fallback&lt;/code&gt; 키워드 전용 인수 를 통해 폴백 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dad841e0c8793fb2acecc194fc87215ceb56552" translate="yes" xml:space="preserve">
          <source>One needs to call this function straight after the &lt;code&gt;if __name__ ==
'__main__'&lt;/code&gt; line of the main module. For example:</source>
          <target state="translated">메인 모듈 의 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 줄 바로 다음에이 함수를 호출해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c23c4fd93b19eb8a93ad4ea94f5022d7dccf40a4" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;determinate&amp;rdquo; or &amp;ldquo;indeterminate&amp;rdquo;.</source>
          <target state="translated">&quot;결정적&quot;또는 &quot;불확정 적&quot;중 하나.</target>
        </trans-unit>
        <trans-unit id="792368d2ec0cc35704b6cdade00d87e0b1b51091" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;horizontal&amp;rdquo; or &amp;ldquo;vertical&amp;rdquo;. Specifies the orientation of the progress bar.</source>
          <target state="translated">&quot;가로&quot;또는 &quot;세로&quot;중 하나입니다. 진행률 표시 줄의 방향을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="413c6ea48d40de27918453c5164fccb674e90d4c" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;horizontal&amp;rdquo; or &amp;ldquo;vertical&amp;rdquo;. Specifies the orientation of the separator.</source>
          <target state="translated">&quot;가로&quot;또는 &quot;세로&quot;중 하나입니다. 구분 기호의 방향을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="76cba3ca26e12a80e4964b3cd3c4c38e4f3792c1" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;readonly&amp;rdquo;, or &amp;ldquo;disabled&amp;rdquo;. In the &amp;ldquo;readonly&amp;rdquo; state, the value may not be edited directly, and the user can only selection of the values from the dropdown list. In the &amp;ldquo;normal&amp;rdquo; state, the text field is directly editable. In the &amp;ldquo;disabled&amp;rdquo; state, no interaction is possible.</source>
          <target state="translated">&quot;정상&quot;, &quot;읽기 전용&quot;또는 &quot;비활성화&quot;중 하나입니다. &quot;읽기 전용&quot;상태에서는 값을 직접 편집 할 수 없으며 사용자는 드롭 다운 목록에서 값만 선택할 수 있습니다. &quot;정상&quot;상태에서는 텍스트 필드를 직접 편집 할 수 있습니다. &quot;비활성화 됨&quot;상태에서는 상호 작용이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="b71680b34169ae274a157ce0f891fed86a995ab7" translate="yes" xml:space="preserve">
          <source>One of the more common uses of &lt;code&gt;nargs='?'&lt;/code&gt; is to allow optional input and output files:</source>
          <target state="translated">&lt;code&gt;nargs='?'&lt;/code&gt; 의 더 일반적인 용도 중 하나 선택적 입력 및 출력 파일을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b55b53653ecf6bdee05bb4d9db6dde58eb35a46" translate="yes" xml:space="preserve">
          <source>One of the most common tasks is to generate the flat (serialized) version of the email message represented by a message object structure. You will need to do this if you want to send your message via &lt;a href=&quot;smtplib#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;smtplib.SMTP.sendmail()&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;nntplib#module-nntplib&quot;&gt;&lt;code&gt;nntplib&lt;/code&gt;&lt;/a&gt; module, or print the message on the console. Taking a message object structure and producing a serialized representation is the job of the generator classes.</source>
          <target state="translated">가장 일반적인 작업 중 하나는 메시지 개체 구조로 표시되는 전자 메일 메시지의 플랫 (직렬화 된) 버전을 생성하는 것입니다. &lt;a href=&quot;smtplib#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;smtplib.SMTP.sendmail()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;nntplib#module-nntplib&quot;&gt; &lt;code&gt;nntplib&lt;/code&gt; &lt;/a&gt; 모듈을 통해 메시지를 보내 거나 콘솔에서 메시지를 인쇄하려면 이 작업을 수행해야합니다 . 메시지 객체 구조를 취하고 직렬화 된 표현을 생성하는 것은 생성기 클래스의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="93c09cddaf4af85bdb82c014ec742b6b5d02f54f" translate="yes" xml:space="preserve">
          <source>One of two places where &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; actually inspects the type of a field is to determine if a field is a class variable as defined in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;. It does this by checking if the type of the field is &lt;code&gt;typing.ClassVar&lt;/code&gt;. If a field is a &lt;code&gt;ClassVar&lt;/code&gt;, it is excluded from consideration as a field and is ignored by the dataclass mechanisms. Such &lt;code&gt;ClassVar&lt;/code&gt; pseudo-fields are not returned by the module-level &lt;a href=&quot;#dataclasses.fields&quot;&gt;&lt;code&gt;fields()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 실제로 필드의 유형을 검사하는 두 곳 중 하나는 필드가 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 526에&lt;/strong&gt;&lt;/a&gt; 정의 된 클래스 변수인지 확인하는 것입니다 . 필드 유형이 &lt;code&gt;typing.ClassVar&lt;/code&gt; 인지 확인하여이를 수행합니다 . 필드가 &lt;code&gt;ClassVar&lt;/code&gt; 인 경우 필드로 간주되지 않고 데이터 클래스 메커니즘에서 무시됩니다. 이러한 &lt;code&gt;ClassVar&lt;/code&gt; 의사 필드는 모듈 수준 &lt;a href=&quot;#dataclasses.fields&quot;&gt; &lt;code&gt;fields()&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b4fa5b092d960caa5c98eb1763a721595959c032" translate="yes" xml:space="preserve">
          <source>One particularly effective way of handling sub-commands is to combine the use of the &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt;&lt;code&gt;add_subparsers()&lt;/code&gt;&lt;/a&gt; method with calls to &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt;&lt;code&gt;set_defaults()&lt;/code&gt;&lt;/a&gt; so that each subparser knows which Python function it should execute. For example:</source>
          <target state="translated">하위 명령을 처리하는 특히 효과적인 방법 중 하나는 &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt; &lt;code&gt;add_subparsers()&lt;/code&gt; &lt;/a&gt; 메서드를 &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt; &lt;code&gt;set_defaults()&lt;/code&gt; &lt;/a&gt; 호출과 결합하여 각 하위 구문 분석기가 실행할 Python 함수를 알 수 있도록하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6265c9633edbf23fb81d92e275200b17517c24ee" translate="yes" xml:space="preserve">
          <source>One possible reason to set &lt;code&gt;hash=False&lt;/code&gt; but &lt;code&gt;compare=True&lt;/code&gt; would be if a field is expensive to compute a hash value for, that field is needed for equality testing, and there are other fields that contribute to the type&amp;rsquo;s hash value. Even if a field is excluded from the hash, it will still be used for comparisons.</source>
          <target state="translated">&lt;code&gt;hash=False&lt;/code&gt; 이지만 &lt;code&gt;compare=True&lt;/code&gt; = 참을 설정하는 한 가지 가능한 이유 는 필드가 해시 값을 계산하는 데 비용이 많이 들고, 해당 필드가 동등성 테스트에 필요하고 유형의 해시 값에 기여하는 다른 필드가 있기 때문입니다. 필드가 해시에서 제외 되더라도 여전히 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a226b0eaad4988e53ed4f880b8d7a128f07557e7" translate="yes" xml:space="preserve">
          <source>One should just use a copy of the referent instead when making comparisons.</source>
          <target state="translated">비교할 때 참조의 사본을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c62e6f913693a5417011764c6f11e9c5f58e5593" translate="yes" xml:space="preserve">
          <source>One use case for this is for mocking objects used as context managers in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">이에 대한 사용 사례는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 컨텍스트 관리자로 사용되는 객체를 조롱하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="2db721d062a28eead2d894ec1cc32437698273d5" translate="yes" xml:space="preserve">
          <source>One useful application of the second form of &lt;a href=&quot;#iter&quot;&gt;&lt;code&gt;iter()&lt;/code&gt;&lt;/a&gt; is to build a block-reader. For example, reading fixed-width blocks from a binary database file until the end of file is reached:</source>
          <target state="translated">&lt;a href=&quot;#iter&quot;&gt; &lt;code&gt;iter()&lt;/code&gt; &lt;/a&gt; 의 두 번째 형식의 유용한 응용 프로그램 중 하나 는 블록 리더를 작성하는 것입니다. 예를 들어, 파일 끝에 도달 할 때까지 이진 데이터베이스 파일에서 고정 너비 블록을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="941e0e22f8b46e0572e23109cb229b556c8c68de" translate="yes" xml:space="preserve">
          <source>One useful feature of the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module is the built-in &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;sqlite3.Row&lt;/code&gt;&lt;/a&gt; class designed to be used as a row factory.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈 의 유용한 기능 중 하나 는 행 팩토리로 사용하도록 설계된 내장 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;sqlite3.Row&lt;/code&gt; &lt;/a&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="aaef7b6555dea31b8a999a49a168f126d8d8fdaf" translate="yes" xml:space="preserve">
          <source>One way to search and explore this XML example is to manually add the URI to every tag or attribute in the xpath of a &lt;a href=&quot;#xml.etree.ElementTree.Element.find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#xml.etree.ElementTree.Element.findall&quot;&gt;&lt;code&gt;findall()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 XML 예제를 검색하고 탐색하는 한 가지 방법은 &lt;a href=&quot;#xml.etree.ElementTree.Element.find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#xml.etree.ElementTree.Element.findall&quot;&gt; &lt;code&gt;findall()&lt;/code&gt; &lt;/a&gt; xpath의 모든 태그 또는 속성에 URI를 수동으로 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="685a8c4199bf6d2bcd91aafdcf97ef52c57e0bf8" translate="yes" xml:space="preserve">
          <source>One-dimensional memoryviews of hashable (read-only) types with formats &amp;lsquo;B&amp;rsquo;, &amp;lsquo;b&amp;rsquo; or &amp;lsquo;c&amp;rsquo; are also hashable. The hash is defined as &lt;code&gt;hash(m) == hash(m.tobytes())&lt;/code&gt;:</source>
          <target state="translated">형식이 'B', 'b'또는 'c'인 해시 가능 (읽기 전용) 유형의 1 차원 메모리 뷰도 해시 가능합니다. 해시는 &lt;code&gt;hash(m) == hash(m.tobytes())&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e2cd4c7e6f9d4fd20fd3009b486f148f36ad549" translate="yes" xml:space="preserve">
          <source>One-shot (de)compression</source>
          <target state="translated">원샷 (de) 압축</target>
        </trans-unit>
        <trans-unit id="e92a8f9a44d55a6fa57ab9d7f17030266d725e27" translate="yes" xml:space="preserve">
          <source>Online reference for tkinter supported by effbot.org.</source>
          <target state="translated">effbot.org에서 지원하는 tkinter에 대한 온라인 참조.</target>
        </trans-unit>
        <trans-unit id="9dbb8fb37052c67451fd1294542a0777a48cd714" translate="yes" xml:space="preserve">
          <source>Only &lt;em&gt;days&lt;/em&gt;, &lt;em&gt;seconds&lt;/em&gt; and &lt;em&gt;microseconds&lt;/em&gt; are stored internally. Arguments are converted to those units:</source>
          <target state="translated">&lt;em&gt;일&lt;/em&gt; , &lt;em&gt;초&lt;/em&gt; 및 &lt;em&gt;마이크로 &lt;/em&gt;&lt;em&gt;초&lt;/em&gt; 만 내부에 저장됩니다. 인수는 해당 단위로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e496096627294b6371ddb1a7da261de2d33baeed" translate="yes" xml:space="preserve">
          <source>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</source>
          <target state="translated">선언 된 소스 코드 인코딩에 관계없이 ASCII 문자 만 바이트 리터럴로 허용됩니다. 127 이상의 이진 값은 적절한 이스케이프 시퀀스를 사용하여 바이트 리터럴로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bcb0283c49f6302675a6e970eee6fdb45189e87" translate="yes" xml:space="preserve">
          <source>Only ASCII is supported. The &lt;code&gt;backslashreplace&lt;/code&gt; error handler is used on encoding.</source>
          <target state="translated">ASCII 만 지원됩니다. &lt;code&gt;backslashreplace&lt;/code&gt; 의 오류 처리기는 부호화에 사용된다.</target>
        </trans-unit>
        <trans-unit id="c6113a93896d56d6fd83ee494a739a1940a20027" translate="yes" xml:space="preserve">
          <source>Only authors of web servers and programming frameworks need to know every detail and corner case of the WSGI design. You don&amp;rsquo;t need to understand every detail of WSGI just to install a WSGI application or to write a web application using an existing framework.</source>
          <target state="translated">웹 서버 및 프로그래밍 프레임 워크 작성자 만 WSGI 디자인의 모든 세부 사항과 코너 사례를 알아야합니다. WSGI 응용 프로그램을 설치하거나 기존 프레임 워크를 사용하여 웹 응용 프로그램을 작성하기 위해 WSGI의 모든 세부 사항을 이해할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5472056d6db2aa4b4e5fca6b6d943ffdc4c17bf0" translate="yes" xml:space="preserve">
          <source>Only available on Windows.</source>
          <target state="translated">Windows에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9cff90a9caa5fca4e097eda23e08985099f6cbd6" translate="yes" xml:space="preserve">
          <source>Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 support, the method raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OpenSSL 1.1.1 및 TLS 1.3이 활성화 된 경우에만 사용 가능합니다. TLS 1.3 지원이 없으면이 메소드는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="62a51d86e2878cfb5387b455ada7f61c5dffd8a7" translate="yes" xml:space="preserve">
          <source>Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 support, the property value is None and can&amp;rsquo;t be modified</source>
          <target state="translated">OpenSSL 1.1.1 및 TLS 1.3이 활성화 된 경우에만 사용 가능합니다. TLS 1.3 지원이 없으면 특성 값은 없음이며 수정할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="95c159d38cefff4dfee104a391e7876c9172be62" translate="yes" xml:space="preserve">
          <source>Only call this method when the calling process or thread owns the lock. An &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is raised if this method is called by a process or thread other than the owner or if the lock is in an unlocked (unowned) state. Note that the type of exception raised in this situation differs from the implemented behavior in &lt;a href=&quot;threading#threading.RLock.release&quot;&gt;&lt;code&gt;threading.RLock.release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 프로세스 또는 스레드가 잠금을 소유 한 경우에만이 메소드를 호출하십시오. &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; 를는&lt;/a&gt; 이 메소드를 호출하는 방법에 의해 또는 소유자 이외의 스레드 경우 발생되거나 로크가 해제 (소유되지 않은) 상태 인 경우. 이 상황에서 발생한 예외 유형은 &lt;a href=&quot;threading#threading.RLock.release&quot;&gt; &lt;code&gt;threading.RLock.release()&lt;/code&gt; &lt;/a&gt; 에서 구현 된 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="a1b68642ddd76fe9bd27aab5c4134b933957a9b2" translate="yes" xml:space="preserve">
          <source>Only call this method when the calling thread owns the lock. A &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised if this method is called when the lock is unlocked.</source>
          <target state="translated">호출 스레드가 잠금을 소유 한 경우에만이 메소드를 호출하십시오. &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에는&lt;/a&gt; 잠금이 해제 될 때이 메소드가 불려 갔을 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb1874f752845c50ae749ab0610da40d6a9ed03f" translate="yes" xml:space="preserve">
          <source>Only class methods are defined by this class to alleviate the need for instantiation.</source>
          <target state="translated">이 클래스는 인스턴스화의 필요성을 완화하기 위해 클래스 메소드 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c3bad470e2ecc603718c76f4c9074b5de3a88646" translate="yes" xml:space="preserve">
          <source>Only docstrings attached to objects belonging to module &lt;em&gt;m&lt;/em&gt; are searched.</source>
          <target state="translated">모듈 &lt;em&gt;m에&lt;/em&gt; 속하는 오브젝트에 첨부 된 docstring 만 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="51af0077ba3cd9ef0693961e00abb68011fe16f6" translate="yes" xml:space="preserve">
          <source>Only on Mac OS X platform.</source>
          <target state="translated">Mac OS X 플랫폼에서만.</target>
        </trans-unit>
        <trans-unit id="4052b81eb936f003d4ae4d67da6755035d5b6d2c" translate="yes" xml:space="preserve">
          <source>Only on Windows platforms.</source>
          <target state="translated">Windows 플랫폼에서만.</target>
        </trans-unit>
        <trans-unit id="c739e35e3345aa2c864403c706892dacb2999ed6" translate="yes" xml:space="preserve">
          <source>Only one &lt;em&gt;ch&lt;/em&gt; can be pushed before &lt;code&gt;get_wch()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;get_wch()&lt;/code&gt; 가 호출 되기 전에 하나의 &lt;em&gt;ch&lt;/em&gt; 만 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a0fe79f0e31124b5d7fe36b8522ebf56951357a" translate="yes" xml:space="preserve">
          <source>Only one &lt;em&gt;ch&lt;/em&gt; can be pushed before &lt;code&gt;getch()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;getch()&lt;/code&gt; 가 호출 되기 전에 하나의 &lt;em&gt;ch&lt;/em&gt; 만 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bb6c14b3d23d2945eacea1ff6486fbffeceb261" translate="yes" xml:space="preserve">
          <source>Only one callback can be set per &lt;code&gt;SSLContext&lt;/code&gt;. If &lt;em&gt;sni_callback&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt; then the callback is disabled. Calling this function a subsequent time will disable the previously registered callback.</source>
          <target state="translated">&lt;code&gt;SSLContext&lt;/code&gt; 당 하나의 콜백 만 설정할 수 있습니다 . 경우 &lt;em&gt;sni_callback가&lt;/em&gt; 설정되어 &lt;code&gt;None&lt;/code&gt; 다음 콜백을 사용할 수 없습니다. 이 기능을 다음에 호출하면 이전에 등록 된 콜백이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="921877f46f6c2f6c956d4c2b43d413ed0f256f18" translate="yes" xml:space="preserve">
          <source>Only one concrete &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; class, is supplied by the &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module. The &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; class can represent simple timezones with fixed offsets from UTC, such as UTC itself or North American EST and EDT timezones. Supporting timezones at deeper levels of detail is up to the application. The rules for time adjustment across the world are more political than rational, change frequently, and there is no standard suitable for every application aside from UTC.</source>
          <target state="translated">하나의 구체적인 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 클래스의 &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 클래스는,에 의해 공급되는 &lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 모듈. &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 클래스는 UTC 자체 또는 북미 EST와 EDT 시간대 등 UTC에서 고정 오프셋, 간단한 시간대를 나타낼 수 있습니다. 더 자세한 수준의 시간대 지원은 응용 프로그램에 달려 있습니다. 전 세계의 시간 조정 규칙은 합리적보다 더 정치적이며 자주 변경되며 UTC 이외의 모든 응용 프로그램에 적합한 표준은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2694ff82c068ccb7ad25e6614404effc6e0e6dd" translate="yes" xml:space="preserve">
          <source>Only one stack frame is returned for a suspended coroutine.</source>
          <target state="translated">정지 된 코 루틴에 대해 하나의 스택 프레임 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="45899a65083753942e402707d87a02ef650b8c6b" translate="yes" xml:space="preserve">
          <source>Only run test methods and classes that match the pattern or substring. This option may be used multiple times, in which case all test cases that match of the given patterns are included.</source>
          <target state="translated">패턴 또는 하위 문자열과 일치하는 테스트 메소드 및 클래스 만 실행하십시오. 이 옵션은 여러 번 사용될 수 있으며,이 경우 주어진 패턴과 일치하는 모든 테스트 사례가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b86acce0e0c3ada12f44f0e9d2c197184c46af52" translate="yes" xml:space="preserve">
          <source>Only the directives specified in the documentation are supported. Because &lt;code&gt;strftime()&lt;/code&gt; is implemented per platform it can sometimes offer more directives than those listed. But &lt;code&gt;strptime()&lt;/code&gt; is independent of any platform and thus does not necessarily support all directives available that are not documented as supported.</source>
          <target state="translated">설명서에 지정된 지시문 만 지원됩니다. &lt;code&gt;strftime()&lt;/code&gt; 은 플랫폼마다 구현 되므로 때로는 나열된 것보다 많은 지시문을 제공 할 수 있습니다. 그러나 &lt;code&gt;strptime()&lt;/code&gt; 은 모든 플랫폼과 독립적이므로 지원되는 것으로 문서화되지 않은 사용 가능한 모든 지시문을 반드시 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="16dec77f10fe170dae724bd68005e7aa2cc49646" translate="yes" xml:space="preserve">
          <source>Only the filename, the function name and the line number are displayed. (no source code)</source>
          <target state="translated">파일 이름, 기능 이름 및 줄 번호 만 표시됩니다. (소스 코드 없음)</target>
        </trans-unit>
        <trans-unit id="60d352aab6fcb944b7fc146c1abce5b6e9d139b1" translate="yes" xml:space="preserve">
          <source>Only the memory consumption directly attributed to the object is accounted for, not the memory consumption of objects it refers to.</source>
          <target state="translated">객체에 직접 기여한 메모리 소비 만 설명하며, 객체의 메모리 소비는 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d182c5edf8d6af50c78e1101233e80d072394832" translate="yes" xml:space="preserve">
          <source>Only works for a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; which defines an &lt;code&gt;iter_modules()&lt;/code&gt; method. This interface is non-standard, so the module also provides implementations for &lt;a href=&quot;importlib#importlib.machinery.FileFinder&quot;&gt;&lt;code&gt;importlib.machinery.FileFinder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zipimport#zipimport.zipimporter&quot;&gt;&lt;code&gt;zipimport.zipimporter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iter_modules()&lt;/code&gt; 메소드 를 정의하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;파인더&lt;/a&gt; 에서만 작동합니다 . 이 인터페이스는 비표준이므로 모듈은 &lt;a href=&quot;importlib#importlib.machinery.FileFinder&quot;&gt; &lt;code&gt;importlib.machinery.FileFinder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zipimport#zipimport.zipimporter&quot;&gt; &lt;code&gt;zipimport.zipimporter&lt;/code&gt; &lt;/a&gt; 구현도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cce35e3b95640fdd8783117c0d6b1bb2575dc0c6" translate="yes" xml:space="preserve">
          <source>Only writeable with OpenSSL 1.1.0 or higher.</source>
          <target state="translated">OpenSSL 1.1.0 이상에서만 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c549906c5562588206324bfc20c815277d21a5" translate="yes" xml:space="preserve">
          <source>Opcode collections</source>
          <target state="translated">Opcode 컬렉션</target>
        </trans-unit>
        <trans-unit id="cf9b77061f7b3126b49d50a6fa68f7ca8c26b7a3" translate="yes" xml:space="preserve">
          <source>Open</source>
          <target state="translated">Open</target>
        </trans-unit>
        <trans-unit id="3fc17c6daa0379542d7b9c9064a83dc69e75bffb" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;file&lt;/em&gt; and return a corresponding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. If the file cannot be opened, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;파일을&lt;/em&gt; 열고 해당 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 . 파일을 열 수 없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0969da77d3b4939c7e92316eec745323136d4364" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;fullurl&lt;/em&gt; using the appropriate protocol. This method sets up cache and proxy information, then calls the appropriate open method with its input arguments. If the scheme is not recognized, &lt;a href=&quot;#urllib.request.URLopener.open_unknown&quot;&gt;&lt;code&gt;open_unknown()&lt;/code&gt;&lt;/a&gt; is called. The &lt;em&gt;data&lt;/em&gt; argument has the same meaning as the &lt;em&gt;data&lt;/em&gt; argument of &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열기 &lt;em&gt;fullurl&lt;/em&gt; 적절한 프로토콜을 사용. 이 메소드는 캐시 및 프록시 정보를 설정 한 다음 입력 인수로 적절한 open 메소드를 호출합니다. 체계가 인식되지 않으면 &lt;a href=&quot;#urllib.request.URLopener.open_unknown&quot;&gt; &lt;code&gt;open_unknown()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. &lt;em&gt;데이터&lt;/em&gt; 인수는 동일한 의미를 갖는 &lt;em&gt;데이터&lt;/em&gt; 의 인수 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea233b21029cc672f31fe9b3997814419601cd0" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new page (&amp;ldquo;tab&amp;rdquo;) of the browser handled by this controller, if possible, otherwise equivalent to &lt;a href=&quot;#webbrowser.open_new&quot;&gt;&lt;code&gt;open_new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가능한 경우이 컨트롤러가 처리하는 브라우저의 새 페이지 (&amp;ldquo;탭&amp;rdquo;)에서 &lt;em&gt;url&lt;/em&gt; 을 엽니 다 . 그렇지 않으면 &lt;a href=&quot;#webbrowser.open_new&quot;&gt; &lt;code&gt;open_new()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b6693c0a4bbf0ab0047e8b16619f81dc52e9dab4" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new page (&amp;ldquo;tab&amp;rdquo;) of the default browser, if possible, otherwise equivalent to &lt;a href=&quot;#webbrowser.open_new&quot;&gt;&lt;code&gt;open_new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가능한 경우 기본 브라우저의 새 페이지 (&amp;ldquo;탭&amp;rdquo;)에서 &lt;em&gt;url&lt;/em&gt; 을 엽니 다 . 그렇지 않으면 &lt;a href=&quot;#webbrowser.open_new&quot;&gt; &lt;code&gt;open_new()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b8866b21bed2f90c7e0d0db5d81720b7915e2396" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new window of the browser handled by this controller, if possible, otherwise, open &lt;em&gt;url&lt;/em&gt; in the only browser window. Alias &lt;a href=&quot;#webbrowser.open_new&quot;&gt;&lt;code&gt;open_new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열기 &lt;em&gt;URL을&lt;/em&gt; 가능하면 브라우저의 새 창에서, 그렇지 않으면,이 컨트롤러에 의해 개방 처리 &lt;em&gt;URL을&lt;/em&gt; 하는 유일한 브라우저 창에서. 별명 &lt;a href=&quot;#webbrowser.open_new&quot;&gt; &lt;code&gt;open_new()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80be1f0f5216d3c4d0013d4e332bf117ad7d0caf" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new window of the default browser, if possible, otherwise, open &lt;em&gt;url&lt;/em&gt; in the only browser window.</source>
          <target state="translated">열기 &lt;em&gt;URL&lt;/em&gt; 기본 브라우저의 새 창에서 가능하면, 그렇지 않으면 오픈 &lt;em&gt;URL&lt;/em&gt; 유일한 브라우저 창입니다.</target>
        </trans-unit>
        <trans-unit id="c004943ea8325dbad5b0898f3d806b2cc79ada2b" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt;. If open fails, raises &lt;a href=&quot;#test.support.TestFailed&quot;&gt;&lt;code&gt;TestFailed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;url을&lt;/em&gt; 엽니 다 . 열리지 않으면 &lt;a href=&quot;#test.support.TestFailed&quot;&gt; &lt;code&gt;TestFailed&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="167f647cfa354d55132f5f4c726947ab44e252e5" translate="yes" xml:space="preserve">
          <source>Open FTP URLs, keeping a cache of open FTP connections to minimize delays.</source>
          <target state="translated">지연 시간을 최소화하기 위해 열린 FTP 연결 캐시를 유지하는 열린 FTP URL</target>
        </trans-unit>
        <trans-unit id="8d287b03a85c8b0ae6a80daba6bfee69f5e82fba" translate="yes" xml:space="preserve">
          <source>Open FTP URLs.</source>
          <target state="translated">FTP URL을여십시오.</target>
        </trans-unit>
        <trans-unit id="83a9f9ab392f027e4bb05e016c0ac5b186fb79a0" translate="yes" xml:space="preserve">
          <source>Open Module&amp;hellip;</source>
          <target state="translated">모듈 열기&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0a169583e6466c4bfd610a1b2484012408457535" translate="yes" xml:space="preserve">
          <source>Open Sound System Programmer&amp;rsquo;s Guide</source>
          <target state="translated">개방형 사운드 시스템 프로그래머 안내서</target>
        </trans-unit>
        <trans-unit id="d650c621aed21d23bbb1a249e9d1ffa127b4a119" translate="yes" xml:space="preserve">
          <source>Open a &lt;code&gt;dumbdbm&lt;/code&gt; database and return a dumbdbm object. The &lt;em&gt;filename&lt;/em&gt; argument is the basename of the database file (without any specific extensions). When a dumbdbm database is created, files with &lt;code&gt;.dat&lt;/code&gt; and &lt;code&gt;.dir&lt;/code&gt; extensions are created.</source>
          <target state="translated">&lt;code&gt;dumbdbm&lt;/code&gt; 데이터베이스를 열고 dumbdbm 오브젝트를 리턴하십시오. &lt;em&gt;파일 이름&lt;/em&gt; 인수는 (특정 확장자없이) 데이터베이스 파일의 기본 이름입니다. dumbdbm 데이터베이스가 작성되면 확장자가 &lt;code&gt;.dat&lt;/code&gt; 및 &lt;code&gt;.dir&lt;/code&gt; 인 파일 이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e632fe179883b3d0338581a425671fd5094822ca" translate="yes" xml:space="preserve">
          <source>Open a &lt;code&gt;gdbm&lt;/code&gt; database and return a &lt;code&gt;gdbm&lt;/code&gt; object. The &lt;em&gt;filename&lt;/em&gt; argument is the name of the database file.</source>
          <target state="translated">&lt;code&gt;gdbm&lt;/code&gt; 데이터베이스를 열고 &lt;code&gt;gdbm&lt;/code&gt; 객체를 반환하십시오 . &lt;em&gt;파일 이름&lt;/em&gt; 인수는 데이터베이스 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4322583748a9c6421dfb4c09fcaf033d44e4d9da" translate="yes" xml:space="preserve">
          <source>Open a &lt;em&gt;stream&lt;/em&gt; of tar blocks for reading with transparent compression.</source>
          <target state="translated">투명한 압축으로 읽을 수 있도록 tar 블록 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="729abd50a19a9f17e3e7c4f19594ca97385dcc56" translate="yes" xml:space="preserve">
          <source>Open a &lt;em&gt;stream&lt;/em&gt; of uncompressed tar blocks for reading.</source>
          <target state="translated">읽을 압축되지 않은 tar 블록 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="0a595c5666012f5a73201a7ad3255c23528028d9" translate="yes" xml:space="preserve">
          <source>Open a TCP connection.</source>
          <target state="translated">TCP 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="dedbe01a1c7e4b40aa832642beeaa62e8071b7b2" translate="yes" xml:space="preserve">
          <source>Open a Unix socket connection.</source>
          <target state="translated">유닉스 소켓 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="c30333aca1528eaa7dec5dcc0b551102c76fb3bc" translate="yes" xml:space="preserve">
          <source>Open a ZIP file, where &lt;em&gt;file&lt;/em&gt; can be a path to a file (a string), a file-like object or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">ZIP 파일을 엽니 다. 여기서 &lt;em&gt;파일&lt;/em&gt; 은 &lt;em&gt;파일&lt;/em&gt; 의 경로 (문자열), 파일과 같은 객체 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은 객체 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="769e263af17bbeb1d57314125f9ccfea5fdf9008" translate="yes" xml:space="preserve">
          <source>Open a bzip2 compressed &lt;em&gt;stream&lt;/em&gt; for reading.</source>
          <target state="translated">읽을 bzip2 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="d71b74051ccf64b5252b5579fb9f29f5d65d41ae" translate="yes" xml:space="preserve">
          <source>Open a bzip2 compressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">쓰기 위해 bzip2 압축 &lt;em&gt;스트림&lt;/em&gt; 을여십시오.</target>
        </trans-unit>
        <trans-unit id="6c202a8f725c3966ee9eb45191a4f1f648fe6ef6" translate="yes" xml:space="preserve">
          <source>Open a bzip2-compressed file in binary mode.</source>
          <target state="translated">이진 모드에서 bzip2 압축 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="61e2bcd0c719fe1eff240cd130593bcf98e87f8b" translate="yes" xml:space="preserve">
          <source>Open a bzip2-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">bzip2 압축 파일을 이진 또는 텍스트 모드로 열고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="efeeb124691327df2e796c4e2f61fca215aaaf35" translate="yes" xml:space="preserve">
          <source>Open a column to the left of the edit window which shows the number of each line of text. The default is off, which may be changed in the preferences (see &lt;a href=&quot;#preferences&quot;&gt;Setting preferences&lt;/a&gt;).</source>
          <target state="translated">각 텍스트 줄 수를 표시하는 편집 창 왼쪽에서 열을 엽니 다. 기본값은 (참조 환경 설정에서 변경 될 수있는, 꺼져 &lt;a href=&quot;#preferences&quot;&gt;설정 기본 설정&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5138f8e4961bfac889560919d28c3273c8242a35" translate="yes" xml:space="preserve">
          <source>Open a configuration dialog and change preferences for the following: fonts, indentation, keybindings, text color themes, startup windows and size, additional help sources, and extensions. On macOS, open the configuration dialog by selecting Preferences in the application menu. For more details, see &lt;a href=&quot;#preferences&quot;&gt;Setting preferences&lt;/a&gt; under Help and preferences.</source>
          <target state="translated">구성 대화 상자를 열고 글꼴, 들여 쓰기, 키 바인딩, 텍스트 색상 테마, 시작 창 및 크기, 추가 도움말 소스 및 확장에 대한 환경 설정을 변경하십시오. macOS의 경우 응용 프로그램 메뉴에서 기본 설정을 선택하여 구성 대화 상자를여십시오. 자세한 내용은 도움말 및 환경 &lt;a href=&quot;#preferences&quot;&gt;설정에서 환경 설정 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb78ee95466565bc19aba0319a23cbc54a1f5a4d" translate="yes" xml:space="preserve">
          <source>Open a context menu by right-clicking in a window (Control-click on macOS). Context menus have the standard clipboard functions also on the Edit menu.</source>
          <target state="translated">윈도우에서 마우스 오른쪽 버튼을 클릭하여 상황에 맞는 메뉴를 엽니 다 (macOS에서 Control- 클릭). 상황에 맞는 메뉴에는 편집 메뉴에도 표준 클립 보드 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1364f2f6816d76d9a15863cac1e9715a393be440" translate="yes" xml:space="preserve">
          <source>Open a datagram (UDP) connection.</source>
          <target state="translated">데이터 그램 (UDP) 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="dab27c8f9d447246bffdf89284e45b057ad9df09" translate="yes" xml:space="preserve">
          <source>Open a dbm database and return a &lt;code&gt;ndbm&lt;/code&gt; object. The &lt;em&gt;filename&lt;/em&gt; argument is the name of the database file (without the &lt;code&gt;.dir&lt;/code&gt; or &lt;code&gt;.pag&lt;/code&gt; extensions).</source>
          <target state="translated">dbm 데이터베이스를 열고 &lt;code&gt;ndbm&lt;/code&gt; 오브젝트를 리턴하십시오 . &lt;em&gt;파일 이름&lt;/em&gt; 인수합니다 (없는 데이터베이스 파일의 이름입니다 &lt;code&gt;.dir&lt;/code&gt; 또는 &lt;code&gt;.pag&lt;/code&gt; 확장).</target>
        </trans-unit>
        <trans-unit id="da0ecd35b7e06e2e10631de386f9db741d263580" translate="yes" xml:space="preserve">
          <source>Open a dialog to change indent width. The accepted default by the Python community is 4 spaces.</source>
          <target state="translated">들여 쓰기 너비를 변경하려면 대화 상자를 엽니 다. Python 커뮤니티에서 허용되는 기본값은 4 개의 공백입니다.</target>
        </trans-unit>
        <trans-unit id="ab3cd1f4cf6f887a03a632cf57e13ad36b7a697f" translate="yes" xml:space="preserve">
          <source>Open a dialog to switch between indenting with spaces and tabs.</source>
          <target state="translated">공백과 탭 들여 쓰기 간을 전환하는 대화 상자를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a25e5b56a56e73584a7689c789c2a64cbda285d4" translate="yes" xml:space="preserve">
          <source>Open a file in read only mode using the encoding detected by &lt;a href=&quot;#tokenize.detect_encoding&quot;&gt;&lt;code&gt;detect_encoding()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#tokenize.detect_encoding&quot;&gt; &lt;code&gt;detect_encoding()&lt;/code&gt; &lt;/a&gt; 의해 감지 된 인코딩을 사용하여 파일을 읽기 전용 모드로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="37ab3730c8e04788612d761f24c638eb97873272" translate="yes" xml:space="preserve">
          <source>Open a file search dialog. Put results in a new output window.</source>
          <target state="translated">파일 검색 대화 상자를 엽니 다. 새로운 출력 창에 결과를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="2eb14a6fd323b13d0beb8b8c63d260dee2458311" translate="yes" xml:space="preserve">
          <source>Open a gzip compressed &lt;em&gt;stream&lt;/em&gt; for reading.</source>
          <target state="translated">읽을 gzip 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="58de51c83b15bd0a90eb56d615d749c080c0428e" translate="yes" xml:space="preserve">
          <source>Open a gzip compressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">쓰기 위해 gzip 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="5f9ebb796e4ce59f8458da340d1d52a456be5ef3" translate="yes" xml:space="preserve">
          <source>Open a gzip-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">바이너리 또는 텍스트 모드에서 gzip 압축 파일을 열고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="30c017ce0258307bd561cc1c740687ba59474f0b" translate="yes" xml:space="preserve">
          <source>Open a list of recent files. Click one to open it.</source>
          <target state="translated">최근 파일 목록을 엽니 다. 하나를 클릭하여 엽니 다.</target>
        </trans-unit>
        <trans-unit id="ca394801875e76928a12c9b6e408f346c581adf2" translate="yes" xml:space="preserve">
          <source>Open a mixer device and return an OSS mixer device object. &lt;em&gt;device&lt;/em&gt; is the mixer device filename to use. If it is not specified, this module first looks in the environment variable &lt;code id=&quot;index-1&quot;&gt;MIXERDEV&lt;/code&gt; for a device to use. If not found, it falls back to &lt;code&gt;/dev/mixer&lt;/code&gt;.</source>
          <target state="translated">믹서 장치를 열고 OSS 믹서 장치 개체를 반환하십시오. &lt;em&gt;device&lt;/em&gt; 는 사용할 믹서 장치 파일 이름입니다. 지정되지 않은 경우이 모듈은 먼저 환경 변수 &lt;code id=&quot;index-1&quot;&gt;MIXERDEV&lt;/code&gt; 에서 장치를 찾습니다 . 찾을 수 없으면 &lt;code&gt;/dev/mixer&lt;/code&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="124de94624e9d6235daba0288398e8d0eda77911" translate="yes" xml:space="preserve">
          <source>Open a new pseudo-terminal pair, using &lt;a href=&quot;os#os.openpty&quot;&gt;&lt;code&gt;os.openpty()&lt;/code&gt;&lt;/a&gt; if possible, or emulation code for generic Unix systems. Return a pair of file descriptors &lt;code&gt;(master, slave)&lt;/code&gt;, for the master and the slave end, respectively.</source>
          <target state="translated">가능한 경우 &lt;a href=&quot;os#os.openpty&quot;&gt; &lt;code&gt;os.openpty()&lt;/code&gt; &lt;/a&gt; 또는 일반 Unix 시스템의 에뮬레이션 코드를 사용하여 새로운 의사 터미널 쌍을 엽니 다 . 마스터 및 슬레이브 엔드에 대해 한 쌍의 파일 디스크립터 &lt;code&gt;(master, slave)&lt;/code&gt; 를 각각 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0f92982986d32cddede6d079b18b515667e6c40" translate="yes" xml:space="preserve">
          <source>Open a new pseudo-terminal pair. Return a pair of file descriptors &lt;code&gt;(master, slave)&lt;/code&gt; for the pty and the tty, respectively. The new file descriptors are &lt;a href=&quot;#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;. For a (slightly) more portable approach, use the &lt;a href=&quot;pty#module-pty&quot;&gt;&lt;code&gt;pty&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">새로운 의사 터미널 쌍을 엽니 다. pty 및 tty에 대한 파일 디스크립터 &lt;code&gt;(master, slave)&lt;/code&gt; 쌍을 각각 리턴하십시오 . 새로운 파일 기술자는 &lt;a href=&quot;#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; . 좀 더 휴대하기 편리한 방법으로 &lt;a href=&quot;pty#module-pty&quot;&gt; &lt;code&gt;pty&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="310ce69a8bca050de2aaf114ea01dff137cc8b62" translate="yes" xml:space="preserve">
          <source>Open a pane at the top of the edit window which shows the block context of the code which has scrolled above the top of the window. See &lt;a href=&quot;#code-context&quot;&gt;Code Context&lt;/a&gt; in the Editing and Navigation section below.</source>
          <target state="translated">창의 상단 위로 스크롤 된 코드의 블록 컨텍스트를 표시하는 편집 창의 상단에서 분할 창을여십시오. 아래의 편집 및 탐색 섹션에서 &lt;a href=&quot;#code-context&quot;&gt;코드 컨텍스트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="961144629087d810690a8c197d9838fead119d99" translate="yes" xml:space="preserve">
          <source>Open a persistent dictionary. The filename specified is the base filename for the underlying database. As a side-effect, an extension may be added to the filename and more than one file may be created. By default, the underlying database file is opened for reading and writing. The optional &lt;em&gt;flag&lt;/em&gt; parameter has the same interpretation as the &lt;em&gt;flag&lt;/em&gt; parameter of &lt;a href=&quot;dbm#dbm.open&quot;&gt;&lt;code&gt;dbm.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">영구 사전을 엽니 다. 지정된 파일 이름은 기본 데이터베이스의 기본 파일 이름입니다. 부작용으로 확장명이 파일 이름에 추가되고 둘 이상의 파일이 생성 될 수 있습니다. 기본적으로 기본 데이터베이스 파일은 읽고 쓰기 위해 열립니다. 선택적 &lt;em&gt;플래그&lt;/em&gt; 매개 변수는 &lt;a href=&quot;dbm#dbm.open&quot;&gt; &lt;code&gt;dbm.open()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;플래그&lt;/em&gt; 매개 변수 와 동일한 해석 을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="e30bcb19f1f39f996dce7f6ad300b894ce70b960" translate="yes" xml:space="preserve">
          <source>Open a pipe to or from command &lt;em&gt;cmd&lt;/em&gt;. The return value is an open file object connected to the pipe, which can be read or written depending on whether &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'r'&lt;/code&gt; (default) or &lt;code&gt;'w'&lt;/code&gt;. The &lt;em&gt;buffering&lt;/em&gt; argument has the same meaning as the corresponding argument to the built-in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. The returned file object reads or writes text strings rather than bytes.</source>
          <target state="translated">&lt;em&gt;cmd&lt;/em&gt; 명령으로 또는 파이프에서 파이프를여십시오 . 리턴 값은 파이프에 연결된 열린 파일 오브젝트 이며 &lt;em&gt;mode&lt;/em&gt; 가 &lt;code&gt;'r'&lt;/code&gt; (기본값) 또는 &lt;code&gt;'w'&lt;/code&gt; 인지에 따라 읽거나 쓸 수 있습니다 . &lt;em&gt;버퍼링&lt;/em&gt; 인수는 내장에 대응하는 인수와 같은 의미가 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수. 반환 된 파일 객체는 바이트가 아닌 텍스트 문자열을 읽거나 씁니다.</target>
        </trans-unit>
        <trans-unit id="e4303f9f37906dec81588a51089c928e75e68e4f" translate="yes" xml:space="preserve">
          <source>Open a scrollable list allowing selection of keywords and attributes. See &lt;a href=&quot;#completions&quot;&gt;Completions&lt;/a&gt; in the Editing and navigation section below.</source>
          <target state="translated">키워드 및 속성을 선택할 수있는 스크롤 가능 목록을 엽니 다. 아래의 편집 및 탐색 섹션에서 &lt;a href=&quot;#completions&quot;&gt;완료&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4217d0cef98e970f4e763e2abdcb21e0e9dba748" translate="yes" xml:space="preserve">
          <source>Open a search dialog with many options</source>
          <target state="translated">많은 옵션으로 검색 대화 상자를 엽니 다</target>
        </trans-unit>
        <trans-unit id="7d488b8ee4c8ad111ad3e0840a8cf0d33d625078" translate="yes" xml:space="preserve">
          <source>Open a search-and-replace dialog.</source>
          <target state="translated">찾기 및 바꾸기 대화 상자를여십시오.</target>
        </trans-unit>
        <trans-unit id="ff5f177e11975357dd6078d245cc9e65ff7d469c" translate="yes" xml:space="preserve">
          <source>Open a streaming transport connection to a given address specified by &lt;em&gt;host&lt;/em&gt; and &lt;em&gt;port&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;host&lt;/em&gt; 및 &lt;em&gt;port로&lt;/em&gt; 지정된 지정된 주소로 스트리밍 전송 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="1744e1544566dcdbef4e0123916bae4c8ecaef7a" translate="yes" xml:space="preserve">
          <source>Open an AIFF or AIFF-C file and return an object instance with methods that are described below. The argument &lt;em&gt;file&lt;/em&gt; is either a string naming a file or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. &lt;em&gt;mode&lt;/em&gt; must be &lt;code&gt;'r'&lt;/code&gt; or &lt;code&gt;'rb'&lt;/code&gt; when the file must be opened for reading, or &lt;code&gt;'w'&lt;/code&gt; or &lt;code&gt;'wb'&lt;/code&gt; when the file must be opened for writing. If omitted, &lt;code&gt;file.mode&lt;/code&gt; is used if it exists, otherwise &lt;code&gt;'rb'&lt;/code&gt; is used. When used for writing, the file object should be seekable, unless you know ahead of time how many samples you are going to write in total and use &lt;code&gt;writeframesraw()&lt;/code&gt; and &lt;code&gt;setnframes()&lt;/code&gt;. The &lt;a href=&quot;#aifc.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function may be used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. When the &lt;code&gt;with&lt;/code&gt; block completes, the &lt;a href=&quot;#aifc.aifc.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">AIFF 또는 AIFF-C 파일을 열고 아래 설명 된 방법으로 객체 인스턴스를 반환하십시오. 인수 &lt;em&gt;파일&lt;/em&gt; 은 &lt;em&gt;파일&lt;/em&gt; 이름을 지정하는 문자열이거나 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 입니다. 읽기 위해 파일을 열어야하는 경우 &lt;em&gt;mode&lt;/em&gt; 는 &lt;code&gt;'r'&lt;/code&gt; 또는 &lt;code&gt;'rb'&lt;/code&gt; 이거나 파일을 쓰기 위해 열어야하는 경우 &lt;code&gt;'w'&lt;/code&gt; 또는 &lt;code&gt;'wb'&lt;/code&gt; 여야합니다. 생략하면, &lt;code&gt;file.mode&lt;/code&gt; 가 있으면 사용되며 그렇지 않으면 &lt;code&gt;'rb'&lt;/code&gt; 가 사용됩니다. 쓰기에 사용될 때 총 몇 개의 샘플을 &lt;code&gt;writeframesraw()&lt;/code&gt; 미리 알고 writeframesraw () 및 &lt;code&gt;setnframes()&lt;/code&gt; 사용하지 않으면 파일 객체를 찾을 수 있어야합니다 . 그만큼&lt;a href=&quot;#aifc.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; ()&lt;/a&gt; 문에서 open () 함수를 사용할 수 있습니다. 경우 &lt;code&gt;with&lt;/code&gt; 블록 완료의&lt;a href=&quot;#aifc.aifc.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출된다.</target>
        </trans-unit>
        <trans-unit id="c826d14c450bf65432c928fcd0ab030434d46051" translate="yes" xml:space="preserve">
          <source>Open an LZMA-compressed file in binary mode.</source>
          <target state="translated">이진 모드에서 LZMA 압축 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e1faabe747c63d77a2b349aef83e34f029746298" translate="yes" xml:space="preserve">
          <source>Open an LZMA-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">이진 또는 텍스트 모드에서 LZMA 압축 파일을 열고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="63c9941ee4cb89d2d889eb4b86133c79f4dbfe23" translate="yes" xml:space="preserve">
          <source>Open an audio device and return an OSS audio device object. This object supports many file-like methods, such as &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;fileno()&lt;/code&gt; (although there are subtle differences between conventional Unix read/write semantics and those of OSS audio devices). It also supports a number of audio-specific methods; see below for the complete list of methods.</source>
          <target state="translated">오디오 장치를 열고 OSS 오디오 장치 개체를 반환하십시오. 이 객체는 &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;write()&lt;/code&gt; 및 &lt;code&gt;fileno()&lt;/code&gt; 와 같은 많은 파일과 유사한 메소드를 지원합니다 ( 기존의 Unix 읽기 / 쓰기 시맨틱과 OSS 오디오 장치의 미묘한 차이가 있지만). 또한 여러 가지 오디오 관련 방법을 지원합니다. 전체 방법 목록은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="603bc2bb14d64c97ed149bdeb1f454a0cdee6bdf" translate="yes" xml:space="preserve">
          <source>Open an encoded file using the given &lt;em&gt;mode&lt;/em&gt; and return an instance of &lt;a href=&quot;#codecs.StreamReaderWriter&quot;&gt;&lt;code&gt;StreamReaderWriter&lt;/code&gt;&lt;/a&gt;, providing transparent encoding/decoding. The default file mode is &lt;code&gt;'r'&lt;/code&gt;, meaning to open the file in read mode.</source>
          <target state="translated">주어진 &lt;em&gt;모드를&lt;/em&gt; 사용하여 인코딩 된 파일을 열고 투명한 인코딩 / 디코딩을 제공하는 &lt;a href=&quot;#codecs.StreamReaderWriter&quot;&gt; &lt;code&gt;StreamReaderWriter&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환합니다 . 기본 파일 모드는 &lt;code&gt;'r'&lt;/code&gt; 이며 파일을 읽기 모드로 여는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70e42698ff3f06e64e68df6dd8b37bb0b559281d" translate="yes" xml:space="preserve">
          <source>Open an existing file with an Open dialog.</source>
          <target state="translated">열기 대화 상자로 기존 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d98d15f410a1d6752590d2b11440fb75fb110d32" translate="yes" xml:space="preserve">
          <source>Open an existing module (searches sys.path).</source>
          <target state="translated">기존 모듈을 엽니 다 (sys.path 검색).</target>
        </trans-unit>
        <trans-unit id="0ee43539d00f6f0549ec54060b1769296318ac88" translate="yes" xml:space="preserve">
          <source>Open an lzma compressed &lt;em&gt;stream&lt;/em&gt; for reading.</source>
          <target state="translated">읽을 lzma 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="31602b490a7a64e6c2db5f868743fe69a5882ae0" translate="yes" xml:space="preserve">
          <source>Open an lzma compressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">쓰기 위해 lzma 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="079b069912678bc0e9edc918427fbb1c6c90a22d" translate="yes" xml:space="preserve">
          <source>Open an uncompressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">비 압축 &lt;em&gt;스트림&lt;/em&gt; 을 작성 하여 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="98a6f72f0f8ba4690a7074b4a4a5e9ed2745f83c" translate="yes" xml:space="preserve">
          <source>Open data URLs.</source>
          <target state="translated">열린 데이터 URL.</target>
        </trans-unit>
        <trans-unit id="16d266be663a4baf112aaf41a72a96cf96f3a372" translate="yes" xml:space="preserve">
          <source>Open database for reading and writing, creating it if it doesn&amp;rsquo;t exist</source>
          <target state="translated">읽기 및 쓰기를위한 데이터베이스를 열고 존재하지 않는 경우 생성</target>
        </trans-unit>
        <trans-unit id="781766b35fa1fffb57637176b0ab6b1592f6edda" translate="yes" xml:space="preserve">
          <source>Open existing database for reading and writing</source>
          <target state="translated">읽고 쓰는 기존 데이터베이스 열기</target>
        </trans-unit>
        <trans-unit id="410e2a4489d3a436b0413ceb110aca00b9d836e3" translate="yes" xml:space="preserve">
          <source>Open existing database for reading only (default)</source>
          <target state="translated">읽기 전용으로 기존 데이터베이스 열기 (기본값)</target>
        </trans-unit>
        <trans-unit id="da8803e86851bcbc32ed1a652aec62b5acaa7e27" translate="yes" xml:space="preserve">
          <source>Open for appending with no compression. The file is created if it does not exist.</source>
          <target state="translated">압축없이 추가하기 위해 엽니 다. 파일이 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a92945eaf20e290447e2fee4702651291e88a7a8" translate="yes" xml:space="preserve">
          <source>Open for binary reading the &lt;em&gt;resource&lt;/em&gt; within &lt;em&gt;package&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;패키지&lt;/em&gt; 내의 &lt;em&gt;리소스&lt;/em&gt; 를 바이너리로 읽을 수 있도록 엽니 다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d7a0fda614e078919dfeee281a77c3029b4cd8d" translate="yes" xml:space="preserve">
          <source>Open for bzip2 compressed writing.</source>
          <target state="translated">bzip2 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="3be0b1cac4b854897b77bfa1ac3644fca43d5aa8" translate="yes" xml:space="preserve">
          <source>Open for gzip compressed writing.</source>
          <target state="translated">gzip 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e4536676ca1a607495256d83de74122a14e9f319" translate="yes" xml:space="preserve">
          <source>Open for lzma compressed writing.</source>
          <target state="translated">lzma 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e39a5b6a548b20c25318d8a7703ff10916012921" translate="yes" xml:space="preserve">
          <source>Open for reading exclusively without compression.</source>
          <target state="translated">압축하지 않고 읽기 전용으로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="5d2a4b3378fdbc3be17d246022eb416831821745" translate="yes" xml:space="preserve">
          <source>Open for reading with bzip2 compression.</source>
          <target state="translated">bzip2 압축으로 읽기 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e27915e983e4971e83b72733d9272da24ed3062a" translate="yes" xml:space="preserve">
          <source>Open for reading with gzip compression.</source>
          <target state="translated">gzip 압축으로 읽기 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="2da82d3e5ef9f2ef062573cb554660a3c136498f" translate="yes" xml:space="preserve">
          <source>Open for reading with lzma compression.</source>
          <target state="translated">lzma 압축으로 읽기 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e3a348820cc41064f1578562b070372b25c805da" translate="yes" xml:space="preserve">
          <source>Open for reading with transparent compression (recommended).</source>
          <target state="translated">투명한 압축으로 읽기 위해 엽니 다 (권장).</target>
        </trans-unit>
        <trans-unit id="72bd4d78cdd6d40e6b66c653af1f6efc9092b2a0" translate="yes" xml:space="preserve">
          <source>Open for text reading the &lt;em&gt;resource&lt;/em&gt; within &lt;em&gt;package&lt;/em&gt;. By default, the resource is opened for reading as UTF-8.</source>
          <target state="translated">&lt;em&gt;패키지&lt;/em&gt; 내 에서 &lt;em&gt;리소스를&lt;/em&gt; 읽는 텍스트를 열려면 엽니 다 . 기본적으로 리소스는 UTF-8로 읽을 수 있도록 열립니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd33d2eb6cd4b2ececd950d2a289a68364e3b2" translate="yes" xml:space="preserve">
          <source>Open for uncompressed writing.</source>
          <target state="translated">비 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="2d5629e9c9ad86de82f582a75bd5aac184a32a98" translate="yes" xml:space="preserve">
          <source>Open local files.</source>
          <target state="translated">로컬 파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="c31d0d8dc1af57114456f8a6995200302c826647" translate="yes" xml:space="preserve">
          <source>Open or wake up the Python Shell window.</source>
          <target state="translated">Python Shell 창을 열거 나 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="64e54bad7370d9dd3ea7ce90f39c116822954b3f" translate="yes" xml:space="preserve">
          <source>Open the FTP file indicated by &lt;em&gt;req&lt;/em&gt;. The login is always done with empty username and password.</source>
          <target state="translated">&lt;em&gt;req로&lt;/em&gt; 표시된 FTP 파일을여십시오 . 로그인은 항상 빈 사용자 이름과 비밀번호로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf0ac9893ebd85b77099d4a402423ddf3e569c0" translate="yes" xml:space="preserve">
          <source>Open the URL &lt;em&gt;url&lt;/em&gt;, which can be either a string or a &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">문자열 또는 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 객체 일 수있는 URL &lt;em&gt;url을&lt;/em&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="a2f57839feb75512fa819cec149b3ca923d075ec" translate="yes" xml:space="preserve">
          <source>Open the database file &lt;em&gt;file&lt;/em&gt; and return a corresponding object.</source>
          <target state="translated">데이터베이스 파일 &lt;em&gt;파일을&lt;/em&gt; 열고 해당 오브젝트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9778684242145c7e5980545da5305f1a835b31fd" translate="yes" xml:space="preserve">
          <source>Open the database in fast mode. Writes to the database will not be synchronized.</source>
          <target state="translated">데이터베이스를 빠른 모드로 엽니 다. 데이터베이스에 대한 쓰기는 동기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dc0480d0f4224d0fb02e5967e073c791476447a" translate="yes" xml:space="preserve">
          <source>Open the file &lt;em&gt;path&lt;/em&gt; and set various flags according to &lt;em&gt;flags&lt;/em&gt; and possibly its mode according to &lt;em&gt;mode&lt;/em&gt;. When computing &lt;em&gt;mode&lt;/em&gt;, the current umask value is first masked out. Return the file descriptor for the newly opened file. The new file descriptor is &lt;a href=&quot;#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;.</source>
          <target state="translated">파일 열기 &lt;em&gt;경로&lt;/em&gt; 에 따라 설정하고 다양한 플래그 &lt;em&gt;플래그&lt;/em&gt; 와 가능성의 모드에 따라 &lt;em&gt;모드&lt;/em&gt; . 컴퓨팅 &lt;em&gt;모드&lt;/em&gt; 에서는 현재 umask 값이 먼저 마스킹됩니다. 새로 열린 파일의 파일 설명자를 반환합니다. 새로운 파일 기술자는 &lt;a href=&quot;#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caa52afce9506061d0fa4472348c0e95be91ed41" translate="yes" xml:space="preserve">
          <source>Open the file locally, if there is no host name, or the host name is &lt;code&gt;'localhost'&lt;/code&gt;.</source>
          <target state="translated">호스트 이름이 없거나 호스트 이름이 &lt;code&gt;'localhost'&lt;/code&gt; 인 경우 파일을 로컬로여십시오 .</target>
        </trans-unit>
        <trans-unit id="cfc513f94813f282c3c61b3a5c7b58c27fabbaa9" translate="yes" xml:space="preserve">
          <source>Open the file pointed to by the path, like the built-in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function does:</source>
          <target state="translated">내장 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수 처럼 경로가 가리키는 파일을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="5eba403538351b5c16610a19c57e8a8df88568dc" translate="yes" xml:space="preserve">
          <source>Open the file pointed to in bytes mode, write &lt;em&gt;data&lt;/em&gt; to it, and close the file:</source>
          <target state="translated">바이트 모드로 지정된 파일을 열고 &lt;em&gt;데이터&lt;/em&gt; 를 쓴 다음 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e701b16e8d36cd75f1fa0285568b0411ec651724" translate="yes" xml:space="preserve">
          <source>Open the file pointed to in text mode, write &lt;em&gt;data&lt;/em&gt; to it, and close the file:</source>
          <target state="translated">텍스트 모드에서 지정된 파일을 열고 &lt;em&gt;데이터&lt;/em&gt; 를 쓴 다음 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="89b97b71d7fce960991c7dd1c07e2cdaec524088" translate="yes" xml:space="preserve">
          <source>Open the given &lt;em&gt;url&lt;/em&gt; (which can be a request object or a string), optionally passing the given &lt;em&gt;data&lt;/em&gt;. Arguments, return values and exceptions raised are the same as those of &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt; (which simply calls the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; method on the currently installed global &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt;). The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). The timeout feature actually works only for HTTP, HTTPS and FTP connections).</source>
          <target state="translated">주어진 &lt;em&gt;url&lt;/em&gt; (요청 객체 또는 문자열 일 수 있음)을 열고 선택적으로 주어진 &lt;em&gt;data를&lt;/em&gt; 전달합니다 . 인수, 리턴 값 및 예외는 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 과 동일 합니다 (현재 설치된 글로벌 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 함 ). 선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수는 연결 시도와 같은 작업을 차단하기위한 시간 초과를 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간 초과 설정이 사용됨). 시간 초과 기능은 실제로 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5e1480c8605ef5bc7bd341fc4f6753a37e43a4d4" translate="yes" xml:space="preserve">
          <source>Open&amp;hellip;</source>
          <target state="translated">Open&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="01d60b1917be3088476a0cd4e28b367766a98677" translate="yes" xml:space="preserve">
          <source>OpenEXR Files</source>
          <target state="translated">OpenEXR 파일</target>
        </trans-unit>
        <trans-unit id="73728b14af6a4a2f3551f7cdac9f5c4d6228013b" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise &lt;a href=&quot;#ssl.SSLError&quot;&gt;&lt;code&gt;SSLError&lt;/code&gt;&lt;/a&gt; when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves like 1.0.2, &lt;a href=&quot;#ssl.SSLSocket.selected_alpn_protocol&quot;&gt;&lt;code&gt;SSLSocket.selected_alpn_protocol()&lt;/code&gt;&lt;/a&gt; returns None.</source>
          <target state="translated">OpenSSL 1.1.0-1.1.0e는 양측이 ALPN을 지원하지만 프로토콜에 동의 할 수없는 경우 핸드 셰이크를 중단하고 &lt;a href=&quot;#ssl.SSLError&quot;&gt; &lt;code&gt;SSLError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다. 1.1.0f +는 1.0.2처럼 동작하며 &lt;a href=&quot;#ssl.SSLSocket.selected_alpn_protocol&quot;&gt; &lt;code&gt;SSLSocket.selected_alpn_protocol()&lt;/code&gt; &lt;/a&gt; 은 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="608031ed74d99bf56acad6cfae3a559becd3fe58" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites cannot be disabled with &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;set_ciphers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OpenSSL 1.1.1에는 기본적으로 TLS 1.3 암호화 제품군이 활성화되어 있습니다. 스위트는 &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;set_ciphers()&lt;/code&gt; &lt;/a&gt; 로 비활성화 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="87910396f08c825fecd3572b61ad32564c05b34d" translate="yes" xml:space="preserve">
          <source>OpenerDirector Objects</source>
          <target state="translated">OpenerDirector 개체</target>
        </trans-unit>
        <trans-unit id="4fa7faa0fef5cd2e070617de5da06be08f27d93b" translate="yes" xml:space="preserve">
          <source>OpenerDirector objects open URLs in three stages:</source>
          <target state="translated">OpenerDirector 개체는 3 단계로 URL을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="16d066a3fc9b4ed5f9b17e3224ef371f27c42ab1" translate="yes" xml:space="preserve">
          <source>Opening a file:</source>
          <target state="translated">파일 열기 :</target>
        </trans-unit>
        <trans-unit id="3b13dba20249cec4bebcc1e50c72c68162719b5f" translate="yes" xml:space="preserve">
          <source>Opening network connections</source>
          <target state="translated">네트워크 연결 열기</target>
        </trans-unit>
        <trans-unit id="2e4955dc64b4b6a99ad04615254b1e5dbed12175" translate="yes" xml:space="preserve">
          <source>Opens a connection to the SQLite database file &lt;em&gt;database&lt;/em&gt;. By default returns a &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; object, unless a custom &lt;em&gt;factory&lt;/em&gt; is given.</source>
          <target state="translated">SQLite 데이터베이스 파일 &lt;em&gt;데이터베이스에&lt;/em&gt; 대한 연결을 엽니 다 . 사용자 정의 &lt;em&gt;팩토리&lt;/em&gt; 가 제공 되지 않은 경우 기본적으로 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 객체가 반환 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85224a398354ea36e289250e0f429ab80eb410a3" translate="yes" xml:space="preserve">
          <source>Opens a new element. &lt;em&gt;tag&lt;/em&gt; is the element name. &lt;em&gt;attrs&lt;/em&gt; is a dictionary containing element attributes. Returns the opened element.</source>
          <target state="translated">새로운 요소를 엽니 다. &lt;em&gt;태그&lt;/em&gt; 는 요소 이름입니다. &lt;em&gt;attrs&lt;/em&gt; 는 요소 속성을 포함하는 사전입니다. 열린 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aabf2727e8cb0ec31b954ad851960d268b7966e2" translate="yes" xml:space="preserve">
          <source>Opens socket to &lt;em&gt;port&lt;/em&gt; at &lt;em&gt;host&lt;/em&gt;. This method is implicitly called by the &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt; constructor. The connection objects established by this method will be used in the &lt;a href=&quot;#imaplib.IMAP4.read&quot;&gt;&lt;code&gt;IMAP4.read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#imaplib.IMAP4.readline&quot;&gt;&lt;code&gt;IMAP4.readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#imaplib.IMAP4.send&quot;&gt;&lt;code&gt;IMAP4.send()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#imaplib.IMAP4.shutdown&quot;&gt;&lt;code&gt;IMAP4.shutdown()&lt;/code&gt;&lt;/a&gt; methods. You may override this method.</source>
          <target state="translated">&lt;em&gt;호스트&lt;/em&gt; 에서 &lt;em&gt;포트&lt;/em&gt; 로 소켓을 엽니 다 . 이 메소드는 &lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; &lt;/a&gt; 생성자에 의해 내재적으로 호출됩니다 . 이 메소드로 설정된 연결 오브젝트는 &lt;a href=&quot;#imaplib.IMAP4.read&quot;&gt; &lt;code&gt;IMAP4.read()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#imaplib.IMAP4.readline&quot;&gt; &lt;code&gt;IMAP4.readline()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#imaplib.IMAP4.send&quot;&gt; &lt;code&gt;IMAP4.send()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#imaplib.IMAP4.shutdown&quot;&gt; &lt;code&gt;IMAP4.shutdown()&lt;/code&gt; &lt;/a&gt; 메소드에서 사용됩니다. 이 방법을 무시할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="525d07220d0ff4234fa0ad51dedfb34d53d57012" translate="yes" xml:space="preserve">
          <source>Opens the provided file with mode &lt;code&gt;'rb'&lt;/code&gt;. This function should be used when the intent is to treat the contents as executable code.</source>
          <target state="translated">제공된 파일을 &lt;code&gt;'rb'&lt;/code&gt; 모드로 엽니 다 . 이 기능은 내용을 실행 코드로 취급하려는 경우에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="413464a07680bc80891d442ceee2443c353ed2dd" translate="yes" xml:space="preserve">
          <source>Opens the specified key, returning a &lt;a href=&quot;#handle-object&quot;&gt;handle object&lt;/a&gt;.</source>
          <target state="translated">지정된 키를 열고 &lt;a href=&quot;#handle-object&quot;&gt;핸들 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e5ba86326755952233b0543acced2995e5faf457" translate="yes" xml:space="preserve">
          <source>Operating System</source>
          <target state="translated">운영 체제</target>
        </trans-unit>
        <trans-unit id="8c04dd154019c144217096dfd3976827b05133f0" translate="yes" xml:space="preserve">
          <source>Operating system interfaces, including functions to work with files at a lower level than Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;.</source>
          <target state="translated">파이썬보다 낮은 수준의 파일 작업에 대한 기능을 포함한 시스템 인터페이스, 운영 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="0fc51a5c314382c855158eda38ff5409a7e69535" translate="yes" xml:space="preserve">
          <source>Operation already in progress</source>
          <target state="translated">이미 진행중인 작업</target>
        </trans-unit>
        <trans-unit id="25ef925607b43bca64c3829868d9989b76540d3a" translate="yes" xml:space="preserve">
          <source>Operation not permitted</source>
          <target state="translated">작동이 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="43a0d8034edc13c8132ddaa1b799ae87a6565b50" translate="yes" xml:space="preserve">
          <source>Operation not supported on transport endpoint</source>
          <target state="translated">전송 끝점에서 지원되지 않는 작업</target>
        </trans-unit>
        <trans-unit id="8fdc938d87d0b18a567701392c335d0c883fa4b7" translate="yes" xml:space="preserve">
          <source>Operation now in progress</source>
          <target state="translated">현재 진행중인 작업</target>
        </trans-unit>
        <trans-unit id="db648ff618df972b87b0f378a6996fcda48575ee" translate="yes" xml:space="preserve">
          <source>Operation would block</source>
          <target state="translated">작업 차단</target>
        </trans-unit>
        <trans-unit id="3f36c3736abf81762323dd82f7d22a61738746fb" translate="yes" xml:space="preserve">
          <source>Operations and built-in functions that have a Boolean result always return &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; for false and &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt; for true, unless otherwise stated. (Important exception: the Boolean operations &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; always return one of their operands.)</source>
          <target state="translated">부울 결과가있는 연산 및 내장 함수는 달리 명시되지 않는 한 항상 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 를 false로, &lt;code&gt;1&lt;/code&gt; 을 true 또는 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. (중요 예외 : 부울 작업 &lt;code&gt;or&lt;/code&gt; 하고 &lt;code&gt;and&lt;/code&gt; 항상 피연산자 중 하나를 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="b0a2a652140b72b9707efca49f6096fb106713ee" translate="yes" xml:space="preserve">
          <source>Operations are used as methods. Since the DOM uses only &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; parameters, the arguments are passed in normal order (from left to right). There are no optional arguments. &lt;code&gt;void&lt;/code&gt; operations return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">작업은 방법으로 사용됩니다. DOM을만을 사용하므로 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 파라미터 (왼쪽에서 오른쪽)에서, 인수는 정상적인 순서로 전달된다. 선택적 인수가 없습니다. &lt;code&gt;void&lt;/code&gt; 연산은 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5842137c602e8b1e20079af1475196379c2bc7a2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+=&lt;/code&gt; which involve a read and write are not atomic. So if, for instance, you want to atomically increment a shared value it is insufficient to just do</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; 와 같은 연산읽기와 쓰기를 포함하는 은 원 자성이 아닙니다. 예를 들어 공유 값을 원자 적으로 증분하려는 경우에는 수행하기에 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f419c43f2273d35c973397ffc8873fd0cff6d1f6" translate="yes" xml:space="preserve">
          <source>Operations which work with sequences (some of them with mappings too) include:</source>
          <target state="translated">시퀀스로 작업하는 작업 (일부 매핑도 해당)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="c431496d10314a298eb196699644e449631b5f2f" translate="yes" xml:space="preserve">
          <source>Option Flags</source>
          <target state="translated">옵션 플래그</target>
        </trans-unit>
        <trans-unit id="e495fe30fe845f1d5517bc35c9d0601fa416e0f7" translate="yes" xml:space="preserve">
          <source>Option for &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt;. This value indicates that the context may be used to authenticate Web clients (therefore, it will be used to create server-side sockets).</source>
          <target state="translated">&lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 옵션입니다 . 이 값은 컨텍스트가 웹 클라이언트를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 서버 측 소켓을 작성하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="0ed5f390cd43fec0c1a9f5e969163e9713365adc" translate="yes" xml:space="preserve">
          <source>Option for &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt;. This value indicates that the context may be used to authenticate Web servers (therefore, it will be used to create client-side sockets).</source>
          <target state="translated">&lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 옵션입니다 . 이 값은 컨텍스트가 웹 서버를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 클라이언트 측 소켓을 작성하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="1dc214003b5cc3f6b308d940b627561092a1f7c2" translate="yes" xml:space="preserve">
          <source>Option value syntax</source>
          <target state="translated">옵션 값 구문</target>
        </trans-unit>
        <trans-unit id="0877ad74bf360dfde627563dd4aa4b01f6ce3129" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_encoder&lt;/em&gt; is a callable (i.e. function) which will perform the actual encoding of the audio data for transport. This callable takes one argument, which is the &lt;a href=&quot;#email.mime.audio.MIMEAudio&quot;&gt;&lt;code&gt;MIMEAudio&lt;/code&gt;&lt;/a&gt; instance. It should use &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt;&lt;code&gt;set_payload()&lt;/code&gt;&lt;/a&gt; to change the payload to encoded form. It should also add any &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; or other headers to the message object as necessary. The default encoding is base64. See the &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt;&lt;code&gt;email.encoders&lt;/code&gt;&lt;/a&gt; module for a list of the built-in encoders.</source>
          <target state="translated">선택적인 &lt;em&gt;_encoder&lt;/em&gt; 는 호출 가능한 오디오 기능의 실제 인코딩을 수행하는 호출 가능 (즉, 기능)입니다. 이 콜 &lt;a href=&quot;#email.mime.audio.MIMEAudio&quot;&gt; &lt;code&gt;MIMEAudio&lt;/code&gt; &lt;/a&gt; 은 하나의 인수, 즉 MIMEAudio 인스턴스를 취 합니다. 페이로드를 인코딩 된 형식으로 변경 하려면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt; &lt;code&gt;set_payload()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 필요에 따라 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 또는 기타 헤더를 ​​메시지 객체에 추가해야합니다. 기본 인코딩은 base64입니다. 내장 인코더 목록은 &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt; &lt;code&gt;email.encoders&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea5df2800bbbbd80f815acd541243fa31a50750a" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_encoder&lt;/em&gt; is a callable (i.e. function) which will perform the actual encoding of the data for transport. This callable takes one argument, which is the &lt;a href=&quot;#email.mime.application.MIMEApplication&quot;&gt;&lt;code&gt;MIMEApplication&lt;/code&gt;&lt;/a&gt; instance. It should use &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt;&lt;code&gt;set_payload()&lt;/code&gt;&lt;/a&gt; to change the payload to encoded form. It should also add any &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; or other headers to the message object as necessary. The default encoding is base64. See the &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt;&lt;code&gt;email.encoders&lt;/code&gt;&lt;/a&gt; module for a list of the built-in encoders.</source>
          <target state="translated">선택적 &lt;em&gt;_encoder&lt;/em&gt; 는 전송 가능한 데이터의 실제 인코딩을 수행하는 호출 가능 (즉, 함수)입니다. 이 콜 &lt;a href=&quot;#email.mime.application.MIMEApplication&quot;&gt; &lt;code&gt;MIMEApplication&lt;/code&gt; &lt;/a&gt; 은 하나의 인수, 즉 MIMEApplication 인스턴스를 취 합니다. 페이로드를 인코딩 된 형식으로 변경 하려면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt; &lt;code&gt;set_payload()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 필요에 따라 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 또는 기타 헤더를 ​​메시지 객체에 추가해야합니다. 기본 인코딩은 base64입니다. 내장 인코더 목록은 &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt; &lt;code&gt;email.encoders&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f423d4e8b5e1e91960dd208dab5452be79d71fb8" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_encoder&lt;/em&gt; is a callable (i.e. function) which will perform the actual encoding of the image data for transport. This callable takes one argument, which is the &lt;a href=&quot;#email.mime.image.MIMEImage&quot;&gt;&lt;code&gt;MIMEImage&lt;/code&gt;&lt;/a&gt; instance. It should use &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt;&lt;code&gt;set_payload()&lt;/code&gt;&lt;/a&gt; to change the payload to encoded form. It should also add any &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; or other headers to the message object as necessary. The default encoding is base64. See the &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt;&lt;code&gt;email.encoders&lt;/code&gt;&lt;/a&gt; module for a list of the built-in encoders.</source>
          <target state="translated">선택적 &lt;em&gt;_encoder&lt;/em&gt; 는 호출 가능한 이미지 데이터의 실제 인코딩을 수행하는 호출 가능 (즉, 함수)입니다. 이 콜 &lt;a href=&quot;#email.mime.image.MIMEImage&quot;&gt; &lt;code&gt;MIMEImage&lt;/code&gt; &lt;/a&gt; 은 MIMEImage 인스턴스 인 하나의 인수를 취 합니다. 페이로드를 인코딩 된 형식으로 변경 하려면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt; &lt;code&gt;set_payload()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 필요에 따라 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 또는 기타 헤더를 ​​메시지 객체에 추가해야합니다. 기본 인코딩은 base64입니다. 내장 인코더 목록은 &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt; &lt;code&gt;email.encoders&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1640c671992d66aa1ab94530cbf0176f120aa8b" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_mangle_from_&lt;/em&gt; and &lt;em&gt;maxheaderlen&lt;/em&gt; are as with the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; base class.</source>
          <target state="translated">선택적인 &lt;em&gt;_mangle_from_&lt;/em&gt; 및 &lt;em&gt;maxheaderlen&lt;/em&gt; 은 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 기본 클래스 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c135f5214b837e44f2f6460a17880339144023cb" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_subtype&lt;/em&gt; sets the subtype of the message; it defaults to &lt;em&gt;rfc822&lt;/em&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;_subtype&lt;/em&gt; 은 메시지의 하위 유형을 설정합니다. 기본값은 &lt;em&gt;rfc822입니다.&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="923ac92596f5e0b048764c0544725cb7d8315bfb" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;altchars&lt;/em&gt; must be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; of at least length 2 (additional characters are ignored) which specifies an alternative alphabet for the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; characters. This allows an application to e.g. generate URL or filesystem safe Base64 strings. The default is &lt;code&gt;None&lt;/code&gt;, for which the standard Base64 alphabet is used.</source>
          <target state="translated">선택적 &lt;em&gt;altchars&lt;/em&gt; 는 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 문자 의 대체 알파벳을 지정하는 최소 길이 2 (추가 문자는 무시 됨) 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 여야합니다 . 이를 통해 응용 프로그램은 예를 들어 URL 또는 파일 시스템 안전 Base64 문자열을 생성 할 수 있습니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 이며 표준 Base64 알파벳이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76bee86fbcac7650eb452298a6aece94136101d1" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;altchars&lt;/em&gt; must be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or ASCII string of at least length 2 (additional characters are ignored) which specifies the alternative alphabet used instead of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; characters.</source>
          <target state="translated">선택적 &lt;em&gt;altchar&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 이거나 길이가 2 이상인 ASCII 문자열 (추가 문자는 무시 됨)이어야하며 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 문자 대신 사용되는 대체 알파벳을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="cb4b9921d192cd1a45a6adc8e11889092e96883c" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;boundary&lt;/em&gt; is the multipart boundary string. When &lt;code&gt;None&lt;/code&gt; (the default), the boundary is calculated when needed (for example, when the message is serialized).</source>
          <target state="translated">선택적인 &lt;em&gt;경계&lt;/em&gt; 는 다중 부분 경계 문자열입니다. 때 &lt;code&gt;None&lt;/code&gt; 필요한 경우 (기본값), 경계가 계산되지 않습니다 (예를 들어, 메시지 직렬화 경우).</target>
        </trans-unit>
        <trans-unit id="83df4bdb171cf95d87daaeffb55e269018e15e7e" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;casefold&lt;/em&gt; is a flag specifying whether a lowercase alphabet is acceptable as input. For security purposes, the default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;casefold&lt;/em&gt; 는 소문자 알파벳을 입력으로 사용할 수 있는지 여부를 지정하는 플래그입니다. 보안을 위해 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3b940d26a790e7ff0f6bc05a182d4d5e74c6dad" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;charset&lt;/em&gt; is the character set that will be used in the &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; encoding of the &lt;code&gt;realname&lt;/code&gt; if the &lt;code&gt;realname&lt;/code&gt; contains non-ASCII characters. Can be an instance of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt;. Defaults to &lt;code&gt;utf-8&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;문자 세트&lt;/em&gt; 는 &lt;code&gt;realname&lt;/code&gt; 에 비 ASCII 문자가 포함 된 경우 &lt;code&gt;realname&lt;/code&gt; 의 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 인코딩에 사용되는 문자 세트입니다 . &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; 의 인스턴스 일 수 있습니다 . 기본값은 &lt;code&gt;utf-8&lt;/code&gt; 입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="63ec82a1964cf6c1f24661387a4dc0633c206b42" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;charset&lt;/em&gt; serves two purposes: it has the same meaning as the &lt;em&gt;charset&lt;/em&gt; argument to the &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; method. It also sets the default character set for all subsequent &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; calls that omit the &lt;em&gt;charset&lt;/em&gt; argument. If &lt;em&gt;charset&lt;/em&gt; is not provided in the constructor (the default), the &lt;code&gt;us-ascii&lt;/code&gt; character set is used both as &lt;em&gt;s&lt;/em&gt;&amp;rsquo;s initial charset and as the default for subsequent &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">선택적 &lt;em&gt;문자 집합&lt;/em&gt; 은 두 가지 용도로 사용됩니다. &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 메서드 의 &lt;em&gt;문자 집합&lt;/em&gt; 인수 와 동일한 의미를 갖습니다 . 또한 문자 &lt;em&gt;세트&lt;/em&gt; 인수 를 생략하는 모든 후속 &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 호출에 대한 기본 문자 세트를 설정합니다 . 경우 &lt;em&gt;캐릭터 세트가&lt;/em&gt; 생성자 (기본값)에서 제공되지는 &lt;code&gt;us-ascii&lt;/code&gt; 문자 세트는 모두 사용되는 &lt;em&gt;S&lt;/em&gt; 의 초기 캐릭터 세트 이후의 기본값으로 &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 호출을.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="642b9453af4c0269ab0ad7d0d8bcb29305105881" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;charset&lt;/em&gt;, if given, should be a &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt; instance (see &lt;a href=&quot;email.charset#module-email.charset&quot;&gt;&lt;code&gt;email.charset&lt;/code&gt;&lt;/a&gt;) or the name of a character set, which will be converted to a &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt; instance. A value of &lt;code&gt;None&lt;/code&gt; (the default) means that the &lt;em&gt;charset&lt;/em&gt; given in the constructor is used.</source>
          <target state="translated">옵션 &lt;em&gt;캐릭터 세트&lt;/em&gt; , 주어진 경우이어야한다 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; (참조 예를 &lt;a href=&quot;email.charset#module-email.charset&quot;&gt; &lt;code&gt;email.charset&lt;/code&gt; &lt;/a&gt; ) 또는으로 변환하는 문자 세트의 이름 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. &lt;code&gt;None&lt;/code&gt; (기본값) 은 생성자에 지정된 &lt;em&gt;문자&lt;/em&gt; 집합 이 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3105978bd6f7423833b30c5cebf668aba1d75338" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;context&lt;/em&gt; parameter is an &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; object; This is an alternative to using a keyfile and a certfile and if specified both &lt;em&gt;keyfile&lt;/em&gt; and &lt;em&gt;certfile&lt;/em&gt; should be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;컨텍스트&lt;/em&gt; 매개 변수는 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 오브젝트입니다. 이 키 파일과 certfile를 사용하는 대신하고 모두 지정한 경우 &lt;em&gt;키 파일을&lt;/em&gt; 하고 &lt;em&gt;certfile는&lt;/em&gt; 없을 것 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d99f38424b2c5ff22681c0c95a235051c8f5f6c" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;continuation_ws&lt;/em&gt; must be &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant folding whitespace, and is usually either a space or a hard tab character. This character will be prepended to continuation lines. &lt;em&gt;continuation_ws&lt;/em&gt; defaults to a single space character.</source>
          <target state="translated">선택적 &lt;em&gt;continuation_ws&lt;/em&gt; 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 호환 접이식 공백 이어야하며 일반적으로 공백 또는 하드 탭 문자입니다. 이 문자는 연속 줄 앞에 추가됩니다. &lt;em&gt;continuation_ws의&lt;/em&gt; 기본값은 단일 공백 ​​문자입니다.</target>
        </trans-unit>
        <trans-unit id="c67c2285f2ee3c267919b8e982d48c9f0e3fac16" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;decode&lt;/em&gt; is a flag indicating whether the payload should be decoded or not, according to the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header. When &lt;code&gt;True&lt;/code&gt; and the message is not a multipart, the payload will be decoded if this header&amp;rsquo;s value is &lt;code&gt;quoted-printable&lt;/code&gt; or &lt;code&gt;base64&lt;/code&gt;. If some other encoding is used, or &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header is missing, the payload is returned as-is (undecoded). In all cases the returned value is binary data. If the message is a multipart and the &lt;em&gt;decode&lt;/em&gt; flag is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;None&lt;/code&gt; is returned. If the payload is base64 and it was not perfectly formed (missing padding, characters outside the base64 alphabet), then an appropriate defect will be added to the message&amp;rsquo;s defect property (&lt;code&gt;InvalidBase64PaddingDefect&lt;/code&gt; or &lt;code&gt;InvalidBase64CharactersDefect&lt;/code&gt;, respectively).</source>
          <target state="translated">선택적 &lt;em&gt;디코드&lt;/em&gt; 는 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더 에 따라 페이로드를 디코드해야하는지 여부를 나타내는 플래그 입니다. 때 &lt;code&gt;True&lt;/code&gt; 과 메시지가 다중 아닌이 헤더의 값이되면, 페이로드 디코딩됩니다 &lt;code&gt;quoted-printable&lt;/code&gt; 또는 &lt;code&gt;base64&lt;/code&gt; . 다른 인코딩이 사용되거나 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더가 누락 된 경우 페이로드는 그대로 (비 경제적) 반환됩니다. 모든 경우에 반환 된 값은 이진 데이터입니다. 메시지가 멀티 파트이고 &lt;em&gt;디코드&lt;/em&gt; 플래그가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;None&lt;/code&gt; 반환됩니다. 페이로드가 base64이고 완벽하게 형성되지 않은 경우 (패딩 누락, base64 알파벳 이외의 문자), 해당 결함이 메시지의 결함 특성 ( 각각 &lt;code&gt;InvalidBase64PaddingDefect&lt;/code&gt; 또는 &lt;code&gt;InvalidBase64CharactersDefect&lt;/code&gt; )에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="369dd5ecc7951cf49ed4b1356b49e703da098189" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;decode&lt;/em&gt; is passed through to &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;Message.get_payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;디코딩&lt;/em&gt; 은 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;Message.get_payload&lt;/code&gt; &lt;/a&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="84972e509ca18de70cc29ad7afa6e0258541f329" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;errors&lt;/em&gt; is passed as the errors argument to the decode call if &lt;em&gt;s&lt;/em&gt; is a byte string.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 바이트 문자열 인 경우 선택적 &lt;em&gt;오류&lt;/em&gt; 가 오류 인수로 디코드 호출에 전달됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cdfa3072d99360bc8281b6670d7022d51cad8c05" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;errors&lt;/em&gt; is passed straight through to the &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;오류&lt;/em&gt; 는 &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 메소드로 직접 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="af5602daa1b8d69afae9c649f6b6721510f50598" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;failobj&lt;/em&gt; is the object to return if there is no &lt;em&gt;Content-Type&lt;/em&gt; header. Optional &lt;em&gt;header&lt;/em&gt; is the header to search instead of &lt;em&gt;Content-Type&lt;/em&gt;.</source>
          <target state="translated">선택적인 &lt;em&gt;failobj&lt;/em&gt; 는 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 가없는 경우 반환 할 객체 입니다. 선택적 &lt;em&gt;헤더&lt;/em&gt; 는 &lt;em&gt;Content-Type&lt;/em&gt; 대신 검색 할 헤더 입니다.</target>
        </trans-unit>
        <trans-unit id="1c9958c82059fc6801aef502b2e8413f811d61fd" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;fp&lt;/em&gt; is a file-like object to print the output to. It must be suitable for Python&amp;rsquo;s &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function. &lt;em&gt;level&lt;/em&gt; is used internally. &lt;em&gt;include_default&lt;/em&gt;, if true, prints the default type as well.</source>
          <target state="translated">선택적 &lt;em&gt;fp&lt;/em&gt; 는 출력을 인쇄 할 파일과 유사한 객체입니다. Python의 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 함수에 적합해야합니다 . &lt;em&gt;레벨&lt;/em&gt; 은 내부적으로 사용됩니다. &lt;em&gt;include_default&lt;/em&gt; 는 true 인 경우 기본 유형도 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a8edc8339641cac835a5f65084c400648dd7bc38" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;header&lt;/em&gt; if given, specifies the message header to use instead of &lt;em&gt;Content-Type&lt;/em&gt;.</source>
          <target state="translated">옵션 &lt;em&gt;헤더 (&lt;/em&gt; 제공된 경우)는 &lt;em&gt;Content-Type&lt;/em&gt; 대신 사용할 메시지 헤더를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="56ec783d1d1ef92af29b2b3bf0edfc7eeea59252" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;header&lt;/em&gt; specifies an alternative header to &lt;em&gt;Content-Type&lt;/em&gt;, and all parameters will be quoted as necessary unless optional &lt;em&gt;requote&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default is &lt;code&gt;True&lt;/code&gt;).</source>
          <target state="translated">옵션 &lt;em&gt;헤더&lt;/em&gt; 에 대한 대안 헤더 지정 &lt;em&gt;콘텐츠 형식을&lt;/em&gt; , 및 선택하지 않는 한 모든 매개 변수는 필요에 따라 인용한다 &lt;em&gt;requote이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본값은 &lt;code&gt;True&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d5523c1c7da4baa3419962027d50d39d8397401a" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;header_enc&lt;/em&gt; and &lt;em&gt;body_enc&lt;/em&gt; is either &lt;code&gt;Charset.QP&lt;/code&gt; for quoted-printable, &lt;code&gt;Charset.BASE64&lt;/code&gt; for base64 encoding, &lt;code&gt;Charset.SHORTEST&lt;/code&gt; for the shortest of quoted-printable or base64 encoding, or &lt;code&gt;None&lt;/code&gt; for no encoding. &lt;code&gt;SHORTEST&lt;/code&gt; is only valid for &lt;em&gt;header_enc&lt;/em&gt;. The default is &lt;code&gt;None&lt;/code&gt; for no encoding.</source>
          <target state="translated">선택 &lt;em&gt;header_enc&lt;/em&gt; 및 &lt;em&gt;body_enc가&lt;/em&gt; 하나 인 &lt;code&gt;Charset.QP&lt;/code&gt; 인용 된 인쇄 들면 &lt;code&gt;Charset.BASE64&lt;/code&gt; 는 Base64 인코딩 들어 &lt;code&gt;Charset.SHORTEST&lt;/code&gt; 는 인용 된 인쇄 또는베이스 64의 최단 인코딩 없거나 &lt;code&gt;None&lt;/code&gt; 없음 인코딩. &lt;code&gt;SHORTEST&lt;/code&gt; 는 &lt;em&gt;header_enc&lt;/em&gt; 에만 유효합니다 . 인코딩이없는 경우 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="348f37b616413a59290dc4137576e659b6b66805" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;headersonly&lt;/em&gt; is a flag specifying whether to stop parsing after reading the headers or not. The default is &lt;code&gt;False&lt;/code&gt;, meaning it parses the entire contents of the file.</source>
          <target state="translated">선택적 &lt;em&gt;헤더 만은&lt;/em&gt; 헤더를 읽은 후 구문 분석을 중지할지 여부를 지정하는 플래그입니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 이며 파일의 전체 내용을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="70ab572101a30eef47fe16af46c39372bde2e339" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;headersonly&lt;/em&gt; is as with the &lt;a href=&quot;#email.parser.BytesParser.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;헤더&lt;/em&gt; 만 &lt;a href=&quot;#email.parser.BytesParser.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b729b7533028c3755db136b3ae706911b578a369" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;headersonly&lt;/em&gt; is as with the &lt;a href=&quot;#email.parser.Parser.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;헤더&lt;/em&gt; 만 &lt;a href=&quot;#email.parser.Parser.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1300eb907c8a0950cd615120af8b9e9015e21490" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;input_charset&lt;/em&gt; is as described below; it is always coerced to lower case. After being alias normalized it is also used as a lookup into the registry of character sets to find out the header encoding, body encoding, and output conversion codec to be used for the character set. For example, if &lt;em&gt;input_charset&lt;/em&gt; is &lt;code&gt;iso-8859-1&lt;/code&gt;, then headers and bodies will be encoded using quoted-printable and no output conversion codec is necessary. If &lt;em&gt;input_charset&lt;/em&gt; is &lt;code&gt;euc-jp&lt;/code&gt;, then headers will be encoded with base64, bodies will not be encoded, but output text will be converted from the &lt;code&gt;euc-jp&lt;/code&gt; character set to the &lt;code&gt;iso-2022-jp&lt;/code&gt; character set.</source>
          <target state="translated">선택적 &lt;em&gt;input_charset&lt;/em&gt; 은 다음과 같습니다. 항상 소문자로 강제됩니다. 별칭이 정규화 된 후에는 문자 집합 레지스트리에서 조회로 사용되어 문자 집합에 사용할 헤더 인코딩, 본문 인코딩 및 출력 변환 코덱을 찾습니다. 예를 들어 &lt;em&gt;input_charset&lt;/em&gt; 이 &lt;code&gt;iso-8859-1&lt;/code&gt; 인 경우 헤더와 본문은 인용 인쇄 가능을 사용하여 인코딩되며 출력 변환 코덱이 필요하지 않습니다. 경우 &lt;em&gt;input_charset가&lt;/em&gt; 있다 &lt;code&gt;euc-jp&lt;/code&gt; , 다음 헤더는, 몸이 인코딩되지 않습니다 base64로 인코딩되지만, 출력 텍스트가 변환됩니다 &lt;code&gt;euc-jp&lt;/code&gt; 받는 문자 집합 &lt;code&gt;iso-2022-jp&lt;/code&gt; 문자 세트.</target>
        </trans-unit>
        <trans-unit id="7f0ac5d6eacc6d8910fdc79f834598dba5f7ecc0" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;localtime&lt;/em&gt; is a flag that when &lt;code&gt;True&lt;/code&gt;, interprets &lt;em&gt;timeval&lt;/em&gt;, and returns a date relative to the local timezone instead of UTC, properly taking daylight savings time into account. The default is &lt;code&gt;False&lt;/code&gt; meaning UTC is used.</source>
          <target state="translated">선택적 &lt;em&gt;localtime&lt;/em&gt; 은 &lt;code&gt;True&lt;/code&gt; 일 때 &lt;em&gt;timeval을&lt;/em&gt; 해석 하고 UTC 대신 현지 시간대를 기준으로 날짜를 반환하여 일광 절약 시간을 올바르게 고려 하는 플래그입니다 . 기본값은 &lt;code&gt;False&lt;/code&gt; 이며 UTC가 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="081534f96775eff49e5f20cd9241c5dc8464300b" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;output_charset&lt;/em&gt; is the character set that the output should be in. Conversions will proceed from input charset, to Unicode, to the output charset when the method &lt;code&gt;Charset.convert()&lt;/code&gt; is called. The default is to output in the same character set as the input.</source>
          <target state="translated">선택적 &lt;em&gt;output_charset&lt;/em&gt; 은 출력에 포함 된 문자 세트입니다. &lt;code&gt;Charset.convert()&lt;/code&gt; 메소드 가 호출 될 때 입력 문자 세트에서 유니 코드로, 출력 문자 세트로 변환이 진행됩니다 . 기본값은 입력과 동일한 문자 세트로 출력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="27a289728023caa13d781ff4f3845ee08d743ebe" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;policy&lt;/em&gt; argument defaults to &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;정책&lt;/em&gt; 인수의 기본값은 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9de5adc35af35a2d0dbdc98b0b7dccae205e947" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;s&lt;/em&gt; is the initial header value. If &lt;code&gt;None&lt;/code&gt; (the default), the initial header value is not set. You can later append to the header with &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; method calls. &lt;em&gt;s&lt;/em&gt; may be an instance of &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, but see the &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; documentation for semantics.</source>
          <target state="translated">선택적인 &lt;em&gt;s&lt;/em&gt; 는 초기 헤더 값입니다. 경우 &lt;code&gt;None&lt;/code&gt; (기본값), 초기 헤더 값이 설정되어 있지 않습니다. 나중에 헤더에 추가 할 수 있습니다&lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 메서드 호출 추가.&lt;em&gt; s&lt;/em&gt; 는&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 인스턴스일 수 있지만의미에대해서는&lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 설명서를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a06aa49f277b03a309f72dd81f7730544395c46" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;splitchars&lt;/em&gt; is a string containing characters which should be given extra weight by the splitting algorithm during normal header wrapping. This is in very rough support of &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;&amp;rsquo;s &amp;lsquo;higher level syntactic breaks&amp;rsquo;: split points preceded by a splitchar are preferred during line splitting, with the characters preferred in the order in which they appear in the string. Space and tab may be included in the string to indicate whether preference should be given to one over the other as a split point when other split chars do not appear in the line being split. Splitchars does not affect &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; encoded lines.</source>
          <target state="translated">선택적 &lt;em&gt;splitchars&lt;/em&gt; 는 문자를 포함하는 문자열로 일반 헤더 줄 바꿈 중 분할 알고리즘으로 추가 가중치를 받아야합니다. 이것은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 의 '상위 구문 구문 나누기' 를 매우 대략적으로 지원합니다 . 행 분할 중에 splitchar가 앞에 오는 분리 점이 선호되며 문자열에 표시되는 순서대로 문자가 선호됩니다. 공백과 탭이 문자열에 포함되어 다른 분할 문자가 분할되는 행에 나타나지 않을 때 분할 점으로 우선 순위를 부여해야하는지 여부를 나타냅니다. Splitchars는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 인코딩 된 라인에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a3f21b8e8630f6eb8e4be7786fc506fc0f12e579" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;timeval&lt;/em&gt; if given is a floating point time value as accepted by &lt;a href=&quot;time#time.gmtime&quot;&gt;&lt;code&gt;time.gmtime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;time#time.localtime&quot;&gt;&lt;code&gt;time.localtime()&lt;/code&gt;&lt;/a&gt;, otherwise the current time is used.</source>
          <target state="translated">&lt;a href=&quot;time#time.gmtime&quot;&gt; &lt;code&gt;time.gmtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;time#time.localtime&quot;&gt; &lt;code&gt;time.localtime()&lt;/code&gt; &lt;/a&gt; 에서 허용되는 부동 소수점 시간 값인 경우 선택적인 &lt;em&gt;timeval&lt;/em&gt; 입니다. 그렇지 않으면 현재 시간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d94e2bee88984200593b6f6da3352d09ebd1bdf9" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;usegmt&lt;/em&gt; is a flag that when &lt;code&gt;True&lt;/code&gt;, outputs a date string with the timezone as an ascii string &lt;code&gt;GMT&lt;/code&gt;, rather than a numeric &lt;code&gt;-0000&lt;/code&gt;. This is needed for some protocols (such as HTTP). This only applies when &lt;em&gt;localtime&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;. The default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;usegmt&lt;/em&gt; 는 &lt;code&gt;True&lt;/code&gt; 일 때 숫자가 아닌 시간대를 ASCII 문자열 &lt;code&gt;GMT&lt;/code&gt; 로 사용하여 날짜 문자열을 출력 하는 플래그입니다. &lt;code&gt;-0000&lt;/code&gt; 이 . 이것은 일부 프로토콜 (예 : HTTP)에 필요합니다. &lt;em&gt;localtime&lt;/em&gt; 이 &lt;code&gt;False&lt;/code&gt; 인 경우에만 적용됩니다 . 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f1580e50d2eddf54a3ae07be51a03a3b611fbc6" translate="yes" xml:space="preserve">
          <source>Optional abstract method which returns a &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; containing metadata about the specified path. Supported dictionary keys are:</source>
          <target state="translated">지정된 경로에 대한 메타 데이터를 포함 하는 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 를 반환하는 선택적 추상 메소드입니다 . 지원되는 사전 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95081d9d4e8221143e59084ea58753f21593f36b" translate="yes" xml:space="preserve">
          <source>Optional abstract method which returns the modification time for the specified path.</source>
          <target state="translated">지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="89231b5583c81ea0c69000746832d731cd8bae53" translate="yes" xml:space="preserve">
          <source>Optional abstract method which writes the specified bytes to a file path. Any intermediate directories which do not exist are to be created automatically.</source>
          <target state="translated">지정된 바이트를 파일 경로에 쓰는 선택적 추상 메소드. 존재하지 않는 중간 디렉토리는 자동으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="44f898292a2dcbd773017d0c19c497a57f45394d" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;compileflags&lt;/em&gt; gives the set of flags that should be used by the Python compiler when running the examples. By default, or if &lt;code&gt;None&lt;/code&gt;, flags are deduced corresponding to the set of future features found in &lt;em&gt;globs&lt;/em&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;compileflags&lt;/em&gt; 는 예제를 실행할 때 Python 컴파일러에서 사용해야하는 플래그 세트를 제공합니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면, &lt;em&gt;globs&lt;/em&gt; 에서 발견 된 향후 기능 세트에 해당하는 플래그가 추론 됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d7c5227339a3dd1d8d5e5070885d664aae3a21" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;cutoff&lt;/em&gt; (default &lt;code&gt;0.6&lt;/code&gt;) is a float in the range [0, 1]. Possibilities that don&amp;rsquo;t score at least that similar to &lt;em&gt;word&lt;/em&gt; are ignored.</source>
          <target state="translated">선택적 인수 &lt;em&gt;컷오프&lt;/em&gt; (기본값 &lt;code&gt;0.6&lt;/code&gt; )는 [0, 1] 범위의 부동 소수점입니다. 최소한 &lt;em&gt;단어&lt;/em&gt; 와 비슷한 점수를 얻지 못할 가능성 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a241b6f1ed98aec382909620ac3173fbadb0aac1" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;encoding&lt;/em&gt; specifies an encoding that should be used to convert the file to unicode.</source>
          <target state="translated">선택적 인수 &lt;em&gt;인코딩&lt;/em&gt; 은 파일을 유니 코드로 변환하는 데 사용해야하는 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="32822bcfb01fea87cd439dcc50837e241cd10492" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;exclude_empty&lt;/em&gt; defaults to false. If true, objects for which no doctests are found are excluded from consideration. The default is a backward compatibility hack, so that code still using &lt;code&gt;doctest.master.summarize()&lt;/code&gt; in conjunction with &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt; continues to get output for objects with no tests. The &lt;em&gt;exclude_empty&lt;/em&gt; argument to the newer &lt;a href=&quot;#doctest.DocTestFinder&quot;&gt;&lt;code&gt;DocTestFinder&lt;/code&gt;&lt;/a&gt; constructor defaults to true.</source>
          <target state="translated">선택적 인수 &lt;em&gt;exclude_empty의&lt;/em&gt; 기본값은 false입니다. true 인 경우, doctest가없는 오브젝트는 고려에서 제외됩니다. 기본값은 이전 버전과의 호환성 해킹이므로 &lt;code&gt;doctest.master.summarize()&lt;/code&gt; 와 함께 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 계속 사용하는 코드는 테스트없이 객체에 대한 출력을 계속 얻습니다. 최신 &lt;a href=&quot;#doctest.DocTestFinder&quot;&gt; &lt;code&gt;DocTestFinder&lt;/code&gt; &lt;/a&gt; 생성자에 대한 &lt;em&gt;exclude_empty&lt;/em&gt; 인수의 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="c56059e44a1695148c4922ca4f4a049c77eff06a" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;extraglobs&lt;/em&gt; gives a dict merged into the globals used to execute examples. This works like &lt;a href=&quot;stdtypes#dict.update&quot;&gt;&lt;code&gt;dict.update()&lt;/code&gt;&lt;/a&gt;: if &lt;em&gt;globs&lt;/em&gt; and &lt;em&gt;extraglobs&lt;/em&gt; have a common key, the associated value in &lt;em&gt;extraglobs&lt;/em&gt; appears in the combined dict. By default, or if &lt;code&gt;None&lt;/code&gt;, no extra globals are used. This is an advanced feature that allows parameterization of doctests. For example, a doctest can be written for a base class, using a generic name for the class, then reused to test any number of subclasses by passing an &lt;em&gt;extraglobs&lt;/em&gt; dict mapping the generic name to the subclass to be tested.</source>
          <target state="translated">선택적 인수 &lt;em&gt;extraglobs&lt;/em&gt; 는 예제를 실행하는 데 사용되는 전역으로 병합 된 dict를 제공합니다. 같은이 작품 &lt;a href=&quot;stdtypes#dict.update&quot;&gt; &lt;code&gt;dict.update()&lt;/code&gt; &lt;/a&gt; 다음과 같은 경우 &lt;em&gt;globs와&lt;/em&gt; 와 &lt;em&gt;extraglobs는&lt;/em&gt; 공통의 키가에 관련된 값 &lt;em&gt;extraglobs이&lt;/em&gt; 결합 된 DICT에 나타납니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면 추가 전역이 사용되지 않습니다. 이것은 doctest의 매개 변수화를 허용하는 고급 기능입니다. 예를 들어, 클래스의 일반 이름을 사용하여 기본 클래스에 대해 doctest를 작성한 다음, 테스트 할 서브 클래스에 일반 이름을 맵핑 하는 &lt;em&gt;엑스트라 글로브 (extraglobs)&lt;/em&gt; dict 를 전달하여 여러 서브 클래스를 테스트하는 데 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fba34650a7fe8672d07c230f7d0e87f1c888f71" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;extraglobs&lt;/em&gt; specifies an extra set of global variables, which is merged into &lt;em&gt;globs&lt;/em&gt;. By default, no extra globals are used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;extraglobs&lt;/em&gt; 는 추가되는 전역 변수 세트를 지정합니다.&lt;em&gt; globs&lt;/em&gt; . 기본적으로 추가 전역이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47e27778c61b07e6d1aab3d14114ebc81c4fa2f2" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;globs&lt;/em&gt; gives a dict to be used as the globals when executing examples. A new shallow copy of this dict is created for the doctest, so its examples start with a clean slate. By default, or if &lt;code&gt;None&lt;/code&gt;, a new empty dict is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;globs&lt;/em&gt; 는 예제를 실행할 때 전역으로 사용될 dict를 제공합니다. 이 dict의 새로운 얕은 사본은 doctest를 위해 만들어 졌으므로 예제는 깨끗한 슬레이트로 시작합니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면 새로운 빈 dict가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e45842c5895e5ae4432fbb87c16f7cb0eeaec604" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;globs&lt;/em&gt; gives a dictionary to use as both local and global execution context. If not specified, or &lt;code&gt;None&lt;/code&gt;, an empty dictionary is used. If specified, a shallow copy of the dictionary is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;globs&lt;/em&gt; 는 로컬 및 전역 실행 컨텍스트로 사용할 사전을 제공합니다. 지정하지 않은 경우 &lt;code&gt;None&lt;/code&gt; 이면 빈 사전이 사용됩니다. 지정된 경우 사전의 얕은 사본이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac2368691c9de6fd84091afdc4f7a61c1910faf1" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;globs&lt;/em&gt; is a dictionary containing the initial global variables for the tests. A new copy of this dictionary is created for each test. By default, &lt;em&gt;globs&lt;/em&gt; is a new empty dictionary.</source>
          <target state="translated">선택적 인수 &lt;em&gt;globs&lt;/em&gt; 는 테스트의 초기 전역 변수를 포함하는 사전입니다. 이 사전의 새 사본이 각 테스트마다 작성됩니다. 기본적으로,&lt;em&gt; globs&lt;/em&gt; 는 새로운 빈 사전입니다.</target>
        </trans-unit>
        <trans-unit id="fb750e9897e2507830eb1c28fae23ef3fcb29129" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;interval&lt;/em&gt; represents the class interval, and defaults to 1. Changing the class interval naturally will change the interpolation:</source>
          <target state="translated">선택적 인수 &lt;em&gt;간격&lt;/em&gt; 은 클래스 나타내며 기본값은 1입니다. 클래스 간격을 자연스럽게 변경하면 보간이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3aac0b0b4936e97b6b254322e753031731854457" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;isjunk&lt;/em&gt; must be &lt;code&gt;None&lt;/code&gt; (the default) or a one-argument function that takes a sequence element and returns true if and only if the element is &amp;ldquo;junk&amp;rdquo; and should be ignored. Passing &lt;code&gt;None&lt;/code&gt; for &lt;em&gt;isjunk&lt;/em&gt; is equivalent to passing &lt;code&gt;lambda x: False&lt;/code&gt;; in other words, no elements are ignored. For example, pass:</source>
          <target state="translated">선택적 인수 &lt;em&gt;isjunk&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; (기본값) 또는 시퀀스 요소를 가져 와서 요소가 &quot;junk&quot;이고 무시해야하는 경우에만 true를 리턴하는 1 인수 함수 여야합니다. 전달하지 &lt;code&gt;None&lt;/code&gt; 위해 &lt;em&gt;isjunk은&lt;/em&gt; 전달에 해당 &lt;code&gt;lambda x: False&lt;/code&gt; ; 즉, 요소가 무시되지 않습니다. 예를 들어, 다음을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="74aea2ea98253e841261cf8043788a6866f1d3cf" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;module&lt;/em&gt; provides the module to be tested. It can be a module object or a (possibly dotted) module name. If not specified, the module calling this function is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;모듈&lt;/em&gt; 은 테스트 할 모듈을 제공합니다. 모듈 객체 또는 점으로 구분 된 모듈 이름 일 수 있습니다. 지정하지 않으면이 함수를 호출하는 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="88fe4782e94348e9fdc401064c2ad56c8058b300" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;module_relative&lt;/em&gt; specifies how the filename should be interpreted:</source>
          <target state="translated">선택적 인수 &lt;em&gt;module_relative&lt;/em&gt; 는 파일 이름을 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="22ad18924a8191c36d6c5c768f2a1805167cb09a" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;module_relative&lt;/em&gt; specifies how the filenames in &lt;em&gt;paths&lt;/em&gt; should be interpreted:</source>
          <target state="translated">선택적 인수 &lt;em&gt;module_relative&lt;/em&gt; 는 &lt;em&gt;경로&lt;/em&gt; 에서 파일 이름을 지정하는 방법을 지정합니다.&lt;em&gt;&lt;/em&gt; 해석 .</target>
        </trans-unit>
        <trans-unit id="c683e99d27fef7549d8e40a7457b3d344329fce8" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;n&lt;/em&gt; (default &lt;code&gt;3&lt;/code&gt;) is the maximum number of close matches to return; &lt;em&gt;n&lt;/em&gt; must be greater than &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;n&lt;/em&gt; (기본값 &lt;code&gt;3&lt;/code&gt; )은 반환 할 최대 근접 일치 수입니다. &lt;em&gt;n&lt;/em&gt; 은 &lt;code&gt;0&lt;/code&gt; 보다 커야합니다 .</target>
        </trans-unit>
        <trans-unit id="74f74bc8bf80163ce9a08ec26c023a78cc6f1351" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;name&lt;/em&gt; gives the name of the module; by default, or if &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;m.__name__&lt;/code&gt; is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;이름&lt;/em&gt; 은 모듈의 이름을 제공합니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code&gt;m.__name__&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d52bd25fbf060bdc8c3b9ca435cbc9618a61325" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;name&lt;/em&gt; gives the name of the test; by default, or if &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;os.path.basename(filename)&lt;/code&gt; is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;이름&lt;/em&gt; 은 테스트 &lt;em&gt;이름을&lt;/em&gt; 제공합니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code&gt;os.path.basename(filename)&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f6b2562f8953f1131c472b47d4b54220bb6ba548" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;name&lt;/em&gt; is used in failure messages, and defaults to &lt;code&gt;&quot;NoName&quot;&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;이름&lt;/em&gt; 은 실패 메시지에 사용되며 기본값은 &lt;code&gt;&quot;NoName&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1699bfdd7fd20973701d3162c62bfa1f9508f5f4" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;optionflags&lt;/em&gt; (default value 0) takes the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;bitwise OR&lt;/a&gt; of option flags. See section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;optionflags&lt;/em&gt; (기본값 0)는 옵션 플래그 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;비트 단위 OR&lt;/a&gt; 을 사용합니다. &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="759e88a19de4d4b0746cebf786891ae177aeb07c" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;optionflags&lt;/em&gt; specifies the default doctest options for the tests, created by or-ing together individual option flags. See section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt;. See function &lt;a href=&quot;#doctest.set_unittest_reportflags&quot;&gt;&lt;code&gt;set_unittest_reportflags()&lt;/code&gt;&lt;/a&gt; below for a better way to set reporting options.</source>
          <target state="translated">선택적 인수 &lt;em&gt;optionflags&lt;/em&gt; 는 개별 옵션 플래그를 함께 또는 함께 만들어 테스트에 대한 기본 doctest 옵션을 지정합니다. &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션을 참조하십시오 . 보고 옵션을 설정하는 더 좋은 방법은 아래의 &lt;a href=&quot;#doctest.set_unittest_reportflags&quot;&gt; &lt;code&gt;set_unittest_reportflags()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37e0a655889a74d4486c037cebbed7ffef38cab5" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;optionflags&lt;/em&gt; works as for function &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">선택적 인수 &lt;em&gt;optionflags&lt;/em&gt; 는 위의 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 함수와 &lt;em&gt;동일하게&lt;/em&gt; 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3866fc6b90b4f4133905c3c5543b075f06526447" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;package&lt;/em&gt; is a Python package or the name of a Python package whose directory should be used as the base directory for a module-relative filename. If no package is specified, then the calling module&amp;rsquo;s directory is used as the base directory for module-relative filenames. It is an error to specify &lt;em&gt;package&lt;/em&gt; if &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;패키지&lt;/em&gt; 는 Python 패키지 또는 디렉토리를 모듈 기준 파일 이름의 기본 디렉토리로 사용해야하는 Python 패키지의 이름입니다. 패키지를 지정하지 않으면 호출 모듈의 디렉토리가 모듈 기준 파일 이름의 기본 디렉토리로 사용됩니다. &lt;em&gt;module_relative&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;em&gt;package&lt;/em&gt; 를 지정하는 것은 오류 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ef5b2b55ab00bb34cd92f7efcd9f129e923c313" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;package&lt;/em&gt; is a Python package or the name of a Python package whose directory should be used as the base directory for module-relative filenames in &lt;em&gt;paths&lt;/em&gt;. If no package is specified, then the calling module&amp;rsquo;s directory is used as the base directory for module-relative filenames. It is an error to specify &lt;em&gt;package&lt;/em&gt; if &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;패키지&lt;/em&gt; 는 Python 패키지 또는 &lt;em&gt;경로&lt;/em&gt; 에서 모듈 기준 파일 이름의 기본 디렉토리로 디렉토리를 사용해야하는 Python 패키지의 이름입니다 . 패키지를 지정하지 않으면 호출 모듈의 디렉토리가 모듈 기준 파일 이름의 기본 디렉토리로 사용됩니다. &lt;em&gt;module_relative&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;em&gt;패키지&lt;/em&gt; 를 지정하는 것은 오류 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94d377498ca11c8e7b908eef8487574468dd8dc7" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;parser&lt;/em&gt; specifies a &lt;a href=&quot;#doctest.DocTestParser&quot;&gt;&lt;code&gt;DocTestParser&lt;/code&gt;&lt;/a&gt; (or subclass) that should be used to extract tests from the files. It defaults to a normal parser (i.e., &lt;code&gt;DocTestParser()&lt;/code&gt;).</source>
          <target state="translated">선택적 인수 &lt;em&gt;구문 분석기&lt;/em&gt; 는 파일에서 테스트를 추출하는 데 사용해야 하는 &lt;a href=&quot;#doctest.DocTestParser&quot;&gt; &lt;code&gt;DocTestParser&lt;/code&gt; &lt;/a&gt; (또는 서브 클래스)를 지정 합니다. 기본 파서 (예 : &lt;code&gt;DocTestParser()&lt;/code&gt; )로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9519b496e1e3f651153ff9769f800e30f69b98e4" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;pm&lt;/em&gt; controls whether post-mortem debugging is used. If &lt;em&gt;pm&lt;/em&gt; has a true value, the script file is run directly, and the debugger gets involved only if the script terminates via raising an unhandled exception. If it does, then post-mortem debugging is invoked, via &lt;a href=&quot;pdb#pdb.post_mortem&quot;&gt;&lt;code&gt;pdb.post_mortem()&lt;/code&gt;&lt;/a&gt;, passing the traceback object from the unhandled exception. If &lt;em&gt;pm&lt;/em&gt; is not specified, or is false, the script is run under the debugger from the start, via passing an appropriate &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; call to &lt;a href=&quot;pdb#pdb.run&quot;&gt;&lt;code&gt;pdb.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;pm&lt;/em&gt; 은 사후 디버깅을 사용할지 여부를 제어합니다. &lt;em&gt;pm&lt;/em&gt; 에 true 값이 있으면 스크립트 파일이 직접 실행되고 처리되지 않은 예외가 발생하여 스크립트가 종료 된 경우에만 디버거가 관여합니다. 그럴 경우 &lt;a href=&quot;pdb#pdb.post_mortem&quot;&gt; &lt;code&gt;pdb.post_mortem()&lt;/code&gt; &lt;/a&gt; 통해 사후 디버깅이 호출 되어 처리되지 않은 예외에서 역 추적 객체를 전달합니다. 경우 &lt;em&gt;오후가&lt;/em&gt; 지정하거나, 거짓되지 않은 스크립트는 적절한 통과를 통해, 처음부터 디버거에서 실행 &lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 를 호출 &lt;a href=&quot;pdb#pdb.run&quot;&gt; &lt;code&gt;pdb.run()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8d4fb8b6c83dfaa1d99881e69a72ea7d791e79" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;pm&lt;/em&gt; has the same meaning as in function &lt;a href=&quot;#doctest.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">선택적 인수 &lt;em&gt;pm&lt;/em&gt; 은 함수 &lt;a href=&quot;#doctest.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다. 위의 .</target>
        </trans-unit>
        <trans-unit id="9dae0c1a5b97e77866ab6881abe2e777305b2301" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;raise_on_error&lt;/em&gt; defaults to false. If true, an exception is raised upon the first failure or unexpected exception in an example. This allows failures to be post-mortem debugged. Default behavior is to continue running examples.</source>
          <target state="translated">선택적 인수 &lt;em&gt;raise_on_error의&lt;/em&gt; 기본값은 false입니다. true 인 경우 예에서 첫 번째 실패 또는 예기치 않은 예외가 발생하면 예외가 발생합니다. 이를 통해 오류를 사후 디버깅 할 수 있습니다. 기본 동작은 예제를 계속 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="56349a38f6363fc65d65da6f8b6443516a01e339" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;report&lt;/em&gt; prints a summary at the end when true, else prints nothing at the end. In verbose mode, the summary is detailed, else the summary is very brief (in fact, empty if all tests passed).</source>
          <target state="translated">선택적 인수 &lt;em&gt;보고서&lt;/em&gt; 는 true 일 때 끝에 요약을 인쇄하고 그렇지 않으면 끝에 아무것도 인쇄하지 않습니다. 상세 모드에서는 요약이 상세하고, 그렇지 않으면 요약이 매우 짧습니다 (사실 모든 테스트가 통과되면 비어 있음).</target>
        </trans-unit>
        <trans-unit id="031d2124c82b980138e2af2ad0b509f59edc68b5" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;setUp&lt;/em&gt; specifies a set-up function for the test suite. This is called before running the tests in each file. The &lt;em&gt;setUp&lt;/em&gt; function will be passed a &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; object. The setUp function can access the test globals as the &lt;em&gt;globs&lt;/em&gt; attribute of the test passed.</source>
          <target state="translated">선택적 인수 &lt;em&gt;setUp&lt;/em&gt; 은 테스트 스위트의 설정 함수를 지정합니다. 각 파일에서 테스트를 실행하기 전에 호출됩니다. &lt;em&gt;설정&lt;/em&gt; 기능은 전달됩니다 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 개체를. 설정 기능은 &lt;em&gt;글로브&lt;/em&gt; 로서 테스트 전역에 액세스 할 수 있습니다&lt;em&gt;&lt;/em&gt; 속성이 통과 .</target>
        </trans-unit>
        <trans-unit id="f72389898b352b75c4f85463a108793b516a19f5" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;source&lt;/em&gt; specifies a context-specific name of the dictionary passed. If not given, &lt;code&gt;&amp;lt;dict&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;소스&lt;/em&gt; 는 전달 된 사전의 컨텍스트 특정 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;&amp;lt;dict&amp;gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40ff180f69c6939133c7c6bbd110c796c6aedf22" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;source&lt;/em&gt; specifies a context-specific name of the string passed. If not given, &lt;code&gt;'&amp;lt;string&amp;gt;'&lt;/code&gt; is used. This should commonly be a filesystem path or a URL.</source>
          <target state="translated">선택적 인수 &lt;em&gt;소스&lt;/em&gt; 는 전달 된 문자열의 컨텍스트 특정 이름을 지정합니다. 지정하지 않으면 &lt;code&gt;'&amp;lt;string&amp;gt;'&lt;/code&gt; 이 사용됩니다. 일반적으로 파일 시스템 경로 또는 URL이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3502c84642c2ef73c0ea7d6513bc9ce05709a14" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;source&lt;/em&gt; specifies the name of the file being read. If not given and &lt;em&gt;f&lt;/em&gt; has a &lt;code&gt;name&lt;/code&gt; attribute, that is used for &lt;em&gt;source&lt;/em&gt;; the default is &lt;code&gt;'&amp;lt;???&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;소스&lt;/em&gt; 는 읽을 파일의 이름을 지정합니다. 지정하지 않고 &lt;em&gt;f&lt;/em&gt; 에 &lt;code&gt;name&lt;/code&gt; 속성이 있으면 &lt;em&gt;source에&lt;/em&gt; 사용됩니다 . 기본값은 &lt;code&gt;'&amp;lt;???&amp;gt;'&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="e3ffb9e4c0b3d8066cd77a81026675c48155def9" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;tearDown&lt;/em&gt; specifies a tear-down function for the test suite. This is called after running the tests in each file. The &lt;em&gt;tearDown&lt;/em&gt; function will be passed a &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; object. The setUp function can access the test globals as the &lt;em&gt;globs&lt;/em&gt; attribute of the test passed.</source>
          <target state="translated">선택적 인수 &lt;em&gt;tearDown&lt;/em&gt; 은 테스트 스위트에 대한 분리 기능을 지정합니다. 각 파일에서 테스트를 실행 한 후에 호출됩니다. &lt;em&gt;의 tearDown&lt;/em&gt; 함수는 전달됩니다 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 개체를. 설정 함수는 테스트의 &lt;em&gt;globs&lt;/em&gt; 속성이 통과 함에 따라 테스트 전역에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7c5453a8a662ff48ce6b05bb63a862556df9025" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;test_finder&lt;/em&gt; is the &lt;a href=&quot;#doctest.DocTestFinder&quot;&gt;&lt;code&gt;DocTestFinder&lt;/code&gt;&lt;/a&gt; object (or a drop-in replacement) that is used to extract doctests from the module.</source>
          <target state="translated">선택적 인수 &lt;em&gt; test_finder&lt;/em&gt; 는 모듈에서 doctest를 추출하는 데 사용되는 &lt;a href=&quot;#doctest.DocTestFinder&quot;&gt; &lt;code&gt;DocTestFinder&lt;/code&gt; &lt;/a&gt; 객체 (또는 드롭 인 대체)입니다.</target>
        </trans-unit>
        <trans-unit id="db4c1cc5f02a40eafb0ed3a5823be338fcf19c2f" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;verbose&lt;/em&gt; prints lots of stuff if true, and prints only failures if false; by default, or if &lt;code&gt;None&lt;/code&gt;, it&amp;rsquo;s true if and only if &lt;code&gt;'-v'&lt;/code&gt; is in &lt;code&gt;sys.argv&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;verbose&lt;/em&gt; 는 true 인 경우 많은 것을 인쇄하고 false 인 경우 실패 만 인쇄합니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code&gt;'-v'&lt;/code&gt; 가 &lt;code&gt;sys.argv&lt;/code&gt; 에있는 경우에만 true 입니다. .</target>
        </trans-unit>
        <trans-unit id="b8153f139b45d286bc6ada5dd1d390a6a4123c3f" translate="yes" xml:space="preserve">
          <source>Optional argument:</source>
          <target state="translated">선택적 인수 :</target>
        </trans-unit>
        <trans-unit id="dc3411c4765a5302ac4a0657ce51631f57505a0c" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;em&gt;extraglobs&lt;/em&gt;, &lt;em&gt;verbose&lt;/em&gt;, &lt;em&gt;report&lt;/em&gt;, &lt;em&gt;optionflags&lt;/em&gt;, &lt;em&gt;raise_on_error&lt;/em&gt;, and &lt;em&gt;globs&lt;/em&gt; are the same as for function &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; above, except that &lt;em&gt;globs&lt;/em&gt; defaults to &lt;code&gt;m.__dict__&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;extraglobs&lt;/em&gt; , &lt;em&gt;verbose&lt;/em&gt; , &lt;em&gt;report&lt;/em&gt; , &lt;em&gt;optionflags&lt;/em&gt; , &lt;em&gt;raise_on_error&lt;/em&gt; 및 &lt;em&gt;globs&lt;/em&gt; 옵션 인수 는 위의 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 함수 와 동일합니다.&lt;em&gt; globs의&lt;/em&gt; 기본값이 &lt;code&gt;m.__dict__&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="66014d9b1f3041cfd84a26a994534d9a74b11dd8" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;em&gt;setUp&lt;/em&gt;, &lt;em&gt;tearDown&lt;/em&gt;, and &lt;em&gt;optionflags&lt;/em&gt; are the same as for function &lt;a href=&quot;#doctest.DocFileSuite&quot;&gt;&lt;code&gt;DocFileSuite()&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">선택적 인수 &lt;em&gt;setUp&lt;/em&gt; , &lt;em&gt;tearDown&lt;/em&gt; 및 &lt;em&gt;optionflags&lt;/em&gt; 는 &lt;a href=&quot;#doctest.DocFileSuite&quot;&gt; &lt;code&gt;DocFileSuite()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다. 위의 합니다.</target>
        </trans-unit>
        <trans-unit id="9e6ad614ba64534bb9b35c5be45e412b81787e19" translate="yes" xml:space="preserve">
          <source>Optional encrypted password</source>
          <target state="translated">선택적인 암호화 된 비밀번호</target>
        </trans-unit>
        <trans-unit id="800aa892de20413e219a54b37b3156efd477e617" translate="yes" xml:space="preserve">
          <source>Optional keyword argument &lt;em&gt;initial_response_ok&lt;/em&gt; specifies whether, for authentication methods that support it, an &amp;ldquo;initial response&amp;rdquo; as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc4954.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 4954&lt;/strong&gt;&lt;/a&gt; can be sent along with the &lt;code&gt;AUTH&lt;/code&gt; command, rather than requiring a challenge/response.</source>
          <target state="translated">선택적 키워드 인수 &lt;em&gt;initial_response_ok&lt;/em&gt; 는이를 지원하는 인증 방법에 대해 &lt;a href=&quot;https://tools.ietf.org/html/rfc4954.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 4954에&lt;/strong&gt;&lt;/a&gt; 지정된대로 &quot;초기 응답&quot;을 지정합니다.&lt;strong&gt;&lt;/strong&gt; 시도 / 응답을 요구하지 않고 &lt;code&gt;AUTH&lt;/code&gt; 명령 과 함께 보낼 수 .</target>
        </trans-unit>
        <trans-unit id="39ded4fc07cc53be3f3b4d11b5ad6e335cab1088" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments correspond to the instance attributes of &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt;, documented below. &lt;em&gt;width&lt;/em&gt; defaults to &lt;code&gt;70&lt;/code&gt;.</source>
          <target state="translated">선택적 키워드 인수는 아래에 설명 된 &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt; 의 인스턴스 속성에 해당 합니다.&lt;em&gt;폭&lt;/em&gt; 기본적으로 &lt;code&gt;70&lt;/code&gt; 입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="3b9eb4e0be951f4005e2e9357a99b2eb0d75d912" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments correspond to the instance attributes of &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt;, documented below. Note that the whitespace is collapsed before the text is passed to the &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#textwrap.fill&quot;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/a&gt; function, so changing the value of &lt;a href=&quot;#textwrap.TextWrapper.tabsize&quot;&gt;&lt;code&gt;tabsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#textwrap.TextWrapper.expand_tabs&quot;&gt;&lt;code&gt;expand_tabs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#textwrap.TextWrapper.drop_whitespace&quot;&gt;&lt;code&gt;drop_whitespace&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt;&lt;code&gt;replace_whitespace&lt;/code&gt;&lt;/a&gt; will have no effect.</source>
          <target state="translated">선택적 키워드 인수는 아래에 설명 된 &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt; 의 인스턴스 속성에 해당 합니다. 텍스트가 &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#textwrap.fill&quot;&gt; &lt;code&gt;fill()&lt;/code&gt; &lt;/a&gt; 함수에 전달되기 전에 공백이 축소 되므로 &lt;a href=&quot;#textwrap.TextWrapper.tabsize&quot;&gt; &lt;code&gt;tabsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#textwrap.TextWrapper.expand_tabs&quot;&gt; &lt;code&gt;expand_tabs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#textwrap.TextWrapper.drop_whitespace&quot;&gt; &lt;code&gt;drop_whitespace&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt; &lt;code&gt;replace_whitespace&lt;/code&gt; &lt;/a&gt;도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="24ca019c9c45a21a1ae8afa31bdc446f05002f0e" translate="yes" xml:space="preserve">
          <source>Optional keyword parameters &lt;em&gt;linejunk&lt;/em&gt; and &lt;em&gt;charjunk&lt;/em&gt; are filtering functions (or &lt;code&gt;None&lt;/code&gt;):</source>
          <target state="translated">선택적 키워드 매개 변수 &lt;em&gt;linejunk&lt;/em&gt; 및 &lt;em&gt;charjunk&lt;/em&gt; 는 필터링 기능 (또는 &lt;code&gt;None&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0a70313273eae3e208c193164419f6a9bd989124" translate="yes" xml:space="preserve">
          <source>Optional keyword parameters &lt;em&gt;linejunk&lt;/em&gt; and &lt;em&gt;charjunk&lt;/em&gt; are for filter functions (or &lt;code&gt;None&lt;/code&gt;):</source>
          <target state="translated">선택적 키워드 매개 변수 &lt;em&gt;linejunk&lt;/em&gt; 및 &lt;em&gt;charjunk&lt;/em&gt; 는 필터 기능 (또는 &lt;code&gt;None&lt;/code&gt; ) 용입니다.</target>
        </trans-unit>
        <trans-unit id="73738e459fc48b15d4c9caa2fae00dc51ed6861e" translate="yes" xml:space="preserve">
          <source>Optional opaque data associated to this file object: for example, this could be used to store a per-client session ID.</source>
          <target state="translated">이 파일 객체와 관련된 선택적인 불투명 데이터 : 예를 들어 클라이언트 별 세션 ID를 저장하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c45096fc76de56eedec7a2b606f898390e6242" translate="yes" xml:space="preserve">
          <source>Optional type.</source>
          <target state="translated">선택적 유형.</target>
        </trans-unit>
        <trans-unit id="7378235c39ea460a01142b753df9f73551ec2ce1" translate="yes" xml:space="preserve">
          <source>Optionally, a callable with a &lt;code&gt;(obj, state)&lt;/code&gt; signature. This callable allows the user to programmatically control the state-updating behavior of a specific object, instead of using &lt;code&gt;obj&lt;/code&gt;&amp;rsquo;s static &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt; method. If not &lt;code&gt;None&lt;/code&gt;, this callable will have priority over &lt;code&gt;obj&lt;/code&gt;&amp;rsquo;s &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적으로, &lt;code&gt;(obj, state)&lt;/code&gt; 서명이 있는 호출 가능 . 이 콜 &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; 을 통해 사용자는 &lt;code&gt;obj&lt;/code&gt; 의 정적 __setstate __ () 메서드 를 사용하는 대신 특정 객체의 상태 업데이트 동작을 프로그래밍 방식으로 제어 할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 ,이 호출 가능 &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;obj&lt;/code&gt; 의 __setstate __ () 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="248e8ab0a4779d85c841d158ffbba3ab30529149" translate="yes" xml:space="preserve">
          <source>Optionally, an iterator (and not a sequence) yielding successive items. These items will be appended to the object either using &lt;code&gt;obj.append(item)&lt;/code&gt; or, in batch, using &lt;code&gt;obj.extend(list_of_items)&lt;/code&gt;. This is primarily used for list subclasses, but may be used by other classes as long as they have &lt;code&gt;append()&lt;/code&gt; and &lt;code&gt;extend()&lt;/code&gt; methods with the appropriate signature. (Whether &lt;code&gt;append()&lt;/code&gt; or &lt;code&gt;extend()&lt;/code&gt; is used depends on which pickle protocol version is used as well as the number of items to append, so both must be supported.)</source>
          <target state="translated">선택적으로, 반복자 (시퀀스 아님)는 연속적인 항목을 생성합니다. 이러한 항목은 &lt;code&gt;obj.append(item)&lt;/code&gt; 하거나 &lt;code&gt;obj.extend(list_of_items)&lt;/code&gt; 사용하여 일괄 적으로 객체에 추가됩니다 . 이것은 주로리스트 서브 클래스에 사용되지만 적절한 서명 을 가진 &lt;code&gt;append()&lt;/code&gt; 및 &lt;code&gt;extend()&lt;/code&gt; 메소드가있는 한 다른 클래스에서 사용될 수 있습니다 . (여부를 &lt;code&gt;append()&lt;/code&gt; 또는 &lt;code&gt;extend()&lt;/code&gt; 모두 지원해야하므로 잘 추가되는 항목의 수만큼 사용하는 피클 프로토콜 버전에 따라 사용된다.)</target>
        </trans-unit>
        <trans-unit id="4d9b55e743d6156b61e3533878c6208bad417979" translate="yes" xml:space="preserve">
          <source>Optionally, an iterator (not a sequence) yielding successive key-value pairs. These items will be stored to the object using &lt;code&gt;obj[key] =
value&lt;/code&gt;. This is primarily used for dictionary subclasses, but may be used by other classes as long as they implement &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적으로, 반복자 (시퀀스 아님)는 연속 키-값 쌍을 생성합니다. 이 항목들은 &lt;code&gt;obj[key] = value&lt;/code&gt; 사용하여 객체에 저장됩니다 . 이것은 주로 사전 서브 클래스에 사용되지만 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; 을 구현하는 한 다른 클래스에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9542e7876fb05dd3c13e6d5bd0e264709c2e4f0" translate="yes" xml:space="preserve">
          <source>Optionally, delete the &lt;code&gt;.dist-info&lt;/code&gt; directories created by pip in the &lt;code&gt;myapp&lt;/code&gt; directory. These hold metadata for pip to manage the packages, and as you won&amp;rsquo;t be making any further use of pip they aren&amp;rsquo;t required - although it won&amp;rsquo;t do any harm if you leave them.</source>
          <target state="translated">선택적으로 &lt;code&gt;myapp&lt;/code&gt; 디렉토리 에서 pip로 작성된 &lt;code&gt;.dist-info&lt;/code&gt; 디렉토리를 삭제하십시오 . 이것들은 패키지를 관리하기 위해 pip에 대한 메타 데이터를 보유하고 있으며, pip를 더 이상 사용하지 않기 때문에 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a52acaea3b3a3449dba5140bba2c078c062d5d24" translate="yes" xml:space="preserve">
          <source>Optionally, the object&amp;rsquo;s state, which will be passed to the object&amp;rsquo;s &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt; method as previously described. If the object has no such method then, the value must be a dictionary and it will be added to the object&amp;rsquo;s &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">선택적으로 객체의 상태 는 앞에서 설명한 것처럼 객체의 &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; 메서드로 전달됩니다 . 객체에 그러한 메소드가없는 경우 값은 사전이어야하며 객체의 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 속성에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="4db22efa7fc9873f3af05807c67613b164308c33" translate="yes" xml:space="preserve">
          <source>Options control things like the color and border width of a widget. Options can be set in three ways:</source>
          <target state="translated">옵션은 위젯의 색상 및 테두리 너비와 같은 것을 제어합니다. 옵션은 세 가지 방법으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de536fda840f7da591573c96c013aeef7cd818d1" translate="yes" xml:space="preserve">
          <source>Options may be provided as keyword arguments:</source>
          <target state="translated">옵션은 키워드 인수로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8335036bab3bafd620537f0b69b86754c080951f" translate="yes" xml:space="preserve">
          <source>Options menu (Shell and Editor)</source>
          <target state="translated">옵션 메뉴 (쉘 및 편집기)</target>
        </trans-unit>
        <trans-unit id="92ce2ae7dc9f79aa3ed9c94ea1705d8d6e562c73" translate="yes" xml:space="preserve">
          <source>Or directly from a string:</source>
          <target state="translated">또는 문자열에서 직접 :</target>
        </trans-unit>
        <trans-unit id="29bb859d05bc7a567ae7f7cc079e9b6720bf0d15" translate="yes" xml:space="preserve">
          <source>Or if a pending task needs to be deleted, how do you find it and remove it from the queue?</source>
          <target state="translated">또는 보류중인 작업을 삭제해야하는 경우 작업을 어떻게 찾아 대기열에서 제거합니까?</target>
        </trans-unit>
        <trans-unit id="4b22593950042710b50dc4a4f90e32e24951a382" translate="yes" xml:space="preserve">
          <source>Or, more often:</source>
          <target state="translated">또는 더 자주 :</target>
        </trans-unit>
        <trans-unit id="1d1f8ef58bd7839e3af26e1c41a86b651180494a" translate="yes" xml:space="preserve">
          <source>Ordered and equality comparisons are supported between ST objects. Pickling of ST objects (using the &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module) is also supported.</source>
          <target state="translated">ST 오브젝트간에 순서 및 동등 비교가 지원됩니다. ST 객체의 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; ( 피클 모듈 사용)도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ec2fcd9ffa26d70803882357a146da9dcfdec817" translate="yes" xml:space="preserve">
          <source>Ordered comparisons between enumeration values are &lt;em&gt;not&lt;/em&gt; supported. Enum members are not integers (but see &lt;a href=&quot;#intenum&quot;&gt;IntEnum&lt;/a&gt; below):</source>
          <target state="translated">열거 값 사이의 순서 비교는 지원 &lt;em&gt;되지 않습니다&lt;/em&gt; . 열거 형 멤버는 정수가 아닙니다 (그러나 아래의 &lt;a href=&quot;#intenum&quot;&gt;IntEnum&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="eb500fa39e2390f334d105e01309ce69a01fcb03" translate="yes" xml:space="preserve">
          <source>Ordered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7).</source>
          <target state="translated">정렬 된 사전은 일반 사전과 비슷하지만 주문 작업과 관련된 몇 가지 추가 기능이 있습니다. 내장 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 클래스가 삽입 순서를 기억하는 기능을 얻었으므로 이제 덜 중요해졌습니다 (이 새로운 동작은 Python 3.7에서 보장되었습니다).</target>
        </trans-unit>
        <trans-unit id="26bb7103f52c11aaccca56efca197b3b55b4bca3" translate="yes" xml:space="preserve">
          <source>OrderedDict objects</source>
          <target state="translated">OrderedDict 객체</target>
        </trans-unit>
        <trans-unit id="67243e03b42bd26dc3e495a6d0366676bb3fea02" translate="yes" xml:space="preserve">
          <source>OrderedEnum</source>
          <target state="translated">OrderedEnum</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="e5dd46594071b12b0a7a38e3a2f8a892e95aa71b" translate="yes" xml:space="preserve">
          <source>Ordinarily, you get a message object structure by passing a file or some text to a parser, which parses the text and returns the root message object. However you can also build a complete message structure from scratch, or even individual &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; objects by hand. In fact, you can also take an existing structure and add new &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; objects, move them around, etc. This makes a very convenient interface for slicing-and-dicing MIME messages.</source>
          <target state="translated">일반적으로 파일 또는 일부 텍스트를 파서에 전달하여 텍스트를 구문 분석하고 루트 메시지 객체를 반환하여 메시지 객체 구조를 얻습니다. 그러나 처음부터 전체 메시지 구조를 만들거나 개별 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 개체를 직접 만들 수도 있습니다. 실제로 기존 구조를 가져 와서 새 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체를 추가 하거나 이동시킬 수도 있습니다. 이렇게하면 MIME 메시지를 슬라이스 및 표시하기위한 매우 편리한 인터페이스가 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="7a430640bbf526678a8da4fb85c2d06d96431f50" translate="yes" xml:space="preserve">
          <source>Organizing test code</source>
          <target state="translated">테스트 코드 구성</target>
        </trans-unit>
        <trans-unit id="1cedde9b69ce01ae9f01a497a5daf62fb6786f91" translate="yes" xml:space="preserve">
          <source>Original Python logging package</source>
          <target state="translated">원래 파이썬 로깅 패키지</target>
        </trans-unit>
        <trans-unit id="0bf18896b8755bd61d4e426a9647970dd9cbbd69" translate="yes" xml:space="preserve">
          <source>Original specification of packages. Some semantics have changed since the writing of this document (e.g. redirecting based on &lt;code&gt;None&lt;/code&gt; in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">패키지의 원래 사양. 이 문서를 작성한 이후 일부 의미가 변경되었습니다 (예 : &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 의&lt;/a&gt; &lt;code&gt;None&lt;/code&gt; 을 기반으로 리디렉션 ).</target>
        </trans-unit>
        <trans-unit id="d8f4478364a57d8876305d6f8a4f1737017ec09e" translate="yes" xml:space="preserve">
          <source>Originally added in 3.3 as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;provisional feature&lt;/a&gt;.</source>
          <target state="translated">원래 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;임시 기능&lt;/a&gt; 으로 3.3에 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="044d5151be7c1b4dd05b8491c7d04527149f63bb" translate="yes" xml:space="preserve">
          <source>Originally added in 3.3 as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;provisional module&lt;/a&gt;</source>
          <target state="translated">3.3에서 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;임시 모듈&lt;/a&gt; 로 원래 추가</target>
        </trans-unit>
        <trans-unit id="3760d15c033b2bd980e7e3d2725429e9f2f28376" translate="yes" xml:space="preserve">
          <source>Originally added in 3.4 as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;provisional module&lt;/a&gt;</source>
          <target state="translated">3.4에서 원래 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;임시 모듈&lt;/a&gt; 로 추가</target>
        </trans-unit>
        <trans-unit id="b2fbc34ec2e89a23970dd81d7e81d17186c5721a" translate="yes" xml:space="preserve">
          <source>Originally added in 3.4 as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;provisional module&lt;/a&gt;. Docs for legacy message class moved to &lt;a href=&quot;email.compat32-message#compat32-message&quot;&gt;email.message.Message: Representing an email message using the compat32 API&lt;/a&gt;.</source>
          <target state="translated">원래 3.4에서 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-provisional-package&quot;&gt;임시 모듈&lt;/a&gt; 로 추가되었습니다 . 레거시 메시지 클래스 용 문서가 &lt;a href=&quot;email.compat32-message#compat32-message&quot;&gt;email.message.Message&lt;/a&gt; 로 이동되었습니다 . compat32 API를 사용하여 이메일 메시지를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c26e6600df66b0af63b8bf38fb88a3db87e5308a" translate="yes" xml:space="preserve">
          <source>Originally specified in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">원래 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;PEP 302에&lt;/strong&gt;&lt;/a&gt; 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f514af7ee84123103b91a2dc752d472d7d48914" translate="yes" xml:space="preserve">
          <source>Originally specified in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">원래 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 302에&lt;/strong&gt;&lt;/a&gt; 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d378e398249f21f59f2d17eaa22696c733bca01" translate="yes" xml:space="preserve">
          <source>Originally, the &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module had attempted to maintain compatibility with &lt;a href=&quot;optparse#module-optparse&quot;&gt;&lt;code&gt;optparse&lt;/code&gt;&lt;/a&gt;. However, &lt;a href=&quot;optparse#module-optparse&quot;&gt;&lt;code&gt;optparse&lt;/code&gt;&lt;/a&gt; was difficult to extend transparently, particularly with the changes required to support the new &lt;code&gt;nargs=&lt;/code&gt; specifiers and better usage messages. When most everything in &lt;a href=&quot;optparse#module-optparse&quot;&gt;&lt;code&gt;optparse&lt;/code&gt;&lt;/a&gt; had either been copy-pasted over or monkey-patched, it no longer seemed practical to try to maintain the backwards compatibility.</source>
          <target state="translated">원래 &lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;a href=&quot;optparse#module-optparse&quot;&gt; &lt;code&gt;optparse&lt;/code&gt; &lt;/a&gt; 와의 호환성을 유지하려고 시도했습니다 . 그러나 &lt;a href=&quot;optparse#module-optparse&quot;&gt; &lt;code&gt;optparse&lt;/code&gt; &lt;/a&gt; 는 특히 새로운 &lt;code&gt;nargs=&lt;/code&gt; 지정자와 더 나은 사용법 메시지 를 지원하는 데 필요한 변경 사항으로 인해 투명하게 확장하기가 어려웠습니다 . &lt;a href=&quot;optparse#module-optparse&quot;&gt; &lt;code&gt;optparse&lt;/code&gt; 의&lt;/a&gt; 대부분 이 복사-붙여 넣기 또는 원숭이 패치로 이루어 졌을 때 더 이상 이전 버전과의 호환성을 유지하려고 시도하는 것이 현실적으로 보이지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fed34ee486c7f5d06dbc7cfc681f00ddfcaf011b" translate="yes" xml:space="preserve">
          <source>Other Built-in Types</source>
          <target state="translated">다른 내장 유형</target>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">다른 예</target>
        </trans-unit>
        <trans-unit id="551852c7028ddd04d28686d5a46f202fe2ad7cb7" translate="yes" xml:space="preserve">
          <source>Other Functions</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="217af07f6b149416704b03c95cdb3752965dd4b3" translate="yes" xml:space="preserve">
          <source>Other Graphical User Interface Packages</source>
          <target state="translated">다른 그래픽 사용자 인터페이스 패키지</target>
        </trans-unit>
        <trans-unit id="b8882f948dba0fc11ba9a6b54e264027bb74d52f" translate="yes" xml:space="preserve">
          <source>Other Module Level Functions</source>
          <target state="translated">다른 모듈 레벨 기능</target>
        </trans-unit>
        <trans-unit id="88f1a5da8a5bf979a3ede7f700833eb578841312" translate="yes" xml:space="preserve">
          <source>Other Unicode decimal digits are also permitted where &lt;code&gt;digit&lt;/code&gt; appears above. These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits &lt;code&gt;'\uff10'&lt;/code&gt; through &lt;code&gt;'\uff19'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;digit&lt;/code&gt; 가 위에 나타나는 다른 유니 코드 10 진수도 허용 됩니다. 여기에는 다양한 다른 알파벳의 십진수 (예 : 아랍어-인도 및 데바 나가리 숫자)와 전각 자릿수 &lt;code&gt;'\uff10'&lt;/code&gt; ~ &lt;code&gt;'\uff19'&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff9d748c4bd543f9761aa15fcf1968d71aec0ec7" translate="yes" xml:space="preserve">
          <source>Other arguments:</source>
          <target state="translated">다른 주장들 :</target>
        </trans-unit>
        <trans-unit id="a90e10ae9215677f534e2d324d08bda0a668ca69" translate="yes" xml:space="preserve">
          <source>Other attributes may exist, but they are private and must not be inspected or relied on.</source>
          <target state="translated">다른 속성이 존재할 수 있지만 개인 속성이므로 검사하거나 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="aedb03b71d3d53b256c55d31e3a1023846152365" translate="yes" xml:space="preserve">
          <source>Other constructor:</source>
          <target state="translated">다른 생성자 :</target>
        </trans-unit>
        <trans-unit id="de575b19ab55681e0fd9c92fcea7275245bb42c9" translate="yes" xml:space="preserve">
          <source>Other constructors, all class methods:</source>
          <target state="translated">다른 생성자, 모든 클래스 메소드 :</target>
        </trans-unit>
        <trans-unit id="e12e322f5b694198963cd183428de579cc666876" translate="yes" xml:space="preserve">
          <source>Other functions</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="bfdf1a80a42b89f60d8528660ffb1316928b3b7c" translate="yes" xml:space="preserve">
          <source>Other library modules may provide additional ways to create text or binary streams. See &lt;a href=&quot;socket#socket.socket.makefile&quot;&gt;&lt;code&gt;socket.socket.makefile()&lt;/code&gt;&lt;/a&gt; for example.</source>
          <target state="translated">다른 라이브러리 모듈은 텍스트 또는 이진 스트림을 만드는 추가 방법을 제공 할 수 있습니다. 예를 들어 &lt;a href=&quot;socket#socket.socket.makefile&quot;&gt; &lt;code&gt;socket.socket.makefile()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="461f70e81617707a4ef7e08e0bf02afe3f4f0770" translate="yes" xml:space="preserve">
          <source>Other methods must be called with the associated lock held. The &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method releases the lock, and then blocks until another thread awakens it by calling &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt;. Once awakened, &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; re-acquires the lock and returns. It is also possible to specify a timeout.</source>
          <target state="translated">연관된 잠금을 보유한 상태에서 다른 메소드를 호출해야합니다. &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 다른 스레드가 호출하여 깨어 때까지 방법은 다음 블록을 잠금을 해제하고, &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; . 깨어 나면 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 는 잠금을 다시 획득하고 반환합니다. 제한 시간을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8806cd1edbc02b7ee32a1acfc728cd7ae05ec92a" translate="yes" xml:space="preserve">
          <source>Other modules that provide Tk support include:</source>
          <target state="translated">Tk 지원을 제공하는 다른 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c094da946507173bdbcbc9838b22e11fb790816a" translate="yes" xml:space="preserve">
          <source>Other parameters:</source>
          <target state="translated">다른 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="61bf50f22a61fb1a7d3d05d04ae2081ef3a300b7" translate="yes" xml:space="preserve">
          <source>Other references to the old objects (such as names external to the module) are not rebound to refer to the new objects and must be updated in each namespace where they occur if that is desired.</source>
          <target state="translated">이전 객체에 대한 다른 참조 (예 : 모듈 외부의 이름)는 새 객체를 참조하기 위해 리 바인드되지 않으며 원하는 경우 각 네임 스페이스에서 업데이트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba9b5975c5a17860bfd12921bda717270fc0fabd" translate="yes" xml:space="preserve">
          <source>Other than the &lt;em&gt;ensure_ascii&lt;/em&gt; parameter, this module is defined strictly in terms of conversion between Python objects and &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;Unicode strings&lt;/code&gt;&lt;/a&gt;, and thus does not otherwise directly address the issue of character encodings.</source>
          <target state="translated">댄 다른 &lt;em&gt;ensure_ascii&lt;/em&gt; 파라미터는,이 모듈은 파이썬 개체 간의 전환의 관점에서 엄격하게 정의 된 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;Unicode strings&lt;/code&gt; &lt;/a&gt; 달리 직접 문자 인코딩의 문제가 해결되지 않기 때문에, 그리고.</target>
        </trans-unit>
        <trans-unit id="334ae5c0280a33be6e1a7440bb997991c7be3c2d" translate="yes" xml:space="preserve">
          <source>Other than the text mode requirement, this method operates like &lt;a href=&quot;#email.parser.BytesParser.parse&quot;&gt;&lt;code&gt;BytesParser.parse()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">텍스트 모드 요구 사항 &lt;a href=&quot;#email.parser.BytesParser.parse&quot;&gt; &lt;code&gt;BytesParser.parse()&lt;/code&gt; &lt;/a&gt; 메서드는 BytesParser.parse () 와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="82d46ce3715467bc2baf73f7bf0f1e61e7104b2a" translate="yes" xml:space="preserve">
          <source>Other threads can call a thread&amp;rsquo;s &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method. This blocks the calling thread until the thread whose &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method is called is terminated.</source>
          <target state="translated">다른 스레드는 스레드의 &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 . &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 스레드 가 종료 될 때까지 호출 스레드를 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="80ebcb8c2214303bc68c1b27cf91f38d351836db" translate="yes" xml:space="preserve">
          <source>Other typical Boolean pairs include &lt;code&gt;accept&lt;/code&gt;/&lt;code&gt;reject&lt;/code&gt; or &lt;code&gt;enabled&lt;/code&gt;/&lt;code&gt;disabled&lt;/code&gt;.</source>
          <target state="translated">다른 일반적인 부울 쌍에는 &lt;code&gt;accept&lt;/code&gt; / &lt;code&gt;reject&lt;/code&gt; 또는 &lt;code&gt;enabled&lt;/code&gt; / &lt;code&gt;disabled&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="09b2b2f9de07b290a776ba27da53dfcb6de8c87b" translate="yes" xml:space="preserve">
          <source>Other utilities</source>
          <target state="translated">다른 유틸리티</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="a8f27da35e68a9f7a5a97f1703ac92769848a8d4" translate="yes" xml:space="preserve">
          <source>Others have execute permission.</source>
          <target state="translated">다른 사람에게는 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b5a656b29825a9211b83ccae7336ee695ce161" translate="yes" xml:space="preserve">
          <source>Others have read permission.</source>
          <target state="translated">다른 사람들에게는 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0d4f6a481380e178acd3897e6a60f3ade59b6a" translate="yes" xml:space="preserve">
          <source>Others have write permission.</source>
          <target state="translated">다른 사람들은 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4222ac892c71e5c85c46120851fe4701ec7917d" translate="yes" xml:space="preserve">
          <source>Otherwise (the signal is trapped), only equality comparisons and explicit conversions are silent. All other mixed operations raise &lt;a href=&quot;#decimal.FloatOperation&quot;&gt;&lt;code&gt;FloatOperation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면 (신호가 갇히는) 등식 비교 및 ​​명시 적 변환 만 자동입니다. 다른 모든 혼합 연산은 &lt;a href=&quot;#decimal.FloatOperation&quot;&gt; &lt;code&gt;FloatOperation&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be46edea33f2697996c7c3567d1d9c18f067cdc7" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;em&gt;d&lt;/em&gt; is naive.</source>
          <target state="translated">그렇지 않으면 &lt;em&gt;d&lt;/em&gt; 는 순진합니다.</target>
        </trans-unit>
        <trans-unit id="dfc31f535285ad24b8fa6617987e28a96cbb3d87" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;em&gt;t&lt;/em&gt; is naive.</source>
          <target state="translated">그렇지 않으면, &lt;em&gt;t&lt;/em&gt; 는 순진합니다.</target>
        </trans-unit>
        <trans-unit id="954ba79aef749f40f5d5ce28f2bceb67836f96e6" translate="yes" xml:space="preserve">
          <source>Otherwise, arguments are files opened for editing and &lt;code&gt;sys.argv&lt;/code&gt; reflects the arguments passed to IDLE itself.</source>
          <target state="translated">그렇지 않으면, 인수는 편집을 위해 열린 파일이고 &lt;code&gt;sys.argv&lt;/code&gt; 는 IDLE 자체에 전달 된 인수를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="14b72810afd38383fb343bc867db69c78f448477" translate="yes" xml:space="preserve">
          <source>Otherwise, if no argument is provided, or if the argument is &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;token_*&lt;/code&gt; functions will use a reasonable default instead.</source>
          <target state="translated">그렇지 않으면 인수가 제공되지 않거나 인수가 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code&gt;token_*&lt;/code&gt; 함수가 대신 적절한 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="54d61e7a8adc1736b3a4f7ffa32c6559beb44abf" translate="yes" xml:space="preserve">
          <source>Otherwise, if the argument is an integer or a floating point number, a floating point number with the same value (within Python&amp;rsquo;s floating point precision) is returned. If the argument is outside the range of a Python float, an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">그렇지 않으면, 인수가 정수 또는 부동 소수점 숫자이면, 파이썬의 부동 소수점 정밀도 내에서 동일한 값을 갖는 부동 소수점 숫자가 리턴됩니다. 인수가 Python float 범위를 벗어나면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ecea0cd28243a5441c028877a147bc1209dbb6d" translate="yes" xml:space="preserve">
          <source>Otherwise, return a list of &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt; pairs for the options in the given &lt;em&gt;section&lt;/em&gt;. Optional arguments have the same meaning as for the &lt;a href=&quot;#configparser.ConfigParser.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">그렇지 않으면 주어진 &lt;em&gt;섹션&lt;/em&gt; 의 옵션에 대한 &lt;em&gt;이름&lt;/em&gt; , &lt;em&gt;값&lt;/em&gt; 쌍 의 목록을 리턴 &lt;em&gt;하십시오&lt;/em&gt; . 선택적 인수는 &lt;a href=&quot;#configparser.ConfigParser.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="9b46eb0d416a3552e2d7853ed1ba1f77360411e1" translate="yes" xml:space="preserve">
          <source>Otherwise, the backslash will be interpreted as part of the string. For example, the &lt;code&gt;\n&lt;/code&gt; above would be interpreted as a newline character. Alternatively, you can double each backslash in the doctest version (and not use a raw string):</source>
          <target state="translated">그렇지 않으면 백 슬래시는 문자열의 일부로 해석됩니다. 예를 들어, 위 의 &lt;code&gt;\n&lt;/code&gt; 은 개행 문자로 해석됩니다. 또는 doctest 버전에서 각 백 슬래시를 두 배로 늘릴 수 있습니다 (원시 문자열은 사용하지 않음).</target>
        </trans-unit>
        <trans-unit id="70814fdd5d3f962107665d79424d211168c0dc43" translate="yes" xml:space="preserve">
          <source>Otherwise, the list contains the object&amp;rsquo;s attributes&amp;rsquo; names, the names of its class&amp;rsquo;s attributes, and recursively of the attributes of its class&amp;rsquo;s base classes.</source>
          <target state="translated">그렇지 않으면, 목록에는 객체의 속성 이름, 클래스 속성의 이름 및 클래스 기본 클래스의 속성이 반복적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f7030a7d49fcfe877e91d4527075807bf0b11fd0" translate="yes" xml:space="preserve">
          <source>Our XML now looks like this:</source>
          <target state="translated">우리의 XML은 이제 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="0be297b561141a6a2d82a7108dddc36e1cc22dba" translate="yes" xml:space="preserve">
          <source>Out of memory</source>
          <target state="translated">메모리 부족</target>
        </trans-unit>
        <trans-unit id="af8eb7df148c890efac2f2ede67c967bf68723f5" translate="yes" xml:space="preserve">
          <source>Out of streams resources</source>
          <target state="translated">스트림 외부 자원</target>
        </trans-unit>
        <trans-unit id="63664fd5af35bc0c3fdff750f9b0e30b4646a15c" translate="yes" xml:space="preserve">
          <source>Out-of-band Buffers</source>
          <target state="translated">대역 외 버퍼</target>
        </trans-unit>
        <trans-unit id="3fac09e90cfccb47e52c968f4fb653462a3d8c88" translate="yes" xml:space="preserve">
          <source>Output in debug mode:</source>
          <target state="translated">디버그 모드에서 출력 :</target>
        </trans-unit>
        <trans-unit id="fe984ffd01f834b22054ca88048eb74573f00d01" translate="yes" xml:space="preserve">
          <source>Output of the child process if it was captured by &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#subprocess.check_output&quot;&gt;&lt;code&gt;check_output()&lt;/code&gt;&lt;/a&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#subprocess.check_output&quot;&gt; &lt;code&gt;check_output()&lt;/code&gt; &lt;/a&gt; 의해 캡처 된 하위 프로세스의 출력입니다 . 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc05deb2ab45aebe353e699363a7fbb6c0b73af3" translate="yes" xml:space="preserve">
          <source>Output parameter. The foreign function fills in a value.</source>
          <target state="translated">출력 매개 변수. 외부 함수는 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="66226a3b482e757cb52b81b1728ded2d649bd5c1" translate="yes" xml:space="preserve">
          <source>Output parameters can be combined with the &lt;code&gt;errcheck&lt;/code&gt; protocol to do further output processing and error checking. The win32 &lt;code&gt;GetWindowRect&lt;/code&gt; api function returns a &lt;code&gt;BOOL&lt;/code&gt; to signal success or failure, so this function could do the error checking, and raises an exception when the api call failed:</source>
          <target state="translated">출력 매개 변수를 &lt;code&gt;errcheck&lt;/code&gt; 프로토콜 과 결합하여 추가 출력 처리 및 오류 점검을 수행 할 수 있습니다 . win32 &lt;code&gt;GetWindowRect&lt;/code&gt; api 함수는 성공 또는 실패를 &lt;code&gt;BOOL&lt;/code&gt; 위해 BOOL 을 반환하므로이 함수는 오류 검사를 수행하고 api 호출이 실패하면 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6c41c030d36ce42b9a8cad80e0baa996c85ae9c1" translate="yes" xml:space="preserve">
          <source>Output to stdout is captured, but not output to stderr (exception tracebacks are captured via a different means).</source>
          <target state="translated">stdout으로의 출력은 캡처되지만 stderr 로의 출력은 제외됩니다 (예외 추적은 다른 방법을 통해 캡처 됨).</target>
        </trans-unit>
        <trans-unit id="052c8a28d79036323fd83c172b2396b59d5c7af9" translate="yes" xml:space="preserve">
          <source>Output windows, such as used for Edit =&amp;gt; Find in Files, are a subtype of editor window. They currently have the same top menu but a different default title and context menu.</source>
          <target state="translated">편집 =&amp;gt; 파일에서 찾기와 같은 출력 창은 편집기 창의 하위 유형입니다. 현재 동일한 최상위 메뉴가 있지만 기본 제목 및 상황에 맞는 메뉴가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="0d058e922b3d393665a54054e5a68be683df369b" translate="yes" xml:space="preserve">
          <source>OutputChecker objects</source>
          <target state="translated">OutputChecker 객체</target>
        </trans-unit>
        <trans-unit id="00b098b7354feb36c1140185524d89b0a668ca13" translate="yes" xml:space="preserve">
          <source>Outputs a symbolic disassembly of the pickle to the file-like object &lt;em&gt;out&lt;/em&gt;, defaulting to &lt;code&gt;sys.stdout&lt;/code&gt;. &lt;em&gt;pickle&lt;/em&gt; can be a string or a file-like object. &lt;em&gt;memo&lt;/em&gt; can be a Python dictionary that will be used as the pickle&amp;rsquo;s memo; it can be used to perform disassemblies across multiple pickles created by the same pickler. Successive levels, indicated by &lt;code&gt;MARK&lt;/code&gt; opcodes in the stream, are indented by &lt;em&gt;indentlevel&lt;/em&gt; spaces. If a nonzero value is given to &lt;em&gt;annotate&lt;/em&gt;, each opcode in the output is annotated with a short description. The value of &lt;em&gt;annotate&lt;/em&gt; is used as a hint for the column where annotation should start.</source>
          <target state="translated">피클의 기호 디스 어셈블리를 파일과 같은 객체 &lt;em&gt;out으로 출력합니다&lt;/em&gt; . 기본값은 &lt;code&gt;sys.stdout&lt;/code&gt; 입니다. &lt;em&gt;pickle&lt;/em&gt; 은 문자열 또는 파일과 같은 객체 일 수 있습니다. &lt;em&gt;메모&lt;/em&gt; 는 피클의 메모로 사용될 Python 사전 일 수 있습니다. 동일한 피커로 만든 여러 피클에서 분해를 수행하는 데 사용할 수 있습니다. 스트림에서 &lt;code&gt;MARK&lt;/code&gt; opcode로 표시되는 연속 레벨 은 들여 쓰기 &lt;em&gt;레벨&lt;/em&gt; 공백 으로 들여 쓰기됩니다 . &lt;em&gt;annotate에&lt;/em&gt; 0이 아닌 값을 지정 하면 출력의 각 opcode에 간단한 설명이 표시됩니다. &lt;em&gt;주석&lt;/em&gt; 값은 &lt;em&gt;주석&lt;/em&gt; 이 시작되어야하는 열에 대한 힌트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dc5698f0af86404dfd9c47dbd73c97838c9a5ae" translate="yes" xml:space="preserve">
          <source>Outputs the record to the file, but first calls &lt;a href=&quot;#logging.handlers.WatchedFileHandler.reopenIfNeeded&quot;&gt;&lt;code&gt;reopenIfNeeded()&lt;/code&gt;&lt;/a&gt; to reopen the file if it has changed.</source>
          <target state="translated">레코드를 파일로 출력하지만 파일이 변경된 경우 먼저 &lt;a href=&quot;#logging.handlers.WatchedFileHandler.reopenIfNeeded&quot;&gt; &lt;code&gt;reopenIfNeeded()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 파일을 다시 엽니 다.</target>
        </trans-unit>
        <trans-unit id="13942066feebbb621d64a590a698fabefbf9f608" translate="yes" xml:space="preserve">
          <source>Outputs the record to the file, catering for rollover as described above.</source>
          <target state="translated">위에서 설명한대로 롤오버를 위해 레코드를 파일로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="3ca087e0da0b536b5faf375d0b4bf87097dd1943" translate="yes" xml:space="preserve">
          <source>Outputs the record to the file, catering for rollover as described previously.</source>
          <target state="translated">이전에 설명한대로 롤오버를 위해 파일에 레코드를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="c717361b7f3869812b4f8d911cb96fca253dd170" translate="yes" xml:space="preserve">
          <source>Outputs the record to the file.</source>
          <target state="translated">레코드를 파일로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="2463e229a293d9ce0593fb8c001c99bade0b894d" translate="yes" xml:space="preserve">
          <source>OverflowError</source>
          <target state="translated">OverflowError</target>
        </trans-unit>
        <trans-unit id="77d28c858b730f53a08a8fef86fd0e4ba755ebd6" translate="yes" xml:space="preserve">
          <source>Overlay the window on top of &lt;em&gt;destwin&lt;/em&gt;. The windows need not be the same size, only the overlapping region is copied. This copy is non-destructive, which means that the current background character does not overwrite the old contents of &lt;em&gt;destwin&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;destwin&lt;/em&gt; 위에 창을 오버레이합니다 . 창의 크기가 같을 필요는 없으며 겹치는 영역 만 복사됩니다. 이 복사본은 비파괴 &lt;em&gt;적이므로&lt;/em&gt; 현재 배경 문자가 &lt;em&gt;destwin&lt;/em&gt; 의 이전 내용을 덮어 쓰지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f325fd31da05c2d6bb7739feb9013527ae1ea6f4" translate="yes" xml:space="preserve">
          <source>Overridable interface to open unknown URL types.</source>
          <target state="translated">알 수없는 URL 유형을 여는 재정의 가능한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="1845ac518f926046d52dd78544dc528bccec6b7b" translate="yes" xml:space="preserve">
          <source>Override &lt;em&gt;object_to_patch.attr_name&lt;/em&gt; with &lt;em&gt;new_value&lt;/em&gt;. Also add cleanup procedure to &lt;em&gt;test_instance&lt;/em&gt; to restore &lt;em&gt;object_to_patch&lt;/em&gt; for &lt;em&gt;attr_name&lt;/em&gt;. The &lt;em&gt;attr_name&lt;/em&gt; should be a valid attribute for &lt;em&gt;object_to_patch&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;object_to_patch.attr_name&lt;/em&gt; 을 &lt;em&gt;new_value로&lt;/em&gt; 대체하십시오 . &lt;em&gt;attr_name에&lt;/em&gt; 대한 &lt;em&gt;object_to_patch&lt;/em&gt; 를 복원하기 위해 정리 절차를 &lt;em&gt;test_instance&lt;/em&gt; 에 추가하십시오 . &lt;em&gt;ATTR_NAME을&lt;/em&gt; 위한 유효한 속성이어야한다 &lt;em&gt;object_to_patch&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7395c655119b2b51ec4e5687f37180aa645f658b" translate="yes" xml:space="preserve">
          <source>Override this in subclasses to use a custom &lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt;&lt;code&gt;SMTPChannel&lt;/code&gt;&lt;/a&gt; for managing SMTP clients.</source>
          <target state="translated">SMTP 클라이언트 관리에 사용자 정의 &lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt; &lt;code&gt;SMTPChannel&lt;/code&gt; &lt;/a&gt; 을 사용하려면 서브 클래스에서이를 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="2909e0ed5928a1fd1982ea6f59b67ccfb9f556df" translate="yes" xml:space="preserve">
          <source>Override to implement platform-specific file transmission. This method is called only if the application&amp;rsquo;s return value is an instance of the class specified by the &lt;a href=&quot;#wsgiref.handlers.BaseHandler.wsgi_file_wrapper&quot;&gt;&lt;code&gt;wsgi_file_wrapper&lt;/code&gt;&lt;/a&gt; attribute. It should return a true value if it was able to successfully transmit the file, so that the default transmission code will not be executed. The default implementation of this method just returns a false value.</source>
          <target state="translated">플랫폼 별 파일 전송을 구현하기 위해 재정의합니다. 이 메소드는 응용 프로그램의 리턴 값이 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.wsgi_file_wrapper&quot;&gt; &lt;code&gt;wsgi_file_wrapper&lt;/code&gt; &lt;/a&gt; 속성으로 지정된 클래스의 인스턴스 인 경우에만 호출됩니다 . 파일을 성공적으로 전송할 수 있으면 true 값을 반환해야 기본 전송 코드가 실행되지 않습니다. 이 메소드의 기본 구현은 단지 거짓 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="841b35088f13fc1f7d90f1447cd5a3232873d19b" translate="yes" xml:space="preserve">
          <source>Overriding the default filter</source>
          <target state="translated">기본 필터 재정의</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="97e3f82b324e49d5bf704d2fcfc3c81fc3bd1c4d" translate="yes" xml:space="preserve">
          <source>Overview of available Turtle and Screen methods</source>
          <target state="translated">사용 가능한 거북이 및 화면 방법 개요</target>
        </trans-unit>
        <trans-unit id="f63c582120e82f9b40889b2e8060bdd0b30b68ad" translate="yes" xml:space="preserve">
          <source>Overwrite the window on top of &lt;em&gt;destwin&lt;/em&gt;. The windows need not be the same size, in which case only the overlapping region is copied. This copy is destructive, which means that the current background character overwrites the old contents of &lt;em&gt;destwin&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;destwin&lt;/em&gt; 위에있는 창을 덮어 씁니다 . 창의 크기가 같을 필요는 없으며,이 경우 겹치는 영역 만 복사됩니다. 이 사본은 파괴적이므로 현재 배경 문자가 &lt;em&gt;destwin&lt;/em&gt; 의 이전 내용을 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="32e42d7cf1d8ef849a65b5a64f751115cac94630" translate="yes" xml:space="preserve">
          <source>Owner has execute permission.</source>
          <target state="translated">소유자에게 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3602226bffa2bf2cc1004ff7d38eed8270dc876b" translate="yes" xml:space="preserve">
          <source>Owner has read permission.</source>
          <target state="translated">소유자에게 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7347b7f7b6214962e6cdded97a0459692c3eb4cb" translate="yes" xml:space="preserve">
          <source>Owner has write permission.</source>
          <target state="translated">소유자에게 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="8188efe6d6c2ca935ce480ac15e4f19beaaefd9e" translate="yes" xml:space="preserve">
          <source>P flag</source>
          <target state="translated">P 플래그</target>
        </trans-unit>
        <trans-unit id="19cff3742b4c4e6723d380bd45c0c6a517354983" translate="yes" xml:space="preserve">
          <source>PEP written and implemented by Eric Snow</source>
          <target state="translated">Eric Snow가 작성하고 구현 한 PEP</target>
        </trans-unit>
        <trans-unit id="96cc3126da39918697345cd1940161ffe9937238" translate="yes" xml:space="preserve">
          <source>PEP written and implemented by Nick Coghlan.</source>
          <target state="translated">Nick Coghlan이 작성하고 구현 한 PEP.</target>
        </trans-unit>
        <trans-unit id="72f66703e54a4ec78b0213c1ad44bcc728157812" translate="yes" xml:space="preserve">
          <source>PEP written by Marc-Andr&amp;eacute; Lemburg.</source>
          <target state="translated">Marc-Andr&amp;eacute; Lemburg가 작성한 PEP.</target>
        </trans-unit>
        <trans-unit id="02c1c27f30006cf59ab74f7a98ff1faa4de16fbf" translate="yes" xml:space="preserve">
          <source>PI element factory. This factory function creates a special element that will be serialized as an XML processing instruction. &lt;em&gt;target&lt;/em&gt; is a string containing the PI target. &lt;em&gt;text&lt;/em&gt; is a string containing the PI contents, if given. Returns an element instance, representing a processing instruction.</source>
          <target state="translated">PI 요소 공장. 이 팩토리 함수는 XML 처리 명령으로 직렬화 될 특수 요소를 작성합니다. &lt;em&gt;target&lt;/em&gt; 은 PI 대상을 포함하는 문자열입니다. &lt;em&gt;텍스트&lt;/em&gt; 는 주어진 경우 PI 내용을 포함하는 문자열입니다. 처리 명령을 나타내는 요소 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="645fd7e9caac181870f9d1dede2beb5dfad6f364" translate="yes" xml:space="preserve">
          <source>PKCS #5: Password-Based Cryptography Specification Version 2.0</source>
          <target state="translated">PKCS # 5 : 비밀번호 기반 암호화 사양 버전 2.0</target>
        </trans-unit>
        <trans-unit id="6a6c80bd7a477c267f845a1634bbf726b750cfed" translate="yes" xml:space="preserve">
          <source>PKZIP Application Note</source>
          <target state="translated">PKZIP 애플리케이션 노트</target>
        </trans-unit>
        <trans-unit id="7ed081aaacf45dc799e1d758e08c1fee43fa6b4d" translate="yes" xml:space="preserve">
          <source>PKZIP version needed to extract archive.</source>
          <target state="translated">아카이브를 추출하려면 PKZIP 버전이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="9781d1150340a69a33be8618584c8cba317bce94" translate="yes" xml:space="preserve">
          <source>PKZIP version which created ZIP archive.</source>
          <target state="translated">ZIP 아카이브를 만든 PKZIP 버전.</target>
        </trans-unit>
        <trans-unit id="a686245107e7535edbc3e18f215337676e95a611" translate="yes" xml:space="preserve">
          <source>PList manual page</source>
          <target state="translated">PList 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="cc56431d28166c67feef84f6c92e21eabfa5d1ca" translate="yes" xml:space="preserve">
          <source>POP (Post Office Protocol) client</source>
          <target state="translated">POP (우체국 프로토콜) 클라이언트</target>
        </trans-unit>
        <trans-unit id="6529429ecfa1cc0534c3143968006f04304bba59" translate="yes" xml:space="preserve">
          <source>POP3 Example</source>
          <target state="translated">POP3 예</target>
        </trans-unit>
        <trans-unit id="ccd83f40f38d28ca57da516a478df1ed22acb88c" translate="yes" xml:space="preserve">
          <source>POP3 Objects</source>
          <target state="translated">POP3 객체</target>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="d1e7dc927b5056ab603c7e76822c32304531f8c5" translate="yes" xml:space="preserve">
          <source>POSIX.1-1988 (ustar) format.</source>
          <target state="translated">POSIX.1-1988 (ustar) 형식.</target>
        </trans-unit>
        <trans-unit id="91bc95b98cf54c5ceaa0e0d916776762d8ddd754" translate="yes" xml:space="preserve">
          <source>POSIX.1-2001 (pax) format.</source>
          <target state="translated">POSIX.1-2001 (pax) 형식.</target>
        </trans-unit>
        <trans-unit id="5673e51c6ba031bafbab056cb4b8681674c77b64" translate="yes" xml:space="preserve">
          <source>PS C:\&amp;gt; &amp;lt;venv&amp;gt;\Scripts\Activate.ps1</source>
          <target state="translated">PS C : \&amp;gt; &amp;lt;venv&amp;gt; \ Scripts \ Activate.ps1</target>
        </trans-unit>
        <trans-unit id="edb353c498914363a5fa96fe5426703486d738f0" translate="yes" xml:space="preserve">
          <source>PYC Repository Directories</source>
          <target state="translated">PYC 리포지토리 디렉토리</target>
        </trans-unit>
        <trans-unit id="5fa81009e6c318f633d81b3520255a8c252b4939" translate="yes" xml:space="preserve">
          <source>P_NOWAIT example:</source>
          <target state="translated">P_NOWAIT 예 :</target>
        </trans-unit>
        <trans-unit id="c71b9bdfc8cd53509b44f69906b2d09fc5c0a78b" translate="yes" xml:space="preserve">
          <source>P_WAIT example:</source>
          <target state="translated">P_WAIT 예 :</target>
        </trans-unit>
        <trans-unit id="1ca4f74cd6ff2ed6c937c0943f68809fb32bebd2" translate="yes" xml:space="preserve">
          <source>Pack the values &lt;em&gt;v1&lt;/em&gt;, &lt;em&gt;v2&lt;/em&gt;, &amp;hellip; according to the format string &lt;em&gt;format&lt;/em&gt; and write the packed bytes into the writable buffer &lt;em&gt;buffer&lt;/em&gt; starting at position &lt;em&gt;offset&lt;/em&gt;. Note that &lt;em&gt;offset&lt;/em&gt; is a required argument.</source>
          <target state="translated">형식 문자열 &lt;em&gt;형식&lt;/em&gt; 에 따라 값 &lt;em&gt;v1&lt;/em&gt; , &lt;em&gt;v2&lt;/em&gt; ,&amp;hellip;를 압축하고 압축 된 바이트를 위치 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작 하여 쓰기 가능한 버퍼 &lt;em&gt;버퍼에&lt;/em&gt; 씁니다 . 참고 &lt;em&gt;오프셋은&lt;/em&gt; 필수 인수입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e600670fc903f64302f254dffcdf0dd2910c01d" translate="yes" xml:space="preserve">
          <source>Pack up a directory into an archive, and run it.</source>
          <target state="translated">디렉토리를 아카이브에 압축하여 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="cf25aa751e3519d8d8bc5c6250a1c8496de96180" translate="yes" xml:space="preserve">
          <source>Package &lt;a href=&quot;https://dateutil.readthedocs.io/en/stable/&quot;&gt;dateutil&lt;/a&gt;</source>
          <target state="translated">패키지 &lt;a href=&quot;https://dateutil.readthedocs.io/en/stable/&quot;&gt;날짜 유틸리티&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cad03b3193d6e7cd78f44b1238ea56433fd311d" translate="yes" xml:space="preserve">
          <source>Package not installed</source>
          <target state="translated">패키지가 설치되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="3880af2ba3f21c17c8cf074ba063ffeb33288fb9" translate="yes" xml:space="preserve">
          <source>Package the application using:</source>
          <target state="translated">다음을 사용하여 애플리케이션을 패키지하십시오.</target>
        </trans-unit>
        <trans-unit id="6b5cd295b63824cbc62d1acfcbff85265b721c98" translate="yes" xml:space="preserve">
          <source>Packages specification</source>
          <target state="translated">패키지 사양</target>
        </trans-unit>
        <trans-unit id="0122990cae2223f01ba8fc059a08202e3a680d47" translate="yes" xml:space="preserve">
          <source>Packed binary storage of homogeneous data.</source>
          <target state="translated">동종 데이터의 팩 바이너리 저장.</target>
        </trans-unit>
        <trans-unit id="a1eee81646800c1c1945b0200d9c5a077bcb9fa3" translate="yes" xml:space="preserve">
          <source>Packer Objects</source>
          <target state="translated">패커 객체</target>
        </trans-unit>
        <trans-unit id="09ab562ad00b6e394a3efca9cba8a8ba6444e5b3" translate="yes" xml:space="preserve">
          <source>Packer Options</source>
          <target state="translated">패커 옵션</target>
        </trans-unit>
        <trans-unit id="e9c9758effdf5587f78f4781fe65b4bc712558b7" translate="yes" xml:space="preserve">
          <source>Packing and unpacking of External Data Representation (XDR) data as used in some remote procedure call systems.</source>
          <target state="translated">일부 원격 프로 시저 호출 시스템에서 사용되는 외부 데이터 표현 (XDR) 데이터의 포장 및 포장 풀기.</target>
        </trans-unit>
        <trans-unit id="ba61d74eba3e7429d5d2efb23fea14de5a4a2686" translate="yes" xml:space="preserve">
          <source>Packing and unpacking of XDR data.</source>
          <target state="translated">XDR 데이터 포장 및 포장 풀기.</target>
        </trans-unit>
        <trans-unit id="ff9ec2ff343ac87044954920f5478e697bc42222" translate="yes" xml:space="preserve">
          <source>Packing and unpacking of heterogeneous binary data.</source>
          <target state="translated">이종 이진 데이터의 압축 및 포장 풀기</target>
        </trans-unit>
        <trans-unit id="2fc884e6acb1b6b441cecf6cac548bb46376e49d" translate="yes" xml:space="preserve">
          <source>Packs a &lt;em&gt;list&lt;/em&gt; of homogeneous items. This method is useful for lists with an indeterminate size; i.e. the size is not available until the entire list has been walked. For each item in the list, an unsigned integer &lt;code&gt;1&lt;/code&gt; is packed first, followed by the data value from the list. &lt;em&gt;pack_item&lt;/em&gt; is the function that is called to pack the individual item. At the end of the list, an unsigned integer &lt;code&gt;0&lt;/code&gt; is packed.</source>
          <target state="translated">팩 &lt;em&gt;목록&lt;/em&gt; 균일 항목을. 이 방법은 크기가 불확실한 목록에 유용합니다. 즉, 전체 목록이 나올 때까지 크기를 사용할 수 없습니다. 목록의 각 항목에 대해 부호없는 정수 &lt;code&gt;1&lt;/code&gt; 이 먼저 압축 된 다음 목록의 데이터 값이 뒤 따릅니다. &lt;em&gt;pack_item&lt;/em&gt; 은 개별 항목을 포장하기 위해 호출되는 함수입니다. 목록의 끝에 부호없는 정수 &lt;code&gt;0&lt;/code&gt; 이 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="b540c95e1283f4fae5fed2992b4cde688a1f8bd0" translate="yes" xml:space="preserve">
          <source>Packs a fixed length list (&lt;em&gt;array&lt;/em&gt;) of homogeneous items. &lt;em&gt;n&lt;/em&gt; is the length of the list; it is &lt;em&gt;not&lt;/em&gt; packed into the buffer, but a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception is raised if &lt;code&gt;len(array)&lt;/code&gt; is not equal to &lt;em&gt;n&lt;/em&gt;. As above, &lt;em&gt;pack_item&lt;/em&gt; is the function used to pack each element.</source>
          <target state="translated">동종 항목 의 고정 길이 목록 ( &lt;em&gt;배열&lt;/em&gt; )을 압축합니다. &lt;em&gt;n&lt;/em&gt; 은리스트의 길이이며; 그것은되어 &lt;em&gt;있지&lt;/em&gt; 버퍼로 포장되지만 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 경우 예외가 발생 &lt;code&gt;len(array)&lt;/code&gt; 동일하지 않은 &lt;em&gt;N&lt;/em&gt; . 위와 같이 &lt;em&gt;pack_item&lt;/em&gt; 은 각 요소를 &lt;em&gt;압축&lt;/em&gt; 하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="993b3f1f48130f3d5499e4bb61480af1f43780a6" translate="yes" xml:space="preserve">
          <source>Packs a fixed length opaque data stream, similarly to &lt;a href=&quot;#xdrlib.Packer.pack_fstring&quot;&gt;&lt;code&gt;pack_fstring()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Packer.pack_fstring&quot;&gt; &lt;code&gt;pack_fstring()&lt;/code&gt; &lt;/a&gt; 과 유사하게 고정 길이의 불투명 한 데이터 스트림을 압축 합니다.</target>
        </trans-unit>
        <trans-unit id="85b656f18a0f07689f2f15d99d57287804c9ec23" translate="yes" xml:space="preserve">
          <source>Packs a fixed length string, &lt;em&gt;s&lt;/em&gt;. &lt;em&gt;n&lt;/em&gt; is the length of the string but it is &lt;em&gt;not&lt;/em&gt; packed into the data buffer. The string is padded with null bytes if necessary to guaranteed 4 byte alignment.</source>
          <target state="translated">고정 길이 문자열 &lt;em&gt;s를 압축&lt;/em&gt; 합니다. &lt;em&gt;n&lt;/em&gt; 은 문자열의 길이이지만 데이터 버퍼에 압축 &lt;em&gt;되지 않습니다&lt;/em&gt; . 필요한 경우 4 바이트 정렬을 보장하기 위해 문자열에 널 바이트가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="d35f3e8d894947627ebea046d9379e59367e078c" translate="yes" xml:space="preserve">
          <source>Packs a variable length &lt;em&gt;list&lt;/em&gt; of homogeneous items. First, the length of the list is packed as an unsigned integer, then each element is packed as in &lt;a href=&quot;#xdrlib.Packer.pack_farray&quot;&gt;&lt;code&gt;pack_farray()&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">동종 항목 의 가변 길이 &lt;em&gt;목록&lt;/em&gt; 을 압축합니다. 먼저 목록의 길이는 부호없는 정수로 압축 된 다음 각 요소는 위의 &lt;a href=&quot;#xdrlib.Packer.pack_farray&quot;&gt; &lt;code&gt;pack_farray()&lt;/code&gt; &lt;/a&gt; 에서와 같이 압축됩니다 .</target>
        </trans-unit>
        <trans-unit id="30061d9c00e384a6f4b04e1bdfb6f26cbfd0caf4" translate="yes" xml:space="preserve">
          <source>Packs a variable length byte stream, similarly to &lt;a href=&quot;#xdrlib.Packer.pack_string&quot;&gt;&lt;code&gt;pack_string()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Packer.pack_string&quot;&gt; &lt;code&gt;pack_string()&lt;/code&gt; &lt;/a&gt; 과 유사하게 가변 길이 바이트 스트림을 압축 합니다.</target>
        </trans-unit>
        <trans-unit id="1f5fb0dbfad21f7013015f277c5718bd76afec8f" translate="yes" xml:space="preserve">
          <source>Packs a variable length opaque data string, similarly to &lt;a href=&quot;#xdrlib.Packer.pack_string&quot;&gt;&lt;code&gt;pack_string()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Packer.pack_string&quot;&gt; &lt;code&gt;pack_string()&lt;/code&gt; &lt;/a&gt; 과 유사하게 가변 길이의 불투명 데이터 문자열을 압축 합니다.</target>
        </trans-unit>
        <trans-unit id="f73c74419bc7c46b6f154ecf0c655bc164189afb" translate="yes" xml:space="preserve">
          <source>Packs a variable length string, &lt;em&gt;s&lt;/em&gt;. The length of the string is first packed as an unsigned integer, then the string data is packed with &lt;a href=&quot;#xdrlib.Packer.pack_fstring&quot;&gt;&lt;code&gt;pack_fstring()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가변 길이 문자열 &lt;em&gt;s를 압축&lt;/em&gt; 합니다. 문자열의 길이는 먼저 부호없는 정수로 압축 된 다음 문자열 데이터는 &lt;a href=&quot;#xdrlib.Packer.pack_fstring&quot;&gt; &lt;code&gt;pack_fstring()&lt;/code&gt; &lt;/a&gt; 압축됩니다 .</target>
        </trans-unit>
        <trans-unit id="298af3b97feaea337e720a2944c01237f7d660aa" translate="yes" xml:space="preserve">
          <source>Packs the double-precision floating point number &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">배정 밀도 부동 소수점 숫자 &lt;em&gt;값을&lt;/em&gt; 압축 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b9506e9ead7ad8bf096843e59e92af3f3db699fd" translate="yes" xml:space="preserve">
          <source>Packs the single-precision floating point number &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">단 정밀도 부동 소수점 숫자 &lt;em&gt;값을&lt;/em&gt; 압축 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a9c02b60fbcf23b1dbfa68021d80be67258ce8" translate="yes" xml:space="preserve">
          <source>Pad byte needed if &lt;em&gt;n&lt;/em&gt; is odd and chunk alignment is used</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 이 홀수이고 청크 정렬이 사용되는 경우 패드 바이트 필요</target>
        </trans-unit>
        <trans-unit id="be6aec49e5262973160789fd096af12232d8eda6" translate="yes" xml:space="preserve">
          <source>Padding is only automatically added between successive structure members. No padding is added at the beginning or the end of the encoded struct.</source>
          <target state="translated">패딩은 연속 구조 멤버간에 만 자동으로 추가됩니다. 인코딩 된 구조체의 시작 또는 끝에 패딩이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eebe8b4d277848e1ec370986e82d2178731c6293" translate="yes" xml:space="preserve">
          <source>Page Down</source>
          <target state="translated">Page Down</target>
        </trans-unit>
        <trans-unit id="5c77b5722c41b6f199f92efb5977aba4430b61c9" translate="yes" xml:space="preserve">
          <source>Page Up</source>
          <target state="translated">페이지 위로</target>
        </trans-unit>
        <trans-unit id="e7d3c63de7852b4a6801684fea08c43e4215eede" translate="yes" xml:space="preserve">
          <source>Paint at most &lt;em&gt;n&lt;/em&gt; characters of the character string &lt;em&gt;str&lt;/em&gt; at &lt;code&gt;(y, x)&lt;/code&gt; with attributes &lt;em&gt;attr&lt;/em&gt;, overwriting anything previously on the display.</source>
          <target state="translated">&lt;em&gt;attr&lt;/em&gt; 속성 을 사용하여 문자열 &lt;em&gt;str&lt;/em&gt; 에서 &lt;code&gt;(y, x)&lt;/code&gt; 의 최대 &lt;em&gt;n&lt;/em&gt; 문자를 페인트하여 이전에 디스플레이의 모든 것을 덮어 씁니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d99809c709d2c937bd8fcaf22711d9e1f53af193" translate="yes" xml:space="preserve">
          <source>Paint character &lt;em&gt;ch&lt;/em&gt; at &lt;code&gt;(y, x)&lt;/code&gt; with attributes &lt;em&gt;attr&lt;/em&gt;, moving the line from position &lt;em&gt;x&lt;/em&gt; right by one character.</source>
          <target state="translated">속성 &lt;em&gt;attr을 사용&lt;/em&gt; 하여 문자 &lt;em&gt;ch&lt;/em&gt; at &lt;code&gt;(y, x)&lt;/code&gt; 를 &lt;em&gt;칠하여&lt;/em&gt; 위치 &lt;em&gt;x&lt;/em&gt; 에서 한 문자 씩 오른쪽으로 줄을 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="24af2750a2e63948648310692a6b52c55421e98d" translate="yes" xml:space="preserve">
          <source>Paint character &lt;em&gt;ch&lt;/em&gt; at &lt;code&gt;(y, x)&lt;/code&gt; with attributes &lt;em&gt;attr&lt;/em&gt;, overwriting any character previously painter at that location. By default, the character position and attributes are the current settings for the window object.</source>
          <target state="translated">속성 &lt;em&gt;attr을 사용&lt;/em&gt; 하여 문자 &lt;em&gt;ch&lt;/em&gt; at &lt;code&gt;(y, x)&lt;/code&gt; 를 페인트하여 해당 위치에서 이전에 화가가었던 문자를 덮어 씁니다. 기본적으로 문자 위치 및 속성은 창 객체의 현재 설정입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d619bb80867eab45009bfb84b6b417b3ca8fc2c3" translate="yes" xml:space="preserve">
          <source>Paint the character string &lt;em&gt;str&lt;/em&gt; at &lt;code&gt;(y, x)&lt;/code&gt; with attributes &lt;em&gt;attr&lt;/em&gt;, overwriting anything previously on the display.</source>
          <target state="translated">속성 &lt;em&gt;attr을 사용&lt;/em&gt; 하여 문자열 &lt;em&gt;str&lt;/em&gt; at &lt;code&gt;(y, x)&lt;/code&gt; 를 페인트하여 이전에 디스플레이의 모든 것을 겹쳐 씁니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e844933b4932ee3937ee43d5f9fbf5690450c6f9" translate="yes" xml:space="preserve">
          <source>Panel Objects</source>
          <target state="translated">패널 객체</target>
        </trans-unit>
        <trans-unit id="fa3f038d65d1a64b9f30b8194e1110843ad0ed17" translate="yes" xml:space="preserve">
          <source>Panel objects have the following methods:</source>
          <target state="translated">패널 객체에는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48250a21bb2f011a6dfba4c5d7e1a9a1c9fdc072" translate="yes" xml:space="preserve">
          <source>Panel objects, as returned by &lt;a href=&quot;#curses.panel.new_panel&quot;&gt;&lt;code&gt;new_panel()&lt;/code&gt;&lt;/a&gt; above, are windows with a stacking order. There&amp;rsquo;s always a window associated with a panel which determines the content, while the panel methods are responsible for the window&amp;rsquo;s depth in the panel stack.</source>
          <target state="translated">위의 &lt;a href=&quot;#curses.panel.new_panel&quot;&gt; &lt;code&gt;new_panel()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 패널 객체 는 스택 순서가있는 창입니다. 내용을 결정하는 패널과 관련된 창이 항상 있으며 패널 방법은 패널 스택에서 창의 깊이를 담당합니다.</target>
        </trans-unit>
        <trans-unit id="fc975aa48f15e94a28935c5e885e735c1b69bb7b" translate="yes" xml:space="preserve">
          <source>Panels are windows with the added feature of depth, so they can be stacked on top of each other, and only the visible portions of each window will be displayed. Panels can be added, moved up or down in the stack, and removed.</source>
          <target state="translated">패널은 깊이 기능이 추가 된 창이므로 서로 쌓을 수 있으며 각 창의 보이는 부분 만 표시됩니다. 스택에서 패널을 추가, 위 또는 아래로 이동 및 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="312270aaaff20da30c74f328ff0f10c9927c4efe" translate="yes" xml:space="preserve">
          <source>Paragraph Separator</source>
          <target state="translated">단락 구분자</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="41656f6d37dec30feb05e7aa728844b98293f13f" translate="yes" xml:space="preserve">
          <source>Parameter &lt;em&gt;arg&lt;/em&gt; should be a &lt;em&gt;key&lt;/em&gt;-to-&lt;em&gt;message&lt;/em&gt; mapping or an iterable of (&lt;em&gt;key&lt;/em&gt;, &lt;em&gt;message&lt;/em&gt;) pairs. Updates the mailbox so that, for each given &lt;em&gt;key&lt;/em&gt; and &lt;em&gt;message&lt;/em&gt;, the message corresponding to &lt;em&gt;key&lt;/em&gt; is set to &lt;em&gt;message&lt;/em&gt; as if by using &lt;a href=&quot;#mailbox.Mailbox.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt;. As with &lt;a href=&quot;#mailbox.Mailbox.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt;, each &lt;em&gt;key&lt;/em&gt; must already correspond to a message in the mailbox or else a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception will be raised, so in general it is incorrect for &lt;em&gt;arg&lt;/em&gt; to be a &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">매개 변수 &lt;em&gt;arg&lt;/em&gt; 는 &lt;em&gt;키&lt;/em&gt; - &lt;em&gt;메시지&lt;/em&gt; 맵핑 또는 반복 가능한 ( &lt;em&gt;key&lt;/em&gt; , &lt;em&gt;message&lt;/em&gt; ) 쌍 이어야합니다 . 그 때문에, 메일 박스, 각각의 주어진 갱신을위한 &lt;em&gt;키&lt;/em&gt; 와 &lt;em&gt;메시지&lt;/em&gt; 에 대응하는 메시지 &lt;em&gt;키&lt;/em&gt; 에 설정되어있는 &lt;em&gt;메시지&lt;/em&gt; 처럼 사용 &lt;a href=&quot;#mailbox.Mailbox.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#mailbox.Mailbox.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 각 &lt;em&gt;키&lt;/em&gt; 는 사서함의 메시지와 이미 일치해야합니다. 그렇지 않으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 예외가 발생하므로 일반적으로 &lt;em&gt;arg&lt;/em&gt; 가 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스 가되는 것은 올바르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="59c4a01bc4aac90732e66b0bec359511c54291d4" translate="yes" xml:space="preserve">
          <source>Parameter &lt;em&gt;message&lt;/em&gt; may be a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance, an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; instance, a string, a byte string, or a file-like object (which should be open in binary mode). If &lt;em&gt;message&lt;/em&gt; is an instance of the appropriate format-specific &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; subclass (e.g., if it&amp;rsquo;s an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance and this is an &lt;a href=&quot;#mailbox.mbox&quot;&gt;&lt;code&gt;mbox&lt;/code&gt;&lt;/a&gt; instance), its format-specific information is used. Otherwise, reasonable defaults for format-specific information are used.</source>
          <target state="translated">매개 변수 &lt;em&gt;메시지&lt;/em&gt; 는 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스, &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; &lt;/a&gt; 인스턴스, 문자열, 바이트 문자열 또는 파일과 유사한 객체 (바이너리 모드로 열려야 함) 일 수 있습니다. 경우 &lt;em&gt;메시지가&lt;/em&gt; 적절한 형식 별의의 인스턴스 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 서브 클래스 (그것이 있다면 예를 들어, &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가이가있다 &lt;a href=&quot;#mailbox.mbox&quot;&gt; &lt;code&gt;mbox&lt;/code&gt; &lt;/a&gt; 예), 그 형식 별 정보가 사용됩니다. 그렇지 않으면 형식 별 정보에 대한 적절한 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="881bf20a17cb18ef7df20e69e4894f8e515d8f08" translate="yes" xml:space="preserve">
          <source>Parameter keys are always compared case insensitively. The return value can either be a string, or a 3-tuple if the parameter was &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; encoded. When it&amp;rsquo;s a 3-tuple, the elements of the value are of the form &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt;. Note that both &lt;code&gt;CHARSET&lt;/code&gt; and &lt;code&gt;LANGUAGE&lt;/code&gt; can be &lt;code&gt;None&lt;/code&gt;, in which case you should consider &lt;code&gt;VALUE&lt;/code&gt; to be encoded in the &lt;code&gt;us-ascii&lt;/code&gt; charset. You can usually ignore &lt;code&gt;LANGUAGE&lt;/code&gt;.</source>
          <target state="translated">매개 변수 키는 항상 대소 문자를 구분하지 않고 비교됩니다. 매개 변수가 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231로&lt;/strong&gt;&lt;/a&gt; 인코딩 된 경우 리턴 값은 문자열이거나 3 개의 튜플 일 수 있습니다. 3 튜플 인 경우 값의 요소는 &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt; 입니다. 참고 둘 것을 &lt;code&gt;CHARSET&lt;/code&gt; 과 &lt;code&gt;LANGUAGE&lt;/code&gt; 될 수 &lt;code&gt;None&lt;/code&gt; 고려해야하는 경우, &lt;code&gt;VALUE&lt;/code&gt; 에서 인코딩 할 &lt;code&gt;us-ascii&lt;/code&gt; 문자 세트. 일반적으로 &lt;code&gt;LANGUAGE&lt;/code&gt; 를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33739f0fe85843a995275178b4ae7686f3467b90" translate="yes" xml:space="preserve">
          <source>Parameter objects are &lt;em&gt;immutable&lt;/em&gt;. Instead of modifying a Parameter object, you can use &lt;a href=&quot;#inspect.Parameter.replace&quot;&gt;&lt;code&gt;Parameter.replace()&lt;/code&gt;&lt;/a&gt; to create a modified copy.</source>
          <target state="translated">매개 변수 객체는 &lt;em&gt;변경할 수 없습니다&lt;/em&gt; . Parameter 객체를 수정하는 대신 &lt;a href=&quot;#inspect.Parameter.replace&quot;&gt; &lt;code&gt;Parameter.replace()&lt;/code&gt; &lt;/a&gt; 를 사용하여 수정 된 복사본을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="a92b79dc56bbd97fdb6a07c22c916ccfa7aee2d6" translate="yes" xml:space="preserve">
          <source>Parameters for last path element</source>
          <target state="translated">마지막 경로 요소의 매개 변수</target>
        </trans-unit>
        <trans-unit id="759e2eb2d1daa387faedef08a108f8727c12a8ef" translate="yes" xml:space="preserve">
          <source>Parameters for the &lt;a href=&quot;#os.getpriority&quot;&gt;&lt;code&gt;getpriority()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.setpriority&quot;&gt;&lt;code&gt;setpriority()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;#os.getpriority&quot;&gt; &lt;code&gt;getpriority()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.setpriority&quot;&gt; &lt;code&gt;setpriority()&lt;/code&gt; &lt;/a&gt; 함수의 매개 변수</target>
        </trans-unit>
        <trans-unit id="838e55f08d1ff41fab5268cb5f1dd771e877ca64" translate="yes" xml:space="preserve">
          <source>Parameters not specified keep current settings, except &lt;code&gt;errors='strict'&lt;/code&gt; is used when &lt;em&gt;encoding&lt;/em&gt; is specified but &lt;em&gt;errors&lt;/em&gt; is not specified.</source>
          <target state="translated">지정되지 않은 매개 변수 는 &lt;em&gt;인코딩&lt;/em&gt; 이 지정되었지만 &lt;em&gt;오류&lt;/em&gt; 가 지정되지 않은 경우 &lt;code&gt;errors='strict'&lt;/code&gt; 가 사용되는 것을 제외하고 현재 설정을 유지 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64930b4862237d51573ab5db32a04df08eaab71b" translate="yes" xml:space="preserve">
          <source>Parameters to the &lt;a href=&quot;#os.lseek&quot;&gt;&lt;code&gt;lseek()&lt;/code&gt;&lt;/a&gt; function. Their values are 0, 1, and 2, respectively.</source>
          <target state="translated">&lt;a href=&quot;#os.lseek&quot;&gt; &lt;code&gt;lseek()&lt;/code&gt; &lt;/a&gt; 함수 에 대한 매개 변수 입니다. 해당 값은 각각 0, 1 및 2입니다.</target>
        </trans-unit>
        <trans-unit id="574eadd03549c46ff070bfc9b5c4604fe3ba3d9e" translate="yes" xml:space="preserve">
          <source>Parameters to the &lt;a href=&quot;#os.sendfile&quot;&gt;&lt;code&gt;sendfile()&lt;/code&gt;&lt;/a&gt; function, if the implementation supports them.</source>
          <target state="translated">구현에서 지원하는 경우 &lt;a href=&quot;#os.sendfile&quot;&gt; &lt;code&gt;sendfile()&lt;/code&gt; &lt;/a&gt; 함수 에 대한 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="bb65093f645552f1d147225f5339fb4c0d809a51" translate="yes" xml:space="preserve">
          <source>Pareto distribution. &lt;em&gt;alpha&lt;/em&gt; is the shape parameter.</source>
          <target state="translated">파레토 분포. &lt;em&gt;alpha&lt;/em&gt; 는 모양 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="a86e41d6f2a5d68c53f3894fcb12cd2f2075fd69" translate="yes" xml:space="preserve">
          <source>Parse XML data reading from the object &lt;em&gt;file&lt;/em&gt;. &lt;em&gt;file&lt;/em&gt; only needs to provide the &lt;code&gt;read(nbytes)&lt;/code&gt; method, returning the empty string when there&amp;rsquo;s no more data.</source>
          <target state="translated">객체 &lt;em&gt;파일&lt;/em&gt; 에서 읽은 XML 데이터를 구문 분석 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;파일&lt;/em&gt; 은 더 이상 데이터가 없을 때 빈 문자열을 반환 하는 &lt;code&gt;read(nbytes)&lt;/code&gt; 메소드 만 제공하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="cd6d8291ae51a08ad977274c0372200b08672145" translate="yes" xml:space="preserve">
          <source>Parse a &lt;code&gt;config.h&lt;/code&gt;-style file.</source>
          <target state="translated">&lt;code&gt;config.h&lt;/code&gt; 스타일 파일을 구문 분석 하십시오.</target>
        </trans-unit>
        <trans-unit id="63c3905d8ecd87702e0ce0c0330bac77c66e32c8" translate="yes" xml:space="preserve">
          <source>Parse a MIME header (such as &lt;em&gt;Content-Type&lt;/em&gt;) into a main value and a dictionary of parameters.</source>
          <target state="translated">MIME 헤더 (예 : &lt;em&gt;Content-Type&lt;/em&gt; )를 기본 값과 매개 변수 사전으로 구문 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff6e1df4dd4d3597f09c70a2e424eab21b6eff12" translate="yes" xml:space="preserve">
          <source>Parse a URL into six components, returning a 6-item &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;. This corresponds to the general structure of a URL: &lt;code&gt;scheme://netloc/path;parameters?query#fragment&lt;/code&gt;. Each tuple item is a string, possibly empty. The components are not broken up in smaller parts (for example, the network location is a single string), and % escapes are not expanded. The delimiters as shown above are not part of the result, except for a leading slash in the &lt;em&gt;path&lt;/em&gt; component, which is retained if present. For example:</source>
          <target state="translated">URL을 6 개의 구성 요소로 구문 분석하여 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;tuple이라는&lt;/a&gt; 6 개 항목을 리턴하십시오 . URL의 일반적인 구조 인 &lt;code&gt;scheme://netloc/path;parameters?query#fragment&lt;/code&gt; 합니다. 각 튜플 항목은 문자열이며 비어있을 수 있습니다. 구성 요소가 더 작은 부분으로 나뉘 지 않고 (예 : 네트워크 위치가 단일 문자열) 이스케이프가 확장되지 않습니다. 위에 표시된 분리 문자는 &lt;em&gt;경로&lt;/em&gt; 구성 요소 의 선행 슬래시를 제외하고 결과의 일부가 아니며 존재하는 경우 유지됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f65d7a6a5967be810a7b45cc7fc1983d29ae04a" translate="yes" xml:space="preserve">
          <source>Parse a query in the environment or from a file (the file defaults to &lt;code&gt;sys.stdin&lt;/code&gt;). The &lt;em&gt;keep_blank_values&lt;/em&gt; and &lt;em&gt;strict_parsing&lt;/em&gt; parameters are passed to &lt;a href=&quot;urllib.parse#urllib.parse.parse_qs&quot;&gt;&lt;code&gt;urllib.parse.parse_qs()&lt;/code&gt;&lt;/a&gt; unchanged.</source>
          <target state="translated">환경 또는 파일에서 쿼리를 구문 분석합니다 (파일의 기본값은 &lt;code&gt;sys.stdin&lt;/code&gt; ). &lt;em&gt;keep_blank_values&lt;/em&gt; 및 &lt;em&gt;strict_parsing&lt;/em&gt; 파라미터에 전달 &lt;a href=&quot;urllib.parse#urllib.parse.parse_qs&quot;&gt; &lt;code&gt;urllib.parse.parse_qs()&lt;/code&gt; &lt;/a&gt; 불변.</target>
        </trans-unit>
        <trans-unit id="83ffcfafda3d2a633dbce55a15d332a9d456e01a" translate="yes" xml:space="preserve">
          <source>Parse a query string given as a string argument (data of type &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt;). Data are returned as a dictionary. The dictionary keys are the unique query variable names and the values are lists of values for each name.</source>
          <target state="translated">문자열 인수 ( &lt;em&gt;application / x-www-form-urlencoded&lt;/em&gt; 유형의 데이터)로 제공된 쿼리 문자열을 구문 분석하십시오 . 데이터는 사전으로 반환됩니다. 사전 키는 고유 한 쿼리 변수 이름이고 값은 각 이름의 값 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3f02af97808b4370f19a36ce2159e13d76d32265" translate="yes" xml:space="preserve">
          <source>Parse a query string given as a string argument (data of type &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt;). Data are returned as a list of name, value pairs.</source>
          <target state="translated">문자열 인수 ( &lt;em&gt;application / x-www-form-urlencoded&lt;/em&gt; 유형의 데이터)로 제공된 쿼리 문자열을 구문 분석하십시오 . 데이터는 이름, 값 쌍의 목록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f5435496a6de34302e5162e2765e6d03eb242ff" translate="yes" xml:space="preserve">
          <source>Parse a string into a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object given a corresponding format</source>
          <target state="translated">해당 형식이 지정된 문자열을 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 로 구문 분석</target>
        </trans-unit>
        <trans-unit id="ddb7f7e51791d0d0bb53020b57f543d16b666e17" translate="yes" xml:space="preserve">
          <source>Parse a string representing a time according to a format. The return value is a &lt;a href=&quot;#time.struct_time&quot;&gt;&lt;code&gt;struct_time&lt;/code&gt;&lt;/a&gt; as returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식에 따라 시간을 나타내는 문자열을 구문 분석하십시오. 리턴 값은 &lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 의해 리턴되는 &lt;a href=&quot;#time.struct_time&quot;&gt; &lt;code&gt;struct_time&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5e9b3948a49b13fe039282714fef7eb741666870" translate="yes" xml:space="preserve">
          <source>Parse address &amp;ndash; which should be the value of some address-containing field such as &lt;em&gt;To&lt;/em&gt; or &lt;em&gt;Cc&lt;/em&gt; &amp;ndash; into its constituent &lt;em&gt;realname&lt;/em&gt; and &lt;em&gt;email address&lt;/em&gt; parts. Returns a tuple of that information, unless the parse fails, in which case a 2-tuple of &lt;code&gt;('', '')&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;em&gt;To&lt;/em&gt; 또는 &lt;em&gt;Cc&lt;/em&gt; 와 같은 일부 주소 포함 필드의 값이어야하는 주소를 구성 &lt;em&gt;실제 이름&lt;/em&gt; 과 &lt;em&gt;전자 메일 주소&lt;/em&gt; 부분으로 구문 분석합니다 . 구문 분석에 실패하지 않는 한 해당 정보의 튜플을 반환합니다.이 경우 2 개의 튜플 &lt;code&gt;('', '')&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfb97eef332ed35c993d49a75d83bad160155a8" translate="yes" xml:space="preserve">
          <source>Parse an IMAP4 &lt;code&gt;INTERNALDATE&lt;/code&gt; string and return corresponding local time. The return value is a &lt;a href=&quot;time#time.struct_time&quot;&gt;&lt;code&gt;time.struct_time&lt;/code&gt;&lt;/a&gt; tuple or &lt;code&gt;None&lt;/code&gt; if the string has wrong format.</source>
          <target state="translated">IMAP4 &lt;code&gt;INTERNALDATE&lt;/code&gt; 문자열을 구문 분석하고 해당 현지 시간을 리턴하십시오. 반환 값은 &lt;a href=&quot;time#time.struct_time&quot;&gt; &lt;code&gt;time.struct_time&lt;/code&gt; &lt;/a&gt; 튜플이거나 문자열의 형식이 잘못된 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="77b4c57e66b64e4534f7423e678b54e99d6e7ad3" translate="yes" xml:space="preserve">
          <source>Parse configuration data from a string.</source>
          <target state="translated">문자열에서 구성 데이터를 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="34ec846a5cc0bb5312516a5590e119f9b3d82572" translate="yes" xml:space="preserve">
          <source>Parse every input line as separate JSON object.</source>
          <target state="translated">모든 입력 행을 별도의 JSON 객체로 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="92f18fdd6a043541a20dbdffd6b3b6b5c6b25947" translate="yes" xml:space="preserve">
          <source>Parse input of type &lt;em&gt;multipart/form-data&lt;/em&gt; (for file uploads). Arguments are &lt;em&gt;fp&lt;/em&gt; for the input file, &lt;em&gt;pdict&lt;/em&gt; for a dictionary containing other parameters in the &lt;em&gt;Content-Type&lt;/em&gt; header, and &lt;em&gt;encoding&lt;/em&gt;, the request encoding.</source>
          <target state="translated">&lt;em&gt;multipart / form-data&lt;/em&gt; 유형의 입력을 구문 분석하십시오 (파일 업로드 용). 인수는 &lt;em&gt;FP&lt;/em&gt; 입력 파일, &lt;em&gt;pdict&lt;/em&gt; 다른 파라미터를 포함하는 사전에 대한 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더 및 &lt;em&gt;인코딩&lt;/em&gt; 요청 인코딩.</target>
        </trans-unit>
        <trans-unit id="b48fc13fc5d8b028c399137b19563a9d740767c5" translate="yes" xml:space="preserve">
          <source>Parse the headers from a file pointer &lt;em&gt;fp&lt;/em&gt; representing a HTTP request/response. The file has to be a &lt;code&gt;BufferedIOBase&lt;/code&gt; reader (i.e. not text) and must provide a valid &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; style header.</source>
          <target state="translated">HTTP 요청 / 응답을 나타내는 파일 포인터 &lt;em&gt;fp&lt;/em&gt; 에서 헤더를 구문 분석하십시오 . 파일은 텍스트가 아닌 &lt;code&gt;BufferedIOBase&lt;/code&gt; 리더 여야하며 유효한 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 스타일 헤더를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6322b351357533e4088cb2f327b3892c078e67a0" translate="yes" xml:space="preserve">
          <source>Parse the source into an AST node. Equivalent to &lt;code&gt;compile(source,
filename, mode, ast.PyCF_ONLY_AST)&lt;/code&gt;.</source>
          <target state="translated">소스를 AST 노드로 구문 분석하십시오. 등가 &lt;code&gt;compile(source, filename, mode, ast.PyCF_ONLY_AST)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac1f2c832714de7833881fe2be021bca052cf91d" translate="yes" xml:space="preserve">
          <source>Parser API</source>
          <target state="translated">파서 API</target>
        </trans-unit>
        <trans-unit id="004fa2d97b3f68b254662790038060204e61b5c4" translate="yes" xml:space="preserve">
          <source>Parser defaults</source>
          <target state="translated">파서 기본값</target>
        </trans-unit>
        <trans-unit id="8ae5e9df787606f6a18b61bb53d88c9edc2ac786" translate="yes" xml:space="preserve">
          <source>Parser for configuration files similar to the Windows &lt;code&gt;.ini&lt;/code&gt; files.</source>
          <target state="translated">Windows &lt;code&gt;.ini&lt;/code&gt; 파일 과 유사한 구성 파일 파서 .</target>
        </trans-unit>
        <trans-unit id="d8dc10de6adfe8e18f4e99f44dfc697378f4b6ab" translate="yes" xml:space="preserve">
          <source>Parser for the &lt;code&gt;.netrc&lt;/code&gt; file format. The file &lt;code&gt;.netrc&lt;/code&gt; is typically used by FTP clients to load user authentication information before prompting the user.</source>
          <target state="translated">&lt;code&gt;.netrc&lt;/code&gt; 파일 형식의 파서 &lt;code&gt;.netrc&lt;/code&gt; 파일 은 일반적으로 FTP 클라이언트가 사용자에게 프롬프트하기 전에 사용자 인증 정보를로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6729f41bc7511e1386806d0ce0191be70095ac9b" translate="yes" xml:space="preserve">
          <source>Parser-level defaults can be particularly useful when working with multiple parsers. See the &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt;&lt;code&gt;add_subparsers()&lt;/code&gt;&lt;/a&gt; method for an example of this type.</source>
          <target state="translated">파서 수준의 기본값은 여러 파서로 작업 할 때 특히 유용 할 수 있습니다. 이 유형의 예 는 &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt; &lt;code&gt;add_subparsers()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edcb4a36322d5054120f5cf55bd4daebc8e8fd44" translate="yes" xml:space="preserve">
          <source>Parsers may set the &lt;em&gt;qname&lt;/em&gt; parameter to &lt;code&gt;None&lt;/code&gt;, unless the &lt;code&gt;feature_namespace_prefixes&lt;/code&gt; feature is activated.</source>
          <target state="translated">&lt;code&gt;feature_namespace_prefixes&lt;/code&gt; 기능이 활성화 되지 않은 경우 구문 분석기는 &lt;em&gt;qname&lt;/em&gt; 매개 변수를 &lt;code&gt;None&lt;/code&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee2780af704008ebc69c8aa8369ff3c29a512d2d" translate="yes" xml:space="preserve">
          <source>Parses an XML document from a sequence of string fragments. &lt;em&gt;sequence&lt;/em&gt; is a list or other sequence containing XML data fragments. &lt;em&gt;parser&lt;/em&gt; is an optional parser instance. If not given, the standard &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; parser is used. Returns an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">일련의 문자열 조각에서 XML 문서를 구문 분석합니다. &lt;em&gt;sequence&lt;/em&gt; 는 XML 데이터 조각을 포함하는 목록 또는 기타 시퀀스입니다. &lt;em&gt;파서&lt;/em&gt; 는 선택적 파서 인스턴스입니다. 지정하지 않으면 표준 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 파서가 사용됩니다. &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fbbb018cccf811e0d533b9e865ec5ffa820c0b5e" translate="yes" xml:space="preserve">
          <source>Parses an XML section from a string constant, and also returns a dictionary which maps from element id:s to elements. &lt;em&gt;text&lt;/em&gt; is a string containing XML data. &lt;em&gt;parser&lt;/em&gt; is an optional parser instance. If not given, the standard &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; parser is used. Returns a tuple containing an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; instance and a dictionary.</source>
          <target state="translated">문자열 상수에서 XML 섹션을 구문 분석하고 요소 id : s에서 요소로 맵핑되는 사전도 리턴합니다. &lt;em&gt;text&lt;/em&gt; 는 XML 데이터를 포함하는 문자열입니다. &lt;em&gt;파서&lt;/em&gt; 는 선택적 파서 인스턴스입니다. 지정하지 않으면 표준 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 파서가 사용됩니다. &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 인스턴스와 사전을 포함하는 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="72927f75fe80a6b69eb37dde451d1d4fc5f35092" translate="yes" xml:space="preserve">
          <source>Parses an XML section from a string constant. Same as &lt;a href=&quot;#xml.etree.ElementTree.XML&quot;&gt;&lt;code&gt;XML()&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;text&lt;/em&gt; is a string containing XML data. &lt;em&gt;parser&lt;/em&gt; is an optional parser instance. If not given, the standard &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; parser is used. Returns an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">문자열 상수에서 XML 섹션을 구문 분석합니다. 동일 &lt;a href=&quot;#xml.etree.ElementTree.XML&quot;&gt; &lt;code&gt;XML()&lt;/code&gt; &lt;/a&gt; . &lt;em&gt;text&lt;/em&gt; 는 XML 데이터를 포함하는 문자열입니다. &lt;em&gt;파서&lt;/em&gt; 는 선택적 파서 인스턴스입니다. 지정하지 않으면 표준 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 파서가 사용됩니다. &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7af853719821e9fd72d58e55be379388db261dbd" translate="yes" xml:space="preserve">
          <source>Parses an XML section from a string constant. This function can be used to embed &amp;ldquo;XML literals&amp;rdquo; in Python code. &lt;em&gt;text&lt;/em&gt; is a string containing XML data. &lt;em&gt;parser&lt;/em&gt; is an optional parser instance. If not given, the standard &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; parser is used. Returns an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">문자열 상수에서 XML 섹션을 구문 분석합니다. 이 함수는 Python 코드에 &quot;XML 리터럴&quot;을 포함시키는 데 사용할 수 있습니다. &lt;em&gt;text&lt;/em&gt; 는 XML 데이터를 포함하는 문자열입니다. &lt;em&gt;파서&lt;/em&gt; 는 선택적 파서 인스턴스입니다. 지정하지 않으면 표준 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 파서가 사용됩니다. &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="dae47704d2ee507567c8bffbe47a3689bb12542a" translate="yes" xml:space="preserve">
          <source>Parses an XML section into an element tree incrementally, and reports what&amp;rsquo;s going on to the user. &lt;em&gt;source&lt;/em&gt; is a filename or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; containing XML data. &lt;em&gt;events&lt;/em&gt; is a sequence of events to report back. The supported events are the strings &lt;code&gt;&quot;start&quot;&lt;/code&gt;, &lt;code&gt;&quot;end&quot;&lt;/code&gt;, &lt;code&gt;&quot;comment&quot;&lt;/code&gt;, &lt;code&gt;&quot;pi&quot;&lt;/code&gt;, &lt;code&gt;&quot;start-ns&quot;&lt;/code&gt; and &lt;code&gt;&quot;end-ns&quot;&lt;/code&gt; (the &amp;ldquo;ns&amp;rdquo; events are used to get detailed namespace information). If &lt;em&gt;events&lt;/em&gt; is omitted, only &lt;code&gt;&quot;end&quot;&lt;/code&gt; events are reported. &lt;em&gt;parser&lt;/em&gt; is an optional parser instance. If not given, the standard &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; parser is used. &lt;em&gt;parser&lt;/em&gt; must be a subclass of &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; and can only use the default &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt;&lt;code&gt;TreeBuilder&lt;/code&gt;&lt;/a&gt; as a target. Returns an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;iterator&lt;/a&gt; providing &lt;code&gt;(event, elem)&lt;/code&gt; pairs.</source>
          <target state="translated">XML 섹션을 요소 트리로 점진적으로 구문 분석하고 사용자에게 진행중인 작업을보고합니다. &lt;em&gt;source&lt;/em&gt; 는 XML 데이터를 포함 하는 파일 이름 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 입니다. &lt;em&gt;events&lt;/em&gt; 는보고 할 일련의 이벤트입니다. 지원되는 이벤트는 &lt;code&gt;&quot;start&quot;&lt;/code&gt; , &lt;code&gt;&quot;end&quot;&lt;/code&gt; , &lt;code&gt;&quot;comment&quot;&lt;/code&gt; , &lt;code&gt;&quot;pi&quot;&lt;/code&gt; , &lt;code&gt;&quot;start-ns&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;end-ns&quot;&lt;/code&gt; 문자열입니다 ( &quot;ns&quot;이벤트는 자세한 네임 스페이스 정보를 얻는 데 사용됨). 경우 &lt;em&gt;이벤트가&lt;/em&gt; 생략되고, 오직 &lt;code&gt;&quot;end&quot;&lt;/code&gt; 이벤트가보고됩니다. &lt;em&gt;파서&lt;/em&gt; 는 선택적 파서 인스턴스입니다. 제공하지 않으면표준 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 파서가 사용됩니다.&lt;em&gt;파서&lt;/em&gt; 는 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 여야하며 기본 &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt; &lt;code&gt;TreeBuilder&lt;/code&gt; &lt;/a&gt; 만 대상 으로 사용할 수 있습니다 . &lt;code&gt;(event, elem)&lt;/code&gt; 쌍을 제공 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;반복자를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ee0df73ef04440db4a8154c7c363a73ee5b68bdc" translate="yes" xml:space="preserve">
          <source>Parses an XML section into an element tree. &lt;em&gt;source&lt;/em&gt; is a filename or file object containing XML data. &lt;em&gt;parser&lt;/em&gt; is an optional parser instance. If not given, the standard &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; parser is used. Returns an &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">XML 섹션을 요소 트리로 구문 분석합니다. &lt;em&gt;source&lt;/em&gt; 는 XML 데이터를 포함하는 파일 이름 또는 파일 객체입니다. &lt;em&gt;파서&lt;/em&gt; 는 선택적 파서 인스턴스입니다. 지정하지 않으면 표준 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 파서가 사용됩니다. &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="151f487cf2996ed020c6158161493638425f24db" translate="yes" xml:space="preserve">
          <source>Parses command line options and parameter list. &lt;em&gt;args&lt;/em&gt; is the argument list to be parsed, without the leading reference to the running program. Typically, this means &lt;code&gt;sys.argv[1:]&lt;/code&gt;. &lt;em&gt;shortopts&lt;/em&gt; is the string of option letters that the script wants to recognize, with options that require an argument followed by a colon (&lt;code&gt;':'&lt;/code&gt;; i.e., the same format that Unix &lt;code&gt;getopt()&lt;/code&gt; uses).</source>
          <target state="translated">명령 행 옵션 및 매개 변수 목록을 구문 분석합니다. &lt;em&gt;args&lt;/em&gt; 는 실행중인 프로그램에 대한 선행 참조없이 구문 분석 할 인수 목록입니다. 일반적으로 이것은 &lt;code&gt;sys.argv[1:]&lt;/code&gt; 의미 합니다. &lt;em&gt;shortopts는&lt;/em&gt; (스크립트가 다음에 콜론 인수를 요구하는 옵션을 인식하기를 원하는 옵션 문자의 문자열입니다 &lt;code&gt;':'&lt;/code&gt; , 즉, 동일한 형식이 유닉스 &lt;code&gt;getopt()&lt;/code&gt; 가 사용하는).</target>
        </trans-unit>
        <trans-unit id="df868cb1150d0cfbe21af7ee4cdd7fd10637e164" translate="yes" xml:space="preserve">
          <source>Parses the contents of the string &lt;em&gt;data&lt;/em&gt;, calling the appropriate handler functions to process the parsed data. &lt;em&gt;isfinal&lt;/em&gt; must be true on the final call to this method; it allows the parsing of a single file in fragments, not the submission of multiple files. &lt;em&gt;data&lt;/em&gt; can be the empty string at any time.</source>
          <target state="translated">문자열 &lt;em&gt;데이터&lt;/em&gt; 의 내용을 구문 분석하고 구문 분석 된 데이터를 처리하기 위해 적절한 핸들러 함수를 호출합니다. 이 메소드에 대한 최종 호출에서 &lt;em&gt;isfinal&lt;/em&gt; 은 true 여야합니다. 여러 파일을 제출하지 않고 조각으로 단일 파일을 구문 분석 할 수 있습니다. &lt;em&gt;데이터&lt;/em&gt; 는 언제든지 빈 문자열이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c9fa62bd1c27ae8dae11e96078b9e813bde82ff" translate="yes" xml:space="preserve">
          <source>Parses the lines argument.</source>
          <target state="translated">행 인수를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="69eb6c34919fe2acf467b9421ca3164345b86455" translate="yes" xml:space="preserve">
          <source>Parsing &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; headers can easily be done by the using the classes from the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">구문 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈 의 클래스를 사용하여 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; 헤더 구문 분석을 쉽게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a72125d574bfaaf5cb1957bf8fd6d75f4bed06e" translate="yes" xml:space="preserve">
          <source>Parsing ASCII Encoded Bytes</source>
          <target state="translated">ASCII로 인코딩 된 바이트 구문 분석</target>
        </trans-unit>
        <trans-unit id="1a2190aff5319c85cf7321ca648eedb2f503316f" translate="yes" xml:space="preserve">
          <source>Parsing Rules</source>
          <target state="translated">파싱 ​​규칙</target>
        </trans-unit>
        <trans-unit id="4574c08a7f81add4e596be6e15b9c64ff9371087" translate="yes" xml:space="preserve">
          <source>Parsing XML</source>
          <target state="translated">XML 파싱</target>
        </trans-unit>
        <trans-unit id="6893fb3b02102f738b0b2dc3c3ca295c4ed12239" translate="yes" xml:space="preserve">
          <source>Parsing XML with Namespaces</source>
          <target state="translated">네임 스페이스를 사용하여 XML 구문 분석</target>
        </trans-unit>
        <trans-unit id="bfa0baebba6e77b74cf2de3bc383caea1641985b" translate="yes" xml:space="preserve">
          <source>Parsing a doctype:</source>
          <target state="translated">독 타입 파싱 :</target>
        </trans-unit>
        <trans-unit id="0a576c94c20901b183af1b9a14ad8b63c3b0db12" translate="yes" xml:space="preserve">
          <source>Parsing a plist:</source>
          <target state="translated">plist 파싱 :</target>
        </trans-unit>
        <trans-unit id="4ed97da7a55821def4af9e81923e5326722f8668" translate="yes" xml:space="preserve">
          <source>Parsing an element with a few attributes and a title:</source>
          <target state="translated">몇 가지 속성과 제목을 가진 요소 구문 분석 :</target>
        </trans-unit>
        <trans-unit id="17b7786ea139dbd78158c2c45139b4c833a9c6d6" translate="yes" xml:space="preserve">
          <source>Parsing arguments</source>
          <target state="translated">인수 파싱</target>
        </trans-unit>
        <trans-unit id="a47b1c882acdc40fdce7e0fb4d77502237f146c7" translate="yes" xml:space="preserve">
          <source>Parsing comments:</source>
          <target state="translated">의견 파싱 :</target>
        </trans-unit>
        <trans-unit id="e31699a29c24a3b26bf46b6d3bdc4ef92cc3a31e" translate="yes" xml:space="preserve">
          <source>Parsing invalid HTML (e.g. unquoted attributes) also works:</source>
          <target state="translated">유효하지 않은 HTML 구문 분석 (예 : 인용되지 않은 속성)도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9d4775ea5c5af964bed4d175c5add3a853ae58b6" translate="yes" xml:space="preserve">
          <source>Parsing is performed by the &lt;code&gt;DictConfigurator&lt;/code&gt; class, whose constructor is passed the dictionary used for configuration, and has a &lt;code&gt;configure()&lt;/code&gt; method. The &lt;a href=&quot;#module-logging.config&quot;&gt;&lt;code&gt;logging.config&lt;/code&gt;&lt;/a&gt; module has a callable attribute &lt;code&gt;dictConfigClass&lt;/code&gt; which is initially set to &lt;code&gt;DictConfigurator&lt;/code&gt;. You can replace the value of &lt;code&gt;dictConfigClass&lt;/code&gt; with a suitable implementation of your own.</source>
          <target state="translated">구문 분석은 생성자에 구성에 사용 된 사전이 전달되고 &lt;code&gt;configure()&lt;/code&gt; 메소드 가있는 &lt;code&gt;DictConfigurator&lt;/code&gt; 클래스에 의해 수행됩니다 . &lt;a href=&quot;#module-logging.config&quot;&gt; &lt;code&gt;logging.config&lt;/code&gt; 의&lt;/a&gt; 모듈은 호출 속성 갖는다 &lt;code&gt;dictConfigClass&lt;/code&gt; 초기에 설정된 &lt;code&gt;DictConfigurator&lt;/code&gt; 를 . &lt;code&gt;dictConfigClass&lt;/code&gt; 의 값을 자신의 적절한 구현으로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e482f0fc24f824a62c06ebb7859dfede7d0aa064" translate="yes" xml:space="preserve">
          <source>Parsing named and numeric character references and converting them to the correct char (note: these 3 references are all equivalent to &lt;code&gt;'&amp;gt;'&lt;/code&gt;):</source>
          <target state="translated">명명 된 숫자 참조 및 숫자 참조를 구문 분석하고 올바른 문자로 변환 (참고 :이 3 개의 참조는 모두 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="a44bc4f5945b088db01b0d914b0d941b07799822" translate="yes" xml:space="preserve">
          <source>Parsing requirements for mailto URL schemes.</source>
          <target state="translated">mailto URL 스킴에 대한 구문 분석 요구 사항</target>
        </trans-unit>
        <trans-unit id="bf3d21c265eb4a00a78d8f62a6d665405bb16b18" translate="yes" xml:space="preserve">
          <source>Partial mocking</source>
          <target state="translated">부분 조롱</target>
        </trans-unit>
        <trans-unit id="8898adadc5b7993600711b7f5c715af91efba444" translate="yes" xml:space="preserve">
          <source>Partial parsing</source>
          <target state="translated">부분 파싱</target>
        </trans-unit>
        <trans-unit id="8a924cc1e2ca080e3d2d9070952b331ebd977a94" translate="yes" xml:space="preserve">
          <source>Partial support of the Windows &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms686331(v=vs.85).aspx&quot;&gt;STARTUPINFO&lt;/a&gt; structure is used for &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; creation. The following attributes can be set by passing them as keyword-only arguments.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 작성 에는 Windows &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms686331(v=vs.85).aspx&quot;&gt;STARTUPINFO&lt;/a&gt; 구조 의 일부 지원 이 사용됩니다 . 다음 속성은 키워드 전용 인수로 전달하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cefe65497d71ce480712ec369093347b9edf071" translate="yes" xml:space="preserve">
          <source>Pass one or more paths (as strings) to text files to be examined.</source>
          <target state="translated">검사 할 텍스트 파일에 하나 이상의 경로 (문자열)를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5f7450f952fba25aff224ced294b6f998b462e06" translate="yes" xml:space="preserve">
          <source>Pass the barrier. When all the threads party to the barrier have called this function, they are all released simultaneously. If a &lt;em&gt;timeout&lt;/em&gt; is provided, it is used in preference to any that was supplied to the class constructor.</source>
          <target state="translated">장벽을 통과하십시오. 장벽에 대한 모든 스레드가이 기능을 호출하면 동시에 해제됩니다. 경우 &lt;em&gt;타임 아웃이&lt;/em&gt; 제공되는데, 이는 클래스 생성자에 공급되었다는 우선적으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="990deeb80d6138076466ced9282b16e7f18f84fb" translate="yes" xml:space="preserve">
          <source>Pass to &lt;a href=&quot;#resource.getrusage&quot;&gt;&lt;code&gt;getrusage()&lt;/code&gt;&lt;/a&gt; to request resources consumed by both the current process and child processes. May not be available on all systems.</source>
          <target state="translated">로 패스 &lt;a href=&quot;#resource.getrusage&quot;&gt; &lt;code&gt;getrusage()&lt;/code&gt; &lt;/a&gt; 현재 프로세스와 자식 프로세스 모두에 의해 소비 요청 리소스에. 모든 시스템에서 사용 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6c0db84a8ee7e54a3fa9e2983efa2cdd04a121a8" translate="yes" xml:space="preserve">
          <source>Pass to &lt;a href=&quot;#resource.getrusage&quot;&gt;&lt;code&gt;getrusage()&lt;/code&gt;&lt;/a&gt; to request resources consumed by child processes of the calling process which have been terminated and waited for.</source>
          <target state="translated">로 패스 &lt;a href=&quot;#resource.getrusage&quot;&gt; &lt;code&gt;getrusage()&lt;/code&gt; &lt;/a&gt; 종료하고 기다렸다 된 호출 프로세스의 자식 프로세스에 의해 소비 요청 리소스에.</target>
        </trans-unit>
        <trans-unit id="65a4c34a2a87e93e40e98a2b333bc373444fe153" translate="yes" xml:space="preserve">
          <source>Pass to &lt;a href=&quot;#resource.getrusage&quot;&gt;&lt;code&gt;getrusage()&lt;/code&gt;&lt;/a&gt; to request resources consumed by the calling process, which is the sum of resources used by all threads in the process.</source>
          <target state="translated">로 패스 &lt;a href=&quot;#resource.getrusage&quot;&gt; &lt;code&gt;getrusage()&lt;/code&gt; &lt;/a&gt; 프로세스의 모든 스레드가 사용하는 자원의 합 호출 과정에서 소비 요청 리소스에.</target>
        </trans-unit>
        <trans-unit id="6d9dbad6ac28906fedfb066087f4e23428020121" translate="yes" xml:space="preserve">
          <source>Pass to &lt;a href=&quot;#resource.getrusage&quot;&gt;&lt;code&gt;getrusage()&lt;/code&gt;&lt;/a&gt; to request resources consumed by the current thread. May not be available on all systems.</source>
          <target state="translated">현재 스레드가 소비 한 자원을 요청 하려면 &lt;a href=&quot;#resource.getrusage&quot;&gt; &lt;code&gt;getrusage()&lt;/code&gt; &lt;/a&gt; 에 전달하십시오. 모든 시스템에서 사용 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="271d60f487b5b3f1af07cb53c6718722743b3a26" translate="yes" xml:space="preserve">
          <source>Passed</source>
          <target state="translated">Passed</target>
        </trans-unit>
        <trans-unit id="c1a8ee630c475631807e09dc9f6d88c91b3db2ff" translate="yes" xml:space="preserve">
          <source>Passing &lt;a href=&quot;#argparse.RawDescriptionHelpFormatter&quot;&gt;&lt;code&gt;RawDescriptionHelpFormatter&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;formatter_class=&lt;/code&gt; indicates that &lt;a href=&quot;#description&quot;&gt;description&lt;/a&gt; and &lt;a href=&quot;#epilog&quot;&gt;epilog&lt;/a&gt; are already correctly formatted and should not be line-wrapped:</source>
          <target state="translated">전달 &lt;a href=&quot;#argparse.RawDescriptionHelpFormatter&quot;&gt; &lt;code&gt;RawDescriptionHelpFormatter&lt;/code&gt; 을&lt;/a&gt; 같이 &lt;code&gt;formatter_class=&lt;/code&gt; 나타냅니다 &lt;a href=&quot;#description&quot;&gt;설명&lt;/a&gt; 및 &lt;a href=&quot;#epilog&quot;&gt;에필로그는&lt;/a&gt; 이미 올바른 형식 및 라인 감싸 안 :</target>
        </trans-unit>
        <trans-unit id="3cc7098ba0d08be5b9eeb5f8d505a19e1aa66759" translate="yes" xml:space="preserve">
          <source>Passing &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; as &lt;em&gt;trace_callback&lt;/em&gt; will disable the trace callback.</source>
          <target state="translated">&lt;em&gt;trace_callback으로 &lt;/em&gt;&lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 전달 하면 추적 콜백이 비활성화됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d024dbf4319068e7f12b8e77a46bc274a6f14064" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;datetime.strptime('Feb 29', '%b %d')&lt;/code&gt; will fail since &lt;code&gt;1900&lt;/code&gt; is not a leap year.</source>
          <target state="translated">전달 &lt;code&gt;datetime.strptime('Feb 29', '%b %d')&lt;/code&gt; 보낸 실패 &lt;code&gt;1900&lt;/code&gt; 윤년 아니다.</target>
        </trans-unit>
        <trans-unit id="02f10d83abb588c6900248de658aa7a62805f3aa" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;debug=True&lt;/code&gt; to &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;debug=True&lt;/code&gt; 를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="d3551e0fe86a1365158e456ce9f8d713fe328a1b" translate="yes" xml:space="preserve">
          <source>Passing a &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object to &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; without the &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; arguments falls under the first case of returning the informal string representation (see also the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-b&quot;&gt;&lt;code&gt;-b&lt;/code&gt;&lt;/a&gt; command-line option to Python). For example:</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 인수 없이 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 전달하는 것은 비공식 문자열 표현을 반환하는 첫 번째 경우에 해당합니다 ( Python 의 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-b&quot;&gt; &lt;code&gt;-b&lt;/code&gt; &lt;/a&gt; 명령 행 옵션 참조 ). 예를 들면 다음과 같습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9cdbfdcb197d91dd62f0f8abd3627fccc6f87c2d" translate="yes" xml:space="preserve">
          <source>Passing a directory is also acceptable:</source>
          <target state="translated">디렉토리 전달도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="23ea26b7b9b743e6b69e8adca10474d32ff7f4c4" translate="yes" xml:space="preserve">
          <source>Passing a false value for &lt;em&gt;flag&lt;/em&gt; will cancel a previous call that passed a true value, but otherwise has no effect.</source>
          <target state="translated">&lt;em&gt;플래그에&lt;/em&gt; 대해 잘못된 값을 전달하면 실제 값을 전달한 이전 호출이 취소되지만 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d96b6cf88dd53f9df9983de6c2674fdbef0f57cf" translate="yes" xml:space="preserve">
          <source>Passing an invalid or expired &lt;em&gt;thread_id&lt;/em&gt; may result in undefined behavior, such as segmentation fault.</source>
          <target state="translated">유효하지 않거나 만료 된 &lt;em&gt;thread_id를&lt;/em&gt; 전달하면 세그먼트 화 결함과 같이 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4373763b08bb2aaf6a891ea712bad980acdaeae" translate="yes" xml:space="preserve">
          <source>Passing arguments of the wrong type (e.g. passing a &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; when an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is expected) should result in a &lt;a href=&quot;#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, but passing arguments with the wrong value (e.g. a number outside expected boundaries) should result in a &lt;a href=&quot;#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잘못된 유형의 인수를 전달하면 (예 : &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 가 예상 될 때 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 전달하면 ) &lt;a href=&quot;#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생 하지만 잘못된 값을 가진 인수를 전달하면 (예 : 예상 범위를 벗어난 숫자) &lt;a href=&quot;#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ce254e377d02b1546a547ed5a4b85276ee5363e9" translate="yes" xml:space="preserve">
          <source>Passing pointers (or: passing parameters by reference)</source>
          <target state="translated">전달 포인터 (또는 참조로 매개 변수 전달)</target>
        </trans-unit>
        <trans-unit id="f3fa6806e05d0efc4240e4ddbbec8d0f63598164" translate="yes" xml:space="preserve">
          <source>Passing the &lt;code&gt;-v&lt;/code&gt; option to your test script will instruct &lt;a href=&quot;#unittest.main&quot;&gt;&lt;code&gt;unittest.main()&lt;/code&gt;&lt;/a&gt; to enable a higher level of verbosity, and produce the following output:</source>
          <target state="translated">&lt;code&gt;-v&lt;/code&gt; 옵션을 테스트 스크립트에 전달하면 &lt;a href=&quot;#unittest.main&quot;&gt; &lt;code&gt;unittest.main()&lt;/code&gt; &lt;/a&gt; 에 더 자세한 레벨을 표시하고 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bd57565121ff601125e660a69c2626eb5a561528" translate="yes" xml:space="preserve">
          <source>Passing the &lt;em&gt;encoding&lt;/em&gt; argument to &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; allows decoding any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; directly, without needing to make a temporary bytes or bytearray object.</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 인수를 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 에&lt;/a&gt; 전달하면 임시 바이트 또는 바이트 배열 객체를 만들 필요없이 모든 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체를&lt;/a&gt; 직접 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c8e2c14f5bd9b6c379aece2cadfc65b3d7043c9" translate="yes" xml:space="preserve">
          <source>Passing the optional &lt;em&gt;timeout&lt;/em&gt; parameter will set the timeout on the socket instance before attempting to connect. If no &lt;em&gt;timeout&lt;/em&gt; is supplied, the global default timeout setting returned by &lt;a href=&quot;#socket.getdefaulttimeout&quot;&gt;&lt;code&gt;getdefaulttimeout()&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수를 전달하면 연결을 시도하기 전에 소켓 인스턴스의 시간 초과가 설정됩니다. &lt;em&gt;시간 초과&lt;/em&gt; 가 제공 되지 않으면 &lt;a href=&quot;#socket.getdefaulttimeout&quot;&gt; &lt;code&gt;getdefaulttimeout()&lt;/code&gt; &lt;/a&gt; 반환 한 전역 기본 시간 초과 설정 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8be3c943b1609fffbfc51aad666d0a04adf83c9d" translate="yes" xml:space="preserve">
          <source>Password</source>
          <target state="translated">Password</target>
        </trans-unit>
        <trans-unit id="8b7a491eeb7b640b68f36bf4268b49be1a79e14c" translate="yes" xml:space="preserve">
          <source>Password database entries are reported as a tuple-like object, whose attributes correspond to the members of the &lt;code&gt;passwd&lt;/code&gt; structure (Attribute field below, see &lt;code&gt;&amp;lt;pwd.h&amp;gt;&lt;/code&gt;):</source>
          <target state="translated">비밀번호 데이터베이스 항목은 속성이 &lt;code&gt;passwd&lt;/code&gt; 구조 의 멤버에 해당하는 튜플 유사 오브젝트로보고됩니다 (아래 속성 필드, &lt;code&gt;&amp;lt;pwd.h&amp;gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="124df59fda65fb78cd1ae393c55a5a743faabbc8" translate="yes" xml:space="preserve">
          <source>Passwords are limited to a subset of the ASCII character set. All ASCII punctuation is allowed in passwords, however, note that whitespace and non-printable characters are not allowed in passwords. This is a limitation of the way the .netrc file is parsed and may be removed in the future.</source>
          <target state="translated">암호는 ASCII 문자 집합의 하위 집합으로 제한됩니다. 모든 ASCII 문장 부호는 비밀번호에 허용되지만 공백 및 인쇄 할 수없는 문자는 비밀번호에 사용할 수 없습니다. 이것은 .netrc 파일이 구문 분석되는 방식의 한계이며 향후 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2483000d154ca9fd74d41fc4e063a4b28faa87" translate="yes" xml:space="preserve">
          <source>Paste</source>
          <target state="translated">Paste</target>
        </trans-unit>
        <trans-unit id="83031d4915377d907a024876b60112ce6b924d4d" translate="yes" xml:space="preserve">
          <source>Patch Decorators</source>
          <target state="translated">패치 데코레이터</target>
        </trans-unit>
        <trans-unit id="09e818ea13f3990a9818a47cc9bb0ee42b62ff97" translate="yes" xml:space="preserve">
          <source>Patch a dictionary, or dictionary like object, and restore the dictionary to its original state after the test.</source>
          <target state="translated">사전 또는 객체와 같은 사전을 패치하고 테스트 후 사전을 원래 상태로 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="263242e9d8ee6d3a8c9d445eaa84200b976eae2d" translate="yes" xml:space="preserve">
          <source>Patch can be used as a &lt;code&gt;TestCase&lt;/code&gt; class decorator. It works by decorating each test method in the class. This reduces the boilerplate code when your test methods share a common patchings set. &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; finds tests by looking for method names that start with &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt;. By default this is &lt;code&gt;'test'&lt;/code&gt;, which matches the way &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; finds tests. You can specify an alternative prefix by setting &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt;.</source>
          <target state="translated">패치는 &lt;code&gt;TestCase&lt;/code&gt; 클래스 데코레이터 로 사용할 수 있습니다 . 클래스의 각 테스트 방법을 장식하여 작동합니다. 테스트 방법이 공통 패치 세트를 공유 할 때 상용구 코드가 줄어 듭니다. &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 로 시작하는 메소드 이름을 찾아 테스트를 찾습니다 . 기본적으로 이것은 &lt;code&gt;'test'&lt;/code&gt; 이며 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 가 테스트를 찾는 방식과 일치합니다 . &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 를 설정하여 대체 접 두부를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ea198b4f1da676b4f4ee1391b5cd9f398dde45f" translate="yes" xml:space="preserve">
          <source>Patch can be used as a context manager, with the with statement. Here the patching applies to the indented block after the with statement. If you use &amp;ldquo;as&amp;rdquo; then the patched object will be bound to the name after the &amp;ldquo;as&amp;rdquo;; very useful if &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is creating a mock object for you.</source>
          <target state="translated">with 문을 사용하여 패치를 컨텍스트 관리자로 사용할 수 있습니다. 여기서 패치는 with 문 다음에 들여 쓰기 된 블록에 적용됩니다. &amp;ldquo;as&amp;rdquo;를 사용하면 패치 된 객체는&amp;ldquo;as&amp;rdquo;뒤에 이름으로 바인딩됩니다. &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 가 모의 객체를 만드는 경우 매우 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="e8cdaeb7364059eaef7f04272544a953feb7db50" translate="yes" xml:space="preserve">
          <source>Patching Descriptors and Proxy Objects</source>
          <target state="translated">패치 설명자 및 프록시 객체</target>
        </trans-unit>
        <trans-unit id="88e8009ab58a0045c0df41b27cf1d23b8f9e089e" translate="yes" xml:space="preserve">
          <source>Patching a class replaces the class with a &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt;&lt;em&gt;instance&lt;/em&gt;. If the class is instantiated in the code under test then it will be the &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt;&lt;code&gt;return_value&lt;/code&gt;&lt;/a&gt; of the mock that will be used.</source>
          <target state="translated">클래스를 패치하면 클래스가 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 인스턴스&lt;/em&gt; 로 바뀝니다 . 테스트중인 코드에서 클래스가 인스턴스화 되면 사용될 모의 의 &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt; &lt;code&gt;return_value&lt;/code&gt; &lt;/a&gt; 가됩니다.</target>
        </trans-unit>
        <trans-unit id="b4f699dcf689fd2e162beca6b9bc0b1522d6aec3" translate="yes" xml:space="preserve">
          <source>Path Browser</source>
          <target state="translated">경로 브라우저</target>
        </trans-unit>
        <trans-unit id="02e6896120f3e34789cebea70374b537c5ff361e" translate="yes" xml:space="preserve">
          <source>Path Objects</source>
          <target state="translated">경로 객체</target>
        </trans-unit>
        <trans-unit id="075cd299fd28fb73d267fb35307dd296768150cc" translate="yes" xml:space="preserve">
          <source>Path for shell if not on Windows; otherwise &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Windows가 아닌 경우 쉘 경로. 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3261580ab23ac434d20083846bb4cb68cc50af6" translate="yes" xml:space="preserve">
          <source>Path objects are traversable using the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">경로 객체는 &lt;code&gt;/&lt;/code&gt; 연산자를 사용하여 순회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a047b8534e4641b171f8a06143fb41928c581a6" translate="yes" xml:space="preserve">
          <source>Path objects expose the following features of &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">Path 객체는 &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 객체 의 다음 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="90d064bd19c4c3b16b5c26cced735433742488ee" translate="yes" xml:space="preserve">
          <source>Path to the base directory for the user site-packages. Can be &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#site.getuserbase&quot;&gt;&lt;code&gt;getuserbase()&lt;/code&gt;&lt;/a&gt; hasn&amp;rsquo;t been called yet. Default value is &lt;code&gt;~/.local&lt;/code&gt; for UNIX and Mac OS X non-framework builds, &lt;code&gt;~/Library/Python/&lt;em&gt;X.Y&lt;/em&gt;&lt;/code&gt; for Mac framework builds, and &lt;code&gt;&lt;em&gt;%APPDATA%&lt;/em&gt;\Python&lt;/code&gt; for Windows. This value is used by Distutils to compute the installation directories for scripts, data files, Python modules, etc. for the &lt;a href=&quot;https://docs.python.org/3.8/install/index.html#inst-alt-install-user&quot;&gt;user installation scheme&lt;/a&gt;. See also &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONUSERBASE&quot; id=&quot;index-9&quot;&gt;&lt;code&gt;PYTHONUSERBASE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 사이트 패키지의 기본 디렉토리에 대한 경로입니다. &lt;a href=&quot;#site.getuserbase&quot;&gt; &lt;code&gt;getuserbase()&lt;/code&gt; &lt;/a&gt; 가 아직 호출되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 기본값은 UNIX 및 Mac OS X 비 프레임 워크 빌드의 경우 &lt;code&gt;~/.local&lt;/code&gt; , Mac 프레임 워크 빌드의 경우 &lt;code&gt;~/Library/Python/&lt;em&gt;X.Y&lt;/em&gt;&lt;/code&gt; &lt;em&gt;XY&lt;/em&gt; , Windows의 경우 &lt;code&gt;&lt;em&gt;%APPDATA%&lt;/em&gt;\Python&lt;/code&gt; \ Python 입니다. 이 값은 Distutils에서 &lt;a href=&quot;https://docs.python.org/3.8/install/index.html#inst-alt-install-user&quot;&gt;사용자 설치 구성표의&lt;/a&gt; 스크립트, 데이터 파일, Python 모듈 등의 설치 디렉토리를 계산하는 데 사용됩니다 . &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONUSERBASE&quot; id=&quot;index-9&quot;&gt; &lt;code&gt;PYTHONUSERBASE&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf71823696007bb6f84923873842b648e97c250a" translate="yes" xml:space="preserve">
          <source>Path to the extension module.</source>
          <target state="translated">확장 모듈의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="d24fcb72bd38ac60753fa7a12e92464c2f4e5e6d" translate="yes" xml:space="preserve">
          <source>Path to the file of the module.</source>
          <target state="translated">모듈 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="082345dbe035cd147fedde8ccbd5cf46cf3be213" translate="yes" xml:space="preserve">
          <source>Path to the user site-packages for the running Python. Can be &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#site.getusersitepackages&quot;&gt;&lt;code&gt;getusersitepackages()&lt;/code&gt;&lt;/a&gt; hasn&amp;rsquo;t been called yet. Default value is &lt;code&gt;~/.local/lib/python&lt;em&gt;X.Y&lt;/em&gt;/site-packages&lt;/code&gt; for UNIX and non-framework Mac OS X builds, &lt;code&gt;~/Library/Python/&lt;em&gt;X.Y&lt;/em&gt;/lib/python/site-packages&lt;/code&gt; for Mac framework builds, and &lt;code&gt;&lt;em&gt;%APPDATA%&lt;/em&gt;\Python\Python&lt;em&gt;XY&lt;/em&gt;\site-packages&lt;/code&gt; on Windows. This directory is a site directory, which means that &lt;code&gt;.pth&lt;/code&gt; files in it will be processed.</source>
          <target state="translated">실행중인 Python의 사용자 사이트 패키지 경로입니다. &lt;a href=&quot;#site.getusersitepackages&quot;&gt; &lt;code&gt;getusersitepackages()&lt;/code&gt; &lt;/a&gt; 가 아직 호출되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 기본값은 UNIX 및 비 프레임 워크 Mac OS X 빌드의 경우 &lt;code&gt;~/.local/lib/python&lt;em&gt;X.Y&lt;/em&gt;/site-packages&lt;/code&gt; &lt;em&gt;X.Y&lt;/em&gt; / site-packages , Mac 프레임 워크 빌드의 경우 &lt;code&gt;~/Library/Python/&lt;em&gt;X.Y&lt;/em&gt;/lib/python/site-packages&lt;/code&gt; &lt;em&gt;XY&lt;/em&gt; / lib / python / site-packages 및 &lt;code&gt;&lt;em&gt;%APPDATA%&lt;/em&gt;\Python\Python&lt;em&gt;XY&lt;/em&gt;\site-packages&lt;/code&gt; Windows에서 &lt;em&gt;%&lt;/em&gt; \ Python \ Python &lt;em&gt;XY&lt;/em&gt; \ site-packages . 이 디렉토리는 사이트 디렉토리이므로 &lt;code&gt;.pth&lt;/code&gt; 파일이 처리됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7f2f6a9b74e163afaf5e72c91f4670c3537cace" translate="yes" xml:space="preserve">
          <source>Paths are immutable and hashable. Paths of a same flavour are comparable and orderable. These properties respect the flavour&amp;rsquo;s case-folding semantics:</source>
          <target state="translated">경로는 변경 불가능하고 해시 가능합니다. 동일한 맛의 경로는 비교 가능하고 주문 가능합니다. 이 속성들은 맛의 대소 문자 구분 의미를 존중합니다 :</target>
        </trans-unit>
        <trans-unit id="03da30c8c0f70e648054fb4f58fddd43a85d5727" translate="yes" xml:space="preserve">
          <source>Paths of a different flavour compare unequal and cannot be ordered:</source>
          <target state="translated">다른 맛의 경로는 동일하지 않으며 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="e25673f3169af15d776c516ae19aa4030127504a" translate="yes" xml:space="preserve">
          <source>Pattern Matching: The Gestalt Approach</source>
          <target state="translated">패턴 매칭 : 게슈탈트 접근법</target>
        </trans-unit>
        <trans-unit id="9c9057f9e71b9a8f041ec30f3fc4350458b54b40" translate="yes" xml:space="preserve">
          <source>Pattern to match test files (&lt;code&gt;test*.py&lt;/code&gt; default)</source>
          <target state="translated">테스트 파일과 일치하는 패턴 ( &lt;code&gt;test*.py&lt;/code&gt; 기본값)</target>
        </trans-unit>
        <trans-unit id="d5b7a4e35290d6ec7c8f9bf1b9c4ba3420b3d7a4" translate="yes" xml:space="preserve">
          <source>Patterns are matched against the fully qualified test method name as imported by the test loader.</source>
          <target state="translated">패턴은 테스트 로더가 가져온 완전한 테스트 방법 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6d0a9052da3aad8ee1a8be3a656e5124e56d40bc" translate="yes" xml:space="preserve">
          <source>Patterns that contain a wildcard character (&lt;code&gt;*&lt;/code&gt;) are matched against the test name using &lt;a href=&quot;fnmatch#fnmatch.fnmatchcase&quot;&gt;&lt;code&gt;fnmatch.fnmatchcase()&lt;/code&gt;&lt;/a&gt;; otherwise simple case-sensitive substring matching is used.</source>
          <target state="translated">와일드 카드 문자 ( &lt;code&gt;*&lt;/code&gt; ) 를 포함하는 패턴은 &lt;a href=&quot;fnmatch#fnmatch.fnmatchcase&quot;&gt; &lt;code&gt;fnmatch.fnmatchcase()&lt;/code&gt; &lt;/a&gt; 사용하여 테스트 이름과 일치합니다 . 그렇지 않으면 간단한 대소 문자 구분 서브 스트링 일치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8d24192acf2841a4026f40125b004cd345b161f3" translate="yes" xml:space="preserve">
          <source>Pause receiving.</source>
          <target state="translated">수신 일시 중지</target>
        </trans-unit>
        <trans-unit id="88bbbed3b2561167e07ac594ad41aef9e33b6843" translate="yes" xml:space="preserve">
          <source>Pause the receiving end of the transport. No data will be passed to the protocol&amp;rsquo;s &lt;a href=&quot;#asyncio.Protocol.data_received&quot;&gt;&lt;code&gt;protocol.data_received()&lt;/code&gt;&lt;/a&gt; method until &lt;a href=&quot;#asyncio.ReadTransport.resume_reading&quot;&gt;&lt;code&gt;resume_reading()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">운송의 수신 끝을 일시 중지하십시오. &lt;a href=&quot;#asyncio.ReadTransport.resume_reading&quot;&gt; &lt;code&gt;resume_reading()&lt;/code&gt; &lt;/a&gt; 이 호출 될 때까지 프로토콜의 &lt;a href=&quot;#asyncio.Protocol.data_received&quot;&gt; &lt;code&gt;protocol.data_received()&lt;/code&gt; &lt;/a&gt; 메소드로 데이터가 전달되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e99a78e932fa2ab9679cec16918f17a775c3a277" translate="yes" xml:space="preserve">
          <source>Pen control</source>
          <target state="translated">펜 컨트롤</target>
        </trans-unit>
        <trans-unit id="e12a091922aa0b42fc8a921c944e57c5b09dfc58" translate="yes" xml:space="preserve">
          <source>PendingDeprecationWarning</source>
          <target state="translated">PendingDeprecationWarning</target>
        </trans-unit>
        <trans-unit id="1c591f7d8be7ebb8d527e8d468608e3bbf82ef75" translate="yes" xml:space="preserve">
          <source>Percentage. Multiplies the number by 100 and displays in fixed (&lt;code&gt;'f'&lt;/code&gt;) format, followed by a percent sign.</source>
          <target state="translated">백분율. 숫자에 100을 곱하고 고정 ( &lt;code&gt;'f'&lt;/code&gt; ) 형식으로 표시 한 다음 백분율 기호를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0af99ae4d5cee179954d90004dcf8ada413c9870" translate="yes" xml:space="preserve">
          <source>Perform &amp;ldquo;rich comparisons&amp;rdquo; between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. Specifically, &lt;code&gt;lt(a, b)&lt;/code&gt; is equivalent to &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;le(a, b)&lt;/code&gt; is equivalent to &lt;code&gt;a &amp;lt;= b&lt;/code&gt;, &lt;code&gt;eq(a,
b)&lt;/code&gt; is equivalent to &lt;code&gt;a == b&lt;/code&gt;, &lt;code&gt;ne(a, b)&lt;/code&gt; is equivalent to &lt;code&gt;a != b&lt;/code&gt;, &lt;code&gt;gt(a, b)&lt;/code&gt; is equivalent to &lt;code&gt;a &amp;gt; b&lt;/code&gt; and &lt;code&gt;ge(a, b)&lt;/code&gt; is equivalent to &lt;code&gt;a
&amp;gt;= b&lt;/code&gt;. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#comparisons&quot;&gt;Comparisons&lt;/a&gt; for more information about rich comparisons.</source>
          <target state="translated">&lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 사이 &lt;em&gt;의&lt;/em&gt; &quot;풍부한 비교&quot;를 수행하십시오 . 구체적으로, &lt;code&gt;lt(a, b)&lt;/code&gt; 는 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 와 같고 , &lt;code&gt;le(a, b)&lt;/code&gt; 는 &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 와 같고 , &lt;code&gt;eq(a, b)&lt;/code&gt; 는 &lt;code&gt;a == b&lt;/code&gt; 와 같습니다 . &lt;code&gt;ne(a, b)&lt;/code&gt; 는 등가 &lt;code&gt;a != b&lt;/code&gt; , &lt;code&gt;gt(a, b)&lt;/code&gt; 동일하다 &lt;code&gt;a &amp;gt; b&lt;/code&gt; 및 &lt;code&gt;ge(a, b)&lt;/code&gt; 동등하다 &lt;code&gt;a &amp;gt;= b&lt;/code&gt; . 이 함수는 모든 값을 반환 할 수 있으며 부울 값으로 해석되거나 해석되지 않을 수 있습니다. 풍부한 비교에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#comparisons&quot;&gt;비교&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c68ed757eddddca4140ad328e3ef6838439a850" translate="yes" xml:space="preserve">
          <source>Perform RLE-decompression on the data, as per the binhex4 standard. The algorithm uses &lt;code&gt;0x90&lt;/code&gt; after a byte as a repeat indicator, followed by a count. A count of &lt;code&gt;0&lt;/code&gt; specifies a byte value of &lt;code&gt;0x90&lt;/code&gt;. The routine returns the decompressed data, unless data input data ends in an orphaned repeat indicator, in which case the &lt;a href=&quot;#binascii.Incomplete&quot;&gt;&lt;code&gt;Incomplete&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">binhex4 표준에 따라 데이터에 대해 RLE 압축 해제를 수행하십시오. 이 알고리즘은 바이트 뒤에 &lt;code&gt;0x90&lt;/code&gt; 을 반복 표시기로 사용하고 그 뒤에 카운트를 사용합니다. 카운트 &lt;code&gt;0&lt;/code&gt; 은 바이트 값 &lt;code&gt;0x90&lt;/code&gt; 을 지정합니다 . 데이터 입력 데이터가 고아 반복 표시기에서 끝나지 않으면 루틴은 압축 해제 된 데이터를 리턴합니다.이 경우 &lt;a href=&quot;#binascii.Incomplete&quot;&gt; &lt;code&gt;Incomplete&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="90a0de185e04f628d3f3df798475782c0edfc543" translate="yes" xml:space="preserve">
          <source>Perform a &lt;code&gt;statvfs()&lt;/code&gt; system call on the given path. The return value is an object whose attributes describe the filesystem on the given path, and correspond to the members of the &lt;code&gt;statvfs&lt;/code&gt; structure, namely: &lt;code&gt;f_bsize&lt;/code&gt;, &lt;code&gt;f_frsize&lt;/code&gt;, &lt;code&gt;f_blocks&lt;/code&gt;, &lt;code&gt;f_bfree&lt;/code&gt;, &lt;code&gt;f_bavail&lt;/code&gt;, &lt;code&gt;f_files&lt;/code&gt;, &lt;code&gt;f_ffree&lt;/code&gt;, &lt;code&gt;f_favail&lt;/code&gt;, &lt;code&gt;f_flag&lt;/code&gt;, &lt;code&gt;f_namemax&lt;/code&gt;, &lt;code&gt;f_fsid&lt;/code&gt;.</source>
          <target state="translated">주어진 경로에서 &lt;code&gt;statvfs()&lt;/code&gt; 시스템 호출을 수행하십시오 . 리턴 값은, 그 속성의 부재로 지정된 경로에 파일 시스템 및 대응 설명하는 목적 &lt;code&gt;statvfs&lt;/code&gt; : 구조, 즉 &lt;code&gt;f_bsize&lt;/code&gt; , &lt;code&gt;f_frsize&lt;/code&gt; , &lt;code&gt;f_blocks&lt;/code&gt; , &lt;code&gt;f_bfree&lt;/code&gt; , &lt;code&gt;f_bavail&lt;/code&gt; , &lt;code&gt;f_files&lt;/code&gt; , &lt;code&gt;f_ffree&lt;/code&gt; , &lt;code&gt;f_favail&lt;/code&gt; , &lt;code&gt;f_flag&lt;/code&gt; , &lt;code&gt;f_namemax&lt;/code&gt; , &lt;code&gt;f_fsid&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="97dfa565438c05e03e5adaed406695350ebb06ae" translate="yes" xml:space="preserve">
          <source>Perform a TurtleScreen update. To be used when tracer is turned off.</source>
          <target state="translated">TurtleScreen 업데이트를 수행하십시오. 추적기가 꺼져있을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="24fd06359ec8ff4397b0b107098fc691c9b96e96" translate="yes" xml:space="preserve">
          <source>Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces &lt;code&gt;{}&lt;/code&gt;. Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument. Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument.</source>
          <target state="translated">문자열 형식화 작업을 수행하십시오. 이 메소드가 호출되는 문자열은 중괄호 &lt;code&gt;{}&lt;/code&gt; 로 구분 된 리터럴 텍스트 또는 대체 필드를 포함 할 수 있습니다 . 각 대체 필드에는 위치 인수의 숫자 색인 또는 키워드 인수의 이름이 있습니다. 각 교체 필드가 ​​해당 인수의 문자열 값으로 대체되는 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a98062a7ec8da49e613524456695bb57c3b3e79" translate="yes" xml:space="preserve">
          <source>Perform binhex4 style RLE-compression on &lt;em&gt;data&lt;/em&gt; and return the result.</source>
          <target state="translated">&lt;em&gt;데이터&lt;/em&gt; 에 대해 binhex4 스타일 RLE 압축을 수행 하고 결과를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="41580f5611bc59f8749d680e8e8ac34cb9061d02" translate="yes" xml:space="preserve">
          <source>Perform case-insensitive matching; expressions like &lt;code&gt;[A-Z]&lt;/code&gt; will also match lowercase letters. Full Unicode matching (such as &lt;code&gt;&amp;Uuml;&lt;/code&gt; matching &lt;code&gt;&amp;uuml;&lt;/code&gt;) also works unless the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;re.ASCII&lt;/code&gt;&lt;/a&gt; flag is used to disable non-ASCII matches. The current locale does not change the effect of this flag unless the &lt;a href=&quot;#re.LOCALE&quot;&gt;&lt;code&gt;re.LOCALE&lt;/code&gt;&lt;/a&gt; flag is also used. Corresponds to the inline flag &lt;code&gt;(?i)&lt;/code&gt;.</source>
          <target state="translated">대소 문자를 구분하지 않는 일치를 수행하십시오. &lt;code&gt;[A-Z]&lt;/code&gt; 와 같은 표현식 도 소문자와 일치합니다. &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;re.ASCII&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 비 ASCII 일치를 비활성화 하지 않으면 전체 유니 코드 일치 (예 : &lt;code&gt;&amp;Uuml;&lt;/code&gt; 일치 &lt;code&gt;&amp;uuml;&lt;/code&gt; )도 작동합니다 . &lt;a href=&quot;#re.LOCALE&quot;&gt; &lt;code&gt;re.LOCALE&lt;/code&gt; &lt;/a&gt; 플래그도 사용 하지 않으면 현재 로케일은이 플래그의 효과를 변경하지 않습니다 . 인라인 플래그 &lt;code&gt;(?i)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7141f68329ade808b5b6fd81e8da76f298f39c47" translate="yes" xml:space="preserve">
          <source>Perform hexbin4 binary-to-ASCII translation and return the resulting string. The argument should already be RLE-coded, and have a length divisible by 3 (except possibly the last fragment).</source>
          <target state="translated">hexbin4 2 진에서 ASCII 로의 변환을 수행하고 결과 문자열을 리턴하십시오. 인수는 이미 RLE 코딩되어 있어야하며 길이는 3으로 나눌 수 있습니다 (마지막 조각 제외).</target>
        </trans-unit>
        <trans-unit id="3f0f2162e62c2dca45b2095b72d3889ce4cdfc84" translate="yes" xml:space="preserve">
          <source>Perform multiple patches in a single call. It takes the object to be patched (either as an object or a string to fetch the object by importing) and keyword arguments for the patches:</source>
          <target state="translated">한 번의 호출로 여러 패치를 수행하십시오. 패치 할 오브젝트 (가져 오기로 오브젝트를 페치 할 오브젝트 또는 문자열로) 및 패치에 대한 키워드 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c9a6c66a017976ffd70385b244358e43640500c2" translate="yes" xml:space="preserve">
          <source>Perform the SSL setup handshake.</source>
          <target state="translated">SSL 설정 핸드 셰이크를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b80254279aa6118dbc6274921622d6049737abc7" translate="yes" xml:space="preserve">
          <source>Perform the equivalent of an &lt;code&gt;lstat()&lt;/code&gt; system call on the given path. Similar to &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;, but does not follow symbolic links. Return a &lt;a href=&quot;#os.stat_result&quot;&gt;&lt;code&gt;stat_result&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">지정된 경로에서 &lt;code&gt;lstat()&lt;/code&gt; 시스템 호출 과 동등한 기능을 수행하십시오 . 유사 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 하지만 심볼릭 링크를 따르지 않습니다. &lt;a href=&quot;#os.stat_result&quot;&gt; &lt;code&gt;stat_result&lt;/code&gt; &lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c4e238899a46acc05e2b8ba043d7a9eaa794d1ac" translate="yes" xml:space="preserve">
          <source>Perform the lock operation &lt;em&gt;operation&lt;/em&gt; on file descriptor &lt;em&gt;fd&lt;/em&gt; (file objects providing a &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method are accepted as well). See the Unix manual &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/flock(2)&quot;&gt;flock(2)&lt;/a&gt;&lt;/em&gt; for details. (On some systems, this function is emulated using &lt;code&gt;fcntl()&lt;/code&gt;.)</source>
          <target state="translated">파일 디스크립터 &lt;em&gt;fd&lt;/em&gt; 에서 잠금 조작 &lt;em&gt;조작&lt;/em&gt; 을 수행하십시오 ( &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 메소드를 제공하는 파일 오브젝트 도 허용됨). 자세한 내용은 유닉스 수동 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/flock(2)&quot;&gt;무리 (2)&lt;/a&gt;&lt;/em&gt; 를 참조하십시오. (일부 시스템에서는이 기능이 &lt;code&gt;fcntl()&lt;/code&gt; 사용하여 에뮬레이트됩니다 .)&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfcdf8211b54c6585eddff98af9183765d8e2f90" translate="yes" xml:space="preserve">
          <source>Perform the operation &lt;em&gt;cmd&lt;/em&gt; on file descriptor &lt;em&gt;fd&lt;/em&gt; (file objects providing a &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method are accepted as well). The values used for &lt;em&gt;cmd&lt;/em&gt; are operating system dependent, and are available as constants in the &lt;a href=&quot;#module-fcntl&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt; module, using the same names as used in the relevant C header files. The argument &lt;em&gt;arg&lt;/em&gt; can either be an integer value, or a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. With an integer value, the return value of this function is the integer return value of the C &lt;code&gt;fcntl()&lt;/code&gt; call. When the argument is bytes it represents a binary structure, e.g. created by &lt;a href=&quot;struct#struct.pack&quot;&gt;&lt;code&gt;struct.pack()&lt;/code&gt;&lt;/a&gt;. The binary data is copied to a buffer whose address is passed to the C &lt;code&gt;fcntl()&lt;/code&gt; call. The return value after a successful call is the contents of the buffer, converted to a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. The length of the returned object will be the same as the length of the &lt;em&gt;arg&lt;/em&gt; argument. This is limited to 1024 bytes. If the information returned in the buffer by the operating system is larger than 1024 bytes, this is most likely to result in a segmentation violation or a more subtle data corruption.</source>
          <target state="translated">파일 디스크립터 &lt;em&gt;fd&lt;/em&gt; 에서 &lt;em&gt;cmd&lt;/em&gt; 조작을 수행하십시오 ( &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 메소드를 제공하는 파일 오브젝트 도 허용됨). &lt;em&gt;cmd에&lt;/em&gt; 사용되는 값 은 운영 체제에 따라 다르며 관련 C 헤더 파일에 사용 된 것과 동일한 이름을 사용하여 &lt;a href=&quot;#module-fcntl&quot;&gt; &lt;code&gt;fcntl&lt;/code&gt; &lt;/a&gt; 모듈 에서 상수로 사용할 수 있습니다. 인수 &lt;em&gt;arg&lt;/em&gt; 는 정수 값이거나 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다. 정수 값의 경우이 함수의 반환 값은 C &lt;code&gt;fcntl()&lt;/code&gt; 호출 의 정수 반환 값입니다 . 인수가 바이트 인 경우 이진 구조를 나타냅니다 &lt;a href=&quot;struct#struct.pack&quot;&gt; &lt;code&gt;struct.pack()&lt;/code&gt; &lt;/a&gt; 예 : struct.pack ()&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;. 이진 데이터는 주소가 C &lt;code&gt;fcntl()&lt;/code&gt; 호출로 전달되는 버퍼에 복사됩니다 . 성공적인 호출 후의 리턴 값은 버퍼의 컨텐츠이며 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 오브젝트 로 변환됩니다 . 반환 된 객체의 길이는 &lt;em&gt;arg&lt;/em&gt; 인수 의 길이와 같습니다 . 이것은 1024 바이트로 제한됩니다. 운영 체제가 버퍼에 리턴 한 정보가 1024 바이트보다 크면 분할 위반 또는보다 미묘한 데이터 손상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4283e2dce7960c4de4bf96707e7142a28f6a01fc" translate="yes" xml:space="preserve">
          <source>Perform the same operation as &lt;a href=&quot;#re.sub&quot;&gt;&lt;code&gt;sub()&lt;/code&gt;&lt;/a&gt;, but return a tuple &lt;code&gt;(new_string,
number_of_subs_made)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#re.sub&quot;&gt; &lt;code&gt;sub()&lt;/code&gt; &lt;/a&gt; 와 동일한 작업을 수행 하지만 튜플 &lt;code&gt;(new_string, number_of_subs_made)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="2446d19393c74ec728f3a7d446f5c53c7a11237e" translate="yes" xml:space="preserve">
          <source>Performing these calculations with at least one extra sign extension bit in a finite two&amp;rsquo;s complement representation (a working bit-width of &lt;code&gt;1 + max(x.bit_length(), y.bit_length())&lt;/code&gt; or more) is sufficient to get the same result as if there were an infinite number of sign bits.</source>
          <target state="translated">유한 2의 보수 표현 ( &lt;code&gt;1 + max(x.bit_length(), y.bit_length())&lt;/code&gt; 이상의 작동 비트 너비)에서 하나 이상의 추가 부호 확장 비트를 사용하여 이러한 계산을 수행 하면 동일한 결과를 얻을 수 있습니다. 무한한 수의 부호 비트가있는 것처럼.</target>
        </trans-unit>
        <trans-unit id="640ef075e3b653fe4832abcbc49e2b91ac8bdeae" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;os.close(fd)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.close(fd)&lt;/code&gt; 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="752e3fe0e837a39bb8a813d706f8b3821bc1a177" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;os.dup2(fd, new_fd)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.dup2(fd, new_fd)&lt;/code&gt; 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="7fb5c5f5cf17f84ca944b4fa1f5dd157aa23e9c8" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;os.dup2(os.open(path, flags, mode), fd)&lt;/code&gt;.</source>
          <target state="translated">수행합니다 &lt;code&gt;os.dup2(os.open(path, flags, mode), fd)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ebc44eecc02e0e3eabcbf63d742a9d04931ce6c" translate="yes" xml:space="preserve">
          <source>Performs a Boolean operation. The operation name can be found in &lt;code&gt;cmp_op[opname]&lt;/code&gt;.</source>
          <target state="translated">부울 연산을 수행합니다. 작업 이름은 &lt;code&gt;cmp_op[opname]&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89f680388cf82b0508f15de49df30d63281b29a9" translate="yes" xml:space="preserve">
          <source>Performs the SSL shutdown handshake, which removes the TLS layer from the underlying socket, and returns the underlying socket object. This can be used to go from encrypted operation over a connection to unencrypted. The returned socket should always be used for further communication with the other side of the connection, rather than the original socket.</source>
          <target state="translated">SSL 종료 핸드 셰이크를 수행하여 기본 소켓에서 TLS 계층을 제거하고 기본 소켓 객체를 반환합니다. 연결을 통한 암호화 된 작업에서 암호화되지 않은 상태로 전환하는 데 사용할 수 있습니다. 반환 된 소켓은 항상 원래 소켓이 아니라 연결의 다른 쪽과 추가 통신을 위해 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d60454ef21734ebe87a8161d440e5d61b544e188" translate="yes" xml:space="preserve">
          <source>Performs the following translations in decoding by default:</source>
          <target state="translated">기본적으로 디코딩시 다음과 같은 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="aabfe29ace57f01ba61c63da5353a7eae4366011" translate="yes" xml:space="preserve">
          <source>Performs the same function as &lt;a href=&quot;#email.utils.parsedate&quot;&gt;&lt;code&gt;parsedate()&lt;/code&gt;&lt;/a&gt;, but returns either &lt;code&gt;None&lt;/code&gt; or a 10-tuple; the first 9 elements make up a tuple that can be passed directly to &lt;a href=&quot;time#time.mktime&quot;&gt;&lt;code&gt;time.mktime()&lt;/code&gt;&lt;/a&gt;, and the tenth is the offset of the date&amp;rsquo;s timezone from UTC (which is the official term for Greenwich Mean Time) &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. If the input string has no timezone, the last element of the tuple returned is &lt;code&gt;0&lt;/code&gt;, which represents UTC. Note that indexes 6, 7, and 8 of the result tuple are not usable.</source>
          <target state="translated">&lt;a href=&quot;#email.utils.parsedate&quot;&gt; &lt;code&gt;parsedate()&lt;/code&gt; &lt;/a&gt; 와 동일한 기능을 수행 하지만 &lt;code&gt;None&lt;/code&gt; 또는 10- 튜플을 반환합니다 . 처음 9 개의 요소는 &lt;a href=&quot;time#time.mktime&quot;&gt; &lt;code&gt;time.mktime()&lt;/code&gt; &lt;/a&gt; 직접 전달 될 수있는 튜플을 구성하며 10 번째는 UTC (그리니치 표준시의 공식 용어) &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 에서 날짜 시간대의 오프셋입니다 . 입력 문자열에 시간대가없는 경우 반환 된 튜플의 마지막 요소는 &lt;code&gt;0&lt;/code&gt; 이며 UTC를 나타냅니다. 결과 튜플의 인덱스 6, 7, 8은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="89ddfd2579b261a0b50909628ce2423da1fab7c8" translate="yes" xml:space="preserve">
          <source>Performs the template substitution, returning a new string. &lt;em&gt;mapping&lt;/em&gt; is any dictionary-like object with keys that match the placeholders in the template. Alternatively, you can provide keyword arguments, where the keywords are the placeholders. When both &lt;em&gt;mapping&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt; are given and there are duplicates, the placeholders from &lt;em&gt;kwds&lt;/em&gt; take precedence.</source>
          <target state="translated">템플릿 대체를 수행하여 새 문자열을 반환합니다. &lt;em&gt;매핑&lt;/em&gt; 은 템플릿의 자리 표시 자와 일치하는 키가있는 사전과 유사한 객체입니다. 또는 키워드가 자리 표시자인 키워드 인수를 제공 할 수 있습니다. 두 경우 &lt;em&gt;매핑&lt;/em&gt; 및 &lt;em&gt;kwds이&lt;/em&gt; 주어지고 중복이 존재하는,에서 자리 &lt;em&gt;kwds이&lt;/em&gt; 우선합니다.</target>
        </trans-unit>
        <trans-unit id="bd9e556fabad08ed102376a515af641b54a566ff" translate="yes" xml:space="preserve">
          <source>Permanent Redirect &lt;a href=&quot;https://tools.ietf.org/html/rfc7238.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 7238&lt;/strong&gt;&lt;/a&gt;, Section 3 (Experimental)</source>
          <target state="translated">영구 리디렉션 &lt;a href=&quot;https://tools.ietf.org/html/rfc7238.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 7238&lt;/strong&gt;&lt;/a&gt; , 섹션 3 (실험적)</target>
        </trans-unit>
        <trans-unit id="57b018dc8100faa36ae221817b9a0becde766f73" translate="yes" xml:space="preserve">
          <source>Permanently remove deleted items from selected mailbox. Generates an &lt;code&gt;EXPUNGE&lt;/code&gt; response for each deleted message. Returned data contains a list of &lt;code&gt;EXPUNGE&lt;/code&gt; message numbers in order received.</source>
          <target state="translated">선택한 메일 함에서 삭제 된 항목을 영구적으로 제거하십시오. 삭제 된 각 메시지에 대해 &lt;code&gt;EXPUNGE&lt;/code&gt; 응답을 생성합니다 . 리턴 된 데이터는 수신 된 &lt;code&gt;EXPUNGE&lt;/code&gt; 메시지 번호 목록을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="922a2aae018739de2e7f95b2906f6a7bda5805d9" translate="yes" xml:space="preserve">
          <source>Permission bits.</source>
          <target state="translated">권한 비트.</target>
        </trans-unit>
        <trans-unit id="d016004473e0e58d7682856755147e33256bb813" translate="yes" xml:space="preserve">
          <source>Permission denied</source>
          <target state="translated">권한이 거부되었습니다</target>
        </trans-unit>
        <trans-unit id="9240c3d4a70b95b9e2dc2b61c69fc6e9243c67cc" translate="yes" xml:space="preserve">
          <source>PermissionError</source>
          <target state="translated">PermissionError</target>
        </trans-unit>
        <trans-unit id="0bf008ca5d81230e81034b7868f292b6c45a642d" translate="yes" xml:space="preserve">
          <source>Permissions and times of directories are copied with &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt;, individual files are copied using &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">디렉토리의 권한과 시간은 &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 로 복사되고 개별 파일은 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 사용하여 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="e504e73bf0a3461a62cbd35fe470dfc8bf2c5dcf" translate="yes" xml:space="preserve">
          <source>Permitscontrol() to returns the event</source>
          <target state="translated">이벤트를 반환하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c5b5b88cbddaa8e1656fda5a833d01be846fc40f" translate="yes" xml:space="preserve">
          <source>Permutations are emitted in lexicographic sort order. So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the permutation tuples will be produced in sorted order.</source>
          <target state="translated">순열은 사전 식 정렬 순서로 방출됩니다. 따라서 입력 &lt;em&gt;반복 가능 항목&lt;/em&gt; 이 정렬되면 순열 튜플이 정렬 된 순서로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0117d320fce0d888119832805e38e4a506f88c57" translate="yes" xml:space="preserve">
          <source>Persistence module which stores non-string data.</source>
          <target state="translated">문자열이 아닌 데이터를 저장하는 지속성 모듈.</target>
        </trans-unit>
        <trans-unit id="d71bbb391ec68a612e1e020d3a59cdde37f5adcf" translate="yes" xml:space="preserve">
          <source>Persistence of External Objects</source>
          <target state="translated">외부 객체의 지속성</target>
        </trans-unit>
        <trans-unit id="f203458ed70f830ecf62ab5ec4fd43db183fc0d2" translate="yes" xml:space="preserve">
          <source>Personalization</source>
          <target state="translated">Personalization</target>
        </trans-unit>
        <trans-unit id="98fd5b480af814b89b456d84e3868a121619c9aa" translate="yes" xml:space="preserve">
          <source>Personalization string length (maximum length accepted by constructors).</source>
          <target state="translated">개인화 문자열 길이 (생성자가 허용하는 최대 길이).</target>
        </trans-unit>
        <trans-unit id="bb60655fa1c14e25e42619b562af366048efc9d5" translate="yes" xml:space="preserve">
          <source>Personalization together with the keyed mode can also be used to derive different keys from a single one.</source>
          <target state="translated">키 모드와 함께 개인 설정을 사용하여 단일 키에서 다른 키를 파생시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b2fd265bce2ea4249697652f9737fe616a79da" translate="yes" xml:space="preserve">
          <source>Peter Funk</source>
          <target state="translated">피터 펑크</target>
        </trans-unit>
        <trans-unit id="503cfd892a68c3d0070d442675777ad188230916" translate="yes" xml:space="preserve">
          <source>Picklability</source>
          <target state="translated">Picklability</target>
        </trans-unit>
        <trans-unit id="b9ac15b70935eb9e679e679f6c189fa09ae67d5d" translate="yes" xml:space="preserve">
          <source>Pickle interface constructor registration for extension types.</source>
          <target state="translated">확장 유형에 대한 피클 인터페이스 생성자 등록</target>
        </trans-unit>
        <trans-unit id="da804ce72ffb2456e57ba07cb24c19e51d793b78" translate="yes" xml:space="preserve">
          <source>Pickles the record&amp;rsquo;s attribute dictionary and writes it to the socket in binary format. If there is an error with the socket, silently drops the packet. If the connection was previously lost, re-establishes the connection. To unpickle the record at the receiving end into a &lt;a href=&quot;logging#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt;, use the &lt;a href=&quot;logging#logging.makeLogRecord&quot;&gt;&lt;code&gt;makeLogRecord()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">레코드의 속성 사전을 피클하고 2 진 형식으로 소켓에 씁니다. 소켓에 오류가 있으면 자동으로 패킷을 삭제합니다. 연결이 이전에 손실 된 경우 연결을 다시 설정하십시오. 수신 측의 레코드를 &lt;a href=&quot;logging#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 로 피클 링하려면 &lt;a href=&quot;logging#logging.makeLogRecord&quot;&gt; &lt;code&gt;makeLogRecord()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c56053b7d0e78c6fbae95ab53af9ceef0a3c06a" translate="yes" xml:space="preserve">
          <source>Pickles the record&amp;rsquo;s attribute dictionary and writes it to the socket in binary format. If there is an error with the socket, silently drops the packet. To unpickle the record at the receiving end into a &lt;a href=&quot;logging#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt;, use the &lt;a href=&quot;logging#logging.makeLogRecord&quot;&gt;&lt;code&gt;makeLogRecord()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">레코드의 속성 사전을 피클하고 2 진 형식으로 소켓에 씁니다. 소켓에 오류가 있으면 자동으로 패킷을 삭제합니다. 수신 측의 레코드를 &lt;a href=&quot;logging#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 로 피클 링하려면 &lt;a href=&quot;logging#logging.makeLogRecord&quot;&gt; &lt;code&gt;makeLogRecord()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c94932969478efe7a329a1a295b5659be6c229f7" translate="yes" xml:space="preserve">
          <source>Pickles the record&amp;rsquo;s attribute dictionary in binary format with a length prefix, and returns it ready for transmission across the socket. The details of this operation are equivalent to:</source>
          <target state="translated">레코드의 속성 사전을 길이 접두사가있는 2 진 형식으로 피클하고 소켓을 통해 전송할 준비가 된 것으로 리턴합니다. 이 작업의 세부 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e451c6df0e9534b87f8f317ad70746e8d408ad1" translate="yes" xml:space="preserve">
          <source>Pickling</source>
          <target state="translated">Pickling</target>
        </trans-unit>
        <trans-unit id="479f26b691b28108bc27a86443e601e66de60606" translate="yes" xml:space="preserve">
          <source>Pickling Class Instances</source>
          <target state="translated">산세 클래스 인스턴스</target>
        </trans-unit>
        <trans-unit id="77e2601ad4aef60f1ee4bac62cdc2791e4c29d92" translate="yes" xml:space="preserve">
          <source>Pickling enums created with the functional API can be tricky as frame stack implementation details are used to try and figure out which module the enumeration is being created in (e.g. it will fail if you use a utility function in separate module, and also may not work on IronPython or Jython). The solution is to specify the module name explicitly as follows:</source>
          <target state="translated">프레임 스택 구현 세부 사항을 사용하여 열거에서 작성중인 모듈을 파악하는 데 기능 API로 작성된 피클 링 열거가 까다로울 수 있습니다 (예 : 별도의 모듈에서 유틸리티 함수를 사용하면 작동하지 않으며 작동하지 않을 수 있음) IronPython 또는 Jython에서). 해결책은 다음과 같이 모듈 이름을 명시 적으로 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="102aedc4c02618208304c84353a4e744e7173c74" translate="yes" xml:space="preserve">
          <source>Pickling: &lt;code&gt;__reduce__&lt;/code&gt;, &lt;code&gt;__reduce_ex__&lt;/code&gt;, &lt;code&gt;__getinitargs__&lt;/code&gt;, &lt;code&gt;__getnewargs__&lt;/code&gt;, &lt;code&gt;__getstate__&lt;/code&gt; and &lt;code&gt;__setstate__&lt;/code&gt;</source>
          <target state="translated">산세 : &lt;code&gt;__reduce__&lt;/code&gt; , &lt;code&gt;__reduce_ex__&lt;/code&gt; , &lt;code&gt;__getinitargs__&lt;/code&gt; , &lt;code&gt;__getnewargs__&lt;/code&gt; , &lt;code&gt;__getstate__&lt;/code&gt; 및 &lt;code&gt;__setstate__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35ca931fcc670468a1619dccb933e3c60b540bff" translate="yes" xml:space="preserve">
          <source>Pipes and Queues</source>
          <target state="translated">파이프와 큐</target>
        </trans-unit>
        <trans-unit id="e64d6f8a78d48c8a48daa8e413ed0a9ee19f4ecd" translate="yes" xml:space="preserve">
          <source>Pipes are not supported, so the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt;&lt;code&gt;loop.connect_read_pipe()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;loop.connect_write_pipe()&lt;/code&gt;&lt;/a&gt; methods are not implemented.</source>
          <target state="translated">파이프는 지원되지 않으므로 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt; &lt;code&gt;loop.connect_read_pipe()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;loop.connect_write_pipe()&lt;/code&gt; &lt;/a&gt; 메소드는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e56e96590262671b12c88a46c7794d2d395c71cd" translate="yes" xml:space="preserve">
          <source>Piping output of your program to tools like &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/head(1)&quot;&gt;head(1)&lt;/a&gt;&lt;/em&gt; will cause a &lt;code&gt;SIGPIPE&lt;/code&gt; signal to be sent to your process when the receiver of its standard output closes early. This results in an exception like &lt;code&gt;BrokenPipeError: [Errno 32] Broken pipe&lt;/code&gt;. To handle this case, wrap your entry point to catch this exception as follows:</source>
          <target state="translated">프로그램의 출력을 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/head(1)&quot;&gt;head (1)&lt;/a&gt;&lt;/em&gt; 과 같은 도구로 파이프 하면 표준 출력의 수신기가 일찍 닫히면 &lt;code&gt;SIGPIPE&lt;/code&gt; 신호가 프로세스로 전송됩니다. 이로 인해 &lt;code&gt;BrokenPipeError: [Errno 32] Broken pipe&lt;/code&gt; 와 같은 예외가 발생 합니다. 이 경우를 처리하려면 다음과 같이 진입 점을 감싸서이 예외를 포착하십시오.</target>
        </trans-unit>
        <trans-unit id="e7abd9437945479aed23328dd738203dfb013266" translate="yes" xml:space="preserve">
          <source>Planet</source>
          <target state="translated">Planet</target>
        </trans-unit>
        <trans-unit id="123a7f2fcc9ae7cbbbd7c7627a483853a9708dab" translate="yes" xml:space="preserve">
          <source>Platform</source>
          <target state="translated">Platform</target>
        </trans-unit>
        <trans-unit id="38b10a3fef9531f82571079e6c0973fde8c3c114" translate="yes" xml:space="preserve">
          <source>Platform Support</source>
          <target state="translated">플랫폼 지원</target>
        </trans-unit>
        <trans-unit id="ff905013a44bbeb970c42652913293a3fa1300b9" translate="yes" xml:space="preserve">
          <source>Platform dependent, but if non-zero, uniquely identifies the file for a given value of &lt;code&gt;st_dev&lt;/code&gt;. Typically:</source>
          <target state="translated">플랫폼에 따라 다르지만 0이 아닌 경우 주어진 값 &lt;code&gt;st_dev&lt;/code&gt; 에 대한 파일을 고유하게 식별합니다 . 일반적으로</target>
        </trans-unit>
        <trans-unit id="7084e0741690a908772be6f36f009af9b7c5145c" translate="yes" xml:space="preserve">
          <source>Platform dependent:</source>
          <target state="translated">플랫폼에 따라 다름 :</target>
        </trans-unit>
        <trans-unit id="8ca44e603d25c586c9bf6c4ad1e35d8888ae2165" translate="yes" xml:space="preserve">
          <source>Platform specific modules</source>
          <target state="translated">플랫폼 별 모듈</target>
        </trans-unit>
        <trans-unit id="0558191147d4364c96f342a5f33275e60632ba76" translate="yes" xml:space="preserve">
          <source>Platform-dependent efficient copy operations</source>
          <target state="translated">플랫폼에 따른 효율적인 복사 작업</target>
        </trans-unit>
        <trans-unit id="89f3176950b094ee092b083d87a3ea394294bab2" translate="yes" xml:space="preserve">
          <source>Platform-specific notes</source>
          <target state="translated">플랫폼 별 노트</target>
        </trans-unit>
        <trans-unit id="9fe47e8a69eece1d617e5e0b2949d5eb25ff3b3a" translate="yes" xml:space="preserve">
          <source>Play the &lt;code&gt;SystemDefault&lt;/code&gt; sound.</source>
          <target state="translated">&lt;code&gt;SystemDefault&lt;/code&gt; 사운드를 재생하십시오 .</target>
        </trans-unit>
        <trans-unit id="566e59746b2e159c689466c2026b06a04a488084" translate="yes" xml:space="preserve">
          <source>Play the &lt;code&gt;SystemExclamation&lt;/code&gt; sound.</source>
          <target state="translated">시스템 &lt;code&gt;SystemExclamation&lt;/code&gt; 사운드를 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="1367087c57e69f911b20e62488a2818796ce3f56" translate="yes" xml:space="preserve">
          <source>Play the &lt;code&gt;SystemHand&lt;/code&gt; sound.</source>
          <target state="translated">&lt;code&gt;SystemHand&lt;/code&gt; 사운드를 재생하십시오 .</target>
        </trans-unit>
        <trans-unit id="286413e479c251f2c8b7505d0c7e872201bd0efe" translate="yes" xml:space="preserve">
          <source>Play the &lt;code&gt;SystemQuestion&lt;/code&gt; sound.</source>
          <target state="translated">&lt;code&gt;SystemQuestion&lt;/code&gt; 사운드를 재생하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5a38385bd1801f94f6afcc5224a41a5634b9ea5" translate="yes" xml:space="preserve">
          <source>Play the sound repeatedly. The &lt;a href=&quot;#winsound.SND_ASYNC&quot;&gt;&lt;code&gt;SND_ASYNC&lt;/code&gt;&lt;/a&gt; flag must also be used to avoid blocking. Cannot be used with &lt;a href=&quot;#winsound.SND_MEMORY&quot;&gt;&lt;code&gt;SND_MEMORY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소리를 반복해서 재생하십시오. &lt;a href=&quot;#winsound.SND_ASYNC&quot;&gt; &lt;code&gt;SND_ASYNC&lt;/code&gt; 의&lt;/a&gt; 플래그도 막지 않도록하는 데 사용되어야합니다. &lt;a href=&quot;#winsound.SND_MEMORY&quot;&gt; &lt;code&gt;SND_MEMORY&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e5c41e818401745189aa92dc2b5b8f589f4936d2" translate="yes" xml:space="preserve">
          <source>Please consult the SQLite documentation about the possible values for the first argument and the meaning of the second and third argument depending on the first one. All necessary constants are available in the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">첫 번째 인수의 가능한 값과 첫 번째 인수에 따른 두 번째 및 세 번째 인수의 의미에 대해서는 SQLite 문서를 참조하십시오. 필요한 모든 상수는 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="965d48bb52ce2d9d91cc30b01489f2b19edc118e" translate="yes" xml:space="preserve">
          <source>Please note that a much more powerful error checking mechanism is available through the &lt;code&gt;errcheck&lt;/code&gt; attribute; see the reference manual for details.</source>
          <target state="translated">&lt;code&gt;errcheck&lt;/code&gt; 속성을 통해 훨씬 강력한 오류 검사 메커니즘을 사용할 수 있습니다 . 자세한 내용은 참조 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8fc0f93e5dd7c64f8d2e2fe1baaf4f1c7641a90" translate="yes" xml:space="preserve">
          <source>Please note that config parsers don&amp;rsquo;t support escaping of comment prefixes so using &lt;em&gt;inline_comment_prefixes&lt;/em&gt; may prevent users from specifying option values with characters used as comment prefixes. When in doubt, avoid setting &lt;em&gt;inline_comment_prefixes&lt;/em&gt;. In any circumstances, the only way of storing comment prefix characters at the beginning of a line in multiline values is to interpolate the prefix, for example:</source>
          <target state="translated">구성 파서는 주석 접두사 이스케이프를 지원하지 않으므로 &lt;em&gt;inline_comment_prefixes를&lt;/em&gt; 사용 하면 사용자가 주석 접두사로 사용되는 문자로 옵션 값을 지정하지 못할 수 있습니다. 의심 &lt;em&gt;스러운 경우 inline_comment_prefixes를&lt;/em&gt; 설정하지 마십시오 . 어떤 상황에서든 줄 시작 부분에 주석 접두사 문자를 여러 줄 값으로 저장하는 유일한 방법은 접두사를 보간하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="310bbccd36313c76e203cfc5b0ebdd8ca95d2449" translate="yes" xml:space="preserve">
          <source>Please note that default values have precedence over fallback values. For instance, in our example the &lt;code&gt;'CompressionLevel'&lt;/code&gt; key was specified only in the &lt;code&gt;'DEFAULT'&lt;/code&gt; section. If we try to get it from the section &lt;code&gt;'topsecret.server.com'&lt;/code&gt;, we will always get the default, even if we specify a fallback:</source>
          <target state="translated">기본값은 대체 값보다 우선합니다. 예를 들어,이 예에서 &lt;code&gt;'CompressionLevel'&lt;/code&gt; 키는 &lt;code&gt;'DEFAULT'&lt;/code&gt; 섹션 에서만 지정되었습니다 . &lt;code&gt;'topsecret.server.com'&lt;/code&gt; 섹션에서 가져 오려고 하면 폴백을 지정하더라도 항상 기본값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="86e0817628ee18c1a8ed5a0fc40828bffeaed3c5" translate="yes" xml:space="preserve">
          <source>Please note that direct use of bytecode files (and thus not source code files) inhibits your modules from being usable by all Python implementations or new versions of Python which change the bytecode format.</source>
          <target state="translated">바이트 코드 파일 (및 소스 코드 파일이 아님)을 직접 사용하면 모든 Python 구현 또는 바이트 코드 형식을 변경하는 새 버전의 Python에서 모듈을 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa6d4d5a47f1ee1b1fd351d19df2d53810a47a9" translate="yes" xml:space="preserve">
          <source>Please note that this function works like &lt;a href=&quot;#locale.format_string&quot;&gt;&lt;code&gt;format_string()&lt;/code&gt;&lt;/a&gt; but will only work for exactly one &lt;code&gt;%char&lt;/code&gt; specifier. For example, &lt;code&gt;'%f'&lt;/code&gt; and &lt;code&gt;'%.0f'&lt;/code&gt; are both valid specifiers, but &lt;code&gt;'%f KiB'&lt;/code&gt; is not.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#locale.format_string&quot;&gt; &lt;code&gt;format_string()&lt;/code&gt; &lt;/a&gt; 처럼 작동 하지만 정확히 하나의 &lt;code&gt;%char&lt;/code&gt; 지정자 에서만 작동 합니다. 예를 들어 &lt;code&gt;'%f'&lt;/code&gt; 와 &lt;code&gt;'%.0f'&lt;/code&gt; 는 모두 유효한 지정자이지만 &lt;code&gt;'%f KiB'&lt;/code&gt; 는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="373685c0595172990b3ace0f5f8fe1c0ca75870e" translate="yes" xml:space="preserve">
          <source>Please note: there are ways to add a set of key-value pairs in a single operation. When you use a regular dictionary in those operations, the order of the keys will be ordered. For example:</source>
          <target state="translated">참고 : 단일 작업에서 일련의 키-값 쌍을 추가하는 방법이 있습니다. 이러한 작업에서 일반 사전을 사용하면 키 순서가 정렬됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ea35b5666ef240cb6a4493c17fe5ba6382d03f6" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;ssl#ssl-security&quot;&gt;Security considerations&lt;/a&gt; for more information on best practices.</source>
          <target state="translated">읽어 보시기 바랍니다 &lt;a href=&quot;ssl#ssl-security&quot;&gt;보안 고려 사항을&lt;/a&gt; 모범 사례에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="47bc58981366eed814a57a39e644b2e08a3b6870" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;os#os.supports_follow_symlinks&quot;&gt;&lt;code&gt;os.supports_follow_symlinks&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;os#os.supports_follow_symlinks&quot;&gt; &lt;code&gt;os.supports_follow_symlinks&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ae02dfe03795c3955ac3c8f1cf68ffc72a268cb" translate="yes" xml:space="preserve">
          <source>Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is &lt;em&gt;not&lt;/em&gt; an identity operation.</source>
          <target state="translated">Plus는 Python의 단항 접두사 더하기 연산자에 해당합니다. 이 작업은 컨텍스트 정밀도와 반올림을 적용하므로 ID 작업 이 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0330491d58c610056c9cfabfdbebacfad2431d29" translate="yes" xml:space="preserve">
          <source>Pointer instances are created by calling the &lt;a href=&quot;#ctypes.pointer&quot;&gt;&lt;code&gt;pointer()&lt;/code&gt;&lt;/a&gt; function on a &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; type:</source>
          <target state="translated">&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 유형 에서 &lt;a href=&quot;#ctypes.pointer&quot;&gt; &lt;code&gt;pointer()&lt;/code&gt; &lt;/a&gt; 함수를 호출하여 포인터 인스턴스가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f705c08361997cb6f7df09dbc0c27afef4b025f1" translate="yes" xml:space="preserve">
          <source>Pointer instances can also be indexed with integers:</source>
          <target state="translated">포인터 인스턴스는 정수로 색인 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="482aa3fcf0e95b3b47d95bdfe561af13938b8ff1" translate="yes" xml:space="preserve">
          <source>Pointer instances have a &lt;a href=&quot;#ctypes._Pointer.contents&quot;&gt;&lt;code&gt;contents&lt;/code&gt;&lt;/a&gt; attribute which returns the object to which the pointer points, the &lt;code&gt;i&lt;/code&gt; object above:</source>
          <target state="translated">포인터 인스턴스에는 포인터가 가리키는 객체, 위 의 &lt;code&gt;i&lt;/code&gt; 객체 를 반환 하는 &lt;a href=&quot;#ctypes._Pointer.contents&quot;&gt; &lt;code&gt;contents&lt;/code&gt; &lt;/a&gt; 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5b722fc5ad9faac57dfe90f51b7e6e51ad5a968" translate="yes" xml:space="preserve">
          <source>Pointers</source>
          <target state="translated">Pointers</target>
        </trans-unit>
        <trans-unit id="8d61184962dda249c7c096096c40ff46b825f4a7" translate="yes" xml:space="preserve">
          <source>Policies</source>
          <target state="translated">Policies</target>
        </trans-unit>
        <trans-unit id="f13ca4e051430c60cd600a3b936cd44760445204" translate="yes" xml:space="preserve">
          <source>Policies is a low-level mechanism to alter the behavior of functions like &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt;&lt;code&gt;asyncio.get_event_loop()&lt;/code&gt;&lt;/a&gt;. See also the main &lt;a href=&quot;asyncio-policy#asyncio-policies&quot;&gt;policies section&lt;/a&gt; for more details.</source>
          <target state="translated">정책은 &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt; &lt;code&gt;asyncio.get_event_loop()&lt;/code&gt; &lt;/a&gt; 와 같은 함수의 동작을 변경하는 저수준 메커니즘 입니다. 자세한 내용은 기본 &lt;a href=&quot;asyncio-policy#asyncio-policies&quot;&gt;정책 섹션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6e19b461365ea4d2f9baa4f1541cdbc31638a3c" translate="yes" xml:space="preserve">
          <source>Policy Objects</source>
          <target state="translated">정책 객체</target>
        </trans-unit>
        <trans-unit id="b9d50f1346b401ffaac22261d9a0445a59b9c3ef" translate="yes" xml:space="preserve">
          <source>Policy objects can also be combined using the addition operator, producing a policy object whose settings are a combination of the non-default values of the summed objects:</source>
          <target state="translated">더하기 연산자를 사용하여 정책 개체를 결합하여 설정이 합산 개체의 기본값이 아닌 값의 조합 인 정책 개체를 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="10db6aaa1dae6d5ca93baae8300239ae0d491fd7" translate="yes" xml:space="preserve">
          <source>Policy objects give the email package the flexibility to handle all these disparate use cases.</source>
          <target state="translated">정책 개체는 전자 메일 패키지에 이러한 개별 사용 사례를 모두 처리 할 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc59ba147a78b1cba0063b32337a5117142efb00" translate="yes" xml:space="preserve">
          <source>Policy objects should implement the APIs defined in the &lt;a href=&quot;#asyncio.AbstractEventLoopPolicy&quot;&gt;&lt;code&gt;AbstractEventLoopPolicy&lt;/code&gt;&lt;/a&gt; abstract base class.</source>
          <target state="translated">정책 객체는 &lt;a href=&quot;#asyncio.AbstractEventLoopPolicy&quot;&gt; &lt;code&gt;AbstractEventLoopPolicy&lt;/code&gt; &lt;/a&gt; 추상 기본 클래스에 정의 된 API를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1809b1c47a1a0f8ffda4a1194b61478553d974fe" translate="yes" xml:space="preserve">
          <source>Polling Objects</source>
          <target state="translated">폴링 객체</target>
        </trans-unit>
        <trans-unit id="5d4332b021cb2ecbffef0b518c251198f0483519" translate="yes" xml:space="preserve">
          <source>Polls the set of registered file descriptors, and returns a possibly-empty list containing &lt;code&gt;(fd, event)&lt;/code&gt; 2-tuples for the descriptors that have events or errors to report. &lt;em&gt;fd&lt;/em&gt; is the file descriptor, and &lt;em&gt;event&lt;/em&gt; is a bitmask with bits set for the reported events for that descriptor &amp;mdash; &lt;code&gt;POLLIN&lt;/code&gt; for waiting input, &lt;code&gt;POLLOUT&lt;/code&gt; to indicate that the descriptor can be written to, and so forth. An empty list indicates that the call timed out and no file descriptors had any events to report. If &lt;em&gt;timeout&lt;/em&gt; is given, it specifies the length of time in milliseconds which the system will wait for events before returning. If &lt;em&gt;timeout&lt;/em&gt; is omitted, -1, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the call will block until there is an event for this poll object.</source>
          <target state="translated">등록 된 파일 디스크립터 세트를 &lt;code&gt;(fd, event)&lt;/code&gt; 하고보고 할 이벤트 또는 오류가있는 디스크립터에 대해 (fd, event) 2 개의 튜플이 포함 된 비어있는 목록을 리턴합니다 . &lt;em&gt;FD는&lt;/em&gt; 파일 기술자이며, &lt;em&gt;이벤트가&lt;/em&gt; 보고 된 그 기술자에 대한 이벤트 설정 비트 비트 마스크입니다 - &lt;code&gt;POLLIN&lt;/code&gt; 입력을 대기 위해, &lt;code&gt;POLLOUT&lt;/code&gt; 는 기술자가 등등에 기록 될 수 있음을 나타냅니다. 빈 목록은 호출 시간이 초과되었으며 파일 설명자에보고 할 이벤트가 없음을 나타냅니다. 경우 &lt;em&gt;제한 시간이&lt;/em&gt; 주어집니다, 시스템이 돌아 오기 전에 이벤트에 대한 대기 시간 (밀리 초)을 지정합니다. 경우 &lt;em&gt;타임 아웃이&lt;/em&gt; 생략되어, -1, 또는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;이 폴링 오브젝트에 대한 이벤트가있을 때까지 호출이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="8235db5fc164907dd37c9f8fe6afa7077606c5a7" translate="yes" xml:space="preserve">
          <source>Polls the set of registered file descriptors, and returns a possibly-empty list containing &lt;code&gt;(fd, event)&lt;/code&gt; 2-tuples for the descriptors that have events or errors to report. &lt;em&gt;fd&lt;/em&gt; is the file descriptor, and &lt;em&gt;event&lt;/em&gt; is a bitmask with bits set for the reported events for that descriptor &amp;mdash; &lt;code&gt;POLLIN&lt;/code&gt; for waiting input, &lt;code&gt;POLLOUT&lt;/code&gt; to indicate that the descriptor can be written to, and so forth. An empty list indicates that the call timed out and no file descriptors had any events to report. If &lt;em&gt;timeout&lt;/em&gt; is given, it specifies the length of time in milliseconds which the system will wait for events before returning. If &lt;em&gt;timeout&lt;/em&gt; is omitted, negative, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the call will block until there is an event for this poll object.</source>
          <target state="translated">등록 된 파일 디스크립터 세트를 &lt;code&gt;(fd, event)&lt;/code&gt; 하고보고 할 이벤트 또는 오류가있는 디스크립터에 대해 (fd, event) 2 개의 튜플이 포함 된 비어있는 목록을 리턴합니다 . &lt;em&gt;FD는&lt;/em&gt; 파일 기술자이며, &lt;em&gt;이벤트가&lt;/em&gt; 보고 된 그 기술자에 대한 이벤트 설정 비트 비트 마스크입니다 - &lt;code&gt;POLLIN&lt;/code&gt; 입력을 대기 위해, &lt;code&gt;POLLOUT&lt;/code&gt; 는 기술자가 등등에 기록 될 수 있음을 나타냅니다. 빈 목록은 호출 시간이 초과되었으며 파일 설명자에보고 할 이벤트가 없음을 나타냅니다. 경우 &lt;em&gt;제한 시간이&lt;/em&gt; 주어집니다, 시스템이 돌아 오기 전에 이벤트에 대한 대기 시간 (밀리 초)을 지정합니다. 경우 &lt;em&gt;타임 아웃이&lt;/em&gt; 생략되어, 음극 또는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;이 폴링 오브젝트에 대한 이벤트가있을 때까지 호출이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c27a9bb77fd2f98033253218b572e79bc22251dc" translate="yes" xml:space="preserve">
          <source>Pop and return the smallest item from the &lt;em&gt;heap&lt;/em&gt;, and also push the new &lt;em&gt;item&lt;/em&gt;. The heap size doesn&amp;rsquo;t change. If the heap is empty, &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;힙&lt;/em&gt; 에서 가장 작은 항목을 팝하여 반환 하고 새 &lt;em&gt;항목을&lt;/em&gt; 푸시합니다 . 힙 크기는 변경되지 않습니다. 힙이 비어 있으면 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9a06f0699ad3349431c67e1a47549dabc15760e" translate="yes" xml:space="preserve">
          <source>Pop and return the smallest item from the &lt;em&gt;heap&lt;/em&gt;, maintaining the heap invariant. If the heap is empty, &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; is raised. To access the smallest item without popping it, use &lt;code&gt;heap[0]&lt;/code&gt;.</source>
          <target state="translated">힙을 변하지 않고 유지하면서 &lt;em&gt;heap&lt;/em&gt; 에서 가장 작은 항목을 팝하고 반환하십시오 . 힙이 비어 있으면 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 팝하지 않고 가장 작은 항목에 액세스하려면 &lt;code&gt;heap[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee245e4e5d6d950b1854efc1afc869a99c34f7b0" translate="yes" xml:space="preserve">
          <source>Pop the last-pushed input source from the input stack. This is the same method used internally when the lexer reaches EOF on a stacked input stream.</source>
          <target state="translated">마지막으로 푸시 된 입력 소스를 입력 스택에서 팝합니다. 이는 렉서가 스택 된 입력 스트림에서 EOF에 도달 할 때 내부적으로 사용되는 것과 동일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="055df3f558473d7ece8b7d50e1df0ab063d8b702" translate="yes" xml:space="preserve">
          <source>Pop up a dialog window for input of a number. title is the title of the dialog window, prompt is a text mostly describing what numerical information to input. default: default value, minval: minimum value for input, maxval: maximum value for input The number input must be in the range minval .. maxval if these are given. If not, a hint is issued and the dialog remains open for correction. Return the number input. If the dialog is canceled, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">숫자를 입력 할 수있는 대화 상자가 나타납니다. title은 대화 창의 제목이고 prompt는 입력 할 숫자 정보를 설명하는 텍스트입니다. 기본값 : 기본값, 최소값 : 입력의 최소값, 최대 값 : 입력의 최대 값 입력되는 경우 숫자 입력은 minval .. maxval 범위에 있어야합니다. 그렇지 않은 경우 힌트가 발행되고 수정을 위해 대화 상자가 열려 있습니다. 숫자 입력을 반환합니다. 대화 상자가 취소되면 &lt;code&gt;None&lt;/code&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a30e7e9c16d1d2289a14843ccfa17e59bc5f258" translate="yes" xml:space="preserve">
          <source>Pop up a dialog window for input of a string. Parameter title is the title of the dialog window, prompt is a text mostly describing what information to input. Return the string input. If the dialog is canceled, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문자열 입력을위한 대화창을 띄웁니다. 매개 변수 제목은 대화 창의 제목이며 프롬프트는 대부분 어떤 정보를 입력해야하는지 설명하는 텍스트입니다. 문자열 입력을 반환합니다. 대화 상자가 취소되면 &lt;code&gt;None&lt;/code&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="aceabe368eed8bf1ef8907fda06132011ac87f29" translate="yes" xml:space="preserve">
          <source>Popen Constructor</source>
          <target state="translated">Popen 생성자</target>
        </trans-unit>
        <trans-unit id="c58508b5bfbc193df948f2c96619660505caf807" translate="yes" xml:space="preserve">
          <source>Popen Objects</source>
          <target state="translated">교황 개체</target>
        </trans-unit>
        <trans-unit id="a46cb4ea3a3611a4d180ffb9a39ca4d82b2ad2d0" translate="yes" xml:space="preserve">
          <source>Popen and the other functions in this module that use it raise an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt; with arguments &lt;code&gt;executable&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt;, &lt;code&gt;cwd&lt;/code&gt;, and &lt;code&gt;env&lt;/code&gt;. The value for &lt;code&gt;args&lt;/code&gt; may be a single string or a list of strings, depending on platform.</source>
          <target state="translated">Popen 및이 모듈에서이를 사용하는 다른 함수는 &lt;a href=&quot;sys#auditing&quot;&gt;auditing 이벤트 &lt;/a&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; 을 인수 &lt;code&gt;executable&lt;/code&gt; , &lt;code&gt;args&lt;/code&gt; , &lt;code&gt;cwd&lt;/code&gt; 및 &lt;code&gt;env&lt;/code&gt; 로 발생 시킵니다. &lt;code&gt;args&lt;/code&gt; 의 값은 플랫폼에 따라 단일 문자열 또는 문자열 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b17551906939bf00cd6210cfc6e1b7c22e1ad7f" translate="yes" xml:space="preserve">
          <source>Popen objects are supported as context managers via the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement: on exit, standard file descriptors are closed, and the process is waited for.</source>
          <target state="translated">Popen 객체는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 통해 컨텍스트 관리자로 지원됩니다. 종료시 표준 파일 디스크립터가 닫히고 프로세스가 대기합니다.</target>
        </trans-unit>
        <trans-unit id="2dd4b5da656a3d45200c0848ee3cb43ac97a6338" translate="yes" xml:space="preserve">
          <source>Pops &lt;em&gt;count&lt;/em&gt; iterables from the stack, joins them in a single tuple, and pushes the result. Implements iterable unpacking in tuple displays &lt;code&gt;(*x, *y, *z)&lt;/code&gt;.</source>
          <target state="translated">Pops 는 스택에서 iterable을 &lt;em&gt;계산&lt;/em&gt; 하여 단일 튜플로 결합하고 결과를 푸시합니다. 튜플 디스플레이 &lt;code&gt;(*x, *y, *z)&lt;/code&gt; 에서 반복 가능한 압축 풀기를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="5814db5efa9b8e3b6caaad0167cd52a48d05cad9" translate="yes" xml:space="preserve">
          <source>Pops &lt;em&gt;count&lt;/em&gt; mappings from the stack, merges them into a single dictionary, and pushes the result. Implements dictionary unpacking in dictionary displays &lt;code&gt;{**x, **y, **z}&lt;/code&gt;.</source>
          <target state="translated">팝 은 스택에서 매핑을 &lt;em&gt;계산&lt;/em&gt; 하여 단일 사전에 병합 한 다음 결과를 푸시합니다. 사전 표시 &lt;code&gt;{**x, **y, **z}&lt;/code&gt; 에서 사전 압축 풀기를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="f955b29f96865f975ad2cc90b3761ccd0a745b04" translate="yes" xml:space="preserve">
          <source>Pops TOS and delegates to it as a subiterator from a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;.</source>
          <target state="translated">TOS를 팝하고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; 에서 하위 반복자로 TOS를 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="e75775f93f745fd74be7c11015a4c8773b0fb9e4" translate="yes" xml:space="preserve">
          <source>Pops TOS and yields it from a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;.</source>
          <target state="translated">TOS를 팝하여 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; 에서 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="6868d2193ffcb37b3d1f2442c16bbba7237b9adc" translate="yes" xml:space="preserve">
          <source>Pops two values from the stack. If SECOND is not None and TOS is true unwinds the EXCEPT_HANDLER block which was created when the exception was caught and pushes &lt;code&gt;NULL&lt;/code&gt; to the stack.</source>
          <target state="translated">스택에서 두 값을 팝합니다. SECOND가 없음이 아니고 TOS가 true 인 경우 예외가 발생했을 때 작성된 EXCEPT_HANDLER 블록을 해제하고 &lt;code&gt;NULL&lt;/code&gt; 을 스택으로 푸시 합니다 .</target>
        </trans-unit>
        <trans-unit id="e6936131642fa3e4ba0d0f2eb70bda60239e2636" translate="yes" xml:space="preserve">
          <source>Population standard deviation of data.</source>
          <target state="translated">데이터의 모집단 표준 편차.</target>
        </trans-unit>
        <trans-unit id="18813ec1cc24c6306c29b1b2d825acb9bd81a19c" translate="yes" xml:space="preserve">
          <source>Population variance of data.</source>
          <target state="translated">데이터의 인구 분산.</target>
        </trans-unit>
        <trans-unit id="5a089a07054447bb48b9434607e3b38a83e6a79f" translate="yes" xml:space="preserve">
          <source>Port number as integer, if present</source>
          <target state="translated">존재하는 경우 정수로 표시되는 포트 번호</target>
        </trans-unit>
        <trans-unit id="b9f18b923e08eb677137525e942c79d70f214b5f" translate="yes" xml:space="preserve">
          <source>Portable Bitmap Files</source>
          <target state="translated">휴대용 비트 맵 파일</target>
        </trans-unit>
        <trans-unit id="abcb4ef75def5eeb0dfd26e2d30fca465df66512" translate="yes" xml:space="preserve">
          <source>Portable Graymap Files</source>
          <target state="translated">휴대용 그레이 맵 파일</target>
        </trans-unit>
        <trans-unit id="0655d96b4660aed951fededfbd01c7c59119ecd3" translate="yes" xml:space="preserve">
          <source>Portable Network Graphics</source>
          <target state="translated">휴대용 네트워크 그래픽</target>
        </trans-unit>
        <trans-unit id="ee01b2134ec356d26acdc9982e7f3833060105a8" translate="yes" xml:space="preserve">
          <source>Portable Pixmap Files</source>
          <target state="translated">휴대용 Pixmap 파일</target>
        </trans-unit>
        <trans-unit id="23882c575954a0789bf02aba9e6dd01f539bc738" translate="yes" xml:space="preserve">
          <source>Portuguese</source>
          <target state="translated">Portuguese</target>
        </trans-unit>
        <trans-unit id="59b624bfe60ebbef01b74f793b39f506221b6c00" translate="yes" xml:space="preserve">
          <source>Positional and keyword arguments may also be passed to &lt;a href=&quot;#atexit.register&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt; to be passed along to the registered function when it is called:</source>
          <target state="translated">위치 및 키워드 인수는 &lt;a href=&quot;#atexit.register&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt; 로 전달되어 등록 된 함수가 호출 될 때 등록 된 함수 로 전달 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8b8ca1d6ad9d89dd32a11078244dcd70423b419" translate="yes" xml:space="preserve">
          <source>Positional arguments are files to compile or directories that contain source files, traversed recursively. If no argument is given, behave as if the command line was &lt;code&gt;-l &amp;lt;directories from sys.path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위치 인수는 컴파일 할 파일 또는 소스 파일이 포함 된 디렉토리이며 재귀 적으로 순회합니다. 인수가 제공되지 않으면 명령 행이 &lt;code&gt;-l &amp;lt;directories from sys.path&amp;gt;&lt;/code&gt; 인 것처럼 작동하십시오 .</target>
        </trans-unit>
        <trans-unit id="06fe9ace9667aa168708159444d8188edd059f54" translate="yes" xml:space="preserve">
          <source>Positive</source>
          <target state="translated">Positive</target>
        </trans-unit>
        <trans-unit id="81a9a0719b90c9b53d8f587213315a80505f6dff" translate="yes" xml:space="preserve">
          <source>Positive and negative infinity, positive and negative zero, and nans, are formatted as &lt;code&gt;inf&lt;/code&gt;, &lt;code&gt;-inf&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;nan&lt;/code&gt; respectively, regardless of the precision.</source>
          <target state="translated">양수 및 음수 무한대, 양수 및 음수 0 및 &lt;code&gt;nan&lt;/code&gt; 은 정밀도에 관계없이 각각 &lt;code&gt;inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;-0&lt;/code&gt; 및 nan 으로 형식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fbadb91c0f2d470c8467dae6bb12a446a01cc7db" translate="yes" xml:space="preserve">
          <source>Possible states are:</source>
          <target state="translated">가능한 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63f69fd6d6f413090e0f4f3fa400b942a162733e" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt;&lt;code&gt;SSLContext.verify_flags&lt;/code&gt;&lt;/a&gt; to disable workarounds for broken X.509 certificates.</source>
          <target state="translated">깨진 X.509 인증서에 대한 해결 방법을 비활성화 하기 위해 &lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt; &lt;code&gt;SSLContext.verify_flags&lt;/code&gt; &lt;/a&gt; 에 가능한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4ba63e08aceb3c446a295cf92ec1b942aa49b732" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt;&lt;code&gt;SSLContext.verify_flags&lt;/code&gt;&lt;/a&gt;. In this mode, CRLs of all certificates in the peer cert chain are checked.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt; &lt;code&gt;SSLContext.verify_flags&lt;/code&gt; 의&lt;/a&gt; 가능한 값입니다 . 이 모드에서는 피어 인증서 체인에있는 모든 인증서의 CRL이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="681006f1919e6854682d4ccba2e10d6f1ec838d7" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt;&lt;code&gt;SSLContext.verify_flags&lt;/code&gt;&lt;/a&gt;. In this mode, certificate revocation lists (CRLs) are not checked. By default OpenSSL does neither require nor verify CRLs.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt; &lt;code&gt;SSLContext.verify_flags&lt;/code&gt; 의&lt;/a&gt; 가능한 값입니다 . 이 모드에서는 CRL (인증서 해지 목록)이 확인되지 않습니다. 기본적으로 OpenSSL은 CRL을 요구하거나 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="834cb8dd69db769ec9e67cc37db58e1dcab7a3c4" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt;&lt;code&gt;SSLContext.verify_flags&lt;/code&gt;&lt;/a&gt;. In this mode, only the peer cert is checked but none of the intermediate CA certificates. The mode requires a valid CRL that is signed by the peer cert&amp;rsquo;s issuer (its direct ancestor CA). If no proper CRL has has been loaded with &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt;&lt;code&gt;SSLContext.load_verify_locations&lt;/code&gt;&lt;/a&gt;, validation will fail.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt; &lt;code&gt;SSLContext.verify_flags&lt;/code&gt; 의&lt;/a&gt; 가능한 값입니다 . 이 모드에서는 피어 인증서 만 확인하지만 중간 CA 인증서는 확인하지 않습니다. 이 모드에는 피어 인증서 발급자 (직계 조상 CA)가 서명 한 유효한 CRL이 필요합니다. &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt; &lt;code&gt;SSLContext.load_verify_locations&lt;/code&gt; &lt;/a&gt; 로 올바른 CRL을로드하지 않은 경우 유효성 검사가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="81033163c8cc54904575c439b4a3466834d6c011" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt;&lt;code&gt;SSLContext.verify_flags&lt;/code&gt;&lt;/a&gt;. It instructs OpenSSL to prefer trusted certificates when building the trust chain to validate a certificate. This flag is enabled by default.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_flags&quot;&gt; &lt;code&gt;SSLContext.verify_flags&lt;/code&gt; 의&lt;/a&gt; 가능한 값입니다 . 인증서를 검증하기 위해 신뢰 체인을 구축 할 때 OpenSSL에 신뢰할 수있는 인증서를 선호하도록 지시합니다. 이 플래그는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d3909c91e1e0e21475e53c7bf078037dcbcbfb5" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;SSLContext.verify_mode&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;cert_reqs&lt;/code&gt; parameter to &lt;a href=&quot;#ssl.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt;. Except for &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt;, it is the default mode. With client-side sockets, just about any cert is accepted. Validation errors, such as untrusted or expired cert, are ignored and do not abort the TLS/SSL handshake.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;SSLContext.verify_mode&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;cert_reqs&lt;/code&gt; 매개 변수의 가능한 값은 &lt;a href=&quot;#ssl.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; 를&lt;/a&gt; 제외하고 기본 모드입니다. 클라이언트 측 소켓을 사용하면 거의 모든 인증서를 사용할 수 있습니다. 신뢰할 수 없거나 만료 된 인증서와 같은 유효성 검사 오류는 무시되며 TLS / SSL 핸드 셰이크를 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8c9444f11c8fa0cbf7a1cf96c440bde31779c0e" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;SSLContext.verify_mode&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;cert_reqs&lt;/code&gt; parameter to &lt;a href=&quot;#ssl.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt;. In client mode, &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; has the same meaning as &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;. It is recommended to use &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; for client-side sockets instead.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;SSLContext.verify_mode&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;cert_reqs&lt;/code&gt; 매개 변수의 가능한 값은 &lt;a href=&quot;#ssl.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 입니다. 클라이언트 모드에서 &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 . 대신 클라이언트 측 소켓에 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5069135a65407b38a1f42b151ee1613e108b36f0" translate="yes" xml:space="preserve">
          <source>Possible value for &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;SSLContext.verify_mode&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;cert_reqs&lt;/code&gt; parameter to &lt;a href=&quot;#ssl.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt;. In this mode, certificates are required from the other side of the socket connection; an &lt;a href=&quot;#ssl.SSLError&quot;&gt;&lt;code&gt;SSLError&lt;/code&gt;&lt;/a&gt; will be raised if no certificate is provided, or if its validation fails. This mode is &lt;strong&gt;not&lt;/strong&gt; sufficient to verify a certificate in client mode as it does not match hostnames. &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; must be enabled as well to verify the authenticity of a cert. &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and enables &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;SSLContext.verify_mode&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;cert_reqs&lt;/code&gt; 매개 변수의 가능한 값은 &lt;a href=&quot;#ssl.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 입니다. 이 모드에서는 소켓 연결의 다른 쪽에서 인증서가 필요합니다. &lt;a href=&quot;#ssl.SSLError&quot;&gt; &lt;code&gt;SSLError&lt;/code&gt; 은&lt;/a&gt; 인증서가 제공되지 않은 경우 발생합니다, 또는 유효성 검사가 실패합니다. 이 모드는 &lt;strong&gt;되지&lt;/strong&gt; 는 호스트 이름과 일치하지 않는 클라이언트 모드에서 인증서를 확인하기에 충분. 인증서의 진위 여부를 확인하려면 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt; 도 활성화해야합니다. &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; 는&lt;/a&gt; 사용 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; 을&lt;/a&gt; 하고 수 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; 을&lt;/a&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="c2907ec0c1e89d9ea47e904c9015b71f6024c1e0" translate="yes" xml:space="preserve">
          <source>Possible value for the &lt;em&gt;mode&lt;/em&gt; parameter to the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; family of functions. If this is given as &lt;em&gt;mode&lt;/em&gt;, the &lt;code&gt;spawn*()&lt;/code&gt; functions will not return until the new process has run to completion and will return the exit code of the process the run is successful, or &lt;code&gt;-signal&lt;/code&gt; if a signal kills the process.</source>
          <target state="translated">&lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수 군에 &lt;em&gt;모드&lt;/em&gt; 매개 변수에 가능한 값 . 이것이 &lt;em&gt;mode로 지정&lt;/em&gt; 되면, &lt;code&gt;spawn*()&lt;/code&gt; 함수는 새 프로세스가 완료 될 때까지 리턴되지 않으며 실행이 성공한 프로세스의 종료 코드를 리턴하거나 &lt;code&gt;-signal&lt;/code&gt; 가 프로세스를 종료 하는 경우-신호 를 리턴합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="595379185db1d5c8fb2fa29686c56e99c74f8a16" translate="yes" xml:space="preserve">
          <source>Possible values for the &lt;em&gt;mode&lt;/em&gt; parameter to the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; family of functions. If either of these values is given, the &lt;code&gt;spawn*()&lt;/code&gt; functions will return as soon as the new process has been created, with the process id as the return value.</source>
          <target state="translated">&lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수 군에 &lt;em&gt;모드&lt;/em&gt; 매개 변수에 가능한 값 . 이 값 중 하나를 지정 하면 프로세스 ID를 반환 값으로 사용하여 새 프로세스가 생성되는 즉시 &lt;code&gt;spawn*()&lt;/code&gt; 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="98444d7e6ce2c20d6c8fa33edbb3a360778be71c" translate="yes" xml:space="preserve">
          <source>Possible values for the &lt;em&gt;mode&lt;/em&gt; parameter to the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; family of functions. These are less portable than those listed above. &lt;a href=&quot;#os.P_DETACH&quot;&gt;&lt;code&gt;P_DETACH&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#os.P_NOWAIT&quot;&gt;&lt;code&gt;P_NOWAIT&lt;/code&gt;&lt;/a&gt;, but the new process is detached from the console of the calling process. If &lt;a href=&quot;#os.P_OVERLAY&quot;&gt;&lt;code&gt;P_OVERLAY&lt;/code&gt;&lt;/a&gt; is used, the current process will be replaced; the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; function will not return.</source>
          <target state="translated">&lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수 군에 &lt;em&gt;mode&lt;/em&gt; 매개 변수에 가능한 값 . 이들은 위에 나열된 것보다 이식성이 떨어집니다. &lt;a href=&quot;#os.P_DETACH&quot;&gt; &lt;code&gt;P_DETACH&lt;/code&gt; 은&lt;/a&gt; 유사하다 &lt;a href=&quot;#os.P_NOWAIT&quot;&gt; &lt;code&gt;P_NOWAIT&lt;/code&gt; &lt;/a&gt; 하지만, 새로운 프로세스는 호출 프로세스의 콘솔에서 분리된다. 경우 &lt;a href=&quot;#os.P_OVERLAY&quot;&gt; &lt;code&gt;P_OVERLAY&lt;/code&gt; 가&lt;/a&gt; 사용되며, 현재 프로세스를 교체해야합니다; &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 기능은 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad471bf2d14a9f069fad782304e156715b0c3a8d" translate="yes" xml:space="preserve">
          <source>Post an article using the &lt;code&gt;POST&lt;/code&gt; command. The &lt;em&gt;data&lt;/em&gt; argument is either a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened for binary reading, or any iterable of bytes objects (representing raw lines of the article to be posted). It should represent a well-formed news article, including the required headers. The &lt;a href=&quot;#nntplib.NNTP.post&quot;&gt;&lt;code&gt;post()&lt;/code&gt;&lt;/a&gt; method automatically escapes lines beginning with &lt;code&gt;.&lt;/code&gt; and appends the termination line.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 명령을 사용하여 기사를 게시하십시오 . &lt;em&gt;데이터&lt;/em&gt; 인수 중 하나 인 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 바이너리 읽기 위해 열, 또는 (게시하는 기사의 원시 라인을 나타내는) 바이트 객체의 반복자. 필수 헤더를 포함하여 올바르게 구성된 뉴스 기사를 나타내야합니다. &lt;a href=&quot;#nntplib.NNTP.post&quot;&gt; &lt;code&gt;post()&lt;/code&gt; &lt;/a&gt; 메서드는 자동으로 시작하는 라인을 탈출 &lt;code&gt;.&lt;/code&gt; 종료 라인을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b63bfd48fc2a1b5e7e89f48afbac27f355349bc7" translate="yes" xml:space="preserve">
          <source>Post-init processing</source>
          <target state="translated">초기 처리</target>
        </trans-unit>
        <trans-unit id="be382487def51aeab399ad276c635ee4d94d07d1" translate="yes" xml:space="preserve">
          <source>Power and logarithmic functions</source>
          <target state="translated">전력 및 로그 함수</target>
        </trans-unit>
        <trans-unit id="5c34f11767e3344552d1ea1633a63119f696d0a7" translate="yes" xml:space="preserve">
          <source>PowerShell</source>
          <target state="translated">PowerShell</target>
        </trans-unit>
        <trans-unit id="178cd9d66a4b1bce25cb5e2cea3f2128b6ffceb3" translate="yes" xml:space="preserve">
          <source>PowerShell Core</source>
          <target state="translated">PowerShell 코어</target>
        </trans-unit>
        <trans-unit id="db3d345a9a0fd91ab9f33caeeec48958f5ce609f" translate="yes" xml:space="preserve">
          <source>Practical Programming in Tcl and Tk</source>
          <target state="translated">Tcl 및 Tk의 실용 프로그래밍</target>
        </trans-unit>
        <trans-unit id="490f67184b68428ab7db592bcebf51431ff864dc" translate="yes" xml:space="preserve">
          <source>Precision (optional), given as a &lt;code&gt;'.'&lt;/code&gt; (dot) followed by the precision. If specified as &lt;code&gt;'*'&lt;/code&gt; (an asterisk), the actual precision is read from the next element of the tuple in &lt;em&gt;values&lt;/em&gt;, and the value to convert comes after the precision.</source>
          <target state="translated">&lt;code&gt;'.'&lt;/code&gt; 으로 제공되는 정밀도 (선택 사항) (점) 뒤에 정밀도가옵니다. &lt;code&gt;'*'&lt;/code&gt; (별표) 로 지정된 경우 실제 정밀도는 튜플의 다음 요소에서 &lt;em&gt;values&lt;/em&gt; 로 읽히고 변환 할 값은 정밀도 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="449d850ff0a5b8d2b97bfb75bf9d9fdcf80b0bd6" translate="yes" xml:space="preserve">
          <source>Precomputed tables</source>
          <target state="translated">미리 계산 된 테이블</target>
        </trans-unit>
        <trans-unit id="71527b4452262b2288bec21620f4277e5383be6c" translate="yes" xml:space="preserve">
          <source>Predicates (expressions within square brackets) must be preceded by a tag name, an asterisk, or another predicate. &lt;code&gt;position&lt;/code&gt; predicates must be preceded by a tag name.</source>
          <target state="translated">술어 (대괄호 안에있는 표현식) 앞에는 태그 이름, 별표 또는 다른 술어가 와야합니다. &lt;code&gt;position&lt;/code&gt; 술어 앞에는 태그 이름이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="707ddefda8b9d501a1d63dad3fcb74d0cb28b51a" translate="yes" xml:space="preserve">
          <source>Preface</source>
          <target state="translated">Preface</target>
        </trans-unit>
        <trans-unit id="bde7dd0530c513b11cc390474cc050f812b6f3db" translate="yes" xml:space="preserve">
          <source>Prefix each line with the time since the program started. Only used while tracing.</source>
          <target state="translated">프로그램이 시작된 이후의 시간을 각 줄 앞에 붙입니다. 추적하는 동안에 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="515863d159aa2e0dd47fb1d5d6139a71281b0192" translate="yes" xml:space="preserve">
          <source>Prefix, net mask and host mask</source>
          <target state="translated">접두사, 네트 마스크 및 호스트 마스크</target>
        </trans-unit>
        <trans-unit id="93c620f6932937b6bc7d5291dc67d610857f5774" translate="yes" xml:space="preserve">
          <source>Prefixes any opcode which has an argument too big to fit into the default one byte. &lt;em&gt;ext&lt;/em&gt; holds an additional byte which act as higher bits in the argument. For each opcode, at most three prefixal &lt;code&gt;EXTENDED_ARG&lt;/code&gt; are allowed, forming an argument from two-byte to four-byte.</source>
          <target state="translated">인수가 너무 커서 기본 1 바이트에 맞지 않는 opcode를 접두어로 사용합니다. &lt;em&gt;ext&lt;/em&gt; 는 인수에서 상위 비트로 작동하는 추가 바이트를 보유합니다. 각 opcode마다 최대 3 개의 접두어 &lt;code&gt;EXTENDED_ARG&lt;/code&gt; 가 허용되며 2 바이트에서 4 바이트 사이의 인수를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="aeab98f5a34301d71af8d216207f9b70ea4d1b4f" translate="yes" xml:space="preserve">
          <source>Prepare a record for handling.</source>
          <target state="translated">취급 할 기록을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="eaabdea71a53a1d312c68621c7a08cafc4337348" translate="yes" xml:space="preserve">
          <source>Prepare for object destruction. &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; provides a default implementation of this method that calls the instance&amp;rsquo;s &lt;a href=&quot;#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">객체 파괴를 준비하십시오. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 는 인스턴스의 &lt;a href=&quot;#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는이 메소드의 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="48869057a3eaf9b7bda4696b2a82f8cd32542baa" translate="yes" xml:space="preserve">
          <source>Prepare the request by connecting to a proxy server. The &lt;em&gt;host&lt;/em&gt; and &lt;em&gt;type&lt;/em&gt; will replace those of the instance, and the instance&amp;rsquo;s selector will be the original URL given in the constructor.</source>
          <target state="translated">프록시 서버에 연결하여 요청을 준비하십시오. &lt;em&gt;호스트&lt;/em&gt; 와 &lt;em&gt;유형은&lt;/em&gt; 인스턴스의 사람들을 대체하며, 인스턴스의 선택은 생성자에 주어진 원래의 URL 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2acd0ee4e2fd08e925fed1556f93a353652b578a" translate="yes" xml:space="preserve">
          <source>Prepares a record for queuing. The object returned by this method is enqueued.</source>
          <target state="translated">큐에 레코드를 준비합니다. 이 메소드에 의해 리턴 된 오브젝트가 큐에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="57c6749aaa2e639ce29f4d77ddbc7ec04736e80b" translate="yes" xml:space="preserve">
          <source>Pretend &lt;em&gt;count&lt;/em&gt; lines have been changed, starting with line &lt;em&gt;start&lt;/em&gt;. If &lt;em&gt;changed&lt;/em&gt; is supplied, it specifies whether the affected lines are marked as having been changed (&lt;em&gt;changed&lt;/em&gt;&lt;code&gt;=True&lt;/code&gt;) or unchanged (&lt;em&gt;changed&lt;/em&gt;&lt;code&gt;=False&lt;/code&gt;).</source>
          <target state="translated">척수 &lt;em&gt;카운트&lt;/em&gt; 라인이 line &lt;em&gt;start로&lt;/em&gt; 시작하여 변경되었습니다 . 경우 &lt;em&gt;변경&lt;/em&gt; 공급되어,이 영향을 줄이 변경된 것으로 표시되는지 여부를 지정 ( &lt;em&gt;변경 &lt;/em&gt; &lt;code&gt;=True&lt;/code&gt; () 또는 변하지 &lt;em&gt;변경 &lt;/em&gt; &lt;code&gt;=False&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f8b9077326620d7215f339382fae5f8dbf5068b" translate="yes" xml:space="preserve">
          <source>Pretend the whole window has been changed, for purposes of drawing optimizations.</source>
          <target state="translated">도면 최적화를 위해 전체 창이 변경된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d69b44b9452e785bcf38a58c11f7522588dd0a12" translate="yes" xml:space="preserve">
          <source>Pretty printing:</source>
          <target state="translated">예쁜 인쇄 :</target>
        </trans-unit>
        <trans-unit id="cc5593cc97eb10b44d34d3ef59a99ba2b518cf84" translate="yes" xml:space="preserve">
          <source>Pretty top</source>
          <target state="translated">예쁜 탑</target>
        </trans-unit>
        <trans-unit id="736722dd09c56467e68847a72672d85b5b4e5d72" translate="yes" xml:space="preserve">
          <source>PrettyPrinter Objects</source>
          <target state="translated">PrettyPrinter 객체</target>
        </trans-unit>
        <trans-unit id="3d63214479b7b9df436250cf443d77f3a6172b43" translate="yes" xml:space="preserve">
          <source>Prev (previous)</source>
          <target state="translated">이전 (이전)</target>
        </trans-unit>
        <trans-unit id="1706782b9fb86817417f6ce4b4b586638f5f4fe5" translate="yes" xml:space="preserve">
          <source>Prevent &lt;a href=&quot;#multiprocessing.Queue.join_thread&quot;&gt;&lt;code&gt;join_thread()&lt;/code&gt;&lt;/a&gt; from blocking. In particular, this prevents the background thread from being joined automatically when the process exits &amp;ndash; see &lt;a href=&quot;#multiprocessing.Queue.join_thread&quot;&gt;&lt;code&gt;join_thread()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Queue.join_thread&quot;&gt; &lt;code&gt;join_thread()&lt;/code&gt; &lt;/a&gt; 가 차단되지 않도록합니다 . 특히, 프로세스가 종료 될 때 백그라운드 스레드가 자동으로 결합되는 것을 방지합니다 &lt;a href=&quot;#multiprocessing.Queue.join_thread&quot;&gt; &lt;code&gt;join_thread()&lt;/code&gt; &lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="107e68d762b79bad537ef9fb207d4e1d39e52d58" translate="yes" xml:space="preserve">
          <source>Prevent client side from requesting a session ticket.</source>
          <target state="translated">클라이언트 측에서 세션 티켓을 요청하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="c30a1250034cd8e55c1c2149d1282952906d4b8e" translate="yes" xml:space="preserve">
          <source>Prevents a TLSv1 connection. This option is only applicable in conjunction with &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;. It prevents the peers from choosing TLSv1 as the protocol version.</source>
          <target state="translated">TLSv1 연결을 방지합니다. 이 옵션은 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 함께 만 적용 할 수 있습니다. 피어가 TLSv1을 프로토콜 버전으로 선택하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="8afbd15b84e40a48b2da893725e169841a8cfb02" translate="yes" xml:space="preserve">
          <source>Prevents a TLSv1.1 connection. This option is only applicable in conjunction with &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;. It prevents the peers from choosing TLSv1.1 as the protocol version. Available only with openssl version 1.0.1+.</source>
          <target state="translated">TLSv1.1 연결을 방지합니다. 이 옵션은 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 함께 만 적용 할 수 있습니다. 피어가 프로토콜 버전으로 TLSv1.1을 선택하지 못하게합니다. openssl 버전 1.0.1 이상에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e1aad586005b65865ebf605785c29cd1a005d4e0" translate="yes" xml:space="preserve">
          <source>Prevents a TLSv1.2 connection. This option is only applicable in conjunction with &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;. It prevents the peers from choosing TLSv1.2 as the protocol version. Available only with openssl version 1.0.1+.</source>
          <target state="translated">TLSv1.2 연결을 방지합니다. 이 옵션은 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 함께 만 적용 할 수 있습니다. 피어가 프로토콜 버전으로 TLSv1.2를 선택하지 못하게합니다. openssl 버전 1.0.1 이상에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="09c8e59b75ea4fcfcf9e178d3d0fa59ba0f19d05" translate="yes" xml:space="preserve">
          <source>Prevents a TLSv1.3 connection. This option is only applicable in conjunction with &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;. It prevents the peers from choosing TLSv1.3 as the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When Python has been compiled against an older version of OpenSSL, the flag defaults to &lt;em&gt;0&lt;/em&gt;.</source>
          <target state="translated">TLSv1.3 연결을 방지합니다. 이 옵션은 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 함께 만 적용 할 수 있습니다. 피어가 프로토콜 버전으로 TLSv1.3을 선택하지 못하게합니다. TLS 1.3은 OpenSSL 1.1.1 이상에서 사용할 수 있습니다. Python이 이전 버전의 OpenSSL에 대해 컴파일 된 경우 플래그의 기본값은 &lt;em&gt;0&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbb04da33d788199d87cc8cadc4dadbebdb32b14" translate="yes" xml:space="preserve">
          <source>Prevents an SSLv2 connection. This option is only applicable in conjunction with &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;. It prevents the peers from choosing SSLv2 as the protocol version.</source>
          <target state="translated">SSLv2 연결을 방지합니다. 이 옵션은 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 함께 만 적용 할 수 있습니다. 피어가 SSLv2를 프로토콜 버전으로 선택하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="e9b46f8715c307e61781566f286e18f0ca110744" translate="yes" xml:space="preserve">
          <source>Prevents an SSLv3 connection. This option is only applicable in conjunction with &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;. It prevents the peers from choosing SSLv3 as the protocol version.</source>
          <target state="translated">SSLv3 연결을 방지합니다. 이 옵션은 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 함께 만 적용 할 수 있습니다. 피어가 SSLv3을 프로토콜 버전으로 선택하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="9dfcb0887264caddd8e829fb5d7f710039337de4" translate="yes" xml:space="preserve">
          <source>Prevents any more tasks from being submitted to the pool. Once all the tasks have been completed the worker processes will exit.</source>
          <target state="translated">더 이상의 작업이 풀에 제출되지 않도록합니다. 모든 작업이 완료되면 작업자 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="dc320ab03d06fd63221446db92226635a2e40b3c" translate="yes" xml:space="preserve">
          <source>Prevents re-use of the same DH key for distinct SSL sessions. This improves forward secrecy but requires more computational resources. This option only applies to server sockets.</source>
          <target state="translated">고유 한 SSL 세션에 동일한 DH 키를 재사용하지 못하게합니다. 이를 통해 순방향 보안이 향상되지만 더 많은 계산 리소스가 필요합니다. 이 옵션은 서버 소켓에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7ea65f7cda64106b6057a83880d70342ae857bc" translate="yes" xml:space="preserve">
          <source>Prevents re-use of the same ECDH key for distinct SSL sessions. This improves forward secrecy but requires more computational resources. This option only applies to server sockets.</source>
          <target state="translated">고유 한 SSL 세션에 동일한 ECDH 키를 재사용하지 못하게합니다. 이를 통해 순방향 보안이 향상되지만 더 많은 계산 리소스가 필요합니다. 이 옵션은 서버 소켓에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f2319e1b3ce31d6273e32117a3b51c171cce33b2" translate="yes" xml:space="preserve">
          <source>Previous History</source>
          <target state="translated">이전 역사</target>
        </trans-unit>
        <trans-unit id="1cf61f9b704231b7d9da66ca29b0efd733397410" translate="yes" xml:space="preserve">
          <source>Previous calls to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; determine exactly what objects are created and how they are assigned. See the documentation for &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 이전 호출은 정확히 어떤 객체가 만들어지고 어떻게 할당되는지를 결정합니다. 자세한 내용은 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="81f547195bef12a0bb74f5af751fe50e78a0c2f3" translate="yes" xml:space="preserve">
          <source>Previous page</source>
          <target state="translated">이전 페이지</target>
        </trans-unit>
        <trans-unit id="7b2c11a3c946fcc3cf0f0e62f1d9a7753a415146" translate="yes" xml:space="preserve">
          <source>Previously detected by MUA</source>
          <target state="translated">이전에 MUA에서 감지</target>
        </trans-unit>
        <trans-unit id="e4da2d9864c0122b5dbabd8caa7e6fe3ce162517" translate="yes" xml:space="preserve">
          <source>Previously registered error handlers (including the standard error handlers) can be looked up by name:</source>
          <target state="translated">이전에 등록 된 오류 처리기 (표준 오류 처리기 포함)는 이름별로 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b221e9c2a451799d8f37e2b9874409d5e03ab05" translate="yes" xml:space="preserve">
          <source>Print</source>
          <target state="translated">Print</target>
        </trans-unit>
        <trans-unit id="92c131e7cbd0707515ecfaf6e40abffb9a8099ab" translate="yes" xml:space="preserve">
          <source>Print (to &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt;) a comparison between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 사이 &lt;em&gt;의&lt;/em&gt; 비교 를 인쇄합니다 ( &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; 에&lt;/a&gt; ) .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24d7c51d91db7ea29be8c3d303dbaf662d021276" translate="yes" xml:space="preserve">
          <source>Print &lt;em&gt;objects&lt;/em&gt; to the text stream &lt;em&gt;file&lt;/em&gt;, separated by &lt;em&gt;sep&lt;/em&gt; and followed by &lt;em&gt;end&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt;, &lt;em&gt;end&lt;/em&gt;, &lt;em&gt;file&lt;/em&gt; and &lt;em&gt;flush&lt;/em&gt;, if present, must be given as keyword arguments.</source>
          <target state="translated">&lt;em&gt;sep로&lt;/em&gt; 구분 된 다음 &lt;em&gt;끝으로&lt;/em&gt; 텍스트 스트림 &lt;em&gt;파일에 &lt;/em&gt;&lt;em&gt;객체&lt;/em&gt; 를 인쇄 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;sep&lt;/em&gt; , &lt;em&gt;end&lt;/em&gt; , &lt;em&gt;file&lt;/em&gt; 및 &lt;em&gt;flush&lt;/em&gt; 는있는 경우 키워드 인수로 제공되어야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="75ea07e0a17305b6a0d75015e0d39ee48139eff9" translate="yes" xml:space="preserve">
          <source>Print Window</source>
          <target state="translated">인쇄 창</target>
        </trans-unit>
        <trans-unit id="092b80785f55799fe50486ddf8f296c06ea3eb11" translate="yes" xml:space="preserve">
          <source>Print a brief description of how the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; should be invoked on the command line. If &lt;em&gt;file&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; is assumed.</source>
          <target state="translated">명령 행 에서 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 를 호출 하는 방법에 대한 간단한 설명을 인쇄하십시오 . 경우 &lt;em&gt;파일이&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; 은&lt;/a&gt; 가정한다.</target>
        </trans-unit>
        <trans-unit id="7a9eb22264c3b5dec2931b1f324be362e8a3caa9" translate="yes" xml:space="preserve">
          <source>Print a comparison between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; and common immediate subdirectories.</source>
          <target state="translated">&lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 와 공통 직계 서브 디렉토리 간의 비교를 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="9737c0d0218890590b21fe3f519df6b481314ddd" translate="yes" xml:space="preserve">
          <source>Print a comparison between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; and common subdirectories (recursively).</source>
          <target state="translated">&lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 와 공통 서브 디렉토리 사이의 비교를 재귀 적으로 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="42a7ec328f156fde422cd7dc61bb23c09f74e406" translate="yes" xml:space="preserve">
          <source>Print a debug message when the debug level is &lt;code&gt;&amp;gt;&lt;/code&gt; 0. If extra arguments are present, they are substituted in the message using the standard string formatting operator.</source>
          <target state="translated">디버그 레벨 일 때 디버그 메시지를 인쇄 &lt;code&gt;&amp;gt;&lt;/code&gt; 추가 인수가 존재 0 경우, 연산자를 포맷 표준 문자열을 사용하여 메시지로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3d5dcdf55a88c009944f0a40c26245225b570e85" translate="yes" xml:space="preserve">
          <source>Print a help message, including the program usage and information about the arguments registered with the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;file&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; is assumed.</source>
          <target state="translated">프로그램 사용법 및 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 에&lt;/a&gt; 등록 된 인수에 대한 정보를 포함하여 도움말 메시지를 인쇄하십시오 . 경우 &lt;em&gt;파일이&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; 은&lt;/a&gt; 가정한다.</target>
        </trans-unit>
        <trans-unit id="87a8729cb0a90de0e71cb0527bb7846eb00c7fa6" translate="yes" xml:space="preserve">
          <source>Print a list of useful (used by CGI) environment variables in HTML.</source>
          <target state="translated">HTML에서 유용한 (CGI에서 사용하는) 환경 변수 목록을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="b7d04d6b0c20b3d6e0ad773b82dd44d393b9fe4c" translate="yes" xml:space="preserve">
          <source>Print a month&amp;rsquo;s calendar as returned by &lt;a href=&quot;#calendar.TextCalendar.formatmonth&quot;&gt;&lt;code&gt;formatmonth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#calendar.TextCalendar.formatmonth&quot;&gt; &lt;code&gt;formatmonth()&lt;/code&gt; &lt;/a&gt; 반환 한 월 달력을 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="8819c1eace7f2970056904e5d1b4f13a04ad201a" translate="yes" xml:space="preserve">
          <source>Print a report to standard output that lists the modules imported by the script and their paths, as well as modules that are missing or seem to be missing.</source>
          <target state="translated">스크립트에서 가져온 모듈과 해당 경로 및 누락되었거나 누락 된 것으로 보이는 모듈을 나열하는 보고서를 표준 출력으로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="5c8fe4e870e195a4e0e71c8a37d1ceb1bdba9faa" translate="yes" xml:space="preserve">
          <source>Print a short usage message and exit.</source>
          <target state="translated">간단한 사용법 메시지를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="46d75d2a40c595663c260f13796637d15127363a" translate="yes" xml:space="preserve">
          <source>Print a stack trace, with the most recent frame at the bottom. An arrow indicates the current frame, which determines the context of most commands.</source>
          <target state="translated">가장 최근 프레임이 맨 아래에 오도록 스택 추적을 인쇄하십시오. 화살표는 현재 프레임을 나타내며 대부분의 명령 컨텍스트를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="226e396c7c77d5972c0c2c1364f81ae49c3ca29d" translate="yes" xml:space="preserve">
          <source>Print a summary of all the test cases that have been run by this DocTestRunner, and return a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;TestResults(failed, attempted)&lt;/code&gt;.</source>
          <target state="translated">이 DocTestRunner가 실행 한 모든 테스트 케이스의 요약을 인쇄하고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플 &lt;/a&gt; &lt;code&gt;TestResults(failed, attempted)&lt;/code&gt; trieded)를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="d50abcb71a77d1ef48177e1bdc2bc346a39afa2a" translate="yes" xml:space="preserve">
          <source>Print a table of contents for the archive to &lt;code&gt;sys.stdout&lt;/code&gt;.</source>
          <target state="translated">아카이브의 목차를 &lt;code&gt;sys.stdout&lt;/code&gt; 에 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bc98eb6896e2c06d7f1828dfb2545f703e3d1a9" translate="yes" xml:space="preserve">
          <source>Print a table of contents to &lt;code&gt;sys.stdout&lt;/code&gt;. If &lt;em&gt;verbose&lt;/em&gt; is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, only the names of the members are printed. If it is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, output similar to that of &lt;strong&gt;ls -l&lt;/strong&gt; is produced. If optional &lt;em&gt;members&lt;/em&gt; is given, it must be a subset of the list returned by &lt;a href=&quot;#tarfile.TarFile.getmembers&quot;&gt;&lt;code&gt;getmembers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">목차를 &lt;code&gt;sys.stdout&lt;/code&gt; 에 인쇄하십시오 . 경우 &lt;em&gt;자세한 정보는&lt;/em&gt; 인 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , 회원의 이름 만 인쇄됩니다. &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;strong&gt;ls -l&lt;/strong&gt; 과 유사한 출력 이 생성됩니다. 선택적 &lt;em&gt;멤버&lt;/em&gt; 가 제공되면 &lt;a href=&quot;#tarfile.TarFile.getmembers&quot;&gt; &lt;code&gt;getmembers()&lt;/code&gt; &lt;/a&gt; 리턴 한 목록의 서브 세트 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="bc5c5b21b998c663e90c709b002328a575120497" translate="yes" xml:space="preserve">
          <source>Print detailed code object information for the supplied function, method, source code string or code object to &lt;em&gt;file&lt;/em&gt; (or &lt;code&gt;sys.stdout&lt;/code&gt; if &lt;em&gt;file&lt;/em&gt; is not specified).</source>
          <target state="translated">제공된 함수, 메소드, 소스 코드 문자열 또는 코드 오브젝트에 대한 자세한 코드 오브젝트 정보를 &lt;em&gt;파일&lt;/em&gt; 로 인쇄 &lt;em&gt;하십시오&lt;/em&gt; (또는 &lt;em&gt;파일&lt;/em&gt; 이 지정되지 않은 경우 &lt;code&gt;sys.stdout&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="37d12069e6f16af033ab45913e5be7746c5e26cb" translate="yes" xml:space="preserve">
          <source>Print exception information and stack trace entries from traceback object &lt;em&gt;tb&lt;/em&gt; to &lt;em&gt;file&lt;/em&gt;. This differs from &lt;a href=&quot;#traceback.print_tb&quot;&gt;&lt;code&gt;print_tb()&lt;/code&gt;&lt;/a&gt; in the following ways:</source>
          <target state="translated">예외 정보를 인쇄하고 추적 오브젝트 &lt;em&gt;tb&lt;/em&gt; 에서 &lt;em&gt;파일로&lt;/em&gt; 추적 추적 항목을 스택 &lt;em&gt;하십시오&lt;/em&gt; . 다음과 같은 점에서 &lt;a href=&quot;#traceback.print_tb&quot;&gt; &lt;code&gt;print_tb()&lt;/code&gt; &lt;/a&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="df0179c0889e679cc1234c128af6d1759f84855f" translate="yes" xml:space="preserve">
          <source>Print information about the specified object rather than the source code</source>
          <target state="translated">소스 코드가 아닌 지정된 객체에 대한 정보를 인쇄합니다</target>
        </trans-unit>
        <trans-unit id="9d7895802cb9df9889bd75e637eaa3eae04b274e" translate="yes" xml:space="preserve">
          <source>Print information of uncollectable objects found (objects which are not reachable but cannot be freed by the collector). These objects will be added to the &lt;code&gt;garbage&lt;/code&gt; list.</source>
          <target state="translated">수집 할 수없는 개체의 정보를 인쇄합니다 (연결할 수 없지만 수집기에서 해제 할 수없는 개체). 이러한 객체는 &lt;code&gt;garbage&lt;/code&gt; 목록에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c75eed0af00a793cf5ded9d6e4b5cc55d5c12d11" translate="yes" xml:space="preserve">
          <source>Print information on collectable objects found.</source>
          <target state="translated">발견 된 수집 가능한 개체에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="fd547948a708e1b1b0f64df6d997902a7615f488" translate="yes" xml:space="preserve">
          <source>Print low-level information to stderr about the state of CPython&amp;rsquo;s memory allocator.</source>
          <target state="translated">CPython의 메모리 할당 자 상태에 대한 저수준 정보를 stderr에 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="1e713e958b47d68260886430651371a5089e51b6" translate="yes" xml:space="preserve">
          <source>Print statistics during collection. This information can be useful when tuning the collection frequency.</source>
          <target state="translated">수집 중 통계를 인쇄합니다. 이 정보는 수집 빈도를 조정할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2ebafe93be796a06067ee45e369ac2e44de72e5" translate="yes" xml:space="preserve">
          <source>Print the argument list of the current function.</source>
          <target state="translated">현재 함수의 인수 목록을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="0f9b05a178e0881d089969f09ca376db8448581e" translate="yes" xml:space="preserve">
          <source>Print the byte string &lt;em&gt;char&lt;/em&gt; to the console without buffering.</source>
          <target state="translated">버퍼링없이 바이트 문자열 &lt;em&gt;char&lt;/em&gt; 을 콘솔에 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="caef0f05a449fbd2f0d330f2b834bbe64628bd70" translate="yes" xml:space="preserve">
          <source>Print the calendar for an entire year as returned by &lt;a href=&quot;#calendar.TextCalendar.formatyear&quot;&gt;&lt;code&gt;formatyear()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#calendar.TextCalendar.formatyear&quot;&gt; &lt;code&gt;formatyear()&lt;/code&gt; &lt;/a&gt; 반환 한 연도 달력을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="1fa21f2ae8d79fedb943ef8eab2b17d9abd3b148" translate="yes" xml:space="preserve">
          <source>Print the current window to the default printer.</source>
          <target state="translated">현재 창을 기본 프린터로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="7797e8c591f71dfae6cf64f791e63ba50f0fffba" translate="yes" xml:space="preserve">
          <source>Print the formatted representation of &lt;em&gt;object&lt;/em&gt; on the configured stream, followed by a newline.</source>
          <target state="translated">구성된 스트림 에서 형식화 된 &lt;em&gt;오브젝트&lt;/em&gt; 표시를 인쇄 한 다음 줄 바꾸기를 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fc7c1a8b497470b56c309b8fd8305feb81fc79d" translate="yes" xml:space="preserve">
          <source>Print the output of &lt;a href=&quot;#bdb.Breakpoint.bpformat&quot;&gt;&lt;code&gt;bpformat()&lt;/code&gt;&lt;/a&gt; to the file &lt;em&gt;out&lt;/em&gt;, or if it is &lt;code&gt;None&lt;/code&gt;, to standard output.</source>
          <target state="translated">의 출력 인쇄 &lt;a href=&quot;#bdb.Breakpoint.bpformat&quot;&gt; &lt;code&gt;bpformat()&lt;/code&gt; &lt;/a&gt; 파일에 &lt;em&gt;아웃&lt;/em&gt; , 또는없는 경우 &lt;code&gt;None&lt;/code&gt; 표준 출력은.</target>
        </trans-unit>
        <trans-unit id="ce8b91aac985dd890d44d4a961ceca91f374cf43" translate="yes" xml:space="preserve">
          <source>Print the path to the user base directory.</source>
          <target state="translated">사용자 기본 디렉토리의 경로를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="9ea1420c3238a622dfc8af9460e9a233cd909099" translate="yes" xml:space="preserve">
          <source>Print the path to the user site-packages directory.</source>
          <target state="translated">사용자 사이트 패키지 디렉토리의 경로를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="d2745eb0a20cb6c1e0fa2f98f22d8ac073bd292f" translate="yes" xml:space="preserve">
          <source>Print the stack or traceback for this Task.</source>
          <target state="translated">이 작업에 대한 스택 또는 역 추적을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="cf40f8cbbb412ec036d201714e2e87709f667e28" translate="yes" xml:space="preserve">
          <source>Print the textual representation of the message object structure rooted at &lt;em&gt;msg&lt;/em&gt; to the output file specified when the &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt; instance was created.</source>
          <target state="translated">&lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 인스턴스가 작성 될 때 지정된 출력 파일 에 &lt;em&gt;msg&lt;/em&gt; 를 기반으로하는 메시지 오브젝트 구조의 텍스트 표현을 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="3736fd4a21976406b9fb9b5b2ec947f398687a95" translate="yes" xml:space="preserve">
          <source>Print the textual representation of the message object structure rooted at &lt;em&gt;msg&lt;/em&gt; to the output file specified when the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; instance was created.</source>
          <target state="translated">&lt;em&gt;msg&lt;/em&gt; 를 기반으로하는 메시지 오브젝트 구조의 텍스트 표현을 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 인스턴스 작성 시 지정된 출력 파일로 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="85716c4627d1c2ba667f0b4530240073c1a8a27b" translate="yes" xml:space="preserve">
          <source>Print the type of the &lt;em&gt;expression&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;표현식&lt;/em&gt; 의 유형을 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="de66d67e0cdcd967953b2d26ab67aebb1e502f14" translate="yes" xml:space="preserve">
          <source>Print up to &lt;em&gt;limit&lt;/em&gt; stack trace entries (starting from the invocation point) if &lt;em&gt;limit&lt;/em&gt; is positive. Otherwise, print the last &lt;code&gt;abs(limit)&lt;/code&gt; entries. If &lt;em&gt;limit&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, all entries are printed. The optional &lt;em&gt;f&lt;/em&gt; argument can be used to specify an alternate stack frame to start. The optional &lt;em&gt;file&lt;/em&gt; argument has the same meaning as for &lt;a href=&quot;#traceback.print_tb&quot;&gt;&lt;code&gt;print_tb()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">최대 인쇄 &lt;em&gt;제한&lt;/em&gt; 하는 경우 (호출 지점에서 시작) 스택 추적 항목 &lt;em&gt;제한은&lt;/em&gt; 긍정적이다. 그렇지 않으면 마지막 &lt;code&gt;abs(limit)&lt;/code&gt; 항목을 인쇄하십시오 . 경우 &lt;em&gt;제한을&lt;/em&gt; 생략하거나됩니다 &lt;code&gt;None&lt;/code&gt; , 모든 항목이 인쇄됩니다. 선택적 &lt;em&gt;f&lt;/em&gt; 인수를 사용하여 시작할 대체 스택 프레임을 지정할 수 있습니다. 선택적 &lt;em&gt;파일&lt;/em&gt; 인수는 &lt;a href=&quot;#traceback.print_tb&quot;&gt; &lt;code&gt;print_tb()&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="4430879a1bd415073f613bc0ba2cdf30ae54b218" translate="yes" xml:space="preserve">
          <source>Print up to &lt;em&gt;limit&lt;/em&gt; stack trace entries from traceback object &lt;em&gt;tb&lt;/em&gt; (starting from the caller&amp;rsquo;s frame) if &lt;em&gt;limit&lt;/em&gt; is positive. Otherwise, print the last &lt;code&gt;abs(limit)&lt;/code&gt; entries. If &lt;em&gt;limit&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, all entries are printed. If &lt;em&gt;file&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, the output goes to &lt;code&gt;sys.stderr&lt;/code&gt;; otherwise it should be an open file or file-like object to receive the output.</source>
          <target state="translated">&lt;em&gt;한계&lt;/em&gt; 가 양수 이면 트레이스 백 객체 &lt;em&gt;tb&lt;/em&gt; (호출자의 프레임에서 시작)에서 스택 추적 항목 을 &lt;em&gt;제한&lt;/em&gt; 하도록 인쇄합니다 . 그렇지 않으면 마지막 &lt;code&gt;abs(limit)&lt;/code&gt; 항목을 인쇄하십시오 . 경우 &lt;em&gt;제한을&lt;/em&gt; 생략하거나됩니다 &lt;code&gt;None&lt;/code&gt; , 모든 항목이 인쇄됩니다. 경우 &lt;em&gt;파일을&lt;/em&gt; 생략하거나한다 &lt;code&gt;None&lt;/code&gt; , 출력 간다 &lt;code&gt;sys.stderr&lt;/code&gt; 를 ; 그렇지 않으면 출력을 받기 위해 열린 파일 또는 파일과 유사한 객체 여야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43ee838f35cd5fefb189059307707fc5452dc591" translate="yes" xml:space="preserve">
          <source>Printing help</source>
          <target state="translated">인쇄 도움말</target>
        </trans-unit>
        <trans-unit id="5e3476705dcdaad7c106c25f982e98a8e8918d78" translate="yes" xml:space="preserve">
          <source>Prints a month&amp;rsquo;s calendar as returned by &lt;a href=&quot;#calendar.month&quot;&gt;&lt;code&gt;month()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#calendar.month&quot;&gt; &lt;code&gt;month()&lt;/code&gt; &lt;/a&gt; 반환 한 월 달력을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="178563981d3b66cd8dadea93b3cf517398992cf3" translate="yes" xml:space="preserve">
          <source>Prints an indented representation of the content types of the message object structure. For example:</source>
          <target state="translated">메시지 객체 구조의 내용 유형을 들여 쓰기하여 표시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90acbbd1c119c04a3ab88d76c20f94aae3ad2b33" translate="yes" xml:space="preserve">
          <source>Prints the calendar for an entire year as returned by &lt;a href=&quot;#module-calendar&quot;&gt;&lt;code&gt;calendar()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-calendar&quot;&gt; &lt;code&gt;calendar()&lt;/code&gt; &lt;/a&gt; 반환 한 연도의 달력을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="765da75ac67c7e69b1b79350da8a59b182712bf6" translate="yes" xml:space="preserve">
          <source>Prints the formatted representation of &lt;em&gt;object&lt;/em&gt; followed by a newline. If &lt;em&gt;sort_dicts&lt;/em&gt; is false (the default), dictionaries will be displayed with their keys in insertion order, otherwise the dict keys will be sorted. &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; will be passed to &lt;a href=&quot;#module-pprint&quot;&gt;&lt;code&gt;pprint()&lt;/code&gt;&lt;/a&gt; as formatting parameters.</source>
          <target state="translated">&lt;em&gt;개체&lt;/em&gt; 의 서식이 지정된 표현과 줄 바꾸기를 인쇄합니다 . 경우 &lt;em&gt;sort_dicts가&lt;/em&gt; false (기본값), 사전은 그렇지 DICT 키가 정렬됩니다, 삽입 순서에서 자신의 키와 함께 표시됩니다. &lt;em&gt;args&lt;/em&gt; 와 &lt;em&gt;kwargs&lt;/em&gt; 는 형식 매개 변수로 &lt;a href=&quot;#module-pprint&quot;&gt; &lt;code&gt;pprint()&lt;/code&gt; &lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a659c78c60d319d6e45a2e439dc3a225dde2ce3" translate="yes" xml:space="preserve">
          <source>Prints the formatted representation of &lt;em&gt;object&lt;/em&gt; on &lt;em&gt;stream&lt;/em&gt;, followed by a newline. If &lt;em&gt;stream&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;sys.stdout&lt;/code&gt; is used. This may be used in the interactive interpreter instead of the &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function for inspecting values (you can even reassign &lt;code&gt;print = pprint.pprint&lt;/code&gt; for use within a scope). &lt;em&gt;indent&lt;/em&gt;, &lt;em&gt;width&lt;/em&gt;, &lt;em&gt;depth&lt;/em&gt;, &lt;em&gt;compact&lt;/em&gt; and &lt;em&gt;sort_dicts&lt;/em&gt; will be passed to the &lt;a href=&quot;#pprint.PrettyPrinter&quot;&gt;&lt;code&gt;PrettyPrinter&lt;/code&gt;&lt;/a&gt; constructor as formatting parameters.</source>
          <target state="translated">형식화 된 &lt;em&gt;객체의&lt;/em&gt; 표현 을 &lt;em&gt;stream&lt;/em&gt; 에 인쇄하고 그 뒤에 개행을 인쇄합니다 . 경우 &lt;em&gt;스트림이&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;sys.stdout&lt;/code&gt; 이 사용됩니다. 이것은 값을 검사하기 위해 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 함수 대신 대화식 인터프리터에서 사용될 수 있습니다 ( 범위 내에서 사용하기 위해 &lt;code&gt;print = pprint.pprint&lt;/code&gt; 를 다시 지정할 수도 있습니다 ). &lt;em&gt;indent&lt;/em&gt; , &lt;em&gt;width&lt;/em&gt; , &lt;em&gt;depth&lt;/em&gt; , &lt;em&gt;compact&lt;/em&gt; 및 &lt;em&gt;sort_dicts&lt;/em&gt; 는 형식 매개 변수로 &lt;a href=&quot;#pprint.PrettyPrinter&quot;&gt; &lt;code&gt;PrettyPrinter&lt;/code&gt; &lt;/a&gt; 생성자에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e2c04dcd549cd717d09f1ffd8b8c5756396cea0" translate="yes" xml:space="preserve">
          <source>Prior to 3.0 on POSIX systems, and for all versions on Windows, if &lt;em&gt;block&lt;/em&gt; is true and &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, this operation goes into an uninterruptible wait on an underlying lock. This means that no exceptions can occur, and in particular a SIGINT will not trigger a &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX 시스템에서 3.0 이전, Windows의 모든 버전에서 &lt;em&gt;블록&lt;/em&gt; 이 참이고 &lt;em&gt;시간 종료&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우이 조작은 기본 잠금에서 인터럽트 불가능한 대기 상태가됩니다. 이는 예외가 발생하지 않으며 특히 SIGINT가 &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; 를&lt;/a&gt; 트리거하지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="28bcc1b532447f6c38e344dc91337fbe1e3f57fc" translate="yes" xml:space="preserve">
          <source>Prior to Python 3.5, these three functions comprised the high level API to subprocess. You can now use &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; in many cases, but lots of existing code calls these functions.</source>
          <target state="translated">Python 3.5 이전에는이 ​​세 가지 기능이 하위 프로세스에 대한 고급 API로 구성되었습니다. 많은 경우 &lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있지만 기존 코드가 많으면 이러한 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ee485a13f3c61d963098075b257dfa068de81844" translate="yes" xml:space="preserve">
          <source>Prior to Python 3.7, &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; was not guaranteed to be ordered, so inputs and outputs were typically scrambled unless &lt;a href=&quot;collections#collections.OrderedDict&quot;&gt;&lt;code&gt;collections.OrderedDict&lt;/code&gt;&lt;/a&gt; was specifically requested. Starting with Python 3.7, the regular &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; became order preserving, so it is no longer necessary to specify &lt;a href=&quot;collections#collections.OrderedDict&quot;&gt;&lt;code&gt;collections.OrderedDict&lt;/code&gt;&lt;/a&gt; for JSON generation and parsing.</source>
          <target state="translated">Python 3.7 이전에는 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; 의&lt;/a&gt; 순서가 보장되지 않았으므로 &lt;a href=&quot;collections#collections.OrderedDict&quot;&gt; &lt;code&gt;collections.OrderedDict&lt;/code&gt; &lt;/a&gt; 이 없으면 입력 및 출력이 일반적으로 스크램블되었습니다 .OrderedDict 가 특별히 요청되었습니다. Python 3.7부터 일반 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 은 순서 보존이되었으므로 더 이상 &lt;a href=&quot;collections#collections.OrderedDict&quot;&gt; &lt;code&gt;collections.OrderedDict&lt;/code&gt; &lt;/a&gt; 을 지정할 필요가 없습니다 . JSON 생성 및 구문 분석을위한 OrderedDict.</target>
        </trans-unit>
        <trans-unit id="ce7b4f6920821f37a53df961801a5e76cb98bc7b" translate="yes" xml:space="preserve">
          <source>Prior to Python 3.8, the serialisation order of the XML attributes of elements was artificially made predictable by sorting the attributes by their name. Based on the now guaranteed ordering of dicts, this arbitrary reordering was removed in Python 3.8 to preserve the order in which attributes were originally parsed or created by user code.</source>
          <target state="translated">Python 3.8 이전에는 속성을 이름별로 정렬하여 요소의 XML 속성의 직렬화 순서를 인위적으로 예측할 수있었습니다. 현재 보장 된 dict 순서를 기반으로,이 임의 순서는 Python 3.8에서 제거되어 속성이 원래 사용자 코드에 의해 구문 분석되거나 작성된 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d1fe312f536bf4e754308dab9f406009132a4bfe" translate="yes" xml:space="preserve">
          <source>Priority Queue</source>
          <target state="translated">우선 순위 대기열</target>
        </trans-unit>
        <trans-unit id="340b6eb8ddb73074dc88d13b36b6daa62750be5f" translate="yes" xml:space="preserve">
          <source>Priority Queue Implementation Notes</source>
          <target state="translated">우선 순위 큐 구현 정보</target>
        </trans-unit>
        <trans-unit id="379a4e214d829e53c41f4b3c44bc18e9da1723bc" translate="yes" xml:space="preserve">
          <source>Priority data band can be read.</source>
          <target state="translated">우선 순위 데이터 대역을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14288e0ca4847b33646fff4072490e000fefb7c7" translate="yes" xml:space="preserve">
          <source>Priority data may be written.</source>
          <target state="translated">우선 순위 데이터가 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7053edee96c0d878acb0f63f6bb849325088c6" translate="yes" xml:space="preserve">
          <source>Priority levels (high to low):</source>
          <target state="translated">우선 순위 수준 (높음에서 낮음) :</target>
        </trans-unit>
        <trans-unit id="42112cc384558a53635559f800e7234355ea8345" translate="yes" xml:space="preserve">
          <source>Private, abstract base class for pointers.</source>
          <target state="translated">포인터를위한 전용의 추상 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="fe0ab232aea403475c4f5484cfb3291f7dcd50a9" translate="yes" xml:space="preserve">
          <source>Probably the best way of solving the problem is to add class attributes as default values for instance members initialised in &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;. Note that if you are only setting default attributes in &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; then providing them via class attributes (shared between instances of course) is faster too. e.g.</source>
          <target state="translated">아마도 문제를 해결하는 가장 좋은 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 에서 초기화 된 인스턴스 멤버의 기본값으로 클래스 속성을 추가하는 것 입니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 에서 기본 속성 만 설정하는 경우 클래스 속성 (물론 인스턴스간에 공유 됨 ) 을 통해 제공하는 것이 더 빠릅니다. 예 :</target>
        </trans-unit>
        <trans-unit id="82a3f6d4a767ee85079d7f46fcb38e6d4bd370e6" translate="yes" xml:space="preserve">
          <source>Process HTTP error responses.</source>
          <target state="translated">HTTP 오류 응답을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="e8e0ada6a5ef6d292d2c93e408caca1ecb42b186" translate="yes" xml:space="preserve">
          <source>Process HTTPS error responses.</source>
          <target state="translated">HTTPS 오류 응답을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="66b1085d2893b19ca61ed0f1a8614ff7c20c8fa9" translate="yes" xml:space="preserve">
          <source>Process ID (if available).</source>
          <target state="translated">프로세스 ID (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="1f5a86d996fe41cd28ad8ea8df3b57c8d1e99153" translate="yes" xml:space="preserve">
          <source>Process Management</source>
          <target state="translated">공정 관리</target>
        </trans-unit>
        <trans-unit id="01df6eb3a4c83ebf34a899c278995155dd9de5c0" translate="yes" xml:space="preserve">
          <source>Process Parameters</source>
          <target state="translated">공정 파라미터</target>
        </trans-unit>
        <trans-unit id="f72f6213bcbf7742acdadc7f46dc0bee1131e9f2" translate="yes" xml:space="preserve">
          <source>Process Pools</source>
          <target state="translated">프로세스 풀</target>
        </trans-unit>
        <trans-unit id="9b86d892e46fbebbb16792b6ab58f8396eb7c342" translate="yes" xml:space="preserve">
          <source>Process Watchers</source>
          <target state="translated">프로세스 감시자</target>
        </trans-unit>
        <trans-unit id="b32cff3bc6a5689bdcb0bac71d092e2dc71583f8" translate="yes" xml:space="preserve">
          <source>Process a chunk of &lt;em&gt;data&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;데이터&lt;/em&gt; 청크를 &lt;em&gt;처리&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="947bfb22e72ecdaf6739dda63b55ef088ecd95cc" translate="yes" xml:space="preserve">
          <source>Process a single command keystroke. Here are the supported special keystrokes:</source>
          <target state="translated">단일 명령 키 입력을 처리하십시오. 지원되는 특수 키 입력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f96a65904dd29e5de1a41c2873eb6109ff1be6f8" translate="yes" xml:space="preserve">
          <source>Process a single request. This function calls the following methods in order: &lt;a href=&quot;#socketserver.BaseServer.get_request&quot;&gt;&lt;code&gt;get_request()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#socketserver.BaseServer.verify_request&quot;&gt;&lt;code&gt;verify_request()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#socketserver.BaseServer.process_request&quot;&gt;&lt;code&gt;process_request()&lt;/code&gt;&lt;/a&gt;. If the user-provided &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt;&lt;code&gt;handle()&lt;/code&gt;&lt;/a&gt; method of the handler class raises an exception, the server&amp;rsquo;s &lt;a href=&quot;#socketserver.BaseServer.handle_error&quot;&gt;&lt;code&gt;handle_error()&lt;/code&gt;&lt;/a&gt; method will be called. If no request is received within &lt;a href=&quot;#socketserver.BaseServer.timeout&quot;&gt;&lt;code&gt;timeout&lt;/code&gt;&lt;/a&gt; seconds, &lt;a href=&quot;#socketserver.BaseServer.handle_timeout&quot;&gt;&lt;code&gt;handle_timeout()&lt;/code&gt;&lt;/a&gt; will be called and &lt;a href=&quot;#socketserver.BaseServer.handle_request&quot;&gt;&lt;code&gt;handle_request()&lt;/code&gt;&lt;/a&gt; will return.</source>
          <target state="translated">단일 요청을 처리하십시오. 이 함수는 &lt;a href=&quot;#socketserver.BaseServer.get_request&quot;&gt; &lt;code&gt;get_request()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#socketserver.BaseServer.verify_request&quot;&gt; &lt;code&gt;verify_request()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socketserver.BaseServer.process_request&quot;&gt; &lt;code&gt;process_request()&lt;/code&gt; &lt;/a&gt; 순서로 메소드를 호출합니다 . 핸들러 클래스 의 사용자 제공 &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt; &lt;code&gt;handle()&lt;/code&gt; &lt;/a&gt; 메소드에서 예외가 발생하면 서버의 &lt;a href=&quot;#socketserver.BaseServer.handle_error&quot;&gt; &lt;code&gt;handle_error()&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. &lt;a href=&quot;#socketserver.BaseServer.timeout&quot;&gt; &lt;code&gt;timeout&lt;/code&gt; &lt;/a&gt; 초) 내에 요청이 수신되지 않으면 &lt;a href=&quot;#socketserver.BaseServer.handle_timeout&quot;&gt; &lt;code&gt;handle_timeout()&lt;/code&gt; &lt;/a&gt; 이 호출되고 &lt;a href=&quot;#socketserver.BaseServer.handle_request&quot;&gt; &lt;code&gt;handle_request()&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b1c507d17a8072014891e2d12127e007cafa17a7" translate="yes" xml:space="preserve">
          <source>Process an input source, producing SAX events. The &lt;em&gt;source&lt;/em&gt; object can be a system identifier (a string identifying the input source &amp;ndash; typically a file name or a URL), a &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object, or an &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; object. When &lt;a href=&quot;#xml.sax.xmlreader.XMLReader.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; returns, the input is completely processed, and the parser object can be discarded or reset.</source>
          <target state="translated">SAX 이벤트를 생성하여 입력 소스를 처리하십시오. &lt;em&gt;소스&lt;/em&gt; , A - 객체는 시스템 식별자 (일반적으로 파일명 또는 URL 입력 소스를 식별하는 문자열) 일 수 &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은&lt;/a&gt; 물체, 또는 &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; 의의&lt;/a&gt; 개체. 경우 &lt;a href=&quot;#xml.sax.xmlreader.XMLReader.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 반환 입력이 완전히 처리되고, 파서 객체가 삭제 또는 리셋된다.</target>
        </trans-unit>
        <trans-unit id="2b311ad25d1db62875cc54150c554d28f143828c" translate="yes" xml:space="preserve">
          <source>Process and return data already in the queues (lazy).</source>
          <target state="translated">이미 대기열에있는 데이터를 처리하고 반환합니다 (lazy).</target>
        </trans-unit>
        <trans-unit id="b3599943b558766e7f19245507d6887c0663d872" translate="yes" xml:space="preserve">
          <source>Process identification number (PID).</source>
          <target state="translated">프로세스 식별 번호 (PID).</target>
        </trans-unit>
        <trans-unit id="297f39b6d2abdfdb1292f997173731b0fddec52a" translate="yes" xml:space="preserve">
          <source>Process name (if available).</source>
          <target state="translated">프로세스 이름 (사용 가능한 경우).</target>
        </trans-unit>
        <trans-unit id="4f0cc309bda79cb8d9bbf8927c6dcb4228a77c6c" translate="yes" xml:space="preserve">
          <source>Process objects represent activity that is run in a separate process. The &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; class has equivalents of all the methods of &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스 개체는 별도의 프로세스에서 실행되는 활동을 나타냅니다. &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 클래스의 모든 메소드의 등가물이 &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2952edfd580aa8a664a3ded614d8f10340a237d" translate="yes" xml:space="preserve">
          <source>Process the HTTP request. The default implementation creates a handler instance using a &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt;&lt;code&gt;wsgiref.handlers&lt;/code&gt;&lt;/a&gt; class to implement the actual WSGI application interface.</source>
          <target state="translated">HTTP 요청을 처리하십시오. 기본 구현은 실제 WSGI 애플리케이션 인터페이스를 구현하기 위해 &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt; &lt;code&gt;wsgiref.handlers&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 핸들러 인스턴스를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="b9f4c1da0a6f95349d5b7cab6bfc3e5d901e4edc" translate="yes" xml:space="preserve">
          <source>ProcessLookupError</source>
          <target state="translated">ProcessLookupError</target>
        </trans-unit>
        <trans-unit id="d4da8a798d14724a0caf5b1f84fe71ed27bd4ff8" translate="yes" xml:space="preserve">
          <source>ProcessPoolExecutor</source>
          <target state="translated">ProcessPoolExecutor</target>
        </trans-unit>
        <trans-unit id="e1cea46436f44b1ca5b79450691e62e489cd9c5c" translate="yes" xml:space="preserve">
          <source>ProcessPoolExecutor Example</source>
          <target state="translated">ProcessPoolExecutor 예제</target>
        </trans-unit>
        <trans-unit id="94bb652c9572461a974b5f2114bbee99c0f0b7ed" translate="yes" xml:space="preserve">
          <source>Processes formatting specifiers as in &lt;code&gt;format % val&lt;/code&gt;, but takes the current locale settings into account.</source>
          <target state="translated">&lt;code&gt;format % val&lt;/code&gt; 형식 지정자를 처리 하지만 현재 로케일 설정을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="21f10da205ad95c538599dfb2cba2ce2d07eb428" translate="yes" xml:space="preserve">
          <source>Processing instruction representation.</source>
          <target state="translated">명령 표현 처리</target>
        </trans-unit>
        <trans-unit id="89856bf9806f209990cb1b3750df87125c96da8a" translate="yes" xml:space="preserve">
          <source>ProcessingInstruction Objects</source>
          <target state="translated">명령 객체 처리</target>
        </trans-unit>
        <trans-unit id="84a5556631d8395e80b4ddd01a2e3c3735e1fc89" translate="yes" xml:space="preserve">
          <source>Produce a directory listing as returned by the &lt;code&gt;LIST&lt;/code&gt; command, printing it to standard output. The optional &lt;em&gt;argument&lt;/em&gt; is a directory to list (default is the current server directory). Multiple arguments can be used to pass non-standard options to the &lt;code&gt;LIST&lt;/code&gt; command. If the last argument is a function, it is used as a &lt;em&gt;callback&lt;/em&gt; function as for &lt;a href=&quot;#ftplib.FTP.retrlines&quot;&gt;&lt;code&gt;retrlines()&lt;/code&gt;&lt;/a&gt;; the default prints to &lt;code&gt;sys.stdout&lt;/code&gt;. This method returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LIST&lt;/code&gt; 명령 으로 리턴 된 디렉토리 목록을 작성 하여 표준 출력으로 인쇄하십시오. 선택적 &lt;em&gt;인수&lt;/em&gt; 는 나열 할 디렉토리입니다 (기본값은 현재 서버 디렉토리 임). 비표준 옵션을 &lt;code&gt;LIST&lt;/code&gt; 명령 에 전달하는 데 여러 인수를 사용할 수 있습니다 . 마지막 인수가 함수이면 &lt;a href=&quot;#ftplib.FTP.retrlines&quot;&gt; &lt;code&gt;retrlines()&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;em&gt;콜백&lt;/em&gt; 함수로 사용됩니다 . 기본값은 &lt;code&gt;sys.stdout&lt;/code&gt; 에 인쇄됩니다 . 이 메소드는 &lt;code&gt;None&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ee2e28d2f8fb31da49f40174236d2b632dbd76de" translate="yes" xml:space="preserve">
          <source>Produce a set of annotated listing files upon program completion that shows how many times each statement was executed. See also &lt;a href=&quot;#cmdoption-trace-coverdir&quot;&gt;&lt;code&gt;--coverdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#cmdoption-trace-f&quot;&gt;&lt;code&gt;--file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#cmdoption-trace-no-report&quot;&gt;&lt;code&gt;--no-report&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">프로그램 완료시 각 명령문이 실행 된 횟수를 표시하는 주석이 달린 리스팅 파일 세트를 생성하십시오. 아래의 &lt;a href=&quot;#cmdoption-trace-coverdir&quot;&gt; &lt;code&gt;--coverdir&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#cmdoption-trace-f&quot;&gt; &lt;code&gt;--file&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cmdoption-trace-no-report&quot;&gt; &lt;code&gt;--no-report&lt;/code&gt; 를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61b62b4918483f7d1f903deb8e344d1eb90bc205" translate="yes" xml:space="preserve">
          <source>Produce an annotated list from an earlier program run that used the &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#cmdoption-trace-f&quot;&gt;&lt;code&gt;--file&lt;/code&gt;&lt;/a&gt; option. This does not execute any code.</source>
          <target state="translated">&lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cmdoption-trace-f&quot;&gt; &lt;code&gt;--file&lt;/code&gt; &lt;/a&gt; 옵션 을 사용한 이전 프로그램 실행에서 주석이 달린 목록을 생성하십시오 . 이것은 코드를 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6206021551dc337089d35c15bdfd762b397d0ed" translate="yes" xml:space="preserve">
          <source>Producing more informative usage messages.</source>
          <target state="translated">보다 유익한 사용법 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b1a89bbc60ade6c8211d72a39eee477320394916" translate="yes" xml:space="preserve">
          <source>Profile &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;</source>
          <target state="translated">프로파일 &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ab5817ee3a38bdd3960784eebb66b96fdd8be97" translate="yes" xml:space="preserve">
          <source>Profile functions should have three arguments: &lt;em&gt;frame&lt;/em&gt;, &lt;em&gt;event&lt;/em&gt;, and &lt;em&gt;arg&lt;/em&gt;. &lt;em&gt;frame&lt;/em&gt; is the current stack frame. &lt;em&gt;event&lt;/em&gt; is a string: &lt;code&gt;'call'&lt;/code&gt;, &lt;code&gt;'return'&lt;/code&gt;, &lt;code&gt;'c_call'&lt;/code&gt;, &lt;code&gt;'c_return'&lt;/code&gt;, or &lt;code&gt;'c_exception'&lt;/code&gt;. &lt;em&gt;arg&lt;/em&gt; depends on the event type.</source>
          <target state="translated">프로파일 함수에는 &lt;em&gt;frame&lt;/em&gt; , &lt;em&gt;event&lt;/em&gt; 및 &lt;em&gt;arg의&lt;/em&gt; 세 가지 인수가 있어야합니다 . &lt;em&gt;frame&lt;/em&gt; 은 현재 스택 프레임입니다. &lt;em&gt;이벤트&lt;/em&gt; 는 &lt;code&gt;'call'&lt;/code&gt; , &lt;code&gt;'return'&lt;/code&gt; , &lt;code&gt;'c_call'&lt;/code&gt; , &lt;code&gt;'c_return'&lt;/code&gt; 또는 &lt;code&gt;'c_exception'&lt;/code&gt; 문자열 입니다. &lt;em&gt;arg&lt;/em&gt; 는 이벤트 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="76b85f64e42b75db85f6100c7446f9839a6a7ea4" translate="yes" xml:space="preserve">
          <source>Profile the cmd via &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; with the specified global and local environment.</source>
          <target state="translated">지정된 전역 및 로컬 환경으로 &lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 를 통해 cmd를 프로파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="36dda3343a7263d4db5c33b4996d45f6d08108ef" translate="yes" xml:space="preserve">
          <source>Profile the cmd via &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 를 통해 cmd를 프로파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="95bd58802dc1b81dce30791a9d8256f51f58596b" translate="yes" xml:space="preserve">
          <source>Program Frameworks</source>
          <target state="translated">프로그램 프레임 워크</target>
        </trans-unit>
        <trans-unit id="29732f847c3e72f38557e028f82b286984b79cf6" translate="yes" xml:space="preserve">
          <source>Programmatic Interface</source>
          <target state="translated">프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="0cc5a8683e649a82320f81d8b98ad22b1224bb2a" translate="yes" xml:space="preserve">
          <source>Programmatic access to enumeration members and their attributes</source>
          <target state="translated">열거 형 멤버 및 해당 특성에 프로그래밍 방식으로 액세스</target>
        </trans-unit>
        <trans-unit id="43946ee36367ff5b56dd7206534999a5f9bb2e0c" translate="yes" xml:space="preserve">
          <source>Programmatic importing of modules should use &lt;a href=&quot;#importlib.import_module&quot;&gt;&lt;code&gt;import_module()&lt;/code&gt;&lt;/a&gt; instead of this function.</source>
          <target state="translated">프로그래밍 방식으로 모듈을 가져 오려면 이 함수 대신 &lt;a href=&quot;#importlib.import_module&quot;&gt; &lt;code&gt;import_module()&lt;/code&gt; &lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="582a71e5cde8061e90cf7cb11216069f82272cfa" translate="yes" xml:space="preserve">
          <source>Programming Python</source>
          <target state="translated">파이썬 프로그래밍</target>
        </trans-unit>
        <trans-unit id="cbb1703ad983064d7b0e59271c23ac61fd18453b" translate="yes" xml:space="preserve">
          <source>Programming guidelines</source>
          <target state="translated">프로그래밍 지침</target>
        </trans-unit>
        <trans-unit id="7da030583783017b4f69be08fb0b0b0892cc669d" translate="yes" xml:space="preserve">
          <source>Progressbar</source>
          <target state="translated">Progressbar</target>
        </trans-unit>
        <trans-unit id="3277e9d5cb2ea7675324d81b2435cfeab83add48" translate="yes" xml:space="preserve">
          <source>Prompt server for an update. Returned data is &lt;code&gt;None&lt;/code&gt; if no new messages, else value of &lt;code&gt;RECENT&lt;/code&gt; response.</source>
          <target state="translated">업데이트를위한 프롬프트 서버. 새 메시지가 없으면 리턴 된 데이터는 &lt;code&gt;None&lt;/code&gt; 이며, 그렇지 않으면 &lt;code&gt;RECENT&lt;/code&gt; 응답의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="36ea9c97c82e09c4c66355ad465d29262386380c" translate="yes" xml:space="preserve">
          <source>Prompt the user for a password without echoing. The user is prompted using the string &lt;em&gt;prompt&lt;/em&gt;, which defaults to &lt;code&gt;'Password: '&lt;/code&gt;. On Unix, the prompt is written to the file-like object &lt;em&gt;stream&lt;/em&gt; using the replace error handler if needed. &lt;em&gt;stream&lt;/em&gt; defaults to the controlling terminal (&lt;code&gt;/dev/tty&lt;/code&gt;) or if that is unavailable to &lt;code&gt;sys.stderr&lt;/code&gt; (this argument is ignored on Windows).</source>
          <target state="translated">에코하지 않고 사용자에게 비밀번호를 묻습니다. 문자열 &lt;em&gt;프롬프트를&lt;/em&gt; 사용하여 사용자에게 &lt;em&gt;프롬프트&lt;/em&gt; 되며 기본값은 &lt;code&gt;'Password: '&lt;/code&gt; 입니다. 유닉스에서, 프롬프트는 필요한 경우 바꾸기 오류 처리기를 사용하여 파일과 같은 객체 &lt;em&gt;스트림에&lt;/em&gt; 기록됩니다 . &lt;em&gt;스트림의&lt;/em&gt; 기본값은 제어 터미널 ( &lt;code&gt;/dev/tty&lt;/code&gt; ) 또는 &lt;code&gt;sys.stderr&lt;/code&gt; 에서 사용할 수없는 경우 (이 인수는 Windows에서 무시 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="588169426c8d1fa7e44bc9a3ff15982cdbfaaa90" translate="yes" xml:space="preserve">
          <source>Property returning a new &lt;a href=&quot;#collections.ChainMap&quot;&gt;&lt;code&gt;ChainMap&lt;/code&gt;&lt;/a&gt; containing all of the maps in the current instance except the first one. This is useful for skipping the first map in the search. Use cases are similar to those for the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#nonlocal&quot;&gt;&lt;code&gt;nonlocal&lt;/code&gt;&lt;/a&gt; keyword used in &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-nested-scope&quot;&gt;nested scopes&lt;/a&gt;. The use cases also parallel those for the built-in &lt;a href=&quot;functions#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; function. A reference to &lt;code&gt;d.parents&lt;/code&gt; is equivalent to: &lt;code&gt;ChainMap(*d.maps[1:])&lt;/code&gt;.</source>
          <target state="translated">현재 인스턴스의 첫 번째 맵을 제외한 모든 맵이 포함 된 새 &lt;a href=&quot;#collections.ChainMap&quot;&gt; &lt;code&gt;ChainMap&lt;/code&gt; &lt;/a&gt; 을 반환하는 속성 입니다. 검색에서 첫 번째 맵을 건너 뛸 때 유용합니다. 사용 사례는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-nested-scope&quot;&gt;중첩 된 범위&lt;/a&gt; 에서 사용되는 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#nonlocal&quot;&gt; &lt;code&gt;nonlocal&lt;/code&gt; &lt;/a&gt; 키워드의 사용 사례와 유사합니다 . 사용 사례는 내장 &lt;a href=&quot;functions#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 함수 의 사용 사례와 유사 합니다. &lt;code&gt;d.parents&lt;/code&gt; 에 대한 참조 는 &lt;code&gt;ChainMap(*d.maps[1:])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77a1661ff20d05707d028062bc86d9655da030da" translate="yes" xml:space="preserve">
          <source>Property which is true if the finalizer is alive, false otherwise.</source>
          <target state="translated">종료자가 살아 있으면 true이고, 그렇지 않으면 false 인 속성입니다.</target>
        </trans-unit>
        <trans-unit id="b71393da154d6654d013fdbe1762a139d1f0c832" translate="yes" xml:space="preserve">
          <source>Protect an &lt;a href=&quot;#asyncio-awaitables&quot;&gt;awaitable object&lt;/a&gt; from being &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt;&lt;code&gt;cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#asyncio-awaitables&quot;&gt;대기 가능한 객체&lt;/a&gt; 가 &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt; &lt;code&gt;cancelled&lt;/code&gt; &lt;/a&gt; 되지 않도록 보호합니다 .</target>
        </trans-unit>
        <trans-unit id="8770cb52bfc12f5c8b944d6be182d7850b41eb42" translate="yes" xml:space="preserve">
          <source>Protected mode</source>
          <target state="translated">보호 모드</target>
        </trans-unit>
        <trans-unit id="02ca74fb7fe36d1ec1ff43755c49fa63ad40ee48" translate="yes" xml:space="preserve">
          <source>Protocol classes can be generic, for example:</source>
          <target state="translated">프로토콜 클래스는 일반적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc9e334f823b2be75b5b8c5ea9906ea9c0b08817" translate="yes" xml:space="preserve">
          <source>Protocol classes can implement the following &lt;strong&gt;callback methods&lt;/strong&gt;:</source>
          <target state="translated">프로토콜 클래스는 다음과 같은 &lt;strong&gt;콜백 메소드를&lt;/strong&gt; 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5889cf55d9c9ddf964af330c62999831d5864d" translate="yes" xml:space="preserve">
          <source>Protocol definition for SMTP. This document covers the model, operating procedure, and protocol details for SMTP.</source>
          <target state="translated">SMTP에 대한 프로토콜 정의. 이 문서는 SMTP 모델, 운영 절차 및 프로토콜 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="0eefce21e56451e311edc639e53ac4594f96d85d" translate="yes" xml:space="preserve">
          <source>Protocol driver not attached</source>
          <target state="translated">프로토콜 드라이버가 연결되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="a31583107f763ed101ab870682277a15652cc1cb" translate="yes" xml:space="preserve">
          <source>Protocol error</source>
          <target state="translated">프로토콜 오류</target>
        </trans-unit>
        <trans-unit id="677789471bfc26b9baa2dcb7bdc1e90f13c9beac" translate="yes" xml:space="preserve">
          <source>Protocol family not supported</source>
          <target state="translated">지원되지 않는 프로토콜 제품군</target>
        </trans-unit>
        <trans-unit id="59bb2975367cf35f9a618efe163f6de98389a1c2" translate="yes" xml:space="preserve">
          <source>Protocol not available</source>
          <target state="translated">사용할 수없는 프로토콜</target>
        </trans-unit>
        <trans-unit id="05ba63ff22fffa946a6c1e3e8b9d184a5a911e55" translate="yes" xml:space="preserve">
          <source>Protocol not supported</source>
          <target state="translated">프로토콜이 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="66c27fe46bd114d55a64e98115a7040327f4a014" translate="yes" xml:space="preserve">
          <source>Protocol version 0 is the original &amp;ldquo;human-readable&amp;rdquo; protocol and is backwards compatible with earlier versions of Python.</source>
          <target state="translated">프로토콜 버전 0은 원래 &quot;사람이 읽을 수있는&quot;프로토콜이며 이전 버전의 Python과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="9f1b19752041a2f953f426891837b895ba0ec61a" translate="yes" xml:space="preserve">
          <source>Protocol version 1 is an old binary format which is also compatible with earlier versions of Python.</source>
          <target state="translated">프로토콜 버전 1은 이전 이진 형식이며 이전 버전의 Python 과도 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="b0b436e92f55285dbba9fe3ed7783a21924f5fb8" translate="yes" xml:space="preserve">
          <source>Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-new-style-class&quot;&gt;new-style class&lt;/a&gt;es. Refer to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0307&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 307&lt;/strong&gt;&lt;/a&gt; for information about improvements brought by protocol 2.</source>
          <target state="translated">프로토콜 버전 2는 Python 2.3에서 도입되었습니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-new-style-class&quot;&gt;새로운 스타일의 클래스를&lt;/a&gt; 훨씬 더 효율적으로 산 세척 합니다. 프로토콜 2의 개선 사항에 대한 정보는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0307&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 307&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d89cbdf33a6f12fe68fa41e5d62e69604f5f111" translate="yes" xml:space="preserve">
          <source>Protocol version 3 was added in Python 3.0. It has explicit support for &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects and cannot be unpickled by Python 2.x. This was the default protocol in Python 3.0&amp;ndash;3.7.</source>
          <target state="translated">프로토콜 버전 3은 Python 3.0에서 추가되었습니다. &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 명시 적으로 지원하며 Python 2.x에서 피클 링 할 수 없습니다. 이것은 Python 3.0&amp;ndash;3.7의 기본 프로토콜입니다.</target>
        </trans-unit>
        <trans-unit id="167932e2e331e862375a10551050e9f26a28976e" translate="yes" xml:space="preserve">
          <source>Protocol version 4 was added in Python 3.4. It adds support for very large objects, pickling more kinds of objects, and some data format optimizations. It is the default protocol starting with Python 3.8. Refer to &lt;a href=&quot;https://www.python.org/dev/peps/pep-3154&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3154&lt;/strong&gt;&lt;/a&gt; for information about improvements brought by protocol 4.</source>
          <target state="translated">프로토콜 버전 4는 Python 3.4에서 추가되었습니다. 매우 큰 객체, 더 많은 종류의 객체 및 일부 데이터 형식 최적화를 지원합니다. Python 3.8로 시작하는 기본 프로토콜입니다. 프로토콜 4의 개선 사항에 대한 정보는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3154&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3154&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="caac2daa3b9e8785152f90bfa59fc39dc69b7cb8" translate="yes" xml:space="preserve">
          <source>Protocol version 5 was added in Python 3.8. It adds support for out-of-band data and speedup for in-band data. Refer to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0574&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;PEP 574&lt;/strong&gt;&lt;/a&gt; for information about improvements brought by protocol 5.</source>
          <target state="translated">프로토콜 버전 5는 Python 3.8에서 추가되었습니다. 대역 외 데이터에 대한 지원 및 대역 내 데이터에 대한 속도 향상을 추가합니다. 프로토콜 5의 개선 사항에 대한 정보는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0574&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;PEP 574&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1202f606b2e32bbc3d0fddceda6783cc8a6fb033" translate="yes" xml:space="preserve">
          <source>Protocol versions</source>
          <target state="translated">프로토콜 버전</target>
        </trans-unit>
        <trans-unit id="3ff5f085a157b60cb28dba0860f39cd3e12b11e1" translate="yes" xml:space="preserve">
          <source>Protocol wrong type for socket</source>
          <target state="translated">소켓에 대한 프로토콜 유형이 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="dd901073191ed23827708d5ff40ed845574f0ca7" translate="yes" xml:space="preserve">
          <source>ProtocolError Objects</source>
          <target state="translated">ProtocolError 객체</target>
        </trans-unit>
        <trans-unit id="2a6e3082f7bd2a56b001fbb1624e361e5599002d" translate="yes" xml:space="preserve">
          <source>Protocols</source>
          <target state="translated">Protocols</target>
        </trans-unit>
        <trans-unit id="6c9370254ccd0ba3c533df6eb04115252a887895" translate="yes" xml:space="preserve">
          <source>Provide a per-write equivalent of the &lt;a href=&quot;#os.O_DSYNC&quot;&gt;&lt;code&gt;O_DSYNC&lt;/code&gt;&lt;/a&gt;&lt;code&gt;open(2)&lt;/code&gt; flag. This flag effect applies only to the data range written by the system call.</source>
          <target state="translated">&lt;a href=&quot;#os.O_DSYNC&quot;&gt; &lt;code&gt;O_DSYNC&lt;/code&gt; &lt;/a&gt; &lt;code&gt;open(2)&lt;/code&gt; 플래그 와 동등한 쓰기 당을 제공하십시오 . 이 플래그 효과는 시스템 호출로 작성된 데이터 범위에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f731e3836b43c76e6eb956ae15aaec713f209063" translate="yes" xml:space="preserve">
          <source>Provide a per-write equivalent of the &lt;a href=&quot;#os.O_SYNC&quot;&gt;&lt;code&gt;O_SYNC&lt;/code&gt;&lt;/a&gt;&lt;code&gt;open(2)&lt;/code&gt; flag. This flag effect applies only to the data range written by the system call.</source>
          <target state="translated">&lt;a href=&quot;#os.O_SYNC&quot;&gt; &lt;code&gt;O_SYNC&lt;/code&gt; &lt;/a&gt; &lt;code&gt;open(2)&lt;/code&gt; 플래그 와 동등한 쓰기 당을 제공하십시오 . 이 플래그 효과는 시스템 호출로 작성된 데이터 범위에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dee6bd9f4cdf3cd7282713ec5dcb4df91afa967f" translate="yes" xml:space="preserve">
          <source>Provide basic introspection for generic types and special typing forms.</source>
          <target state="translated">제네릭 형식과 특수한 타이핑 형식에 대한 기본적인 내부 검사를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="25d9907a6882636abf50f5974e10c9b5af617618" translate="yes" xml:space="preserve">
          <source>Provide data to the compressor object. Returns a chunk of compressed data if possible, or an empty byte string otherwise.</source>
          <target state="translated">압축기 개체에 데이터를 제공하십시오. 가능하면 압축 된 데이터 덩어리를 반환하고, 그렇지 않으면 빈 바이트 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="370dad65015117426ba525e495fbbfdd82d208f2" translate="yes" xml:space="preserve">
          <source>Provider API</source>
          <target state="translated">공급자 API</target>
        </trans-unit>
        <trans-unit id="778e9e5642a2d090654969214e90a85ebd83e83d" translate="yes" xml:space="preserve">
          <source>Provides (for &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt; vectors, &lt;em&gt;k&lt;/em&gt; number):</source>
          <target state="translated">제공합니다 ( &lt;em&gt;a&lt;/em&gt; , &lt;em&gt;b&lt;/em&gt; 벡터, &lt;em&gt;k&lt;/em&gt; 숫자) :</target>
        </trans-unit>
        <trans-unit id="1956b5072d57097ccefc1302702b4e99efeb926e" translate="yes" xml:space="preserve">
          <source>Provides a dictionary, based on &lt;code&gt;record&lt;/code&gt;, which is to be URL-encoded and sent to the web server. The default implementation just returns &lt;code&gt;record.__dict__&lt;/code&gt;. This method can be overridden if e.g. only a subset of &lt;a href=&quot;logging#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; is to be sent to the web server, or if more specific customization of what&amp;rsquo;s sent to the server is required.</source>
          <target state="translated">URL 기반으로 인코딩되어 웹 서버로 전송 될 &lt;code&gt;record&lt;/code&gt; 기반 사전을 제공 합니다. 기본 구현은 단지 &lt;code&gt;record.__dict__&lt;/code&gt; 반환합니다 . 예를 들어 &lt;a href=&quot;logging#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 의 하위 집합 만 웹 서버로 보내거나 서버로 보낸 내용을보다 구체적으로 사용자 지정해야하는 경우이 방법을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c072b53c7e573480587a748eb43bae4c740a2472" translate="yes" xml:space="preserve">
          <source>Provides a mutable list-like object where all values stored within are stored in a shared memory block. This constrains storable values to only the &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt; (less than 10M bytes each), &lt;code&gt;bytes&lt;/code&gt; (less than 10M bytes each), and &lt;code&gt;None&lt;/code&gt; built-in data types. It also notably differs from the built-in &lt;code&gt;list&lt;/code&gt; type in that these lists can not change their overall length (i.e. no append, insert, etc.) and do not support the dynamic creation of new &lt;a href=&quot;#multiprocessing.shared_memory.ShareableList&quot;&gt;&lt;code&gt;ShareableList&lt;/code&gt;&lt;/a&gt; instances via slicing.</source>
          <target state="translated">내부에 저장된 모든 값이 공유 메모리 블록에 저장되는 변경 가능한 목록 유사 객체를 제공합니다. 이는 저장 가능 값을 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;str&lt;/code&gt; (각각 10M 바이트 미만), &lt;code&gt;bytes&lt;/code&gt; (각각 10M 바이트 미만) 및 내장 데이터 유형 &lt;code&gt;None&lt;/code&gt; 합니다. 또한 &lt;code&gt;list&lt;/code&gt; 의 전체 길이를 변경할 수없고 (예 : 추가, 삽입 등) 슬라이싱을 통한 새 &lt;a href=&quot;#multiprocessing.shared_memory.ShareableList&quot;&gt; &lt;code&gt;ShareableList&lt;/code&gt; &lt;/a&gt; 인스턴스 의 동적 생성을 지원하지 않는다는 점에서 기본 제공 목록 유형 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="08a1afa7742389a1900345e97b7ed61c3d3364c2" translate="yes" xml:space="preserve">
          <source>Provides an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;iterator&lt;/a&gt; over all of the opcodes in a pickle, returning a sequence of &lt;code&gt;(opcode, arg, pos)&lt;/code&gt; triples. &lt;em&gt;opcode&lt;/em&gt; is an instance of an &lt;code&gt;OpcodeInfo&lt;/code&gt; class; &lt;em&gt;arg&lt;/em&gt; is the decoded value, as a Python object, of the opcode&amp;rsquo;s argument; &lt;em&gt;pos&lt;/em&gt; is the position at which this opcode is located. &lt;em&gt;pickle&lt;/em&gt; can be a string or a file-like object.</source>
          <target state="translated">피클의 모든 opcode에 대해 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;반복자&lt;/a&gt; 를 제공하여 일련의 &lt;code&gt;(opcode, arg, pos)&lt;/code&gt; 트리플을 반환합니다 . &lt;em&gt;opcode&lt;/em&gt; 는 &lt;code&gt;OpcodeInfo&lt;/code&gt; 클래스 의 인스턴스입니다 . &lt;em&gt;arg&lt;/em&gt; 는 Python 객체로서 opcode 인수의 디코딩 된 값입니다. &lt;em&gt;pos&lt;/em&gt; 는이 opcode가있는 위치입니다. &lt;em&gt;pickle&lt;/em&gt; 은 문자열 또는 파일과 같은 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da5bc34e31a7e203e61c3d0dc371e4d52c7b8b4" translate="yes" xml:space="preserve">
          <source>Provides an overriding level &lt;em&gt;level&lt;/em&gt; for all loggers which takes precedence over the logger&amp;rsquo;s own level. When the need arises to temporarily throttle logging output down across the whole application, this function can be useful. Its effect is to disable all logging calls of severity &lt;em&gt;level&lt;/em&gt; and below, so that if you call it with a value of INFO, then all INFO and DEBUG events would be discarded, whereas those of severity WARNING and above would be processed according to the logger&amp;rsquo;s effective level. If &lt;code&gt;logging.disable(logging.NOTSET)&lt;/code&gt; is called, it effectively removes this overriding level, so that logging output again depends on the effective levels of individual loggers.</source>
          <target state="translated">로거 자체 레벨보다 우선하는 모든 로거에 우선 순위 &lt;em&gt;레벨&lt;/em&gt; 을 제공합니다 . 전체 응용 프로그램에서 로깅 출력을 일시적으로 제한해야 할 경우이 기능이 유용 할 수 있습니다. 그 결과는 심각도 &lt;em&gt;수준&lt;/em&gt; 이하 의 모든 로깅 호출을 비활성화 하여 값을 INFO로 호출하면 모든 INFO 및 DEBUG 이벤트가 삭제되는 반면 심각도 경고 이상의 이벤트는 로거에 따라 처리됩니다. 효과적인 수준. 만약 &lt;code&gt;logging.disable(logging.NOTSET)&lt;/code&gt; 이 로깅 출력을 다시 개별 로거의 유효 수준에 따라 소위되어, 효과적으로,이 겹쳐 레벨을 제거한다.</target>
        </trans-unit>
        <trans-unit id="4199b1324e6bc5b4d37525ed1a37df751d8d1273" translate="yes" xml:space="preserve">
          <source>Provides screen oriented methods like &lt;code&gt;setbg()&lt;/code&gt; etc. that are described above.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;setbg()&lt;/code&gt; 등과 같은 화면 지향 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3bcce81b2bfb8b4c888c6e8ed2e2a5f477886f7d" translate="yes" xml:space="preserve">
          <source>Providing &lt;code&gt;default=argparse.SUPPRESS&lt;/code&gt; causes no attribute to be added if the command-line argument was not present:</source>
          <target state="translated">명령 줄 인수가 없으면 &lt;code&gt;default=argparse.SUPPRESS&lt;/code&gt; 를 제공 하면 속성이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a736f976e35e63e7d42af793c52253fd6b6d0d72" translate="yes" xml:space="preserve">
          <source>Providing a much simpler interface for custom &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;action&lt;/code&gt;.</source>
          <target state="translated">커스텀 &lt;code&gt;type&lt;/code&gt; 과 &lt;code&gt;action&lt;/code&gt; 위한 훨씬 간단한 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="63e7afc9f05c9ff9c919f47c668df6b888d2dc7f" translate="yes" xml:space="preserve">
          <source>Providing both of the script selection options will trigger an exception.</source>
          <target state="translated">두 스크립트 선택 옵션을 모두 제공하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d47999c4330b5fcd4daac54f907a640b4b134c74" translate="yes" xml:space="preserve">
          <source>Providing keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used.</source>
          <target state="translated">첫 번째 예에서와 같이 키워드 인수를 제공하면 유효한 Python 식별자 인 키에 대해서만 작동합니다. 그렇지 않으면 유효한 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25510081ac86d2210221f153b51cdc9df9ae4304" translate="yes" xml:space="preserve">
          <source>Proxy Objects</source>
          <target state="translated">프록시 객체</target>
        </trans-unit>
        <trans-unit id="2d5c573197196120569f02776eccc66f21f53599" translate="yes" xml:space="preserve">
          <source>Proxy objects are instances of subclasses of &lt;a href=&quot;#multiprocessing.managers.BaseProxy&quot;&gt;&lt;code&gt;BaseProxy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프록시 객체는 &lt;a href=&quot;#multiprocessing.managers.BaseProxy&quot;&gt; &lt;code&gt;BaseProxy&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="c75a7087ecf855f67fcb81ebf6a5e6082a750517" translate="yes" xml:space="preserve">
          <source>ProxyBasicAuthHandler Objects</source>
          <target state="translated">ProxyBasicAuthHandler 객체</target>
        </trans-unit>
        <trans-unit id="9a3c956a4a7ba8ac42fa61ab44f51e4675dacefb" translate="yes" xml:space="preserve">
          <source>ProxyDigestAuthHandler Objects</source>
          <target state="translated">ProxyDigestAuthHandler 객체</target>
        </trans-unit>
        <trans-unit id="56ba0f30de43dff01434861636d0129dc0849fff" translate="yes" xml:space="preserve">
          <source>ProxyHandler Objects</source>
          <target state="translated">ProxyHandler 객체</target>
        </trans-unit>
        <trans-unit id="4aeca1dd4670f2e0941bbdb681eaf9b9e7516518" translate="yes" xml:space="preserve">
          <source>Pseudo-code:</source>
          <target state="translated">Pseudo-code:</target>
        </trans-unit>
        <trans-unit id="c0fa5326d4b67d5bcfd41e0e59ce698212f3e714" translate="yes" xml:space="preserve">
          <source>Public classes</source>
          <target state="translated">공개 수업</target>
        </trans-unit>
        <trans-unit id="ab5297b4267339fff5c9910aec762c3934118955" translate="yes" xml:space="preserve">
          <source>Public functions</source>
          <target state="translated">공공 기능</target>
        </trans-unit>
        <trans-unit id="f7563f6262a1a1f5617d82e0f1e3e2dee8d1e4c6" translate="yes" xml:space="preserve">
          <source>Pull API for non-blocking parsing</source>
          <target state="translated">비 차단 파싱을위한 풀 API</target>
        </trans-unit>
        <trans-unit id="c10612aa80041fdd7d816e69a190284aeec952e2" translate="yes" xml:space="preserve">
          <source>Pull the pen down &amp;ndash; drawing when moving.</source>
          <target state="translated">움직일 때 펜을 아래로 당기십시오.</target>
        </trans-unit>
        <trans-unit id="7487a2e53df9e03ad9e8b9f59ae0d9088b93bad6" translate="yes" xml:space="preserve">
          <source>Pull the pen up &amp;ndash; no drawing when moving.</source>
          <target state="translated">움직일 때 그림이없는 펜을 위로 당기십시오.</target>
        </trans-unit>
        <trans-unit id="b6aada712c839fa727d6824da8ff431315046580" translate="yes" xml:space="preserve">
          <source>Pure path objects implement the &lt;a href=&quot;os#os.PathLike&quot;&gt;&lt;code&gt;os.PathLike&lt;/code&gt;&lt;/a&gt; interface, allowing them to be used anywhere the interface is accepted.</source>
          <target state="translated">순수 경로 객체는 &lt;a href=&quot;os#os.PathLike&quot;&gt; &lt;code&gt;os.PathLike&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현 하여 인터페이스가 허용되는 모든 위치에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62df8698802935952f3191995f045390c63e6835" translate="yes" xml:space="preserve">
          <source>Pure path objects provide path-handling operations which don&amp;rsquo;t actually access a filesystem. There are three ways to access these classes, which we also call &lt;em&gt;flavours&lt;/em&gt;:</source>
          <target state="translated">순수 경로 객체는 실제로 파일 시스템에 액세스하지 않는 경로 처리 작업을 제공합니다. 이 클래스에 액세스하는 방법에는 세 가지가 있으며,이를 &lt;em&gt;맛&lt;/em&gt; 이라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="86c00397451c193a0cb88542e126e0a1e73aafdb" translate="yes" xml:space="preserve">
          <source>Pure paths</source>
          <target state="translated">순수한 길</target>
        </trans-unit>
        <trans-unit id="fa6b0a14eac80901b75a9e016b6ad99c88fe43b0" translate="yes" xml:space="preserve">
          <source>Pure paths are useful in some special cases; for example:</source>
          <target state="translated">순수한 경로는 특별한 경우에 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a95973d5a8727818a646cdeaf2207e97f5c432af" translate="yes" xml:space="preserve">
          <source>Pure paths provide the following methods and properties:</source>
          <target state="translated">순수한 경로는 다음과 같은 방법과 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66b0802b57fa5d6f4443fda5ba7dcc1d15cb11ba" translate="yes" xml:space="preserve">
          <source>PureProxy Objects</source>
          <target state="translated">PureProxy 객체</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="d2076bd43bbde39434180af8fb6f4c6d0957b8c3" translate="yes" xml:space="preserve">
          <source>Push &lt;em&gt;ch&lt;/em&gt; so the next &lt;a href=&quot;#curses.window.get_wch&quot;&gt;&lt;code&gt;get_wch()&lt;/code&gt;&lt;/a&gt; will return it.</source>
          <target state="translated">다음 &lt;a href=&quot;#curses.window.get_wch&quot;&gt; &lt;code&gt;get_wch()&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;ch&lt;/em&gt; 를 반환 하도록 &lt;em&gt;ch를&lt;/em&gt; 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="cc55018208e43f65febacf54f81f7d45197acf2c" translate="yes" xml:space="preserve">
          <source>Push &lt;em&gt;ch&lt;/em&gt; so the next &lt;a href=&quot;#curses.window.getch&quot;&gt;&lt;code&gt;getch()&lt;/code&gt;&lt;/a&gt; will return it.</source>
          <target state="translated">밀어 &lt;em&gt;채널&lt;/em&gt; 다음 있도록 &lt;a href=&quot;#curses.window.getch&quot;&gt; &lt;code&gt;getch()&lt;/code&gt; &lt;/a&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46b37576d9141e6a9f06389f49d50517fb63900b" translate="yes" xml:space="preserve">
          <source>Push &lt;em&gt;item&lt;/em&gt; on the heap, then pop and return the smallest item from the &lt;em&gt;heap&lt;/em&gt;. The combined action runs more efficiently than &lt;a href=&quot;#heapq.heappush&quot;&gt;&lt;code&gt;heappush()&lt;/code&gt;&lt;/a&gt; followed by a separate call to &lt;a href=&quot;#heapq.heappop&quot;&gt;&lt;code&gt;heappop()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">밀어 &lt;em&gt;항목을&lt;/em&gt; , 힙에 다음 팝과에서 가장 작은 항목을 반환 &lt;em&gt;힙&lt;/em&gt; . 보다 더 효율적으로 조합 된 액션을 실행 &lt;a href=&quot;#heapq.heappush&quot;&gt; &lt;code&gt;heappush()&lt;/code&gt; &lt;/a&gt; 개별 통화가 다음 &lt;a href=&quot;#heapq.heappop&quot;&gt; &lt;code&gt;heappop()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="deeb8489db73ca68d5d5e5c0e00a56bb921df592" translate="yes" xml:space="preserve">
          <source>Push a &lt;code&gt;KEY_MOUSE&lt;/code&gt; event onto the input queue, associating the given state data with it.</source>
          <target state="translated">주어진 상태 데이터와 관련하여 &lt;code&gt;KEY_MOUSE&lt;/code&gt; 이벤트를 입력 큐로 푸시 하십시오.</target>
        </trans-unit>
        <trans-unit id="bdc5f19341ef454044ce777ed9a985c1ee736ce7" translate="yes" xml:space="preserve">
          <source>Push a line of source text to the interpreter. The line should not have a trailing newline; it may have internal newlines. The line is appended to a buffer and the interpreter&amp;rsquo;s &lt;code&gt;runsource()&lt;/code&gt; method is called with the concatenated contents of the buffer as source. If this indicates that the command was executed or invalid, the buffer is reset; otherwise, the command is incomplete, and the buffer is left as it was after the line was appended. The return value is &lt;code&gt;True&lt;/code&gt; if more input is required, &lt;code&gt;False&lt;/code&gt; if the line was dealt with in some way (this is the same as &lt;code&gt;runsource()&lt;/code&gt;).</source>
          <target state="translated">한 줄의 소스 텍스트를 인터프리터에게 보냅니다. 줄에 줄 바꿈 문자가 없어야합니다. 내부 개행이있을 수 있습니다. 행이 버퍼에 추가되고 인터프리터의 &lt;code&gt;runsource()&lt;/code&gt; 메소드가 버퍼의 연결된 컨텐츠를 소스로 사용하여 호출됩니다. 명령이 실행되었거나 유효하지 않음을 나타내는 경우 버퍼가 재설정됩니다. 그렇지 않으면 명령이 불완전하며 버퍼가 줄이 추가 된 후 그대로 남아 있습니다. 더 많은 입력이 필요한 경우 반환 값은 &lt;code&gt;True&lt;/code&gt; 이고 , 라인이 어떤 방식으로 처리 된 경우 &lt;code&gt;False&lt;/code&gt; 입니다 ( &lt;code&gt;runsource()&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="1ff551f79566ed40a79345d1a8d8c3a5bf217bd8" translate="yes" xml:space="preserve">
          <source>Push an input source stream onto the input stack. If the filename argument is specified it will later be available for use in error messages. This is the same method used internally by the &lt;a href=&quot;#shlex.shlex.sourcehook&quot;&gt;&lt;code&gt;sourcehook()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">입력 소스 스트림을 입력 스택으로 밀어 넣습니다. filename 인수가 지정되면 나중에 오류 메시지에 사용할 수 있습니다. 이것은 &lt;a href=&quot;#shlex.shlex.sourcehook&quot;&gt; &lt;code&gt;sourcehook()&lt;/code&gt; &lt;/a&gt; 메소드가 내부적으로 사용하는 것과 동일한 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="db6c3afd930aeb68d89014ee5433350a0a681bc6" translate="yes" xml:space="preserve">
          <source>Push panel to the top of the stack.</source>
          <target state="translated">스택 상단으로 패널을 밉니다.</target>
        </trans-unit>
        <trans-unit id="285e296d900920005aeb30736d8c5b8dbc446057" translate="yes" xml:space="preserve">
          <source>Push the argument onto the token stack.</source>
          <target state="translated">인수를 토큰 스택으로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="e33f8f562ff442430fbdaadf2f184466a7cf2d74" translate="yes" xml:space="preserve">
          <source>Push the panel to the bottom of the stack.</source>
          <target state="translated">패널을 스택 맨 아래로 밉니다.</target>
        </trans-unit>
        <trans-unit id="1a260125546e3d60f42e10e3381f7f1f4e4702de" translate="yes" xml:space="preserve">
          <source>Push the value &lt;em&gt;item&lt;/em&gt; onto the &lt;em&gt;heap&lt;/em&gt;, maintaining the heap invariant.</source>
          <target state="translated">&lt;em&gt;힙을 변경하지&lt;/em&gt; 않고 값 &lt;em&gt;항목&lt;/em&gt; 을 &lt;em&gt;힙&lt;/em&gt; 으로 푸시하십시오 .</target>
        </trans-unit>
        <trans-unit id="e87381f973c93a45ec66467fdd6d2f61819e610f" translate="yes" xml:space="preserve">
          <source>Pushes &lt;code&gt;NULL&lt;/code&gt; onto the stack for using it in &lt;a href=&quot;#opcode-END_FINALLY&quot;&gt;&lt;code&gt;END_FINALLY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#opcode-POP_FINALLY&quot;&gt;&lt;code&gt;POP_FINALLY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#opcode-WITH_CLEANUP_START&quot;&gt;&lt;code&gt;WITH_CLEANUP_START&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#opcode-WITH_CLEANUP_FINISH&quot;&gt;&lt;code&gt;WITH_CLEANUP_FINISH&lt;/code&gt;&lt;/a&gt;. Starts the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#opcode-END_FINALLY&quot;&gt; &lt;code&gt;END_FINALLY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#opcode-POP_FINALLY&quot;&gt; &lt;code&gt;POP_FINALLY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#opcode-WITH_CLEANUP_START&quot;&gt; &lt;code&gt;WITH_CLEANUP_START&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#opcode-WITH_CLEANUP_FINISH&quot;&gt; &lt;code&gt;WITH_CLEANUP_FINISH&lt;/code&gt; &lt;/a&gt; 에서 사용하기 위해 &lt;code&gt;NULL&lt;/code&gt; 을 스택으로 푸시 합니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 블록을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="6d0445bcde7e6ba3eb17ac8b16105316c176699b" translate="yes" xml:space="preserve">
          <source>Pushes &lt;code&gt;builtins.__build_class__()&lt;/code&gt; onto the stack. It is later called by &lt;a href=&quot;#opcode-CALL_FUNCTION&quot;&gt;&lt;code&gt;CALL_FUNCTION&lt;/code&gt;&lt;/a&gt; to construct a class.</source>
          <target state="translated">푸쉬 &lt;code&gt;builtins.__build_class__()&lt;/code&gt; 스택에. 나중에 클래스를 구성하기 위해 &lt;a href=&quot;#opcode-CALL_FUNCTION&quot;&gt; &lt;code&gt;CALL_FUNCTION&lt;/code&gt; &lt;/a&gt; 에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="49a0ce60315742720d6e790708903a5cbdd38a13" translate="yes" xml:space="preserve">
          <source>Pushes &lt;code&gt;co_consts[consti]&lt;/code&gt; onto the stack.</source>
          <target state="translated">푸쉬 &lt;code&gt;co_consts[consti]&lt;/code&gt; 스택 상.</target>
        </trans-unit>
        <trans-unit id="8c5c906f16d7213e3fe5cb70f6c4ba0d38aaf04f" translate="yes" xml:space="preserve">
          <source>Pushes a &lt;code&gt;None&lt;/code&gt; on to the producer queue. When this producer is popped off the queue it causes the channel to be closed.</source>
          <target state="translated">생산자 대기열 로 &lt;code&gt;None&lt;/code&gt; 을 푸시합니다 . 이 제작자가 대기열에서 튀어 나오면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="914c8745b5a1bdf4649b1e5f23b242a942f8605d" translate="yes" xml:space="preserve">
          <source>Pushes a new dictionary object onto the stack. Pops &lt;code&gt;2 * count&lt;/code&gt; items so that the dictionary holds &lt;em&gt;count&lt;/em&gt; entries: &lt;code&gt;{..., TOS3: TOS2, TOS1: TOS}&lt;/code&gt;.</source>
          <target state="translated">새 사전 개체를 스택으로 푸시합니다. 사전이 &lt;em&gt;카운트&lt;/em&gt; 항목을 보유하도록 &lt;code&gt;2 * count&lt;/code&gt; items를 팝 합니다 : &lt;code&gt;{..., TOS3: TOS2, TOS1: TOS}&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08052794fb7c2dbab8e430d2dd07bf32e9f75c31" translate="yes" xml:space="preserve">
          <source>Pushes a new function object on the stack. From bottom to top, the consumed stack must consist of values if the argument carries a specified flag value</source>
          <target state="translated">스택에서 새 함수 객체를 푸시합니다. 인수에 지정된 플래그 값이 있으면 소비되는 스택은 아래에서 위로 값으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="68ab25e4336f083f291523bf1fae81222344fd0f" translate="yes" xml:space="preserve">
          <source>Pushes a reference to the cell contained in slot &lt;em&gt;i&lt;/em&gt; of the cell and free variable storage. The name of the variable is &lt;code&gt;co_cellvars[i]&lt;/code&gt; if &lt;em&gt;i&lt;/em&gt; is less than the length of &lt;em&gt;co_cellvars&lt;/em&gt;. Otherwise it is &lt;code&gt;co_freevars[i -
len(co_cellvars)]&lt;/code&gt;.</source>
          <target state="translated">셀의 슬롯 &lt;em&gt;i&lt;/em&gt; 및 비어있는 가변 스토리지에 포함 된 셀에 대한 참조를 푸시합니다 . &lt;em&gt;i&lt;/em&gt; 가 &lt;em&gt;co_cellvars&lt;/em&gt; 길이보다 작은 경우 변수 이름은 &lt;code&gt;co_cellvars[i]&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;co_freevars[i - len(co_cellvars)]&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8dfe3cb391a82a542609fdfa5be8b3aa0ca06b25" translate="yes" xml:space="preserve">
          <source>Pushes a reference to the local &lt;code&gt;co_varnames[var_num]&lt;/code&gt; onto the stack.</source>
          <target state="translated">로컬 &lt;code&gt;co_varnames[var_num]&lt;/code&gt; 에 대한 참조를 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="21b2febb965d2f948ea4cf0206cc623631a6cdd3" translate="yes" xml:space="preserve">
          <source>Pushes a slice object on the stack. &lt;em&gt;argc&lt;/em&gt; must be 2 or 3. If it is 2, &lt;code&gt;slice(TOS1, TOS)&lt;/code&gt; is pushed; if it is 3, &lt;code&gt;slice(TOS2, TOS1, TOS)&lt;/code&gt; is pushed. See the &lt;a href=&quot;functions#slice&quot;&gt;&lt;code&gt;slice()&lt;/code&gt;&lt;/a&gt; built-in function for more information.</source>
          <target state="translated">스택에서 슬라이스 객체를 푸시합니다. &lt;em&gt;argc&lt;/em&gt; 는 2 또는 3이어야합니다. 2 인 경우 &lt;code&gt;slice(TOS1, TOS)&lt;/code&gt; 가 푸시됩니다. 3이면 &lt;code&gt;slice(TOS2, TOS1, TOS)&lt;/code&gt; 가 푸시됩니다. 자세한 내용은 &lt;a href=&quot;functions#slice&quot;&gt; &lt;code&gt;slice()&lt;/code&gt; &lt;/a&gt; 내장 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d73d5ba6395f82b6350b0d8b60bb72d4aec78ca" translate="yes" xml:space="preserve">
          <source>Pushes a try block from a try-finally or try-except clause onto the block stack. &lt;em&gt;delta&lt;/em&gt; points to the finally block or the first except block.</source>
          <target state="translated">try-finally 또는 try-except 절에서 try 블록을 블록 스택으로 푸시합니다. &lt;em&gt;델타&lt;/em&gt; 는 finally 블록 또는 첫 번째 제외 블록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="20231af18a4c3e5c00a678485187da72502959f9" translate="yes" xml:space="preserve">
          <source>Pushes data on to the channel&amp;rsquo;s queue to ensure its transmission. This is all you need to do to have the channel write the data out to the network, although it is possible to use your own producers in more complex schemes to implement encryption and chunking, for example.</source>
          <target state="translated">전송을 위해 데이터를 채널 대기열로 푸시합니다. 예를 들어, 암호화 및 청킹을 구현하기 위해 더 복잡한 방식으로 자체 제작자를 사용하는 것이 가능하지만 채널이 네트워크에 데이터를 쓰도록하려면이 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c46ce674d43f69f80e61570dc3c7d94f5756df0" translate="yes" xml:space="preserve">
          <source>Pushes the address of the next instruction onto the stack and increments bytecode counter by &lt;em&gt;delta&lt;/em&gt;. Used for calling the finally block as a &amp;ldquo;subroutine&amp;rdquo;.</source>
          <target state="translated">다음 명령어의 주소를 스택으로 푸시하고 바이트 코드 카운터를 &lt;em&gt;델타&lt;/em&gt; 단위로 증가시킵니다 . finally 블록을 &quot;서브 루틴&quot;으로 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d579563bfb99148066bcc319f8230278195bae33" translate="yes" xml:space="preserve">
          <source>Pushes the value associated with &lt;code&gt;co_names[namei]&lt;/code&gt; onto the stack.</source>
          <target state="translated">&lt;code&gt;co_names[namei]&lt;/code&gt; 와 연관된 값을 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="83775fb1f938d53ebaafa17df99df1094d912529" translate="yes" xml:space="preserve">
          <source>Put &lt;em&gt;item&lt;/em&gt; into the queue.</source>
          <target state="translated">넣어 &lt;em&gt;항목을&lt;/em&gt; 큐에.</target>
        </trans-unit>
        <trans-unit id="58b24c1f540864fcca7249c13913776d87e3018e" translate="yes" xml:space="preserve">
          <source>Put &lt;em&gt;item&lt;/em&gt; into the queue. If optional args &lt;em&gt;block&lt;/em&gt; is true and &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), block if necessary until a free slot is available. If &lt;em&gt;timeout&lt;/em&gt; is a positive number, it blocks at most &lt;em&gt;timeout&lt;/em&gt; seconds and raises the &lt;a href=&quot;#queue.Full&quot;&gt;&lt;code&gt;Full&lt;/code&gt;&lt;/a&gt; exception if no free slot was available within that time. Otherwise (&lt;em&gt;block&lt;/em&gt; is false), put an item on the queue if a free slot is immediately available, else raise the &lt;a href=&quot;#queue.Full&quot;&gt;&lt;code&gt;Full&lt;/code&gt;&lt;/a&gt; exception (&lt;em&gt;timeout&lt;/em&gt; is ignored in that case).</source>
          <target state="translated">넣어 &lt;em&gt;항목을&lt;/em&gt; 큐에. 선택적 args &lt;em&gt;블록&lt;/em&gt; 이 true이고 &lt;em&gt;시간 종료&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우, 사용 가능한 슬롯이 사용 가능할 때까지 필요한 경우 차단하십시오. 경우 &lt;em&gt;제한 시간은&lt;/em&gt; 최대 양수, 차단이다 &lt;em&gt;타임 아웃&lt;/em&gt; 초와 제기 &lt;a href=&quot;#queue.Full&quot;&gt; &lt;code&gt;Full&lt;/code&gt; &lt;/a&gt; 여유 슬롯이 그 시간 내에서 사용할 수 없었다 경우 예외를. 그렇지 않으면 ( &lt;em&gt;블록&lt;/em&gt; 이 false 인 경우) 비어있는 슬롯을 즉시 사용할 수있는 경우 항목을 대기열에 넣거나 &lt;a href=&quot;#queue.Full&quot;&gt; &lt;code&gt;Full&lt;/code&gt; &lt;/a&gt; 예외를 발생 시킵니다 ( 이 경우 &lt;em&gt;시간 초과&lt;/em&gt; 는 무시 됨).</target>
        </trans-unit>
        <trans-unit id="8934b5345ae85e054929da0954168f7106a4dc3e" translate="yes" xml:space="preserve">
          <source>Put &lt;em&gt;item&lt;/em&gt; into the queue. The method never blocks and always succeeds (except for potential low-level errors such as failure to allocate memory). The optional args &lt;em&gt;block&lt;/em&gt; and &lt;em&gt;timeout&lt;/em&gt; are ignored and only provided for compatibility with &lt;a href=&quot;#queue.Queue.put&quot;&gt;&lt;code&gt;Queue.put()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">넣어 &lt;em&gt;항목을&lt;/em&gt; 큐에. 이 방법은 절대로 차단하지 않고 항상 성공합니다 (메모리 할당 실패와 같은 잠재적 인 저수준 오류 제외). 선택적 args &lt;em&gt;블록&lt;/em&gt; 및 &lt;em&gt;시간 초과&lt;/em&gt; 는 무시되며 &lt;a href=&quot;#queue.Queue.put&quot;&gt; &lt;code&gt;Queue.put()&lt;/code&gt; &lt;/a&gt; 과의 호환성을 위해서만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb7807661d9be22693cbaed0a5656176c454fe3d" translate="yes" xml:space="preserve">
          <source>Put an item into the queue without blocking.</source>
          <target state="translated">차단하지 않고 항목을 대기열에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="8218d84bd6234ff18e8621ebfadb8c4e7388dc86" translate="yes" xml:space="preserve">
          <source>Put an item into the queue. If the queue is full, wait until a free slot is available before adding the item.</source>
          <target state="translated">항목을 대기열에 넣습니다. 대기열이 가득 찬 경우 사용 가능한 슬롯을 사용할 수있을 때까지 기다렸다가 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f9cae25a978f59af9278740f11652ef7349f16a2" translate="yes" xml:space="preserve">
          <source>Put obj into the queue. If the optional argument &lt;em&gt;block&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) and &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), block if necessary until a free slot is available. If &lt;em&gt;timeout&lt;/em&gt; is a positive number, it blocks at most &lt;em&gt;timeout&lt;/em&gt; seconds and raises the &lt;a href=&quot;queue#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; exception if no free slot was available within that time. Otherwise (&lt;em&gt;block&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;), put an item on the queue if a free slot is immediately available, else raise the &lt;a href=&quot;queue#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; exception (&lt;em&gt;timeout&lt;/em&gt; is ignored in that case).</source>
          <target state="translated">obj를 대기열에 넣습니다. 선택적 인수 &lt;em&gt;블록&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; (기본값)이고 &lt;em&gt;시간 초과&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우 사용 가능한 슬롯을 사용할 수있을 때까지 필요한 경우 차단하십시오. 경우 &lt;em&gt;시간 제한은&lt;/em&gt; 양수, 차단 대부분에있다 &lt;em&gt;타임 아웃&lt;/em&gt; 초와 제기 &lt;a href=&quot;queue#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; 의&lt;/a&gt; 여유 슬롯이 그 시간 내에서 사용할 수 없었다 경우 예외를. 그렇지 않으면 ( &lt;em&gt;block&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; ), 여유 슬롯을 즉시 사용할 수 있으면 대기열에 항목을 넣고 그렇지 않으면 대기열을 올리십시오. &lt;a href=&quot;queue#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; &lt;/a&gt; 예외 ( 이 경우 &lt;em&gt;시간 초과&lt;/em&gt; 는 무시됩니다).</target>
        </trans-unit>
        <trans-unit id="e30ebfbecb90eab274dc7f46a9658e29a415f031" translate="yes" xml:space="preserve">
          <source>Put the SMTP connection in TLS (Transport Layer Security) mode. All SMTP commands that follow will be encrypted. You should then call &lt;a href=&quot;#smtplib.SMTP.ehlo&quot;&gt;&lt;code&gt;ehlo()&lt;/code&gt;&lt;/a&gt; again.</source>
          <target state="translated">SMTP 연결을 TLS (Transport Layer Security) 모드로 설정하십시오. 뒤 따르는 모든 SMTP 명령은 암호화됩니다. 그런 다음 &lt;a href=&quot;#smtplib.SMTP.ehlo&quot;&gt; &lt;code&gt;ehlo()&lt;/code&gt; &lt;/a&gt; 다시 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2ad11b0512fca8842d107a0a94c7fecd10f4d659" translate="yes" xml:space="preserve">
          <source>Put the barrier into a broken state. This causes any active or future calls to &lt;a href=&quot;#threading.Barrier.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; to fail with the &lt;a href=&quot;#threading.BrokenBarrierError&quot;&gt;&lt;code&gt;BrokenBarrierError&lt;/code&gt;&lt;/a&gt;. Use this for example if one of the threads needs to abort, to avoid deadlocking the application.</source>
          <target state="translated">장벽을 고장난 상태로 만듭니다. 이로 인해 활성 또는 이후의 &lt;a href=&quot;#threading.Barrier.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출 이 &lt;a href=&quot;#threading.BrokenBarrierError&quot;&gt; &lt;code&gt;BrokenBarrierError&lt;/code&gt; &lt;/a&gt; 와 함께 실패 합니다 . 예를 들어 애플리케이션 중 교착 상태를 피하기 위해 스레드 중 하나를 중단해야하는 경우이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9ad93fb8bceb03469b0b240c1d94e65e4ddf2c18" translate="yes" xml:space="preserve">
          <source>Put the device into non-blocking mode. Once in non-blocking mode, there is no way to return it to blocking mode.</source>
          <target state="translated">장치를 비 차단 모드로 설정하십시오. 비 차단 모드에서는 차단 모드로 되돌릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1091cfdefe23623ba530a4b8db12fc943326a5c3" translate="yes" xml:space="preserve">
          <source>Put the socket object into closed state without actually closing the underlying file descriptor. The file descriptor is returned, and can be reused for other purposes.</source>
          <target state="translated">기본 파일 설명자를 실제로 닫지 않고 소켓 객체를 닫힌 상태로 만듭니다. 파일 디스크립터가 리턴되며 다른 목적으로 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9d46fd9600b7e447b3fa4d11f9c74fc286b7f64" translate="yes" xml:space="preserve">
          <source>PyGObject</source>
          <target state="translated">PyGObject</target>
        </trans-unit>
        <trans-unit id="4d31c346c14baa247ff0c97428735b59c889439f" translate="yes" xml:space="preserve">
          <source>PyGObject provides introspection bindings for C libraries using &lt;a href=&quot;https://developer.gnome.org/gobject/stable/&quot;&gt;GObject&lt;/a&gt;. One of these libraries is the &lt;a href=&quot;https://www.gtk.org/&quot;&gt;GTK+ 3&lt;/a&gt; widget set. GTK+ comes with many more widgets than Tkinter provides. An online &lt;a href=&quot;https://python-gtk-3-tutorial.readthedocs.io/&quot;&gt;Python GTK+ 3 Tutorial&lt;/a&gt; is available.</source>
          <target state="translated">PyGObject는 &lt;a href=&quot;https://developer.gnome.org/gobject/stable/&quot;&gt;GObject를&lt;/a&gt; 사용하여 C 라이브러리에 대한 내부 검사 바인딩을 제공합니다 . 이러한 라이브러리 중 하나는 &lt;a href=&quot;https://www.gtk.org/&quot;&gt;GTK + 3&lt;/a&gt; 위젯 세트입니다. GTK +는 Tkinter가 제공하는 것보다 더 많은 위젯을 제공합니다. 온라인 &lt;a href=&quot;https://python-gtk-3-tutorial.readthedocs.io/&quot;&gt;Python GTK + 3 자습서&lt;/a&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="42911d3d75f013cbeb6206491fb434ba0ff3febc" translate="yes" xml:space="preserve">
          <source>PyGTK</source>
          <target state="translated">PyGTK</target>
        </trans-unit>
        <trans-unit id="b94652fa2011827f7f94decf66c9ec4272404a0c" translate="yes" xml:space="preserve">
          <source>PyGTK provides bindings for an older version of the library, GTK+ 2. It provides an object oriented interface that is slightly higher level than the C one. There are also bindings to &lt;a href=&quot;https://www.gnome.org/&quot;&gt;GNOME&lt;/a&gt;. An online &lt;a href=&quot;http://www.pygtk.org/pygtk2tutorial/index.html&quot;&gt;tutorial&lt;/a&gt; is available.</source>
          <target state="translated">PyGTK는 이전 버전의 라이브러리 인 GTK + 2에 대한 바인딩을 제공합니다. Cy보다 약간 더 높은 객체 지향 인터페이스를 제공합니다. &lt;a href=&quot;https://www.gnome.org/&quot;&gt;그놈에 대한&lt;/a&gt; 바인딩도 있습니다 . 온라인 &lt;a href=&quot;http://www.pygtk.org/pygtk2tutorial/index.html&quot;&gt;자습서&lt;/a&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d64c8cbe603dd88121eb44e96c989e19fb82e43a" translate="yes" xml:space="preserve">
          <source>PyGTK, PyQt, and wxPython, all have a modern look and feel and more widgets than Tkinter. In addition, there are many other GUI toolkits for Python, both cross-platform, and platform-specific. See the &lt;a href=&quot;https://wiki.python.org/moin/GuiProgramming&quot;&gt;GUI Programming&lt;/a&gt; page in the Python Wiki for a much more complete list, and also for links to documents where the different GUI toolkits are compared.</source>
          <target state="translated">PyGTK, PyQt 및 wxPython은 모두 Tkinter보다 현대적인 모양과 느낌 및 더 많은 위젯을 가지고 있습니다. 또한 크로스 플랫폼 및 플랫폼에 따라 다른 많은 Python 용 GUI 툴킷이 있습니다. 훨씬 더 완전한 목록과 다른 GUI 툴킷이 비교되는 문서에 대한 링크는 Python Wiki 의 &lt;a href=&quot;https://wiki.python.org/moin/GuiProgramming&quot;&gt;GUI 프로그래밍&lt;/a&gt; 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="591695c92a51e0a4994db8d71fa3299632cd41a3" translate="yes" xml:space="preserve">
          <source>PyQt</source>
          <target state="translated">PyQt</target>
        </trans-unit>
        <trans-unit id="9ae98c491854c976c1556187b6e1b97776f7d16f" translate="yes" xml:space="preserve">
          <source>PyQt is a &lt;strong&gt;sip&lt;/strong&gt;-wrapped binding to the Qt toolkit. Qt is an extensive C++ GUI application development framework that is available for Unix, Windows and Mac OS X. &lt;strong&gt;sip&lt;/strong&gt; is a tool for generating bindings for C++ libraries as Python classes, and is specifically designed for Python.</source>
          <target state="translated">PyQt는 Qt 툴킷에 대한 &lt;strong&gt;sip-&lt;/strong&gt; wrapped 바인딩입니다. Qt는 Unix, Windows 및 Mac OS X에서 사용할 수있는 광범위한 C ++ GUI 응용 프로그램 개발 프레임 워크입니다. &lt;strong&gt;sip&lt;/strong&gt; 는 C ++ 라이브러리에 대한 바인딩을 Python 클래스로 생성하는 도구이며 특히 Python을 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="619105fc659c95fc540d2c1e747b3b2993ea7fd1" translate="yes" xml:space="preserve">
          <source>PySide</source>
          <target state="translated">PySide</target>
        </trans-unit>
        <trans-unit id="c06a107c4ddf3a14e7737b994f893c16e1981005" translate="yes" xml:space="preserve">
          <source>PySide is a newer binding to the Qt toolkit, provided by Nokia. Compared to PyQt, its licensing scheme is friendlier to non-open source applications.</source>
          <target state="translated">PySide는 Nokia에서 제공하는 Qt 툴킷에 대한 최신 바인딩입니다. PyQt와 비교할 때, 라이센스 체계는 비 오픈 소스 응용 프로그램에 더 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="8cc5e9ed71ff538ccf01ed1a98424a08329a58d3" translate="yes" xml:space="preserve">
          <source>PyZipFile Objects</source>
          <target state="translated">PyZipFile 객체</target>
        </trans-unit>
        <trans-unit id="0abcfa3470fb7187c7fa3a03e26b907cf9a49745" translate="yes" xml:space="preserve">
          <source>Py_UNICODE</source>
          <target state="translated">Py_UNICODE</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="6b8f61655c7227cb356bd2f7409e5033dbd21174" translate="yes" xml:space="preserve">
          <source>Python 3.3 adds several new functions in &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; that can be used to make precise measurements of process or wall-clock time. For example, see &lt;a href=&quot;time#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 3.3 은 프로세스 또는 벽시계 시간을 정확하게 측정하는 데 사용할 수있는 몇 가지 새로운 기능을 &lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 추가합니다 . 예를 들어 &lt;a href=&quot;time#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0711b02500c16372db7e037b0db241051fe28013" translate="yes" xml:space="preserve">
          <source>Python API</source>
          <target state="translated">파이썬 API</target>
        </trans-unit>
        <trans-unit id="3ee394b6d17ed1fc6cf7615a47330585fc9b0a01" translate="yes" xml:space="preserve">
          <source>Python Bytecode Instructions</source>
          <target state="translated">파이썬 바이트 코드 명령어</target>
        </trans-unit>
        <trans-unit id="3cb0f443a4045dcf52595aa8531b43c5c2fa7460" translate="yes" xml:space="preserve">
          <source>Python Docs</source>
          <target state="translated">파이썬 문서</target>
        </trans-unit>
        <trans-unit id="0355f05a806d1783a9cc7d8c5ea6ee60f3d6f24f" translate="yes" xml:space="preserve">
          <source>Python Interface</source>
          <target state="translated">파이썬 인터페이스</target>
        </trans-unit>
        <trans-unit id="1f009e17d19f9da1b9faa9295f208962e3e63806" translate="yes" xml:space="preserve">
          <source>Python Language Mapping Specification</source>
          <target state="translated">파이썬 언어 매핑 사양</target>
        </trans-unit>
        <trans-unit id="0c6b8fde978bf14a2cd633dafb4a0b230f557746" translate="yes" xml:space="preserve">
          <source>Python Language Services</source>
          <target state="translated">파이썬 언어 서비스</target>
        </trans-unit>
        <trans-unit id="092211b0a454b4bd3d5953ff3df7fd3f99cf63ea" translate="yes" xml:space="preserve">
          <source>Python Packaging User Guide: Creating and using virtual environments</source>
          <target state="translated">Python Packaging 사용자 안내서 : 가상 환경 작성 및 사용</target>
        </trans-unit>
        <trans-unit id="7a623bcfe092da5ad8c875bc8b6a2c58c3966c7b" translate="yes" xml:space="preserve">
          <source>Python Runtime Services</source>
          <target state="translated">파이썬 런타임 서비스</target>
        </trans-unit>
        <trans-unit id="5e8caadc585bc176b908975c7b0f5adfd3ca07e5" translate="yes" xml:space="preserve">
          <source>Python Shell</source>
          <target state="translated">파이썬 쉘</target>
        </trans-unit>
        <trans-unit id="37023209cd8d17b87ec33c9fedfa931e2dc4f32b" translate="yes" xml:space="preserve">
          <source>Python Shell window</source>
          <target state="translated">파이썬 쉘 창</target>
        </trans-unit>
        <trans-unit id="b7d42ac213c92acc79852232679f79b31ea56451" translate="yes" xml:space="preserve">
          <source>Python Specific Encodings</source>
          <target state="translated">파이썬 특정 인코딩</target>
        </trans-unit>
        <trans-unit id="99225c5a1bfdba35aa585e3e9d0046d88e7f76de" translate="yes" xml:space="preserve">
          <source>Python Tkinter Resources</source>
          <target state="translated">파이썬 Tkinter 리소스</target>
        </trans-unit>
        <trans-unit id="c4b41fa096c8ca8de1aca03645726f801a284621" translate="yes" xml:space="preserve">
          <source>Python Type</source>
          <target state="translated">파이썬 타입</target>
        </trans-unit>
        <trans-unit id="8df32fb907357083986db821e14e12d057113627" translate="yes" xml:space="preserve">
          <source>Python and Tkinter Programming</source>
          <target state="translated">파이썬과 Tkinter 프로그래밍</target>
        </trans-unit>
        <trans-unit id="aafe008164775ee95643f93c690b0bf91843c0fc" translate="yes" xml:space="preserve">
          <source>Python applications should normally find no need to invoke these functions, and should use &lt;a href=&quot;gettext#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; instead. A known exception to this rule are applications that link with additional C libraries which internally invoke &lt;code&gt;gettext()&lt;/code&gt; or &lt;code&gt;dcgettext()&lt;/code&gt;. For these applications, it may be necessary to bind the text domain, so that the libraries can properly locate their message catalogs.</source>
          <target state="translated">파이썬 응용 프로그램은 일반적으로 이러한 함수를 호출 할 필요가 없으며 대신 &lt;a href=&quot;gettext#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 이 규칙의 알려진 예외는 내부적으로 &lt;code&gt;gettext()&lt;/code&gt; 또는 &lt;code&gt;dcgettext()&lt;/code&gt; 호출하는 추가 C 라이브러리와 링크되는 응용 프로그램입니다 . 이러한 응용 프로그램의 경우 라이브러리가 메시지 카탈로그를 올바르게 찾을 수 있도록 텍스트 도메인을 바인드해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ba27acbccfe931c72cdbb3e8631db3a08ab43de" translate="yes" xml:space="preserve">
          <source>Python callable. Will be called with no arguments whenever either of the increment or decrement buttons are pressed.</source>
          <target state="translated">파이썬 호출 가능. 증가 또는 감소 버튼 중 하나를 누를 때마다 인수없이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7c63cfd12aa8ac5be1bf526866c306771615c5c9" translate="yes" xml:space="preserve">
          <source>Python code objects have a &lt;code&gt;co_flags&lt;/code&gt; attribute, which is a bitmap of the following flags:</source>
          <target state="translated">Python 코드 객체에는 &lt;code&gt;co_flags&lt;/code&gt; 속성이 있으며 이는 다음 플래그의 비트 맵입니다.</target>
        </trans-unit>
        <trans-unit id="55264df222d98db1d1d4885beaee43c36a00af15" translate="yes" xml:space="preserve">
          <source>Python comes with a number of codecs built-in, either implemented as C functions or with dictionaries as mapping tables. The following table lists the codecs by name, together with a few common aliases, and the languages for which the encoding is likely used. Neither the list of aliases nor the list of languages is meant to be exhaustive. Notice that spelling alternatives that only differ in case or use a hyphen instead of an underscore are also valid aliases; therefore, e.g. &lt;code&gt;'utf-8'&lt;/code&gt; is a valid alias for the &lt;code&gt;'utf_8'&lt;/code&gt; codec.</source>
          <target state="translated">Python에는 C 함수로 구현되거나 사전을 매핑 테이블로 사용하는 많은 코덱이 내장되어 있습니다. 다음 표는 몇 가지 공통 별칭 및 인코딩이 사용되는 언어와 함께 이름별로 코덱을 나열합니다. 별명 목록이나 언어 목록이 모두 철저하지는 않습니다. 대소 문자 만 다르거 나 밑줄 대신 하이픈을 사용하는 철자 대안도 유효한 별칭입니다. 따라서 &lt;code&gt;'utf-8'&lt;/code&gt; 은 &lt;code&gt;'utf_8'&lt;/code&gt; 코덱 의 유효한 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="6638c7fb834b1386886a4ceb27ea78e43c6f048a" translate="yes" xml:space="preserve">
          <source>Python coroutines are &lt;em&gt;awaitables&lt;/em&gt; and therefore can be awaited from other coroutines:</source>
          <target state="translated">파이썬 코 루틴은 &lt;em&gt;기다릴&lt;/em&gt; 수 있으므로 다른 코 루틴에서 &lt;em&gt;기다릴&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d88fc13b34091cdf70c9cff13c4b1284d594820" translate="yes" xml:space="preserve">
          <source>Python currently supports seven schemes:</source>
          <target state="translated">파이썬은 현재 7 가지 방식을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="eaf945f94327f2c0ce5f5922c999addd589c7d83" translate="yes" xml:space="preserve">
          <source>Python defines &lt;code&gt;pow(0, 0)&lt;/code&gt; and &lt;code&gt;0 ** 0&lt;/code&gt; to be &lt;code&gt;1&lt;/code&gt;, as is common for programming languages.</source>
          <target state="translated">파이썬은 프로그래밍 언어에서 공통적으로 &lt;code&gt;pow(0, 0)&lt;/code&gt; 및 &lt;code&gt;0 ** 0&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6b384100739e74cedd9aa09dc50763c7744aa517" translate="yes" xml:space="preserve">
          <source>Python defines several context managers to support easy thread synchronisation, prompt closure of files or other objects, and simpler manipulation of the active decimal arithmetic context. The specific types are not treated specially beyond their implementation of the context management protocol. See the &lt;a href=&quot;contextlib#module-contextlib&quot;&gt;&lt;code&gt;contextlib&lt;/code&gt;&lt;/a&gt; module for some examples.</source>
          <target state="translated">Python은 쉬운 스레드 동기화, 파일 또는 기타 객체의 신속한 폐쇄 및 활성 10 진수 산술 컨텍스트의 간단한 조작을 지원하기 위해 여러 컨텍스트 관리자를 정의합니다. 특정 유형은 컨텍스트 관리 프로토콜의 구현을 넘어서는 특별히 취급되지 않습니다. 일부 예제 는 &lt;a href=&quot;contextlib#module-contextlib&quot;&gt; &lt;code&gt;contextlib&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="137da51dc044f7d1989ccf40d2cf2bb7660c7a2f" translate="yes" xml:space="preserve">
          <source>Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms. The specific types are not important beyond their implementation of the iterator protocol.</source>
          <target state="translated">파이썬은 몇 가지 반복자 객체를 정의하여 일반 및 특정 시퀀스 유형, 사전 및 기타 더 특수한 형식에 대한 반복을 지원합니다. 특정 유형은 반복자 프로토콜 구현을 넘어서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b17cefa47591600687b4080407aa059ba0bde83" translate="yes" xml:space="preserve">
          <source>Python does not currently have an equivalent to &lt;code&gt;scanf()&lt;/code&gt;. Regular expressions are generally more powerful, though also more verbose, than &lt;code&gt;scanf()&lt;/code&gt; format strings. The table below offers some more-or-less equivalent mappings between &lt;code&gt;scanf()&lt;/code&gt; format tokens and regular expressions.</source>
          <target state="translated">파이썬에는 현재 &lt;code&gt;scanf()&lt;/code&gt; 와 동등한 것이 없습니다 . 정규 표현식은 일반적으로 &lt;code&gt;scanf()&lt;/code&gt; 형식 문자열 보다 더 강력하지만 더 강력 합니다. 아래 표는 &lt;code&gt;scanf()&lt;/code&gt; 형식 토큰과 정규식 사이에 다소 비슷한 매핑을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="3865683b646bac2aedc53f477cbeee82b1f7c068" translate="yes" xml:space="preserve">
          <source>Python doesn&amp;rsquo;t depend on the underlying operating system&amp;rsquo;s notion of text files; all the processing is done by Python itself, and is therefore platform-independent.</source>
          <target state="translated">파이썬은 기본 운영 체제의 텍스트 파일 개념에 의존하지 않습니다. 모든 처리는 Python 자체에서 수행되므로 플랫폼 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="8638513dc3901fe6eaa10ec89548c63a1ae8d88b" translate="yes" xml:space="preserve">
          <source>Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the &amp;ldquo;narrower&amp;rdquo; type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. Comparisons between numbers of mixed type use the same rule. &lt;a href=&quot;#id13&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; The constructors &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex()&lt;/code&gt;&lt;/a&gt; can be used to produce numbers of a specific type.</source>
          <target state="translated">파이썬은 혼합 산술을 완벽하게 지원합니다. 이진 산술 연산자에 다른 숫자 유형의 피연산자가있는 경우&amp;ldquo;좁은&amp;rdquo;유형의 피연산자는 다른 것의 피연산자로 넓어집니다. 여기서 정수는 부동 소수점보다 좁으며 복잡한 것보다 좁습니다. 혼합 유형 수의 비교는 동일한 규칙을 사용합니다. &lt;a href=&quot;#id13&quot; id=&quot;id2&quot;&gt;2 &lt;/a&gt;&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex()&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 특정 유형의 숫자를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd854c517849a451ddd0370a06d5d10daf25373" translate="yes" xml:space="preserve">
          <source>Python has a more primitive serialization module called &lt;a href=&quot;marshal#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt;, but in general &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; should always be the preferred way to serialize Python objects. &lt;a href=&quot;marshal#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt; exists primarily to support Python&amp;rsquo;s &lt;code&gt;.pyc&lt;/code&gt; files.</source>
          <target state="translated">파이썬에는 &lt;a href=&quot;marshal#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 이라는 더 원시적 인 직렬화 모듈이 있지만 일반적으로 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 은 항상 파이썬 객체를 직렬화하는 선호되는 방법이어야합니다. &lt;a href=&quot;marshal#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 은 주로 Python의 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 지원하기 위해 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="125ddd4ef4447aca73bf2a25322e98803fa07676" translate="yes" xml:space="preserve">
          <source>Python has been able to execute zip files which contain a &lt;code&gt;__main__.py&lt;/code&gt; file since version 2.6. In order to be executed by Python, an application archive simply has to be a standard zip file containing a &lt;code&gt;__main__.py&lt;/code&gt; file which will be run as the entry point for the application. As usual for any Python script, the parent of the script (in this case the zip file) will be placed on &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; and thus further modules can be imported from the zip file.</source>
          <target state="translated">Python은 버전 2.6 이후 &lt;code&gt;__main__.py&lt;/code&gt; 파일 을 포함하는 zip 파일을 실행할 수있었습니다 . Python에서 실행하려면 응용 프로그램 아카이브는 응용 프로그램 의 시작점으로 실행될 &lt;code&gt;__main__.py&lt;/code&gt; 파일이 포함 된 표준 zip 파일 이어야합니다. 모든 Python 스크립트와 마찬가지로 스크립트의 상위 (이 경우 zip 파일)는 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에&lt;/a&gt; 배치 되므로 zip 파일에서 추가 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8662158d794f9720576b3782157e79d1cffd1410" translate="yes" xml:space="preserve">
          <source>Python has provisional and experimental support for TLS 1.3 with OpenSSL 1.1.1. The new protocol behaves slightly differently than previous version of TLS/SSL. Some new TLS 1.3 features are not yet available.</source>
          <target state="translated">Python은 OpenSSL 1.1.1과 함께 TLS 1.3을 임시 및 실험적으로 지원합니다. 새로운 프로토콜은 이전 버전의 TLS / SSL과 약간 다르게 작동합니다. 일부 새로운 TLS 1.3 기능은 아직 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3eae67939d577e355bd547630d90de6f5735051" translate="yes" xml:space="preserve">
          <source>Python installation issues occasionally stop IDLE: multiple versions can clash, or a single installation might need admin access. If one undo the clash, or cannot or does not want to run as admin, it might be easiest to completely remove Python and start over.</source>
          <target state="translated">Python 설치 문제로 인해 IDLE이 중지되는 경우가 있습니다. 여러 버전이 충돌하거나 단일 설치에 관리자 액세스가 필요할 수 있습니다. 충돌을 취소하거나 관리자 권한으로 실행하고 싶지 않거나 실행하지 않으려면 Python을 완전히 제거하고 다시 시작하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="e2b2848aeccd01905aee189ff04a70f830b0c331" translate="yes" xml:space="preserve">
          <source>Python is started in isolated mode (command line option &lt;code&gt;-I&lt;/code&gt;), except if the &lt;code&gt;__isolated&lt;/code&gt; keyword is set to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__isolated&lt;/code&gt; 키워드가 &lt;code&gt;False&lt;/code&gt; 로 설정된 경우를 제외하고 Python은 격리 모드 (명령 행 옵션 &lt;code&gt;-I&lt;/code&gt; ) 에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="038067e0594bc4123eff8d27bc300eff7f181804" translate="yes" xml:space="preserve">
          <source>Python module&amp;rsquo;s code is recompiled and the module-level code re-executed, defining a new set of objects which are bound to names in the module&amp;rsquo;s dictionary by reusing the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; which originally loaded the module. The &lt;code&gt;init&lt;/code&gt; function of extension modules is not called a second time.</source>
          <target state="translated">Python 모듈의 코드가 다시 컴파일되고 모듈 수준 코드가 다시 실행 되어 원래 모듈을로드 한 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 를 재사용하여 모듈 사전에 이름으로 바인드 된 새 오브젝트 세트를 정의 합니다. 확장 모듈 의 &lt;code&gt;init&lt;/code&gt; 기능은 두 번째로 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ea68622690cfcc29885ac7d1676e3539567a58b" translate="yes" xml:space="preserve">
          <source>Python offers two different primitive operations based on regular expressions: &lt;a href=&quot;#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt; checks for a match only at the beginning of the string, while &lt;a href=&quot;#re.search&quot;&gt;&lt;code&gt;re.search()&lt;/code&gt;&lt;/a&gt; checks for a match anywhere in the string (this is what Perl does by default).</source>
          <target state="translated">파이썬은 정규 표현식을 기반으로 두 가지 다른 기본 연산을 제공합니다. &lt;a href=&quot;#re.match&quot;&gt; &lt;code&gt;re.match()&lt;/code&gt; &lt;/a&gt; 는 문자열의 시작 부분에서만 일치를 확인하고 &lt;a href=&quot;#re.search&quot;&gt; &lt;code&gt;re.search()&lt;/code&gt; &lt;/a&gt; 는 문자열의 어느 곳에서나 일치를 확인합니다 (기본적으로 Perl이 수행하는 작업) ).</target>
        </trans-unit>
        <trans-unit id="dc58dabbdc5bf17a7dfddcd9a8c1a72ef3764bbf" translate="yes" xml:space="preserve">
          <source>Python programmers issue warnings by calling the &lt;a href=&quot;#warnings.warn&quot;&gt;&lt;code&gt;warn()&lt;/code&gt;&lt;/a&gt; function defined in this module. (C programmers use &lt;a href=&quot;https://docs.python.org/3.8/c-api/exceptions.html#c.PyErr_WarnEx&quot;&gt;&lt;code&gt;PyErr_WarnEx()&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;https://docs.python.org/3.8/c-api/exceptions.html#exceptionhandling&quot;&gt;Exception Handling&lt;/a&gt; for details).</source>
          <target state="translated">Python 프로그래머 는이 모듈에 정의 된 &lt;a href=&quot;#warnings.warn&quot;&gt; &lt;code&gt;warn()&lt;/code&gt; &lt;/a&gt; 함수 를 호출하여 경고를 발행 합니다. (C 프로그래머는 &lt;a href=&quot;https://docs.python.org/3.8/c-api/exceptions.html#c.PyErr_WarnEx&quot;&gt; &lt;code&gt;PyErr_WarnEx()&lt;/code&gt; &lt;/a&gt; 사용 합니다. 자세한 내용 은 &lt;a href=&quot;https://docs.python.org/3.8/c-api/exceptions.html#exceptionhandling&quot;&gt;예외 처리&lt;/a&gt; 를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="e37dc2c721fd1ebbf3abee81977fa9b416561970" translate="yes" xml:space="preserve">
          <source>Python searches a standard list of directories to find one which the calling user can create files in. The list is:</source>
          <target state="translated">Python은 표준 디렉토리 목록을 검색하여 호출하는 사용자가 파일을 작성할 수있는 디렉토리를 찾습니다. 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c6d42373ec2780784c0876435cfe9919395c210" translate="yes" xml:space="preserve">
          <source>Python shell window (interactive interpreter) with colorizing of code input, output, and error messages</source>
          <target state="translated">코드 입력, 출력 및 오류 메시지를 채색하는 Python 셸 창 (대화식 인터프리터)</target>
        </trans-unit>
        <trans-unit id="2df8d28b8372bf27065261b4a06d22c97b3c0df5" translate="yes" xml:space="preserve">
          <source>Python signal handlers are always executed in the main Python thread, even if the signal was received in another thread. This means that signals can&amp;rsquo;t be used as a means of inter-thread communication. You can use the synchronization primitives from the &lt;a href=&quot;threading#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">Python 신호 처리기는 신호가 다른 스레드에서 수신 된 경우에도 항상 기본 Python 스레드에서 실행됩니다. 이는 신호를 스레드 간 통신 수단으로 사용할 수 없음을 의미합니다. 대신 &lt;a href=&quot;threading#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈 에서 동기화 프리미티브를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="805515798ecd3a95f5151c4222be6d7e0eb0a1ce" translate="yes" xml:space="preserve">
          <source>Python stores default member variable values in class attributes. Consider this example, not using dataclasses:</source>
          <target state="translated">파이썬은 기본 멤버 변수 값을 클래스 속성에 저장합니다. 데이터 클래스를 사용하지 않고이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e57d4905f981518de8f41bf06f243fe9666343f0" translate="yes" xml:space="preserve">
          <source>Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods.</source>
          <target state="translated">파이썬은 컨테이너에 대한 반복 개념을 지원합니다. 이것은 두 가지 방법으로 구현됩니다. 이것들은 사용자 정의 클래스가 반복을 지원하는 데 사용됩니다. 아래에 자세히 설명 된 시퀀스는 항상 반복 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e0a75faf88bfb70662f9456d02405996512aa26f" translate="yes" xml:space="preserve">
          <source>Python supports this conversion in several ways: the &lt;code&gt;idna&lt;/code&gt; codec performs conversion between Unicode and ACE, separating an input string into labels based on the separator characters defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3490.html#section-3.1&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;section 3.1 of RFC 3490&lt;/strong&gt;&lt;/a&gt; and converting each label to ACE as required, and conversely separating an input byte string into labels based on the &lt;code&gt;.&lt;/code&gt; separator and converting any ACE labels found into unicode. Furthermore, the &lt;a href=&quot;socket#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module transparently converts Unicode host names to ACE, so that applications need not be concerned about converting host names themselves when they pass them to the socket module. On top of that, modules that have host names as function parameters, such as &lt;a href=&quot;http.client#module-http.client&quot;&gt;&lt;code&gt;http.client&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ftplib#module-ftplib&quot;&gt;&lt;code&gt;ftplib&lt;/code&gt;&lt;/a&gt;, accept Unicode host names (&lt;a href=&quot;http.client#module-http.client&quot;&gt;&lt;code&gt;http.client&lt;/code&gt;&lt;/a&gt; then also transparently sends an IDNA hostname in the &lt;em&gt;Host&lt;/em&gt; field if it sends that field at all).</source>
          <target state="translated">파이썬은 여러 가지 방식으로이 변환을 지원합니다. &lt;code&gt;idna&lt;/code&gt; 코덱은 유니 코드와 ACE 간의 변환을 수행하고, &lt;a href=&quot;https://tools.ietf.org/html/rfc3490.html#section-3.1&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 3490의 섹션 3.1에&lt;/strong&gt;&lt;/a&gt; 정의 된 구분 문자를 기반으로 입력 문자열을 레이블 로 분리하고, 필요에 따라 각 레이블을 ACE로 변환하고, 반대로 입력을 분리합니다 에 따라 바이트 문자열을 레이블로 바꿉니다 &lt;code&gt;.&lt;/code&gt; 구분 기호를 찾아 유니 코드로 찾은 ACE 레이블을 변환합니다. 또한 &lt;a href=&quot;socket#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈은 유니 코드 호스트 이름을 투명하게 ACE로 변환하므로 응용 프로그램이 호스트 이름을 소켓 모듈로 전달할 때 호스트 이름을 변환하는 것에 대해 걱정할 필요가 없습니다. 또한 &lt;a href=&quot;http.client#module-http.client&quot;&gt; &lt;code&gt;http.client&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ftplib#module-ftplib&quot;&gt; &lt;code&gt;ftplib&lt;/code&gt; &lt;/a&gt; 와 같은 함수 매개 변수로 호스트 이름을 갖는 모듈유니 코드 호스트 이름을 수락합니다 ( &lt;a href=&quot;http.client#module-http.client&quot;&gt; &lt;code&gt;http.client&lt;/code&gt; &lt;/a&gt; 는 해당 필드를 전혀 보내지 않으면 &lt;em&gt;호스트&lt;/em&gt; 필드 에 IDNA 호스트 이름을 투명하게 보냅니다 ).</target>
        </trans-unit>
        <trans-unit id="121a3c63ec9b91ea07418db0e66efcf64062bcca" translate="yes" xml:space="preserve">
          <source>Python type</source>
          <target state="translated">파이썬 타입</target>
        </trans-unit>
        <trans-unit id="9ccd99214ece3191a794e3112fc45207a3eb50bd" translate="yes" xml:space="preserve">
          <source>Python uses an installation scheme that differs depending on the platform and on the installation options. These schemes are stored in &lt;a href=&quot;#module-sysconfig&quot;&gt;&lt;code&gt;sysconfig&lt;/code&gt;&lt;/a&gt; under unique identifiers based on the value returned by &lt;a href=&quot;os#os.name&quot;&gt;&lt;code&gt;os.name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python은 플랫폼 및 설치 옵션에 따라 다른 설치 체계를 사용합니다. 이 체계는 &lt;a href=&quot;os#os.name&quot;&gt; &lt;code&gt;os.name&lt;/code&gt; 이&lt;/a&gt; 반환 한 값을 기반으로 고유 식별자 로 &lt;a href=&quot;#module-sysconfig&quot;&gt; &lt;code&gt;sysconfig&lt;/code&gt; &lt;/a&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5252a40c4f65097cb15222a351f8348f0bc26406" translate="yes" xml:space="preserve">
          <source>Python uses files to contain certificates. They should be formatted as &amp;ldquo;PEM&amp;rdquo; (see &lt;a href=&quot;https://tools.ietf.org/html/rfc1422.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 1422&lt;/strong&gt;&lt;/a&gt;), which is a base-64 encoded form wrapped with a header line and a footer line:</source>
          <target state="translated">파이썬은 파일을 사용하여 인증서를 포함합니다. 헤더 줄과 바닥 글 줄로 감싸 인 base-64로 인코딩 된 형식 인 &quot;PEM&quot;( &lt;a href=&quot;https://tools.ietf.org/html/rfc1422.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 1422&lt;/strong&gt;&lt;/a&gt; 참조) 형식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f8bdbb93a76ab2d3cdffb25ae64e2c3b88bee50" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;s and the &lt;a href=&quot;contextlib#contextlib.contextmanager&quot;&gt;&lt;code&gt;contextlib.contextmanager&lt;/code&gt;&lt;/a&gt; decorator provide a convenient way to implement these protocols. If a generator function is decorated with the &lt;a href=&quot;contextlib#contextlib.contextmanager&quot;&gt;&lt;code&gt;contextlib.contextmanager&lt;/code&gt;&lt;/a&gt; decorator, it will return a context manager implementing the necessary &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; methods, rather than the iterator produced by an undecorated generator function.</source>
          <target state="translated">파이썬의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;제너레이터&lt;/a&gt; 와 &lt;a href=&quot;contextlib#contextlib.contextmanager&quot;&gt; &lt;code&gt;contextlib.contextmanager&lt;/code&gt; &lt;/a&gt; 데코레이터는 이러한 프로토콜을 구현하는 편리한 방법을 제공합니다. 생성기 함수가 &lt;a href=&quot;contextlib#contextlib.contextmanager&quot;&gt; &lt;code&gt;contextlib.contextmanager&lt;/code&gt; &lt;/a&gt; 데코레이터로 장식 된 경우 데코 레이팅 되지 않은 생성기 함수로 생성 된 반복자가 아닌 필요한 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메서드를 구현하는 컨텍스트 관리자를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="677bd4593d4e82724111b6c2b600512ad45bb115" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;s provide a convenient way to implement the iterator protocol. If a container object&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt; method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#generator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt; methods. More information about generators can be found in &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#yieldexpr&quot;&gt;the documentation for the yield expression&lt;/a&gt;.</source>
          <target state="translated">파이썬의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;제너레이터&lt;/a&gt; 는 이터레이터 프로토콜을 구현하는 편리한 방법을 제공합니다. 컨테이너 객체의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 메소드가 생성자로 구현되면 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#generator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 메소드를 제공하는 반복자 객체 (기술적으로 생성기 객체)를 자동으로 반환합니다 . 제너레이터에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#yieldexpr&quot;&gt;생산량 표현 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
