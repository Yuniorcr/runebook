<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="edcc18ac436a03bd44d6ef6223e83024174e89fd" translate="yes" xml:space="preserve">
          <source>Typical uses:</source>
          <target state="translated">일반적인 용도 :</target>
        </trans-unit>
        <trans-unit id="ac8bd79c1f65ce75577f89953181b5836814ced2" translate="yes" xml:space="preserve">
          <source>Typically Futures are used to enable low-level callback-based code (e.g. in protocols implemented using asyncio &lt;a href=&quot;asyncio-protocol#asyncio-transports-protocols&quot;&gt;transports&lt;/a&gt;) to interoperate with high-level async/await code.</source>
          <target state="translated">일반적으로 Futures는 저수준 콜백 기반 코드 (예 : asyncio &lt;a href=&quot;asyncio-protocol#asyncio-transports-protocols&quot;&gt;transports를&lt;/a&gt; 사용하여 구현 된 프로토콜 )가 고수준 비동기 / 대기 코드와 상호 운용 되도록하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="aa0d8913086c02de73375f9a037bf2d54a4d4b86" translate="yes" xml:space="preserve">
          <source>Typically, &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; is a list of directory names as strings. This module also allows an item of &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; to be a string naming a ZIP file archive. The ZIP archive can contain a subdirectory structure to support package imports, and a path within the archive can be specified to only import from a subdirectory. For example, the path &lt;code&gt;example.zip/lib/&lt;/code&gt; would only import from the &lt;code&gt;lib/&lt;/code&gt; subdirectory within the archive.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;/a&gt; 는 문자열로 표시되는 디렉토리 이름 목록입니다. 이 모듈은 또한 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;/a&gt; 의 항목이 ZIP 파일 아카이브를 명명하는 문자열이되도록합니다. ZIP 아카이브는 패키지 가져 오기를 지원하기위한 서브 디렉토리 구조를 포함 할 수 있으며, 서브 디렉토리에서만 가져 오도록 아카이브 내의 경로를 지정할 수 있습니다. 예를 들어, &lt;code&gt;example.zip/lib/&lt;/code&gt; 경로 는 아카이브 내의 &lt;code&gt;lib/&lt;/code&gt; 서브 디렉토리 에서만 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="307c90d60f24c34409c0cbbb907e2ebee94f9501" translate="yes" xml:space="preserve">
          <source>Typically, a mail user agent application moves all of the messages in the &lt;code&gt;new&lt;/code&gt; subdirectory to the &lt;code&gt;cur&lt;/code&gt; subdirectory after the first time the user opens and closes the mailbox, recording that the messages are old whether or not they&amp;rsquo;ve actually been read. Each message in &lt;code&gt;cur&lt;/code&gt; has an &amp;ldquo;info&amp;rdquo; section added to its file name to store information about its state. (Some mail readers may also add an &amp;ldquo;info&amp;rdquo; section to messages in &lt;code&gt;new&lt;/code&gt;.) The &amp;ldquo;info&amp;rdquo; section may take one of two forms: it may contain &amp;ldquo;2,&amp;rdquo; followed by a list of standardized flags (e.g., &amp;ldquo;2,FR&amp;rdquo;) or it may contain &amp;ldquo;1,&amp;rdquo; followed by so-called experimental information. Standard flags for Maildir messages are as follows:</source>
          <target state="translated">일반적으로 메일 사용자 에이전트 응용 프로그램 은 사용자가 처음으로 사서함을 열고 닫은 후 &lt;code&gt;new&lt;/code&gt; 하위 디렉터리 의 모든 메시지를 &lt;code&gt;cur&lt;/code&gt; 하위 디렉터리로 이동하여 실제로 읽었는지 여부에 관계없이 메시지가 오래되었음을 기록합니다. &lt;code&gt;cur&lt;/code&gt; 각 메시지에는 파일 정보에&amp;ldquo;info&amp;rdquo;섹션이 추가되어 해당 상태에 대한 정보를 저장합니다. (일부 메일 리더는 &lt;code&gt;new&lt;/code&gt; 에있는 메시지에 &quot;info&quot;섹션을 추가 할 수도 있습니다 .) &quot;info&quot;섹션은 두 가지 형식 중 하나를 취할 수 있습니다. &quot;2&quot;와 표준화 된 플래그 목록 (예 : &quot;2, FR &quot;) 또는&quot;1 &quot;과 소위 실험 정보가 포함될 수 있습니다. Maildir 메시지의 표준 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9569066be942f47eac360ee7e9604e189cacf75" translate="yes" xml:space="preserve">
          <source>Typically, clamping occurs when an exponent falls outside the context&amp;rsquo;s &lt;code&gt;Emin&lt;/code&gt; and &lt;code&gt;Emax&lt;/code&gt; limits. If possible, the exponent is reduced to fit by adding zeros to the coefficient.</source>
          <target state="translated">일반적으로 클램핑은 지수가 컨텍스트의 &lt;code&gt;Emin&lt;/code&gt; 및 &lt;code&gt;Emax&lt;/code&gt; 한계를 벗어날 때 발생합니다 . 가능하면 지수에 0을 추가하여 지수가 적합하게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="16226deec705b103a976d79100c8b31ccbd60936" translate="yes" xml:space="preserve">
          <source>Typically, this routine is used to process each portion of a request URI path, for example to treat the path as a series of dictionary keys. This routine modifies the passed-in environment to make it suitable for invoking another WSGI application that is located at the target URI. For example, if there is a WSGI application at &lt;code&gt;/foo&lt;/code&gt;, and the request URI path is &lt;code&gt;/foo/bar/baz&lt;/code&gt;, and the WSGI application at &lt;code&gt;/foo&lt;/code&gt; calls &lt;a href=&quot;#wsgiref.util.shift_path_info&quot;&gt;&lt;code&gt;shift_path_info()&lt;/code&gt;&lt;/a&gt;, it will receive the string &amp;ldquo;bar&amp;rdquo;, and the environment will be updated to be suitable for passing to a WSGI application at &lt;code&gt;/foo/bar&lt;/code&gt;. That is, &lt;code&gt;SCRIPT_NAME&lt;/code&gt; will change from &lt;code&gt;/foo&lt;/code&gt; to &lt;code&gt;/foo/bar&lt;/code&gt;, and &lt;code&gt;PATH_INFO&lt;/code&gt; will change from &lt;code&gt;/bar/baz&lt;/code&gt; to &lt;code&gt;/baz&lt;/code&gt;.</source>
          <target state="translated">일반적으로이 루틴은 요청 URI 경로의 각 부분을 처리하는 데 사용됩니다 (예 : 경로를 일련의 사전 키로 처리). 이 루틴은 전달 된 환경을 수정하여 대상 URI에있는 다른 WSGI 애플리케이션을 호출하는 데 적합합니다. 예를 들어, &lt;code&gt;/foo&lt;/code&gt; 에 WSGI 애플리케이션이 있고 요청 URI 경로가 &lt;code&gt;/foo/bar/baz&lt;/code&gt; 이고 &lt;code&gt;/foo&lt;/code&gt; 에 있는 WSGI 애플리케이션 이 &lt;a href=&quot;#wsgiref.util.shift_path_info&quot;&gt; &lt;code&gt;shift_path_info()&lt;/code&gt; &lt;/a&gt; 호출 하면 문자열 &quot;bar&quot;가 수신되고 환경이 &lt;code&gt;/foo/bar&lt;/code&gt; 의 WSGI 애플리케이션으로 전달하기에 적합하도록 업데이트됩니다 . 즉, &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 은 &lt;code&gt;/foo&lt;/code&gt; 에서 &lt;code&gt;/foo/bar&lt;/code&gt; 로 변경되며 &lt;code&gt;PATH_INFO&lt;/code&gt; 는 &lt;code&gt;/bar/baz&lt;/code&gt; 에서 &lt;code&gt;/baz&lt;/code&gt; 로 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="4c25227e4d8caebe673fedb75cae4fb249b96c0f" translate="yes" xml:space="preserve">
          <source>Typically, you should use an &amp;ldquo;/usr/bin/env python2&amp;rdquo; or &amp;ldquo;/usr/bin/env python3&amp;rdquo;, depending on whether your code is written for Python 2 or 3.</source>
          <target state="translated">일반적으로 코드가 Python 2 또는 3 용으로 작성되었는지에 따라 &quot;/ usr / bin / env python2&quot;또는 &quot;/ usr / bin / env python3&quot;을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e713da74eea6cd17134e526d4f4bfa85ea29e095" translate="yes" xml:space="preserve">
          <source>U16, utf16</source>
          <target state="translated">U16, utf16</target>
        </trans-unit>
        <trans-unit id="c72fcac268773b2862516cee4a159e76b48faf49" translate="yes" xml:space="preserve">
          <source>U32, utf32</source>
          <target state="translated">U32, utf32</target>
        </trans-unit>
        <trans-unit id="f11edf3411c63e0f8d0db9d99f22c6d068007f5f" translate="yes" xml:space="preserve">
          <source>U7, unicode-1-1-utf-7</source>
          <target state="translated">U7, 유니 코드 -1-1-UTF-7</target>
        </trans-unit>
        <trans-unit id="d24ccdbf9775e02769365300203e1554ee400e3d" translate="yes" xml:space="preserve">
          <source>U8, UTF, utf8, cp65001</source>
          <target state="translated">U8, UTF, utf8, cp65001</target>
        </trans-unit>
        <trans-unit id="6acf01764f7a6626f0891a32f61a073dc0762d8b" translate="yes" xml:space="preserve">
          <source>UDP Echo Client</source>
          <target state="translated">UDP 에코 클라이언트</target>
        </trans-unit>
        <trans-unit id="343e5cce60ceccd79ae37a898828ecb0fca0950a" translate="yes" xml:space="preserve">
          <source>UDP Echo Server</source>
          <target state="translated">UDP 에코 서버</target>
        </trans-unit>
        <trans-unit id="7d0bd1a5584aa8e277199b8bce0be0eebe6eae7c" translate="yes" xml:space="preserve">
          <source>UNC drive names are not considered:</source>
          <target state="translated">UNC 드라이브 이름은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d532d59e790c855bac6f2fd3a3d63a663ac152d" translate="yes" xml:space="preserve">
          <source>UNC shares always have a root:</source>
          <target state="translated">UNC 공유에는 항상 루트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1754f7546fc5579a80084a7fbd2c4dbd78786101" translate="yes" xml:space="preserve">
          <source>UNC shares are also considered drives:</source>
          <target state="translated">UNC 공유도 드라이브로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="46423b62f1108237d6637f21aa348b01ed444951" translate="yes" xml:space="preserve">
          <source>URL Parsing</source>
          <target state="translated">URL 파싱</target>
        </trans-unit>
        <trans-unit id="ac79cb4725903fc4cbc65532def1e7734288ed43" translate="yes" xml:space="preserve">
          <source>URL Quoting</source>
          <target state="translated">URL 인용</target>
        </trans-unit>
        <trans-unit id="c4b7ac1e2711f01d24c210e143cb9a34515550f7" translate="yes" xml:space="preserve">
          <source>URL linking to a comment from the server explaining the function of this cookie, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">URL이 쿠키, 또는의 기능을 설명하는 서버에서 댓글에 링크 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8681bd94130610c53bd7f38805813627eb6cdf42" translate="yes" xml:space="preserve">
          <source>URL opening with automatic cookie handling.</source>
          <target state="translated">자동 쿠키 처리를 통한 URL 열기</target>
        </trans-unit>
        <trans-unit id="8c6ff6209d4df1bcf1d35de653b99ca192c7aa0c" translate="yes" xml:space="preserve">
          <source>URL scheme specifier</source>
          <target state="translated">URL 스킴 지정자</target>
        </trans-unit>
        <trans-unit id="8fedebad85ba6d8c62697769bc62126e584a5f4b" translate="yes" xml:space="preserve">
          <source>URL with no fragment</source>
          <target state="translated">조각이없는 URL</target>
        </trans-unit>
        <trans-unit id="5575b942a5f6d8077af646b856fee8b432912c99" translate="yes" xml:space="preserve">
          <source>UTC is Coordinated Universal Time (formerly known as Greenwich Mean Time, or GMT). The acronym UTC is not a mistake but a compromise between English and French.</source>
          <target state="translated">UTC는 협정 세계시 (구 그리니치 표준시 또는 GMT)입니다. 약어 UTC는 실수가 아니라 영어와 프랑스어의 타협입니다.</target>
        </trans-unit>
        <trans-unit id="7bd3d96c46d2e3221efb69d9b12e15082127b8e4" translate="yes" xml:space="preserve">
          <source>UTC offset in the form &lt;code&gt;&amp;plusmn;HHMM[SS[.ffffff]]&lt;/code&gt; (empty string if the object is naive).</source>
          <target state="translated">&lt;code&gt;&amp;plusmn;HHMM[SS[.ffffff]]&lt;/code&gt; 형식의 UTC 오프셋 (객체가 순진한 경우 빈 문자열).</target>
        </trans-unit>
        <trans-unit id="de4a45e716017695cfee4bc84f1a4e0c8e1e9b9a" translate="yes" xml:space="preserve">
          <source>UTF-16BE</source>
          <target state="translated">UTF-16BE</target>
        </trans-unit>
        <trans-unit id="6af12beb19d40aa853839c482e864ce703f4d2a9" translate="yes" xml:space="preserve">
          <source>UTF-16LE</source>
          <target state="translated">UTF-16LE</target>
        </trans-unit>
        <trans-unit id="9e4d8d4f017185a065b570c771eb332a1c842bec" translate="yes" xml:space="preserve">
          <source>UTF-32BE</source>
          <target state="translated">UTF-32BE</target>
        </trans-unit>
        <trans-unit id="35cabe85c31dfe3f6b86974de33fef51a0f7276a" translate="yes" xml:space="preserve">
          <source>UTF-32LE</source>
          <target state="translated">UTF-32LE</target>
        </trans-unit>
        <trans-unit id="515451058797b204e188dd70f8d20f32dacca327" translate="yes" xml:space="preserve">
          <source>Ukrainian</source>
          <target state="translated">Ukrainian</target>
        </trans-unit>
        <trans-unit id="21c390ed919f285d1fbd2bc30ead55ffc59b9262" translate="yes" xml:space="preserve">
          <source>Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter.</source>
          <target state="translated">단항 더하기 및 빼기는 빈 카운터를 추가하거나 빈 카운터에서 빼기 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="76f4685e58374089d5c55b4161cd981dc6132724" translate="yes" xml:space="preserve">
          <source>Unary numeric methods: &lt;code&gt;__neg__&lt;/code&gt;, &lt;code&gt;__pos__&lt;/code&gt; and &lt;code&gt;__invert__&lt;/code&gt;</source>
          <target state="translated">단항 숫자 방법 : &lt;code&gt;__neg__&lt;/code&gt; , &lt;code&gt;__pos__&lt;/code&gt; 및 &lt;code&gt;__invert__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec04384d60dde2abd489f1b93a17f46f88408ec" translate="yes" xml:space="preserve">
          <source>Unary operations take the top of the stack, apply the operation, and push the result back on the stack.</source>
          <target state="translated">단항 연산은 스택의 상단을 차지하고 작업을 적용한 다음 결과를 스택에 다시 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="af724c9a541ce2ab11909206f58df607bfbac91b" translate="yes" xml:space="preserve">
          <source>UnboundLocalError</source>
          <target state="translated">UnboundLocalError</target>
        </trans-unit>
        <trans-unit id="0bbb24dbe913bf1acad1b3813b19242195efde3d" translate="yes" xml:space="preserve">
          <source>Uncomment Region</source>
          <target state="translated">주석 해제 영역</target>
        </trans-unit>
        <trans-unit id="09163dc46bc3ebc70b19a70c153e7b0ff2a536a0" translate="yes" xml:space="preserve">
          <source>Unconditionally skip the decorated test. &lt;em&gt;reason&lt;/em&gt; should describe why the test is being skipped.</source>
          <target state="translated">무조건 장식 된 테스트를 건너 뜁니다. &lt;em&gt;이유&lt;/em&gt; 는 테스트를 건너 뛴 &lt;em&gt;이유&lt;/em&gt; 를 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="b33dbdee390d46cbc4b2f0c8d71034b96e387e3a" translate="yes" xml:space="preserve">
          <source>Under System Preferences: Dock, one can set &amp;ldquo;Prefer tabs when opening documents&amp;rdquo; to &amp;ldquo;Always&amp;rdquo;. This setting is not compatible with the tk/tkinter GUI framework used by IDLE, and it breaks a few IDLE features.</source>
          <target state="translated">시스템 환경 설정 : 도크에서&amp;ldquo;문서를 열 때 선호 탭&amp;rdquo;을&amp;ldquo;항상&amp;rdquo;으로 설정할 수 있습니다. 이 설정은 IDLE에서 사용하는 tk / tkinter GUI 프레임 워크와 호환되지 않으며 몇 가지 IDLE 기능을 손상시킵니다.</target>
        </trans-unit>
        <trans-unit id="09ff4fd5fd078f6a770a49eda709711308d815f4" translate="yes" xml:space="preserve">
          <source>Under Unix, graphical browsers are preferred under X11, but text-mode browsers will be used if graphical browsers are not available or an X11 display isn&amp;rsquo;t available. If text-mode browsers are used, the calling process will block until the user exits the browser.</source>
          <target state="translated">Unix에서는 그래픽 브라우저가 X11에서 선호되지만 그래픽 브라우저를 사용할 수 없거나 X11 디스플레이를 사용할 수없는 경우 텍스트 모드 브라우저가 사용됩니다. 텍스트 모드 브라우저를 사용하는 경우 사용자가 브라우저를 종료 할 때까지 호출 프로세스가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="cc774a2bad012898ce4ca44d59cd0ee58a92ba80" translate="yes" xml:space="preserve">
          <source>Under Windows the small integer returned by this method cannot be used where a file descriptor can be used (such as &lt;a href=&quot;os#os.fdopen&quot;&gt;&lt;code&gt;os.fdopen()&lt;/code&gt;&lt;/a&gt;). Unix does not have this limitation.</source>
          <target state="translated">Windows에서는 파일 디스크립터를 사용할 수있는 위치 (예 : &lt;a href=&quot;os#os.fdopen&quot;&gt; &lt;code&gt;os.fdopen()&lt;/code&gt; &lt;/a&gt; ) 에서이 메소드가 리턴 한 작은 정수를 사용할 수 없습니다 . 유닉스에는이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="43487233aaa2dc1293a621ac76f9af16f9598bae" translate="yes" xml:space="preserve">
          <source>Under Windows, if the &lt;em&gt;winerror&lt;/em&gt; constructor argument is an integer, the &lt;a href=&quot;#OSError.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; attribute is determined from the Windows error code, and the &lt;em&gt;errno&lt;/em&gt; argument is ignored. On other platforms, the &lt;em&gt;winerror&lt;/em&gt; argument is ignored, and the &lt;a href=&quot;#OSError.winerror&quot;&gt;&lt;code&gt;winerror&lt;/code&gt;&lt;/a&gt; attribute does not exist.</source>
          <target state="translated">Windows에서 &lt;em&gt;winerror&lt;/em&gt; 생성자 인수가 정수인 경우 &lt;a href=&quot;#OSError.errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 속성은 Windows 오류 코드에서 결정되며 &lt;em&gt;errno&lt;/em&gt; 인수는 무시됩니다. 다른 플랫폼에서는 &lt;em&gt;winerror&lt;/em&gt; 인수가 무시되고 &lt;a href=&quot;#OSError.winerror&quot;&gt; &lt;code&gt;winerror&lt;/code&gt; &lt;/a&gt; 속성이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="122a25820ac6c0450f8cdb99f851d87ee3865318" translate="yes" xml:space="preserve">
          <source>Under Windows, this gives you the native Windows error code. The &lt;a href=&quot;#OSError.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; attribute is then an approximate translation, in POSIX terms, of that native error code.</source>
          <target state="translated">Windows에서는 기본 Windows 오류 코드가 표시됩니다. &lt;a href=&quot;#OSError.errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 속성은 그 원시 오류 코드의 POSIX의 측면에서 대략적인 번역입니다.</target>
        </trans-unit>
        <trans-unit id="84a4f0c399ddd6228df271cff58e6d0b91d19d11" translate="yes" xml:space="preserve">
          <source>Under all platforms, you can override the character encoding by setting the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONIOENCODING&quot; id=&quot;index-32&quot;&gt;&lt;code&gt;PYTHONIOENCODING&lt;/code&gt;&lt;/a&gt; environment variable before starting Python or by using the new &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;utf8&lt;/code&gt; command line option and &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONUTF8&quot; id=&quot;index-33&quot;&gt;&lt;code&gt;PYTHONUTF8&lt;/code&gt;&lt;/a&gt; environment variable. However, for the Windows console, this only applies when &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONLEGACYWINDOWSSTDIO&quot; id=&quot;index-34&quot;&gt;&lt;code&gt;PYTHONLEGACYWINDOWSSTDIO&lt;/code&gt;&lt;/a&gt; is also set.</source>
          <target state="translated">모든 플랫폼에서 Python을 시작하기 전에 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONIOENCODING&quot; id=&quot;index-32&quot;&gt; &lt;code&gt;PYTHONIOENCODING&lt;/code&gt; &lt;/a&gt; 환경 변수 를 설정 하거나 새로운 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;utf8&lt;/code&gt; 명령 행 옵션 및 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONUTF8&quot; id=&quot;index-33&quot;&gt; &lt;code&gt;PYTHONUTF8&lt;/code&gt; &lt;/a&gt; 환경 변수 를 사용하여 문자 인코딩을 대체 할 수 있습니다 . 그러나 Windows 콘솔의 경우 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONLEGACYWINDOWSSTDIO&quot; id=&quot;index-34&quot;&gt; &lt;code&gt;PYTHONLEGACYWINDOWSSTDIO&lt;/code&gt; &lt;/a&gt; 도 설정 한 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="86c529a5c56c8e1acf4f20d73e1f5a6a05aad70c" translate="yes" xml:space="preserve">
          <source>Under composition</source>
          <target state="translated">구성에서</target>
        </trans-unit>
        <trans-unit id="3bb49fa79f069f1e503b56cda42fc86a007f633b" translate="yes" xml:space="preserve">
          <source>Under some conditions &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; as well as the original values &lt;code&gt;__stdin__&lt;/code&gt;, &lt;code&gt;__stdout__&lt;/code&gt; and &lt;code&gt;__stderr__&lt;/code&gt; can be &lt;code&gt;None&lt;/code&gt;. It is usually the case for Windows GUI apps that aren&amp;rsquo;t connected to a console and Python apps started with &lt;strong&gt;pythonw&lt;/strong&gt;.</source>
          <target state="translated">일부 조건에서 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 과 원래 값 &lt;code&gt;__stdin__&lt;/code&gt; , &lt;code&gt;__stdout__&lt;/code&gt; 및 &lt;code&gt;__stderr__&lt;/code&gt; 은 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 콘솔에 연결되지 않은 Windows GUI 앱과 &lt;strong&gt;pythonw로&lt;/strong&gt; 시작된 Python 앱의 경우가 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="793bf299721caabec9e054ab03d026686481a8fa" translate="yes" xml:space="preserve">
          <source>Under the covers, &lt;a href=&quot;#doctest.DocTestSuite&quot;&gt;&lt;code&gt;DocTestSuite()&lt;/code&gt;&lt;/a&gt; creates a &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; out of &lt;code&gt;doctest.DocTestCase&lt;/code&gt; instances, and &lt;code&gt;DocTestCase&lt;/code&gt; is a subclass of &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;DocTestCase&lt;/code&gt; isn&amp;rsquo;t documented here (it&amp;rsquo;s an internal detail), but studying its code can answer questions about the exact details of &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; integration.</source>
          <target state="translated">표지 아래에서 &lt;a href=&quot;#doctest.DocTestSuite&quot;&gt; &lt;code&gt;DocTestSuite()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;doctest.DocTestCase&lt;/code&gt; 인스턴스에서 &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; 를&lt;/a&gt; 작성 하며 &lt;code&gt;DocTestCase&lt;/code&gt; 는 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 . &lt;code&gt;DocTestCase&lt;/code&gt; 은 여기 (이 내부 세부 사항입니다) 문서화되어 있지 않습니다,하지만 코드를 공부의 정확한 세부 사항에 대한 질문에 대답 할 수있는 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 통합을.</target>
        </trans-unit>
        <trans-unit id="f37c5cd1f45c987d07df9e3363045593abcab226" translate="yes" xml:space="preserve">
          <source>Underline mode</source>
          <target state="translated">밑줄 모드</target>
        </trans-unit>
        <trans-unit id="cdc95b3422722b03a214a7379a614933ad297732" translate="yes" xml:space="preserve">
          <source>Underlying encoded files are always opened in binary mode. No automatic conversion of &lt;code&gt;'\n'&lt;/code&gt; is done on reading and writing. The &lt;em&gt;mode&lt;/em&gt; argument may be any binary mode acceptable to the built-in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function; the &lt;code&gt;'b'&lt;/code&gt; is automatically added.</source>
          <target state="translated">기본 인코딩 된 파일은 항상 이진 모드로 열립니다. 읽고 쓸 때 자동으로 &lt;code&gt;'\n'&lt;/code&gt; 변환 이 수행 되지 않습니다 . &lt;em&gt;모드&lt;/em&gt; 인수 수락 바이너리 모드 일 수있는 내장형 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 기능; &lt;code&gt;'b'&lt;/code&gt; 자동으로 추가된다.</target>
        </trans-unit>
        <trans-unit id="1c426c5d3245f89c66b8d44eb9a7418a57214883" translate="yes" xml:space="preserve">
          <source>Underlying file descriptor.</source>
          <target state="translated">기본 파일 설명자.</target>
        </trans-unit>
        <trans-unit id="39fc72124884d6573e4f9f89585f071ed0782696" translate="yes" xml:space="preserve">
          <source>Undo</source>
          <target state="translated">Undo</target>
        </trans-unit>
        <trans-unit id="facdf490605511ac7953e25b9d58432a61076c4e" translate="yes" xml:space="preserve">
          <source>Undo (repeatedly) the last turtle action(s). Number of available undo actions is determined by the size of the undobuffer.</source>
          <target state="translated">마지막 거북이 작업을 취소합니다 (반복적으로). 사용 가능한 실행 취소 작업 수는 실행 취소 버퍼 크기에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="12ffa2fcbfc6a89513586da0ea5253ed26d4950d" translate="yes" xml:space="preserve">
          <source>Undo the last change to the current window. A maximum of 1000 changes may be undone.</source>
          <target state="translated">현재 창에 대한 마지막 변경을 취소하십시오. 최대 1000 개의 변경 사항이 취소 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5173f55ca599f2baa4e8cf060601f130743f6e5c" translate="yes" xml:space="preserve">
          <source>Undocumented Modules</source>
          <target state="translated">문서화되지 않은 모듈</target>
        </trans-unit>
        <trans-unit id="7afa636f1dcd288a19ebf51b051831aa190255a4" translate="yes" xml:space="preserve">
          <source>Unescape &lt;code&gt;'&amp;amp;amp;'&lt;/code&gt;, &lt;code&gt;'&amp;amp;lt;'&lt;/code&gt;, and &lt;code&gt;'&amp;amp;gt;'&lt;/code&gt; in a string of data.</source>
          <target state="translated">&lt;code&gt;'&amp;amp;amp;'&lt;/code&gt; 탈출 , &lt;code&gt;'&amp;amp;lt;'&lt;/code&gt; 및 &lt;code&gt;'&amp;amp;gt;'&lt;/code&gt; 일련의 데이터로.</target>
        </trans-unit>
        <trans-unit id="1ae07519eb339aa0a6d65a7ecc51b6a9a2141e8c" translate="yes" xml:space="preserve">
          <source>Unfinished errata to &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2965에 대한&lt;/strong&gt;&lt;/a&gt; 미완성 정오표 .</target>
        </trans-unit>
        <trans-unit id="760f925ad5f161e1f96d23cf3994740c822322b1" translate="yes" xml:space="preserve">
          <source>Unfortunately, a CGI script will generally not run when you try it from the command line, and a script that works perfectly from the command line may fail mysteriously when run from the server. There&amp;rsquo;s one reason why you should still test your script from the command line: if it contains a syntax error, the Python interpreter won&amp;rsquo;t execute it at all, and the HTTP server will most likely send a cryptic error to the client.</source>
          <target state="translated">불행히도 CGI 스크립트는 일반적으로 명령 줄에서 시도 할 때 실행되지 않으며 명령 줄에서 완벽하게 작동하는 스크립트가 서버에서 실행될 때 신비하게 실패 할 수 있습니다. 명령 행에서 스크립트를 테스트해야하는 한 가지 이유가 있습니다. 구문 오류가 포함 된 경우 Python 인터프리터는 스크립트를 전혀 실행하지 않으며 HTTP 서버는 대부분 클라이언트에게 암호 오류를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4cb76619273a40dbd3b69446939d186f550fa921" translate="yes" xml:space="preserve">
          <source>Unfortunately, in the current implementation of &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; it is not possible to hand over an arbitrary Python variable to a widget through a &lt;code&gt;variable&lt;/code&gt; or &lt;code&gt;textvariable&lt;/code&gt; option. The only kinds of variables for which this works are variables that are subclassed from a class called Variable, defined in &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">불행히도, &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 의 현재 구현 에서는 &lt;code&gt;variable&lt;/code&gt; 또는 &lt;code&gt;textvariable&lt;/code&gt; 변수 옵션을 통해 임의의 Python 변수를 위젯으로 넘길 수 없습니다. 이것이 작동하는 변수의 유일한 종류는 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; 에&lt;/a&gt; 정의 된 Variable 클래스에서 서브 클래 싱 된 변수입니다 .</target>
        </trans-unit>
        <trans-unit id="6c4109db22111ac0157ddd1a1b60ab5ea903954f" translate="yes" xml:space="preserve">
          <source>Unfreeze the objects in the permanent generation, put them back into the oldest generation.</source>
          <target state="translated">영구 세대의 물체를 고정 해제하고 가장 오래된 세대로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="e7fc7822d3ca51d28bdd7a9ee19f9336a4230d3b" translate="yes" xml:space="preserve">
          <source>Unicode character</source>
          <target state="translated">유니 코드 문자</target>
        </trans-unit>
        <trans-unit id="9e8265bf80e6bc5985b5427e35abc3cdd9d7da17" translate="yes" xml:space="preserve">
          <source>Unicode issues</source>
          <target state="translated">유니 코드 문제</target>
        </trans-unit>
        <trans-unit id="b5b526768b1969cfa8a08fe014a311e1718f9ed9" translate="yes" xml:space="preserve">
          <source>UnicodeDecodeError</source>
          <target state="translated">UnicodeDecodeError</target>
        </trans-unit>
        <trans-unit id="f9973e2691d99be91e5b5ef9ad2cbe53ffe3fadc" translate="yes" xml:space="preserve">
          <source>UnicodeEncodeError</source>
          <target state="translated">UnicodeEncodeError</target>
        </trans-unit>
        <trans-unit id="58283ecfa32971a53446570a674574fdd0222dda" translate="yes" xml:space="preserve">
          <source>UnicodeError</source>
          <target state="translated">UnicodeError</target>
        </trans-unit>
        <trans-unit id="f1716ad72e62babae0b6ebd36034174f931ab674" translate="yes" xml:space="preserve">
          <source>UnicodeError.encoding</source>
          <target state="translated">UnicodeError.encoding</target>
        </trans-unit>
        <trans-unit id="fe9d3d97c338283ce266f47d2b1d395c73fb7f1d" translate="yes" xml:space="preserve">
          <source>UnicodeError.end</source>
          <target state="translated">UnicodeError.end</target>
        </trans-unit>
        <trans-unit id="656ba97916742be36d330b15af168cbc79f8a2ab" translate="yes" xml:space="preserve">
          <source>UnicodeError.object</source>
          <target state="translated">UnicodeError.object</target>
        </trans-unit>
        <trans-unit id="14cca87e64dbb585003f7df820b8f5a57f0aab80" translate="yes" xml:space="preserve">
          <source>UnicodeError.reason</source>
          <target state="translated">UnicodeError.reason</target>
        </trans-unit>
        <trans-unit id="3b8f61fae443c3cca69d6e573eb7e4f82cd7d379" translate="yes" xml:space="preserve">
          <source>UnicodeError.start</source>
          <target state="translated">UnicodeError.start</target>
        </trans-unit>
        <trans-unit id="86ef62e8ac070df397f526dd95d38ffc3c15aeee" translate="yes" xml:space="preserve">
          <source>UnicodeTranslateError</source>
          <target state="translated">UnicodeTranslateError</target>
        </trans-unit>
        <trans-unit id="b71d2cc5fd619eca3b73d5c3091b18067741280b" translate="yes" xml:space="preserve">
          <source>UnicodeWarning</source>
          <target state="translated">UnicodeWarning</target>
        </trans-unit>
        <trans-unit id="23e60ae32a7af57bd10051941d5faa9269e1cbba" translate="yes" xml:space="preserve">
          <source>Unified Chinese</source>
          <target state="translated">통합 중국어</target>
        </trans-unit>
        <trans-unit id="48bf340eb1af34013d116721a6b365f7bd850c4d" translate="yes" xml:space="preserve">
          <source>Unified diffs are a compact way of showing just the lines that have changed plus a few lines of context. The changes are shown in an inline style (instead of separate before/after blocks). The number of context lines is set by &lt;em&gt;n&lt;/em&gt; which defaults to three.</source>
          <target state="translated">통합 diff는 변경된 라인과 몇 줄의 컨텍스트 만 표시하는 간단한 방법입니다. 변경 사항은 별도의 전후 블록 대신 인라인 스타일로 표시됩니다. 컨텍스트 라인 수는 &lt;em&gt;n&lt;/em&gt; 으로 설정되며 기본값은 3입니다.</target>
        </trans-unit>
        <trans-unit id="b23a036b5a5fc3d186211fcee99032ae543b0068" translate="yes" xml:space="preserve">
          <source>Union type; &lt;code&gt;Union[X, Y]&lt;/code&gt; means either X or Y.</source>
          <target state="translated">유니온 타입; &lt;code&gt;Union[X, Y]&lt;/code&gt; 는 X 또는 Y를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0eb559f7d253f052b5fc0c24eb1006d8b21bb4e2" translate="yes" xml:space="preserve">
          <source>Unions of a single argument vanish, e.g.:</source>
          <target state="translated">단일 논쟁의 연합은 사라진다. 예 :</target>
        </trans-unit>
        <trans-unit id="e074348d912505b595223b5c9df37529adad25df" translate="yes" xml:space="preserve">
          <source>Unions of unions are flattened, e.g.:</source>
          <target state="translated">예를 들어 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="a6013fd2beb609fb6c408bc5428b39a0ba92fa33" translate="yes" xml:space="preserve">
          <source>UniqueAddressHeader</source>
          <target state="translated">UniqueAddressHeader</target>
        </trans-unit>
        <trans-unit id="8cadb2b420289f9e588a18d9273812d40cde290f" translate="yes" xml:space="preserve">
          <source>UniqueDateHeader</source>
          <target state="translated">UniqueDateHeader</target>
        </trans-unit>
        <trans-unit id="f6e35626af402641832362022f7bb51f7666a5d5" translate="yes" xml:space="preserve">
          <source>UniqueSingleAddressHeader</source>
          <target state="translated">UniqueSingleAddressHeader</target>
        </trans-unit>
        <trans-unit id="5e5b15a19084f3693eb1aaa731c3bfb0eff4150a" translate="yes" xml:space="preserve">
          <source>UniqueUnstructuredHeader</source>
          <target state="translated">UniqueUnstructuredHeader</target>
        </trans-unit>
        <trans-unit id="3db9bdfab0f022f13a4bb48d254cae9da8cb6639" translate="yes" xml:space="preserve">
          <source>Unit separator</source>
          <target state="translated">단위 분리기</target>
        </trans-unit>
        <trans-unit id="dc4f2bd7bfcffb7a6d6e83447eac85d3afa07920" translate="yes" xml:space="preserve">
          <source>Unittest API</source>
          <target state="translated">단위 테스트 API</target>
        </trans-unit>
        <trans-unit id="e675c3dd2d602712e85f0cdbca3a0feb954afda6" translate="yes" xml:space="preserve">
          <source>Unittest supports simple test discovery. In order to be compatible with test discovery, all of the test files must be &lt;a href=&quot;https://docs.python.org/3.8/tutorial/modules.html#tut-modules&quot;&gt;modules&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/tutorial/modules.html#tut-packages&quot;&gt;packages&lt;/a&gt; (including &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-namespace-package&quot;&gt;namespace packages&lt;/a&gt;) importable from the top-level directory of the project (this means that their filenames must be valid &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#identifiers&quot;&gt;identifiers&lt;/a&gt;).</source>
          <target state="translated">Unittest는 간단한 테스트 검색을 지원합니다. 테스트 발견과 호환 되려면 모든 테스트 파일 이 프로젝트의 최상위 디렉토리에서 가져올 수 있는 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/modules.html#tut-modules&quot;&gt;모듈&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/modules.html#tut-packages&quot;&gt;패키지&lt;/a&gt; ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-namespace-package&quot;&gt;네임 스페이스 패키지&lt;/a&gt; 포함 ) 여야합니다 (이는 파일 이름이 유효한 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#identifiers&quot;&gt;식별자&lt;/a&gt; 여야 함을 의미 함 ).</target>
        </trans-unit>
        <trans-unit id="6f5a7f4e3781a69dbf9bc8bde34477a22943eb3a" translate="yes" xml:space="preserve">
          <source>Unittest supports skipping individual test methods and even whole classes of tests. In addition, it supports marking a test as an &amp;ldquo;expected failure,&amp;rdquo; a test that is broken and will fail, but shouldn&amp;rsquo;t be counted as a failure on a &lt;a href=&quot;#unittest.TestResult&quot;&gt;&lt;code&gt;TestResult&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unittest는 개별 테스트 방법과 전체 테스트 클래스 건너 뛰기를 지원합니다. 또한 테스트를 &quot;예상 실패&quot;로 표시하는 기능을 지원합니다.이 테스트는 중단되어 실패하지만 &lt;a href=&quot;#unittest.TestResult&quot;&gt; &lt;code&gt;TestResult&lt;/code&gt; &lt;/a&gt; 에서 실패로 간주해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="61269b47d1912b3422eba3f73aece2ef97a5b744" translate="yes" xml:space="preserve">
          <source>Unix Platforms</source>
          <target state="translated">유닉스 플랫폼</target>
        </trans-unit>
        <trans-unit id="0e13810f1a14b62c949e081b6a7b9339dcbb5a03" translate="yes" xml:space="preserve">
          <source>Unix Signals</source>
          <target state="translated">유닉스 신호</target>
        </trans-unit>
        <trans-unit id="6816141193a0e3dc3b48a84b10bea2489b164992" translate="yes" xml:space="preserve">
          <source>Unix Sockets</source>
          <target state="translated">유닉스 소켓</target>
        </trans-unit>
        <trans-unit id="1bdb0064b2fcd2fcd102a38464d440d9eff8fea9" translate="yes" xml:space="preserve">
          <source>Unix Specific Services</source>
          <target state="translated">유닉스 전용 서비스</target>
        </trans-unit>
        <trans-unit id="847c5fad076a68d49660f9eb9a8817b853479991" translate="yes" xml:space="preserve">
          <source>Unix V7 synonym for &lt;a href=&quot;#stat.S_IRUSR&quot;&gt;&lt;code&gt;S_IRUSR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유닉스 V7은 동의어 &lt;a href=&quot;#stat.S_IRUSR&quot;&gt; &lt;code&gt;S_IRUSR&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c559c0bd7b52c6d5fcd6c4cdfa0164567d71c81" translate="yes" xml:space="preserve">
          <source>Unix V7 synonym for &lt;a href=&quot;#stat.S_IWUSR&quot;&gt;&lt;code&gt;S_IWUSR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유닉스 V7은 동의어 &lt;a href=&quot;#stat.S_IWUSR&quot;&gt; &lt;code&gt;S_IWUSR&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46b7a407dbe01720c5581466e65e5d6766b08dcd" translate="yes" xml:space="preserve">
          <source>Unix V7 synonym for &lt;a href=&quot;#stat.S_IXUSR&quot;&gt;&lt;code&gt;S_IXUSR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#stat.S_IXUSR&quot;&gt; &lt;code&gt;S_IXUSR&lt;/code&gt; 에&lt;/a&gt; 대한 Unix V7 동의어 .</target>
        </trans-unit>
        <trans-unit id="082c2a1389c9c2ea8c60ebb7f7c8a999f936e231" translate="yes" xml:space="preserve">
          <source>Unix shell-style path expansion.</source>
          <target state="translated">유닉스 쉘 스타일 경로 확장.</target>
        </trans-unit>
        <trans-unit id="32e32465c877196c71d88374d755b3b7baedfc11" translate="yes" xml:space="preserve">
          <source>Unix signals</source>
          <target state="translated">유닉스 신호</target>
        </trans-unit>
        <trans-unit id="5e4a3d86de027e8272c31e5a7f66ec8b0b49bbef" translate="yes" xml:space="preserve">
          <source>UnknownHandler Objects</source>
          <target state="translated">UnknownHandler 객체</target>
        </trans-unit>
        <trans-unit id="4cd89cfc1a4e26f640c99600149f2caa1d397d8a" translate="yes" xml:space="preserve">
          <source>Unless explicitly noted, these functions support &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt;. Behaviour with other types (whether in the numeric tower or not) is currently unsupported. Collections with a mix of types are also undefined and implementation-dependent. If your input data consists of mixed types, you may be able to use &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; to ensure a consistent result, for example: &lt;code&gt;map(float, input_data)&lt;/code&gt;.</source>
          <target state="translated">명시 적으로 언급되지 않는 한,이 함수는 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; 을 지원&lt;/a&gt; 합니다. 다른 유형의 동작 (숫자 탑에 있든 없든)은 현재 지원되지 않습니다. 다양한 유형의 컬렉션은 정의되지 않으며 구현에 따라 다릅니다. 입력 데이터가 혼합 유형으로 구성된 경우 &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 을 사용하여 일관된 결과를 보장 할 수 있습니다 ( 예 : &lt;code&gt;map(float, input_data)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b245a8781f57e2ee32cd0bd7e365277ad5f0b91" translate="yes" xml:space="preserve">
          <source>Unless intentionally delayed, login is normally performed during the &lt;a href=&quot;#nntplib.NNTP&quot;&gt;&lt;code&gt;NNTP&lt;/code&gt;&lt;/a&gt; object initialization and separately calling this function is unnecessary. To force authentication to be delayed, you must not set &lt;em&gt;user&lt;/em&gt; or &lt;em&gt;password&lt;/em&gt; when creating the object, and must set &lt;em&gt;usenetrc&lt;/em&gt; to False.</source>
          <target state="translated">의도적으로 지연되지 않는 한 일반적으로 &lt;a href=&quot;#nntplib.NNTP&quot;&gt; &lt;code&gt;NNTP&lt;/code&gt; &lt;/a&gt; 객체 초기화 중에 로그인이 수행되며 별도로이 기능을 호출 할 필요가 없습니다. 인증을 강제로 지연 시키려면 오브젝트를 작성할 때 &lt;em&gt;사용자&lt;/em&gt; 또는 &lt;em&gt;비밀번호&lt;/em&gt; 를 설정하지 &lt;em&gt;말고 usenetrc&lt;/em&gt; 를 False로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7daaf11df16b200f419dc320e67a326ec4d10c2" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, the connection will be open even after an exception is raised.</source>
          <target state="translated">달리 명시되지 않는 한 예외가 발생한 후에도 연결이 열립니다.</target>
        </trans-unit>
        <trans-unit id="7339f074fcb0ea2ac52be61a728102c0e5798d94" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, all network methods accepting other network/address objects will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the argument&amp;rsquo;s IP version is incompatible to &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">달리 명시되지 않는 한 , 인수의 IP 버전이 &lt;code&gt;self&lt;/code&gt; 와 호환되지 않으면 다른 네트워크 / 주소 객체를 허용하는 모든 네트워크 메소드는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="993ab4594b8b02fc5860d357a6b3b9b2b3ab001e" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;--without-pip&lt;/code&gt; option is given, &lt;a href=&quot;ensurepip#module-ensurepip&quot;&gt;&lt;code&gt;ensurepip&lt;/code&gt;&lt;/a&gt; will be invoked to bootstrap &lt;code&gt;pip&lt;/code&gt; into the virtual environment.</source>
          <target state="translated">하지 않으면 &lt;code&gt;--without-pip&lt;/code&gt; 옵션이 주어, &lt;a href=&quot;ensurepip#module-ensurepip&quot;&gt; &lt;code&gt;ensurepip&lt;/code&gt; 는&lt;/a&gt; 부트 스트랩에 호출됩니다 &lt;code&gt;pip&lt;/code&gt; 가상 환경에.</target>
        </trans-unit>
        <trans-unit id="c4a782d6fa682b46e8e886c88894b4beb34c1b11" translate="yes" xml:space="preserve">
          <source>Unless the &lt;em&gt;_charset&lt;/em&gt; argument is explicitly set to &lt;code&gt;None&lt;/code&gt;, the MIMEText object created will have both a &lt;em&gt;Content-Type&lt;/em&gt; header with a &lt;code&gt;charset&lt;/code&gt; parameter, and a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header. This means that a subsequent &lt;code&gt;set_payload&lt;/code&gt; call will not result in an encoded payload, even if a charset is passed in the &lt;code&gt;set_payload&lt;/code&gt; command. You can &amp;ldquo;reset&amp;rdquo; this behavior by deleting the &lt;code&gt;Content-Transfer-Encoding&lt;/code&gt; header, after which a &lt;code&gt;set_payload&lt;/code&gt; call will automatically encode the new payload (and add a new &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header).</source>
          <target state="translated">&lt;em&gt;_charset&lt;/em&gt; 인수가 명시 적으로 &lt;code&gt;None&lt;/code&gt; 으로 설정되어 있지 않은 경우, 작성된 MIMEText 객체 에는 &lt;code&gt;charset&lt;/code&gt; 매개 변수가 있는 &lt;em&gt;Content-Type&lt;/em&gt; 헤더와 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더가 있습니다. 이것은 후속&lt;em&gt;&lt;/em&gt; &lt;code&gt;set_payload&lt;/code&gt; &lt;code&gt;set_payload&lt;/code&gt; 명령 에서 문자 세트가 전달 되더라도 set_payload 호출로 인해 인코딩 된 페이로드가 발생하지 않음을 . &lt;code&gt;Content-Transfer-Encoding&lt;/code&gt; 헤더 를 삭제하여이 동작을 &quot;재설정&quot;할 수 있습니다. 그 후 &lt;code&gt;set_payload&lt;/code&gt; 호출은 자동으로 새로운 페이로드를 인코딩하고 새로운 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="41468c42a8b09a43651139d245a1d58ff2225ad6" translate="yes" xml:space="preserve">
          <source>Unless you set the &lt;a href=&quot;#weakref.finalize.atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt; attribute to &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, a finalizer will be called when the program exits if it is still alive. For instance</source>
          <target state="translated">&lt;a href=&quot;#weakref.finalize.atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt; 속성을 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 로&lt;/a&gt; 설정하지 않으면 프로그램이 아직 활성 상태 인 경우 프로그램이 종료 될 때 종료자가 호출됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8ac92788612719ddd5c97ea10f0326dfc1c7c844" translate="yes" xml:space="preserve">
          <source>Unless you wish to use &lt;a href=&quot;#smtplib.SMTP.has_extn&quot;&gt;&lt;code&gt;has_extn()&lt;/code&gt;&lt;/a&gt; before sending mail, it should not be necessary to call this method explicitly. It will be implicitly called by &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;sendmail()&lt;/code&gt;&lt;/a&gt; when necessary.</source>
          <target state="translated">사용하지 않으려는 경우 &lt;a href=&quot;#smtplib.SMTP.has_extn&quot;&gt; &lt;code&gt;has_extn()&lt;/code&gt; &lt;/a&gt;메일을 보내기 전에 has_extn ()한이 메소드를 명시 적으로 호출 할 필요는 없습니다. 필요한 경우&lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;sendmail()&lt;/code&gt; &lt;/a&gt; 의해 암시 적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0c258f7bb0ea2dfce26a7399ef9cf54157425d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#asyncio.BoundedSemaphore&quot;&gt;&lt;code&gt;BoundedSemaphore&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; allows making more &lt;code&gt;release()&lt;/code&gt; calls than &lt;code&gt;acquire()&lt;/code&gt; calls.</source>
          <target state="translated">달리 &lt;a href=&quot;#asyncio.BoundedSemaphore&quot;&gt; &lt;code&gt;BoundedSemaphore&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#asyncio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; 더 만들기 허용 &lt;code&gt;release()&lt;/code&gt; 이상 통화 &lt;code&gt;acquire()&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="33618204c6228bb2f08249a4999150db6c1a3c5a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#asyncio.wait_for&quot;&gt;&lt;code&gt;wait_for()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;wait()&lt;/code&gt; does not cancel the futures when a timeout occurs.</source>
          <target state="translated">달리 &lt;a href=&quot;#asyncio.wait_for&quot;&gt; &lt;code&gt;wait_for()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;wait()&lt;/code&gt; 시간 초과가 발생하면 선물을 취소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67e1ebd0e3d2c8e2ee24effe1aafb7d36dfc4f44" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#bytes.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; when a delimiter string &lt;em&gt;sep&lt;/em&gt; is given, this method returns an empty list for the empty string, and a terminal line break does not result in an extra line:</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#bytes.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt;구분자 문자열&lt;em&gt; sep&lt;/em&gt; 가 제공될 때 split ()메소드는 빈 문자열에 대한 빈 목록을 리턴하며 터미널 행 분리는 추가 행을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1293cddc7f4a5a7d63761eedfd744e93178c07" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#str.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; when a delimiter string &lt;em&gt;sep&lt;/em&gt; is given, this method returns an empty list for the empty string, and a terminal line break does not result in an extra line:</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#str.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt;구분자 문자열&lt;em&gt; sep&lt;/em&gt; 가 제공될 때 split ()메소드는 빈 문자열에 대한 빈 목록을 리턴하며 터미널 행 분리는 추가 행을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3e82dc45fec18fee8381940667b7739fe395eba" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#str.swapcase&quot;&gt;&lt;code&gt;str.swapcase()&lt;/code&gt;&lt;/a&gt;, it is always the case that &lt;code&gt;bin.swapcase().swapcase() == bin&lt;/code&gt; for the binary versions. Case conversions are symmetrical in ASCII, even though that is not generally true for arbitrary Unicode code points.</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#str.swapcase&quot;&gt; &lt;code&gt;str.swapcase()&lt;/code&gt; &lt;/a&gt;바이너리 버전의 경우 항상 &lt;code&gt;bin.swapcase().swapcase() == bin&lt;/code&gt; 입니다. 임의의 유니 코드 코드 포인트에는 일반적으로 적용되지 않지만 대소 문자 변환은 ASCII로 대칭입니다.</target>
        </trans-unit>
        <trans-unit id="0c95a6d7a10d383afd78d9c0e2a9a3a25e57da5e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt;&lt;code&gt;TemporaryFile()&lt;/code&gt;&lt;/a&gt;, the user of &lt;a href=&quot;#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt; is responsible for deleting the temporary file when done with it.</source>
          <target state="translated">&lt;a href=&quot;#tempfile.TemporaryFile&quot;&gt; &lt;code&gt;TemporaryFile()&lt;/code&gt; &lt;/a&gt; 과 달리&lt;a href=&quot;#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; 의 사용자 는 임시 파일을 완료하면 파일을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="d713f1bbd5fe8d9d3ef65d626ba711d216ccc024" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asynchat.async_chat&quot;&gt;&lt;code&gt;async_chat&lt;/code&gt;&lt;/a&gt; allows you to define a</source>
          <target state="translated">&lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt; 와 달리 , &lt;a href=&quot;#asynchat.async_chat&quot;&gt; &lt;code&gt;async_chat&lt;/code&gt; 는&lt;/a&gt; 당신이를 정의 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5c886da08a6499e65a78a1b5c0d1665bb125f558" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;SimpleNamespace&lt;/code&gt; you can add and remove attributes. If a &lt;code&gt;SimpleNamespace&lt;/code&gt; object is initialized with keyword arguments, those are directly added to the underlying namespace.</source>
          <target state="translated">&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 와 달리 로 &lt;code&gt;SimpleNamespace&lt;/code&gt; 추가하고 속성을 제거 할 수 있습니다. 경우 &lt;code&gt;SimpleNamespace&lt;/code&gt; 의 객체가 키워드 인자로 초기화되어, 사람들은 직접 기본 네임 스페이스에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="596d48dc2d054d385685290e71d4024b5251eff2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;marshal#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt;, JSON is not a framed protocol, so trying to serialize multiple objects with repeated calls to &lt;a href=&quot;#json.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; using the same &lt;em&gt;fp&lt;/em&gt; will result in an invalid JSON file.</source>
          <target state="translated">&lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;marshal#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 과 달리 JSON은 프레임 프로토콜이 아니므로 여러 객체를 직렬화하려고 시도하면 &lt;a href=&quot;#json.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 를 반복해서 호출합니다. 동일한 &lt;em&gt;fp&lt;/em&gt; 를 사용하여 를 JSON 파일이 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="75c3001ddb5896b3f0beaf0cf2b3057b6d86a8ca" translate="yes" xml:space="preserve">
          <source>Unlike GNU &lt;code&gt;getopt()&lt;/code&gt;, after a non-option argument, all further arguments are considered also non-options. This is similar to the way non-GNU Unix systems work.</source>
          <target state="translated">GNU &lt;code&gt;getopt()&lt;/code&gt; 와 달리 옵션이 아닌 인수 뒤에는 모든 추가 인수도 옵션이 아닌 것으로 간주됩니다. 이는 GNU 이외의 Unix 시스템이 작동하는 방식과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="1dec49b182e8d7603947a0985b2ecf4c1b9d6835" translate="yes" xml:space="preserve">
          <source>Unlike Java abstract methods, these abstract methods may have an implementation. This implementation can be called via the &lt;a href=&quot;functions#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; mechanism from the class that overrides it. This could be useful as an end-point for a super-call in a framework that uses cooperative multiple-inheritance.</source>
          <target state="translated">Java 추상 메소드와 달리이 추상 메소드는 구현을 가질 수 있습니다. 이 구현은이 를 재정의하는 클래스에서 &lt;a href=&quot;functions#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 메커니즘을 통해 호출 할 수 있습니다 . 이것은 협동 다중 상속을 사용하는 프레임 워크에서 수퍼 콜의 엔드 포인트로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f16780c200014deeda946367354cdafa913c303" translate="yes" xml:space="preserve">
          <source>Unlike a dictionary, &lt;a href=&quot;#wsgiref.headers.Headers&quot;&gt;&lt;code&gt;Headers&lt;/code&gt;&lt;/a&gt; objects do not raise an error when you try to get or delete a key that isn&amp;rsquo;t in the wrapped header list. Getting a nonexistent header just returns &lt;code&gt;None&lt;/code&gt;, and deleting a nonexistent header does nothing.</source>
          <target state="translated">사전과 달리 줄 바꿈 된 헤더 목록에없는 키를 가져 오거나 삭제하려고하면 &lt;a href=&quot;#wsgiref.headers.Headers&quot;&gt; &lt;code&gt;Headers&lt;/code&gt; &lt;/a&gt; 객체에서 오류가 발생하지 않습니다. 존재하지 않는 헤더를 가져 오면 &lt;code&gt;None&lt;/code&gt; 이 반환 되고 존재하지 않는 헤더를 삭제하면 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c6f6aee98d471465b243d4e2fd41bf6e3854779" translate="yes" xml:space="preserve">
          <source>Unlike a unix shell, Python does not do any &lt;em&gt;automatic&lt;/em&gt; path expansions. Functions such as &lt;a href=&quot;#os.path.expanduser&quot;&gt;&lt;code&gt;expanduser()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.path.expandvars&quot;&gt;&lt;code&gt;expandvars()&lt;/code&gt;&lt;/a&gt; can be invoked explicitly when an application desires shell-like path expansion. (See also the &lt;a href=&quot;glob#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; module.)</source>
          <target state="translated">유닉스 쉘과 달리 파이썬은 &lt;em&gt;자동&lt;/em&gt; 경로 확장을 수행하지 않습니다 . 같은 기능 &lt;a href=&quot;#os.path.expanduser&quot;&gt; &lt;code&gt;expanduser()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#os.path.expandvars&quot;&gt; &lt;code&gt;expandvars()&lt;/code&gt; &lt;/a&gt; 응용 프로그램의 욕망 쉘 같은 경우 경로 확장 명시 적으로 호출 할 수 있습니다. (또한 참조&lt;a href=&quot;glob#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 모듈.)</target>
        </trans-unit>
        <trans-unit id="e7bd162bae41d85a4f9b40addad75b0dfc5f8ca4" translate="yes" xml:space="preserve">
          <source>Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be as large as needed for a given problem:</source>
          <target state="translated">하드웨어 기반 이진 부동 소수점과 달리, 십진 모듈은 사용자가 변경할 수있는 정밀도 (기본값은 28 자리)이며 주어진 문제에 필요한만큼 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed2b66476f9ed547b34b80c9bc1ba9db01e1b4b" translate="yes" xml:space="preserve">
          <source>Unlike normal generators, async generators cannot return a value, so there is no &lt;code&gt;ReturnType&lt;/code&gt; type parameter. As with &lt;a href=&quot;#typing.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SendType&lt;/code&gt; behaves contravariantly.</source>
          <target state="translated">일반 생성기와 달리 비동기 생성기는 값을 반환 할 수 없으므로 &lt;code&gt;ReturnType&lt;/code&gt; 형식 매개 변수 가 없습니다 . 와 같이 &lt;a href=&quot;#typing.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;SendType&lt;/code&gt; contravariantly 동작합니다.</target>
        </trans-unit>
        <trans-unit id="02e5049358a9b6f903a818d8a1d172b104aa9a7e" translate="yes" xml:space="preserve">
          <source>Unlike other asyncio functions this function requires the &lt;em&gt;loop&lt;/em&gt; argument to be passed explicitly.</source>
          <target state="translated">다른 asyncio 함수와 달리이 함수에는 &lt;em&gt;루프&lt;/em&gt; 가 필요합니다&lt;em&gt;&lt;/em&gt; 인수를 명시 적으로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="daabe887cf8afd0ee7dd85b067f7ffc7a6ff2139" translate="yes" xml:space="preserve">
          <source>Unlike other operations, if the length of the coefficient after the quantize operation would be greater than precision, then an &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt; is signaled. This guarantees that, unless there is an error condition, the quantized exponent is always equal to that of the right-hand operand.</source>
          <target state="translated">다른 연산과 달리 양자화 연산 후 계수의 길이가 정밀도보다 크면 &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; &lt;/a&gt; 이 신호됩니다. 이를 통해 오류 조건이없는 한 양자화 된 지수는 항상 오른쪽 피연산자의 지수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8eddae08f6656a48c18c114d2d80555ac88cc50" translate="yes" xml:space="preserve">
          <source>Unlike other representations of messages, file-like representations are not necessarily independent of the &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance that created them or of the underlying mailbox. More specific documentation is provided by each subclass.</source>
          <target state="translated">다른 메시지 표현과 달리 파일과 유사한 표현이 반드시 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 독립적 일 필요는 없습니다. 를 만든 인스턴스 나 기본 사서함과 . 보다 구체적인 문서는 각 서브 클래스에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1729cdad2c6448823f2a52f8dea629abf34cbd9d" translate="yes" xml:space="preserve">
          <source>Unlike pickle, deserializing untrusted JSON does not in itself create an arbitrary code execution vulnerability.</source>
          <target state="translated">피클과 달리 신뢰할 수없는 JSON의 직렬화 해제 자체가 임의 코드 실행 취약점을 생성하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c027bbb86d577787589ae4a2296400dfbc620f5d" translate="yes" xml:space="preserve">
          <source>Unlike some other popen functions, this implementation will never implicitly call a system shell. This means that all characters, including shell metacharacters, can safely be passed to child processes. If the shell is invoked explicitly, via &lt;code&gt;shell=True&lt;/code&gt;, it is the application&amp;rsquo;s responsibility to ensure that all whitespace and metacharacters are quoted appropriately to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;shell injection&lt;/a&gt; vulnerabilities.</source>
          <target state="translated">다른 popen 함수와 달리이 구현은 절대로 시스템 셸을 암시 적으로 호출하지 않습니다. 즉, 쉘 메타 문자를 포함한 모든 문자를 하위 프로세스로 안전하게 전달할 수 있습니다. &lt;code&gt;shell=True&lt;/code&gt; 를 통해 쉘을 명시 적으로 호출하는 경우, &lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;쉘 삽입&lt;/a&gt; 을 피하기 위해 모든 공백 및 메타 문자가 적절하게 인용되도록하는 것은 애플리케이션의 책임입니다. 취약점 합니다.</target>
        </trans-unit>
        <trans-unit id="326e5cb29ac1685ac6b6540756008303df0cd9e9" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;functions#sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; function, it does not make sense for the &lt;a href=&quot;#module-bisect&quot;&gt;&lt;code&gt;bisect()&lt;/code&gt;&lt;/a&gt; functions to have &lt;em&gt;key&lt;/em&gt; or &lt;em&gt;reversed&lt;/em&gt; arguments because that would lead to an inefficient design (successive calls to bisect functions would not &amp;ldquo;remember&amp;rdquo; all of the previous key lookups).</source>
          <target state="translated">&lt;a href=&quot;functions#sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 함수 와 달리 &lt;a href=&quot;#module-bisect&quot;&gt; &lt;code&gt;bisect()&lt;/code&gt; &lt;/a&gt; 함수가 &lt;em&gt;키&lt;/em&gt; 를 갖 거나 &lt;em&gt;뒤집는&lt;/em&gt; 것은 의미가 없습니다.&lt;em&gt;&lt;/em&gt; 인수가있는 것은 의미가 없습니다. 비효율적 인 디자인으로 이어질 수 있기 때문입니다 (비 섹트 함수에 대한 성공적인 호출은 이전 키 조회를 모두 &quot;기억하지 않습니다&quot;). .</target>
        </trans-unit>
        <trans-unit id="3793d0204514f0cecb268eaedd5865f0bf82163f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; module, the &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module does not support leap seconds.</source>
          <target state="translated">&lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 모듈 과 달리 &lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 모듈은 윤초를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6e58a4913f53cdae8b1ea35f09013530b7aa1c4" translate="yes" xml:space="preserve">
          <source>Unlike the C function of the same name, &lt;a href=&quot;#time.asctime&quot;&gt;&lt;code&gt;asctime()&lt;/code&gt;&lt;/a&gt; does not add a trailing newline.</source>
          <target state="translated">같은 이름의 C 함수와 달리 &lt;a href=&quot;#time.asctime&quot;&gt; &lt;code&gt;asctime()&lt;/code&gt; &lt;/a&gt; 은 후행 줄 바꿈을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f224bbef952cee89d776f9978fc11e4d77aacd93" translate="yes" xml:space="preserve">
          <source>Unlike the built-in &lt;code&gt;**&lt;/code&gt; operator, &lt;a href=&quot;#math.pow&quot;&gt;&lt;code&gt;math.pow()&lt;/code&gt;&lt;/a&gt; converts both its arguments to type &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Use &lt;code&gt;**&lt;/code&gt; or the built-in &lt;a href=&quot;functions#pow&quot;&gt;&lt;code&gt;pow()&lt;/code&gt;&lt;/a&gt; function for computing exact integer powers.</source>
          <target state="translated">내장 &lt;code&gt;**&lt;/code&gt; 연산자 와 달리 &lt;a href=&quot;#math.pow&quot;&gt; &lt;code&gt;math.pow()&lt;/code&gt; &lt;/a&gt; 는 두 인수를 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 유형으로 변환합니다 . 정확한 정수 제곱을 계산 하려면 &lt;code&gt;**&lt;/code&gt; 또는 내장 &lt;a href=&quot;functions#pow&quot;&gt; &lt;code&gt;pow()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="41e1fdb4abd6dd67c502fc5584b98310de24db38" translate="yes" xml:space="preserve">
          <source>Unlike the other methods, callbacks added this way cannot suppress exceptions (as they are never passed the exception details).</source>
          <target state="translated">다른 방법과 달리이 방법으로 추가 된 콜백은 예외 세부 사항을 전달하지 않으므로 예외를 억제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="200b8c21994a17a42d1321647abef543d47f7741" translate="yes" xml:space="preserve">
          <source>Unlike the standard library threading &lt;a href=&quot;queue#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt;, the size of the queue is always known and can be returned by calling the &lt;a href=&quot;#asyncio.Queue.qsize&quot;&gt;&lt;code&gt;qsize()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">표준 라이브러리 스레딩 &lt;a href=&quot;queue#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt; 와 달리 큐 의 크기는 항상 알려져 있으며 &lt;a href=&quot;#asyncio.Queue.qsize&quot;&gt; &lt;code&gt;qsize()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99e8b687ce1472cf64f559941f128998de28a367" translate="yes" xml:space="preserve">
          <source>Unlike with dictionaries, keyword arguments are not supported.</source>
          <target state="translated">사전과 달리 키워드 인수는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b295b1626651c0f81546df6b37a5a08b3d17b159" translate="yes" xml:space="preserve">
          <source>Unlinks all of the specified &lt;em&gt;items&lt;/em&gt; from the tree.</source>
          <target state="translated">트리에서 지정된 모든 &lt;em&gt;항목&lt;/em&gt; 을 연결 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="228d085fb175c515aa2497f02a042daa9633e64b" translate="yes" xml:space="preserve">
          <source>Unlocks the specified bytes, which must have been previously locked.</source>
          <target state="translated">이전에 잠겨 있어야했던 지정된 바이트를 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="048eced2fb1660f6cbfc326ec3236a428f12a1cc" translate="yes" xml:space="preserve">
          <source>Unmatched square brackets in the &lt;code&gt;netloc&lt;/code&gt; attribute will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;netloc&lt;/code&gt; 속성 에서 대괄호가 일치하지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c4b43c42ceb925094a8a1fcebdac4099acaace32" translate="yes" xml:space="preserve">
          <source>Unofficial XML-RPC Errata</source>
          <target state="translated">비공식 XML-RPC 정오표</target>
        </trans-unit>
        <trans-unit id="e180d436cafe3018c8820226a888ae5caa7011f1" translate="yes" xml:space="preserve">
          <source>Unpack an archive. &lt;em&gt;filename&lt;/em&gt; is the full path of the archive.</source>
          <target state="translated">보관소의 포장을 풉니 다. &lt;em&gt;filename&lt;/em&gt; 은 아카이브의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="d093e02eacf25883f9dd3d7f93c744854d7c18ee" translate="yes" xml:space="preserve">
          <source>Unpack from &lt;em&gt;buffer&lt;/em&gt; starting at position &lt;em&gt;offset&lt;/em&gt;, according to the format string &lt;em&gt;format&lt;/em&gt;. The result is a tuple even if it contains exactly one item. The buffer&amp;rsquo;s size in bytes, starting at position &lt;em&gt;offset&lt;/em&gt;, must be at least the size required by the format, as reflected by &lt;a href=&quot;#struct.calcsize&quot;&gt;&lt;code&gt;calcsize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식 문자열 &lt;em&gt;형식&lt;/em&gt; 에 따라 위치 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작하여 &lt;em&gt;버퍼&lt;/em&gt; 에서 압축을 풉니 다 . 정확히 하나의 항목을 포함하더라도 결과는 튜플입니다. 위치 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작하여 버퍼 크기 (바이트 &lt;a href=&quot;#struct.calcsize&quot;&gt; &lt;code&gt;calcsize()&lt;/code&gt; &lt;/a&gt; 는 calcsize ()에 의해 반영된대로 형식에 필요한 크기 이상이어야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2fa5bd12750940524bd0d1cfbac26ffee31f5657" translate="yes" xml:space="preserve">
          <source>Unpack from the buffer &lt;em&gt;buffer&lt;/em&gt; (presumably packed by &lt;code&gt;pack(format, ...)&lt;/code&gt;) according to the format string &lt;em&gt;format&lt;/em&gt;. The result is a tuple even if it contains exactly one item. The buffer&amp;rsquo;s size in bytes must match the size required by the format, as reflected by &lt;a href=&quot;#struct.calcsize&quot;&gt;&lt;code&gt;calcsize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식 문자열 &lt;em&gt;형식&lt;/em&gt; 에 따라 버퍼 &lt;em&gt;버퍼&lt;/em&gt; 에서 압축을 풉니 다 (아마 &lt;code&gt;pack(format, ...)&lt;/code&gt; 의해 압축 됨 ) . 정확히 하나의 항목을 포함하더라도 결과는 튜플입니다. 바이트 단위의 버퍼 크기는 &lt;a href=&quot;#struct.calcsize&quot;&gt; &lt;code&gt;calcsize()&lt;/code&gt; &lt;/a&gt; 의해 반영된 형식에 필요한 크기와 일치해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2adde7706bee77bb5b34b7f4130eb67fec002267" translate="yes" xml:space="preserve">
          <source>Unpacked fields can be named by assigning them to variables or by wrapping the result in a named tuple:</source>
          <target state="translated">압축을 푼 필드는 변수에 지정하거나 결과를 명명 된 튜플에 래핑하여 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d79ef8abbb1d3bae278d963c12afbc654d35da6" translate="yes" xml:space="preserve">
          <source>Unpacker Objects</source>
          <target state="translated">언 패커 객체</target>
        </trans-unit>
        <trans-unit id="0861b7332a50e0249c0fdf3780673bf2dce97c44" translate="yes" xml:space="preserve">
          <source>Unpacks TOS into &lt;em&gt;count&lt;/em&gt; individual values, which are put onto the stack right-to-left.</source>
          <target state="translated">TOS를 개별 값 으로 &lt;em&gt;계산&lt;/em&gt; 하여 스택을 오른쪽에서 왼쪽으로 옮깁니다.</target>
        </trans-unit>
        <trans-unit id="b02e0fc33103f5359830c43333262a8e84c26205" translate="yes" xml:space="preserve">
          <source>Unpacks a double-precision floating point number, similarly to &lt;a href=&quot;#xdrlib.Unpacker.unpack_float&quot;&gt;&lt;code&gt;unpack_float()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Unpacker.unpack_float&quot;&gt; &lt;code&gt;unpack_float()&lt;/code&gt; &lt;/a&gt; 와 유사하게 배정 밀도 부동 소수점 숫자를 압축 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="8df6c980c62c8f14de2fd87d0d289322eb884d40" translate="yes" xml:space="preserve">
          <source>Unpacks a single-precision floating point number.</source>
          <target state="translated">단 정밀도 부동 소수점 숫자를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4b95c1bc4e94907b6abeef024e6d5b6bf5bb8a71" translate="yes" xml:space="preserve">
          <source>Unpacks and returns (as a list) a fixed length array of homogeneous items. &lt;em&gt;n&lt;/em&gt; is number of list elements to expect in the buffer. As above, &lt;em&gt;unpack_item&lt;/em&gt; is the function used to unpack each element.</source>
          <target state="translated">고정 된 길이의 동종 항목 배열을 풀고 (목록으로) 반환합니다. &lt;em&gt;n&lt;/em&gt; 은 버퍼에서 예상되는 목록 요소의 수입니다. 위와 같이 &lt;em&gt;unpack_item&lt;/em&gt; 은 각 요소의 압축을 푸는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="c2c5b548d5976f90964462cd30f8809920479b37" translate="yes" xml:space="preserve">
          <source>Unpacks and returns a fixed length opaque data stream, similarly to &lt;a href=&quot;#xdrlib.Unpacker.unpack_fstring&quot;&gt;&lt;code&gt;unpack_fstring()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Unpacker.unpack_fstring&quot;&gt; &lt;code&gt;unpack_fstring()&lt;/code&gt; &lt;/a&gt; 과 유사하게 고정 길이의 불투명 한 데이터 스트림을 언 패킹 하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2df57ac4a973e9ba3f6bd5eaedcc74a144ce664b" translate="yes" xml:space="preserve">
          <source>Unpacks and returns a fixed length string. &lt;em&gt;n&lt;/em&gt; is the number of characters expected. Padding with null bytes to guaranteed 4 byte alignment is assumed.</source>
          <target state="translated">고정 길이 문자열의 압축을 풀고 반환합니다. &lt;em&gt;n&lt;/em&gt; 은 예상되는 문자 수입니다. 4 바이트 정렬을 보장하기 위해 널 바이트 패딩이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="73c5115d1baf6a3ec3a1fff4ab85bc77008c5914" translate="yes" xml:space="preserve">
          <source>Unpacks and returns a list of homogeneous items. The list is unpacked one element at a time by first unpacking an unsigned integer flag. If the flag is &lt;code&gt;1&lt;/code&gt;, then the item is unpacked and appended to the list. A flag of &lt;code&gt;0&lt;/code&gt; indicates the end of the list. &lt;em&gt;unpack_item&lt;/em&gt; is the function that is called to unpack the items.</source>
          <target state="translated">동종 항목의 목록을 풀고 반환합니다. 부호없는 정수 플래그를 먼저 압축 해제하여 목록을 한 번에 한 요소 씩 압축 해제합니다. 플래그가 &lt;code&gt;1&lt;/code&gt; 이면 항목의 압축이 풀리고 목록에 추가됩니다. 플래그 &lt;code&gt;0&lt;/code&gt; 은 목록의 끝을 나타냅니다. &lt;em&gt;unpack_item&lt;/em&gt; 은 아이템을 풀기 위해 호출되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="6cc4a7d8ee8262fa9d412c53ecbce94d54254aba" translate="yes" xml:space="preserve">
          <source>Unpacks and returns a variable length &lt;em&gt;list&lt;/em&gt; of homogeneous items. First, the length of the list is unpacked as an unsigned integer, then each element is unpacked as in &lt;a href=&quot;#xdrlib.Unpacker.unpack_farray&quot;&gt;&lt;code&gt;unpack_farray()&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">균일 한 항목 의 가변 길이 &lt;em&gt;목록&lt;/em&gt; 을 압축 해제하고 리턴 합니다. 먼저, 목록의 길이는 부호없는 정수로 압축이 풀린 다음 위의 &lt;a href=&quot;#xdrlib.Unpacker.unpack_farray&quot;&gt; &lt;code&gt;unpack_farray()&lt;/code&gt; &lt;/a&gt; 에서와 같이 각 요소의 압축이 풀 립니다 .</target>
        </trans-unit>
        <trans-unit id="a7799cee99003d765f6427b7c1ace2dfb316c858" translate="yes" xml:space="preserve">
          <source>Unpacks and returns a variable length byte stream, similarly to &lt;a href=&quot;#xdrlib.Unpacker.unpack_string&quot;&gt;&lt;code&gt;unpack_string()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Unpacker.unpack_string&quot;&gt; &lt;code&gt;unpack_string()&lt;/code&gt; &lt;/a&gt; 과 유사하게 가변 길이 바이트 스트림을 압축 해제 하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="34766fddbfbc6bc1488290d0daec6b714af30a9b" translate="yes" xml:space="preserve">
          <source>Unpacks and returns a variable length opaque data string, similarly to &lt;a href=&quot;#xdrlib.Unpacker.unpack_string&quot;&gt;&lt;code&gt;unpack_string()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Unpacker.unpack_string&quot;&gt; &lt;code&gt;unpack_string()&lt;/code&gt; &lt;/a&gt; 과 유사하게 가변 길이의 불투명 한 데이터 문자열을 압축 해제 하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ba0b788676d3b41a1c5127c92dde79d487ede145" translate="yes" xml:space="preserve">
          <source>Unpacks and returns a variable length string. The length of the string is first unpacked as an unsigned integer, then the string data is unpacked with &lt;a href=&quot;#xdrlib.Unpacker.unpack_fstring&quot;&gt;&lt;code&gt;unpack_fstring()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가변 길이 문자열을 압축 해제하고 반환합니다. 문자열의 길이는 먼저 부호없는 정수로 압축 해제 된 다음 문자열 데이터는 &lt;a href=&quot;#xdrlib.Unpacker.unpack_fstring&quot;&gt; &lt;code&gt;unpack_fstring()&lt;/code&gt; &lt;/a&gt; 압축 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3ee08b55fbca7f6d37e79386552db63d6525e57" translate="yes" xml:space="preserve">
          <source>Unregister a file object from selection, removing it from monitoring. A file object shall be unregistered prior to being closed.</source>
          <target state="translated">파일 오브젝트를 선택에서 등록 해제하여 모니터링에서 제거하십시오. 파일 객체는 닫히기 전에 등록이 취소되어야합니다.</target>
        </trans-unit>
        <trans-unit id="84737bad5fde4cf5467cba5b10bfa3fac33dbc22" translate="yes" xml:space="preserve">
          <source>Unregister a user signal: uninstall the handler of the &lt;em&gt;signum&lt;/em&gt; signal installed by &lt;a href=&quot;#faulthandler.register&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt;. Return &lt;code&gt;True&lt;/code&gt; if the signal was registered, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">사용자 신호 등록 취소 : &lt;a href=&quot;#faulthandler.register&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt; 설치된 &lt;em&gt;signum&lt;/em&gt; 신호 처리기를 제거하십시오 . 반환 &lt;code&gt;True&lt;/code&gt; 신호가 등록 된 경우 &lt;code&gt;False&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0eeb11afbb54691f5e0783b93bd21e3897e4d244" translate="yes" xml:space="preserve">
          <source>Unregister an unpack format. &lt;em&gt;name&lt;/em&gt; is the name of the format.</source>
          <target state="translated">압축 풀기 형식을 등록 취소하십시오. &lt;em&gt;name&lt;/em&gt; 은 형식의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b7b92c7cba3823febabcbe4aaa8633bbc550444a" translate="yes" xml:space="preserve">
          <source>Unregisters a file handler.</source>
          <target state="translated">파일 핸들러를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="fe99f3a697d86fd74d01d0ec29562a573d784a93" translate="yes" xml:space="preserve">
          <source>Unset (delete) the environment variable named &lt;em&gt;key&lt;/em&gt;. Such changes to the environment affect subprocesses started with &lt;a href=&quot;#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.popen&quot;&gt;&lt;code&gt;popen()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.fork&quot;&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt; 라는 환경 변수를 설정 해제 (삭제)합니다 . 이러한 환경 변경은 &lt;a href=&quot;#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.popen&quot;&gt; &lt;code&gt;popen()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.fork&quot;&gt; &lt;code&gt;fork()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execv&quot;&gt; &lt;code&gt;execv()&lt;/code&gt; &lt;/a&gt; 시작된 하위 프로세스에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="8f11e903da2827da2ff494dc45518a52073a6deb" translate="yes" xml:space="preserve">
          <source>Unset the flag(s) specified by &lt;em&gt;flag&lt;/em&gt; without changing other flags. To remove more than one flag at a time, &lt;em&gt;flag&lt;/em&gt; maybe a string of more than one character.</source>
          <target state="translated">다른 플래그를 변경하지 않고 &lt;em&gt;플래그로&lt;/em&gt; 지정된 플래그를 설정 해제하십시오 . 한 번에 둘 이상의 플래그를 제거하려면 &lt;em&gt;플래그&lt;/em&gt; 가 둘 이상의 문자로 구성된 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9423b5564c4d3ab497eed5796bde589630c032b" translate="yes" xml:space="preserve">
          <source>Unset the flag(s) specified by &lt;em&gt;flag&lt;/em&gt; without changing other flags. To remove more than one flag at a time, &lt;em&gt;flag&lt;/em&gt; maybe a string of more than one character. If &amp;ldquo;info&amp;rdquo; contains experimental information rather than flags, the current &amp;ldquo;info&amp;rdquo; is not modified.</source>
          <target state="translated">다른 플래그를 변경하지 않고 &lt;em&gt;플래그로&lt;/em&gt; 지정된 플래그를 설정 해제하십시오 . 한 번에 둘 이상의 플래그를 제거하려면 &lt;em&gt;플래그&lt;/em&gt; 가 둘 이상의 문자로 구성된 문자열 일 수 있습니다. &quot;info&quot;에 플래그가 아닌 실험 정보가 포함되어 있으면 현재 &quot;info&quot;가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b5ce3b0587e5dfc574c05a997b77253d37b5a96" translate="yes" xml:space="preserve">
          <source>Unsigned, 16-bit big-endian audio</source>
          <target state="translated">부호없는 16 비트 빅 엔디안 오디오</target>
        </trans-unit>
        <trans-unit id="3cf888094dce0dff5dc88fdc3a8fdf414a7518f5" translate="yes" xml:space="preserve">
          <source>Unsigned, 16-bit little-endian audio</source>
          <target state="translated">부호없는 16 비트 리틀 엔디안 오디오</target>
        </trans-unit>
        <trans-unit id="3a6c3f57facb20b402f0b1be0b10f27489e6c0cc" translate="yes" xml:space="preserve">
          <source>Unsigned, 8-bit audio</source>
          <target state="translated">부호없는 8 비트 오디오</target>
        </trans-unit>
        <trans-unit id="0eebb997e8491e1bc2700306d597290b18c9bdb9" translate="yes" xml:space="preserve">
          <source>Unsubscribe from old mailbox.</source>
          <target state="translated">기존 메일 박스에서 탈퇴합니다.</target>
        </trans-unit>
        <trans-unit id="d4c4c55a3d374ba63645f299181454728fde4b94" translate="yes" xml:space="preserve">
          <source>Untabify Region</source>
          <target state="translated">지역 탭 해제</target>
        </trans-unit>
        <trans-unit id="6124f32fdf4ba4b9425841e4026583849d20ed0f" translate="yes" xml:space="preserve">
          <source>Until Python 3.8, &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; lacked a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__reversed__&quot;&gt;&lt;code&gt;__reversed__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Python 3.8까지 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__reversed__&quot;&gt; &lt;code&gt;__reversed__()&lt;/code&gt; &lt;/a&gt; 메서드 가 부족했습니다 .</target>
        </trans-unit>
        <trans-unit id="3b0b27ec87edd9e5b151e783684c3250b5138da3" translate="yes" xml:space="preserve">
          <source>Up to the prompt, the output from the above is:</source>
          <target state="translated">프롬프트까지 위의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c35290c06ff39f7f8240e3f8c98ffb7469e01ce" translate="yes" xml:space="preserve">
          <source>Up-arrow</source>
          <target state="translated">Up-arrow</target>
        </trans-unit>
        <trans-unit id="0a4cd8f9b0c49335833b73322f5129a273d0a57f" translate="yes" xml:space="preserve">
          <source>Update &lt;code id=&quot;index-3&quot;&gt;LINES&lt;/code&gt; and &lt;code id=&quot;index-4&quot;&gt;COLS&lt;/code&gt;. Useful for detecting manual screen resize.</source>
          <target state="translated">업데이트 &lt;code id=&quot;index-3&quot;&gt;LINES&lt;/code&gt; 와 &lt;code id=&quot;index-4&quot;&gt;COLS&lt;/code&gt; . 수동 화면 크기 조정을 감지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6cc3833644a8b3574bfb4234d0fb0ff4bb3d0c1b" translate="yes" xml:space="preserve">
          <source>Update &lt;em&gt;environ&lt;/em&gt; with trivial defaults for testing purposes.</source>
          <target state="translated">테스트 목적으로 사소한 기본값으로 &lt;em&gt;환경&lt;/em&gt; 을 업데이트 하십시오.</target>
        </trans-unit>
        <trans-unit id="7d43ded4f21a448758ca9de774778892a8573fef" translate="yes" xml:space="preserve">
          <source>Update a &lt;em&gt;wrapper&lt;/em&gt; function to look like the &lt;em&gt;wrapped&lt;/em&gt; function. The optional arguments are tuples to specify which attributes of the original function are assigned directly to the matching attributes on the wrapper function and which attributes of the wrapper function are updated with the corresponding attributes from the original function. The default values for these arguments are the module level constants &lt;code&gt;WRAPPER_ASSIGNMENTS&lt;/code&gt; (which assigns to the wrapper function&amp;rsquo;s &lt;code&gt;__module__&lt;/code&gt;, &lt;code&gt;__name__&lt;/code&gt;, &lt;code&gt;__qualname__&lt;/code&gt;, &lt;code&gt;__annotations__&lt;/code&gt; and &lt;code&gt;__doc__&lt;/code&gt;, the documentation string) and &lt;code&gt;WRAPPER_UPDATES&lt;/code&gt; (which updates the wrapper function&amp;rsquo;s &lt;code&gt;__dict__&lt;/code&gt;, i.e. the instance dictionary).</source>
          <target state="translated">&lt;em&gt;랩핑 된&lt;/em&gt; 기능 처럼 보이도록 &lt;em&gt;랩퍼&lt;/em&gt; 기능을 갱신하십시오 . 선택적 인수는 원래 함수의 속성이 랩퍼 함수의 일치하는 속성에 직접 지정되고 랩퍼 함수의 속성이 원래 함수의 해당 속성으로 업데이트되도록 지정하는 튜플입니다. 이러한 인수의 기본값은 모듈 레벨 상수 &lt;code&gt;WRAPPER_ASSIGNMENTS&lt;/code&gt; (랩퍼 함수의 &lt;code&gt;__module__&lt;/code&gt; , &lt;code&gt;__name__&lt;/code&gt; , &lt;code&gt;__qualname__&lt;/code&gt; , &lt;code&gt;__annotations__&lt;/code&gt; 및 &lt;code&gt;__doc__&lt;/code&gt; , 문서화 문자열에 지정됨 ) 및 (랩퍼 함수의 &lt;code&gt;__dict__&lt;/code&gt; 를 갱신하는)&lt;em&gt;&lt;/em&gt; &lt;code&gt;WRAPPER_UPDATES&lt;/code&gt; 즉, 인스턴스 사전).</target>
        </trans-unit>
        <trans-unit id="c8eaa3caae0035d8d2b93d9ea5157036f5e890f4" translate="yes" xml:space="preserve">
          <source>Update and return a dictionary representing the current local symbol table. Free variables are returned by &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; when it is called in function blocks, but not in class blocks. Note that at the module level, &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; are the same dictionary.</source>
          <target state="translated">현재 로컬 심볼 테이블을 나타내는 사전을 업데이트하고 반환합니다. 사용 가능한 변수는 함수 블록에서 호출되지만 클래스 블록에서는 호출되지 않을 때 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 의해 반환됩니다 . 모듈 수준에서 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 는 동일한 사전입니다.</target>
        </trans-unit>
        <trans-unit id="6e881f9b576f8d197b4c916699604917c6bea3ff" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;is_authenticated&lt;/code&gt; flag for the given &lt;em&gt;uri&lt;/em&gt; or list of URIs.</source>
          <target state="translated">지정된 &lt;em&gt;URI&lt;/em&gt; 또는 URI 목록에 대해 &lt;code&gt;is_authenticated&lt;/code&gt; 플래그를 업데이트하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="676722049af84191150c39b99ccf011847f430a6" translate="yes" xml:space="preserve">
          <source>Update the current cursor position of all the ancestors of the window to reflect the current cursor position of the window.</source>
          <target state="translated">창의 현재 커서 위치를 반영하도록 창의 모든 조상의 현재 커서 위치를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="7f52facdafd3c7b416be3ca2987e689c01a20aeb" translate="yes" xml:space="preserve">
          <source>Update the dictionary with the key/value pairs from &lt;em&gt;other&lt;/em&gt;, overwriting existing keys. Return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">기존 키를 덮어 쓰는 &lt;em&gt;다른&lt;/em&gt; 키 / 값 쌍으로 사전을 업데이트하십시오 . 반환 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="844dd4fa8e5519fd020d3adb913a31ce577cec8e" translate="yes" xml:space="preserve">
          <source>Update the display immediately (sync actual screen with previous drawing/deleting methods).</source>
          <target state="translated">디스플레이를 즉시 업데이트합니다 (실제 화면을 이전 그리기 / 삭제 방법과 동기화).</target>
        </trans-unit>
        <trans-unit id="c72f3ad02a5bd1086e31aa55dc65f7726c021bb9" translate="yes" xml:space="preserve">
          <source>Update the hash object with the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;. Repeated calls are equivalent to a single call with the concatenation of all the arguments: &lt;code&gt;m.update(a); m.update(b)&lt;/code&gt; is equivalent to &lt;code&gt;m.update(a+b)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object로&lt;/a&gt; 해시 객체를 업데이트하십시오 . 반복되는 호출은 모든 인수가 연결된 단일 호출과 같습니다. &lt;code&gt;m.update(a); m.update(b)&lt;/code&gt; 는 &lt;code&gt;m.update(a+b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64c77d232184003c8e5ef8dfe4a062a6ffc29da4" translate="yes" xml:space="preserve">
          <source>Update the hmac object with &lt;em&gt;msg&lt;/em&gt;. Repeated calls are equivalent to a single call with the concatenation of all the arguments: &lt;code&gt;m.update(a); m.update(b)&lt;/code&gt; is equivalent to &lt;code&gt;m.update(a + b)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;msg로&lt;/em&gt; hmac 객체를 업데이트하십시오 . 반복되는 호출은 모든 인수가 연결된 단일 호출과 같습니다. &lt;code&gt;m.update(a); m.update(b)&lt;/code&gt; 는 &lt;code&gt;m.update(a + b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49fcb28da96252d3143add7d524b059fc11f4dbf" translate="yes" xml:space="preserve">
          <source>Update the physical screen. The curses library keeps two data structures, one representing the current physical screen contents and a virtual screen representing the desired next state. The &lt;a href=&quot;#curses.doupdate&quot;&gt;&lt;code&gt;doupdate()&lt;/code&gt;&lt;/a&gt; ground updates the physical screen to match the virtual screen.</source>
          <target state="translated">실제 화면을 업데이트하십시오. curses 라이브러리는 두 개의 데이터 구조를 유지합니다. 하나는 현재 실제 화면 내용을 나타내고 하나는 원하는 다음 상태를 나타냅니다. &lt;a href=&quot;#curses.doupdate&quot;&gt; &lt;code&gt;doupdate()&lt;/code&gt; &lt;/a&gt; 접지는 가상 화면에 맞게 실제 화면을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="916502e64e45e8917403b3f7e2e4cb9240ec037b" translate="yes" xml:space="preserve">
          <source>Update the set, adding elements from all others.</source>
          <target state="translated">다른 모든 요소를 ​​추가하여 세트를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="ac6527f15e4975da015ccaa43d3d4bfa51b09597" translate="yes" xml:space="preserve">
          <source>Update the set, keeping only elements found in either set, but not in both.</source>
          <target state="translated">두 세트가 아닌 두 세트에있는 요소 만 유지하면서 세트를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="1efb006f7c16e37178e13286e3116f97a446042c" translate="yes" xml:space="preserve">
          <source>Update the set, keeping only elements found in it and all others.</source>
          <target state="translated">세트와 다른 모든 요소에있는 요소 만 유지하면서 세트를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="e5f938e1032dfc279fd2d4c9bbde2ed0d316e18d" translate="yes" xml:space="preserve">
          <source>Update the set, removing elements found in others.</source>
          <target state="translated">다른 세트에서 발견 된 요소를 제거하여 세트를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="8f6ad5a4c112a979bb39e0daf27f6f78eab18230" translate="yes" xml:space="preserve">
          <source>Update the values in the Morsel dictionary with the values in the dictionary &lt;em&gt;values&lt;/em&gt;. Raise an error if any of the keys in the &lt;em&gt;values&lt;/em&gt; dict is not a valid &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Morsel 사전의 값을 사전 &lt;em&gt;값&lt;/em&gt; 의 값으로 업데이트하십시오 . &lt;em&gt;값&lt;/em&gt; dict 의 키 중 하나가 유효한 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 속성 이 아닌 경우 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="403f8c83e34150e4e050e7802c9ae3b5c02baa0b" translate="yes" xml:space="preserve">
          <source>Updates the virtual screen after changes in the panel stack. This does not call &lt;a href=&quot;curses#curses.doupdate&quot;&gt;&lt;code&gt;curses.doupdate()&lt;/code&gt;&lt;/a&gt;, so you&amp;rsquo;ll have to do this yourself.</source>
          <target state="translated">패널 스택이 변경된 후 가상 화면을 업데이트합니다. 이것은 &lt;a href=&quot;curses#curses.doupdate&quot;&gt; &lt;code&gt;curses.doupdate()&lt;/code&gt; &lt;/a&gt; 호출하지 않으므로 직접해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fbbdb84597aa8a194e7826194c031e681da3e5b" translate="yes" xml:space="preserve">
          <source>Updating Code For New Versions of Dependencies</source>
          <target state="translated">새 버전의 종속성에 대한 코드 업데이트</target>
        </trans-unit>
        <trans-unit id="6cfc0fe1e7552b2208957be5568c4b831410776d" translate="yes" xml:space="preserve">
          <source>Upgrade an existing connection to TLS.</source>
          <target state="translated">기존 연결을 TLS로 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="c033cfa69d72d0506f0739c3dd946dac4f60d820" translate="yes" xml:space="preserve">
          <source>Upgrade an existing transport-based connection to TLS.</source>
          <target state="translated">기존 전송 기반 연결을 TLS로 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="93c2d8026e88b79d364deb29293028e59014ecd4" translate="yes" xml:space="preserve">
          <source>Upgrading optparse code</source>
          <target state="translated">옵 파스 코드 업그레이드</target>
        </trans-unit>
        <trans-unit id="6885989b161691127084226c65d60813ef15d1e3" translate="yes" xml:space="preserve">
          <source>Upon startup with the &lt;code&gt;-s&lt;/code&gt; option, IDLE will execute the file referenced by the environment variables &lt;code id=&quot;index-5&quot;&gt;IDLESTARTUP&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-6&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt;. IDLE first checks for &lt;code&gt;IDLESTARTUP&lt;/code&gt;; if &lt;code&gt;IDLESTARTUP&lt;/code&gt; is present the file referenced is run. If &lt;code&gt;IDLESTARTUP&lt;/code&gt; is not present, IDLE checks for &lt;code&gt;PYTHONSTARTUP&lt;/code&gt;. Files referenced by these environment variables are convenient places to store functions that are used frequently from the IDLE shell, or for executing import statements to import common modules.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; 옵션으로 시작하면 IDLE은 환경 변수 &lt;code id=&quot;index-5&quot;&gt;IDLESTARTUP&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-6&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; &lt;/a&gt; 에서 참조하는 파일을 실행합니다 . IDLE은 먼저 &lt;code&gt;IDLESTARTUP&lt;/code&gt; 을 확인합니다 . 경우 &lt;code&gt;IDLESTARTUP&lt;/code&gt; 가 존재하는 참조 파일이 실행됩니다. 경우 &lt;code&gt;IDLESTARTUP&lt;/code&gt; 을 위한 본, IDLE 검사 아니다 &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; . 이러한 환경 변수가 참조하는 파일은 IDLE 쉘에서 자주 사용되는 함수를 저장하거나 공통 명령문을 가져 오기 위해 import 문을 실행하기에 편리한 위치입니다.</target>
        </trans-unit>
        <trans-unit id="ceeef23b43f204cd4fc87f8a0c602258f435ad5b" translate="yes" xml:space="preserve">
          <source>Upon unpickling, if the class defines &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt;, it is called with the unpickled state. In that case, there is no requirement for the state object to be a dictionary. Otherwise, the pickled state must be a dictionary and its items are assigned to the new instance&amp;rsquo;s dictionary.</source>
          <target state="translated">피클 링 해제시 클래스가 &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; 정의하면 피클 링되지 않은 상태로 호출됩니다. 이 경우 상태 객체가 사전 일 필요는 없습니다. 그렇지 않으면 절인 상태는 사전이어야하고 해당 항목은 새 인스턴스 사전에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="442c0ca432bba7bb5e9fddb35000be1fc0080e00" translate="yes" xml:space="preserve">
          <source>Upper left of keypad</source>
          <target state="translated">키패드의 왼쪽 상단</target>
        </trans-unit>
        <trans-unit id="26be040f98d4f92519d4f55adbafdaf27d0bf91c" translate="yes" xml:space="preserve">
          <source>Upper right of keypad</source>
          <target state="translated">키패드의 오른쪽 상단</target>
        </trans-unit>
        <trans-unit id="5d6984e58af99ef5098428fe251573a59542bd1a" translate="yes" xml:space="preserve">
          <source>Upper-left corner</source>
          <target state="translated">왼쪽 상단</target>
        </trans-unit>
        <trans-unit id="f899c21125a124680149002a215b010390a14035" translate="yes" xml:space="preserve">
          <source>Upper-right corner</source>
          <target state="translated">오른쪽 상단</target>
        </trans-unit>
        <trans-unit id="412e31909b8ad1417c4a39495653fdeba58cd034" translate="yes" xml:space="preserve">
          <source>Urdu</source>
          <target state="translated">Urdu</target>
        </trans-unit>
        <trans-unit id="6c0f6c90b039eb2f8ccf225a7eea7326a1231177" translate="yes" xml:space="preserve">
          <source>Urgent data for read</source>
          <target state="translated">읽을 긴급 데이터</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="c54d06d3411c536072cc47249dd128a605cc382d" translate="yes" xml:space="preserve">
          <source>Usage as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt;:</source>
          <target state="translated">A와 사용법 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;장식&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8e06c218123ecda4e08d6b8f0a242dd0c07ffde1" translate="yes" xml:space="preserve">
          <source>Usage example: &lt;code&gt;fi =
fileinput.FileInput(openhook=fileinput.hook_encoded(&quot;utf-8&quot;,
&quot;surrogateescape&quot;))&lt;/code&gt;</source>
          <target state="translated">사용 예 : &lt;code&gt;fi = fileinput.FileInput(openhook=fileinput.hook_encoded(&quot;utf-8&quot;, &quot;surrogateescape&quot;))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23a84570fc52dfd991c6774587f13dbfa3c6b304" translate="yes" xml:space="preserve">
          <source>Usage example: &lt;code&gt;fi = fileinput.FileInput(openhook=fileinput.hook_compressed)&lt;/code&gt;</source>
          <target state="translated">사용 예 : &lt;code&gt;fi = fileinput.FileInput(openhook=fileinput.hook_compressed)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30417f716d6267476ad9fad028a2fc6e463880c9" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;KabulTz&lt;/code&gt; from above:</source>
          <target state="translated">위 의 &lt;code&gt;KabulTz&lt;/code&gt; 사용법 :</target>
        </trans-unit>
        <trans-unit id="fd2184f1d367ba383d26c0e300960fadb0d8272b" translate="yes" xml:space="preserve">
          <source>Usage of the DOM interface in Python is straight-forward. The following mapping rules apply:</source>
          <target state="translated">파이썬에서 DOM 인터페이스의 사용법은 간단합니다. 다음과 같은 매핑 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="4b1f7ccf5dd79f8ee16571bf32c1e6c4007733ce" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#asyncio.WriteTransport.get_write_buffer_limits&quot;&gt;&lt;code&gt;get_write_buffer_limits()&lt;/code&gt;&lt;/a&gt; to get the limits.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.WriteTransport.get_write_buffer_limits&quot;&gt; &lt;code&gt;get_write_buffer_limits()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 한계를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="0bcdd77ca18769c76d2f648e31dbca518354ce9b" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#asyncio.WriteTransport.set_write_buffer_limits&quot;&gt;&lt;code&gt;set_write_buffer_limits()&lt;/code&gt;&lt;/a&gt; to set the limits.</source>
          <target state="translated">사용 &lt;a href=&quot;#asyncio.WriteTransport.set_write_buffer_limits&quot;&gt; &lt;code&gt;set_write_buffer_limits()&lt;/code&gt; &lt;/a&gt; 한계를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5ff19ffa16005ed393bb50a2fc301ae7c8434921" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#subprocess.Popen.stdin&quot;&gt;&lt;code&gt;.stdin.write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#subprocess.Popen.stdout&quot;&gt;&lt;code&gt;.stdout.read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#subprocess.Popen.stderr&quot;&gt;&lt;code&gt;.stderr.read&lt;/code&gt;&lt;/a&gt; to avoid deadlocks due to any of the other OS pipe buffers filling up and blocking the child process.</source>
          <target state="translated">자식 프로세스를 채우고 차단하는 다른 OS 파이프 버퍼로 인한 교착 상태를 피하려면 &lt;a href=&quot;#subprocess.Popen.stdin&quot;&gt; &lt;code&gt;.stdin.write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#subprocess.Popen.stdout&quot;&gt; &lt;code&gt;.stdout.read&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#subprocess.Popen.stderr&quot;&gt; &lt;code&gt;.stderr.read&lt;/code&gt; &lt;/a&gt; 대신 communi &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd81adbbc79cd205fc1bc2737ce1e2085e7810fe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#tokenize.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; to open Python source files: it uses &lt;a href=&quot;#tokenize.detect_encoding&quot;&gt;&lt;code&gt;detect_encoding()&lt;/code&gt;&lt;/a&gt; to detect the file encoding.</source>
          <target state="translated">&lt;a href=&quot;#tokenize.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 Python 소스 파일을 엽니 다. &lt;a href=&quot;#tokenize.detect_encoding&quot;&gt; &lt;code&gt;detect_encoding()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 파일 인코딩을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="b5b266fadd2e7245f37c616a8922563663fb3b4d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#tracemalloc.Snapshot.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; to reload the snapshot.</source>
          <target state="translated">&lt;a href=&quot;#tracemalloc.Snapshot.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 스냅 샷을 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="5773877b49b43db6bf7c94187009bb8144711130" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; as the value if you want &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; to create mocks for you. In this case the created mocks are passed into a decorated function by keyword, and a dictionary is returned when &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; is used as a context manager.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 에서 모의 ​​객체를 만들려면 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 를 값으로 사용하십시오 . 이 경우 작성된 ​​모의는 키워드로 데코 레이팅 된 함수로 전달되며 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 이 컨텍스트 관리자로 사용될 때 사전이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="801ec70715ed39b5c5c242a01eb2e137022a3645" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; to indicate that a value could be any type in a typesafe manner. Use &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; to indicate that a value is dynamically typed.</source>
          <target state="translated">typesafe 방식으로 값이 모든 유형이 될 수 있음을 나타내려면 &lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . 값을 동적으로 입력 하려면 &lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d55b6e9ca90a032f6af3085cee74e97a5a82792" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;functools#functools.cmp_to_key&quot;&gt;&lt;code&gt;functools.cmp_to_key()&lt;/code&gt;&lt;/a&gt; to convert an old-style &lt;em&gt;cmp&lt;/em&gt; function to a &lt;em&gt;key&lt;/em&gt; function.</source>
          <target state="translated">&lt;a href=&quot;functools#functools.cmp_to_key&quot;&gt; &lt;code&gt;functools.cmp_to_key()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 이전 스타일 &lt;em&gt;cmp&lt;/em&gt; 함수를 &lt;em&gt;키&lt;/em&gt; 함수 로 변환 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ae804c4e2566a021e2b7df1cb5f86d33af4f596" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;functools#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#asyncio-pass-keywords&quot;&gt;to pass keyword arguments&lt;/a&gt; to &lt;em&gt;callback&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;functools#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#asyncio-pass-keywords&quot;&gt; 을&lt;/a&gt; 사용 하여 키워드 인수 를 &lt;em&gt;callback &lt;/em&gt;에 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7faa606e98b27a2cbd434b59751dcf554bb80399" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;functools#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#asyncio-pass-keywords&quot;&gt;to pass keyword arguments&lt;/a&gt; to &lt;em&gt;func&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;functools#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#asyncio-pass-keywords&quot;&gt; 을&lt;/a&gt; 사용 하여 키워드 인수 를 &lt;em&gt;func &lt;/em&gt;에 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="caa6b6a91146066a6ab2e2391258412526412a60" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;importlib#importlib.util.module_from_spec&quot;&gt;&lt;code&gt;importlib.util.module_from_spec()&lt;/code&gt;&lt;/a&gt; to create a new module if you wish to set the various import-controlled attributes.</source>
          <target state="translated">다양한 가져 오기 제어 속성을 설정 하려면 &lt;a href=&quot;importlib#importlib.util.module_from_spec&quot;&gt; &lt;code&gt;importlib.util.module_from_spec()&lt;/code&gt; &lt;/a&gt; 을 사용하여 새 모듈을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="92571159e076392f54e9a058f2068114f55f5d84" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;pickletools#pickletools.optimize&quot;&gt;&lt;code&gt;pickletools.optimize()&lt;/code&gt;&lt;/a&gt; if you need more compact pickles.</source>
          <target state="translated">더 작은 피클이 필요한 경우 &lt;a href=&quot;pickletools#pickletools.optimize&quot;&gt; &lt;code&gt;pickletools.optimize()&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="977759ccf7fc3d35b1728ab61d457345039786ef" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;threading#threading.get_ident&quot;&gt;&lt;code&gt;threading.get_ident()&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;threading#threading.Thread.ident&quot;&gt;&lt;code&gt;ident&lt;/code&gt;&lt;/a&gt; attribute of &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt; objects to get a suitable value for &lt;em&gt;thread_id&lt;/em&gt;.</source>
          <target state="translated">사용 &lt;a href=&quot;threading#threading.get_ident&quot;&gt; &lt;code&gt;threading.get_ident()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;threading#threading.Thread.ident&quot;&gt; &lt;code&gt;ident&lt;/code&gt; &lt;/a&gt; 의 속성 &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; 는&lt;/a&gt; 에 적합한 값을 얻기 위해 객체 &lt;em&gt;thread_id을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4f310326200524afa7764d68027ab6eeaeafc777" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Text&lt;/code&gt; to indicate that a value must contain a unicode string in a manner that is compatible with both Python 2 and Python 3:</source>
          <target state="translated">&lt;code&gt;Text&lt;/code&gt; 를 사용 하여 값이 Python 2 및 Python 3과 호환되는 방식으로 유니 코드 문자열을 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fea35a235eec9b227adb5fcb0a0c00435b41bfcb" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;N&lt;/em&gt; workers to compile the files within the given directory. If &lt;code&gt;0&lt;/code&gt; is used, then the result of &lt;a href=&quot;os#os.cpu_count&quot;&gt;&lt;code&gt;os.cpu_count()&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="translated">&lt;em&gt;N&lt;/em&gt; worker를 사용 하여 주어진 디렉토리 내에서 파일을 컴파일하십시오. 경우 &lt;code&gt;0&lt;/code&gt; 이 사용되며, 다음의 결과 &lt;a href=&quot;os#os.cpu_count&quot;&gt; &lt;code&gt;os.cpu_count()&lt;/code&gt; &lt;/a&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="495d495d7facfbe6f23a76a082fc3a5f0950c5d6" translate="yes" xml:space="preserve">
          <source>Use RPOP authentication (similar to UNIX r-commands) to log into POP3 server.</source>
          <target state="translated">POP3 서버에 로그인하려면 RPOP 인증 (UNIX r- 명령과 유사)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="38ed25f85936d5ec93f7f6baaff0782bf76ef725" translate="yes" xml:space="preserve">
          <source>Use and behaviors of the &lt;em&gt;timeout&lt;/em&gt; argument are the same as in &lt;a href=&quot;#multiprocessing.Lock.acquire&quot;&gt;&lt;code&gt;Lock.acquire()&lt;/code&gt;&lt;/a&gt;. Note that some of these behaviors of &lt;em&gt;timeout&lt;/em&gt; differ from the implemented behaviors in &lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt;&lt;code&gt;threading.RLock.acquire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;timeout&lt;/em&gt; 인수 의 사용 및 동작은 &lt;a href=&quot;#multiprocessing.Lock.acquire&quot;&gt; &lt;code&gt;Lock.acquire()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 이러한 &lt;em&gt;시간 초과&lt;/em&gt; 동작 중 일부는 &lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt; &lt;code&gt;threading.RLock.acquire()&lt;/code&gt; &lt;/a&gt; 의 구현 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b8f6b7836c3c9781322ac632c3472944cbf5882e" translate="yes" xml:space="preserve">
          <source>Use of Basic HTTP Authentication:</source>
          <target state="translated">기본 HTTP 인증 사용 :</target>
        </trans-unit>
        <trans-unit id="06b1cfba601081732eb4d25b9f84434e8e55c28d" translate="yes" xml:space="preserve">
          <source>Use of a configuration file where logging configuration is just part of the overall application configuration.</source>
          <target state="translated">로깅 구성이 전체 응용 프로그램 구성의 일부인 구성 파일 사용.</target>
        </trans-unit>
        <trans-unit id="a7aa6e5161d91c7285f5b1ed3868d5a6211a2320" translate="yes" xml:space="preserve">
          <source>Use of a configuration read from a file, and then modified by the using application (e.g. based on command-line parameters or other aspects of the runtime environment) before being passed to &lt;code&gt;fileConfig&lt;/code&gt;.</source>
          <target state="translated">구성의 사용은 파일로부터 판독 한 다음에 전달되기 전에 (커맨드 라인 파라미터 또는 런타임 환경의 다른 측면에 기초 등)를 사용하여 애플리케이션에 의해 수정 &lt;code&gt;fileConfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28af66b770f56fa6175a1ed4bd8aca50a0212688" translate="yes" xml:space="preserve">
          <source>Use of the &lt;em&gt;requote&lt;/em&gt; parameter with &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; objects is deprecated.</source>
          <target state="translated">의 사용 &lt;em&gt;requote의&lt;/em&gt; 와 매개 변수 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 이&lt;/a&gt; 되지 않습니다 오브젝트.</target>
        </trans-unit>
        <trans-unit id="f8807a8f268cd5a3fec930a6e701e4eec1a5a268" translate="yes" xml:space="preserve">
          <source>Use of the functions above is more portable than use of the first set of flags:</source>
          <target state="translated">위의 함수를 사용하면 첫 번째 플래그 집합을 사용하는 것보다 이식성이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="0ee11de24afff11a85727ddbffb864bb44227fcd" translate="yes" xml:space="preserve">
          <source>Use of this function may introduce a security hole in your program. By the time you get around to doing anything with the file name it returns, someone else may have beaten you to the punch. &lt;a href=&quot;#tempfile.mktemp&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; usage can be replaced easily with &lt;a href=&quot;#tempfile.NamedTemporaryFile&quot;&gt;&lt;code&gt;NamedTemporaryFile()&lt;/code&gt;&lt;/a&gt;, passing it the &lt;code&gt;delete=False&lt;/code&gt; parameter:</source>
          <target state="translated">이 기능을 사용하면 프로그램에 보안 허점이 생길 수 있습니다. 반환되는 파일 이름으로 무언가를 할 때 다른 누군가가 당신을 때릴 수도 있습니다. &lt;a href=&quot;#tempfile.mktemp&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt; 사용법은 &lt;a href=&quot;#tempfile.NamedTemporaryFile&quot;&gt; &lt;code&gt;NamedTemporaryFile()&lt;/code&gt; &lt;/a&gt; 로 쉽게 대체 하여 &lt;code&gt;delete=False&lt;/code&gt; 매개 변수를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="f802f95d5b72b7e3d461f9294f782b8fe070b88f" translate="yes" xml:space="preserve">
          <source>Use of this setting requires a valid set of CA certificates to be passed, either to &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt;&lt;code&gt;SSLContext.load_verify_locations()&lt;/code&gt;&lt;/a&gt; or as a value of the &lt;code&gt;ca_certs&lt;/code&gt; parameter to &lt;a href=&quot;#ssl.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 설정을 사용하려면 유효한 CA 인증서 세트를 &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt; &lt;code&gt;SSLContext.load_verify_locations()&lt;/code&gt; &lt;/a&gt; 전달 하거나 &lt;code&gt;ca_certs&lt;/code&gt; 매개 변수 의 값 으로 &lt;a href=&quot;#ssl.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="086661bc0d18c4e4d7976acf67e710dca98ca570" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; method rather than &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdin&quot;&gt;&lt;code&gt;process.stdin.write()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdout&quot;&gt;&lt;code&gt;await process.stdout.read()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stderr&quot;&gt;&lt;code&gt;await process.stderr.read&lt;/code&gt;&lt;/a&gt;. This avoids deadlocks due to streams pausing reading or writing and blocking the child process.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdin&quot;&gt; &lt;code&gt;process.stdin.write()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdout&quot;&gt; &lt;code&gt;await process.stdout.read()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stderr&quot;&gt; &lt;code&gt;await process.stderr.read&lt;/code&gt; &lt;/a&gt; 대신 communi &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . 이렇게하면 읽기 또는 쓰기를 일시 중지하고 자식 프로세스를 차단하는 스트림으로 인한 교착 상태를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15cd98149cc9f937cb92cf3ef933c1d25a1d0470" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#typing.NewType&quot;&gt;&lt;code&gt;NewType()&lt;/code&gt;&lt;/a&gt; helper function to create distinct types:</source>
          <target state="translated">사용 &lt;a href=&quot;#typing.NewType&quot;&gt; &lt;code&gt;NewType()&lt;/code&gt; &lt;/a&gt; 구별 유형을 만들 도우미 함수를 :</target>
        </trans-unit>
        <trans-unit id="fa0f4760d676107d72f2532d197197a7035768be" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#urllib.parse.urlencode&quot;&gt;&lt;code&gt;urllib.parse.urlencode()&lt;/code&gt;&lt;/a&gt; function (with the &lt;code&gt;doseq&lt;/code&gt; parameter set to &lt;code&gt;True&lt;/code&gt;) to convert such dictionaries into query strings.</source>
          <target state="translated">사용 &lt;a href=&quot;#urllib.parse.urlencode&quot;&gt; &lt;code&gt;urllib.parse.urlencode()&lt;/code&gt; &lt;/a&gt; 합니다 (와 기능 &lt;code&gt;doseq&lt;/code&gt; 의 에 파라미터 세트 &lt;code&gt;True&lt;/code&gt; 쿼리 문자열에 같은 사전 변환).</target>
        </trans-unit>
        <trans-unit id="e77864b913c6ed2d3f7946296e1c4dd7eaea83b6" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#urllib.parse.urlencode&quot;&gt;&lt;code&gt;urllib.parse.urlencode()&lt;/code&gt;&lt;/a&gt; function to convert such lists of pairs into query strings.</source>
          <target state="translated">&lt;a href=&quot;#urllib.parse.urlencode&quot;&gt; &lt;code&gt;urllib.parse.urlencode()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 이러한 쌍의 목록을 쿼리 문자열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe5f8c7c68a5eb4c363855f9e618e8fc09e455f" translate="yes" xml:space="preserve">
          <source>Use the &lt;em&gt;headers&lt;/em&gt; argument to the &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor, or:</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 생성자에 &lt;em&gt;headers&lt;/em&gt; 인수를 사용 하거나 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="397b1bdc25c901492de8340e267b2d32924dd46a" translate="yes" xml:space="preserve">
          <source>Use the config() method to update multiple attrs subsequent to object creation</source>
          <target state="translated">config () 메소드를 사용하여 오브젝트 작성 후 여러 attr을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="269f723392451288e2d733a8ac1b951a0f732cfc" translate="yes" xml:space="preserve">
          <source>Use the following functions to convert between time representations:</source>
          <target state="translated">다음 기능을 사용하여 시간 표현을 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="8b0e3f6f824fb870d980396594c6ee74a24533bb" translate="yes" xml:space="preserve">
          <source>Use the high median when your data are discrete and you prefer the median to be an actual data point rather than interpolated.</source>
          <target state="translated">데이터가 불연속적이고 중간 값이 보간되지 않고 실제 데이터 포인트가되는 것을 선호 할 때 높은 중앙값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc76d8aaa9d87f83107351e712614efa5b9a4366" translate="yes" xml:space="preserve">
          <source>Use the high-level &lt;a href=&quot;#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; function to create Tasks, or the low-level &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_task&quot;&gt;&lt;code&gt;loop.create_task()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-future#asyncio.ensure_future&quot;&gt;&lt;code&gt;ensure_future()&lt;/code&gt;&lt;/a&gt; functions. Manual instantiation of Tasks is discouraged.</source>
          <target state="translated">상위 레벨 &lt;a href=&quot;#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 태스크를 작성하거나 하위 레벨 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_task&quot;&gt; &lt;code&gt;loop.create_task()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-future#asyncio.ensure_future&quot;&gt; &lt;code&gt;ensure_future()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오. 작업의 수동 인스턴스화는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac8913b6579e52d49bb894464f33a8f70139a5e9" translate="yes" xml:space="preserve">
          <source>Use the low median when your data are discrete and you prefer the median to be an actual data point rather than interpolated.</source>
          <target state="translated">데이터가 불연속적이고 중간 값이 보간되지 않고 실제 데이터 포인트가되는 것을 선호 할 때 낮은 중앙값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="38fc6d08600772eccde5630b8b2095c84488dee1" translate="yes" xml:space="preserve">
          <source>Use the more secure APOP authentication to log into the POP3 server.</source>
          <target state="translated">보다 안전한 APOP 인증을 사용하여 POP3 서버에 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="0c2845b8ec29e4c6963ceba130325e617d9cc8d5" translate="yes" xml:space="preserve">
          <source>Use the real uid/gid to test for access to &lt;em&gt;path&lt;/em&gt;. Note that most operations will use the effective uid/gid, therefore this routine can be used in a suid/sgid environment to test if the invoking user has the specified access to &lt;em&gt;path&lt;/em&gt;. &lt;em&gt;mode&lt;/em&gt; should be &lt;a href=&quot;#os.F_OK&quot;&gt;&lt;code&gt;F_OK&lt;/code&gt;&lt;/a&gt; to test the existence of &lt;em&gt;path&lt;/em&gt;, or it can be the inclusive OR of one or more of &lt;a href=&quot;#os.R_OK&quot;&gt;&lt;code&gt;R_OK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.W_OK&quot;&gt;&lt;code&gt;W_OK&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.X_OK&quot;&gt;&lt;code&gt;X_OK&lt;/code&gt;&lt;/a&gt; to test permissions. Return &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if access is allowed, &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; if not. See the Unix man page &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/access(2)&quot;&gt;access(2)&lt;/a&gt;&lt;/em&gt; for more information.</source>
          <target state="translated">실제 uid / gid를 사용하여 &lt;em&gt;path에&lt;/em&gt; 대한 액세스를 테스트하십시오 . 대부분의 작업은 효과적인 uid / gid를 사용하므로이 루틴은 suid / sgid 환경에서 호출하는 사용자에게 지정된 액세스 권한이 있는지 테스트하기 위해 사용할 수 있습니다.&lt;em&gt; path에&lt;/em&gt; . &lt;em&gt;모드는&lt;/em&gt; 해야 &lt;a href=&quot;#os.F_OK&quot;&gt; &lt;code&gt;F_OK&lt;/code&gt; 이&lt;/a&gt; 의 존재를 테스트하기 위해 &lt;em&gt;경로를&lt;/em&gt; , 또는 포괄적 또는 하나 또는 그 이상이 될 수 &lt;a href=&quot;#os.R_OK&quot;&gt; &lt;code&gt;R_OK&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.W_OK&quot;&gt; &lt;code&gt;W_OK&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.X_OK&quot;&gt; &lt;code&gt;X_OK&lt;/code&gt; &lt;/a&gt; 권한을 테스트합니다. 액세스가 허용되면 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; , &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 않으면 False를 리턴하십시오 . 자세한 내용은 Unix 매뉴얼 페이지 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/access(2)&quot;&gt;access (2)&lt;/a&gt;&lt;/em&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="62d360059b352a3db9e680b1043a8ec5f3406a4a" translate="yes" xml:space="preserve">
          <source>Use the server&amp;rsquo;s cipher ordering preference, rather than the client&amp;rsquo;s. This option has no effect on client sockets and SSLv2 server sockets.</source>
          <target state="translated">클라이언트보다는 서버의 암호 순서 환경 설정을 사용하십시오. 이 옵션은 클라이언트 소켓 및 SSLv2 서버 소켓에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8de5b3b768e02c520630dfc4e4662871b8e86cb2" translate="yes" xml:space="preserve">
          <source>Use the specified date/time format, as accepted by &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 허용 된대로 지정된 날짜 / 시간 형식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2201f34bb8cca334db23ea9d46313e59f85d0d4" translate="yes" xml:space="preserve">
          <source>Use the specified format string for the handler.</source>
          <target state="translated">핸들러에 지정된 형식 문자열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="213c03b10565262fbdcced639b5887e0adcb2562" translate="yes" xml:space="preserve">
          <source>Use the specified stream to initialize the StreamHandler. Note that this argument is incompatible with &lt;em&gt;filename&lt;/em&gt; - if both are present, a &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="translated">지정된 스트림을 사용하여 StreamHandler를 초기화하십시오. 이 인수는 &lt;em&gt;filename&lt;/em&gt; 과 호환되지 않습니다. 둘 다 있으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c2fd056e5e1d4febf6b91464a41740d353dee2ec" translate="yes" xml:space="preserve">
          <source>Use this at the end of &lt;code&gt;test_main&lt;/code&gt; whenever sub-processes are started. This will help ensure that no extra children (zombies) stick around to hog resources and create problems when looking for refleaks.</source>
          <target state="translated">서브 프로세스가 시작될 때마다 &lt;code&gt;test_main&lt;/code&gt; 의 끝에 이것을 사용하십시오 . 이렇게하면 여분의 어린이 (좀비)가 돼지 자원을 찌르기 위해 집착하거나 리플 랙을 찾을 때 문제를 일으키지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="286f91c9a880de7bf2bb606d7ce509a86af31f09" translate="yes" xml:space="preserve">
          <source>Use this check to guard CPython&amp;rsquo;s implementation-specific tests or to run them only on the implementations guarded by the arguments:</source>
          <target state="translated">CPython의 구현 별 테스트를 보호하거나 인수로 보호되는 구현에서만 테스트를 실행하려면이 점검을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ce127e7831cfc938739483bdfbe497d108a0f467" translate="yes" xml:space="preserve">
          <source>Use this function to calculate the variance from the entire population. To estimate the variance from a sample, the &lt;a href=&quot;#statistics.variance&quot;&gt;&lt;code&gt;variance()&lt;/code&gt;&lt;/a&gt; function is usually a better choice.</source>
          <target state="translated">이 함수를 사용하여 전체 모집단의 분산을 계산하십시오. 표본에서 분산을 추정하려면 일반적으로 &lt;a href=&quot;#statistics.variance&quot;&gt; &lt;code&gt;variance()&lt;/code&gt; &lt;/a&gt; 함수가 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="113c4cd7a277e177b4ab8b221b14cfbf88cf5706" translate="yes" xml:space="preserve">
          <source>Use this function when your data is a sample from a population. To calculate the variance from the entire population, see &lt;a href=&quot;#statistics.pvariance&quot;&gt;&lt;code&gt;pvariance()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터가 모집단의 표본 인 경우이 기능을 사용하십시오. 전체 모집단의 분산을 계산하려면 &lt;a href=&quot;#statistics.pvariance&quot;&gt; &lt;code&gt;pvariance()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1722f7fbf19d23d96b7db6a746432471393e9f3d" translate="yes" xml:space="preserve">
          <source>Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as &amp;ldquo;virtual subclasses&amp;rdquo; &amp;ndash; these and their descendants will be considered subclasses of the registering ABC by the built-in &lt;a href=&quot;functions#issubclass&quot;&gt;&lt;code&gt;issubclass()&lt;/code&gt;&lt;/a&gt; function, but the registering ABC won&amp;rsquo;t show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via &lt;a href=&quot;functions#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt;). &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">이 메타 클래스를 사용하여 ABC를 작성하십시오. ABC는 직접 서브 클래 싱 된 다음 믹스 인 클래스 역할을합니다. 관련이없는 구체적 클래스 (내장 클래스)와 관련이없는 ABC를 &quot;가상 서브 클래스&quot;로 등록 할 수도 있습니다.이 서브 클래스와 그 하위 항목은 내장 &lt;a href=&quot;functions#issubclass&quot;&gt; &lt;code&gt;issubclass()&lt;/code&gt; &lt;/a&gt; 함수 에 의해 등록 ABC의 서브 클래스로 간주 되지만 등록 ABC는 이겼습니다. MRO (Method Resolution Order)에 표시되지 않으며 ABC 등록에 의해 정의 된 메소드 구현을 호출 할 수 없습니다 &lt;a href=&quot;functions#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 조차도 ). &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bdab79877c9aff2232b3c33a22d6693c69abec8" translate="yes" xml:space="preserve">
          <source>Used as the return value of the callback function in &lt;a href=&quot;#ssl.SSLContext.set_servername_callback&quot;&gt;&lt;code&gt;SSLContext.set_servername_callback()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.set_servername_callback&quot;&gt; &lt;code&gt;SSLContext.set_servername_callback()&lt;/code&gt; &lt;/a&gt; 에서 콜백 함수의 반환 값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f82127a2c2d7d75bf1de72d48006249872b07dda" translate="yes" xml:space="preserve">
          <source>Used by class Screen, which thus automatically provides a ScrolledCanvas as playground for the turtles.</source>
          <target state="translated">클래스 스크린에서 사용되며, 거북 놀이터로 ScrolledCanvas를 자동으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1e979fe09b6bd0f001f9f5432c729b3ccb465bc9" translate="yes" xml:space="preserve">
          <source>Used by queue consumers. For each &lt;a href=&quot;#asyncio.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; used to fetch a task, a subsequent call to &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; tells the queue that the processing on the task is complete.</source>
          <target state="translated">큐 소비자가 사용합니다. 태스크를 페치하는 데 사용 된 각 &lt;a href=&quot;#asyncio.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 에 대해 후속 &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출 은 태스크 처리가 완료되었음을 큐에 알립니다.</target>
        </trans-unit>
        <trans-unit id="7a8582ae1f2665fbf84f38cb456084728c223988" translate="yes" xml:space="preserve">
          <source>Used for half-delay mode, which is similar to cbreak mode in that characters typed by the user are immediately available to the program. However, after blocking for &lt;em&gt;tenths&lt;/em&gt; tenths of seconds, raise an exception if nothing has been typed. The value of &lt;em&gt;tenths&lt;/em&gt; must be a number between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;255&lt;/code&gt;. Use &lt;a href=&quot;#curses.nocbreak&quot;&gt;&lt;code&gt;nocbreak()&lt;/code&gt;&lt;/a&gt; to leave half-delay mode.</source>
          <target state="translated">사용자가 입력 한 문자를 프로그램에서 즉시 사용할 수 있다는 점에서 중단 모드와 유사한 반 지연 모드에 사용됩니다. 그러나 &lt;em&gt;10&lt;/em&gt; 분의 1/10 초 동안 차단 한 후 아무 것도 입력하지 않으면 예외가 발생합니다. &lt;em&gt;10&lt;/em&gt; 의 값은 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;255&lt;/code&gt; 사이의 숫자 여야합니다 . 반 지연 모드를 &lt;a href=&quot;#curses.nocbreak&quot;&gt; &lt;code&gt;nocbreak()&lt;/code&gt; &lt;/a&gt; 하려면 nocbreak () 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f06f022628c2d1b93ae2cc8948d4d0af4d5ae00a" translate="yes" xml:space="preserve">
          <source>Used for implementing formatted literal strings (f-strings). Pops an optional &lt;em&gt;fmt_spec&lt;/em&gt; from the stack, then a required &lt;em&gt;value&lt;/em&gt;. &lt;em&gt;flags&lt;/em&gt; is interpreted as follows:</source>
          <target state="translated">형식화 된 리터럴 문자열 (f- 문자열)을 구현하는 데 사용됩니다. 스택에서 선택적 &lt;em&gt;fmt_spec&lt;/em&gt; 을 &lt;em&gt;팝한&lt;/em&gt; 다음 필수 &lt;em&gt;값을&lt;/em&gt; 팝합니다 . &lt;em&gt;플래그&lt;/em&gt; 는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc54f6a9aa92d7a088351515d65a7c819a35b89" translate="yes" xml:space="preserve">
          <source>Used internally for PIL-style arrays. The value is informational only.</source>
          <target state="translated">PIL 스타일 배열에 내부적으로 사용됩니다. 값은 정보 제공 용입니다.</target>
        </trans-unit>
        <trans-unit id="6491331167a81c53e5c33555dd1c8389a48d8445" translate="yes" xml:space="preserve">
          <source>Used to communicate with horizontal scrollbars.</source>
          <target state="translated">가로 스크롤 막대와 통신하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c64f9f83dce5dde840388bdaecc8458dccd14e03" translate="yes" xml:space="preserve">
          <source>Used to communicate with vertical scrollbars. For some more information, see above.</source>
          <target state="translated">세로 스크롤 막대와 통신하는 데 사용됩니다. 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4ad9ddaa5df0e2aafe056836983124424bd313" translate="yes" xml:space="preserve">
          <source>Used to compare</source>
          <target state="translated">비교하는 데 사용</target>
        </trans-unit>
        <trans-unit id="91a1d8f2678510dd75c3aa4dbdec84d9816a43ed" translate="yes" xml:space="preserve">
          <source>Used to compute initial rollover time</source>
          <target state="translated">초기 롤오버 시간을 계산하는 데 사용</target>
        </trans-unit>
        <trans-unit id="08a327ec030bd193b20ca54e75819675f7371b1c" translate="yes" xml:space="preserve">
          <source>Used to indicate a set of characters. In a set:</source>
          <target state="translated">문자 집합을 나타내는 데 사용됩니다. 세트에서 :</target>
        </trans-unit>
        <trans-unit id="f0e9f07f7d6a756d8e0d078a5e0fe1a3f6b1b536" translate="yes" xml:space="preserve">
          <source>Useful constants representing internal nodes of the parse tree.</source>
          <target state="translated">구문 분석 트리의 내부 노드를 나타내는 유용한 상수입니다.</target>
        </trans-unit>
        <trans-unit id="87be7f67261e2f0fefc8a90dca21ae95816dbf29" translate="yes" xml:space="preserve">
          <source>Useful constants representing leaf nodes of the parse tree and functions for testing node values.</source>
          <target state="translated">구문 분석 트리의 리프 노드를 나타내는 유용한 상수 및 노드 값을 테스트하기위한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ba015f21c7d53068a8d1713a783f9a4aa518b47d" translate="yes" xml:space="preserve">
          <source>Useful example of &lt;a href=&quot;#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt; to read and write &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; history files.</source>
          <target state="translated">유용한 예를 &lt;a href=&quot;#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; 는&lt;/a&gt; 읽기 및 쓰기 &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 기록 파일을.</target>
        </trans-unit>
        <trans-unit id="819cd88d697fb04114357734d0a4953e1648cc70" translate="yes" xml:space="preserve">
          <source>Useful handlers included with the logging module.</source>
          <target state="translated">로깅 모듈에 포함 된 유용한 핸들러.</target>
        </trans-unit>
        <trans-unit id="bffb7bde8fb1030560f8c81be752d28554cebade" translate="yes" xml:space="preserve">
          <source>User ID of the user who originally stored this member.</source>
          <target state="translated">이 멤버를 처음 저장 한 사용자의 사용자 ID입니다.</target>
        </trans-unit>
        <trans-unit id="f30e1fe7c0b6acd8745b10a765a7f4fb5c5ee0d0" translate="yes" xml:space="preserve">
          <source>User code can define additional warning categories by subclassing one of the standard warning categories. A warning category must always be a subclass of the &lt;a href=&quot;exceptions#Warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">사용자 코드는 표준 경고 범주 중 하나를 서브 클래 싱하여 추가 경고 범주를 정의 할 수 있습니다. 경고 범주는 항상 &lt;a href=&quot;exceptions#Warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; 클래스 의 하위 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd76a6ef01344dc63fffbe020875acc447df8daf" translate="yes" xml:space="preserve">
          <source>User code can raise built-in exceptions. This can be used to test an exception handler or to report an error condition &amp;ldquo;just like&amp;rdquo; the situation in which the interpreter raises the same exception; but beware that there is nothing to prevent user code from raising an inappropriate error.</source>
          <target state="translated">사용자 코드는 내장 예외를 일으킬 수 있습니다. 이것은 예외 처리기를 테스트하거나 인터프리터가 동일한 예외를 발생시키는 상황을 &quot;처럼&quot;오류 상태를보고하는 데 사용될 수 있습니다. 그러나 사용자 코드가 부적절한 오류를 일으키는 것을 막을 수있는 것은 없다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9f14b6f0b236ede7621ba0fdd6909e518df52703" translate="yes" xml:space="preserve">
          <source>User code does not normally need to call &lt;code&gt;auth&lt;/code&gt; directly, but can instead call the &lt;a href=&quot;#smtplib.SMTP.login&quot;&gt;&lt;code&gt;login()&lt;/code&gt;&lt;/a&gt; method, which will try each of the above mechanisms in turn, in the order listed. &lt;code&gt;auth&lt;/code&gt; is exposed to facilitate the implementation of authentication methods not (or not yet) supported directly by &lt;a href=&quot;#module-smtplib&quot;&gt;&lt;code&gt;smtplib&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 코드는 일반적으로 &lt;code&gt;auth&lt;/code&gt; 를 직접 호출 할 필요는 없지만 &lt;a href=&quot;#smtplib.SMTP.login&quot;&gt; &lt;code&gt;login()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 할 수 있습니다. login () 메소드는 위의 각 메커니즘을 차례로 나열된 순서대로 시도합니다. &lt;code&gt;auth&lt;/code&gt; 는 &lt;a href=&quot;#module-smtplib&quot;&gt; &lt;code&gt;smtplib&lt;/code&gt; 가&lt;/a&gt; 직접 지원하지 않는 (또는 아직) 인증 방법을 쉽게 구현할 수 있도록 노출되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84a81fa60a53fd3f70212f8a883a1173635ab4b0" translate="yes" xml:space="preserve">
          <source>User command interpreter</source>
          <target state="translated">사용자 명령 해석기</target>
        </trans-unit>
        <trans-unit id="e5adf91ece726624b104dd2485c2a839a6328d16" translate="yes" xml:space="preserve">
          <source>User defined flags for file.</source>
          <target state="translated">파일에 대한 사용자 정의 플래그.</target>
        </trans-unit>
        <trans-unit id="837ac2f806f11ca580d1c3781163b0e72e002397" translate="yes" xml:space="preserve">
          <source>User defined generic type aliases are also supported. Examples:</source>
          <target state="translated">사용자 정의 일반 유형 별명도 지원됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b74dd2344f56ad9942272568c160da474cef5e98" translate="yes" xml:space="preserve">
          <source>User defined value.</source>
          <target state="translated">사용자 정의 값.</target>
        </trans-unit>
        <trans-unit id="dae4b56a599d30541843d6111db279c8f6e56e71" translate="yes" xml:space="preserve">
          <source>User home directory</source>
          <target state="translated">사용자 홈 디렉토리</target>
        </trans-unit>
        <trans-unit id="050950cdf0452013f4526d6003822fc72d925c74" translate="yes" xml:space="preserve">
          <source>User id of the owner.</source>
          <target state="translated">소유자의 사용자 ID</target>
        </trans-unit>
        <trans-unit id="e1f63eb061937021f51dba01e97a48c55059e9c6" translate="yes" xml:space="preserve">
          <source>User identifier of the file owner.</source>
          <target state="translated">파일 소유자의 사용자 식별자.</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">사용자 이름</target>
        </trans-unit>
        <trans-unit id="1e3704b9f36dfd77d888c25db447d4825601916a" translate="yes" xml:space="preserve">
          <source>User name or comment field</source>
          <target state="translated">사용자 이름 또는 설명 필드</target>
        </trans-unit>
        <trans-unit id="10ef42a45644103797c878bfd194ec705ff80ac2" translate="yes" xml:space="preserve">
          <source>User name.</source>
          <target state="translated">사용자 이름.</target>
        </trans-unit>
        <trans-unit id="1c40247837db435c6ac2d3e4807fdb9eaa3fcfec" translate="yes" xml:space="preserve">
          <source>User output in Shell</source>
          <target state="translated">쉘의 사용자 출력</target>
        </trans-unit>
        <trans-unit id="1fa0023bf437bb34f21239d1a3a528a2484c4b30" translate="yes" xml:space="preserve">
          <source>User-defined generic types</source>
          <target state="translated">사용자 정의 제네릭 형식</target>
        </trans-unit>
        <trans-unit id="096a2210b655aeab11edc5d2a988883921409748" translate="yes" xml:space="preserve">
          <source>User-defined objects</source>
          <target state="translated">사용자 정의 객체</target>
        </trans-unit>
        <trans-unit id="d237d99366c12cd2bbf976603224da547f3ec351" translate="yes" xml:space="preserve">
          <source>UserDict objects</source>
          <target state="translated">UserDict 객체</target>
        </trans-unit>
        <trans-unit id="43496013c3e57310ccf58d32810be25b59dbdc0f" translate="yes" xml:space="preserve">
          <source>UserList objects</source>
          <target state="translated">UserList 객체</target>
        </trans-unit>
        <trans-unit id="fdbfc8c4e254851301cd44b01a7f822ceaae5ea4" translate="yes" xml:space="preserve">
          <source>UserString objects</source>
          <target state="translated">UserString 객체</target>
        </trans-unit>
        <trans-unit id="d7c41484c828a997d0c616496cb5a9ba5f11a17d" translate="yes" xml:space="preserve">
          <source>UserWarning</source>
          <target state="translated">UserWarning</target>
        </trans-unit>
        <trans-unit id="a53964d7702a603f5cc33f3432206f51279cc2ec" translate="yes" xml:space="preserve">
          <source>Users are expected to subclass &lt;a href=&quot;#xml.sax.handler.ContentHandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; to support their application. The following methods are called by the parser on the appropriate events in the input document:</source>
          <target state="translated">사용자는 애플리케이션을 지원하기 위해 &lt;a href=&quot;#xml.sax.handler.ContentHandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 를 서브 클래스 화 해야합니다. 입력 문서의 해당 이벤트에 대해 구문 분석기가 다음 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="45a5cf6473d9786c93e12f2179a5a34390bce117" translate="yes" xml:space="preserve">
          <source>Uses an incremental decoder to iteratively decode the input provided by &lt;em&gt;iterator&lt;/em&gt;. This function is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;. The &lt;em&gt;errors&lt;/em&gt; argument (as well as any other keyword argument) is passed through to the incremental decoder.</source>
          <target state="translated">증분 디코더를 사용하여 &lt;em&gt;반복자가&lt;/em&gt; 제공 한 입력을 반복적으로 디코딩 &lt;em&gt;합니다&lt;/em&gt; . 이 기능은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 입니다. &lt;em&gt;에러&lt;/em&gt; 인자 (뿐만 아니라 다른 키워드 인수)이 점진적 디코더로 통과된다.</target>
        </trans-unit>
        <trans-unit id="97ee2b4b00c59db46e2110ba3dfbbe7fc0fb5b55" translate="yes" xml:space="preserve">
          <source>Uses an incremental encoder to iteratively encode the input provided by &lt;em&gt;iterator&lt;/em&gt;. This function is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;. The &lt;em&gt;errors&lt;/em&gt; argument (as well as any other keyword argument) is passed through to the incremental encoder.</source>
          <target state="translated">증분 인코더를 사용하여 &lt;em&gt;반복자가&lt;/em&gt; 제공하는 입력을 반복적으로 인코딩 &lt;em&gt;합니다&lt;/em&gt; . 이 기능은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 입니다. &lt;em&gt;오류&lt;/em&gt; 인수 (뿐만 아니라 다른 키워드 인수) 증분 인코더로 전달된다.</target>
        </trans-unit>
        <trans-unit id="1796fd07c3abc6b437c002199b8dec150da9d3ce" translate="yes" xml:space="preserve">
          <source>Uses the most efficient &lt;em&gt;selector&lt;/em&gt; available for the given platform. It is also possible to manually configure the exact selector implementation to be used:</source>
          <target state="translated">주어진 플랫폼에 가장 효율적인 &lt;em&gt;선택기를&lt;/em&gt; 사용합니다. 사용할 정확한 선택기 구현을 수동으로 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0e598218cf75820dbb2cd3bea919913cabb5e7e" translate="yes" xml:space="preserve">
          <source>Using 2to3</source>
          <target state="translated">2to3 사용</target>
        </trans-unit>
        <trans-unit id="b22ccfadca9ffaf0ddcc4fc0358c97c924012086" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#bz2.BZ2Compressor&quot;&gt;&lt;code&gt;BZ2Compressor&lt;/code&gt;&lt;/a&gt; for incremental compression:</source>
          <target state="translated">증분 압축에 &lt;a href=&quot;#bz2.BZ2Compressor&quot;&gt; &lt;code&gt;BZ2Compressor&lt;/code&gt; &lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="7eebc61ad3858b05e62f7bd808af37d63075ffd3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#bz2.compress&quot;&gt;&lt;code&gt;compress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bz2.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; to demonstrate round-trip compression:</source>
          <target state="translated">왕복 압축을 설명하기 위해 &lt;a href=&quot;#bz2.compress&quot;&gt; &lt;code&gt;compress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bz2.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="2029fedc2458a13f77c1f9a3bf4c5809903fcd63" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#enum.auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#enum.auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="43d26a426ee79b95bc796073c23282baef718e71" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#enum.auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt; would look like:</source>
          <target state="translated">&lt;a href=&quot;#enum.auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; 사용 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3332153ff30b7216dceddba7970328bb03f8b0c5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#hashlib.new&quot;&gt;&lt;code&gt;new()&lt;/code&gt;&lt;/a&gt; with an algorithm provided by OpenSSL:</source>
          <target state="translated">OpenSSL에서 제공하는 알고리즘으로 &lt;a href=&quot;#hashlib.new&quot;&gt; &lt;code&gt;new()&lt;/code&gt; &lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="ad62c774eb93ab84a6850c05f0ec364f019a5e7b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#module-json.tool&quot;&gt;&lt;code&gt;json.tool&lt;/code&gt;&lt;/a&gt; from the shell to validate and pretty-print:</source>
          <target state="translated">쉘에서 &lt;a href=&quot;#module-json.tool&quot;&gt; &lt;code&gt;json.tool&lt;/code&gt; &lt;/a&gt; 을 사용 하여 유효성을 검사하고 예쁘게 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="d464f393105084bac6303efd2c33e015be5fe683" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="4e7ad4acf32468f4df31858e1a7c38b2a8027571" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; to check if a user is authorized to e.g. open a file before actually doing so using &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. It&amp;rsquo;s preferable to use &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-eafp&quot;&gt;EAFP&lt;/a&gt; techniques. For example:</source>
          <target state="translated">예를 들어 실제로 파일을 열기 전에 파일을 열 수있는 권한이 있는지 확인하기 위해 &lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; 를 사용 하는 경우 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 사용 하면 파일을 확인하기 위해 파일을 확인하고 여는 것 사이의 짧은 시간 간격을 이용하여 파일을 조작 할 수 있으므로 보안 허점이 생깁니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-eafp&quot;&gt;EAFP&lt;/a&gt; 기술 을 사용하는 것이 좋습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05e46086069a4eb6aba79398aaeef75e0337d56c" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#os.listdir&quot;&gt;&lt;code&gt;listdir()&lt;/code&gt;&lt;/a&gt; can significantly increase the performance of code that also needs file type or file attribute information, because &lt;a href=&quot;#os.DirEntry&quot;&gt;&lt;code&gt;os.DirEntry&lt;/code&gt;&lt;/a&gt; objects expose this information if the operating system provides it when scanning a directory. All &lt;a href=&quot;#os.DirEntry&quot;&gt;&lt;code&gt;os.DirEntry&lt;/code&gt;&lt;/a&gt; methods may perform a system call, but &lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt;&lt;code&gt;is_dir()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.DirEntry.is_file&quot;&gt;&lt;code&gt;is_file()&lt;/code&gt;&lt;/a&gt; usually only require a system call for symbolic links; &lt;a href=&quot;#os.DirEntry.stat&quot;&gt;&lt;code&gt;os.DirEntry.stat()&lt;/code&gt;&lt;/a&gt; always requires a system call on Unix but only requires one for symbolic links on Windows.</source>
          <target state="translated">&lt;a href=&quot;#os.DirEntry&quot;&gt; &lt;code&gt;os.DirEntry&lt;/code&gt; &lt;/a&gt; 객체는 디렉토리를 스캔 할 때 운영 체제에서 정보를 제공 할 경우이 정보를 노출 하므로 &lt;a href=&quot;#os.listdir&quot;&gt; &lt;code&gt;listdir()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 대신 scandir ()을 사용하면 파일 유형 또는 파일 속성 정보가 필요한 코드의 성능이 크게 향상 될 수 있습니다 . 모든 &lt;a href=&quot;#os.DirEntry&quot;&gt; &lt;code&gt;os.DirEntry&lt;/code&gt; &lt;/a&gt; 메소드는 시스템 호출을 수행 할 수 있지만 &lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt; &lt;code&gt;is_dir()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.DirEntry.is_file&quot;&gt; &lt;code&gt;is_file()&lt;/code&gt; &lt;/a&gt; 일반적으로 기호 링크에 대한 시스템 호출 만 필요합니다. &lt;a href=&quot;#os.DirEntry.stat&quot;&gt; &lt;code&gt;os.DirEntry.stat()&lt;/code&gt; &lt;/a&gt; 항상 Unix에서 시스템 호출이 필요하지만 Windows에서는 기호 링크에 대한 호출 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3883f28289ce4c7d604b31aff5ba0b408a5bf2f7" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; to return a sequence of values:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 를 사용 하여 일련의 값을 반환 :</target>
        </trans-unit>
        <trans-unit id="ea0de95702cc7230baa48c3cfd3852b48dab7f01" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="1e3aeddb8fef1ed2a7cff5e13174b13353739c23" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; would look like:</source>
          <target state="translated">&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2689ab8940d02d7de1ca68e6a4b43fe67530d0bc" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; as a context manager is a great way to ensure your file handles are closed properly and is becoming common:</source>
          <target state="translated">컨텍스트 관리자로 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 을 사용하면 파일 핸들이 올바르게 닫히고 일반화되는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="75ece5db0a196d8368913a7d8ebe30c4301fe19a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; as the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt;, it is easy to group a sequence of key-value pairs into a dictionary of lists:</source>
          <target state="translated">&lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 로 사용하면 일련의 키-값 쌍을 목록 사전으로 쉽게 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ff2511d6a7f0fa504c9e9bb252e706108d932f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;datetime.strptime(date_string, format)&lt;/code&gt; is equivalent to:</source>
          <target state="translated">사용 &lt;code&gt;datetime.strptime(date_string, format)&lt;/code&gt; 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="aa1c396214dc747fc568a18547cde7d0930db839" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;loop.create_connection()&lt;/code&gt; to &lt;a href=&quot;asyncio-protocol#asyncio-example-create-connection&quot;&gt;connect a socket&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;code&gt;loop.create_connection()&lt;/code&gt; 하는 &lt;a href=&quot;asyncio-protocol#asyncio-example-create-connection&quot;&gt;소켓을 연결합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce11a3954da4ad24f2eda9c45c6a6a5ff16cff8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;loop.create_connection()&lt;/code&gt; to implement &lt;a href=&quot;asyncio-protocol#asyncio-example-tcp-echo-client-protocol&quot;&gt;an echo-client&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;code&gt;loop.create_connection()&lt;/code&gt; 구현하는 &lt;a href=&quot;asyncio-protocol#asyncio-example-tcp-echo-client-protocol&quot;&gt;에코 클라이언트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e73e77844e32168a133432fdc484125ad1e928e" translate="yes" xml:space="preserve">
          <source>Using Mock</source>
          <target state="translated">모의 사용</target>
        </trans-unit>
        <trans-unit id="988ffa6cf84925a7e2f11a2d4da93941ab8db1b3" translate="yes" xml:space="preserve">
          <source>Using Tix</source>
          <target state="translated">Tix 사용</target>
        </trans-unit>
        <trans-unit id="a3b39b06fc36d238ca9fd0e34aa3702c74df4872" translate="yes" xml:space="preserve">
          <source>Using Ttk</source>
          <target state="translated">Ttk 사용</target>
        </trans-unit>
        <trans-unit id="6f2bfcfa7f0c89ae800d87806ee91ffdff6c2390" translate="yes" xml:space="preserve">
          <source>Using UTF-8 as the Default Source Encoding</source>
          <target state="translated">UTF-8을 기본 소스 인코딩으로 사용</target>
        </trans-unit>
        <trans-unit id="7b4dafbddf83b4c5d5c51b21c48f00b8d136bed2" translate="yes" xml:space="preserve">
          <source>Using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cumulative_distribution_function&quot;&gt;cumulative distribution function (cdf)&lt;/a&gt;, compute the probability that a random variable &lt;em&gt;X&lt;/em&gt; will be less than or equal to &lt;em&gt;x&lt;/em&gt;. Mathematically, it is written &lt;code&gt;P(X &amp;lt;= x)&lt;/code&gt;.</source>
          <target state="translated">사용하여 A &lt;a href=&quot;https://en.wikipedia.org/wiki/Cumulative_distribution_function&quot;&gt;누적 분포 함수 (CDF)를&lt;/a&gt; , 확률 변수의 확률 계산 &lt;em&gt;X가&lt;/em&gt; 미만이거나 동일 할 &lt;em&gt;X를&lt;/em&gt; . 수학적으로 &lt;code&gt;P(X &amp;lt;= x)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ba910e1ce5f13f1f4ea2ed92206f282bf3b88194" translate="yes" xml:space="preserve">
          <source>Using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;probability density function (pdf)&lt;/a&gt;, compute the relative likelihood that a random variable &lt;em&gt;X&lt;/em&gt; will be near the given value &lt;em&gt;x&lt;/em&gt;. Mathematically, it is the limit of the ratio &lt;code&gt;P(x &amp;lt;=
X &amp;lt; x+dx) / dx&lt;/code&gt; as &lt;em&gt;dx&lt;/em&gt; approaches zero.</source>
          <target state="translated">사용하여 A &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;확률 밀도 함수 (PDF)를&lt;/a&gt; , 랜덤 변수이라는 상대 가능성 계산 &lt;em&gt;X가&lt;/em&gt; 소정 값 근방 것이다 &lt;em&gt;X를&lt;/em&gt; . 수학적으로, 이는 비의 한계 &lt;code&gt;P(x &amp;lt;= X &amp;lt; x+dx) / dx&lt;/code&gt; 로서 &lt;em&gt;DX가&lt;/em&gt; 제로 접근법.</target>
        </trans-unit>
        <trans-unit id="50e9189c5263c54e966ddb0c0fcbf7b491be40a3" translate="yes" xml:space="preserve">
          <source>Using a callable:</source>
          <target state="translated">호출 가능 사용하기 :</target>
        </trans-unit>
        <trans-unit id="75220b874a1b14dcc1d9274c28e10a2768d28bff" translate="yes" xml:space="preserve">
          <source>Using a context manager as a function decorator</source>
          <target state="translated">함수 데코레이터로 컨텍스트 관리자 사용</target>
        </trans-unit>
        <trans-unit id="4d5214967f9aa69db8719e748debbab68f82aea5" translate="yes" xml:space="preserve">
          <source>Using a custom &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de60096a210691c18ae3d3da4e5e7f7f31853253" translate="yes" xml:space="preserve">
          <source>Using a custom timer</source>
          <target state="translated">맞춤 타이머 사용</target>
        </trans-unit>
        <trans-unit id="9ca12f2496ddb81117cd62c302718c441b5e7172" translate="yes" xml:space="preserve">
          <source>Using a descriptive string</source>
          <target state="translated">설명 문자열 사용</target>
        </trans-unit>
        <trans-unit id="afb7c939cdae700f3a6eb60d7fb5128652ab012f" translate="yes" xml:space="preserve">
          <source>Using a generic class without specifying type parameters assumes &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; for each position. In the following example, &lt;code&gt;MyIterable&lt;/code&gt; is not generic but implicitly inherits from &lt;code&gt;Iterable[Any]&lt;/code&gt;:</source>
          <target state="translated">유형 매개 변수를 지정하지 않고 일반 클래스를 사용하면 각 위치에 대해 &lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 를 가정합니다 . 다음 예제에서 &lt;code&gt;MyIterable&lt;/code&gt; 은 일반이 아니지만 &lt;code&gt;Iterable[Any]&lt;/code&gt; 에서 암시 적으로 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="d307c55b385e0819ab9d20174ffebefe22e8b6b6" translate="yes" xml:space="preserve">
          <source>Using a list comprehension: &lt;code&gt;[x for x in iterable]&lt;/code&gt;</source>
          <target state="translated">리스트 이해하기 : &lt;code&gt;[x for x in iterable]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9615543c2d928cf50040f980706115431fc8728d" translate="yes" xml:space="preserve">
          <source>Using a pair of parentheses to denote the empty tuple: &lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">빈 튜플을 나타내는 괄호 쌍 사용 : &lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bc851502c6676f542b9ab198cbf3f862b23400c" translate="yes" xml:space="preserve">
          <source>Using a pair of square brackets to denote the empty list: &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">빈 목록을 표시하기 위해 대괄호 쌍 사용 : &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5a75250125304baf8a8f8d2739eb842d37fc846" translate="yes" xml:space="preserve">
          <source>Using a pool of workers</source>
          <target state="translated">작업자 풀 사용</target>
        </trans-unit>
        <trans-unit id="8383415a2a10a3f8f1036870f131e3fe6f99e151" translate="yes" xml:space="preserve">
          <source>Using a remote manager</source>
          <target state="translated">원격 관리자 사용</target>
        </trans-unit>
        <trans-unit id="f23700feacc3a477143f8b09438dc2426f25eecd" translate="yes" xml:space="preserve">
          <source>Using a separate test for &amp;ldquo;liveness&amp;rdquo; creates race conditions in threaded applications; another thread can cause a weak reference to become invalidated before the weak reference is called; the idiom shown above is safe in threaded applications as well as single-threaded applications.</source>
          <target state="translated">&quot;liveness&quot;에 대한 별도의 테스트를 사용하면 스레드 응용 프로그램에서 경쟁 조건이 발생합니다. 다른 스레드는 약한 참조가 호출되기 전에 약한 참조가 무효화 될 수 있습니다. 위에 표시된 관용구는 단일 스레드 응용 프로그램뿐만 아니라 스레드 응용 프로그램에서도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="38537e54bac1a305fb2ceea706898c0b3eab781f" translate="yes" xml:space="preserve">
          <source>Using a string as the value would look like:</source>
          <target state="translated">문자열을 값으로 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0514595eb268ee9e74173dda1049b389b853d97" translate="yes" xml:space="preserve">
          <source>Using a trailing comma for a singleton tuple: &lt;code&gt;a,&lt;/code&gt; or &lt;code&gt;(a,)&lt;/code&gt;</source>
          <target state="translated">싱글 톤 튜플에 후행 쉼표 사용 : &lt;code&gt;a,&lt;/code&gt; 또는 &lt;code&gt;(a,)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac783cf466229eb8f1ea0637db6e6bae53f92af8" translate="yes" xml:space="preserve">
          <source>Using a value in the configuration dict lets configurations to be sent over the wire as pickled dicts to a socket listener. Thus, the logging verbosity of a long-running application can be altered over time with no need to stop and restart the application.</source>
          <target state="translated">구성 dict에 값을 사용하면 소켓 리스너에 절인 dict로 구성을 와이어를 통해 전송할 수 있습니다. 따라서 장기 실행 응용 프로그램의 로깅 세부 정보는 시간이 지남에 따라 응용 프로그램을 중지했다가 다시 시작할 필요없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f653044b0deb519381cad92e86f64dbb241a7b3" translate="yes" xml:space="preserve">
          <source>Using adapters to store additional Python types in SQLite databases</source>
          <target state="translated">어댑터를 사용하여 SQLite 데이터베이스에 추가 Python 유형 저장</target>
        </trans-unit>
        <trans-unit id="8ed960171bb00be50b6cf25e8e3d2d57ed5e8c5b" translate="yes" xml:space="preserve">
          <source>Using an auto-numbering &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; would look like:</source>
          <target state="translated">자동 번호 매기기 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9684f34bd96b132133b1597608ee067cffce7c3" translate="yes" xml:space="preserve">
          <source>Using any of these methods signifies to the user that these values are not important, and also enables one to add, remove, or reorder members without having to renumber the remaining members.</source>
          <target state="translated">이러한 방법 중 하나를 사용하면 사용자에게 이러한 값이 중요하지 않으며 나머지 구성원의 번호를 다시 매길 필요없이 구성원을 추가, 제거 또는 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ef4f4199027402c151a50d927a41c2996ff8f9f" translate="yes" xml:space="preserve">
          <source>Using automatic values</source>
          <target state="translated">자동 값 사용</target>
        </trans-unit>
        <trans-unit id="8e18b23aa8166ee94001b3c568e708c504704e7c" translate="yes" xml:space="preserve">
          <source>Using dataclasses, &lt;em&gt;if&lt;/em&gt; this code was valid:</source>
          <target state="translated">이 코드가 유효한 &lt;em&gt;경우 데이터&lt;/em&gt; 클래스 사용 :</target>
        </trans-unit>
        <trans-unit id="121ccf7d7533afb43d6d034aec33aed44552426e" translate="yes" xml:space="preserve">
          <source>Using default factory functions is a way to create new instances of mutable types as default values for fields:</source>
          <target state="translated">기본 팩토리 함수를 사용하면 변경 가능한 유형의 새 인스턴스를 필드의 기본값으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6559d2f6f048a1637ae00fb7cb017f563475f7" translate="yes" xml:space="preserve">
          <source>Using different digest sizes</source>
          <target state="translated">다른 다이제스트 크기 사용</target>
        </trans-unit>
        <trans-unit id="255ce6190840fec731e885d587707ae723af9b80" translate="yes" xml:space="preserve">
          <source>Using events</source>
          <target state="translated">이벤트 사용</target>
        </trans-unit>
        <trans-unit id="de77a822ff9b97844fd2f5eef17f93a224452770" translate="yes" xml:space="preserve">
          <source>Using importlib.metadata</source>
          <target state="translated">importlib.metadata 사용</target>
        </trans-unit>
        <trans-unit id="94dd17d3eee91a6f460b34718a819c2ee9b54b47" translate="yes" xml:space="preserve">
          <source>Using locks, conditions, and semaphores in the &lt;code&gt;with&lt;/code&gt; statement</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문 에서 잠금, 조건 및 세마포어 사용</target>
        </trans-unit>
        <trans-unit id="72adde2953e72ee1f91517e883fc94f79d9bef65" translate="yes" xml:space="preserve">
          <source>Using long option names is equally easy:</source>
          <target state="translated">긴 옵션 이름을 사용하는 것도 마찬가지로 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f99afb1c0580e5c9200f58e2effc9e111e841402" translate="yes" xml:space="preserve">
          <source>Using maildir format</source>
          <target state="translated">maildir 형식 사용</target>
        </trans-unit>
        <trans-unit id="c3e9900bea0722fcf9bc91bc0b782f7afce3e773" translate="yes" xml:space="preserve">
          <source>Using partial objects is usually more convenient than using lambdas, as asyncio can render partial objects better in debug and error messages.</source>
          <target state="translated">asyncio가 디버그 및 오류 메시지에서 부분 객체를 더 잘 렌더링 할 수 있으므로 부분 객체를 사용하는 것이 일반적으로 람다를 사용하는 것보다 편리합니다.</target>
        </trans-unit>
        <trans-unit id="799ae737f71621b7f1a5b1c9102fbd2295987f9d" translate="yes" xml:space="preserve">
          <source>Using screen events</source>
          <target state="translated">스크린 이벤트 사용</target>
        </trans-unit>
        <trans-unit id="c0f796650a131fcb2aa652625b99a9658f346ae5" translate="yes" xml:space="preserve">
          <source>Using separate &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; instances instead of reusing a single instance avoids that problem:</source>
          <target state="translated">단일 인스턴스를 재사용하는 대신 별도의 &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용 하면 이러한 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3442d5c13fd47976c3bf0ec76271111a44909d9e" translate="yes" xml:space="preserve">
          <source>Using shortcut methods</source>
          <target state="translated">바로 가기 방법 사용</target>
        </trans-unit>
        <trans-unit id="c2d8da51afc83980ac89c6ca94ec45396b00f1ac" translate="yes" xml:space="preserve">
          <source>Using sqlite3 efficiently</source>
          <target state="translated">sqlite3를 효율적으로 사용하기</target>
        </trans-unit>
        <trans-unit id="320599014228e813440efb4020e5b50ef5441b66" translate="yes" xml:space="preserve">
          <source>Using square brackets, separating items with commas: &lt;code&gt;[a]&lt;/code&gt;, &lt;code&gt;[a, b, c]&lt;/code&gt;</source>
          <target state="translated">대괄호를 사용하여 항목을 쉼표로 구분 : &lt;code&gt;[a]&lt;/code&gt; , &lt;code&gt;[a, b, c]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d8c6027625bc1e5d809004bd3a7dfcd28685592" translate="yes" xml:space="preserve">
          <source>Using sysconfig as a script</source>
          <target state="translated">sysconfig를 스크립트로 사용</target>
        </trans-unit>
        <trans-unit id="c598912622c37d39a35330e55608828824a76ad7" translate="yes" xml:space="preserve">
          <source>Using the &amp;ldquo;&lt;code&gt;**&lt;/code&gt;&amp;rdquo; pattern in large directory trees may consume an inordinate amount of time.</source>
          <target state="translated">큰 디렉토리 트리에서 &quot; &lt;code&gt;**&lt;/code&gt; &quot;패턴을 사용하면 시간이 많이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20b1a4d90df2ea292b0302f5e727d9dd477ac602" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#module-zipapp&quot;&gt;&lt;code&gt;zipapp&lt;/code&gt;&lt;/a&gt; module, it is possible to create self-contained Python programs, which can be distributed to end users who only need to have a suitable version of Python installed on their system. The key to doing this is to bundle all of the application&amp;rsquo;s dependencies into the archive, along with the application code.</source>
          <target state="translated">&lt;a href=&quot;#module-zipapp&quot;&gt; &lt;code&gt;zipapp&lt;/code&gt; &lt;/a&gt; 모듈을 사용하면 시스템에 적합한 버전의 Python 만 설치해야하는 최종 사용자에게 배포 할 수있는 자체 포함 된 Python 프로그램을 작성할 수 있습니다. 이 작업의 핵심은 응용 프로그램 코드와 함께 모든 응용 프로그램의 종속성을 아카이브에 묶는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7864597e7acea55d09dd94985971ff805ed9a8a0" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate&lt;/code&gt;&lt;/a&gt; method to stop a process is liable to cause any shared resources (such as locks, semaphores, pipes and queues) currently being used by the process to become broken or unavailable to other processes.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 프로세스를 중지하면 프로세스에서 현재 사용중인 공유 자원 (예 : 잠금, 세마포어, 파이프 및 큐)이 손상되거나 다른 프로세스에서 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="b726411759353a962ae614ca51a43d068731b30e" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#tuple&quot;&gt;&lt;code&gt;tuple()&lt;/code&gt;&lt;/a&gt; built-in: &lt;code&gt;tuple()&lt;/code&gt; or &lt;code&gt;tuple(iterable)&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;#tuple&quot;&gt; &lt;code&gt;tuple()&lt;/code&gt; &lt;/a&gt; 내장 사용 : &lt;code&gt;tuple()&lt;/code&gt; 또는 &lt;code&gt;tuple(iterable)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b90745245f4a0f18b1bf49ea4cccb202e2b1025" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dev&lt;/code&gt; Python command line option.</source>
          <target state="translated">은 Using &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;dev&lt;/code&gt; 에 파이썬 명령 줄 옵션을.</target>
        </trans-unit>
        <trans-unit id="0fd2d05a10558a5e6e11eb83de43bd2b9e3020b5" translate="yes" xml:space="preserve">
          <source>Using the Ttk widgets gives the application an improved look and feel. As discussed above, there are differences in how the styling is coded.</source>
          <target state="translated">Ttk 위젯을 사용하면 애플리케이션의 모양과 느낌이 향상됩니다. 위에서 설명한 것처럼 스타일을 코딩하는 방법에는 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8b1f1cc65fb2aeb01222b99772f21a79b8f9f1c" translate="yes" xml:space="preserve">
          <source>Using the cgi module</source>
          <target state="translated">cgi 모듈 사용</target>
        </trans-unit>
        <trans-unit id="414513cd2ccd5f659d92ac7be558ff20be654791" translate="yes" xml:space="preserve">
          <source>Using the comma as a thousands separator:</source>
          <target state="translated">쉼표를 천 단위 구분 기호로 사용 :</target>
        </trans-unit>
        <trans-unit id="4be88d9241472398fa24fa0cf31272713a8b4373" translate="yes" xml:space="preserve">
          <source>Using the connection as a context manager</source>
          <target state="translated">컨텍스트 관리자로 연결 사용</target>
        </trans-unit>
        <trans-unit id="3f82472d95e0faa8f20343f14d65c9d0b7f0391e" translate="yes" xml:space="preserve">
          <source>Using the file after calling &lt;code&gt;flush()&lt;/code&gt; or &lt;code&gt;close()&lt;/code&gt; on the &lt;a href=&quot;#mailbox.MMDF&quot;&gt;&lt;code&gt;MMDF&lt;/code&gt;&lt;/a&gt; instance may yield unpredictable results or raise an exception.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.MMDF&quot;&gt; &lt;code&gt;MMDF&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 &lt;code&gt;flush()&lt;/code&gt; 또는 &lt;code&gt;close()&lt;/code&gt; 를 호출 한 후 파일을 사용하면 예기치 않은 결과가 발생하거나 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99db02a945df11fe3bf69aa645bc3e8c058040d1" translate="yes" xml:space="preserve">
          <source>Using the file after calling &lt;code&gt;flush()&lt;/code&gt; or &lt;code&gt;close()&lt;/code&gt; on the &lt;a href=&quot;#mailbox.mbox&quot;&gt;&lt;code&gt;mbox&lt;/code&gt;&lt;/a&gt; instance may yield unpredictable results or raise an exception.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.mbox&quot;&gt; &lt;code&gt;mbox&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 &lt;code&gt;flush()&lt;/code&gt; 또는 &lt;code&gt;close()&lt;/code&gt; 를 호출 한 후 파일을 사용하면 예기치 않은 결과가 발생하거나 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="657776931d7a6faef6a4a5155f927f48b4e36008" translate="yes" xml:space="preserve">
          <source>Using the nonstandard &lt;code&gt;execute()&lt;/code&gt;, &lt;code&gt;executemany()&lt;/code&gt; and &lt;code&gt;executescript()&lt;/code&gt; methods of the &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; object, your code can be written more concisely because you don&amp;rsquo;t have to create the (often superfluous) &lt;a href=&quot;#sqlite3.Cursor&quot;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/a&gt; objects explicitly. Instead, the &lt;a href=&quot;#sqlite3.Cursor&quot;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/a&gt; objects are created implicitly and these shortcut methods return the cursor objects. This way, you can execute a &lt;code&gt;SELECT&lt;/code&gt; statement and iterate over it directly using only a single call on the &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 객체 의 비표준 &lt;code&gt;execute()&lt;/code&gt; , &lt;code&gt;executemany()&lt;/code&gt; 및 &lt;code&gt;executescript()&lt;/code&gt; 메소드 를 사용하면 (종종 불필요한) &lt;a href=&quot;#sqlite3.Cursor&quot;&gt; &lt;code&gt;Cursor&lt;/code&gt; &lt;/a&gt; 객체를 명시 적으로 만들 필요가 없으므로 코드를 더 간결하게 작성할 수 있습니다 . 대신 &lt;a href=&quot;#sqlite3.Cursor&quot;&gt; &lt;code&gt;Cursor&lt;/code&gt; &lt;/a&gt; 객체는 암시 적으로 만들어지며 이러한 바로 가기 메서드는 커서 객체를 반환합니다. 이런 식으로 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 개체 에서 단일 호출 만 사용하여 &lt;code&gt;SELECT&lt;/code&gt; 문을 실행하고 직접 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47aee112b6935fb523810f9a1f409db0f6fb290a" translate="yes" xml:space="preserve">
          <source>Using the standard (non-&lt;code&gt;compat32&lt;/code&gt;) policies, the returned value is an instance of a subclass of &lt;a href=&quot;email.headerregistry#email.headerregistry.BaseHeader&quot;&gt;&lt;code&gt;email.headerregistry.BaseHeader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 (비 &lt;code&gt;compat32&lt;/code&gt; ) 정책을 사용하면 반환 된 값은 &lt;a href=&quot;email.headerregistry#email.headerregistry.BaseHeader&quot;&gt; &lt;code&gt;email.headerregistry.BaseHeader&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="fc3fe35d196e1ad26b58992b8e30d0a618b3d15e" translate="yes" xml:space="preserve">
          <source>Using the subprocess Module</source>
          <target state="translated">서브 프로세스 모듈 사용</target>
        </trans-unit>
        <trans-unit id="05aa4e92daaabfec4cab2e49b437833277ca4e0d" translate="yes" xml:space="preserve">
          <source>Using the type constructor: &lt;code&gt;list()&lt;/code&gt; or &lt;code&gt;list(iterable)&lt;/code&gt;</source>
          <target state="translated">유형 생성자 사용 : &lt;code&gt;list()&lt;/code&gt; 또는 &lt;code&gt;list(iterable)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dcc39a1df1cb3105fe567a435d77e0613cb83af" translate="yes" xml:space="preserve">
          <source>Using these ASCII based operations to manipulate binary data that is not stored in an ASCII based format may lead to data corruption.</source>
          <target state="translated">ASCII 기반 형식으로 저장되지 않은 이진 데이터를 조작하기 위해 이러한 ASCII 기반 작업을 사용하면 데이터가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ffcc30a6ebac687ec14a0dec9c03c4874f525e" translate="yes" xml:space="preserve">
          <source>Using these methods you can write nice compact code:</source>
          <target state="translated">이 방법을 사용하면 멋진 소형 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82a820d85f9921e73994a56e494b8359a6094ae" translate="yes" xml:space="preserve">
          <source>Using this attribute you can control what objects are returned for the &lt;code&gt;TEXT&lt;/code&gt; data type. By default, this attribute is set to &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module will return Unicode objects for &lt;code&gt;TEXT&lt;/code&gt;. If you want to return bytestrings instead, you can set it to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성을 사용하면 &lt;code&gt;TEXT&lt;/code&gt; 데이터 유형에 대해 리턴 될 오브젝트를 제어 할 수 있습니다 . 기본적으로이 속성은 설정되어 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 에&lt;/a&gt; 와 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; 를&lt;/a&gt; 유니 코드를 반환 모듈에 대한 객체 &lt;code&gt;TEXT&lt;/code&gt; . &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 스트링을 대신 리턴하려면 bytes로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88d5a4c73559123ffb06df00d967f9cd0b062c9f" translate="yes" xml:space="preserve">
          <source>Using this decorator requires that the class&amp;rsquo;s metaclass is &lt;a href=&quot;#abc.ABCMeta&quot;&gt;&lt;code&gt;ABCMeta&lt;/code&gt;&lt;/a&gt; or is derived from it. A class that has a metaclass derived from &lt;a href=&quot;#abc.ABCMeta&quot;&gt;&lt;code&gt;ABCMeta&lt;/code&gt;&lt;/a&gt; cannot be instantiated unless all of its abstract methods and properties are overridden. The abstract methods can be called using any of the normal &amp;lsquo;super&amp;rsquo; call mechanisms. &lt;a href=&quot;#abc.abstractmethod&quot;&gt;&lt;code&gt;abstractmethod()&lt;/code&gt;&lt;/a&gt; may be used to declare abstract methods for properties and descriptors.</source>
          <target state="translated">이 데코레이터를 사용하려면 클래스의 메타 클래스가 &lt;a href=&quot;#abc.ABCMeta&quot;&gt; &lt;code&gt;ABCMeta&lt;/code&gt; &lt;/a&gt; 이거나 그 클래스에서 파생되어야합니다. &lt;a href=&quot;#abc.ABCMeta&quot;&gt; &lt;code&gt;ABCMeta&lt;/code&gt; &lt;/a&gt; 에서 파생 된 메타 클래스가있는 클래스는 모든 추상 메서드 및 속성을 재정의하지 않으면 인스턴스화 할 수 없습니다. 추상적 인 메소드는 일반적인 '슈퍼'호출 메커니즘을 사용하여 호출 할 수 있습니다. &lt;a href=&quot;#abc.abstractmethod&quot;&gt; &lt;code&gt;abstractmethod()&lt;/code&gt; &lt;/a&gt; 사용하여 속성 및 설명자에 대한 추상 메서드를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04978a627ce1975c2d08d1fe862ff2c396639ee3" translate="yes" xml:space="preserve">
          <source>Using type-specific formatting:</source>
          <target state="translated">유형별 서식 사용 :</target>
        </trans-unit>
        <trans-unit id="6a192d773066b752e8add03087aaa95e9d5840fd" translate="yes" xml:space="preserve">
          <source>Usually an IFF-type file consists of one or more chunks. The proposed usage of the &lt;a href=&quot;#chunk.Chunk&quot;&gt;&lt;code&gt;Chunk&lt;/code&gt;&lt;/a&gt; class defined here is to instantiate an instance at the start of each chunk and read from the instance until it reaches the end, after which a new instance can be instantiated. At the end of the file, creating a new instance will fail with an &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">일반적으로 IFF 형식 파일은 하나 이상의 청크로 구성됩니다. 여기에 정의 된 &lt;a href=&quot;#chunk.Chunk&quot;&gt; &lt;code&gt;Chunk&lt;/code&gt; &lt;/a&gt; 클래스 의 제안 된 사용법은 각 청크가 시작될 때 인스턴스를 인스턴스화하고 인스턴스가 끝날 때까지 인스턴스에서 읽은 다음 새 인스턴스를 인스턴스화 할 수 있습니다. 파일 끝에서 새 인스턴스 작성은 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 예외 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="42f0c83d353a2c88d75349acfedbc55986b5c477" translate="yes" xml:space="preserve">
          <source>Usually message passing between processes is done using queues or by using &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; objects returned by &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 프로세스 간 메시지 전달은 큐를 사용하거나 &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe()&lt;/code&gt; &lt;/a&gt; 반환 한 &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 객체 를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="55c3035b6a0c2c422567b7b94ec5c3d81b6f4353" translate="yes" xml:space="preserve">
          <source>Usually this option consists of the method &lt;code&gt;Scrollbar.set()&lt;/code&gt; of some scrollbar. This will cause the scrollbar to be updated whenever the view in the window changes.</source>
          <target state="translated">일반적으로이 옵션은 일부 스크롤 &lt;code&gt;Scrollbar.set()&lt;/code&gt; 메소드로 구성됩니다 . 그러면 창의보기가 변경 될 때마다 스크롤 막대가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="948448f0d7e18600e63d50ac1f18a1bd083aad1f" translate="yes" xml:space="preserve">
          <source>Usually you can use &lt;a href=&quot;#unittest.TestCase.skipTest&quot;&gt;&lt;code&gt;TestCase.skipTest()&lt;/code&gt;&lt;/a&gt; or one of the skipping decorators instead of raising this directly.</source>
          <target state="translated">일반적으로 이것을 직접 올리는 대신 &lt;a href=&quot;#unittest.TestCase.skipTest&quot;&gt; &lt;code&gt;TestCase.skipTest()&lt;/code&gt; &lt;/a&gt; 또는 건너 뛰는 데코레이터 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7159aa4ebaad10cbad60df9f2f47fdab12006d8d" translate="yes" xml:space="preserve">
          <source>Usually you use the transformer like this:</source>
          <target state="translated">일반적으로 다음과 같이 변압기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3c8bb6feca38dd5baf6726db91fee35d699471bf" translate="yes" xml:space="preserve">
          <source>Usually your SQL operations will need to use values from Python variables. You shouldn&amp;rsquo;t assemble your query using Python&amp;rsquo;s string operations because doing so is insecure; it makes your program vulnerable to an SQL injection attack (see &lt;a href=&quot;https://xkcd.com/327/&quot;&gt;https://xkcd.com/327/&lt;/a&gt; for humorous example of what can go wrong).</source>
          <target state="translated">일반적으로 SQL 작업은 Python 변수의 값을 사용해야합니다. 파이썬의 문자열 연산을 사용하여 쿼리를 어셈블해서는 안됩니다. 안전하지 않기 때문입니다. 프로그램이 SQL 인젝션 공격에 취약 해집니다 (오류가 발생할 수있는 유머러스 한 예는 &lt;a href=&quot;https://xkcd.com/327/&quot;&gt;https://xkcd.com/327/&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="18aef760d202fd986f9f4b8de779ecd32a97e992" translate="yes" xml:space="preserve">
          <source>Usually, ctypes does strict type checking. This means, if you have &lt;code&gt;POINTER(c_int)&lt;/code&gt; in the &lt;code&gt;argtypes&lt;/code&gt; list of a function or as the type of a member field in a structure definition, only instances of exactly the same type are accepted. There are some exceptions to this rule, where ctypes accepts other objects. For example, you can pass compatible array instances instead of pointer types. So, for &lt;code&gt;POINTER(c_int)&lt;/code&gt;, ctypes accepts an array of c_int:</source>
          <target state="translated">일반적으로 ctypes는 엄격한 유형 검사를 수행합니다. 이는 함수 의 &lt;code&gt;argtypes&lt;/code&gt; 목록에 또는 구조 정의의 멤버 필드 유형으로 &lt;code&gt;POINTER(c_int)&lt;/code&gt; 가있는 경우 정확히 동일한 유형의 인스턴스 만 허용됨을 의미합니다. 이 규칙에는 ctypes가 다른 객체를 허용하는 예외가 있습니다. 예를 들어, 포인터 유형 대신 호환 가능한 배열 인스턴스를 전달할 수 있습니다. 따라서 &lt;code&gt;POINTER(c_int)&lt;/code&gt; 경우 ctypes는 c_int 배열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="46defc487dd609e5e11afede6e42ed7efb746478" translate="yes" xml:space="preserve">
          <source>Usually, the number of elements output matches the input iterable. However, if the keyword argument &lt;em&gt;initial&lt;/em&gt; is provided, the accumulation leads off with the &lt;em&gt;initial&lt;/em&gt; value so that the output has one more element than the input iterable.</source>
          <target state="translated">일반적으로 출력되는 요소 수는 반복 가능한 입력과 일치합니다. 그러나 키워드 인수 &lt;em&gt;initial&lt;/em&gt; 이 제공되면 누적은 &lt;em&gt;초기&lt;/em&gt; 값으로 &lt;em&gt;시작&lt;/em&gt; 하여 출력에 입력 반복 가능 요소보다 하나 이상의 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="fdb7e6fac588b967be8115ae1239c9f13b01bc33" translate="yes" xml:space="preserve">
          <source>Utilities for working with ASCII characters, regardless of your locale settings.</source>
          <target state="translated">로케일 설정에 관계없이 ASCII 문자로 작업하기위한 유틸리티.</target>
        </trans-unit>
        <trans-unit id="102dc7d3bf538e66387889d7daeeb05e53a870a4" translate="yes" xml:space="preserve">
          <source>Utilities to compile all Python source files in a directory tree.</source>
          <target state="translated">디렉토리 트리에서 모든 Python 소스 파일을 컴파일하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="894c08b4d341d3181d652622edf583cdb792b50d" translate="yes" xml:space="preserve">
          <source>Utilities to help work with fonts.</source>
          <target state="translated">글꼴 작업에 도움이되는 유틸리티.</target>
        </trans-unit>
        <trans-unit id="9b5439bb171dd02403cd4a0162c5e608f757fe9b" translate="yes" xml:space="preserve">
          <source>Utilities to run asyncio programs, create Tasks, and await on multiple things with timeouts.</source>
          <target state="translated">asyncio 프로그램을 실행하고 작업을 생성하며 시간 초과로 여러 항목을 기다리는 유틸리티</target>
        </trans-unit>
        <trans-unit id="4fafea3320bd24aef44e569f108bcf7bb663fa8f" translate="yes" xml:space="preserve">
          <source>Utilities to spawn subprocesses and run shell commands.</source>
          <target state="translated">서브 프로세스를 생성하고 쉘 명령을 실행하는 유틸리티.</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="6e7be9dc79ed50d8c704d7f221a2758927ee65a3" translate="yes" xml:space="preserve">
          <source>Uuencode file &lt;em&gt;in_file&lt;/em&gt; into file &lt;em&gt;out_file&lt;/em&gt;. The uuencoded file will have the header specifying &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt; as the defaults for the results of decoding the file. The default defaults are taken from &lt;em&gt;in_file&lt;/em&gt;, or &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;0o666&lt;/code&gt; respectively. If &lt;em&gt;backtick&lt;/em&gt; is true, zeros are represented by &lt;code&gt;'`'&lt;/code&gt; instead of spaces.</source>
          <target state="translated">uuencode 파일 &lt;em&gt;in_file&lt;/em&gt; 을 파일 &lt;em&gt;out_file로&lt;/em&gt; . 인코딩 된 파일에는 파일 디코딩 결과의 기본값으로 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;모드&lt;/em&gt; 를 지정하는 헤더 가 있습니다. 기본 기본값은 &lt;em&gt;in_file&lt;/em&gt; 또는 각각 &lt;code&gt;'-'&lt;/code&gt; 및 &lt;code&gt;0o666&lt;/code&gt; 에서 가져옵니다 . 경우 &lt;em&gt;역 따옴표는&lt;/em&gt; 사실이다 영 (0)으로 표현된다 &lt;code&gt;'`'&lt;/code&gt; 대신 공간.</target>
        </trans-unit>
        <trans-unit id="51920a4103a076cddaea8c5320e3e3d41f0fe359" translate="yes" xml:space="preserve">
          <source>VRFY</source>
          <target state="translated">VRFY</target>
        </trans-unit>
        <trans-unit id="6ef9fae42b29329a1ed8c77701fe1700d757002f" translate="yes" xml:space="preserve">
          <source>Valid String Arg</source>
          <target state="translated">유효한 문자열 인수</target>
        </trans-unit>
        <trans-unit id="ae9f1d564485db39fcd34520a7886185a9f3d9bb" translate="yes" xml:space="preserve">
          <source>Valid enum Arg</source>
          <target state="translated">유효한 열거 형 Arg</target>
        </trans-unit>
        <trans-unit id="d11dea5084c554faaf9051f680e8d26ff170b6ad" translate="yes" xml:space="preserve">
          <source>Valid values are &lt;code&gt;7bit&lt;/code&gt;, &lt;code&gt;8bit&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, and &lt;code&gt;quoted-printable&lt;/code&gt;. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">유효한 값은 &lt;code&gt;7bit&lt;/code&gt; , &lt;code&gt;8bit&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; 및 &lt;code&gt;quoted-printable&lt;/code&gt; 입니다. 자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ed34a07f3d8b83630e9e822f76c6734a7177025" translate="yes" xml:space="preserve">
          <source>Validating Parsers must use this method to report each chunk of ignorable whitespace (see the W3C XML 1.0 recommendation, section 2.10): non-validating parsers may also use this method if they are capable of parsing and using content models.</source>
          <target state="translated">유효성 검사 파서는 무시할 수있는 공백의 각 청크를보고하기 위해이 방법을 사용해야합니다 (W3C XML 1.0 권장 사항, 섹션 2.10 참조).</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="0701d51e2238471096af133360d47b98e784ca3c" translate="yes" xml:space="preserve">
          <source>Value Types</source>
          <target state="translated">가치 유형</target>
        </trans-unit>
        <trans-unit id="2ee2c05664be5bc3b7425a3cd5c2eaeb9af87ebe" translate="yes" xml:space="preserve">
          <source>Value if not present</source>
          <target state="translated">존재하지 않는 경우의 값</target>
        </trans-unit>
        <trans-unit id="7dd7eb81edd524ab9b2cc8166a90a72809941195" translate="yes" xml:space="preserve">
          <source>Value lengths are limited by available memory. Long values (more than 2048 bytes) should be stored as files with the filenames stored in the configuration registry. This helps the registry perform efficiently.</source>
          <target state="translated">사용 가능한 메모리에 따라 값 길이가 제한됩니다. 긴 값 (2048 바이트 이상)은 구성 레지스트리에 저장된 파일 이름을 가진 파일로 저장해야합니다. 이렇게하면 레지스트리가 효율적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ff4442e3ee6e85b03ce0d04c09a9f9afc7926b83" translate="yes" xml:space="preserve">
          <source>Value may be supplied as either a keyword or positional argument (this is the standard binding behaviour for functions implemented in Python.)</source>
          <target state="translated">값은 키워드 또는 위치 인수로 제공 될 수 있습니다 (Python으로 구현 된 함수에 대한 표준 바인딩 동작입니다).</target>
        </trans-unit>
        <trans-unit id="e606eb6146ca90bd2780303c47db18287309d201" translate="yes" xml:space="preserve">
          <source>Value must be supplied as a keyword argument. Keyword only parameters are those which appear after a &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;*args&lt;/code&gt; entry in a Python function definition.</source>
          <target state="translated">키워드 인수로 값을 제공해야합니다. 키워드 전용 매개 변수는 Python 함수 정의에서 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;*args&lt;/code&gt; 항목 다음에 나타나는 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="f281af900c7055431a7ba9336e9f5b33972ace2e" translate="yes" xml:space="preserve">
          <source>Value must be supplied as a positional argument. Positional only parameters are those which appear before a &lt;code&gt;/&lt;/code&gt; entry (if present) in a Python function definition.</source>
          <target state="translated">위치 인수로 값을 제공해야합니다. 위치 만 매개 변수는 Python 함수 정의에서 &lt;code&gt;/&lt;/code&gt; 항목 (있는 경우) 앞에 표시되는 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="86d356e451eb275892ab84a0a8cabfd82d894744" translate="yes" xml:space="preserve">
          <source>Value of function key &lt;em&gt;n&lt;/em&gt;</source>
          <target state="translated">기능 키 &lt;em&gt;n의&lt;/em&gt; 값&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58abe8dc89cf79184a2726248be2244df3ce518b" translate="yes" xml:space="preserve">
          <source>Value too large for defined data type</source>
          <target state="translated">정의 된 데이터 유형에 비해 너무 큰 값</target>
        </trans-unit>
        <trans-unit id="0f22edd532486ea6c69bc19fb1bb15eb52cfdba0" translate="yes" xml:space="preserve">
          <source>Value used to identify the event. The interpretation depends on the filter but it&amp;rsquo;s usually the file descriptor. In the constructor ident can either be an int or an object with a &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method. kevent stores the integer internally.</source>
          <target state="translated">이벤트를 식별하는 데 사용되는 값입니다. 해석은 필터에 따라 다르지만 일반적으로 파일 디스크립터입니다. 생성자에서 ident는 int이거나 &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 메서드가 있는 객체 일 수 있습니다 . kevent는 정수를 내부적으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ca5e1888f7ff9f4679a3377b455596a48d014681" translate="yes" xml:space="preserve">
          <source>ValueError</source>
          <target state="translated">ValueError</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4ffc08181d2110828c38d18c73ceb4f5562de955" translate="yes" xml:space="preserve">
          <source>Values can be strings, integers, floats, booleans, tuples, lists, dictionaries (but only with string keys), &lt;a href=&quot;#plistlib.Data&quot;&gt;&lt;code&gt;Data&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;bytesarray&lt;/code&gt; or &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">값은 문자열, 정수, 부동 소수점, 부울, 튜플, 목록, 사전 (문자열 키만 포함), &lt;a href=&quot;#plistlib.Data&quot;&gt; &lt;code&gt;Data&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;bytesarray&lt;/code&gt; 또는 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4af2aaf629c09c7b586c6140040cd042f1b5dae" translate="yes" xml:space="preserve">
          <source>Values from other sections can be fetched as well:</source>
          <target state="translated">다른 섹션의 값도 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c8e3c3012e41d09c6656db5fddb8ed8d0ecd84" translate="yes" xml:space="preserve">
          <source>Values in the registry have name, type, and data components. This method retrieves the data for a key&amp;rsquo;s first value that has a &lt;code&gt;NULL&lt;/code&gt; name. But the underlying API call doesn&amp;rsquo;t return the type, so always use &lt;a href=&quot;#winreg.QueryValueEx&quot;&gt;&lt;code&gt;QueryValueEx()&lt;/code&gt;&lt;/a&gt; if possible.</source>
          <target state="translated">레지스트리의 값에는 이름, 유형 및 데이터 구성 요소가 있습니다. 이 메소드는 &lt;code&gt;NULL&lt;/code&gt; 이름 을 가진 키의 첫 번째 값에 대한 데이터를 검색합니다 . 그러나 기본 API 호출은 유형을 반환하지 않으므로 가능하면 항상 &lt;a href=&quot;#winreg.QueryValueEx&quot;&gt; &lt;code&gt;QueryValueEx()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="64c44a2d0d8fe41ed1dbff4d435d6b3be6cd0c3f" translate="yes" xml:space="preserve">
          <source>Values of &lt;em&gt;n&lt;/em&gt; less than &lt;code&gt;0&lt;/code&gt; are treated as &lt;code&gt;0&lt;/code&gt; (which yields an empty sequence of the same type as &lt;em&gt;s&lt;/em&gt;). Note that items in the sequence &lt;em&gt;s&lt;/em&gt; are not copied; they are referenced multiple times. This often haunts new Python programmers; consider:</source>
          <target state="translated">값 &lt;em&gt;N&lt;/em&gt; 미만 &lt;code&gt;0&lt;/code&gt; 으로 취급 &lt;code&gt;0&lt;/code&gt; (동일한 타입의 빈 시퀀스 산출하는 &lt;em&gt;들&lt;/em&gt; ). 시퀀스 &lt;em&gt;의&lt;/em&gt; 항목은 복사되지 않습니다. 그들은 여러 번 참조됩니다. 이것은 종종 새로운 파이썬 프로그래머를 괴롭 힙니다. 치다:</target>
        </trans-unit>
        <trans-unit id="99882406ebedbb37513cb23cc3017de1859ae178" translate="yes" xml:space="preserve">
          <source>Values that cannot be determined are returned as given by the parameter presets. If bits is given as &lt;code&gt;''&lt;/code&gt;, the &lt;code&gt;sizeof(pointer)&lt;/code&gt; (or &lt;code&gt;sizeof(long)&lt;/code&gt; on Python version &amp;lt; 1.5.2) is used as indicator for the supported pointer size.</source>
          <target state="translated">결정할 수없는 값은 매개 변수 사전 설정에 따라 반환됩니다. 비트가로 주어지면 &lt;code&gt;''&lt;/code&gt; 상기 &lt;code&gt;sizeof(pointer)&lt;/code&gt; (또는 &lt;code&gt;sizeof(long)&lt;/code&gt; 파이썬 버전 &amp;lt;1.5.2에)을 지원 포인터 크기의 지표로 사용된다.</target>
        </trans-unit>
        <trans-unit id="b7fc44b31c7c9574a8212b50dbd39bc45209ed3f" translate="yes" xml:space="preserve">
          <source>Values to pass as the &lt;em&gt;mode&lt;/em&gt; parameter of &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; to test the existence, readability, writability and executability of &lt;em&gt;path&lt;/em&gt;, respectively.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 의 존재, 가독성, 쓰기 가능성 및 실행 가능성을 각각 테스트하기 위해 &lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;모드&lt;/em&gt; 매개 변수 로 전달할 값 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="505c78fab28aa9b0b70f7dcbd71feb993b8ff277" translate="yes" xml:space="preserve">
          <source>Variable that specifies the user agent of the opener object. To get &lt;a href=&quot;urllib#module-urllib&quot;&gt;&lt;code&gt;urllib&lt;/code&gt;&lt;/a&gt; to tell servers that it is a particular user agent, set this in a subclass as a class variable or in the constructor before calling the base constructor.</source>
          <target state="translated">오프너 객체의 사용자 에이전트를 지정하는 변수입니다. &lt;a href=&quot;urllib#module-urllib&quot;&gt; &lt;code&gt;urllib&lt;/code&gt; &lt;/a&gt; 가 서버에 특정 사용자 에이전트임을 알리 려면 기본 생성자를 호출하기 전에 서브 클래스에서 클래스 변수 또는 생성자로이를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="acc4399a5b517cf7222cd58ad2c32cfd48aac016" translate="yes" xml:space="preserve">
          <source>Variable-sized data types</source>
          <target state="translated">가변 크기 데이터 유형</target>
        </trans-unit>
        <trans-unit id="25482e67402e6c3f5fe20df41e9dcae2a9ba2841" translate="yes" xml:space="preserve">
          <source>Various structures for implementing schedulers have been extensively studied, and heaps are good for this, as they are reasonably speedy, the speed is almost constant, and the worst case is not much different than the average case. However, there are other representations which are more efficient overall, yet the worst cases might be terrible.</source>
          <target state="translated">스케줄러를 구현하기위한 다양한 구조가 광범위하게 연구되었으며 힙은 합리적으로 빠르며 속도가 거의 일정하며 최악의 경우는 평균 경우와 크게 다르지 않기 때문에 이것에 좋습니다. 그러나 전반적으로 더 효율적인 다른 표현이 있지만 최악의 경우는 끔찍할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c01dc65ed82215cf4434e1aca2d7412f6c775240" translate="yes" xml:space="preserve">
          <source>Vector example:</source>
          <target state="translated">벡터 예 :</target>
        </trans-unit>
        <trans-unit id="965ef7e332ac200f4b5e70778db19b375745f0da" translate="yes" xml:space="preserve">
          <source>Verbose output</source>
          <target state="translated">자세한 출력</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">자세한 출력.</target>
        </trans-unit>
        <trans-unit id="c3b257b1e9f0266480a6612a0d51d64c417b942e" translate="yes" xml:space="preserve">
          <source>Verify that &lt;em&gt;cert&lt;/em&gt; (in decoded format as returned by &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt;&lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt;&lt;/a&gt;) matches the given &lt;em&gt;hostname&lt;/em&gt;. The rules applied are those for checking the identity of HTTPS servers as outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2818&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5280.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5280&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc6125.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6125&lt;/strong&gt;&lt;/a&gt;. In addition to HTTPS, this function should be suitable for checking the identity of servers in various SSL-based protocols such as FTPS, IMAPS, POPS and others.</source>
          <target state="translated">&lt;em&gt;cert&lt;/em&gt; ( &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt; &lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 디코딩 된 형식 )가 지정된 &lt;em&gt;hostname&lt;/em&gt; 과 일치 하는지 확인하십시오 . 적용되는 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2818&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5280.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5280&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6125.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6125에&lt;/strong&gt;&lt;/a&gt; 요약 된 HTTPS 서버의 ID를 확인하기위한 규칙 입니다. HTTPS 외에도이 기능은 FTPS, IMAPS, POPS 등과 같은 다양한 SSL 기반 프로토콜에서 서버의 ID를 확인하는 데 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="53ba4e70726a4a91e073b0dd557344bd475a0a8b" translate="yes" xml:space="preserve">
          <source>Verifying certificates</source>
          <target state="translated">인증서 확인</target>
        </trans-unit>
        <trans-unit id="63f133e763468a73947f4629707ecc9c9d90bb76" translate="yes" xml:space="preserve">
          <source>Version interface for Jython.</source>
          <target state="translated">자이 썬 버전 인터페이스.</target>
        </trans-unit>
        <trans-unit id="19e3aaed4d8f8b4a00e21a218ae1c005508d0951" translate="yes" xml:space="preserve">
          <source>Vertical highlight</source>
          <target state="translated">수직 하이라이트</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">세로 탭</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="c72e003330b099c436ab550f7c7a659390de0b50" translate="yes" xml:space="preserve">
          <source>View Last Restart</source>
          <target state="translated">마지막 재시작보기</target>
        </trans-unit>
        <trans-unit id="f633d1002c0f5f6ce6be33d7377af0ab89993bbb" translate="yes" xml:space="preserve">
          <source>View Objects</source>
          <target state="translated">객체보기</target>
        </trans-unit>
        <trans-unit id="8674ea8214e1ae57f3e50b4fb7b3ef79a1d1476a" translate="yes" xml:space="preserve">
          <source>Vincent Bernat.</source>
          <target state="translated">빈센트 베르나 트.</target>
        </trans-unit>
        <trans-unit id="82cb0e10bd78d0153cd1698ceb6ca31fb1f0f1e3" translate="yes" xml:space="preserve">
          <source>Virtual Events</source>
          <target state="translated">가상 이벤트</target>
        </trans-unit>
        <trans-unit id="17939436623483b052de1e4d3f9d6c11ccdc98ad" translate="yes" xml:space="preserve">
          <source>Virtual events</source>
          <target state="translated">가상 이벤트</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="5a2efe7f1abb84c38f1725a2ecc3c4e87349a479" translate="yes" xml:space="preserve">
          <source>Visit a node. The default implementation calls the method called &lt;code&gt;self.visit_&lt;em&gt;classname&lt;/em&gt;&lt;/code&gt; where &lt;em&gt;classname&lt;/em&gt; is the name of the node class, or &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt;&lt;code&gt;generic_visit()&lt;/code&gt;&lt;/a&gt; if that method doesn&amp;rsquo;t exist.</source>
          <target state="translated">노드를 방문하십시오. 기본 구현은 &lt;code&gt;self.visit_&lt;em&gt;classname&lt;/em&gt;&lt;/code&gt; 이라는 메소드를 호출합니다. 여기서 &lt;em&gt;classname&lt;/em&gt; 은 노드 클래스의 이름이거나 해당 메소드가없는 경우 &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt; &lt;code&gt;generic_visit()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb3c755d8a06e5cd333fac0016835f914045f69e" translate="yes" xml:space="preserve">
          <source>Visual inspection shows that the certificate does identify the desired service (that is, the HTTPS host &lt;code&gt;www.python.org&lt;/code&gt;):</source>
          <target state="translated">육안 검사에 따르면 인증서가 원하는 서비스 (즉, HTTPS 호스트 &lt;code&gt;www.python.org&lt;/code&gt; )를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="5eee88bfaa26b0b2250c40217a4675afbea5cd23" translate="yes" xml:space="preserve">
          <source>Volume number of file header.</source>
          <target state="translated">파일 헤더의 볼륨 번호입니다.</target>
        </trans-unit>
        <trans-unit id="c328c0ed13eb319fbdea95de7337047e0b069c45" translate="yes" xml:space="preserve">
          <source>Voluntarily relinquish the CPU.</source>
          <target state="translated">자발적으로 CPU를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="30e1c76ac6526fc5debd6d9e1463cc9f2e2c997b" translate="yes" xml:space="preserve">
          <source>VxWorks only supports setting &lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt;&lt;code&gt;RLIMIT_NOFILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">VxWorks는 &lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt; &lt;code&gt;RLIMIT_NOFILE&lt;/code&gt; &lt;/a&gt; 설정 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="b3645a420f6c8c0399ea11997839dc3fbde6f0ad" translate="yes" xml:space="preserve">
          <source>Wait for child process to terminate. Set and return &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">자식 프로세스가 종료 될 때까지 기다립니다. 리턴 &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 속성을 설정하고 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee4b0606dd5fd109342b9b5b4880dd14615482ba" translate="yes" xml:space="preserve">
          <source>Wait for completion of a child process, and return a tuple containing its pid and exit status indication: a 16-bit number, whose low byte is the signal number that killed the process, and whose high byte is the exit status (if the signal number is zero); the high bit of the low byte is set if a core file was produced.</source>
          <target state="translated">하위 프로세스가 완료 될 때까지 기다렸다가 pid 및 exit 상태 표시를 포함하는 튜플을 리턴하십시오. 16 비트 숫자, 하위 바이트는 프로세스를 종료 한 신호 번호이고 상위 바이트는 종료 상태 (신호가있는 경우) 숫자는 0); 코어 파일이 생성 된 경우 하위 바이트의 상위 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6cf3a1c5971c4c21eec5eb16a888eb935b06df3a" translate="yes" xml:space="preserve">
          <source>Wait for events. timeout in seconds (float)</source>
          <target state="translated">이벤트를 기다리십시오. 초 단위의 시간 초과 (부동)</target>
        </trans-unit>
        <trans-unit id="cabdac1beb596d1e8239e59912c30fa91617e2d4" translate="yes" xml:space="preserve">
          <source>Wait for the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; instances (possibly created by different &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; instances) given by &lt;em&gt;fs&lt;/em&gt; to complete. Returns a named 2-tuple of sets. The first set, named &lt;code&gt;done&lt;/code&gt;, contains the futures that completed (finished or cancelled futures) before the wait completed. The second set, named &lt;code&gt;not_done&lt;/code&gt;, contains the futures that did not complete (pending or running futures).</source>
          <target state="translated">&lt;em&gt;fs&lt;/em&gt; 가 제공 한 &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 인스턴스 (다른 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 인스턴스에 의해 생성 될 수 있음 ) 가 완료 될 때까지 기다 립니다. 명명 된 2- 튜플 세트를 반환합니다. &lt;code&gt;done&lt;/code&gt; 이라는 첫 번째 세트 에는 대기가 완료되기 전에 완료된 (미완료 또는 취소 된 선물) 선물이 포함됩니다. &lt;code&gt;not_done&lt;/code&gt; 이라는 두 번째 세트 에는 완료되지 않은 선물 (미래 또는 보류중인 선물)이 포함됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29151336d8a123354d0b207654c1c2fac16dbab5" translate="yes" xml:space="preserve">
          <source>Wait for the &lt;em&gt;aw&lt;/em&gt;&lt;a href=&quot;#asyncio-awaitables&quot;&gt;awaitable&lt;/a&gt; to complete with a timeout.</source>
          <target state="translated">기다립니다 &lt;em&gt;아 &lt;/em&gt;&lt;a href=&quot;#asyncio-awaitables&quot;&gt;awaitable&lt;/a&gt; 타임 아웃 완료합니다.</target>
        </trans-unit>
        <trans-unit id="d5bfcef6a02be7849ca322a1b7fa63807a4361ed" translate="yes" xml:space="preserve">
          <source>Wait for the child process to terminate.</source>
          <target state="translated">하위 프로세스가 종료 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="fc57d83fd49bf3b1beb38bc11fe23ab63ce80444" translate="yes" xml:space="preserve">
          <source>Wait for the completion of one or more child processes. &lt;em&gt;idtype&lt;/em&gt; can be &lt;a href=&quot;#os.P_PID&quot;&gt;&lt;code&gt;P_PID&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.P_PGID&quot;&gt;&lt;code&gt;P_PGID&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.P_ALL&quot;&gt;&lt;code&gt;P_ALL&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;id&lt;/em&gt; specifies the pid to wait on. &lt;em&gt;options&lt;/em&gt; is constructed from the ORing of one or more of &lt;a href=&quot;#os.WEXITED&quot;&gt;&lt;code&gt;WEXITED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.WSTOPPED&quot;&gt;&lt;code&gt;WSTOPPED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WCONTINUED&quot;&gt;&lt;code&gt;WCONTINUED&lt;/code&gt;&lt;/a&gt; and additionally may be ORed with &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WNOWAIT&quot;&gt;&lt;code&gt;WNOWAIT&lt;/code&gt;&lt;/a&gt;. The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; is specified and there are no children in a waitable state.</source>
          <target state="translated">하나 이상의 자식 프로세스가 완료 될 때까지 기다립니다. &lt;em&gt;idtype&lt;/em&gt; 은 &lt;a href=&quot;#os.P_PID&quot;&gt; &lt;code&gt;P_PID&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.P_PGID&quot;&gt; &lt;code&gt;P_PGID&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.P_ALL&quot;&gt; &lt;code&gt;P_ALL&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 . &lt;em&gt;id&lt;/em&gt; 는 기다릴 pid를 지정합니다. &lt;em&gt;옵션&lt;/em&gt; 은 &lt;a href=&quot;#os.WEXITED&quot;&gt; &lt;code&gt;WEXITED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.WSTOPPED&quot;&gt; &lt;code&gt;WSTOPPED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.WCONTINUED&quot;&gt; &lt;code&gt;WCONTINUED&lt;/code&gt; &lt;/a&gt; 중 하나 이상의 ORing으로 구성되며 추가로 &lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.WNOWAIT&quot;&gt; &lt;code&gt;WNOWAIT&lt;/code&gt; &lt;/a&gt; 로 OR 될 수 있습니다 . 리턴 값은 포함 된 데이터 표현 목적 &lt;code&gt;siginfo_t&lt;/code&gt; : 즉 구조 &lt;code&gt;si_pid&lt;/code&gt; , &lt;code&gt;si_uid&lt;/code&gt; , &lt;code&gt;si_signo&lt;/code&gt; , &lt;code&gt;si_status&lt;/code&gt; , &lt;code&gt;si_code&lt;/code&gt; 을또는 &lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt; 이 지정되고 대기 가능한 상태의 하위가없는 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ec9481f9a89a7f37a291ebe888b480fa7b27740" translate="yes" xml:space="preserve">
          <source>Wait for the worker processes to exit. One must call &lt;a href=&quot;#multiprocessing.pool.Pool.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; before using &lt;a href=&quot;#multiprocessing.pool.Pool.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자 프로세스가 종료 될 때까지 기다리십시오. &lt;a href=&quot;#multiprocessing.pool.Pool.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 사용하기 전에 &lt;a href=&quot;#multiprocessing.pool.Pool.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="24c2968b108d264170fd51a0470c595df02b5436" translate="yes" xml:space="preserve">
          <source>Wait till an object in &lt;em&gt;object_list&lt;/em&gt; is ready. Returns the list of those objects in &lt;em&gt;object_list&lt;/em&gt; which are ready. If &lt;em&gt;timeout&lt;/em&gt; is a float then the call blocks for at most that many seconds. If &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; then it will block for an unlimited period. A negative timeout is equivalent to a zero timeout.</source>
          <target state="translated">&lt;em&gt;object_list&lt;/em&gt; 의 오브젝트 가 준비 될 때까지 기다리십시오 . &lt;em&gt;object_list&lt;/em&gt; 에서 준비된 오브젝트 목록을 리턴합니다 . 경우 &lt;em&gt;시간 제한은&lt;/em&gt; 부동는 대부분의 많은 초 동안 통화 블록이다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 그때는 무제한 기간 동안 차단합니다. 음의 타임 아웃은 타임 아웃 제로와 같습니다.</target>
        </trans-unit>
        <trans-unit id="70307f0b7918be1c3ba2811e4af742880bd148cb" translate="yes" xml:space="preserve">
          <source>Wait until a condition evaluates to true. &lt;em&gt;predicate&lt;/em&gt; should be a callable which result will be interpreted as a boolean value. A &lt;em&gt;timeout&lt;/em&gt; may be provided giving the maximum time to wait.</source>
          <target state="translated">조건이 true로 평가 될 때까지 기다리십시오. &lt;em&gt;술어&lt;/em&gt; 는 호출 가능해야하며 결과는 부울 값으로 해석됩니다. 최대 대기 시간을 제공 하는 &lt;em&gt;제한 시간&lt;/em&gt; 이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2cef329a9efde14e8d238168106e3ca5692ee07" translate="yes" xml:space="preserve">
          <source>Wait until a file descriptor received some data using the &lt;a href=&quot;#asyncio.loop.add_reader&quot;&gt;&lt;code&gt;loop.add_reader()&lt;/code&gt;&lt;/a&gt; method and then close the event loop:</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.add_reader&quot;&gt; &lt;code&gt;loop.add_reader()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 파일 디스크립터가 데이터를 수신 할 때까지 기다린 후 이벤트 루프를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="74ad20c64b497f2ca5ab845b7554279263b0f679" translate="yes" xml:space="preserve">
          <source>Wait until a predicate becomes &lt;em&gt;true&lt;/em&gt;.</source>
          <target state="translated">술어가 &lt;em&gt;true&lt;/em&gt; 가 될 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="a6ca18daf863b117483b5967387209392304958f" translate="yes" xml:space="preserve">
          <source>Wait until a socket receives data using the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt; method with a protocol:</source>
          <target state="translated">프로토콜과 함께 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 소켓이 데이터를 수신 할 때까지 기다 립니다 .</target>
        </trans-unit>
        <trans-unit id="07a9261621d8e68aedbd16e18722b9a67f39cec1" translate="yes" xml:space="preserve">
          <source>Wait until all output written to file descriptor &lt;em&gt;fd&lt;/em&gt; has been transmitted.</source>
          <target state="translated">파일 디스크립터 &lt;em&gt;fd에&lt;/em&gt; 기록 된 모든 출력 이 전송 될 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe11ac9dce22748ac5bc6e88601147ef1f88fb6" translate="yes" xml:space="preserve">
          <source>Wait until it is appropriate to resume writing to the stream. Example:</source>
          <target state="translated">스트림 쓰기를 다시 시작할 때까지 기다립니다. 예:</target>
        </trans-unit>
        <trans-unit id="b67b0cd8f0df8f71b4a7721db60c000c4a9aaff5" translate="yes" xml:space="preserve">
          <source>Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">통지 될 때까지 또는 시간 종료가 발생할 때까지 기다리십시오. 이 메소드가 호출 될 때 호출 스레드가 잠금을 획득하지 않은 경우 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0970419de06465ae0edf094213021ffbd86ca8c" translate="yes" xml:space="preserve">
          <source>Wait until notified.</source>
          <target state="translated">통지 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="ec9622e8f50c22884aacc0c6a6c6d1d859b01b43" translate="yes" xml:space="preserve">
          <source>Wait until some registered file objects become ready, or the timeout expires.</source>
          <target state="translated">등록 된 일부 파일 객체가 준비되거나 타임 아웃이 만료 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="c5ec2047d1b5f0f5a23a91d4267a89adebce9d94" translate="yes" xml:space="preserve">
          <source>Wait until the &lt;a href=&quot;#asyncio.Server.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method completes.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.Server.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 완료 될 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="fdc40d911794127c221170ea25e3065e9d790a27" translate="yes" xml:space="preserve">
          <source>Wait until the event is set.</source>
          <target state="translated">이벤트가 설정 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="29508508455305b1db6d27aa2e48c694fd3d730b" translate="yes" xml:space="preserve">
          <source>Wait until the result is available or until &lt;em&gt;timeout&lt;/em&gt; seconds pass.</source>
          <target state="translated">결과가 나올 때까지 또는 &lt;em&gt;시간 초과&lt;/em&gt; 초가 지날 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="056d3e2f705449186f7ac1299798e318e2219fbd" translate="yes" xml:space="preserve">
          <source>Wait until the sound device has played every byte in its buffer. (This happens implicitly when the device is closed.) The OSS documentation recommends closing and re-opening the device rather than using &lt;a href=&quot;#ossaudiodev.oss_audio_device.sync&quot;&gt;&lt;code&gt;sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사운드 장치가 버퍼의 모든 바이트를 재생할 때까지 기다리십시오. (이것은 장치가 닫힐 때 암시 적으로 발생합니다.) OSS 설명서는 &lt;a href=&quot;#ossaudiodev.oss_audio_device.sync&quot;&gt; &lt;code&gt;sync()&lt;/code&gt; &lt;/a&gt; 사용하는 대신 장치를 닫았다가 다시 열 것을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="ec111d4c42deb0f141e5bb12ebeed4601999588c" translate="yes" xml:space="preserve">
          <source>Wait until the stream is closed.</source>
          <target state="translated">스트림이 닫힐 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="eba24cad077b45f2680eff0bdf9fd0536486f778" translate="yes" xml:space="preserve">
          <source>Wait until the thread terminates. This blocks the calling thread until the thread whose &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method is called terminates &amp;ndash; either normally or through an unhandled exception &amp;ndash; or until the optional timeout occurs.</source>
          <target state="translated">스레드가 끝날 때까지 기다리십시오. 이것은 &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 스레드가 정상적으로 또는 처리되지 않은 예외를 통해 종료 될 때까지 또는 선택적 시간 종료가 발생할 때까지 호출 스레드를 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="08e6575bce34aa7e829066c628e1bbe5ee1d226d" translate="yes" xml:space="preserve">
          <source>Waiting Primitives</source>
          <target state="translated">대기 프리미티브</target>
        </trans-unit>
        <trans-unit id="f3bea4a4b6439483e8e78f429d91872ebd9c3c18" translate="yes" xml:space="preserve">
          <source>Wake only one epoll object when the associated fd has an event. The default (if this flag is not set) is to wake all epoll objects polling on a fd.</source>
          <target state="translated">연관된 fd에 이벤트가있을 때 하나의 epoll 오브젝트 만 깨우십시오. 디폴트 (이 플래그가 설정되지 않은 경우)는 fd에서 폴링하는 모든 epoll 오브젝트를 깨우는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a8cfa9cdcc5cfd14c9ca062c6bc6c63f61f28de" translate="yes" xml:space="preserve">
          <source>Wake up all tasks waiting on this condition.</source>
          <target state="translated">이 상태에서 대기중인 모든 작업을 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="93ae74426e9dc6545cb55c36b1af9d2f7460d6e8" translate="yes" xml:space="preserve">
          <source>Wake up all threads waiting on this condition. This method acts like &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt;, but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">이 상태에서 대기중인 모든 스레드를 깨 웁니다. 이 메소드는 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 처럼 작동 하지만 하나 대신에 대기중인 모든 스레드를 깨 웁니다. 이 메소드가 호출 될 때 호출 스레드가 잠금을 획득하지 않은 경우 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd4a765d51a4008bcc07316f2233df4d04edeb34" translate="yes" xml:space="preserve">
          <source>Wake up at most &lt;em&gt;n&lt;/em&gt; tasks (1 by default) waiting on this condition. The method is no-op if no tasks are waiting.</source>
          <target state="translated">이 상태에서 대기하는 최대 &lt;em&gt;n 개의&lt;/em&gt; 작업 (기본적으로 1 개)을 깨 웁니다 . 대기중인 작업이 없으면이 방법은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf340b925958411b04f22ec98ee18783d9a1e220" translate="yes" xml:space="preserve">
          <source>Walk a stack following &lt;code&gt;f.f_back&lt;/code&gt; from the given frame, yielding the frame and line number for each frame. If &lt;em&gt;f&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the current stack is used. This helper is used with &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt;&lt;code&gt;StackSummary.extract()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 프레임에서 &lt;code&gt;f.f_back&lt;/code&gt; 뒤에 스택을 걸어 각 프레임의 프레임과 라인 번호를 산출합니다. 하면 &lt;em&gt;F가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 현재 스택이 사용된다. 이 도우미는 &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt; &lt;code&gt;StackSummary.extract()&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a27a446a60fb72e15035278b0c8eb08c42135e9" translate="yes" xml:space="preserve">
          <source>Walk a traceback following &lt;code&gt;tb_next&lt;/code&gt; yielding the frame and line number for each frame. This helper is used with &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt;&lt;code&gt;StackSummary.extract()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tb_next&lt;/code&gt; 다음에 역 추적을 걸어 각 프레임의 프레임과 라인 번호를 산출하십시오. 이 도우미는 &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt; &lt;code&gt;StackSummary.extract()&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="f0b8c638923d24a321f5c6972c05277cf144fb7b" translate="yes" xml:space="preserve">
          <source>Warning Categories</source>
          <target state="translated">경고 카테고리</target>
        </trans-unit>
        <trans-unit id="4b2c3cc9b73eb686d163d3880f8c1912f8b96956" translate="yes" xml:space="preserve">
          <source>Warning categories that are primarily of interest to Python developers (rather than end users of applications written in Python) are ignored by default.</source>
          <target state="translated">Python으로 작성된 응용 프로그램의 최종 사용자가 아닌 Python 개발자가 주로 관심을 갖는 경고 범주는 기본적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="847345091f804153cb593f84ad497f73b760d180" translate="yes" xml:space="preserve">
          <source>Warning messages are normally written to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;, but their disposition can be changed flexibly, from ignoring all warnings to turning them into exceptions. The disposition of warnings can vary based on the &lt;a href=&quot;#warning-categories&quot;&gt;warning category&lt;/a&gt;, the text of the warning message, and the source location where it is issued. Repetitions of a particular warning for the same source location are typically suppressed.</source>
          <target state="translated">경고 메시지는 일반적으로 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 에&lt;/a&gt; 작성 되지만 모든 경고를 무시하는 것에서 예외로 변경하는 것에 이르기까지 배치를 유연하게 변경할 수 있습니다. 경고 처리는 경고 &lt;a href=&quot;#warning-categories&quot;&gt;범주&lt;/a&gt; , 경고 메시지의 텍스트 및 경고가 발생한 원본 위치 에 따라 달라질 수 있습니다 . 동일한 소스 위치에 대한 특정 경고의 반복은 일반적으로 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="6fa8d6a7b1b2b2ba758f00991e78c8631d91fa69" translate="yes" xml:space="preserve">
          <source>Warning messages are typically issued in situations where it is useful to alert the user of some condition in a program, where that condition (normally) doesn&amp;rsquo;t warrant raising an exception and terminating the program. For example, one might want to issue a warning when a program uses an obsolete module.</source>
          <target state="translated">경고 메시지는 일반적으로 프로그램에서 사용자에게 특정 조건에 대해 경고하는 것이 유용한 상황 (일반적으로)에서 예외 발생 및 프로그램 종료를 보증하지 않는 상황에서 발행됩니다. 예를 들어, 프로그램이 더 이상 사용되지 않는 모듈을 사용할 때 경고를 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="09505683c6b5bf3932806860c33becb79c315a18" translate="yes" xml:space="preserve">
          <source>Watch a file descriptor for read events</source>
          <target state="translated">읽기 이벤트에 대한 파일 디스크립터 시청</target>
        </trans-unit>
        <trans-unit id="56bdf1df2d6de2dce3cb70cc7a1d445ff547ab4f" translate="yes" xml:space="preserve">
          <source>Watch for events on a network device [not available on Mac OS X]</source>
          <target state="translated">네트워크 장비에서 이벤트를 확인하십시오 (Mac OS X에서는 사용할 수 없음)</target>
        </trans-unit>
        <trans-unit id="a77a9f44b3dc9612388cdc66f0973471511ca754" translate="yes" xml:space="preserve">
          <source>Watch for events on a process id</source>
          <target state="translated">프로세스 ID에서 이벤트를 감시하십시오</target>
        </trans-unit>
        <trans-unit id="7b8d444f092659996944c98103896607bf61afda" translate="yes" xml:space="preserve">
          <source>WatchedFileHandler</source>
          <target state="translated">WatchedFileHandler</target>
        </trans-unit>
        <trans-unit id="6c952491e9149238af6d5009db8cdd488e66dcb2" translate="yes" xml:space="preserve">
          <source>Watching file descriptors</source>
          <target state="translated">파일 디스크립터 관찰</target>
        </trans-unit>
        <trans-unit id="853f81f21983a508519fe18408fdef4381a53c85" translate="yes" xml:space="preserve">
          <source>Wave_read Objects</source>
          <target state="translated">Wave_read 객체</target>
        </trans-unit>
        <trans-unit id="40b33acc387d819933f3a4e356b1224932bc5fe4" translate="yes" xml:space="preserve">
          <source>Wave_read objects, as returned by &lt;a href=&quot;#wave.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#wave.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 Wave_read 객체 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e5965f88e6bbc53b5aa0194a15009dfa785bfa" translate="yes" xml:space="preserve">
          <source>Wave_write Objects</source>
          <target state="translated">Wave_write 객체</target>
        </trans-unit>
        <trans-unit id="b2438cc47ac4cf690f00fb0bcb5a03c6f4fd235a" translate="yes" xml:space="preserve">
          <source>Wave_write objects, as returned by &lt;a href=&quot;#wave.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#wave.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 Wave_write 객체 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1d2fa5af87cd6de5bce19db6524cc1d529a3d0" translate="yes" xml:space="preserve">
          <source>Ways to reference it</source>
          <target state="translated">그것을 참조하는 방법</target>
        </trans-unit>
        <trans-unit id="d85190bf88b389c7893fdc3f90cf47dcd9cbeca0" translate="yes" xml:space="preserve">
          <source>We can import this data by reading from a file:</source>
          <target state="translated">파일을 읽어서이 데이터를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b789995e580ea25048a2285a5926e24768d9cf2" translate="yes" xml:space="preserve">
          <source>We can remove elements using &lt;a href=&quot;#xml.etree.ElementTree.Element.remove&quot;&gt;&lt;code&gt;Element.remove()&lt;/code&gt;&lt;/a&gt;. Let&amp;rsquo;s say we want to remove all countries with a rank higher than 50:</source>
          <target state="translated">&lt;a href=&quot;#xml.etree.ElementTree.Element.remove&quot;&gt; &lt;code&gt;Element.remove()&lt;/code&gt; &lt;/a&gt; 사용하여 요소를 제거 할 수 있습니다 . 순위가 50보다 높은 모든 국가를 제거하려고한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="215e314610fefea13b5da68c465496bf961d967a" translate="yes" xml:space="preserve">
          <source>We can see that Python has loaded &lt;code&gt;8173 KiB&lt;/code&gt; of module data (bytecode and constants), and that this is &lt;code&gt;4428 KiB&lt;/code&gt; more than had been loaded before the tests, when the previous snapshot was taken. Similarly, the &lt;a href=&quot;linecache#module-linecache&quot;&gt;&lt;code&gt;linecache&lt;/code&gt;&lt;/a&gt; module has cached &lt;code&gt;940 KiB&lt;/code&gt; of Python source code to format tracebacks, all of it since the previous snapshot.</source>
          <target state="translated">우리는 파이썬이 &lt;code&gt;8173 KiB&lt;/code&gt; 의 모듈 데이터 (바이트 코드와 상수)를 로드했으며, 이전 스냅 샷을 만들 때 테스트 이전에로드 된 것보다 &lt;code&gt;4428 KiB&lt;/code&gt; 더 많은 것을 알 수 있습니다. 마찬가지로 &lt;a href=&quot;linecache#module-linecache&quot;&gt; &lt;code&gt;linecache&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;code&gt;940 KiB&lt;/code&gt; 의 Python 소스 코드를 캐시 하여 이전 스냅 샷 이후의 모든 역 추적 형식을 추적했습니다.</target>
        </trans-unit>
        <trans-unit id="a3cfb793dfee5070acdfd0a536b9c921adeb6f59" translate="yes" xml:space="preserve">
          <source>We can see that Python loaded &lt;code&gt;4855 KiB&lt;/code&gt; data (bytecode and constants) from modules and that the &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module allocated &lt;code&gt;244 KiB&lt;/code&gt; to build &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">파이썬이 모듈에서 &lt;code&gt;4855 KiB&lt;/code&gt; 데이터 (바이트 코드 및 상수)를 로드 했으며 &lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈이 &lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple&lt;/code&gt; &lt;/a&gt; 유형 을 빌드하기 위해 &lt;code&gt;244 KiB&lt;/code&gt; 를 할당 했음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b16f5f4ffc8f56cb2bb30fa071edafeee046554" translate="yes" xml:space="preserve">
          <source>We can see that the most memory was allocated in the &lt;a href=&quot;importlib#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; module to load data (bytecode and constants) from modules: &lt;code&gt;870.1 KiB&lt;/code&gt;. The traceback is where the &lt;a href=&quot;importlib#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; loaded data most recently: on the &lt;code&gt;import pdb&lt;/code&gt; line of the &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; module. The traceback may change if a new module is loaded.</source>
          <target state="translated">&lt;a href=&quot;importlib#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 모듈 에 가장 많은 메모리가 할당되어 모듈 ( &lt;code&gt;870.1 KiB&lt;/code&gt; )에서 데이터 (바이트 코드 및 상수)를로드 했음을 알 수 있습니다. 역 추적은 &lt;a href=&quot;importlib#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 가 가장 최근에 데이터를로드 한 위치 입니다 ( &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;code&gt;import pdb&lt;/code&gt; 행) . 새 모듈이로드되면 트레이스 백이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41498dcbefc1d323bf74e1d9ce5b53a4cc360514" translate="yes" xml:space="preserve">
          <source>We have defined the &lt;code&gt;struct _frozen&lt;/code&gt; data type, so we can get the pointer to the table:</source>
          <target state="translated">&lt;code&gt;struct _frozen&lt;/code&gt; 데이터 형식 을 정의 했으므로 테이블에 대한 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cfcb5b8900d48c6735c6871c6773651f8b0c087" translate="yes" xml:space="preserve">
          <source>We might try to implement the class using a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; method as follows:</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 클래스를 구현하려고 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31f330039a177b6f4ba692d81baa88bba27b8da4" translate="yes" xml:space="preserve">
          <source>We recommend that all application designers seriously consider doing this; we have seen many protocols where a hash that is computed in one part of the protocol can be used in an entirely different part because two hash computations were done on similar or related data, and the attacker can force the application to make the hash inputs the same. Personalizing each hash function used in the protocol summarily stops this type of attack.</source>
          <target state="translated">모든 응용 프로그램 디자이너는이 작업을 진지하게 고려할 것을 권장합니다. 우리는 프로토콜의 한 부분에서 계산 된 해시가 유사하거나 관련된 데이터에 대해 두 개의 해시 계산이 수행 되었기 때문에 완전히 다른 부분에서 사용될 수있는 많은 프로토콜을 보았으며, 공격자는 응용 프로그램이 해시 입력을하도록 강제 할 수 있습니다. 같은. 프로토콜에 사용 된 각 해시 함수를 개인화하면 이러한 유형의 공격이 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="366243de9e8dd818c63915fa0eb00c27eb54fd4e" translate="yes" xml:space="preserve">
          <source>We say that an object is an &lt;strong&gt;awaitable&lt;/strong&gt; object if it can be used in an &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; expression. Many asyncio APIs are designed to accept awaitables.</source>
          <target state="translated">우리는 객체가 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 표현식 에서 사용될 수 있다면 &lt;strong&gt;awaitable&lt;/strong&gt; 객체 라고 말합니다 . 많은 asyncio API는 대기 가능 항목을 허용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="57b5ab6e43e7e9a6b2ac86fe4eb61e522b2004b3" translate="yes" xml:space="preserve">
          <source>We want to implement the arithmetic operations so that mixed-mode operations either call an implementation whose author knew about the types of both arguments, or convert both to the nearest built in type and do the operation there. For subtypes of &lt;a href=&quot;#numbers.Integral&quot;&gt;&lt;code&gt;Integral&lt;/code&gt;&lt;/a&gt;, this means that &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; should be defined as:</source>
          <target state="translated">혼합 모드 연산이 저자가 두 인수의 유형에 대해 알고있는 구현을 호출하거나 가장 가까운 내장 유형으로 변환하여 연산을 수행하도록 산술 연산을 구현하려고합니다. &lt;a href=&quot;#numbers.Integral&quot;&gt; &lt;code&gt;Integral&lt;/code&gt; &lt;/a&gt; 하위 유형의 경우 이는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 가 다음과 같이 정의되어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d8571598e317c5f7d8abde12db88f57270cea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be using the following XML document as the sample data for this section:</source>
          <target state="translated">이 섹션의 샘플 데이터로 다음 XML 문서를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="498251e1ee5e102841353e28c1ae8f3a3c95d0ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re given a training dataset with measurements for eight people. The measurements are assumed to be normally distributed, so we summarize the data with &lt;a href=&quot;#statistics.NormalDist&quot;&gt;&lt;code&gt;NormalDist&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">우리는 8 명을 측정 한 훈련 데이터 세트를 받았습니다. 측정 값은 정규 분포로 가정되므로 &lt;a href=&quot;#statistics.NormalDist&quot;&gt; &lt;code&gt;NormalDist&lt;/code&gt; 로&lt;/a&gt; 데이터를 요약합니다 .</target>
        </trans-unit>
        <trans-unit id="53fa691162f39e16d25e99147762bfdb99f7853f" translate="yes" xml:space="preserve">
          <source>Weak Reference Objects</source>
          <target state="translated">약한 참조 객체</target>
        </trans-unit>
        <trans-unit id="5ee5214a04390535aa3407199b4313f1342ce933" translate="yes" xml:space="preserve">
          <source>Weak reference objects have no methods and no attributes besides &lt;a href=&quot;#weakref.ref.__callback__&quot;&gt;&lt;code&gt;ref.__callback__&lt;/code&gt;&lt;/a&gt;. A weak reference object allows the referent to be obtained, if it still exists, by calling it:</source>
          <target state="translated">약한 참조 객체에는 &lt;a href=&quot;#weakref.ref.__callback__&quot;&gt; &lt;code&gt;ref.__callback__&lt;/code&gt; &lt;/a&gt; 외에 메소드와 속성이 없습니다 . 약한 참조 객체는 참조가 존재한다면 참조를 호출하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="269b06c67f58c7694dc71ae7f0afae036d4818c7" translate="yes" xml:space="preserve">
          <source>Weak references are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; if the &lt;em&gt;object&lt;/em&gt; is hashable. They will maintain their hash value even after the &lt;em&gt;object&lt;/em&gt; was deleted. If &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; is called the first time only after the &lt;em&gt;object&lt;/em&gt; was deleted, the call will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;객체&lt;/em&gt; 가 해시 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;가능한&lt;/a&gt; 경우 약한 참조는 해시 가능합니다 . &lt;em&gt;객체&lt;/em&gt; 가 삭제 된 후에도 해시 값을 유지합니다 . 경우 &lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt; 유일한 후 처음이라고 &lt;em&gt;객체가&lt;/em&gt; 삭제 된 통화가 올릴 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf5772b94a870ac2c2a272ce1b65b3d3ec5cdd0a" translate="yes" xml:space="preserve">
          <source>Weak references support tests for equality, but not ordering. If the referents are still alive, two references have the same equality relationship as their referents (regardless of the &lt;em&gt;callback&lt;/em&gt;). If either referent has been deleted, the references are equal only if the reference objects are the same object.</source>
          <target state="translated">약한 참조는 평등에 대한 테스트를 지원하지만 순서는 지원하지 않습니다. 참조가 여전히 살아있는 경우 두 참조는 ( &lt;em&gt;콜백에&lt;/em&gt; 관계없이) 참조와 동일한 동등 관계를 갖습니다 . 참조가 삭제 된 경우 참조 개체가 동일한 개체 인 경우에만 참조가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="160d43660c7e93a34cbf9e6d0683b3f1d070e0fc" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc2518.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2518&lt;/strong&gt;&lt;/a&gt;, Section 10.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc2518.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2518&lt;/strong&gt;&lt;/a&gt; , 섹션 10.1</target>
        </trans-unit>
        <trans-unit id="4a73d3d2fe230642eaf557fd34c51c84ef4ff1ba" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.1</target>
        </trans-unit>
        <trans-unit id="74f89d6c2e38467f5b13ae0091d9a8a51c1b16e1" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-41&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.2</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-41&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.2</target>
        </trans-unit>
        <trans-unit id="a2bff95c1e44c73456e7cae10cda54d6fa398f6f" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-42&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.3</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-42&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.3</target>
        </trans-unit>
        <trans-unit id="fd468def379a57145ba45b0607d05b11370a29a3" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.4</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.4</target>
        </trans-unit>
        <trans-unit id="98acc379abdeda29844b5028a71fa64b09754bd1" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-56&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.5</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-56&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.5</target>
        </trans-unit>
        <trans-unit id="98047a8d0918ebb9d2a9d3244b26fc929a5bcb7c" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.1 (Experimental)</source>
          <target state="translated">WebDAV 바인딩 확장 &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt; , 섹션 7.1 (실험적)</target>
        </trans-unit>
        <trans-unit id="2525087157bd91fd05837fb713cd7d80f247559d" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-57&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.2 (Experimental)</source>
          <target state="translated">WebDAV 바인딩 확장 &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-57&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt; , 섹션 7.2 (실험적)</target>
        </trans-unit>
        <trans-unit id="efaa49e0aaddcee60c9e56544c7c0972d0e98dcb" translate="yes" xml:space="preserve">
          <source>WebP files</source>
          <target state="translated">WebP 파일</target>
        </trans-unit>
        <trans-unit id="fe3f61ddecbabd9df7b81c596b0e344f7a9a1ef0" translate="yes" xml:space="preserve">
          <source>Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (월요일의 첫 번째 요일)를 10 진수로 표시합니다 [00,53]. 첫 번째 월요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="957344126e376dfec66a5865493968e5033a759d" translate="yes" xml:space="preserve">
          <source>Week number of the year (Monday as the first day of the week) as a decimal number. All days in a new year preceding the first Monday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (월요일의 첫 번째 요일)를 10 진수로 나타냅니다. 첫 번째 월요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3aadb81eb1a1699671247b51c01b0cc44432b8bb" translate="yes" xml:space="preserve">
          <source>Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (일요일의 첫 번째 요일)를 10 진수로 표시합니다 [00,53]. 첫 번째 일요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f93371df01a8682d904d17bbc9258abc77e066be" translate="yes" xml:space="preserve">
          <source>Week number of the year (Sunday as the first day of the week) as a zero padded decimal number. All days in a new year preceding the first Sunday are considered to be in week 0.</source>
          <target state="translated">0으로 채워진 10 진수로 표시되는 연중 주 번호 (일요일의 첫 번째 요일)입니다. 첫 번째 일요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="027417f7bd7fb85e6bdc77ed8d873c5e62146b37" translate="yes" xml:space="preserve">
          <source>Weekday (0=Monday)</source>
          <target state="translated">평일 (0 = 월요일)</target>
        </trans-unit>
        <trans-unit id="da94621ef8999a8ac972599f062234bc846d53f9" translate="yes" xml:space="preserve">
          <source>Weekday as a decimal number [0(Sunday),6].</source>
          <target state="translated">평일을 10 진수로 표시 [0 (일요일), 6].</target>
        </trans-unit>
        <trans-unit id="149ccb2de453647267122d8a96dda7b0ae559978" translate="yes" xml:space="preserve">
          <source>Weekday as a decimal number, where 0 is Sunday and 6 is Saturday.</source>
          <target state="translated">평일을 10 진수로 표시합니다. 여기서 0은 일요일이고 6은 토요일입니다.</target>
        </trans-unit>
        <trans-unit id="bb0fc2dc3a75233397a7a28f15f9662ee67c106e" translate="yes" xml:space="preserve">
          <source>Weekday as locale&amp;rsquo;s abbreviated name.</source>
          <target state="translated">로케일의 약칭으로 평일.</target>
        </trans-unit>
        <trans-unit id="bb1e28b07531c9368250cf22e73ebdac9375108f" translate="yes" xml:space="preserve">
          <source>Weekday as locale&amp;rsquo;s full name.</source>
          <target state="translated">로케일의 전체 이름으로 평일.</target>
        </trans-unit>
        <trans-unit id="f6103eca7ab314d7e7cfd58095933632e58c72c4" translate="yes" xml:space="preserve">
          <source>Weibull distribution. &lt;em&gt;alpha&lt;/em&gt; is the scale parameter and &lt;em&gt;beta&lt;/em&gt; is the shape parameter.</source>
          <target state="translated">와 이블 분포. &lt;em&gt;alpha&lt;/em&gt; 는 scale 매개 변수이고 &lt;em&gt;beta&lt;/em&gt; 는 shape 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c74e5c5d315ff3f823c6f47d8fb4fc7d0c8fe3e0" translate="yes" xml:space="preserve">
          <source>Western Europe</source>
          <target state="translated">서유럽</target>
        </trans-unit>
        <trans-unit id="ed6c63b0557e98944ebbf0299cfb303283e1e58e" translate="yes" xml:space="preserve">
          <source>What About Exceptions?</source>
          <target state="translated">예외는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="6ee52e14b570b091324e858324b60dbe6df01e5a" translate="yes" xml:space="preserve">
          <source>What Is Deterministic Profiling?</source>
          <target state="translated">결정 론적 프로파일 링이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e5ac2d9156eb23a3dbdb1999476310a8ac6727e3" translate="yes" xml:space="preserve">
          <source>What can be pickled and unpickled?</source>
          <target state="translated">피클과 피클 링 할 수있는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fcf1ade96b2641b7f1c03643a78aaf7e4461cb47" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;[[]]&lt;/code&gt; is a one-element list containing an empty list, so all three elements of &lt;code&gt;[[]] * 3&lt;/code&gt; are references to this single empty list. Modifying any of the elements of &lt;code&gt;lists&lt;/code&gt; modifies this single list. You can create a list of different lists this way:</source>
          <target state="translated">일어났던 것은 즉 &lt;code&gt;[[]]&lt;/code&gt; 모든 세 요소 있도록 빈 목록을 포함하는 하나의 요소 목록 &lt;code&gt;[[]] * 3&lt;/code&gt; 이 하나의 빈 목록을 참조한다. &lt;code&gt;lists&lt;/code&gt; 요소를 수정하면이 단일 목록이 수정됩니다. 이 방법으로 다른 목록의 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea4146566e7e0cd8f5a8d4c34d120c18c585cf1" translate="yes" xml:space="preserve">
          <source>What the &lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt;&lt;code&gt;parseString()&lt;/code&gt;&lt;/a&gt; functions do is connect an XML parser with a &amp;ldquo;DOM builder&amp;rdquo; that can accept parse events from any SAX parser and convert them into a DOM tree. The name of the functions are perhaps misleading, but are easy to grasp when learning the interfaces. The parsing of the document will be completed before these functions return; it&amp;rsquo;s simply that these functions do not provide a parser implementation themselves.</source>
          <target state="translated">무엇 &lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt; &lt;code&gt;parseString()&lt;/code&gt; &lt;/a&gt; 함수가하는 일은 어떤 SAX 파서에서 구문 분석 이벤트를 받아 DOM 트리로 변환 할 수있는 &quot;DOM 빌더&quot;와 XML 파서를 연결합니다. 함수의 이름은 오해의 소지가 있지만 인터페이스를 배울 때 이해하기 쉽습니다. 이러한 함수가 반환되기 전에 문서 파싱이 완료됩니다. 단순히 이러한 함수가 파서 구현 자체를 제공하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3c2e61a8fe0f76312d3b9af5434565ee7de2ec5" translate="yes" xml:space="preserve">
          <source>What the new Enum class will record as its name.</source>
          <target state="translated">새 Enum 클래스 이름으로 기록 할 내용</target>
        </trans-unit>
        <trans-unit id="0711f3c581dc5072b2cf9e260f7e705f68754df8" translate="yes" xml:space="preserve">
          <source>What this means in practice is that to support finding distribution package metadata in locations other than the file system, subclass &lt;code&gt;Distribution&lt;/code&gt; and implement the abstract methods. Then from a custom finder, return instances of this derived &lt;code&gt;Distribution&lt;/code&gt; in the &lt;code&gt;find_distributions()&lt;/code&gt; method.</source>
          <target state="translated">이것이 실제로 의미하는 것은 파일 시스템, 서브 클래스 &lt;code&gt;Distribution&lt;/code&gt; 이외의 위치에서 배포 패키지 메타 데이터 찾기를 지원 하고 추상 메서드를 구현한다는 것입니다. 그런 다음 사용자 정의 파인더 에서 &lt;code&gt;find_distributions()&lt;/code&gt; 메소드 에서이 파생 된 &lt;code&gt;Distribution&lt;/code&gt; 의 인스턴스를 리턴 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5390d096f592c9ee00a6e75cd2a40d199772255f" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the Execution Context?</source>
          <target state="translated">실행 컨텍스트는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="86d433886770959c5f8b1c7316fb956a27baddc4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#abc.abstractmethod&quot;&gt;&lt;code&gt;abstractmethod()&lt;/code&gt;&lt;/a&gt; is applied in combination with other method descriptors, it should be applied as the innermost decorator, as shown in the following usage examples:</source>
          <target state="translated">경우 &lt;a href=&quot;#abc.abstractmethod&quot;&gt; &lt;code&gt;abstractmethod()&lt;/code&gt; &lt;/a&gt; 다른 방법 디스크립터와 함께 적용되는 다음의 예문에 도시 된 바와 같이, 또, 최 데코으로 적용되어야한다 :</target>
        </trans-unit>
        <trans-unit id="7f660ad4252bf5d8a48ac42ba8b9a8060d0a917e" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; generates help messages, it needs some way to refer to each expected argument. By default, ArgumentParser objects use the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value as the &amp;ldquo;name&amp;rdquo; of each object. By default, for positional argument actions, the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value is used directly, and for optional argument actions, the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value is uppercased. So, a single positional argument with &lt;code&gt;dest='bar'&lt;/code&gt; will be referred to as &lt;code&gt;bar&lt;/code&gt;. A single optional argument &lt;code&gt;--foo&lt;/code&gt; that should be followed by a single command-line argument will be referred to as &lt;code&gt;FOO&lt;/code&gt;. An example:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 가 도움말 메시지를 생성 할 때 예상되는 각 인수를 참조 할 방법이 필요합니다. 기본적으로 ArgumentParser 객체는 &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; 값을 각 객체의 &quot;이름&quot;으로 사용합니다. 기본적으로 위치 인수 조치의 경우 &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; 값이 직접 사용되며 선택적 인수 조치의 경우 &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; 값이 대문자입니다. 따라서 &lt;code&gt;dest='bar'&lt;/code&gt; 인 단일 위치 인수는 bar 라고 &lt;code&gt;bar&lt;/code&gt; . 단일 명령 행 인수 뒤에 와야 하는 단일 선택적 인수 &lt;code&gt;--foo&lt;/code&gt; 는 &lt;code&gt;FOO&lt;/code&gt; 라고합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="bbb7e98f193941e94a08737449c4a58a55c161fa" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is called with &lt;code&gt;action='store_const'&lt;/code&gt; or &lt;code&gt;action='append_const'&lt;/code&gt;. These actions add the &lt;code&gt;const&lt;/code&gt; value to one of the attributes of the object returned by &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;#action&quot;&gt;action&lt;/a&gt; description for examples.</source>
          <target state="translated">때 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 호출되는 &lt;code&gt;action='store_const'&lt;/code&gt; 또는 &lt;code&gt;action='append_const'&lt;/code&gt; . 이러한 액션은 &lt;code&gt;const&lt;/code&gt; 값을 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 반환 한 객체의 속성 중 하나에 추가합니다 . 예제 는 &lt;a href=&quot;#action&quot;&gt;조치&lt;/a&gt; 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="908430b67ffab7192c58d413878590107f99ac8a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is called with option strings (like &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--foo&lt;/code&gt;) and &lt;code&gt;nargs='?'&lt;/code&gt;. This creates an optional argument that can be followed by zero or one command-line arguments. When parsing the command line, if the option string is encountered with no command-line argument following it, the value of &lt;code&gt;const&lt;/code&gt; will be assumed instead. See the &lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt; description for examples.</source>
          <target state="translated">때 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 옵션 (같은 문자열이라고 &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--foo&lt;/code&gt; )와 &lt;code&gt;nargs='?'&lt;/code&gt; . 이렇게하면 0 개 또는 1 개의 명령 줄 인수가 올 수있는 선택적 인수가 만들어집니다. 명령 행을 구문 분석 할 때 옵션 문자열에 명령 행 인수가 없으면 &lt;code&gt;const&lt;/code&gt; 값이 대신 가정됩니다. 예제 는 &lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt; 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02441c1f960fb0baf4239fae2d2c88d890e1b2fc" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; is called, optional arguments will be identified by the &lt;code&gt;-&lt;/code&gt; prefix, and the remaining arguments will be assumed to be positional:</source>
          <target state="translated">때 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 호출, 선택적 인수는에 의해 식별됩니다 &lt;code&gt;-&lt;/code&gt; 접두사, 나머지 인수는 위치로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="629de685613646d00ea10bd953237cc1c7924121" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; is available then backwards-compatible functionality is provided.</source>
          <target state="translated">때 &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;exec_module()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 다음, 이전 버전과 호환 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d39c6fdaaf5a388a75f42af12f2c38b99a2423" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#importlib.reload&quot;&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/a&gt; is executed:</source>
          <target state="translated">&lt;a href=&quot;#importlib.reload&quot;&gt; &lt;code&gt;reload()&lt;/code&gt; &lt;/a&gt; 가 실행될 때 :</target>
        </trans-unit>
        <trans-unit id="fd23a56d325ff0bf7a6e61d85cd4f34a2147f5d5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; is initialized the main process is assigned a random string using &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 초기화되는 주요 프로세스를 사용하여 임의의 문자열을 할당 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11aa0c7fff9e9b567a187a2e5b13f5a8d5be7181" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; is supported, assignments to items in &lt;code&gt;os.environ&lt;/code&gt; are automatically translated into corresponding calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt;; however, calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; don&amp;rsquo;t update &lt;code&gt;os.environ&lt;/code&gt;, so it is actually preferable to assign to items of &lt;code&gt;os.environ&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 지원되며 항목에 할당 &lt;code&gt;os.environ&lt;/code&gt; 은 자동으로 호출 해당로 번역 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; ; 그러나, 호출 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 업데이트되지 않습니다 &lt;code&gt;os.environ&lt;/code&gt; 그것의 항목에 할당하는 것이 실제로 바람직하므로, &lt;code&gt;os.environ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c01e42f0e3d04cc243dd7a57f8e10baf4c6db3b1" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt;&lt;code&gt;st_file_attributes&lt;/code&gt;&lt;/a&gt; has the &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; set, this field contains the tag identifying the type of reparse point. See the &lt;code&gt;IO_REPARSE_TAG_*&lt;/code&gt; constants in the &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">경우 &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt; &lt;code&gt;st_file_attributes&lt;/code&gt; 가&lt;/a&gt; 갖는다 &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; 의 집합,이 필드는 재분석 포인트의 종류를 식별하는 태그를 포함한다. &lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;code&gt;IO_REPARSE_TAG_*&lt;/code&gt; 상수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf790e480175785930a548355dd8f5086f5c9b7a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; is supported, deletion of items in &lt;code&gt;os.environ&lt;/code&gt; is automatically translated into a corresponding call to &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt;; however, calls to &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; don&amp;rsquo;t update &lt;code&gt;os.environ&lt;/code&gt;, so it is actually preferable to delete items of &lt;code&gt;os.environ&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 지지되어있는 항목의 삭제 &lt;code&gt;os.environ&lt;/code&gt; 가 자동으로 해당 통화로 번역 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; ; 그러나, 호출 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 업데이트되지 않습니다 &lt;code&gt;os.environ&lt;/code&gt; 가의 항목을 삭제 실제로 바람직하므로, &lt;code&gt;os.environ&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e962e2ecd1be54236efb9b9cd0dcb1c0a6890061" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; detects a source request (see &lt;a href=&quot;#shlex.shlex.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; below) this method is given the following token as argument, and expected to return a tuple consisting of a filename and an open file-like object.</source>
          <target state="translated">경우 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; 은&lt;/a&gt; 원본 요청을 검출한다 (참조 &lt;a href=&quot;#shlex.shlex.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; 이 방법은, 인수로서 주어진 다음 토큰 및 파일명으로 이루어지는 튜플과 같은 오픈 파일 객체를 반환 할 것으로 예상된다 아래 참조).</target>
        </trans-unit>
        <trans-unit id="003413e572cb08fc012d56140cf949b7ac4b28b8" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ssl.SSLContext.keylog_filename&quot;&gt;&lt;code&gt;keylog_filename&lt;/code&gt;&lt;/a&gt; is supported and the environment variable &lt;code id=&quot;index-2&quot;&gt;SSLKEYLOGFILE&lt;/code&gt; is set, &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; enables key logging.</source>
          <target state="translated">경우 &lt;a href=&quot;#ssl.SSLContext.keylog_filename&quot;&gt; &lt;code&gt;keylog_filename&lt;/code&gt; 가&lt;/a&gt; 지지되고 환경 변수 &lt;code id=&quot;index-2&quot;&gt;SSLKEYLOGFILE&lt;/code&gt; 가 설정되어 &lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 키 로깅 할 수있다.</target>
        </trans-unit>
        <trans-unit id="ae592f12245b7b672b2b312ad6a41430e2206fbb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is creating a mock for you, it is common that the first thing you need to do is to configure the mock. Some of that configuration can be done in the call to patch. Any arbitrary keywords you pass into the call will be used to set attributes on the created mock:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 가 모의 객체를 만들 때 가장 먼저해야 할 일은 모의 객체를 구성하는 것입니다. 해당 구성 중 일부는 패치 호출에서 수행 할 수 있습니다. 호출에 전달한 임의의 키워드는 생성 된 모의 속성을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="984f54d038232b41fa8fb278710d0228edce2b46" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, whitespace immediately following the &lt;em&gt;delimiter&lt;/em&gt; is ignored. The default is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 바로 다음 공백, &lt;em&gt;구분 기호는&lt;/em&gt; 무시됩니다. 기본값은 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fbc90776622a0bcb40ca2bd0c844997d03d08a5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;COLUMNS&lt;/code&gt; or &lt;code&gt;LINES&lt;/code&gt; is not defined, which is the common case, the terminal connected to &lt;a href=&quot;sys#sys.__stdout__&quot;&gt;&lt;code&gt;sys.__stdout__&lt;/code&gt;&lt;/a&gt; is queried by invoking &lt;a href=&quot;os#os.get_terminal_size&quot;&gt;&lt;code&gt;os.get_terminal_size()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;COLUMNS&lt;/code&gt; 또는 &lt;code&gt;LINES&lt;/code&gt; 정의되지 않고, 일반적인 경우, 접속 단자에 이는 &lt;a href=&quot;sys#sys.__stdout__&quot;&gt; &lt;code&gt;sys.__stdout__&lt;/code&gt; &lt;/a&gt; IS 조회 된 호출하여 &lt;a href=&quot;os#os.get_terminal_size&quot;&gt; &lt;code&gt;os.get_terminal_size()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be1c8634db85a77e79d600408825132f805fd2d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;None&lt;/code&gt; is passed, it&amp;rsquo;s up to the class designer to decide the best response. For example, returning &lt;code&gt;None&lt;/code&gt; is appropriate if the class wishes to say that time objects don&amp;rsquo;t participate in the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; protocols. It may be more useful for &lt;code&gt;utcoffset(None)&lt;/code&gt; to return the standard UTC offset, as there is no other convention for discovering the standard offset.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 전달 되면 최상의 응답을 결정하는 것은 클래스 디자이너의 책임입니다. 예를 들어, 클래스가 시간 객체가 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 프로토콜에 참여하지 않는다고 말하고 싶다면 &lt;code&gt;None&lt;/code&gt; 을 반환하는 것이 적절 합니다. 표준 오프셋을 발견하는 다른 규칙이 없으므로 &lt;code&gt;utcoffset(None)&lt;/code&gt; 이 표준 UTC 오프셋을 반환하는 것이 더 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d247f34d37a9741e0b40611aec77465bb0b0659a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PATH_INFO&lt;/code&gt; is just a &amp;ldquo;/&amp;rdquo;, this routine returns an empty string and appends a trailing slash to &lt;code&gt;SCRIPT_NAME&lt;/code&gt;, even though empty path segments are normally ignored, and &lt;code&gt;SCRIPT_NAME&lt;/code&gt; doesn&amp;rsquo;t normally end in a slash. This is intentional behavior, to ensure that an application can tell the difference between URIs ending in &lt;code&gt;/x&lt;/code&gt; from ones ending in &lt;code&gt;/x/&lt;/code&gt; when using this routine to do object traversal.</source>
          <target state="translated">때 &lt;code&gt;PATH_INFO&lt;/code&gt; 는 단지 &quot;/&quot;이 돌아 간다 빈 문자열과에 후행 슬래시 추가 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 을 빈 경로 세그먼트는 일반적으로 무시에도 불구하고, &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 은 일반적으로 슬래시로 끝나지 않습니다. 이 응용 프로그램이 종료 된 URI 사이의 차이를 구별 할 수 있도록하기 위해, 의도적 인 동작입니다에서 &lt;code&gt;/x&lt;/code&gt; 로 끝나는 것과 &lt;code&gt;/x/&lt;/code&gt; 객체 탐색을 할이 루틴을 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="3259a3e106d026a974e471af3e09c6877af341cc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;True&lt;/code&gt;, raise exception &lt;a href=&quot;#csv.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; on bad CSV input. The default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;True&lt;/code&gt; , 인상 예외 &lt;a href=&quot;#csv.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 나쁜 CSV 입력합니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7249093ec9e4d3cc83bc42119bb94a864c87dc19" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;punctuation_chars&lt;/code&gt; is specified, the &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt;&lt;code&gt;wordchars&lt;/code&gt;&lt;/a&gt; attribute is augmented with the characters &lt;code&gt;~-./*?=&lt;/code&gt;. That is because these characters can appear in file names (including wildcards) and command-line arguments (e.g. &lt;code&gt;--color=auto&lt;/code&gt;). Hence:</source>
          <target state="translated">때 &lt;code&gt;punctuation_chars&lt;/code&gt; 가 지정되면, &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt; &lt;code&gt;wordchars&lt;/code&gt; 의&lt;/a&gt; 속성은 문자로 증강되어 &lt;code&gt;~-./*?=&lt;/code&gt; . 이러한 문자는 파일 이름 (와일드 카드 포함)과 명령 줄 인수 (예 : &lt;code&gt;--color=auto&lt;/code&gt; )에 나타날 수 있기 때문 입니다. 그 후:</target>
        </trans-unit>
        <trans-unit id="18714bad76b2938b84e76ca6a48899884c985828" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;cmd&lt;/em&gt; is &lt;code&gt;LOCK_SH&lt;/code&gt; or &lt;code&gt;LOCK_EX&lt;/code&gt;, it can also be bitwise ORed with &lt;code&gt;LOCK_NB&lt;/code&gt; to avoid blocking on lock acquisition. If &lt;code&gt;LOCK_NB&lt;/code&gt; is used and the lock cannot be acquired, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised and the exception will have an &lt;em&gt;errno&lt;/em&gt; attribute set to &lt;code&gt;EACCES&lt;/code&gt; or &lt;code&gt;EAGAIN&lt;/code&gt; (depending on the operating system; for portability, check for both values). On at least some systems, &lt;code&gt;LOCK_EX&lt;/code&gt; can only be used if the file descriptor refers to a file opened for writing.</source>
          <target state="translated">때 &lt;em&gt;cmd를이&lt;/em&gt; 입니다 &lt;code&gt;LOCK_SH&lt;/code&gt; 또는 &lt;code&gt;LOCK_EX&lt;/code&gt; , 그것은 또한과 단위의 논리합 수 있습니다 &lt;code&gt;LOCK_NB&lt;/code&gt; 락 취득에 막지 않도록. 경우 &lt;code&gt;LOCK_NB&lt;/code&gt; 가 사용되며, 로크가 획득 될 수없는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 제기되고 예외가있을 것이다 &lt;em&gt;의 errno&lt;/em&gt; 에 속성 세트 &lt;code&gt;EACCES&lt;/code&gt; 또는 &lt;code&gt;EAGAIN&lt;/code&gt; (오퍼레이팅 시스템에 따라, 휴대가 두 값을 확인). 적어도 일부 시스템에서는 파일 디스크립터가 쓰기 위해 열린 파일을 참조하는 경우에만 &lt;code&gt;LOCK_EX&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83c29eb631fb560f29f322bca1a715e76bddb07" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;converters&lt;/em&gt; is given, it should be a dictionary where each key represents the name of a type converter and each value is a callable implementing the conversion from string to the desired datatype. Every converter gets its own corresponding &lt;code&gt;get*()&lt;/code&gt; method on the parser object and section proxies.</source>
          <target state="translated">&lt;em&gt;변환기&lt;/em&gt; 가 제공 되면 각 키는 유형 변환기의 이름을 나타내며 각 값은 문자열에서 원하는 데이터 유형으로의 변환을 구현하는 호출 가능 인 사전이어야합니다. 모든 변환기는 파서 객체와 섹션 프록시에서 해당 &lt;code&gt;get*()&lt;/code&gt; 메소드를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="af9e0a3c67c495e5f8455996a807bfc6861a7af3" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;decode&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default) the body is returned as a string without decoding the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;. However, for a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; of 8bit, an attempt is made to decode the original bytes using the &lt;code&gt;charset&lt;/code&gt; specified by the &lt;em&gt;Content-Type&lt;/em&gt; header, using the &lt;code&gt;replace&lt;/code&gt; error handler. If no &lt;code&gt;charset&lt;/code&gt; is specified, or if the &lt;code&gt;charset&lt;/code&gt; given is not recognized by the email package, the body is decoded using the default ASCII charset.</source>
          <target state="translated">때 &lt;em&gt;디코드&lt;/em&gt; 이다 &lt;code&gt;False&lt;/code&gt; (기본) 몸은 디코딩하지 않고 문자열로 반환되는 &lt;em&gt;콘텐츠 전송 인코딩을&lt;/em&gt; . 그러나 8 비트 의 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 의 경우 , &lt;code&gt;replace&lt;/code&gt; 오류 핸들러를 사용하여 &lt;em&gt;Content-Type&lt;/em&gt; 헤더에 지정된 &lt;code&gt;charset&lt;/code&gt; 사용하여 원래 바이트를 디코딩하려고 시도 합니다. 어떤 경우 &lt;code&gt;charset&lt;/code&gt; 지정되지 않는 경우, 또는 &lt;code&gt;charset&lt;/code&gt; 주어진이 이메일 패키지를 인식하지 못하는, 몸은 기본 ASCII 문자 세트를 사용하여 디코딩된다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8896ffa0276b29fe5abcec59ab4dbb6132b4621" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;default_section&lt;/em&gt; is given, it specifies the name for the special section holding default values for other sections and interpolation purposes (normally named &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt;). This value can be retrieved and changed on runtime using the &lt;code&gt;default_section&lt;/code&gt; instance attribute.</source>
          <target state="translated">&lt;em&gt;default_section&lt;/em&gt; 이 지정 되면 다른 섹션 및 보간 목적으로 기본값을 보유하는 특수 섹션의 이름을 지정합니다 (일반적으로 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; ). 이 값은 &lt;code&gt;default_section&lt;/code&gt; 인스턴스 속성을 사용하여 런타임시 검색하고 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ec4070356db325dd5a3a1a7a7c4a6d9c8470430" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;delimiters&lt;/em&gt; is given, it is used as the set of substrings that divide keys from values. When &lt;em&gt;comment_prefixes&lt;/em&gt; is given, it will be used as the set of substrings that prefix comments in otherwise empty lines. Comments can be indented. When &lt;em&gt;inline_comment_prefixes&lt;/em&gt; is given, it will be used as the set of substrings that prefix comments in non-empty lines.</source>
          <target state="translated">&lt;em&gt;구분 기호&lt;/em&gt; 가 제공 되면 키를 값과 나누는 하위 문자열 집합으로 사용됩니다. 때 &lt;em&gt;comment_prefixes이&lt;/em&gt; 주어집니다, 그것은 그렇지 않으면 빈 줄에 주석을 앞에 문자열의 집합으로 사용됩니다. 주석을 들여 쓸 수 있습니다. 때 &lt;em&gt;inline_comment_prefixes이&lt;/em&gt; 주어집니다, 그것은 문자열의 집합으로 사용됩니다 비어 있지 않은 라인의 접두사 주석이.</target>
        </trans-unit>
        <trans-unit id="017422042ed5196395fe163f83a712b974664f00" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;fileobj&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the &lt;em&gt;filename&lt;/em&gt; argument is only used to be included in the &lt;strong&gt;gzip&lt;/strong&gt; file header, which may include the original filename of the uncompressed file. It defaults to the filename of &lt;em&gt;fileobj&lt;/em&gt;, if discernible; otherwise, it defaults to the empty string, and in this case the original filename is not included in the header.</source>
          <target state="translated">때 &lt;em&gt;fileobj가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; 의 &lt;em&gt;파일 이름&lt;/em&gt; 인수는에 포함하는 데 사용됩니다 &lt;strong&gt;은 gzip&lt;/strong&gt; 압축되지 않은 파일의 원래 파일 이름을 포함 할 수있다 파일 헤더. 식별 가능한 경우 기본적으로 &lt;em&gt;fileobj&lt;/em&gt; 의 파일 이름이 사용 됩니다. 그렇지 않으면, 기본값은 빈 문자열이며,이 경우 원래 파일 이름은 헤더에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e007940c1a1ac1b90ed239aaae563d08c3c83e5c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;follow_symlinks&lt;/em&gt; is false, and &lt;em&gt;src&lt;/em&gt; is a symbolic link, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; attempts to copy all metadata from the &lt;em&gt;src&lt;/em&gt; symbolic link to the newly-created &lt;em&gt;dst&lt;/em&gt; symbolic link. However, this functionality is not available on all platforms. On platforms where some or all of this functionality is unavailable, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; will preserve all the metadata it can; &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; never raises an exception because it cannot preserve file metadata.</source>
          <target state="translated">때 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이며, &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 시도는 모든 메타 데이터를 복사 &lt;em&gt;SRC&lt;/em&gt; 새로 생성에 심볼릭 링크 &lt;em&gt;DST&lt;/em&gt; 심볼릭 링크. 그러나이 기능이 모든 플랫폼에서 사용 가능한 것은 아닙니다. 이 기능 중 일부 또는 전부를 사용할 수없는 플랫폼에서 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 는 가능한 모든 메타 데이터를 유지합니다. &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 는 파일 메타 데이터를 보존 할 수 없으므로 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef749f2221652284c69ca1d8aca13dd2c69b4877" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;func&lt;/em&gt; is a descriptor (such as a normal Python function, &lt;a href=&quot;functions#classmethod&quot;&gt;&lt;code&gt;classmethod()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;abstractmethod()&lt;/code&gt; or another instance of &lt;a href=&quot;#functools.partialmethod&quot;&gt;&lt;code&gt;partialmethod&lt;/code&gt;&lt;/a&gt;), calls to &lt;code&gt;__get__&lt;/code&gt; are delegated to the underlying descriptor, and an appropriate &lt;a href=&quot;#partial-objects&quot;&gt;partial object&lt;/a&gt; returned as the result.</source>
          <target state="translated">경우 &lt;em&gt;FUNC는&lt;/em&gt; 디스크립터이다 (예컨대 정상적인 파이썬 함수 &lt;a href=&quot;functions#classmethod&quot;&gt; &lt;code&gt;classmethod()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;abstractmethod()&lt;/code&gt; 또는 다른 인스턴스 &lt;a href=&quot;#functools.partialmethod&quot;&gt; &lt;code&gt;partialmethod&lt;/code&gt; &lt;/a&gt; ) 호출 &lt;code&gt;__get__&lt;/code&gt; 가 기본 기술자에게 위임 및 적절한 &lt;a href=&quot;#partial-objects&quot;&gt;부분 목적은&lt;/a&gt; 결과로서 리턴 .</target>
        </trans-unit>
        <trans-unit id="2a7099d0edd318bbd39005c2813b14b352de9cce" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;func&lt;/em&gt; is a non-descriptor callable, an appropriate bound method is created dynamically. This behaves like a normal Python function when used as a method: the &lt;em&gt;self&lt;/em&gt; argument will be inserted as the first positional argument, even before the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;keywords&lt;/em&gt; supplied to the &lt;a href=&quot;#functools.partialmethod&quot;&gt;&lt;code&gt;partialmethod&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">경우 &lt;em&gt;FUNC가&lt;/em&gt; 아닌 기술자 호출하고, 적절한 결합 방법이 동적으로 생성된다. 이것은 메소드로 사용될 때 일반적인 Python 함수처럼 작동합니다. &lt;em&gt;self&lt;/em&gt; 인수는 &lt;a href=&quot;#functools.partialmethod&quot;&gt; &lt;code&gt;partialmethod&lt;/code&gt; &lt;/a&gt; 생성자에 제공된 &lt;em&gt;인수&lt;/em&gt; 및 &lt;em&gt;키워드&lt;/em&gt; 앞에도 첫 번째 위치 인수로 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="45e75310ec28936ea5e8f063d0b326f7a35ceaaa" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;limits&lt;/em&gt; is not given the function returns the &lt;em&gt;resource&lt;/em&gt; limit of the process &lt;em&gt;pid&lt;/em&gt;. When &lt;em&gt;limits&lt;/em&gt; is given the &lt;em&gt;resource&lt;/em&gt; limit of the process is set and the former resource limit is returned.</source>
          <target state="translated">때 &lt;em&gt;제한이&lt;/em&gt; 함수가 반환을 부여하지 않는 &lt;em&gt;자원&lt;/em&gt; 프로세스의 제한 &lt;em&gt;PID&lt;/em&gt; . 경우 &lt;em&gt;제한이&lt;/em&gt; 주어진되는 &lt;em&gt;자원&lt;/em&gt; 공정의 한계를 설정하고, 이전의 자원 한계가 반환된다.</target>
        </trans-unit>
        <trans-unit id="e06b2c5a32e26f67b12baa218e1362803c4f76e3" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;operation&lt;/em&gt; is not specified or &lt;code&gt;'open'&lt;/code&gt;, this acts like double-clicking the file in Windows Explorer, or giving the file name as an argument to the &lt;strong&gt;start&lt;/strong&gt; command from the interactive command shell: the file is opened with whatever application (if any) its extension is associated.</source>
          <target state="translated">때 &lt;em&gt;작업이&lt;/em&gt; 지정되지 않았거나 &lt;code&gt;'open'&lt;/code&gt; 이 Windows 탐색기에서 파일을 두 번 클릭하거나 인수로 파일 이름을 지정 같은 역할을 &lt;strong&gt;시작&lt;/strong&gt; 대화 형 명령 셸에서 명령 파일 (있는 경우 어떤 응용 프로그램과 함께 열립니다 ) 확장이 연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="821a2ea402d2f70a801f8008ac1f17c8a85bc5fa" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;pathsegments&lt;/em&gt; is empty, the current directory is assumed:</source>
          <target state="translated">때 &lt;em&gt;pathsegments가&lt;/em&gt; 비어 현재 디렉토리로 간주됩니다 :</target>
        </trans-unit>
        <trans-unit id="75967987830adb468980e21d08d3b79aba8262fe" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;section&lt;/em&gt; is not given, return a list of &lt;em&gt;section_name&lt;/em&gt;, &lt;em&gt;section_proxy&lt;/em&gt; pairs, including DEFAULTSECT.</source>
          <target state="translated">때 &lt;em&gt;섹션이&lt;/em&gt; 주어지지의 목록 반환 &lt;em&gt;SECTION_NAME&lt;/em&gt; , &lt;em&gt;section_proxy&lt;/em&gt; DEFAULTSECT 포함 쌍.</target>
        </trans-unit>
        <trans-unit id="ceee677568b16b47671c5f9b32ba5aa7d309179a" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;skipkeys&lt;/em&gt; is false (the default) the function raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when a key of a dictionary is not a string, otherwise such keys are skipped.</source>
          <target state="translated">때 &lt;em&gt;skipkeys가&lt;/em&gt; false (기본값) 기능이 제기 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 사전의 키가 문자열이 아닌 경우, 그렇지 않으면 같은 키를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="472dd01686c20762dc7bf928e1bdbe2e019a8702" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;sort_keys&lt;/em&gt; is true (the default) the keys for dictionaries will be written to the plist in sorted order, otherwise they will be written in the iteration order of the dictionary.</source>
          <target state="translated">때 &lt;em&gt;sort_keys이&lt;/em&gt; 참 (기본)이 사전의 키는 그렇지 않은 경우는 사전의 반복 순서로 쓸 수있게되어, 정렬 된 순서로 PLIST에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="c2f903cfa4c4022ca7d7343290d72e1caad4bcee" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;st&lt;/em&gt; represents an &lt;code&gt;'eval'&lt;/code&gt; form, this function returns &lt;code&gt;True&lt;/code&gt;, otherwise it returns &lt;code&gt;False&lt;/code&gt;. This is useful, since code objects normally cannot be queried for this information using existing built-in functions. Note that the code objects created by &lt;a href=&quot;#parser.compilest&quot;&gt;&lt;code&gt;compilest()&lt;/code&gt;&lt;/a&gt; cannot be queried like this either, and are identical to those created by the built-in &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">때 &lt;em&gt;일이&lt;/em&gt; 대표하는 &lt;code&gt;'eval'&lt;/code&gt; 양식을,이 함수는 반환 &lt;code&gt;True&lt;/code&gt; , 그렇지 않으면 반환 &lt;code&gt;False&lt;/code&gt; . 일반적으로 기존 내장 함수를 사용하여이 정보에 대해 코드 객체를 쿼리 할 수 ​​없으므로 유용합니다. &lt;a href=&quot;#parser.compilest&quot;&gt; &lt;code&gt;compilest()&lt;/code&gt; &lt;/a&gt; 작성된 코드 오브젝트는 이와 같이 조회 할 수 없으며 내장 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 함수로 작성된 코드 오브젝트 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c4701dad121dbacff21ec8bfc48ee5a248faeaec" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), the mapping will be added to the official MIME types, otherwise to the non-standard ones.</source>
          <target state="translated">때 &lt;em&gt;엄격한가&lt;/em&gt; 있습니다 &lt;code&gt;True&lt;/code&gt; (기본), 매핑 그렇지 않으면 표준이 아닌 것들로, 공식 MIME 유형에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c8f2e3f887ca166194ca9ecc8d2f3c166b6328e" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), the parser won&amp;rsquo;t allow for any section or option duplicates while reading from a single source (file, string or dictionary), raising &lt;a href=&quot;#configparser.DuplicateSectionError&quot;&gt;&lt;code&gt;DuplicateSectionError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#configparser.DuplicateOptionError&quot;&gt;&lt;code&gt;DuplicateOptionError&lt;/code&gt;&lt;/a&gt;. When &lt;em&gt;empty_lines_in_values&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (default: &lt;code&gt;True&lt;/code&gt;), each empty line marks the end of an option. Otherwise, internal empty lines of a multiline option are kept as part of the value. When &lt;em&gt;allow_no_value&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (default: &lt;code&gt;False&lt;/code&gt;), options without values are accepted; the value held for these is &lt;code&gt;None&lt;/code&gt; and they are serialized without the trailing delimiter.</source>
          <target state="translated">때 &lt;em&gt;엄격한가&lt;/em&gt; 있습니다 &lt;code&gt;True&lt;/code&gt; (기본) 상승, 단일 소스 (파일, 문자열 또는 사전)에서 읽는 동안, 파서는 섹션 또는 옵션 중복을 허용하지 않습니다 &lt;a href=&quot;#configparser.DuplicateSectionError&quot;&gt; &lt;code&gt;DuplicateSectionError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#configparser.DuplicateOptionError&quot;&gt; &lt;code&gt;DuplicateOptionError&lt;/code&gt; 을&lt;/a&gt; . 때 &lt;em&gt;empty_lines_in_values이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본 : &lt;code&gt;True&lt;/code&gt; ), 각각의 빈 줄 표시 옵션의 끝. 그렇지 않으면 여러 줄 옵션의 내부 빈 줄이 값의 일부로 유지됩니다. 때 &lt;em&gt;allow_no_value가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; (기본값 : &lt;code&gt;False&lt;/code&gt; ), 값이없는 옵션이 허용됩니다; 이에 대한 가치는 &lt;code&gt;None&lt;/code&gt; 후행 구분 기호없이 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="13434fcf0e93bac1cc2c94533fc5d1edd99c06f4" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;symlinks&lt;/em&gt; is false, if the file pointed by the symlink doesn&amp;rsquo;t exist, an exception will be added in the list of errors raised in an &lt;a href=&quot;#shutil.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; exception at the end of the copy process. You can set the optional &lt;em&gt;ignore_dangling_symlinks&lt;/em&gt; flag to true if you want to silence this exception. Notice that this option has no effect on platforms that don&amp;rsquo;t support &lt;a href=&quot;os#os.symlink&quot;&gt;&lt;code&gt;os.symlink()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;em&gt;심볼릭 링크가&lt;/em&gt; 거짓 심볼릭 링크가 가리키는 파일이 존재하지 않는 경우, 예외가에서 제기 된 오류 목록에 추가됩니다 &lt;a href=&quot;#shutil.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 복사 프로세스의 마지막에 예외입니다. 이 예외를 침묵 시키려면 선택적 &lt;em&gt;ignore_dangling_symlinks&lt;/em&gt; 플래그를 true로 설정할 수 있습니다 . 이 옵션은 &lt;a href=&quot;os#os.symlink&quot;&gt; &lt;code&gt;os.symlink()&lt;/code&gt; &lt;/a&gt; 지원하지 않는 플랫폼에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dc2a3c9dea5d3009f072403af68bc41dbee55be1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the caller can modify the &lt;em&gt;dirnames&lt;/em&gt; list in-place (perhaps using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt;&lt;code&gt;del&lt;/code&gt;&lt;/a&gt; or slice assignment), and &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; will only recurse into the subdirectories whose names remain in &lt;em&gt;dirnames&lt;/em&gt;; this can be used to prune the search, impose a specific order of visiting, or even to inform &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; about directories the caller creates or renames before it resumes &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; again. Modifying &lt;em&gt;dirnames&lt;/em&gt; when &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; has no effect on the behavior of the walk, because in bottom-up mode the directories in &lt;em&gt;dirnames&lt;/em&gt; are generated before &lt;em&gt;dirpath&lt;/em&gt; itself is generated.</source>
          <target state="translated">때 &lt;em&gt;하향식이&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 호출자는 수정할 수 있습니다 &lt;em&gt;dirnames의&lt;/em&gt; (아마도 사용하여 현재 위치 목록을 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt; &lt;code&gt;del&lt;/code&gt; &lt;/a&gt; 및 또는 슬라이스 할당) &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 만이 같이 Recurse 이름이 유지 하위 디렉토리에 &lt;em&gt;dirnames&lt;/em&gt; ; 검색을 제거하거나, 특정 방문 순서를 적용하거나 , 호출자가 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 다시 시작하기 전에 작성하거나 이름을 바꾸는 디렉토리에 대해 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 에 알리는 데 사용할 수 있습니다 . &lt;em&gt;하향식&lt;/em&gt; 모드에서 디렉토리의 디렉토리는 &lt;em&gt;하향식이므로&lt;/em&gt; 디렉토리 가 &lt;code&gt;False&lt;/code&gt; &lt;em&gt;일&lt;/em&gt; 때 &lt;em&gt;디렉토리 이름을&lt;/em&gt; 수정 &lt;em&gt;해도&lt;/em&gt; 도보 동작에 영향을 미치지 않습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;dirpath&lt;/em&gt; 자체가 생성되기 전에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="40cb053f7928b5af0b380bb285ed3b898bb57205" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;pydoc&lt;/strong&gt; generates documentation, it uses the current environment and path to locate modules. Thus, invoking &lt;strong&gt;pydoc spam&lt;/strong&gt; documents precisely the version of the module you would get if you started the Python interpreter and typed &lt;code&gt;import spam&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;pydoc&lt;/strong&gt; 은 문서를 생성 할 때 현재 환경과 경로를 사용하여 모듈을 찾습니다. 따라서 Python 인터프리터를 시작하고 &lt;code&gt;import spam&lt;/code&gt; 을 입력하면 &lt;strong&gt;pydoc 스팸&lt;/strong&gt; 문서를 정확하게 호출 하는 모듈 버전을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="966d03fa55cf89b971f2711329e87cfb6a8d70ef" translate="yes" xml:space="preserve">
          <source>When DST ends (the &amp;ldquo;end&amp;rdquo; line), there&amp;rsquo;s a potentially worse problem: there&amp;rsquo;s an hour that can&amp;rsquo;t be spelled unambiguously in local wall time: the last hour of daylight time. In Eastern, that&amp;rsquo;s times of the form 5:MM UTC on the day daylight time ends. The local wall clock leaps from 1:59 (daylight time) back to 1:00 (standard time) again. Local times of the form 1:MM are ambiguous. &lt;code&gt;astimezone()&lt;/code&gt; mimics the local clock&amp;rsquo;s behavior by mapping two adjacent UTC hours into the same local hour then. In the Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when converted to Eastern, but earlier times have the &lt;a href=&quot;#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute set to 0 and the later times have it set to 1. For example, at the Fall back transition of 2016, we get:</source>
          <target state="translated">DST가 끝날 때 ( &quot;종료&quot;줄) 잠재적으로 더 나쁜 문제가 있습니다. 현지 시간으로 명확하게 표기 할 수없는 한 시간이 있습니다. 일광 시간의 마지막 시간입니다. 동부에서 일광 절약 시간이 종료되는 날의 시간은 5 : MM UTC입니다. 현지 벽시계는 1:59 (일광 시간)에서 1:00 (표준 시간)으로 다시 뛰었습니다. 1 : MM 형식의 현지 시간은 모호합니다. &lt;code&gt;astimezone()&lt;/code&gt; 은 인접한 두 UTC 시간을 동일한 현지 시간으로 매핑하여 로컬 시계의 동작을 모방합니다. 동부 예제에서 동부 형식으로 변환 할 때 5 : MM 및 6 : MM 형식의 UTC 시간은 모두 동부 표준시로 1 : MM으로 매핑되지만 이전에는 &lt;a href=&quot;#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 속성이 0으로 설정되고 나중에는 1로 설정됩니다. 2016 년 폴백 전환에서 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e5d2b07f1f34036b37e1fe11345da1aa1e1630" translate="yes" xml:space="preserve">
          <source>When DST starts (the &amp;ldquo;start&amp;rdquo; line), the local wall clock leaps from 1:59 to 3:00. A wall time of the form 2:MM doesn&amp;rsquo;t really make sense on that day, so &lt;code&gt;astimezone(Eastern)&lt;/code&gt; won&amp;rsquo;t deliver a result with &lt;code&gt;hour == 2&lt;/code&gt; on the day DST begins. For example, at the Spring forward transition of 2016, we get:</source>
          <target state="translated">DST가 시작되면 ( &quot;시작&quot;라인) 로컬 벽시계가 1:59에서 3:00으로 도약합니다. 2 : MM 형식의 월 타임은 해당 날짜에 실제로 의미 가 없으므로 DST가 시작되는 날에 &lt;code&gt;astimezone(Eastern)&lt;/code&gt; 가 &lt;code&gt;hour == 2&lt;/code&gt; 결과를 제공하지 않습니다 . 예를 들어, 2016 년 스프링 포워드 전환에서 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="607bcef959d2c892c1b6a1b372716350bf979b2f" translate="yes" xml:space="preserve">
          <source>When IDLE first starts, it attempts to read user configuration files in &lt;code&gt;~/.idlerc/&lt;/code&gt; (~ is one&amp;rsquo;s home directory). If there is a problem, an error message should be displayed. Leaving aside random disk glitches, this can be prevented by never editing the files by hand, using the configuration dialog, under Options, instead Options. Once it happens, the solution may be to delete one or more of the configuration files.</source>
          <target state="translated">IDLE이 처음 시작되면 &lt;code&gt;~/.idlerc/&lt;/code&gt; 에서 사용자 구성 파일을 읽으려고 시도합니다 (~는 홈 디렉토리 임). 문제가 있으면 오류 메시지가 표시되어야합니다. 임의 디스크 결함을 남기지 않고, 옵션 대신 구성 대화 상자의 옵션 대화 상자를 사용하여 파일을 직접 편집하지 않으면이를 방지 할 수 있습니다. 일단 발생하면 해결책은 하나 이상의 구성 파일을 삭제하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e8cfacfb0ec66c495be055f582089d68c4b5869" translate="yes" xml:space="preserve">
          <source>When Python code uses the &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module to change the locale, this also affects the embedding application. If the embedding application doesn&amp;rsquo;t want this to happen, it should remove the &lt;code&gt;_locale&lt;/code&gt; extension module (which does all the work) from the table of built-in modules in the &lt;code&gt;config.c&lt;/code&gt; file, and make sure that the &lt;code&gt;_locale&lt;/code&gt; module is not accessible as a shared library.</source>
          <target state="translated">Python 코드가 &lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 로케일 을 변경하면 임베드 응용 프로그램에도 영향을줍니다. 임베드 응용 프로그램이이를 원하지 않으면 &lt;code&gt;config.c&lt;/code&gt; 파일 의 내장 모듈 테이블에서 &lt;code&gt;_locale&lt;/code&gt; 확장 모듈 (모든 작업을 수행함)을 제거 하고 &lt;code&gt;_locale&lt;/code&gt; 모듈이 아닌지 확인해야합니다. 공유 라이브러리로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f41d4f67b29d3c1098269b891e9bec309ad5e3" translate="yes" xml:space="preserve">
          <source>When Shell has the focus, it controls the keyboard and screen. This is normally transparent, but functions that directly access the keyboard and screen will not work. These include system-specific functions that determine whether a key has been pressed and if so, which.</source>
          <target state="translated">Shell에 포커스가 있으면 키보드와 화면을 제어합니다. 이것은 일반적으로 투명하지만 키보드와 화면에 직접 액세스하는 기능은 작동하지 않습니다. 여기에는 키를 눌렀는지 여부를 결정하는 시스템 별 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7a359f4fa5e01180f16295319eaf53142e2c0994" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object is passed in response to a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;dt.tzinfo&lt;/code&gt; is the same object as &lt;em&gt;self&lt;/em&gt;. &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods can rely on this, unless user code calls &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods directly. The intent is that the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods interpret &lt;em&gt;dt&lt;/em&gt; as being in local time, and not need worry about objects in other timezones.</source>
          <target state="translated">때 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 오브젝트가 응답으로 전달되는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 에있어서, &lt;code&gt;dt.tzinfo&lt;/code&gt; 는 동일한 목적 &lt;em&gt;자기&lt;/em&gt; . 사용자 코드가 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 메소드를 직접 호출하지 않는 한 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 메소드는 이에 의존 할 수 있습니다. 의도는 점이다 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 방법은 해석 &lt;em&gt;DT&lt;/em&gt; 현지 시간 것으로, 그리고 다른 시간대에있는 개체에 대한 걱정이 필요합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc52f05baa4394318109ef8dd16b0838e7819096" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="a87ed137d28adb4e7367125bf334be63876e2c24" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4e6e7fb6abd8fd4a202f9606c8570fc783915cb4" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X-상태&lt;/em&gt; 헤더는 생략하고 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="ca33d6c3c9d25ed20394d7c3deaa901e7846bdec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s original headers are modified, the visible headers are not automatically modified to correspond. This method updates the visible headers as follows: each visible header with a corresponding original header is set to the value of the original header, each visible header without a corresponding original header is removed, and any of &lt;em&gt;Date&lt;/em&gt;, &lt;em&gt;From&lt;/em&gt;, &lt;em&gt;Reply-To&lt;/em&gt;, &lt;em&gt;To&lt;/em&gt;, &lt;em&gt;CC&lt;/em&gt;, and &lt;em&gt;Subject&lt;/em&gt; that are present in the original headers but not the visible headers are added to the visible headers.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt; 인스턴스의 원래 헤더가 수정 될 때 보이는 헤더는 자동으로 수정되지 않습니다. 이 메소드는 표시되는 헤더를 다음과 같이 업데이트합니다. 해당하는 원래 헤더가있는 각 표시되는 헤더는 원래 헤더의 값으로 설정되고 해당하는 원래 헤더가없는 각 표시되는 헤더는 제거되며 &lt;em&gt;Date&lt;/em&gt; , &lt;em&gt;From&lt;/em&gt; , &lt;em&gt;Reply-To&lt;/em&gt; , &lt;em&gt;To&lt;/em&gt; 원래 헤더에는 있지만 표시되는 헤더는없는 , &lt;em&gt;CC&lt;/em&gt; 및 &lt;em&gt;Subject&lt;/em&gt; 가 표시되는 헤더에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="75531aef3bfb04565ed01de282e0e8a5dd90cd56" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="a351f9e4fca060cf05b544590758e13c938d87a1" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="1152ba9f8c4290368623aeaac928cca549892729" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X-상태&lt;/em&gt; 헤더는 생략하고 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="ebde1da7e650fdde9e9869ca15dbe9af33e8273e" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &amp;ldquo;From &amp;rdquo; line is copied and all flags directly correspond:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 라인이 복사되고 모든 플래그가 직접 대응 &quot;에서&quot;</target>
        </trans-unit>
        <trans-unit id="b0a451fe8c2a75c0a9d07b757e5b645a5db0c95a" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object is created, it will inherit the authentication key of its parent process, although this may be changed by setting &lt;a href=&quot;#multiprocessing.Process.authkey&quot;&gt;&lt;code&gt;authkey&lt;/code&gt;&lt;/a&gt; to another byte string.</source>
          <target state="translated">때 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 오브젝트가 작성이 설정에 의해 변경 될 수 있지만, 그 부모 프로세스의 인증 키를 상속 &lt;a href=&quot;#multiprocessing.Process.authkey&quot;&gt; &lt;code&gt;authkey&lt;/code&gt; &lt;/a&gt; 다른 바이트 스트링.</target>
        </trans-unit>
        <trans-unit id="bd552e17015aa5c66496ae4f45468cddbe08da34" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object is created, it acquires a policy. If the message is created by a &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt;, a policy passed to the parser will be the policy used by the message it creates. If the message is created by the program, then the policy can be specified when it is created. When a message is passed to a &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;, the generator uses the policy from the message by default, but you can also pass a specific policy to the generator that will override the one stored on the message object.</source>
          <target state="translated">때 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 개체가 만들어, 그것은 정책을 획득한다. 메시지가 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 의해 생성되면 파서 에 전달 된 정책 은 메시지가 생성 한 메시지에 의해 사용되는 정책이됩니다. 프로그램이 메시지를 작성하면 작성 될 때 정책을 지정할 수 있습니다. 메시지가 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 로 전달 되면 생성기는 기본적으로 메시지의 정책을 사용하지만 특정 정책을 생성기에 전달하여 메시지 객체에 저장된 정책을 재정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="796474d1752f90ea152f5dd6af4e1499894479a4" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; function returns, a new &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; instance is raised, and the value returned by the function is used as the &lt;code&gt;value&lt;/code&gt; parameter to the constructor of the exception.</source>
          <target state="translated">때 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 함수 리턴 새로운 &lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 인스턴스가 발생되고, 함수에 의해 리턴 된 값으로 사용되는 &lt;code&gt;value&lt;/code&gt; 예외의 생성자 파라미터.</target>
        </trans-unit>
        <trans-unit id="f43590acc1cf538fae98de86cea41d189b3c470b" translate="yes" xml:space="preserve">
          <source>When a Future object is &lt;em&gt;awaited&lt;/em&gt; it means that the coroutine will wait until the Future is resolved in some other place.</source>
          <target state="translated">Future를 객체가 될 때 &lt;em&gt;기다려온&lt;/em&gt; 은 미래가 다른 곳에서 해결 될 때까지 코 루틴이 대기하는 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="a501ed1c9da143e744360045a70756ab3a3c2bbc" translate="yes" xml:space="preserve">
          <source>When a HTTP/1.1 compliant server receives an &lt;code&gt;Expect: 100-continue&lt;/code&gt; request header it responds back with a &lt;code&gt;100 Continue&lt;/code&gt; followed by &lt;code&gt;200
OK&lt;/code&gt; headers. This method can be overridden to raise an error if the server does not want the client to continue. For e.g. server can chose to send &lt;code&gt;417
Expectation Failed&lt;/code&gt; as a response header and &lt;code&gt;return False&lt;/code&gt;.</source>
          <target state="translated">HTTP / 1.1 호환 서버는 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 요청 헤더를 받으면 &lt;code&gt;100 Continue&lt;/code&gt; 와 &lt;code&gt;200 OK&lt;/code&gt; 헤더로 다시 응답합니다 . 서버가 클라이언트를 계속하지 않으려는 경우 오류를 발생시키기 위해이 메소드를 대체 할 수 있습니다. 예를 들어, 서버는 &lt;code&gt;417 Expectation Failed&lt;/code&gt; 를 응답 헤더로 &lt;code&gt;return False&lt;/code&gt; 하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f1159e7b0d3c34483e2df19f60fd60e258658c" translate="yes" xml:space="preserve">
          <source>When a binary (or in-place) method returns &lt;code&gt;NotImplemented&lt;/code&gt; the interpreter will try the reflected operation on the other type (or some other fallback, depending on the operator). If all attempts return &lt;code&gt;NotImplemented&lt;/code&gt;, the interpreter will raise an appropriate exception. Incorrectly returning &lt;code&gt;NotImplemented&lt;/code&gt; will result in a misleading error message or the &lt;code&gt;NotImplemented&lt;/code&gt; value being returned to Python code.</source>
          <target state="translated">이진 (또는 내부) 메소드가 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환 하면 인터프리터는 다른 유형 (또는 연산자에 따라 다른 대체)에 대해 반영된 조작을 시도합니다. 모든 시도가 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환 하면 인터프리터는 적절한 예외를 발생시킵니다. &lt;code&gt;NotImplemented&lt;/code&gt; 를 잘못 반환 하면 잘못된 오류 메시지 또는 &lt;code&gt;NotImplemented&lt;/code&gt; 값이 Python 코드로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63fc5ba727ad83fc978cb83426ef44950fb22f0c" translate="yes" xml:space="preserve">
          <source>When a client connects, you&amp;rsquo;ll call &lt;code&gt;accept()&lt;/code&gt; on the socket to get the new socket from the other end, and use the context&amp;rsquo;s &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt; method to create a server-side SSL socket for the connection:</source>
          <target state="translated">클라이언트가 연결되면 소켓에서 &lt;code&gt;accept()&lt;/code&gt; 를 호출 하여 다른 쪽 끝에서 새 소켓을 가져오고 컨텍스트의 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 연결을위한 서버 측 SSL 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="14355459d065a2126b707c1cdaf9a9ce0eb37d01" translate="yes" xml:space="preserve">
          <source>When a coroutine function is called, but not awaited (e.g. &lt;code&gt;coro()&lt;/code&gt; instead of &lt;code&gt;await coro()&lt;/code&gt;) or the coroutine is not scheduled with &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt;, asyncio will emit a &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt;&lt;code&gt;RuntimeWarning&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">코 루틴 함수를 호출하지만 기다리게하지 (예되면 &lt;code&gt;coro()&lt;/code&gt; 대신 &lt;code&gt;await coro()&lt;/code&gt; ) 또는 코 루틴과는 예약되지 &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; , asyncio가 발광한다 &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt; &lt;code&gt;RuntimeWarning&lt;/code&gt; 을&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="80027fbdb3d8bf1a0774de4650e2b1aab343032a" translate="yes" xml:space="preserve">
          <source>When a coroutine is wrapped into a &lt;em&gt;Task&lt;/em&gt; with functions like &lt;a href=&quot;#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; the coroutine is automatically scheduled to run soon:</source>
          <target state="translated">코 루틴이 &lt;a href=&quot;#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; 와 같은 함수 를 사용하여 &lt;em&gt;Task에&lt;/em&gt; 래핑 되면 코 루틴이 자동으로 곧 실행되도록 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="29bdbe2316b1cfa1ea855e4c3c8a620f07d98c69" translate="yes" xml:space="preserve">
          <source>When a database is accessed by multiple connections, and one of the processes modifies the database, the SQLite database is locked until that transaction is committed. The &lt;em&gt;timeout&lt;/em&gt; parameter specifies how long the connection should wait for the lock to go away until raising an exception. The default for the timeout parameter is 5.0 (five seconds).</source>
          <target state="translated">여러 연결로 데이터베이스에 액세스하고 프로세스 중 하나에서 데이터베이스를 수정하면 해당 트랜잭션이 커밋 될 때까지 SQLite 데이터베이스가 잠 깁니다. &lt;em&gt;타임 아웃&lt;/em&gt; 연결이 잠금을 기다리는 시간 매개 변수를 지정 예외를 제기 할 때까지 멀리 이동합니다. 시간 종료 매개 변수의 기본값은 5.0 (5 초)입니다.</target>
        </trans-unit>
        <trans-unit id="58541f13ed67949530f68a704b5ad0ef345cd0ab" translate="yes" xml:space="preserve">
          <source>When a foreign function is called, each actual argument is passed to the &lt;code&gt;from_param()&lt;/code&gt; class method of the items in the &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt;&lt;code&gt;argtypes&lt;/code&gt;&lt;/a&gt; tuple, this method allows adapting the actual argument to an object that the foreign function accepts. For example, a &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt; item in the &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt;&lt;code&gt;argtypes&lt;/code&gt;&lt;/a&gt; tuple will convert a string passed as argument into a bytes object using ctypes conversion rules.</source>
          <target state="translated">외부 함수가 호출 될 때 각 실제 인수는 &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt; &lt;code&gt;argtypes&lt;/code&gt; &lt;/a&gt; 튜플 에있는 항목 의 &lt;code&gt;from_param()&lt;/code&gt; 클래스 메소드로 전달됩니다. 이 메소드를 사용하면 외부 인수가 허용하는 오브젝트에 실제 인수를 적용 할 수 있습니다. 예를 들어, &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt; &lt;code&gt;argtypes&lt;/code&gt; &lt;/a&gt; 튜플 의 &lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; 항목은 ctypes 변환 규칙을 사용하여 인수로 전달 된 문자열을 bytes 객체로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b49ea0d90c828ff025e45c681bc2ce260779892" translate="yes" xml:space="preserve">
          <source>When a form is submitted in the &amp;ldquo;old&amp;rdquo; format (as the query string or as a single data part of type &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt;), the items will actually be instances of the class &lt;code&gt;MiniFieldStorage&lt;/code&gt;. In this case, the &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;filename&lt;/code&gt; attributes are always &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">쿼리 문자열 또는 &lt;em&gt;application / x-www-form-urlencoded&lt;/em&gt; 유형의 단일 데이터 부분으로 양식을 &quot;이전&quot;형식으로 제출 하면 항목은 실제로 &lt;code&gt;MiniFieldStorage&lt;/code&gt; 클래스의 인스턴스가 됩니다. 이 경우 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;filename&lt;/code&gt; 속성은 항상 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff8b51f9aced6e65bff3f4369665f2c727321580" translate="yes" xml:space="preserve">
          <source>When a header parameter is encoded in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; format, &lt;a href=&quot;email.compat32-message#email.message.Message.get_param&quot;&gt;&lt;code&gt;Message.get_param&lt;/code&gt;&lt;/a&gt; may return a 3-tuple containing the character set, language, and value. &lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt;&lt;code&gt;collapse_rfc2231_value()&lt;/code&gt;&lt;/a&gt; turns this into a unicode string. Optional &lt;em&gt;errors&lt;/em&gt; is passed to the &lt;em&gt;errors&lt;/em&gt; argument of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; method; it defaults to &lt;code&gt;'replace'&lt;/code&gt;. Optional &lt;em&gt;fallback_charset&lt;/em&gt; specifies the character set to use if the one in the &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; header is not known by Python; it defaults to &lt;code&gt;'us-ascii'&lt;/code&gt;.</source>
          <target state="translated">헤더 매개 변수가 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 형식으로 인코딩 되면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_param&quot;&gt; &lt;code&gt;Message.get_param&lt;/code&gt; &lt;/a&gt; 은 문자 세트, 언어 및 값을 포함하는 3 개의 튜플을 리턴 할 수 있습니다. &lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt; &lt;code&gt;collapse_rfc2231_value()&lt;/code&gt; &lt;/a&gt; 는 이것을 유니 코드 문자열로 변환합니다. 선택적 &lt;em&gt;오류&lt;/em&gt; 는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; 메소드 의 &lt;em&gt;errors&lt;/em&gt; 인수로 전달됩니다 . 기본값은 &lt;code&gt;'replace'&lt;/code&gt; 입니다. 선택적 &lt;em&gt;fallback_charset&lt;/em&gt; 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 헤더에 있는 문자 를 Python에서 알 수없는 경우 사용할 문자 세트를 지정합니다 . 기본값은 &lt;code&gt;'us-ascii'&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d710381a25baff3243b6945ecd27556783f6e36" translate="yes" xml:space="preserve">
          <source>When a letter is first encountered, it is missing from the mapping, so the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; function calls &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt; to supply a default count of zero. The increment operation then builds up the count for each letter.</source>
          <target state="translated">문자가 처음 발견되면 맵핑에서 누락되므로 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 함수는 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 기본 카운트 0을 제공합니다. 그런 다음 증분 연산은 각 문자의 개수를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="32fdfac5d569cc8091912ece10591faa073940b3" translate="yes" xml:space="preserve">
          <source>When a logger is created, the level is set to &lt;code&gt;NOTSET&lt;/code&gt; (which causes all messages to be processed when the logger is the root logger, or delegation to the parent when the logger is a non-root logger). Note that the root logger is created with level &lt;code&gt;WARNING&lt;/code&gt;.</source>
          <target state="translated">로거가 작성되면 레벨은 &lt;code&gt;NOTSET&lt;/code&gt; 으로 설정됩니다 (로거가 루트 로거 일 때 모든 메시지가 처리되거나 로거가 루트 로거가 아닌 경우 부모에게 위임). 루트 로거는 &lt;code&gt;WARNING&lt;/code&gt; 레벨로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c121beda2f5083b1511f5b13c9899bd1d6ba9b6" translate="yes" xml:space="preserve">
          <source>When a module is reloaded, its dictionary (containing the module&amp;rsquo;s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module&amp;rsquo;s advantage if it maintains a global table or cache of objects &amp;mdash; with a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement it can test for the table&amp;rsquo;s presence and skip its initialization if desired:</source>
          <target state="translated">모듈을 다시로드하면 사전 (모듈의 전역 변수 포함)이 유지됩니다. 이름을 재정의하면 이전 정의가 재정의되므로 일반적으로 문제가되지 않습니다. 새 버전의 모듈에서 이전 버전으로 정의 된 이름을 정의하지 않으면 이전 정의가 그대로 유지됩니다. 이 기능은 전역 테이블 또는 객체 캐시를 유지하는 경우 모듈의 이점에 사용될 수 있습니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 문을 사용하면 테이블의 존재 여부를 테스트하고 원하는 경우 초기화를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102ecaca0081733892ac9c0922de0ed7ff3dd82f" translate="yes" xml:space="preserve">
          <source>When a process exits, it attempts to terminate all of its daemonic child processes.</source>
          <target state="translated">프로세스가 종료되면 모든 데몬 하위 프로세스를 종료하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f779be4e8bb9308b016d27968c5002b765b616cf" translate="yes" xml:space="preserve">
          <source>When a program outputs text, the result is determined by the corresponding output device. When IDLE executes user code, &lt;code&gt;sys.stdout&lt;/code&gt; and &lt;code&gt;sys.stderr&lt;/code&gt; are connected to the display area of IDLE&amp;rsquo;s Shell. Some of its features are inherited from the underlying Tk Text widget. Others are programmed additions. Where it matters, Shell is designed for development rather than production runs.</source>
          <target state="translated">프로그램이 텍스트를 출력 할 때 결과는 해당 출력 장치에 의해 결정됩니다. IDLE이 사용자 코드를 실행하면 &lt;code&gt;sys.stdout&lt;/code&gt; 및 &lt;code&gt;sys.stderr&lt;/code&gt; 이 IDLE 셸의 표시 영역에 연결됩니다. 그 기능 중 일부는 기본 Tk Text 위젯에서 상속됩니다. 다른 것은 프로그래밍 된 추가 사항입니다. 중요한 경우, Shell은 생산 작업이 아닌 개발 용으로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="5fe3fda7a7625ed5821ce75af517849bfdd0407e" translate="yes" xml:space="preserve">
          <source>When a sequence of two-element tuples is used as the &lt;em&gt;query&lt;/em&gt; argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter &lt;em&gt;doseq&lt;/em&gt; is evaluates to &lt;code&gt;True&lt;/code&gt;, individual &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.</source>
          <target state="translated">두 요소 튜플의 시퀀스가 &lt;em&gt;쿼리&lt;/em&gt; 인수 로 사용되는 경우 각 튜플의 첫 번째 요소는 키이고 두 번째 요소는 값입니다. 값 요소 자체는 시퀀스 일 수 있으며,이 경우 선택적 매개 변수 &lt;em&gt;doseq&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 평가되면 &lt;code&gt;key=value&lt;/code&gt; 에 대한 값 시퀀스의 각 요소에 대해 &lt;code&gt;'&amp;amp;'&lt;/code&gt; 로 구분 된 개별 키 = 값 쌍이 생성됩니다. 인코딩 된 문자열의 매개 변수 순서는 시퀀스의 매개 변수 튜플 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7b4f273f661846773d9602c6e5e1ab50f3c31c65" translate="yes" xml:space="preserve">
          <source>When a snapshot is taken, tracebacks of traces are limited to &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; frames. See the &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt;&lt;code&gt;take_snapshot()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">스냅 샷이 작성되면 추적 추적이 &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt; 프레임으로 제한됩니다 . &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt; &lt;code&gt;take_snapshot()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0093f870eef1dbea47bfba379efd8c3efa29578" translate="yes" xml:space="preserve">
          <source>When a test needs to look more deeply into the warnings, rather than just checking whether or not they occurred, code like this can be used:</source>
          <target state="translated">테스트가 단순히 발생했는지 여부를 확인하는 것보다 경고를 더 자세히 조사해야하는 경우 다음과 같은 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace6e48a34ddec70b997e7ed4ef30cd1200e48dd" translate="yes" xml:space="preserve">
          <source>When a tuple is returned, it must be between two and six items long. Optional items can either be omitted, or &lt;code&gt;None&lt;/code&gt; can be provided as their value. The semantics of each item are in order:</source>
          <target state="translated">튜플이 반환되면 길이는 2-6 개의 항목이어야합니다. 선택적 항목을 생략하거나 값으로 &lt;code&gt;None&lt;/code&gt; 을 제공 할 수 있습니다. 각 항목의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e91619aaae63d9b1d57efcb79896aa3fdd3e043" translate="yes" xml:space="preserve">
          <source>When a tuple with an incorrect length is passed to a function expecting a &lt;a href=&quot;#time.struct_time&quot;&gt;&lt;code&gt;struct_time&lt;/code&gt;&lt;/a&gt;, or having elements of the wrong type, a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">길이가 잘못된 튜플이 &lt;a href=&quot;#time.struct_time&quot;&gt; &lt;code&gt;struct_time&lt;/code&gt; 을&lt;/a&gt; 예상 하거나 잘못된 유형의 요소 가있는 함수에 전달 되면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="122b5a9e98f973011f8c23604c35ee0744f01180" translate="yes" xml:space="preserve">
          <source>When a virtual environment is active (i.e., the virtual environment&amp;rsquo;s Python interpreter is running), the attributes &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt;&lt;code&gt;sys.exec_prefix&lt;/code&gt;&lt;/a&gt; point to the base directory of the virtual environment, whereas &lt;a href=&quot;sys#sys.base_prefix&quot;&gt;&lt;code&gt;sys.base_prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt;&lt;code&gt;sys.base_exec_prefix&lt;/code&gt;&lt;/a&gt; point to the non-virtual environment Python installation which was used to create the virtual environment. If a virtual environment is not active, then &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;sys#sys.base_prefix&quot;&gt;&lt;code&gt;sys.base_prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt;&lt;code&gt;sys.exec_prefix&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt;&lt;code&gt;sys.base_exec_prefix&lt;/code&gt;&lt;/a&gt; (they all point to a non-virtual environment Python installation).</source>
          <target state="translated">가상 환경이 활성화 된 경우 (즉, 가상 환경의 Python 인터프리터가 실행중인 경우) &lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt; &lt;code&gt;sys.exec_prefix&lt;/code&gt; &lt;/a&gt; 속성 은 가상 환경의 기본 디렉토리를 가리키고 &lt;a href=&quot;sys#sys.base_prefix&quot;&gt; &lt;code&gt;sys.base_prefix&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt; &lt;code&gt;sys.base_exec_prefix&lt;/code&gt; &lt;/a&gt; 는 비 환경을 가리 킵니다. 가상 환경 가상 환경을 만드는 데 사용 된 Python 설치. 가상 환경이 활성화되어 있지 않은 경우 &lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;sys#sys.base_prefix&quot;&gt; &lt;code&gt;sys.base_prefix&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt; &lt;code&gt;sys.exec_prefix&lt;/code&gt; &lt;/a&gt; 는 sys.base_exec_prefix 와 &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt; &lt;code&gt;sys.base_exec_prefix&lt;/code&gt; &lt;/a&gt; (모두 비가 상 환경 Python 설치 를 가리킴 ).</target>
        </trans-unit>
        <trans-unit id="49099fe8787d9b66d249172b5b8c16fae8d8776e" translate="yes" xml:space="preserve">
          <source>When a virtual environment is active, any options that change the installation path will be ignored from all &lt;a href=&quot;distutils#module-distutils&quot;&gt;&lt;code&gt;distutils&lt;/code&gt;&lt;/a&gt; configuration files to prevent projects being inadvertently installed outside of the virtual environment.</source>
          <target state="translated">가상 환경이 활성화되면 프로젝트가 가상 환경 외부에 실수로 설치되지 않도록 설치 경로를 변경하는 모든 옵션이 모든 &lt;a href=&quot;distutils#module-distutils&quot;&gt; &lt;code&gt;distutils&lt;/code&gt; &lt;/a&gt; 구성 파일 에서 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="e73006af8303cac324a6bee6ebfb9a71386816b0" translate="yes" xml:space="preserve">
          <source>When activated, code entered in the Shell or run from an Editor will run under the debugger. In the Editor, breakpoints can be set with the context menu. This feature is still incomplete and somewhat experimental.</source>
          <target state="translated">활성화되면 셸에 입력되거나 편집기에서 실행 된 코드가 디버거에서 실행됩니다. 편집기에서 상황에 맞는 메뉴를 사용하여 중단 점을 설정할 수 있습니다. 이 기능은 여전히 ​​불완전하고 다소 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="cbdd2a51e4781c318a7a1a81e4c3eb4ba6ae291d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="ddc891f4c25b8225fd0001cdae26af6639e7537e" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="e46ed5b47728cdf79b8e4b0ea7954bf28bac75b9" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X-상태&lt;/em&gt; 헤더는 생략하고 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="e173b2ac8c61d6fbcc0ffb178a6f5c0aa5074e9e" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4a95e85d749bc7be23343bcb5277621335a1948d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, a &amp;ldquo;From &amp;rdquo; line is generated based upon the &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s delivery date, and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스 (A)는 라인 &quot;에서&quot;를 기반으로 생성되는 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스의 납기, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="e255b577d6bbc86290e4f9d517b3ffbe62bbaae4" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="10d8c3d31070cdae2a2783c0d5f2693fbf078f89" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance, the &amp;ldquo;From &amp;rdquo; line is copied and all flags directly correspond:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 라인이 복사되고 모든 플래그가 직접 대응 &quot;에서&quot;</target>
        </trans-unit>
        <trans-unit id="286e3f12905a38714edf02bf122a3f8052a6268d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4c4296d06ab3b5a40fe3f89cb3f43ef0aef304f8" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, a &amp;ldquo;From &amp;rdquo; line is generated based upon the &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s delivery date, and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스 (A)는 라인 &quot;에서&quot;를 기반으로 생성되는 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스의 납기, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4d0342e5504d800d945bf2084fb63194683176ac" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="d9ae3b18f623ec44c4c53a80c85290adab2b1644" translate="yes" xml:space="preserve">
          <source>When an array object is printed or converted to a string, it is represented as &lt;code&gt;array(typecode, initializer)&lt;/code&gt;. The &lt;em&gt;initializer&lt;/em&gt; is omitted if the array is empty, otherwise it is a string if the &lt;em&gt;typecode&lt;/em&gt; is &lt;code&gt;'u'&lt;/code&gt;, otherwise it is a list of numbers. The string is guaranteed to be able to be converted back to an array with the same type and value using &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;, so long as the &lt;a href=&quot;#array.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; class has been imported using &lt;code&gt;from array import array&lt;/code&gt;. Examples:</source>
          <target state="translated">배열 객체가 인쇄되거나 문자열로 변환되면 &lt;code&gt;array(typecode, initializer)&lt;/code&gt; 됩니다. &lt;em&gt;이니셜&lt;/em&gt; 어레이가 비어 있으면, 그렇지 않으면 그 캐릭터가 생략 &lt;em&gt;타입 코드가&lt;/em&gt; 인 &lt;code&gt;'u'&lt;/code&gt; 그렇지 않으면 번호의 목록이다. 문자열은 동일한 유형 및 값 사용에 배열 변환 돌아올 수 있도록 보장 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 너무 오래로, &lt;a href=&quot;#array.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 클래스가 가져온 사용하여 &lt;code&gt;from array import array&lt;/code&gt; . 예 :</target>
        </trans-unit>
        <trans-unit id="e57a24f717690d606e0285653c2532690dac8586" translate="yes" xml:space="preserve">
          <source>When an auditing event is raised through the &lt;a href=&quot;#sys.audit&quot;&gt;&lt;code&gt;sys.audit()&lt;/code&gt;&lt;/a&gt; function, each hook will be called in the order it was added with the event name and the tuple of arguments. Native hooks added by &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt;&lt;code&gt;PySys_AddAuditHook()&lt;/code&gt;&lt;/a&gt; are called first, followed by hooks added in the current interpreter.</source>
          <target state="translated">&lt;a href=&quot;#sys.audit&quot;&gt; &lt;code&gt;sys.audit()&lt;/code&gt; &lt;/a&gt; 함수를 통해 감사 이벤트가 발생 하면 각 후크는 이벤트 이름 및 인수 튜플과 함께 추가 된 순서대로 호출됩니다. &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt; &lt;code&gt;PySys_AddAuditHook()&lt;/code&gt; &lt;/a&gt; 에 의해 추가 된 기본 후크 가 먼저 호출 된 후 현재 인터프리터에 추가 된 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a060e94770f6ada605adcbe7b40294d9f24ee084" translate="yes" xml:space="preserve">
          <source>When an exception is raised and uncaught, the interpreter calls &lt;code&gt;sys.excepthook&lt;/code&gt; with three arguments, the exception class, exception instance, and a traceback object. In an interactive session this happens just before control is returned to the prompt; in a Python program this happens just before the program exits. The handling of such top-level exceptions can be customized by assigning another three-argument function to &lt;code&gt;sys.excepthook&lt;/code&gt;.</source>
          <target state="translated">예외가 발생하여 포착되지 않으면 인터프리터는 세 개의 인수, 예외 클래스, 예외 인스턴스 및 추적 백 오브젝트와 함께 &lt;code&gt;sys.excepthook&lt;/code&gt; 을 호출 합니다. 대화식 세션에서는 제어가 프롬프트로 리턴되기 직전에 발생합니다. 파이썬 프로그램에서 이것은 프로그램이 종료되기 직전에 발생합니다. 이러한 최상위 예외 처리는 &lt;code&gt;sys.excepthook&lt;/code&gt; 에 다른 3 개의 인수 함수를 할당하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98cb90ca3fe9c876d8490b4b2d59b0b2fc0154fc" translate="yes" xml:space="preserve">
          <source>When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt;&lt;code&gt;signal.ITIMER_REAL&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGALRM&lt;/code&gt;, &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt;&lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt;&lt;/a&gt; sends &lt;code&gt;SIGVTALRM&lt;/code&gt;, and &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt;&lt;code&gt;signal.ITIMER_PROF&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGPROF&lt;/code&gt;.</source>
          <target state="translated">인터벌 타이머가 작동하면 신호가 프로세스로 전송됩니다. 전송되는 신호는 사용중인 타이머에 따라 다릅니다. &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt; &lt;code&gt;signal.ITIMER_REAL&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;SIGALRM&lt;/code&gt; 을 전달 하고 &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt; &lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;SIGVTALRM&lt;/code&gt; 을 전송 하며 &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt; &lt;code&gt;signal.ITIMER_PROF&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;SIGPROF&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="d729011a0caf801b2d3090cac48b85a3ba68cf73" translate="yes" xml:space="preserve">
          <source>When an object is put on a queue, the object is pickled and a background thread later flushes the pickled data to an underlying pipe. This has some consequences which are a little surprising, but should not cause any practical difficulties &amp;ndash; if they really bother you then you can instead use a queue created with a &lt;a href=&quot;#multiprocessing-managers&quot;&gt;manager&lt;/a&gt;.</source>
          <target state="translated">객체가 대기열에 놓이면 객체가 피클되고 백그라운드 스레드가 나중에 피클 된 데이터를 기본 파이프로 플러시합니다. 이것은 약간 놀라운 결과이지만 실제적으로 어려움을 겪지 않아야합니다. 만약 실제로 귀찮게한다면 대신 &lt;a href=&quot;#multiprocessing-managers&quot;&gt;관리자로&lt;/a&gt; 만든 대기열을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46c6a7ab062a3f1ac7a1fa12015f2ab3e6c6e8ef" translate="yes" xml:space="preserve">
          <source>When an ordinary Python script raises an unhandled exception (for whatever reason: of a typo in a module name, a file that can&amp;rsquo;t be opened, etc.), the Python interpreter prints a nice traceback and exits. While the Python interpreter will still do this when your CGI script raises an exception, most likely the traceback will end up in one of the HTTP server&amp;rsquo;s log files, or be discarded altogether.</source>
          <target state="translated">일반적인 파이썬 스크립트가 처리되지 않은 예외 (어떤 이유로 모듈 이름의 오타, 열 수없는 파일 등)를 발생 시키면, 파이썬 인터프리터는 훌륭한 역 추적을 출력하고 종료합니다. Python 인터프리터는 CGI 스크립트에서 예외가 발생할 때 여전히이 작업을 수행하지만 대부분의 경우 역 추적이 HTTP 서버의 로그 파일 중 하나에서 발생하거나 완전히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b18b0dca198469e2e5821b568a8af8553f7137" translate="yes" xml:space="preserve">
          <source>When another &lt;em&gt;operation&lt;/em&gt; is given, it must be a &amp;ldquo;command verb&amp;rdquo; that specifies what should be done with the file. Common verbs documented by Microsoft are &lt;code&gt;'print'&lt;/code&gt; and &lt;code&gt;'edit'&lt;/code&gt; (to be used on files) as well as &lt;code&gt;'explore'&lt;/code&gt; and &lt;code&gt;'find'&lt;/code&gt; (to be used on directories).</source>
          <target state="translated">다른 &lt;em&gt;작업&lt;/em&gt; 이 제공되면 파일로 수행 할 작업을 지정하는 &quot;명령 동사&quot;여야합니다. Microsoft가 문서화 한 일반적인 동사는 &lt;code&gt;'print'&lt;/code&gt; 및 &lt;code&gt;'edit'&lt;/code&gt; (파일에 사용)과 &lt;code&gt;'explore'&lt;/code&gt; 및 &lt;code&gt;'find'&lt;/code&gt; (디렉토리에 사용)입니다.</target>
        </trans-unit>
        <trans-unit id="c4d9c23255dc7b8ca6f19ef5a940eb877d9642dd" translate="yes" xml:space="preserve">
          <source>When another data type is mixed in, the &lt;code&gt;value&lt;/code&gt; attribute is &lt;em&gt;not the same&lt;/em&gt; as the enum member itself, although it is equivalent and will compare equal.</source>
          <target state="translated">다른 데이터 타입이 혼합 될 때, &lt;code&gt;value&lt;/code&gt; 특성은 &lt;em&gt;동일하지&lt;/em&gt; 가 동일하며 동일한 비교한다하더라도, ENUM 부재 자체.</target>
        </trans-unit>
        <trans-unit id="782a74b6093e9a274767f8a985a07199d8c71046" translate="yes" xml:space="preserve">
          <source>When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt; method then that method is called to convert the argument to an integer before packing.</source>
          <target state="translated">정수 변환 코드 중 하나를 사용하여 정수가 아닌 팩을 패킹하려고 할 때, 정수가 아닌 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; 메소드가 있으면 해당 메소드가 호출되어 인수 전에 정수를 변환하여 팩킹합니다.</target>
        </trans-unit>
        <trans-unit id="38f8d78459f2077063513420c80633ee6ca35e36" translate="yes" xml:space="preserve">
          <source>When called as a program from the command line, the following form is used:</source>
          <target state="translated">명령 행에서 프로그램으로 호출되면 다음 형식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7774c1b19e4f3bda02017096fe4f300d221be9d7" translate="yes" xml:space="preserve">
          <source>When called with the entire population, this gives the population variance &amp;sigma;&amp;sup2;. When called on a sample instead, this is the biased sample variance s&amp;sup2;, also known as variance with N degrees of freedom.</source>
          <target state="translated">전체 모집단과 함께 호출하면 모집단 분산 &amp;sigma;&amp;sup2;가됩니다. 대신 샘플에서 호출 될 때 이것은 바이어스 된 샘플 분산 s&amp;sup2;이며 N 자유도의 분산이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="e1510a977d9eec8bae218f453f2180521adfa1a6" translate="yes" xml:space="preserve">
          <source>When called without arguments this function removes the control-c handler if it has been installed. This function can also be used as a test decorator to temporarily remove the handler while the test is being executed:</source>
          <target state="translated">인수없이 호출되면이 함수는 control-c 핸들러가 설치된 경우이를 제거합니다. 이 함수는 테스트가 실행되는 동안 핸들러를 일시적으로 제거하기 위해 테스트 데코레이터로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68b31def5bdc28465822c89803310f8ec7825150" translate="yes" xml:space="preserve">
          <source>When called, the generic function dispatches on the type of the first argument:</source>
          <target state="translated">호출되면 일반 함수는 첫 번째 인수의 유형을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="49f7a0d990e54e7e4ff423f9bcf931e35657cbac" translate="yes" xml:space="preserve">
          <source>When calling the &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; constructor directly, &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; is the default. Since it does not authenticate the other peer, it can be insecure, especially in client mode where most of time you would like to ensure the authenticity of the server you&amp;rsquo;re talking to. Therefore, when in client mode, it is highly recommended to use &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;. However, it is in itself not sufficient; you also have to check that the server certificate, which can be obtained by calling &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt;&lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt;&lt;/a&gt;, matches the desired service. For many protocols and applications, the service can be identified by the hostname; in this case, the &lt;a href=&quot;#ssl.match_hostname&quot;&gt;&lt;code&gt;match_hostname()&lt;/code&gt;&lt;/a&gt; function can be used. This common check is automatically performed when &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;SSLContext.check_hostname&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 생성자를 직접 호출 할 때 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; 이 기본값입니다. 다른 피어를 인증하지 않으므로 특히 대화하는 서버의 신뢰성을 보장하려는 대부분의 클라이언트 모드에서는 안전하지 않을 수 있습니다. 따라서 클라이언트 모드에서는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 . 그러나 그 자체로는 충분하지 않습니다. &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt; &lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt; &lt;/a&gt; 를 호출하여 얻을 수있는 서버 인증서 가 원하는 서비스와 일치 하는지 확인해야합니다 . 많은 프로토콜과 응용 프로그램의 경우 호스트 이름으로 서비스를 식별 할 수 있습니다. 이 경우 &lt;a href=&quot;#ssl.match_hostname&quot;&gt; &lt;code&gt;match_hostname()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다. 이 공통 점검은 자동으로 수행됩니다&lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;SSLContext.check_hostname&lt;/code&gt; &lt;/a&gt; 이 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4dc40bbe639d96f637bd93855f1791e60c735e90" translate="yes" xml:space="preserve">
          <source>When calling with the two argument form you omit the replacement object, and a mock is created for you and passed in as an extra argument to the decorated function:</source>
          <target state="translated">두 개의 인수 형식으로 호출하면 대체 객체가 생략되고 모의 객체가 만들어져 장식 된 함수에 대한 추가 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="18e0548d845776f7d9fb1bb48334763d7bb375ac" translate="yes" xml:space="preserve">
          <source>When compared to &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, this object lacks the following features:</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 과 비교할 때이 객체에는 다음 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="856a45270239471af6c5f0a357260107cdc44d90" translate="yes" xml:space="preserve">
          <source>When comparing the output of &lt;a href=&quot;#hmac.HMAC.hexdigest&quot;&gt;&lt;code&gt;hexdigest()&lt;/code&gt;&lt;/a&gt; to an externally-supplied digest during a verification routine, it is recommended to use the &lt;a href=&quot;#hmac.compare_digest&quot;&gt;&lt;code&gt;compare_digest()&lt;/code&gt;&lt;/a&gt; function instead of the &lt;code&gt;==&lt;/code&gt; operator to reduce the vulnerability to timing attacks.</source>
          <target state="translated">확인 루틴 동안 &lt;a href=&quot;#hmac.HMAC.hexdigest&quot;&gt; &lt;code&gt;hexdigest()&lt;/code&gt; &lt;/a&gt; 의 출력을 외부 제공 다이제스트와 &lt;a href=&quot;#hmac.compare_digest&quot;&gt; &lt;code&gt;compare_digest()&lt;/code&gt; &lt;/a&gt; 때 타이밍 공격에 대한 취약성을 줄이기 위해 &lt;code&gt;==&lt;/code&gt; 연산자 대신 compare_digest () 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="92028d8951df45be6cbda2380b77dd7080678d69" translate="yes" xml:space="preserve">
          <source>When comparing the output of &lt;a href=&quot;#hmac.digest&quot;&gt;&lt;code&gt;digest()&lt;/code&gt;&lt;/a&gt; to an externally-supplied digest during a verification routine, it is recommended to use the &lt;a href=&quot;#hmac.compare_digest&quot;&gt;&lt;code&gt;compare_digest()&lt;/code&gt;&lt;/a&gt; function instead of the &lt;code&gt;==&lt;/code&gt; operator to reduce the vulnerability to timing attacks.</source>
          <target state="translated">검증 루틴 동안 &lt;a href=&quot;#hmac.digest&quot;&gt; &lt;code&gt;digest()&lt;/code&gt; &lt;/a&gt; 의 출력을 외부 제공 다이제스트와 &lt;a href=&quot;#hmac.compare_digest&quot;&gt; &lt;code&gt;compare_digest()&lt;/code&gt; &lt;/a&gt; 때 타이밍 공격에 대한 취약성을 줄이기 위해 &lt;code&gt;==&lt;/code&gt; 연산자 대신 compare_digest () 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cc34f0feb28081050c116e0b782b908cc2cd4bfa" translate="yes" xml:space="preserve">
          <source>When comparing unions, the argument order is ignored, e.g.:</source>
          <target state="translated">공용체를 비교할 때 인수 순서는 무시됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ed05a329db63e10d1f8fb992f1545e7cd8c147c7" translate="yes" xml:space="preserve">
          <source>When compiling a string with multi-line code in &lt;code&gt;'single'&lt;/code&gt; or &lt;code&gt;'eval'&lt;/code&gt; mode, input must be terminated by at least one newline character. This is to facilitate detection of incomplete and complete statements in the &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;'single'&lt;/code&gt; 또는 &lt;code&gt;'eval'&lt;/code&gt; 모드 에서 여러 줄 코드로 문자열을 컴파일 할 때 입력은 하나 이상의 줄 바꿈 문자로 끝나야합니다. 이는 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 모듈 에서 불완전하고 완전한 문장을 쉽게 감지 할 수 있도록하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="696dab8a84aeff4c3a2e883a2314face9ba4d539" translate="yes" xml:space="preserve">
          <source>When computing the next rollover time for the first time (when the handler is created), the last modification time of an existing log file, or else the current time, is used to compute when the next rotation will occur.</source>
          <target state="translated">다음 롤오버 시간을 처음 계산할 때 (핸들러가 생성 될 때) 기존 로그 파일의 마지막 수정 시간 또는 현재 시간은 다음 회전이 발생할시기를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d884d8babe5a567edcfd0ea18f46faab02d32494" translate="yes" xml:space="preserve">
          <source>When connected, &lt;a href=&quot;#nntplib.NNTP&quot;&gt;&lt;code&gt;NNTP&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#nntplib.NNTP_SSL&quot;&gt;&lt;code&gt;NNTP_SSL&lt;/code&gt;&lt;/a&gt; objects support the following methods and attributes.</source>
          <target state="translated">연결되면 &lt;a href=&quot;#nntplib.NNTP&quot;&gt; &lt;code&gt;NNTP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#nntplib.NNTP_SSL&quot;&gt; &lt;code&gt;NNTP_SSL&lt;/code&gt; &lt;/a&gt; 객체는 다음 방법과 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="060ff3bcb23f907c12e71640fb12cf92d2d0e3e5" translate="yes" xml:space="preserve">
          <source>When converting from a string, the string must not contain whitespace around the central &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; operator. For example, &lt;code&gt;complex('1+2j')&lt;/code&gt; is fine, but &lt;code&gt;complex('1 + 2j')&lt;/code&gt; raises &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열에서 변환 할 때 문자열에는 중앙 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 연산자 주위에 공백이 없어야합니다 . 예를 들어, &lt;code&gt;complex('1+2j')&lt;/code&gt; 좋지만 &lt;code&gt;complex('1 + 2j')&lt;/code&gt; 상승 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6c5e5ce837c0e22ffcd56a47571a9b383672bcb" translate="yes" xml:space="preserve">
          <source>When copying an existing archive, file objects supplied only need &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;readline&lt;/code&gt;, or &lt;code&gt;write&lt;/code&gt; methods. When creating an archive from a directory, if the target is a file object it will be passed to the &lt;code&gt;zipfile.ZipFile&lt;/code&gt; class, and must supply the methods needed by that class.</source>
          <target state="translated">기존 아카이브를 복사 할 때 제공된 파일 오브젝트에는 &lt;code&gt;read&lt;/code&gt; 및 &lt;code&gt;readline&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 메소드 만 필요 합니다. 디렉토리에서 아카이브를 작성할 때 대상이 파일 오브젝트 인 경우 &lt;code&gt;zipfile.ZipFile&lt;/code&gt; 클래스 로 전달 되며 해당 클래스에 필요한 메소드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="62f08dfe8f53d7f93ca2ca215d1e0ef6f39c519e" translate="yes" xml:space="preserve">
          <source>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: &lt;code&gt;(start + step * i
for i in count())&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;(start + step * i for i in count())&lt;/code&gt; 와 같은 곱셈 코드를 대체하여 정확도를 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a51eebc4aef573b36497fe8c2650ded21d78cac" translate="yes" xml:space="preserve">
          <source>When creating &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; objects from scratch, you often need to encode the payloads for transport through compliant mail servers. This is especially true for &lt;em&gt;image/*&lt;/em&gt; and &lt;em&gt;text/*&lt;/em&gt; type messages containing binary data.</source>
          <target state="translated">&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체를 처음부터 만들 때 종종 호환 메일 서버를 통한 전송을 위해 페이로드를 인코딩해야합니다. 이진 데이터가 포함 된 &lt;em&gt;image / *&lt;/em&gt; 및 &lt;em&gt;text / *&lt;/em&gt; 유형 메시지의 경우 특히 그렇습니다 .</target>
        </trans-unit>
        <trans-unit id="a423c248f1413b6e1e0f4f3faa51f5f733b512cd" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;DateHeader&lt;/code&gt;, &lt;em&gt;value&lt;/em&gt; may be &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance. This means, for example, that the following code is valid and does what one would expect:</source>
          <target state="translated">작성할 때 &lt;code&gt;DateHeader&lt;/code&gt; , &lt;em&gt;값이&lt;/em&gt; 될 수 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스. 예를 들어, 다음 코드가 유효하고 기대하는 것을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a4db0b5c5393d0800539c706fee74aab4223e2df" translate="yes" xml:space="preserve">
          <source>When creating a breakpoint, its associated filename should be in canonical form. If a &lt;em&gt;funcname&lt;/em&gt; is defined, a breakpoint hit will be counted when the first line of that function is executed. A conditional breakpoint always counts a hit.</source>
          <target state="translated">중단 점을 만들 때 관련된 파일 이름은 정식 형식이어야합니다. 경우 &lt;em&gt;funcname에이&lt;/em&gt; 정의됨을 함수의 첫 번째 행이 실행되면, 브레이크 포인트의 히트를 카운트한다. 조건부 중단 점은 항상 적중을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="672bf0c86c2581afe64984ce3a00746c2792ef5c" translate="yes" xml:space="preserve">
          <source>When creating new WSGI application objects, frameworks, servers, or middleware, it can be useful to validate the new code&amp;rsquo;s conformance using &lt;a href=&quot;#module-wsgiref.validate&quot;&gt;&lt;code&gt;wsgiref.validate&lt;/code&gt;&lt;/a&gt;. This module provides a function that creates WSGI application objects that validate communications between a WSGI server or gateway and a WSGI application object, to check both sides for protocol conformance.</source>
          <target state="translated">새 WSGI 애플리케이션 오브젝트, 프레임 워크, 서버 또는 미들웨어를 작성할 때 &lt;a href=&quot;#module-wsgiref.validate&quot;&gt; &lt;code&gt;wsgiref.validate&lt;/code&gt; 를&lt;/a&gt; 사용하여 새 코드의 적합성을 검증하는 것이 유용 할 수 있습니다 . 이 모듈은 WSGI 서버 또는 게이트웨이와 WSGI 응용 프로그램 개체 간의 통신을 확인하여 프로토콜 적합성을 확인하는 WSGI 응용 프로그램 개체를 만드는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e5bb3321cca6ff1fb46c71f838479a459fa1e5d" translate="yes" xml:space="preserve">
          <source>When decompressing a stream, the window size must not be smaller than the size originally used to compress the stream; using a too-small value may result in an &lt;a href=&quot;#zlib.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; exception. The default &lt;em&gt;wbits&lt;/em&gt; value corresponds to the largest window size and requires a zlib header and trailer to be included.</source>
          <target state="translated">스트림을 압축 해제 할 때 창 크기는 스트림을 압축하는 데 원래 사용 된 크기보다 작아서는 안됩니다. 너무 작은 값을 사용하면 &lt;a href=&quot;#zlib.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 예외 가 발생할 수 있습니다 . 기본 &lt;em&gt;wbits&lt;/em&gt; 값은 가장 큰 창 크기에 해당하며 zlib 헤더와 트레일러를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d74f26e8d112aef4595ce1a87bdb3b198f7b5e3" translate="yes" xml:space="preserve">
          <source>When decompressing, the value of the last modification time field in the most recently read header may be read from this attribute, as an integer. The initial value before reading any headers is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">압축을 풀 때 가장 최근에 읽은 헤더의 마지막 수정 시간 필드 값을 정수로이 속성에서 읽을 수 있습니다. 헤더를 읽기 전의 초기 값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02833f75f25f075b18c22a28c5aa2ba25a8444fc" translate="yes" xml:space="preserve">
          <source>When each key is encountered for the first time, it is not already in the mapping; so an entry is automatically created using the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; function which returns an empty &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;list.append()&lt;/code&gt; operation then attaches the value to the new list. When keys are encountered again, the look-up proceeds normally (returning the list for that key) and the &lt;code&gt;list.append()&lt;/code&gt; operation adds another value to the list. This technique is simpler and faster than an equivalent technique using &lt;a href=&quot;stdtypes#dict.setdefault&quot;&gt;&lt;code&gt;dict.setdefault()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">각 키가 처음 발견되면 아직 맵핑에 있지 않은 것입니다. 따라서 빈 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 을 리턴하는 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 항목이 자동으로 작성 됩니다 . &lt;code&gt;list.append()&lt;/code&gt; 연산은 다음의 새로운리스트에 값을 첨부. 키가 다시 발생하면 조회가 정상적으로 진행되고 (해당 키의 목록을 반환) &lt;code&gt;list.append()&lt;/code&gt; 작업이 다른 값을 목록에 추가합니다. 이 기술은 &lt;a href=&quot;stdtypes#dict.setdefault&quot;&gt; &lt;code&gt;dict.setdefault()&lt;/code&gt; &lt;/a&gt; 사용하는 동등한 기술보다 간단하고 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="9887fe8e3c1a8945458c737be092d9fc035304db" translate="yes" xml:space="preserve">
          <source>When enabled on client-side sockets, the client signals the server that it supports post-handshake authentication.</source>
          <target state="translated">클라이언트 측 소켓에서 활성화되면 클라이언트는 서버에게 핸드 셰이크 후 인증을 지원한다는 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4b197cf7dc7faf88b3cb2e54d710a0d303daee67" translate="yes" xml:space="preserve">
          <source>When enabled on server-side sockets, &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;SSLContext.verify_mode&lt;/code&gt;&lt;/a&gt; must be set to &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;, too. The actual client cert exchange is delayed until &lt;a href=&quot;#ssl.SSLSocket.verify_client_post_handshake&quot;&gt;&lt;code&gt;SSLSocket.verify_client_post_handshake()&lt;/code&gt;&lt;/a&gt; is called and some I/O is performed.</source>
          <target state="translated">서버 측 소켓에서 사용 가능한 경우 &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;SSLContext.verify_mode&lt;/code&gt; 도&lt;/a&gt;&lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 로 설정해야합니다 . 실제 클라이언트 인증서 교환은 &lt;a href=&quot;#ssl.SSLSocket.verify_client_post_handshake&quot;&gt; &lt;code&gt;SSLSocket.verify_client_post_handshake()&lt;/code&gt; &lt;/a&gt; 가 호출되고 일부 I / O가 수행 될 때까지 지연 됩니다.</target>
        </trans-unit>
        <trans-unit id="a621755ca7f41470229f75442067ad0d1c20faff" translate="yes" xml:space="preserve">
          <source>When encountering a &lt;code&gt;multipart/related&lt;/code&gt;, check the &lt;code&gt;start&lt;/code&gt; parameter and if a part with a matching &lt;em&gt;Content-ID&lt;/em&gt; is found, consider only it when looking for candidate matches. Otherwise consider only the first (default root) part of the &lt;code&gt;multipart/related&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;multipart/related&lt;/code&gt; 를 발견 하면 &lt;code&gt;start&lt;/code&gt; 매개 변수를 확인하고 일치하는 &lt;em&gt;Content-ID를&lt;/em&gt; 가진 부품을 찾으면 후보 일치를 찾을 때만 고려하십시오. 그렇지 않으면 &lt;code&gt;multipart/related&lt;/code&gt; 의 첫 번째 (기본 루트) 부분 만 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="d720d1be1de6b788b045c550171b49ace0d34e71" translate="yes" xml:space="preserve">
          <source>When executed without arguments &lt;a href=&quot;#unittest-test-discovery&quot;&gt;Test Discovery&lt;/a&gt; is started:</source>
          <target state="translated">인수없이 실행하면 &lt;a href=&quot;#unittest-test-discovery&quot;&gt;Test Discovery&lt;/a&gt; 가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f5758875cf66a5a33444f0562ccc5e99c8db03" translate="yes" xml:space="preserve">
          <source>When first created the logger has level &lt;code&gt;logging.NOTSET&lt;/code&gt; and no default handler. Messages sent to this logger will not by default propagate to the root logger.</source>
          <target state="translated">처음 작성된 로거에는 레벨 &lt;code&gt;logging.NOTSET&lt;/code&gt; 이 있으며 기본 핸들러는 없습니다. 이 로거로 전송 된 메시지는 기본적으로 루트 로거로 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69309127fb83429d8269e5e345250adcff5991bf" translate="yes" xml:space="preserve">
          <source>When formatting a number (&lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt; and subclasses) with the &lt;code&gt;n&lt;/code&gt; type (ex: &lt;code&gt;'{:n}'.format(1234)&lt;/code&gt;), the function temporarily sets the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale to the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale to decode &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt; fields of &lt;code&gt;localeconv()&lt;/code&gt; if they are non-ASCII or longer than 1 byte, and the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale is different than the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale. This temporary change affects other threads.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 유형 (예 : &lt;code&gt;'{:n}'.format(1234)&lt;/code&gt; ) 으로 숫자 ( &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; 및 서브 클래스)를 형식화 할 때이 함수는 일시적으로 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일을 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일로 설정하여 디코딩합니다. &lt;code&gt;localeconv()&lt;/code&gt; 의 &lt;code&gt;decimal_point&lt;/code&gt; 및 &lt;code&gt;thousands_sep&lt;/code&gt; 필드는 ASCII가 아니거나 1 바이트보다 길고 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로캘이 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로캘 과 다른 경우 입니다. 이 임시 변경은 다른 스레드에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0c6c0444904253e2eedbaa36573956718aa2948c" translate="yes" xml:space="preserve">
          <source>When generating annotated listings, mark lines which were not executed with &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">주석이 달린 리스팅을 생성 할 때 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 실행되지 않은 라인을 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="be8e8b32da74a37571c34b0e9517346b53020b30" translate="yes" xml:space="preserve">
          <source>When identifying things (such as host names) in the internet, it is often necessary to compare such identifications for &amp;ldquo;equality&amp;rdquo;. Exactly how this comparison is executed may depend on the application domain, e.g. whether it should be case-insensitive or not. It may be also necessary to restrict the possible identifications, to allow only identifications consisting of &amp;ldquo;printable&amp;rdquo; characters.</source>
          <target state="translated">인터넷에서 사물 (예 : 호스트 이름)을 식별 할 때 이러한 식별을 &quot;평등&quot;과 비교해야하는 경우가 종종 있습니다. 이 비교가 정확히 어떻게 수행되는지는 애플리케이션 도메인에 따라 다를 수 있습니다 (예 : 대소 문자를 구분하지 않아야하는지). &amp;ldquo;인쇄 가능한&amp;rdquo;문자로 구성된 식별 만 허용하기 위해 가능한 식별을 제한해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e7e37fe6162273e5e4281cf61c42ffd2d46e957" translate="yes" xml:space="preserve">
          <source>When implementing coroutine schedulers and for other advanced uses of generators, it is useful to determine whether a generator is currently executing, is waiting to start or resume or execution, or has already terminated. &lt;a href=&quot;#inspect.getgeneratorstate&quot;&gt;&lt;code&gt;getgeneratorstate()&lt;/code&gt;&lt;/a&gt; allows the current state of a generator to be determined easily.</source>
          <target state="translated">코 루틴 스케줄러를 구현하고 기타 고급 생성기를 사용하는 경우 생성기가 현재 실행 중인지, 시작 또는 재개 또는 실행 대기 중인지 또는 이미 종료되었는지 여부를 판별하는 것이 유용합니다. &lt;a href=&quot;#inspect.getgeneratorstate&quot;&gt; &lt;code&gt;getgeneratorstate()&lt;/code&gt; &lt;/a&gt; 사용하면 생성기의 현재 상태를 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5376e91d28fee3241c94e60ac21eaf1934266aa4" translate="yes" xml:space="preserve">
          <source>When in non-blocking mode, a &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; is raised if the data needed to be written to the raw stream but it couldn&amp;rsquo;t accept all the data without blocking.</source>
          <target state="translated">비 차단 모드 에서 데이터를 원시 스트림에 기록해야하지만 차단하지 않고 모든 데이터를 받아 들일 수없는 경우 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="949c191a2b89d062d5cb3c84d7a255f7ab9b1114" translate="yes" xml:space="preserve">
          <source>When inheriting from &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; for threaded connection behavior, you should explicitly declare how you want your threads to behave on an abrupt shutdown. The &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; class defines an attribute &lt;em&gt;daemon_threads&lt;/em&gt;, which indicates whether or not the server should wait for thread termination. You should set the flag explicitly if you would like threads to behave autonomously; the default is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, meaning that Python will not exit until all threads created by &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; have exited.</source>
          <target state="translated">스레드 연결 동작을 위해 &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt; 에서 상속 할 때 갑작스러운 종료시 스레드 작동 방식을 명시 적으로 선언해야합니다. &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; 의&lt;/a&gt; 클래스는 속성 정의 &lt;em&gt;daemon_threads&lt;/em&gt; 서버가 스레드 종료를 기다릴 것인지 여부를 나타냅니다. 스레드가 자율적으로 동작하게하려면 플래그를 명시 적으로 설정해야합니다. 기본값은 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 입니다&lt;/a&gt; . 이는 &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 모든 스레드가 종료 될 때까지 Python이 종료되지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0c4ce52ce81abe52a94c5ca1b4e84054f0c345e6" translate="yes" xml:space="preserve">
          <source>When inheriting from generic classes, some type variables could be fixed:</source>
          <target state="translated">일반 클래스에서 상속 할 때 일부 유형 변수가 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d57a9f5d007446cdead859ca66e2d6075df536d" translate="yes" xml:space="preserve">
          <source>When instantiated, &lt;em&gt;msg&lt;/em&gt; should be a human-readable description of the error. The optional &lt;em&gt;exception&lt;/em&gt; parameter, if given, should be &lt;code&gt;None&lt;/code&gt; or an exception that was caught by the parsing code and is being passed along as information.</source>
          <target state="translated">인스턴스화 될 때 &lt;em&gt;msg&lt;/em&gt; 는 사람이 읽을 수있는 오류에 대한 설명이어야합니다. 선택적인 &lt;em&gt;예외&lt;/em&gt; 매개 변수 (제공된 경우)는 &lt;code&gt;None&lt;/code&gt; 또는 구문 분석 코드에 의해 포착되어 정보로 전달되는 예외 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a44c954d6ff4db8ecacb3e811d6941f43087b96" translate="yes" xml:space="preserve">
          <source>When interactive, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; streams are line-buffered. Otherwise, they are block-buffered like regular text files. You can override this value with the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-u&quot;&gt;&lt;code&gt;-u&lt;/code&gt;&lt;/a&gt; command-line option.</source>
          <target state="translated">대화식 일 때 &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 스트림은 라인 버퍼링됩니다. 그렇지 않으면 일반 텍스트 파일처럼 차단됩니다. &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-u&quot;&gt; &lt;code&gt;-u&lt;/code&gt; &lt;/a&gt; 명령 행 옵션 으로이 값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="995afee8f4fa71b9b054d20a6203385ccf1bd50f" translate="yes" xml:space="preserve">
          <source>When invoked as a script, pdb will automatically enter post-mortem debugging if the program being debugged exits abnormally. After post-mortem debugging (or after normal exit of the program), pdb will restart the program. Automatic restarting preserves pdb&amp;rsquo;s state (such as breakpoints) and in most cases is more useful than quitting the debugger upon program&amp;rsquo;s exit.</source>
          <target state="translated">스크립트로 호출 될 때 pdb는 디버깅중인 프로그램이 비정상적으로 종료되면 사후 디버깅에 자동으로 들어갑니다. 사후 디버깅 후 (또는 프로그램이 정상적으로 종료 된 후) pdb는 프로그램을 다시 시작합니다. 자동 재시작은 pdb의 상태 (예 : 중단 점)를 유지하며 대부분의 경우 프로그램 종료시 디버거를 종료하는 것보다 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2539ba7b8e0eee8855621eedd477ec61c17b8f6b" translate="yes" xml:space="preserve">
          <source>When invoked from the command line, &lt;code&gt;python -m pickletools&lt;/code&gt; will disassemble the contents of one or more pickle files. Note that if you want to see the Python object stored in the pickle rather than the details of pickle format, you may want to use &lt;code&gt;-m pickle&lt;/code&gt; instead. However, when the pickle file that you want to examine comes from an untrusted source, &lt;code&gt;-m pickletools&lt;/code&gt; is a safer option because it does not execute pickle bytecode.</source>
          <target state="translated">명령 행에서 호출하면 &lt;code&gt;python -m pickletools&lt;/code&gt; 는 하나 이상의 pickle 파일의 내용을 디스 어셈블합니다. 피클 형식의 세부 정보가 아닌 피클에 저장된 Python 객체를 보려면 대신 &lt;code&gt;-m pickle&lt;/code&gt; 을 사용하는 것이 좋습니다. 그러나 검사하려는 피클 파일이 신뢰할 수없는 소스에서 온 경우 &lt;code&gt;-m pickletools&lt;/code&gt; 는 피클 바이트 코드를 실행하지 않기 때문에 더 안전한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="4b61fed1c9136364f71b07a1ac9ee9de891cc79e" translate="yes" xml:space="preserve">
          <source>When invoked on an unlocked lock, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">잠금 해제 된 잠금에서 호출되면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a4c03388380d599f150c844d9f2270ba506b4b5" translate="yes" xml:space="preserve">
          <source>When invoked with &lt;em&gt;blocking&lt;/em&gt; set to false, do not block. If a call without an argument would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;차단&lt;/em&gt; 을 false로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. 인수가없는 호출이 차단되면 즉시 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 그렇지 않으면 인수없이 호출 할 때와 동일한 작업을 수행하고 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3215b0285b31a2e686d7f6ba8334728310827391" translate="yes" xml:space="preserve">
          <source>When invoked with a &lt;em&gt;timeout&lt;/em&gt; other than &lt;code&gt;None&lt;/code&gt;, it will block for at most &lt;em&gt;timeout&lt;/em&gt; seconds. If acquire does not complete successfully in that interval, return &lt;code&gt;False&lt;/code&gt;. Return &lt;code&gt;True&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이외 의 &lt;em&gt;시간 초과로&lt;/em&gt; 호출하면 최대 &lt;em&gt;시간 초과&lt;/em&gt; 초 동안 차단됩니다 . 해당 간격에서 획득이 성공적으로 완료되지 않으면 &lt;code&gt;False&lt;/code&gt; 를 리턴하십시오 . 반환 &lt;code&gt;True&lt;/code&gt; 이 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1e3e192edfe421df0ce1b99d20b60757870a5ac" translate="yes" xml:space="preserve">
          <source>When invoked with a positive, floating-point value for &lt;em&gt;timeout&lt;/em&gt;, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; as long as the lock can not be acquired. Invocations with a negative value for &lt;em&gt;timeout&lt;/em&gt; are equivalent to a &lt;em&gt;timeout&lt;/em&gt; of zero. Invocations with a &lt;em&gt;timeout&lt;/em&gt; value of &lt;code&gt;None&lt;/code&gt; (the default) set the timeout period to infinite. Note that the treatment of negative or &lt;code&gt;None&lt;/code&gt; values for &lt;em&gt;timeout&lt;/em&gt; differs from the implemented behavior in &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt;&lt;code&gt;threading.Lock.acquire()&lt;/code&gt;&lt;/a&gt;. The &lt;em&gt;timeout&lt;/em&gt; argument has no practical implications if the &lt;em&gt;block&lt;/em&gt; argument is set to &lt;code&gt;False&lt;/code&gt; and is thus ignored. Returns &lt;code&gt;True&lt;/code&gt; if the lock has been acquired or &lt;code&gt;False&lt;/code&gt; if the timeout period has elapsed.</source>
          <target state="translated">&lt;em&gt;timeout에&lt;/em&gt; 양의 부동 소수점 값을 사용하여 호출 하면 잠금을 획득 할 수없는 한 &lt;em&gt;시간 초과&lt;/em&gt; 로 지정된 &lt;em&gt;시간 (&lt;/em&gt; 초) 동안 차단 하십시오. &lt;em&gt;시간 종료&lt;/em&gt; 값이 음수 인 호출 은 &lt;em&gt;시간 종료&lt;/em&gt; 0 과 같습니다 . &lt;em&gt;시간 종료&lt;/em&gt; 값이 &lt;code&gt;None&lt;/code&gt; (기본값) 인 호출 은 시간 종료 기간을 무한대로 설정합니다. &lt;em&gt;시간 초과에&lt;/em&gt; 대한 음수 또는 &lt;code&gt;None&lt;/code&gt; 값 처리는 &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt; &lt;code&gt;threading.Lock.acquire()&lt;/code&gt; &lt;/a&gt; 의 구현 된 동작과 다릅니다 . &lt;em&gt;타임 아웃&lt;/em&gt; 경우 생성 인자는 실제적인 의미가 없습니다 &lt;em&gt;블록&lt;/em&gt; 인수로 설정&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;False&lt;/code&gt; 이므로 무시됩니다. 반환 &lt;code&gt;True&lt;/code&gt; 잠금이 획득하거나 한 경우 &lt;code&gt;False&lt;/code&gt; 제한 시간이 경과 한 경우.</target>
        </trans-unit>
        <trans-unit id="b7920fec1db552b1e56262de88d29376efd098e4" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, do not block. If the lock has already been acquired (and thus is owned) by another process or thread, the current process or thread does not take ownership and the recursion level within the lock is not changed, resulting in a return value of &lt;code&gt;False&lt;/code&gt;. If the lock is in an unlocked state, the current process or thread takes ownership and the recursion level is incremented, resulting in a return value of &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;block&lt;/em&gt; 인수를 &lt;code&gt;False&lt;/code&gt; 로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. 다른 프로세스 또는 스레드가 잠금을 이미 획득하여 소유 한 경우 현재 프로세스 또는 스레드는 소유권을 얻지 못하고 잠금 내 재귀 수준이 변경되지 않아 &lt;code&gt;False&lt;/code&gt; 의 반환 값이 발생 합니다. 잠금이 잠금 해제 상태 인 경우 현재 프로세스 또는 스레드가 소유권을 가져오고 재귀 수준이 증가하여 반환 값이 &lt;code&gt;True&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="26d84ac2fed2d1d6bf35aca2492e7a51b1254f22" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt;, block until the lock is in an unlocked state (not owned by any process or thread) unless the lock is already owned by the current process or thread. The current process or thread then takes ownership of the lock (if it does not already have ownership) and the recursion level inside the lock increments by one, resulting in a return value of &lt;code&gt;True&lt;/code&gt;. Note that there are several differences in this first argument&amp;rsquo;s behavior compared to the implementation of &lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt;&lt;code&gt;threading.RLock.acquire()&lt;/code&gt;&lt;/a&gt;, starting with the name of the argument itself.</source>
          <target state="translated">&lt;em&gt;block&lt;/em&gt; 인수를 &lt;code&gt;True&lt;/code&gt; 로 설정하여 호출 하면 잠금이 현재 프로세스 또는 스레드에 의해 이미 소유되어 있지 않은 경우 잠금이 잠금 해제 상태 (프로세스 또는 스레드가 소유하지 않음)가 될 때까지 차단합니다. 그런 다음 현재 프로세스 또는 스레드는 잠금 소유권 (아직 소유권이없는 경우)을 가져오고 잠금 내부의 재귀 수준은 1 씩 증가하여 반환 값은 &lt;code&gt;True&lt;/code&gt; 입니다. 인수 자체의 이름으로 시작하는 &lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt; &lt;code&gt;threading.RLock.acquire()&lt;/code&gt; &lt;/a&gt; 의 구현과 비교하여이 첫 번째 인수의 동작에는 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3adb7479baf4957251699e2c3f19fc3aa413e8ed" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, do not block. If a call with &lt;em&gt;blocking&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt; would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, set the lock to locked and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;blocking&lt;/em&gt; 인수를 &lt;code&gt;False&lt;/code&gt; 로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. &lt;em&gt;차단&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 로 설정된 통화가 &lt;em&gt;차단&lt;/em&gt; 되면 즉시 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 그렇지 않으면 잠금을 잠금으로 설정하고 &lt;code&gt;True&lt;/code&gt; 를 리턴하십시오. .</target>
        </trans-unit>
        <trans-unit id="00fee988fe737d2ff47fe5cb9ac426ebebb9888c" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt; (the default), block until the lock is unlocked, then set it to locked and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;차단&lt;/em&gt; 인수를 &lt;code&gt;True&lt;/code&gt; (기본값)로 설정하여 호출 하면 잠금이 해제 될 때까지 차단 한 다음 잠금으로 설정하고 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="530808d79c5fd710b7d8c76ae1e70cbe8c467712" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to false, do not block. If a call without an argument would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;blocking&lt;/em&gt; 인수를 false로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. 인수가없는 호출이 차단되면 즉시 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 그렇지 않으면 인수없이 호출 할 때와 동일한 작업을 수행하고 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="4c7b2e8b0136f5c21ccc0f8e3de7ab48e6ebe94d" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to true, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">호출 할 때 &lt;em&gt;차단&lt;/em&gt; true로 인수 세트, 인수없이 호출 할 때와 같은 일을하고, 반환 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b710997372980f7c6061e22520300cdf15b9436e" translate="yes" xml:space="preserve">
          <source>When invoked with the floating-point &lt;em&gt;timeout&lt;/em&gt; argument set to a positive value, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; and as long as the lock cannot be acquired. A &lt;em&gt;timeout&lt;/em&gt; argument of &lt;code&gt;-1&lt;/code&gt; specifies an unbounded wait. It is forbidden to specify a &lt;em&gt;timeout&lt;/em&gt; when &lt;em&gt;blocking&lt;/em&gt; is false.</source>
          <target state="translated">부동 소수점 &lt;em&gt;시간 종료&lt;/em&gt; 인수를 양수 값으로 설정하여 호출 할 경우 , 잠금을 확보 할 수없는 한 &lt;em&gt;시간 종료로&lt;/em&gt; 지정된 최대 &lt;em&gt;시간 (&lt;/em&gt; 초) 동안 차단 하십시오. &lt;em&gt;초과&lt;/em&gt; 의 인자 &lt;code&gt;-1&lt;/code&gt; 안 바운드 대기를 지정한다. &lt;em&gt;차단할&lt;/em&gt; 때 &lt;em&gt;시간 초과&lt;/em&gt; 를 지정하는 것은 금지되어 있습니다&lt;em&gt;&lt;/em&gt; 이 거짓 일 있습니다.</target>
        </trans-unit>
        <trans-unit id="2140b5f65b8ba6f4b2bd371613d7e60332a2c64a" translate="yes" xml:space="preserve">
          <source>When invoked with the floating-point &lt;em&gt;timeout&lt;/em&gt; argument set to a positive value, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; and as long as the lock cannot be acquired. Return &lt;code&gt;True&lt;/code&gt; if the lock has been acquired, false if the timeout has elapsed.</source>
          <target state="translated">부동 소수점 &lt;em&gt;시간 종료&lt;/em&gt; 인수를 양수 값으로 설정하여 호출 할 경우 , 잠금을 확보 할 수없는 한 &lt;em&gt;시간 종료로&lt;/em&gt; 지정된 최대 &lt;em&gt;시간 (&lt;/em&gt; 초) 동안 차단 하십시오. &lt;code&gt;True&lt;/code&gt; 반환잠금이 획득되면 , 제한 시간이 경과하면 false를 합니다.</target>
        </trans-unit>
        <trans-unit id="dec567edc06d3b9893b2e7ade359dacbc93eb18e" translate="yes" xml:space="preserve">
          <source>When invoked without arguments:</source>
          <target state="translated">인수없이 호출 된 경우 :</target>
        </trans-unit>
        <trans-unit id="2c15ab576c9f7d8bf5867e09294955007cfb98cc" translate="yes" xml:space="preserve">
          <source>When invoked without arguments: if this thread already owns the lock, increment the recursion level by one, and return immediately. Otherwise, if another thread owns the lock, block until the lock is unlocked. Once the lock is unlocked (not owned by any thread), then grab ownership, set the recursion level to one, and return. If more than one thread is blocked waiting until the lock is unlocked, only one at a time will be able to grab ownership of the lock. There is no return value in this case.</source>
          <target state="translated">인수없이 호출 된 경우 :이 스레드가 이미 잠금을 소유 한 경우 재귀 레벨을 1 씩 늘리고 즉시 리턴하십시오. 그렇지 않으면 다른 스레드가 잠금을 소유 한 경우 잠금이 해제 될 때까지 차단하십시오. 잠금이 해제되면 (스레드가 소유하지 않은) 소유권을 잡고 재귀 수준을 1로 설정 한 후 돌아갑니다. 잠금이 해제 될 때까지 대기중인 스레드가 둘 이상인 경우 한 번에 하나만 잠금 소유권을 잡을 수 있습니다. 이 경우 반환 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b96b14764f1e6579b1b14032256583960d45abf4" translate="yes" xml:space="preserve">
          <source>When invoking external programs, make sure they can be found. Usually, this means using absolute path names &amp;mdash; &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; is usually not set to a very useful value in a CGI script.</source>
          <target state="translated">외부 프로그램을 호출 할 때 찾을 수 있는지 확인하십시오. 일반적으로 이것은 절대 경로 이름을 사용함을 의미합니다. &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; 는 일반적으로 CGI 스크립트에서 매우 유용한 값으로 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d49406082e5d3ef12b51588b4ee561e90642dbb" translate="yes" xml:space="preserve">
          <source>When more than one coroutine is blocked in &lt;a href=&quot;#asyncio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; waiting for the lock to be unlocked, only one coroutine eventually proceeds.</source>
          <target state="translated">잠금 해제를 기다리는 &lt;a href=&quot;#asyncio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 에서 둘 이상의 코 루틴이 차단되면 결국 하나의 코 루틴 만 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="d757253ec842e92c57d2efdf31bbd2d4624ea4d1" translate="yes" xml:space="preserve">
          <source>When more than one key is provided, then additional keys are used as secondary criteria when there is equality in all keys selected before them. For example, &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILE)&lt;/code&gt; will sort all the entries according to their function name, and resolve all ties (identical function names) by sorting by file name.</source>
          <target state="translated">둘 이상의 키가 제공되면, 이전에 선택된 모든 키가 동일 할 때 추가 키가 보조 기준으로 사용됩니다. 예를 들어 &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILE)&lt;/code&gt; 은 함수 이름에 따라 모든 항목을 정렬하고 파일 이름을 기준으로 정렬하여 모든 관계 (동일한 함수 이름)를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="ea00e1f9fb3773e02544a5c95c6a57b4665e0f48" translate="yes" xml:space="preserve">
          <source>When more than one pickle file are specified, print given preamble before each disassembly.</source>
          <target state="translated">하나 이상의 피클 파일이 지정되면 각 분해 전에 주어진 프리앰블을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="9a26198a4f09f3862bf0af3dbd7f4aeaa0993b74" translate="yes" xml:space="preserve">
          <source>When more than one thread is blocked in &lt;a href=&quot;#threading.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; waiting for the state to turn to unlocked, only one thread proceeds when a &lt;a href=&quot;#threading.Lock.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; call resets the state to unlocked; which one of the waiting threads proceeds is not defined, and may vary across implementations.</source>
          <target state="translated">상태가 잠금 해제 상태가되기를 기다리는 &lt;a href=&quot;#threading.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 에서 둘 이상의 스레드가 차단 되면 &lt;a href=&quot;#threading.Lock.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출이 상태를 잠금 해제 상태로 재설정 할 때 하나의 스레드 만 진행 됩니다. 대기 스레드 중 하나가 진행되는 것은 정의되지 않았으며 구현에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf9260c7b087d873e21d35d7eab19843d9322220" translate="yes" xml:space="preserve">
          <source>When multiple objects are disassembled, preserve memo between disassemblies.</source>
          <target state="translated">여러 개체를 분해 할 때는 분해간에 메모를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="d053b7be9831593a88afbed3a5bc6fa5f8506a45" translate="yes" xml:space="preserve">
          <source>When multiple processes with differing UIDs assign sockets to an identical UDP socket address with &lt;code&gt;SO_REUSEADDR&lt;/code&gt;, incoming packets can become randomly distributed among the sockets.</source>
          <target state="translated">UID가 다른 여러 프로세스가 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 을 사용하여 동일한 UDP 소켓 주소에 소켓을 할당 하면 들어오는 패킷이 소켓간에 무작위로 분산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3978842d4de4c74136c46923ed77df9264119bc1" translate="yes" xml:space="preserve">
          <source>When no &lt;em&gt;path&lt;/em&gt; is specified, the results of &lt;a href=&quot;os#os.environ&quot;&gt;&lt;code&gt;os.environ()&lt;/code&gt;&lt;/a&gt; are used, returning either the &amp;ldquo;PATH&amp;rdquo; value or a fallback of &lt;a href=&quot;os#os.defpath&quot;&gt;&lt;code&gt;os.defpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;경로&lt;/em&gt; 를 지정 하지 않으면 &lt;a href=&quot;os#os.environ&quot;&gt; &lt;code&gt;os.environ()&lt;/code&gt; &lt;/a&gt; 의 결과 가 사용되어&amp;ldquo;PATH&amp;rdquo;값 또는 &lt;a href=&quot;os#os.defpath&quot;&gt; &lt;code&gt;os.defpath&lt;/code&gt; &lt;/a&gt; 의 폴백을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="60fa2ee1d31958e02f93bc8b356815374fa1d19b" translate="yes" xml:space="preserve">
          <source>When no explicit alignment is given, preceding the &lt;em&gt;width&lt;/em&gt; field by a zero (&lt;code&gt;'0'&lt;/code&gt;) character enables sign-aware zero-padding for numeric types. This is equivalent to a &lt;em&gt;fill&lt;/em&gt; character of &lt;code&gt;'0'&lt;/code&gt; with an &lt;em&gt;alignment&lt;/em&gt; type of &lt;code&gt;'='&lt;/code&gt;.</source>
          <target state="translated">명시적인 정렬이 지정되지 않은 경우 &lt;em&gt;너비&lt;/em&gt; 필드 앞에 0 ( &lt;code&gt;'0'&lt;/code&gt; ) 문자 가 있으면 숫자 유형에 대해 부호 인식 제로 패딩이 가능합니다. 이것은 &lt;em&gt;정렬&lt;/em&gt; 유형이 &lt;code&gt;'='&lt;/code&gt; 인&lt;em&gt;채우기&lt;/em&gt; 문자 &lt;code&gt;'0'&lt;/code&gt; 과 같습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6065b034a11abad3d959f6d6989348ca636780d3" translate="yes" xml:space="preserve">
          <source>When no match is found, return whatever is available instead, possibly empty bytes. Raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; if the connection is closed and no cooked data is available.</source>
          <target state="translated">일치하는 것이 없으면 빈 바이트가 아닌 사용 가능한 것을 반환하십시오. 인상 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 연결이 닫혀없이 조리 데이터를 사용할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="4d974deeca1f469c2b5a6fa343cdf431c097d9b5" translate="yes" xml:space="preserve">
          <source>When one pastes code into Shell, it is not compiled and possibly executed until one hits</source>
          <target state="translated">셸에 코드를 붙여 넣을 때 코드가 컴파일되지 않고 적중 될 때까지 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4178055aedbbbaa771fd15ebbc33ceeea78f97" translate="yes" xml:space="preserve">
          <source>When one uses &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt;&lt;code&gt;Connection.recv&lt;/code&gt;&lt;/a&gt;, the data received is automatically unpickled. Unfortunately unpickling data from an untrusted source is a security risk. Therefore &lt;a href=&quot;#multiprocessing.connection.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.connection.Client&quot;&gt;&lt;code&gt;Client()&lt;/code&gt;&lt;/a&gt; use the &lt;a href=&quot;hmac#module-hmac&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; module to provide digest authentication.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt; &lt;code&gt;Connection.recv&lt;/code&gt; 를&lt;/a&gt; 사용하면 수신 된 데이터가 자동으로 선택 해제됩니다. 불행히도 신뢰할 수없는 출처에서 데이터를 뽑아내는 것은 보안 상 위험합니다. 따라서 &lt;a href=&quot;#multiprocessing.connection.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#multiprocessing.connection.Client&quot;&gt; &lt;code&gt;Client()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;hmac#module-hmac&quot;&gt; &lt;code&gt;hmac&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 다이제스트 인증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="defeae2dfe201352a7bdcfddb389352110acc25b" translate="yes" xml:space="preserve">
          <source>When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means &lt;code&gt;r&quot;\\&quot;&lt;/code&gt;. Without raw string notation, one must use &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;, making the following lines of code functionally identical:</source>
          <target state="translated">리터럴 백 슬래시와 일치 시키려면 정규식에서 이스케이프해야합니다. 원시 문자열 표기법을 사용하면 &lt;code&gt;r&quot;\\&quot;&lt;/code&gt; 입니다. 원시 문자열 표기법이 없으면 &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt; 를 사용해야 다음 코드 행의 기능이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb74b28bda4099bc79fd005722acae57fc6872e" translate="yes" xml:space="preserve">
          <source>When opening a file for reading, the &lt;em&gt;format&lt;/em&gt; and &lt;em&gt;filters&lt;/em&gt; arguments have the same meanings as for &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt;&lt;code&gt;LZMADecompressor&lt;/code&gt;&lt;/a&gt;. In this case, the &lt;em&gt;check&lt;/em&gt; and &lt;em&gt;preset&lt;/em&gt; arguments should not be used.</source>
          <target state="translated">읽을 파일을 열 때 &lt;em&gt;형식&lt;/em&gt; 및 &lt;em&gt;필터&lt;/em&gt; 인수는 &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt; &lt;code&gt;LZMADecompressor&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 . 이 경우 &lt;em&gt;확인&lt;/em&gt; 및 &lt;em&gt;사전 설정&lt;/em&gt; 인수를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2aa3b23d9c311bebcce2d82c3b6469767bdd03e8" translate="yes" xml:space="preserve">
          <source>When opening a file for reading, the input file may be the concatenation of multiple separate compressed streams. These are transparently decoded as a single logical stream.</source>
          <target state="translated">읽을 파일을 열 때 입력 파일은 여러 개의 개별 압축 스트림을 연결 한 것일 수 있습니다. 이들은 단일 논리 스트림으로 투명하게 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="b40148ffbc845740f7452ddadab19f55d4a0a189" translate="yes" xml:space="preserve">
          <source>When opening a file for writing, the &lt;em&gt;format&lt;/em&gt;, &lt;em&gt;check&lt;/em&gt;, &lt;em&gt;preset&lt;/em&gt; and &lt;em&gt;filters&lt;/em&gt; arguments have the same meanings as for &lt;a href=&quot;#lzma.LZMACompressor&quot;&gt;&lt;code&gt;LZMACompressor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쓰기 위해 파일을 열 때 &lt;em&gt;형식&lt;/em&gt; , &lt;em&gt;검사&lt;/em&gt; , &lt;em&gt;사전 설정&lt;/em&gt; 및 &lt;em&gt;필터&lt;/em&gt; 인수는 &lt;a href=&quot;#lzma.LZMACompressor&quot;&gt; &lt;code&gt;LZMACompressor&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0673e8efa9150c8c2de8c19210f1833061eca945" translate="yes" xml:space="preserve">
          <source>When operating in POSIX mode, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will try to obey to the following parsing rules.</source>
          <target state="translated">POSIX 모드에서 작동 할 때 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 는 다음 구문 분석 규칙을 따르려고합니다.</target>
        </trans-unit>
        <trans-unit id="07b63f3da75da4705f49d38fa15d535bbd4d2a24" translate="yes" xml:space="preserve">
          <source>When operating in non-POSIX mode, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will try to obey to the following rules.</source>
          <target state="translated">비 POSIX 모드에서 작동 할 때 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 는 다음 규칙을 따르려고합니다.</target>
        </trans-unit>
        <trans-unit id="45df7e43b0ea1fa603be77df6607a8c7e5ebe833" translate="yes" xml:space="preserve">
          <source>When packing a value &lt;code&gt;x&lt;/code&gt; using one of the integer formats (&lt;code&gt;'b'&lt;/code&gt;, &lt;code&gt;'B'&lt;/code&gt;, &lt;code&gt;'h'&lt;/code&gt;, &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'i'&lt;/code&gt;, &lt;code&gt;'I'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'L'&lt;/code&gt;, &lt;code&gt;'q'&lt;/code&gt;, &lt;code&gt;'Q'&lt;/code&gt;), if &lt;code&gt;x&lt;/code&gt; is outside the valid range for that format then &lt;a href=&quot;#struct.error&quot;&gt;&lt;code&gt;struct.error&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">정수 형식 ( &lt;code&gt;'b'&lt;/code&gt; , &lt;code&gt;'B'&lt;/code&gt; , &lt;code&gt;'h'&lt;/code&gt; , &lt;code&gt;'H'&lt;/code&gt; , &lt;code&gt;'i'&lt;/code&gt; , &lt;code&gt;'I'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'L'&lt;/code&gt; , &lt;code&gt;'q'&lt;/code&gt; , &lt;code&gt;'Q'&lt;/code&gt; 중 하나를 사용하여 값 &lt;code&gt;x&lt;/code&gt; 를 패킹 할 때 ' ), &lt;code&gt;x&lt;/code&gt; 가 해당 형식의 유효한 범위를 벗어나면 &lt;a href=&quot;#struct.error&quot;&gt; &lt;code&gt;struct.error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ff53ce933cb55e5d195fd8da14f24a9ea8a7dec" translate="yes" xml:space="preserve">
          <source>When passing a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance as the &lt;em&gt;zinfo_or_arcname&lt;/em&gt; parameter, the compression method used will be that specified in the &lt;em&gt;compress_type&lt;/em&gt; member of the given &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance. By default, the &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; constructor sets this member to &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt;&lt;code&gt;ZIP_STORED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스를 &lt;em&gt;zinfo_or_arcname&lt;/em&gt; 매개 변수 로 전달할 때 사용 된 압축 방법 은 지정된 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;em&gt;compress_type&lt;/em&gt; 멤버에 지정된 압축 방법 입니다. 기본적으로 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 생성자는이 멤버를 &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt; &lt;code&gt;ZIP_STORED&lt;/code&gt; 로&lt;/a&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fbfc7a1fdbd85a7a8af9ae652a598a7fb18209e5" translate="yes" xml:space="preserve">
          <source>When passing strings, characters special to XML such as &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&lt;/code&gt; will be automatically escaped. However, it&amp;rsquo;s the caller&amp;rsquo;s responsibility to ensure that the string is free of characters that aren&amp;rsquo;t allowed in XML, such as the control characters with ASCII values between 0 and 31 (except, of course, tab, newline and carriage return); failing to do this will result in an XML-RPC request that isn&amp;rsquo;t well-formed XML. If you have to pass arbitrary bytes via XML-RPC, use &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; classes or the &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt;&lt;code&gt;Binary&lt;/code&gt;&lt;/a&gt; wrapper class described below.</source>
          <target state="translated">문자열을 전달하면 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 XML에 특수한 문자 가 자동으로 이스케이프됩니다. 그러나 0에서 31 사이의 ASCII 값을 가진 제어 문자 (물론 탭, 줄 바꿈 및 캐리지 리턴 제외)와 같이 문자열에 XML에서 허용되지 않는 문자가 없는지 확인하는 것은 호출자의 책임입니다. 이렇게하지 않으면 XML 형식이 잘못된 XML-RPC 요청이 발생합니다. XML-RPC를 통해 임의의 바이트를 전달해야하는 경우 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 바이트 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 클래스 또는 아래 설명 된 &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt; &lt;code&gt;Binary&lt;/code&gt; &lt;/a&gt; 래퍼 클래스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="63bc2447bdc66517ffbc569605d6b0a283df40ef" translate="yes" xml:space="preserve">
          <source>When performing basic authentication, a &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt; instance calls its &lt;a href=&quot;#urllib.request.FancyURLopener.prompt_user_passwd&quot;&gt;&lt;code&gt;prompt_user_passwd()&lt;/code&gt;&lt;/a&gt; method. The default implementation asks the users for the required information on the controlling terminal. A subclass may override this method to support more appropriate behavior if needed.</source>
          <target state="translated">기본 인증을 수행 할 때 &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;#urllib.request.FancyURLopener.prompt_user_passwd&quot;&gt; &lt;code&gt;prompt_user_passwd()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 . 기본 구현은 사용자에게 제어 터미널에 대한 필수 정보를 요청합니다. 필요한 경우 서브 클래스가이 메소드를 대체하여보다 적절한 동작을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd3028f0460b2a38b88a225adf972c3a4a4fe5b" translate="yes" xml:space="preserve">
          <source>When printing output to the console, &lt;strong&gt;pydoc&lt;/strong&gt; attempts to paginate the output for easier reading. If the &lt;code id=&quot;index-1&quot;&gt;PAGER&lt;/code&gt; environment variable is set, &lt;strong&gt;pydoc&lt;/strong&gt; will use its value as a pagination program.</source>
          <target state="translated">콘솔에 출력을 인쇄 할 때 &lt;strong&gt;pydoc&lt;/strong&gt; 은 더 읽기 쉽게 출력을 페이지 매김하려고 시도합니다. 경우] &lt;code id=&quot;index-1&quot;&gt;PAGER&lt;/code&gt; 환경 변수 설정, &lt;strong&gt;pydoc이는&lt;/strong&gt; 페이지 매김 프로그램으로 그 값을 사용한다.</target>
        </trans-unit>
        <trans-unit id="0ed1e3583fcf60dc14b51dea1fcf2276215158d1" translate="yes" xml:space="preserve">
          <source>When programming in a compiled language, shared libraries are accessed when compiling/linking a program, and when the program is run.</source>
          <target state="translated">컴파일 된 언어로 프로그래밍 할 때 프로그램을 컴파일 / 링크 할 때 및 프로그램이 실행될 때 공유 라이브러리에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="03f1758f540eba7a39f832dfe0bdad388ef357ae" translate="yes" xml:space="preserve">
          <source>When provided, &lt;em&gt;extra_args&lt;/em&gt; is a sequence of &lt;code&gt;(name, value)&lt;/code&gt; tuples that will be passed as keywords arguments to the callable.</source>
          <target state="translated">제공되면 &lt;em&gt;extra_args&lt;/em&gt; 는 &lt;code&gt;(name, value)&lt;/code&gt; 튜플 의 시퀀스로 , 키워드 인수로 호출 가능 항목에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7d590e3c7f8f976b86d3937ef37f23bbcf9e23b0" translate="yes" xml:space="preserve">
          <source>When raising (or re-raising) an exception in an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clause &lt;code&gt;__context__&lt;/code&gt; is automatically set to the last exception caught; if the new exception is not handled the traceback that is eventually displayed will include the originating exception(s) and the final exception.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절 에서 예외를 발생 (또는 다시 발생) 할 때 &lt;code&gt;__context__&lt;/code&gt; 는 마지막으로 발생한 예외로 자동 설정됩니다. 새 예외가 처리되지 않으면 결국 표시되는 추적에는 원래 예외 및 최종 예외가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="84626ccb1f1b7c51c54d20b65a4d9d24bac172db" translate="yes" xml:space="preserve">
          <source>When raising a new exception (rather than using a bare &lt;code&gt;raise&lt;/code&gt; to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#raise&quot;&gt;&lt;code&gt;raise&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">현재 처리중인 예외를 다시 발생시키기 &lt;code&gt;raise&lt;/code&gt; 베어 인상 을 사용하지 않고 새 예외를 발생 시킬 때 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#raise&quot;&gt; &lt;code&gt;raise&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; 을 사용하여 명시 적 원인으로 암시 적 예외 컨텍스트를 보완 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc416240914fa2f9d0a3585ee1b058f79fc51d82" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If it is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">스트림에서 입력을 읽을 때 &lt;em&gt;개행&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용 개행&lt;/a&gt; 모드가 사용됩니다. 입력의 행은 &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 또는 &lt;code&gt;'\r\n'&lt;/code&gt; 끝날 수 있으며 호출자에게 반환되기 전에 &lt;code&gt;'\n'&lt;/code&gt; 으로 변환됩니다 . 이 경우 &lt;code&gt;''&lt;/code&gt; 보편적 인 줄 바꿈 모드가 활성화되어 있지만, 라인 끝은 번역되지 않은 호출자에게 반환됩니다. 다른 유효한 값이 있으면 입력 줄은 주어진 문자열로만 끝나고 줄 끝은 번역되지 않은 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="521e95b377d73dc55cb2baf5c5af8fdf1ed894f3" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, universal newlines mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If it is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">스트림에서 입력을 읽을 때 &lt;em&gt;개행&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이면 범용 개행 모드가 사용됩니다. 입력의 행은 &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 또는 &lt;code&gt;'\r\n'&lt;/code&gt; 끝날 수 있으며 호출자에게 반환되기 전에 &lt;code&gt;'\n'&lt;/code&gt; 으로 변환됩니다 . 이 경우 &lt;code&gt;''&lt;/code&gt; 보편적 인 줄 바꿈 모드가 활성화되어 있지만, 라인 끝은 번역되지 않은 호출자에게 반환됩니다. 다른 유효한 값이 있으면 입력 줄은 주어진 문자열로만 끝나고 줄 끝은 번역되지 않은 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6664d6092937daced8b81f9ccf4a2841a1ee61" translate="yes" xml:space="preserve">
          <source>When reading or writing external files, make sure they can be read or written by the userid under which your CGI script will be running: this is typically the userid under which the web server is running, or some explicitly specified userid for a web server&amp;rsquo;s &lt;code&gt;suexec&lt;/code&gt; feature.</source>
          <target state="translated">외부 파일을 읽거나 쓸 때 CGI 스크립트가 실행될 사용자 ID로 파일을 읽거나 쓸 수 있는지 확인하십시오. 일반적으로 웹 서버가 실행되는 사용자 ID이거나 웹 서버의 &lt;code&gt;suexec&lt;/code&gt; 에 대해 명시 적으로 지정된 사용자 ID입니다. 특색.</target>
        </trans-unit>
        <trans-unit id="d8df0ae7a831d2bc654fc7f26ceaddd0fec6a53d" translate="yes" xml:space="preserve">
          <source>When receiving host names from the wire (such as in reverse name lookup), no automatic conversion to Unicode is performed: applications wishing to present such host names to the user should decode them to Unicode.</source>
          <target state="translated">유선에서 호스트 이름을 수신 할 때 (예 : 리버스 이름 검색에서) 유니 코드로 자동 변환되지 않습니다. 이러한 호스트 이름을 사용자에게 제공하려는 응용 프로그램은 유니 코드로 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="c249fada241449b7a8d98255500a026f1ff7ff6e" translate="yes" xml:space="preserve">
          <source>When rotating, rotate the current log.</source>
          <target state="translated">회전 할 때 현재 로그를 회전하십시오.</target>
        </trans-unit>
        <trans-unit id="009f8f1003bd38ceb66bdf4766db141ef685c52a" translate="yes" xml:space="preserve">
          <source>When run with the appropriate arguments, it prints either the sum or the max of the command-line integers:</source>
          <target state="translated">적절한 인수를 사용하여 실행하면 명령 줄 정수의 합계 또는 최대 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d2c61737a1449cc5834b15d481c322aac953d7bb" translate="yes" xml:space="preserve">
          <source>When running a tkinter program from an IDLE editor, one can comment out the mainloop call. One then gets a shell prompt immediately and can interact with the live application. One just has to remember to re-enable the mainloop call when running in standard Python.</source>
          <target state="translated">IDLE 편집기에서 tkinter 프로그램을 실행할 때 mainloop 호출을 주석 처리 할 수 ​​있습니다. 그러면 즉시 쉘 프롬프트가 표시되고 라이브 애플리케이션과 상호 작용할 수 있습니다. 표준 파이썬에서 실행할 때 mainloop 호출을 다시 활성화해야한다는 것을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef04bb8c76c31bcff2e40b83fb3b51dbc495fd47" translate="yes" xml:space="preserve">
          <source>When serializing to JSON, beware any such limitations in applications that may consume your JSON. In particular, it is common for JSON numbers to be deserialized into IEEE 754 double precision numbers and thus subject to that representation&amp;rsquo;s range and precision limitations. This is especially relevant when serializing Python &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; values of extremely large magnitude, or when serializing instances of &amp;ldquo;exotic&amp;rdquo; numerical types such as &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JSON으로 직렬화 할 때 JSON을 소비 할 수있는 애플리케이션에서 이러한 제한 사항에 유의하십시오. 특히 JSON 숫자는 IEEE 754 배정 밀도 숫자로 역 직렬화되는 것이 일반적이므로 해당 표현의 범위 및 정밀도 제한이 적용됩니다. 이것은 매우 큰 규모의 Python &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 값을 직렬화하거나 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; 과 같은 &quot;이국적인&quot;숫자 유형의 인스턴스를 직렬화 할 때 특히 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3856e8bd6a5962d17cc2916a2ad00664a1e6d558" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, the parser will not allow for any section or option duplicates while reading from a single source (using &lt;code&gt;read_file()&lt;/code&gt;, &lt;code&gt;read_string()&lt;/code&gt; or &lt;code&gt;read_dict()&lt;/code&gt;). It is recommended to use strict parsers in new applications.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정 하면 구문 분석기는 단일 소스에서 읽는 동안 ( &lt;code&gt;read_file()&lt;/code&gt; , &lt;code&gt;read_string()&lt;/code&gt; 또는 &lt;code&gt;read_dict()&lt;/code&gt; ) 섹션 또는 옵션 중복을 허용하지 않습니다 . 새로운 응용 프로그램에서는 엄격한 파서를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="af553f6e77f3799cc572c24f6b17d618156fcd66" translate="yes" xml:space="preserve">
          <source>When set to a value other than &lt;code&gt;None&lt;/code&gt;, this variable defines the default value for the &lt;em&gt;dir&lt;/em&gt; argument to the functions defined in this module.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이외의 값으로 설정되면 이 변수는 &lt;em&gt;dir&lt;/em&gt; 인수 의 기본값 을이 모듈에 정의 된 함수로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a651c4386e23ffbd8bc757cc1022ed6e854c9c0d" translate="yes" xml:space="preserve">
          <source>When set, all unreachable objects found will be appended to &lt;em&gt;garbage&lt;/em&gt; rather than being freed. This can be useful for debugging a leaking program.</source>
          <target state="translated">설정하면 발견 할 수없는 모든 오브젝트 가 해제되지 않고 &lt;em&gt;가비지에&lt;/em&gt; 추가됩니다 . 누출 프로그램을 디버깅하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="966461a5030c03e1d1f1351234001ea1acd1bcfd" translate="yes" xml:space="preserve">
          <source>When setting cookies, require a full &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; domain-match.</source>
          <target state="translated">쿠키를 설정할 때 전체 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 도메인 일치가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="962945e9937ea98d222513b922d5881fd1bf1687" translate="yes" xml:space="preserve">
          <source>When setting cookies, the &amp;lsquo;host prefix&amp;rsquo; must not contain a dot (eg. &lt;code&gt;www.foo.bar.com&lt;/code&gt; can&amp;rsquo;t set a cookie for &lt;code&gt;.bar.com&lt;/code&gt;, because &lt;code&gt;www.foo&lt;/code&gt; contains a dot).</source>
          <target state="translated">쿠키를 설정하면, '호스트 접두사'는 점을 포함 할 수 없습니다 (예를 들면. &lt;code&gt;www.foo.bar.com&lt;/code&gt; 을 위해 쿠키를 설정할 수 없습니다 &lt;code&gt;.bar.com&lt;/code&gt; 을 하기 때문에, &lt;code&gt;www.foo&lt;/code&gt; 는 점을 포함).</target>
        </trans-unit>
        <trans-unit id="1497d638ca2af8c9832a39909543a42d33c7e1e0" translate="yes" xml:space="preserve">
          <source>When several absolute paths are given, the last is taken as an anchor (mimicking &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s behaviour):</source>
          <target state="translated">몇 개의 절대 경로가 주어지면 마지막은 앵커로 간주됩니다 ( &lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt; 의 동작을 모방 ).</target>
        </trans-unit>
        <trans-unit id="0ef246b92ec78bbb2904be545cecaaa31079bddf" translate="yes" xml:space="preserve">
          <source>When specified, all sequences of whitespace (blanks and newlines) are treated as equal. Any sequence of whitespace within the expected output will match any sequence of whitespace within the actual output. By default, whitespace must match exactly. &lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt;&lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt;&lt;/a&gt; is especially useful when a line of expected output is very long, and you want to wrap it across multiple lines in your source.</source>
          <target state="translated">지정하면 모든 공백 문자 (공백 및 개행)가 동일하게 처리됩니다. 예상 출력 내의 공백 시퀀스는 실제 출력 내의 공백 시퀀스와 일치합니다. 기본적으로 공백은 정확히 일치해야합니다. &lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt; &lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt; &lt;/a&gt; 는 예상 출력 라인이 매우 길고 소스의 여러 라인에 랩핑하려는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1b218a31cb42b5880f2b77432b336a4dc41d9aa7" translate="yes" xml:space="preserve">
          <source>When specified, an ellipsis marker (&lt;code&gt;...&lt;/code&gt;) in the expected output can match any substring in the actual output. This includes substrings that span line boundaries, and empty substrings, so it&amp;rsquo;s best to keep usage of this simple. Complicated uses can lead to the same kinds of &amp;ldquo;oops, it matched too much!&amp;rdquo; surprises that &lt;code&gt;.*&lt;/code&gt; is prone to in regular expressions.</source>
          <target state="translated">지정된 경우 예상 출력 의 줄임표 마커 ( &lt;code&gt;...&lt;/code&gt; )는 실제 출력의 모든 하위 문자열과 일치 할 수 있습니다. 여기에는 줄 경계에 걸쳐있는 하위 문자열과 빈 하위 문자열이 포함되므로이 사용법을 간단하게 유지하는 것이 가장 좋습니다. 복잡한 사용으로 인해 같은 종류의 &quot;죄송합니다. 너무 많이 일치합니다!&quot; 그 놀라움 &lt;code&gt;.*&lt;/code&gt; 정규식에서하는 경향이있다.</target>
        </trans-unit>
        <trans-unit id="dcb31cc2903efca845f37ae06ecb0d7faead34bc" translate="yes" xml:space="preserve">
          <source>When specified, an example that expects an exception passes if an exception of the expected type is raised, even if the exception detail does not match. For example, an example expecting &lt;code&gt;ValueError: 42&lt;/code&gt; will pass if the actual exception raised is &lt;code&gt;ValueError: 3*14&lt;/code&gt;, but will fail, e.g., if &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 경우 예외 세부 사항이 일치하지 않더라도 예상 유형의 예외가 발생하면 예외를 예상하는 예제가 전달됩니다. 예를 들어, 실제 발생 된 예외가 &lt;code&gt;ValueError: 3*14&lt;/code&gt; 인 경우 &lt;code&gt;ValueError: 42&lt;/code&gt; 를 예상하는 예제 가 전달 되지만 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생 하면 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="506d23fee0102647e3e510ecb1828895d54af340" translate="yes" xml:space="preserve">
          <source>When specified, differences are computed by &lt;code&gt;difflib.Differ&lt;/code&gt;, using the same algorithm as the popular &lt;code&gt;ndiff.py&lt;/code&gt; utility. This is the only method that marks differences within lines as well as across lines. For example, if a line of expected output contains digit &lt;code&gt;1&lt;/code&gt; where actual output contains letter &lt;code&gt;l&lt;/code&gt;, a line is inserted with a caret marking the mismatching column positions.</source>
          <target state="translated">지정되면, 차이점은 &lt;code&gt;difflib.Differ&lt;/code&gt; 사용되는 &lt;code&gt;ndiff.py&lt;/code&gt; 유틸리티 와 동일한 알고리즘을 사용하여 difflib.Differ 에 의해 계산됩니다 . 이것은 라인과 라인 간의 차이를 표시하는 유일한 방법입니다. 예를 들어, 예상 출력 행에 실제 출력에 문자 &lt;code&gt;l&lt;/code&gt; 이 포함 된 숫자 &lt;code&gt;1&lt;/code&gt; 이 포함 된 경우, 일치하지 않는 열 위치를 표시하는 캐럿이있는 행이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="725ed21a520fb4bdfd0c582f999632c3b3e1a3c6" translate="yes" xml:space="preserve">
          <source>When specified, display the first failing example in each doctest, but suppress output for all remaining examples. This will prevent doctest from reporting correct examples that break because of earlier failures; but it might also hide incorrect examples that fail independently of the first failure. When &lt;a href=&quot;#doctest.REPORT_ONLY_FIRST_FAILURE&quot;&gt;&lt;code&gt;REPORT_ONLY_FIRST_FAILURE&lt;/code&gt;&lt;/a&gt; is specified, the remaining examples are still run, and still count towards the total number of failures reported; only the output is suppressed.</source>
          <target state="translated">지정된 경우, 각 doctest에서 첫 번째 실패한 예제를 표시하지만 나머지 모든 예제의 출력은 억제하십시오. 이렇게하면 doctest가 초기 실패로 인해 깨지는 올바른 예제를보고하지 못하게됩니다. 그러나 첫 번째 실패와 독립적으로 실패한 잘못된 예를 숨길 수도 있습니다. 때 &lt;a href=&quot;#doctest.REPORT_ONLY_FIRST_FAILURE&quot;&gt; &lt;code&gt;REPORT_ONLY_FIRST_FAILURE&lt;/code&gt; 가&lt;/a&gt; 지정되어, 남아있는 예는 아직 실행하고 여전히보고 실패의 총 수에 반영된다 출력 만 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="aeb4572ffe4ed819ce94cd6722f54cd0aadb9fe4" translate="yes" xml:space="preserve">
          <source>When specified, do not run the example at all. This can be useful in contexts where doctest examples serve as both documentation and test cases, and an example should be included for documentation purposes, but should not be checked. E.g., the example&amp;rsquo;s output might be random; or the example might depend on resources which would be unavailable to the test driver.</source>
          <target state="translated">지정된 경우 예제를 전혀 실행하지 마십시오. 이것은 doctest 예제가 문서 및 테스트 사례로 사용되는 상황에서 유용 할 수 있으며, 예제는 문서 목적으로 포함되어야하지만 점검해서는 안됩니다. 예를 들어, 예제의 출력은 무작위 일 수 있습니다. 또는 예제는 테스트 드라이버가 사용할 수없는 자원에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1313668fddf2714b9e79f58afa68fecf0d72d780" translate="yes" xml:space="preserve">
          <source>When specified, exit after the first failing example and don&amp;rsquo;t attempt to run the remaining examples. Thus, the number of failures reported will be at most 1. This flag may be useful during debugging, since examples after the first failure won&amp;rsquo;t even produce debugging output.</source>
          <target state="translated">지정된 경우 첫 번째 실패한 예제를 종료 한 후 나머지 예제를 실행하지 마십시오. 따라서보고 된 실패 수는 최대 1입니다.이 플래그는 첫 번째 실패 이후의 예에서는 디버깅 출력을 생성하지 않기 때문에 디버깅 중에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a165ac4e0fc877daf25b2fcfe0a4d6e37cd8566f" translate="yes" xml:space="preserve">
          <source>When specified, failures that involve multi-line expected and actual outputs are displayed using a unified diff.</source>
          <target state="translated">지정된 경우 다중 라인 예상 및 실제 출력과 관련된 장애는 통합 된 diff를 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="210d27f93a6ffbf0d54ba3a0a4a851f82c25d9b1" translate="yes" xml:space="preserve">
          <source>When specified, failures that involve multi-line expected and actual outputs will be displayed using a context diff.</source>
          <target state="translated">지정된 경우 다중 라인 예상 및 실제 출력과 관련된 실패는 컨텍스트 차이를 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2e021460883f1eef6780ecadd57bc2f7a8e86c36" translate="yes" xml:space="preserve">
          <source>When specified, the pattern character &lt;code&gt;'^'&lt;/code&gt; matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character &lt;code&gt;'$'&lt;/code&gt; matches at the end of the string and at the end of each line (immediately preceding each newline). By default, &lt;code&gt;'^'&lt;/code&gt; matches only at the beginning of the string, and &lt;code&gt;'$'&lt;/code&gt; only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag &lt;code&gt;(?m)&lt;/code&gt;.</source>
          <target state="translated">지정 될 때 패턴 문자 &lt;code&gt;'^'&lt;/code&gt; 은 문자열의 시작과 각 줄의 시작 부분에서 일치합니다 (각 줄 바꿈 바로 다음). 패턴 문자 &lt;code&gt;'$'&lt;/code&gt; 는 문자열의 끝과 각 줄의 끝에서 (각 줄 바꿈 바로 앞에) 일치합니다. 기본적으로 &lt;code&gt;'^'&lt;/code&gt; 은 문자열의 시작 부분에서만, &lt;code&gt;'$'&lt;/code&gt; 는 문자열의 끝 부분에서만 , 그리고 문자열 끝에서 줄 바꿈 바로 앞 (있는 경우) 에만 일치 합니다. 인라인 플래그 &lt;code&gt;(?m)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6508ccae0114f70101a39c1ade3be77f9a0e54cc" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, mix-in types must appear before &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; itself in the sequence of bases, as in the &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; example above.</source>
          <target state="translated">&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 을&lt;/a&gt; 서브 클래 싱 할 때 , 위 의 &lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 예제 에서와 같이 믹스 인 타입 은 기본 시퀀스에서 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 자체 앞에 나타나야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ab9f2e0c84d1cef2e81d17d102b665c42c1b918" translate="yes" xml:space="preserve">
          <source>When symbolic link cycles occur, the returned path will be one member of the cycle, but no guarantee is made about which member that will be.</source>
          <target state="translated">심볼릭 링크 사이클이 발생하면 반환 된 경로는 사이클의 한 멤버가되지만 어떤 멤버가 될지는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dda516a7e878443b38c4fe64189ee1bdd2488b07" translate="yes" xml:space="preserve">
          <source>When testing multiple operations that raise the same kind of warning, it is important to test them in a manner that confirms each operation is raising a new warning (e.g. set warnings to be raised as exceptions and check the operations raise exceptions, check that the length of the warning list continues to increase after each operation, or else delete the previous entries from the warnings list before each new operation).</source>
          <target state="translated">동일한 종류의 경고를 발생시키는 여러 작업을 테스트 할 때는 각 작업이 새로운 경고를 발생시키는 지 확인하는 방식으로 테스트하는 것이 중요합니다 (예 : 예외로 발생하는 경고를 설정하고 작업에서 예외가 발생하는지 확인하고 길이를 확인하십시오) 각 작업 후에 경고 목록이 계속 증가하거나 새 작업 전에 경고 목록에서 이전 항목을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="32c986eba58685d8d5c5b9096bea3ea17575dc2a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt;&lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt;&lt;/a&gt; doctest option is specified, everything following the leftmost colon and any module information in the exception name is ignored.</source>
          <target state="translated">때 &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt; &lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt; &lt;/a&gt; 옵션 doctest가 지정되면, 왼쪽 콜론과 예외 이름에 모듈 정보를 다음의 모든 것을 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3f49f30bcc7e091d5c01e4ab7c4d154fba44f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noqiflush()&lt;/code&gt; routine is used, normal flush of input and output queues associated with the &lt;code&gt;INTR&lt;/code&gt;, &lt;code&gt;QUIT&lt;/code&gt; and &lt;code&gt;SUSP&lt;/code&gt; characters will not be done. You may want to call &lt;code&gt;noqiflush()&lt;/code&gt; in a signal handler if you want output to continue as though the interrupt had not occurred, after the handler exits.</source>
          <target state="translated">때 &lt;code&gt;noqiflush()&lt;/code&gt; 루틴을 사용하는 경우,과 관련된 입력 및 출력 큐의 정상 높이 &lt;code&gt;INTR&lt;/code&gt; 은 , &lt;code&gt;QUIT&lt;/code&gt; 및 &lt;code&gt;SUSP&lt;/code&gt; 문자는 수행되지 않습니다. 핸들러가 종료 된 후 인터럽트가 발생하지 않은 것처럼 출력을 계속하려면 신호 핸들러에서 &lt;code&gt;noqiflush()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92f7176cdc28e8fabe1cc4ce9c92d06ff62a9627" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;value&lt;/code&gt; attribute is retrieved from a ctypes instance, usually a new object is returned each time. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; implement original object return, always a new object is constructed. The same is true for all other ctypes object instances.</source>
          <target state="translated">때 &lt;code&gt;value&lt;/code&gt; 속성이하는 ctypes 인스턴스에서 검색, 일반적으로 새로운 객체가 리턴됩니다. &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 원래 객체 반환을 구현 하지 &lt;em&gt;않으며&lt;/em&gt; 항상 새로운 객체가 생성됩니다. 다른 모든 ctypes 객체 인스턴스도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="cba25eeaf6632c7ebc55efeeb8b1a2231818ee6e" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;name&lt;/em&gt; variable is of the form &lt;code&gt;package.module&lt;/code&gt;, normally, the top-level package (the name up till the first dot) is returned, &lt;em&gt;not&lt;/em&gt; the module named by &lt;em&gt;name&lt;/em&gt;. However, when a non-empty &lt;em&gt;fromlist&lt;/em&gt; argument is given, the module named by &lt;em&gt;name&lt;/em&gt; is returned.</source>
          <target state="translated">때 &lt;em&gt;이름&lt;/em&gt; 변수 폼이다 &lt;code&gt;package.module&lt;/code&gt; 통상, 최상위 레벨 패키지 (제 점까지 이름까지)를 반환 &lt;em&gt;하지&lt;/em&gt; 명명 한 모듈 &lt;em&gt;이름&lt;/em&gt; . 그러나 비어 있지 않은 &lt;em&gt;fromlist&lt;/em&gt; 인수가 제공되면 &lt;em&gt;name&lt;/em&gt; 으로 &lt;em&gt;이름&lt;/em&gt; 지정된 모듈 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0839b23fb2fd3debdac05fc9ae13ae6b565a4724" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is not present or &lt;code&gt;None&lt;/code&gt;, the operation will block until the thread terminates.</source>
          <target state="translated">때 &lt;em&gt;시간 제한&lt;/em&gt; 인자가 존재 아닌지 &lt;code&gt;None&lt;/code&gt; , 동작은 스레드가 종료 될 때까지 차단된다.</target>
        </trans-unit>
        <trans-unit id="a4f2a083cefefece0f9a989089d273d2343db7c8" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</source>
          <target state="translated">때 &lt;em&gt;시간 제한&lt;/em&gt; 인자가 존재하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 이는 초 작동 시간 제한 (또는 이의 분획물)를 특정하는 부동 소수점 수이어야한다.</target>
        </trans-unit>
        <trans-unit id="9427976e1510be53b2baa1d26a02bd7a239f5c51" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; always returns &lt;code&gt;None&lt;/code&gt;, you must call &lt;a href=&quot;#threading.Thread.is_alive&quot;&gt;&lt;code&gt;is_alive()&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; to decide whether a timeout happened &amp;ndash; if the thread is still alive, the &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; call timed out.</source>
          <target state="translated">때 &lt;em&gt;시간 제한&lt;/em&gt; 인자가 존재하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 이는 초 작동 시간 제한 (또는 이의 분획물)를 특정하는 부동 소수점 수이어야한다. 로 &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 항상 반환 &lt;code&gt;None&lt;/code&gt; , 당신은 호출해야합니다&lt;a href=&quot;#threading.Thread.is_alive&quot;&gt; &lt;code&gt;is_alive()&lt;/code&gt; &lt;/a&gt; 이후&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 타임 아웃이 발생 여부를 결정하기 - 스레드가 아직 살아 경우&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 호출이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="4efa641d2d18d3d35e2f53ff91c7db9472e3c6c4" translate="yes" xml:space="preserve">
          <source>When the database has been opened in fast mode, this method forces any unwritten data to be written to the disk.</source>
          <target state="translated">데이터베이스가 빠른 모드로 열린 경우이 방법을 사용하면 쓰지 않은 데이터가 디스크에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b82443f1c4eff35532245efa9cbc5d46a5e79a79" translate="yes" xml:space="preserve">
          <source>When the dataclass is being created by the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator, it looks through all of the class&amp;rsquo;s base classes in reverse MRO (that is, starting at &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;) and, for each dataclass that it finds, adds the fields from that base class to an ordered mapping of fields. After all of the base class fields are added, it adds its own fields to the ordered mapping. All of the generated methods will use this combined, calculated ordered mapping of fields. Because the fields are in insertion order, derived classes override base classes. An example:</source>
          <target state="translated">에 의해 데이터 클래스가 생성 될 때 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 장식, 그것은 (에서 시작된다 역 MRO의 클래스의 기본 클래스의 모든 통해 보이는&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 는 발견하는 각 dataclass에 대한 등)에 그 기본 클래스에서 필드를 추가합니다 정렬 된 필드 매핑 모든 기본 클래스 필드가 추가 된 후 자체 맵핑 된 필드를 순서 맵핑에 추가합니다. 생성 된 모든 메소드는이 결합 된 계산 된 순서화 된 필드 맵핑을 사용합니다. 필드는 삽입 순서이므로 파생 클래스는 기본 클래스를 재정의합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d9b66dd18ce1e12e4286175c7d8752f320de1be6" translate="yes" xml:space="preserve">
          <source>When the debug mode is enabled:</source>
          <target state="translated">디버그 모드가 활성화 된 경우 :</target>
        </trans-unit>
        <trans-unit id="3d323c0b3abd37e8843f26f7250d48151ff4e9e4" translate="yes" xml:space="preserve">
          <source>When the deque is not empty, rotating one step to the right is equivalent to &lt;code&gt;d.appendleft(d.pop())&lt;/code&gt;, and rotating one step to the left is equivalent to &lt;code&gt;d.append(d.popleft())&lt;/code&gt;.</source>
          <target state="translated">데크가 비어 있지 않은 경우 오른쪽으로 한 단계 씩 회전하는 것은 &lt;code&gt;d.appendleft(d.pop())&lt;/code&gt; 와 같으며 왼쪽으로 한 단계 씩 회전하는 것은 &lt;code&gt;d.append(d.popleft())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965bb2961456fd9ec18c155c435cd124d7f1e1f7" translate="yes" xml:space="preserve">
          <source>When the following functions return &amp;ldquo;frame records,&amp;rdquo; each record is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt;. The tuple contains the frame object, the filename, the line number of the current line, the function name, a list of lines of context from the source code, and the index of the current line within that list.</source>
          <target state="translated">다음 함수가 &quot;프레임 레코드&quot;를 반환하면 각 레코드는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt; 명명 된 튜플 &lt;/a&gt; &lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt; 입니다. 튜플에는 프레임 객체, 파일 이름, 현재 줄의 줄 번호, 함수 이름, 소스 코드의 컨텍스트 줄 목록 및 해당 목록 내 현재 줄의 색인이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a192ce7dd917b79cdadcecc69d15e0e840e3fac2" translate="yes" xml:space="preserve">
          <source>When the function raises a &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; exception, it is silently ignored.</source>
          <target state="translated">함수가 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 예외를 발생 시키면 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8af2d5b431a64609659111ed46cf47a5a6d0cb" translate="yes" xml:space="preserve">
          <source>When the function returns, the thread silently exits.</source>
          <target state="translated">함수가 반환되면 스레드가 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2939cf22671cec72fb407f91f1dd1da33466f4b0" translate="yes" xml:space="preserve">
          <source>When the function terminates with an unhandled exception, &lt;a href=&quot;sys#sys.unraisablehook&quot;&gt;&lt;code&gt;sys.unraisablehook()&lt;/code&gt;&lt;/a&gt; is called to handle the exception. The &lt;em&gt;object&lt;/em&gt; attribute of the hook argument is &lt;em&gt;function&lt;/em&gt;. By default, a stack trace is printed and then the thread exits (but other threads continue to run).</source>
          <target state="translated">처리되지 않은 예외로 함수가 종료되면 예외 를 처리하기 위해 &lt;a href=&quot;sys#sys.unraisablehook&quot;&gt; &lt;code&gt;sys.unraisablehook()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. 후크 인수 의 &lt;em&gt;객체&lt;/em&gt; 속성은&lt;em&gt; function&lt;/em&gt; 입니다. 기본적으로 스택 추적이 인쇄 된 다음 스레드가 종료되지만 다른 스레드는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="11e1f7a5314c521814efab7673f88a014796119b" translate="yes" xml:space="preserve">
          <source>When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.</source>
          <target state="translated">iterable이 비어 있으면 시작 값을 리턴하십시오. 이 기능은 숫자 값과 함께 사용하기위한 것으로 숫자가 아닌 유형을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0619f802303d6a776090a8553bcded1600861c45" translate="yes" xml:space="preserve">
          <source>When the lock is &lt;em&gt;locked&lt;/em&gt;, reset it to &lt;em&gt;unlocked&lt;/em&gt; and return.</source>
          <target state="translated">잠금이 &lt;em&gt;잠기면&lt;/em&gt; 잠금 을 &lt;em&gt;해제&lt;/em&gt; 하여 다시 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="12b90fc7c45f662a12bf1ee8cea1898d278f7026" translate="yes" xml:space="preserve">
          <source>When the lock is locked, reset it to unlocked, and return. If any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed.</source>
          <target state="translated">잠금 장치가 잠기면 잠금 해제로 재설정하고 돌아갑니다. 잠금이 해제 될 때까지 다른 스레드가 차단 된 경우 정확히 하나의 스레드가 진행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="6c398f7629217467760d733727be89698cfaee23" translate="yes" xml:space="preserve">
          <source>When the logging module is imported, it registers this function as an exit handler (see &lt;a href=&quot;atexit#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;), so normally there&amp;rsquo;s no need to do that manually.</source>
          <target state="translated">로깅 모듈을 가져 오면이 함수를 종료 핸들러로 등록합니다 ( &lt;a href=&quot;atexit#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt; 참조). )로 등록하므로 일반적으로 수동으로 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cdd980ea6acc8763679979a08e2398cb455101b4" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it does not do any of its usual cleanup (except that &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses are honored), and the standard I/O files are not flushed.</source>
          <target state="translated">기본 스레드가 종료되면 일반적인 정리는 수행되지 않으며 ( &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; ... &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절이 적용되는 것을 제외하고 ) 표준 I / O 파일은 플러시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5af7554aea463351096c790b6eebb65f8d0e1e78" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses or executing object destructors.</source>
          <target state="translated">주 스레드가 종료되면 다른 스레드가 존속하는지 여부가 시스템 정의입니다. 대부분의 시스템에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절을 실행하거나 객체 소멸자를 실행 하지 않고 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="df8416c53a3fab417f18d34ff6b2c7c89921bb9b" translate="yes" xml:space="preserve">
          <source>When the number of data points is even, the median is interpolated by taking the average of the two middle values:</source>
          <target state="translated">데이터 포인트 수가 짝수 인 경우 중간 값은 두 중간 값의 평균을 취하여 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="c3727a0d49a696958b7e7aedf6197c454a60d276" translate="yes" xml:space="preserve">
          <source>When the parser is instantiated it is ready to begin accepting data from the feed method immediately. After parsing has been finished with a call to close the reset method must be called to make the parser ready to accept new data, either from feed or using the parse method.</source>
          <target state="translated">파서가 인스턴스화되면 즉시 피드 메소드에서 데이터를 수락 할 수 있습니다. 구문 분석이 닫히는 호출로 구문 분석이 완료된 후, 구문 분석기가 피드에서 또는 구문 분석 메소드를 사용하여 새 데이터를 승인 할 준비가되도록 재설정 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="512d3776530707ff872caf29c6b20b7211d9d8d5" translate="yes" xml:space="preserve">
          <source>When the path points to a directory, yield path objects of the directory contents:</source>
          <target state="translated">경로가 디렉토리를 가리키는 경우 디렉토리 내용의 경로 객체를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="df6ac2fad722ee466b6d6cb46713a1963668153e" translate="yes" xml:space="preserve">
          <source>When the program exits, each remaining live finalizer is called unless its &lt;a href=&quot;atexit#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt; attribute has been set to false. They are called in reverse order of creation.</source>
          <target state="translated">프로그램이 종료되면 해당 &lt;a href=&quot;atexit#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt; 속성이 false로 설정되어 있지 않으면 남아있는 각 라이브 파이널 라이저가 호출됩니다 . 그것들은 생성 순서와 반대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a67cebb1835e8e6bf7a770664e7365b4b2e21589" translate="yes" xml:space="preserve">
          <source>When the program starts and selects the &lt;em&gt;forkserver&lt;/em&gt; start method, a server process is started. From then on, whenever a new process is needed, the parent process connects to the server and requests that it fork a new process. The fork server process is single threaded so it is safe for it to use &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt;. No unnecessary resources are inherited.</source>
          <target state="translated">프로그램이 시작되고 &lt;em&gt;forkserver&lt;/em&gt; start 메소드를 선택하면 서버 프로세스가 시작됩니다. 그때부터 새 프로세스가 필요할 때마다 상위 프로세스가 서버에 연결하여 새 프로세스를 분기하도록 요청합니다. 포크 서버 프로세스는 단일 스레드이므로 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 안전합니다 . 불필요한 리소스는 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f5136bd917b359254fcb25318d6cf9878572072" translate="yes" xml:space="preserve">
          <source>When the right argument is a dictionary (or other mapping type), then the formats in the bytes object &lt;em&gt;must&lt;/em&gt; include a parenthesised mapping key into that dictionary inserted immediately after the &lt;code&gt;'%'&lt;/code&gt; character. The mapping key selects the value to be formatted from the mapping. For example:</source>
          <target state="translated">올바른 인수가 사전 (또는 다른 매핑 유형) 인 경우 bytes 객체의 형식 에는 &lt;code&gt;'%'&lt;/code&gt; 문자 바로 뒤에 삽입 된 사전에 괄호로 묶인 매핑 키 &lt;em&gt;가&lt;/em&gt; 포함 &lt;em&gt;되어야합니다&lt;/em&gt; . 맵핑 키는 맵핑에서 형식화 할 값을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1b647f4b9964ada60f8adbae790c7e50f0a7417" translate="yes" xml:space="preserve">
          <source>When the right argument is a dictionary (or other mapping type), then the formats in the string &lt;em&gt;must&lt;/em&gt; include a parenthesised mapping key into that dictionary inserted immediately after the &lt;code&gt;'%'&lt;/code&gt; character. The mapping key selects the value to be formatted from the mapping. For example:</source>
          <target state="translated">올바른 인수가 사전 (또는 다른 매핑 유형) 인 경우 문자열의 형식 에는 &lt;code&gt;'%'&lt;/code&gt; 문자 바로 뒤에 삽입 된 사전에 괄호로 묶인 매핑 키 &lt;em&gt;가&lt;/em&gt; 포함 &lt;em&gt;되어야합니다&lt;/em&gt; . 맵핑 키는 맵핑에서 형식화 할 값을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c542987ce2fae3c5dd363658acde3db213bccc7" translate="yes" xml:space="preserve">
          <source>When the timeout argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</source>
          <target state="translated">제한 시간 인수가 존재하지만 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우, 조작에 대한 제한 시간을 초 (또는 소수)로 지정하는 부동 소수점 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dcaffd14aa04c2c35de2956e1ed898667e511dfc" translate="yes" xml:space="preserve">
          <source>When the underlying lock is an &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt;, it is not released using its &lt;a href=&quot;#threading.Condition.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method, since this may not actually unlock the lock when it was acquired multiple times recursively. Instead, an internal interface of the &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; class is used, which really unlocks it even when it has been recursively acquired several times. Another internal interface is then used to restore the recursion level when the lock is reacquired.</source>
          <target state="translated">기본 잠금이 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;#threading.Condition.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 잠금을 해제하지 않습니다. 잠금이 여러 번 재귀 적으로 획득되었을 때 잠금을 실제로 잠금 해제하지 못할 수 있습니다. 대신 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 클래스 의 내부 인터페이스 가 사용되는데,이 인터페이스는 재귀 적으로 여러 번 획득 한 경우에도 실제로 잠금을 해제합니다. 그런 다음 다른 내부 인터페이스를 사용하여 잠금을 다시 획득 할 때 재귀 수준을 복원합니다.</target>
        </trans-unit>
        <trans-unit id="a547e1586802e299eb73e97be7ee39d485999089" translate="yes" xml:space="preserve">
          <source>When the view in the widget&amp;rsquo;s window change, the widget will generate a Tcl command based on the scrollcommand.</source>
          <target state="translated">위젯 창의보기가 변경되면 위젯은 scroll 명령을 기반으로 Tcl 명령을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="befa970eff3f7ebe6809143ffe66cd7843089ead" translate="yes" xml:space="preserve">
          <source>When there are two numbers in the first column (for example &lt;code&gt;3/1&lt;/code&gt;), it means that the function recursed. The second value is the number of primitive calls and the former is the total number of calls. Note that when the function does not recurse, these two values are the same, and only the single figure is printed.</source>
          <target state="translated">첫 번째 열에 두 개의 숫자 (예 : &lt;code&gt;3/1&lt;/code&gt; )가 있으면 함수가 반복되었음을 의미합니다. 두 번째 값은 기본 통화 수이고 전자는 총 통화 수입니다. 함수가 되풀이되지 않으면이 두 값은 동일하며 단일 숫자 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ab22dc5a231f8fc7cacd590361630a5e4a9cd4ba" translate="yes" xml:space="preserve">
          <source>When there are very small differences among your tests, for instance some parameters, unittest allows you to distinguish them inside the body of a test method using the &lt;a href=&quot;#unittest.TestCase.subTest&quot;&gt;&lt;code&gt;subTest()&lt;/code&gt;&lt;/a&gt; context manager.</source>
          <target state="translated">테스트간에 약간의 차이가있을 경우 (예 : 일부 매개 변수), unittest를 사용하면 &lt;a href=&quot;#unittest.TestCase.subTest&quot;&gt; &lt;code&gt;subTest()&lt;/code&gt; &lt;/a&gt; 컨텍스트 관리자를 사용하여 테스트 메소드 본문 내에서이를 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c77d278084a249196dc8ad39e0428b94116b8a" translate="yes" xml:space="preserve">
          <source>When this attribute exists, its value is automatically called (with no arguments) when the interpreter is launched in &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt;. This is done after the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file is read, so that you can set this hook there. The &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module &lt;a href=&quot;site#rlcompleter-config&quot;&gt;sets this&lt;/a&gt;.</source>
          <target state="translated">이 속성이 존재하면 인터프리터가 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;대화식 모드&lt;/a&gt; 에서 시작될 때 값이 인수없이 자동으로 호출 됩니다 . 이것은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; &lt;/a&gt; 파일을 읽은 후에 수행 되므로이 후크를 설정할 수 있습니다. &lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 모듈 &lt;a href=&quot;site#rlcompleter-config&quot;&gt;이 설정됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5561b0bcfc3026fbfdb899d58edadb60d7787f" translate="yes" xml:space="preserve">
          <source>When this module is imported on a Unix platform with the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module available, an instance of the &lt;code&gt;Completer&lt;/code&gt; class is automatically created and its &lt;code&gt;complete()&lt;/code&gt; method is set as the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; completer.</source>
          <target state="translated">&lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈을 사용할 수 있는 Unix 플랫폼에서이 모듈을 가져 오면 &lt;code&gt;Completer&lt;/code&gt; 클래스 의 인스턴스 가 자동으로 생성되고 &lt;code&gt;complete()&lt;/code&gt; 메서드가 &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; completer 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="51abaa779be741115f9981dd161abaf14ca5f234" translate="yes" xml:space="preserve">
          <source>When this module is run as a script, the &lt;a href=&quot;#py_compile.main&quot;&gt;&lt;code&gt;main()&lt;/code&gt;&lt;/a&gt; is used to compile all the files named on the command line. The exit status is nonzero if one of the files could not be compiled.</source>
          <target state="translated">이 모듈이 스크립트로 실행될 때 &lt;a href=&quot;#py_compile.main&quot;&gt; &lt;code&gt;main()&lt;/code&gt; &lt;/a&gt; 은 명령 행에 이름이 지정된 모든 파일을 컴파일하는 데 사용됩니다. 파일 중 하나를 컴파일 할 수없는 경우 종료 상태는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ad505c5cec1abb554c0e70fe34e8dfe5e8ee251d" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is a URL.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 URL입니다.</target>
        </trans-unit>
        <trans-unit id="c4271730cf91863d7eba060c9ce05e17fb1e5d3d" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is a fully-qualified domain name.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 정규화 된 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="df57f6bd5424a2b48ed53224b034c92f20111436" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is an ISO OID.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 ISO OID입니다.</target>
        </trans-unit>
        <trans-unit id="b118949a5b99f77f5500b4d3f0d5939a3e84377f" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is an X.500 DN in DER or a text output format.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 DER의 X.500 DN 또는 텍스트 출력 형식입니다.</target>
        </trans-unit>
        <trans-unit id="1ac5dffa9ac6727f876535e5fe1228a53748f38d" translate="yes" xml:space="preserve">
          <source>When this variable is set to an integer value, it determines the maximum number of levels of traceback information printed when an unhandled exception occurs. The default is &lt;code&gt;1000&lt;/code&gt;. When set to &lt;code&gt;0&lt;/code&gt; or less, all traceback information is suppressed and only the exception type and value are printed.</source>
          <target state="translated">이 변수가 정수 값으로 설정되면 처리되지 않은 예외가 발생할 때 인쇄되는 최대 역 추적 정보 레벨 수를 판별합니다. 기본값은 &lt;code&gt;1000&lt;/code&gt; 입니다. &lt;code&gt;0&lt;/code&gt; 이하로 설정하면 모든 역 추적 정보가 억제되고 예외 유형 및 값만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="278cf1fb88404480dadf9b626eaab7ebb46fb611" translate="yes" xml:space="preserve">
          <source>When threads are enabled, this function can only be called from the main thread; attempting to call it from other threads will cause a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception to be raised.</source>
          <target state="translated">스레드가 활성화되면이 기능은 기본 스레드에서만 호출 할 수 있습니다. 다른 스레드에서 호출하려고하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa49c23d5b633ba09194c60a98a0663082ee806f" translate="yes" xml:space="preserve">
          <source>When to use __new__() vs. __init__()</source>
          <target state="translated">__new __ () 및 __init __ ()을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="ae8e822e628357a56fee4e1e237f47916afdb25d" translate="yes" xml:space="preserve">
          <source>When trying to answer questions of the form &amp;ldquo;how do I do blah&amp;rdquo;, it is often best to find out how to do &amp;ldquo;blah&amp;rdquo; in straight Tk, and then convert this back into the corresponding &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; call. Python programmers can often guess at the correct Python command by looking at the Tk documentation. This means that in order to use Tkinter, you will have to know a little bit about Tk. This document can&amp;rsquo;t fulfill that role, so the best we can do is point you to the best documentation that exists. Here are some hints:</source>
          <target state="translated">&amp;ldquo;어떻게해야합니까?&amp;rdquo;형식의 질문에 대답하려고 할 때, 직선 Tk에서&amp;ldquo;blah&amp;rdquo;를 수행하는 방법을 찾은 다음이를 해당 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 호출 로 다시 변환하는 것이 가장 좋습니다 . 파이썬 프로그래머는 종종 Tk 문서를보고 올바른 파이썬 명령을 추측 할 수 있습니다. 이것은 Tkinter를 사용하기 위해서는 Tk에 대해 약간 알아야한다는 것을 의미합니다. 이 문서는 그 역할을 수행 할 수 없으므로 최선을 다하는 것이 최선의 문서를 제시하는 것입니다. 힌트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76b7fde33d91393f4e37520e38b01684ea8be333" translate="yes" xml:space="preserve">
          <source>When trying to resolve a path that may contain links, use &lt;a href=&quot;os.path#os.path.realpath&quot;&gt;&lt;code&gt;realpath()&lt;/code&gt;&lt;/a&gt; to properly handle recursion and platform differences.</source>
          <target state="translated">링크가 포함 된 경로를 해결하려고 할 때 &lt;a href=&quot;os.path#os.path.realpath&quot;&gt; &lt;code&gt;realpath()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 재귀 및 플랫폼 차이를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="2f3811d14f89d59ba51a06a1a040db1eba48fe96" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt;&lt;code&gt;patch.dict()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; (default to &lt;code&gt;'test'&lt;/code&gt;) for choosing which methods to wrap:</source>
          <target state="translated">클래스 데코레이터로 사용될 때 &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt; &lt;code&gt;patch.dict()&lt;/code&gt; &lt;/a&gt; 는 포장 할 메소드를 선택 하기 위해 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; (기본값은 &lt;code&gt;'test'&lt;/code&gt; )를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="705e7c80833fc33cb99db4df5a3694a333edc598" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; for choosing which methods to wrap.</source>
          <target state="translated">클래스 데코레이터로 사용될 때 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 은 어떤 메소드를 포장할지 선택하는 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="5b03309707733138089592715f0e9b9ff4448b18" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt;&lt;code&gt;patch.object()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; for choosing which methods to wrap.</source>
          <target state="translated">클래스 데코레이터로 사용될 때 &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt; &lt;code&gt;patch.object()&lt;/code&gt; &lt;/a&gt; 는 어떤 메소드를 포장할지 선택하는 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="fba105ce35abd2dc08e1a686f3ddd015c632904f" translate="yes" xml:space="preserve">
          <source>When used as a context manager, &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt; accepts the additional keyword argument &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용될 때 &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; 는 추가 키워드 인수 &lt;em&gt;msg를&lt;/em&gt; 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="83414cd2e98b72f702142fb8a769008e29f7a984" translate="yes" xml:space="preserve">
          <source>When used as a context manager, &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt;&lt;code&gt;assertWarns()&lt;/code&gt;&lt;/a&gt; accepts the additional keyword argument &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용될 때 &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt; &lt;code&gt;assertWarns()&lt;/code&gt; &lt;/a&gt; 는 추가 키워드 인수 &lt;em&gt;msg를&lt;/em&gt; 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a119452aa32cdce61667b0d150a3806d0c9b047c" translate="yes" xml:space="preserve">
          <source>When used with the &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;%U&lt;/code&gt; and &lt;code&gt;%W&lt;/code&gt; are only used in calculations when the day of the week and the year are specified.</source>
          <target state="translated">&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 함수 와 함께 사용하면 &lt;code&gt;%U&lt;/code&gt; 및 &lt;code&gt;%W&lt;/code&gt; 는 요일과 연도가 지정된 경우에만 계산에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c496b450e8c39131b7391ec30143aac02a4ea29" translate="yes" xml:space="preserve">
          <source>When used with the &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; function, the &lt;code&gt;%p&lt;/code&gt; directive only affects the output hour field if the &lt;code&gt;%I&lt;/code&gt; directive is used to parse the hour.</source>
          <target state="translated">함께 사용하면 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 함수는 &lt;code&gt;%p&lt;/code&gt; 경우 생성 지시문은 출력 시간 필드 영향 &lt;code&gt;%I&lt;/code&gt; 지정이 시간을 해석하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="53f6e3b18d54172809724ec98b1116def825fde0" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, &lt;code&gt;%U&lt;/code&gt; and &lt;code&gt;%W&lt;/code&gt; are only used in calculations when the day of the week and the calendar year (&lt;code&gt;%Y&lt;/code&gt;) are specified.</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드 와 함께 사용하면 &lt;code&gt;%U&lt;/code&gt; 및 &lt;code&gt;%W&lt;/code&gt; 는 요일과 달력 연도 ( &lt;code&gt;%Y&lt;/code&gt; )가 지정된 경우에만 계산에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="4b2ee1207071c0489d96d299dd458032cc3f29e2" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the &lt;code&gt;%f&lt;/code&gt; directive accepts from one to six digits and zero pads on the right. &lt;code&gt;%f&lt;/code&gt; is an extension to the set of format characters in the C standard (but implemented separately in datetime objects, and therefore always available).</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드 와 함께 사용되는 경우, &lt;code&gt;%f&lt;/code&gt; 지시문은 오른쪽에 1-6 자리 숫자와 제로 패드를 허용합니다. &lt;code&gt;%f&lt;/code&gt; 는 C 표준의 형식 문자 세트에 대한 확장입니다 (하지만 datetime 오브젝트에 별도로 구현되므로 항상 사용 가능함).</target>
        </trans-unit>
        <trans-unit id="dc1c5087fa82a6d1840533fce5b820256e369ddd" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the &lt;code&gt;%p&lt;/code&gt; directive only affects the output hour field if the &lt;code&gt;%I&lt;/code&gt; directive is used to parse the hour.</source>
          <target state="translated">함께 사용하면 &lt;code&gt;strptime()&lt;/code&gt; 에있어서, 상기 &lt;code&gt;%p&lt;/code&gt; 경우 생성 지시문은 출력 시간 필드 영향 &lt;code&gt;%I&lt;/code&gt; 지정이 시간을 해석하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="8b8a227fcef52e704757038bfb5a5f8a8ba80e0a" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the leading zero is optional for formats &lt;code&gt;%d&lt;/code&gt;, &lt;code&gt;%m&lt;/code&gt;, &lt;code&gt;%H&lt;/code&gt;, &lt;code&gt;%I&lt;/code&gt;, &lt;code&gt;%M&lt;/code&gt;, &lt;code&gt;%S&lt;/code&gt;, &lt;code&gt;%J&lt;/code&gt;, &lt;code&gt;%U&lt;/code&gt;, &lt;code&gt;%W&lt;/code&gt;, and &lt;code&gt;%V&lt;/code&gt;. Format &lt;code&gt;%y&lt;/code&gt; does require a leading zero.</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드 와 함께 사용되는 경우 앞에 오는 0은 형식 &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%m&lt;/code&gt; , &lt;code&gt;%H&lt;/code&gt; , &lt;code&gt;%I&lt;/code&gt; , &lt;code&gt;%M&lt;/code&gt; , &lt;code&gt;%S&lt;/code&gt; , &lt;code&gt;%J&lt;/code&gt; , &lt;code&gt;%U&lt;/code&gt; , &lt;code&gt;%W&lt;/code&gt; 및 &lt;code&gt;%V&lt;/code&gt; 입니다. &lt;code&gt;%y&lt;/code&gt; 형식 은 앞에 0이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8993c4db89e355448ee2758089ff089b6167f894" translate="yes" xml:space="preserve">
          <source>When user code raises SystemExit either directly or by calling sys.exit, IDLE returns to a Shell prompt instead of exiting.</source>
          <target state="translated">사용자 코드가 직접 또는 sys.exit를 호출하여 SystemExit를 발생 시키면 IDLE은 종료하지 않고 쉘 프롬프트로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e8d99d6e745dcc773c5780813fa3d777f5ab117b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#cmdoption-trace-r&quot;&gt;&lt;code&gt;--report&lt;/code&gt;&lt;/a&gt;, write a brief summary to stdout for each file processed.</source>
          <target state="translated">&lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#cmdoption-trace-r&quot;&gt; &lt;code&gt;--report&lt;/code&gt; 를&lt;/a&gt; 사용할 때는 처리 된 각 파일에 대해 간단한 요약을 stdout에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d69285961c4bd67c93bcd61d97d840352615a6b6" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt;, this method chops &lt;em&gt;iterables&lt;/em&gt; into a number of chunks which it submits to the pool as separate tasks. The (approximate) size of these chunks can be specified by setting &lt;em&gt;chunksize&lt;/em&gt; to a positive integer. For very long iterables, using a large value for &lt;em&gt;chunksize&lt;/em&gt; can significantly improve performance compared to the default size of 1. With &lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;chunksize&lt;/em&gt; has no effect.</source>
          <target state="translated">사용시 &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; 를&lt;/a&gt; ,이 방법은 자르면 &lt;em&gt;반복 가능 객체를&lt;/em&gt; 이 분리 작업시에 풀에 제출 청크들로. 이 청크의 대략적인 크기는 &lt;em&gt;chunksize&lt;/em&gt; 를 양의 정수 로 설정하여 지정할 수 있습니다 . 에 대한 큰 값을 사용하여 매우 긴 반복 가능 객체의 경우, &lt;em&gt;chunksize 영역은&lt;/em&gt; 크게 1.의 기본 크기에 비해 성능을 향상시킬 수 &lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; , &lt;em&gt;chunksize 영역은&lt;/em&gt; 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="67dbf8b14ab5b34c346cf0ec2ca601d364ad77a4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;shell=True&lt;/code&gt;, the &lt;a href=&quot;shlex#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; function can be used to properly escape whitespace and shell metacharacters in strings that are going to be used to construct shell commands.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;shell=True&lt;/code&gt; 의 &lt;a href=&quot;shlex#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 기능이 제대로 구조 쉘 명령에 사용하려고하는 문자열의 공백과 쉘 메타 문자를 탈출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8018ded6871ec6f5c2db4b1df5eb57ea72056b" translate="yes" xml:space="preserve">
          <source>When using IDLE, tooltips show the signatures and first lines of the docstrings of typed in function-/method calls.</source>
          <target state="translated">IDLE을 사용할 때 툴팁은 함수 / 메소드 호출에 입력 된 문서 문자열의 서명과 첫 줄을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6a5ee388e1f0b24ab337fb675482fe01a76a1b13" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;SharedMemoryManager&lt;/code&gt; in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, the shared memory blocks created using that manager are all released when the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement&amp;rsquo;s code block finishes execution.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;SharedMemoryManager&lt;/code&gt; 을 A의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문, 공유 메모리 블록이 모두 출시되는 관리자를 사용하여 만들 때 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 코드 블록이 완료 실행.</target>
        </trans-unit>
        <trans-unit id="cff5871a771c52192ce76b27da8593fb1ba702e3" translate="yes" xml:space="preserve">
          <source>When using any of the policy objects derived from &lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicy&lt;/code&gt;&lt;/a&gt;, all headers are produced by &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt; and have &lt;a href=&quot;#email.headerregistry.BaseHeader&quot;&gt;&lt;code&gt;BaseHeader&lt;/code&gt;&lt;/a&gt; as their last base class. Each header class has an additional base class that is determined by the type of the header. For example, many headers have the class &lt;a href=&quot;#email.headerregistry.UnstructuredHeader&quot;&gt;&lt;code&gt;UnstructuredHeader&lt;/code&gt;&lt;/a&gt; as their other base class. The specialized second class for a header is determined by the name of the header, using a lookup table stored in the &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt;. All of this is managed transparently for the typical application program, but interfaces are provided for modifying the default behavior for use by more complex applications.</source>
          <target state="translated">&lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicy&lt;/code&gt; &lt;/a&gt; 에서 파생 된 정책 객체를 사용하는 경우 모든 헤더는 &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; 에&lt;/a&gt; 의해 생성되며 마지막 기본 클래스로 &lt;a href=&quot;#email.headerregistry.BaseHeader&quot;&gt; &lt;code&gt;BaseHeader&lt;/code&gt; &lt;/a&gt; 를 갖 습니다 . 각 헤더 클래스에는 헤더 유형에 따라 결정되는 추가 기본 클래스가 있습니다. 예를 들어 많은 헤더에는 다른 기본 클래스로 &lt;a href=&quot;#email.headerregistry.UnstructuredHeader&quot;&gt; &lt;code&gt;UnstructuredHeader&lt;/code&gt; &lt;/a&gt; 클래스가 있습니다. 헤더의 특수한 두 번째 클래스는 &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; 에&lt;/a&gt; 저장된 조회 테이블을 사용하여 헤더 이름으로 결정됩니다 . 이 모든 것은 일반적인 응용 프로그램에 대해 투명하게 관리되지만보다 복잡한 응용 프로그램에서 사용할 수 있도록 기본 동작을 수정하기위한 인터페이스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b05e16fdd139b928e5d9f97d7e26405bb10ad23a" translate="yes" xml:space="preserve">
          <source>When using array objects from code written in C or C++ (the only way to effectively make use of this information), it makes more sense to use the buffer interface supported by array objects. This method is maintained for backward compatibility and should be avoided in new code. The buffer interface is documented in &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;.</source>
          <target state="translated">C 또는 C ++로 작성된 코드에서 배열 오브젝트를 사용할 때 (이 정보를 효과적으로 사용하는 유일한 방법) 배열 오브젝트가 지원하는 버퍼 인터페이스를 사용하는 것이 더 합리적입니다. 이 방법은 이전 버전과의 호환성을 위해 유지되므로 새 코드에서는 사용하지 않아야합니다. 버퍼 인터페이스는 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b80cace7f20688ab820fe8baf0df818b93de50" translate="yes" xml:space="preserve">
          <source>When using multiple processes, one generally uses message passing for communication between processes and avoids having to use any synchronization primitives like locks.</source>
          <target state="translated">다중 프로세스를 사용할 때 일반적으로 프로세스 간 통신을 위해 메시지 전달을 사용하고 잠금과 같은 동기화 기본 요소를 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd6a46b825093b75110261b57205d3c8b35775e" translate="yes" xml:space="preserve">
          <source>When using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start methods many types from &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; need to be picklable so that child processes can use them. However, one should generally avoid sending shared objects to other processes using pipes or queues. Instead you should arrange the program so that a process which needs access to a shared resource created elsewhere can inherit it from an ancestor process.</source>
          <target state="translated">사용하는 경우 &lt;em&gt;산란을&lt;/em&gt; 하거나 &lt;em&gt;forkserver&lt;/em&gt; 에서 방법에게 많은 유형을 시작 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 이 자식 프로세스를 사용할 수 있도록 요구하는 것은 picklable 수 있습니다. 그러나 일반적으로 파이프 나 큐를 사용하여 공유 객체를 다른 프로세스로 보내지 않아야합니다. 대신 다른 곳에서 작성된 공유 자원에 액세스해야하는 프로세스가 상위 프로세스에서이를 상속 할 수 있도록 프로그램을 배열해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f3d8f9182ed3d95d5c0426514f0709e918d398" translate="yes" xml:space="preserve">
          <source>When using this pattern, remember that all classes that inherit from &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt; are run as tests. The &lt;code&gt;Mixin&lt;/code&gt; class in the example above does not have any data and so can&amp;rsquo;t be run by itself, thus it does not inherit from &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 패턴을 사용할 때 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt; 에서 상속 된 모든 클래스는 테스트로 실행됩니다. 위 예제 의 &lt;code&gt;Mixin&lt;/code&gt; 클래스에는 데이터가 없으므로 자체적으로 실행할 수 없으므로 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt; 에서 상속되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3bc63598e62f8448d98f0887d22314a85ab47257" translate="yes" xml:space="preserve">
          <source>When using weekday-based rotation, specify &amp;lsquo;W0&amp;rsquo; for Monday, &amp;lsquo;W1&amp;rsquo; for Tuesday, and so on up to &amp;lsquo;W6&amp;rsquo; for Sunday. In this case, the value passed for &lt;em&gt;interval&lt;/em&gt; isn&amp;rsquo;t used.</source>
          <target state="translated">주중 회전을 사용할 때는 월요일에 'W0', 화요일에 'W1'등을 일요일에 'W6'까지 지정하십시오. 이 경우 &lt;em&gt;interval에&lt;/em&gt; 전달 된 값 은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6aea84bd51b5a34854466c47a84c480e9d183e1" translate="yes" xml:space="preserve">
          <source>When working in a command shell, users can make a virtual environment active by running an &lt;code&gt;activate&lt;/code&gt; script in the virtual environment&amp;rsquo;s executables directory (the precise filename and command to use the file is shell-dependent), which prepends the virtual environment&amp;rsquo;s directory for executables to the &lt;code&gt;PATH&lt;/code&gt; environment variable for the running shell. There should be no need in other circumstances to activate a virtual environment; scripts installed into virtual environments have a &amp;ldquo;shebang&amp;rdquo; line which points to the virtual environment&amp;rsquo;s Python interpreter. This means that the script will run with that interpreter regardless of the value of &lt;code&gt;PATH&lt;/code&gt;. On Windows, &amp;ldquo;shebang&amp;rdquo; line processing is supported if you have the Python Launcher for Windows installed (this was added to Python in 3.3 - see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0397&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 397&lt;/strong&gt;&lt;/a&gt; for more details). Thus, double-clicking an installed script in a Windows Explorer window should run the script with the correct interpreter without there needing to be any reference to its virtual environment in &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">명령 셸에서 작업 할 때 사용자는 가상 환경의 실행 파일 디렉토리 (파일을 사용하는 정확한 파일 이름 및 명령이 셸에 따라 다름)에서 &lt;code&gt;activate&lt;/code&gt; 스크립트를 실행하여 가상 환경을 활성화 할 수 있습니다. 실행중인 쉘 의 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 다른 환경에서는 가상 환경을 활성화 할 필요가 없습니다. 가상 환경에 설치된 스크립트에는 가상 환경의 Python 인터프리터를 가리키는 &quot;shebang&quot;줄이 있습니다. 이는 스크립트가 &lt;code&gt;PATH&lt;/code&gt; 값에 관계없이 해당 인터프리터와 함께 실행됨을 의미합니다. Windows에서는 Windows 용 Python Launcher를 설치 한 경우 &quot;shebang&quot;라인 처리가 지원됩니다 (3.3에서 Python에 추가됨- 자세한 내용 은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0397&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 397&lt;/strong&gt;&lt;/a&gt; 참조). 따라서 Windows 탐색기 창에서 설치된 스크립트를 두 번 클릭하면 &lt;code&gt;PATH&lt;/code&gt; 의 가상 환경에 대한 참조가 없어도 올바른 인터프리터로 스크립트를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8a8029dbde9896495f35f3b5cc6049139cf4061" translate="yes" xml:space="preserve">
          <source>When writing a docstring, choose docstring examples with care. There&amp;rsquo;s an art to this that needs to be learned&amp;mdash;it may not be natural at first. Examples should add genuine value to the documentation. A good example can often be worth many words. If done with care, the examples will be invaluable for your users, and will pay back the time it takes to collect them many times over as the years go by and things change. I&amp;rsquo;m still amazed at how often one of my &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; examples stops working after a &amp;ldquo;harmless&amp;rdquo; change.</source>
          <target state="translated">docstring을 작성할 때 docstring 예제를 신중하게 선택하십시오. 여기에는 배워야 할 예술이 있습니다. 처음에는 자연스럽지 않을 수도 있습니다. 예제는 문서에 진정한 가치를 부여해야합니다. 좋은 예는 종종 많은 단어의 가치가 있습니다. 주의를 기울이면 예제는 사용자에게 귀중한 것이며 시간이 지남에 따라 여러 번 수집하는 데 걸리는 시간을 상환 할 것입니다. 나는 여전히 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 예제 중 하나가 &quot;무해한&quot;변경 후에 작동을 멈추는 빈도에 놀랐습니다 .</target>
        </trans-unit>
        <trans-unit id="8592ae082c5c9b46046c7a2f018c32ed0f608909" translate="yes" xml:space="preserve">
          <source>When writing a file, if the file size is not known in advance but may exceed 2 GiB, pass &lt;code&gt;force_zip64=True&lt;/code&gt; to ensure that the header format is capable of supporting large files. If the file size is known in advance, construct a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; object with &lt;a href=&quot;#zipfile.ZipInfo.file_size&quot;&gt;&lt;code&gt;file_size&lt;/code&gt;&lt;/a&gt; set, and use that as the &lt;em&gt;name&lt;/em&gt; parameter.</source>
          <target state="translated">파일을 쓸 때 파일 크기를 미리 알 수 없지만 &lt;code&gt;force_zip64=True&lt;/code&gt; 초과 할 수있는 경우 force_zip64 = True 를 전달 하여 헤더 형식이 큰 파일을 지원할 수 있는지 확인하십시오. 파일 크기가 미리 알려진 경우 &lt;a href=&quot;#zipfile.ZipInfo.file_size&quot;&gt; &lt;code&gt;file_size&lt;/code&gt; 가&lt;/a&gt; 설정된 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 객체를 구성하고 이를&lt;em&gt; 이름&lt;/em&gt; 매개 변수로 사용하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eabb64e4773edb5fffc016299f8bed93923cd8c" translate="yes" xml:space="preserve">
          <source>When writing output to the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, any &lt;code&gt;'\n'&lt;/code&gt; characters written are translated to the system default line separator, &lt;a href=&quot;os#os.linesep&quot;&gt;&lt;code&gt;os.linesep&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;''&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt;, no translation takes place. If &lt;em&gt;newline&lt;/em&gt; is any of the other legal values, any &lt;code&gt;'\n'&lt;/code&gt; characters written are translated to the given string.</source>
          <target state="translated">출력을 스트림에 쓸 때 &lt;em&gt;줄 바꿈&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이면 기록 된 &lt;code&gt;'\n'&lt;/code&gt; 문자는 시스템 기본 줄 구분자 &lt;a href=&quot;os#os.linesep&quot;&gt; &lt;code&gt;os.linesep&lt;/code&gt; 로 변환&lt;/a&gt; 됩니다. 경우 &lt;em&gt;줄 바꿈이&lt;/em&gt; 있다 &lt;code&gt;''&lt;/code&gt; 또는 &lt;code&gt;'\n'&lt;/code&gt; , 어떤 번역은 일어나지 않는다. 경우 &lt;em&gt;줄 바꿈이&lt;/em&gt; 다른 법적 값 중 하나입니다, 어떤 &lt;code&gt;'\n'&lt;/code&gt; 쓴 문자는 주어진 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="067f2ecb8b6372c1f3e42f05250baae071a8c1df" translate="yes" xml:space="preserve">
          <source>When writing to the path fails because the path is read-only (&lt;a href=&quot;errno#errno.EACCES&quot;&gt;&lt;code&gt;errno.EACCES&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;exceptions#PermissionError&quot;&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/a&gt;), do not propagate the exception.</source>
          <target state="translated">경로가 읽기 전용 ( &lt;a href=&quot;errno#errno.EACCES&quot;&gt; &lt;code&gt;errno.EACCES&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;exceptions#PermissionError&quot;&gt; &lt;code&gt;PermissionError&lt;/code&gt; &lt;/a&gt; ) 이므로 경로 에 쓰지 못하는 경우 예외를 전파하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0aec152755409343dddc07ce07a2031e69c7060e" translate="yes" xml:space="preserve">
          <source>When you are finished with a DOM tree, you may optionally call the &lt;code&gt;unlink()&lt;/code&gt; method to encourage early cleanup of the now-unneeded objects. &lt;code&gt;unlink()&lt;/code&gt; is an &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;-specific extension to the DOM API that renders the node and its descendants are essentially useless. Otherwise, Python&amp;rsquo;s garbage collector will eventually take care of the objects in the tree.</source>
          <target state="translated">DOM 트리가 끝나면 필요에 따라 &lt;code&gt;unlink()&lt;/code&gt; 메소드를 호출하여 필요없는 객체를 조기에 정리할 수 있습니다. &lt;code&gt;unlink()&lt;/code&gt; 는 노드를 렌더링하는 DOM API에 대한 &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 특정 확장이며 그 하위 항목은 본질적으로 쓸모가 없습니다. 그렇지 않으면 파이썬의 가비지 수집기는 결국 트리의 객체를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d8b4b9124db1d9506c6395b32b710d76c6d1388e" translate="yes" xml:space="preserve">
          <source>When you attach a mock as an attribute of another mock (or as the return value) it becomes a &amp;ldquo;child&amp;rdquo; of that mock. Calls to the child are recorded in the &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt;&lt;code&gt;method_calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; attributes of the parent. This is useful for configuring child mocks and then attaching them to the parent, or for attaching mocks to a parent that records all calls to the children and allows you to make assertions about the order of calls between mocks:</source>
          <target state="translated">모의 객체를 다른 모의 속성 (또는 반환 값)으로 첨부하면 해당 모의 &quot;자식&quot;이됩니다. 자식에 대한 호출 은 부모 의 &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt; &lt;code&gt;method_calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; 속성에 기록됩니다 . 이는 자식 모의를 구성한 다음 부모에 연결하거나 자식에 대한 모든 호출을 기록하고 모의 호출 순서에 대한 어설 션을 만들 수있는 모의 부모에 연결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="be1b470500af8dd6da06d2ce49d4cefe28a83a6b" translate="yes" xml:space="preserve">
          <source>When you compile a node tree with &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, the compiler expects &lt;code&gt;lineno&lt;/code&gt; and &lt;code&gt;col_offset&lt;/code&gt; attributes for every node that supports them. This is rather tedious to fill in for generated nodes, so this helper adds these attributes recursively where not already set, by setting them to the values of the parent node. It works recursively starting at &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 으로 노드 트리를 컴파일 할 때 컴파일러는 이를 지원하는 모든 노드에 대해 &lt;code&gt;lineno&lt;/code&gt; 및 &lt;code&gt;col_offset&lt;/code&gt; 속성을 예상 합니다. 이는 생성 된 노드를 채우는 데 다소 지루하므로,이 헬퍼는 이러한 속성을 아직 설정되지 않은 위치에 부모 노드의 값으로 설정하여 재귀 적으로 추가합니다. &lt;em&gt;node&lt;/em&gt; 에서 재귀 적으로 시작 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8168a6e30b1a0dd14b3d6bed0aa248b7873034b1" translate="yes" xml:space="preserve">
          <source>When you have a consistent answer, there are three ways you can use it:</source>
          <target state="translated">일관된 답변이 있으면 세 가지 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="980c6f4da1cfe70fd805b5d970a5223e7e867fdd" translate="yes" xml:space="preserve">
          <source>When you have finished providing data to the compressor, call the &lt;a href=&quot;#bz2.BZ2Compressor.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; method to finish the compression process.</source>
          <target state="translated">압축기에 데이터를 제공 한 후 &lt;a href=&quot;#bz2.BZ2Compressor.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 압축 프로세스를 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="ebaa64dbb3e64356296053a73cf19b2addb5348d" translate="yes" xml:space="preserve">
          <source>When you have placed your tests in a module, the module can itself be the test runner. When a test fails, you can arrange for your test runner to re-run only the failing doctest while you debug the problem. Here is a minimal example of such a test runner:</source>
          <target state="translated">테스트를 모듈에 배치하면 모듈 자체가 테스트 실행자가 될 수 있습니다. 테스트가 실패하면 문제를 디버그하는 동안 테스트 실행기가 실패한 doctest 만 다시 실행하도록 할 수 있습니다. 다음은 이러한 테스트 러너의 최소 예입니다.</target>
        </trans-unit>
        <trans-unit id="f6bcd3b04b0d7cac7cf2e9d8396970c1121f17d6" translate="yes" xml:space="preserve">
          <source>When you nest patch decorators the mocks are passed in to the decorated function in the same order they applied (the normal &lt;em&gt;Python&lt;/em&gt; order that decorators are applied). This means from the bottom up, so in the example above the mock for &lt;code&gt;module.ClassName1&lt;/code&gt; is passed in first.</source>
          <target state="translated">패치 데코레이터를 중첩하면 모의 객체는 적용한 순서 ( 데코레이터가 적용되는 일반적인 &lt;em&gt;Python&lt;/em&gt; 순서)로 꾸며진 함수에 전달됩니다 . 이것은 위에서 아래를 의미하므로 위의 예에서 &lt;code&gt;module.ClassName1&lt;/code&gt; 에 대한 모의 가 먼저 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4d0ae07c9462ed9e0e688008d531cdc33cae796d" translate="yes" xml:space="preserve">
          <source>When you use the context to connect to a server, &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; validate the server certificate: it ensures that the server certificate was signed with one of the CA certificates, checks the signature for correctness, and verifies other properties like validity and identity of the hostname:</source>
          <target state="translated">컨텍스트를 사용하여 서버에 연결하는 경우 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt; 은 서버 인증서의 유효성을 검증합니다. 서버 인증서가 CA 인증서 중 하나로 서명되었는지 확인하고, 서명이 올바른지 확인하고, 유효성 및 ID와 같은 다른 특성을 검증합니다. 호스트 이름 :</target>
        </trans-unit>
        <trans-unit id="693ee6b490569d4d5711a3b5add559ce77978de6" translate="yes" xml:space="preserve">
          <source>When you write a new script, consider adding these lines:</source>
          <target state="translated">새 스크립트를 작성할 때 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="205afaa9a1fee6195f966485ecd67e9562f2bb6a" translate="yes" xml:space="preserve">
          <source>Whenever &lt;em&gt;x&lt;/em&gt; or &lt;em&gt;y&lt;/em&gt; arguments to a function or a method are optional, they default to the current cursor location. Whenever &lt;em&gt;attr&lt;/em&gt; is optional, it defaults to &lt;code&gt;A_NORMAL&lt;/code&gt;.</source>
          <target state="translated">때마다 &lt;em&gt;X&lt;/em&gt; 또는 &lt;em&gt;Y&lt;/em&gt; 함수 나 방법에 대한 인수는 선택, 그들은 현재의 커서 위치에 기본. &lt;em&gt;attr&lt;/em&gt; 이 선택적 일 때마다 기본값은 &lt;code&gt;A_NORMAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8765d4b8962f94d6b6eef545316618c01d52eff3" translate="yes" xml:space="preserve">
          <source>Whenever the documentation mentions a &lt;em&gt;character string&lt;/em&gt; it can be specified as a Unicode string or a byte string.</source>
          <target state="translated">설명서에서 &lt;em&gt;문자열을&lt;/em&gt; 언급 할 때마다 유니 코드 문자열 또는 바이트 문자열로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999400ad526ca682840c4c4ec0cf126c5252625e" translate="yes" xml:space="preserve">
          <source>Whenever the documentation mentions a &lt;em&gt;character&lt;/em&gt; it can be specified as an integer, a one-character Unicode string or a one-byte byte string.</source>
          <target state="translated">설명서에서 &lt;em&gt;문자를&lt;/em&gt; 언급 할 때마다 정수, 1 문자 유니 코드 문자열 또는 1 바이트 바이트 문자열로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bfb2c4bd7e77dce0abe22138a5a1dba3fd4d8e" translate="yes" xml:space="preserve">
          <source>Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is &lt;code&gt;1.0&lt;/code&gt; if the sequences are identical, and &lt;code&gt;0.0&lt;/code&gt; if they have nothing in common.</source>
          <target state="translated">여기서 T는 두 시퀀스의 총 요소 수이고 M은 일치 수입니다. 이는 2.0 * M / T입니다 . 시퀀스가 ​​동일하면 &lt;code&gt;1.0&lt;/code&gt; , 공통점이없는 경우 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0698d3446ab96f16d8d0f4a7d46e511ffaa1b1a" translate="yes" xml:space="preserve">
          <source>Where the components are:</source>
          <target state="translated">구성 요소가있는 위치 :</target>
        </trans-unit>
        <trans-unit id="9043b61aa57de9fe6a9cd0fbf895ea057d46ea33" translate="yes" xml:space="preserve">
          <source>Where the following options are understood:</source>
          <target state="translated">다음 옵션이 이해되는 경우 :</target>
        </trans-unit>
        <trans-unit id="f5a5f04e05ccffc4c2734a94e36079f88e06a02b" translate="yes" xml:space="preserve">
          <source>Where there is no registered implementation for a specific type, its method resolution order is used to find a more generic implementation. The original function decorated with &lt;code&gt;@singledispatch&lt;/code&gt; is registered for the base &lt;code&gt;object&lt;/code&gt; type, which means it is used if no better implementation is found.</source>
          <target state="translated">특정 유형에 대해 등록 된 구현이없는 경우 메소드 해결 순서는보다 일반적인 구현을 찾는 데 사용됩니다. &lt;code&gt;@singledispatch&lt;/code&gt; 로 장식 된 원래 함수 는 기본 &lt;code&gt;object&lt;/code&gt; 유형에 등록되어 있으므로 더 나은 구현이 없으면 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="53573fb4e5abc3ff45094b0052fde922a5a87848" translate="yes" xml:space="preserve">
          <source>Where to patch</source>
          <target state="translated">패치 할 곳</target>
        </trans-unit>
        <trans-unit id="c18e7a9c733c88bde9faa67d79db05fefdfd3ec9" translate="yes" xml:space="preserve">
          <source>Wherever the former background character appears, it is changed to the new background character.</source>
          <target state="translated">이전 배경 문자가 나타날 때마다 새 배경 문자로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0a042ada48fa9e3c00cffdff61a30274621080e2" translate="yes" xml:space="preserve">
          <source>Whether &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; falls back to verify the cert&amp;rsquo;s subject common name in the absence of a subject alternative name extension (default: true).</source>
          <target state="translated">주제 대체 이름 확장자가없는 경우 인증서의 주제 공통 이름을 확인하기 위해 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt; 이 폴백 되는지 여부 (기본값 : true)</target>
        </trans-unit>
        <trans-unit id="8cd43d90a2c53503d089732d23dcac513590b751" translate="yes" xml:space="preserve">
          <source>Whether &lt;em&gt;K&lt;/em&gt; is a member of the set of keys of a &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여부 &lt;em&gt;K는&lt;/em&gt; (A)의 키 세트의 구성원 인 &lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d302d51b9f99d9aa32a01277d93fb96ac09ca34" translate="yes" xml:space="preserve">
          <source>Whether a frame is considered to originate in a certain module is determined by the &lt;code&gt;__name__&lt;/code&gt; in the frame globals.</source>
          <target state="translated">프레임이 특정 모듈에서 시작된 것으로 간주되는지 여부는 프레임 전역 의 &lt;code&gt;__name__&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a943fe736644b8b8c93795478580ff25f5fcf6e7" translate="yes" xml:space="preserve">
          <source>Whether line buffering is enabled.</source>
          <target state="translated">라인 버퍼링 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="04435c32a748b091872ac0d2173dbfad57d8cf08" translate="yes" xml:space="preserve">
          <source>Whether or not two values are considered close is determined according to given absolute and relative tolerances.</source>
          <target state="translated">두 값이 근접한 것으로 간주되는지의 여부는 주어진 절대 및 상대 공차에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="704f9ab62db9376e10128b17cb17cbd1569fe1d7" translate="yes" xml:space="preserve">
          <source>Whether output is buffered is usually determined by &lt;em&gt;file&lt;/em&gt;, but if the &lt;em&gt;flush&lt;/em&gt; keyword argument is true, the stream is forcibly flushed.</source>
          <target state="translated">출력이 버퍼링되는지 여부는 일반적으로 &lt;em&gt;file&lt;/em&gt; 에 의해 결정 되지만 &lt;em&gt;flush&lt;/em&gt; 키워드 인수가 true이면 스트림이 강제로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9704f5d09c8a18f1f4b364c56355a76782182d8" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Application-Layer Protocol Negotiation&lt;/em&gt; TLS extension as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7301.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7301&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">에는 OpenSSL 라이브러리가 내장되어 있는지의 여부에 대한 지원 &lt;em&gt;응용 프로그램 계층 프로토콜 협상&lt;/em&gt; TLS 확장에 설명 된대로 &lt;a href=&quot;https://tools.ietf.org/html/rfc7301.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7301&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f75f6bb7fcb11e2f45c69c0a7ca4c4682d4f5923" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Next Protocol Negotiation&lt;/em&gt; as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&quot;&gt;Application Layer Protocol Negotiation&lt;/a&gt;. When true, you can use the &lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt;&lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt;&lt;/a&gt; method to advertise which protocols you want to support.</source>
          <target state="translated">에는 OpenSSL 라이브러리가 내장되어 있는지의 여부에 대한 지원 &lt;em&gt;다음 프로토콜 협상&lt;/em&gt; 에서 설명한대로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&quot;&gt;응용 계층 프로토콜 협상&lt;/a&gt; . true 인 경우 &lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt; &lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지원하려는 프로토콜을 알릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a2de0f65d5d2e9aa283fe9814ef530df9f4d7f4" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Server Name Indication&lt;/em&gt; extension (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc6066.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 6066&lt;/strong&gt;&lt;/a&gt;).</source>
          <target state="translated">OpenSSL 라이브러리에 &lt;em&gt;서버 이름 표시&lt;/em&gt; 확장 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc6066.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 6066에&lt;/strong&gt;&lt;/a&gt; 정의 된 &lt;strong&gt;대로&lt;/strong&gt; ) 이 기본적으로 지원되는지 여부</target>
        </trans-unit>
        <trans-unit id="f10549c2669f338103d9d69275acd6ff0bb42f85" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the Elliptic Curve-based Diffie-Hellman key exchange. This should be true unless the feature was explicitly disabled by the distributor.</source>
          <target state="translated">OpenSSL 라이브러리가 Elliptic Curve 기반 Diffie-Hellman 키 교환을 기본적으로 지원하는지 여부 이 기능은 배포자가 명시 적으로 비활성화하지 않은 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="189c811d0c4a89efbb0bd31d293ff4f4943d0dbe" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the SSL 2.0 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 SSL 2.0 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="cc2afc4d9cd37973dffe79768c99919a50576238" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the SSL 3.0 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 SSL 3.0 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="89e2466bdf6938ea2d60c44e09f1c3edaea29f39" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.0 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.0 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="adb5564adfd4cdc59e03f6665550cc56692d4f99" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.1 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.1 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="cca6b49130e274478019943c2fbeb20a7cbc1d17" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.2 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.2 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="e350ddccc623cf6675373d55c31c906ec7237c92" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.3 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.3 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="fb7e4191f43e54b167216c9758819c2068bd3dfe" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support not checking subject common name and &lt;a href=&quot;#ssl.SSLContext.hostname_checks_common_name&quot;&gt;&lt;code&gt;SSLContext.hostname_checks_common_name&lt;/code&gt;&lt;/a&gt; is writeable.</source>
          <target state="translated">에는 OpenSSL 라이브러리 지원 확인하지 주제 공통 이름 내장 여부 &lt;a href=&quot;#ssl.SSLContext.hostname_checks_common_name&quot;&gt; &lt;code&gt;SSLContext.hostname_checks_common_name&lt;/code&gt; 은&lt;/a&gt; 쓰기 가능합니다.</target>
        </trans-unit>
        <trans-unit id="88f23b4bf4e20fc7a9bdac4783297fabf3f1c246" translate="yes" xml:space="preserve">
          <source>Whether the currency symbol is separated from the value by a space (for positive resp. negative values).</source>
          <target state="translated">통화 기호가 공백으로 값과 구분되는지 여부 (양의 음수 값).</target>
        </trans-unit>
        <trans-unit id="7bb65cdf22c5687fc74b96fb5b3b8c68399e1532" translate="yes" xml:space="preserve">
          <source>Whether the currency symbol precedes the value (for positive resp. negative values).</source>
          <target state="translated">통화 기호가 값보다 우선하는지 여부 (양의 음수 값).</target>
        </trans-unit>
        <trans-unit id="b6318ba22ae30ad3468f9876a3fd1a5745b34ced" translate="yes" xml:space="preserve">
          <source>Whether the data is buffered, chunked or reassembled depends on the transport. In general, you shouldn&amp;rsquo;t rely on specific semantics and instead make your parsing generic and flexible. However, data is always received in the correct order.</source>
          <target state="translated">데이터의 버퍼링, 청크 분할 또는 재 조립 여부는 전송에 따라 다릅니다. 일반적으로 특정 의미에 의존하지 말고 구문 분석을 일반적이고 유연하게 만드십시오. 그러나 데이터는 항상 올바른 순서로 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="728787761dd4dda0e68398ac7fa7afe469103a47" translate="yes" xml:space="preserve">
          <source>Whether the path points to an existing file or directory:</source>
          <target state="translated">경로가 기존 파일 또는 디렉토리를 가리키는 지 여부 :</target>
        </trans-unit>
        <trans-unit id="7c0b74000f7c6661d85ff5da8e8055be52233230" translate="yes" xml:space="preserve">
          <source>Whether the server will allow the reuse of an address. This defaults to &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, and can be set in subclasses to change the policy.</source>
          <target state="translated">서버가 주소를 재사용 할 수 있는지 여부 기본값은 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 이며 정책을 변경하기 위해 서브 클래스에서 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4273367589a735b6de5ee51a98d1f45ef36ee8a3" translate="yes" xml:space="preserve">
          <source>Whether to match the peer cert&amp;rsquo;s hostname with &lt;a href=&quot;#ssl.match_hostname&quot;&gt;&lt;code&gt;match_hostname()&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt;. The context&amp;rsquo;s &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; must be set to &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;, and you must pass &lt;em&gt;server_hostname&lt;/em&gt; to &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt; in order to match the hostname. Enabling hostname checking automatically sets &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;. It cannot be set back to &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; as long as hostname checking is enabled. The &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt; protocol enables hostname checking by default. With other protocols, hostname checking must be enabled explicitly.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 에서 피어 인증서의 호스트 이름을 &lt;a href=&quot;#ssl.match_hostname&quot;&gt; &lt;code&gt;match_hostname()&lt;/code&gt; &lt;/a&gt; 과 일치 시킬지 여부 입니다. 컨텍스트의 &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 로 설정 되어야 하며 호스트 이름과 일치하도록 &lt;em&gt;server_hostname&lt;/em&gt; 을 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 에 전달해야합니다 . 호스트 이름 확인을 활성화 하면 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; 로 자동 설정됩니다 . 호스트 이름 확인이 활성화 되어 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; 으로 다시 설정할 수 없습니다 . &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; &lt;/a&gt;&lt;em&gt;&lt;/em&gt;프로토콜은 기본적으로 호스트 이름 확인을 활성화합니다. 다른 프로토콜의 경우 호스트 이름 확인을 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b724e20c7a82379a9a08525bdba888f74aefd96" translate="yes" xml:space="preserve">
          <source>Whether to try to verify other peers&amp;rsquo; certificates and how to behave if verification fails. This attribute must be one of &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 피어의 인증서를 확인하려고하는지 여부와 확인에 실패한 경우 동작하는 방법 이 속성은 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="25631d4668b3c0f9f32771f513f7cdbaf448ad8a" translate="yes" xml:space="preserve">
          <source>Whether writes are passed immediately to the underlying binary buffer.</source>
          <target state="translated">쓰기가 기본 바이너리 버퍼로 즉시 전달되는지 여부</target>
        </trans-unit>
        <trans-unit id="71cfd83d887f9f86d88898814a6869aad231de3a" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-package&quot;&gt;package&lt;/a&gt; a module belongs to. If the module is top-level (i.e. not a part of any specific package) then the attribute should be set to &lt;code&gt;''&lt;/code&gt;, else it should be set to the name of the package (which can be &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; if the module is a package itself). Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">어떤 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-package&quot;&gt;패키지&lt;/a&gt; 모듈이 속한. 모듈이 최상위 레벨 (예 : 특정 패키지의 일부가 아님) 인 경우 속성을 &lt;code&gt;''&lt;/code&gt; 로 설정해야합니다. 그렇지 않으면 패키지 이름으로 설정해야합니다 ( 모듈이 패키지 자체 인 경우 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; &lt;/a&gt; 일 수 있음). ). 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4040c278cd792b1142c2b0b1b82b0f58225cee15" translate="yes" xml:space="preserve">
          <source>Which Docstrings Are Examined?</source>
          <target state="translated">어떤 독 스트링이 검사됩니까?</target>
        </trans-unit>
        <trans-unit id="422d9e85c4992821c007871473f5fa36c3b56c95" translate="yes" xml:space="preserve">
          <source>Which produces</source>
          <target state="translated">어느 생산</target>
        </trans-unit>
        <trans-unit id="a995c55c592cf94976c7d041d87c783ecf9451c8" translate="yes" xml:space="preserve">
          <source>Which solves the fundamental issue of processes colliding with each other resulting in a bad file descriptor error, but introduces a potential danger to applications which replace &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin()&lt;/code&gt;&lt;/a&gt; with a &amp;ldquo;file-like object&amp;rdquo; with output buffering. This danger is that if multiple processes call &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; on this file-like object, it could result in the same data being flushed to the object multiple times, resulting in corruption.</source>
          <target state="translated">서로 충돌하는 프로세스의 근본적인 문제를 해결하면 파일 디스크립터 오류가 발생하지만 출력 버퍼링을 사용하여 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin()&lt;/code&gt; &lt;/a&gt; 을 &quot;file-like object&quot;로 바꾸는 응용 프로그램에 잠재적 인 위험이 발생합니다 . 이 위험은 여러 프로세스 가이 파일과 같은 객체에서 &lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 동일한 데이터가 객체에 여러 번 플러시되어 손상 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddaaf09868cf6400cdcb648881000117dda08bc9" translate="yes" xml:space="preserve">
          <source>Whichever method you choose, you should provide a &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; that also hides the (unimportant) value:</source>
          <target state="translated">어떤 방법을 선택 하든지 (중요하지 않은) 값을 숨기는 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c646905a39f0ba1aaa09265f14adc54f064ca461" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; above. This restriction does not apply to mix-ins which only add methods and don&amp;rsquo;t specify another data type such as &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 은 모든 유형의 멤버를 가질 수 있지만 추가 유형을 혼합하면 모든 멤버는 해당 유형의 값을 가져야합니다 (예 : 위의 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; )&lt;/a&gt; . 이 제한은 메소드 만 추가하고 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 같은 다른 데이터 유형을 지정하지 않는 믹스 인에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e556a67224525bf738669c6821725b3262368ed7" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; are expected to cover the majority of use-cases, they cannot cover them all. Here are recipes for some different types of enumerations that can be used directly, or as examples for creating one&amp;rsquo;s own.</source>
          <target state="translated">하지만 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 사용 사례의 대부분을 포함 할 것으로 예상된다, 그들은 그들 모두를 포함 할 수 없습니다. 다음은 직접 사용할 수 있거나 직접 작성하는 예제로 사용할 수있는 여러 유형의 열거에 대한 레시피입니다.</target>
        </trans-unit>
        <trans-unit id="fe708d810599cc0f179e22587c1998a55fa295c9" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; is part of the &lt;a href=&quot;#module-enum&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; module, it would be very simple to implement independently:</source>
          <target state="translated">&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#module-enum&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt; 모듈의 일부 이지만 독립적으로 구현하는 것은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="02cb7cf515d5ba420c468f846b2ed31c98f290b6" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;The Python Language Reference&lt;/a&gt; describes the exact syntax and semantics of the Python language, this library reference manual describes the standard library that is distributed with Python. It also describes some of the optional components that are commonly included in Python distributions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;Python 언어 참조&lt;/a&gt; 는 Python 언어 의 정확한 구문과 의미를 설명 하지만 이 라이브러리 참조 설명서는 Python과 함께 배포되는 표준 라이브러리를 설명합니다. 또한 파이썬 배포판에 일반적으로 포함되는 일부 선택적 구성 요소에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0785829e0c8a5f6cee5eb7d590c1588c0e86596" translate="yes" xml:space="preserve">
          <source>While ConfigParser objects also use an &lt;code&gt;OPTCRE&lt;/code&gt; attribute for recognizing option lines, it&amp;rsquo;s not recommended to override it because that would interfere with constructor options &lt;em&gt;allow_no_value&lt;/em&gt; and &lt;em&gt;delimiters&lt;/em&gt;.</source>
          <target state="translated">ConfigParser 객체는 옵션 라인을 인식 하기 위해 &lt;code&gt;OPTCRE&lt;/code&gt; 속성 도 사용하지만 생성자 옵션 &lt;em&gt;allow_no_value&lt;/em&gt; 및 &lt;em&gt;delimiters를&lt;/em&gt; 방해하므로이를 무시하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0aea4fc9adcf74252cf54344d84df634df38ce92" translate="yes" xml:space="preserve">
          <source>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; (attempts to violate this restriction will trigger &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;). This is done deliberately to emphasise that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption).</source>
          <target state="translated">바이트 리터럴과 표현은 ASCII 텍스트를 기반으로하지만 바이트 객체는 실제로 불변의 정수 시퀀스처럼 동작하며, 시퀀스의 각 값은 &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; (제한을 위반하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 트리거됩니다 )으로 제한됩니다 . 이것은 많은 바이너리 형식이 ASCII 기반 요소를 포함하고 일부 텍스트 지향 알고리즘으로 유용하게 조작 될 수 있지만, 일반적으로 임의의 이진 데이터 (텍스트 처리 알고리즘을 그렇지 않은 이진 데이터 형식에 맹목적으로 적용)에는 해당되지 않는다는 점을 강조하기 위해 의도적으로 수행됩니다. ASCII 호환은 일반적으로 데이터 손상을 초래합니다).</target>
        </trans-unit>
        <trans-unit id="afca682adab62f0880b590c7e59b89279df102ab" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#bz2.BZ2File.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; was constructed by passing a file object for &lt;em&gt;filename&lt;/em&gt;).</source>
          <target state="translated">&lt;a href=&quot;#bz2.BZ2File.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt; 호출 해도 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 의 파일 위치는 변경되지 않지만 기본 파일 객체의 위치가 변경 될 수 있습니다 (예 : &lt;em&gt;filename&lt;/em&gt; 의 파일 객체를 전달 하여 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 이 구성된 경우 ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38177ebefc8686714a66d6d82cf4ee10e3058268" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#gzip.GzipFile.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; was constructed with the &lt;em&gt;fileobj&lt;/em&gt; parameter).</source>
          <target state="translated">&lt;a href=&quot;#gzip.GzipFile.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt; 호출 해도 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 의 파일 위치는 변경되지 않지만 기본 파일 객체의 위치가 변경 될 수 있습니다 (예 : &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 이 &lt;em&gt;fileobj&lt;/em&gt; 매개 변수 로 구성된 경우 ).</target>
        </trans-unit>
        <trans-unit id="e6545af489ed1f20fcc9c3b27afc7248e80f9df3" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#lzma.LZMAFile.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; was constructed by passing a file object for &lt;em&gt;filename&lt;/em&gt;).</source>
          <target state="translated">&lt;a href=&quot;#lzma.LZMAFile.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt; 호출 해도 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 의 파일 위치는 변경되지 않지만 기본 파일 객체의 위치가 변경 될 수 있습니다 (예 : &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 이 &lt;em&gt;filename&lt;/em&gt; 의 파일 객체를 전달하여 생성 된 경우 ).</target>
        </trans-unit>
        <trans-unit id="c0bb1fc2909ab24f32996f8a6e44f36be2000ff2" translate="yes" xml:space="preserve">
          <source>While curses is most widely used in the Unix environment, versions are available for Windows, DOS, and possibly other systems as well. This extension module is designed to match the API of ncurses, an open-source curses library hosted on Linux and the BSD variants of Unix.</source>
          <target state="translated">curses는 Unix 환경에서 가장 널리 사용되는 반면 Windows, DOS 및 기타 시스템에서도 버전을 사용할 수 있습니다. 이 확장 모듈은 Linux에서 호스팅되는 오픈 소스 curses 라이브러리 인 ncurses의 API 및 Unix의 BSD 변형과 일치하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="786cdfb379403ea4cce195f3dca6c17b6ee0052a" translate="yes" xml:space="preserve">
          <source>While date and time arithmetic is supported, the focus of the implementation is on efficient attribute extraction for output formatting and manipulation.</source>
          <target state="translated">날짜 및 시간 산술이 지원되지만 구현의 초점은 출력 형식 및 조작을위한 효율적인 속성 추출에 있습니다.</target>
        </trans-unit>
        <trans-unit id="67281bc9ed61750f29460e86ce99cc6681899c14" translate="yes" xml:space="preserve">
          <source>While many objects natively support use in with statements, sometimes a resource needs to be managed that isn&amp;rsquo;t a context manager in its own right, and doesn&amp;rsquo;t implement a &lt;code&gt;close()&lt;/code&gt; method for use with &lt;code&gt;contextlib.closing&lt;/code&gt;</source>
          <target state="translated">기본적으로 많은 객체가 with 문에서의 사용을 지원하지만 자체적으로 컨텍스트 관리자가 아니고 &lt;code&gt;contextlib.closing&lt;/code&gt; 과 함께 사용할 &lt;code&gt;close()&lt;/code&gt; 메서드를 구현하지 않는 리소스를 관리해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="93bfa21ab3a98f4858cf4bc1efde7812c899e149" translate="yes" xml:space="preserve">
          <source>While many useful operations may take place between parsing and bytecode generation, the simplest operation is to do nothing. For this purpose, using the &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module to produce an intermediate data structure is equivalent to the code</source>
          <target state="translated">구문 분석과 바이트 코드 생성간에 많은 유용한 작업이 수행 될 수 있지만 가장 간단한 작업은 아무 것도 수행하지 않는 것입니다. 이를 위해 &lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 중간 데이터 구조를 생성하는 것은 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b514cb7bc8722d4e70eacb8c91412ef7465d4c76" translate="yes" xml:space="preserve">
          <source>While other exceptions may still occur, this method is called &amp;ldquo;safe&amp;rdquo; because it always tries to return a usable string instead of raising an exception. In another sense, &lt;a href=&quot;#string.Template.safe_substitute&quot;&gt;&lt;code&gt;safe_substitute()&lt;/code&gt;&lt;/a&gt; may be anything other than safe, since it will silently ignore malformed templates containing dangling delimiters, unmatched braces, or placeholders that are not valid Python identifiers.</source>
          <target state="translated">다른 예외가 여전히 발생할 수 있지만이 메서드는 항상 예외를 발생시키는 대신 사용 가능한 문자열을 반환하려고하기 때문에 &quot;안전&quot;이라고합니다. 다른 의미에서 &lt;a href=&quot;#string.Template.safe_substitute&quot;&gt; &lt;code&gt;safe_substitute()&lt;/code&gt; &lt;/a&gt; 는 안전한 구분 기호, 일치하지 않는 중괄호 또는 유효한 Python 식별자가 아닌 자리 표시자를 포함하는 잘못된 템플릿을 자동으로 무시하므로 safe 이외의 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a915d6b0d37f05b5affd54282cd5bb33c1eff648" translate="yes" xml:space="preserve">
          <source>While parsing the command line, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; checks for a variety of errors, including ambiguous options, invalid types, invalid options, wrong number of positional arguments, etc. When it encounters such an error, it exits and prints the error along with a usage message:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 명령 행을 구문 분석하는 동안 모호한 옵션, 유효하지 않은 유형, 유효하지 않은 옵션, 잘못된 수의 위치 인수 등을 포함하여 다양한 오류를 검사합니다. 이러한 오류가 발생하면 종료되고 오류와 함께 오류가 인쇄됩니다. 사용 메시지 :</target>
        </trans-unit>
        <trans-unit id="af0a5de79e2df6a8d199d3d065c11df24c028f5b" translate="yes" xml:space="preserve">
          <source>While symlinks are supported on Windows, they are not recommended. Of particular note is that double-clicking &lt;code&gt;python.exe&lt;/code&gt; in File Explorer will resolve the symlink eagerly and ignore the virtual environment.</source>
          <target state="translated">심볼릭 링크는 Windows에서 지원되지만 권장되지 않습니다. 특히 주목할 점은 파일 탐색기에서 &lt;code&gt;python.exe&lt;/code&gt; 를 두 번 클릭하면 심볼릭 링크를 열심히 해결하고 가상 환경을 무시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0e04edc4d322f07593d9595090717727de98239" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;not in&lt;/code&gt; operations are used only for simple containment testing in the general case, some specialised sequences (such as &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;) also use them for subsequence testing:</source>
          <target state="translated">그동안 &lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;not in&lt;/code&gt; 작업에만 일반적인 경우에 간단한 봉쇄 테스트에 사용된다 (예 : 일부 전문 시퀀스 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; )도 서브 테스트에 사용할 :</target>
        </trans-unit>
        <trans-unit id="5d31855d6be2ba764837d00ac8c9c8aa85b873bb" translate="yes" xml:space="preserve">
          <source>While the above API is the most common and convenient usage, you can get all of that information from the &lt;code&gt;Distribution&lt;/code&gt; class. A &lt;code&gt;Distribution&lt;/code&gt; is an abstract object that represents the metadata for a Python package. You can get the &lt;code&gt;Distribution&lt;/code&gt; instance:</source>
          <target state="translated">위의 API가 가장 일반적이고 편리한 사용법이지만 &lt;code&gt;Distribution&lt;/code&gt; 클래스 에서 해당 정보를 모두 얻을 수 있습니다 . &lt;code&gt;Distribution&lt;/code&gt; 파이썬 패키지에 대한 메타 데이터를 나타내는 추상 개체입니다. &lt;code&gt;Distribution&lt;/code&gt; 인스턴스를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6319151ce24cde9d9afeaf68fdcdbec22e36ba3" translate="yes" xml:space="preserve">
          <source>While the builtin &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; and the associated &lt;a href=&quot;io#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; module are the recommended approach for working with encoded text files, this module provides additional utility functions and classes that allow the use of a wider range of codecs when working with binary files:</source>
          <target state="translated">내장 된 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 및 관련 &lt;a href=&quot;io#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 모듈은 인코딩 된 텍스트 파일 작업에 권장되는 접근 방법이지만이 모듈은 바이너리 파일로 작업 할 때 더 넓은 범위의 코덱을 사용할 수있는 추가 유틸리티 함수 및 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42821c116527a74cd5c9f35556c03beeb2cf5d8f" translate="yes" xml:space="preserve">
          <source>While the method has a default implementation, it is suggested that it be overridden if possible for performance.</source>
          <target state="translated">이 방법에는 기본 구현이 있지만 가능한 경우 성능을 위해 재정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="14032b7a66889d07d3394faf5c484ef0cdf94cea" translate="yes" xml:space="preserve">
          <source>While these are technically &lt;a href=&quot;exceptions#warning-categories-as-exceptions&quot;&gt;built-in exceptions&lt;/a&gt;, they are documented here, because conceptually they belong to the warnings mechanism.</source>
          <target state="translated">이들은 기술적으로 &lt;a href=&quot;exceptions#warning-categories-as-exceptions&quot;&gt;내장 된 예외&lt;/a&gt; 이지만 개념적으로 경고 메커니즘에 속하기 때문에 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcfc856d002acccc1fa089a7e19be1782a8e1118" translate="yes" xml:space="preserve">
          <source>While they are not listed below, the &lt;code&gt;camelCase&lt;/code&gt; names used for some methods and functions in this module in the Python 2.x series are still supported by this module.</source>
          <target state="translated">아래에 나열되어 있지는 않지만 Python 2.x 시리즈에서이 모듈의 일부 메소드 및 함수에 사용 된 &lt;code&gt;camelCase&lt;/code&gt; 이름은이 모듈에서 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4b7324352db1ad0e38dfcfad84d64814555c92" translate="yes" xml:space="preserve">
          <source>While this decorator makes it easy to create well behaved totally ordered types, it &lt;em&gt;does&lt;/em&gt; come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost.</source>
          <target state="translated">이 장식은 쉽게 잘 완전히 주문 행동 유형을 만들 수 있지만, 그것은 &lt;em&gt;않습니다&lt;/em&gt; 파생 비교 방법에 대한 느린 실행과 더 복잡한 스택 추적의 비용으로 제공됩니다. 성능 벤치마킹이 이것이 특정 응용 프로그램의 병목 현상이라고 표시하는 경우 6 가지의 풍부한 비교 방법을 모두 구현하면 속도를 쉽게 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8863d901011fb351d3633ca34f340a2828c5fea0" translate="yes" xml:space="preserve">
          <source>While this might be annoying, this feature is intended for use in specialized circumstances, such as multi-threaded servers where the same code executes in many contexts, and interesting conditions which arise are dependent on this context (such as remote client IP address and authenticated user name, in the above example). In such circumstances, it is likely that specialized &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;s would be used with particular &lt;a href=&quot;#logging.Handler&quot;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이 작업은 성가신 일이지만이 기능은 동일한 코드가 여러 컨텍스트에서 실행되는 멀티 스레드 서버와 같은 특수한 환경에서 사용하기위한 것이며 흥미로운 상황은이 컨텍스트에 따라 다릅니다 (예 : 원격 클라이언트 IP 주소 및 인증 됨) 위의 예에서 사용자 이름). 이러한 상황에서는 특수한 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 가 특정 &lt;a href=&quot;#logging.Handler&quot;&gt; &lt;code&gt;Handler&lt;/code&gt; &lt;/a&gt; 와 함께 사용될 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="840def8eae0283a6cbfe40db44014f3c77b1c43b" translate="yes" xml:space="preserve">
          <source>While using a hierarchy of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt;-derived classes can be convenient in sharing fixtures and helper functions, defining test methods on base classes that are not intended to be instantiated directly does not play well with this method. Doing so, however, can be useful when the fixtures are different and defined in subclasses.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 파생 클래스 의 계층 구조를 사용하면 조명기 및 도우미 함수를 공유하는 데 편리 할 수 ​​있지만 직접 인스턴스화되지 않는 기본 클래스에서 테스트 메소드를 정의하는 것은이 메소드에서 잘 작동하지 않습니다. 그러나 픽스쳐가 다르고 서브 클래스에 정의 된 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="988a0cff7503163f428287a56046c0bb09b3b7fd" translate="yes" xml:space="preserve">
          <source>While within the context manager all warnings will simply be ignored. This allows you to use known-deprecated code without having to see the warning while not suppressing the warning for other code that might not be aware of its use of deprecated code. Note: this can only be guaranteed in a single-threaded application. If two or more threads use the &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; context manager at the same time, the behavior is undefined.</source>
          <target state="translated">컨텍스트 관리자 내에서 모든 경고는 무시됩니다. 이를 통해 더 이상 사용되지 않는 코드 사용을 인식하지 못하는 다른 코드에 대한 경고를 표시하지 않으면 서 경고를 보지 않고도 알려진 사용되지 않는 코드를 사용할 수 있습니다. 참고 : 이것은 단일 스레드 응용 프로그램에서만 보장 될 수 있습니다. 둘 이상의 스레드가 &lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; &lt;/a&gt; 컨텍스트 관리자를 동시에 사용하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="62d692a71777fd55efffbdb0ca5893dd735770aa" translate="yes" xml:space="preserve">
          <source>Whitebox testing (examining the code being tested when the tests are being written) is preferred. Blackbox testing (testing only the published user interface) is not complete enough to make sure all boundary and edge cases are tested.</source>
          <target state="translated">화이트 박스 테스트 (테스트를 작성할 때 테스트중인 코드 검사)가 선호됩니다. 블랙 박스 테스트 (게시 된 사용자 인터페이스 만 테스트)는 모든 경계 및 경계 사례를 테스트하기에 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="931f4c5c75b75b488b411586b1c52d7e9f8da29c" translate="yes" xml:space="preserve">
          <source>Whiteout.</source>
          <target state="translated">Whiteout.</target>
        </trans-unit>
        <trans-unit id="b78a557954071d939474b0820ce2d887c5949beb" translate="yes" xml:space="preserve">
          <source>Whitespace characters between formats are ignored; a count and its format must not contain whitespace though.</source>
          <target state="translated">형식 사이의 공백 문자는 무시됩니다. 카운트와 형식에는 공백이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b7e00ea7c678d4c6c68704506146cc03ff76587" translate="yes" xml:space="preserve">
          <source>Whitespace is not allowed between the &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and the directive option name. The directive option name can be any of the option flag names explained above.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 와 지시문 옵션 이름 사이에는 공백이 허용되지 않습니다 . 지시문 옵션 이름은 위에서 설명한 옵션 플래그 이름 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8fe1444c5cef2f1bf2942426dad26edc71785bf" translate="yes" xml:space="preserve">
          <source>Why is it printing &lt;code&gt;False&lt;/code&gt;? ctypes instances are objects containing a memory block plus some &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;descriptor&lt;/a&gt;s accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the &lt;code&gt;contents&lt;/code&gt; of the object is stored. Accessing the contents again constructs a new Python object each time!</source>
          <target state="translated">왜 &lt;code&gt;False&lt;/code&gt; 를 인쇄 합니까? ctypes 인스턴스는 메모리 블록과 메모리 내용에 액세스하는 일부 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;디스크립터를&lt;/a&gt; 포함하는 객체 입니다. 메모리 블록에 파이썬 객체를 저장하면 객체 자체가 저장되지 않고 객체의 &lt;code&gt;contents&lt;/code&gt; 이 저장됩니다. 내용에 다시 액세스하면 매번 새로운 Python 객체가 생성됩니다!</target>
        </trans-unit>
        <trans-unit id="fb8f747f33b6f74dbe7fd5ac838801c9d72b22ac" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.getch&quot;&gt;&lt;code&gt;getch()&lt;/code&gt;&lt;/a&gt;, returning a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.getch&quot;&gt; &lt;code&gt;getch()&lt;/code&gt; &lt;/a&gt; 의 넓은 char 변형으로 유니 코드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c5be99ca3a70e3977f2f65814d98de5c5b56d2d2" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.getche&quot;&gt;&lt;code&gt;getche()&lt;/code&gt;&lt;/a&gt;, returning a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.getche&quot;&gt; &lt;code&gt;getche()&lt;/code&gt; &lt;/a&gt; 의 넓은 char 변형으로 유니 코드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="255f38720857b44ab5ff2e2d98e37a3c89e37d00" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.putch&quot;&gt;&lt;code&gt;putch()&lt;/code&gt;&lt;/a&gt;, accepting a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.putch&quot;&gt; &lt;code&gt;putch()&lt;/code&gt; &lt;/a&gt; 의 넓은 문자 변형으로 유니 코드 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6f0779174f97c45da57524e6b209ae90dff53c3d" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.ungetch&quot;&gt;&lt;code&gt;ungetch()&lt;/code&gt;&lt;/a&gt;, accepting a Unicode value.</source>
          <target state="translated">유니 코드 값을 허용하는 &lt;a href=&quot;#msvcrt.ungetch&quot;&gt; &lt;code&gt;ungetch()&lt;/code&gt; &lt;/a&gt; 의 넓은 char 변형 .</target>
        </trans-unit>
        <trans-unit id="df15305cc141d8294713eba43aaee44d1edfe3bd" translate="yes" xml:space="preserve">
          <source>Widget</source>
          <target state="translated">Widget</target>
        </trans-unit>
        <trans-unit id="bfee860a8a5dc6ac74dd99d215ad1d51cce5c8c7" translate="yes" xml:space="preserve">
          <source>Widget States</source>
          <target state="translated">위젯 상태</target>
        </trans-unit>
        <trans-unit id="79beed1fb49764e8862ef327797df09e07c316a6" translate="yes" xml:space="preserve">
          <source>Widget has keyboard focus</source>
          <target state="translated">위젯에 키보드 포커스가 있습니다</target>
        </trans-unit>
        <trans-unit id="2233730413ec55a5b571e7d775be44e6e3e013b3" translate="yes" xml:space="preserve">
          <source>Widget is being pressed</source>
          <target state="translated">위젯을 누르고 있습니다</target>
        </trans-unit>
        <trans-unit id="da46e3b7f16d7ede37378d1c431a4c43fb3ef6fc" translate="yes" xml:space="preserve">
          <source>Widget is disabled under program control</source>
          <target state="translated">프로그램 제어에서 위젯이 비활성화 됨</target>
        </trans-unit>
        <trans-unit id="211f67af4e336b2c25b87952f14880aca797600a" translate="yes" xml:space="preserve">
          <source>Widget should not allow user modification</source>
          <target state="translated">위젯은 사용자 수정을 허용하지 않아야합니다</target>
        </trans-unit>
        <trans-unit id="802f4ec2a7a115583d6e55e6d32a4beead4d14b2" translate="yes" xml:space="preserve">
          <source>Width of the terminal window in characters.</source>
          <target state="translated">문자로 된 터미널 창의 너비.</target>
        </trans-unit>
        <trans-unit id="080323da0bfe1ab0191a174c2237858164d7cdaf" translate="yes" xml:space="preserve">
          <source>Wikipedia article with information on which algorithms have known issues and what that means regarding their use.</source>
          <target state="translated">알려진 알고리즘에 대해 알고있는 알고리즘과 그 사용에 대한 의미에 대한 정보가 포함 된 Wikipedia 기사</target>
        </trans-unit>
        <trans-unit id="c1b3cf193c6d821b49984f993d3ea75cf5a5a2be" translate="yes" xml:space="preserve">
          <source>Wikipedia entry for &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiset&quot;&gt;Multisets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiset&quot;&gt;다중 집합에&lt;/a&gt; 대한 Wikipedia 항목 .</target>
        </trans-unit>
        <trans-unit id="113f18f5469ce5347437610dd55d140a53fa09c6" translate="yes" xml:space="preserve">
          <source>Wikipedia has a &lt;a href=&quot;https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification&quot;&gt;nice example of a Naive Bayesian Classifier&lt;/a&gt;. The challenge is to predict a person&amp;rsquo;s gender from measurements of normally distributed features including height, weight, and foot size.</source>
          <target state="translated">Wikipedia에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification&quot;&gt;Naive Bayesian Classifier&lt;/a&gt; 의 좋은 예가 있습니다. 문제는 키, 몸무게 및 발 크기를 포함하여 정상적으로 분포 된 피처를 측정하여 사람의 성별을 예측하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6fe06680d0563e4e9deb6c1d86aa445e8e5c908" translate="yes" xml:space="preserve">
          <source>Will add, among other things, a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; that looks like:</source>
          <target state="translated">무엇보다도 다음과 같은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d239e74c0170d39d6786ccf1a848d04c2c537ed2" translate="yes" xml:space="preserve">
          <source>Will call &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; when the indicated number of characters have been received</source>
          <target state="translated">표시된 문자 수가 수신되면 &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4426413765c214020905681f96c46df4a803dd94" translate="yes" xml:space="preserve">
          <source>Will call &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; when the string is found in the input stream</source>
          <target state="translated">입력 스트림에서 문자열이 발견되면 &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="47374c257b33abb533116a9cb9651554e18faed7" translate="yes" xml:space="preserve">
          <source>Will generally raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; if executed on a 32-bit operating system.</source>
          <target state="translated">32 비트 운영 체제에서 실행되면 일반적으로 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b90c5925294b920cc6ddfbe599b541b3edf485fe" translate="yes" xml:space="preserve">
          <source>Will try to match with &lt;code&gt;yes-pattern&lt;/code&gt; if the group with given &lt;em&gt;id&lt;/em&gt; or &lt;em&gt;name&lt;/em&gt; exists, and with &lt;code&gt;no-pattern&lt;/code&gt; if it doesn&amp;rsquo;t. &lt;code&gt;no-pattern&lt;/code&gt; is optional and can be omitted. For example, &lt;code&gt;(&amp;lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&amp;gt;|$)&lt;/code&gt; is a poor email matching pattern, which will match with &lt;code&gt;'&amp;lt;user@host.com&amp;gt;'&lt;/code&gt; as well as &lt;code&gt;'user@host.com'&lt;/code&gt;, but not with &lt;code&gt;'&amp;lt;user@host.com'&lt;/code&gt; nor &lt;code&gt;'user@host.com&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">일치하려고합니다 &lt;code&gt;yes-pattern&lt;/code&gt; 주어진과 그룹 경우 &lt;em&gt;ID&lt;/em&gt; 나 &lt;em&gt;이름이&lt;/em&gt; 존재하고와 &lt;code&gt;no-pattern&lt;/code&gt; 이하지 않는 경우. &lt;code&gt;no-pattern&lt;/code&gt; 은 선택 사항이며 생략 할 수 있습니다. 예를 들어, &lt;code&gt;(&amp;lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&amp;gt;|$)&lt;/code&gt; 는 전자 메일 일치 패턴이 잘못되어 &lt;code&gt;'&amp;lt;user@host.com&amp;gt;'&lt;/code&gt; 과 일치합니다. &amp;gt; ' 뿐만 아니라 &lt;code&gt;'user@host.com'&lt;/code&gt; 이지만 &lt;code&gt;'&amp;lt;user@host.com'&lt;/code&gt; 또는 &lt;code&gt;'user@host.com&amp;gt;'&lt;/code&gt; 과는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="81dab24e3d9f50cff7ee608ff0514afa0cfa05b9" translate="yes" xml:space="preserve">
          <source>Window Objects</source>
          <target state="translated">창 객체</target>
        </trans-unit>
        <trans-unit id="ce658069fb4ffc6d3ca8e791633d8df32975802b" translate="yes" xml:space="preserve">
          <source>Window control</source>
          <target state="translated">창 제어</target>
        </trans-unit>
        <trans-unit id="660e57fa2bc58f9dadba0b1f9648498cca7a58e4" translate="yes" xml:space="preserve">
          <source>Window menu (Shell and Editor)</source>
          <target state="translated">창 메뉴 (쉘 및 편집기)</target>
        </trans-unit>
        <trans-unit id="b7e449a2f3ba9b16acfab22bc1c12f4e17b45718" translate="yes" xml:space="preserve">
          <source>Window objects, as returned by &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#curses.newwin&quot;&gt;&lt;code&gt;newwin()&lt;/code&gt;&lt;/a&gt; above, have the following methods and attributes:</source>
          <target state="translated">위의 &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#curses.newwin&quot;&gt; &lt;code&gt;newwin()&lt;/code&gt; &lt;/a&gt; 반환 된 Window 객체 에는 다음과 같은 메서드와 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="e23575cabbcb9b7c4f9b7f51a07387fed98002f0" translate="yes" xml:space="preserve">
          <source>Windows Constants</source>
          <target state="translated">윈도우 상수</target>
        </trans-unit>
        <trans-unit id="733b53500cac45b1ccabfeea23e2dd3682ceafd7" translate="yes" xml:space="preserve">
          <source>Windows Platform</source>
          <target state="translated">윈도우 플랫폼</target>
        </trans-unit>
        <trans-unit id="707d9815b3e7e66dfa8de1e9a953cf814bb32ace" translate="yes" xml:space="preserve">
          <source>Windows Popen Helpers</source>
          <target state="translated">Windows Popen 도우미</target>
        </trans-unit>
        <trans-unit id="059cace6c4e4f2ba24a96dd77457fa820cea57be" translate="yes" xml:space="preserve">
          <source>Windows and Mac have a notion of an &amp;ldquo;active&amp;rdquo; or foreground window. The &lt;em&gt;background&lt;/em&gt; state is set for widgets in a background window, and cleared for those in the foreground window</source>
          <target state="translated">Windows 및 Mac에는 &quot;활성&quot;또는 포 그라운드 창이라는 개념이 있습니다. &lt;em&gt;배경&lt;/em&gt; 상태는 전경 창에서 사람들을 위해 배경 화면에서 위젯 설정 및 해제</target>
        </trans-unit>
        <trans-unit id="58f8b33dac190c990211b26ccc6956c320800b74" translate="yes" xml:space="preserve">
          <source>Windows appends the usual &lt;code&gt;.dll&lt;/code&gt; file suffix automatically.</source>
          <target state="translated">Windows는 일반적인 &lt;code&gt;.dll&lt;/code&gt; 파일 접미사를 자동으로 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="c3fc7bf4a41cf349e493878f4d10064c2cb45383" translate="yes" xml:space="preserve">
          <source>Windows file attributes: &lt;code&gt;dwFileAttributes&lt;/code&gt; member of the &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; structure returned by &lt;code&gt;GetFileInformationByHandle()&lt;/code&gt;. See the &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; constants in the &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Windows 파일 속성 : &lt;code&gt;GetFileInformationByHandle()&lt;/code&gt; 의해 리턴 된 &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; 구조 의 &lt;code&gt;dwFileAttributes&lt;/code&gt; 멤버 . &lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; 상수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3fbab09a7f617cae95132c649f8e0c1742cca65" translate="yes" xml:space="preserve">
          <source>Windows only: Creates &lt;a href=&quot;#ctypes.OleDLL&quot;&gt;&lt;code&gt;OleDLL&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">Windows 전용 : &lt;a href=&quot;#ctypes.OleDLL&quot;&gt; &lt;code&gt;OleDLL&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="612e01f22f9c1d88221548d271f8b961715eb8ed" translate="yes" xml:space="preserve">
          <source>Windows only: Creates &lt;a href=&quot;#ctypes.WinDLL&quot;&gt;&lt;code&gt;WinDLL&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">Windows 전용 : &lt;a href=&quot;#ctypes.WinDLL&quot;&gt; &lt;code&gt;WinDLL&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e2c52f5bde98e844c1500dc7688f5098974c8782" translate="yes" xml:space="preserve">
          <source>Windows only: Encode the operand according to the ANSI codepage (CP_ACP).</source>
          <target state="translated">Windows 전용 : ANSI 코드 페이지 (CP_ACP)에 따라 피연산자를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="266fb264e8732c43ca999faee5d793005f28e1c9" translate="yes" xml:space="preserve">
          <source>Windows only: Encode the operand according to the OEM codepage (CP_OEMCP).</source>
          <target state="translated">Windows 전용 : OEM 코드 페이지 (CP_OEMCP)에 따라 피연산자를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="edb6ed45a1b723b7af51540eab62bf7ae64e1059" translate="yes" xml:space="preserve">
          <source>Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and are assumed to return &lt;code&gt;int&lt;/code&gt; by default.</source>
          <target state="translated">Windows 전용 :이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타내며,이 라이브러리의 함수는 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용하며 기본적으로 &lt;code&gt;int&lt;/code&gt; 를 리턴하는 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a8baa6ebf95b244d430b0bac19d2d4be067fc743" translate="yes" xml:space="preserve">
          <source>Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and are assumed to return the windows specific &lt;a href=&quot;#ctypes.HRESULT&quot;&gt;&lt;code&gt;HRESULT&lt;/code&gt;&lt;/a&gt; code. &lt;a href=&quot;#ctypes.HRESULT&quot;&gt;&lt;code&gt;HRESULT&lt;/code&gt;&lt;/a&gt; values contain information specifying whether the function call failed or succeeded, together with additional error code. If the return value signals a failure, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is automatically raised.</source>
          <target state="translated">Windows 전용 :이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타내며,이 라이브러리의 함수는 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용 하며 Windows 고유의 &lt;a href=&quot;#ctypes.HRESULT&quot;&gt; &lt;code&gt;HRESULT&lt;/code&gt; &lt;/a&gt; 코드 를 리턴하는 것으로 가정 합니다. &lt;a href=&quot;#ctypes.HRESULT&quot;&gt; &lt;code&gt;HRESULT&lt;/code&gt; &lt;/a&gt; 값에는 추가 오류 코드와 함께 함수 호출 실패 또는 성공 여부를 지정하는 정보가 포함됩니다. 리턴 값이 실패를 신호하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 자동으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4996849541b713bd583a818c47de0918c05b035c" translate="yes" xml:space="preserve">
          <source>Windows only: Represents a &lt;code&gt;HRESULT&lt;/code&gt; value, which contains success or error information for a function or method call.</source>
          <target state="translated">Windows 전용 : 함수 또는 메소드 호출에 대한 성공 또는 오류 정보가 포함 된 &lt;code&gt;HRESULT&lt;/code&gt; 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bdabf613004cb36f7b1c0e46576c928355e113b5" translate="yes" xml:space="preserve">
          <source>Windows only: Returns a textual description of the error code &lt;em&gt;code&lt;/em&gt;. If no error code is specified, the last error code is used by calling the Windows api function GetLastError.</source>
          <target state="translated">Windows 전용 : 오류 코드 &lt;em&gt;code&lt;/em&gt; 의 텍스트 설명을 리턴합니다 . 오류 코드를 지정하지 않으면 Windows API 함수 GetLastError를 호출하여 마지막 오류 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fbcbf3ad5bd151aa5b3e3fde3eb8d692caac57ec" translate="yes" xml:space="preserve">
          <source>Windows only: Returns the last error code set by Windows in the calling thread. This function calls the Windows &lt;code&gt;GetLastError()&lt;/code&gt; function directly, it does not return the ctypes-private copy of the error code.</source>
          <target state="translated">Windows 전용 : 호출 스레드에서 Windows가 설정 한 마지막 오류 코드를 리턴합니다. 이 함수는 Windows &lt;code&gt;GetLastError()&lt;/code&gt; 함수를 직접 호출 하며 오류 코드의 ctypes-private 복사본을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2511b1a5b947b91013c7afa28eb6b0b78fe0e385" translate="yes" xml:space="preserve">
          <source>Windows only: The returned function prototype creates functions that use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, except on Windows CE where &lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt;&lt;code&gt;WINFUNCTYPE()&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt;&lt;code&gt;CFUNCTYPE()&lt;/code&gt;&lt;/a&gt;. The function will release the GIL during the call. &lt;em&gt;use_errno&lt;/em&gt; and &lt;em&gt;use_last_error&lt;/em&gt; have the same meaning as above.</source>
          <target state="translated">Windows 전용 : 반환 된 함수 프로토 타입은 사용하는 함수 생성 &lt;code&gt;stdcall&lt;/code&gt; 을 어디에 윈도우 CE를 제외하고, 호출 규칙을 &lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt; &lt;code&gt;WINFUNCTYPE()&lt;/code&gt; &lt;/a&gt; 과 동일 &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt; &lt;code&gt;CFUNCTYPE()&lt;/code&gt; &lt;/a&gt; . 이 기능은 호출 중에 GIL을 해제합니다. &lt;em&gt;use_errno&lt;/em&gt; 및 &lt;em&gt;use_last_error&lt;/em&gt; 는 위와 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="08605ae2b964896441a344b5311963123c2e7022" translate="yes" xml:space="preserve">
          <source>Windows only: This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllCanUnloadNow function that the _ctypes extension dll exports.</source>
          <target state="translated">Windows 전용 :이 기능은 ctypes를 사용하여 처리중인 COM 서버를 구현할 수있는 후크입니다. _ctypes 확장명 dll이 내보내는 DllCanUnloadNow 함수에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="29751233ae7d28491bf89fa51c323518e5fedbd3" translate="yes" xml:space="preserve">
          <source>Windows only: This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllGetClassObject function that the &lt;code&gt;_ctypes&lt;/code&gt; extension dll exports.</source>
          <target state="translated">Windows 전용 :이 기능은 ctypes를 사용하여 처리중인 COM 서버를 구현할 수있는 후크입니다. &lt;code&gt;_ctypes&lt;/code&gt; 확장 dll이 내보내는 DllGetClassObject 함수에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4880e94875e68f82bb6fce3490b9c97c9c5d775d" translate="yes" xml:space="preserve">
          <source>Windows only: return the filename of the VC runtime library used by Python, and by the extension modules. If the name of the library cannot be determined, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">Windows 전용 : Python 및 확장 모듈에서 사용하는 VC 런타임 라이브러리의 파일 이름을 리턴하십시오. 라이브러리 이름을 판별 할 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d3e388ef290e4bd8ff8d89808b87dad3695d974a" translate="yes" xml:space="preserve">
          <source>Windows only: returns the current value of the ctypes-private copy of the system &lt;code&gt;LastError&lt;/code&gt; variable in the calling thread.</source>
          <target state="translated">Windows 전용 : 호출 스레드에서 시스템 &lt;code&gt;LastError&lt;/code&gt; 변수 의 ctypes-private 사본의 현재 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8310fccfe554408a2574b1c48ddf84fd935b53" translate="yes" xml:space="preserve">
          <source>Windows only: set the current value of the ctypes-private copy of the system &lt;code&gt;LastError&lt;/code&gt; variable in the calling thread to &lt;em&gt;value&lt;/em&gt; and return the previous value.</source>
          <target state="translated">Windows에만 해당 : 시스템의하는 ctypes - 개인 복사본의 현재 값으로 설정 &lt;code&gt;LastError&lt;/code&gt; 의 에 호출 스레드에서 변수 &lt;em&gt;값을&lt;/em&gt; 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8358fc5d14e0fbf09bf3e54d163a390795bbe4f7" translate="yes" xml:space="preserve">
          <source>Windows only: this function is probably the worst-named thing in ctypes. It creates an instance of OSError. If &lt;em&gt;code&lt;/em&gt; is not specified, &lt;code&gt;GetLastError&lt;/code&gt; is called to determine the error code. If &lt;em&gt;descr&lt;/em&gt; is not specified, &lt;a href=&quot;#ctypes.FormatError&quot;&gt;&lt;code&gt;FormatError()&lt;/code&gt;&lt;/a&gt; is called to get a textual description of the error.</source>
          <target state="translated">Windows 전용 :이 기능은 아마도 ctypes에서 최악의 이름 일 것입니다. OSError의 인스턴스를 만듭니다. 경우 &lt;em&gt;코드가&lt;/em&gt; 지정되지 않은, &lt;code&gt;GetLastError&lt;/code&gt; 는 에러 코드를 확인하기 위해 호출됩니다. 경우 &lt;em&gt;DESCR가&lt;/em&gt; 지정되지 않은, &lt;a href=&quot;#ctypes.FormatError&quot;&gt; &lt;code&gt;FormatError()&lt;/code&gt; &lt;/a&gt; 오류의 텍스트 설명을 얻기 위해 호출된다.</target>
        </trans-unit>
        <trans-unit id="db996879e3dc4634bda2abfa9ed3e517199ceb69" translate="yes" xml:space="preserve">
          <source>Windows will return one of:</source>
          <target state="translated">Windows는 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cd7eea9943b6fe344a02e8fbc71ef279241c91a" translate="yes" xml:space="preserve">
          <source>Windows/Cygwin</source>
          <target state="translated">Windows/Cygwin</target>
        </trans-unit>
        <trans-unit id="a807de5503cda53ca6fea19efe8608ddcb20996b" translate="yes" xml:space="preserve">
          <source>Windows: The &lt;a href=&quot;signal#signal.CTRL_C_EVENT&quot;&gt;&lt;code&gt;signal.CTRL_C_EVENT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;signal#signal.CTRL_BREAK_EVENT&quot;&gt;&lt;code&gt;signal.CTRL_BREAK_EVENT&lt;/code&gt;&lt;/a&gt; signals are special signals which can only be sent to console processes which share a common console window, e.g., some subprocesses. Any other value for &lt;em&gt;sig&lt;/em&gt; will cause the process to be unconditionally killed by the TerminateProcess API, and the exit code will be set to &lt;em&gt;sig&lt;/em&gt;. The Windows version of &lt;a href=&quot;#os.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt; additionally takes process handles to be killed.</source>
          <target state="translated">Windows : &lt;a href=&quot;signal#signal.CTRL_C_EVENT&quot;&gt; &lt;code&gt;signal.CTRL_C_EVENT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;signal#signal.CTRL_BREAK_EVENT&quot;&gt; &lt;code&gt;signal.CTRL_BREAK_EVENT&lt;/code&gt; &lt;/a&gt; 신호는 공통 콘솔 창을 공유하는 콘솔 프로세스 (예 : 일부 하위 프로세스)로만 보낼 수있는 특수 신호입니다. &lt;em&gt;sig의&lt;/em&gt; 다른 값 은 프로세스가 TerminateProcess API에 의해 무조건 종료되며 종료 코드는 &lt;em&gt;sig&lt;/em&gt; 로 설정됩니다 . &lt;a href=&quot;#os.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; 의 Windows 버전은 추가로 프로세스 핸들을 강제 종료합니다.</target>
        </trans-unit>
        <trans-unit id="adf309288e97790d19b86dd6d3f7067de5f4100b" translate="yes" xml:space="preserve">
          <source>WindowsError</source>
          <target state="translated">WindowsError</target>
        </trans-unit>
        <trans-unit id="a20440ab3aefcfb4bb482ffec0fe5d04e27395bf" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; event loop, the &lt;em&gt;pipe&lt;/em&gt; is set to non-blocking mode.</source>
          <target state="translated">함께 &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; 의&lt;/a&gt; 이벤트 루프의 &lt;em&gt;관&lt;/em&gt; 비 차단 모드로 설정된다.</target>
        </trans-unit>
        <trans-unit id="c2504489b4771be876382108e6f7ae9120afc09b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;, each caller is preceded by three numbers: the number of times this specific call was made, and the total and cumulative times spent in the current function while it was invoked by this specific caller.</source>
          <target state="translated">&lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; 을&lt;/a&gt; 사용하면 각 호출자 앞에이 특정 호출이 발생한 횟수와이 특정 호출자가 호출 한 동안 현재 함수에 소요 된 총 및 누적 시간의 세 숫자가 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="d44b294510f145891db9e384bc38c4e88df7f7c7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt;, a number is shown in parentheses after each caller to show how many times this specific call was made. For convenience, a second non-parenthesized number repeats the cumulative time spent in the function at the right.</source>
          <target state="translated">&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; 을&lt;/a&gt; 사용하면 각 호출자 다음에 괄호 안에 숫자가 표시되어이 특정 호출이 몇 번이나되었는지 표시됩니다. 편의를 위해 두 번째 괄호로 묶지 않은 숫자는 오른쪽 함수에서 소비 한 누적 시간을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="cab1487529e22885346d5098b46bd492a9089ff9" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt;&lt;code&gt;PureWindowsPath&lt;/code&gt;&lt;/a&gt;, return &lt;code&gt;True&lt;/code&gt; if the path is considered reserved under Windows, &lt;code&gt;False&lt;/code&gt; otherwise. With &lt;a href=&quot;#pathlib.PurePosixPath&quot;&gt;&lt;code&gt;PurePosixPath&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;False&lt;/code&gt; is always returned.</source>
          <target state="translated">&lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt; &lt;code&gt;PureWindowsPath&lt;/code&gt; 를&lt;/a&gt; 사용 하여 경로가 Windows에서 예약 된 것으로 간주되면 &lt;code&gt;True&lt;/code&gt; 를 , &lt;code&gt;False&lt;/code&gt; 않으면 False를 리턴 하십시오 . 로 &lt;a href=&quot;#pathlib.PurePosixPath&quot;&gt; &lt;code&gt;PurePosixPath&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;False&lt;/code&gt; 항상 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e771f57ddca6161f395e0eeba63e82d899e7d5f" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; it matters that you patch objects in the namespace where they are looked up. This is normally straightforward, but for a quick guide read &lt;a href=&quot;#where-to-patch&quot;&gt;where to patch&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 사용하면 검색된 네임 스페이스에서 객체를 패치해야합니다. 이것은 일반적으로 간단하지만, 빠른 가이드 &lt;a href=&quot;#where-to-patch&quot;&gt;를 위해 패치 할 곳을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="687dc08f377a2b328a8f70bc97535a43cc502f58" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;interpolation&lt;/code&gt; set to &lt;code&gt;None&lt;/code&gt;, the parser would simply return &lt;code&gt;%(my_dir)s/Pictures&lt;/code&gt; as the value of &lt;code&gt;my_pictures&lt;/code&gt; and &lt;code&gt;%(home_dir)s/lumberjack&lt;/code&gt; as the value of &lt;code&gt;my_dir&lt;/code&gt;.</source>
          <target state="translated">하여 &lt;code&gt;interpolation&lt;/code&gt; 에 집합 &lt;code&gt;None&lt;/code&gt; 파서 단순히 반환 &lt;code&gt;%(my_dir)s/Pictures&lt;/code&gt; 의 값으로 &lt;code&gt;my_pictures&lt;/code&gt; 및 &lt;code&gt;%(home_dir)s/lumberjack&lt;/code&gt; 의 값 &lt;code&gt;my_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15bc87ebe549a152d95621af5e9d7461b775788e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;mode='w'&lt;/code&gt;, a writable file handle is returned, which supports the &lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; method. While a writable file handle is open, attempting to read or write other files in the ZIP file will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로 &lt;code&gt;mode='w'&lt;/code&gt; , 쓰기 가능한 파일 핸들이지지되는 반환 &lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 방법. 쓰기 가능한 파일 핸들이 열려있는 동안 ZIP 파일에서 다른 파일을 읽거나 쓰려고하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fd7953113e258fb4a03370e957ae379b0c21dcb8" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt; you can specify which file mode will be passed to &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. It must be one of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rU'&lt;/code&gt;, &lt;code&gt;'U'&lt;/code&gt; and &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;mode&lt;/em&gt; 를 사용하면 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 전달할 파일 모드를 지정할 수 있습니다 . &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rU'&lt;/code&gt; , &lt;code&gt;'U'&lt;/code&gt; 및 &lt;code&gt;'rb'&lt;/code&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="2da8c5473cf49716c34f3c81822b2920eb1d2993" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt;&lt;code&gt;'r'&lt;/code&gt; the file-like object (&lt;code&gt;ZipExtFile&lt;/code&gt;) is read-only and provides the following methods: &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;readlines()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.seek&quot;&gt;&lt;code&gt;seek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.tell&quot;&gt;&lt;code&gt;tell()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt;. These objects can operate independently of the ZipFile.</source>
          <target state="translated">&lt;code&gt;'r'&lt;/code&gt; &lt;em&gt;모드를&lt;/em&gt; 사용 하면 파일과 유사한 객체 ( &lt;code&gt;ZipExtFile&lt;/code&gt; )는 읽기 전용이며 &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;readlines()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.seek&quot;&gt; &lt;code&gt;seek()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.tell&quot;&gt; &lt;code&gt;tell()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다 . 이러한 객체는 ZipFile과 독립적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="760bad3e7ab6068220380f26094e6c0104a0a57d" translate="yes" xml:space="preserve">
          <source>With IDLE&amp;rsquo;s Shell, one enters, edits, and recalls complete statements. Most consoles and terminals only work with a single physical line at a time.</source>
          <target state="translated">IDLE의 Shell을 사용하면 완전한 진술을 입력, 편집 및 호출 할 수 있습니다. 대부분의 콘솔과 터미널은 한 번에 하나의 물리적 회선으로 만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c8624f48bb5849e7e5433618835e15f38bb647da" translate="yes" xml:space="preserve">
          <source>With SQLite versions before 3.6.5, &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt;&lt;code&gt;rowcount&lt;/code&gt;&lt;/a&gt; is set to 0 if you make a &lt;code&gt;DELETE FROM table&lt;/code&gt; without any condition.</source>
          <target state="translated">3.6.5 이전의 SQLite 버전에서는 조건없이 &lt;code&gt;DELETE FROM table&lt;/code&gt; 을 만들면 &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt; &lt;code&gt;rowcount&lt;/code&gt; &lt;/a&gt; 가 0으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="25ab21266758b5ede32eaf88e6036970613bdaaa" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;filename:lineno&lt;/em&gt; argument, clear all the breakpoints at this line. With a space separated list of breakpoint numbers, clear those breakpoints. Without argument, clear all breaks (but first ask confirmation).</source>
          <target state="translated">A의 &lt;em&gt;파일 이름 : LINENO의&lt;/em&gt; 인수,이 라인에서 모든 중단 점을 취소합니다. 공백으로 구분 된 중단 점 번호 목록을 사용하여 해당 중단 점을 지우십시오. 논증없이 모든 휴식 시간을 지 웁니다 (그러나 먼저 확인을 요청하십시오).</target>
        </trans-unit>
        <trans-unit id="2f04d9aa94fac16f17c271f8cc6b74f5e423a9cf" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;lineno&lt;/em&gt; argument, set a break there in the current file. With a &lt;em&gt;function&lt;/em&gt; argument, set a break at the first executable statement within that function. The line number may be prefixed with a filename and a colon, to specify a breakpoint in another file (probably one that hasn&amp;rsquo;t been loaded yet). The file is searched on &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;. Note that each breakpoint is assigned a number to which all the other breakpoint commands refer.</source>
          <target state="translated">A를 &lt;em&gt;LINENO의&lt;/em&gt; 인수, 현재 파일에 휴식이 설정합니다. &lt;em&gt;함수&lt;/em&gt; 인수를 사용하여 해당 함수 내 첫 번째 실행 문에서 구분을 설정하십시오. 줄 번호 앞에 파일 이름과 콜론을 붙여 다른 파일 (아마도 아직로드되지 않은)에 중단 점을 지정할 수 있습니다. 파일은 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에서&lt;/a&gt; 검색됩니다 . 각 중단 점에는 다른 모든 중단 점 명령이 참조하는 번호가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2644e40930b324401a9a51c3ee62d4106eb004ee" translate="yes" xml:space="preserve">
          <source>With a line number, continue execution until a line with a number greater or equal to that is reached. In both cases, also stop when the current frame returns.</source>
          <target state="translated">줄 번호를 사용하면 그보다 크거나 같은 줄에 도달 할 때까지 계속 실행하십시오. 두 경우 모두 현재 프레임이 반환되면 중지합니다.</target>
        </trans-unit>
        <trans-unit id="38ea4c11846bc3197c60dd6b0099e4ae33231ccb" translate="yes" xml:space="preserve">
          <source>With all of these &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicies&lt;/code&gt;&lt;/a&gt;, the effective API of the email package is changed from the Python 3.2 API in the following ways:</source>
          <target state="translated">이러한 모든 &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicies&lt;/code&gt; &lt;/a&gt; 를 사용하면 이메일 패키지의 유효 API가 다음과 같은 방식으로 Python 3.2 API에서 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="b96c4be50c56eb883550373721c030d4e8832643" translate="yes" xml:space="preserve">
          <source>With all these new widgets, you can introduce new interaction techniques into applications, creating more useful and more intuitive user interfaces. You can design your application by choosing the most appropriate widgets to match the special needs of your application and users.</source>
          <target state="translated">이러한 모든 새로운 위젯을 사용하면 응용 프로그램에 새로운 상호 작용 기술을 도입하여보다 유용하고 직관적 인 사용자 인터페이스를 만들 수 있습니다. 애플리케이션과 사용자의 특수 요구에 맞는 가장 적합한 위젯을 선택하여 애플리케이션을 설계 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfb01d15923e2347d124cf6810b6f7bbee6f12aa" translate="yes" xml:space="preserve">
          <source>With an explicit &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; argument, the result is a byte string in the specified encoding. With no &lt;em&gt;encoding&lt;/em&gt; argument, the result is a Unicode string, and the XML declaration in the resulting string does not specify an encoding. Encoding this string in an encoding other than UTF-8 is likely incorrect, since UTF-8 is the default encoding of XML.</source>
          <target state="translated">명시 적 &lt;em&gt;인코딩 &lt;/em&gt;&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 인수를 사용하면 결과는 지정된 인코딩의 바이트 문자열입니다. &lt;em&gt;인코딩&lt;/em&gt; 인수가 없으면 결과는 유니 코드 문자열이며 결과 문자열의 XML 선언은 인코딩을 지정하지 않습니다. UTF-8이 XML의 기본 인코딩이므로 UTF-8 이외의 인코딩으로이 문자열을 인코딩하는 것은 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4880d188a38217b2e5a2d31451fe8eadcea721e6" translate="yes" xml:space="preserve">
          <source>With arguments, return a list of values that result from looking up each argument in the configuration variable dictionary.</source>
          <target state="translated">인수를 사용하여 구성 변수 사전에서 각 인수를 찾은 결과 값 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="764867c8bff630b1f0ada90f3f9eb8f138801c7b" translate="yes" xml:space="preserve">
          <source>With filtering on, &lt;code&gt;dir(some_mock)&lt;/code&gt; shows only useful attributes and will include any dynamically created attributes that wouldn&amp;rsquo;t normally be shown. If the mock was created with a &lt;em&gt;spec&lt;/em&gt; (or &lt;em&gt;autospec&lt;/em&gt; of course) then all the attributes from the original are shown, even if they haven&amp;rsquo;t been accessed yet:</source>
          <target state="translated">필터링을 설정하면 &lt;code&gt;dir(some_mock)&lt;/code&gt; 은 유용한 속성 만 표시하며 일반적으로 표시되지 않는 동적으로 생성 된 속성을 포함합니다. 모의가 &lt;em&gt;스펙&lt;/em&gt; (또는 &lt;em&gt;자동 &lt;/em&gt;&lt;em&gt;스펙)&lt;/em&gt; 으로 작성된 경우, 아직 액세스하지 않은 경우에도 원본의 모든 속성이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aab53d4374bfcc2a7d9f8f2e07cc334e9b8d4ebe" translate="yes" xml:space="preserve">
          <source>With no &lt;em&gt;bpnumber&lt;/em&gt; argument, &lt;code&gt;commands&lt;/code&gt; refers to the last breakpoint set.</source>
          <target state="translated">&lt;em&gt;bpnumber&lt;/em&gt; 인수가 없으면 &lt;code&gt;commands&lt;/code&gt; 은 마지막 중단 점 세트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a0d7fd252a8ac0acd7b9c9b4e24a97bf47857d8f" translate="yes" xml:space="preserve">
          <source>With no arguments, return a dictionary of all configuration variables relevant for the current platform.</source>
          <target state="translated">인수없이, 현재 플랫폼과 관련된 모든 구성 변수의 사전을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="efd89a071ec612fcc528b4ebb7e35378e6acc199" translate="yes" xml:space="preserve">
          <source>With no arguments, run a full collection. The optional argument &lt;em&gt;generation&lt;/em&gt; may be an integer specifying which generation to collect (from 0 to 2). A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if the generation number is invalid. The number of unreachable objects found is returned.</source>
          <target state="translated">인수없이 전체 컬렉션을 실행하십시오. 선택적 인수 &lt;em&gt;생성&lt;/em&gt; 은 수집 할 생성을 지정하는 정수일 수 있습니다 (0에서 2까지). &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 생성 번호가 무효 인 경우 발생합니다. 찾을 수없는 개체의 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed5301520b7fd396ab2dfe6409c5f533e884e4c5" translate="yes" xml:space="preserve">
          <source>With one argument, return the natural logarithm of &lt;em&gt;x&lt;/em&gt; (to base &lt;em&gt;e&lt;/em&gt;).</source>
          <target state="translated">하나의 인수로 &lt;em&gt;x&lt;/em&gt; 의 자연 로그 ( &lt;em&gt;e&lt;/em&gt; 를 밑으로 ) 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5717389f2b0fe33f8fc1d55c281454fe06d5e2b" translate="yes" xml:space="preserve">
          <source>With one argument, return the type of an &lt;em&gt;object&lt;/em&gt;. The return value is a type object and generally the same object as returned by &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt;&lt;code&gt;object.__class__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나의 인수로 &lt;em&gt;객체&lt;/em&gt; 의 유형을 반환 &lt;em&gt;합니다&lt;/em&gt; . 리턴 값은 유형 오브젝트이며 일반적으로 &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt; &lt;code&gt;object.__class__&lt;/code&gt; &lt;/a&gt; 리턴 한 것과 동일한 오브젝트 입니다.</target>
        </trans-unit>
        <trans-unit id="3010b34325387d6e0374de77099e8677662b587d" translate="yes" xml:space="preserve">
          <source>With one argument, returns a dictionary of column/value pairs for the specified &lt;em&gt;item&lt;/em&gt;. With two arguments, returns the current value of the specified &lt;em&gt;column&lt;/em&gt;. With three arguments, sets the value of given &lt;em&gt;column&lt;/em&gt; in given &lt;em&gt;item&lt;/em&gt; to the specified &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">하나의 인수로 지정된 &lt;em&gt;item에&lt;/em&gt; 대한 열 / 값 쌍 사전을 리턴합니다 . 두 개의 인수를 사용하면 지정된 &lt;em&gt;column&lt;/em&gt; 의 현재 값을 반환합니다 . 세 인수로 주어진 값으로 설정 &lt;em&gt;열의&lt;/em&gt; 소정의 &lt;em&gt;항목에&lt;/em&gt; 지정된 행 &lt;em&gt;값&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f254b557ac83471d6ca20286be89daa2ca79428b" translate="yes" xml:space="preserve">
          <source>With optional argument &lt;em&gt;i&lt;/em&gt;, &lt;a href=&quot;#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; will return the &lt;em&gt;i&lt;/em&gt;-th element of the payload, counting from zero, if &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;. An &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;em&gt;i&lt;/em&gt; is less than 0 or greater than or equal to the number of items in the payload. If the payload is a string (i.e. &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;) and &lt;em&gt;i&lt;/em&gt; is given, a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">선택적 인수로 &lt;em&gt;난&lt;/em&gt; , &lt;a href=&quot;#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 반환됩니다 &lt;em&gt;난&lt;/em&gt; 경우, 0에서 페이로드, 계산의 번째 요소를 &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; 입니다 &lt;code&gt;True&lt;/code&gt; . &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; 는&lt;/a&gt; 경우 발생한다 &lt;em&gt;제가&lt;/em&gt; 0보다 작거나 또는보다 큰 페이로드의 항목 수와 같다. 페이로드가 문자열이고 (즉, &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; is &lt;code&gt;False&lt;/code&gt; ) &lt;em&gt;i&lt;/em&gt; 가 제공되면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95cfd380016562aed86b66b762be2eb99843bf08" translate="yes" xml:space="preserve">
          <source>With pickle protocol version 4 it is possible to easily pickle enums nested in other classes.</source>
          <target state="translated">피클 프로토콜 버전 4를 사용하면 다른 클래스에 중첩 된 열거 형을 쉽게 피클 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1839f1bd0fed63c796608b36a191d7890a7fee" translate="yes" xml:space="preserve">
          <source>With rare exceptions, the result of executing Python code with IDLE is intended to be the same as executing the same code by the default method, directly with Python in a text-mode system console or terminal window. However, the different interface and operation occasionally affect visible results. For instance, &lt;code&gt;sys.modules&lt;/code&gt; starts with more entries, and &lt;code&gt;threading.activeCount()&lt;/code&gt; returns 2 instead of 1.</source>
          <target state="translated">드문 경우를 제외하고 IDLE을 사용하여 Python 코드를 실행 한 결과는 텍스트 모드 시스템 콘솔 또는 터미널 창에서 Python을 사용하여 기본 방법으로 동일한 코드를 실행하는 것과 동일합니다. 그러나 다른 인터페이스와 작업은 때때로 가시적 인 결과에 영향을줍니다. 예를 들어 &lt;code&gt;sys.modules&lt;/code&gt; 는 더 많은 항목으로 시작하고 &lt;code&gt;threading.activeCount()&lt;/code&gt; 는 1 대신 2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0015f869c31b401bfecbb86dbfba0c4047c9bd7" translate="yes" xml:space="preserve">
          <source>With server socket, this mode provides mandatory TLS client cert authentication. A client certificate request is sent to the client and the client must provide a valid and trusted certificate.</source>
          <target state="translated">서버 소켓을 사용하면이 모드는 필수 TLS 클라이언트 인증서 인증을 제공합니다. 클라이언트 인증서 요청이 클라이언트로 전송되고 클라이언트는 유효하고 신뢰할 수있는 인증서를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d44fbe6e65b12b51b031a5cae9513730c1dc7435" translate="yes" xml:space="preserve">
          <source>With sufficient knowledge of applicable algorithmic and political time adjustments, such as time zone and daylight saving time information, an &lt;strong&gt;aware&lt;/strong&gt; object can locate itself relative to other aware objects. An aware object represents a specific moment in time that is not open to interpretation. &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">시간대 및 일광 절약 시간제 정보와 같은 적용 가능한 알고리즘 및 정치적 시간 조정에 대한 충분한 지식이 있으면 &lt;strong&gt;인식&lt;/strong&gt; 대상은 다른 인식 대상에 상대적으로 위치 할 수 있습니다. 인식 객체는 해석 할 수없는 특정 시점을 나타냅니다. &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="deac18952e93d68efd06227e703e6bf5a3115b23" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;'store_const'&lt;/code&gt; and &lt;code&gt;'append_const'&lt;/code&gt; actions, the &lt;code&gt;const&lt;/code&gt; keyword argument must be given. For other actions, it defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;'store_const'&lt;/code&gt; 와 &lt;code&gt;'append_const'&lt;/code&gt; 행동의 &lt;code&gt;const&lt;/code&gt; 키워드 인수를 제공해야합니다. 다른 조치의 경우 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="194119009270c68f60a1104e8b4240dd2ceaff94" translate="yes" xml:space="preserve">
          <source>With the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, the method call does not block. If the lock is currently in a locked state, return &lt;code&gt;False&lt;/code&gt;; otherwise set the lock to a locked state and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;em&gt;블록&lt;/em&gt; 에 인수 세트 &lt;code&gt;False&lt;/code&gt; , 메서드 호출이 차단되지 않습니다. 잠금이 현재 잠금 상태 인 경우 &lt;code&gt;False&lt;/code&gt; 를 리턴하십시오 . 그렇지 않으면 잠금을 잠금 상태로 설정하고 &lt;code&gt;True&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e871eb88b98ae8c67b374e93e1e89a7c0c7dcd5" translate="yes" xml:space="preserve">
          <source>With the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt; (the default), the method call will block until the lock is in an unlocked state, then set it to locked and return &lt;code&gt;True&lt;/code&gt;. Note that the name of this first argument differs from that in &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt;&lt;code&gt;threading.Lock.acquire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">으로 &lt;em&gt;블록&lt;/em&gt; 에 인수 세트 &lt;code&gt;True&lt;/code&gt; (기본), 메소드 호출은 잠금이 해제 상태가 될 때까지, 다음 잠금으로 설정하고 반환 차단합니다 &lt;code&gt;True&lt;/code&gt; . 이 첫 번째 인수의 이름은 &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt; &lt;code&gt;threading.Lock.acquire()&lt;/code&gt; &lt;/a&gt; 의 이름과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="2269bdd62541838f898684dcd5142d85924bfe48" translate="yes" xml:space="preserve">
          <source>With the subsequent code object one can execute it in a module by running &lt;code&gt;exec(code, module.__dict__)&lt;/code&gt;.</source>
          <target state="translated">후속 코드 객체를 사용하면 &lt;code&gt;exec(code, module.__dict__)&lt;/code&gt; 를 실행하여 모듈에서 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebbacdcf56db793c4cc45ee8691bf7b6605ec5c1" translate="yes" xml:space="preserve">
          <source>With this pattern, multiple factories could be chained, and as long as they don&amp;rsquo;t overwrite each other&amp;rsquo;s attributes or unintentionally overwrite the standard attributes listed above, there should be no surprises.</source>
          <target state="translated">이 패턴을 사용하면 여러 팩토리를 체인화 할 수 있으며 서로의 속성을 덮어 쓰지 않거나 위에 나열된 표준 속성을 실수로 덮어 쓰지 않는 한 놀랄 일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="40a6ba4daa5a2342ad82ea7038d0c1a705a07197" translate="yes" xml:space="preserve">
          <source>With three arguments, compute &lt;code&gt;(x**y) % modulo&lt;/code&gt;. For the three argument form, the following restrictions on the arguments hold:</source>
          <target state="translated">세 개의 인수를 사용하여 &lt;code&gt;(x**y) % modulo&lt;/code&gt; . 세 가지 인수 형식의 경우 다음과 같은 인수 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fab22f970395c672be8c4c452402f6883149c6e" translate="yes" xml:space="preserve">
          <source>With three arguments, return a new type object. This is essentially a dynamic form of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; statement. The &lt;em&gt;name&lt;/em&gt; string is the class name and becomes the &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; attribute; the &lt;em&gt;bases&lt;/em&gt; tuple itemizes the base classes and becomes the &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt;&lt;code&gt;__bases__&lt;/code&gt;&lt;/a&gt; attribute; and the &lt;em&gt;dict&lt;/em&gt; dictionary is the namespace containing definitions for class body and is copied to a standard dictionary to become the &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute. For example, the following two statements create identical &lt;a href=&quot;#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">세 개의 인수를 사용하여 새 유형 객체를 반환하십시오. 이것은 본질적으로 동적 인 형태의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt; &lt;code&gt;class&lt;/code&gt; &lt;/a&gt; 진술이다. &lt;em&gt;이름&lt;/em&gt; 문자열은 클래스 이름이며,이된다 &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; 의&lt;/a&gt; 속성; &lt;em&gt;염기&lt;/em&gt; 기본 클래스를 항목별로 상기 튜플된다 &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt; &lt;code&gt;__bases__&lt;/code&gt; 의&lt;/a&gt; 특성; 그리고 &lt;em&gt;DICT의&lt;/em&gt; 사전 클래스 본문에 대한 정의를 포함하는 네임 스페이스와되기 위해 표준 사전에 복사 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; 의&lt;/a&gt; 속성. 예를 들어, 다음 두 명령문은 동일한 &lt;a href=&quot;#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 오브젝트를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="f8885c6119b55f6917eee9f2b9372898c8263a3e" translate="yes" xml:space="preserve">
          <source>With two arguments, compute &lt;code&gt;x**y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is negative then &lt;code&gt;y&lt;/code&gt; must be integral. The result will be inexact unless &lt;code&gt;y&lt;/code&gt; is integral and the result is finite and can be expressed exactly in &amp;lsquo;precision&amp;rsquo; digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version.</source>
          <target state="translated">두 개의 인수로 &lt;code&gt;x**y&lt;/code&gt; 계산하십시오 . 경우 &lt;code&gt;x&lt;/code&gt; 음수 후 &lt;code&gt;y&lt;/code&gt; 정수이어야한다. &lt;code&gt;y&lt;/code&gt; 가 정수이고 결과가 유한 하지 않고 정확하게 '정밀'숫자로 표현 될 수 없으면 결과는 정확하지 않습니다 . 컨텍스트의 반올림 모드가 사용됩니다. 파이썬 버전에서는 항상 결과가 올바로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="b43cb0e0aa8bf5b547ad83f94e989da6ff98d438" translate="yes" xml:space="preserve">
          <source>With two arguments, return the logarithm of &lt;em&gt;x&lt;/em&gt; to the given &lt;em&gt;base&lt;/em&gt;, calculated as &lt;code&gt;log(x)/log(base)&lt;/code&gt;.</source>
          <target state="translated">두 개의 인수 를 사용하여 &lt;code&gt;log(x)/log(base)&lt;/code&gt; 로 계산 된 &lt;em&gt;x&lt;/em&gt; 의 로그를 주어진 &lt;em&gt;base&lt;/em&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="00a50c0d900159dbcd62b43debe7309bd2b37fad" translate="yes" xml:space="preserve">
          <source>With version 1 (provided for reproducing random sequences from older versions of Python), the algorithm for &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; generates a narrower range of seeds.</source>
          <target state="translated">버전 1 (이전 버전의 Python에서 임의의 시퀀스를 재생하기 위해 제공됨)을 사용하면 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 알고리즘 이 더 좁은 범위의 시드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b20bd639ded266fcc391752e271e39a98c7700d3" translate="yes" xml:space="preserve">
          <source>With version 2 (the default), a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; object gets converted to an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; and all of its bits are used.</source>
          <target state="translated">버전 2 (기본값)를 사용하면 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 객체가 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 로 변환 되고 모든 비트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ec63c85650e7ada817c79ea880456525b435a75" translate="yes" xml:space="preserve">
          <source>With versions of OpenSSL older than 0.9.8m, it is only possible to set options, not to clear them. Attempting to clear an option (by resetting the corresponding bits) will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">0.9.8m 이전의 OpenSSL 버전에서는 옵션을 지우지 않고 설정할 수 있습니다. 해당 비트를 재설정하여 옵션을 지우려고하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6887de87bb8914463818ce0668d423fe277ff788" translate="yes" xml:space="preserve">
          <source>Within an editor window containing Python code, code context can be toggled in order to show or hide a pane at the top of the window. When shown, this pane freezes the opening lines for block code, such as those beginning with &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, or &lt;code&gt;if&lt;/code&gt; keywords, that would have otherwise scrolled out of view. The size of the pane will be expanded and contracted as needed to show the all current levels of context, up to the maximum number of lines defined in the Configure IDLE dialog (which defaults to 15). If there are no current context lines and the feature is toggled on, a single blank line will display. Clicking on a line in the context pane will move that line to the top of the editor.</source>
          <target state="translated">Python 코드가 포함 된 편집기 창 내에서 창의 상단에 창을 표시하거나 숨기려면 코드 컨텍스트를 토글 할 수 있습니다. 표시 할 때,이 창은로 시작하는 것과 같은 블록 코드의 오프닝 라인, 정지 &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; , 또는 &lt;code&gt;if&lt;/code&gt; 그렇지 않으면보기 밖으로 스크롤했을 그 키워드를. 분할 창의 크기는 모든 현재 컨텍스트 레벨을 표시하기 위해 필요에 따라 확장 및 축소되며 IDLE 구성 대화 상자에 정의 된 최대 줄 수 (기본값은 15)입니다. 현재 상황에 맞는 줄이없고 기능이 설정되어 있으면 빈 줄 하나가 표시됩니다. 상황에 맞는 창에서 행을 클릭하면 해당 행이 편집기 맨 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2f8b057e4c0feacb665a8a7757beb8aa22e2fdde" translate="yes" xml:space="preserve">
          <source>Without an argument, &lt;a href=&quot;#vars&quot;&gt;&lt;code&gt;vars()&lt;/code&gt;&lt;/a&gt; acts like &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt;. Note, the locals dictionary is only useful for reads since updates to the locals dictionary are ignored.</source>
          <target state="translated">인수가 없으면 &lt;a href=&quot;#vars&quot;&gt; &lt;code&gt;vars()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 처럼 작동 합니다. 지역 사전에 대한 업데이트는 무시되므로 지역 사전은 읽기에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89afaf5902230f11dab6931656e83d660578a26d" translate="yes" xml:space="preserve">
          <source>Without an argument, an array of size 0 is created.</source>
          <target state="translated">인수가 없으면 크기가 0 인 배열이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9879a08d72136016023f63f62288fdbd06d5e766" translate="yes" xml:space="preserve">
          <source>Without any optional argument, this method acquires the lock unconditionally, if necessary waiting until it is released by another thread (only one thread at a time can acquire a lock &amp;mdash; that&amp;rsquo;s their reason for existence).</source>
          <target state="translated">선택적인 인수가 없으면이 메소드는 필요에 따라 다른 스레드에 의해 해제 될 때까지 대기하는 동안 무조건 잠금을 획득합니다 (한 번에 하나의 스레드 만 잠금을 획득 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="eb98828bb03ebff04d92f1d4995a6a336ce35b0c" translate="yes" xml:space="preserve">
          <source>Without argument, continue execution until the line with a number greater than the current one is reached.</source>
          <target state="translated">인수가 없으면 현재 행보다 큰 행에 도달 할 때까지 실행을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="c89138ed071a0b6e27259e35980ae9555134901d" translate="yes" xml:space="preserve">
          <source>Without argument, list all breaks, including for each breakpoint, the number of times that breakpoint has been hit, the current ignore count, and the associated condition if any.</source>
          <target state="translated">인수없이 각 중단 점, 중단 점에 도달 한 횟수, 현재 무시 횟수 및 연관된 조건이있는 경우를 포함하여 모든 중단을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="5eeedd2237cda7b0eb8c9cc1a204ca22979c1c18" translate="yes" xml:space="preserve">
          <source>Without argument, print the list of available commands. With a &lt;em&gt;command&lt;/em&gt; as argument, print help about that command. &lt;code&gt;help pdb&lt;/code&gt; displays the full documentation (the docstring of the &lt;a href=&quot;#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; module). Since the &lt;em&gt;command&lt;/em&gt; argument must be an identifier, &lt;code&gt;help exec&lt;/code&gt; must be entered to get help on the &lt;code&gt;!&lt;/code&gt; command.</source>
          <target state="translated">인수없이 사용 가능한 명령 목록을 인쇄하십시오. &lt;em&gt;명령&lt;/em&gt; 을 인수로 사용하여 해당 명령에 대한 도움말을 인쇄하십시오. &lt;code&gt;help pdb&lt;/code&gt; 는 전체 문서 ( &lt;a href=&quot;#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 모듈 의 docstring)를 표시합니다 . 때문에 &lt;em&gt;명령&lt;/em&gt; 인수가 식별자 여야합니다, &lt;code&gt;help exec&lt;/code&gt; 상의 도움을받을 수를 입력해야합니다 &lt;code&gt;!&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="77f66cab56a49a5274a00828711f0d39b63586e1" translate="yes" xml:space="preserve">
          <source>Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.</source>
          <target state="translated">인수가 없으면 현재 로컬 범위의 이름 목록을 반환하십시오. 인수를 사용하여 해당 오브젝트에 유효한 속성 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="769b9bb5176bd30fc5c9a906deb72757797c5114" translate="yes" xml:space="preserve">
          <source>Without expression, list all display expressions for the current frame.</source>
          <target state="translated">표현식없이 현재 프레임에 대한 모든 표시 표현식을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="f094cebe8a845676c5da8b2f31cd1951b0afca42" translate="yes" xml:space="preserve">
          <source>Without external information it&amp;rsquo;s impossible to reliably determine which encoding was used for encoding a string. Each charmap encoding can decode any random byte sequence. However that&amp;rsquo;s not possible with UTF-8, as UTF-8 byte sequences have a structure that doesn&amp;rsquo;t allow arbitrary byte sequences. To increase the reliability with which a UTF-8 encoding can be detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls &lt;code&gt;&quot;utf-8-sig&quot;&lt;/code&gt;) for its Notepad program: Before any of the Unicode characters is written to the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: &lt;code&gt;0xef&lt;/code&gt;, &lt;code&gt;0xbb&lt;/code&gt;, &lt;code&gt;0xbf&lt;/code&gt;) is written. As it&amp;rsquo;s rather improbable that any charmap encoded file starts with these byte values (which would e.g. map to</source>
          <target state="translated">외부 정보가 없으면 문자열 인코딩에 사용 된 인코딩을 확실하게 확인할 수 없습니다. 각 charmap 인코딩은 임의의 바이트 시퀀스를 디코딩 할 수 있습니다. 그러나 UTF-8 바이트 시퀀스에는 임의의 바이트 시퀀스를 허용하지 않는 구조가 있으므로 UTF-8에서는 불가능합니다. UTF-8 인코딩을 감지 할 수있는 안정성을 높이기 위해 Microsoft 는 메모장 프로그램에 대해 UTF-8 (Python 2.5에서 &lt;code&gt;&quot;utf-8-sig&quot;&lt;/code&gt; 라고 함 ) 변형을 개발했습니다 . 유니 코드 문자를 쓰기 전에 UTF-8로 인코딩 된 BOM (바이트 시퀀스 : &lt;code&gt;0xef&lt;/code&gt; , &lt;code&gt;0xbb&lt;/code&gt; , &lt;code&gt;0xbf&lt;/code&gt; 으로 보이는 파일 )이 작성됩니다. 모든 charmap 인코딩 파일이 이러한 바이트 값으로 시작한다는 것은 다소 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="7849a7a1c3473cfd49dc9807cf4c861c767d29df" translate="yes" xml:space="preserve">
          <source>Without the directive it would fail, both because the actual output doesn&amp;rsquo;t have two blanks before the single-digit list elements, and because the actual output is on a single line. This test also passes, and also requires a directive to do so:</source>
          <target state="translated">지시문이 없으면 실제 출력에 한 자리 목록 요소 앞에 두 개의 공백이없고 실제 출력이 한 줄에 있기 때문에 실패합니다. 이 테스트는 또한 통과하며 지시문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b56f8f7059663881528e5f04cc607dbf57d02130" translate="yes" xml:space="preserve">
          <source>Without the use of this decorator factory, the name of the example function would have been &lt;code&gt;'wrapper'&lt;/code&gt;, and the docstring of the original &lt;code&gt;example()&lt;/code&gt; would have been lost.</source>
          <target state="translated">이 데코레이터 팩토리를 사용하지 않으면 예제 함수의 이름은 &lt;code&gt;'wrapper'&lt;/code&gt; 였고 원래 &lt;code&gt;example()&lt;/code&gt; 의 docstring은 손실되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7fe2fe1baf1ec16cf5ceba69d9460d06d020a49" translate="yes" xml:space="preserve">
          <source>Without using a subtest, execution would stop after the first failure, and the error would be less easy to diagnose because the value of &lt;code&gt;i&lt;/code&gt; wouldn&amp;rsquo;t be displayed:</source>
          <target state="translated">하위 테스트를 사용하지 않으면 첫 번째 실패 후 실행이 중지되며 &lt;code&gt;i&lt;/code&gt; 값 이 표시되지 않으므로 오류를 진단하기가 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ea2ab24d7c35c5430a569d407bd85c65f4e85bc" translate="yes" xml:space="preserve">
          <source>Without using the lock output from the different processes is liable to get all mixed up.</source>
          <target state="translated">다른 프로세스의 잠금 출력을 사용하지 않으면 모든 것이 섞일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27c0f0558f8802b19cb669e94d2076c0c6c0fda" translate="yes" xml:space="preserve">
          <source>Worker processes within a &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; typically live for the complete duration of the Pool&amp;rsquo;s work queue. A frequent pattern found in other systems (such as Apache, mod_wsgi, etc) to free resources held by workers is to allow a worker within a pool to complete only a set amount of work before being exiting, being cleaned up and a new process spawned to replace the old one. The &lt;em&gt;maxtasksperchild&lt;/em&gt; argument to the &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; exposes this ability to the end user.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 내의 작업자 프로세스는 일반적으로 풀 작업 대기열의 전체 기간 동안 존재합니다. 작업자가 보유한 자원을 확보하기 위해 다른 시스템 (예 : Apache, mod_wsgi 등)에서 발견되는 빈번한 패턴은 풀 내의 작업자가 종료, 정리 및 새 프로세스 생성 전에 정해진 양의 작업 만 완료하도록 허용하는 것입니다. 이전 것을 교체하십시오. &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 대한 &lt;em&gt;maxtasksperchild&lt;/em&gt; 인수 는이 기능을 최종 사용자에게 노출합니다.</target>
        </trans-unit>
        <trans-unit id="89015cfdb27fab11c50f80e1f354316ca91c613f" translate="yes" xml:space="preserve">
          <source>Working with pipes</source>
          <target state="translated">파이프 작업</target>
        </trans-unit>
        <trans-unit id="8bae363ed38dab1b6d087a54fbbd4f84ed78b18a" translate="yes" xml:space="preserve">
          <source>Working with socket objects directly</source>
          <target state="translated">소켓 객체로 직접 작업</target>
        </trans-unit>
        <trans-unit id="9d6d7f52d1d150a89cde4bda127b7602fe0e15d9" translate="yes" xml:space="preserve">
          <source>Working with threads</source>
          <target state="translated">스레드 작업</target>
        </trans-unit>
        <trans-unit id="67bb3765ae259f479c80ae46b7c05de23c1886aa" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt;&lt;code&gt;BUILD_TUPLE&lt;/code&gt;&lt;/a&gt;, but creates a list.</source>
          <target state="translated">&lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt; &lt;code&gt;BUILD_TUPLE&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fb8fe5d39fb592372defca4a7c0cdd14adfc931a" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt;&lt;code&gt;BUILD_TUPLE&lt;/code&gt;&lt;/a&gt;, but creates a set.</source>
          <target state="translated">&lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt; &lt;code&gt;BUILD_TUPLE&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 세트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2e4b35ffa278b6b960046684c3fd2fa34208fe21" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-DELETE_NAME&quot;&gt;&lt;code&gt;DELETE_NAME&lt;/code&gt;&lt;/a&gt;, but deletes a global name.</source>
          <target state="translated">&lt;a href=&quot;#opcode-DELETE_NAME&quot;&gt; &lt;code&gt;DELETE_NAME&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 전체 이름을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="9391eb2e809296019b9e1392d2df6abc88491766" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-STORE_NAME&quot;&gt;&lt;code&gt;STORE_NAME&lt;/code&gt;&lt;/a&gt;, but stores the name as a global.</source>
          <target state="translated">&lt;a href=&quot;#opcode-STORE_NAME&quot;&gt; &lt;code&gt;STORE_NAME&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 이름을 전역으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f9b523701c081148b44a5e161316a03f46215499" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt; except that the input to the &lt;a href=&quot;#email.parser.BytesFeedParser.feed&quot;&gt;&lt;code&gt;feed()&lt;/code&gt;&lt;/a&gt; method must be a string. This is of limited utility, since the only way for such a message to be valid is for it to contain only ASCII text or, if &lt;code&gt;utf8&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, no binary attachments.</source>
          <target state="translated">&lt;a href=&quot;#email.parser.BytesFeedParser.feed&quot;&gt; &lt;code&gt;feed()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 입력 이 문자열이어야 &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; &lt;/a&gt; 점을 제외하면 BytesFeedParser 와 유사하게 작동 합니다. 이러한 메시지가 유효한 유일한 방법은 ASCII 텍스트 만 포함하거나 &lt;code&gt;utf8&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 이면 이진 첨부 파일이없는 것이므로 유틸리티의 기능이 제한적 입니다.</target>
        </trans-unit>
        <trans-unit id="185db21e361257c180478865bbb0efa3b0737049" translate="yes" xml:space="preserve">
          <source>Works the same way as &lt;a href=&quot;#inspect.Signature.bind&quot;&gt;&lt;code&gt;Signature.bind()&lt;/code&gt;&lt;/a&gt;, but allows the omission of some required arguments (mimics &lt;a href=&quot;functools#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt; behavior.) Returns &lt;a href=&quot;#inspect.BoundArguments&quot;&gt;&lt;code&gt;BoundArguments&lt;/code&gt;&lt;/a&gt;, or raises a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the passed arguments do not match the signature.</source>
          <target state="translated">&lt;a href=&quot;#inspect.Signature.bind&quot;&gt; &lt;code&gt;Signature.bind()&lt;/code&gt; &lt;/a&gt; 와 같은 방식으로 작동 하지만 일부 필수 인수 (mimics &lt;a href=&quot;functools#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; 동작 )를 생략 할 수 있습니다. &lt;a href=&quot;#inspect.BoundArguments&quot;&gt; &lt;code&gt;BoundArguments&lt;/code&gt; 를&lt;/a&gt; 반환 하거나 전달 된 인수가 서명과 일치하지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1783e364fda74448269ebe2d7f239fb3ef7f871" translate="yes" xml:space="preserve">
          <source>Wrap &lt;em&gt;application&lt;/em&gt; and return a new WSGI application object. The returned application will forward all requests to the original &lt;em&gt;application&lt;/em&gt;, and will check that both the &lt;em&gt;application&lt;/em&gt; and the server invoking it are conforming to the WSGI specification and to &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;애플리케이션을&lt;/em&gt; 랩핑 하고 새 WSGI 애플리케이션 오브젝트를 리턴하십시오. 리턴 된 애플리케이션은 모든 요청을 원래 &lt;em&gt;애플리케이션&lt;/em&gt; 으로 전달하고 이를 호출 하는 &lt;em&gt;애플리케이션&lt;/em&gt; 과 서버가 WSGI 스펙 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt; 을 준수하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="50ddf4360a796894dae0f6d5a9d4445df2e11d56" translate="yes" xml:space="preserve">
          <source>Wrap a &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt;&lt;code&gt;concurrent.futures.Future&lt;/code&gt;&lt;/a&gt; object in a &lt;a href=&quot;#asyncio.Future&quot;&gt;&lt;code&gt;asyncio.Future&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">랩 &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt; &lt;code&gt;concurrent.futures.Future&lt;/code&gt; 의&lt;/a&gt; A의 객체를 &lt;a href=&quot;#asyncio.Future&quot;&gt; &lt;code&gt;asyncio.Future&lt;/code&gt; 의&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2b27f3224dafe97e6c0b3e8a8fa06d53cea4dc76" translate="yes" xml:space="preserve">
          <source>Wrap a &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;(transport, protocol)&lt;/code&gt; 쌍 으로 감싸십시오 .</target>
        </trans-unit>
        <trans-unit id="c612d6e5f7981ee986eea5813673351e3cb45b2c" translate="yes" xml:space="preserve">
          <source>Wrap a read end of a pipe into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">파이프의 읽기 끝을 &lt;code&gt;(transport, protocol)&lt;/code&gt; 쌍 으로 랩핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff3306add2272df4e9ce3ccf3f316e30e699743f" translate="yes" xml:space="preserve">
          <source>Wrap a write end of a pipe into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">파이프의 쓰기 끝을 &lt;code&gt;(transport, protocol)&lt;/code&gt; 쌍 으로 랩핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="b76b940bb5be2bb8e2a70d99685e901b66b64693" translate="yes" xml:space="preserve">
          <source>Wrap an already accepted connection into a transport/protocol pair.</source>
          <target state="translated">이미 승인 된 연결을 전송 / 프로토콜 쌍으로 래핑하십시오.</target>
        </trans-unit>
        <trans-unit id="6a18c9e5ad1f9bbb6b629543bc34a3ee5302486a" translate="yes" xml:space="preserve">
          <source>Wrap an existing Python socket &lt;em&gt;sock&lt;/em&gt; and return an instance of &lt;a href=&quot;#ssl.SSLContext.sslsocket_class&quot;&gt;&lt;code&gt;SSLContext.sslsocket_class&lt;/code&gt;&lt;/a&gt; (default &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;). The returned SSL socket is tied to the context, its settings and certificates. &lt;em&gt;sock&lt;/em&gt; must be a &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; socket; other socket types are unsupported.</source>
          <target state="translated">기존 Python 소켓 &lt;em&gt;양말을&lt;/em&gt; 감싸고 &lt;a href=&quot;#ssl.SSLContext.sslsocket_class&quot;&gt; &lt;code&gt;SSLContext.sslsocket_class&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하십시오 (기본 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; ). 반환 된 SSL 소켓은 컨텍스트, 설정 및 인증서에 연결됩니다. &lt;em&gt;양말&lt;/em&gt; 은 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 소켓 이어야합니다 . 다른 소켓 유형은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0016efeeb31ae253fc49cf82049e6b29fd8ba856" translate="yes" xml:space="preserve">
          <source>Wrap the &lt;em&gt;coro&lt;/em&gt;&lt;a href=&quot;#coroutine&quot;&gt;coroutine&lt;/a&gt; into a &lt;a href=&quot;#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; and schedule its execution. Return the Task object.</source>
          <target state="translated">&lt;em&gt;코로 &lt;/em&gt;&lt;a href=&quot;#coroutine&quot;&gt;코 루틴&lt;/a&gt; 을 &lt;a href=&quot;#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 싸서 실행을 예약합니다. Task 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f98244aacb2a997c25507ffd260f55a5828e5faa" translate="yes" xml:space="preserve">
          <source>Wrap the BIO objects &lt;em&gt;incoming&lt;/em&gt; and &lt;em&gt;outgoing&lt;/em&gt; and return an instance of &lt;a href=&quot;#ssl.SSLContext.sslobject_class&quot;&gt;&lt;code&gt;SSLContext.sslobject_class&lt;/code&gt;&lt;/a&gt; (default &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;). The SSL routines will read input data from the incoming BIO and write data to the outgoing BIO.</source>
          <target state="translated">&lt;em&gt;수신&lt;/em&gt; 및 &lt;em&gt;발신&lt;/em&gt; BIO 오브젝트를 랩핑하고 &lt;a href=&quot;#ssl.SSLContext.sslobject_class&quot;&gt; &lt;code&gt;SSLContext.sslobject_class&lt;/code&gt; &lt;/a&gt; 인스턴스 (기본 &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; )를 리턴 하십시오. SSL 루틴은 들어오는 BIO에서 입력 데이터를 읽고 나가는 BIO에 데이터를 씁니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
