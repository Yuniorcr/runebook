<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="ae7afc7cda35b97ec7792acdf19b73ce74efe65d" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#getopt.GetoptError&quot;&gt;&lt;code&gt;GetoptError&lt;/code&gt;&lt;/a&gt;; for backward compatibility.</source>
          <target state="translated">&lt;a href=&quot;#getopt.GetoptError&quot;&gt; &lt;code&gt;GetoptError&lt;/code&gt; 의&lt;/a&gt; 별칭 ; 이전 버전과의 호환성을 위해.</target>
        </trans-unit>
        <trans-unit id="b4c82b8c87f05ccdbcc3a216b96cf1a53ccf563e" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; 의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="eab0dbe8bd01f5049191cf6e61204d3aabd1ee93" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#xml.parsers.expat.ExpatError&quot;&gt;&lt;code&gt;ExpatError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.ExpatError&quot;&gt; &lt;code&gt;ExpatError&lt;/code&gt; 의&lt;/a&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="cadc80a1cf0273c362c8330f48cb4ddc336aa467" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;LF&lt;/code&gt;: &amp;ldquo;New line&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; 의 별칭 : &quot;새 줄&quot;</target>
        </trans-unit>
        <trans-unit id="d38e79ce398493b91869071ba23338cb1cdcfe6f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;TAB&lt;/code&gt;: &amp;ldquo;Horizontal tab&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;TAB&lt;/code&gt; 별칭 :&amp;ldquo;수평 탭&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="59614a7389348101f9b1ea41779375c6d97c1236" translate="yes" xml:space="preserve">
          <source>Alias for output, for symmetry with &lt;a href=&quot;#subprocess.CalledProcessError.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.CalledProcessError.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 과의 대칭을위한 출력 별명 .</target>
        </trans-unit>
        <trans-unit id="4d404ca5cc49cbaffcbe2bdf1037676fb7d13f36" translate="yes" xml:space="preserve">
          <source>Alias for output, for symmetry with &lt;a href=&quot;#subprocess.TimeoutExpired.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.TimeoutExpired.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 과의 대칭을위한 출력 별명 .</target>
        </trans-unit>
        <trans-unit id="471e12f5a361936c257c992b8760c41b0d9219fb" translate="yes" xml:space="preserve">
          <source>Alias of &lt;a href=&quot;#zipfile.BadZipFile&quot;&gt;&lt;code&gt;BadZipFile&lt;/code&gt;&lt;/a&gt;, for compatibility with older Python versions.</source>
          <target state="translated">이전 Python 버전과의 호환성을위한 &lt;a href=&quot;#zipfile.BadZipFile&quot;&gt; &lt;code&gt;BadZipFile&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="6fe6d4aa04dab6037d66eb4cb0b7d08cc478f9d1" translate="yes" xml:space="preserve">
          <source>Aliases may be nested and can contain anything that can be legally typed at the pdb prompt. Note that internal pdb commands &lt;em&gt;can&lt;/em&gt; be overridden by aliases. Such a command is then hidden until the alias is removed. Aliasing is recursively applied to the first word of the command line; all other words in the line are left alone.</source>
          <target state="translated">별명은 중첩 될 수 있으며 pdb 프롬프트에서 합법적으로 입력 할 수있는 모든 것을 포함 할 수 있습니다. 내부 pdb 명령 &lt;em&gt;은&lt;/em&gt; 별명으로 대체 될 &lt;em&gt;수&lt;/em&gt; 있습니다. 그런 다음 별명을 제거 할 때까지 이러한 명령이 숨겨집니다. 별칭은 명령 줄의 첫 번째 단어에 재귀 적으로 적용됩니다. 줄의 다른 모든 단어는 그대로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c1a164caf9d915e6d248f6f19c0c5b6e55d90b" translate="yes" xml:space="preserve">
          <source>Aligning the text and specifying a width:</source>
          <target state="translated">텍스트 정렬 및 너비 지정 :</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="a82c356470136a5da9aaa83cba880eb8930e0b37" translate="yes" xml:space="preserve">
          <source>All &amp;ldquo;a&amp;rdquo; functions in this section fail (more or less) silently if the executed program cannot be found; the &amp;ldquo;b&amp;rdquo; replacements raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 섹션의 모든 &quot;a&quot;기능은 실행 된 프로그램을 찾을 수 없으면 자동으로 실패합니다 (약간 또는 그 이하). &quot;b&quot;대체는 대신 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f1726842c26241e242541890252b33775dc0eae3" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;numbers#numbers.Real&quot;&gt;&lt;code&gt;numbers.Real&lt;/code&gt;&lt;/a&gt; types (&lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;) also include the following operations:</source>
          <target state="translated">모든 &lt;a href=&quot;numbers#numbers.Real&quot;&gt; &lt;code&gt;numbers.Real&lt;/code&gt; 의&lt;/a&gt; 유형 ( &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; )도 다음과 같은 작업을 포함한다 :</target>
        </trans-unit>
        <trans-unit id="68cd5f511616dc760e97502971cef15504097ea7" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;multipart&lt;/em&gt; type messages will be parsed as a container message object with a list of sub-message objects for their payload. The outer container message will return &lt;code&gt;True&lt;/code&gt; for &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt;&lt;code&gt;iter_parts()&lt;/code&gt;&lt;/a&gt; will yield a list of subparts.</source>
          <target state="translated">모든 &lt;em&gt;멀티 파트&lt;/em&gt; 유형 메시지는 페이로드에 대한 하위 메시지 객체 목록이있는 컨테이너 메시지 객체로 구문 분석됩니다. 외부 컨테이너 메시지는 &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; 대해 &lt;code&gt;True&lt;/code&gt; 를 반환 하고 &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt; &lt;code&gt;iter_parts()&lt;/code&gt; &lt;/a&gt; 는 하위 파트 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="59f4fc3531243119771587b080eddb77449d0769" translate="yes" xml:space="preserve">
          <source>All &lt;em&gt;other&lt;/em&gt; keys are passed through as keyword arguments to the handler&amp;rsquo;s constructor. For example, given the snippet:</source>
          <target state="translated">&lt;em&gt;다른&lt;/em&gt; 모든 키는 키워드 인수로 핸들러의 생성자에 전달됩니다. 예를 들어, 스 니펫이 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="fb1488621f65c70bf66f1f957d6992583befc69c" translate="yes" xml:space="preserve">
          <source>All &lt;strong&gt;gzip&lt;/strong&gt; compressed streams are required to contain this timestamp field. Some programs, such as &lt;strong&gt;gunzip&lt;/strong&gt;, make use of the timestamp. The format is the same as the return value of &lt;a href=&quot;time#time.time&quot;&gt;&lt;code&gt;time.time()&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;os#os.stat_result.st_mtime&quot;&gt;&lt;code&gt;st_mtime&lt;/code&gt;&lt;/a&gt; attribute of the object returned by &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 &lt;strong&gt;gzip&lt;/strong&gt; 압축 스트림은이 타임 스탬프 필드를 포함해야합니다. &lt;strong&gt;gunzip&lt;/strong&gt; 과 같은 일부 프로그램 은 타임 스탬프를 사용합니다. 형식은 &lt;a href=&quot;time#time.time&quot;&gt; &lt;code&gt;time.time()&lt;/code&gt; &lt;/a&gt; 의 리턴 값 및 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 오브젝트 의 &lt;a href=&quot;os#os.stat_result.st_mtime&quot;&gt; &lt;code&gt;st_mtime&lt;/code&gt; &lt;/a&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f64a36de478d59806bf84b1b01392cf6f7782245" translate="yes" xml:space="preserve">
          <source>All IMAP4rev1 commands are represented by methods of the same name, either upper-case or lower-case.</source>
          <target state="translated">모든 IMAP4rev1 명령은 대문자 또는 소문자로 동일한 이름의 메소드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="59eff8140f7f6cc8eee1beb73070dcf238148177" translate="yes" xml:space="preserve">
          <source>All IO on an &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;#ssl-nonblocking&quot;&gt;non-blocking&lt;/a&gt;. This means that for example &lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; will raise an &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt;&lt;code&gt;SSLWantReadError&lt;/code&gt;&lt;/a&gt; if it needs more data than the incoming BIO has available.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; 의&lt;/a&gt; 모든 IO 는 &lt;a href=&quot;#ssl-nonblocking&quot;&gt;비 블로킹&lt;/a&gt; 입니다. 이는 예를 들어 &lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 가 들어오는 BIO가 사용할 수있는 것보다 더 많은 데이터가 필요한 경우 &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt; &lt;code&gt;SSLWantReadError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f05e728b285d42a5cfcc7b03157016dd489531bf" translate="yes" xml:space="preserve">
          <source>All POP3 commands are represented by methods of the same name, in lower-case; most return the response text sent by the server.</source>
          <target state="translated">모든 POP3 명령은 동일한 이름의 방법으로 소문자로 표시됩니다. 대부분 서버가 보낸 응답 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3414548f8739b658119012bc5a437c65f919cdbe" translate="yes" xml:space="preserve">
          <source>All Platforms</source>
          <target state="translated">모든 플랫폼</target>
        </trans-unit>
        <trans-unit id="3f22c61ff7186f7ff5a4a7b6ac42edb2119d4f66" translate="yes" xml:space="preserve">
          <source>All Win32 systems support at least the following; most systems support many more:</source>
          <target state="translated">모든 Win32 시스템은 최소한 다음을 지원합니다. 대부분의 시스템은 더 많은 것을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="b4c3e2e5e166bd33c375661190706f81b3415ea8" translate="yes" xml:space="preserve">
          <source>All arguments are optional and default to &lt;code&gt;0&lt;/code&gt;. Arguments may be integers or floats, and may be positive or negative.</source>
          <target state="translated">모든 인수는 선택 사항이며 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다. 인수는 정수 또는 부동 소수점 일 수 있으며 양수 또는 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afeaadb9a3f4efc626cf9837aa136718e99ff657" translate="yes" xml:space="preserve">
          <source>All arguments are optional, and all except for &lt;em&gt;m&lt;/em&gt; should be specified in keyword form.</source>
          <target state="translated">모든 인수는 선택 사항이며 &lt;em&gt;m을&lt;/em&gt; 제외한 모든 인수는 키워드 형식으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="45da80b609e066ba052795b1ad773af41969ce6d" translate="yes" xml:space="preserve">
          <source>All arguments are optional. &lt;em&gt;tzinfo&lt;/em&gt; may be &lt;code&gt;None&lt;/code&gt;, or an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass. The remaining arguments must be integers in the following ranges:</source>
          <target state="translated">모든 인수는 선택 사항입니다. &lt;em&gt;tzinfo&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 이거나 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 일 수 있습니다 . 나머지 인수는 다음 범위의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a41de24556098cd8f538669ad809aeff6d77b80b" translate="yes" xml:space="preserve">
          <source>All arguments are required. Arguments must be integers, in the following ranges:</source>
          <target state="translated">모든 주장이 필요합니다. 인수는 다음 범위의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b9c41702d1e64bc776766a2674021dc0acd4cdbf" translate="yes" xml:space="preserve">
          <source>All arguments except &lt;em&gt;filename&lt;/em&gt; are optional, and should be specified in keyword form.</source>
          <target state="translated">&lt;em&gt;filename을&lt;/em&gt; 제외한 모든 인수 는 선택 사항이며 키워드 형식으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee92851c158191e121c730100fcb0d60e5daea4d" translate="yes" xml:space="preserve">
          <source>All arguments to commands are converted to strings, except for &lt;code&gt;AUTHENTICATE&lt;/code&gt;, and the last argument to &lt;code&gt;APPEND&lt;/code&gt; which is passed as an IMAP4 literal. If necessary (the string contains IMAP4 protocol-sensitive characters and isn&amp;rsquo;t enclosed with either parentheses or double quotes) each string is quoted. However, the &lt;em&gt;password&lt;/em&gt; argument to the &lt;code&gt;LOGIN&lt;/code&gt; command is always quoted. If you want to avoid having an argument string quoted (eg: the &lt;em&gt;flags&lt;/em&gt; argument to &lt;code&gt;STORE&lt;/code&gt;) then enclose the string in parentheses (eg: &lt;code&gt;r'(\Deleted)'&lt;/code&gt;).</source>
          <target state="translated">명령에 대한 모든 인수는 &lt;code&gt;AUTHENTICATE&lt;/code&gt; 및 IMAP4 리터럴로 전달되는 &lt;code&gt;APPEND&lt;/code&gt; 에 대한 마지막 인수를 제외하고 문자열로 변환됩니다 . 필요한 경우 (문자열에 IMAP4 프로토콜 구분 문자가 포함되며 괄호 나 큰 따옴표로 묶지 않음) 각 문자열이 인용됩니다. 그러나 &lt;code&gt;LOGIN&lt;/code&gt; 명령 의 &lt;em&gt;비밀번호&lt;/em&gt; 인수 는 항상 인용됩니다. 인수 문자열을 따옴표로 묶지 않으려면 (예 : &lt;code&gt;STORE&lt;/code&gt; 의 &lt;em&gt;flags&lt;/em&gt; 인수 ) 문자열을 괄호로 묶습니다 (예 : &lt;code&gt;r'(\Deleted)'&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="031f5a606c175280f66f531447d16bf78411e5be" translate="yes" xml:space="preserve">
          <source>All asyncio protocols can implement Base Protocol callbacks.</source>
          <target state="translated">모든 asyncio 프로토콜은 기본 프로토콜 콜백을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbd9ac4a05c360b4511702914270df681ebcd66a" translate="yes" xml:space="preserve">
          <source>All attributes implemented by address objects are implemented by network objects as well. In addition, network objects implement additional attributes. All of these are common between &lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt;&lt;code&gt;IPv4Network&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ipaddress.IPv6Network&quot;&gt;&lt;code&gt;IPv6Network&lt;/code&gt;&lt;/a&gt;, so to avoid duplication they are only documented for &lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt;&lt;code&gt;IPv4Network&lt;/code&gt;&lt;/a&gt;. Network objects are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;, so they can be used as keys in dictionaries.</source>
          <target state="translated">주소 객체로 구현 된 모든 속성은 네트워크 객체로도 구현됩니다. 또한 네트워크 객체는 추가 속성을 구현합니다. 이것들은 모두 &lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt; &lt;code&gt;IPv4Network&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#ipaddress.IPv6Network&quot;&gt; &lt;code&gt;IPv6Network&lt;/code&gt; &lt;/a&gt; 간에 공통적 이므로 중복을 피하기 위해 &lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt; &lt;code&gt;IPv4Network&lt;/code&gt; 에&lt;/a&gt; 대해서만 문서화되어 있습니다 . 네트워크 객체는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;해시 가능&lt;/a&gt; 하므로 사전에서 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dbd3c5316f651cef378d40e6f747eaf218b9172" translate="yes" xml:space="preserve">
          <source>All built-in, non-system-exiting exceptions are derived from this class. All user-defined exceptions should also be derived from this class.</source>
          <target state="translated">시스템에 존재하지 않는 모든 내장 예외는이 클래스에서 파생됩니다. 모든 사용자 정의 예외도이 클래스에서 파생되어야합니다.</target>
        </trans-unit>
        <trans-unit id="db1915ddc75890b79023cb3d160beb6524f1bf36" translate="yes" xml:space="preserve">
          <source>All calls to this function with a given name return the same logger instance. This means that logger instances never need to be passed between different parts of an application.</source>
          <target state="translated">주어진 이름으로이 함수를 호출하면 동일한 로거 인스턴스가 반환됩니다. 이는 로거 인스턴스가 애플리케이션의 다른 부분 사이에 전달 될 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0c7ddca5ecb214fc8a6ff6ead24282869b3d742a" translate="yes" xml:space="preserve">
          <source>All changes to MH mailboxes are immediately applied, so this method does nothing.</source>
          <target state="translated">MH 사서함에 대한 모든 변경 사항은 즉시 적용되므로이 방법으로 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36ef7a286b4df5227bf77c9f5987c04ce550fd48" translate="yes" xml:space="preserve">
          <source>All changes to Maildir mailboxes are immediately applied, so this method does nothing.</source>
          <target state="translated">Maildir 사서함에 대한 모든 변경 사항이 즉시 적용되므로이 방법으로 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ba4ce793f08c2aeaad053356252f02ff9e86122" translate="yes" xml:space="preserve">
          <source>All commands will raise an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;nntplib.putline&lt;/code&gt; with arguments &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;, where &lt;code&gt;line&lt;/code&gt; is the bytes about to be sent to the remote host.</source>
          <target state="translated">모든 명령은 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 인수와 함께 &lt;a href=&quot;sys#auditing&quot;&gt;감사 이벤트 &lt;/a&gt; &lt;code&gt;nntplib.putline&lt;/code&gt; 을 발생 시킵니다 . 여기서 &lt;code&gt;line&lt;/code&gt; 은 원격 호스트로 전송 될 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="987583aba6ab43986ee540ce2d5a0a979df6e457" translate="yes" xml:space="preserve">
          <source>All commands will raise an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;poplib.putline&lt;/code&gt; with arguments &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;, where &lt;code&gt;line&lt;/code&gt; is the bytes about to be sent to the remote host.</source>
          <target state="translated">모든 명령은 인수 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 과 함께 &lt;a href=&quot;sys#auditing&quot;&gt;감사 이벤트 &lt;/a&gt; &lt;code&gt;poplib.putline&lt;/code&gt; 을 발생 시킵니다 . 여기서 &lt;code&gt;line&lt;/code&gt; 은 원격 호스트로 전송 될 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="0ebb715b219c77d2b43f98501c7daf8840b7660a" translate="yes" xml:space="preserve">
          <source>All commands will raise an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;smtplib.SMTP.send&lt;/code&gt; with arguments &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;, where &lt;code&gt;data&lt;/code&gt; is the bytes about to be sent to the remote host.</source>
          <target state="translated">모든 명령은 &lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;data&lt;/code&gt; 인수와 함께 &lt;a href=&quot;sys#auditing&quot;&gt;감사 이벤트 &lt;/a&gt; &lt;code&gt;smtplib.SMTP.send&lt;/code&gt; 를 발생 시킵니다 . 여기서 &lt;code&gt;data&lt;/code&gt; 는 원격 호스트로 전송 될 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="130ec836bbcb22e52ee0cf2ee501ba311b193ebb" translate="yes" xml:space="preserve">
          <source>All constants are now &lt;a href=&quot;enum#enum.IntEnum&quot;&gt;&lt;code&gt;enum.IntEnum&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum#enum.IntFlag&quot;&gt;&lt;code&gt;enum.IntFlag&lt;/code&gt;&lt;/a&gt; collections.</source>
          <target state="translated">모든 상수는 이제 &lt;a href=&quot;enum#enum.IntEnum&quot;&gt; &lt;code&gt;enum.IntEnum&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum#enum.IntFlag&quot;&gt; &lt;code&gt;enum.IntFlag&lt;/code&gt; &lt;/a&gt; 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="8bf35df37eefcc4b205b0e86b2bb42edebe23d0f" translate="yes" xml:space="preserve">
          <source>All constants from the &lt;a href=&quot;token#module-token&quot;&gt;&lt;code&gt;token&lt;/code&gt;&lt;/a&gt; module are also exported from &lt;a href=&quot;#module-tokenize&quot;&gt;&lt;code&gt;tokenize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;token#module-token&quot;&gt; &lt;code&gt;token&lt;/code&gt; &lt;/a&gt; 모듈의 모든 상수도 &lt;a href=&quot;#module-tokenize&quot;&gt; &lt;code&gt;tokenize&lt;/code&gt; &lt;/a&gt; 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="299f6f3a07c72abcf84b07e20f8d55abc29c53bc" translate="yes" xml:space="preserve">
          <source>All ctypes data types have a default implementation of this classmethod that normally returns &lt;em&gt;obj&lt;/em&gt; if that is an instance of the type. Some types accept other objects as well.</source>
          <target state="translated">모든 ctypes 데이터 형식에는이 클래스 메서드의 기본 구현이 있으며이 클래스 메서드는 일반적으로 형식의 인스턴스 인 경우 &lt;em&gt;obj를&lt;/em&gt; 반환 합니다. 일부 유형은 다른 객체도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4cb08e4edd7da0cbd1811b03590d4649a88477dd" translate="yes" xml:space="preserve">
          <source>All defect classes are subclassed from &lt;code&gt;email.errors.MessageDefect&lt;/code&gt;.</source>
          <target state="translated">모든 결함 클래스는 &lt;code&gt;email.errors.MessageDefect&lt;/code&gt; 에서 서브 클래스됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4baad04cd2258a2a56a2f8fc40748593c649301" translate="yes" xml:space="preserve">
          <source>All entity references from &lt;a href=&quot;html.entities#module-html.entities&quot;&gt;&lt;code&gt;html.entities&lt;/code&gt;&lt;/a&gt; are replaced in the attribute values.</source>
          <target state="translated">&lt;a href=&quot;html.entities#module-html.entities&quot;&gt; &lt;code&gt;html.entities&lt;/code&gt; 의&lt;/a&gt; 모든 엔티티 참조 는 속성 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e465e17c1a37d9609d9ff9aff3453fc0828078fd" translate="yes" xml:space="preserve">
          <source>All errors raise exceptions. The normal exceptions for invalid argument types and out-of-memory conditions can be raised; starting from Python 3.3, errors related to socket or address semantics raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; or one of its subclasses (they used to raise &lt;a href=&quot;#socket.error&quot;&gt;&lt;code&gt;socket.error&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">모든 오류는 예외를 발생시킵니다. 유효하지 않은 인수 유형 및 메모리 부족 조건에 대한 일반적인 예외가 발생할 수 있습니다. Python 3.3부터 소켓 또는 주소 의미와 관련된 오류는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 또는 해당 서브 클래스 중 하나 ( &lt;a href=&quot;#socket.error&quot;&gt; &lt;code&gt;socket.error&lt;/code&gt; 를 발생시키는&lt;/a&gt; 데 사용됨 )를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2bc61495b794fe0aa34758d7e2920183e2b9b9bd" translate="yes" xml:space="preserve">
          <source>All event loops on Windows do not support the following methods:</source>
          <target state="translated">Windows의 모든 이벤트 루프는 다음 방법을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="caf8948335d4c7f60ae36806aadee301a2f018ea" translate="yes" xml:space="preserve">
          <source>All examples assume a native byte order, size, and alignment with a big-endian machine.</source>
          <target state="translated">모든 예제는 기본 바이트 순서, 크기 및 빅 엔디안 컴퓨터와의 정렬을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f809ac9170e1c6e6ca0f059a4d69cb510f1c3d53" translate="yes" xml:space="preserve">
          <source>All files are opened in text mode by default, but you can override this by specifying the &lt;em&gt;mode&lt;/em&gt; parameter in the call to &lt;a href=&quot;#fileinput.input&quot;&gt;&lt;code&gt;input()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#fileinput.FileInput&quot;&gt;&lt;code&gt;FileInput&lt;/code&gt;&lt;/a&gt;. If an I/O error occurs during opening or reading a file, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">모든 파일은 기본적으로 텍스트 모드로 열리지 만 &lt;a href=&quot;#fileinput.input&quot;&gt; &lt;code&gt;input()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#fileinput.FileInput&quot;&gt; &lt;code&gt;FileInput&lt;/code&gt; &lt;/a&gt; 호출에서 &lt;em&gt;mode&lt;/em&gt; 매개 변수를 지정하여이를 대체 할 수 있습니다 . 파일을 열거 나 읽는 동안 I / O 오류가 발생하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="293649b21c6f8fabecd0b086b5127c14b3f9f4f1" translate="yes" xml:space="preserve">
          <source>All following arguments are optional and can be accessed as instance attributes as well.</source>
          <target state="translated">다음의 모든 인수는 선택 사항이며 인스턴스 속성으로도 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a1a5d969852f9eb11af03015e19c7b15f856807" translate="yes" xml:space="preserve">
          <source>All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.</source>
          <target state="translated">경로 또는 파일 이름을 허용하는 모든 함수는 바이트 및 문자열 객체를 모두 허용하며 경로 또는 파일 이름이 반환되면 동일한 유형의 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="764b4d6c99569a6649ee11a3f6913ea07403cc88" translate="yes" xml:space="preserve">
          <source>All functions in this module raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; (or subclasses thereof) in the case of invalid or inaccessible file names and paths, or other arguments that have the correct type, but are not accepted by the operating system.</source>
          <target state="translated">이 모듈의 모든 함수 는 유효하지 않거나 액세스 할 수없는 파일 이름 및 경로 또는 올바른 유형을 갖지만 운영 체제에서 허용하지 않는 기타 인수의 경우 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; (또는 서브 클래스)를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="84373164968c0434294b7890098e13ea24078ada" translate="yes" xml:space="preserve">
          <source>All functions in this module take a file descriptor &lt;em&gt;fd&lt;/em&gt; as their first argument. This can be an integer file descriptor, such as returned by &lt;code&gt;sys.stdin.fileno()&lt;/code&gt;, or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, such as &lt;code&gt;sys.stdin&lt;/code&gt; itself.</source>
          <target state="translated">이 모듈의 모든 함수는 파일 설명자 &lt;em&gt;fd&lt;/em&gt; 를 첫 번째 인수로 사용합니다. 이것은 &lt;code&gt;sys.stdin.fileno()&lt;/code&gt; 의해 리턴 된 정수 파일 디스크립터 이거나 &lt;code&gt;sys.stdin&lt;/code&gt; 자체 와 같은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 오브젝트&lt;/a&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f341c1e6b9c8fc27dafea2f00fb8167a63cc9f5b" translate="yes" xml:space="preserve">
          <source>All functions in this module take a file descriptor &lt;em&gt;fd&lt;/em&gt; as their first argument. This can be an integer file descriptor, such as returned by &lt;code&gt;sys.stdin.fileno()&lt;/code&gt;, or an &lt;a href=&quot;io#io.IOBase&quot;&gt;&lt;code&gt;io.IOBase&lt;/code&gt;&lt;/a&gt; object, such as &lt;code&gt;sys.stdin&lt;/code&gt; itself, which provides a &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; that returns a genuine file descriptor.</source>
          <target state="translated">이 모듈의 모든 함수는 파일 디스크립터 &lt;em&gt;fd&lt;/em&gt; 를 첫 번째 인수로 사용합니다. 이것은 &lt;code&gt;sys.stdin.fileno()&lt;/code&gt; 의해 리턴 된 정수 파일 디스크립터 이거나 &lt;code&gt;sys.stdin&lt;/code&gt; 자체 와 같은 &lt;a href=&quot;io#io.IOBase&quot;&gt; &lt;code&gt;io.IOBase&lt;/code&gt; &lt;/a&gt; 오브젝트 일 수 있으며 , 이는 실제 파일 디스크립터를 리턴하는 &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1c016a97492d8141818b674772a3c8a871a986a2" translate="yes" xml:space="preserve">
          <source>All hard tab characters are expanded to spaces, using 8-column tab stops. Tabs in output generated by the tested code are not modified. Because any hard tabs in the sample output &lt;em&gt;are&lt;/em&gt; expanded, this means that if the code output includes hard tabs, the only way the doctest can pass is if the &lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt;&lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt;&lt;/a&gt; option or &lt;a href=&quot;#doctest-directives&quot;&gt;directive&lt;/a&gt; is in effect. Alternatively, the test can be rewritten to capture the output and compare it to an expected value as part of the test. This handling of tabs in the source was arrived at through trial and error, and has proven to be the least error prone way of handling them. It is possible to use a different algorithm for handling tabs by writing a custom &lt;a href=&quot;#doctest.DocTestParser&quot;&gt;&lt;code&gt;DocTestParser&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">모든 열 탭 문자는 8 열 탭 정지를 사용하여 공백으로 확장됩니다. 테스트 된 코드에 의해 생성 된 출력의 탭은 수정되지 않습니다. 샘플 출력의 하드 탭 &lt;em&gt;이&lt;/em&gt; 확장 되었으므로 코드 출력에 하드 탭이 포함 된 경우 &lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt; &lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt; &lt;/a&gt; 옵션 또는 &lt;a href=&quot;#doctest-directives&quot;&gt;지시문&lt;/a&gt; 이 유효한 경우 doctest가 통과 할 수있는 유일한 방법 입니다. 또는 테스트를 다시 작성하여 출력을 캡처하고 테스트의 일부로 예상 값과 비교할 수 있습니다. 소스의 탭 처리는 시행 착오를 통해 이루어졌으며 오류 처리가 가장 쉬운 방법으로 입증되었습니다. 사용자 정의 &lt;a href=&quot;#doctest.DocTestParser&quot;&gt; &lt;code&gt;DocTestParser&lt;/code&gt; &lt;/a&gt; 클래스를 작성하여 탭 처리에 다른 알고리즘을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91fc0829f8889a22e20ca26434fbffa2dbfb02ff" translate="yes" xml:space="preserve">
          <source>All inclusive filters are applied at once, a trace is ignored if no inclusive filters match it. A trace is ignored if at least one exclusive filter matches it.</source>
          <target state="translated">모든 포함 필터가 한 번에 적용되며 포함 필터가 일치하지 않으면 추적이 무시됩니다. 하나 이상의 배타적 필터가 일치하면 추적이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e5ed3dd190b5e59dac468767ad1a88d8c4cdff2e" translate="yes" xml:space="preserve">
          <source>All incremental decoders must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</source>
          <target state="translated">모든 증분 디코더는이 생성자 인터페이스를 제공해야합니다. 추가 키워드 인수를 자유롭게 추가 할 수 있지만 여기에 정의 된 키워드 인수 만 Python 코덱 레지스트리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="470d7585fb716131eaa2ac8ea527a90daf24a7cc" translate="yes" xml:space="preserve">
          <source>All incremental encoders must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</source>
          <target state="translated">모든 증분 인코더는이 생성자 인터페이스를 제공해야합니다. 추가 키워드 인수를 자유롭게 추가 할 수 있지만 여기에 정의 된 키워드 인수 만 Python 코덱 레지스트리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e3878938189c7d78e25155ae9238ddf1f98a9c" translate="yes" xml:space="preserve">
          <source>All leading whitespace is removed from the first line. Any leading whitespace that can be uniformly removed from the second line onwards is removed. Empty lines at the beginning and end are subsequently removed. Also, all tabs are expanded to spaces.</source>
          <target state="translated">모든 선행 공백이 첫 번째 줄에서 제거됩니다. 두 번째 줄부터 균일하게 제거 할 수있는 선행 공백이 제거됩니다. 시작과 끝의 빈 줄은 이후에 제거됩니다. 또한 모든 탭이 공백으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a51d14eb54abb876437a862ebfe4b068d36c0dfa" translate="yes" xml:space="preserve">
          <source>All methods are executed atomically.</source>
          <target state="translated">모든 메소드는 원자 적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="af2e44950a8c7f07ebc93e9cd910e4550fa37531" translate="yes" xml:space="preserve">
          <source>All methods of RawTurtle/Turtle also exist as functions, i.e. part of the procedure-oriented interface.</source>
          <target state="translated">RawTurtle / Turtle의 모든 메소드는 함수, 즉 프로 시저 지향 인터페이스의 일부로도 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8a2f5fe29ba9facb218010f2a3bc8e0b1c83b43a" translate="yes" xml:space="preserve">
          <source>All methods of TurtleScreen/Screen also exist as functions, i.e. as part of the procedure-oriented interface.</source>
          <target state="translated">TurtleScreen / Screen의 모든 방법은 함수, 즉 프로 시저 지향 인터페이스의 일부로도 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6a8c9608d8c8cf4f12dfcb3de0e222922cd76e05" translate="yes" xml:space="preserve">
          <source>All non-keyword arguments are converted to strings like &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; does and written to the stream, separated by &lt;em&gt;sep&lt;/em&gt; and followed by &lt;em&gt;end&lt;/em&gt;. Both &lt;em&gt;sep&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; must be strings; they can also be &lt;code&gt;None&lt;/code&gt;, which means to use the default values. If no &lt;em&gt;objects&lt;/em&gt; are given, &lt;a href=&quot;#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; will just write &lt;em&gt;end&lt;/em&gt;.</source>
          <target state="translated">키워드가 아닌 모든 인수는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 과 같은 문자열로 변환되어 스트림에 기록되며 &lt;em&gt;sep로&lt;/em&gt; 구분되고 그 뒤에 &lt;em&gt;end가&lt;/em&gt; 옵니다 . 두 &lt;em&gt;9월&lt;/em&gt; 과 &lt;em&gt;끝은&lt;/em&gt; 문자열이어야합니다 또한 &lt;code&gt;None&lt;/code&gt; 일 수 있으며 이는 기본값을 사용한다는 의미입니다. &lt;em&gt;객체&lt;/em&gt; 가 주어 지지 않으면 &lt;a href=&quot;#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;end&lt;/em&gt; 만 쓰게 됩니다.</target>
        </trans-unit>
        <trans-unit id="04bd0bba21301d490d1f0f4f5b72a1a7c73e3c80" translate="yes" xml:space="preserve">
          <source>All numeric types (except complex) support the following operations (for priorities of the operations, see &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#operator-summary&quot;&gt;Operator precedence&lt;/a&gt;):</source>
          <target state="translated">모든 숫자 유형 (복소수 제외)은 다음 작업을 지원합니다 (작업의 우선 순위는 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#operator-summary&quot;&gt;연산자 우선 순위&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6665fa2ccce2b7ff1105b3c545c20966ec9a92ac" translate="yes" xml:space="preserve">
          <source>All numeric values can be set to &lt;a href=&quot;#locale.CHAR_MAX&quot;&gt;&lt;code&gt;CHAR_MAX&lt;/code&gt;&lt;/a&gt; to indicate that there is no value specified in this locale.</source>
          <target state="translated">이 숫자에 지정된 값이 없음을 나타 내기 위해 모든 숫자 값을 &lt;a href=&quot;#locale.CHAR_MAX&quot;&gt; &lt;code&gt;CHAR_MAX&lt;/code&gt; &lt;/a&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b594fe2c3851296cea213bd7a2a361b71f255ca" translate="yes" xml:space="preserve">
          <source>All of the classes in this module may safely be accessed from multiple threads.</source>
          <target state="translated">이 모듈의 모든 클래스는 여러 스레드에서 안전하게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="645eb36ba7e57dbbed8d6a760714020cf4ac62b5" translate="yes" xml:space="preserve">
          <source>All of the components of an XML document are subclasses of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">XML 문서의 모든 컴포넌트는 &lt;code&gt;Node&lt;/code&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="579249eb8333e1522a9306c9dc218208c5dd6079" translate="yes" xml:space="preserve">
          <source>All of the following opcodes use their arguments.</source>
          <target state="translated">다음 opcode는 모두 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d04e47f9a86b5546a2f86ac6f4ea83613fea27aa" translate="yes" xml:space="preserve">
          <source>All of the functions and methods that accept a &lt;em&gt;timeout&lt;/em&gt; parameter, such as &lt;a href=&quot;#subprocess.call&quot;&gt;&lt;code&gt;call()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;Popen.communicate()&lt;/code&gt;&lt;/a&gt; will raise &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt;&lt;code&gt;TimeoutExpired&lt;/code&gt;&lt;/a&gt; if the timeout expires before the process exits.</source>
          <target state="translated">기능 및 동의 방법의 모든 &lt;em&gt;시간 제한&lt;/em&gt; 과 같은 매개 변수를 &lt;a href=&quot;#subprocess.call&quot;&gt; &lt;code&gt;call()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;Popen.communicate()&lt;/code&gt; &lt;/a&gt; 올릴 것이다 &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt; &lt;code&gt;TimeoutExpired&lt;/code&gt; 을&lt;/a&gt; 제한 시간은 프로세스가 종료되기 전에 만료되면.</target>
        </trans-unit>
        <trans-unit id="6356cc46033a8c7b9c133294fcdbe6e0be5fcabf" translate="yes" xml:space="preserve">
          <source>All of the methods described below are executed atomically.</source>
          <target state="translated">아래에 설명 된 모든 방법은 원자 적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1381ad08272119ae9383c4ca5833de30090df2a0" translate="yes" xml:space="preserve">
          <source>All of the objects provided by this module that have &lt;code&gt;acquire()&lt;/code&gt; and &lt;code&gt;release()&lt;/code&gt; methods can be used as context managers for a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The &lt;code&gt;acquire()&lt;/code&gt; method will be called when the block is entered, and &lt;code&gt;release()&lt;/code&gt; will be called when the block is exited. Hence, the following snippet:</source>
          <target state="translated">&lt;code&gt;acquire()&lt;/code&gt; 및 &lt;code&gt;release()&lt;/code&gt; 메소드가있는 이 모듈에서 제공하는 모든 오브젝트 는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 컨텍스트 관리자로 사용될 수 있습니다 . &lt;code&gt;acquire()&lt;/code&gt; 블록이 입력 될 때 메소드가 호출되고, &lt;code&gt;release()&lt;/code&gt; 블럭이 종료 할 때 호출된다. 따라서 다음 스 니펫 :</target>
        </trans-unit>
        <trans-unit id="426266f1daf6856271c7f10aaf7a44d29269f7a4" translate="yes" xml:space="preserve">
          <source>All of the other &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt; methods are invoked by this method in the process of running the application, and thus exist primarily to allow customizing the process.</source>
          <target state="translated">다른 모든 &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 메소드는 애플리케이션 실행 프로세스에서이 메소드에 의해 호출되므로 프로세스를 사용자 정의 할 수 있도록 기본적으로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="361c6eeb57590924defca62876cd3138035cc03c" translate="yes" xml:space="preserve">
          <source>All of the patchers can be used as class decorators. When used in this way they wrap every test method on the class. The patchers recognise methods that start with &lt;code&gt;'test'&lt;/code&gt; as being test methods. This is the same way that the &lt;a href=&quot;unittest#unittest.TestLoader&quot;&gt;&lt;code&gt;unittest.TestLoader&lt;/code&gt;&lt;/a&gt; finds test methods by default.</source>
          <target state="translated">모든 패처를 클래스 데코레이터로 사용할 수 있습니다. 이런 식으로 사용하면 클래스의 모든 테스트 방법을 래핑합니다. 패치 프로그램은 &lt;code&gt;'test'&lt;/code&gt; 로 시작하는 메소드를 테스트 메소드로 인식 합니다. 이것은 &lt;a href=&quot;unittest#unittest.TestLoader&quot;&gt; &lt;code&gt;unittest.TestLoader&lt;/code&gt; &lt;/a&gt; 가 기본적으로 테스트 메소드를 찾는 것과 같은 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="bab58e75ce965a7bd1231cdeac8f8a7d861f2d0d" translate="yes" xml:space="preserve">
          <source>All of the usual dictionary methods are supported. In addition, there is a &lt;em&gt;maps&lt;/em&gt; attribute, a method for creating new subcontexts, and a property for accessing all but the first mapping:</source>
          <target state="translated">일반적인 사전 방법이 모두 지원됩니다. 또한 &lt;em&gt;maps&lt;/em&gt; 속성, 새 하위 컨텍스트를 작성하는 방법 및 첫 번째 맵핑을 제외한 모든 항목에 액세스하기위한 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb1ed368ab426895fc4010d5ccc90be43d6d02bf" translate="yes" xml:space="preserve">
          <source>All of these encodings can only encode 256 of the 1114112 code points defined in Unicode. A simple and straightforward way that can store each Unicode code point, is to store each code point as four consecutive bytes. There are two possibilities: store the bytes in big endian or in little endian order. These two encodings are called &lt;code&gt;UTF-32-BE&lt;/code&gt; and &lt;code&gt;UTF-32-LE&lt;/code&gt; respectively. Their disadvantage is that if e.g. you use &lt;code&gt;UTF-32-BE&lt;/code&gt; on a little endian machine you will always have to swap bytes on encoding and decoding. &lt;code&gt;UTF-32&lt;/code&gt; avoids this problem: bytes will always be in natural endianness. When these bytes are read by a CPU with a different endianness, then bytes have to be swapped though. To be able to detect the endianness of a &lt;code&gt;UTF-16&lt;/code&gt; or &lt;code&gt;UTF-32&lt;/code&gt; byte sequence, there&amp;rsquo;s the so called BOM (&amp;ldquo;Byte Order Mark&amp;rdquo;). This is the Unicode character &lt;code&gt;U+FEFF&lt;/code&gt;. This character can be prepended to every &lt;code&gt;UTF-16&lt;/code&gt; or &lt;code&gt;UTF-32&lt;/code&gt; byte sequence. The byte swapped version of this character (&lt;code&gt;0xFFFE&lt;/code&gt;) is an illegal character that may not appear in a Unicode text. So when the first character in an &lt;code&gt;UTF-16&lt;/code&gt; or &lt;code&gt;UTF-32&lt;/code&gt; byte sequence appears to be a &lt;code&gt;U+FFFE&lt;/code&gt; the bytes have to be swapped on decoding. Unfortunately the character &lt;code&gt;U+FEFF&lt;/code&gt; had a second purpose as a &lt;code&gt;ZERO WIDTH NO-BREAK SPACE&lt;/code&gt;: a character that has no width and doesn&amp;rsquo;t allow a word to be split. It can e.g. be used to give hints to a ligature algorithm. With Unicode 4.0 using &lt;code&gt;U+FEFF&lt;/code&gt; as a &lt;code&gt;ZERO WIDTH NO-BREAK SPACE&lt;/code&gt; has been deprecated (with &lt;code&gt;U+2060&lt;/code&gt; (&lt;code&gt;WORD JOINER&lt;/code&gt;) assuming this role). Nevertheless Unicode software still must be able to handle &lt;code&gt;U+FEFF&lt;/code&gt; in both roles: as a BOM it&amp;rsquo;s a device to determine the storage layout of the encoded bytes, and vanishes once the byte sequence has been decoded into a string; as a &lt;code&gt;ZERO WIDTH
NO-BREAK SPACE&lt;/code&gt; it&amp;rsquo;s a normal character that will be decoded like any other.</source>
          <target state="translated">이러한 모든 인코딩은 유니 코드로 정의 된 1114112 코드 포인트 중 256 개만 인코딩 할 수 있습니다. 각 유니 코드 코드 포인트를 저장할 수있는 간단하고 간단한 방법은 각 코드 포인트를 4 개의 연속 바이트로 저장하는 것입니다. 두 가지 가능성이 있습니다. 바이트를 빅 엔디안 또는 리틀 엔디안 순서로 저장하십시오. 이 두 가지 인코딩을 각각 &lt;code&gt;UTF-32-BE&lt;/code&gt; 및 &lt;code&gt;UTF-32-LE&lt;/code&gt; 라고 합니다. 작은 엔디안 머신에서 &lt;code&gt;UTF-32-BE&lt;/code&gt; 를 사용하는 경우 인코딩 및 디코딩시 항상 바이트를 교체해야 한다는 단점이 있습니다. &lt;code&gt;UTF-32&lt;/code&gt; 는이 문제를 피합니다. 바이트는 항상 자연 엔디안입니다. 엔디안이 다른 CPU에서이 바이트를 읽으면 바이트를 교체해야합니다. 의 엔디안을 감지 할 수 있도록 &lt;code&gt;UTF-16&lt;/code&gt; 또는 &lt;code&gt;UTF-32&lt;/code&gt; 바이트 시퀀스에는 BOM ( &quot;Byte Order Mark&quot;)이 있습니다. 이것은 유니 코드 문자 &lt;code&gt;U+FEFF&lt;/code&gt; 입니다. 이 문자는 모든 &lt;code&gt;UTF-16&lt;/code&gt; 또는 &lt;code&gt;UTF-32&lt;/code&gt; 바이트 시퀀스 앞에 붙일 수 있습니다 . 이 문자의 바이트 스왑 버전 ( &lt;code&gt;0xFFFE&lt;/code&gt; )은 유니 코드 텍스트에 나타나지 않을 수있는 잘못된 문자입니다. 따라서 &lt;code&gt;UTF-16&lt;/code&gt; 또는 &lt;code&gt;UTF-32&lt;/code&gt; 바이트 시퀀스 의 첫 번째 문자 가 &lt;code&gt;U+FFFE&lt;/code&gt; 인 경우 디코딩시 바이트를 교체해야합니다. 불행히도 &lt;code&gt;U+FEFF&lt;/code&gt; 캐릭터 는 &lt;code&gt;ZERO WIDTH NO-BREAK SPACE&lt;/code&gt; 로 두 번째 목적을 가졌습니다.: 너비가없고 단어를 나눌 수없는 문자입니다. 예를 들어 합자 알고리즘에 힌트를주기 위해 사용될 수 있습니다. &lt;code&gt;U+FEFF&lt;/code&gt; 를 &lt;code&gt;ZERO WIDTH NO-BREAK SPACE&lt;/code&gt; 로 사용하는 유니 코드 4.0 에서는 이 역할을 가정 하여 &lt;code&gt;U+2060&lt;/code&gt; ( &lt;code&gt;WORD JOINER&lt;/code&gt; ) 이 더 이상 사용되지 않습니다 . 그럼에도 불구하고 유니 코드 소프트웨어는 여전히 두 가지 역할 모두에서 &lt;code&gt;U+FEFF&lt;/code&gt; 를 처리 할 수 ​​있어야 합니다. BOM으로서 인코딩 된 바이트의 스토리지 레이아웃을 결정하는 장치이며 바이트 시퀀스가 ​​문자열로 디코딩되면 사라집니다. A와 &lt;code&gt;ZERO WIDTH NO-BREAK SPACE&lt;/code&gt; 가 다른 같은 복호화되는 일반 문자입니다.</target>
        </trans-unit>
        <trans-unit id="608f0188bcbb97cbbc13a474f23016a327d60ea0" translate="yes" xml:space="preserve">
          <source>All of these functions accept either only bytes or only string objects as their parameters. The result is an object of the same type, if a path or file name is returned.</source>
          <target state="translated">이러한 함수는 모두 바이트 또는 문자열 객체 만 매개 변수로 허용합니다. 경로 또는 파일 이름이 리턴되면 결과는 동일한 유형의 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="5ffe41514d0ba0c7681ed589014b164ed58ca272" translate="yes" xml:space="preserve">
          <source>All option names used in interpolation will be passed through the &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt;&lt;code&gt;optionxform()&lt;/code&gt;&lt;/a&gt; method just like any other option name reference. For example, using the default implementation of &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt;&lt;code&gt;optionxform()&lt;/code&gt;&lt;/a&gt; (which converts option names to lower case), the values &lt;code&gt;foo %(bar)s&lt;/code&gt; and &lt;code&gt;foo
%(BAR)s&lt;/code&gt; are equivalent.</source>
          <target state="translated">보간에 사용 된 모든 옵션 이름은 다른 옵션 이름 참조와 같이 &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt; &lt;code&gt;optionxform()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 전달됩니다 . 예를 들어, 옵션 이름을 소문자로 변환하는 &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt; &lt;code&gt;optionxform()&lt;/code&gt; &lt;/a&gt; 의 기본 구현을 사용하면 &lt;code&gt;foo %(bar)s&lt;/code&gt; 및 &lt;code&gt;foo %(BAR)s&lt;/code&gt; 이 같습니다.</target>
        </trans-unit>
        <trans-unit id="8653fe45c3a0598bc76268bebd81e9303afe45cd" translate="yes" xml:space="preserve">
          <source>All optional arguments and some positional arguments may be omitted at the command line. The &lt;code&gt;default&lt;/code&gt; keyword argument of &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt;, whose value defaults to &lt;code&gt;None&lt;/code&gt;, specifies what value should be used if the command-line argument is not present. For optional arguments, the &lt;code&gt;default&lt;/code&gt; value is used when the option string was not present at the command line:</source>
          <target state="translated">모든 선택적 인수와 일부 위치 인수는 명령 행에서 생략 될 수 있습니다. 값이 기본값이 &lt;code&gt;None&lt;/code&gt; 인 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;default&lt;/code&gt; 키워드 인수 는 명령 행 인수가없는 경우 사용해야하는 값을 지정합니다. 선택적 인수의 경우 옵션 문자열이 명령 행에없는 경우 &lt;code&gt;default&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce2357893bbf0135effa63850776998057d31bea" translate="yes" xml:space="preserve">
          <source>All other keys are optional, but if present they will be interpreted as described below. In all cases below where a &amp;lsquo;configuring dict&amp;rsquo; is mentioned, it will be checked for the special &lt;code&gt;'()'&lt;/code&gt; key to see if a custom instantiation is required. If so, the mechanism described in &lt;a href=&quot;#logging-config-dict-userdef&quot;&gt;User-defined objects&lt;/a&gt; below is used to create an instance; otherwise, the context is used to determine what to instantiate.</source>
          <target state="translated">다른 모든 키는 선택 사항이지만 존재하는 경우 아래에 설명 된대로 해석됩니다. 'dictive dict'가 언급 된 아래의 모든 경우 에 사용자 지정 인스턴스화가 필요한지 확인하기 위해 특수한 &lt;code&gt;'()'&lt;/code&gt; 키가 있는지 확인합니다. 그렇다면 아래의 &lt;a href=&quot;#logging-config-dict-userdef&quot;&gt;사용자 정의 개체에&lt;/a&gt; 설명 된 메커니즘 을 사용하여 인스턴스를 만듭니다. 그렇지 않으면 컨텍스트는 인스턴스화 대상을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19335cd87d8044146043baea7e04506def10ffde" translate="yes" xml:space="preserve">
          <source>All other keystrokes are treated as a command to insert the given character and move right (with line wrapping).</source>
          <target state="translated">다른 모든 키 입력은 주어진 문자를 삽입하고 줄 바꿈을 사용하여 오른쪽으로 이동하는 명령으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="aa448210156c802173864da10c49485e10eee030" translate="yes" xml:space="preserve">
          <source>All other keyword arguments are passed to &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt; without interpretation, except for &lt;em&gt;bufsize&lt;/em&gt;, &lt;em&gt;universal_newlines&lt;/em&gt;, &lt;em&gt;shell&lt;/em&gt;, &lt;em&gt;text&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt;, which should not be specified at all.</source>
          <target state="translated">&lt;em&gt;bufsize&lt;/em&gt; , &lt;em&gt;universal_newlines&lt;/em&gt; , &lt;em&gt;shell&lt;/em&gt; , &lt;em&gt;text&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; 및 &lt;em&gt;errors를&lt;/em&gt; 제외한 다른 모든 키워드 인수는 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 에 전달됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66331451f6a993bd6a4ec3db875b698eaae7b08f" translate="yes" xml:space="preserve">
          <source>All other optional or keyword arguments are passed to the underlying &lt;a href=&quot;#csv.reader&quot;&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">다른 모든 선택적 또는 키워드 인수는 기본 &lt;a href=&quot;#csv.reader&quot;&gt; &lt;code&gt;reader&lt;/code&gt; &lt;/a&gt; 인스턴스 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="00cca373364efaf0f83bf84be29776f4417aa391" translate="yes" xml:space="preserve">
          <source>All pending input is processed, and a bytes object containing the remaining compressed output is returned. &lt;em&gt;mode&lt;/em&gt; can be selected from the constants &lt;code&gt;Z_NO_FLUSH&lt;/code&gt;, &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt;, &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt;, &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt;, &lt;code&gt;Z_BLOCK&lt;/code&gt; (zlib 1.2.3.4), or &lt;code&gt;Z_FINISH&lt;/code&gt;, defaulting to &lt;code&gt;Z_FINISH&lt;/code&gt;. Except &lt;code&gt;Z_FINISH&lt;/code&gt;, all constants allow compressing further bytestrings of data, while &lt;code&gt;Z_FINISH&lt;/code&gt; finishes the compressed stream and prevents compressing any more data. After calling &lt;a href=&quot;#zlib.Compress.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; with &lt;em&gt;mode&lt;/em&gt; set to &lt;code&gt;Z_FINISH&lt;/code&gt;, the &lt;a href=&quot;#zlib.compress&quot;&gt;&lt;code&gt;compress()&lt;/code&gt;&lt;/a&gt; method cannot be called again; the only realistic action is to delete the object.</source>
          <target state="translated">보류중인 모든 입력이 처리되고 나머지 압축 출력을 포함하는 bytes 객체가 반환됩니다. &lt;em&gt;모드&lt;/em&gt; 정수로부터 선택 될 수 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; , &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_BLOCK&lt;/code&gt; (ZLIB 1.2.3.4) 또는 &lt;code&gt;Z_FINISH&lt;/code&gt; 가 , 디폴트로 &lt;code&gt;Z_FINISH&lt;/code&gt; . &lt;code&gt;Z_FINISH&lt;/code&gt; 를 제외한 모든 상수는 추가 바이트 열의 데이터를 압축 할 수있는 반면 &lt;code&gt;Z_FINISH&lt;/code&gt; 는 압축 된 스트림을 끝내고 더 이상 데이터의 압축을 방지합니다. 호출 한 후 &lt;a href=&quot;#zlib.Compress.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 와 &lt;em&gt;모드&lt;/em&gt; 로 설정 &lt;code&gt;Z_FINISH&lt;/code&gt; 를 상기 &lt;a href=&quot;#zlib.compress&quot;&gt; &lt;code&gt;compress()&lt;/code&gt; &lt;/a&gt;메소드를 다시 호출 할 수 없습니다. 유일한 현실적인 조치는 객체를 삭제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="845f9f346c71bf5f52a9188ace35c5ecaa3ed3df" translate="yes" xml:space="preserve">
          <source>All pending input is processed, and a bytes object containing the remaining uncompressed output is returned. After calling &lt;a href=&quot;#zlib.Decompress.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#zlib.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; method cannot be called again; the only realistic action is to delete the object.</source>
          <target state="translated">보류중인 모든 입력이 처리되고 나머지 압축되지 않은 출력을 포함하는 bytes 객체가 반환됩니다. 호출 한 후 &lt;a href=&quot;#zlib.Decompress.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 상기 &lt;a href=&quot;#zlib.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 메소드를 다시 호출 할 수 없다; 유일한 현실적인 조치는 객체를 삭제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc9ede07789c80374474bed5143b787444e15389" translate="yes" xml:space="preserve">
          <source>All platforms support sockets as &lt;em&gt;out&lt;/em&gt; file descriptor, and some platforms allow other types (e.g. regular file, pipe) as well.</source>
          <target state="translated">모든 플랫폼으로 소켓을 지원 &lt;em&gt;밖으로&lt;/em&gt; 파일 설명, 일부 플랫폼은 다른 유형 (예 : 일반 파일, 파이프)뿐만 아니라 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a103db9094a7f0996094f573e4e6dea84bed483" translate="yes" xml:space="preserve">
          <source>All recipient addresses refused. The errors for each recipient are accessible through the attribute &lt;code&gt;recipients&lt;/code&gt;, which is a dictionary of exactly the same sort as &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;SMTP.sendmail()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">모든 수신자 주소가 거부되었습니다. &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;SMTP.sendmail()&lt;/code&gt; &lt;/a&gt; 반환 하는 것과 정확히 동일한 사전 인 속성 인 &lt;code&gt;recipients&lt;/code&gt; 통해 각 수신자의 오류에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5e2d016729108cbe2a6252b7e9f9f25b138be7a" translate="yes" xml:space="preserve">
          <source>All recipients were refused. Nobody got the mail. The &lt;code&gt;recipients&lt;/code&gt; attribute of the exception object is a dictionary with information about the refused recipients (like the one returned when at least one recipient was accepted).</source>
          <target state="translated">모든 수령인이 거부되었습니다. 아무도 메일을받지 못했습니다. 예외 오브젝트 의 &lt;code&gt;recipients&lt;/code&gt; 속성은 거부 된 수신자에 대한 정보가있는 사전입니다 (예 : 하나 이상의 수신자가 승인되었을 때 리턴 된 수신자).</target>
        </trans-unit>
        <trans-unit id="ed7add52656f73c9f9ee77cb2062c4141e037209" translate="yes" xml:space="preserve">
          <source>All registry functions in this module return one of these objects.</source>
          <target state="translated">이 모듈의 모든 레지스트리 함수는 이러한 개체 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2fe55d4566c1ed0919fec63b9086185e8f09e18" translate="yes" xml:space="preserve">
          <source>All registry functions in this module which accept a handle object also accept an integer, however, use of the handle object is encouraged.</source>
          <target state="translated">핸들 오브젝트를 승인하는이 모듈의 모든 레지스트리 함수도 정수를 허용하지만 핸들 오브젝트의 사용을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="10ada46f1636db2c68259c55e5dbc2108cc9bb8a" translate="yes" xml:space="preserve">
          <source>All sections include &lt;code&gt;DEFAULTSECT&lt;/code&gt; values as well which means that &lt;code&gt;.clear()&lt;/code&gt; on a section may not leave the section visibly empty. This is because default values cannot be deleted from the section (because technically they are not there). If they are overridden in the section, deleting causes the default value to be visible again. Trying to delete a default value causes a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 섹션에는 &lt;code&gt;DEFAULTSECT&lt;/code&gt; 값도 포함 되어 있습니다. 즉 , 섹션의 &lt;code&gt;.clear()&lt;/code&gt; 는 섹션을 시각적으로 비워 둘 수 없습니다. 기술적으로는 기본값이 없기 때문에 섹션에서 기본값을 삭제할 수 없기 때문입니다. 섹션에서 재정의 된 경우 삭제하면 기본값이 다시 표시됩니다. 기본값을 삭제하려고하면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 가&lt;/a&gt; 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="98e89195defbf174865e4ed3cfadb43c73afc721" translate="yes" xml:space="preserve">
          <source>All start methods</source>
          <target state="translated">모든 시작 방법</target>
        </trans-unit>
        <trans-unit id="75d16b8bb98cb55dff06e1fc0c1ed62ef7d52a39" translate="yes" xml:space="preserve">
          <source>All stream readers must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</source>
          <target state="translated">모든 스트림 리더는이 생성자 인터페이스를 제공해야합니다. 추가 키워드 인수를 자유롭게 추가 할 수 있지만 여기에 정의 된 키워드 인수 만 Python 코덱 레지스트리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="26bf04c11ae57a8dd9464a075f980fb924cc9927" translate="yes" xml:space="preserve">
          <source>All stream writers must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</source>
          <target state="translated">모든 스트림 작성자는이 생성자 인터페이스를 제공해야합니다. 추가 키워드 인수를 자유롭게 추가 할 수 있지만 여기에 정의 된 키워드 인수 만 Python 코덱 레지스트리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="511adfa816e0d1230d548ef9bee4b8cae3ba51aa" translate="yes" xml:space="preserve">
          <source>All streams are careful about the type of data you give to them. For example giving a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; object to the &lt;code&gt;write()&lt;/code&gt; method of a binary stream will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. So will giving a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object to the &lt;code&gt;write()&lt;/code&gt; method of a text stream.</source>
          <target state="translated">모든 스트림은 데이터 유형에주의를 기울입니다. 예를 들어 이진 스트림 의 &lt;code&gt;write()&lt;/code&gt; 메서드에 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체를 제공 하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다. 따라서 텍스트 스트림 의 &lt;code&gt;write()&lt;/code&gt; 메소드에 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="8cfe73a6df86f8c591b70da4f2a97d04f73d2842" translate="yes" xml:space="preserve">
          <source>All subclasses of &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; inherit a predefined &lt;code&gt;do_help()&lt;/code&gt;. This method, called with an argument &lt;code&gt;'bar'&lt;/code&gt;, invokes the corresponding method &lt;code&gt;help_bar()&lt;/code&gt;, and if that is not present, prints the docstring of &lt;code&gt;do_bar()&lt;/code&gt;, if available. With no argument, &lt;code&gt;do_help()&lt;/code&gt; lists all available help topics (that is, all commands with corresponding &lt;code&gt;help_*()&lt;/code&gt; methods or commands that have docstrings), and also lists any undocumented commands.</source>
          <target state="translated">&lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; 의&lt;/a&gt; 모든 서브 클래스는 미리 정의 된 &lt;code&gt;do_help()&lt;/code&gt; 상속합니다 . 인수 &lt;code&gt;'bar'&lt;/code&gt; 와 함께 호출 된이 메소드 는 해당 메소드 &lt;code&gt;help_bar()&lt;/code&gt; 호출하고 , 존재하지 않는 경우, 사용 가능한 경우 &lt;code&gt;do_bar()&lt;/code&gt; 의 docstring을 인쇄합니다 . 인수없이 &lt;code&gt;do_help()&lt;/code&gt; 는 사용 가능한 모든 도움말 항목 (즉, 해당 &lt;code&gt;help_*()&lt;/code&gt; 메소드 가있는 모든 명령 또는 문서 문자열이있는 명령)을 나열하고 문서화되지 않은 명령도 나열합니다.</target>
        </trans-unit>
        <trans-unit id="16bfa0e96351e7a39a097e3fa26ad685c6d79d8d" translate="yes" xml:space="preserve">
          <source>All tasks waiting for event to be set will be immediately awakened.</source>
          <target state="translated">이벤트가 설정되기를 기다리는 모든 작업이 즉시 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0d4a1283ee19c5afe6ce70d63cdcdf8e6081cc" translate="yes" xml:space="preserve">
          <source>All test modules must be importable from the top level of the project. If the start directory is not the top level directory then the top level directory must be specified separately.</source>
          <target state="translated">모든 테스트 모듈은 프로젝트의 최상위 레벨에서 가져올 수 있어야합니다. 시작 디렉토리가 최상위 레벨 디렉토리가 아닌 경우 최상위 레벨 디렉토리를 별도로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="95e86b0a592b2672e5e54dba5071e87a49d334f8" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;'%'&lt;/code&gt; interpolations are expanded in the return values, unless the &lt;em&gt;raw&lt;/em&gt; argument is true. Values for interpolation keys are looked up in the same manner as the option.</source>
          <target state="translated">&lt;em&gt;원시&lt;/em&gt; 인수가 true가 아닌 한 모든 &lt;code&gt;'%'&lt;/code&gt; 보간은 반환 값에서 확장됩니다 . 보간 키의 값은 옵션과 같은 방식으로 조회됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="68ec4ea8caa603e129e1cdd2dda1c8e8f88e770a" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;ttk&lt;/code&gt; Widgets accepts the following options:</source>
          <target state="translated">모든 &lt;code&gt;ttk&lt;/code&gt; 위젯은 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a0aa67ee5d395c9a58857bc43029eb764f978551" translate="yes" xml:space="preserve">
          <source>All the assert methods accept a &lt;em&gt;msg&lt;/em&gt; argument that, if specified, is used as the error message on failure (see also &lt;a href=&quot;#unittest.TestCase.longMessage&quot;&gt;&lt;code&gt;longMessage&lt;/code&gt;&lt;/a&gt;). Note that the &lt;em&gt;msg&lt;/em&gt; keyword argument can be passed to &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.TestCase.assertRaisesRegex&quot;&gt;&lt;code&gt;assertRaisesRegex()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt;&lt;code&gt;assertWarns()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.TestCase.assertWarnsRegex&quot;&gt;&lt;code&gt;assertWarnsRegex()&lt;/code&gt;&lt;/a&gt; only when they are used as a context manager.</source>
          <target state="translated">모든 assert 메소드는 지정된 경우 실패시 오류 메시지로 사용되는 &lt;em&gt;msg&lt;/em&gt; 인수를 승인합니다 ( &lt;a href=&quot;#unittest.TestCase.longMessage&quot;&gt; &lt;code&gt;longMessage&lt;/code&gt; &lt;/a&gt; 참조 ). 합니다 &lt;em&gt;MSG의&lt;/em&gt; 키워드 인수에 전달 될 수 &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#unittest.TestCase.assertRaisesRegex&quot;&gt; &lt;code&gt;assertRaisesRegex()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt; &lt;code&gt;assertWarns()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#unittest.TestCase.assertWarnsRegex&quot;&gt; &lt;code&gt;assertWarnsRegex()&lt;/code&gt; &lt;/a&gt; 그들은 문맥 관리자로 사용하는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba0ad57eff10b2932e3d0da3c26b31a3d89093f7" translate="yes" xml:space="preserve">
          <source>All the patchers have &lt;code&gt;start()&lt;/code&gt; and &lt;code&gt;stop()&lt;/code&gt; methods. These make it simpler to do patching in &lt;code&gt;setUp&lt;/code&gt; methods or where you want to do multiple patches without nesting decorators or with statements.</source>
          <target state="translated">모든 패처에는 &lt;code&gt;start()&lt;/code&gt; 및 &lt;code&gt;stop()&lt;/code&gt; 메소드가 있습니다. 이를 통해 &lt;code&gt;setUp&lt;/code&gt; 메소드 에서 패치를 수행하는 것이 더 간단 해 지거나 데코레이터를 중첩하거나 명령문을 사용하지 않고 여러 패치를 수행하려는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b3a6c16b642ad7026440e7678571fdc94dcd20" translate="yes" xml:space="preserve">
          <source>All the signal numbers are defined symbolically. For example, the hangup signal is defined as &lt;code&gt;signal.SIGHUP&lt;/code&gt;; the variable names are identical to the names used in C programs, as found in &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;. The Unix man page for &amp;lsquo;&lt;code&gt;signal()&lt;/code&gt;&amp;rsquo; lists the existing signals (on some systems this is &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/signal(2)&quot;&gt;signal(2)&lt;/a&gt;&lt;/em&gt;, on others the list is in &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/signal(7)&quot;&gt;signal(7)&lt;/a&gt;&lt;/em&gt;). Note that not all systems define the same set of signal names; only those names defined by the system are defined by this module.</source>
          <target state="translated">모든 신호 번호는 상징적으로 정의됩니다. 예를 들어, 행업 신호는 &lt;code&gt;signal.SIGHUP&lt;/code&gt; ; 변수 이름은 &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; 에있는 C 프로그램에서 사용 된 이름과 동일합니다 . ' &lt;code&gt;signal()&lt;/code&gt; ' 의 유닉스 매뉴얼 페이지 는 기존 신호를 나열합니다 (일부 시스템에서는 이것이 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/signal(2)&quot;&gt;signal (2)&lt;/a&gt;&lt;/em&gt; 이고 다른 시스템에서는 목록이 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/signal(7)&quot;&gt;signal (7)에 있습니다&lt;/a&gt;&lt;/em&gt; ). 모든 시스템이 동일한 신호 이름 세트를 정의하는 것은 아닙니다. 시스템에서 정의한 이름 만이 모듈에서 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a718f5f334bffff82ac9ca18a26df3475e054a96" translate="yes" xml:space="preserve">
          <source>All the user-callable functions and constructors take additional arguments which allow direct control over the location and name of temporary files and directories. Files names used by this module include a string of random characters which allows those files to be securely created in shared temporary directories. To maintain backward compatibility, the argument order is somewhat odd; it is recommended to use keyword arguments for clarity.</source>
          <target state="translated">사용자가 호출 할 수있는 모든 함수와 생성자는 추가 인수를 사용하여 임시 파일 및 디렉토리의 위치와 이름을 직접 제어 할 수 있습니다. 이 모듈에서 사용하는 파일 이름에는 임의의 문자열이 포함되어있어 공유 임시 디렉토리에서 해당 파일을 안전하게 작성할 수 있습니다. 이전 버전과의 호환성을 유지하기 위해 인수 순서는 다소 이상합니다. 명확성을 위해 키워드 인수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="27ab5e9ece9f6fec3cae084274e655c615da7669" translate="yes" xml:space="preserve">
          <source>All the variables below are simply symbolic indexes into the 10-tuple returned by &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os#os.fstat&quot;&gt;&lt;code&gt;os.fstat()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.lstat&quot;&gt;&lt;code&gt;os.lstat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래의 모든 변수는 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os#os.fstat&quot;&gt; &lt;code&gt;os.fstat()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.lstat&quot;&gt; &lt;code&gt;os.lstat()&lt;/code&gt; &lt;/a&gt; 반환 한 10- 튜플에 대한 단순한 기호 인덱스 입니다.</target>
        </trans-unit>
        <trans-unit id="8a1874be964dba6caf7536a5f6cdb4d12bf2f501" translate="yes" xml:space="preserve">
          <source>All these classes can be instantiated by calling them with at least one argument, the pathname of the shared library. If you have an existing handle to an already loaded shared library, it can be passed as the &lt;code&gt;handle&lt;/code&gt; named parameter, otherwise the underlying platforms &lt;code&gt;dlopen&lt;/code&gt; or &lt;code&gt;LoadLibrary&lt;/code&gt; function is used to load the library into the process, and to get a handle to it.</source>
          <target state="translated">이러한 모든 클래스는 공유 라이브러리의 경로 이름 인 하나 이상의 인수로 호출하여 인스턴스화 할 수 있습니다. 이미로드 된 공유 라이브러리에 대한 기존 핸들이있는 경우 &lt;code&gt;handle&lt;/code&gt; 이라는 매개 변수 로 전달 될 수 있습니다 . 그렇지 않으면 기본 플랫폼 &lt;code&gt;dlopen&lt;/code&gt; 또는 &lt;code&gt;LoadLibrary&lt;/code&gt; 함수를 사용하여 라이브러리를 프로세스에로드하고 핸들을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="417f37663be75dee9f473867fc0f32047be90a11" translate="yes" xml:space="preserve">
          <source>All these types can be created by calling them with an optional initializer of the correct type and value:</source>
          <target state="translated">이러한 모든 유형은 올바른 유형 및 값의 선택적 초기화 프로그램으로 호출하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="155ee124577e1fe137df7c33d4f6d23d523b7db8" translate="yes" xml:space="preserve">
          <source>All transports implement the following methods:</source>
          <target state="translated">모든 전송은 다음 방법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0861f5cc7168426f537bde444cc103b430c6b13c" translate="yes" xml:space="preserve">
          <source>All wrappers around MSI functions raise &lt;code&gt;MSIError&lt;/code&gt;; the string inside the exception will contain more detail.</source>
          <target state="translated">MSI 함수 주위의 모든 래퍼는 &lt;code&gt;MSIError&lt;/code&gt; 를 발생시킵니다 . 예외 안의 문자열은 더 자세한 내용을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="edffc8bbc8f24bd588ae17bcfd535bebc57f13ec" translate="yes" xml:space="preserve">
          <source>Allow an application to set the locale for errors and warnings.</source>
          <target state="translated">응용 프로그램이 오류 및 경고에 대한 로케일을 설정하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="603dd6037e099395a31f0e59c9ba1913159c4a7e" translate="yes" xml:space="preserve">
          <source>Allow encoding and decoding of surrogate codes. These codecs normally treat the presence of surrogates as an error.</source>
          <target state="translated">대리 코드의 인코딩 및 디코딩을 허용합니다. 이러한 코덱은 일반적으로 서로 게이트의 존재를 오류로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="1e19ac51136d0637f9af6d20c7258158d6721dc5" translate="yes" xml:space="preserve">
          <source>Allow simple extension commands notified by server in &lt;code&gt;CAPABILITY&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;CAPABILITY&lt;/code&gt; 응답 으로 서버에 통지 된 간단한 확장 명령을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="ef317f8483480a64e1b0dccb14f7bb6883cce1dc" translate="yes" xml:space="preserve">
          <source>Allow use of default values for colors on terminals supporting this feature. Use this to support transparency in your application. The default color is assigned to the color number &lt;code&gt;-1&lt;/code&gt;. After calling this function, &lt;code&gt;init_pair(x,
curses.COLOR_RED, -1)&lt;/code&gt; initializes, for instance, color pair &lt;em&gt;x&lt;/em&gt; to a red foreground color on the default background.</source>
          <target state="translated">이 기능을 지원하는 터미널에서 색상의 기본값을 사용하도록 허용하십시오. 이를 사용하여 응용 프로그램의 투명성을 지원하십시오. 기본 색상은 색상 번호 &lt;code&gt;-1&lt;/code&gt; 에 할당됩니다 . 이 함수를 호출 한 후 &lt;code&gt;init_pair(x, curses.COLOR_RED, -1)&lt;/code&gt; 은 기본 배경 에서 색상 쌍 &lt;em&gt;x&lt;/em&gt; 를 빨간색 전경색으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9af2608dce4ccd3a4d7fe7ccd5d8a999659ec6be" translate="yes" xml:space="preserve">
          <source>Allow wildcard when it is the leftmost and the only character in that segment. Partial wildcards like &lt;code&gt;www*.example.com&lt;/code&gt; are no longer supported.</source>
          <target state="translated">와일드 카드가 해당 세그먼트에서 가장 왼쪽에있는 유일한 문자이면 와일드 카드를 허용하십시오. &lt;code&gt;www*.example.com&lt;/code&gt; 과 같은 부분 와일드 카드 는 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d545cb48e8fe2e090c8d20ba1902d68904e84436" translate="yes" xml:space="preserve">
          <source>Allowed members and attributes of enumerations</source>
          <target state="translated">허용 된 멤버 및 열거 속성</target>
        </trans-unit>
        <trans-unit id="27759cb686cd5bf827a6e5a82d77411f516dc61c" translate="yes" xml:space="preserve">
          <source>Allowing alternative option prefixes like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 와 같은 대체 옵션 접두사를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a6ebd07370440c663e4f0e55185f972d0240507b" translate="yes" xml:space="preserve">
          <source>Allowing applications to identify and clear their own uncollectable types when they appear in &lt;a href=&quot;#gc.garbage&quot;&gt;&lt;code&gt;garbage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램이 &lt;a href=&quot;#gc.garbage&quot;&gt; &lt;code&gt;garbage&lt;/code&gt; &lt;/a&gt; 나타날 때 수집 할 수없는 유형을 식별하고 지울 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="1698c3d6368b675b56ce12b0b386c7be180d6706" translate="yes" xml:space="preserve">
          <source>Allowing non-resource names to be returned is to allow for situations where how a package and its resources are stored are known a priori and the non-resource names would be useful. For instance, returning subdirectory names is allowed so that when it is known that the package and resources are stored on the file system then those subdirectory names can be used directly.</source>
          <target state="translated">비자 원 이름이 리턴되도록하는 것은 패키지 및 해당 자원이 저장되는 방법을 우선적으로 알고 비자 원 이름이 유용한 상황을 허용하는 것입니다. 예를 들어, 패키지 및 자원이 파일 시스템에 저장되어있는 것으로 알려진 경우 해당 서브 디렉토리 이름을 직접 사용할 수 있도록 서브 디렉토리 이름 리턴이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b68e07d7d7b9f4e84654d4589ca6f207be1705b6" translate="yes" xml:space="preserve">
          <source>Allowing subclassing of enums that define members would lead to a violation of some important invariants of types and instances. On the other hand, it makes sense to allow sharing some common behavior between a group of enumerations. (See &lt;a href=&quot;#orderedenum&quot;&gt;OrderedEnum&lt;/a&gt; for an example.)</source>
          <target state="translated">멤버를 정의하는 열거 형의 서브 클래 싱을 허용하면 유형 및 인스턴스의 중요한 불변 변수를 위반하게됩니다. 반면에 열거 그룹간에 공통적 인 동작을 공유하는 것이 좋습니다. ( 예는 &lt;a href=&quot;#orderedenum&quot;&gt;OrderedEnum&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="5168b39c43df53db082b41562ffb47b2581e0dfa" translate="yes" xml:space="preserve">
          <source>Allows customizing how exceptions are handled in the event loop.</source>
          <target state="translated">이벤트 루프에서 예외를 처리하는 방법을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3af65b7b8a24fd1ab3b136e24dca1bdc29a79fcb" translate="yes" xml:space="preserve">
          <source>Allows enabling or disabling coroutine origin tracking. When enabled, the &lt;code&gt;cr_origin&lt;/code&gt; attribute on coroutine objects will contain a tuple of (filename, line number, function name) tuples describing the traceback where the coroutine object was created, with the most recent call first. When disabled, &lt;code&gt;cr_origin&lt;/code&gt; will be None.</source>
          <target state="translated">코 루틴 원산지 추적을 활성화 또는 비활성화 할 수 있습니다. 활성화하면 코 루틴 객체 의 &lt;code&gt;cr_origin&lt;/code&gt; 속성에 코 루틴 객체가 생성 된 역 추적을 설명하는 (파일 이름, 줄 번호, 함수 이름) 튜플이 포함됩니다. 비활성화하면 &lt;code&gt;cr_origin&lt;/code&gt; 은 None이됩니다.</target>
        </trans-unit>
        <trans-unit id="738636a3be8341b9cebe3dd58e0680a5032b2eea" translate="yes" xml:space="preserve">
          <source>Allows specifying that the module named &lt;em&gt;oldname&lt;/em&gt; is in fact the package named &lt;em&gt;newname&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;oldname&lt;/em&gt; 이라는 모듈 이 실제로 &lt;em&gt;newname&lt;/em&gt; 이라는 패키지 임을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e8494b281173c0688479a4b6438c4a9f916278d" translate="yes" xml:space="preserve">
          <source>Allows you to compare data with unknown or inconsistent encoding. All inputs except &lt;em&gt;n&lt;/em&gt; must be bytes objects, not str. Works by losslessly converting all inputs (except &lt;em&gt;n&lt;/em&gt;) to str, and calling &lt;code&gt;dfunc(a, b,
fromfile, tofile, fromfiledate, tofiledate, n, lineterm)&lt;/code&gt;. The output of &lt;em&gt;dfunc&lt;/em&gt; is then converted back to bytes, so the delta lines that you receive have the same unknown/inconsistent encodings as &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">알 수 없거나 일관성이없는 인코딩과 데이터를 비교할 수 있습니다. &lt;em&gt;n을&lt;/em&gt; 제외한 모든 입력 은 str이 아닌 bytes 객체 여야합니다. 모든 입력 ( &lt;em&gt;n&lt;/em&gt; 제외 )을 str 로 손실없이 변환하고 &lt;code&gt;dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm)&lt;/code&gt; . 그런 다음 &lt;em&gt;dfunc&lt;/em&gt; 의 출력은 바이트로 다시 변환되므로 수신하는 델타 라인은 &lt;em&gt;a&lt;/em&gt; 및 &lt;em&gt;b&lt;/em&gt; 와 동일한 알 수없는 / 일관되지 않은 인코딩을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="18dea076b2e37e15d1b1e3961b5af0025bae1395" translate="yes" xml:space="preserve">
          <source>Almost all asyncio objects are not thread safe, which is typically not a problem unless there is code that works with them from outside of a Task or a callback. If there&amp;rsquo;s a need for such code to call a low-level asyncio API, the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon_threadsafe&quot;&gt;&lt;code&gt;loop.call_soon_threadsafe()&lt;/code&gt;&lt;/a&gt; method should be used, e.g.:</source>
          <target state="translated">거의 모든 asyncio 객체는 스레드로부터 안전하지 않으므로 Task 외부 나 콜백 외부에서 작동하는 코드가 없으면 일반적으로 문제가되지 않습니다. 이러한 코드가 저수준 asyncio API를 호출해야하는 경우 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon_threadsafe&quot;&gt; &lt;code&gt;loop.call_soon_threadsafe()&lt;/code&gt; &lt;/a&gt; 메서드를 사용해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8ef26a78c0878f712db4f13e47f33bc1d3fc032c" translate="yes" xml:space="preserve">
          <source>Almost all module functions depend on the basic function &lt;a href=&quot;#random.random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt;, which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.</source>
          <target state="translated">거의 모든 모듈 함수는 기본 함수 &lt;a href=&quot;#random.random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; 에 의존합니다.이 함수 는 semi-open 범위 [0.0, 1.0)에서 임의의 부동 소수점을 균일하게 생성합니다. 파이썬은 Mersenne Twister를 핵심 생성기로 사용합니다. 53 비트 정밀 플로트를 생성하며주기는 2 ** 19937-1입니다. C의 기본 구현은 빠르고 안전합니다. Mersenne Twister는 가장 광범위하게 테스트 된 난수 생성기 중 하나입니다. 그러나 완전히 결정적이므로 모든 목적에 적합하지는 않으며 암호화 목적에 완전히 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="748de8dc879eb6680f9d63547210f95925fe14ea" translate="yes" xml:space="preserve">
          <source>Along with the &lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt;&lt;code&gt;QueueHandler&lt;/code&gt;&lt;/a&gt; class, &lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt;&lt;code&gt;QueueListener&lt;/code&gt;&lt;/a&gt; can be used to let handlers do their work on a separate thread from the one which does the logging. This is important in Web applications and also other service applications where threads servicing clients need to respond as quickly as possible, while any potentially slow operations (such as sending an email via &lt;a href=&quot;#logging.handlers.SMTPHandler&quot;&gt;&lt;code&gt;SMTPHandler&lt;/code&gt;&lt;/a&gt;) are done on a separate thread.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt; &lt;code&gt;QueueHandler&lt;/code&gt; &lt;/a&gt; 클래스 와 함께 &lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt; &lt;code&gt;QueueListener&lt;/code&gt; &lt;/a&gt; 를 사용하면 핸들러가 로깅을 수행하는 스레드와 별도의 스레드에서 작업을 수행 할 수 있습니다. 이는 웹 서비스 및 클라이언트를 서비스하는 스레드가 가능한 한 빨리 응답해야하는 다른 서비스 응용 프로그램에서 중요하지만, 잠재적으로 느린 작업 (예 : &lt;a href=&quot;#logging.handlers.SMTPHandler&quot;&gt; &lt;code&gt;SMTPHandler&lt;/code&gt; &lt;/a&gt; 를 통해 전자 메일 보내기 )은 별도의 스레드에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e133f1847d6ba17ada9412544089973439552b65" translate="yes" xml:space="preserve">
          <source>Along with the &lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt;&lt;code&gt;QueueListener&lt;/code&gt;&lt;/a&gt; class, &lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt;&lt;code&gt;QueueHandler&lt;/code&gt;&lt;/a&gt; can be used to let handlers do their work on a separate thread from the one which does the logging. This is important in Web applications and also other service applications where threads servicing clients need to respond as quickly as possible, while any potentially slow operations (such as sending an email via &lt;a href=&quot;#logging.handlers.SMTPHandler&quot;&gt;&lt;code&gt;SMTPHandler&lt;/code&gt;&lt;/a&gt;) are done on a separate thread.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt; &lt;code&gt;QueueListener&lt;/code&gt; &lt;/a&gt; 클래스 와 함께 &lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt; &lt;code&gt;QueueHandler&lt;/code&gt; &lt;/a&gt; 를 사용하면 핸들러가 로깅을 수행하는 스레드와 별도의 스레드에서 작업을 수행 할 수 있습니다. 이는 웹 서비스 및 클라이언트를 서비스하는 스레드가 가능한 한 빨리 응답해야하는 다른 서비스 응용 프로그램에서 중요하지만, 잠재적으로 느린 작업 (예 : &lt;a href=&quot;#logging.handlers.SMTPHandler&quot;&gt; &lt;code&gt;SMTPHandler&lt;/code&gt; &lt;/a&gt; 를 통해 전자 메일 보내기 )은 별도의 스레드에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c13a6fce77ea6aef73a68321fa87a9bf9f996061" translate="yes" xml:space="preserve">
          <source>Already-issued keys are invalidated by this operation and should not be subsequently used.</source>
          <target state="translated">이미 발행 된 키는이 조작으로 무효화되며 이후에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ddaad8ef2dfb964d8f8351c0c13727dace14f681" translate="yes" xml:space="preserve">
          <source>Also add a &lt;em&gt;MIME-Version&lt;/em&gt; header if one is not present (see also &lt;a href=&quot;email.message#email.message.MIMEPart&quot;&gt;&lt;code&gt;MIMEPart&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;MIME-Version&lt;/em&gt; 헤더가 없으면 추가 하십시오 ( &lt;a href=&quot;email.message#email.message.MIMEPart&quot;&gt; &lt;code&gt;MIMEPart&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="04aa310dbe2a0c208ac29daad11f4c7a1536bccb" translate="yes" xml:space="preserve">
          <source>Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of the expression &lt;code&gt;(1 + x) ** n&lt;/code&gt;.</source>
          <target state="translated">이항 계수라고도합니다. 식 &lt;code&gt;(1 + x) ** n&lt;/code&gt; 의 다항식 확장에서 k 번째 항의 계수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4da92deb98831a7db28244e57fd52231a3f52e3a" translate="yes" xml:space="preserve">
          <source>Also if &lt;em&gt;chunksize&lt;/em&gt; is &lt;code&gt;1&lt;/code&gt; then the &lt;code&gt;next()&lt;/code&gt; method of the iterator returned by the &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt;&lt;code&gt;imap()&lt;/code&gt;&lt;/a&gt; method has an optional &lt;em&gt;timeout&lt;/em&gt; parameter: &lt;code&gt;next(timeout)&lt;/code&gt; will raise &lt;a href=&quot;#multiprocessing.TimeoutError&quot;&gt;&lt;code&gt;multiprocessing.TimeoutError&lt;/code&gt;&lt;/a&gt; if the result cannot be returned within &lt;em&gt;timeout&lt;/em&gt; seconds.</source>
          <target state="translated">또한 &lt;em&gt;chunksize&lt;/em&gt; 가 &lt;code&gt;1&lt;/code&gt; 인 경우 &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt; &lt;code&gt;imap()&lt;/code&gt; &lt;/a&gt; 메서드가 반환 한 반복자 의 &lt;code&gt;next()&lt;/code&gt; 메서드 에는 선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수가 있습니다. &lt;code&gt;next(timeout)&lt;/code&gt; 은 &lt;em&gt;timeout&lt;/em&gt; 초 내에 결과를 반환 할 수없는 경우 &lt;a href=&quot;#multiprocessing.TimeoutError&quot;&gt; &lt;code&gt;multiprocessing.TimeoutError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2b37f91f9986d19a74d71c28f0eb3cf516b74d0" translate="yes" xml:space="preserve">
          <source>Also note that cookies saved while Mozilla is running will get clobbered by Mozilla.</source>
          <target state="translated">또한 Mozilla가 실행되는 동안 저장된 쿠키는 Mozilla에 의해 방해를받습니다.</target>
        </trans-unit>
        <trans-unit id="05381aa96697605cddfb622e6c2165e3e0c1cfd5" translate="yes" xml:space="preserve">
          <source>Also note that if &lt;code&gt;sys.breakpointhook()&lt;/code&gt; is overridden programmatically, &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-4&quot;&gt;&lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; consulted.</source>
          <target state="translated">또한 경우에주의 &lt;code&gt;sys.breakpointhook()&lt;/code&gt; 프로그램 오버라이드 (override), &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-4&quot;&gt; &lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt; 가&lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 상담.</target>
        </trans-unit>
        <trans-unit id="332b93cd68d70da8be748419e7b6e1e7630df4b0" translate="yes" xml:space="preserve">
          <source>Also note that, aside from the zero argument form, &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods.</source>
          <target state="translated">또한 제로 인수 형식 외에도 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 는 내부 메소드 사용으로 제한되지 않습니다. 두 개의 인수 형식은 인수를 정확하게 지정하고 적절한 참조를합니다. 제로 인수 형식은 컴파일러가 정의 된 클래스를 올바르게 검색하고 일반 메소드의 현재 인스턴스에 액세스하기 위해 필요한 세부 사항을 채우므로 클래스 정의 내에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="30f25e2caeef7e4eba52c7c66bd42d7b1a2c33c9" translate="yes" xml:space="preserve">
          <source>Also referred to as integer division. The resultant value is a whole integer, though the result&amp;rsquo;s type is not necessarily int. The result is always rounded towards minus infinity: &lt;code&gt;1//2&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;(-1)//2&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;1//(-2)&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, and &lt;code&gt;(-1)//(-2)&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">정수 나누기라고도합니다. 결과 값이 정수가 아니더라도 결과 값은 정수입니다. 결과는 항상 빼기 무한대로 반올림됩니다. &lt;code&gt;1//2&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;(-1)//2&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;1//(-2)&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;(-1)//(-2)&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="969aafb04012095b4d6476bad1048d3bb9a0ed99" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;functions#func-bytearray&quot;&gt;bytearray&lt;/a&gt; built-in.</source>
          <target state="translated">&lt;a href=&quot;functions#func-bytearray&quot;&gt;bytearray&lt;/a&gt; 내장 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17dcbded66c86a6599675ce2d2b8b6553fefda44" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;functions#func-bytes&quot;&gt;bytes&lt;/a&gt; built-in.</source>
          <target state="translated">내장 &lt;a href=&quot;functions#func-bytes&quot;&gt;바이트&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eea734960db56a51ce22d3968f6f1a077a73c20" translate="yes" xml:space="preserve">
          <source>Also test examples reachable from dict &lt;code&gt;m.__test__&lt;/code&gt;, if it exists and is not &lt;code&gt;None&lt;/code&gt;. &lt;code&gt;m.__test__&lt;/code&gt; maps names (strings) to functions, classes and strings; function and class docstrings are searched for examples; strings are searched directly, as if they were docstrings.</source>
          <target state="translated">또한 dict &lt;code&gt;m.__test__&lt;/code&gt; 에서 도달 할 수 있고 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 테스트 예제에 도달 할 수 있습니다 . &lt;code&gt;m.__test__&lt;/code&gt; 는 이름 (문자열)을 함수, 클래스 및 문자열에 매핑합니다. 함수 및 클래스 docstrings에서 예제를 검색합니다. 문자열은 마치 docstring 인 것처럼 직접 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1297c5eac193ee99dea660520c3d5d38eabae727" translate="yes" xml:space="preserve">
          <source>Also unlike other operations, quantize never signals Underflow, even if the result is subnormal and inexact.</source>
          <target state="translated">또한 다른 연산과 달리 양자화는 결과가 비정상적이고 부정확하더라도 언더 플로에 신호를 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d52e998b134acc66f821dc9e280d60f9ef6cf6e" translate="yes" xml:space="preserve">
          <source>Also, note that if the callback function is called in a thread created outside of Python&amp;rsquo;s control (e.g. by the foreign code that calls the callback), ctypes creates a new dummy Python thread on every invocation. This behavior is correct for most purposes, but it means that values stored with &lt;a href=&quot;threading#threading.local&quot;&gt;&lt;code&gt;threading.local&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;not&lt;/em&gt; survive across different callbacks, even when those calls are made from the same C thread.</source>
          <target state="translated">또한 콜백 함수가 Python 제어 외부에서 생성 된 스레드에서 호출되면 (예 : 콜백을 호출하는 외부 코드에 의해) ctypes는 모든 호출에서 새로운 더미 Python 스레드를 만듭니다. 이 문제는 대부분의 목적을 위해 정확하지만, 함께 저장된 값을 의미 &lt;a href=&quot;threading#threading.local&quot;&gt; &lt;code&gt;threading.local&lt;/code&gt; 의는&lt;/a&gt; 것입니다 &lt;em&gt;하지&lt;/em&gt; 이러한 호출이 동일한 C 스레드에서 만들어진 경우에도, 다른 콜백을 통해 생존.</target>
        </trans-unit>
        <trans-unit id="ffda43397fafd0562d904b85d70629199b0601e9" translate="yes" xml:space="preserve">
          <source>Also, remember that a few standard headers (&lt;em&gt;Content-Length&lt;/em&gt;, &lt;em&gt;Content-Type&lt;/em&gt; and &lt;em&gt;Host&lt;/em&gt;) are added when the &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; is passed to &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt;&lt;code&gt;OpenerDirector.open()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt; &lt;code&gt;OpenerDirector.open()&lt;/code&gt; &lt;/a&gt; )으로 전달 될 때 몇 가지 표준 헤더 ( &lt;em&gt;Content-Length&lt;/em&gt; , &lt;em&gt;Content-Type&lt;/em&gt; 및 &lt;em&gt;Host&lt;/em&gt; )가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c31d635bef296eddc9b7067796d9ac2ceca1971" translate="yes" xml:space="preserve">
          <source>Also, setting &lt;code&gt;feature_version&lt;/code&gt; to a tuple &lt;code&gt;(major, minor)&lt;/code&gt; will attempt to parse using that Python version&amp;rsquo;s grammar. Currently &lt;code&gt;major&lt;/code&gt; must equal to &lt;code&gt;3&lt;/code&gt;. For example, setting &lt;code&gt;feature_version=(3, 4)&lt;/code&gt; will allow the use of &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; as variable names. The lowest supported version is &lt;code&gt;(3, 4)&lt;/code&gt;; the highest is &lt;code&gt;sys.version_info[0:2]&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;feature_version&lt;/code&gt; 을 튜플 &lt;code&gt;(major, minor)&lt;/code&gt; 하면 해당 Python 버전의 문법을 사용하여 구문 분석을 시도합니다. 현재 &lt;code&gt;major&lt;/code&gt; 는 &lt;code&gt;3&lt;/code&gt; 과 같아야합니다 . 예를 들어 &lt;code&gt;feature_version=(3, 4)&lt;/code&gt; 를 설정하면 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 를 변수 이름으로 사용할 수 있습니다 . 가장 낮은 지원 버전은 &lt;code&gt;(3, 4)&lt;/code&gt; . 가장 높은 것은 &lt;code&gt;sys.version_info[0:2]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c038b15b5de4f5872e231b0f4fef4b3d1ab4a8a" translate="yes" xml:space="preserve">
          <source>Also, subclassing an enumeration is allowed only if the enumeration does not define any members. So this is forbidden:</source>
          <target state="translated">또한 열거 서브 클래 싱은 열거가 멤버를 정의하지 않은 경우에만 허용됩니다. 따라서 이것은 금지되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d88f419db1d727742f4296df8e60905129a6eaa4" translate="yes" xml:space="preserve">
          <source>Alt-/</source>
          <target state="translated">Alt-/</target>
        </trans-unit>
        <trans-unit id="523f1fa185299e53f8073a5f4db33f3a543e0c73" translate="yes" xml:space="preserve">
          <source>Alt-K</source>
          <target state="translated">Alt-K</target>
        </trans-unit>
        <trans-unit id="08044dfe50ef88573dd4b98d40dcea3bbb29cb1b" translate="yes" xml:space="preserve">
          <source>Alt-n</source>
          <target state="translated">Alt-n</target>
        </trans-unit>
        <trans-unit id="f8b5304cb9f515ca84a85d6f59d92eb340d9d86e" translate="yes" xml:space="preserve">
          <source>Alt-p</source>
          <target state="translated">Alt-p</target>
        </trans-unit>
        <trans-unit id="166df40fdc45fa8435a0aeaeb724d35b2824b092" translate="yes" xml:space="preserve">
          <source>Altered an exponent to fit representation constraints.</source>
          <target state="translated">표현 구속 조건에 맞게 지수를 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="7a26af879a761b43ca17a9773a7940683b3c696e" translate="yes" xml:space="preserve">
          <source>Alternate character set mode</source>
          <target state="translated">대체 문자 세트 모드</target>
        </trans-unit>
        <trans-unit id="d9b3cf0658ad7ba54f125c370d44945ffd5bbbab" translate="yes" xml:space="preserve">
          <source>Alternate constructor for &lt;a href=&quot;#itertools.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt;. Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to:</source>
          <target state="translated">&lt;a href=&quot;#itertools.chain&quot;&gt; &lt;code&gt;chain()&lt;/code&gt; &lt;/a&gt; 대체 생성자 . 게으르게 평가되는 반복 가능한 단일 인수에서 체인 입력을 가져옵니다. 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b95b413e2781a6e9f949c96afb8e7654b0b6a7c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use the &lt;code&gt;setparameters()&lt;/code&gt; method to set all three audio parameters at once. This is more convenient, but may not be as flexible in all cases.</source>
          <target state="translated">또는 &lt;code&gt;setparameters()&lt;/code&gt; 메서드를 사용하여 세 가지 오디오 매개 변수를 한 번에 모두 설정할 수 있습니다 . 이것은 더 편리하지만 모든 경우에 유연하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="120472849a159296aff2262eb84d4aabcf036f62" translate="yes" xml:space="preserve">
          <source>Alternative Generator</source>
          <target state="translated">대체 발전기</target>
        </trans-unit>
        <trans-unit id="c3192b9728e7aa2994a20b12d0f484a50d4d9db8" translate="yes" xml:space="preserve">
          <source>Alternative command line option and argument parsing library.</source>
          <target state="translated">대체 명령 행 옵션 및 인수 구문 분석 라이브러리.</target>
        </trans-unit>
        <trans-unit id="6f08874d859f81959583d494b6024b88f3206311" translate="yes" xml:space="preserve">
          <source>Alternative constructor. The &lt;a href=&quot;#tarfile.open&quot;&gt;&lt;code&gt;tarfile.open()&lt;/code&gt;&lt;/a&gt; function is actually a shortcut to this classmethod.</source>
          <target state="translated">대체 생성자. &lt;a href=&quot;#tarfile.open&quot;&gt; &lt;code&gt;tarfile.open()&lt;/code&gt; &lt;/a&gt; 함수는 실제로이 classmethod에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="851a8413bea4eb55cb0ed6c5d8946229982061a0" translate="yes" xml:space="preserve">
          <source>Alternatively &lt;em&gt;side_effect&lt;/em&gt; can be an exception class or instance. In this case the exception will be raised when the mock is called.</source>
          <target state="translated">또는 &lt;em&gt;side_effect&lt;/em&gt; 는 예외 클래스 또는 인스턴스 일 수 있습니다. 이 경우 모의가 호출 될 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f2589d09d2de9e0443187f1741ac9282ceccb5b" translate="yes" xml:space="preserve">
          <source>Alternatively you can just use &lt;code&gt;vars(my_mock)&lt;/code&gt; (instance members) and &lt;code&gt;dir(type(my_mock))&lt;/code&gt; (type members) to bypass the filtering irrespective of &lt;code&gt;mock.FILTER_DIR&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;vars(my_mock)&lt;/code&gt; (인스턴스 멤버) 및 &lt;code&gt;dir(type(my_mock))&lt;/code&gt; (유형 멤버)을 사용하여 &lt;code&gt;mock.FILTER_DIR&lt;/code&gt; 에 관계없이 필터링을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="560cce3f7cddd3320937666765b3cde7401b149e" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;a href=&quot;#object.__reduce_ex__&quot;&gt;&lt;code&gt;__reduce_ex__()&lt;/code&gt;&lt;/a&gt; method may be defined. The only difference is this method should take a single integer argument, the protocol version. When defined, pickle will prefer it over the &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt; method. In addition, &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt; automatically becomes a synonym for the extended version. The main use for this method is to provide backwards-compatible reduce values for older Python releases.</source>
          <target state="translated">또는 &lt;a href=&quot;#object.__reduce_ex__&quot;&gt; &lt;code&gt;__reduce_ex__()&lt;/code&gt; &lt;/a&gt; 메서드를 정의 할 수 있습니다. 유일한 차이점은이 방법은 단일 정수 인수 인 프로토콜 버전을 사용해야한다는 것입니다. 정의되면 pickle은 &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 메소드 보다 선호합니다 . 또한 &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 자동으로 확장 버전의 동의어가됩니다. 이 방법의 주요 용도는 이전 Python 릴리스에 대해 하위 호환 호환 감소 값을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b8170ca6af713e396125022cf5ef83122166378a" translate="yes" xml:space="preserve">
          <source>Alternatively, annotate your generator as having a return type of either &lt;code&gt;AsyncIterable[YieldType]&lt;/code&gt; or &lt;code&gt;AsyncIterator[YieldType]&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;AsyncIterable[YieldType]&lt;/code&gt; 또는 &lt;code&gt;AsyncIterator[YieldType]&lt;/code&gt; 의 반환 유형을 갖는 것으로 생성기에 주석을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="bedcc0b6120fd2e8105cbf4a4b500b32795b5330" translate="yes" xml:space="preserve">
          <source>Alternatively, annotate your generator as having a return type of either &lt;code&gt;Iterable[YieldType]&lt;/code&gt; or &lt;code&gt;Iterator[YieldType]&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;Iterable[YieldType]&lt;/code&gt; 또는 &lt;code&gt;Iterator[YieldType]&lt;/code&gt; 의 리턴 유형을 갖는 것으로 생성기에 주석을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3a0dab4ca32a3c12f17a83c0742fa58af47dd19" translate="yes" xml:space="preserve">
          <source>Alternatively, for trusted input, the shell&amp;rsquo;s own pipeline support may still be used directly:</source>
          <target state="translated">또는 신뢰할 수있는 입력의 경우 셸의 자체 파이프 라인 지원을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2c53c18dbfbfd58e92716305404323d14180eb0" translate="yes" xml:space="preserve">
          <source>Alternatively, if you configured the &lt;code&gt;PATH&lt;/code&gt; and &lt;code&gt;PATHEXT&lt;/code&gt; variables for your &lt;a href=&quot;https://docs.python.org/3.8/using/windows.html#using-on-windows&quot;&gt;Python installation&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;https://docs.python.org/3.8/using/windows.html#using-on-windows&quot;&gt;Python 설치를&lt;/a&gt; 위해 &lt;code&gt;PATH&lt;/code&gt; 및 &lt;code&gt;PATHEXT&lt;/code&gt; 변수를 구성한 경우 :</target>
        </trans-unit>
        <trans-unit id="7a7e943dc867b6734626dcdec4a25f40c03a249a" translate="yes" xml:space="preserve">
          <source>Alternatively, inputs can be rounded upon creation using the &lt;a href=&quot;#decimal.Context.create_decimal&quot;&gt;&lt;code&gt;Context.create_decimal()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">또는 &lt;a href=&quot;#decimal.Context.create_decimal&quot;&gt; &lt;code&gt;Context.create_decimal()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 생성시 입력을 반올림 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afdd5b97037a223bd3a94ba552f2a81c0c1bf175" translate="yes" xml:space="preserve">
          <source>Alternatively, the first character of the format string can be used to indicate the byte order, size and alignment of the packed data, according to the following table:</source>
          <target state="translated">또는 다음 표에 따라 형식 문자열의 첫 번째 문자를 사용하여 압축 된 데이터의 바이트 순서, 크기 및 정렬을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="161271a624435f85f1f3f89dd66674cf40b4b411" translate="yes" xml:space="preserve">
          <source>Alternatively, use &lt;a href=&quot;#inspect.signature&quot;&gt;&lt;code&gt;signature()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#inspect-signature-object&quot;&gt;Signature Object&lt;/a&gt;, which provide a more structured introspection API for callables.</source>
          <target state="translated">또는 callables에 대해보다 구조화 된 내부 검사 API를 제공하는 &lt;a href=&quot;#inspect.signature&quot;&gt; &lt;code&gt;signature()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#inspect-signature-object&quot;&gt;Signature Object&lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc69874a843b8bca70392a6b4845a801e795ddc4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can provide the entire regular expression pattern by overriding the class attribute &lt;em&gt;pattern&lt;/em&gt;. If you do this, the value must be a regular expression object with four named capturing groups. The capturing groups correspond to the rules given above, along with the invalid placeholder rule:</source>
          <target state="translated">또는 클래스 속성 &lt;em&gt;pattern&lt;/em&gt; 을 재정 의하여 전체 정규식 패턴을 제공 할 수 있습니다 . 이렇게하면 값이 4 개의 명명 된 캡처 그룹이있는 정규식 객체 여야합니다. 캡처 그룹이 유효하지 않은 자리 표시 자 규칙과 함께 위에 제공된 규칙에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="537f3d9f59a4cc7f4b3b3b1d8452a61dcfcd6369" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run the demo scripts individually. For example,</source>
          <target state="translated">또는 데모 스크립트를 개별적으로 실행할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="fa0d39d2965e611cb72e153681483b50e7579f0d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;#multiprocessing.get_context&quot;&gt;&lt;code&gt;get_context()&lt;/code&gt;&lt;/a&gt; to obtain a context object. Context objects have the same API as the multiprocessing module, and allow one to use multiple start methods in the same program.</source>
          <target state="translated">또는 &lt;a href=&quot;#multiprocessing.get_context&quot;&gt; &lt;code&gt;get_context()&lt;/code&gt; &lt;/a&gt; 를 사용하여 컨텍스트 객체를 얻을 수 있습니다 . 컨텍스트 객체는 멀티 프로세싱 모듈과 동일한 API를 가지며 동일한 프로그램에서 여러 시작 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c25f25fc8595d803ebcfcdb59b8832dd261b439" translate="yes" xml:space="preserve">
          <source>Alters flag dispositions for messages in mailbox. &lt;em&gt;command&lt;/em&gt; is specified by section 6.4.6 of &lt;a href=&quot;https://tools.ietf.org/html/rfc2060.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2060&lt;/strong&gt;&lt;/a&gt; as being one of &amp;ldquo;FLAGS&amp;rdquo;, &amp;ldquo;+FLAGS&amp;rdquo;, or &amp;ldquo;-FLAGS&amp;rdquo;, optionally with a suffix of &amp;ldquo;.SILENT&amp;rdquo;.</source>
          <target state="translated">사서함의 메시지에 대한 플래그 처리를 변경합니다. &lt;em&gt;명령&lt;/em&gt; 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2060.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2060&lt;/strong&gt;&lt;/a&gt; 의 섹션 6.4.6에 &quot;FLAGS&quot;, &quot;+ FLAGS&quot;또는 &quot;-FLAGS&quot;중 하나로 지정되고 선택적으로 접미사가 &quot;.SILENT&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6ca488175d062da3b916916dcc5cf1c6c0a580bc" translate="yes" xml:space="preserve">
          <source>Although &lt;a href=&quot;os.path#os.path.relpath&quot;&gt;&lt;code&gt;os.path.relpath()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pathlib.PurePath.relative_to&quot;&gt;&lt;code&gt;PurePath.relative_to()&lt;/code&gt;&lt;/a&gt; have some overlapping use-cases, their semantics differ enough to warrant not considering them equivalent.</source>
          <target state="translated">하지만 &lt;a href=&quot;os.path#os.path.relpath&quot;&gt; &lt;code&gt;os.path.relpath()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#pathlib.PurePath.relative_to&quot;&gt; &lt;code&gt;PurePath.relative_to()&lt;/code&gt; &lt;/a&gt; 일부 중복 사용 사례를 가지고, 자신의 의미는 상당을 고려하지 않고 보증 할만큼 다르다.</target>
        </trans-unit>
        <trans-unit id="5aba7d7e4194f7e569bb1e4976c4f49e69cd0c0d" translate="yes" xml:space="preserve">
          <source>Although Windows supports &lt;a href=&quot;#os.chmod&quot;&gt;&lt;code&gt;chmod()&lt;/code&gt;&lt;/a&gt;, you can only set the file&amp;rsquo;s read-only flag with it (via the &lt;code&gt;stat.S_IWRITE&lt;/code&gt; and &lt;code&gt;stat.S_IREAD&lt;/code&gt; constants or a corresponding integer value). All other bits are ignored.</source>
          <target state="translated">Windows는 &lt;a href=&quot;#os.chmod&quot;&gt; &lt;code&gt;chmod()&lt;/code&gt; &lt;/a&gt; 지원하지만 &lt;code&gt;stat.S_IWRITE&lt;/code&gt; 및 &lt;code&gt;stat.S_IREAD&lt;/code&gt; 상수 또는 해당 정수 값을 통해 파일의 읽기 전용 플래그 만 설정할 수 있습니다 . 다른 모든 비트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ff306b2fbe16e39bfb4f4ae1cb51d280ddc5b736" translate="yes" xml:space="preserve">
          <source>Although filters are used primarily to filter records based on more sophisticated criteria than levels, they get to see every record which is processed by the handler or logger they&amp;rsquo;re attached to: this can be useful if you want to do things like counting how many records were processed by a particular logger or handler, or adding, changing or removing attributes in the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; being processed. Obviously changing the LogRecord needs to be done with some care, but it does allow the injection of contextual information into logs (see &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#filters-contextual&quot;&gt;Using Filters to impart contextual information&lt;/a&gt;).</source>
          <target state="translated">필터는 주로 레벨보다 더 정교한 기준에 따라 레코드를 필터링하는 데 사용되지만 첨부 된 처리기 또는 로거가 처리하는 모든 레코드를 볼 수 있습니다. 레코드는 특정 로거 또는 핸들러에 의해 처리되거나 처리중인 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 에서 속성을 추가, 변경 또는 제거합니다 . 분명히 LogRecord를 변경하려면 약간의주의를 기울여야하지만 상황에 맞는 정보를 로그에 삽입 할 수 있습니다 ( &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#filters-contextual&quot;&gt;컨텍스트 정보를 전달하기 위해 필터 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e435625441b2f1626446dd761b8fafec987e5b2e" translate="yes" xml:space="preserve">
          <source>Although in many cases, changing the &lt;code id=&quot;index-15&quot;&gt;TZ&lt;/code&gt; environment variable may affect the output of functions like &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; without calling &lt;a href=&quot;#time.tzset&quot;&gt;&lt;code&gt;tzset()&lt;/code&gt;&lt;/a&gt;, this behavior should not be relied on.</source>
          <target state="translated">많은 경우에 &lt;code id=&quot;index-15&quot;&gt;TZ&lt;/code&gt; 환경 변수를 변경하면 &lt;a href=&quot;#time.tzset&quot;&gt; &lt;code&gt;tzset()&lt;/code&gt; &lt;/a&gt; 을 호출하지 않고 &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 과 같은 함수의 출력에 영향을 줄 수 있지만이 동작에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5f7e770948da6ad1f5401b21b0a95acc8356e162" translate="yes" xml:space="preserve">
          <source>Although it is possible to store a pointer in shared memory remember that this will refer to a location in the address space of a specific process. However, the pointer is quite likely to be invalid in the context of a second process and trying to dereference the pointer from the second process may cause a crash.</source>
          <target state="translated">공유 메모리에 포인터를 저장할 수 있지만 특정 프로세스의 주소 공간에있는 위치를 나타냅니다. 그러나 두 번째 프로세스 컨텍스트에서 포인터가 유효하지 않을 가능성이 높으며 두 번째 프로세스에서 포인터를 역 참조하려고하면 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36ac042d6e7c56f32a4f17c62570dba38897403c" translate="yes" xml:space="preserve">
          <source>Although powerful, implementing &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt; directly in your classes is error prone. For this reason, class designers should use the high-level interface (i.e., &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt;&lt;code&gt;__getnewargs_ex__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#object.__getstate__&quot;&gt;&lt;code&gt;__getstate__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt;) whenever possible. We will show, however, cases where using &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt; is the only option or leads to more efficient pickling or both.</source>
          <target state="translated">강력하지만 클래스에서 &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 직접 구현 하면 오류가 발생하기 쉽습니다. 이러한 이유로 클래스 디자이너는 가능할 때마다 높은 수준의 인터페이스 (예 : &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt; &lt;code&gt;__getnewargs_ex__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#object.__getstate__&quot;&gt; &lt;code&gt;__getstate__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; )를 사용해야 합니다. 그러나 &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 유일한 옵션이거나 더 효율적인 산세 또는 두 가지 경우를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="81a1b224e7ad62f02a109883807627a1786137e9" translate="yes" xml:space="preserve">
          <source>Although the &lt;a href=&quot;#sqlite3.Cursor&quot;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/a&gt; class of the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module implements this attribute, the database engine&amp;rsquo;s own support for the determination of &amp;ldquo;rows affected&amp;rdquo;/&amp;rdquo;rows selected&amp;rdquo; is quirky.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;a href=&quot;#sqlite3.Cursor&quot;&gt; &lt;code&gt;Cursor&lt;/code&gt; &lt;/a&gt; 클래스 가이 속성을 구현 하지만 &quot;영향을받는 행&quot;/ &quot;선택한 행&quot;을 결정하기위한 데이터베이스 엔진의 자체 지원은 기발합니다.</target>
        </trans-unit>
        <trans-unit id="5e789a4520b246a8dd4042cca86036c0f5a37df9" translate="yes" xml:space="preserve">
          <source>Although this module is always available, not all functions are available on all platforms. Most of the functions defined in this module call platform C library functions with the same name. It may sometimes be helpful to consult the platform documentation, because the semantics of these functions varies among platforms.</source>
          <target state="translated">이 모듈을 항상 사용할 수 있지만 모든 플랫폼에서 모든 기능을 사용할 수있는 것은 아닙니다. 이 모듈에 정의 된 대부분의 함수는 동일한 이름의 플랫폼 C 라이브러리 함수를 호출합니다. 이러한 기능의 의미는 플랫폼마다 다르므로 플랫폼 설명서를 참조하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e0fade5c33a8c0706c1ee4ec4d3b8efefa5ae6" translate="yes" xml:space="preserve">
          <source>Always check a script for syntax errors first, by doing something like &lt;code&gt;python script.py&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;python script.py&lt;/code&gt; 와 같은 작업을 수행하여 스크립트에 구문 오류가 있는지 먼저 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="940801d3a0b2504730f2938dc103aefa05f13928" translate="yes" xml:space="preserve">
          <source>Always create a new, empty database, open for reading and writing</source>
          <target state="translated">항상 새로운 빈 데이터베이스를 작성하십시오</target>
        </trans-unit>
        <trans-unit id="2b68c9edfa6077c66acf9229ba5007aeabfd27c6" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d92042192835b0201f0080332bb4fd84f15bccf0" translate="yes" xml:space="preserve">
          <source>Among other uses, this allows for initializing field values that depend on one or more other fields. For example:</source>
          <target state="translated">다른 용도 중에서, 이는 하나 이상의 다른 필드에 의존하는 필드 값을 초기화 할 수있게합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08b2cdd1820b99395356f8484945cb33f7bdcc5d" translate="yes" xml:space="preserve">
          <source>Among the acceptable object types in the sequences are Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt; (e.g. &lt;code&gt;sys.stdin&lt;/code&gt;, or objects returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;os.popen()&lt;/code&gt;&lt;/a&gt;), socket objects returned by &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;. You may also define a &lt;em&gt;wrapper&lt;/em&gt; class yourself, as long as it has an appropriate &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method (that really returns a file descriptor, not just a random integer).</source>
          <target state="translated">시퀀스에서 허용되는 객체 유형에는 Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; (예 : &lt;code&gt;sys.stdin&lt;/code&gt; 또는 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;os.popen()&lt;/code&gt; &lt;/a&gt; 반환 된 객체), &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 반환 된 소켓 객체가 있습니다. 적절한 &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 메소드 (임의의 정수가 아닌 파일 디스크립터를 실제로 리턴 함 ) 가있는 한 &lt;em&gt;랩퍼&lt;/em&gt; 클래스를 직접 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67f920425dfdb0e1d204c3706777c2dfb256039d" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;unstructured&amp;rdquo; header is the default type of header in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;. Any header that does not have a specified syntax is treated as unstructured. The classic example of an unstructured header is the &lt;em&gt;Subject&lt;/em&gt; header.</source>
          <target state="translated">&quot;구조화되지 않은&quot;헤더는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 의 기본 헤더 유형입니다 . 지정된 구문이없는 헤더는 구조화되지 않은 것으로 취급됩니다. 구조화되지 않은 헤더의 전형적인 예는 &lt;em&gt;Subject&lt;/em&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="e131bde80853d47856e8609b6fce7ef182378143" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; would also be useful for implementing variants of &lt;a href=&quot;functools#functools.lru_cache&quot;&gt;&lt;code&gt;functools.lru_cache()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; 은&lt;/a&gt; 또한 변종 구현하는 데 유용 할 것이다 &lt;a href=&quot;functools#functools.lru_cache&quot;&gt; &lt;code&gt;functools.lru_cache()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="47217b41bb1d751c58676a69570e3346ce5098e4" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; subclass that executes calls asynchronously using a pool of at most &lt;em&gt;max_workers&lt;/em&gt; processes. If &lt;em&gt;max_workers&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; or not given, it will default to the number of processors on the machine. If &lt;em&gt;max_workers&lt;/em&gt; is lower or equal to &lt;code&gt;0&lt;/code&gt;, then a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised. On Windows, &lt;em&gt;max_workers&lt;/em&gt; must be equal or lower than &lt;code&gt;61&lt;/code&gt;. If it is not then &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised. If &lt;em&gt;max_workers&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, then the default chosen will be at most &lt;code&gt;61&lt;/code&gt;, even if more processors are available. &lt;em&gt;mp_context&lt;/em&gt; can be a multiprocessing context or None. It will be used to launch the workers. If &lt;em&gt;mp_context&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; or not given, the default multiprocessing context is used.</source>
          <target state="translated">최대 &lt;em&gt;max_workers&lt;/em&gt; 프로세스 풀을 사용하여 비동기 적으로 호출을 실행 하는 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 서브 클래스 . 경우 &lt;em&gt;max_workers이&lt;/em&gt; 있다 &lt;code&gt;None&lt;/code&gt; 여부가 주어지지의 경우 시스템의 프로세서 수에 기본 설정됩니다. 경우 &lt;em&gt;max_workers가&lt;/em&gt; 낮거나 같은지 &lt;code&gt;0&lt;/code&gt; , 다음 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 발생한다. Windows에서 &lt;em&gt;max_workers&lt;/em&gt; 는 &lt;code&gt;61&lt;/code&gt; 이하 여야합니다 . 그렇지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 경우 &lt;em&gt;max_workers가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 다음, 선택된 기본값은 가장에있을 것입니다 &lt;code&gt;61&lt;/code&gt; 이상의 프로세서를 사용할 수있는 경우에도. &lt;em&gt;mp_context&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;다중 처리 컨텍스트 또는 없음 일 수 있습니다. 노동자를 발사하는 데 사용됩니다. 경우 &lt;em&gt;mp_context가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 여부를 지정, 기본 다중 처리 컨텍스트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f20b7dfdda203d4d41b7e3513f2e5b7977c7e2d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; subclass that uses a pool of at most &lt;em&gt;max_workers&lt;/em&gt; threads to execute calls asynchronously.</source>
          <target state="translated">최대 &lt;em&gt;max_workers&lt;/em&gt; 스레드 풀을 사용하여 호출을 비동기 적으로 실행 하는 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 서브 클래스입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8c23a468c316481bdf2183623e1c6846281a4c8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt;&lt;code&gt;HTMLParser&lt;/code&gt;&lt;/a&gt; instance is fed HTML data and calls handler methods when start tags, end tags, text, comments, and other markup elements are encountered. The user should subclass &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt;&lt;code&gt;HTMLParser&lt;/code&gt;&lt;/a&gt; and override its methods to implement the desired behavior.</source>
          <target state="translated">&lt;a href=&quot;#html.parser.HTMLParser&quot;&gt; &lt;code&gt;HTMLParser&lt;/code&gt; 의&lt;/a&gt; 태그, 종료 태그, 텍스트, 주석을 시작할 때 인스턴스는 HTML 데이터와 호출 핸들러 메소드를 공급하고, 다른 마크 업 요소가 발생하고 있습니다. 사용자는 &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt; &lt;code&gt;HTMLParser&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱 하고 메소드를 재정 의하여 원하는 동작을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d0411e58015548ce4f79bef8d87ffb7f4cf110d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#http.client.HTTPConnection&quot;&gt;&lt;code&gt;HTTPConnection&lt;/code&gt;&lt;/a&gt; instance represents one transaction with an HTTP server. It should be instantiated passing it a host and optional port number. If no port number is passed, the port is extracted from the host string if it has the form &lt;code&gt;host:port&lt;/code&gt;, else the default HTTP port (80) is used. If the optional &lt;em&gt;timeout&lt;/em&gt; parameter is given, blocking operations (like connection attempts) will timeout after that many seconds (if it is not given, the global default timeout setting is used). The optional &lt;em&gt;source_address&lt;/em&gt; parameter may be a tuple of a (host, port) to use as the source address the HTTP connection is made from. The optional &lt;em&gt;blocksize&lt;/em&gt; parameter sets the buffer size in bytes for sending a file-like message body.</source>
          <target state="translated">&lt;a href=&quot;#http.client.HTTPConnection&quot;&gt; &lt;code&gt;HTTPConnection&lt;/code&gt; &lt;/a&gt; 인스턴스는 HTTP 서버와 하나의 트랜잭션을 나타냅니다. 호스트 및 선택적 포트 번호를 전달하여 인스턴스화해야합니다. 포트 번호가 전달되지 않으면 호스트 문자열이 &lt;code&gt;host:port&lt;/code&gt; 형식이면 호스트 문자열에서 포트가 추출됩니다. 그렇지 않으면 기본 HTTP 포트 (80)가 사용됩니다. 선택적 &lt;em&gt;시간 초과&lt;/em&gt; 매개 변수가 제공되면 차단 시도 (예 : 연결 시도)가 몇 초 후에 시간 초과됩니다 (제공되지 않으면 전역 기본 시간 초과 설정이 사용됨). 선택적 &lt;em&gt;source_address&lt;/em&gt; 매개 변수는 HTTP 연결의 소스 주소로 사용할 (호스트, 포트)의 튜플 일 수 있습니다. 선택적 &lt;em&gt;blocksize&lt;/em&gt; 매개 변수는 파일과 유사한 메시지 본문을 보내기 위해 버퍼 크기를 바이트 단위로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ed2fb59076f740158ba38827bce5bff26573eb0c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#http.client.HTTPResponse&quot;&gt;&lt;code&gt;HTTPResponse&lt;/code&gt;&lt;/a&gt; instance wraps the HTTP response from the server. It provides access to the request headers and the entity body. The response is an iterable object and can be used in a with statement.</source>
          <target state="translated">&lt;a href=&quot;#http.client.HTTPResponse&quot;&gt; &lt;code&gt;HTTPResponse&lt;/code&gt; &lt;/a&gt; 인스턴스는 서버에서 HTTP 응답을 래핑합니다. 요청 헤더 및 엔티티 본문에 대한 액세스를 제공합니다. 응답은 반복 가능한 객체이며 with 문에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30417cc6f1be8386812ed952297391d77fecc73f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt; instance has the following methods:</source>
          <target state="translated">&lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 다음과 같은 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="88406d2d2cb0f1d94ca189eb244e8e9fe67a27a7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#ipaddress.AddressValueError&quot;&gt;&lt;code&gt;AddressValueError&lt;/code&gt;&lt;/a&gt; is raised if &lt;em&gt;address&lt;/em&gt; is not a valid IPv4 address. A &lt;a href=&quot;#ipaddress.NetmaskValueError&quot;&gt;&lt;code&gt;NetmaskValueError&lt;/code&gt;&lt;/a&gt; is raised if the mask is not valid for an IPv4 address.</source>
          <target state="translated">&lt;a href=&quot;#ipaddress.AddressValueError&quot;&gt; &lt;code&gt;AddressValueError&lt;/code&gt; 는&lt;/a&gt; 경우 발생합니다 &lt;em&gt;주소가&lt;/em&gt; 유효한 IPv4 주소가 아닙니다. &lt;a href=&quot;#ipaddress.NetmaskValueError&quot;&gt; &lt;code&gt;NetmaskValueError&lt;/code&gt; 이&lt;/a&gt; 마스크는 IPv4 주소에 대한 유효하지 않은 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2c00af07c169fbcb2dc420227c3de9360f629263" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#ipaddress.AddressValueError&quot;&gt;&lt;code&gt;AddressValueError&lt;/code&gt;&lt;/a&gt; is raised if &lt;em&gt;address&lt;/em&gt; is not a valid IPv6 address. A &lt;a href=&quot;#ipaddress.NetmaskValueError&quot;&gt;&lt;code&gt;NetmaskValueError&lt;/code&gt;&lt;/a&gt; is raised if the mask is not valid for an IPv6 address.</source>
          <target state="translated">&lt;a href=&quot;#ipaddress.AddressValueError&quot;&gt; &lt;code&gt;AddressValueError&lt;/code&gt; 는&lt;/a&gt; 경우 발생합니다 &lt;em&gt;주소가&lt;/em&gt; 유효한 IPv6 주소가 아닙니다. &lt;a href=&quot;#ipaddress.NetmaskValueError&quot;&gt; &lt;code&gt;NetmaskValueError&lt;/code&gt; 는&lt;/a&gt; 마스크가 IPv6 주소에 대한 유효하지 않은 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e22e8e2b70a072517721b45185e0df25bf62617a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; can wrap an already-open &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, or operate directly on a named file. The &lt;em&gt;filename&lt;/em&gt; argument specifies either the file object to wrap, or the name of the file to open (as a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object). When wrapping an existing file object, the wrapped file will not be closed when the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; is closed.</source>
          <target state="translated">&lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; 은&lt;/a&gt; 이미 오픈 랩 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; , 또는 명명 된 파일을 직접 운영하고 있습니다. &lt;em&gt;파일 이름&lt;/em&gt; 인수를 지정하거나 랩에 파일 객체 또는 열 파일의 이름 (A와 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은&lt;/a&gt; 객체). 기존 파일 객체를 줄 바꿈 할 때 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 을 닫을 때 줄 바꿈 된 파일이 닫히지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="39f46664bc28103047a5cc26287a1fd211662851" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#poplib.POP3&quot;&gt;&lt;code&gt;POP3&lt;/code&gt;&lt;/a&gt; instance has the following methods:</source>
          <target state="translated">&lt;a href=&quot;#poplib.POP3&quot;&gt; &lt;code&gt;POP3&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 다음과 같은 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4e40ef7751f7971309b0f2f98a0b9e618f82a29f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt; instance encapsulates an SMTP connection. It has methods that support a full repertoire of SMTP and ESMTP operations. If the optional host and port parameters are given, the SMTP &lt;a href=&quot;#smtplib.SMTP.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; method is called with those parameters during initialization. If specified, &lt;em&gt;local_hostname&lt;/em&gt; is used as the FQDN of the local host in the HELO/EHLO command. Otherwise, the local hostname is found using &lt;a href=&quot;socket#socket.getfqdn&quot;&gt;&lt;code&gt;socket.getfqdn()&lt;/code&gt;&lt;/a&gt;. If the &lt;a href=&quot;#smtplib.SMTP.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; call returns anything other than a success code, an &lt;a href=&quot;#smtplib.SMTPConnectError&quot;&gt;&lt;code&gt;SMTPConnectError&lt;/code&gt;&lt;/a&gt; is raised. The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). If the timeout expires, &lt;a href=&quot;socket#socket.timeout&quot;&gt;&lt;code&gt;socket.timeout&lt;/code&gt;&lt;/a&gt; is raised. The optional source_address parameter allows binding to some specific source address in a machine with multiple network interfaces, and/or to some specific source TCP port. It takes a 2-tuple (host, port), for the socket to bind to as its source address before connecting. If omitted (or if host or port are &lt;code&gt;''&lt;/code&gt; and/or 0 respectively) the OS default behavior will be used.</source>
          <target state="translated">&lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 SMTP 연결을 캡슐화합니다. SMTP 및 ESMTP 작업의 전체 레퍼토리를 지원하는 메소드가 있습니다. 선택적 호스트 및 포트 매개 변수가 제공되면 초기화 중에 해당 매개 변수와 함께 SMTP &lt;a href=&quot;#smtplib.SMTP.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 지정된 경우 &lt;em&gt;local_hostname&lt;/em&gt; 은 HELO / EHLO 명령에서 로컬 호스트의 FQDN으로 사용됩니다. 그렇지 않으면 &lt;a href=&quot;socket#socket.getfqdn&quot;&gt; &lt;code&gt;socket.getfqdn()&lt;/code&gt; &lt;/a&gt; 사용하여 로컬 호스트 이름을 찾습니다 . 상기 중간 &lt;a href=&quot;#smtplib.SMTP.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 호출이 성공 코드 이외의 반환, &lt;a href=&quot;#smtplib.SMTPConnectError&quot;&gt; &lt;code&gt;SMTPConnectError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 선택적 &lt;em&gt;타임 아웃&lt;/em&gt;매개 변수는 연결 시도와 같은 작업을 차단하기위한 시간 초과를 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간 초과 설정이 사용됨). 시간 초과가 만료되면 &lt;a href=&quot;socket#socket.timeout&quot;&gt; &lt;code&gt;socket.timeout&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 선택적 source_address 매개 변수를 사용하면 여러 네트워크 인터페이스가있는 머신의 특정 소스 주소 및 / 또는 특정 소스 TCP 포트에 바인딩 할 수 있습니다. 소켓이 연결하기 전에 소스 주소로 바인드하려면 2 튜플 (호스트, 포트)이 필요합니다. 생략하거나 호스트 또는 포트가 각각 &lt;code&gt;''&lt;/code&gt; 및 / 또는 0 인 경우 OS 기본 동작이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b06f296a09f34cbedecd22805400c41792ba65c6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt; instance has the following methods:</source>
          <target state="translated">&lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 다음과 같은 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2c58fa6751490e6d0e0d24391a1319962ea6b856" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#smtplib.SMTP_SSL&quot;&gt;&lt;code&gt;SMTP_SSL&lt;/code&gt;&lt;/a&gt; instance behaves exactly the same as instances of &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#smtplib.SMTP_SSL&quot;&gt;&lt;code&gt;SMTP_SSL&lt;/code&gt;&lt;/a&gt; should be used for situations where SSL is required from the beginning of the connection and using &lt;code&gt;starttls()&lt;/code&gt; is not appropriate. If &lt;em&gt;host&lt;/em&gt; is not specified, the local host is used. If &lt;em&gt;port&lt;/em&gt; is zero, the standard SMTP-over-SSL port (465) is used. The optional arguments &lt;em&gt;local_hostname&lt;/em&gt;, &lt;em&gt;timeout&lt;/em&gt; and &lt;em&gt;source_address&lt;/em&gt; have the same meaning as they do in the &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt; class. &lt;em&gt;context&lt;/em&gt;, also optional, can contain a &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; and allows configuring various aspects of the secure connection. Please read &lt;a href=&quot;ssl#ssl-security&quot;&gt;Security considerations&lt;/a&gt; for best practices.</source>
          <target state="translated">&lt;a href=&quot;#smtplib.SMTP_SSL&quot;&gt; &lt;code&gt;SMTP_SSL&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 정확하게의 경우와 동일하게 동작 &lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; &lt;/a&gt; . 연결 시작시 SSL이 필요하고 &lt;code&gt;starttls()&lt;/code&gt; 이 적합하지 않은 상황에서는 &lt;a href=&quot;#smtplib.SMTP_SSL&quot;&gt; &lt;code&gt;SMTP_SSL&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다 . 경우 &lt;em&gt;호스트가&lt;/em&gt; 지정되지 않은 로컬 호스트가 사용됩니다. 경우 &lt;em&gt;포트가&lt;/em&gt; 제로의 표준 SMTP - 이상 - SSL 포트 (465)가 사용됩니다. 선택적 인수 &lt;em&gt;local_hostname&lt;/em&gt; , &lt;em&gt;timeout&lt;/em&gt; 및 &lt;em&gt;source_address&lt;/em&gt; 는 &lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; &lt;/a&gt; 클래스 에서와 동일한 의미를 갖습니다 . &lt;em&gt;context&lt;/em&gt; 도 옵션이며 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; 를&lt;/a&gt; 포함 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;보안 연결의 다양한 측면을 구성 할 수 있습니다. 모범 사례는 &lt;a href=&quot;ssl#ssl-security&quot;&gt;보안 고려 사항&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="4381f9c58b5b614abf7892a4b1f45ba2f8360660" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#ssl.SSLError&quot;&gt;&lt;code&gt;SSLError&lt;/code&gt;&lt;/a&gt; is raised if the private key doesn&amp;rsquo;t match with the certificate.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLError&quot;&gt; &lt;code&gt;SSLError&lt;/code&gt; 는&lt;/a&gt; 개인 키가 인증서와 일치하지 않는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6503930af8cf259e4f55b3889f6a90017471de7a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; belongs to the application, the &lt;a href=&quot;#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt; is not allowed to modify &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; objects passed to it from the application, although it may make copies and modify those.</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; 의는&lt;/a&gt; 1, 응용 프로그램에 속한 &lt;a href=&quot;#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt; 수정할 수 없습니다 &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; 의는&lt;/a&gt; 이 복사본을 만들어 사람들을 수정할 수 있지만, 응용 프로그램에서 전달 객체.</target>
        </trans-unit>
        <trans-unit id="79185203e0837e407c9cfffcf6c6215ce7683000" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; can be raised if either file cannot be accessed for some reason.</source>
          <target state="translated">&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 는&lt;/a&gt; 두 파일이 어떤 이유로 액세스 할 수없는 경우 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c390610582f1c814d75321837553c7075f775df3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised on syscall failure.</source>
          <target state="translated">&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 는&lt;/a&gt; 콜 실패에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6e45de73f5fdf516cc14c157c02fac73fbe32076" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised with the value of errno when the syscall returns -1.</source>
          <target state="translated">&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 은&lt;/a&gt; errno를 값 제기 될 때 콜 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cfafa94088c5bdf5d8dde31f6359f2a768fafdbe" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; will be raised for integer values that cannot be represented in (binary) plist files.</source>
          <target state="translated">&lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 은&lt;/a&gt; (진) PLIST 파일에 표시 할 수없는 정수 값을 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8902561dc3621643794d523ee377886fb9098907" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt; for classes that implement &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aenter__&quot;&gt;&lt;code&gt;object.__aenter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt;&lt;code&gt;object.__aexit__()&lt;/code&gt;&lt;/a&gt;. A default implementation for &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aenter__&quot;&gt;&lt;code&gt;object.__aenter__()&lt;/code&gt;&lt;/a&gt; is provided which returns &lt;code&gt;self&lt;/code&gt; while &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt;&lt;code&gt;object.__aexit__()&lt;/code&gt;&lt;/a&gt; is an abstract method which by default returns &lt;code&gt;None&lt;/code&gt;. See also the definition of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#async-context-managers&quot;&gt;Asynchronous Context Managers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aenter__&quot;&gt; &lt;code&gt;object.__aenter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt; &lt;code&gt;object.__aexit__()&lt;/code&gt; &lt;/a&gt; 을 구현하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;클래스&lt;/a&gt; 의 추상 기본 클래스 입니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aenter__&quot;&gt; &lt;code&gt;object.__aenter__()&lt;/code&gt; &lt;/a&gt; 의 기본 구현 은 &lt;code&gt;self&lt;/code&gt; 를 반환 하는 반면 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt; &lt;code&gt;object.__aexit__()&lt;/code&gt; &lt;/a&gt; 은 기본적으로 &lt;code&gt;None&lt;/code&gt; 을 반환하는 추상 메서드입니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#async-context-managers&quot;&gt;비동기 컨텍스트 관리자&lt;/a&gt; 정의도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dda979d2a681c46df74b589ab265649e61f26e6c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt; for classes that implement &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;object.__enter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;object.__exit__()&lt;/code&gt;&lt;/a&gt;. A default implementation for &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;object.__enter__()&lt;/code&gt;&lt;/a&gt; is provided which returns &lt;code&gt;self&lt;/code&gt; while &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;object.__exit__()&lt;/code&gt;&lt;/a&gt; is an abstract method which by default returns &lt;code&gt;None&lt;/code&gt;. See also the definition of &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;Context Manager Types&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;object.__enter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;object.__exit__()&lt;/code&gt; &lt;/a&gt; 을 구현하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;클래스&lt;/a&gt; 의 추상 기본 클래스 입니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;object.__enter__()&lt;/code&gt; &lt;/a&gt; 의 기본 구현 은 &lt;code&gt;self&lt;/code&gt; 를 반환 하는 반면, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;object.__exit__()&lt;/code&gt; &lt;/a&gt; 은 기본적으로 &lt;code&gt;None&lt;/code&gt; 을 반환하는 추상 메서드입니다 . &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;컨텍스트 관리자 유형&lt;/a&gt; 정의도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fdb63e9d860e12df6617deab601b29ae6ed82b3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt; for objects representing a file system path, e.g. &lt;a href=&quot;pathlib#pathlib.PurePath&quot;&gt;&lt;code&gt;pathlib.PurePath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 시스템 경로를 나타내는 객체 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스&lt;/a&gt; 입니다 (예 : &lt;a href=&quot;pathlib#pathlib.PurePath&quot;&gt; &lt;code&gt;pathlib.PurePath&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33ab1cf8909ceb57812b37b76ad04f8a117605e8" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt; to provide the ability to read &lt;em&gt;resources&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;자원&lt;/em&gt; 을 읽을 수있는 기능을 제공 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3659fcc10888c5f8705dd1f37cd33e48a2bd5bc6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-importer&quot;&gt;importer&lt;/a&gt; for built-in modules. All known built-in modules are listed in &lt;a href=&quot;sys#sys.builtin_module_names&quot;&gt;&lt;code&gt;sys.builtin_module_names&lt;/code&gt;&lt;/a&gt;. This class implements the &lt;a href=&quot;#importlib.abc.MetaPathFinder&quot;&gt;&lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#importlib.abc.InspectLoader&quot;&gt;&lt;code&gt;importlib.abc.InspectLoader&lt;/code&gt;&lt;/a&gt; ABCs.</source>
          <target state="translated">내장 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-importer&quot;&gt;수입 업체&lt;/a&gt; . 알려진 모든 내장 모듈은 &lt;a href=&quot;sys#sys.builtin_module_names&quot;&gt; &lt;code&gt;sys.builtin_module_names&lt;/code&gt; 에&lt;/a&gt; 나열되어 있습니다 . 이 클래스는 &lt;a href=&quot;#importlib.abc.MetaPathFinder&quot;&gt; &lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#importlib.abc.InspectLoader&quot;&gt; &lt;code&gt;importlib.abc.InspectLoader&lt;/code&gt; &lt;/a&gt; ABC를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d3c626fb55d328c4d6e0b42ec6745a070458977c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-importer&quot;&gt;importer&lt;/a&gt; for frozen modules. This class implements the &lt;a href=&quot;#importlib.abc.MetaPathFinder&quot;&gt;&lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#importlib.abc.InspectLoader&quot;&gt;&lt;code&gt;importlib.abc.InspectLoader&lt;/code&gt;&lt;/a&gt; ABCs.</source>
          <target state="translated">고정 된 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-importer&quot;&gt;수입 업체&lt;/a&gt; . 이 클래스는 &lt;a href=&quot;#importlib.abc.MetaPathFinder&quot;&gt; &lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#importlib.abc.InspectLoader&quot;&gt; &lt;code&gt;importlib.abc.InspectLoader&lt;/code&gt; &lt;/a&gt; ABC를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="5ba830af2baa220c63058bd688a4c963ad3b97c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#async-context-managers&quot;&gt;asynchronous context manager&lt;/a&gt;, similar to &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt;, that supports combining both synchronous and asynchronous context managers, as well as having coroutines for cleanup logic.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#async-context-managers&quot;&gt;비동기 콘텍스트 관리자&lt;/a&gt; 와 유사 &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 지원 동기 및 비동기 콘텍스트 관리자뿐만 아니라 정리 로직 갖는 코 루틴 모두를 조합 한 것이다.</target>
        </trans-unit>
        <trans-unit id="4b1e4da468b2701c8321a708c9ecb7fa13e7e244" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_algorithms#Examples&quot;&gt;LRU (least recently used) cache&lt;/a&gt; works best when the most recent calls are the best predictors of upcoming calls (for example, the most popular articles on a news server tend to change each day). The cache&amp;rsquo;s size limit assures that the cache does not grow without bound on long-running processes such as web servers.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_algorithms#Examples&quot;&gt;(적어도 최근에 사용한) LRU 캐시는&lt;/a&gt; 가장 최근의 호출이 곧 전화의 가장 좋은 예측 인자가있을 때 가장 잘 작동합니다 (예를 들어, 뉴스 서버에서 가장 인기있는 기사는 매일 변경하는 경향이있다). 캐시의 크기 제한은 웹 서버와 같은 장기 실행 프로세스에 제한없이 캐시가 커지지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="3761bc9891cb807e2bd71dcdb229acbbbd262ea3" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt; input stream, ready to read from the start of the optional input data.</source>
          <target state="translated">선택적 입력 데이터의 시작부터 읽을 준비가 된 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 입력 스트림.</target>
        </trans-unit>
        <trans-unit id="134b8c5f8672fe5893203afb4343e752db19a0c9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;'AF_INET'&lt;/code&gt; address is a tuple of the form &lt;code&gt;(hostname, port)&lt;/code&gt; where &lt;em&gt;hostname&lt;/em&gt; is a string and &lt;em&gt;port&lt;/em&gt; is an integer.</source>
          <target state="translated">&lt;code&gt;'AF_INET'&lt;/code&gt; 주소 형태의 튜플 &lt;code&gt;(hostname, port)&lt;/code&gt; &lt;em&gt;호스트는&lt;/em&gt; 문자열이며 &lt;em&gt;포트&lt;/em&gt; 정수이다.</target>
        </trans-unit>
        <trans-unit id="728c7bfe4ba1acdb2c72fa346ca49007566679c3" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;'AF_UNIX'&lt;/code&gt; address is a string representing a filename on the filesystem.</source>
          <target state="translated">&lt;code&gt;'AF_UNIX'&lt;/code&gt; 주소는 파일 시스템에서 파일 이름을 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="279c56929f7657d41eb016d797accbea5fc43126" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;HTTPError&lt;/code&gt; exception raised as a security consideration if the HTTPRedirectHandler is presented with a redirected URL which is not an HTTP, HTTPS or FTP URL.</source>
          <target state="translated">&lt;code&gt;HTTPError&lt;/code&gt; 의 보안 고려 사항으로 제기 예외는 HTTPRedirectHandler 경우 HTTP, HTTPS 또는 FTP URL이 아닌 리디렉션 된 URL로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3fcacb835ee81a42ed8d1456cd79b0226a380e" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;http.client.HTTPMessage&lt;/code&gt; instance holds the headers from an HTTP response. It is implemented using the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;code&gt;http.client.HTTPMessage&lt;/code&gt; 의 인스턴스는 HTTP 응답의 헤더를 보유하고 있습니다. &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="e64e19d30a6b038f871b1a0ba266542e0cf44731" translate="yes" xml:space="preserve">
          <source>An ABC with one abstract method &lt;code&gt;__abs__&lt;/code&gt; that is covariant in its return type.</source>
          <target state="translated">리턴 유형이 공변 인 인 하나의 추상 메소드 &lt;code&gt;__abs__&lt;/code&gt; 를 가진 ABC .</target>
        </trans-unit>
        <trans-unit id="d1781ec94a5b61e39438eca65acc12f99677f117" translate="yes" xml:space="preserve">
          <source>An ABC with one abstract method &lt;code&gt;__bytes__&lt;/code&gt;.</source>
          <target state="translated">하나의 추상 메소드를 가진 ABC &lt;code&gt;__bytes__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0fc1ecd30f8b9047835f4fbca4de0c1a7114ddd" translate="yes" xml:space="preserve">
          <source>An ABC with one abstract method &lt;code&gt;__complex__&lt;/code&gt;.</source>
          <target state="translated">하나의 추상 메소드를 가진 ABC &lt;code&gt;__complex__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc0d8a21ea5d1cfd983b9cd9cc3577a029a5d40" translate="yes" xml:space="preserve">
          <source>An ABC with one abstract method &lt;code&gt;__float__&lt;/code&gt;.</source>
          <target state="translated">하나의 추상 메소드를 가진 ABC &lt;code&gt;__float__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a96e7a759cdcee0e8a671529f6684f0284b3c73" translate="yes" xml:space="preserve">
          <source>An ABC with one abstract method &lt;code&gt;__index__&lt;/code&gt;.</source>
          <target state="translated">하나의 추상 메소드를 가진 ABC &lt;code&gt;__index__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79db425b6df47a0eb8f4b913a4b8f04661c96e98" translate="yes" xml:space="preserve">
          <source>An ABC with one abstract method &lt;code&gt;__int__&lt;/code&gt;.</source>
          <target state="translated">하나의 추상 메소드를 가진 ABC &lt;code&gt;__int__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15ea43b80301cadc8e24d4d28cf8330de4a4c022" translate="yes" xml:space="preserve">
          <source>An ABC with one abstract method &lt;code&gt;__round__&lt;/code&gt; that is covariant in its return type.</source>
          <target state="translated">리턴 유형이 공변 인 추상 메소드 &lt;code&gt;__round__&lt;/code&gt; 가 있는 ABC입니다 .</target>
        </trans-unit>
        <trans-unit id="d47c45aeccb0981a58aa461b9dad821d712d95bc" translate="yes" xml:space="preserve">
          <source>An Event object manages an internal flag that can be set to &lt;em&gt;true&lt;/em&gt; with the &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; method and reset to &lt;em&gt;false&lt;/em&gt; with the &lt;a href=&quot;#asyncio.Event.clear&quot;&gt;&lt;code&gt;clear()&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;asyncio-task#asyncio.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method blocks until the flag is set to &lt;em&gt;true&lt;/em&gt;. The flag is set to &lt;em&gt;false&lt;/em&gt; initially.</source>
          <target state="translated">Event 객체는 &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 메서드 로 &lt;em&gt;true&lt;/em&gt; 로 설정 하고 &lt;a href=&quot;#asyncio.Event.clear&quot;&gt; &lt;code&gt;clear()&lt;/code&gt; &lt;/a&gt; 메서드 로 &lt;em&gt;false&lt;/em&gt; 로 재설정 할 수있는 내부 플래그를 관리합니다 . &lt;a href=&quot;asyncio-task#asyncio.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 플래그까지 방법을 블록으로 설정되어 &lt;em&gt;사실&lt;/em&gt; . 플래그는 처음 에 &lt;em&gt;false&lt;/em&gt; 로 설정됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33c1328176988806c7acc0aff05cc07892efc2ee" translate="yes" xml:space="preserve">
          <source>An HMAC object has the following methods:</source>
          <target state="translated">HMAC 객체에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="96ce959eac9c1efc4346b40a6c2b0fcdb09eb53b" translate="yes" xml:space="preserve">
          <source>An HTTP Extension Framework &lt;a href=&quot;https://tools.ietf.org/html/rfc2774.html&quot; id=&quot;index-58&quot;&gt;&lt;strong&gt;RFC 2774&lt;/strong&gt;&lt;/a&gt;, Section 7 (Experimental)</source>
          <target state="translated">HTTP 확장 프레임 워크 &lt;a href=&quot;https://tools.ietf.org/html/rfc2774.html&quot; id=&quot;index-58&quot;&gt;&lt;strong&gt;RFC 2774&lt;/strong&gt;&lt;/a&gt; , 섹션 7 (실험적)</target>
        </trans-unit>
        <trans-unit id="586cd579fe48ea0181edb6aee914365f538aa9a9" translate="yes" xml:space="preserve">
          <source>An HTTP Status Code to Report Legal Obstacles &lt;a href=&quot;https://tools.ietf.org/html/rfc7725.html&quot; id=&quot;index-48&quot;&gt;&lt;strong&gt;RFC 7725&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">법적 장애 &lt;a href=&quot;https://tools.ietf.org/html/rfc7725.html&quot; id=&quot;index-48&quot;&gt;&lt;strong&gt;RFC 7725&lt;/strong&gt;&lt;/a&gt; 를보고하기위한 HTTP 상태 코드&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="950ad3d1cdc9b45ddd459fc6e7dc06daf0425f0b" translate="yes" xml:space="preserve">
          <source>An HTTP status code as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt;. This numeric value corresponds to a value found in the dictionary of codes as found in &lt;a href=&quot;http.server#http.server.BaseHTTPRequestHandler.responses&quot;&gt;&lt;code&gt;http.server.BaseHTTPRequestHandler.responses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2616에&lt;/strong&gt;&lt;/a&gt; 정의 된 HTTP 상태 코드 입니다. 이 숫자 값은 &lt;a href=&quot;http.server#http.server.BaseHTTPRequestHandler.responses&quot;&gt; &lt;code&gt;http.server.BaseHTTPRequestHandler.responses&lt;/code&gt; &lt;/a&gt; 에있는 코드 사전에서 찾은 값에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="0fd6615738f7a41f38401d20b6960d63cc413cb5" translate="yes" xml:space="preserve">
          <source>An SSL context holds various data longer-lived than single SSL connections, such as SSL configuration options, certificate(s) and private key(s). It also manages a cache of SSL sessions for server-side sockets, in order to speed up repeated connections from the same clients.</source>
          <target state="translated">SSL 컨텍스트는 SSL 구성 옵션, 인증서 및 개인 키와 같은 단일 SSL 연결보다 수명이 긴 다양한 데이터를 보유합니다. 또한 동일한 클라이언트의 반복 연결 속도를 높이기 위해 서버 측 소켓에 대한 SSL 세션 캐시를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="76cf9150b9af7f68ed4e620f15b7b416606b07f7" translate="yes" xml:space="preserve">
          <source>An SSLObject communicates with the outside world using memory buffers. The class &lt;a href=&quot;#ssl.MemoryBIO&quot;&gt;&lt;code&gt;MemoryBIO&lt;/code&gt;&lt;/a&gt; provides a memory buffer that can be used for this purpose. It wraps an OpenSSL memory BIO (Basic IO) object:</source>
          <target state="translated">SSLObject는 메모리 버퍼를 사용하여 외부와 통신합니다. &lt;a href=&quot;#ssl.MemoryBIO&quot;&gt; &lt;code&gt;MemoryBIO&lt;/code&gt; &lt;/a&gt; 클래스 는이 용도로 사용할 수있는 메모리 버퍼를 제공합니다. OpenSSL 메모리 BIO (기본 IO) 오브젝트를 랩핑합니다.</target>
        </trans-unit>
        <trans-unit id="a466897649a3d651921f5fa00e86176f05ce65c2" translate="yes" xml:space="preserve">
          <source>An XML declaration was found somewhere other than the start of the input data.</source>
          <target state="translated">입력 데이터의 시작 이외의 XML 선언이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f6e529d041ed7501f54f3d2eb8b240dc32017aa" translate="yes" xml:space="preserve">
          <source>An abbreviation for &amp;ldquo;derive window&amp;rdquo;, &lt;a href=&quot;#curses.window.derwin&quot;&gt;&lt;code&gt;derwin()&lt;/code&gt;&lt;/a&gt; is the same as calling &lt;a href=&quot;#curses.window.subwin&quot;&gt;&lt;code&gt;subwin()&lt;/code&gt;&lt;/a&gt;, except that &lt;em&gt;begin_y&lt;/em&gt; and &lt;em&gt;begin_x&lt;/em&gt; are relative to the origin of the window, rather than relative to the entire screen. Return a window object for the derived window.</source>
          <target state="translated">&amp;ldquo;derive window&amp;rdquo;의 약자 인 &lt;a href=&quot;#curses.window.derwin&quot;&gt; &lt;code&gt;derwin()&lt;/code&gt; &lt;/a&gt; 은 &lt;em&gt;begin_y&lt;/em&gt; 및 &lt;em&gt;begin_x&lt;/em&gt; 가 전체 화면이 아니라 창의 원점에 상대적 이라는 점을 제외하고 &lt;a href=&quot;#curses.window.subwin&quot;&gt; &lt;code&gt;subwin()&lt;/code&gt; &lt;/a&gt; 호출과 동일 합니다. 파생 된 창의 창 개체를 반환합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e10c1add34316ae69c55a9723388948395613133" translate="yes" xml:space="preserve">
          <source>An abstract base class for a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; which implements the optional &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; protocol for loading arbitrary resources from the storage back-end.</source>
          <target state="translated">스토리지 백엔드에서 임의의 리소스를로드하기위한 선택적 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 프로토콜을 구현 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 의 추상 기본 클래스입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c00c78ac6821af3449c4a38de1c0d33c74f95d2" translate="yes" xml:space="preserve">
          <source>An abstract base class for a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; which implements the optional &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; protocol for loaders that inspect modules.</source>
          <target state="translated">모듈을 검사 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 를위한 선택적 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 프로토콜을 구현 하는 로더 의 추상 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="940dc0b3afc6e45c33bbd105502b6ee876696cec" translate="yes" xml:space="preserve">
          <source>An abstract base class for a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt;. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; for the exact definition for a loader.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 의 추상 기본 클래스입니다 . 로더에 대한 정확한 정의는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0db9b27bf89080da856677605e14657460be5647" translate="yes" xml:space="preserve">
          <source>An abstract base class for asyncio policies.</source>
          <target state="translated">비동기 정책에 대한 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b462ad15f20b8da0d5b31b0986af332c0c7b0e96" translate="yes" xml:space="preserve">
          <source>An abstract base class for implementing source (and optionally bytecode) file loading. The class inherits from both &lt;a href=&quot;#importlib.abc.ResourceLoader&quot;&gt;&lt;code&gt;ResourceLoader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#importlib.abc.ExecutionLoader&quot;&gt;&lt;code&gt;ExecutionLoader&lt;/code&gt;&lt;/a&gt;, requiring the implementation of:</source>
          <target state="translated">소스 (및 선택적으로 바이트 코드) 파일로드를 구현하기위한 추상 기본 클래스입니다. 이 클래스는 &lt;a href=&quot;#importlib.abc.ResourceLoader&quot;&gt; &lt;code&gt;ResourceLoader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#importlib.abc.ExecutionLoader&quot;&gt; &lt;code&gt;ExecutionLoader&lt;/code&gt; &lt;/a&gt; 모두에서 상속되며 다음을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="2021dfdbcfaef781d0d06f712def8d7955c0628e" translate="yes" xml:space="preserve">
          <source>An abstract base class for time zone information objects. These are used by the &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; classes to provide a customizable notion of time adjustment (for example, to account for time zone and/or daylight saving time).</source>
          <target state="translated">시간대 정보 객체에 대한 추상 기본 클래스입니다. 이들은 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 클래스에서 사용자 정의 가능한 시간 조정 개념을 제공하기 위해 사용됩니다 (예 : 시간대 및 / 또는 일광 절약 시간을 고려하기 위해).</target>
        </trans-unit>
        <trans-unit id="41c1eeca19930aa837c9177b8ebdce0b081bc67f" translate="yes" xml:space="preserve">
          <source>An abstract base class representing a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;파인더를&lt;/a&gt; 나타내는 추상 기본 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="cfd3e5d07b9f0593a253ce92bd9938e6c4961954" translate="yes" xml:space="preserve">
          <source>An abstract base class representing a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-meta-path-finder&quot;&gt;meta path finder&lt;/a&gt;. For compatibility, this is a subclass of &lt;a href=&quot;#importlib.abc.Finder&quot;&gt;&lt;code&gt;Finder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-meta-path-finder&quot;&gt;메타 패스 파인더를&lt;/a&gt; 나타내는 추상 기본 클래스 입니다. 호환성을 위해 이것은 &lt;a href=&quot;#importlib.abc.Finder&quot;&gt; &lt;code&gt;Finder&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="a589cb6dfdfee9aae19397d6a303891c9da74964" translate="yes" xml:space="preserve">
          <source>An abstract base class representing a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry-finder&quot;&gt;path entry finder&lt;/a&gt;. Though it bears some similarities to &lt;a href=&quot;#importlib.abc.MetaPathFinder&quot;&gt;&lt;code&gt;MetaPathFinder&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PathEntryFinder&lt;/code&gt; is meant for use only within the path-based import subsystem provided by &lt;code&gt;PathFinder&lt;/code&gt;. This ABC is a subclass of &lt;a href=&quot;#importlib.abc.Finder&quot;&gt;&lt;code&gt;Finder&lt;/code&gt;&lt;/a&gt; for compatibility reasons only.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry-finder&quot;&gt;경로 엔트리 파인더를&lt;/a&gt; 나타내는 추상 기본 클래스 입니다. &lt;a href=&quot;#importlib.abc.MetaPathFinder&quot;&gt; &lt;code&gt;MetaPathFinder&lt;/code&gt; &lt;/a&gt; 와 약간 유사하지만 &lt;code&gt;PathEntryFinder&lt;/code&gt; 는 &lt;code&gt;PathFinder&lt;/code&gt; 가 제공하는 경로 기반 가져 오기 서브 시스템 내에서만 사용하도록되어 있습니다 . 이 ABC는 호환성을 위해서만 &lt;a href=&quot;#importlib.abc.Finder&quot;&gt; &lt;code&gt;Finder&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="8a9af4121f78134bb685216fbf44bd4f5d826951" translate="yes" xml:space="preserve">
          <source>An abstract base class which inherits from &lt;a href=&quot;#importlib.abc.InspectLoader&quot;&gt;&lt;code&gt;InspectLoader&lt;/code&gt;&lt;/a&gt; that, when implemented, helps a module to be executed as a script. The ABC represents an optional &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">구현시 모듈이 스크립트로 실행되도록 도와주는 &lt;a href=&quot;#importlib.abc.InspectLoader&quot;&gt; &lt;code&gt;InspectLoader&lt;/code&gt; &lt;/a&gt; 에서 상속되는 추상 기본 클래스입니다 . ABC는 선택적인 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 프로토콜을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="11de885f0ab5a2d6a8da413f025f1f42a92914a8" translate="yes" xml:space="preserve">
          <source>An abstract base class which inherits from &lt;a href=&quot;#importlib.abc.ResourceLoader&quot;&gt;&lt;code&gt;ResourceLoader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#importlib.abc.ExecutionLoader&quot;&gt;&lt;code&gt;ExecutionLoader&lt;/code&gt;&lt;/a&gt;, providing concrete implementations of &lt;a href=&quot;#importlib.abc.ResourceLoader.get_data&quot;&gt;&lt;code&gt;ResourceLoader.get_data()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#importlib.abc.ExecutionLoader.get_filename&quot;&gt;&lt;code&gt;ExecutionLoader.get_filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#importlib.abc.ResourceLoader.get_data&quot;&gt; &lt;code&gt;ResourceLoader.get_data()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#importlib.abc.ExecutionLoader.get_filename&quot;&gt; &lt;code&gt;ExecutionLoader.get_filename()&lt;/code&gt; &lt;/a&gt; 의 구체적인 구현을 제공하는 &lt;a href=&quot;#importlib.abc.ResourceLoader&quot;&gt; &lt;code&gt;ResourceLoader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#importlib.abc.ExecutionLoader&quot;&gt; &lt;code&gt;ExecutionLoader&lt;/code&gt; &lt;/a&gt; 에서 상속되는 추상 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="955770255554b096c2a2d0d00989cc8cb2114744" translate="yes" xml:space="preserve">
          <source>An abstract class that provides methods to execute calls asynchronously. It should not be used directly, but through its concrete subclasses.</source>
          <target state="translated">비동기 적으로 호출을 실행하는 메소드를 제공하는 추상 클래스입니다. 직접 사용하지 말고 구체적인 하위 클래스를 통해 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f134861215475c0febc28a88cff9f900d434fd5d" translate="yes" xml:space="preserve">
          <source>An abstract example would be the following to ensure correct resource management:</source>
          <target state="translated">올바른 자원 관리를 보장하기위한 추상 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c833ccaac11f4d73ed6358d2404695fb39851cf" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; for the specified module. Originally specified in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;, this method was meant for use in &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt; and in the path-based import subsystem.</source>
          <target state="translated">지정된 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 를 찾는 추상적 인 방법입니다 . 원래 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 302에&lt;/strong&gt;&lt;/a&gt; 지정된 이 방법은 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; 및 경로 기반 가져 오기 하위 시스템에서 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b301e64f6be02c979b39c0a7f2f8742151baec4c" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;spec&lt;/a&gt; for the specified module. If this is a top-level import, &lt;em&gt;path&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;. Otherwise, this is a search for a subpackage or module and &lt;em&gt;path&lt;/em&gt; will be the value of &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt;&lt;code&gt;__path__&lt;/code&gt;&lt;/a&gt; from the parent package. If a spec cannot be found, &lt;code&gt;None&lt;/code&gt; is returned. When passed in, &lt;code&gt;target&lt;/code&gt; is a module object that the finder may use to make a more educated guess about what spec to return. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt;&lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt;&lt;/a&gt; may be useful for implementing concrete &lt;code&gt;MetaPathFinders&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;스펙&lt;/a&gt; 을 찾는 추상적 인 방법입니다 . 이것이 최상위 레벨 임포트 인 경우 &lt;em&gt;path&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 입니다. 그렇지 않으면 하위 패키지 또는 모듈을 검색하며 &lt;em&gt;경로&lt;/em&gt; 는 상위 패키지 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt; &lt;code&gt;__path__&lt;/code&gt; &lt;/a&gt; 값입니다 . 스펙을 찾을 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다. 전달되면 &lt;code&gt;target&lt;/code&gt; 은 파인더가 어떤 스펙을 반환할지에 대해 더 잘 추측 할 수있는 모듈 객체입니다. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt; &lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt; &lt;/a&gt; 는 구체적인 &lt;code&gt;MetaPathFinders&lt;/code&gt; 를 구현하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd63589c5c5bc876ea90a7b05def4d9308abd0ce" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;spec&lt;/a&gt; for the specified module. The finder will search for the module only within the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry&quot;&gt;path entry&lt;/a&gt; to which it is assigned. If a spec cannot be found, &lt;code&gt;None&lt;/code&gt; is returned. When passed in, &lt;code&gt;target&lt;/code&gt; is a module object that the finder may use to make a more educated guess about what spec to return. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt;&lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt;&lt;/a&gt; may be useful for implementing concrete &lt;code&gt;PathEntryFinders&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;스펙&lt;/a&gt; 을 찾는 추상적 인 방법입니다 . 파인더 는 지정된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry&quot;&gt;경로 항목&lt;/a&gt; 내에서만 모듈을 검색합니다 . 스펙을 찾을 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다. 전달 될 때 &lt;code&gt;target&lt;/code&gt; 은 파인더가 반환 할 스펙에 대해보다 잘 추측 할 수있는 모듈 객체입니다. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt; &lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt; &lt;/a&gt; 는 구체적인 &lt;code&gt;PathEntryFinders&lt;/code&gt; 구현에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b518cc20074a6e012522371b44d4863fba9c6708" translate="yes" xml:space="preserve">
          <source>An abstract method that executes the module in its own namespace when a module is imported or reloaded. The module should already be initialized when &lt;code&gt;exec_module()&lt;/code&gt; is called. When this method exists, &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;create_module()&lt;/code&gt;&lt;/a&gt; must be defined.</source>
          <target state="translated">모듈을 가져 오거나 다시로드 할 때 자체 네임 스페이스에서 모듈을 실행하는 추상 메서드입니다. &lt;code&gt;exec_module()&lt;/code&gt; 을 호출 할 때 모듈이 이미 초기화되어 있어야합니다 . 이 메소드가 존재하면 &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;create_module()&lt;/code&gt; &lt;/a&gt; 을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6bf9688b7b004247ae61425719c8753e917df0c" translate="yes" xml:space="preserve">
          <source>An abstract method that is to return the value of &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt;&lt;code&gt;__file__&lt;/code&gt;&lt;/a&gt; for the specified module. If no path is available, &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 모듈에 대한 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt; &lt;code&gt;__file__&lt;/code&gt; &lt;/a&gt; 값을 반환하는 추상 메서드입니다 . 사용 가능한 경로가 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9546a7a2c25822b3aefc76fd55131bcac817f789" translate="yes" xml:space="preserve">
          <source>An abstract method to return a true value if the module is a package, a false value otherwise. &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised if the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; cannot find the module.</source>
          <target state="translated">모듈이 패키지이면 true 값을 반환하고 그렇지 않으면 false 값을 반환하는 추상 메서드입니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 가 모듈을 찾을 수 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="800c0095cbad1a18da2d314befc33c5c39978794" translate="yes" xml:space="preserve">
          <source>An abstract method to return the bytes for the data located at &lt;em&gt;path&lt;/em&gt;. Loaders that have a file-like storage back-end that allows storing arbitrary data can implement this abstract method to give direct access to the data stored. &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is to be raised if the &lt;em&gt;path&lt;/em&gt; cannot be found. The &lt;em&gt;path&lt;/em&gt; is expected to be constructed using a module&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt;&lt;code&gt;__file__&lt;/code&gt;&lt;/a&gt; attribute or an item from a package&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt;&lt;code&gt;__path__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 에 위치한 데이터의 바이트를 반환하는 추상 메소드 입니다. 임의의 데이터를 저장할 수있는 파일과 같은 스토리지 백엔드가있는 로더는이 추상 메소드를 구현하여 저장된 데이터에 직접 액세스 할 수 있습니다. &lt;em&gt;경로&lt;/em&gt; 를 찾을 수 없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . &lt;em&gt;경로는&lt;/em&gt; 모듈의 사용하여 구성 될 것으로 예상된다 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt; &lt;code&gt;__file__&lt;/code&gt; 의&lt;/a&gt; 속성 또는 패키지의에서 항목 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt; &lt;code&gt;__path__&lt;/code&gt; 을&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="563d61fc457a3bfb950c5833afc59f047a9c4836" translate="yes" xml:space="preserve">
          <source>An abstract method to return the source of a module. It is returned as a text string using &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt;, translating all recognized line separators into &lt;code&gt;'\n'&lt;/code&gt; characters. Returns &lt;code&gt;None&lt;/code&gt; if no source is available (e.g. a built-in module). Raises &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; if the loader cannot find the module specified.</source>
          <target state="translated">모듈의 소스를 돌려주는 추상 메소드. 인식되는 모든 줄 구분 기호를 &lt;code&gt;'\n'&lt;/code&gt; 문자 로 변환 하여 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용&lt;/a&gt; 줄 바꾸기를 사용하여 텍스트 문자열로 반환됩니다 . 사용 가능한 소스가없는 경우 (예 : 내장 모듈) &lt;code&gt;None&lt;/code&gt; 반환 합니다. 발생시킵니다 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를이&lt;/a&gt; 로더가 지정된 모듈을 찾을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="9ce1167dff3e80e3af3cc98084356e72a0bd3a36" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree can be generated by passing &lt;code&gt;ast.PyCF_ONLY_AST&lt;/code&gt; as a flag to the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; built-in function, or using the &lt;a href=&quot;#ast.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; helper provided in this module. The result will be a tree of objects whose classes all inherit from &lt;a href=&quot;#ast.AST&quot;&gt;&lt;code&gt;ast.AST&lt;/code&gt;&lt;/a&gt;. An abstract syntax tree can be compiled into a Python code object using the built-in &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;ast.PyCF_ONLY_AST&lt;/code&gt; 를 플래그로 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 내장 함수 에 전달 하거나이 모듈에 제공된 &lt;a href=&quot;#ast.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 도우미를 사용하여 추상 구문 트리를 생성 할 수 있습니다 . 결과는 클래스가 모두 &lt;a href=&quot;#ast.AST&quot;&gt; &lt;code&gt;ast.AST&lt;/code&gt; &lt;/a&gt; 에서 상속되는 객체 트리가됩니다 . 내장 된 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 추상 구문 트리를 Python 코드 객체로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70da3ef21c99fc01e1c391e4ec0a45bb54025f8a" translate="yes" xml:space="preserve">
          <source>An abstraction of a pipeline.</source>
          <target state="translated">파이프 라인의 추상화.</target>
        </trans-unit>
        <trans-unit id="2b4487c478caae94a1d2a055c39dc744680ef17b" translate="yes" xml:space="preserve">
          <source>An abstraction to represent a connection between a parent and its child OS process.</source>
          <target state="translated">부모와 자식 OS 프로세스 간의 연결을 나타내는 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="70554b33f749f867144e33b7010322e8a2d9c2f6" translate="yes" xml:space="preserve">
          <source>An additional example of normalization:</source>
          <target state="translated">정규화의 추가 예 :</target>
        </trans-unit>
        <trans-unit id="1f8b93a1b318ef3b489264436cd2920634f37e5c" translate="yes" xml:space="preserve">
          <source>An additional section describes the exceptions defined for working with the DOM in Python.</source>
          <target state="translated">추가 섹션에서는 Python에서 DOM 작업을 위해 정의 된 예외에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7de5be9d95857a8f7fae738465f4f7a4ecbfe0bd" translate="yes" xml:space="preserve">
          <source>An additional utility function is provided to convert a file&amp;rsquo;s mode in a human readable string:</source>
          <target state="translated">사람이 읽을 수있는 문자열로 파일 모드를 변환하기위한 추가 유틸리티 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b4bc718c3660ae312ee29fc3f760532b2ef990dd" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#ssl.SSLCertVerificationError&quot;&gt;&lt;code&gt;SSLCertVerificationError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLCertVerificationError&quot;&gt; &lt;code&gt;SSLCertVerificationError&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="d8d058f0ff4ac1d3e35f124836eb7543d9d30422" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#tkinter.ttk.Treeview.move&quot;&gt;&lt;code&gt;Treeview.move()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#tkinter.ttk.Treeview.move&quot;&gt; &lt;code&gt;Treeview.move()&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="4f34bb1fd3121bf24f28736c112a6ea7ecb860b5" translate="yes" xml:space="preserve">
          <source>An alias for the built-in &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">내장 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외 의 별명 .</target>
        </trans-unit>
        <trans-unit id="ee952a3e338de8476144642c2ed1be940175b262" translate="yes" xml:space="preserve">
          <source>An alias to &lt;a href=&quot;collections.abc#collections.abc.Hashable&quot;&gt;&lt;code&gt;collections.abc.Hashable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;collections.abc#collections.abc.Hashable&quot;&gt; &lt;code&gt;collections.abc.Hashable&lt;/code&gt; &lt;/a&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="72cf7f2af19bdbb20c360e706340e6ea11885d97" translate="yes" xml:space="preserve">
          <source>An alias to &lt;a href=&quot;collections.abc#collections.abc.Sized&quot;&gt;&lt;code&gt;collections.abc.Sized&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;collections.abc#collections.abc.Sized&quot;&gt; &lt;code&gt;collections.abc.Sized&lt;/code&gt; &lt;/a&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="a63391b1faab340a2bb4934be82d08de2b51040f" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or &lt;code&gt;None&lt;/code&gt; if only one separator character exists. This is set to &lt;code&gt;'/'&lt;/code&gt; on Windows systems where &lt;code&gt;sep&lt;/code&gt; is a backslash. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로 이름 구성 요소를 분리하기 위해 운영 체제에서 사용하는 대체 문자이거나 하나의 분리 문자 만있는 경우 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;sep&lt;/code&gt; 가 백 슬래시 인 Windows 시스템에서는 &lt;code&gt;'/'&lt;/code&gt; 로 설정됩니다 . &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="a3d5b628a54d39bf8ee6093f8e0d37a9d4cee60c" translate="yes" xml:space="preserve">
          <source>An alternative dictionary type can be used for example to sort sections and options on write-back.</source>
          <target state="translated">대체 사전 유형을 사용하여 예를 들어 다시 쓸 때 섹션과 옵션을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d850059763c1f7e51f2d1d11cf0427ad5eded88" translate="yes" xml:space="preserve">
          <source>An alternative event loop policy that uses the &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; event loop implementation.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 이벤트 루프 구현 을 사용하는 대체 이벤트 루프 정책 .</target>
        </trans-unit>
        <trans-unit id="84083d9dc2f2455c7f8ae18733c112f9f4922f99" translate="yes" xml:space="preserve">
          <source>An alternative event loop policy that uses the &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; event loop implementation.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 이벤트 루프 구현 을 사용하는 대체 이벤트 루프 정책 .</target>
        </trans-unit>
        <trans-unit id="8fe9d34c1b43e8d3bc59379cabc74d88762dfb06" translate="yes" xml:space="preserve">
          <source>An alternative handler for interpolation which implements a more advanced syntax, used for instance in &lt;code&gt;zc.buildout&lt;/code&gt;. Extended interpolation is using &lt;code&gt;${section:option}&lt;/code&gt; to denote a value from a foreign section. Interpolation can span multiple levels. For convenience, if the &lt;code&gt;section:&lt;/code&gt; part is omitted, interpolation defaults to the current section (and possibly the default values from the special section).</source>
          <target state="translated">&lt;code&gt;zc.buildout&lt;/code&gt; 에서 사용되는 고급 구문을 구현하는 보간 용 대체 처리기입니다 . 확장 보간은 &lt;code&gt;${section:option}&lt;/code&gt; 을 사용하여 외부 섹션의 값을 나타냅니다. 보간은 여러 수준으로 확장 될 수 있습니다. 편의상 &lt;code&gt;section:&lt;/code&gt; part가 생략되면 보간은 현재 섹션 (및 가능하면 특수 섹션의 기본값)으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="558c117d3161559bd859666a91b9bb66c414c1f5" translate="yes" xml:space="preserve">
          <source>An alternative header can be specified in the &lt;em&gt;header&lt;/em&gt; argument. When the &lt;em&gt;Content-Type&lt;/em&gt; header is set a &lt;em&gt;MIME-Version&lt;/em&gt; header is also added.</source>
          <target state="translated">&lt;em&gt;헤더&lt;/em&gt; 인수 에 대체 헤더를 지정할 수 있습니다 . 경우 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더가 설정되어있는 &lt;em&gt;MIME-버전&lt;/em&gt; 헤더도 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ba665411f071ae5d955adbe5282d9694eae5c4" translate="yes" xml:space="preserve">
          <source>An alternative name can be specified with &lt;code&gt;metavar&lt;/code&gt;:</source>
          <target state="translated">대체 이름은 &lt;code&gt;metavar&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6416917ffae045c2865eba964ef88e695b8f701a" translate="yes" xml:space="preserve">
          <source>An alternative request handler class that makes use of streams (file-like objects that simplify communication by providing the standard file interface):</source>
          <target state="translated">스트림 (표준 파일 인터페이스를 제공하여 통신을 단순화하는 파일과 유사한 객체)을 사용하는 대체 요청 핸들러 클래스 :</target>
        </trans-unit>
        <trans-unit id="affd50cda4dcf68b768688e4f672192d92888ed0" translate="yes" xml:space="preserve">
          <source>An analogue of &lt;a href=&quot;threading#threading.current_thread&quot;&gt;&lt;code&gt;threading.current_thread()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;threading#threading.current_thread&quot;&gt; &lt;code&gt;threading.current_thread()&lt;/code&gt; &lt;/a&gt; 의 아날로그 .</target>
        </trans-unit>
        <trans-unit id="8e8b2aaa418b53858967709906f3a78f69197dab" translate="yes" xml:space="preserve">
          <source>An application which needs both ST and code objects can package this code into readily available functions:</source>
          <target state="translated">ST와 코드 객체를 모두 필요로하는 응용 프로그램은이 코드를 즉시 사용 가능한 기능으로 패키지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5a68e4a13d841bc92021b61944ccadf166e7e79" translate="yes" xml:space="preserve">
          <source>An appropriate &lt;code&gt;Content-Type&lt;/code&gt; header should be included if the &lt;em&gt;data&lt;/em&gt; argument is present. If this header has not been provided and &lt;em&gt;data&lt;/em&gt; is not None, &lt;code&gt;Content-Type: application/x-www-form-urlencoded&lt;/code&gt; will be added as a default.</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 인수가있는 경우 적절한 &lt;code&gt;Content-Type&lt;/code&gt; 헤더가 포함되어야합니다 . 이 헤더가 제공되지 않고 &lt;em&gt;데이터&lt;/em&gt; 가 없음이 아닌 경우 &lt;code&gt;Content-Type: application/x-www-form-urlencoded&lt;/code&gt; 가 기본값으로 추가됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c475a455c39ee03168c8c78b435dcd38ae70e3df" translate="yes" xml:space="preserve">
          <source>An argument for using the original mbox format rather than a variation.</source>
          <target state="translated">변형이 아닌 원래 mbox 형식을 사용하기위한 인수입니다.</target>
        </trans-unit>
        <trans-unit id="6ec278a245be82c537401d0aff88bd1ef6e21621" translate="yes" xml:space="preserve">
          <source>An array that represents the abbreviated days of the week in the current locale.</source>
          <target state="translated">현재 로케일에서 약식 요일을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2ba535593adca4dfcb800d6a4065c1b6b73e79fa" translate="yes" xml:space="preserve">
          <source>An array that represents the abbreviated months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and &lt;code&gt;month_abbr[0]&lt;/code&gt; is the empty string.</source>
          <target state="translated">현재 로캘에서 약식 월을 나타내는 배열입니다. 이는 1 월이 1 월의 일반적인 규칙을 따르므로 길이는 13이며 &lt;code&gt;month_abbr[0]&lt;/code&gt; 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fcf4961a8aabb7adc6bcd479568762d6de58a7a7" translate="yes" xml:space="preserve">
          <source>An array that represents the days of the week in the current locale.</source>
          <target state="translated">현재 로케일의 요일을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f186d41c71a389deb5bc2ad8c9d947ed1464a0a8" translate="yes" xml:space="preserve">
          <source>An array that represents the months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and &lt;code&gt;month_name[0]&lt;/code&gt; is the empty string.</source>
          <target state="translated">현재 로케일에서 한 달의 월을 나타내는 배열입니다. 이것은 1 월의 월 번호 1 인 일반적인 규칙을 따르므로 길이는 13이며 &lt;code&gt;month_name[0]&lt;/code&gt; 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2f78c0d8986a31d197009b378a1891659c6d5c40" translate="yes" xml:space="preserve">
          <source>An async generator can be annotated by the generic type &lt;code&gt;AsyncGenerator[YieldType, SendType]&lt;/code&gt;. For example:</source>
          <target state="translated">비동기 생성기는 일반 유형 &lt;code&gt;AsyncGenerator[YieldType, SendType]&lt;/code&gt; 로 주석을 달 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47a32ba6658f6bd3552449f82e57df961a67e806" translate="yes" xml:space="preserve">
          <source>An asynchronous version of &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt;&lt;code&gt;AsyncMock&lt;/code&gt;&lt;/a&gt; object will behave so the object is recognized as an async function, and the result of a call is an awaitable.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 . &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt; &lt;code&gt;AsyncMock&lt;/code&gt; 의&lt;/a&gt; 목적은 비동기 함수로서 인식되어 있고, 호출의 결과가 awaitable 정도로 개체 동작한다.</target>
        </trans-unit>
        <trans-unit id="1fdc0779a5b2419f946e9654c6370c12f380766a" translate="yes" xml:space="preserve">
          <source>An asyncio condition primitive can be used by a task to wait for some event to happen and then get exclusive access to a shared resource.</source>
          <target state="translated">asyncio condition 프리미티브는 작업에서 일부 이벤트가 발생할 때까지 기다린 다음 공유 리소스에 독점적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce693ef39f956e4dfceff810a01b25898982c4eb" translate="yes" xml:space="preserve">
          <source>An asyncio event can be used to notify multiple asyncio tasks that some event has happened.</source>
          <target state="translated">asyncio 이벤트는 여러 asyncio 작업에 일부 이벤트가 발생했음을 알리는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d221089bb63278ae2eac9dba4c559652680a0628" translate="yes" xml:space="preserve">
          <source>An asyncio lock can be used to guarantee exclusive access to a shared resource.</source>
          <target state="translated">공유 리소스에 대한 독점 액세스를 보장하기 위해 asyncio 잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8132e7095ff57a267c20149288415aebe2314d5" translate="yes" xml:space="preserve">
          <source>An attempt to resume the parser was made when the parser had not been suspended.</source>
          <target state="translated">파서가 일시 중지되지 않았을 때 파서를 다시 시작하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="06688b12c4727b91b1013a9b4b85afe3f1de51e7" translate="yes" xml:space="preserve">
          <source>An attribute value that must be a tuple listing valid path portions of the URL for receiving XML-RPC requests. Requests posted to other paths will result in a 404 &amp;ldquo;no such page&amp;rdquo; HTTP error. If this tuple is empty, all paths will be considered valid. The default value is &lt;code&gt;('/', '/RPC2')&lt;/code&gt;.</source>
          <target state="translated">XML-RPC 요청을 수신하기 위해 URL의 유효한 경로 부분을 나열하는 튜플이어야하는 속성 값입니다. 다른 경로에 게시 된 요청은 404 &quot;No such page&quot;HTTP 오류를 발생시킵니다. 이 튜플이 비어 있으면 모든 경로가 유효한 것으로 간주됩니다. 기본값은 &lt;code&gt;('/', '/RPC2')&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="247e09baf71df7f71e226b7096feb96275db6196" translate="yes" xml:space="preserve">
          <source>An attribute was used more than once in a start tag.</source>
          <target state="translated">시작 태그에서 속성이 두 번 이상 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="cca38611cc7b83df2236356ffa28d63d72e96458" translate="yes" xml:space="preserve">
          <source>An authentication key is a byte string which can be thought of as a password: once a connection is established both ends will demand proof that the other knows the authentication key. (Demonstrating that both ends are using the same key does &lt;strong&gt;not&lt;/strong&gt; involve sending the key over the connection.)</source>
          <target state="translated">인증 키는 암호로 생각할 수있는 바이트 문자열입니다. 일단 연결이 설정되면 양쪽 끝에 상대방이 인증 키를 알고 있다는 증거가 필요합니다. (두 끝이 같은 키를 사용하고 있음을 증명하는 것은 연결을 통해 키를 보내는 것을 포함 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .)</target>
        </trans-unit>
        <trans-unit id="c23b9bb5bd999d4e26c014cb734e6fa9c87b39aa" translate="yes" xml:space="preserve">
          <source>An email message consists of &lt;em&gt;headers&lt;/em&gt; and a &lt;em&gt;payload&lt;/em&gt; (which is also referred to as the &lt;em&gt;content&lt;/em&gt;). Headers are &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; style field names and values, where the field name and value are separated by a colon. The colon is not part of either the field name or the field value. The payload may be a simple text message, or a binary object, or a structured sequence of sub-messages each with their own set of headers and their own payload. The latter type of payload is indicated by the message having a MIME type such as &lt;em&gt;multipart/*&lt;/em&gt; or &lt;em&gt;message/rfc822&lt;/em&gt;.</source>
          <target state="translated">이메일 메시지는 &lt;em&gt;헤더&lt;/em&gt; 와 &lt;em&gt;페이로드&lt;/em&gt; ( &lt;em&gt;콘텐츠&lt;/em&gt; 라고도 함)로 &lt;em&gt;구성&lt;/em&gt; 됩니다. 헤더는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; 스타일 필드 이름 및 값이며 필드 이름과 값은 콜론으로 구분됩니다. 콜론은 필드 이름 또는 필드 값의 일부가 아닙니다. 페이로드는 간단한 문자 메시지 또는 이진 객체이거나 각각 고유 한 헤더 세트와 자체 페이로드가있는 구조화 된 하위 메시지 시퀀스 일 수 있습니다. 후자의 페이로드 유형은 &lt;em&gt;multipart / *&lt;/em&gt; 또는 &lt;em&gt;message / rfc822&lt;/em&gt; 와 같은 MIME 유형을 가진 메시지로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c372588e305c30fd92a3064303d38c2f969de76" translate="yes" xml:space="preserve">
          <source>An email message consists of &lt;em&gt;headers&lt;/em&gt; and a &lt;em&gt;payload&lt;/em&gt;. Headers must be &lt;a href=&quot;https://tools.ietf.org/html/rfc5233.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5233&lt;/strong&gt;&lt;/a&gt; style names and values, where the field name and value are separated by a colon. The colon is not part of either the field name or the field value. The payload may be a simple text message, or a binary object, or a structured sequence of sub-messages each with their own set of headers and their own payload. The latter type of payload is indicated by the message having a MIME type such as &lt;em&gt;multipart/*&lt;/em&gt; or &lt;em&gt;message/rfc822&lt;/em&gt;.</source>
          <target state="translated">이메일 메시지는 &lt;em&gt;헤더&lt;/em&gt; 와 &lt;em&gt;페이로드&lt;/em&gt; 로 구성됩니다 . 헤더는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5233.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5233&lt;/strong&gt;&lt;/a&gt; 스타일 이름과 값 이어야하며 필드 이름과 값은 콜론으로 구분됩니다. 콜론은 필드 이름 또는 필드 값의 일부가 아닙니다. 페이로드는 간단한 텍스트 메시지, 이진 객체 또는 각각 고유 한 헤더 세트와 자체 페이로드가있는 구조화 된 하위 메시지 시퀀스 일 수 있습니다. 후자의 페이로드 유형은 &lt;em&gt;multipart / *&lt;/em&gt; 또는 &lt;em&gt;message / rfc822&lt;/em&gt; 와 같은 MIME 유형을 가진 메시지로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9ac870ddd7b9cee7af970522ac0cb62cc665869" translate="yes" xml:space="preserve">
          <source>An empty string is returned if the value cannot be determined. Note that many platforms do not provide this information or simply return the same value as for &lt;a href=&quot;#platform.machine&quot;&gt;&lt;code&gt;machine()&lt;/code&gt;&lt;/a&gt;. NetBSD does this.</source>
          <target state="translated">값을 확인할 수 없으면 빈 문자열이 반환됩니다. 많은 플랫폼에서이 정보를 제공하지 않거나 단순히 &lt;a href=&quot;#platform.machine&quot;&gt; &lt;code&gt;machine()&lt;/code&gt; &lt;/a&gt; 과 동일한 값을 반환합니다 . NetBSD는 이것을합니다.</target>
        </trans-unit>
        <trans-unit id="0626a6597dc747aecf4b27d088ed3268190477de" translate="yes" xml:space="preserve">
          <source>An end tag did not match the innermost open start tag.</source>
          <target state="translated">종료 태그가 가장 안쪽에있는 시작 태그와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e204644cad08d09082fc0881f67657a40116f7c5" translate="yes" xml:space="preserve">
          <source>An end-of-file on input is passed back as the string &lt;code&gt;'EOF'&lt;/code&gt;.</source>
          <target state="translated">입력시 파일 끝은 문자열 &lt;code&gt;'EOF'&lt;/code&gt; 로 다시 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7b3b2a0614b25738aef986d351e59fa4b2b82de" translate="yes" xml:space="preserve">
          <source>An entity reference contained another reference to the same entity; possibly via a different name, and possibly indirectly.</source>
          <target state="translated">엔티티 참조는 동일한 엔티티에 대한 다른 참조를 포함합니다. 다른 이름을 통해 간접적으로 가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3703befccbd34b5b25cb780b7ad45fd641ab0fee" translate="yes" xml:space="preserve">
          <source>An entity reference in an attribute value referred to an external entity instead of an internal entity.</source>
          <target state="translated">속성 값의 엔티티 참조는 내부 엔티티 대신 외부 엔티티를 참조했습니다.</target>
        </trans-unit>
        <trans-unit id="3d37f6c8e1d729e4b74279866b363474e3ce5063" translate="yes" xml:space="preserve">
          <source>An entity reference referred to an entity which was declared with a notation, so cannot be parsed.</source>
          <target state="translated">엔티티 참조는 표기법으로 선언 된 엔티티를 참조하므로 구문 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35cf344fbad219897b2d51ae8eba44868eff1f92" translate="yes" xml:space="preserve">
          <source>An entry in a &lt;a href=&quot;#symtable.SymbolTable&quot;&gt;&lt;code&gt;SymbolTable&lt;/code&gt;&lt;/a&gt; corresponding to an identifier in the source. The constructor is not public.</source>
          <target state="translated">소스의 식별자에 해당 하는 &lt;a href=&quot;#symtable.SymbolTable&quot;&gt; &lt;code&gt;SymbolTable&lt;/code&gt; &lt;/a&gt; 의 항목입니다 . 생성자가 공개되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f406f6ad3dfbdd6e32c42a45910cc78a6fbc0eb9" translate="yes" xml:space="preserve">
          <source>An enumeration is a set of symbolic names (members) bound to unique, constant values. Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.</source>
          <target state="translated">열거 형은 고유 한 상수 값에 바인딩 된 일련의 기호 이름 (멤버)입니다. 열거 내에서 멤버를 ID별로 비교할 수 있으며 열거 자체를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ceb56cb5ae384a7c045483416aaaa181587fc4e" translate="yes" xml:space="preserve">
          <source>An enumeration of &lt;a href=&quot;#uuid.SafeUUID&quot;&gt;&lt;code&gt;SafeUUID&lt;/code&gt;&lt;/a&gt; which indicates whether the platform generated the UUID in a multiprocessing-safe way.</source>
          <target state="translated">플랫폼이 다중 처리 안전 방식으로 UUID를 생성했는지 여부를 나타내는 &lt;a href=&quot;#uuid.SafeUUID&quot;&gt; &lt;code&gt;SafeUUID&lt;/code&gt; &lt;/a&gt; 열거입니다 .</target>
        </trans-unit>
        <trans-unit id="191e9b46b39612e5a45fb6724e6abdd03694c710" translate="yes" xml:space="preserve">
          <source>An equality comparison between one &lt;code&gt;dict.values()&lt;/code&gt; view and another will always return &lt;code&gt;False&lt;/code&gt;. This also applies when comparing &lt;code&gt;dict.values()&lt;/code&gt; to itself:</source>
          <target state="translated">한 &lt;code&gt;dict.values()&lt;/code&gt; 뷰와 다른 dict.values ​​() 뷰 의 동등 비교 는 항상 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. &lt;code&gt;dict.values()&lt;/code&gt; 를 자체와 비교할 때도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a01448ba36fc6180ade36d1e4999112151667f7e" translate="yes" xml:space="preserve">
          <source>An error is produced for arguments that could produce more than one options. This feature can be disabled by setting &lt;a href=&quot;#allow-abbrev&quot;&gt;allow_abbrev&lt;/a&gt; to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">둘 이상의 옵션을 생성 할 수있는 인수에 대해 오류가 발생합니다. &lt;a href=&quot;#allow-abbrev&quot;&gt;allow_abbrev&lt;/a&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정 하면 이 기능을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dc2e93e3b7a317994b5c3eb2e52e7df07abc268" translate="yes" xml:space="preserve">
          <source>An error is returned whenever the resulting exponent is greater than &lt;code&gt;Emax&lt;/code&gt; or less than &lt;code&gt;Etiny&lt;/code&gt;.</source>
          <target state="translated">결과 지수가 &lt;code&gt;Emax&lt;/code&gt; 보다 크 거나 &lt;code&gt;Etiny&lt;/code&gt; 보다 작을 때마다 오류가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="516d3d6e48e258e621be2b2a76babfa7dc02e706" translate="yes" xml:space="preserve">
          <source>An error raised when a NIS function returns an error code.</source>
          <target state="translated">NIS 함수가 오류 코드를 리턴하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="58377c1e23ec237f7e5eaaef750df18f85b3cb45" translate="yes" xml:space="preserve">
          <source>An error raised when something is impossible because it violates the WAV specification or hits an implementation deficiency.</source>
          <target state="translated">WAV 사양을 위반하거나 구현 결함에 도달하여 불가능한 경우 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4593a10048262564ce6c822735e42f44f346b661" translate="yes" xml:space="preserve">
          <source>An event loop based on the &lt;a href=&quot;selectors#module-selectors&quot;&gt;&lt;code&gt;selectors&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;selectors#module-selectors&quot;&gt; &lt;code&gt;selectors&lt;/code&gt; &lt;/a&gt; 모듈을 기반으로하는 이벤트 루프 .</target>
        </trans-unit>
        <trans-unit id="f3adc0d9c6ca30e1ba3e56151e0bcf79cc795c22" translate="yes" xml:space="preserve">
          <source>An event loop for Windows that uses &amp;ldquo;I/O Completion Ports&amp;rdquo; (IOCP).</source>
          <target state="translated">&amp;ldquo;I / O 완료 포트&amp;rdquo;(IOCP)를 사용하는 Windows 용 이벤트 루프.</target>
        </trans-unit>
        <trans-unit id="fd91140b0fe187a666b9e9bf676cecb25b813937" translate="yes" xml:space="preserve">
          <source>An event loop policy is a global per-process object that controls the management of the event loop. Each event loop has a default policy, which can be changed and customized using the policy API.</source>
          <target state="translated">이벤트 루프 정책은 이벤트 루프 관리를 제어하는 ​​전역 프로세스 별 개체입니다. 각 이벤트 루프에는 기본 정책이 있으며 정책 API를 사용하여 변경하고 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e556041e787dfb19531ed6bea3ca88bb68687f" translate="yes" xml:space="preserve">
          <source>An event loop runs in a thread (typically the main thread) and executes all callbacks and Tasks in its thread. While a Task is running in the event loop, no other Tasks can run in the same thread. When a Task executes an &lt;code&gt;await&lt;/code&gt; expression, the running Task gets suspended, and the event loop executes the next Task.</source>
          <target state="translated">이벤트 루프는 스레드 (일반적으로 기본 스레드)에서 실행되며 스레드의 모든 콜백 및 작업을 실행합니다. 작업이 이벤트 루프에서 실행되는 동안 다른 작업은 동일한 스레드에서 실행할 수 없습니다. Task가 &lt;code&gt;await&lt;/code&gt; 식을 실행하면 실행중인 Task가 일시 중단되고 이벤트 루프가 다음 Task를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="608baac34ec6b479b1e075077346da843d886918" translate="yes" xml:space="preserve">
          <source>An event object manages an internal flag that can be set to true with the &lt;a href=&quot;#threading.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; method and reset to false with the &lt;a href=&quot;#threading.Event.clear&quot;&gt;&lt;code&gt;clear()&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;#threading.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method blocks until the flag is true.</source>
          <target state="translated">이벤트 객체는 &lt;a href=&quot;#threading.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 메서드 로 true로 설정 하고 &lt;a href=&quot;#threading.Event.clear&quot;&gt; &lt;code&gt;clear()&lt;/code&gt; &lt;/a&gt; 메서드 로 false로 재설정 할 수있는 내부 플래그를 관리합니다 . &lt;a href=&quot;#threading.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 플래그까지 방법 블록은 사실이다.</target>
        </trans-unit>
        <trans-unit id="9cf919b4535184a2bac9b21b394a3391ed3be52c" translate="yes" xml:space="preserve">
          <source>An event object.</source>
          <target state="translated">이벤트 객체.</target>
        </trans-unit>
        <trans-unit id="3197165a12532ea18a4db9c10db35c9e41c35331" translate="yes" xml:space="preserve">
          <source>An event object. Not thread-safe.</source>
          <target state="translated">이벤트 객체. 스레드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58be36b1fcb18ab8fd811be0960165993ee1b495" translate="yes" xml:space="preserve">
          <source>An example for &lt;a href=&quot;#csv.Sniffer&quot;&gt;&lt;code&gt;Sniffer&lt;/code&gt;&lt;/a&gt; use:</source>
          <target state="translated">&lt;a href=&quot;#csv.Sniffer&quot;&gt; &lt;code&gt;Sniffer&lt;/code&gt; &lt;/a&gt; 사용 예 :</target>
        </trans-unit>
        <trans-unit id="d24bd94253a9e026200e1be3ce54276cf7eb1d9f" translate="yes" xml:space="preserve">
          <source>An example for the &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">&lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt; 클래스 의 예 :</target>
        </trans-unit>
        <trans-unit id="2b1abaee744f811fdecf714da38ec6d05c1976f7" translate="yes" xml:space="preserve">
          <source>An example illustrating the order:</source>
          <target state="translated">순서를 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="71f4f4affa7b143203b514eaf53d7bbc4a253b38" translate="yes" xml:space="preserve">
          <source>An example may make it more understandable:</source>
          <target state="translated">예를 들어 이해하기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f80b147a88b6b8cb2d7f13419efc055fe8a5741d" translate="yes" xml:space="preserve">
          <source>An example of a callback displaying the current date every second. The callback uses the &lt;a href=&quot;#asyncio.loop.call_later&quot;&gt;&lt;code&gt;loop.call_later()&lt;/code&gt;&lt;/a&gt; method to reschedule itself after 5 seconds, and then stops the event loop:</source>
          <target state="translated">매초마다 현재 날짜를 표시하는 콜백의 예입니다. 콜백은 &lt;a href=&quot;#asyncio.loop.call_later&quot;&gt; &lt;code&gt;loop.call_later()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 5 초 후에 자체 일정을 조정 한 다음 이벤트 루프를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="11af1171f8dc0175c6f96364b3dfa7e2608ea195" translate="yes" xml:space="preserve">
          <source>An example of a context manager that returns a related object is the one returned by &lt;a href=&quot;decimal#decimal.localcontext&quot;&gt;&lt;code&gt;decimal.localcontext()&lt;/code&gt;&lt;/a&gt;. These managers set the active decimal context to a copy of the original decimal context and then return the copy. This allows changes to be made to the current decimal context in the body of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement without affecting code outside the &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">관련 객체를 반환하는 컨텍스트 관리자의 예는 &lt;a href=&quot;decimal#decimal.localcontext&quot;&gt; &lt;code&gt;decimal.localcontext()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 것 입니다. 이 관리자는 활성 10 진수 컨텍스트를 원래 10 진수 컨텍스트의 사본으로 설정 한 다음 사본을 리턴합니다. 이 변화가 본문에 현재의 진수 컨텍스트에 할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 외부 코드에 영향을주지 않고 문 &lt;code&gt;with&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="229e46ea428fdf9847aacb2de4467c37f32f31e2" translate="yes" xml:space="preserve">
          <source>An example of a context manager that returns itself is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. File objects return themselves from __enter__() to allow &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; to be used as the context expression in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">자체를 리턴하는 컨텍스트 관리자의 예는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 오브젝트&lt;/a&gt; 입니다. 파일 객체는 __enter __ ()에서 자신을 반환 하여 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 을 컨텍스트 표현식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a36c0094a4d20f58e22fab2dc6ea6b13c4064617" translate="yes" xml:space="preserve">
          <source>An example of a custom action:</source>
          <target state="translated">맞춤 작업의 예 :</target>
        </trans-unit>
        <trans-unit id="bd79d7fcb90941297a732fcb5d7d3317ee346397" translate="yes" xml:space="preserve">
          <source>An example of a mock that raises an exception (to test exception handling of an API):</source>
          <target state="translated">API의 예외 처리를 테스트하기 위해 예외를 발생시키는 모의 예 :</target>
        </trans-unit>
        <trans-unit id="16f4febaa13c59704ab69ba35886f8105bd56383" translate="yes" xml:space="preserve">
          <source>An example of a subprocess protocol used to get the output of a subprocess and to wait for the subprocess exit.</source>
          <target state="translated">하위 프로세스의 출력을 가져오고 하위 프로세스 종료를 기다리는 데 사용되는 하위 프로세스 프로토콜의 예입니다.</target>
        </trans-unit>
        <trans-unit id="359da9d396e7a3381bf357db2dce0ae96d67afdf" translate="yes" xml:space="preserve">
          <source>An example of dictionary view usage:</source>
          <target state="translated">사전보기 사용법의 예 :</target>
        </trans-unit>
        <trans-unit id="195305d65f73569e3259a2afbec9afedbef3ecc9" translate="yes" xml:space="preserve">
          <source>An example of extending &lt;code&gt;EnvBuilder&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EnvBuilder&lt;/code&gt; 확장의 예</target>
        </trans-unit>
        <trans-unit id="1081cc9057f681139574ba8aa1d51a1b7326375e" translate="yes" xml:space="preserve">
          <source>An example of reading the configuration file again:</source>
          <target state="translated">구성 파일을 다시 읽는 예 :</target>
        </trans-unit>
        <trans-unit id="a17cbc95ce9a012142cb3b9171e1c0a196a14699" translate="yes" xml:space="preserve">
          <source>An example of setting some log options, these would include the process ID in logged messages, and write the messages to the destination facility used for mail logging:</source>
          <target state="translated">일부 로그 옵션을 설정하는 예는 로깅 된 메시지의 프로세스 ID를 포함하고 메일 로깅에 사용되는 대상 기능에 메시지를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0fc1f9040cc5763e678640ef2363a997c9953de5" translate="yes" xml:space="preserve">
          <source>An example of the extended interface with non-ASCII characters:</source>
          <target state="translated">비 ASCII 문자로 확장 된 인터페이스의 예 :</target>
        </trans-unit>
        <trans-unit id="cc391b585ed780ac543ae3ed4c184e7ef73852d8" translate="yes" xml:space="preserve">
          <source>An example of the usage of &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt;&lt;code&gt;_callmethod()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt; &lt;code&gt;_callmethod()&lt;/code&gt; &lt;/a&gt; 사용법의 예 :</target>
        </trans-unit>
        <trans-unit id="b0374afa67447b447f7a013a60acd58beb789bd8" translate="yes" xml:space="preserve">
          <source>An example of writing to a configuration file:</source>
          <target state="translated">구성 파일에 쓰는 예 :</target>
        </trans-unit>
        <trans-unit id="678e726964a2ce10c4c1a7c983eb935e47f7d7bc" translate="yes" xml:space="preserve">
          <source>An example showing how to use queues to feed tasks to a collection of worker processes and collect the results:</source>
          <target state="translated">대기열을 사용하여 작업자 프로세스 콜렉션에 태스크를 공급하고 결과를 수집하는 방법을 보여주는 예제 :</target>
        </trans-unit>
        <trans-unit id="ce7f7b7a4c5476e3cc316370c635a0a929e3cae0" translate="yes" xml:space="preserve">
          <source>An example that will remove &lt;em&gt;remove_this&lt;/em&gt; from email addresses:</source>
          <target state="translated">이메일 주소에서 &lt;em&gt;remove_this&lt;/em&gt; 를 제거하는 예제 :</target>
        </trans-unit>
        <trans-unit id="81981452dd23b6b05db05d7cfb0589b85b814ed7" translate="yes" xml:space="preserve">
          <source>An example to show the &lt;code&gt;_ignore_&lt;/code&gt; attribute in use:</source>
          <target state="translated">사용중인 &lt;code&gt;_ignore_&lt;/code&gt; 속성 을 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="85eca7d3c00b4de3339c2e436d45332986ea35c3" translate="yes" xml:space="preserve">
          <source>An example usage of the module:</source>
          <target state="translated">모듈 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="b8690b021b6b6b9da606f08de01ded9048222325" translate="yes" xml:space="preserve">
          <source>An example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="7c60e5df7208cba172a6b4861bef2a01e85722af" translate="yes" xml:space="preserve">
          <source>An example using &lt;em&gt;enter_result&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;enter_result&lt;/em&gt; 사용 예 :</target>
        </trans-unit>
        <trans-unit id="619d126046efa510fbee514e656faac7c28fa578" translate="yes" xml:space="preserve">
          <source>An example using only Unix style options:</source>
          <target state="translated">유닉스 스타일 옵션 만 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="cb40c2136fa42deb9a36926aa145be2f5a4b420f" translate="yes" xml:space="preserve">
          <source>An example using the &lt;a href=&quot;#asyncio.asyncio.subprocess.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; class to control a subprocess and the &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; class to read from its standard output.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.asyncio.subprocess.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 하위 프로세스를 제어하고 &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 클래스를 표준 출력에서 ​​읽 도록 제어 하는 예제 입니다.</target>
        </trans-unit>
        <trans-unit id="99f3529798fae53307059d813edb69b2362e7c71" translate="yes" xml:space="preserve">
          <source>An example using the &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt; method to schedule a callback. The callback displays &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; and then stops the event loop:</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 콜백을 스케줄 하는 예제 입니다. 콜백에 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 가 표시 되고 이벤트 루프가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="ff40ba096df117ee2ce62d129f289e94ce50d311" translate="yes" xml:space="preserve">
          <source>An example which will deadlock is the following:</source>
          <target state="translated">교착 상태가되는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1449c62b11b34c51038e54fc84c6c14e5bdd420c" translate="yes" xml:space="preserve">
          <source>An example with non-ASCII characters:</source>
          <target state="translated">비 ASCII 문자의 예 :</target>
        </trans-unit>
        <trans-unit id="f71f4e4b07c8d3bd6da392502d651c55e4d66276" translate="yes" xml:space="preserve">
          <source>An example&amp;rsquo;s doctest directives modify doctest&amp;rsquo;s behavior for that single example. Use &lt;code&gt;+&lt;/code&gt; to enable the named behavior, or &lt;code&gt;-&lt;/code&gt; to disable it.</source>
          <target state="translated">예제의 doctest 지시문은 해당 단일 예제에 대한 doctest의 동작을 수정합니다. 명명 된 동작을 사용 하려면 &lt;code&gt;+&lt;/code&gt; 를 사용하고, 사용하지 않으려면 &lt;code&gt;-&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="23a14600961e92118a1b9c9768e9bc704485af4b" translate="yes" xml:space="preserve">
          <source>An exception has occurred. The local trace function is called; &lt;em&gt;arg&lt;/em&gt; is a tuple &lt;code&gt;(exception, value, traceback)&lt;/code&gt;; the return value specifies the new local trace function.</source>
          <target state="translated">예외가 발생했습니다. 로컬 추적 기능이 호출됩니다. &lt;em&gt;arg&lt;/em&gt; 는 튜플 &lt;code&gt;(exception, value, traceback)&lt;/code&gt; . 리턴 값은 새로운 로컬 추적 기능을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="077f3a8d799c59c87a7879ae93f65a8b265b382c" translate="yes" xml:space="preserve">
          <source>An exception inheriting &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; that is raised when an unsupported operation is called on a stream.</source>
          <target state="translated">지원되지 않는 작업이 스트림에서 호출 될 때 발생하는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 를 상속하는 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="90348b9ec43ea456461b13b883f04b6adc7d95fc" translate="yes" xml:space="preserve">
          <source>An exception raised by &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt; to signal that a doctest example raised an unexpected exception. The constructor arguments are used to initialize the attributes of the same names.</source>
          <target state="translated">&lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 가 doctest 예제에서 예기치 않은 예외가 발생했음을 알리기 위해 예외가 발생했습니다 . 생성자 인수는 동일한 이름의 속성을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a2d6bd0f6bfde706cbcad0479411815ccfff05d" translate="yes" xml:space="preserve">
          <source>An exception raised by &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt; to signal that a doctest example&amp;rsquo;s actual output did not match its expected output. The constructor arguments are used to initialize the attributes of the same names.</source>
          <target state="translated">doctest 예제의 실제 출력이 예상 출력과 일치하지 않음 을 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 위해 DocTestRunner 에 의해 발생한 예외 입니다. 생성자 인수는 동일한 이름의 속성을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d371cb40c11f76c5c36febec63cfec9705178506" translate="yes" xml:space="preserve">
          <source>An exception raised for invalid gzip files. It inherits &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zlib#zlib.error&quot;&gt;&lt;code&gt;zlib.error&lt;/code&gt;&lt;/a&gt; can also be raised for invalid gzip files.</source>
          <target state="translated">잘못된 gzip 파일에 대해 예외가 발생했습니다. &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 상속 합니다. 잘못된 gzip 파일에 대해 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zlib#zlib.error&quot;&gt; &lt;code&gt;zlib.error&lt;/code&gt; &lt;/a&gt; 도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595cdbaab3299ecf183e16949385b4ed75622bb8" translate="yes" xml:space="preserve">
          <source>An exception tuple, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">예외 튜플, 또는 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6b714867157f6242c971860d61ec3d6ff7556a5" translate="yes" xml:space="preserve">
          <source>An executable line in a &lt;code&gt;.pth&lt;/code&gt; file is run at every Python startup, regardless of whether a particular module is actually going to be used. Its impact should thus be kept to a minimum. The primary intended purpose of executable lines is to make the corresponding module(s) importable (load 3rd-party import hooks, adjust &lt;code id=&quot;index-3&quot;&gt;PATH&lt;/code&gt; etc). Any other initialization is supposed to be done upon a module&amp;rsquo;s actual import, if and when it happens. Limiting a code chunk to a single line is a deliberate measure to discourage putting anything more complex here.</source>
          <target state="translated">&lt;code&gt;.pth&lt;/code&gt; 파일 의 실행 가능 라인은 특정 모듈의 실제 사용 여부에 관계없이 모든 Python 시작시 실행됩니다. 따라서 영향을 최소화해야합니다. 실행 가능한 행의 주요 목적은 해당 모듈을 가져 오기 가능하게 만드는 것입니다 (타사 가져 오기 후크로드, &lt;code id=&quot;index-3&quot;&gt;PATH&lt;/code&gt; 조정 등). 다른 초기화는 모듈의 실제 가져 오기에 따라 수행됩니다. 코드 청크를 한 줄로 제한하는 것은 여기에 더 복잡한 것을 넣지 않도록 의도적으로 측정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b1add73ad794c032de45e9a10a3307ac96e89eae" translate="yes" xml:space="preserve">
          <source>An executor can be used to run a task in a different thread or even in a different process to avoid blocking the OS thread with the event loop. See the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt;&lt;code&gt;loop.run_in_executor()&lt;/code&gt;&lt;/a&gt; method for more details.</source>
          <target state="translated">실행기는 이벤트 스레드로 OS 스레드를 차단하지 않도록 다른 스레드 또는 다른 프로세스에서 태스크를 실행하는 데 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt; &lt;code&gt;loop.run_in_executor()&lt;/code&gt; &lt;/a&gt; 메서드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e11c12943faf16444ceedb9804a38db006485b2" translate="yes" xml:space="preserve">
          <source>An existing file of the same name is overwritten.</source>
          <target state="translated">동일한 이름의 기존 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="2e1fe8390882dfde7bc76d70b8e2cafd23494e82" translate="yes" xml:space="preserve">
          <source>An existing file of the same name is overwritten. The optional parameters have the same meaning as in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동일한 이름의 기존 파일을 덮어 씁니다. 선택적 매개 변수는 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="02ba8d7a14486c8e174ff533d6d9c0663952b29e" translate="yes" xml:space="preserve">
          <source>An explanation of some terminology and conventions is in order.</source>
          <target state="translated">일부 용어 및 규칙에 대한 설명이 순서대로 있습니다.</target>
        </trans-unit>
        <trans-unit id="890aae396d7bacf660f2e6509a7c070fac630d67" translate="yes" xml:space="preserve">
          <source>An extended example which also demonstrates the use of pointers accesses the &lt;a href=&quot;https://docs.python.org/3.8/c-api/import.html#c.PyImport_FrozenModules&quot;&gt;&lt;code&gt;PyImport_FrozenModules&lt;/code&gt;&lt;/a&gt; pointer exported by Python.</source>
          <target state="translated">포인터 사용을 보여주는 확장 된 예제 는 Python에서 내 보낸 &lt;a href=&quot;https://docs.python.org/3.8/c-api/import.html#c.PyImport_FrozenModules&quot;&gt; &lt;code&gt;PyImport_FrozenModules&lt;/code&gt; &lt;/a&gt; 포인터에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="d874aff9356fc6c2a27e76364bce500fa2c6518e" translate="yes" xml:space="preserve">
          <source>An extensive list of Python testing tools including functional testing frameworks and mock object libraries.</source>
          <target state="translated">기능 테스트 프레임 워크 및 모의 객체 라이브러리를 포함한 광범위한 Python 테스트 도구 목록.</target>
        </trans-unit>
        <trans-unit id="0a23d9f159c83bfe97b484a3e6115e80af5d4380" translate="yes" xml:space="preserve">
          <source>An hour is converted to 3600 seconds.</source>
          <target state="translated">시간은 3600 초로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6236d6ba69aedf0745fd1ea63614a9e2262bf5" translate="yes" xml:space="preserve">
          <source>An id which does not have a corresponding destination.</source>
          <target state="translated">해당 목적지가없는 아이디입니다.</target>
        </trans-unit>
        <trans-unit id="b4dfb427510e074283a39a54e4d9dbf2b185f2a3" translate="yes" xml:space="preserve">
          <source>An idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect. Attributes: &lt;a href=&quot;#datetime.date.year&quot;&gt;&lt;code&gt;year&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.date.month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#datetime.date.day&quot;&gt;&lt;code&gt;day&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 그레고리력이 항상 유효하고 항상 유효하다고 가정 할 때 이상적인 순진한 날짜. 속성 : &lt;a href=&quot;#datetime.date.year&quot;&gt; &lt;code&gt;year&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.date.month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#datetime.date.day&quot;&gt; &lt;code&gt;day&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5099199c1ac259aae0741f72ef6e8d7849ea93" translate="yes" xml:space="preserve">
          <source>An idealized time, independent of any particular day, assuming that every day has exactly 24*60*60 seconds. (There is no notion of &amp;ldquo;leap seconds&amp;rdquo; here.) Attributes: &lt;a href=&quot;#datetime.time.hour&quot;&gt;&lt;code&gt;hour&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.time.minute&quot;&gt;&lt;code&gt;minute&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.time.second&quot;&gt;&lt;code&gt;second&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.time.microsecond&quot;&gt;&lt;code&gt;microsecond&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매일 하루가 정확히 24 * 60 * 60 초라고 가정 할 때 특정 날짜와 상관없이 이상적인 시간입니다. (. 여기에 &quot;윤초&quot;에 대한 개념이 없다) 속성 : &lt;a href=&quot;#datetime.time.hour&quot;&gt; &lt;code&gt;hour&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.time.minute&quot;&gt; &lt;code&gt;minute&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.time.second&quot;&gt; &lt;code&gt;second&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.time.microsecond&quot;&gt; &lt;code&gt;microsecond&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5610b3c1cc31886ddf86db3b6bfe9dce38bb3a3c" translate="yes" xml:space="preserve">
          <source>An immutable sequence providing access to the logical ancestors of the path:</source>
          <target state="translated">경로의 논리적 조상에 대한 액세스를 제공하는 불변 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="6b6c96734c11fca9ebe4c7cbcdfffa8db89d5e28" translate="yes" xml:space="preserve">
          <source>An implementation of the built-in &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">내장 된 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 함수 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="f7720d17fff53dae117343d8e9e4e3bdf42554ea" translate="yes" xml:space="preserve">
          <source>An important feature of proxy objects is that they are picklable so they can be passed between processes. As such, a referent can contain &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt;. This permits nesting of these managed lists, dicts, and other &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt;:</source>
          <target state="translated">프록시 개체의 중요한 기능은 프로세스간에 전달 될 수 있도록 선택 가능하다는 것입니다. 따라서, 지시자는 &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;프록시 객체를&lt;/a&gt; 포함 할 수 있습니다 . 이를 통해 이러한 관리되는 목록, dict 및 기타 &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;프록시 객체를&lt;/a&gt; 중첩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ca5c2b2d5e23075377145528c4bb6a274c41020" translate="yes" xml:space="preserve">
          <source>An in-memory stream for text I/O. The text buffer is discarded when the &lt;a href=&quot;#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">텍스트 I / O를위한 인 메모리 스트림. &lt;a href=&quot;#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되면 텍스트 버퍼가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c40d804be737d2c53024a9e0ca00bbefc518b84" translate="yes" xml:space="preserve">
          <source>An incomplete character was found in the input.</source>
          <target state="translated">입력에서 불완전한 문자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="90ea41c9a0216bd11cc24452f4b96fc38cb07e7e" translate="yes" xml:space="preserve">
          <source>An indicator of the native byte order. This will have the value &lt;code&gt;'big'&lt;/code&gt; on big-endian (most-significant byte first) platforms, and &lt;code&gt;'little'&lt;/code&gt; on little-endian (least-significant byte first) platforms.</source>
          <target state="translated">기본 바이트 순서의 표시기입니다. 이는 빅 엔디안 (가장 중요한 바이트 우선) 플랫폼에서 &lt;code&gt;'big'&lt;/code&gt; 값을 가지며 리틀 엔디안 (가장 중요한 바이트 우선) 플랫폼에서 &lt;code&gt;'little'&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="703b3bb1868e2e8bc5b77367f969f62a6671a60f" translate="yes" xml:space="preserve">
          <source>An instance &lt;em&gt;tz&lt;/em&gt; of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass that models both standard and daylight times must be consistent in this sense:</source>
          <target state="translated">표준 및 일광 시간을 모두 모델링 하는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 &lt;em&gt;tz&lt;/em&gt; 는 이러한 의미에서 일관성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2f07dcb4a65f5f3cfefa434bd9d52d248683b91d" translate="yes" xml:space="preserve">
          <source>An instance of (a concrete subclass of) &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; can be passed to the constructors for &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects. The latter objects view their attributes as being in local time, and the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; object supports methods revealing offset of local time from UTC, the name of the time zone, and DST offset, all relative to a date or time object passed to them.</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 의 (구체적인 서브 클래스) 인스턴스는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 의 생성자에 전달 될 수 있습니다 . 후자의 객체는 속성을 현지 시간으로 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 하고 tzinfo 객체는 UTC에서 현지 시간의 오프셋, 시간대 이름 및 DST 오프셋을 전달하는 날짜 또는 시간 객체를 기준으로하는 메서드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e4b67a267f48e3562f47079d2bb418c11e0684d5" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#asyncio.Handle&quot;&gt;&lt;code&gt;asyncio.Handle&lt;/code&gt;&lt;/a&gt; is returned, which can be used later to cancel the callback.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.Handle&quot;&gt; &lt;code&gt;asyncio.Handle&lt;/code&gt; &lt;/a&gt; 의 인스턴스 가 리턴되며 나중에 콜백을 취소하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d80ce39420c2628cfc7e1e9324435012f462488d" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#asyncio.TimerHandle&quot;&gt;&lt;code&gt;asyncio.TimerHandle&lt;/code&gt;&lt;/a&gt; is returned which can be used to cancel the callback.</source>
          <target state="translated">콜백을 취소하는 데 사용할 수있는 &lt;a href=&quot;#asyncio.TimerHandle&quot;&gt; &lt;code&gt;asyncio.TimerHandle&lt;/code&gt; &lt;/a&gt; 인스턴스 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="01872a127016c725833502fe1517e9a8bb1110fd" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#ctypes.PyDLL&quot;&gt;&lt;code&gt;PyDLL&lt;/code&gt;&lt;/a&gt; that exposes Python C API functions as attributes. Note that all these functions are assumed to return C &lt;code&gt;int&lt;/code&gt;, which is of course not always the truth, so you have to assign the correct &lt;code&gt;restype&lt;/code&gt; attribute to use these functions.</source>
          <target state="translated">Python C API 함수를 속성으로 노출 하는 &lt;a href=&quot;#ctypes.PyDLL&quot;&gt; &lt;code&gt;PyDLL&lt;/code&gt; &lt;/a&gt; 의 인스턴스입니다 . 이러한 모든 함수는 C &lt;code&gt;int&lt;/code&gt; 를 반환하는 것으로 가정합니다. 물론 항상 사실은 아니므로 이러한 함수를 사용 하려면 올바른 &lt;code&gt;restype&lt;/code&gt; 속성을 할당 해야합니다.</target>
        </trans-unit>
        <trans-unit id="c664e0f73090f1e1bd70299e8da8a6073f9919cd" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#email.policy.Compat32&quot;&gt;&lt;code&gt;Compat32&lt;/code&gt;&lt;/a&gt;, providing backward compatibility with the behavior of the email package in Python 3.2.</source>
          <target state="translated">Python 3.2의 전자 메일 패키지 동작과 호환되는 &lt;a href=&quot;#email.policy.Compat32&quot;&gt; &lt;code&gt;Compat32&lt;/code&gt; &lt;/a&gt; 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="753712898d5c60e92ce9fc7f47232fd4e688b279" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;EmailPolicy&lt;/code&gt; with all defaults unchanged. This policy uses the standard Python &lt;code&gt;\n&lt;/code&gt; line endings rather than the RFC-correct &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">모든 기본값이 변경되지 않은 &lt;code&gt;EmailPolicy&lt;/code&gt; 인스턴스 . 이 정책은 RFC-correct &lt;code&gt;\r\n&lt;/code&gt; 대신 표준 Python &lt;code&gt;\n&lt;/code&gt; 줄 끝을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6eefcaafe768844d20d2285a9ea781eccd2b0ead" translate="yes" xml:space="preserve">
          <source>An int containing the default buffer size used by the module&amp;rsquo;s buffered I/O classes. &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; uses the file&amp;rsquo;s blksize (as obtained by &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;) if possible.</source>
          <target state="translated">모듈의 버퍼 된 I / O 클래스에서 사용하는 기본 버퍼 크기를 포함하는 int입니다. &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 은 가능한 경우 파일의 blksize를 사용합니다 ( &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 얻은대로 ).</target>
        </trans-unit>
        <trans-unit id="6753a22067c075c8c9a4c5a84ef7830915742ad2" translate="yes" xml:space="preserve">
          <source>An integer between zero and the number of tabs</source>
          <target state="translated">0과 탭 수 사이의 정수</target>
        </trans-unit>
        <trans-unit id="645936da5c83c45f9587c17d8b318b09bd721e60" translate="yes" xml:space="preserve">
          <source>An integer containing the number of characters written to the stream before it blocked. This attribute is available when using the buffered I/O classes from the &lt;a href=&quot;io#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">스트림하기 전에 스트림에 쓴 문자 수를 포함하는 정수입니다. 이 속성은 &lt;a href=&quot;io#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 모듈 에서 버퍼 된 I / O 클래스를 사용할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f40b0022f33627acc9876d1e86f6750f237785b" translate="yes" xml:space="preserve">
          <source>An integer giving the maximum value a variable of type &lt;code&gt;Py_ssize_t&lt;/code&gt; can take. It&amp;rsquo;s usually &lt;code&gt;2**31 - 1&lt;/code&gt; on a 32-bit platform and &lt;code&gt;2**63 - 1&lt;/code&gt; on a 64-bit platform.</source>
          <target state="translated">&lt;code&gt;Py_ssize_t&lt;/code&gt; 유형의 변수에 사용할 수 있는 최대 값을 제공하는 정수 입니다. 일반적으로 32 비트 플랫폼에서는 &lt;code&gt;2**31 - 1&lt;/code&gt; 이고 64 비트 플랫폼에서는 &lt;code&gt;2**63 - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4f6a82aa8fc81a2e88d2ec14a5abf2c015f9ab5" translate="yes" xml:space="preserve">
          <source>An integer giving the number of sub keys this key has.</source>
          <target state="translated">이 키가 가진 하위 키 수를 제공하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e3671820be7fdb3b8d7153be88789dda60eca34a" translate="yes" xml:space="preserve">
          <source>An integer giving the number of values this key has.</source>
          <target state="translated">이 키의 값을 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="61158287398e3913556fd8de17d987f121a49ce2" translate="yes" xml:space="preserve">
          <source>An integer giving the registry type for this value (see table in docs for &lt;a href=&quot;#winreg.SetValueEx&quot;&gt;&lt;code&gt;SetValueEx()&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">이 값의 레지스트리 유형을 제공하는 정수입니다 ( &lt;a href=&quot;#winreg.SetValueEx&quot;&gt; &lt;code&gt;SetValueEx()&lt;/code&gt; &lt;/a&gt; 대한 문서는 표 참조 ).</target>
        </trans-unit>
        <trans-unit id="9c4fb4071cc7728855d3b16ff06baa25bc7f67a5" translate="yes" xml:space="preserve">
          <source>An integer giving the value of the largest Unicode code point, i.e. &lt;code&gt;1114111&lt;/code&gt; (&lt;code&gt;0x10FFFF&lt;/code&gt; in hexadecimal).</source>
          <target state="translated">가장 큰 유니 코드 코드 포인트의 값 ( 예 : &lt;code&gt;1114111&lt;/code&gt; ( 16 진의 &lt;code&gt;0x10FFFF&lt;/code&gt; ))을 제공하는 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="70ed9451b9be56604da549be2ff4d27c0a823db6" translate="yes" xml:space="preserve">
          <source>An integer giving when the key was last modified (if available) as 100&amp;rsquo;s of nanoseconds since Jan 1, 1601.</source>
          <target state="translated">1601 년 1 월 1 일 이후로 키가 마지막으로 수정되었을 때 (가능한 경우) 100 초의 나노초로 제공되는 정수.</target>
        </trans-unit>
        <trans-unit id="17b0fef7eb70950fd1875b2099b192af05f223df" translate="yes" xml:space="preserve">
          <source>An integer indicating how many dimensions of a multi-dimensional array the memory represents.</source>
          <target state="translated">메모리가 나타내는 다차원 배열의 차원 수를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="8bef0117d73063c1a4d56593cf70e5fec7f031c6" translate="yes" xml:space="preserve">
          <source>An integer keeping track of how many times the mock object has been awaited.</source>
          <target state="translated">모의 객체가 몇 번이나 대기했는지를 추적하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ae0518f4d7529a2d85bc7601acec4302104bbbbb" translate="yes" xml:space="preserve">
          <source>An integer n, specifying the nth data column.</source>
          <target state="translated">n 번째 데이터 열을 지정하는 정수 n.</target>
        </trans-unit>
        <trans-unit id="b0d279e661a8927158d65f021e9f995b44d56314" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 16, big-endian.</source>
          <target state="translated">길이가 16 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체 (big-endian) 로 채워진 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="646e733efcef9696eb9443aa091caa22bf73aa29" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 16, big-endian. The interpretation is similar to an integer &lt;em&gt;address&lt;/em&gt;.</source>
          <target state="translated">길이가 16 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체 (big-endian) 로 채워진 정수 해석은 정수 &lt;em&gt;주소&lt;/em&gt; 와 유사 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f5ca0496bffcd3b5349fb91457405154481dd3" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 4 (most significant octet first).</source>
          <target state="translated">길이가 4 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 오브젝트에 채워진 정수 (가장 중요한 옥텟 우선).</target>
        </trans-unit>
        <trans-unit id="64aac0469b4285c7ace562fb45219c88f4d45beb" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 4, big-endian. The interpretation is similar to an integer &lt;em&gt;address&lt;/em&gt;.</source>
          <target state="translated">길이 4, 빅 엔디안 의 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 로 채워진 정수 입니다. 해석은 정수 &lt;em&gt;주소&lt;/em&gt; 와 유사 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="882a8de446fcecf6cab8bc081fa438fcd87c37bf" translate="yes" xml:space="preserve">
          <source>An integer preceded by &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;@6&lt;/code&gt;, where the integer is interpreted as a y pixel coordinate in the menu&amp;rsquo;s coordinate system;</source>
          <target state="translated">&lt;code&gt;@6&lt;/code&gt; 에서와 같이 &lt;code&gt;@&lt;/code&gt; 앞에 오는 정수 . 여기서 정수는 메뉴의 좌표계에서 y 픽셀 좌표로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8c87923a15988fabf3c441c9e1307e478e6d10" translate="yes" xml:space="preserve">
          <source>An integer representing the node type. Symbolic constants for the types are on the &lt;code&gt;Node&lt;/code&gt; object: &lt;code&gt;ELEMENT_NODE&lt;/code&gt;, &lt;code&gt;ATTRIBUTE_NODE&lt;/code&gt;, &lt;code&gt;TEXT_NODE&lt;/code&gt;, &lt;code&gt;CDATA_SECTION_NODE&lt;/code&gt;, &lt;code&gt;ENTITY_NODE&lt;/code&gt;, &lt;code&gt;PROCESSING_INSTRUCTION_NODE&lt;/code&gt;, &lt;code&gt;COMMENT_NODE&lt;/code&gt;, &lt;code&gt;DOCUMENT_NODE&lt;/code&gt;, &lt;code&gt;DOCUMENT_TYPE_NODE&lt;/code&gt;, &lt;code&gt;NOTATION_NODE&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">노드 유형을 나타내는 정수 유형에 대한 기호 상수는에있는 &lt;code&gt;Node&lt;/code&gt; 객체 : &lt;code&gt;ELEMENT_NODE&lt;/code&gt; , &lt;code&gt;ATTRIBUTE_NODE&lt;/code&gt; , &lt;code&gt;TEXT_NODE&lt;/code&gt; , &lt;code&gt;CDATA_SECTION_NODE&lt;/code&gt; , &lt;code&gt;ENTITY_NODE&lt;/code&gt; , &lt;code&gt;PROCESSING_INSTRUCTION_NODE&lt;/code&gt; , &lt;code&gt;COMMENT_NODE&lt;/code&gt; , &lt;code&gt;DOCUMENT_NODE&lt;/code&gt; , &lt;code&gt;DOCUMENT_TYPE_NODE&lt;/code&gt; , &lt;code&gt;NOTATION_NODE&lt;/code&gt; . 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="f1a555fc41c7502bfba0c65b97ab4ac5b9cd080b" translate="yes" xml:space="preserve">
          <source>An integer representing the set of SSL options enabled on this context. The default value is &lt;a href=&quot;#ssl.OP_ALL&quot;&gt;&lt;code&gt;OP_ALL&lt;/code&gt;&lt;/a&gt;, but you can specify other options such as &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt;&lt;code&gt;OP_NO_SSLv2&lt;/code&gt;&lt;/a&gt; by ORing them together.</source>
          <target state="translated">이 컨텍스트에서 사용 가능한 SSL 옵션 세트를 나타내는 정수입니다. 기본값은 &lt;a href=&quot;#ssl.OP_ALL&quot;&gt; &lt;code&gt;OP_ALL&lt;/code&gt; &lt;/a&gt; 이지만 &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt; &lt;code&gt;OP_NO_SSLv2&lt;/code&gt; &lt;/a&gt; 와 같은 다른 옵션을 함께 OR하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e38281ba09868abdfe8882473c5fa3690e426a3" translate="yes" xml:space="preserve">
          <source>An integer representing the version of the NNTP protocol supported by the server. In practice, this should be &lt;code&gt;2&lt;/code&gt; for servers advertising &lt;a href=&quot;https://tools.ietf.org/html/rfc3977.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 3977&lt;/strong&gt;&lt;/a&gt; compliance and &lt;code&gt;1&lt;/code&gt; for others.</source>
          <target state="translated">서버에서 지원하는 NNTP 프로토콜 버전을 나타내는 정수입니다. 실제로,이 있어야한다 &lt;code&gt;2&lt;/code&gt; 광고 서버에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc3977.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC에게 3977&lt;/strong&gt;&lt;/a&gt; 준수 및 &lt;code&gt;1&lt;/code&gt; 다른 사람을.</target>
        </trans-unit>
        <trans-unit id="543f543f7b3326e3df52c58c046ecc3ca49dcfe2" translate="yes" xml:space="preserve">
          <source>An integer telling you how many times the mock object has been called:</source>
          <target state="translated">모의 객체가 몇 번이나 호출되었는지를 알려주는 정수 :</target>
        </trans-unit>
        <trans-unit id="187f154843eb20b15b663f5ef77b74ffa766be88" translate="yes" xml:space="preserve">
          <source>An integer that fits into 128 bits.</source>
          <target state="translated">128 비트에 맞는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4243e776fd6616aba00dbcc2c2488ad7be2afc37" translate="yes" xml:space="preserve">
          <source>An integer that fits into 128 bits. This is equivalent to a single-address network, with the network address being &lt;em&gt;address&lt;/em&gt; and the mask being &lt;code&gt;/128&lt;/code&gt;.</source>
          <target state="translated">128 비트에 맞는 정수입니다. 이는 네트워크 주소가 &lt;em&gt;주소&lt;/em&gt; 이고 마스크가 &lt;code&gt;/128&lt;/code&gt; 인 단일 주소 네트워크와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="44316d770fca56bd5eaaf3a3511c5ee64cecdc22" translate="yes" xml:space="preserve">
          <source>An integer that fits into 32 bits.</source>
          <target state="translated">32 비트에 맞는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ecdd55c3c245e5b3b8388fa54918c20b35e6e67f" translate="yes" xml:space="preserve">
          <source>An integer that fits into 32 bits. This is equivalent to a single-address network, with the network address being &lt;em&gt;address&lt;/em&gt; and the mask being &lt;code&gt;/32&lt;/code&gt;.</source>
          <target state="translated">32 비트에 맞는 정수입니다. 이는 네트워크 주소가 &lt;em&gt;주소&lt;/em&gt; 이고 마스크가 &lt;code&gt;/32&lt;/code&gt; 인 단일 주소 네트워크와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a078dc74c1c703bd1abf51f26bcdd05ff58dc2cc" translate="yes" xml:space="preserve">
          <source>An integer that identifies the type of the value data (see table in docs for &lt;a href=&quot;#winreg.SetValueEx&quot;&gt;&lt;code&gt;SetValueEx()&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">값 데이터의 유형을 식별하는 정수 ( &lt;a href=&quot;#winreg.SetValueEx&quot;&gt; &lt;code&gt;SetValueEx()&lt;/code&gt; &lt;/a&gt; 대한 문서는 표 참조 )</target>
        </trans-unit>
        <trans-unit id="6221568d61a57ce1a59e1d75f271d5b94fd58a61" translate="yes" xml:space="preserve">
          <source>An integer, the default &lt;a href=&quot;#pickle-protocols&quot;&gt;protocol version&lt;/a&gt; used for pickling. May be less than &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt;&lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt;&lt;/a&gt;. Currently the default protocol is 4, first introduced in Python 3.4 and incompatible with previous versions.</source>
          <target state="translated">산세에 사용되는 기본 &lt;a href=&quot;#pickle-protocols&quot;&gt;프로토콜 버전&lt;/a&gt; 인 정수 입니다. &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt; &lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt; &lt;/a&gt; 보다 작을 수 있습니다 . 현재 기본 프로토콜은 4이며, Python 3.4에서 처음 도입되었으며 이전 버전과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3ff29ab8afde8b6ee23d29bb72e09168c7b6f37" translate="yes" xml:space="preserve">
          <source>An integer, the highest &lt;a href=&quot;#pickle-protocols&quot;&gt;protocol version&lt;/a&gt; available. This value can be passed as a &lt;em&gt;protocol&lt;/em&gt; value to functions &lt;a href=&quot;#pickle.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; as well as the &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">사용 가능한 최고 &lt;a href=&quot;#pickle-protocols&quot;&gt;프로토콜 버전&lt;/a&gt; 인 정수 입니다. 이 값은 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 생성자 뿐만 아니라 함수 &lt;a href=&quot;#pickle.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 프로토콜&lt;/em&gt; 값 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89f7acaa85bea0ee87dbe1ef47defa1dd89b2cca" translate="yes" xml:space="preserve">
          <source>An interface to the group database, similar to this.</source>
          <target state="translated">이와 유사한 그룹 데이터베이스에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="59cb6ef37b0cd57060129e4c5a383119176babe9" translate="yes" xml:space="preserve">
          <source>An interface to the normal password database, similar to this.</source>
          <target state="translated">이와 유사한 일반 비밀번호 데이터베이스에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="23aa9ac5ddca3f3d883d5cc83284856548229022" translate="yes" xml:space="preserve">
          <source>An interface to the shadow password database, similar to this.</source>
          <target state="translated">이와 유사한 섀도 비밀번호 데이터베이스에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="994fe15ee3ca3aa04c018a8fe65a5d200d8e16aa" translate="yes" xml:space="preserve">
          <source>An interface to the user database, similar to this.</source>
          <target state="translated">이와 유사한 사용자 데이터베이스 인터페이스.</target>
        </trans-unit>
        <trans-unit id="8d1844ce395b8e9fdc98c2cc653690def38555f0" translate="yes" xml:space="preserve">
          <source>An interpreter instance will recognize a command name &lt;code&gt;foo&lt;/code&gt; if and only if it has a method &lt;code&gt;do_foo()&lt;/code&gt;. As a special case, a line beginning with the character &lt;code&gt;'?'&lt;/code&gt; is dispatched to the method &lt;code&gt;do_help()&lt;/code&gt;. As another special case, a line beginning with the character &lt;code&gt;'!'&lt;/code&gt; is dispatched to the method &lt;code&gt;do_shell()&lt;/code&gt; (if such a method is defined).</source>
          <target state="translated">인터프리터 인스턴스는 &lt;code&gt;do_foo()&lt;/code&gt; 메소드가있는 경우에만 명령 이름 &lt;code&gt;foo&lt;/code&gt; 를 인식합니다 . 특별한 경우, 문자 &lt;code&gt;'?'&lt;/code&gt; 로 시작하는 줄 &lt;code&gt;do_help()&lt;/code&gt; 메소드로 전달됩니다 . 또 다른 특별한 경우로, 문자 &lt;code&gt;'!'&lt;/code&gt; 로 시작하는 줄 &lt;code&gt;do_shell()&lt;/code&gt; 메소드로 전달됩니다 (이러한 메소드가 정의 된 경우).</target>
        </trans-unit>
        <trans-unit id="a6fc8b26e70e09d313612cac6794fdb4aad1682f" translate="yes" xml:space="preserve">
          <source>An invalid logger name.</source>
          <target state="translated">잘못된 로거 이름입니다.</target>
        </trans-unit>
        <trans-unit id="74a940fd099263dda413cd8757526ef0956f8af4" translate="yes" xml:space="preserve">
          <source>An invalid operation was performed.</source>
          <target state="translated">유효하지 않은 작업이 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a26e16375583adf85ddeccaecb2b8c4ef50d837" translate="yes" xml:space="preserve">
          <source>An object containing information about the implementation of the currently running Python interpreter. The following attributes are required to exist in all Python implementations.</source>
          <target state="translated">현재 실행중인 Python 인터프리터의 구현에 대한 정보가 포함 된 객체입니다. 모든 Python 구현에 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="998e5eccbd293e12c5532b4dc44ce7656abeec0b" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; may be aware or naive.</source>
          <target state="translated">&lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 유형의 오브젝트는 인식하거나 순진 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b174b298545e9f1f9dff3565076e2ed782564e88" translate="yes" xml:space="preserve">
          <source>An object that holds the value data, and whose type depends on the underlying registry type</source>
          <target state="translated">값 데이터를 보유하고 유형이 기본 레지스트리 유형에 따라 달라지는 오브젝트</target>
        </trans-unit>
        <trans-unit id="97080ae4ed5d803c9b0a23c71de971dafd14c52c" translate="yes" xml:space="preserve">
          <source>An object that wraps OS processes created by the &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt;&lt;code&gt;create_subprocess_shell()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt; &lt;code&gt;create_subprocess_shell()&lt;/code&gt; &lt;/a&gt; 함수로 생성 된 OS 프로세스를 래핑하는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="647c7a24d6cf9ebcbec2e05257e54cb377032a7a" translate="yes" xml:space="preserve">
          <source>An object with at least two methods: get_content and set_content. When the &lt;a href=&quot;email.message#email.message.EmailMessage.get_content&quot;&gt;&lt;code&gt;get_content()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method of an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object is called, it calls the corresponding method of this object, passing it the message object as its first argument, and any arguments or keywords that were passed to it as additional arguments. By default &lt;code&gt;content_manager&lt;/code&gt; is set to &lt;a href=&quot;email.contentmanager#email.contentmanager.raw_data_manager&quot;&gt;&lt;code&gt;raw_data_manager&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">get_content 및 set_content 두 가지 이상의 메소드가있는 오브젝트입니다. 때 &lt;a href=&quot;email.message#email.message.EmailMessage.get_content&quot;&gt; &lt;code&gt;get_content()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 객체가 호출 될 때, 그것의 첫 번째 인수로에게 메시지 객체를 전달,이 오브젝트의 해당 메소드를 호출하고, 추가 인수로 전달 된 인수 또는 키워드. 기본적으로 &lt;code&gt;content_manager&lt;/code&gt; 는 &lt;a href=&quot;email.contentmanager#email.contentmanager.raw_data_manager&quot;&gt; &lt;code&gt;raw_data_manager&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1865264489923958e5df1f2c9473facc3252cce6" translate="yes" xml:space="preserve">
          <source>An operation was requested that requires DTD support to be compiled in, but Expat was configured without DTD support. This should never be reported by a standard build of the &lt;a href=&quot;#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">DTD 지원을 컴파일해야하는 작업이 요청되었지만 Expat은 DTD 지원없이 구성되었습니다. &lt;a href=&quot;#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; &lt;/a&gt; 모듈 의 표준 빌드에서보고해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="4947a546c6d3f34597067ace626c8f1253938be2" translate="yes" xml:space="preserve">
          <source>An optional keyword-only &lt;em&gt;context&lt;/em&gt; argument allows specifying a custom &lt;a href=&quot;contextvars#contextvars.Context&quot;&gt;&lt;code&gt;contextvars.Context&lt;/code&gt;&lt;/a&gt; for the &lt;em&gt;callback&lt;/em&gt; to run in. The current context is used when no &lt;em&gt;context&lt;/em&gt; is provided.</source>
          <target state="translated">선택적 키워드 전용 &lt;em&gt;컨텍스트&lt;/em&gt; 인수를 사용 하면 &lt;em&gt;콜백&lt;/em&gt; 을 실행할 사용자 정의 &lt;a href=&quot;contextvars#contextvars.Context&quot;&gt; &lt;code&gt;contextvars.Context&lt;/code&gt; &lt;/a&gt; 를 지정할 수 있습니다 . &lt;em&gt;컨텍스트&lt;/em&gt; 가 제공 되지 않으면 현재 컨텍스트가 사용됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ea3a8a5b272ed84ab311819ca2985d04005ee2d" translate="yes" xml:space="preserve">
          <source>An optional method which, when called, should invalidate any internal cache used by the finder. Used by &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt;&lt;code&gt;importlib.invalidate_caches()&lt;/code&gt;&lt;/a&gt; when invalidating the caches of all finders on &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 될 때 파인더가 사용하는 내부 캐시를 무효화해야하는 선택적 메소드입니다. &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; 의 모든 파인더 캐시를 무효화 할 때 &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt; &lt;code&gt;importlib.invalidate_caches()&lt;/code&gt; &lt;/a&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9077f55d2b0b62326a8204fc9578f269c9e7d89a" translate="yes" xml:space="preserve">
          <source>An optional method which, when called, should invalidate any internal cache used by the finder. Used by &lt;code&gt;PathFinder.invalidate_caches()&lt;/code&gt; when invalidating the caches of all cached finders.</source>
          <target state="translated">호출 될 때 파인더가 사용하는 내부 캐시를 무효화해야하는 선택적 메소드입니다. 캐시 된 모든 파인더의 캐시를 무효화 할 때 &lt;code&gt;PathFinder.invalidate_caches()&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1c77488f2592943bd451545ce7ed54c2b1a12d3c" translate="yes" xml:space="preserve">
          <source>An optional sequence that lists the names of unnamed (anonymous) fields. &lt;a href=&quot;#ctypes.Structure._anonymous_&quot;&gt;&lt;code&gt;_anonymous_&lt;/code&gt;&lt;/a&gt; must be already defined when &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; is assigned, otherwise it will have no effect.</source>
          <target state="translated">이름이없는 (익명) 필드의 이름을 나열하는 선택적 순서입니다. &lt;a href=&quot;#ctypes.Structure._anonymous_&quot;&gt; &lt;code&gt;_anonymous_&lt;/code&gt; &lt;/a&gt; 가 할당 될 때 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 가 이미 정의되어 있어야합니다 . 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b40583112592749895ecadcf35532f5fbb351912" translate="yes" xml:space="preserve">
          <source>An optional shebang line, containing the characters &lt;code&gt;b'#!'&lt;/code&gt; followed by an interpreter name, and then a newline (&lt;code&gt;b'\n'&lt;/code&gt;) character. The interpreter name can be anything acceptable to the OS &amp;ldquo;shebang&amp;rdquo; processing, or the Python launcher on Windows. The interpreter should be encoded in UTF-8 on Windows, and in &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; on POSIX.</source>
          <target state="translated">문자 &lt;code&gt;b'#!'&lt;/code&gt; 포함하는 선택적인 shebang 행 뒤에 인터프리터 이름과 개행 문자 ( &lt;code&gt;b'\n'&lt;/code&gt; )가 옵니다 . 인터프리터 이름은 OS&amp;ldquo;shebang&amp;rdquo;처리 또는 Windows의 Python 실행기에 허용되는 이름 일 수 있습니다. 인터프리터는 Windows에서는 UTF-8로, POSIX 에서는 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 으로 인코딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eadbfe27c0b9f4036e4c5d9ffd152ecaddfb607d" translate="yes" xml:space="preserve">
          <source>An optional small integer that allows overriding the alignment of structure fields in the instance. &lt;a href=&quot;#ctypes.Structure._pack_&quot;&gt;&lt;code&gt;_pack_&lt;/code&gt;&lt;/a&gt; must already be defined when &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; is assigned, otherwise it will have no effect.</source>
          <target state="translated">인스턴스에서 구조 필드의 정렬을 재정의 할 수있는 선택적 작은 정수입니다. &lt;a href=&quot;#ctypes.Structure._pack_&quot;&gt; &lt;code&gt;_pack_&lt;/code&gt; &lt;/a&gt; 가 지정 되면 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 이 이미 정의되어 있어야합니다 . 그렇지 않으면 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79293485a901f4be4341911a3c3007d1e643a627" translate="yes" xml:space="preserve">
          <source>An ordered enumeration that is not based on &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; and so maintains the normal &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; invariants (such as not being comparable to other enumerations):</source>
          <target state="translated">&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; 을&lt;/a&gt; 기반으로하지 않기 때문에 일반적인 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 불변량을 유지 하는 순서가 지정된 열거 형 (예 : 다른 열거 형과 비교할 수 없음) :</target>
        </trans-unit>
        <trans-unit id="a54eaeb427bd767e9c78a3fcf6309d624d005ab3" translate="yes" xml:space="preserve">
          <source>An ordered mapping of parameters&amp;rsquo; names to the corresponding &lt;a href=&quot;#inspect.Parameter&quot;&gt;&lt;code&gt;Parameter&lt;/code&gt;&lt;/a&gt; objects. Parameters appear in strict definition order, including keyword-only parameters.</source>
          <target state="translated">매개 변수 이름을 해당 &lt;a href=&quot;#inspect.Parameter&quot;&gt; &lt;code&gt;Parameter&lt;/code&gt; &lt;/a&gt; 객체에 순서대로 매핑 합니다. 키워드 전용 매개 변수를 포함하여 매개 변수가 엄격한 정의 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e73d51218d474d87723969e9844e08e443986117" translate="yes" xml:space="preserve">
          <source>An ordered, mutable mapping (&lt;a href=&quot;collections#collections.OrderedDict&quot;&gt;&lt;code&gt;collections.OrderedDict&lt;/code&gt;&lt;/a&gt;) of parameters&amp;rsquo; names to arguments&amp;rsquo; values. Contains only explicitly bound arguments. Changes in &lt;a href=&quot;#inspect.BoundArguments.arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/a&gt; will reflect in &lt;a href=&quot;#inspect.BoundArguments.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#inspect.BoundArguments.kwargs&quot;&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수 이름과 인수 값 의 순서가 변경 가능한 맵핑 ( &lt;a href=&quot;collections#collections.OrderedDict&quot;&gt; &lt;code&gt;collections.OrderedDict&lt;/code&gt; &lt;/a&gt; ) 명시 적으로 바인딩 된 인수 만 포함합니다. &lt;a href=&quot;#inspect.BoundArguments.arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; &lt;/a&gt; 변화는 &lt;a href=&quot;#inspect.BoundArguments.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#inspect.BoundArguments.kwargs&quot;&gt; &lt;code&gt;kwargs&lt;/code&gt; 에&lt;/a&gt; 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b5b35b74ba6101747c9d4196b50ff8061dcc151" translate="yes" xml:space="preserve">
          <source>An output filename must be specified if the &lt;em&gt;source&lt;/em&gt; is an archive (and in that case, &lt;em&gt;output&lt;/em&gt; must not be the same as &lt;em&gt;source&lt;/em&gt;).</source>
          <target state="translated">&lt;em&gt;소스&lt;/em&gt; 가 아카이브 인 경우 출력 파일 이름을 지정해야합니다 (이 경우 &lt;em&gt;출력&lt;/em&gt; 은 &lt;em&gt;source&lt;/em&gt; 와 동일하지 않아야 함 ).</target>
        </trans-unit>
        <trans-unit id="521aa7e611225a521017270940523db0f976f977" translate="yes" xml:space="preserve">
          <source>An undeclared prefix was found when namespace processing was enabled.</source>
          <target state="translated">네임 스페이스 처리가 활성화되었을 때 선언되지 않은 접두사가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="9656bc89a24603fa1dca440ac3a2361066df5ac5" translate="yes" xml:space="preserve">
          <source>An unrelated but handy function that takes a time tuple such as returned by the &lt;a href=&quot;time#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt; function in the &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; module, and returns the corresponding Unix timestamp value, assuming an epoch of 1970, and the POSIX encoding. In fact, &lt;a href=&quot;time#time.gmtime&quot;&gt;&lt;code&gt;time.gmtime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#calendar.timegm&quot;&gt;&lt;code&gt;timegm()&lt;/code&gt;&lt;/a&gt; are each others&amp;rsquo; inverse.</source>
          <target state="translated">&lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;a href=&quot;time#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; 함수에 의해 리턴되는 것과 같이 시간 튜플을 취하고 1970 년의 에포크 (epoch) 및 POSIX 인코딩을 가정하여 해당 Unix 타임 스탬프 값을 리턴 하는 관련이없는 편리한 함수입니다 . 실제로 &lt;a href=&quot;time#time.gmtime&quot;&gt; &lt;code&gt;time.gmtime()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#calendar.timegm&quot;&gt; &lt;code&gt;timegm()&lt;/code&gt; &lt;/a&gt; 은 서로의 역수입니다.</target>
        </trans-unit>
        <trans-unit id="3a0de6a3a36da0eabd1ed37cb78f0a84df8288d5" translate="yes" xml:space="preserve">
          <source>Analyse the bytecode corresponding to a function, generator, asynchronous generator, coroutine, method, string of source code, or a code object (as returned by &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수, 생성기, 비동기 생성기, 코 루틴, 메소드, 소스 코드 문자열 또는 코드 오브젝트 ( &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 의해 리턴 됨 )에 해당하는 바이트 코드를 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="819da723c3c425f237bdf8f03b696821a94f3e1f" translate="yes" xml:space="preserve">
          <source>Analysis functions</source>
          <target state="translated">분석 기능</target>
        </trans-unit>
        <trans-unit id="975f7b4df518f323a30297a1f1be4e096d3fcec3" translate="yes" xml:space="preserve">
          <source>Analysis of the profiler data is done using the &lt;a href=&quot;#pstats.Stats&quot;&gt;&lt;code&gt;Stats&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">프로파일 러 데이터의 분석은 &lt;a href=&quot;#pstats.Stats&quot;&gt; &lt;code&gt;Stats&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="25ad53cf48f04b7c123150cc524cc9d87c444927" translate="yes" xml:space="preserve">
          <source>Analyze the contents of the &lt;em&gt;pathname&lt;/em&gt; file, which must contain Python code.</source>
          <target state="translated">Python 코드를 포함해야하는 &lt;em&gt;경로 이름&lt;/em&gt; 파일 의 내용을 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="4623f537e597cbfacf24dc615db20b47e0e3c5c7" translate="yes" xml:space="preserve">
          <source>Analyze the given &lt;em&gt;sample&lt;/em&gt; and return a &lt;a href=&quot;#csv.Dialect&quot;&gt;&lt;code&gt;Dialect&lt;/code&gt;&lt;/a&gt; subclass reflecting the parameters found. If the optional &lt;em&gt;delimiters&lt;/em&gt; parameter is given, it is interpreted as a string containing possible valid delimiter characters.</source>
          <target state="translated">주어진 &lt;em&gt;샘플을&lt;/em&gt; 분석하고 발견 된 매개 변수를 반영 하는 &lt;a href=&quot;#csv.Dialect&quot;&gt; &lt;code&gt;Dialect&lt;/code&gt; &lt;/a&gt; 서브 클래스를 반환합니다 . 선택적 &lt;em&gt;분리 문자&lt;/em&gt; 매개 변수가 제공되면 유효한 분리 문자를 포함하는 문자열로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c77624248a182e0208b43d1dd511b74c035283" translate="yes" xml:space="preserve">
          <source>Analyze the sample text (presumed to be in CSV format) and return &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if the first row appears to be a series of column headers.</source>
          <target state="translated">샘플 텍스트 (CSV 형식으로 추정)를 분석하고 첫 번째 행이 일련의 열 머리글 인 경우 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b15cefd38640764e47311aa1a3c3174217ea802b" translate="yes" xml:space="preserve">
          <source>Anchor type. Denotes where the packer is to place each slave in its parcel.</source>
          <target state="translated">앵커 타입. 패커가 각 슬레이브를 해당 소포에 배치 할 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a680a6b219fde5428a49a155c5016f2f6534116" translate="yes" xml:space="preserve">
          <source>And also as a function decorator:</source>
          <target state="translated">또한 함수 데코레이터로서 :</target>
        </trans-unit>
        <trans-unit id="e25b174a26dc77d7bd4c171e7b788567380cfcad" translate="yes" xml:space="preserve">
          <source>And for reading files:</source>
          <target state="translated">그리고 파일을 읽는 경우 :</target>
        </trans-unit>
        <trans-unit id="8ea4f6d1b5164f1de2cd6425075d887c2f52dc7b" translate="yes" xml:space="preserve">
          <source>And go back to listening for new client connections (of course, a real server would probably handle each client connection in a separate thread, or put the sockets in &lt;a href=&quot;#ssl-nonblocking&quot;&gt;non-blocking mode&lt;/a&gt; and use an event loop).</source>
          <target state="translated">그리고 새로운 클라이언트 연결 수신으로 돌아가십시오 (물론 실제 서버는 각 클라이언트 연결을 별도의 스레드에서 처리하거나 소켓을 &lt;a href=&quot;#ssl-nonblocking&quot;&gt;비 블로킹 모드로 설정&lt;/a&gt; 하고 이벤트 루프를 사용합니다).</target>
        </trans-unit>
        <trans-unit id="e01a2b18c0aa33d0bf1ebb4b61f24aa85532e4a4" translate="yes" xml:space="preserve">
          <source>And lets you write code like this:</source>
          <target state="translated">그리고 다음과 같은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c80b8291de4e65f0384d5df0e931faa6f06e26" translate="yes" xml:space="preserve">
          <source>And so on, eventually ending with:</source>
          <target state="translated">그리고 결국은 다음과 같이 끝납니다.</target>
        </trans-unit>
        <trans-unit id="56675d3775ea977079a196ffe5d39d5c6e0ed45d" translate="yes" xml:space="preserve">
          <source>And some mathematical functions are also available to Decimal:</source>
          <target state="translated">Decimal에는 다음과 같은 수학 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e030fd6f202d12a04313413b21ce123caf324f74" translate="yes" xml:space="preserve">
          <source>And while the module doesn&amp;rsquo;t directly support parsing strings, it can easily be done:</source>
          <target state="translated">모듈은 문자열 구문 분석을 직접 지원하지 않지만 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29a859de34d8206276e4fbe86c78577ef463680" translate="yes" xml:space="preserve">
          <source>And:</source>
          <target state="translated">And:</target>
        </trans-unit>
        <trans-unit id="5d25066343c14fdbc8cd148ee308e69f694558d6" translate="yes" xml:space="preserve">
          <source>Angular conversion</source>
          <target state="translated">각도 변환</target>
        </trans-unit>
        <trans-unit id="fa955e785130d1bfb76908f175692b42dcf5a748" translate="yes" xml:space="preserve">
          <source>Animation control</source>
          <target state="translated">애니메이션 컨트롤</target>
        </trans-unit>
        <trans-unit id="e17e6aa01f27f483f31ae9a05f633ce17a08ca63" translate="yes" xml:space="preserve">
          <source>Annotate each line with a short opcode description.</source>
          <target state="translated">짧은 opcode 설명으로 각 줄에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="c1fbe3f2c0adda2514893a924abcd2d00ba0c968" translate="yes" xml:space="preserve">
          <source>Announces an intention to access data in a specific pattern thus allowing the kernel to make optimizations. The advice applies to the region of the file specified by &lt;em&gt;fd&lt;/em&gt; starting at &lt;em&gt;offset&lt;/em&gt; and continuing for &lt;em&gt;len&lt;/em&gt; bytes. &lt;em&gt;advice&lt;/em&gt; is one of &lt;a href=&quot;#os.POSIX_FADV_NORMAL&quot;&gt;&lt;code&gt;POSIX_FADV_NORMAL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_SEQUENTIAL&quot;&gt;&lt;code&gt;POSIX_FADV_SEQUENTIAL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_RANDOM&quot;&gt;&lt;code&gt;POSIX_FADV_RANDOM&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_NOREUSE&quot;&gt;&lt;code&gt;POSIX_FADV_NOREUSE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_WILLNEED&quot;&gt;&lt;code&gt;POSIX_FADV_WILLNEED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.POSIX_FADV_DONTNEED&quot;&gt;&lt;code&gt;POSIX_FADV_DONTNEED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커널이 최적화 할 수 있도록 특정 패턴으로 데이터에 액세스하려는 의도를 나타냅니다. 조언 은 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작하여 &lt;em&gt;len&lt;/em&gt; 바이트 동안 계속되는 &lt;em&gt;fd로&lt;/em&gt; 지정된 파일 영역에 적용됩니다 . &lt;em&gt;권고&lt;/em&gt; 는 &lt;a href=&quot;#os.POSIX_FADV_NORMAL&quot;&gt; &lt;code&gt;POSIX_FADV_NORMAL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_SEQUENTIAL&quot;&gt; &lt;code&gt;POSIX_FADV_SEQUENTIAL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_RANDOM&quot;&gt; &lt;code&gt;POSIX_FADV_RANDOM&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_NOREUSE&quot;&gt; &lt;code&gt;POSIX_FADV_NOREUSE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_WILLNEED&quot;&gt; &lt;code&gt;POSIX_FADV_WILLNEED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.POSIX_FADV_DONTNEED&quot;&gt; &lt;code&gt;POSIX_FADV_DONTNEED&lt;/code&gt; &lt;/a&gt; 중 하나입니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eddbfc47bdf2815567f148a943ae50904ef48c9e" translate="yes" xml:space="preserve">
          <source>Another Modular Crypt Format method with 16 character salt and 43 character hash based on the SHA-256 hash function.</source>
          <target state="translated">SHA-256 해시 함수를 기반으로 16 자 솔트 및 43 자 해시를 사용하는 다른 모듈 식 암호화 형식 방법.</target>
        </trans-unit>
        <trans-unit id="1489f7e40318e54fcbeae8f12ceaa2e676f89a1d" translate="yes" xml:space="preserve">
          <source>Another Modular Crypt Format method with 22 character salt and 31 character hash based on the Blowfish cipher.</source>
          <target state="translated">복어 암호를 기반으로 22 문자 소금과 31 문자 해시를 사용하는 또 다른 모듈 식 암호화 형식 방법.</target>
        </trans-unit>
        <trans-unit id="cfaedd99a89f28548596fb67a7f378505de1e4e9" translate="yes" xml:space="preserve">
          <source>Another Modular Crypt Format method with 8 character salt and 22 character hash based on the MD5 hash function.</source>
          <target state="translated">MD5 해시 함수를 기반으로 8 문자 솔트와 22 문자 해시를 사용하는 다른 모듈 식 암호화 형식 방법.</target>
        </trans-unit>
        <trans-unit id="59264d0e98298421242f9f70b711b5e947525220" translate="yes" xml:space="preserve">
          <source>Another approach to handling multiple simultaneous requests in an environment that supports neither threads nor &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; (or where these are too expensive or inappropriate for the service) is to maintain an explicit table of partially finished requests and to use &lt;a href=&quot;selectors#module-selectors&quot;&gt;&lt;code&gt;selectors&lt;/code&gt;&lt;/a&gt; to decide which request to work on next (or whether to handle a new incoming request). This is particularly important for stream services where each client can potentially be connected for a long time (if threads or subprocesses cannot be used). See &lt;a href=&quot;asyncore#module-asyncore&quot;&gt;&lt;code&gt;asyncore&lt;/code&gt;&lt;/a&gt; for another way to manage this.</source>
          <target state="translated">스레드 나 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;fork()&lt;/code&gt; &lt;/a&gt; 를 지원하지 않는 환경에서 (또는 서비스에 너무 비싸거나 부적절한 경우 ) 여러 동시 요청을 처리하는 또 다른 방법 은 부분적으로 완료된 요청의 명시적인 테이블을 유지하고 &lt;a href=&quot;selectors#module-selectors&quot;&gt; &lt;code&gt;selectors&lt;/code&gt; &lt;/a&gt; 를 사용 하여 요청을 결정하는 것입니다. 다음에 작업하십시오 (또는 새로운 수신 요청을 처리할지 여부). 이는 스레드 또는 하위 프로세스를 사용할 수없는 경우 각 클라이언트를 오랫동안 연결할 수있는 스트림 서비스에 특히 중요합니다. 이것을 관리하는 다른 방법 은 &lt;a href=&quot;asyncore#module-asyncore&quot;&gt; &lt;code&gt;asyncore&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a6eaecc1b4becc1ce97180c1ca37fd242427bac" translate="yes" xml:space="preserve">
          <source>Another approach to using deques is to maintain a sequence of recently added elements by appending to the right and popping to the left:</source>
          <target state="translated">deques를 사용하는 또 다른 방법은 오른쪽에 추가하고 왼쪽에 팝하여 최근에 추가 된 요소의 순서를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="154eea36fb4a3e04d9685d308f84e6f97bb356c1" translate="yes" xml:space="preserve">
          <source>Another bad idea is to print things that embed an object address, like</source>
          <target state="translated">또 다른 나쁜 아이디어는 객체 주소를 포함하는 것을 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="857365788cdb8b0f09e1949a46fb3dc32e28e350" translate="yes" xml:space="preserve">
          <source>Another client can also use it:</source>
          <target state="translated">다른 클라이언트도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="830cb7a34d4e9668c5f056cdbb14f9a43e0de2af" translate="yes" xml:space="preserve">
          <source>Another example of a reusable, but not reentrant, context manager is &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt;, as it invokes &lt;em&gt;all&lt;/em&gt; currently registered callbacks when leaving any with statement, regardless of where those callbacks were added:</source>
          <target state="translated">재사용 가능하지만 재진입 할 ​​수없는 컨텍스트 관리자의 또 다른 예는 &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 이며, 콜백이 추가 된 위치에 관계없이 with 문을 떠날 때 현재 등록 된 &lt;em&gt;모든&lt;/em&gt; 콜백을 호출 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="970d45390b614e57c3adbeccf052061f6cbb7027" translate="yes" xml:space="preserve">
          <source>Another example that may behave differently from what one would expect is this:</source>
          <target state="translated">예상했던 것과 다르게 행동 할 수있는 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1524e3727b5a15e1e58deafe30417f1f9c6a01f4" translate="yes" xml:space="preserve">
          <source>Another example that uses the &lt;a href=&quot;#shutil.ignore_patterns&quot;&gt;&lt;code&gt;ignore_patterns()&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">&lt;a href=&quot;#shutil.ignore_patterns&quot;&gt; &lt;code&gt;ignore_patterns()&lt;/code&gt; &lt;/a&gt; 도우미 를 사용하는 또 다른 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5cd67ff52eb9c7ecece2900a3c7ca5a0e8906891" translate="yes" xml:space="preserve">
          <source>Another example that uses the &lt;em&gt;ignore&lt;/em&gt; argument to add a logging call:</source>
          <target state="translated">&lt;em&gt;ignore&lt;/em&gt; 인수를 사용하여 로깅 호출을 추가하는 다른 예 :</target>
        </trans-unit>
        <trans-unit id="a012876e7eec4d9cf2933f51ae341f5f02747bc6" translate="yes" xml:space="preserve">
          <source>Another function is provided to reverse the tokenization process. This is useful for creating tools that tokenize a script, modify the token stream, and write back the modified script.</source>
          <target state="translated">토큰 화 프로세스를 취소하기위한 다른 기능이 제공됩니다. 이는 스크립트를 토큰 화하고 토큰 스트림을 수정하며 수정 된 스크립트를 다시 작성하는 도구를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1345847ee9d2d8f4b40cf2bd43a2a8f4b81d19c5" translate="yes" xml:space="preserve">
          <source>Another important difference between &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is that if no flags are set (the value is 0), its boolean evaluation is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 의&lt;/a&gt; 또 다른 중요한 차이점은 플래그가 설정되지 않은 경우 (값이 0 임) 부울 평가는 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd138c705d1febdcd3cd71c72f455f7d8136282" translate="yes" xml:space="preserve">
          <source>Another option is to pass &lt;a href=&quot;functions#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; to the &lt;em&gt;globals&lt;/em&gt; parameter, which will cause the code to be executed within your current global namespace. This can be more convenient than individually specifying imports:</source>
          <target state="translated">또 다른 옵션은 &lt;a href=&quot;functions#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 를 &lt;em&gt;globals&lt;/em&gt; 매개 변수에 전달하는 것입니다.이 경우 현재 전역 네임 스페이스 내에서 코드가 실행됩니다. 개별적으로 가져 오기를 지정하는 것보다 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7d89ebe791f42c5af101c46d42ea21377b531087" translate="yes" xml:space="preserve">
          <source>Another similar &lt;a href=&quot;asyncio-stream#asyncio-example-create-connection-streams&quot;&gt;example&lt;/a&gt; using the high-level &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt;&lt;code&gt;asyncio.open_connection()&lt;/code&gt;&lt;/a&gt; function and streams.</source>
          <target state="translated">고급 &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt; &lt;code&gt;asyncio.open_connection()&lt;/code&gt; &lt;/a&gt; 함수 및 스트림을 사용하는 또 다른 유사한 &lt;a href=&quot;asyncio-stream#asyncio-example-create-connection-streams&quot;&gt;예&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b12cf40ba46cdbcdda739851e799c9deed7beda0" translate="yes" xml:space="preserve">
          <source>Another simple application of doctest is testing interactive examples in a text file. This can be done with the &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">doctest의 또 다른 간단한 적용은 텍스트 파일에서 대화식 예제를 테스트하는 것입니다. 이 작업은 수행 할 수 있습니다 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="380a1673c02d6ffedb7ef8ccb17de0d7583fd47b" translate="yes" xml:space="preserve">
          <source>Another solution to the problem of non-comparable tasks is to create a wrapper class that ignores the task item and only compares the priority field:</source>
          <target state="translated">비교할 수없는 작업 문제에 대한 또 다른 해결책은 작업 항목을 무시하고 우선 순위 필드 만 비교하는 랩퍼 클래스를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f5e78d9ba1c7a1f17d713904f11c8fb976e77d2" translate="yes" xml:space="preserve">
          <source>Another specification of the format, with details on locking.</source>
          <target state="translated">잠금에 대한 세부 사항이있는 형식의 다른 스펙.</target>
        </trans-unit>
        <trans-unit id="e0a6209aa300b723ce63cb3581b82c93359f079d" translate="yes" xml:space="preserve">
          <source>Another specification of the format. Describes a common extension for supporting folders.</source>
          <target state="translated">형식의 다른 사양. 폴더를 지원하기위한 일반적인 확장명을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="259c6f7c7f71afa5d1276a3716f6996db84a2e2c" translate="yes" xml:space="preserve">
          <source>Another test-support module with a very different flavor.</source>
          <target state="translated">맛이 매우 다른 또 다른 테스트 지원 모듈.</target>
        </trans-unit>
        <trans-unit id="e52e511337918750293ba11f89a9f569c1bc3067" translate="yes" xml:space="preserve">
          <source>Another use case might be to replace an object with an &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="translated">또 다른 사용 사례는 객체를 &lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 인스턴스 로 교체하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="62a6c1f548ab752cd5952e7bc0d4d963e5bf6502" translate="yes" xml:space="preserve">
          <source>Another way to encode binary hashes for non-binary environments.</source>
          <target state="translated">비 이진 환경에 대한 이진 해시를 인코딩하는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fefd86df1dfa20cdf5dc78f24eca9be7a5e90b0f" translate="yes" xml:space="preserve">
          <source>Another way to handle this is with the following example:</source>
          <target state="translated">이를 처리하는 다른 방법은 다음 예제를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16e0cebdfbbfd2a87dc6c52fdedb0b3db0e01e83" translate="yes" xml:space="preserve">
          <source>Another way to use variable-sized data types with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; is to use the dynamic nature of Python, and (re-)define the data type after the required size is already known, on a case by case basis.</source>
          <target state="translated">&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 와 함께 가변 크기 데이터 유형을 사용하는 또 다른 방법 은 Python의 동적 특성을 사용하고 필요한 크기가 이미 알려진 후에 데이터 유형을 경우에 따라 재정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0aafffa028c1a77c7cc61a286a8bfa21a85356c" translate="yes" xml:space="preserve">
          <source>Answered</source>
          <target state="translated">Answered</target>
        </trans-unit>
        <trans-unit id="af5a6d2c7bcbd0595666bd7855f0f03cca3bf497" translate="yes" xml:space="preserve">
          <source>Any changes to any context variables that &lt;em&gt;callable&lt;/em&gt; makes will be contained in the context object:</source>
          <target state="translated">&lt;em&gt;호출&lt;/em&gt; 가능한 컨텍스트 변수에 대한 변경 사항 은 컨텍스트 객체에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8e39a27177f793a03dc9f620dad817066a7f33c1" translate="yes" xml:space="preserve">
          <source>Any classes found are recursively searched similarly, to test docstrings in their contained methods and nested classes.</source>
          <target state="translated">발견 된 모든 클래스는 포함 된 메소드 및 중첩 클래스에서 docstring을 테스트하기 위해 유사하게 재귀 적으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="f798ac81b2f74b659d7f586dd5eabb5ce15db13e" translate="yes" xml:space="preserve">
          <source>Any container can be passed as the &lt;em&gt;choices&lt;/em&gt; value, so &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; objects, &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; objects, and custom containers are all supported.</source>
          <target state="translated">모든 컨테이너는 &lt;em&gt;선택 사항&lt;/em&gt; 값 으로 전달 될 수 있으므로 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 오브젝트, &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 오브젝트 및 사용자 정의 컨테이너가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="96d6483718787eb0c399b57df09b4bd366515f2b" translate="yes" xml:space="preserve">
          <source>Any detected nonconformance results in an &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; being raised; note, however, that how these errors are handled is server-dependent. For example, &lt;a href=&quot;#module-wsgiref.simple_server&quot;&gt;&lt;code&gt;wsgiref.simple_server&lt;/code&gt;&lt;/a&gt; and other servers based on &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt;&lt;code&gt;wsgiref.handlers&lt;/code&gt;&lt;/a&gt; (that don&amp;rsquo;t override the error handling methods to do something else) will simply output a message that an error has occurred, and dump the traceback to &lt;code&gt;sys.stderr&lt;/code&gt; or some other error stream.</source>
          <target state="translated">감지 된 부적합으로 인해 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 그러나 이러한 오류를 처리하는 방법은 서버에 따라 다릅니다. 예를 들어 &lt;a href=&quot;#module-wsgiref.simple_server&quot;&gt; &lt;code&gt;wsgiref.simple_server&lt;/code&gt; &lt;/a&gt; 에 기초하여 다른 서버 &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt; &lt;code&gt;wsgiref.handlers&lt;/code&gt; &lt;/a&gt; (즉, 다른 뭔가를 할 방법을 처리하는 오류를 무시하지 않음) 단순히 출력 메시지가 오류가 발생하고,에 역 추적을 덤프 한 것을 &lt;code&gt;sys.stderr&lt;/code&gt; 를 또는 일부 다른 오류 스트림.</target>
        </trans-unit>
        <trans-unit id="c3161a1f48d49aece84ad1e7ba2994c99487c066" translate="yes" xml:space="preserve">
          <source>Any expected output must immediately follow the final &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; or &lt;code&gt;'... '&lt;/code&gt; line containing the code, and the expected output (if any) extends to the next &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; or all-whitespace line.</source>
          <target state="translated">예상되는 출력은 코드를 포함 하는 마지막 &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; 또는 &lt;code&gt;'... '&lt;/code&gt; 줄 바로 뒤에 와야하며 예상되는 출력 (있는 경우)은 다음 &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; 또는 전체 공백 줄로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="16ef8204c61c9a1813182c916e1e34ec0c335625" translate="yes" xml:space="preserve">
          <source>Any files may be present in the ZIP archive, but only files &lt;code&gt;.py&lt;/code&gt; and &lt;code&gt;.pyc&lt;/code&gt; are available for import. ZIP import of dynamic modules (&lt;code&gt;.pyd&lt;/code&gt;, &lt;code&gt;.so&lt;/code&gt;) is disallowed. Note that if an archive only contains &lt;code&gt;.py&lt;/code&gt; files, Python will not attempt to modify the archive by adding the corresponding &lt;code&gt;.pyc&lt;/code&gt; file, meaning that if a ZIP archive doesn&amp;rsquo;t contain &lt;code&gt;.pyc&lt;/code&gt; files, importing may be rather slow.</source>
          <target state="translated">ZIP 아카이브에는 모든 파일이있을 수 있지만 &lt;code&gt;.py&lt;/code&gt; 및 &lt;code&gt;.pyc&lt;/code&gt; 파일 만 가져올 수 있습니다. 동적 모듈 ( &lt;code&gt;.pyd&lt;/code&gt; , &lt;code&gt;.so&lt;/code&gt; ) 의 ZIP 가져 오기 는 허용되지 않습니다. 아카이브에 &lt;code&gt;.py&lt;/code&gt; 파일 만 포함 된 경우 Python은 해당 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 추가하여 아카이브를 수정하려고 시도 하지 않습니다. 즉, ZIP 아카이브에 &lt;code&gt;.pyc&lt;/code&gt; 파일 이 없으면 가져 오기 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8dee1375bcf6a8c6c517898f5fc97f065da4ba9" translate="yes" xml:space="preserve">
          <source>Any form of network IO; &lt;code&gt;recv()&lt;/code&gt; and &lt;code&gt;send()&lt;/code&gt; read and write only to the underlying &lt;a href=&quot;#ssl.MemoryBIO&quot;&gt;&lt;code&gt;MemoryBIO&lt;/code&gt;&lt;/a&gt; buffers.</source>
          <target state="translated">모든 형태의 네트워크 IO; &lt;code&gt;recv()&lt;/code&gt; 및 &lt;code&gt;send()&lt;/code&gt; 는 기본 &lt;a href=&quot;#ssl.MemoryBIO&quot;&gt; &lt;code&gt;MemoryBIO&lt;/code&gt; &lt;/a&gt; 버퍼 에만 읽고 씁니다 .</target>
        </trans-unit>
        <trans-unit id="0f114f3ceee9858acec62bd48fb36dd2e76f81ac" translate="yes" xml:space="preserve">
          <source>Any header object, or any header that is refolded due to the policy settings, is folded using an algorithm that fully implements the RFC folding algorithms, including knowing where encoded words are required and allowed.</source>
          <target state="translated">인코딩 된 단어가 필요한 위치와 허용되는 위치를 포함하여 RFC 폴딩 알고리즘을 완전히 구현하는 알고리즘을 사용하여 모든 헤더 개체 또는 정책 설정으로 인해 다시 접힌 헤더가 접 힙니다.</target>
        </trans-unit>
        <trans-unit id="87a66302b5c5f0a22de125246046b1cdfffefa6b" translate="yes" xml:space="preserve">
          <source>Any object can be tested for truth value, for use in an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; condition or as operand of the Boolean operations below.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 조건에서 사용하거나 아래 부울 연산의 피연산자로 사용하기 위해 모든 값을 진리 값으로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b871425be90d75ff7f0f750362354908800f258b" translate="yes" xml:space="preserve">
          <source>Any other appearance of &lt;code&gt;$&lt;/code&gt; in the string will result in a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; being raised.</source>
          <target state="translated">문자열 에 &lt;code&gt;$&lt;/code&gt; 가 표시 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32e241730c485594f505f9764a3cbc96f2e45b62" translate="yes" xml:space="preserve">
          <source>Any other keys in the dictionary are ignored, to allow for future extensions. If the path cannot be handled, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">향후 확장을 위해 사전의 다른 키는 무시됩니다. 경로를 처리 할 수 ​​없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d4f45530c29236c208822a755f335ab895f7ae9" translate="yes" xml:space="preserve">
          <source>Any valid Python identifier may be used for a fieldname except for names starting with an underscore. Valid identifiers consist of letters, digits, and underscores but do not start with a digit or underscore and cannot be a &lt;a href=&quot;keyword#module-keyword&quot;&gt;&lt;code&gt;keyword&lt;/code&gt;&lt;/a&gt; such as &lt;em&gt;class&lt;/em&gt;, &lt;em&gt;for&lt;/em&gt;, &lt;em&gt;return&lt;/em&gt;, &lt;em&gt;global&lt;/em&gt;, &lt;em&gt;pass&lt;/em&gt;, or &lt;em&gt;raise&lt;/em&gt;.</source>
          <target state="translated">밑줄로 시작하는 이름을 제외한 모든 유효한 Python 식별자를 필드 이름에 사용할 수 있습니다. 유효한 식별자는 문자, 숫자 및 밑줄로 구성되지만 숫자 또는 밑줄로 시작하지 않으며 &lt;em&gt;class&lt;/em&gt; , &lt;em&gt;for&lt;/em&gt; , &lt;em&gt;return&lt;/em&gt; , &lt;em&gt;global&lt;/em&gt; , &lt;em&gt;pass&lt;/em&gt; 또는 &lt;em&gt;raise&lt;/em&gt; 와 같은 &lt;a href=&quot;keyword#module-keyword&quot;&gt; &lt;code&gt;keyword&lt;/code&gt; &lt;/a&gt; 될 수 없습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1518232458ae063224b67a33fbc39f874e6e7652" translate="yes" xml:space="preserve">
          <source>Any value error related to the address.</source>
          <target state="translated">주소와 관련된 모든 값 오류.</target>
        </trans-unit>
        <trans-unit id="71a52ce7a5fdb3bd7ec0934cf4eb202d8034ff6e" translate="yes" xml:space="preserve">
          <source>Any value error related to the net mask.</source>
          <target state="translated">넷 마스크와 관련된 모든 값 오류.</target>
        </trans-unit>
        <trans-unit id="f5f7839523439ed5db0c3285770ed6a7ad0ef07d" translate="yes" xml:space="preserve">
          <source>Apart from &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt;&lt;code&gt;getboolean()&lt;/code&gt;&lt;/a&gt;, config parsers also provide equivalent &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt;&lt;code&gt;getint()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt;&lt;code&gt;getfloat()&lt;/code&gt;&lt;/a&gt; methods. You can register your own converters and customize the provided ones. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt; &lt;code&gt;getboolean()&lt;/code&gt; &lt;/a&gt; 외에도 구성 파서는 동등한 &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt; &lt;code&gt;getint()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt; &lt;code&gt;getfloat()&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다. 자신의 변환기를 등록하고 제공된 변환기를 사용자 정의 할 수 있습니다. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="004e30185abf19283aba3fcb4dd5458909228910" translate="yes" xml:space="preserve">
          <source>Apart from making the code (potentially) compatible with Windows and the other start methods this also ensures that as long as the child process is still alive the object will not be garbage collected in the parent process. This might be important if some resource is freed when the object is garbage collected in the parent process.</source>
          <target state="translated">Windows 및 기타 시작 방법과 코드를 (잠재적으로) 호환 가능하게 만드는 것 외에도 자식 프로세스가 계속 존재하는 한 부모 프로세스에서 개체가 가비지 수집되지 않습니다. 부모 프로세스에서 개체가 가비지 수집 될 때 일부 리소스가 해제 된 경우 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f8e3f0f5b15c39aef46bc951d434aa2f994181" translate="yes" xml:space="preserve">
          <source>Apart from the node classes, the &lt;a href=&quot;#module-ast&quot;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt; module defines these utility functions and classes for traversing abstract syntax trees:</source>
          <target state="translated">노드 클래스 외에도 &lt;a href=&quot;#module-ast&quot;&gt; &lt;code&gt;ast&lt;/code&gt; &lt;/a&gt; 모듈은 추상 구문 트리를 순회하기 위해 다음 유틸리티 함수와 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="41def7a0febe741da87c5b79ce78ce27b83f3ae7" translate="yes" xml:space="preserve">
          <source>Appearance</source>
          <target state="translated">Appearance</target>
        </trans-unit>
        <trans-unit id="7c6156597bec64b2efa893f896b414ba015b84f0" translate="yes" xml:space="preserve">
          <source>Append &lt;em&gt;line&lt;/em&gt; to the history buffer, as if it was the last line typed. This calls &lt;code&gt;add_history()&lt;/code&gt; in the underlying library.</source>
          <target state="translated">추가]의 &lt;em&gt;라인&lt;/em&gt; 이 인 것처럼 역사 버퍼는, 마지막 줄에 입력했습니다. 기본 라이브러리에서 &lt;code&gt;add_history()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="15e3d810f53a90235f3be7ee31ad204835b47079" translate="yes" xml:space="preserve">
          <source>Append &lt;em&gt;message&lt;/em&gt; to named mailbox.</source>
          <target state="translated">명명 된 사서함에 &lt;em&gt;메시지&lt;/em&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="5012b56fdb1fabff75d417024359f5123b3c7cf5" translate="yes" xml:space="preserve">
          <source>Append a new action at the end. The &lt;em&gt;cmd&lt;/em&gt; variable must be a valid bourne shell command. The &lt;em&gt;kind&lt;/em&gt; variable consists of two letters.</source>
          <target state="translated">끝에 새로운 행동을 추가하십시오. &lt;em&gt;cmd를의&lt;/em&gt; 변수는 유효한 본 셸 명령이어야합니다. &lt;em&gt;종류의&lt;/em&gt; 변수는 두 글자로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb2f2dddbf426366118168a9e541a67ab5450c2" translate="yes" xml:space="preserve">
          <source>Append a new item with value &lt;em&gt;x&lt;/em&gt; to the end of the array.</source>
          <target state="translated">값이 &lt;em&gt;x 인&lt;/em&gt; 새 항목을 배열 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bec2f10908ba5de36daf156b98af3c60ee338f32" translate="yes" xml:space="preserve">
          <source>Append items from &lt;em&gt;iterable&lt;/em&gt; to the end of the array. If &lt;em&gt;iterable&lt;/em&gt; is another array, it must have &lt;em&gt;exactly&lt;/em&gt; the same type code; if not, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be raised. If &lt;em&gt;iterable&lt;/em&gt; is not an array, it must be iterable and its elements must be the right type to be appended to the array.</source>
          <target state="translated">&lt;em&gt;반복 가능한&lt;/em&gt; 항목부터 배열의 끝까지 항목을 추가합니다 . 경우 &lt;em&gt;반복 가능한이&lt;/em&gt; 다른 배열이, 그것은이 있어야 &lt;em&gt;정확히&lt;/em&gt; 같은 종류의 코드; 그렇지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;em&gt;iterable&lt;/em&gt; 이 배열이 아닌 경우 &lt;em&gt;iterable&lt;/em&gt; 이어야하며 해당 요소는 배열에 추가 할 올바른 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="70b18019b4972b108e37841f15945c9d21d175bf" translate="yes" xml:space="preserve">
          <source>Append items from the list. This is equivalent to &lt;code&gt;for x in list:
a.append(x)&lt;/code&gt; except that if there is a type error, the array is unchanged.</source>
          <target state="translated">목록에서 항목을 추가하십시오. 이것은 유형 오류가있는 경우 배열이 변경되지 않는다는 점을 제외하고 &lt;code&gt;for x in list: a.append(x)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="44b7a672882b72ed3eb65f4fc161e2735a4aad2e" translate="yes" xml:space="preserve">
          <source>Append the callable &lt;em&gt;hook&lt;/em&gt; to the list of active auditing hooks for the current interpreter.</source>
          <target state="translated">현재 인터프리터의 활성 감사 후크 목록에 호출 가능 &lt;em&gt;후크&lt;/em&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb08b061999d25be95bd753505fb9df32467aab4" translate="yes" xml:space="preserve">
          <source>Append the last &lt;em&gt;nelements&lt;/em&gt; items of history to a file. The default filename is &lt;code&gt;~/.history&lt;/code&gt;. The file must already exist. This calls &lt;code&gt;append_history()&lt;/code&gt; in the underlying library. This function only exists if Python was compiled for a version of the library that supports it.</source>
          <target state="translated">히스토리 의 마지막 &lt;em&gt;nelements&lt;/em&gt; 항목을 파일에 추가 하십시오. 기본 파일 이름은 &lt;code&gt;~/.history&lt;/code&gt; 입니다. 파일이 이미 존재해야합니다. 기본 라이브러리에서 &lt;code&gt;append_history()&lt;/code&gt; 를 호출 합니다. 이 함수는 Python이이를 지원하는 라이브러리 버전 용으로 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2c421a3b35b989d4ece772b4d7f4d642bcef1d02" translate="yes" xml:space="preserve">
          <source>Append the record to the buffer. If &lt;a href=&quot;#logging.handlers.BufferingHandler.shouldFlush&quot;&gt;&lt;code&gt;shouldFlush()&lt;/code&gt;&lt;/a&gt; returns true, call &lt;a href=&quot;#logging.handlers.BufferingHandler.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; to process the buffer.</source>
          <target state="translated">레코드를 버퍼에 추가하십시오. &lt;a href=&quot;#logging.handlers.BufferingHandler.shouldFlush&quot;&gt; &lt;code&gt;shouldFlush()&lt;/code&gt; &lt;/a&gt; 가 true를 리턴 하면 &lt;a href=&quot;#logging.handlers.BufferingHandler.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 버퍼를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="b6428efcfa3b692ae0853afc12b91104655bc067" translate="yes" xml:space="preserve">
          <source>Append the string &lt;em&gt;s&lt;/em&gt; to the MIME header.</source>
          <target state="translated">추가] 문자열 &lt;em&gt;s의&lt;/em&gt; MIME 헤더에.</target>
        </trans-unit>
        <trans-unit id="63afd5dcef3cb2a0dae141c8bb5ab6871063eaa8" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;subelements&lt;/em&gt; from a sequence object with zero or more elements. Raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if a subelement is not an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;em&gt;서브 엘리먼트&lt;/em&gt; 는 0 개 이상의 요소가 시퀀스에서 객체. 발생시킵니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 하위 요소가 아닌 경우 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bceea9f719c67ae44ec147e59a3ff45f6a13a85" translate="yes" xml:space="preserve">
          <source>Appends items from the string, interpreting the string as an array of machine values (as if it had been read from a file using the &lt;a href=&quot;#array.array.fromfile&quot;&gt;&lt;code&gt;fromfile()&lt;/code&gt;&lt;/a&gt; method).</source>
          <target state="translated">문자열을 기계 값의 배열로 해석하여 문자열에서 항목을 추가합니다 ( &lt;a href=&quot;#array.array.fromfile&quot;&gt; &lt;code&gt;fromfile()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 파일에서 읽은 것처럼 ).</target>
        </trans-unit>
        <trans-unit id="e26d38984e101ccc199d48ef993f80d0a613b479" translate="yes" xml:space="preserve">
          <source>Apple&amp;rsquo;s documentation of the file format.</source>
          <target state="translated">파일 형식에 대한 Apple의 설명서</target>
        </trans-unit>
        <trans-unit id="09c258e5edf35ac67db5d64e7635e8a3d86b778e" translate="yes" xml:space="preserve">
          <source>Application developers should typically use the high-level asyncio functions, such as &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt;, and should rarely need to reference the loop object or call its methods. This section is intended mostly for authors of lower-level code, libraries, and frameworks, who need finer control over the event loop behavior.</source>
          <target state="translated">애플리케이션 개발자는 일반적으로 &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; 과 같은 고급 asyncio 함수를 사용해야하며 루프 객체를 참조하거나 해당 메소드를 호출 할 필요가 거의 없습니다. 이 섹션은 주로 이벤트 루프 동작을보다 세밀하게 제어해야하는 하위 수준 코드, 라이브러리 및 프레임 워크 작성자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="ad91f8ac2108f501e8aa1719fa2b68f46b05d5af" translate="yes" xml:space="preserve">
          <source>Applications can add their own callbacks to this list. The primary use cases are:</source>
          <target state="translated">애플리케이션은이 목록에 자체 콜백을 추가 할 수 있습니다. 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15e3de344c6c36974c5693ae0deb456a758bdd3d" translate="yes" xml:space="preserve">
          <source>Applications may store arbitrary objects in these attributes.</source>
          <target state="translated">응용 프로그램은 이러한 속성에 임의의 개체를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c498690ce78323bc09d2e18d14d4892b6e8abd0" translate="yes" xml:space="preserve">
          <source>Applications should not &lt;a href=&quot;http://cwe.mitre.org/data/definitions/257.html&quot;&gt;store passwords in a recoverable format&lt;/a&gt;, whether plain text or encrypted. They should be salted and hashed using a cryptographically-strong one-way (irreversible) hash function.</source>
          <target state="translated">응용 프로그램은 일반 텍스트 또는 암호화 된 &lt;a href=&quot;http://cwe.mitre.org/data/definitions/257.html&quot;&gt;암호를 복구 가능한 형식으로 저장&lt;/a&gt; 해서는 안됩니다 . 암호화 방식으로 강력한 단방향 (돌이킬 수없는) 해시 기능을 사용하여 소금에 절이고 해시해야합니다.</target>
        </trans-unit>
        <trans-unit id="9516d3c40d5579ce0328d2d1808e751ea327f8e2" translate="yes" xml:space="preserve">
          <source>Applications that can&amp;rsquo;t bear wall-time ambiguities should explicitly check the value of the &lt;a href=&quot;#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute or avoid using hybrid &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclasses; there are no ambiguities when using &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt;, or any other fixed-offset &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass (such as a class representing only EST (fixed offset -5 hours), or only EDT (fixed offset -4 hours)).</source>
          <target state="translated">Wall-Time 모호성을 견딜 수없는 응용 프로그램은 &lt;a href=&quot;#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 속성 값을 명시 적으로 확인 하거나 하이브리드 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스를 사용하지 않아야합니다 . &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 또는 기타 고정 오프셋 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 (예 : EST 만 (고정 오프셋 -5 시간) 또는 EDT (고정 오프셋 -4 시간) 만 나타내는 클래스)를 사용할 때는 모호성이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0719959018ae4f7d3b51e5a78769bd3b0ca3df46" translate="yes" xml:space="preserve">
          <source>Applications that need to operate on potentially improperly quoted URLs that may contain non-ASCII data will need to do their own decoding from bytes to characters before invoking the URL parsing methods.</source>
          <target state="translated">비 ASCII 데이터를 포함 할 수있는 잘못 인용 된 URL에서 작동해야하는 응용 프로그램은 URL 구문 분석 방법을 호출하기 전에 바이트에서 문자로 자체 디코딩을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fafdab997b122fcdc3b5c0971f1785992cabff68" translate="yes" xml:space="preserve">
          <source>Applications will create objects of this class for use in the &lt;a href=&quot;#xml.sax.xmlreader.XMLReader.parse&quot;&gt;&lt;code&gt;XMLReader.parse()&lt;/code&gt;&lt;/a&gt; method and for returning from EntityResolver.resolveEntity.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;#xml.sax.xmlreader.XMLReader.parse&quot;&gt; &lt;code&gt;XMLReader.parse()&lt;/code&gt; &lt;/a&gt; 메소드에서 사용하고 EntityResolver.resolveEntity에서 리턴 하기 위해이 클래스의 오브젝트를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e7284143fe53744047558a065875930ca468cf98" translate="yes" xml:space="preserve">
          <source>Applies the logical operation &lt;em&gt;and&lt;/em&gt; between each operand&amp;rsquo;s digits.</source>
          <target state="translated">논리 연산 적용 &lt;em&gt;및&lt;/em&gt; 각 피연산자의 숫자 사이를.</target>
        </trans-unit>
        <trans-unit id="37c10a7d11316205bdac710e988348ca767a1a19" translate="yes" xml:space="preserve">
          <source>Applies the logical operation &lt;em&gt;or&lt;/em&gt; between each operand&amp;rsquo;s digits.</source>
          <target state="translated">논리 연산을 적용 &lt;em&gt;하거나&lt;/em&gt; 각 피연산자의 숫자 사이에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="a0b520db8cdcd1e798321610d25b1d0aa46d3781" translate="yes" xml:space="preserve">
          <source>Applies the logical operation &lt;em&gt;xor&lt;/em&gt; between each operand&amp;rsquo;s digits.</source>
          <target state="translated">논리 연산의 적용 &lt;em&gt;XOR&lt;/em&gt; 각 피연산자의 숫자 사이를.</target>
        </trans-unit>
        <trans-unit id="c6347e1f0ae0fe6eb691488a3a3790d194631241" translate="yes" xml:space="preserve">
          <source>Apply &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; rules on unverifiable transactions even to Netscape cookies.</source>
          <target state="translated">검증 할 수없는 거래에 대해 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 규칙을 Netscape 쿠키에도 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6c11221fbbce04188875f4bbd9a5712dd69e34a" translate="yes" xml:space="preserve">
          <source>Apply &lt;em&gt;function&lt;/em&gt; of two arguments cumulatively to the items of &lt;em&gt;iterable&lt;/em&gt;, from left to right, so as to reduce the iterable to a single value. For example, &lt;code&gt;reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])&lt;/code&gt; calculates &lt;code&gt;((((1+2)+3)+4)+5)&lt;/code&gt;. The left argument, &lt;em&gt;x&lt;/em&gt;, is the accumulated value and the right argument, &lt;em&gt;y&lt;/em&gt;, is the update value from the &lt;em&gt;iterable&lt;/em&gt;. If the optional &lt;em&gt;initializer&lt;/em&gt; is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If &lt;em&gt;initializer&lt;/em&gt; is not given and &lt;em&gt;iterable&lt;/em&gt; contains only one item, the first item is returned.</source>
          <target state="translated">iterable을 단일 값으로 줄이기 위해 두 인수의 &lt;em&gt;함수&lt;/em&gt; 를 왼쪽에서 오른쪽 으로 &lt;em&gt;iterable&lt;/em&gt; 의 항목에 누적 적으로 적용하십시오 . 예를 들어, &lt;code&gt;reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])&lt;/code&gt; 는 &lt;code&gt;((((1+2)+3)+4)+5)&lt;/code&gt; 를 계산 합니다. 왼쪽 인수 &lt;em&gt;x&lt;/em&gt; 는 누적 값이고 오른쪽 인수 &lt;em&gt;y&lt;/em&gt; 는 &lt;em&gt;iterable&lt;/em&gt; 의 업데이트 값입니다 . 선택적 &lt;em&gt;이니셜 라이저&lt;/em&gt; 가 있으면 계산에서 이터 러블 항목 앞에 배치되고 이터 러블이 비어있을 때 기본값으로 사용됩니다. 경우 &lt;em&gt;초기화가&lt;/em&gt; 제공되지 않고 &lt;em&gt;반복 가능한이&lt;/em&gt; 하나의 항목이 들어있는 첫 번째 항목이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6f6b8050ae59615c4994444f8cdf9e2812e29cae" translate="yes" xml:space="preserve">
          <source>Apply this handler&amp;rsquo;s filters to the record and return &lt;code&gt;True&lt;/code&gt; if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be emitted. If one returns a false value, the handler will not emit the record.</source>
          <target state="translated">이 핸들러의 필터를 레코드에 적용 하고 레코드가 처리 될 경우 &lt;code&gt;True&lt;/code&gt; 를 리턴 하십시오. 필터 중 하나가 잘못된 값을 반환 할 때까지 필터를 차례로 참조합니다. 둘 중 어느 것도 잘못된 값을 반환하지 않으면 레코드가 생성됩니다. 거짓 값을 반환하면 처리기는 레코드를 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75727d4b37b8d6f61c121aa55945e43277e79623" translate="yes" xml:space="preserve">
          <source>Apply this logger&amp;rsquo;s filters to the record and return &lt;code&gt;True&lt;/code&gt; if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be processed (passed to handlers). If one returns a false value, no further processing of the record occurs.</source>
          <target state="translated">이 로거의 필터를 레코드에 적용 하고 레코드를 처리하려면 &lt;code&gt;True&lt;/code&gt; 를 리턴 하십시오. 필터 중 하나가 잘못된 값을 반환 할 때까지 필터를 차례로 참조합니다. 둘 중 하나라도 잘못된 값을 반환하지 않으면 레코드가 처리됩니다 (핸들러로 전달됨). 잘못된 값을 반환하면 더 이상 레코드를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5f8992ee05391b7dd15844b0a81da4dcbca1d1a" translate="yes" xml:space="preserve">
          <source>Apply, test or remove a POSIX lock on an open file descriptor. &lt;em&gt;fd&lt;/em&gt; is an open file descriptor. &lt;em&gt;cmd&lt;/em&gt; specifies the command to use - one of &lt;a href=&quot;#os.F_LOCK&quot;&gt;&lt;code&gt;F_LOCK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.F_TLOCK&quot;&gt;&lt;code&gt;F_TLOCK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.F_ULOCK&quot;&gt;&lt;code&gt;F_ULOCK&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.F_TEST&quot;&gt;&lt;code&gt;F_TEST&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;len&lt;/em&gt; specifies the section of the file to lock.</source>
          <target state="translated">열린 파일 디스크립터에서 POSIX 잠금을 적용, 테스트 또는 제거하십시오. &lt;em&gt;fd&lt;/em&gt; 는 열린 파일 디스크립터입니다. &lt;em&gt;cmd&lt;/em&gt; 는 &lt;a href=&quot;#os.F_LOCK&quot;&gt; &lt;code&gt;F_LOCK&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.F_TLOCK&quot;&gt; &lt;code&gt;F_TLOCK&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.F_ULOCK&quot;&gt; &lt;code&gt;F_ULOCK&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.F_TEST&quot;&gt; &lt;code&gt;F_TEST&lt;/code&gt; &lt;/a&gt; 중 하나를 사용하도록 명령을 지정합니다 . &lt;em&gt;len&lt;/em&gt; 은 잠글 파일 섹션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="83c16cf7fbf4a6d50f42643443798c0192cc0915" translate="yes" xml:space="preserve">
          <source>Applying the reverse conversion to &lt;code&gt;3740.0&lt;/code&gt; gives a different hexadecimal string representing the same number:</source>
          <target state="translated">&lt;code&gt;3740.0&lt;/code&gt; 에 역변환을 적용하면 동일한 숫자를 나타내는 다른 16 진 문자열이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="06bee686a5eaf240f9c56fe230e927f0bbd2a171" translate="yes" xml:space="preserve">
          <source>Applying the same patch to every test method</source>
          <target state="translated">모든 테스트 방법에 동일한 패치 적용</target>
        </trans-unit>
        <trans-unit id="c570ce78a064ac6afc5df19b2e24947c18c38dc5" translate="yes" xml:space="preserve">
          <source>Approximating &lt;a href=&quot;#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">근사 &lt;a href=&quot;#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="aa559da736898dbd0d15602df291a370ff954c58" translate="yes" xml:space="preserve">
          <source>Archive names should be relative to the archive root, that is, they should not start with a path separator.</source>
          <target state="translated">아카이브 이름은 아카이브 루트에 상대적이어야합니다. 즉, 경로 구분 기호로 시작해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4e93a940c9f8e4f679d6284bd8a795953316844a" translate="yes" xml:space="preserve">
          <source>Archiving example</source>
          <target state="translated">보관 예</target>
        </trans-unit>
        <trans-unit id="0c2ca1a37605ad24f1be144c9f7d4cb1b3101631" translate="yes" xml:space="preserve">
          <source>Archiving operations</source>
          <target state="translated">보관 작업</target>
        </trans-unit>
        <trans-unit id="71f392576d7e147141bf396686950b09802b28f4" translate="yes" xml:space="preserve">
          <source>Arg list too long</source>
          <target state="translated">인수 목록이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="8126f6e897947aa2bcce9fdc2c65455309bc87d1" translate="yes" xml:space="preserve">
          <source>Argument &lt;em&gt;flags&lt;/em&gt; takes the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;bitwise OR&lt;/a&gt; of option flags. See section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt;. Only &amp;ldquo;reporting flags&amp;rdquo; can be used.</source>
          <target state="translated">인수 &lt;em&gt;플래그&lt;/em&gt; 는 옵션 플래그 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;비트 단위 OR&lt;/a&gt; 을 사용합니다. &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션을 참조하십시오 . &quot;보고 플래그&quot;만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49cda49e510f79a25d5fe2cd3ec5f12c16ca5615" translate="yes" xml:space="preserve">
          <source>Argument &lt;em&gt;module&lt;/em&gt; is a module object, or dotted name of a module, containing the object whose doctests are of interest. Argument &lt;em&gt;name&lt;/em&gt; is the name (within the module) of the object with the doctests of interest. The result is a string, containing the object&amp;rsquo;s docstring converted to a Python script, as described for &lt;a href=&quot;#doctest.script_from_examples&quot;&gt;&lt;code&gt;script_from_examples()&lt;/code&gt;&lt;/a&gt; above. For example, if module &lt;code&gt;a.py&lt;/code&gt; contains a top-level function &lt;code&gt;f()&lt;/code&gt;, then</source>
          <target state="translated">인수 &lt;em&gt;모듈&lt;/em&gt; 은 doctest가 관심있는 객체를 포함하는 모듈 객체 또는 모듈의 점으로 구분 된 이름입니다. 인수 &lt;em&gt;이름&lt;/em&gt; 은 관심이있는 doctest를 가진 오브젝트의 이름 (모듈 내)입니다. 결과는 위의 &lt;a href=&quot;#doctest.script_from_examples&quot;&gt; &lt;code&gt;script_from_examples()&lt;/code&gt; &lt;/a&gt; 설명 된대로 Python 스크립트로 변환 된 객체의 docstring을 포함하는 문자열 입니다. 예를 들어, 모듈의 경우 &lt;code&gt;a.py&lt;/code&gt; 는 최상위 기능 포함 &lt;code&gt;f()&lt;/code&gt; 한 다음,</target>
        </trans-unit>
        <trans-unit id="d13ab8175963907a3c38cd5c0e397fdc5a88b925" translate="yes" xml:space="preserve">
          <source>Argument &lt;em&gt;s&lt;/em&gt; is a string containing doctest examples. The string is converted to a Python script, where doctest examples in &lt;em&gt;s&lt;/em&gt; are converted to regular code, and everything else is converted to Python comments. The generated script is returned as a string. For example,</source>
          <target state="translated">인수 &lt;em&gt;들&lt;/em&gt; doctest가 예를 포함하는 문자열입니다. 문자열은 Python 스크립트로 변환됩니다. 여기서 &lt;em&gt;s의&lt;/em&gt; doctest 예제는 일반 코드로 변환되고 다른 모든 것은 Python 주석으로 변환됩니다. 생성 된 스크립트는 문자열로 반환됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="dc60f0a9ed6b8901fa4738eb86c947f1aba137a8" translate="yes" xml:space="preserve">
          <source>Argument abbreviations (prefix matching)</source>
          <target state="translated">인수 약어 (접두사 일치)</target>
        </trans-unit>
        <trans-unit id="646f35c0fe5203eb12ebdfc5f6722d5f4ee8b9f2" translate="yes" xml:space="preserve">
          <source>Argument groups</source>
          <target state="translated">인수 그룹</target>
        </trans-unit>
        <trans-unit id="3c66f14d2ce5db0e563f7a0a9cea03ef993a86f3" translate="yes" xml:space="preserve">
          <source>Argument names are not part of the specification, and only the arguments of &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; are intended to be used as keyword arguments.</source>
          <target state="translated">인수 이름은 사양의 일부가 아니며 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 인수 만 키워드 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6331038cb6dd518cc8a1c33aa6d56e471c0a5793" translate="yes" xml:space="preserve">
          <source>ArgumentParser objects</source>
          <target state="translated">ArgumentParser 객체</target>
        </trans-unit>
        <trans-unit id="81018876e5e0fb20f6d9b1140eb03c00025d7bd7" translate="yes" xml:space="preserve">
          <source>ArgumentParser objects usually associate a single command-line argument with a single action to be taken. The &lt;code&gt;nargs&lt;/code&gt; keyword argument associates a different number of command-line arguments with a single action. The supported values are:</source>
          <target state="translated">ArgumentParser 객체는 일반적으로 단일 명령 줄 인수를 단일 액션과 연결합니다. &lt;code&gt;nargs&lt;/code&gt; 키워드 인수는 단일 작업과 명령 줄 인수의 다른 번호를 연결합니다. 지원되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="74013187b9b262d759763c71b93fc2050badc103" translate="yes" xml:space="preserve">
          <source>Arguments &lt;em&gt;file&lt;/em&gt;, &lt;em&gt;fix_imports&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt;, &lt;em&gt;strict&lt;/em&gt; and &lt;em&gt;buffers&lt;/em&gt; have the same meaning as in the &lt;a href=&quot;#pickle.Unpickler&quot;&gt;&lt;code&gt;Unpickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">인수 &lt;em&gt;file&lt;/em&gt; , &lt;em&gt;fix_imports&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; , &lt;em&gt;errors&lt;/em&gt; , &lt;em&gt;strict&lt;/em&gt; 및 &lt;em&gt;buffer&lt;/em&gt; 는 &lt;a href=&quot;#pickle.Unpickler&quot;&gt; &lt;code&gt;Unpickler&lt;/code&gt; &lt;/a&gt; 생성자 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d89665ba13ee62d24ea7f2b734e91ef581e6bf8d" translate="yes" xml:space="preserve">
          <source>Arguments &lt;em&gt;file&lt;/em&gt;, &lt;em&gt;protocol&lt;/em&gt;, &lt;em&gt;fix_imports&lt;/em&gt; and &lt;em&gt;buffer_callback&lt;/em&gt; have the same meaning as in the &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">인수 &lt;em&gt;file&lt;/em&gt; , &lt;em&gt;protocol&lt;/em&gt; , &lt;em&gt;fix_imports&lt;/em&gt; 및 &lt;em&gt;buffer_callback&lt;/em&gt; 은 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 생성자 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="062cac0907e3b6761cd5955db7e55e88c29370c5" translate="yes" xml:space="preserve">
          <source>Arguments &lt;em&gt;protocol&lt;/em&gt;, &lt;em&gt;fix_imports&lt;/em&gt; and &lt;em&gt;buffer_callback&lt;/em&gt; have the same meaning as in the &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">인수 &lt;em&gt;protocol&lt;/em&gt; , &lt;em&gt;fix_imports&lt;/em&gt; 및 &lt;em&gt;buffer_callback&lt;/em&gt; 은 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 생성자 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="abe50e0f8895e96e60e7ed8a520f00b347b19db9" translate="yes" xml:space="preserve">
          <source>Arguments are as for &lt;a href=&quot;#http.cookiejar.FileCookieJar.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수는 &lt;a href=&quot;#http.cookiejar.FileCookieJar.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31b8834506fb3b7c5be5a3ce85e8e0c3db7c0b3f" translate="yes" xml:space="preserve">
          <source>Arguments are delimited by white space, which is either a space or a tab.</source>
          <target state="translated">인수는 공백 또는 탭인 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="ca383ab55205e5fb89e07118c8e14e4621db4341" translate="yes" xml:space="preserve">
          <source>Arguments containing &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">다음을 포함하는 인수 &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7d8d9a6376cd495ec8cafea6a5b8bff545de70d" translate="yes" xml:space="preserve">
          <source>Arguments for which &lt;a href=&quot;#inspect.Signature.bind&quot;&gt;&lt;code&gt;Signature.bind()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#inspect.Signature.bind_partial&quot;&gt;&lt;code&gt;Signature.bind_partial()&lt;/code&gt;&lt;/a&gt; relied on a default value are skipped. However, if needed, use &lt;a href=&quot;#inspect.BoundArguments.apply_defaults&quot;&gt;&lt;code&gt;BoundArguments.apply_defaults()&lt;/code&gt;&lt;/a&gt; to add them.</source>
          <target state="translated">&lt;a href=&quot;#inspect.Signature.bind&quot;&gt; &lt;code&gt;Signature.bind()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#inspect.Signature.bind_partial&quot;&gt; &lt;code&gt;Signature.bind_partial()&lt;/code&gt; &lt;/a&gt; 이 기본값에 의존 하는 인수 는 건너 뜁니다. 그러나 필요한 경우 &lt;a href=&quot;#inspect.BoundArguments.apply_defaults&quot;&gt; &lt;code&gt;BoundArguments.apply_defaults()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5642db0a84a9bfcf6fa6b2be3d81eb1124eeef" translate="yes" xml:space="preserve">
          <source>Arguments read from a file must by default be one per line (but see also &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt;&lt;code&gt;convert_arg_line_to_args()&lt;/code&gt;&lt;/a&gt;) and are treated as if they were in the same place as the original file referencing argument on the command line. So in the example above, the expression &lt;code&gt;['-f', 'foo', '@args.txt']&lt;/code&gt; is considered equivalent to the expression &lt;code&gt;['-f', 'foo', '-f', 'bar']&lt;/code&gt;.</source>
          <target state="translated">파일에서 읽은 인수는 기본적으로 한 줄에 하나씩 있어야하지만 ( &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt; &lt;code&gt;convert_arg_line_to_args()&lt;/code&gt; &lt;/a&gt; 참조) 명령 줄에서 원래 파일 참조 인수와 같은 위치에있는 것처럼 처리됩니다. 따라서 위의 예에서 &lt;code&gt;['-f', 'foo', '@args.txt']&lt;/code&gt; 표현식은 &lt;code&gt;['-f', 'foo', '-f', 'bar']&lt;/code&gt; 표현식과 동등한 것으로 간주됩니다 . .</target>
        </trans-unit>
        <trans-unit id="254fe913b44f0083c86b3a72eb64233d6c9c9037" translate="yes" xml:space="preserve">
          <source>Arguments that are read from a file (see the &lt;em&gt;fromfile_prefix_chars&lt;/em&gt; keyword argument to the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; constructor) are read one argument per line. &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt;&lt;code&gt;convert_arg_line_to_args()&lt;/code&gt;&lt;/a&gt; can be overridden for fancier reading.</source>
          <target state="translated">파일에서 읽은 인수 ( &lt;em&gt;fromfile_prefix_chars&lt;/em&gt; 키워드 인수를 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 생성자 참조)는 한 줄에 하나의 인수를 읽습니다. 더 빠른 읽기를 위해 &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt; &lt;code&gt;convert_arg_line_to_args()&lt;/code&gt; &lt;/a&gt; 를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c888f0156e119be7fcf794112bbc633d3a855af" translate="yes" xml:space="preserve">
          <source>Arguments, return values and exceptions raised should be the same as for &lt;code&gt;http_error_default()&lt;/code&gt;.</source>
          <target state="translated">인수, 리턴 값 및 예외는 &lt;code&gt;http_error_default()&lt;/code&gt; 와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="05d9f54c2dee44d1764ce455fe2d7d6a602d3b2c" translate="yes" xml:space="preserve">
          <source>Arithmetic mean (&amp;ldquo;average&amp;rdquo;) of data.</source>
          <target state="translated">데이터의 산술 평균 (&amp;ldquo;평균&amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="5509c94c0f9f738717633e15c4c8dbc85e63a4c9" translate="yes" xml:space="preserve">
          <source>ArithmeticError</source>
          <target state="translated">ArithmeticError</target>
        </trans-unit>
        <trans-unit id="00bda803d743e23213c7aa7e2ecbc5b4d57d34e7" translate="yes" xml:space="preserve">
          <source>Arrange for &lt;code&gt;callback(pid, returncode, *args)&lt;/code&gt; to be called when a process with PID equal to &lt;em&gt;pid&lt;/em&gt; terminates. Specifying another callback for the same process replaces the previous handler.</source>
          <target state="translated">PID가 &lt;em&gt;pid 인&lt;/em&gt; 프로세스가 종료 될 때 &lt;code&gt;callback(pid, returncode, *args)&lt;/code&gt; 이 호출되도록 배열하십시오 . 동일한 프로세스에 다른 콜백을 지정하면 이전 핸들러가 바뀝니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e83bc7d750aaf3109a4f2191f8a594db7bc12dc" translate="yes" xml:space="preserve">
          <source>Arrange for &lt;em&gt;func&lt;/em&gt; to be called in the specified executor.</source>
          <target state="translated">주선 &lt;em&gt;FUNC&lt;/em&gt; 지정된 실행기에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ce67aeaeb955aba8123768b6b67cd81cceff896b" translate="yes" xml:space="preserve">
          <source>Arrange the given list of classes into a hierarchy of nested lists. Where a nested list appears, it contains classes derived from the class whose entry immediately precedes the list. Each entry is a 2-tuple containing a class and a tuple of its base classes. If the &lt;em&gt;unique&lt;/em&gt; argument is true, exactly one entry appears in the returned structure for each class in the given list. Otherwise, classes using multiple inheritance and their descendants will appear multiple times.</source>
          <target state="translated">주어진 클래스 목록을 중첩 된 목록의 계층 구조로 배열하십시오. 중첩 된 목록이 나타나면 목록 바로 앞에 항목이있는 클래스에서 파생 된 클래스가 포함됩니다. 각 항목은 클래스와 기본 클래스의 튜플을 포함하는 2 개의 튜플입니다. 는 IF &lt;em&gt;고유의&lt;/em&gt; 인수가 true, 정확히 하나 개의 항목이 주어진 목록의 각 클래스에 대한 반환 된 구조에 나타납니다. 그렇지 않으면 다중 상속을 사용하는 클래스와 그 하위 항목이 여러 번 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e09bcef1e1561563a4c3e831676e473af1795dff" translate="yes" xml:space="preserve">
          <source>Array objects support the ordinary sequence operations of indexing, slicing, concatenation, and multiplication. When using slice assignment, the assigned value must be an array object with the same type code; in all other cases, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised. Array objects also implement the buffer interface, and may be used wherever &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; are supported.</source>
          <target state="translated">배열 객체는 인덱싱, 슬라이싱, 연결 및 곱셈의 일반적인 시퀀스 작업을 지원합니다. 슬라이스 할당을 사용할 때 할당 된 값은 유형 코드가 동일한 배열 객체 여야합니다. 다른 모든 경우에는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 배열 객체는 또한 버퍼 인터페이스를 구현하며 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 가 지원 되는 모든 곳에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a038e3af2ef2f9438b219a899eb40b5d237a4ed2" translate="yes" xml:space="preserve">
          <source>Array subclass constructors accept positional arguments, used to initialize the elements in order.</source>
          <target state="translated">배열 서브 클래스 생성자는 요소를 순서대로 초기화하는 데 사용되는 위치 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="2116ae0173d1a47165ce7b4c6dd99787a4f44df7" translate="yes" xml:space="preserve">
          <source>Arrays and pointers</source>
          <target state="translated">배열과 포인터</target>
        </trans-unit>
        <trans-unit id="d2ba2d6827acb128b9bc6dce24cfef791a15ff8e" translate="yes" xml:space="preserve">
          <source>Arrays are sequences, containing a fixed number of instances of the same type.</source>
          <target state="translated">배열은 동일한 유형의 고정 된 수의 인스턴스를 포함하는 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="ea1bebde72fbc4b9eac4d8bc3c178b395db87608" translate="yes" xml:space="preserve">
          <source>Arrow keys and</source>
          <target state="translated">화살표 키와</target>
        </trans-unit>
        <trans-unit id="492a48af0242c28b406dd17c1e3f267f5f7d0dde" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt;, return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by &lt;a href=&quot;#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;\x&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; escapes. This generates a string similar to that returned by &lt;a href=&quot;#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; in Python 2.</source>
          <target state="translated">대로 &lt;a href=&quot;#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 문자열에 비 ASCII 문자를 객체의 인쇄 가능한 표현을 포함하는 문자열을 반환하지만 탈출 &lt;a href=&quot;#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;\x&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 이스케이프합니다. 파이썬 2에서 &lt;a href=&quot;#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 것과 비슷한 문자열을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="02f76a37b3c37f88ec864fc817fca31de5c8cd6a" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;__enter__&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; invoked, this method can be used to cover part of an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; implementation with a context manager&amp;rsquo;s own &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">마찬가지로 &lt;code&gt;__enter__&lt;/code&gt; 가 되어 &lt;em&gt;있지&lt;/em&gt; 호출이 방법은 표지 부분에 사용될 수있다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 콘텍스트 관리자 자체로 구현 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="21a1436804ffd6271fbdf496e469190ad95cfadb" translate="yes" xml:space="preserve">
          <source>As IPv4 does not define a shorthand notation for addresses with octets set to zero, these two attributes are always the same as &lt;code&gt;str(addr)&lt;/code&gt; for IPv4 addresses. Exposing these attributes makes it easier to write display code that can handle both IPv4 and IPv6 addresses.</source>
          <target state="translated">IPv4는 옥텟이 0으로 설정된 주소에 대한 속기 표기법을 정의하지 않으므로이 두 속성은 항상 IPv4 주소의 &lt;code&gt;str(addr)&lt;/code&gt; 과 동일 합니다. 이러한 속성을 노출하면 IPv4 및 IPv6 주소를 모두 처리 할 수있는 디스플레이 코드를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01b75b6a03e85825e5ae6f5174dafbcc20884f22" translate="yes" xml:space="preserve">
          <source>As UTF-8 is an 8-bit encoding no BOM is required and any &lt;code&gt;U+FEFF&lt;/code&gt; character in the decoded string (even if it&amp;rsquo;s the first character) is treated as a &lt;code&gt;ZERO
WIDTH NO-BREAK SPACE&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 8 비트 인코딩이므로 BOM이 필요하지 않으며 디코딩 된 문자열의 &lt;code&gt;U+FEFF&lt;/code&gt; 문자 (첫 번째 문자 임에도 불구하고)는 &lt;code&gt;ZERO WIDTH NO-BREAK SPACE&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="e93d4b1e7a80c62c1fe29ce1183609ea319edc6b" translate="yes" xml:space="preserve">
          <source>As a basic example, below is a simple HTML parser that uses the &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt;&lt;code&gt;HTMLParser&lt;/code&gt;&lt;/a&gt; class to print out start tags, end tags, and data as they are encountered:</source>
          <target state="translated">기본적인 예로, 아래는 &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt; &lt;code&gt;HTMLParser&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 시작 태그, 종료 태그 및 데이터가 발견 될 때 인쇄 하는 간단한 HTML 파서입니다 .</target>
        </trans-unit>
        <trans-unit id="56cc68f817847f0888385ee2f0ae8a8820897e0f" translate="yes" xml:space="preserve">
          <source>As a consequence, the list &lt;code&gt;[1, 2]&lt;/code&gt; is considered equal to &lt;code&gt;[1.0, 2.0]&lt;/code&gt;, and similarly for tuples.</source>
          <target state="translated">결과적으로,리스트 &lt;code&gt;[1, 2]&lt;/code&gt; 는 &lt;code&gt;[1.0, 2.0]&lt;/code&gt; 과 같 으며 튜플과 유사하게 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c47037d0ed57ce0ffcb9e6f5f456d8a5dfad7c5" translate="yes" xml:space="preserve">
          <source>As a convenience &lt;em&gt;addr_spec&lt;/em&gt; can be specified instead of &lt;em&gt;username&lt;/em&gt; and &lt;em&gt;domain&lt;/em&gt;, in which case &lt;em&gt;username&lt;/em&gt; and &lt;em&gt;domain&lt;/em&gt; will be parsed from the &lt;em&gt;addr_spec&lt;/em&gt;. An &lt;em&gt;addr_spec&lt;/em&gt; must be a properly RFC quoted string; if it is not &lt;code&gt;Address&lt;/code&gt; will raise an error. Unicode characters are allowed and will be property encoded when serialized. However, per the RFCs, unicode is &lt;em&gt;not&lt;/em&gt; allowed in the username portion of the address.</source>
          <target state="translated">편의상 &lt;em&gt;username&lt;/em&gt; 과 &lt;em&gt;domain&lt;/em&gt; 대신 &lt;em&gt;addr_spec을&lt;/em&gt; 지정할 수 있으며 ,이 경우 &lt;em&gt;addr_spec&lt;/em&gt; 에서 &lt;em&gt;username&lt;/em&gt; 과 &lt;em&gt;domain&lt;/em&gt; 이 구문 분석됩니다 . &lt;em&gt;addr_spec은&lt;/em&gt; 제대로 RFC 인용 문자열이어야합니다; &lt;code&gt;Address&lt;/code&gt; 가 아닌 경우 오류가 발생합니다. 유니 코드 문자는 허용되며 직렬화 할 때 속성 인코딩됩니다. 그러나 RFC 에 따라 주소의 사용자 이름 부분에는 유니 코드가 허용 &lt;em&gt;되지&lt;/em&gt; 않습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56d9575dc7f90bc34c436a75f7caf3eeeecd477e" translate="yes" xml:space="preserve">
          <source>As a convenience for processing lists of addresses that consist of a mixture of groups and single addresses, a &lt;code&gt;Group&lt;/code&gt; may also be used to represent single addresses that are not part of a group by setting &lt;em&gt;display_name&lt;/em&gt; to &lt;code&gt;None&lt;/code&gt; and providing a list of the single address as &lt;em&gt;addresses&lt;/em&gt;.</source>
          <target state="translated">그룹과 단일 주소의 혼합으로 구성된 주소 목록을 처리하기위한 편의상 &lt;code&gt;Group&lt;/code&gt; 은 &lt;em&gt;display_name&lt;/em&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 설정 하고 단일 주소 목록을 다음과 같이 제공하여 그룹의 일부가 아닌 단일 주소를 나타내는 데 사용될 수도 있습니다. &lt;em&gt;주소&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="21c6d9923ff5341e64ead3588bfe1b0fc8708eec" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; provides the methods &lt;a href=&quot;email.message#email.message.EmailMessage.as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;bytes(aMessage)&lt;/code&gt; (a.k.a. &lt;a href=&quot;email.message#email.message.EmailMessage.__bytes__&quot;&gt;&lt;code&gt;__bytes__()&lt;/code&gt;&lt;/a&gt;), which simplify the generation of a serialized binary representation of a message object. For more detail, see &lt;a href=&quot;email.message#module-email.message&quot;&gt;&lt;code&gt;email.message&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의상, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 는&lt;/a&gt; 방법의 제공 &lt;a href=&quot;email.message#email.message.EmailMessage.as_bytes&quot;&gt; &lt;code&gt;as_bytes()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;bytes(aMessage)&lt;/code&gt; (일명 &lt;a href=&quot;email.message#email.message.EmailMessage.__bytes__&quot;&gt; &lt;code&gt;__bytes__()&lt;/code&gt; &lt;/a&gt; ) 메시지 객체의 직렬화 이진 표현의 생성을 간소화한다. 자세한 내용은 &lt;a href=&quot;email.message#module-email.message&quot;&gt; &lt;code&gt;email.message&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4abff2ddf7e07b5dde53a45acae67c7d73f15471" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; provides the methods &lt;a href=&quot;email.message#email.message.EmailMessage.as_string&quot;&gt;&lt;code&gt;as_string()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;str(aMessage)&lt;/code&gt; (a.k.a. &lt;a href=&quot;email.message#email.message.EmailMessage.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt;), which simplify the generation of a formatted string representation of a message object. For more detail, see &lt;a href=&quot;email.message#module-email.message&quot;&gt;&lt;code&gt;email.message&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의상, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 이&lt;/a&gt; 방법 제공 &lt;a href=&quot;email.message#email.message.EmailMessage.as_string&quot;&gt; &lt;code&gt;as_string()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;str(aMessage)&lt;/code&gt; (일명 &lt;a href=&quot;email.message#email.message.EmailMessage.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; ) 메시지 객체의 포맷 문자열 표현의 생성을 간소화한다. 자세한 내용은 &lt;a href=&quot;email.message#module-email.message&quot;&gt; &lt;code&gt;email.message&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="702d8b69bc2e4520c3ea7fda0210ac4d16730354" translate="yes" xml:space="preserve">
          <source>As a convenience, it is allowed to call this method more than once; only the first call, however, will have an effect.</source>
          <target state="translated">편의상이 메소드를 두 번 이상 호출 할 수 있습니다. 그러나 첫 번째 전화 만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="246fcbe17d21c864d76f20a8ea7b1030891cbcc5" translate="yes" xml:space="preserve">
          <source>As a default namespace, if &lt;em&gt;globs&lt;/em&gt; is not specified.</source>
          <target state="translated">&lt;em&gt;globs&lt;/em&gt; 가 지정되지 않은 경우 기본 네임 스페이스로 .</target>
        </trans-unit>
        <trans-unit id="59fca4637f2c6a11c94c0115101f5eb5fe7f8b54" translate="yes" xml:space="preserve">
          <source>As a hint: &lt;em&gt;ptype&lt;/em&gt; is &lt;code&gt;'Uniprocessor Free'&lt;/code&gt; on single processor NT machines and &lt;code&gt;'Multiprocessor Free'&lt;/code&gt; on multi processor machines. The &lt;em&gt;&amp;lsquo;Free&amp;rsquo;&lt;/em&gt; refers to the OS version being free of debugging code. It could also state &lt;em&gt;&amp;lsquo;Checked&amp;rsquo;&lt;/em&gt; which means the OS version uses debugging code, i.e. code that checks arguments, ranges, etc.</source>
          <target state="translated">힌트 : &lt;em&gt;ptype&lt;/em&gt; 은 단일 프로세서 NT 시스템에서 &lt;code&gt;'Uniprocessor Free'&lt;/code&gt; 이고 다중 프로세서 시스템에서 &lt;code&gt;'Multiprocessor Free'&lt;/code&gt; 입니다. &lt;em&gt;'무료'&lt;/em&gt; 코드를 디버깅이없는 것으로 OS 버전을 의미합니다. 또한 OS 버전이 디버깅 코드, 즉 인수, 범위 등을 확인하는 코드를 사용한다는 것을 의미하는 &lt;em&gt;'Checked'라고 표시&lt;/em&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01542f6485eff7fcd66532527eb2903905db20bd" translate="yes" xml:space="preserve">
          <source>As a last resort, the current working directory.</source>
          <target state="translated">최후의 수단으로 현재 작업 디렉토리.</target>
        </trans-unit>
        <trans-unit id="4394d88d5506fb6bad90992f89785a34f016a9f1" translate="yes" xml:space="preserve">
          <source>As a practical example, a web application can symmetrically sign cookies sent to users and later verify them to make sure they weren&amp;rsquo;t tampered with:</source>
          <target state="translated">실용적인 예로, 웹 응용 프로그램은 사용자에게 전송 된 쿠키에 대칭 적으로 서명하고 나중에 쿠키가 변경되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7a3250916881530139f1d3c3f521304a2d00f953" translate="yes" xml:space="preserve">
          <source>As a resource for sharing data across processes, shared memory blocks may outlive the original process that created them. When one process no longer needs access to a shared memory block that might still be needed by other processes, the &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method should be called. When a shared memory block is no longer needed by any process, the &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.unlink&quot;&gt;&lt;code&gt;unlink()&lt;/code&gt;&lt;/a&gt; method should be called to ensure proper cleanup.</source>
          <target state="translated">프로세스간에 데이터를 공유하기위한 리소스로서 공유 메모리 블록은이를 생성 한 원래 프로세스보다 오래 지속될 수 있습니다. 한 프로세스가 더 이상 다른 프로세스에 필요할 수있는 공유 메모리 블록에 액세스 할 필요가 없으면 &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다. 프로세스에서 공유 메모리 블록이 더 이상 필요하지 않으면 적절한 정리를 위해 &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.unlink&quot;&gt; &lt;code&gt;unlink()&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="461cbf814397c1a6ad159d386793e5950747ea9b" translate="yes" xml:space="preserve">
          <source>As a result, these tables are exposed as functions, not as data structures. There are two kinds of tables in the RFC: sets and mappings. For a set, &lt;a href=&quot;#module-stringprep&quot;&gt;&lt;code&gt;stringprep&lt;/code&gt;&lt;/a&gt; provides the &amp;ldquo;characteristic function&amp;rdquo;, i.e. a function that returns &lt;code&gt;True&lt;/code&gt; if the parameter is part of the set. For mappings, it provides the mapping function: given the key, it returns the associated value. Below is a list of all functions available in the module.</source>
          <target state="translated">결과적으로이 테이블은 데이터 구조가 아니라 함수로 노출됩니다. RFC에는 두 가지 종류의 테이블 인 집합과 매핑이 있습니다. 세트의 경우, &lt;a href=&quot;#module-stringprep&quot;&gt; &lt;code&gt;stringprep&lt;/code&gt; &lt;/a&gt; 은 &quot;특성 함수&quot;, 즉 매개 변수가 세트의 일부인 경우 &lt;code&gt;True&lt;/code&gt; 를 리턴하는 함수를 제공합니다 . 맵핑의 경우 맵핑 기능을 제공합니다. 키가 제공되면 연관된 값을 리턴합니다. 아래는 모듈에서 사용 가능한 모든 기능의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="2a184ffa1e02bb553c3cf1bb5908fd5b4956ff6b" translate="yes" xml:space="preserve">
          <source>As a shortcut, &lt;code&gt;python -m unittest&lt;/code&gt; is the equivalent of &lt;code&gt;python -m unittest discover&lt;/code&gt;. If you want to pass arguments to test discovery the &lt;code&gt;discover&lt;/code&gt; sub-command must be used explicitly.</source>
          <target state="translated">바로 가기로서, &lt;code&gt;python -m unittest&lt;/code&gt; 하는 것과 동일 &lt;code&gt;python -m unittest discover&lt;/code&gt; . 감지를 테스트하기 위해 인수를 전달하려면 &lt;code&gt;discover&lt;/code&gt; 하위 명령을 명시 적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c6052cb2b7ab711a2dfe70683f2ac20c152dc62" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can pass the first chunk of data to update directly to the constructor as the positional argument:</source>
          <target state="translated">바로 가기로, 첫 번째 데이터 청크를 전달하여 위치 인수로 생성자에 직접 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="589b7e27763c67c7426c653620d97a4afe45eed8" translate="yes" xml:space="preserve">
          <source>As a shorthand for this type, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; can be used to annotate arguments of any of the types mentioned above.</source>
          <target state="translated">이 유형의 줄임말로, &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 는 위에서 언급 한 유형의 인수에 주석을 달기 위해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc30d222e457c2b86d38c6dc2682bd1cf49fbc5" translate="yes" xml:space="preserve">
          <source>As a single multi-line string it looks like this:</source>
          <target state="translated">단일 여러 줄 문자열로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31fec187f046cbb0fe0fcc91b7f32ecb2bd751ff" translate="yes" xml:space="preserve">
          <source>As an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;root&lt;/code&gt; has a tag and a dictionary of attributes:</source>
          <target state="translated">AS를 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;root&lt;/code&gt; 태그 및 속성의 사전을 가지고 :</target>
        </trans-unit>
        <trans-unit id="f8f3227359947ab2ce5b9947bd2e229fe5f93f58" translate="yes" xml:space="preserve">
          <source>As an added bonus you no longer need to keep a reference to the &lt;code&gt;patcher&lt;/code&gt; object.</source>
          <target state="translated">추가 보너스로 더 이상 &lt;code&gt;patcher&lt;/code&gt; 객체에 대한 참조를 유지할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b503ab5544f8b7e846527fe7cd3425f0b5545263" translate="yes" xml:space="preserve">
          <source>As an alternative to using the &lt;code&gt;request()&lt;/code&gt; method described above, you can also send your request step by step, by using the four functions below.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;request()&lt;/code&gt; 메소드 를 사용하는 대신 아래 네 가지 함수를 사용하여 단계별로 요청을 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7336776d38139cf85922861d97a6c8dfca4d4e8" translate="yes" xml:space="preserve">
          <source>As an example, here are two useful aliases (especially when placed in the &lt;code&gt;.pdbrc&lt;/code&gt; file):</source>
          <target state="translated">예를 들어 다음은 두 가지 유용한 별칭입니다 (특히 &lt;code&gt;.pdbrc&lt;/code&gt; 파일 에있을 때 ).</target>
        </trans-unit>
        <trans-unit id="5a80b839cbf77be14d284871859db2716a2d8281" translate="yes" xml:space="preserve">
          <source>As an example, here is a simple way to synchronize a client and server thread:</source>
          <target state="translated">예를 들어, 클라이언트와 서버 스레드를 동기화하는 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f4562ba3c72351908cae38e3fc969623aaf1135" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change the Combobox for the default theme a bit:</source>
          <target state="translated">예를 들어, 기본 테마의 콤보 박스를 약간 변경해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="4228081bb4db5df72a0d8ad128755e932ebc79ee" translate="yes" xml:space="preserve">
          <source>As an example, the following calls to &lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt; are equivalent:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;#os.spawnlp&quot;&gt; &lt;code&gt;spawnlp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnvpe&quot;&gt; &lt;code&gt;spawnvpe()&lt;/code&gt; &lt;/a&gt; 대한 다음 호출 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ba4b1a6703f8b07e5a6b60e4bad30c91c5890466" translate="yes" xml:space="preserve">
          <source>As an example, the following code could be used to read an email message from a file on disk and pass it to the system &lt;code&gt;sendmail&lt;/code&gt; program on a Unix system:</source>
          <target state="translated">예를 들어, 다음 코드를 사용하여 디스크의 파일에서 전자 메일 메시지를 읽고 Unix 시스템 의 시스템 &lt;code&gt;sendmail&lt;/code&gt; 프로그램으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdbacbe7504a62ca3305f0051ceceb7ce7683b37" translate="yes" xml:space="preserve">
          <source>As an implementation detail, most modules have the name &lt;code&gt;__builtins__&lt;/code&gt; made available as part of their globals. The value of &lt;code&gt;__builtins__&lt;/code&gt; is normally either this module or the value of this module&amp;rsquo;s &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute. Since this is an implementation detail, it may not be used by alternate implementations of Python.</source>
          <target state="translated">구현 세부 사항으로 대부분의 모듈은 &lt;code&gt;__builtins__&lt;/code&gt; 라는 이름을 전역의 일부로 제공합니다. &lt;code&gt;__builtins__&lt;/code&gt; 값 은 일반적으로이 모듈 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 모듈의 __dict__ 특성 값입니다 . 이것은 구현 세부 사항이므로 파이썬의 대체 구현에서는 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c7b885f679999067032935a1aa6716b565ddb72" translate="yes" xml:space="preserve">
          <source>As at any time a re-negotiation is possible, a call to &lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; can also cause write operations.</source>
          <target state="translated">재협상이 가능할 때마다 &lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 호출로 인해 쓰기 작업이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd487951e11f4d42348b340f0a9fb430d37c5cc" translate="yes" xml:space="preserve">
          <source>As at any time a re-negotiation is possible, a call to &lt;a href=&quot;#ssl.SSLSocket.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can also cause read operations.</source>
          <target state="translated">재협상이 가능할 때마다 &lt;a href=&quot;#ssl.SSLSocket.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 호출로 인해 읽기 작업이 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e24aa9e1ac5aea4c36f22d36193b3afce59ac93" translate="yes" xml:space="preserve">
          <source>As bytearray objects are mutable, they support the &lt;a href=&quot;#typesseq-mutable&quot;&gt;mutable&lt;/a&gt; sequence operations in addition to the common bytes and bytearray operations described in &lt;a href=&quot;#bytes-methods&quot;&gt;Bytes and Bytearray Operations&lt;/a&gt;.</source>
          <target state="translated">이 ByteArray 오브젝트가 변하는, 그들은지지 &lt;a href=&quot;#typesseq-mutable&quot;&gt;변경할&lt;/a&gt; 에 기재된 일반적인 바이트 된 ByteArray 조작 이외에 시퀀스 연산 &lt;a href=&quot;#bytes-methods&quot;&gt;바이트 오퍼레이션이 ByteArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78bf9d41f9b029450b419cb811cff375582f4159" translate="yes" xml:space="preserve">
          <source>As described before, SQLite supports only a limited set of types natively. To use other Python types with SQLite, you must &lt;strong&gt;adapt&lt;/strong&gt; them to one of the sqlite3 module&amp;rsquo;s supported types for SQLite: one of NoneType, int, float, str, bytes.</source>
          <target state="translated">앞에서 설명한 것처럼 SQLite는 기본적으로 제한된 유형의 집합 만 지원합니다. SQLite와 함께 다른 Python 유형을 사용하려면 SQLite 에 대해 sqlite3 모듈에서 지원되는 유형 중 하나에 NoneType, int, float, str, bytes 중 하나를 &lt;strong&gt;적용&lt;/strong&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="12104d6983d2c0ac8c4e8e3db3bbb26e8a81d6cd" translate="yes" xml:space="preserve">
          <source>As explained in the previous section, foreign functions can be accessed as attributes of loaded shared libraries. The function objects created in this way by default accept any number of arguments, accept any ctypes data instances as arguments, and return the default result type specified by the library loader. They are instances of a private class:</source>
          <target state="translated">이전 섹션에서 설명한 것처럼 외부 함수는로드 된 공유 라이브러리의 속성으로 액세스 할 수 있습니다. 기본적으로이 방식으로 작성된 함수 오브젝트는 여러 개의 인수를 허용하고 ctypes 데이터 인스턴스를 인수로 승인하며 라이브러리 로더가 지정한 기본 결과 유형을 리턴합니다. 개인 클래스의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="c1c8f40732d97a4b4e90b1a6e8a0be872ac0ea63" translate="yes" xml:space="preserve">
          <source>As far as possible one should try to avoid shifting large amounts of data between processes.</source>
          <target state="translated">가능한 한 프로세스간에 많은 양의 데이터가 이동되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="1dbfa2bc97572579991ca5c4ddb17267e21f80e3" translate="yes" xml:space="preserve">
          <source>As has been mentioned before, all Python types except integers, strings, and bytes objects have to be wrapped in their corresponding &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; type, so that they can be converted to the required C data type:</source>
          <target state="translated">앞에서 언급했듯이 정수, 문자열 및 바이트 객체를 제외한 모든 Python 유형은 해당 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 유형 으로 랩핑되어 필요한 C 데이터 유형으로 변환 될 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ddf55edc3a51e93aacbc734fc2d7fe5eb787249" translate="yes" xml:space="preserve">
          <source>As initialized upon program startup, the first item of this list, &lt;code&gt;path[0]&lt;/code&gt;, is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), &lt;code&gt;path[0]&lt;/code&gt; is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted &lt;em&gt;before&lt;/em&gt; the entries inserted as a result of &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-21&quot;&gt;&lt;code&gt;PYTHONPATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로그램 시작시 초기화 된대로이 목록의 첫 번째 항목 인 &lt;code&gt;path[0]&lt;/code&gt; 은 Python 인터프리터를 호출하는 데 사용 된 스크립트가 포함 된 디렉토리입니다. 스크립트 디렉토리를 사용할 수없는 경우 (예 : 인터프리터가 대화식으로 호출되거나 표준 입력에서 스크립트를 읽는 경우) &lt;code&gt;path[0]&lt;/code&gt; 은 빈 문자열로, 현재 디렉토리에서 모듈을 먼저 검색하도록 Python에 지시합니다. 스크립트 디렉토리는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-21&quot;&gt; &lt;code&gt;PYTHONPATH&lt;/code&gt; &lt;/a&gt; 의 결과로 삽입 된 항목 &lt;em&gt;앞에&lt;/em&gt; 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d02dd5a1c0be670a5afec6d8bf7ade0cbe0a443" translate="yes" xml:space="preserve">
          <source>As introduced in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, a variable annotation wrapped in ClassVar indicates that a given attribute is intended to be used as a class variable and should not be set on instances of that class. Usage:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt; 에서 소개 된 바와 같이 , ClassVar로 래핑 된 변수 주석은 주어진 속성이 클래스 변수로 사용되도록 의도되었으며 해당 클래스의 인스턴스에 설정되어서는 안됨을 나타냅니다. 용법:</target>
        </trans-unit>
        <trans-unit id="b975573d762213d718d91e5a19d0201d6f4a860f" translate="yes" xml:space="preserve">
          <source>As is the case with all named tuples, the subclass has a few additional methods and attributes that are particularly useful. One such method is &lt;code&gt;_replace()&lt;/code&gt;. The &lt;code&gt;_replace()&lt;/code&gt; method will return a new ParseResult object replacing specified fields with new values.</source>
          <target state="translated">모든 명명 된 튜플의 경우와 마찬가지로 서브 클래스는 특히 유용한 몇 가지 추가 메소드 및 속성을 갖습니다. 그러한 방법 중 하나는 &lt;code&gt;_replace()&lt;/code&gt; 입니다. &lt;code&gt;_replace()&lt;/code&gt; 메소드는 새로운 값으로 지정된 필드를 대체하는 새로운 ParseResult 객체를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="1c24eca1bdc966d5e836feb3ab27d1d9ed3eb23f" translate="yes" xml:space="preserve">
          <source>As long as the view exists, the &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt; object cannot be resized or closed.</source>
          <target state="translated">보기가 존재하는 한 &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 개체는 크기를 조정하거나 닫을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="610fcdc735062bf431e7a9e2ee300d06d531c84b" translate="yes" xml:space="preserve">
          <source>As mentioned above, if a child process has put items on a queue (and it has not used &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt;&lt;code&gt;JoinableQueue.cancel_join_thread&lt;/code&gt;&lt;/a&gt;), then that process will not terminate until all buffered items have been flushed to the pipe.</source>
          <target state="translated">위에서 언급 한 것처럼 하위 프로세스가 큐에 항목을 넣은 경우 (그리고 &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt; &lt;code&gt;JoinableQueue.cancel_join_thread&lt;/code&gt; 를&lt;/a&gt; 사용하지 않은 경우 ), 버퍼링 된 모든 항목이 파이프로 플러시 될 때까지 해당 프로세스가 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c946dacfc8f875db22dfcdba42153aefbf4569f0" translate="yes" xml:space="preserve">
          <source>As mentioned above, when doing concurrent programming it is usually best to avoid using shared state as far as possible. This is particularly true when using multiple processes.</source>
          <target state="translated">위에서 언급했듯이 동시 프로그래밍을 할 때는 가능한 한 공유 상태를 사용하지 않는 것이 가장 좋습니다. 여러 프로세스를 사용할 때 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="741a8166c57402ebadd253e7254391864f2e0259" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;a href=&quot;io#io-overview&quot;&gt;Overview&lt;/a&gt;, Python distinguishes between binary and text I/O. Files opened in binary mode (including &lt;code&gt;'b'&lt;/code&gt; in the &lt;em&gt;mode&lt;/em&gt; argument) return contents as &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects without any decoding. In text mode (the default, or when &lt;code&gt;'t'&lt;/code&gt; is included in the &lt;em&gt;mode&lt;/em&gt; argument), the contents of the file are returned as &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, the bytes having been first decoded using a platform-dependent encoding or using the specified &lt;em&gt;encoding&lt;/em&gt; if given.</source>
          <target state="translated">&lt;a href=&quot;io#io-overview&quot;&gt;Overview&lt;/a&gt; 에서 언급했듯이 Python은 이진과 텍스트 I / O를 구분합니다. 이진 모드로 열린 파일 ( &lt;em&gt;mode&lt;/em&gt; 인수 에 &lt;code&gt;'b'&lt;/code&gt; 포함 ) 은 디코딩없이 내용을 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 로 반환 합니다. 텍스트 모드 (기본값 또는 &lt;code&gt;'t'&lt;/code&gt; 가 &lt;em&gt;mode&lt;/em&gt; 인수에 포함 된 경우 )에서 파일의 내용은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 으로 반환되며 , 바이트는 플랫폼 종속 인코딩을 사용하거나 지정된 경우 지정된 &lt;em&gt;인코딩을&lt;/em&gt; 사용하여 먼저 디코딩되었습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="554761a2dd1c786ee19c7c8d095e92534e85fcea" translate="yes" xml:space="preserve">
          <source>As mentioned in the introduction, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; has grown to have three primary uses:</source>
          <target state="translated">소개에서 언급했듯이 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 세 가지 주요 용도로 성장했습니다.</target>
        </trans-unit>
        <trans-unit id="2dd3237ecb3ed79cf4cebba9859ab17d40aea008" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=7159&quot;&gt;the errata for RFC 7159&lt;/a&gt;, JSON permits literal U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas JavaScript (as of ECMAScript Edition 5.1) does not.</source>
          <target state="translated">&lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=7159&quot;&gt;RFC 7159의 정오표&lt;/a&gt; 에서 언급했듯이 JSON은 문자열에서 리터럴 U + 2028 (LINE SEPARATOR) 및 U + 2029 (PARAGRAPH SEPARATOR) 문자를 허용하지만 JavaScript (ECMAScript Edition 5.1 기준)는 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1d391aeb07828e2c8ece6409fe0c3895c39bf56" translate="yes" xml:space="preserve">
          <source>As noted in the documentation of &lt;a href=&quot;#contextlib.ExitStack.push&quot;&gt;&lt;code&gt;ExitStack.push()&lt;/code&gt;&lt;/a&gt;, this method can be useful in cleaning up an already allocated resource if later steps in the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; implementation fail.</source>
          <target state="translated">&lt;a href=&quot;#contextlib.ExitStack.push&quot;&gt; &lt;code&gt;ExitStack.push()&lt;/code&gt; &lt;/a&gt; 문서에서 언급 했듯이이 메소드는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 구현 의 이후 단계가 실패 할 경우 이미 할당 된 리소스를 정리하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a4749ff1ae4127c8c5d53e09d2473530212eedd" translate="yes" xml:space="preserve">
          <source>As of Python 3.3, this is equivalent to &lt;code&gt;os.pathconf(fd, name)&lt;/code&gt;.</source>
          <target state="translated">Python 3.3 &lt;code&gt;os.pathconf(fd, name)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="254ec21e59cc0a2f51b3d99a3106cbbf6e86b501" translate="yes" xml:space="preserve">
          <source>As of Python 3.3, this is equivalent to &lt;code&gt;os.stat(fd)&lt;/code&gt;.</source>
          <target state="translated">Python 3.3 &lt;code&gt;os.stat(fd)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="de72d09fd1ee5572d4a2be6e2e876c81871f619b" translate="yes" xml:space="preserve">
          <source>As of Python 3.3, this is equivalent to &lt;code&gt;os.stat(path, dir_fd=dir_fd,
follow_symlinks=False)&lt;/code&gt;.</source>
          <target state="translated">Python 3.3 &lt;code&gt;os.stat(path, dir_fd=dir_fd, follow_symlinks=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="020b6b46db7feae3d90b1504ca1411e18c36a07a" translate="yes" xml:space="preserve">
          <source>As our examples shows, you have to be careful with what you allow to be unpickled. Therefore if security is a concern, you may want to consider alternatives such as the marshalling API in &lt;a href=&quot;xmlrpc.client#module-xmlrpc.client&quot;&gt;&lt;code&gt;xmlrpc.client&lt;/code&gt;&lt;/a&gt; or third-party solutions.</source>
          <target state="translated">우리의 예에서 알 수 있듯이, 피클 링되지 않은 것을 조심해야합니다. 따라서 보안이 중요한 경우 &lt;a href=&quot;xmlrpc.client#module-xmlrpc.client&quot;&gt; &lt;code&gt;xmlrpc.client&lt;/code&gt; &lt;/a&gt; 의 마샬링 API 또는 타사 솔루션 과 같은 대안을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94873ca8fb7d049aa1f358ba21e1835b6d80677c" translate="yes" xml:space="preserve">
          <source>As permitted, though not required, by the RFC, this module&amp;rsquo;s serializer sets &lt;em&gt;ensure_ascii=True&lt;/em&gt; by default, thus escaping the output so that the resulting strings only contain ASCII characters.</source>
          <target state="translated">RFC에 의해 허용되지는 않지만이 모듈의 시리얼 라이저는 기본적으로 &lt;em&gt;ensure_ascii = True&lt;/em&gt; 를 설정하여 결과 문자열을 ASCII 문자 만 포함하도록 출력을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="ab552d0f5d2aaec29b8f53a32c1edd92d2547512" translate="yes" xml:space="preserve">
          <source>As required by the Python DB API Spec, the &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt;&lt;code&gt;rowcount&lt;/code&gt;&lt;/a&gt; attribute &amp;ldquo;is -1 in case no &lt;code&gt;executeXX()&lt;/code&gt; has been performed on the cursor or the rowcount of the last operation is not determinable by the interface&amp;rdquo;. This includes &lt;code&gt;SELECT&lt;/code&gt; statements because we cannot determine the number of rows a query produced until all rows were fetched.</source>
          <target state="translated">Python DB API 스펙에서 요구하는대로 &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt; &lt;code&gt;rowcount&lt;/code&gt; &lt;/a&gt; 속성은 &quot; 커서에서 &lt;code&gt;executeXX()&lt;/code&gt; 가 수행되지 않았거나 인터페이스에서 마지막 작업의 행 수를 판별 할 수 없는 경우 -1 &quot;입니다. 모든 행을 페치 할 때까지 쿼리가 생성 한 행 수를 판별 할 수 없으므로 &lt;code&gt;SELECT&lt;/code&gt; 문 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d9ef0be3fa5743d16dd6068d735d43da1ed1d14" translate="yes" xml:space="preserve">
          <source>As seen below, you usually mark the strings in your application that are candidates for translation, by wrapping them in a call to the &lt;code&gt;_()&lt;/code&gt; function, like this:</source>
          <target state="translated">아래에서 볼 수 있듯이 일반적으로 응용 프로그램에서 다음 과 같이 &lt;code&gt;_()&lt;/code&gt; 함수 에 대한 호출로 래핑하여 번역 후보 인 문자열을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="777c0664c56b282dce066ba8bdfa9c0f273bd6e5" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; function accesses the current context and allows the settings to be changed. This approach meets the needs of most applications.</source>
          <target state="translated">위에 표시된 것처럼 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 함수는 현재 컨텍스트에 액세스하여 설정을 변경할 수 있습니다. 이 접근 방식은 대부분의 응용 프로그램 요구를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="ca7a4ca36c98546dcbae60adf434cc1fdf31f390" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;MISSING&lt;/code&gt; value is a sentinel object used to detect if the &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;default_factory&lt;/code&gt; parameters are provided. This sentinel is used because &lt;code&gt;None&lt;/code&gt; is a valid value for &lt;code&gt;default&lt;/code&gt;. No code should directly use the &lt;code&gt;MISSING&lt;/code&gt; value.</source>
          <target state="translated">위에 표시된 것처럼 &lt;code&gt;MISSING&lt;/code&gt; 값은 &lt;code&gt;default&lt;/code&gt; 및 &lt;code&gt;default_factory&lt;/code&gt; 매개 변수가 제공 되는지 감지하는 데 사용되는 센티넬 오브젝트 입니다. &lt;code&gt;None&lt;/code&gt; 은 &lt;code&gt;default&lt;/code&gt; 유효한 값 이므로이 센티넬이 사용됩니다 . 어떤 코드도 &lt;code&gt;MISSING&lt;/code&gt; 값을 직접 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="e77922c76564f11dd7e1353e59f5212f7c398d9d" translate="yes" xml:space="preserve">
          <source>As shown, &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; also makes it quite easy to use &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements to manage arbitrary resources that don&amp;rsquo;t natively support the context management protocol.</source>
          <target state="translated">표시된 것처럼 &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 은 또한 컨텍스트 관리 프로토콜을 기본적으로 지원하지 않는 임의의 자원을 관리하기 위해 명령문 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 사용하기가 매우 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="afcd78e93b46d440282cd0af672c39772532099d" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;cProfile.Profile&lt;/code&gt; class cannot be calibrated, custom timer functions should be used with care and should be as fast as possible. For the best results with a custom timer, it might be necessary to hard-code it in the C source of the internal &lt;code&gt;_lsprof&lt;/code&gt; module.</source>
          <target state="translated">는 AS &lt;code&gt;cProfile.Profile&lt;/code&gt; 의 클래스를 보정 할 수 없습니다, 사용자 정의 타이머 기능은주의해서 사용해야합니다 가능한 한 빨리해야한다. 커스텀 타이머로 최상의 결과를 얻으려면 내부 &lt;code&gt;_lsprof&lt;/code&gt; 모듈 의 C 소스에 하드 코딩해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45e79820db8ac841bcd7b5678fd84162e5edd5f6" translate="yes" xml:space="preserve">
          <source>As the circle is approximated by an inscribed regular polygon, &lt;em&gt;steps&lt;/em&gt; determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons.</source>
          <target state="translated">원이 내접 정다각형으로 근사 될 때, &lt;em&gt;단계들은&lt;/em&gt; 사용하기위한 단계의 수를 결정한다. 지정하지 않으면 자동으로 계산됩니다. 일반 다각형을 그리는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="471b958617fa3e20177a04beca298db4067ef76f" translate="yes" xml:space="preserve">
          <source>As the decorated function must be able to be called multiple times, the underlying context manager must support use in multiple &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements. If this is not the case, then the original construct with the explicit &lt;code&gt;with&lt;/code&gt; statement inside the function should be used.</source>
          <target state="translated">데코 레이팅 된 함수는 여러 번 호출 될 수 있어야하므로 기본 컨텍스트 관리자는 여러 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서의 사용을 지원해야합니다 . 그렇지 않은 경우 함수 내에 명시 적 &lt;code&gt;with&lt;/code&gt; 문이 있는 원래 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="68dd2b46461463b5dc81b3ce8b1f5caf9be1fe6b" translate="yes" xml:space="preserve">
          <source>As the example shows, if an option is marked as &lt;code&gt;required&lt;/code&gt;, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will report an error if that option is not present at the command line.</source>
          <target state="translated">예제에서 볼 수 있듯이 옵션이 &lt;code&gt;required&lt;/code&gt; 로 표시 되면 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 해당 옵션이 명령 줄에없는 경우 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="76e64b80b59b5f1ae7b48ded543b566b2c5fea6e" translate="yes" xml:space="preserve">
          <source>As the help string supports %-formatting, if you want a literal &lt;code&gt;%&lt;/code&gt; to appear in the help string, you must escape it as &lt;code&gt;%%&lt;/code&gt;.</source>
          <target state="translated">도움말 문자열이 %-포매팅을 지원하므로 리터럴 &lt;code&gt;%&lt;/code&gt; 를 도움말 문자열에 표시하려면이를 &lt;code&gt;%%&lt;/code&gt; 로 이스케이프해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a59b1810ad2366588e1560b21083e815a61d7702" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, reusing a single stack object across multiple with statements works correctly, but attempting to nest them will cause the stack to be cleared at the end of the innermost with statement, which is unlikely to be desirable behaviour.</source>
          <target state="translated">예제의 결과에서 알 수 있듯이 여러 with 문에서 단일 스택 객체를 재사용하면 올바르게 작동하지만 중첩을 시도하면 가장 안쪽 with 문 끝에 스택이 지워 지므로 바람직한 동작이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7432cc881a9c7f8b1e82bf98956cfaf69b88ec94" translate="yes" xml:space="preserve">
          <source>As the previous example shows, you can add &lt;code&gt;...&lt;/code&gt; lines to your example containing only directives. This can be useful when an example is too long for a directive to comfortably fit on the same line:</source>
          <target state="translated">이전 예제에서 볼 수 있듯이 지시문 만 포함하는 예제에 &lt;code&gt;...&lt;/code&gt; 행을 추가 할 수 있습니다 . 지시문이 같은 행에 편안하게 들어가기에는 예제가 너무 긴 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bad0a4f610137a71fbd404f93777ff0fbaf5382a" translate="yes" xml:space="preserve">
          <source>As the python.org website uses &lt;em&gt;utf-8&lt;/em&gt; encoding as specified in its meta tag, we will use the same for decoding the bytes object.</source>
          <target state="translated">python.org 웹 사이트는 메타 태그에 지정된대로 &lt;em&gt;utf-8&lt;/em&gt; 인코딩을 사용하므로 bytes 객체를 디코딩 할 때도 &lt;em&gt;utf-8&lt;/em&gt; 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9ef874d7307cc69342eb69c015b2b52804bc24e" translate="yes" xml:space="preserve">
          <source>As we can easily check, our array is sorted now:</source>
          <target state="translated">쉽게 확인할 수 있듯이 이제 배열이 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c23b38ddb6aef5ba6269faf72685d2b4793ec969" translate="yes" xml:space="preserve">
          <source>As we can see above, the API is pretty straightforward. The only bit of magic involves the &lt;code&gt;DEFAULT&lt;/code&gt; section which provides default values for all other sections &lt;a href=&quot;#id14&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. Note also that keys in sections are case-insensitive and stored in lowercase &lt;a href=&quot;#id14&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">위에서 볼 수 있듯이 API는 매우 간단합니다. 마법의 유일한 비트는 다른 모든 섹션 &lt;a href=&quot;#id14&quot; id=&quot;id1&quot;&gt;1에&lt;/a&gt; 대한 기본값을 제공 하는 &lt;code&gt;DEFAULT&lt;/code&gt; 섹션과 관련이 있습니다 . 섹션의 키는 대소 문자를 구분하지 않으며 소문자 &lt;a href=&quot;#id14&quot; id=&quot;id2&quot;&gt;1로&lt;/a&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd35f4640dac53d4cba2d342193297bc4fce7dc6" translate="yes" xml:space="preserve">
          <source>As we shall see, pickle does not use directly the methods described above. In fact, these methods are part of the copy protocol which implements the &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt; special method. The copy protocol provides a unified interface for retrieving the data necessary for pickling and copying objects. &lt;a href=&quot;#id10&quot; id=&quot;id5&quot;&gt;4&lt;/a&gt;</source>
          <target state="translated">알다시피 피클은 위에서 설명한 방법을 직접 사용하지 않습니다. 실제로 이러한 메소드는 &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 특수 메소드 를 구현하는 복사 프로토콜의 일부입니다 . 복사 프로토콜은 객체를 선택하고 복사하는 데 필요한 데이터를 검색하기위한 통합 인터페이스를 제공합니다. &lt;a href=&quot;#id10&quot; id=&quot;id5&quot;&gt;4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="debea2eb93150eb2d1b36d8b1bf25e4f62753e5c" translate="yes" xml:space="preserve">
          <source>As well as a decorator &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; can be used as a context manager in a with statement:</source>
          <target state="translated">데코레이터 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 는 with 문에서 컨텍스트 관리자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9da1c5bbe7d0c4d318b5718e8cf13b1be346dab" translate="yes" xml:space="preserve">
          <source>As well as attributes on the created mock attributes, like the &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt;&lt;code&gt;return_value&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt;, of child mocks can also be configured. These aren&amp;rsquo;t syntactically valid to pass in directly as keyword arguments, but a dictionary with these as keys can still be expanded into a &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; call using &lt;code&gt;**&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt; &lt;code&gt;return_value&lt;/code&gt; &lt;/a&gt; mock의 return_value 및 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 와 같이 생성 된 mock 속성의 속성 도 구성 할 수 있습니다. 다음은 키워드 인수로 직접에서 통과 구문이 유효하지 않습니다,하지만 키와 같은 이들과 사전 여전히로 확장 될 수 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 사용하여 전화 &lt;code&gt;**&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f8beeb01a1af78f02464bc704487f07739d5804d" translate="yes" xml:space="preserve">
          <source>As well as being a path it is possible to pass a package name, for example &lt;code&gt;myproject.subpackage.test&lt;/code&gt;, as the start directory. The package name you supply will then be imported and its location on the filesystem will be used as the start directory.</source>
          <target state="translated">경로 일뿐만 아니라 패키지 이름 (예 : &lt;code&gt;myproject.subpackage.test&lt;/code&gt; )을 시작 디렉토리 로 전달할 수 있습니다 . 제공 한 패키지 이름을 가져오고 파일 시스템의 해당 위치가 시작 디렉토리로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ac654a9b0a771a253377851cbe7d9dcdd53aa08" translate="yes" xml:space="preserve">
          <source>As well as external objects, there is sometimes also a need to refer to objects in the configuration. This will be done implicitly by the configuration system for things that it knows about. For example, the string value &lt;code&gt;'DEBUG'&lt;/code&gt; for a &lt;code&gt;level&lt;/code&gt; in a logger or handler will automatically be converted to the value &lt;code&gt;logging.DEBUG&lt;/code&gt;, and the &lt;code&gt;handlers&lt;/code&gt;, &lt;code&gt;filters&lt;/code&gt; and &lt;code&gt;formatter&lt;/code&gt; entries will take an object id and resolve to the appropriate destination object.</source>
          <target state="translated">외부 객체뿐만 아니라 구성에서 객체를 참조해야 할 경우도 있습니다. 이것은 알고있는 것에 대해 구성 시스템에 의해 내재적으로 수행됩니다. 예를 들어, 문자열 값 &lt;code&gt;'DEBUG'&lt;/code&gt; A의 &lt;code&gt;level&lt;/code&gt; 로거 또는 핸들러가 자동으로 값으로 변환됩니다 &lt;code&gt;logging.DEBUG&lt;/code&gt; 하고, &lt;code&gt;handlers&lt;/code&gt; , &lt;code&gt;filters&lt;/code&gt; 및 &lt;code&gt;formatter&lt;/code&gt; 항목은 적절한 대상 객체에 대한 객체 ID와 결의를 취할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a2e6cebd59a22f19c5763adb2176795f3405ba5" translate="yes" xml:space="preserve">
          <source>As well as tracking calls to themselves, mocks also track calls to methods and attributes, and &lt;em&gt;their&lt;/em&gt; methods and attributes:</source>
          <target state="translated">모의는 자신에 대한 호출을 추적 할뿐만 아니라 메소드 및 속성에 대한 호출과 &lt;em&gt;해당&lt;/em&gt; 메소드 및 속성 을 추적 합니다.</target>
        </trans-unit>
        <trans-unit id="eba8324196b8dfc54af3887d0a5dc2b00afccd66" translate="yes" xml:space="preserve">
          <source>As well as using &lt;em&gt;autospec&lt;/em&gt; through &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; there is a &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt;&lt;code&gt;create_autospec()&lt;/code&gt;&lt;/a&gt; for creating autospecced mocks directly:</source>
          <target state="translated">물론 사용으로 &lt;em&gt;autospec을&lt;/em&gt; 통해 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 있다 &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt; &lt;code&gt;create_autospec()&lt;/code&gt; &lt;/a&gt; 직접 autospecced 모의 객체를 생성은 :</target>
        </trans-unit>
        <trans-unit id="0630c32a8836c172a8afec7c1702dc1fc98e8c01" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; won&amp;rsquo;t display anything unless an example fails. If an example does fail, then the failing example(s) and the cause(s) of the failure(s) are printed to stdout, using the same format as &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 예를 들어 오류가 발생하지 않는 한 아무 것도 표시되지 않습니다. 예제가 실패하면 실패한 예제 및 실패의 원인이 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 와 동일한 형식을 사용하여 stdout에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d2f16ec04ec8da2a8b6d28bff1e96ae0730df2f" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#mailbox.Mailbox.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt;, parameter &lt;em&gt;message&lt;/em&gt; may be a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance, an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; instance, a string, a byte string, or a file-like object (which should be open in binary mode). If &lt;em&gt;message&lt;/em&gt; is an instance of the appropriate format-specific &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; subclass (e.g., if it&amp;rsquo;s an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance and this is an &lt;a href=&quot;#mailbox.mbox&quot;&gt;&lt;code&gt;mbox&lt;/code&gt;&lt;/a&gt; instance), its format-specific information is used. Otherwise, the format-specific information of the message that currently corresponds to &lt;em&gt;key&lt;/em&gt; is left unchanged.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 매개 변수 &lt;em&gt;메시지&lt;/em&gt; 는 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스, &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; &lt;/a&gt; 인스턴스, 문자열, 바이트 문자열 또는 파일과 유사한 객체 (바이너리 모드로 열려야 함) 일 수 있습니다. 경우 &lt;em&gt;메시지가&lt;/em&gt; 적절한 형식 별의의 인스턴스 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 서브 클래스 (그것이 있다면 예를 들어, &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가이가있다 &lt;a href=&quot;#mailbox.mbox&quot;&gt; &lt;code&gt;mbox&lt;/code&gt; &lt;/a&gt; 예), 그 형식 별 정보가 사용됩니다. 그렇지 않으면 현재 &lt;em&gt;키에&lt;/em&gt; 해당하는 메시지의 형식 별 정보는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bf2339fc3da041c7b40d65293bdd95b7f0f7885" translate="yes" xml:space="preserve">
          <source>As with a dictionary, you can use a section&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; method to provide fallback values:</source>
          <target state="translated">사전과 마찬가지로 섹션의 &lt;code&gt;get()&lt;/code&gt; 메소드를 사용하여 폴백 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57771b08d272fad9dc8b1be5068d86775d7fa3ca" translate="yes" xml:space="preserve">
          <source>As with all other objects in Python the old objects are only reclaimed after their reference counts drop to zero.</source>
          <target state="translated">파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으로 떨어진 후에 만 ​​재생됩니다.</target>
        </trans-unit>
        <trans-unit id="de44bc643f497be8df1b37fe142eb3754e000e16" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;try&lt;/code&gt; statement based code, this can cause problems for development and review, because the setup code and the cleanup code can end up being separated by arbitrarily long sections of code.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 문 기반 코드 와 마찬가지로 설치 코드와 정리 코드가 임의로 긴 코드 섹션으로 분리 될 수 있으므로 개발 및 검토에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3ab064145c449d1616c3eb8354b791e442472ff" translate="yes" xml:space="preserve">
          <source>As with any other mechanism that completely suppresses exceptions, this context manager should be used only to cover very specific errors where silently continuing with program execution is known to be the right thing to do.</source>
          <target state="translated">예외를 완전히 억제하는 다른 메커니즘과 마찬가지로이 컨텍스트 관리자는 프로그램 실행을 자동으로 계속하는 것이 올바른 것으로 알려진 매우 구체적인 오류를 처리하는 데만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="61ba626904718f435e8bb9195d72a3d4e176bd46" translate="yes" xml:space="preserve">
          <source>As with message in an mbox mailbox, MMDF messages are stored with the sender&amp;rsquo;s address and the delivery date in an initial line beginning with &amp;ldquo;From &amp;ldquo;. Likewise, flags that indicate the state of the message are typically stored in &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers.</source>
          <target state="translated">mbox 편지함에있는 메시지와 마찬가지로 MMDF 메시지는 보낸 사람의 주소와 배달 날짜와 함께 &quot;보낸 사람&quot;으로 시작하는 첫 줄에 저장됩니다. 마찬가지로, 메시지 상태를 나타내는 플래그는 일반적으로 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X- 상태&lt;/em&gt; 헤더에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8bb7354faa685cfe016fc2268268a70658988eb5" translate="yes" xml:space="preserve">
          <source>As with other methods, case-sensitivity is observed:</source>
          <target state="translated">다른 방법과 마찬가지로 대소 문자 구분이 관찰됩니다.</target>
        </trans-unit>
        <trans-unit id="31db4d814a8ee3a9c296a0ac9ab18e1168c00cb9" translate="yes" xml:space="preserve">
          <source>As with string literals, bytes literals may also use a &lt;code&gt;r&lt;/code&gt; prefix to disable processing of escape sequences. See &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#strings&quot;&gt;String and Bytes literals&lt;/a&gt; for more about the various forms of bytes literal, including supported escape sequences.</source>
          <target state="translated">문자열 리터럴과 마찬가지로 바이트 리터럴도 &lt;code&gt;r&lt;/code&gt; 접두사를 사용하여 이스케이프 시퀀스 처리를 비활성화 할 수 있습니다 . 지원되는 이스케이프 시퀀스를 포함한 다양한 형식의 바이트 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#strings&quot;&gt;리터럴에&lt;/a&gt; 대한 자세한 내용은 문자열 및 바이트 리터럴 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6084fcb644e26dce144964d5ce8fd1b644c1bcfd" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;#description&quot;&gt;description&lt;/a&gt; argument, the &lt;code&gt;epilog=&lt;/code&gt; text is by default line-wrapped, but this behavior can be adjusted with the &lt;a href=&quot;#formatter-class&quot;&gt;formatter_class&lt;/a&gt; argument to &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#description&quot;&gt;설명&lt;/a&gt; 인수의 &lt;code&gt;epilog=&lt;/code&gt; 텍스트는 기본 라인 포장에 의해이지만,이 문제는 조정할 수 있습니다 &lt;a href=&quot;#formatter-class&quot;&gt;formatter_class&lt;/a&gt; 에 인수 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50d385a8286d57094c5ce3df7ad9daf11b5640f8" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; module, you aren&amp;rsquo;t limited to the functionality of the bundled generator; you could write one from scratch yourself. However the bundled generator knows how to generate most email in a standards-compliant way, should handle MIME and non-MIME email messages just fine, and is designed so that the bytes-oriented parsing and generation operations are inverses, assuming the same non-transforming &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; is used for both. That is, parsing the serialized byte stream via the &lt;a href=&quot;email.parser#email.parser.BytesParser&quot;&gt;&lt;code&gt;BytesParser&lt;/code&gt;&lt;/a&gt; class and then regenerating the serialized byte stream using &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt; should produce output identical to the input &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. (On the other hand, using the generator on an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; constructed by program may result in changes to the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object as defaults are filled in.)</source>
          <target state="translated">&lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; &lt;/a&gt; 모듈 과 마찬가지로 번들 생성기의 기능에 제한되지 않습니다. 처음부터 직접 작성할 수 있습니다. 그러나 번들 생성기는 표준 호환 방식으로 대부분의 전자 메일을 생성하는 방법을 알고 있으며 MIME 및 비 MIME 전자 메일 메시지를 잘 처리해야하며 바이트 지향 구문 분석 및 생성 작업이 동일하지 않은 것으로 가정합니다. 변형 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 은 둘 다에 사용됩니다. 즉, &lt;a href=&quot;email.parser#email.parser.BytesParser&quot;&gt; &lt;code&gt;BytesParser&lt;/code&gt; &lt;/a&gt; 클래스 를 통해 직렬화 된 바이트 스트림을 구문 분석 한 후 &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 를 사용하여 직렬화 된 바이트 스트림을 재생성 하면 입력 &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 과 동일한 출력이 생성 됩니다. (반면, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 에서 생성기를 사용하면프로그램에 의해 생성 되면 기본값이 채워짐에 따라 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 객체 가 변경 될 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="98b68bf763d9b565df24602f94e028fb7d75d354" translate="yes" xml:space="preserve">
          <source>As with the constructor for &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;, the &lt;em&gt;filename&lt;/em&gt; argument can be an actual filename (a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object), or an existing file object to read from or write to.</source>
          <target state="translated">생성자와 마찬가지로 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;파일 이름&lt;/em&gt; 인수는 실제 파일 이름 (A 할 수 있습니다 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체), 또는 나 쓰기에 읽을 수있는 기존 파일 개체를.</target>
        </trans-unit>
        <trans-unit id="39b89ac3cbb6042a6b76daccce240847a7e0deae" translate="yes" xml:space="preserve">
          <source>As with the normal socket object, &lt;em&gt;address&lt;/em&gt; is a tuple with the first element the host to connect to, and the second the port number.</source>
          <target state="translated">일반 소켓 객체와 마찬가지로 &lt;em&gt;address&lt;/em&gt; 는 호스트가 연결하는 첫 번째 요소와 두 번째 포트 번호가 포함 된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="f590c8191e52a5707968f655cd53f953a854a829" translate="yes" xml:space="preserve">
          <source>As you can see, we can treat a config parser much like a dictionary. There are differences, &lt;a href=&quot;#mapping-protocol-access&quot;&gt;outlined later&lt;/a&gt;, but the behavior is very close to what you would expect from a dictionary.</source>
          <target state="translated">보시다시피, 구성 파서는 사전처럼 취급 할 수 있습니다. 차이점은 &lt;a href=&quot;#mapping-protocol-access&quot;&gt;나중에 설명&lt;/a&gt; 하지만 동작은 사전에서 기대하는 것과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="59f904f27b756361ae89156e1ce717db987f76ba" translate="yes" xml:space="preserve">
          <source>As you&amp;rsquo;d expect, the legal values for &lt;em&gt;someAction&lt;/em&gt; will depend on the widget&amp;rsquo;s class: &lt;code&gt;.fred disable&lt;/code&gt; works if fred is a button (fred gets greyed out), but does not work if fred is a label (disabling of labels is not supported in Tk).</source>
          <target state="translated">예상 한 바와 같이 &lt;em&gt;someAction&lt;/em&gt; 의 유효한 값 은 위젯 클래스에 따라 다릅니다. &lt;code&gt;.fred disable&lt;/code&gt; 은 fred가 버튼 인 경우 작동하지만 (fred는 회색으로 표시됨) fred가 레이블 인 경우 작동하지 않습니다 (레이블 사용 안함은 지원되지 않음). Tk에서).</target>
        </trans-unit>
        <trans-unit id="61b9f99dea4285cc76b6c48cda8a14e52d2b891d" translate="yes" xml:space="preserve">
          <source>As your collection of doctest&amp;rsquo;ed modules grows, you&amp;rsquo;ll want a way to run all their doctests systematically. &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; provides two functions that can be used to create &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; test suites from modules and text files containing doctests. To integrate with &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; test discovery, include a &lt;code&gt;load_tests()&lt;/code&gt; function in your test module:</source>
          <target state="translated">doctest'ed 모듈의 컬렉션이 증가함에 따라 모든 doctest를 체계적으로 실행할 수있는 방법이 필요합니다. &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 모듈 및 doctest를 포함하는 텍스트 파일에서 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 테스트 스위트 를 작성하는 데 사용할 수있는 두 가지 기능을 제공합니다 . &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 테스트 감지 와 통합하려면 테스트 모듈에 &lt;code&gt;load_tests()&lt;/code&gt; 함수를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="2a9978f5d754841b336538c4c5a01a51bbcd2678" translate="yes" xml:space="preserve">
          <source>Assert that &lt;em&gt;iter&lt;/em&gt; is deallocated after iterating.</source>
          <target state="translated">주장 &lt;em&gt;ITER는&lt;/em&gt; 반복하는 후 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fd264d50fb4b9eeefc754b5a58a5fcba3dedc28e" translate="yes" xml:space="preserve">
          <source>Assert that running the interpreter with &lt;em&gt;args&lt;/em&gt; and optional environment variables &lt;em&gt;env_vars&lt;/em&gt; fails (&lt;code&gt;rc != 0&lt;/code&gt;) and return a &lt;code&gt;(return code,
stdout, stderr)&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; 및 선택적 환경 변수 &lt;em&gt;env_vars를 사용&lt;/em&gt; 하여 인터프리터 실행이 실패하고 ( &lt;code&gt;rc != 0&lt;/code&gt; ) &lt;code&gt;(return code, stdout, stderr)&lt;/code&gt; 튜플을 리턴한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e0d6e30e5daa962c493e2c53bfd3e5bd71e7f71" translate="yes" xml:space="preserve">
          <source>Assert that running the interpreter with &lt;em&gt;args&lt;/em&gt; and optional environment variables &lt;em&gt;env_vars&lt;/em&gt; succeeds (&lt;code&gt;rc == 0&lt;/code&gt;) and return a &lt;code&gt;(return code,
stdout, stderr)&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; 및 선택적 환경 변수 &lt;em&gt;env_vars를 사용&lt;/em&gt; 하여 인터프리터를 실행 하면 ( &lt;code&gt;rc == 0&lt;/code&gt; ) 성공 하고 &lt;code&gt;(return code, stdout, stderr)&lt;/code&gt; 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f8fb3abe58177e5028044ca5b20cc140fb7d71a8" translate="yes" xml:space="preserve">
          <source>Assert that the &lt;code&gt;__all__&lt;/code&gt; variable of &lt;em&gt;module&lt;/em&gt; contains all public names.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 의 &lt;code&gt;__all__&lt;/code&gt; 변수에 모든 공용 이름이 포함되어 있다고 가정하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55a3005fb29b0592036701f49249b35f6fe4e576" translate="yes" xml:space="preserve">
          <source>Assert that the last await was with the specified arguments.</source>
          <target state="translated">마지막 대기가 지정된 인수와 함께 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab3c9a0f942a4e5218663ad1728f419192ba180" translate="yes" xml:space="preserve">
          <source>Assert that the mock was awaited at least once. Note that this is separate from the object having been called, the &lt;code&gt;await&lt;/code&gt; keyword must be used:</source>
          <target state="translated">모의가 적어도 한 번 기다렸다 고 주장하십시오. 이것은 호출 된 객체와 별개이므로 &lt;code&gt;await&lt;/code&gt; 키워드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="559c5d43237366024e3609d35920dccb6c140415" translate="yes" xml:space="preserve">
          <source>Assert that the mock was awaited exactly once and with the specified arguments.</source>
          <target state="translated">모의가 정확히 한 번, 지정된 인수로 기다리고 있다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad7deeafb38bd4aeb17622c34aa957e7bdb88a1" translate="yes" xml:space="preserve">
          <source>Assert that the mock was awaited exactly once.</source>
          <target state="translated">모의가 정확히 한 번 기다렸다 고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="1f4df423286b9ac2be8365c78eafe1774099f5f2" translate="yes" xml:space="preserve">
          <source>Assert that the mock was called at least once.</source>
          <target state="translated">모의가 한 번 이상 호출되었다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="3324ced759f5d86b62cf891c7da413bc53b68560" translate="yes" xml:space="preserve">
          <source>Assert that the mock was called exactly once and that that call was with the specified arguments.</source>
          <target state="translated">모의가 정확히 한 번 호출되었고 해당 호출이 지정된 인수와 함께 있다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="5bf57493612b2763417d96c9bf7967affcea4272" translate="yes" xml:space="preserve">
          <source>Assert that the mock was called exactly once.</source>
          <target state="translated">모의가 정확히 한 번 호출되었다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="3db0fab7867c814616ac71a3a5143ce2dff5900d" translate="yes" xml:space="preserve">
          <source>Assert that the mock was never awaited.</source>
          <target state="translated">모의를 기다리지 않았다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="c1c646d111dcc42ccae26bbe43d3ddada473ab0f" translate="yes" xml:space="preserve">
          <source>Assert the mock has been awaited with the specified calls. The &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt;&lt;code&gt;await_args_list&lt;/code&gt;&lt;/a&gt; list is checked for the awaits.</source>
          <target state="translated">지정된 호출로 모의가 대기되었다고 가정하십시오. &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt; &lt;code&gt;await_args_list&lt;/code&gt; &lt;/a&gt; 목록이 기다리고 점검한다.</target>
        </trans-unit>
        <trans-unit id="aeceb688911f6dcdcfa555a84d22383aa56d4db7" translate="yes" xml:space="preserve">
          <source>Assert the mock has ever been awaited with the specified arguments.</source>
          <target state="translated">지정된 인수로 모의가 기다리고 있다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="3d67cb9aa133440c8ea1ec7d7cc69fcf71038d22" translate="yes" xml:space="preserve">
          <source>Assert the mock was never called.</source>
          <target state="translated">모의가 불려지지 않았다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="e3292c12a856a02722a46d87471ff4e6faefa104" translate="yes" xml:space="preserve">
          <source>AssertionError</source>
          <target state="translated">AssertionError</target>
        </trans-unit>
        <trans-unit id="096ae7879fe3ac7e3285826b7966eb892e08f3e2" translate="yes" xml:space="preserve">
          <source>Assign a Python function or another callable to this attribute. The callable will be called with three or more arguments:</source>
          <target state="translated">이 함수에 파이썬 함수 또는 다른 호출 가능 함수를 할당하십시오. 콜 러블은 세 개 이상의 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2d6b37186bcf31c990ffb06dcf0507a39bd37db6" translate="yes" xml:space="preserve">
          <source>Assign a ctypes type to specify the result type of the foreign function. Use &lt;code&gt;None&lt;/code&gt; for &lt;code&gt;void&lt;/code&gt;, a function not returning anything.</source>
          <target state="translated">외부 함수의 결과 유형을 지정하려면 ctypes 유형을 지정하십시오. 아무것도 반환하지 않는 함수 인 &lt;code&gt;void&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="87af2d9b58846a93bc5651822c3deea453207ca5" translate="yes" xml:space="preserve">
          <source>Assign a tuple of ctypes types to specify the argument types that the function accepts. Functions using the &lt;code&gt;stdcall&lt;/code&gt; calling convention can only be called with the same number of arguments as the length of this tuple; functions using the C calling convention accept additional, unspecified arguments as well.</source>
          <target state="translated">함수가 허용하는 인수 유형을 지정하려면 ctypes 유형의 튜플을 지정하십시오. &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용하는 함수 는이 튜플의 길이와 동일한 수의 인수로만 호출 할 수 있습니다. C 호출 규칙을 사용하는 함수는 지정되지 않은 추가 인수도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="24cd252fad6840a721b5d763b587fe334065ad54" translate="yes" xml:space="preserve">
          <source>Assigning a new value to instances of the pointer types &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ctypes.c_wchar_p&quot;&gt;&lt;code&gt;c_wchar_p&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ctypes.c_void_p&quot;&gt;&lt;code&gt;c_void_p&lt;/code&gt;&lt;/a&gt; changes the &lt;em&gt;memory location&lt;/em&gt; they point to, &lt;em&gt;not the contents&lt;/em&gt; of the memory block (of course not, because Python bytes objects are immutable):</source>
          <target state="translated">포인터 유형 &lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ctypes.c_wchar_p&quot;&gt; &lt;code&gt;c_wchar_p&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.c_void_p&quot;&gt; &lt;code&gt;c_void_p&lt;/code&gt; 의&lt;/a&gt; 인스턴스에 새 값을 지정 하면 메모리 블록 &lt;em&gt;의 내용&lt;/em&gt; 이 &lt;em&gt;아니라&lt;/em&gt; 그들이 가리키는 &lt;em&gt;메모리 위치가&lt;/em&gt; 변경 됩니다 (물론 파이썬 바이트 오브젝트는 변경할 수 없기 때문에).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ad21f0fedcc6176cc70cb700d98f976d15416af" translate="yes" xml:space="preserve">
          <source>Assigning another &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt; instance to the pointer&amp;rsquo;s contents attribute would cause the pointer to point to the memory location where this is stored:</source>
          <target state="translated">다른 &lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; &lt;/a&gt; 인스턴스를 포인터의 contents 속성에 할당 하면 포인터가 저장된 메모리 위치를 가리키게됩니다.</target>
        </trans-unit>
        <trans-unit id="0b02ed6e18cfc24fbfbfe9a5ea607ee75077dc86" translate="yes" xml:space="preserve">
          <source>Assigning to an integer index changes the pointed to value:</source>
          <target state="translated">정수 색인에 지정하면 지정된 값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="d425ffd0dc0c03777b86385bf81e964839a8b08e" translate="yes" xml:space="preserve">
          <source>Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other. This module provides generic shallow and deep copy operations (explained below).</source>
          <target state="translated">파이썬에서 대 입문은 객체를 복사하지 않고 대상과 객체 사이에 바인딩을 만듭니다. 변경 가능하거나 변경 가능한 항목이 포함 된 컬렉션의 경우 복사본이 필요할 수 있으므로 다른 복사본을 변경하지 않고 한 복사본을 변경할 수 있습니다. 이 모듈은 일반적인 얕은 복사 및 깊은 복사 작업을 제공합니다 (아래 설명).</target>
        </trans-unit>
        <trans-unit id="8e44ce9ac8ed3d578e4f315bbe0851d670b4c1ce" translate="yes" xml:space="preserve">
          <source>Assignment to these attributes should not be necessary other than in rare circumstances in a &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; method. The class does not enforce internal consistency, so you should know what you&amp;rsquo;re doing if you do that.</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 메서드 에서 드문 경우를 제외하고 이러한 특성에 할당 할 필요는 없습니다 . 수업은 내부 일관성을 강요하지 않으므로 그렇게 할 경우 수행중인 작업을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="4bdbb7b0403c9ed5b42c0c1a8e706970ef50e63c" translate="yes" xml:space="preserve">
          <source>Associate &lt;em&gt;dialect&lt;/em&gt; with &lt;em&gt;name&lt;/em&gt;. &lt;em&gt;name&lt;/em&gt; must be a string. The dialect can be specified either by passing a sub-class of &lt;a href=&quot;#csv.Dialect&quot;&gt;&lt;code&gt;Dialect&lt;/code&gt;&lt;/a&gt;, or by &lt;em&gt;fmtparams&lt;/em&gt; keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about the dialect and formatting parameters, see section &lt;a href=&quot;#csv-fmt-params&quot;&gt;Dialects and Formatting Parameters&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;방언&lt;/em&gt; 을 &lt;em&gt;name&lt;/em&gt; 과 연결하십시오 . &lt;em&gt;이름&lt;/em&gt; 은 문자열이어야합니다. &lt;a href=&quot;#csv.Dialect&quot;&gt; &lt;code&gt;Dialect&lt;/code&gt; &lt;/a&gt; 의 하위 클래스를 전달 하거나 &lt;em&gt;fmtparams&lt;/em&gt; 키워드 인수 또는 둘 다를 사용하여 방언의 매개 변수를 재정의하는 키워드 인수를 사용하여 방언을 지정할 수 있습니다. 방언 및 서식 매개 변수에 대한 자세한 내용은 섹션을 참조 &lt;a href=&quot;#csv-fmt-params&quot;&gt;방언 및 서식 매개 변수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f3bcabdd04e1667230d7f6889c5454cd909ae99" translate="yes" xml:space="preserve">
          <source>Associates a value with a specified key.</source>
          <target state="translated">값을 지정된 키와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="57c2abf791222401df793e61a9b604ada26f9510" translate="yes" xml:space="preserve">
          <source>Associates level &lt;em&gt;level&lt;/em&gt; with text &lt;em&gt;levelName&lt;/em&gt; in an internal dictionary, which is used to map numeric levels to a textual representation, for example when a &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; formats a message. This function can also be used to define your own levels. The only constraints are that all levels used must be registered using this function, levels should be positive integers and they should increase in increasing order of severity.</source>
          <target state="translated">내부 사전에서 레벨 &lt;em&gt;레벨&lt;/em&gt; 을 텍스트 &lt;em&gt;levelName&lt;/em&gt; 과 연관 시킵니다. 예를 들어 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 가 메시지를 형식화 할 때 숫자 레벨을 텍스트 표시에 맵핑 합니다. 이 기능을 사용하여 자신 만의 레벨을 정의 할 수도 있습니다. 사용되는 모든 레벨은이 함수를 사용하여 등록해야하며 레벨은 양의 정수 여야하며 심각도의 증가에 따라 증가해야한다는 제약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99867ade566e46b388e954ef09df2f75d1038b85" translate="yes" xml:space="preserve">
          <source>Assume authentication as &lt;em&gt;user&lt;/em&gt;. Allows an authorised administrator to proxy into any user&amp;rsquo;s mailbox.</source>
          <target state="translated">&lt;em&gt;user로&lt;/em&gt; 인증을 가정하십시오 . 권한있는 관리자가 사용자의 사서함에 프록시를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="26bb7ee1e82bfd124b995cad27c9d2ea8e6c6188" translate="yes" xml:space="preserve">
          <source>Assume the end of the document. That will check well-formedness conditions that can be checked only at the end, invoke handlers, and may clean up resources allocated during parsing.</source>
          <target state="translated">문서의 끝을 가정하십시오. 그러면 끝에서만 확인할 수있는 올바른 형식의 조건을 확인하고 핸들러를 호출하며 구문 분석 중에 할당 된 자원을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6fb61e671a32cacd481771d74554c4616cd64b" translate="yes" xml:space="preserve">
          <source>Assuming the Python code above is saved into a file called &lt;code&gt;prog.py&lt;/code&gt;, it can be run at the command line and provides useful help messages:</source>
          <target state="translated">위의 Python 코드가 &lt;code&gt;prog.py&lt;/code&gt; 파일에 저장되어 있다고 가정하면 명령 행에서 실행할 수 있으며 유용한 도움말 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="17acdde866027b94b28efa16a0a09a1e51553c63" translate="yes" xml:space="preserve">
          <source>Assuming the associated lock is recursive (which it is by default) you can instead do</source>
          <target state="translated">연관된 잠금이 재귀 적이라고 가정하면 (기본적으로) 대신 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="005edc07fe911b0da3e54105325e3a3dbe1f1711" translate="yes" xml:space="preserve">
          <source>Assuming your script has no syntax errors, yet it does not work, you have no choice but to read the next section.</source>
          <target state="translated">스크립트에 구문 오류가 없지만 작동하지 않는 경우 다음 섹션을 읽을 수 밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="f329190d0fd15344dac730aabc63c032720e1284" translate="yes" xml:space="preserve">
          <source>Asterisk</source>
          <target state="translated">Asterisk</target>
        </trans-unit>
        <trans-unit id="7011bcb2a149d047c8ec7153896517a23adc9f65" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O</source>
          <target state="translated">비동기식 I / O</target>
        </trans-unit>
        <trans-unit id="76a9f4eccd2719060ed9b323830b0077d403caed" translate="yes" xml:space="preserve">
          <source>Asynchronous Mixins</source>
          <target state="translated">비동기 믹스 인</target>
        </trans-unit>
        <trans-unit id="104c39ddd5b87efe32adc15b6d214b9332b179b7" translate="yes" xml:space="preserve">
          <source>Asynchronous iteration methods: &lt;code&gt;__aiter__&lt;/code&gt; and &lt;code&gt;__anext__&lt;/code&gt;</source>
          <target state="translated">비동기 반복 방법 : &lt;code&gt;__aiter__&lt;/code&gt; 및 &lt;code&gt;__anext__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="209a40d7b9cbb542c52bb05184d751a0e19a14bd" translate="yes" xml:space="preserve">
          <source>Asynchronous programming is different from classic &amp;ldquo;sequential&amp;rdquo; programming.</source>
          <target state="translated">비동기식 프로그래밍은 일반적인 &quot;순차적&quot;프로그래밍과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="120004888d9e7b45090be61175fabb0ddafb7dcc" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="9704ec7e27d093412e9ffd17b2f9417c95ee49f0" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.getnameinfo&quot;&gt;&lt;code&gt;socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.getnameinfo&quot;&gt; &lt;code&gt;socket.getnameinfo()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="e75a6e60c21cef60290f8db343e2dd2f1b6b1276" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.socket.connect&quot;&gt;&lt;code&gt;socket.connect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.socket.connect&quot;&gt; &lt;code&gt;socket.connect()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="e50fde5f44e91a6cb4dcbfaaaadebf896e7d84b9" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.socket.sendfile&quot;&gt;&lt;code&gt;socket.sendfile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.socket.sendfile&quot;&gt; &lt;code&gt;socket.sendfile()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="03e876b72734198f8efacaee16cfa51b70b11561" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified when invoking &lt;a href=&quot;#module-trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#cmdoption-trace-l&quot;&gt;&lt;code&gt;--listfuncs&lt;/code&gt;&lt;/a&gt; option is mutually exclusive with the &lt;a href=&quot;#cmdoption-trace-t&quot;&gt;&lt;code&gt;--trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; options. When &lt;a href=&quot;#cmdoption-trace-l&quot;&gt;&lt;code&gt;--listfuncs&lt;/code&gt;&lt;/a&gt; is provided, neither &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;#cmdoption-trace-t&quot;&gt;&lt;code&gt;--trace&lt;/code&gt;&lt;/a&gt; are accepted, and vice versa.</source>
          <target state="translated">&lt;a href=&quot;#module-trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 다음 옵션 중 하나 이상을 지정해야합니다 . &lt;a href=&quot;#cmdoption-trace-l&quot;&gt; &lt;code&gt;--listfuncs&lt;/code&gt; 의&lt;/a&gt; 옵션과 상호 배타적입니다 &lt;a href=&quot;#cmdoption-trace-t&quot;&gt; &lt;code&gt;--trace&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 옵션을 제공합니다. 때 &lt;a href=&quot;#cmdoption-trace-l&quot;&gt; &lt;code&gt;--listfuncs&lt;/code&gt; 는&lt;/a&gt; ,도 제공 &lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 도 &lt;a href=&quot;#cmdoption-trace-t&quot;&gt; &lt;code&gt;--trace&lt;/code&gt; 은&lt;/a&gt; 받아, 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="005c763745673715312660addc3a03a01b8c8624" translate="yes" xml:space="preserve">
          <source>At normal program termination (for instance, if &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt; is called or the main module&amp;rsquo;s execution completes), all functions registered are called in last in, first out order. The assumption is that lower level modules will normally be imported before higher level modules and thus must be cleaned up later.</source>
          <target state="translated">정상적인 프로그램 종료시 (예를 들어, &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 가 호출되거나 주 모듈의 실행이 완료된 경우) 등록 된 모든 함수는 마지막 순서대로 먼저 호출됩니다. 일반적으로 하위 모듈은 상위 모듈보다 먼저 가져 오기 때문에 나중에 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4212a7fb6907badcb796ef9f8a9820ede2ad461f" translate="yes" xml:space="preserve">
          <source>At object creation time, using keyword arguments</source>
          <target state="translated">키워드 인수를 사용하여 객체 생성시</target>
        </trans-unit>
        <trans-unit id="b9dffbcc195db46cf07fd560bf9cf819a6052dfc" translate="yes" xml:space="preserve">
          <source>At runtime, &lt;code&gt;isinstance(x, T)&lt;/code&gt; will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In general, &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions#issubclass&quot;&gt;&lt;code&gt;issubclass()&lt;/code&gt;&lt;/a&gt; should not be used with types.</source>
          <target state="translated">런타임시 &lt;code&gt;isinstance(x, T)&lt;/code&gt; 는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 일반적으로 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;functions#issubclass&quot;&gt; &lt;code&gt;issubclass()&lt;/code&gt; &lt;/a&gt; 는 유형과 함께 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="86ca4076074ecbdd662b657c7418c10266e2fae5" translate="yes" xml:space="preserve">
          <source>At the end of the module, there is a test section that contains a more extensive example of usage.</source>
          <target state="translated">모듈의 끝에는보다 광범위한 사용 예제가 포함 된 테스트 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73eae57537773d1ac17b68b2f125d8fe89f21f11" translate="yes" xml:space="preserve">
          <source>At the highest level, the transport is concerned with &lt;em&gt;how&lt;/em&gt; bytes are transmitted, while the protocol determines &lt;em&gt;which&lt;/em&gt; bytes to transmit (and to some extent when).</source>
          <target state="translated">최상위 레벨에서, 상기 전송이 염려되는 &lt;em&gt;방법&lt;/em&gt; 프로토콜 결정하면서, 바이트들이 전송 &lt;em&gt;되는&lt;/em&gt; (언제, 어느 정도까지)로 송신 바이트.</target>
        </trans-unit>
        <trans-unit id="7b93ef8974634ba1eeddb05cd6f4fb7beae6e9cc" translate="yes" xml:space="preserve">
          <source>At the moment, there is only one possible parameter:</source>
          <target state="translated">현재 가능한 매개 변수는 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8578bb4b0c201f731d20286e27c500875b32217c" translate="yes" xml:space="preserve">
          <source>At the operating system level, sockets in &lt;em&gt;timeout mode&lt;/em&gt; are internally set in non-blocking mode. Also, the blocking and timeout modes are shared between file descriptors and socket objects that refer to the same network endpoint. This implementation detail can have visible consequences if e.g. you decide to use the &lt;a href=&quot;#socket.socket.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; of a socket.</source>
          <target state="translated">운영 체제 레벨에서 &lt;em&gt;시간 종료 모드의&lt;/em&gt; 소켓 은 내부적으로 비 블로킹 모드로 설정됩니다. 또한 차단 및 시간 종료 모드는 파일 설명자와 동일한 네트워크 엔드 포인트를 참조하는 소켓 오브젝트간에 공유됩니다. 예를 들어 , 소켓 의 &lt;a href=&quot;#socket.socket.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 를 사용하기로 결정한 경우이 구현 세부 사항은 가시적 인 결과를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de79fa22e86445c74c1c60a24771c2ff1fcf7262" translate="yes" xml:space="preserve">
          <source>At the point where the generator yields, the block nested in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement is executed. The generator is then resumed after the block is exited. If an unhandled exception occurs in the block, it is reraised inside the generator at the point where the yield occurred. Thus, you can use a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt;&amp;hellip;&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt;&amp;hellip;&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; statement to trap the error (if any), or ensure that some cleanup takes place. If an exception is trapped merely in order to log it or to perform some action (rather than to suppress it entirely), the generator must reraise that exception. Otherwise the generator context manager will indicate to the &lt;code&gt;with&lt;/code&gt; statement that the exception has been handled, and execution will resume with the statement immediately following the &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">생성기가 생성되는 시점에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에 중첩 된 블록 이 실행됩니다. 그런 다음 블록이 종료 된 후 생성기가 다시 시작됩니다. 처리되지 않은 예외가 블록에서 발생하면 수율이 발생한 지점에서 발생기 내부에서 다시 발생합니다. 따라서 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 문을 사용하여 오류를 잡거나 (정리 된 경우) 정리할 수 있습니다. 예외를 기록하기 위해 또는 예외를 완전히 억제하지 않고 일부 작업을 수행하기 위해 예외가 발생하는 경우 생성기는 해당 예외를 다시 발생시켜야합니다. 그렇지 않으면 발전기 컨텍스트 관리자는로 표시됩니다 &lt;code&gt;with&lt;/code&gt; 예외가 처리되었다고 선언하면 &lt;code&gt;with&lt;/code&gt; 문 바로 뒤에 나오는 문으로 실행이 다시 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f936198137a924a78693853317db45f419b314f" translate="yes" xml:space="preserve">
          <source>At the time of this writing there are docstring dictionaries in German and in Italian. (Requests please to &lt;a href=&quot;mailto:glingl%40aon.at&quot;&gt;glingl@aon.at&lt;/a&gt;.)</source>
          <target state="translated">이 글을 쓰는 시점에는 독어와 이탈리아어로 된 docstring 사전이 있습니다. ( &lt;a href=&quot;mailto:glingl%40aon.at&quot;&gt;glingl@aon.at에&lt;/a&gt; 요청하십시오 .)</target>
        </trans-unit>
        <trans-unit id="bd54bc6b94be573dbc110a2ed3dd2570d7474e92" translate="yes" xml:space="preserve">
          <source>At the top of the I/O hierarchy is the abstract base class &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. It defines the basic interface to a stream. Note, however, that there is no separation between reading and writing to streams; implementations are allowed to raise &lt;a href=&quot;#io.UnsupportedOperation&quot;&gt;&lt;code&gt;UnsupportedOperation&lt;/code&gt;&lt;/a&gt; if they do not support a given operation.</source>
          <target state="translated">I / O 계층의 맨 위에는 추상 기본 클래스 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 가&lt;/a&gt; 있습니다. 스트림에 대한 기본 인터페이스를 정의합니다. 그러나 스트림에 대한 읽기와 쓰기는 분리되지 않습니다. 구현이 지정된 작업을 지원하지 않으면 &lt;a href=&quot;#io.UnsupportedOperation&quot;&gt; &lt;code&gt;UnsupportedOperation&lt;/code&gt; 을&lt;/a&gt; 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546ddf033018c3a7e711de15f41a05346f8ae2b5" translate="yes" xml:space="preserve">
          <source>At the top of the stack are either &lt;code&gt;NULL&lt;/code&gt; (pushed by &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt;&lt;code&gt;BEGIN_FINALLY&lt;/code&gt;&lt;/a&gt;) or 6 values pushed if an exception has been raised in the with block. Below is the context manager&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt;&lt;code&gt;__aexit__()&lt;/code&gt;&lt;/a&gt; bound method.</source>
          <target state="translated">스택의 맨 위에는 &lt;code&gt;NULL&lt;/code&gt; ( &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt; &lt;code&gt;BEGIN_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 됨 ) 또는 with 블록에서 예외가 발생한 경우 6 개의 값이 푸시됩니다. 아래는 컨텍스트 관리자의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt; &lt;code&gt;__aexit__()&lt;/code&gt; &lt;/a&gt; 바운드 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="3a9ec1befa4a5306b468dc7e8631beee73bd6981" translate="yes" xml:space="preserve">
          <source>At this point, you can remove the application name from the registry as a source of event log entries. However, if you do this, you will not be able to see the events as you intended in the Event Log Viewer - it needs to be able to access the registry to get the .dll name. The current version does not do this.</source>
          <target state="translated">이때 레지스트리에서 응용 프로그램 이름을 이벤트 로그 항목의 소스로 제거 할 수 있습니다. 그러나이 작업을 수행하면 이벤트 로그 뷰어에서 의도 한대로 이벤트를 볼 수 없습니다. 레지스트리에 액세스하여 .dll 이름을 가져와야합니다. 현재 버전은이 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77945ec79bafc1b696c30defadbc717e1a79af37" translate="yes" xml:space="preserve">
          <source>At unpickling time, some methods like &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;__setattr__()&lt;/code&gt;&lt;/a&gt; may be called upon the instance. In case those methods rely on some internal invariant being true, the type should implement &lt;a href=&quot;#object.__getnewargs__&quot;&gt;&lt;code&gt;__getnewargs__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt;&lt;code&gt;__getnewargs_ex__()&lt;/code&gt;&lt;/a&gt; to establish such an invariant; otherwise, neither &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">피클 링 해제시 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;__setattr__()&lt;/code&gt; &lt;/a&gt; 과 같은 일부 메소드 가 인스턴스에서 호출 될 수 있습니다. 이러한 메소드가 일부 내부 불변에 의존하는 경우, 유형은 이러한 불변을 설정하기 위해 &lt;a href=&quot;#object.__getnewargs__&quot;&gt; &lt;code&gt;__getnewargs__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt; &lt;code&gt;__getnewargs_ex__()&lt;/code&gt; &lt;/a&gt; 를 구현해야합니다 . 그렇지 않으면 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 가 호출 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eb9837a1d06939ed7ea8bb756a82ada0870d4850" translate="yes" xml:space="preserve">
          <source>Attach a mock as an attribute of this one, replacing its name and parent. Calls to the attached mock will be recorded in the &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt;&lt;code&gt;method_calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; attributes of this one.</source>
          <target state="translated">이 속성을 모의 이름과 부모로 바꾸십시오. 첨부 된 mock에 대한 호출 은 this 의 &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt; &lt;code&gt;method_calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; 속성에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="b00d5eac33db6facb2e7b7a2c2ed13c7c2c1b486" translate="yes" xml:space="preserve">
          <source>Attach the watcher to an event loop.</source>
          <target state="translated">감시자를 이벤트 루프에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="8968365a321bb5b470f5dd2910dc56d308443a45" translate="yes" xml:space="preserve">
          <source>Attaches the callable &lt;em&gt;fn&lt;/em&gt; to the future. &lt;em&gt;fn&lt;/em&gt; will be called, with the future as its only argument, when the future is cancelled or finishes running.</source>
          <target state="translated">호출 가능한 &lt;em&gt;fn&lt;/em&gt; 을 미래 에 연결합니다 . 미래가 유일한 인수로서 미래가 취소되거나 실행이 완료되면 &lt;em&gt;fn&lt;/em&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2de4844092811a250638c499c463f6e1183dadac" translate="yes" xml:space="preserve">
          <source>Attaching Mocks as Attributes</source>
          <target state="translated">Mocks를 속성으로 첨부</target>
        </trans-unit>
        <trans-unit id="05d7b70d5d34350cfab01a5105b6cadb19208146" translate="yes" xml:space="preserve">
          <source>Attempt to cancel the call. If the call is currently being executed or finished running and cannot be cancelled then the method will return &lt;code&gt;False&lt;/code&gt;, otherwise the call will be cancelled and the method will return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">통화를 취소하려고합니다. 호출이 현재 실행 중이거나 실행이 끝나고 취소 할 수없는 경우 메소드는 &lt;code&gt;False&lt;/code&gt; 를 리턴 하고 그렇지 않으면 호출이 취소되고 메소드는 &lt;code&gt;True&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a94ab803dbe317473c0a7010ac4289475d2e741b" translate="yes" xml:space="preserve">
          <source>Attempt to find the loader to handle &lt;em&gt;fullname&lt;/em&gt; within &lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 내에서 &lt;em&gt;전체 이름&lt;/em&gt; 을 처리 할 로더를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="87e96da2c623edd35028d89720f05572c7ca81a6" translate="yes" xml:space="preserve">
          <source>Attempt to find the spec to handle &lt;em&gt;fullname&lt;/em&gt; within &lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 내에서 &lt;em&gt;전체 이름&lt;/em&gt; 을 처리 할 스펙을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ad8c10f0d76337b6eb760519bcf124aa2fa5b5" translate="yes" xml:space="preserve">
          <source>Attempt to read and parse an iterable of filenames, returning a list of filenames which were successfully parsed.</source>
          <target state="translated">반복 가능한 파일 이름을 읽고 구문 분석하여 성공적으로 구문 분석 된 파일 이름 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cec2196c119a8750bee0a499c586caefe53531d9" translate="yes" xml:space="preserve">
          <source>Attempt to set up a connection to the listener which is using address &lt;em&gt;address&lt;/em&gt;, returning a &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주소 &lt;em&gt;주소를&lt;/em&gt; 사용하는 리스너에 대한 연결을 설정 하여 &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; 을&lt;/a&gt; 리턴하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="bcfcda249f8236d3c4a374364c689dafac6d094d" translate="yes" xml:space="preserve">
          <source>Attempting to create a member with the same name as an already defined attribute (another member, a method, etc.) or attempting to create an attribute with the same name as a member is not allowed.</source>
          <target state="translated">이미 정의 된 속성 (다른 멤버, 메소드 등)과 동일한 이름의 멤버를 작성하거나 멤버와 동일한 이름의 속성을 작성하려는 시도는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="582daf17ef09c37849d7cd683a4bf531834c0538" translate="yes" xml:space="preserve">
          <source>Attempting to decompress data after the end of stream is reached raises an &lt;code&gt;EOFError&lt;/code&gt;. Any data found after the end of the stream is ignored and saved in the &lt;a href=&quot;#bz2.BZ2Decompressor.unused_data&quot;&gt;&lt;code&gt;unused_data&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">스트림 끝에 도달 한 후 데이터 압축 해제를 시도하면 &lt;code&gt;EOFError&lt;/code&gt; 가 발생 합니다. 스트림 끝 이후에 발견 된 모든 데이터는 무시되고 &lt;a href=&quot;#bz2.BZ2Decompressor.unused_data&quot;&gt; &lt;code&gt;unused_data&lt;/code&gt; &lt;/a&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b665a0261d8155c9a7fef41d1c6d0fafe94af38" translate="yes" xml:space="preserve">
          <source>Attempting to decompress data after the end of stream is reached raises an &lt;code&gt;EOFError&lt;/code&gt;. Any data found after the end of the stream is ignored and saved in the &lt;a href=&quot;#lzma.LZMADecompressor.unused_data&quot;&gt;&lt;code&gt;unused_data&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">스트림 끝에 도달 한 후 데이터 압축 해제를 시도하면 &lt;code&gt;EOFError&lt;/code&gt; 가 발생 합니다. 스트림 끝 이후에 발견 된 모든 데이터는 무시되고 &lt;a href=&quot;#lzma.LZMADecompressor.unused_data&quot;&gt; &lt;code&gt;unused_data&lt;/code&gt; &lt;/a&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e681818ae46e966f6a5519bb892f806874ff3de9" translate="yes" xml:space="preserve">
          <source>Attempting to hash an immutable sequence that contains unhashable values will result in &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">해싱 불가능한 값을 포함하는 불변 시퀀스를 해시하려고하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4315a818f5b166adfafe5e6b5bedd0f534c2d06f" translate="yes" xml:space="preserve">
          <source>Attempting to link in too many shared libraries</source>
          <target state="translated">너무 많은 공유 라이브러리에서 링크를 시도</target>
        </trans-unit>
        <trans-unit id="5c1642b2606e4707280aebbdbf990340b047aa2c" translate="yes" xml:space="preserve">
          <source>Attempting to mix &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data with &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; in a single function call will result in a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; being raised, while attempting to pass in non-ASCII byte values will trigger &lt;a href=&quot;exceptions#UnicodeDecodeError&quot;&gt;&lt;code&gt;UnicodeDecodeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 함수 호출에서 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 데이터를 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 바이트 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 과 혼합하려고 시도 하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생하고 ASCII가 아닌 바이트 값을 전달하면 &lt;a href=&quot;exceptions#UnicodeDecodeError&quot;&gt; &lt;code&gt;UnicodeDecodeError&lt;/code&gt; &lt;/a&gt; 가 트리거 됩니다.</target>
        </trans-unit>
        <trans-unit id="f6184f80184272af2a3f2d6c0b9b164e1af53cf1" translate="yes" xml:space="preserve">
          <source>Attempting to pass an invalid interval timer will cause an &lt;a href=&quot;#signal.ItimerError&quot;&gt;&lt;code&gt;ItimerError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유효하지 않은 간격 타이머를 전달하려고하면 &lt;a href=&quot;#signal.ItimerError&quot;&gt; &lt;code&gt;ItimerError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="6e116626d01e2573360701151c730543d251d466" translate="yes" xml:space="preserve">
          <source>Attempting to remove a file descriptor that was never registered causes a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception to be raised.</source>
          <target state="translated">등록되지 않은 파일 설명자를 제거하려고하면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3488e5797ae34b2740e12aca784ebb804aa2a11a" translate="yes" xml:space="preserve">
          <source>Attempting to remove a file descriptor that was never registered is safely ignored.</source>
          <target state="translated">등록되지 않은 파일 설명자를 제거하려고 시도해도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="413a8b0ee7fbafdd8b138da7cc28cc290a17232c" translate="yes" xml:space="preserve">
          <source>Attempts to parse a date according to the rules in &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;. however, some mailers don&amp;rsquo;t follow that format as specified, so &lt;a href=&quot;#email.utils.parsedate&quot;&gt;&lt;code&gt;parsedate()&lt;/code&gt;&lt;/a&gt; tries to guess correctly in such cases. &lt;em&gt;date&lt;/em&gt; is a string containing an &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; date, such as &lt;code&gt;&quot;Mon, 20 Nov 1995 19:12:08 -0500&quot;&lt;/code&gt;. If it succeeds in parsing the date, &lt;a href=&quot;#email.utils.parsedate&quot;&gt;&lt;code&gt;parsedate()&lt;/code&gt;&lt;/a&gt; returns a 9-tuple that can be passed directly to &lt;a href=&quot;time#time.mktime&quot;&gt;&lt;code&gt;time.mktime()&lt;/code&gt;&lt;/a&gt;; otherwise &lt;code&gt;None&lt;/code&gt; will be returned. Note that indexes 6, 7, and 8 of the result tuple are not usable.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 의 규칙에 따라 날짜를 구문 분석하려고 시도합니다 . 그러나 일부 메일러는 지정된 형식을 따르지 않으므로 &lt;a href=&quot;#email.utils.parsedate&quot;&gt; &lt;code&gt;parsedate()&lt;/code&gt; &lt;/a&gt; 는 이러한 경우 올바르게 추측하려고합니다. &lt;em&gt;date&lt;/em&gt; 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 날짜를 포함하는 문자열입니다 ( 예 : &lt;code&gt;&quot;Mon, 20 Nov 1995 19:12:08 -0500&quot;&lt;/code&gt; . 이 날짜를 구문 분석에 성공하면, &lt;a href=&quot;#email.utils.parsedate&quot;&gt; &lt;code&gt;parsedate()&lt;/code&gt; &lt;/a&gt; 에 직접 전달 될 수있는 9 튜플 반환 &lt;a href=&quot;time#time.mktime&quot;&gt; &lt;code&gt;time.mktime()&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 결과 튜플의 인덱스 6, 7, 8은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f8f0a192956c468d1f05450c3d0f99e1ed3eb87" translate="yes" xml:space="preserve">
          <source>Attempts to pickle unpicklable objects will raise the &lt;a href=&quot;#pickle.PicklingError&quot;&gt;&lt;code&gt;PicklingError&lt;/code&gt;&lt;/a&gt; exception; when this happens, an unspecified number of bytes may have already been written to the underlying file. Trying to pickle a highly recursive data structure may exceed the maximum recursion depth, a &lt;a href=&quot;exceptions#RecursionError&quot;&gt;&lt;code&gt;RecursionError&lt;/code&gt;&lt;/a&gt; will be raised in this case. You can carefully raise this limit with &lt;a href=&quot;sys#sys.setrecursionlimit&quot;&gt;&lt;code&gt;sys.setrecursionlimit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택할 수없는 객체를 피클하려고하면 &lt;a href=&quot;#pickle.PicklingError&quot;&gt; &lt;code&gt;PicklingError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 이 경우, 지정되지 않은 바이트 수가 이미 기본 파일에 기록되었을 수 있습니다. 높은 재귀 데이터 구조를 피클하려고하면 최대 재귀 깊이를 초과 할 수 &lt;a href=&quot;exceptions#RecursionError&quot;&gt; &lt;code&gt;RecursionError&lt;/code&gt; &lt;/a&gt; 경우 RecursionError 가 발생합니다. &lt;a href=&quot;sys#sys.setrecursionlimit&quot;&gt; &lt;code&gt;sys.setrecursionlimit()&lt;/code&gt; &lt;/a&gt; 사용 하여이 제한을 신중하게 올릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b271428a65f77bc781cd47b969a5bc6e419af63a" translate="yes" xml:space="preserve">
          <source>Attention: &lt;em&gt;speed&lt;/em&gt; = 0 means that &lt;em&gt;no&lt;/em&gt; animation takes place. forward/back makes turtle jump and likewise left/right make the turtle turn instantly.</source>
          <target state="translated">주의 : &lt;em&gt;speed&lt;/em&gt; = 0은 애니메이션이 발생 &lt;em&gt;하지 않음을&lt;/em&gt; 의미합니다 . 앞으로 / 뒤로 거북이가 점프하고 왼쪽 / 오른쪽으로 거북이가 즉시 회전합니다.</target>
        </trans-unit>
        <trans-unit id="4704ccf5d9826a4b8c3ff2f628be8f9ea11d5c58" translate="yes" xml:space="preserve">
          <source>Attr Objects</source>
          <target state="translated">Attr 객체</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="fd11efd3b2bb215beb5fe4deac5b15c31b49871e" translate="yes" xml:space="preserve">
          <source>Attribute name</source>
          <target state="translated">속성 이름</target>
        </trans-unit>
        <trans-unit id="44b0ecb440f33452e3b57f0fc1355b5b83b53b65" translate="yes" xml:space="preserve">
          <source>Attribute value nodes on element nodes.</source>
          <target state="translated">요소 노드의 속성 값 노드</target>
        </trans-unit>
        <trans-unit id="e30390c6b25519953f15954ce4132cba67fdd587" translate="yes" xml:space="preserve">
          <source>AttributeError</source>
          <target state="translated">AttributeError</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="79c3aeb6146abe2231f5b89a475ab249029d088e" translate="yes" xml:space="preserve">
          <source>Attributes and methods for customizing the WSGI environment:</source>
          <target state="translated">WSGI 환경을 사용자 정의하기위한 속성 및 메소드 :</target>
        </trans-unit>
        <trans-unit id="e9b663bf28955d0808f846d124c86b6d0183b33f" translate="yes" xml:space="preserve">
          <source>Attributes and methods on a &lt;code&gt;os.DirEntry&lt;/code&gt; instance are as follows:</source>
          <target state="translated">&lt;code&gt;os.DirEntry&lt;/code&gt; 인스턴스의 속성 및 메소드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73692911ebd863a9a87e4961881d432666982309" translate="yes" xml:space="preserve">
          <source>Attributes are created on demand when you access them by name. Accessing the same attribute will always return the same object. The objects returned have a sensible repr so that test failure messages are readable.</source>
          <target state="translated">이름으로 속성에 액세스하면 요청시 속성이 작성됩니다. 동일한 속성에 액세스하면 항상 동일한 객체가 반환됩니다. 반환 된 객체는 테스트 실패 메시지를 읽을 수 있도록 적절한 repr을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="101df875704c7152821017f27b87995406582c71" translate="yes" xml:space="preserve">
          <source>Attributes plus return values and side effects can be set on child mocks using standard dot notation and unpacking a dictionary in the method call:</source>
          <target state="translated">표준 점 표기법을 사용하고 메소드 호출에서 사전 포장 풀기를 사용하여 자식 모의에 속성과 반환 값 및 부작용을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c886066a950b07e9817b943cf62493312e7bdd7" translate="yes" xml:space="preserve">
          <source>Attributes set when an exception is catched:</source>
          <target state="translated">예외가 발견 될 때 설정되는 속성 :</target>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="5c7c68f4b64e821cb3bb3f3f760a898c036a3f74" translate="yes" xml:space="preserve">
          <source>Audio Device Objects</source>
          <target state="translated">오디오 장치 객체</target>
        </trans-unit>
        <trans-unit id="16176810d7decb98eb62c4c87a10dd432035c88f" translate="yes" xml:space="preserve">
          <source>Audio device objects also support several read-only attributes:</source>
          <target state="translated">오디오 장치 개체는 여러 가지 읽기 전용 특성도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6e947bb134465c1c6a6e453065d0c48e8ca8c64a" translate="yes" xml:space="preserve">
          <source>Audio files have a number of parameters that describe the audio data. The sampling rate or frame rate is the number of times per second the sound is sampled. The number of channels indicate if the audio is mono, stereo, or quadro. Each frame consists of one sample per channel. The sample size is the size in bytes of each sample. Thus a frame consists of &lt;code&gt;nchannels * samplesize&lt;/code&gt; bytes, and a second&amp;rsquo;s worth of audio consists of &lt;code&gt;nchannels * samplesize * framerate&lt;/code&gt; bytes.</source>
          <target state="translated">오디오 파일에는 오디오 데이터를 설명하는 여러 매개 변수가 있습니다. 샘플링 속도 또는 프레임 속도는 사운드가 샘플링되는 초당 횟수입니다. 채널 수는 오디오가 모노, 스테레오 또는 쿼드로인지를 나타냅니다. 각 프레임은 채널당 하나의 샘플로 구성됩니다. 샘플 크기는 각 샘플의 크기 (바이트)입니다. 따라서 프레임은 &lt;code&gt;nchannels * samplesize&lt;/code&gt; 바이트)로 구성되며 1 초 분량의 오디오는 &lt;code&gt;nchannels * samplesize * framerate&lt;/code&gt; 바이트) 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff3e0d680200101f6f9f4009685f904d7888a4b5" translate="yes" xml:space="preserve">
          <source>Audit event</source>
          <target state="translated">감사 이벤트</target>
        </trans-unit>
        <trans-unit id="14c2893dc5aedb9cac7688ec4357a58cad8f48e8" translate="yes" xml:space="preserve">
          <source>Audit events table</source>
          <target state="translated">감사 이벤트 테이블</target>
        </trans-unit>
        <trans-unit id="6922a9610304991071bd728c3a287a51b532d68c" translate="yes" xml:space="preserve">
          <source>Authenticate command &amp;mdash; requires response processing.</source>
          <target state="translated">인증 명령-응답 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8ccb8a1076f255643cd045f9684ad5f445deae31" translate="yes" xml:space="preserve">
          <source>Authentication is supported, using the regular SMTP mechanism. When using a Unix socket, LMTP generally don&amp;rsquo;t support or require any authentication, but your mileage might vary.</source>
          <target state="translated">일반 SMTP 메커니즘을 사용하여 인증이 지원됩니다. Unix 소켓을 사용할 때 LMTP는 일반적으로 인증을 지원하거나 요구하지 않지만 마일리지는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34762561a060645d5e694a00f5c15f22688272cc" translate="yes" xml:space="preserve">
          <source>Authentication keys</source>
          <target state="translated">인증 키</target>
        </trans-unit>
        <trans-unit id="b6d03350228ac0bf7f8b015328effcfd7281fdb3" translate="yes" xml:space="preserve">
          <source>Auto-negotiate the highest protocol version like &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;, but only support client-side &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; connections. The protocol enables &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 같은 최고 프로토콜 버전을 자동 협상 하지만 클라이언트 측 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 연결 만 지원 합니다. 이 프로토콜은 기본적으로 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt; 을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="b1b09a77c9093ba1c2df03bc5d6beeb4959883e7" translate="yes" xml:space="preserve">
          <source>Auto-negotiate the highest protocol version like &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;, but only support server-side &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; connections.</source>
          <target state="translated">&lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 같은 최고 프로토콜 버전을 자동 협상 하지만 서버 측 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 연결 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f47c5ab52bbe1a984f857a4d21dd996e64a02f48" translate="yes" xml:space="preserve">
          <source>Auto-open Stack Viewer</source>
          <target state="translated">자동 열기 스택 뷰어</target>
        </trans-unit>
        <trans-unit id="197be9c04cb2e21653d60342178244091efa77b8" translate="yes" xml:space="preserve">
          <source>Auto-speccing solves this problem. You can either pass &lt;code&gt;autospec=True&lt;/code&gt; to &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt;&lt;code&gt;patch.object()&lt;/code&gt;&lt;/a&gt; or use the &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt;&lt;code&gt;create_autospec()&lt;/code&gt;&lt;/a&gt; function to create a mock with a spec. If you use the &lt;code&gt;autospec=True&lt;/code&gt; argument to &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; then the object that is being replaced will be used as the spec object. Because the speccing is done &amp;ldquo;lazily&amp;rdquo; (the spec is created as attributes on the mock are accessed) you can use it with very complex or deeply nested objects (like modules that import modules that import modules) without a big performance hit.</source>
          <target state="translated">자동 지정은이 문제를 해결합니다. 당신도 전달할 수 있습니다 &lt;code&gt;autospec=True&lt;/code&gt; 에 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt; &lt;code&gt;patch.object()&lt;/code&gt; &lt;/a&gt; 하거나 사용 &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt; &lt;code&gt;create_autospec()&lt;/code&gt; &lt;/a&gt; 스펙과 실물 크기의 모형을 만드는 기능. &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;autospec=True&lt;/code&gt; 인수를 사용하면 교체중인 객체가 사양 객체로 사용됩니다. 지정이 &quot;게으르게&quot;수행되므로 (모형의 속성에 액세스 할 때 지정됨) 성능이 크게 저하되지 않고 매우 복잡하거나 깊이 중첩 된 개체 (예 : 모듈을 가져 오는 모듈을 가져 오는 모듈)와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c61da791d8a006bda906f9ae1ff768b72eb7dc76" translate="yes" xml:space="preserve">
          <source>Automatic indentation</source>
          <target state="translated">자동 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="6403e37e9140843598c5440d1e8bc72de007ae50" translate="yes" xml:space="preserve">
          <source>Automatically determine how many times to call &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 호출 횟수를 자동으로 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="4d5117dbfc630c5ff47b8c4726c276df15d1bd1e" translate="yes" xml:space="preserve">
          <source>Autospeccing</source>
          <target state="translated">Autospeccing</target>
        </trans-unit>
        <trans-unit id="aae79d454597517030f9ce7ec36250067a2b9f35" translate="yes" xml:space="preserve">
          <source>Autospeccing is based on the existing &lt;code&gt;spec&lt;/code&gt; feature of mock. It limits the api of mocks to the api of an original object (the spec), but it is recursive (implemented lazily) so that attributes of mocks only have the same api as the attributes of the spec. In addition mocked functions / methods have the same call signature as the original so they raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if they are called incorrectly.</source>
          <target state="translated">자동 &lt;code&gt;spec&lt;/code&gt; 은 기존 모의 사양 기능을 기반으로합니다 . 모의 API를 원본 객체 (사양)의 API로 제한하지만 재귀 (게으르게 구현 됨)하여 모의 속성은 사양의 속성과 동일한 api를 갖습니다. 또한 조롱 된 함수 / 메서드는 원본과 동일한 호출 서명을 가지므로 잘못 호출되면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6e04a76e0651512ad3b1c9b3855e894e52bacec7" translate="yes" xml:space="preserve">
          <source>Auxiliary method for getting a filename in a canonical form, that is, as a case-normalized (on case-insensitive filesystems) absolute path, stripped of surrounding angle brackets.</source>
          <target state="translated">파일 이름을 정식 형식, 즉 대소 문자를 구분하지 않는 파일 시스템에서 절대 경로로 사용하여 주변 꺾쇠 괄호를 제거하는 보조 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d15ede98b9b5686d60eb679c69ff709aea96450e" translate="yes" xml:space="preserve">
          <source>Availability: SQLite 3.6.11 or higher</source>
          <target state="translated">가용성 : SQLite 3.6.11 이상</target>
        </trans-unit>
        <trans-unit id="0648a25bb67f0b4d3be9ad2e32d5343d5884c667" translate="yes" xml:space="preserve">
          <source>Availability: Systems with the &lt;code&gt;madvise()&lt;/code&gt; system call.</source>
          <target state="translated">가용성 : &lt;code&gt;madvise()&lt;/code&gt; 시스템 호출이있는 시스템.</target>
        </trans-unit>
        <trans-unit id="fcc09c1546fd2002ad5bda6442ec6858c4d44e94" translate="yes" xml:space="preserve">
          <source>Availability: Systems with the madvise() system call.</source>
          <target state="translated">가용성 : madvise () 시스템 호출이있는 시스템.</target>
        </trans-unit>
        <trans-unit id="c9fcd2b619f3ed9f21f2ae1dc44a712e8e0c1b0c" translate="yes" xml:space="preserve">
          <source>Availability: Tk 8.6</source>
          <target state="translated">가용성 : Tk 8.6</target>
        </trans-unit>
        <trans-unit id="fb3bce3637a32f6ce35b6791b2442a57507592a0" translate="yes" xml:space="preserve">
          <source>Availability: Tk 8.6.</source>
          <target state="translated">가용성 : Tk 8.6.</target>
        </trans-unit>
        <trans-unit id="dad7b53c45f37c3a8f080b151e9238c41b4b613e" translate="yes" xml:space="preserve">
          <source>Availability: if the ncurses library is used.</source>
          <target state="translated">가용성 : ncurses 라이브러리가 사용 된 경우.</target>
        </trans-unit>
        <trans-unit id="90ede860852b2d88bce6f917c8c626dd1ebd0863" translate="yes" xml:space="preserve">
          <source>Available Context Managers</source>
          <target state="translated">사용 가능한 컨텍스트 관리자</target>
        </trans-unit>
        <trans-unit id="e8fb788cf6307a8cd78a358b3227f7e4460f4896" translate="yes" xml:space="preserve">
          <source>Available Functions</source>
          <target state="translated">사용 가능한 기능</target>
        </trans-unit>
        <trans-unit id="886aad58c06c842c7cf3407ff5f794bccc525568" translate="yes" xml:space="preserve">
          <source>Available Types</source>
          <target state="translated">사용 가능한 유형</target>
        </trans-unit>
        <trans-unit id="c1743168e4383b0ceeb14b5166304e0f0f3be9ec" translate="yes" xml:space="preserve">
          <source>Available for read</source>
          <target state="translated">읽기 가능</target>
        </trans-unit>
        <trans-unit id="247b0d4f98d15c3f067f1f036f9a2288ba9508e3" translate="yes" xml:space="preserve">
          <source>Available for write</source>
          <target state="translated">쓰기 가능</target>
        </trans-unit>
        <trans-unit id="d5cbfc01dab58f33d6399bdf92d34e12742cc326" translate="yes" xml:space="preserve">
          <source>Available on Unix and Windows. The default on Windows and macOS.</source>
          <target state="translated">Unix 및 Windows에서 사용 가능합니다. Windows 및 macOS의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5bd9dd81c594faef45bb68cd8e2f6b57306afbb3" translate="yes" xml:space="preserve">
          <source>Available on Unix only. The default on Unix.</source>
          <target state="translated">유닉스에서만 사용 가능합니다. 유닉스의 기본값.</target>
        </trans-unit>
        <trans-unit id="8b289188b8156e0915761af80089ec725b1d7c5e" translate="yes" xml:space="preserve">
          <source>Available on Unix platforms which support passing file descriptors over Unix pipes.</source>
          <target state="translated">Unix 파이프를 통한 파일 디스크립터 전달을 지원하는 Unix 플랫폼에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f6c3e2a80c9a11385439b399a1bbc1528532103f" translate="yes" xml:space="preserve">
          <source>Averages and measures of central location</source>
          <target state="translated">중심 위치의 평균 및 측정</target>
        </trans-unit>
        <trans-unit id="63dece88439aa338ed47cd03f066290634af6ebb" translate="yes" xml:space="preserve">
          <source>Avoid shared state</source>
          <target state="translated">공유 상태를 피하십시오</target>
        </trans-unit>
        <trans-unit id="49cd5a5cd25205ca8554e1312e26ecf321d1c177" translate="yes" xml:space="preserve">
          <source>Avoid terminating processes</source>
          <target state="translated">프로세스 종료 방지</target>
        </trans-unit>
        <trans-unit id="9dfd80c478c083df370ff07aeddda8591a1285bc" translate="yes" xml:space="preserve">
          <source>Awaitables</source>
          <target state="translated">Awaitables</target>
        </trans-unit>
        <trans-unit id="da49b3337696e8a2b4c64d3033aa0a3a5fbc2d3f" translate="yes" xml:space="preserve">
          <source>Awaiting on a coroutine. The following snippet of code will print &amp;ldquo;hello&amp;rdquo; after waiting for 1 second, and then print &amp;ldquo;world&amp;rdquo; after waiting for &lt;em&gt;another&lt;/em&gt; 2 seconds:</source>
          <target state="translated">코 루틴을 기다리고 있습니다. 다음 코드 스 니펫은 1 초 동안 기다린 후 &quot;hello&quot;를 인쇄하고 2 초 &lt;em&gt;더&lt;/em&gt; 기다린 후 &quot;world&quot;를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d09738049226150f62d909b1178a56d0dfe67bbd" translate="yes" xml:space="preserve">
          <source>Aware and Naive Objects</source>
          <target state="translated">인식하고 순진한 객체</target>
        </trans-unit>
        <trans-unit id="708e5124ff648e8126313adce762960fdf915375" translate="yes" xml:space="preserve">
          <source>BLAKE2</source>
          <target state="translated">BLAKE2</target>
        </trans-unit>
        <trans-unit id="9bc500c21c3285144fc28bd0e912a7783b167e8c" translate="yes" xml:space="preserve">
          <source>BLAKE2 can be personalized by passing bytes to the &lt;em&gt;person&lt;/em&gt; argument:</source>
          <target state="translated">BLAKE2는 &lt;em&gt;person&lt;/em&gt; 인수에 바이트를 전달하여 개인화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c571b2356698c401ae7c55f2f7327fe7d7dcc208" translate="yes" xml:space="preserve">
          <source>BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to 32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without changing the size of output, we can tell BLAKE2b to produce 20-byte digests:</source>
          <target state="translated">BLAKE2는 BLAKE2b의 경우 최대 64 바이트, BLAKE2의 경우 최대 32 바이트의 다이제스트 크기를 구성 할 수 있습니다. 예를 들어, 출력 크기를 변경하지 않고 SHA-1을 BLAKE2b로 바꾸려면 BLAKE2b에 20 바이트 다이제스트를 생성하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eef9c659e49da103106b41ae1c8a79320baba6dc" translate="yes" xml:space="preserve">
          <source>BLAKE2 specification defines constant lengths for salt and personalization parameters, however, for convenience, this implementation accepts byte strings of any size up to the specified length. If the length of the parameter is less than specified, it is padded with zeros, thus, for example, &lt;code&gt;b'salt'&lt;/code&gt; and &lt;code&gt;b'salt\x00'&lt;/code&gt; is the same value. (This is not the case for &lt;em&gt;key&lt;/em&gt;.)</source>
          <target state="translated">BLAKE2 스펙은 솔트 및 개인화 매개 변수에 대해 일정한 길이를 정의하지만 편의상이 구현에서는 지정된 길이까지 모든 크기의 바이트 문자열을 허용합니다. 매개 변수의 길이가 지정된 길이보다 작 으면 0으로 채워 지므로 예를 들어 &lt;code&gt;b'salt'&lt;/code&gt; 및 &lt;code&gt;b'salt\x00'&lt;/code&gt; 은 동일한 값입니다. (이것은의 경우에는 해당되지 않습니다 &lt;em&gt;키&lt;/em&gt; .)</target>
        </trans-unit>
        <trans-unit id="cd2ef75abf83ba49f622d80373a85346c04a5b37" translate="yes" xml:space="preserve">
          <source>BLAKE2 supports &lt;strong&gt;keyed mode&lt;/strong&gt; (a faster and simpler replacement for &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;HMAC&lt;/a&gt;), &lt;strong&gt;salted hashing&lt;/strong&gt;, &lt;strong&gt;personalization&lt;/strong&gt;, and &lt;strong&gt;tree hashing&lt;/strong&gt;.</source>
          <target state="translated">BLAKE2는 &lt;strong&gt;키 모드&lt;/strong&gt; ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;HMAC를&lt;/a&gt; 위한 더 빠르고 간단한 대체 ), &lt;strong&gt;솔트 해싱&lt;/strong&gt; , &lt;strong&gt;개인화&lt;/strong&gt; 및 &lt;strong&gt;트리 해싱을 지원&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cc708fbeac5b1cf0a46d24793514cf456186e0b0" translate="yes" xml:space="preserve">
          <source>BLAKE2b</source>
          <target state="translated">BLAKE2b</target>
        </trans-unit>
        <trans-unit id="b5b58babc24a9c4ee1a0847d9544ddb7d16f7c8f" translate="yes" xml:space="preserve">
          <source>BLAKE2s</source>
          <target state="translated">BLAKE2s</target>
        </trans-unit>
        <trans-unit id="e0e381dd5fc1fcdbadce37e6a061ba49795a568d" translate="yes" xml:space="preserve">
          <source>BMP files</source>
          <target state="translated">BMP 파일</target>
        </trans-unit>
        <trans-unit id="a42a05330f8bf46c41ac1665544187ff109c2243" translate="yes" xml:space="preserve">
          <source>Babyl is a single-file mailbox format used by the Rmail mail user agent included with Emacs. The beginning of a message is indicated by a line containing the two characters Control-Underscore (&lt;code&gt;'\037'&lt;/code&gt;) and Control-L (&lt;code&gt;'\014'&lt;/code&gt;). The end of a message is indicated by the start of the next message or, in the case of the last message, a line containing a Control-Underscore (&lt;code&gt;'\037'&lt;/code&gt;) character.</source>
          <target state="translated">Babyl은 Emacs에 포함 된 Rmail 메일 사용자 에이전트가 사용하는 단일 파일 사서함 형식입니다. 메시지의 시작은 Control-Underscore ( &lt;code&gt;'\037'&lt;/code&gt; )와 Control-L ( &lt;code&gt;'\014'&lt;/code&gt; ) 두 문자를 포함하는 줄로 표시됩니다 . 메시지의 끝은 다음 메시지의 시작 또는 마지막 메시지의 경우 Control-Underscore ( &lt;code&gt;'\037'&lt;/code&gt; ) 문자를 포함하는 줄로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="51e1b906cbdb74be5ef8d171c417a6f96c704e55" translate="yes" xml:space="preserve">
          <source>Back tab</source>
          <target state="translated">뒷면 탭</target>
        </trans-unit>
        <trans-unit id="fcf84c7c42731b104d6bb1ee61a75ed5dec2fca1" translate="yes" xml:space="preserve">
          <source>Back up your cookies before saving if you have cookies whose loss / corruption would be inconvenient (there are some subtleties which may lead to slight changes in the file over a load / save round-trip).</source>
          <target state="translated">손실 / 손상이 불편한 쿠키가있는 경우 저장하기 전에 쿠키를 백업하십시오 (로드 / 저장 왕복으로 파일이 약간 변경 될 수있는 미묘한 부분이 있습니다).</target>
        </trans-unit>
        <trans-unit id="f7cabb8d741c7dccd3373c3e1b45a4517c4bc9a5" translate="yes" xml:space="preserve">
          <source>Backend function used by &lt;a href=&quot;#curses.resizeterm&quot;&gt;&lt;code&gt;resizeterm()&lt;/code&gt;&lt;/a&gt;, performing most of the work; when resizing the windows, &lt;a href=&quot;#curses.resize_term&quot;&gt;&lt;code&gt;resize_term()&lt;/code&gt;&lt;/a&gt; blank-fills the areas that are extended. The calling application should fill in these areas with appropriate data. The &lt;code&gt;resize_term()&lt;/code&gt; function attempts to resize all windows. However, due to the calling convention of pads, it is not possible to resize these without additional interaction with the application.</source>
          <target state="translated">대부분의 작업을 수행하는 &lt;a href=&quot;#curses.resizeterm&quot;&gt; &lt;code&gt;resizeterm()&lt;/code&gt; &lt;/a&gt; 에서 사용하는 백엔드 함수 . 창 크기를 조정할 때 &lt;a href=&quot;#curses.resize_term&quot;&gt; &lt;code&gt;resize_term()&lt;/code&gt; &lt;/a&gt; 은 확장 된 영역을 공백으로 채 웁니다. 발신 애플리케이션은 이러한 영역을 적절한 데이터로 채워야합니다. &lt;code&gt;resize_term()&lt;/code&gt; 함수를 시도 모든 창 크기를 조정합니다. 그러나 패드의 호출 규칙으로 인해 응용 프로그램과의 추가 상호 작용없이 크기를 조정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad8d0fed9a547cc64ffb221201642666f0011ab4" translate="yes" xml:space="preserve">
          <source>Background, details, hints, tips and caveats</source>
          <target state="translated">배경, 세부 사항, 힌트, 팁 및 경고</target>
        </trans-unit>
        <trans-unit id="d761e5a62561f09ed0d44ad1cb46328e1f217a6f" translate="yes" xml:space="preserve">
          <source>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</source>
          <target state="translated">백 슬래시는 큰 따옴표가 바로 앞에 오지 않는 한 문자 그대로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="a3b4e1ecc274bf718cbbd8a1a3fe637f6e1d74f9" translate="yes" xml:space="preserve">
          <source>Backspace (unreliable)</source>
          <target state="translated">백 스페이스 (신뢰할 수 없음)</target>
        </trans-unit>
        <trans-unit id="e55f2cbe5dc4e91bd91593c8be3a8399315bbfdf" translate="yes" xml:space="preserve">
          <source>Backward-compatible usage:</source>
          <target state="translated">이전 버전과 호환되는 사용법 :</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="translated">잘못된 주소</target>
        </trans-unit>
        <trans-unit id="a9ac5297b2f804cdafa5d88f5e271e340ba5cf37" translate="yes" xml:space="preserve">
          <source>Bad file number</source>
          <target state="translated">잘못된 파일 번호</target>
        </trans-unit>
        <trans-unit id="d42cb962824573639b58c8ac6238174cbbe0902e" translate="yes" xml:space="preserve">
          <source>Bad font file format</source>
          <target state="translated">잘못된 글꼴 파일 형식</target>
        </trans-unit>
        <trans-unit id="09b7225a7007de0840d3002393babbaf7c304ea8" translate="yes" xml:space="preserve">
          <source>Baltic languages</source>
          <target state="translated">발트 어</target>
        </trans-unit>
        <trans-unit id="5e5a05a8b84deb1f27d7d9a68b519e2daa6a3749" translate="yes" xml:space="preserve">
          <source>Barrier Objects</source>
          <target state="translated">배리어 객체</target>
        </trans-unit>
        <trans-unit id="c5376071164581eb584cba9b3620cf0285ee49f3" translate="yes" xml:space="preserve">
          <source>Barry Warsaw</source>
          <target state="translated">배리 바르샤바</target>
        </trans-unit>
        <trans-unit id="cbfa89884cf762b2c8452214a9cb7c8b56848102" translate="yes" xml:space="preserve">
          <source>Base Protocol</source>
          <target state="translated">기본 프로토콜</target>
        </trans-unit>
        <trans-unit id="e7847ef64ed125924cd719af4769f2b49be1f954" translate="yes" xml:space="preserve">
          <source>Base Protocols</source>
          <target state="translated">기본 프로토콜</target>
        </trans-unit>
        <trans-unit id="b1fa70ba520aae580db170cd80267cedd66c66af" translate="yes" xml:space="preserve">
          <source>Base Transport</source>
          <target state="translated">기본 운송</target>
        </trans-unit>
        <trans-unit id="0f7c08675f792982cba4bf468bb32f3974d128d6" translate="yes" xml:space="preserve">
          <source>Base category for warnings about deprecated features when those warnings are intended for end users of applications that are written in Python.</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 범주는 해당 경고가 Python으로 작성된 응용 프로그램의 최종 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ded4acb00e3e9a0e2c6d819d2be38745cb197828" translate="yes" xml:space="preserve">
          <source>Base category for warnings about deprecated features when those warnings are intended for other Python developers (ignored by default, unless triggered by code in &lt;code&gt;__main__&lt;/code&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 범주는 다른 Python 개발자를위한 경고입니다 ( &lt;code&gt;__main__&lt;/code&gt; 의 코드로 트리거되지 않는 한 기본적으로 무시 됨 ).</target>
        </trans-unit>
        <trans-unit id="aecd2a13287ac24c073616d7be9ca1bac4b820e3" translate="yes" xml:space="preserve">
          <source>Base category for warnings about dubious runtime features.</source>
          <target state="translated">모호한 런타임 기능에 대한 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="adbf72d780c57a442a1d40e971f0bafb4ba000b7" translate="yes" xml:space="preserve">
          <source>Base category for warnings about dubious syntactic features.</source>
          <target state="translated">모호한 구문 기능에 대한 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="b961e19180b568120a243fe8a965f885400f3963" translate="yes" xml:space="preserve">
          <source>Base category for warnings about features that will be deprecated in the future (ignored by default).</source>
          <target state="translated">향후 더 이상 사용되지 않을 기능에 대한 경고의 기본 범주입니다 (기본적으로 무시 됨).</target>
        </trans-unit>
        <trans-unit id="271b2d511f8d7cb0d37d60a7165a2a6be096fb2d" translate="yes" xml:space="preserve">
          <source>Base category for warnings related to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 관련 경고의 기본 범주입니다 .</target>
        </trans-unit>
        <trans-unit id="e56c87eafe934bdffdcf80bbda3a3f1bafd3951a" translate="yes" xml:space="preserve">
          <source>Base category for warnings related to Unicode.</source>
          <target state="translated">유니 코드와 관련된 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="8aca1ccdde79b14ca072dd8196fe1a8eaa20e816" translate="yes" xml:space="preserve">
          <source>Base category for warnings related to resource usage.</source>
          <target state="translated">자원 사용과 관련된 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="9db12d86e6ccca93eb8b1b63e07ce33c90af51f7" translate="yes" xml:space="preserve">
          <source>Base category for warnings triggered during the process of importing a module (ignored by default).</source>
          <target state="translated">모듈을 가져 오는 과정에서 트리거되는 경고의 기본 범주 (기본적으로 무시 됨).</target>
        </trans-unit>
        <trans-unit id="62c7f7b7e6449dee51da32f88ce059c9f0a6e133" translate="yes" xml:space="preserve">
          <source>Base class for C callable foreign functions.</source>
          <target state="translated">C 호출 가능 외부 함수의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="93b278fdd49d1caec7588ea1619ab8693a3d6aea" translate="yes" xml:space="preserve">
          <source>Base class for all &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">모든 &lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 예외의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="83a2ff960e585bade07c251fc6907e1766bfdcea" translate="yes" xml:space="preserve">
          <source>Base class for all exceptions that include an SMTP error code. These exceptions are generated in some instances when the SMTP server returns an error code. The error code is stored in the &lt;code&gt;smtp_code&lt;/code&gt; attribute of the error, and the &lt;code&gt;smtp_error&lt;/code&gt; attribute is set to the error message.</source>
          <target state="translated">SMTP 오류 코드가 포함 된 모든 예외의 기본 클래스입니다. 이러한 예외는 SMTP 서버가 오류 코드를 반환 할 때 일부 경우에 생성됩니다. 오류 코드는 오류의 &lt;code&gt;smtp_code&lt;/code&gt; 속성에 저장되며 &lt;code&gt;smtp_error&lt;/code&gt; 속성은 오류 메시지로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc4d1cfe65641ccd75006d6cb0c5273ca53b06fc" translate="yes" xml:space="preserve">
          <source>Base class for all other &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">다른 모든 &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 예외의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="2e79acf9343097cfca004b026b1e289b6e81d9e7" translate="yes" xml:space="preserve">
          <source>Base class for all other exceptions from this module.</source>
          <target state="translated">이 모듈의 다른 모든 예외에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0094874eb16d8f35c44e0f11faca44e7bc129804" translate="yes" xml:space="preserve">
          <source>Base class for all transports. Contains methods that all asyncio transports share.</source>
          <target state="translated">모든 운송의 기본 클래스. 모든 비동기 전송이 공유하는 메소드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bc8dc0e5d7f463652bc46330f069074014733a53" translate="yes" xml:space="preserve">
          <source>Base class for binary streams that support some kind of buffering. It inherits &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. There is no public constructor.</source>
          <target state="translated">어떤 종류의 버퍼링을 지원하는 이진 스트림의 기본 클래스입니다. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 를&lt;/a&gt; 상속 합니다 . 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="111505a2e2f1c5d720f4dbb20b18464824cc26d2" translate="yes" xml:space="preserve">
          <source>Base class for content managers. Provides the standard registry mechanisms to register converters between MIME content and other representations, as well as the &lt;code&gt;get_content&lt;/code&gt; and &lt;code&gt;set_content&lt;/code&gt; dispatch methods.</source>
          <target state="translated">컨텐츠 관리자를위한 기본 클래스. &lt;code&gt;get_content&lt;/code&gt; 및 &lt;code&gt;set_content&lt;/code&gt; 디스패치 메소드 뿐만 아니라 MIME 컨텐츠와 다른 표시간에 변환기를 등록하기위한 표준 레지스트리 메커니즘을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="77e0fa5fb9d9cb92c49e07f64d986e277b736562" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants that are also subclasses of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; 의&lt;/a&gt; 서브 클래스이기도 한 열거 상수를 작성하기위한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="bc4710022b4a59f7309e498f9784b89980698d53" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants that can be combined using the bitwise operations without losing their &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; membership.</source>
          <target state="translated">&lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 멤버십 을 잃지 않고 비트 단위 연산을 사용하여 결합 할 수있는 열거 상수를 작성하기위한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="8067a9d2bd64f504a0ed0bf642eba1d2667cdb0d" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants that can be combined using the bitwise operators without losing their &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; membership. &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; members are also subclasses of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버십 을 잃지 않고 비트 연산자를 사용하여 결합 할 수있는 열거 상수를 작성하기위한 기본 클래스입니다 . &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버도 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; 의&lt;/a&gt; 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="49651f12dd69e9fc5b9eb9a491dae1396c8f4820" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants. See section &lt;a href=&quot;#functional-api&quot;&gt;Functional API&lt;/a&gt; for an alternate construction syntax.</source>
          <target state="translated">열거 된 상수를 만들기위한 기본 클래스입니다. 대체 구문에 대해서는 &lt;a href=&quot;#functional-api&quot;&gt;기능적 API&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8496250f8d316f4c2fb71bb6afeaf2db8d55ba5" translate="yes" xml:space="preserve">
          <source>Base class for exceptions raised when problems occur performing string interpolation.</source>
          <target state="translated">문자열 보간 수행시 문제가 발생할 때 발생하는 예외의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7a8cc99e6dd0fa75e5d9d18d1e2f0b6d159ef64b" translate="yes" xml:space="preserve">
          <source>Base class for opening and reading URLs. Unless you need to support opening objects using schemes other than &lt;code&gt;http:&lt;/code&gt;, &lt;code&gt;ftp:&lt;/code&gt;, or &lt;code&gt;file:&lt;/code&gt;, you probably want to use &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">URL을 열고 읽는 기본 클래스입니다. &lt;code&gt;http:&lt;/code&gt; , &lt;code&gt;ftp:&lt;/code&gt; 또는 &lt;code&gt;file:&lt;/code&gt; 이외의 스키마를 사용하여 객체 열기를 지원하지 않는 한 &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 를 사용하고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="aa942d873b8cc2045025e1cba883f43a926d1060" translate="yes" xml:space="preserve">
          <source>Base class for other signals and a subclass of &lt;a href=&quot;exceptions#ArithmeticError&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자료의 다른 신호 클래스의 서브 클래스 &lt;a href=&quot;exceptions#ArithmeticError&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d78011d81daf58732134a6e10362b07bb6ae789f" translate="yes" xml:space="preserve">
          <source>Base class for policy objects.</source>
          <target state="translated">정책 개체의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="37baa2206d896a594f1f8aa5a3db8477752589d1" translate="yes" xml:space="preserve">
          <source>Base class for protocol classes. Protocol classes are defined like this:</source>
          <target state="translated">프로토콜 클래스의 기본 클래스 프로토콜 클래스는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6a52a47b306d18d17af6700a5e02d334eea68489" translate="yes" xml:space="preserve">
          <source>Base class for raw binary I/O. It inherits &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. There is no public constructor.</source>
          <target state="translated">원시 이진 I / O의 기본 클래스입니다. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 를&lt;/a&gt; 상속 합니다 . 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec5274c46b7e76247d7c11c675e64556818455ea" translate="yes" xml:space="preserve">
          <source>Base class for syntax errors related to incorrect indentation. This is a subclass of &lt;a href=&quot;#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잘못된 들여 쓰기와 관련된 구문 오류의 기본 클래스입니다. &lt;a href=&quot;#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="f8034f1f619a25403ea22ca32afe23c323c69db0" translate="yes" xml:space="preserve">
          <source>Base class for text streams. This class provides a character and line based interface to stream I/O. It inherits &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. There is no public constructor.</source>
          <target state="translated">텍스트 스트림의 기본 클래스입니다. 이 클래스는 스트림 I / O를위한 문자 및 라인 기반 인터페이스를 제공합니다. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 를&lt;/a&gt; 상속 합니다 . 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="115592b440ded17229a2be8652ec1583576bd6be" translate="yes" xml:space="preserve">
          <source>Base class for the dialogs defined in the other modules listed here.</source>
          <target state="translated">여기에 나열된 다른 모듈에 정의 된 대화 상자의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1a767590a449f53c349f02ce7bd8efd407590883" translate="yes" xml:space="preserve">
          <source>Base class for warning categories.</source>
          <target state="translated">경고 범주의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="30e62bee9558e07fac538cacc23a8c4434dcd550" translate="yes" xml:space="preserve">
          <source>Base class for warnings about deprecated features when those warnings are intended for end users of applications that are written in Python.</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 클래스는 해당 경고가 Python으로 작성된 응용 프로그램의 최종 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bef4dbd3cc05db0caaef10bd33d535aef6000686" translate="yes" xml:space="preserve">
          <source>Base class for warnings about deprecated features when those warnings are intended for other Python developers.</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 클래스는 해당 경고가 다른 Python 개발자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d911ad966f332393c3708556614e73ed1cbd284" translate="yes" xml:space="preserve">
          <source>Base class for warnings about dubious runtime behavior.</source>
          <target state="translated">모호한 런타임 동작에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ed11da738626db6bc66dc76605890a35049a6b1f" translate="yes" xml:space="preserve">
          <source>Base class for warnings about dubious syntax.</source>
          <target state="translated">모호한 구문에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1e39f8ab9b8f97932eee2df10cc6b10cd8aec138" translate="yes" xml:space="preserve">
          <source>Base class for warnings about features which are obsolete and expected to be deprecated in the future, but are not deprecated at the moment.</source>
          <target state="translated">더 이상 사용되지 않으며 향후 폐기 될 예정이지만 현재 폐기되지는 않을 기능에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9dda81dec15bfcd224d1e4d932c986e759a07e6a" translate="yes" xml:space="preserve">
          <source>Base class for warnings about probable mistakes in module imports.</source>
          <target state="translated">모듈 가져 오기에서 발생할 수있는 실수에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a020b0a894b4052b6ee113d3143b9d2aef84bb79" translate="yes" xml:space="preserve">
          <source>Base class for warnings generated by user code.</source>
          <target state="translated">사용자 코드로 생성 된 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b307ddcc59f65f2e18cfc4a546c8cbf5e9483f01" translate="yes" xml:space="preserve">
          <source>Base class for warnings related to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 관련 경고의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="14f1306f10d78b1a318d2d99f7741e21a1990aab" translate="yes" xml:space="preserve">
          <source>Base class for warnings related to Unicode.</source>
          <target state="translated">유니 코드와 관련된 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d1c1a39f6eb8799e6d29048479dd3cf5cc598666" translate="yes" xml:space="preserve">
          <source>Base class for warnings related to resource usage. Ignored by the default warning filters.</source>
          <target state="translated">자원 사용과 관련된 경고의 기본 클래스입니다. 기본 경고 필터에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1dd274748a920e7e6b6531ecc973725498ebb54" translate="yes" xml:space="preserve">
          <source>Base class of the dialog controls. &lt;em&gt;dlg&lt;/em&gt; is the dialog object the control belongs to, and &lt;em&gt;name&lt;/em&gt; is the control&amp;rsquo;s name.</source>
          <target state="translated">대화 상자 컨트롤의 기본 클래스. &lt;em&gt;dlg&lt;/em&gt; 는 컨트롤이 속한 대화 상자 개체이고 &lt;em&gt;name&lt;/em&gt; 은 컨트롤의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8f20f1270a9dcc163b4e1c85af830ebcf1500698" translate="yes" xml:space="preserve">
          <source>Base class which can be inherited by SAX parsers.</source>
          <target state="translated">SAX 파서에 의해 상속 될 수있는 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="597d1d5f179914ea7470a3760bd8ee3a2400c1bc" translate="yes" xml:space="preserve">
          <source>Base classes</source>
          <target state="translated">기본 수업</target>
        </trans-unit>
        <trans-unit id="f532cd83f6f9947116baa3849ec23355cdfb324d" translate="yes" xml:space="preserve">
          <source>Base exception class used for all specific DOM exceptions. This exception class cannot be directly instantiated.</source>
          <target state="translated">모든 특정 DOM 예외에 사용되는 기본 예외 클래스. 이 예외 클래스는 직접 인스턴스화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f00864be99f44fa68097e7a11c50dc2553483317" translate="yes" xml:space="preserve">
          <source>Base interface for most objects in a document.</source>
          <target state="translated">문서에서 대부분의 객체에 대한 기본 인터페이스.</target>
        </trans-unit>
        <trans-unit id="0691eb22ac03b573f0c69a50a9e4abca05842012" translate="yes" xml:space="preserve">
          <source>Base protocol with methods that all protocols share.</source>
          <target state="translated">모든 프로토콜이 공유하는 방법이있는 기본 프로토콜.</target>
        </trans-unit>
        <trans-unit id="0433583846f35c2ba0aec03a821f97c49d6fc91d" translate="yes" xml:space="preserve">
          <source>BaseException</source>
          <target state="translated">BaseException</target>
        </trans-unit>
        <trans-unit id="2139b25cc7ba47829b2613ecd5640b728063f573" translate="yes" xml:space="preserve">
          <source>BaseException.args</source>
          <target state="translated">BaseException.args</target>
        </trans-unit>
        <trans-unit id="f8a3365a764654373607fbb6ccc5794d20c265b0" translate="yes" xml:space="preserve">
          <source>BaseException.with_traceback()</source>
          <target state="translated">BaseException.with_traceback()</target>
        </trans-unit>
        <trans-unit id="74d736dbe7da7ac2d79279fada28cb6cbb8192ea" translate="yes" xml:space="preserve">
          <source>BaseHandler Objects</source>
          <target state="translated">BaseHandler 객체</target>
        </trans-unit>
        <trans-unit id="34ce97d8702b53323f2a4a2c72c66dc5a0eb4e72" translate="yes" xml:space="preserve">
          <source>BaseRotatingHandler</source>
          <target state="translated">BaseRotatingHandler</target>
        </trans-unit>
        <trans-unit id="7348670742e76aaa11d877df8fca9b83a11d1757" translate="yes" xml:space="preserve">
          <source>Basic API</source>
          <target state="translated">기본 API</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="9a289e7dff9101f26b8dc18725557c4f9fdf82bd" translate="yes" xml:space="preserve">
          <source>Basic Examples</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="0d3f6e8e2e15cd0179d1216f1c988e44f90d868e" translate="yes" xml:space="preserve">
          <source>Basic Tutorial</source>
          <target state="translated">기본 튜토리얼</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="03cdc9f64fd1c085bb10854b62f123e70ce40ba7" translate="yes" xml:space="preserve">
          <source>Basic Widgets</source>
          <target state="translated">기본 위젯</target>
        </trans-unit>
        <trans-unit id="af90dc70fae02c63e1b5bfb27dfff83393f621b5" translate="yes" xml:space="preserve">
          <source>Basic dialogs and convenience functions.</source>
          <target state="translated">기본 대화 상자 및 편의 기능.</target>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="cfd84c756956f6869f891f756d2ed679a18b4696" translate="yes" xml:space="preserve">
          <source>Basic examples:</source>
          <target state="translated">기본 예 :</target>
        </trans-unit>
        <trans-unit id="c58a44745c80d118117b0a04466e564264a9e678" translate="yes" xml:space="preserve">
          <source>Basic interface for resolving entities. If you create an object implementing this interface, then register the object with your Parser, the parser will call the method in your object to resolve all external entities.</source>
          <target state="translated">엔티티 해결을위한 기본 인터페이스. 이 인터페이스를 구현하는 객체를 만든 다음 파서에 객체를 등록하면 파서는 객체의 메소드를 호출하여 모든 외부 엔티티를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="dc42d64e6761d3023d0a23567aa37e8faeed769a" translate="yes" xml:space="preserve">
          <source>Basic skipping looks like this:</source>
          <target state="translated">기본 건너 뛰기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="955f12253b570691dddd89d6664ff86c6ffea525" translate="yes" xml:space="preserve">
          <source>Basic turtle commands such as &lt;a href=&quot;turtle#turtle.forward&quot;&gt;&lt;code&gt;forward()&lt;/code&gt;&lt;/a&gt; are added to a &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; subclass with method named &lt;code&gt;do_forward()&lt;/code&gt;. The argument is converted to a number and dispatched to the turtle module. The docstring is used in the help utility provided by the shell.</source>
          <target state="translated">&lt;a href=&quot;turtle#turtle.forward&quot;&gt; &lt;code&gt;forward()&lt;/code&gt; &lt;/a&gt; 와 같은 기본 터틀 명령 은 &lt;code&gt;do_forward()&lt;/code&gt; 라는 메소드 를 사용하여 &lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 서브 클래스에 추가됩니다 . 인수는 숫자로 변환되어 turtle 모듈로 전달됩니다. docstring은 쉘에서 제공하는 도움말 유틸리티에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="168929183d2470cb5fd9c8ab272eed288ccb698d" translate="yes" xml:space="preserve">
          <source>Basic use</source>
          <target state="translated">기본 사용</target>
        </trans-unit>
        <trans-unit id="de3816b07b2c1c67b6c5d0b0c0ef9af019f07757" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;em&gt;followlinks&lt;/em&gt; to &lt;code&gt;True&lt;/code&gt; can lead to infinite recursion if a link points to a parent directory of itself. &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; does not keep track of the directories it visited already.</source>
          <target state="translated">링크가 자체의 상위 디렉토리를 가리키는 경우 &lt;em&gt;후속 링크&lt;/em&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정 하면 무한 재귀로 이어질 수 있습니다. &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 는 이미 방문한 디렉토리를 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4d410bcf0f1e8b0447d1481b24eeff8e98f8899" translate="yes" xml:space="preserve">
          <source>Be careful to not use this module where deadlock might occur from a thread being created that blocks waiting for another thread to be created. This often occurs with blocking I/O.</source>
          <target state="translated">다른 스레드가 작성 될 때까지 대기하는 것을 막는 스레드 작성시 교착 상태가 발생할 수있는 경우이 모듈을 사용하지 마십시오. 이것은 종종 I / O 차단과 함께 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1cc029ce668972e8e992f6e3aa06dc274e72815" translate="yes" xml:space="preserve">
          <source>Be forewarned about how &lt;code&gt;init=False&lt;/code&gt; fields work during a call to &lt;a href=&quot;#dataclasses.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt;. They are not copied from the source object, but rather are initialized in &lt;code&gt;__post_init__()&lt;/code&gt;, if they&amp;rsquo;re initialized at all. It is expected that &lt;code&gt;init=False&lt;/code&gt; fields will be rarely and judiciously used. If they are used, it might be wise to have alternate class constructors, or perhaps a custom &lt;code&gt;replace()&lt;/code&gt; (or similarly named) method which handles instance copying.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 호출 중에 &lt;code&gt;init=False&lt;/code&gt; 필드가 작동 하는 방식에 대해 미리 알고 있어야 합니다. 그것들은 소스 객체에서 복사되는 것이 아니라, 초기화 된 경우 &lt;code&gt;__post_init__()&lt;/code&gt; 에서 초기화됩니다. &lt;code&gt;init=False&lt;/code&gt; 필드는 드물고 신중하게 사용될 것으로 예상 됩니다. 그것들이 사용된다면, 대체 클래스 생성자, 또는 인스턴스 복사를 처리 하는 커스텀 &lt;code&gt;replace()&lt;/code&gt; (또는 비슷한 이름의) 메소드 를 갖는 것이 현명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abae3c10b04d3f45674d8d84138847d156e5d77c" translate="yes" xml:space="preserve">
          <source>Be very cautious when modifying mailboxes that might be simultaneously changed by some other process. The safest mailbox format to use for such tasks is Maildir; try to avoid using single-file formats such as mbox for concurrent writing. If you&amp;rsquo;re modifying a mailbox, you &lt;em&gt;must&lt;/em&gt; lock it by calling the &lt;a href=&quot;#mailbox.Mailbox.lock&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mailbox.Mailbox.unlock&quot;&gt;&lt;code&gt;unlock()&lt;/code&gt;&lt;/a&gt; methods &lt;em&gt;before&lt;/em&gt; reading any messages in the file or making any changes by adding or deleting a message. Failing to lock the mailbox runs the risk of losing messages or corrupting the entire mailbox.</source>
          <target state="translated">다른 프로세스에 의해 동시에 변경 될 수있는 사서함을 수정할 때는 매우주의해야합니다. 이러한 작업에 가장 안전한 사서함 형식은 Maildir입니다. 동시 쓰기에 mbox와 같은 단일 파일 형식을 사용하지 마십시오. 사서함을 수정하는 경우 파일의 메시지를 읽거나 메시지를 추가하거나 삭제하여 변경 &lt;em&gt;하기 전에 &lt;/em&gt;&lt;a href=&quot;#mailbox.Mailbox.lock&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mailbox.Mailbox.unlock&quot;&gt; &lt;code&gt;unlock()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 사서함을 잠 &lt;em&gt;가야합니다&lt;/em&gt; . 사서함을 잠그지 않으면 메시지가 손실되거나 전체 사서함이 손상 될 위험이 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0c1fe83f49ee94713ba4bebb01d2337218d28eb" translate="yes" xml:space="preserve">
          <source>Be warned that you should calibrate the profiler class for the timer function that you choose (see &lt;a href=&quot;#profile-calibration&quot;&gt;Calibration&lt;/a&gt;). For most machines, a timer that returns a lone integer value will provide the best results in terms of low overhead during profiling. (&lt;a href=&quot;os#os.times&quot;&gt;&lt;code&gt;os.times()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;pretty&lt;/em&gt; bad, as it returns a tuple of floating point values). If you want to substitute a better timer in the cleanest fashion, derive a class and hardwire a replacement dispatch method that best handles your timer call, along with the appropriate calibration constant.</source>
          <target state="translated">선택한 타이머 기능에 대한 프로파일 러 클래스를 교정해야합니다 ( &lt;a href=&quot;#profile-calibration&quot;&gt;교정&lt;/a&gt; 참조 ). 대부분의 컴퓨터에서 고독 정수 값을 반환하는 타이머는 프로파일 링 중 오버 헤드가 적다는 점에서 최상의 결과를 제공합니다. ( &lt;a href=&quot;os#os.times&quot;&gt; &lt;code&gt;os.times()&lt;/code&gt; &lt;/a&gt; 는 부동 소수점 값의 튜플을 반환하기 때문에 &lt;em&gt;꽤&lt;/em&gt; 나쁩니다). 더 깨끗한 타이머를 가장 깨끗한 방식으로 대체하려면 클래스를 도출하고 적절한 교정 상수와 함께 타이머 호출을 가장 잘 처리하는 대체 디스패치 메소드를 배선하십시오.</target>
        </trans-unit>
        <trans-unit id="fb941ef4dc684b044e6e45b9283386b1eb3e83df" translate="yes" xml:space="preserve">
          <source>Bear in mind that a process that has put items in a queue will wait before terminating until all the buffered items are fed by the &amp;ldquo;feeder&amp;rdquo; thread to the underlying pipe. (The child process can call the &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt;&lt;code&gt;Queue.cancel_join_thread&lt;/code&gt;&lt;/a&gt; method of the queue to avoid this behaviour.)</source>
          <target state="translated">큐에 항목을 넣은 프로세스는 버퍼링 된 모든 항목이 &quot;피더&quot;스레드에 의해 기본 파이프로 공급 될 때까지 종료되기 전에 대기합니다. 하위 프로세스는 이 동작을 피하기 위해 큐 의 &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt; &lt;code&gt;Queue.cancel_join_thread&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4332bde329f74d1a7a1aff8d1cef2c7d17c810" translate="yes" xml:space="preserve">
          <source>Bear in mind that if code run in a child process tries to access a global variable, then the value it sees (if any) may not be the same as the value in the parent process at the time that &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;Process.start&lt;/code&gt;&lt;/a&gt; was called.</source>
          <target state="translated">자식 프로세스에서 실행되는 코드가 전역 변수에 액세스하려고하면 보이는 값 (있는 경우)이 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;Process.start&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 부모 프로세스의 값과 같지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10e62a51dfa0dc36185ec273da331d0a6fb29a35" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. For example, metaclass attributes are not in the result list when the argument is a class.</source>
          <target state="translated">때문에 &lt;a href=&quot;#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 대화 형 프롬프트에서 사용의 편의를 주로 공급되고, 그것이 이름의 엄격 또는 일관되게 정의 세트를 제공하려고보다 더 많은 이름의 흥미로운 세트를 제공하려고, 그 상세한 동작은 릴리스에 따라 변경 될 수 있습니다. 예를 들어, 인수가 클래스 인 경우 메타 클래스 속성이 결과 목록에 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ed699fc6637c9326d06d5f91cf8cfe03647969a" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; members are also subclasses of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; they can be combined with them:</source>
          <target state="translated">&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버도 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; 의&lt;/a&gt; 서브 클래스 이므로 다음과 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5676d312428ed566fc5e55055b04a8a487aa66cb" translate="yes" xml:space="preserve">
          <source>Because NIS exists only on Unix systems, this module is only available for Unix.</source>
          <target state="translated">NIS는 Unix 시스템에만 존재하므로이 모듈은 Unix에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449b33e822195d1cb40d26026e8bbadbe72c580f" translate="yes" xml:space="preserve">
          <source>Because all asyncio subprocess functions are asynchronous and asyncio provides many tools to work with such functions, it is easy to execute and monitor multiple subprocesses in parallel. It is indeed trivial to modify the above example to run several commands simultaneously:</source>
          <target state="translated">모든 asyncio 하위 프로세스 기능은 비동기식이며 asyncio는 이러한 기능으로 작업 할 수있는 많은 도구를 제공하므로 여러 하위 프로세스를 병렬로 쉽게 실행하고 모니터링 할 수 있습니다. 위의 예제를 수정하여 여러 명령을 동시에 실행하는 것은 사소한 일입니다.</target>
        </trans-unit>
        <trans-unit id="cd024808dd20391db9a5d87efaaa473460d75e55" translate="yes" xml:space="preserve">
          <source>Because deep copy copies everything it may copy too much, such as data which is intended to be shared between copies.</source>
          <target state="translated">딥 카피는 카피간에 공유 할 데이터와 같이 모든 것을 카피하기 때문에 너무 많이 카피 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe4a8056160b609c3f4db4e7d117d78cac2ac63" translate="yes" xml:space="preserve">
          <source>Because it requires the &lt;a href=&quot;termios#module-termios&quot;&gt;&lt;code&gt;termios&lt;/code&gt;&lt;/a&gt; module, it will work only on Unix.</source>
          <target state="translated">&lt;a href=&quot;termios#module-termios&quot;&gt; &lt;code&gt;termios&lt;/code&gt; &lt;/a&gt; 모듈 이 필요하기 때문에 Unix에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="512d82a1a965117bb846701b126fb31120198553" translate="yes" xml:space="preserve">
          <source>Because it&amp;rsquo;s so flexible, &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt;&lt;code&gt;XMLPullParser&lt;/code&gt;&lt;/a&gt; can be inconvenient to use for simpler use-cases. If you don&amp;rsquo;t mind your application blocking on reading XML data but would still like to have incremental parsing capabilities, take a look at &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt;&lt;code&gt;iterparse()&lt;/code&gt;&lt;/a&gt;. It can be useful when you&amp;rsquo;re reading a large XML document and don&amp;rsquo;t want to hold it wholly in memory.</source>
          <target state="translated">&lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt; &lt;code&gt;XMLPullParser&lt;/code&gt; &lt;/a&gt; 는 매우 유연하기 때문에 더 단순한 사용 사례에 사용하기 불편할 수 있습니다. 응용 프로그램에서 XML 데이터 읽기를 차단하지 않아도 증분 구문 분석 기능을 사용하려면 &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt; &lt;code&gt;iterparse()&lt;/code&gt; &lt;/a&gt; 살펴보십시오 . 큰 XML 문서를 읽을 때 메모리에 완전히 저장하지 않으려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97e478af3d6ae73e7bc440c377cd0710be8dd209" translate="yes" xml:space="preserve">
          <source>Because magic methods are looked up differently from normal methods &lt;a href=&quot;#id9&quot; id=&quot;id7&quot;&gt;2&lt;/a&gt;, this support has been specially implemented. This means that only specific magic methods are supported. The supported list includes &lt;em&gt;almost&lt;/em&gt; all of them. If there are any missing that you need please let us know.</source>
          <target state="translated">매직 메소드는 일반 메소드 &lt;a href=&quot;#id9&quot; id=&quot;id7&quot;&gt;2&lt;/a&gt; 와 다르게 조회 되므로이 지원은 특별히 구현되었습니다. 즉, 특정 마법 방법 만 지원됩니다. 지원되는 목록에는 &lt;em&gt;거의&lt;/em&gt; 모든 것이 포함 됩니다. 누락 된 부분이 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="ff5644c87e7d8c8596308ff2c76d404cdc5f9f5e" translate="yes" xml:space="preserve">
          <source>Because many of the traps are enabled, this context is useful for debugging.</source>
          <target state="translated">많은 트랩이 사용 가능하므로이 컨텍스트는 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0682abf783b1442ff30ccebb13d38ee0bde7ce7f" translate="yes" xml:space="preserve">
          <source>Because mocks auto-create attributes on demand, and allow you to call them with arbitrary arguments, if you misspell one of these assert methods then your assertion is gone:</source>
          <target state="translated">mock은 필요에 따라 속성을 자동 생성하고 임의의 인수로 속성을 호출 할 수 있으므로 이러한 어설트 메서드 중 하나를 잘못 입력하면 어설 션이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="d2f324a634323f6253d750beb01677494c624217" translate="yes" xml:space="preserve">
          <source>Because most of the operations on any given type will be very similar, it can be useful to define a helper function which generates the forward and reverse instances of any given operator. For example, &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt; uses:</source>
          <target state="translated">주어진 유형에 대한 대부분의 연산은 매우 유사하므로 주어진 연산자의 정방향 및 역방향 인스턴스를 생성하는 도우미 함수를 정의하는 것이 유용 할 수 있습니다. 예를 들어 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt; 은 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f37e0b8c6e2c7fbb2cc8dfb353efdeb9905b90d4" translate="yes" xml:space="preserve">
          <source>Because multiple signatures (ie. overloading) is permitted, this method returns a list of signatures rather than a singleton.</source>
          <target state="translated">여러 서명 (예 : 오버로드)이 허용되므로이 메서드는 싱글 톤이 아닌 서명 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8d328dbf9ad55c5ef4fe48e9b55f65c19053b49" translate="yes" xml:space="preserve">
          <source>Because naive &lt;code&gt;datetime&lt;/code&gt; objects are treated by many &lt;code&gt;datetime&lt;/code&gt; methods as local times, it is preferred to use aware datetimes to represent times in UTC. As such, the recommended way to create an object representing a specific timestamp in UTC is by calling &lt;code&gt;datetime.fromtimestamp(timestamp, tz=timezone.utc)&lt;/code&gt;.</source>
          <target state="translated">순진한 &lt;code&gt;datetime&lt;/code&gt; 객체는 많은 &lt;code&gt;datetime&lt;/code&gt; 메서드에 의해 현지 시간으로 처리 되므로 UTC로 인식 된 날짜 시간을 사용하여 시간을 나타내는 것이 좋습니다. 따라서 UTC로 특정 타임 스탬프를 나타내는 객체를 만드는 권장 방법은 &lt;code&gt;datetime.fromtimestamp(timestamp, tz=timezone.utc)&lt;/code&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6c258a614b92ea7ab843f0053cb8a4745997da95" translate="yes" xml:space="preserve">
          <source>Because naive &lt;code&gt;datetime&lt;/code&gt; objects are treated by many &lt;code&gt;datetime&lt;/code&gt; methods as local times, it is preferred to use aware datetimes to represent times in UTC. As such, the recommended way to create an object representing the current time in UTC is by calling &lt;code&gt;datetime.now(timezone.utc)&lt;/code&gt;.</source>
          <target state="translated">순진한 &lt;code&gt;datetime&lt;/code&gt; 객체는 많은 &lt;code&gt;datetime&lt;/code&gt; 메서드에 의해 현지 시간으로 처리 되므로 UTC로 인식 된 날짜 시간을 사용하여 시간을 나타내는 것이 좋습니다. 따라서 UTC로 현재 시간을 나타내는 객체를 만드는 권장 방법은 &lt;code&gt;datetime.now(timezone.utc)&lt;/code&gt; 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f47a5630dcb74119e881ec10d145701d12e134d9" translate="yes" xml:space="preserve">
          <source>Because naive &lt;code&gt;datetime&lt;/code&gt; objects are treated by many &lt;code&gt;datetime&lt;/code&gt; methods as local times, it is preferred to use aware datetimes to represent times in UTC; as a result, using &lt;code&gt;utcfromtimetuple&lt;/code&gt; may give misleading results. If you have a naive &lt;code&gt;datetime&lt;/code&gt; representing UTC, use &lt;code&gt;datetime.replace(tzinfo=timezone.utc)&lt;/code&gt; to make it aware, at which point you can use &lt;a href=&quot;#datetime.datetime.timetuple&quot;&gt;&lt;code&gt;datetime.timetuple()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">순진한 &lt;code&gt;datetime&lt;/code&gt; 객체는 많은 &lt;code&gt;datetime&lt;/code&gt; 메서드에 의해 현지 시간으로 처리 되므로 UTC로 인식 된 날짜 시간을 사용하는 것이 좋습니다. 결과적으로 &lt;code&gt;utcfromtimetuple&lt;/code&gt; 을 사용 하면 잘못된 결과 를 초래할 수 있습니다. UTC를 나타내는 순진한 &lt;code&gt;datetime&lt;/code&gt; 이있는 경우 &lt;code&gt;datetime.replace(tzinfo=timezone.utc)&lt;/code&gt; 를 사용하여 알 수 있도록하십시오 . 그러면 &lt;a href=&quot;#datetime.datetime.timetuple&quot;&gt; &lt;code&gt;datetime.timetuple()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05c1292e4567d219d1d4e44f189debf054b0b060" translate="yes" xml:space="preserve">
          <source>Because of Python semantics, a shelf cannot know when a mutable persistent-dictionary entry is modified. By default modified objects are written &lt;em&gt;only&lt;/em&gt; when assigned to the shelf (see &lt;a href=&quot;#shelve-example&quot;&gt;Example&lt;/a&gt;). If the optional &lt;em&gt;writeback&lt;/em&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, all entries accessed are also cached in memory, and written back on &lt;a href=&quot;#shelve.Shelf.sync&quot;&gt;&lt;code&gt;sync()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#shelve.Shelf.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;; this can make it handier to mutate mutable entries in the persistent dictionary, but, if many entries are accessed, it can consume vast amounts of memory for the cache, and it can make the close operation very slow since all accessed entries are written back (there is no way to determine which accessed entries are mutable, nor which ones were actually mutated).</source>
          <target state="translated">파이썬 시맨틱으로 인해 선반은 변경 가능한 영구 사전 항목이 수정 된시기를 알 수 없습니다. 기본적으로 수정 된 개체는 선반에 할당 된 경우 &lt;em&gt;에만&lt;/em&gt; 작성 &lt;em&gt;됩니다&lt;/em&gt; ( &lt;a href=&quot;#shelve-example&quot;&gt;예&lt;/a&gt; 참조 ). 선택적 &lt;em&gt;쓰기 저장&lt;/em&gt; 매개 변수가 &lt;code&gt;True&lt;/code&gt; 로 설정되면 액세스 된 모든 항목도 메모리에 캐시되고 &lt;a href=&quot;#shelve.Shelf.sync&quot;&gt; &lt;code&gt;sync()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#shelve.Shelf.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 에 다시 기록됩니다.; 이로 인해 영속 사전에서 변경 가능한 항목을 변경하는 것이 더 쉬워 질 수 있지만, 많은 항목에 액세스하는 경우 캐시를 위해 방대한 양의 메모리를 소비 할 수 있으며 모든 액세스 된 항목이 다시 기록되므로 닫기 조작이 매우 느려질 수 있습니다 ( 어떤 액세스 가능한 항목이 변경 가능한지 또는 실제로 어떤 항목이 변경되었는지 확인할 방법이 없습니다).</target>
        </trans-unit>
        <trans-unit id="8a25338cf8065d3938e8ff0b097c26f981ba9436" translate="yes" xml:space="preserve">
          <source>Because of the way Tk handles the X option database, after Tix has been has imported and inited, it is not possible to reset the color schemes and font sets using the &lt;code&gt;tix_config()&lt;/code&gt; method. Instead, the &lt;a href=&quot;#tkinter.tix.tixCommand.tix_resetoptions&quot;&gt;&lt;code&gt;tix_resetoptions()&lt;/code&gt;&lt;/a&gt; method must be used.</source>
          <target state="translated">Tk가 X 옵션 데이터베이스를 처리하는 방식으로 인해 Tix를 가져 와서 초기화 한 후에 &lt;code&gt;tix_config()&lt;/code&gt; 메소드를 사용하여 색상 구성표 및 글꼴 세트를 재설정 할 수 없습니다 . 대신 &lt;a href=&quot;#tkinter.tix.tixCommand.tix_resetoptions&quot;&gt; &lt;code&gt;tix_resetoptions()&lt;/code&gt; &lt;/a&gt; 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="80d71e1d1d10cd40808346877ec280d341096ac6" translate="yes" xml:space="preserve">
          <source>Because of the way mock attributes are stored you can&amp;rsquo;t directly attach a &lt;a href=&quot;#unittest.mock.PropertyMock&quot;&gt;&lt;code&gt;PropertyMock&lt;/code&gt;&lt;/a&gt; to a mock object. Instead you can attach it to the mock type object:</source>
          <target state="translated">모의 속성이 저장되는 방식으로 인해 &lt;a href=&quot;#unittest.mock.PropertyMock&quot;&gt; &lt;code&gt;PropertyMock&lt;/code&gt; &lt;/a&gt; 을 모의 객체에 직접 연결할 수 없습니다 . 대신 모의 유형 객체에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="400e21a04dc1ea4ab9991dc7b7931687ece1123f" translate="yes" xml:space="preserve">
          <source>Because package metadata is not available through &lt;code&gt;sys.path&lt;/code&gt; searches, or package loaders directly, the metadata for a package is found through import system &lt;a href=&quot;https://docs.python.org/3/reference/import.html#finders-and-loaders&quot;&gt;finders&lt;/a&gt;. To find a distribution package&amp;rsquo;s metadata, &lt;code&gt;importlib.metadata&lt;/code&gt; queries the list of &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-meta-path-finder&quot;&gt;meta path finders&lt;/a&gt; on &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.meta_path&quot;&gt;sys.meta_path&lt;/a&gt;.</source>
          <target state="translated">패키지 메타 데이터는 &lt;code&gt;sys.path&lt;/code&gt; 검색 또는 패키지 로더를 통해 직접 사용할 수 없으므로 패키지의 메타 데이터는 import system &lt;a href=&quot;https://docs.python.org/3/reference/import.html#finders-and-loaders&quot;&gt;finders를&lt;/a&gt; 통해 찾을 수 있습니다. 배포 패키지의 메타 데이터를 찾기 위해 &lt;code&gt;importlib.metadata&lt;/code&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.meta_path&quot;&gt;sys.meta_path&lt;/a&gt; 에서 &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-meta-path-finder&quot;&gt;메타 경로 파인더&lt;/a&gt; 목록을 쿼리합니다 .</target>
        </trans-unit>
        <trans-unit id="d55b59f6bf0508d0270277c6f73d5728e5bbe79f" translate="yes" xml:space="preserve">
          <source>Because portions of the configuration are passed through &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;, use of this function may open its users to a security risk. While the function only binds to a socket on &lt;code&gt;localhost&lt;/code&gt;, and so does not accept connections from remote machines, there are scenarios where untrusted code could be run under the account of the process which calls &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt;. Specifically, if the process calling &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; runs on a multi-user machine where users cannot trust each other, then a malicious user could arrange to run essentially arbitrary code in a victim user&amp;rsquo;s process, simply by connecting to the victim&amp;rsquo;s &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; socket and sending a configuration which runs whatever code the attacker wants to have executed in the victim&amp;rsquo;s process. This is especially easy to do if the default port is used, but not hard even if a different port is used). To avoid the risk of this happening, use the &lt;code&gt;verify&lt;/code&gt; argument to &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; to prevent unrecognised configurations from being applied.</source>
          <target state="translated">구성의 일부가 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 통해 전달 되므로이 함수를 사용하면 사용자가 보안 위험에 노출 될 수 있습니다. 이 함수는 &lt;code&gt;localhost&lt;/code&gt; 의 소켓에만 바인딩 되므로 원격 시스템의 연결을 허용하지 않지만, &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 을 호출하는 프로세스의 계정으로 신뢰할 수없는 코드가 실행될 수있는 시나리오가 있습니다 . 특히, &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 호출하는 프로세스 가 사용자가 서로를 신뢰할 수없는 다중 사용자 컴퓨터에서 실행되는 경우 악의적 인 사용자는 피해자의 &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 에 연결하여 피해자의 사용자 프로세스에서 본질적으로 임의의 코드를 실행하도록 조정할 수 있습니다.공격자가 피해자의 프로세스에서 실행하고자하는 모든 코드를 실행하는 구성을 전송합니다. 이것은 기본 포트가 사용되는 경우에 특히 쉽지만 다른 포트를 사용하더라도 어렵지 않습니다). 이러한 상황의 위험을 피하려면 &lt;code&gt;verify&lt;/code&gt; 인수를 사용하여 &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 으로 인식 할 수없는 구성이 적용되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="5624fe7445294e1d731602dabe55a2ad5baa3be9" translate="yes" xml:space="preserve">
          <source>Because pseudo-terminal handling is highly platform dependent, there is code to do it only for Linux. (The Linux code is supposed to work on other platforms, but hasn&amp;rsquo;t been tested yet.)</source>
          <target state="translated">의사 터미널 처리는 플랫폼에 따라 크게 달라 지므로 Linux에서만 처리하는 코드가 있습니다. (Linux 코드는 다른 플랫폼에서 작동하지만 아직 테스트되지는 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="d26513ebec365d3c671c97db0de645fa9c2e3b1f" translate="yes" xml:space="preserve">
          <source>Because strings cannot represent binary data, the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; class must convert any binary data in any message it flattens to an ASCII compatible format, by converting them to an ASCII compatible &lt;em&gt;Content-Transfer_Encoding&lt;/em&gt;. Using the terminology of the email RFCs, you can think of this as &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; serializing to an I/O stream that is not &amp;ldquo;8 bit clean&amp;rdquo;. In other words, most applications will want to be using &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt;, and not &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 이진 데이터를 나타낼 수 없으므로 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 클래스는 병합하는 모든 메시지의 이진 데이터를 ASCII 호환 &lt;em&gt;Content-Transfer_Encoding&lt;/em&gt; 으로 변환하여 ASCII 호환 형식으로 변환해야합니다 . 이메일 RFC의 용어를 사용하면이를 &quot;8 비트 클린&quot;이 아닌 I / O 스트림으로 직렬화하는 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 로 생각할 수 있습니다 . 즉, 대부분의 응용 프로그램은 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 가&lt;/a&gt; 아닌 &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; 를&lt;/a&gt; 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="89da8e115c0fb8ba5661a24d5093eacb1e6421a5" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#module-shelve&quot;&gt;&lt;code&gt;shelve&lt;/code&gt;&lt;/a&gt; module is backed by &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt;, it is insecure to load a shelf from an untrusted source. Like with pickle, loading a shelf can execute arbitrary code.</source>
          <target state="translated">때문에 &lt;a href=&quot;#module-shelve&quot;&gt; &lt;code&gt;shelve&lt;/code&gt; &lt;/a&gt; 모듈에 연동 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; , 신뢰 소스로부터 선반로드 불안정하다. 피클과 마찬가지로 선반을로드하면 임의 코드가 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d13ce7f4ddc06362be70a3eb8a64c34f10a0b7" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;os.DirEntry&lt;/code&gt; methods can make operating system calls, they may also raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;. If you need very fine-grained control over errors, you can catch &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; when calling one of the &lt;code&gt;os.DirEntry&lt;/code&gt; methods and handle as appropriate.</source>
          <target state="translated">때문에 &lt;code&gt;os.DirEntry&lt;/code&gt; 의 방법은 시스템 호출을 운영 할 수 있습니다, 그들은 또한 제기 할 수 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 을&lt;/a&gt; . 오류에 대한 매우 세밀한 제어가 필요한 경우 &lt;code&gt;os.DirEntry&lt;/code&gt; 메소드 중 하나를 호출 할 때 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 를 포착 하고 적절하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f5cc4736c7fbeafded92a9d1efa62626a33de504" translate="yes" xml:space="preserve">
          <source>Because the default behavior of &lt;code&gt;Message.__setitem__&lt;/code&gt; is to append the value to the list of headers, it is easy to create duplicate headers without realizing it. This method allows certain headers to be limited in the number of instances of that header that may be added to a &lt;code&gt;Message&lt;/code&gt; programmatically. (The limit is not observed by the parser, which will faithfully produce as many headers as exist in the message being parsed.)</source>
          <target state="translated">&lt;code&gt;Message.__setitem__&lt;/code&gt; 의 기본 동작은 헤더 목록에 값을 추가하는 것이므로 중복 헤더를 실현하지 않고 쉽게 만들 수 있습니다. 이 방법을 사용하면 특정 헤더를 프로그래밍 방식 으로 &lt;code&gt;Message&lt;/code&gt; 추가 할 수있는 해당 헤더의 인스턴스 수로 제한 할 수 있습니다 . 파서는이 제한을 준수하지 않으므로 구문 분석중인 메시지에 존재하는만큼의 헤더를 충실하게 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e508e7ca842cae56ee0fee2a7255d491cd76f437" translate="yes" xml:space="preserve">
          <source>Because the file name does not end with &lt;code&gt;.py&lt;/code&gt;, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; infers that it must be run with &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 이름이로 끝나지 않기 때문에 &lt;code&gt;.py&lt;/code&gt; , &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; 가&lt;/a&gt; 그것을 실행해야한다고 추론한다 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; ,하지 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bdfdaaeb849970dad8f9e9818061fb878cb7999" translate="yes" xml:space="preserve">
          <source>Because the format depends on the current locale, care should be taken when making assumptions about the output value. Field orderings will vary (for example, &amp;ldquo;month/day/year&amp;rdquo; versus &amp;ldquo;day/month/year&amp;rdquo;), and the output may contain Unicode characters encoded using the locale&amp;rsquo;s default encoding (for example, if the current locale is &lt;code&gt;ja_JP&lt;/code&gt;, the default encoding could be any one of &lt;code&gt;eucJP&lt;/code&gt;, &lt;code&gt;SJIS&lt;/code&gt;, or &lt;code&gt;utf-8&lt;/code&gt;; use &lt;a href=&quot;locale#locale.getlocale&quot;&gt;&lt;code&gt;locale.getlocale()&lt;/code&gt;&lt;/a&gt; to determine the current locale&amp;rsquo;s encoding).</source>
          <target state="translated">형식은 현재 로케일에 따라 다르므로 출력 값에 대해 가정 할 때주의해야합니다. 필드 순서는 다양하며 (예 : &quot;월 / 일 / 년&quot;대 &quot;일 / 월 / 년&quot;) 출력에는 로케일의 기본 인코딩을 사용하여 인코딩 된 유니 코드 문자가 포함될 수 있습니다 (예 : 현재 로케일이 &lt;code&gt;ja_JP&lt;/code&gt; 이면 기본 인코딩은 중 하나가 될 수 있습니다 &lt;code&gt;eucJP&lt;/code&gt; , &lt;code&gt;SJIS&lt;/code&gt; , 또는 &lt;code&gt;utf-8&lt;/code&gt; 을 사용; &lt;a href=&quot;locale#locale.getlocale&quot;&gt; &lt;code&gt;locale.getlocale()&lt;/code&gt; &lt;/a&gt; 현재의 로케일의 인코딩을 결정하기 위해).</target>
        </trans-unit>
        <trans-unit id="19cc5a3ec7f1feac3debf6aac3103f1d83152c83" translate="yes" xml:space="preserve">
          <source>Because the module uses &lt;strong&gt;/bin/sh&lt;/strong&gt; command lines, a POSIX or compatible shell for &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;os.popen()&lt;/code&gt;&lt;/a&gt; is required.</source>
          <target state="translated">모듈은 &lt;strong&gt;/ bin / sh&lt;/strong&gt; 명령 행을 사용하므로 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;os.popen()&lt;/code&gt; &lt;/a&gt; 대한 POSIX 또는 호환 쉘 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3f1f9af0dfdfed0a5be1b6b9e51ad5d7c030fac2" translate="yes" xml:space="preserve">
          <source>Because the pattern is passed into &lt;code&gt;load_tests&lt;/code&gt; the package is free to continue (and potentially modify) test discovery. A &amp;lsquo;do nothing&amp;rsquo; &lt;code&gt;load_tests&lt;/code&gt; function for a test package would look like:</source>
          <target state="translated">패턴이 &lt;code&gt;load_tests&lt;/code&gt; 로 전달 되므로 패키지는 테스트 발견을 계속하고 잠재적으로 수정할 수 있습니다. 테스트 패키지에 대한 '아무것도하지 않음' &lt;code&gt;load_tests&lt;/code&gt; 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7eeaba1ce3974d485fc10bfd66f07a672724c5b" translate="yes" xml:space="preserve">
          <source>Because the traps are disabled, this context is useful for applications that prefer to have result value of &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; instead of raising exceptions. This allows an application to complete a run in the presence of conditions that would otherwise halt the program.</source>
          <target state="translated">트랩이 비활성화되어 있으므로이 컨텍스트는 예외를 발생시키는 대신 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;Infinity&lt;/code&gt; 의 결과 값을 선호하는 응용 프로그램에 유용합니다 . 이렇게하면 응용 프로그램이 프로그램을 중지시키는 조건이있는 상태에서 실행을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f8021b79e3f19e12b4eea6f7791f976cf9c551" translate="yes" xml:space="preserve">
          <source>Because this function has rather complex behavior (especially when custom event loop policies are in use), using the &lt;a href=&quot;#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt; function is preferred to &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt; in coroutines and callbacks.</source>
          <target state="translated">이 함수는 다소 복잡한 동작 (특히 사용자 정의 이벤트 루프 정책을 사용중인 경우) 을 &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; 코 루틴 및 콜백에서 &lt;a href=&quot;#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것이 get_event_loop () 보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="945f996940a3d1a131b75aea9889abba3eb63002" translate="yes" xml:space="preserve">
          <source>Because this is a naive &lt;code&gt;datetime&lt;/code&gt; it will be interpreted as a UTC timestamp, and the resulting value will have a timezone of &lt;code&gt;-0000&lt;/code&gt;. Much more useful is to use the &lt;a href=&quot;email.utils#email.utils.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; function from the &lt;a href=&quot;email.utils#module-email.utils&quot;&gt;&lt;code&gt;utils&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">이것은 순진한 &lt;code&gt;datetime&lt;/code&gt; 이므로 UTC 타임 스탬프로 해석되며 결과 값의 시간대는 &lt;code&gt;-0000&lt;/code&gt; 입니다. &lt;a href=&quot;email.utils#module-email.utils&quot;&gt; &lt;code&gt;utils&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;a href=&quot;email.utils#email.utils.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하는 것이 훨씬 더 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="aa017ba24b44b99db1534c67404110bcb6547224" translate="yes" xml:space="preserve">
          <source>Beep the PC&amp;rsquo;s speaker. The &lt;em&gt;frequency&lt;/em&gt; parameter specifies frequency, in hertz, of the sound, and must be in the range 37 through 32,767. The &lt;em&gt;duration&lt;/em&gt; parameter specifies the number of milliseconds the sound should last. If the system is not able to beep the speaker, &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">PC 스피커에서 경고음을냅니다. &lt;em&gt;주파수&lt;/em&gt; 파라미터 지정 음향 헤르쯔 주파수, 및 32,767 내지 37이어야한다. &lt;em&gt;duration&lt;/em&gt; 매개 변수는 사운드가 &lt;em&gt;지속&lt;/em&gt; 되는 &lt;em&gt;시간 (&lt;/em&gt; 밀리 초)을 지정합니다. 시스템에서 스피커에서 경고음을 낼 수 없으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9decded3226de91a3370052bd429264360dba835" translate="yes" xml:space="preserve">
          <source>Before I explain how auto-speccing works, here&amp;rsquo;s why it is needed.</source>
          <target state="translated">자동 지정의 작동 방식을 설명하기 전에 이것이 필요한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="648ed538fe4d41e0992f761cec23ce4dc2546702" translate="yes" xml:space="preserve">
          <source>Before Python 3.6, when printing a dict, Python did not guarantee that the key-value pairs was printed in any particular order.</source>
          <target state="translated">Python 3.6 이전에는 dict를 인쇄 할 때 키-값 쌍이 특정 순서로 인쇄되었음을 보증하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="46d337986d57f221ecbc2aaa26bd0ab430008b76" translate="yes" xml:space="preserve">
          <source>Before the end of the stream is reached, this will be &lt;code&gt;b&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">스트림의 끝에 도달하기 전에 &lt;code&gt;b&quot;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48c0f47c1261299c0864a67fc685c6a3005db48e" translate="yes" xml:space="preserve">
          <source>Before we move on calling functions with other parameter types, we have to learn more about &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; data types.</source>
          <target state="translated">다른 매개 변수 유형을 사용하여 함수를 호출하기 전에 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 데이터 유형 에 대해 자세히 학습해야합니다 .</target>
        </trans-unit>
        <trans-unit id="483be28c0eaadf9f1aa628c534f11b5e079a5451" translate="yes" xml:space="preserve">
          <source>Before you can write to or read from an audio device, you must call three methods in the correct order:</source>
          <target state="translated">오디오 장치에 쓰거나 읽 기 전에 올바른 순서로 세 가지 방법을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c68a6e6a64dac6bce2f425b8bf2ec3d1606a381e" translate="yes" xml:space="preserve">
          <source>Beg (beginning)</source>
          <target state="translated">구걸 (시작)</target>
        </trans-unit>
        <trans-unit id="40f9d4d10702ae8642d1d7383cb9d28d940dec80" translate="yes" xml:space="preserve">
          <source>Begin autoincrement mode: schedules a recurring timer event that calls &lt;a href=&quot;#tkinter.ttk.Progressbar.step&quot;&gt;&lt;code&gt;Progressbar.step()&lt;/code&gt;&lt;/a&gt; every &lt;em&gt;interval&lt;/em&gt; milliseconds. If omitted, &lt;em&gt;interval&lt;/em&gt; defaults to 50 milliseconds.</source>
          <target state="translated">자동 증가 모드 시작 : &lt;em&gt;간격 (&lt;/em&gt; 밀리 초 &lt;a href=&quot;#tkinter.ttk.Progressbar.step&quot;&gt; &lt;code&gt;Progressbar.step()&lt;/code&gt; &lt;/a&gt; 마다 Progressbar.step () 을 호출하는 반복 타이머 이벤트를 예약합니다 . 생략하면 &lt;em&gt;interval의&lt;/em&gt; 기본값은 50 밀리 초입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1fa1a5c3ae45577ab117ab821ac5874e521c6ac6" translate="yes" xml:space="preserve">
          <source>Begin by writing &lt;code&gt;import cgi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import cgi&lt;/code&gt; 를 작성하여 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="d21290f4ef30d771e174960f4bd7877417e7b443" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping.</source>
          <target state="translated">접두사 URI 네임 스페이스 매핑의 범위를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="df80a1098d80f4a77aa0c5fa9359c3f1b5d396a4" translate="yes" xml:space="preserve">
          <source>Behavior is the same as in &lt;a href=&quot;threading#threading.Lock.release&quot;&gt;&lt;code&gt;threading.Lock.release()&lt;/code&gt;&lt;/a&gt; except that when invoked on an unlocked lock, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">동작은 잠금 해제 된 잠금에서 호출 될 때 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 라는 점을 제외하고 &lt;a href=&quot;threading#threading.Lock.release&quot;&gt; &lt;code&gt;threading.Lock.release()&lt;/code&gt; &lt;/a&gt; 동일합니다. 가 발생 .</target>
        </trans-unit>
        <trans-unit id="aa8a60766ac333f80dc11610250a1865830afb33" translate="yes" xml:space="preserve">
          <source>Behind the scenes, the &lt;a href=&quot;#ctypes.pointer&quot;&gt;&lt;code&gt;pointer()&lt;/code&gt;&lt;/a&gt; function does more than simply create pointer instances, it has to create pointer &lt;em&gt;types&lt;/em&gt; first. This is done with the &lt;a href=&quot;#ctypes.POINTER&quot;&gt;&lt;code&gt;POINTER()&lt;/code&gt;&lt;/a&gt; function, which accepts any &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; type, and returns a new type:</source>
          <target state="translated">배후에서, &lt;a href=&quot;#ctypes.pointer&quot;&gt; &lt;code&gt;pointer()&lt;/code&gt; &lt;/a&gt; 함수는 단순히 포인터 인스턴스를 만드는 것보다 먼저 포인터 &lt;em&gt;유형&lt;/em&gt; 을 만들어야 합니다. 이것은 모든 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 을 허용 하는 &lt;a href=&quot;#ctypes.POINTER&quot;&gt; &lt;code&gt;POINTER()&lt;/code&gt; &lt;/a&gt; 함수 로 수행됩니다. 유형 하고 새로운 유형을 반환하는 .</target>
        </trans-unit>
        <trans-unit id="bca285402106aa0f0f7b601a2f8df4f157534b63" translate="yes" xml:space="preserve">
          <source>Being able to tell if a line of input completes a Python statement: in short, telling whether to print &amp;lsquo;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&amp;rsquo; or &amp;lsquo;&lt;code&gt;...&lt;/code&gt;&amp;rsquo; next.</source>
          <target state="translated">입력 줄이 파이썬 문장을 완성하는지 알 수 있음 : 간단히 말해서 ' &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; '또는 ' &lt;code&gt;...&lt;/code&gt; '다음.</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="f8c124cc977ebefe3c2c86720bb514be851e243e" translate="yes" xml:space="preserve">
          <source>Below are some examples of typical usage of the &lt;a href=&quot;#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다음은 &lt;a href=&quot;#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 의 일반적인 사용법에 대한 몇 가지 예입니다. 모듈 .</target>
        </trans-unit>
        <trans-unit id="5d357b659dbe283278a24199979dd7871083127a" translate="yes" xml:space="preserve">
          <source>Below is a table mapping various &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; functions to their corresponding &lt;a href=&quot;#pathlib.PurePath&quot;&gt;&lt;code&gt;PurePath&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#pathlib.Path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; equivalent.</source>
          <target state="translated">아래는 다양한 &lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 함수를 해당하는 &lt;a href=&quot;#pathlib.PurePath&quot;&gt; &lt;code&gt;PurePath&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#pathlib.Path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 해당 항목에 매핑하는 표 입니다.</target>
        </trans-unit>
        <trans-unit id="ab4a051ee0b5f6099448f93c169d9e07992b08e7" translate="yes" xml:space="preserve">
          <source>Below is an example session with logging turned on:</source>
          <target state="translated">다음은 로깅이 설정된 세션 예입니다.</target>
        </trans-unit>
        <trans-unit id="a1129a8f113198207df5b47176143371497861ab" translate="yes" xml:space="preserve">
          <source>Below is an example where a number of ctypes objects are modified by a child process:</source>
          <target state="translated">다음은 많은 ctypes 객체가 자식 프로세스에 의해 수정되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="3e802043d7d026781c9db6d85cb3061d11ca8b23" translate="yes" xml:space="preserve">
          <source>Besides the methods described below, the &lt;code&gt;ttk.Widget&lt;/code&gt; supports the methods &lt;code&gt;tkinter.Widget.cget()&lt;/code&gt; and &lt;code&gt;tkinter.Widget.configure()&lt;/code&gt;.</source>
          <target state="translated">아래에 설명 된 메소드 외에도 &lt;code&gt;ttk.Widget&lt;/code&gt; 은 &lt;code&gt;tkinter.Widget.cget()&lt;/code&gt; 및 &lt;code&gt;tkinter.Widget.configure()&lt;/code&gt; 메소드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2e1367870fdc44f776287e47700c866b325754e2" translate="yes" xml:space="preserve">
          <source>Besides the methods inherited from &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt;&lt;code&gt;Widget&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;Widget.cget()&lt;/code&gt;, &lt;code&gt;Widget.configure()&lt;/code&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt;&lt;code&gt;Widget.identify()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt;&lt;code&gt;Widget.instate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt;&lt;code&gt;Widget.state()&lt;/code&gt;&lt;/a&gt;, and the following inherited from &lt;code&gt;Entry&lt;/code&gt;: &lt;code&gt;Entry.bbox()&lt;/code&gt;, &lt;code&gt;Entry.delete()&lt;/code&gt;, &lt;code&gt;Entry.icursor()&lt;/code&gt;, &lt;code&gt;Entry.index()&lt;/code&gt;, &lt;code&gt;Entry.insert()&lt;/code&gt;, &lt;code&gt;Entry.selection()&lt;/code&gt;, &lt;code&gt;Entry.xview()&lt;/code&gt;, it has some other methods, described at &lt;code&gt;ttk.Combobox&lt;/code&gt;.</source>
          <target state="translated">로부터 상속 된 메소드 이외에 &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt; &lt;code&gt;Widget&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;Widget.cget()&lt;/code&gt; , &lt;code&gt;Widget.configure()&lt;/code&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt; &lt;code&gt;Widget.identify()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt; &lt;code&gt;Widget.instate()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt; &lt;code&gt;Widget.state()&lt;/code&gt; &lt;/a&gt; , 상기로부터 상속 다음 &lt;code&gt;Entry&lt;/code&gt; : &lt;code&gt;Entry.bbox()&lt;/code&gt; , &lt;code&gt;Entry.delete()&lt;/code&gt; , &lt;code&gt;Entry.icursor()&lt;/code&gt; , &lt;code&gt;Entry.index()&lt;/code&gt; , &lt;code&gt;Entry.insert()&lt;/code&gt; , &lt;code&gt;Entry.selection()&lt;/code&gt; , &lt;code&gt;Entry.xview()&lt;/code&gt; 에는 &lt;code&gt;ttk.Combobox&lt;/code&gt; 에 설명 된 다른 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f831523d7c6cadde7e0cb39c81a22ba24bb9ec" translate="yes" xml:space="preserve">
          <source>Besides the methods inherited from &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt;&lt;code&gt;Widget&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;Widget.cget()&lt;/code&gt;, &lt;code&gt;Widget.configure()&lt;/code&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt;&lt;code&gt;Widget.identify()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt;&lt;code&gt;Widget.instate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt;&lt;code&gt;Widget.state()&lt;/code&gt;&lt;/a&gt;, and the following inherited from &lt;code&gt;Entry&lt;/code&gt;: &lt;code&gt;Entry.bbox()&lt;/code&gt;, &lt;code&gt;Entry.delete()&lt;/code&gt;, &lt;code&gt;Entry.icursor()&lt;/code&gt;, &lt;code&gt;Entry.index()&lt;/code&gt;, &lt;code&gt;Entry.insert()&lt;/code&gt;, &lt;code&gt;Entry.xview()&lt;/code&gt;, it has some other methods, described at &lt;code&gt;ttk.Spinbox&lt;/code&gt;.</source>
          <target state="translated">로부터 상속 된 메소드 이외에 &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt; &lt;code&gt;Widget&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;Widget.cget()&lt;/code&gt; , &lt;code&gt;Widget.configure()&lt;/code&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt; &lt;code&gt;Widget.identify()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt; &lt;code&gt;Widget.instate()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt; &lt;code&gt;Widget.state()&lt;/code&gt; &lt;/a&gt; , 상기로부터 상속 다음 &lt;code&gt;Entry&lt;/code&gt; : &lt;code&gt;Entry.bbox()&lt;/code&gt; , &lt;code&gt;Entry.delete()&lt;/code&gt; , &lt;code&gt;Entry.icursor()&lt;/code&gt; , &lt;code&gt;Entry.index()&lt;/code&gt; , &lt;code&gt;Entry.insert()&lt;/code&gt; , &lt;code&gt;Entry.xview()&lt;/code&gt; 에는 &lt;code&gt;ttk.Spinbox&lt;/code&gt; 에 설명 된 다른 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3ff9eb01f9273b0084e00951f1623a111bedef" translate="yes" xml:space="preserve">
          <source>Besides, only the main thread is allowed to set a new signal handler.</source>
          <target state="translated">게다가 메인 스레드 만이 새로운 시그널 핸들러를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf8d3be729847deb19b6a44bdd74975d6befe47c" translate="yes" xml:space="preserve">
          <source>Besides, the &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; method does not have a default implementation that defers to &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt;&lt;code&gt;readinto()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게다가, &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 메소드에는 &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt; &lt;code&gt;readinto()&lt;/code&gt; &lt;/a&gt; 를 연기하는 기본 구현이 없습니다. .</target>
        </trans-unit>
        <trans-unit id="e83a3ab69e9fd0abbfb55d96374f52bcbc103b5f" translate="yes" xml:space="preserve">
          <source>Best defaults</source>
          <target state="translated">최선의 기본값</target>
        </trans-unit>
        <trans-unit id="a5e1caaf3a558a5215965e11aae5b2c42a62435b" translate="yes" xml:space="preserve">
          <source>Best practice is to omit the traceback stack, unless it adds significant documentation value to the example. So the last example is probably better as:</source>
          <target state="translated">모범 사례 값이 예제에 추가되지 않는 한 역 추적 스택을 생략하는 것이 가장 좋습니다. 따라서 마지막 예는 다음과 같이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb8df3d1388d60aad85d2be198e574d70525685d" translate="yes" xml:space="preserve">
          <source>Beta distribution. Conditions on the parameters are &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt; and &lt;code&gt;beta &amp;gt; 0&lt;/code&gt;. Returned values range between 0 and 1.</source>
          <target state="translated">베타 배포. 매개 변수의 조건은 &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt; 및 &lt;code&gt;beta &amp;gt; 0&lt;/code&gt; 입니다. 반환 된 값의 범위는 0과 1입니다.</target>
        </trans-unit>
        <trans-unit id="d8ba6dd6cc0d2b6353ea52b89942547287c30fad" translate="yes" xml:space="preserve">
          <source>Better to inherit than pickle/unpickle</source>
          <target state="translated">피클 / 피클 링보다 상속하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="9c1dda353e343c24e7708a72b54529d23347826a" translate="yes" xml:space="preserve">
          <source>Between -999999999 and 999999999 inclusive</source>
          <target state="translated">-999999999 ~ 999999999 사이</target>
        </trans-unit>
        <trans-unit id="b6c74a472b928b3de7f142f2f611644179e766ce" translate="yes" xml:space="preserve">
          <source>Between 0 and 86399 inclusive</source>
          <target state="translated">0에서 86399 사이</target>
        </trans-unit>
        <trans-unit id="954ca93f131384b9558ca914d678c167bd92e718" translate="yes" xml:space="preserve">
          <source>Between 0 and 999999 inclusive</source>
          <target state="translated">0에서 999999 사이</target>
        </trans-unit>
        <trans-unit id="ed2cf7c590b6e7f609a00c26affc3a6e2749ead7" translate="yes" xml:space="preserve">
          <source>Between 1 and 12 inclusive.</source>
          <target state="translated">1에서 12 사이.</target>
        </trans-unit>
        <trans-unit id="08bfcd2e1cae8c1d62e31e45c7e3c998b88e587e" translate="yes" xml:space="preserve">
          <source>Between 1 and the number of days in the given month of the given year.</source>
          <target state="translated">1과 주어진 연도의 주어진 달의 일 수 사이.</target>
        </trans-unit>
        <trans-unit id="74437956ab6159c55badf4bbc91e7ad2175fad4e" translate="yes" xml:space="preserve">
          <source>Between &lt;a href=&quot;#datetime.MINYEAR&quot;&gt;&lt;code&gt;MINYEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.MAXYEAR&quot;&gt;&lt;code&gt;MAXYEAR&lt;/code&gt;&lt;/a&gt; inclusive.</source>
          <target state="translated">사이 &lt;a href=&quot;#datetime.MINYEAR&quot;&gt; &lt;code&gt;MINYEAR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.MAXYEAR&quot;&gt; &lt;code&gt;MAXYEAR&lt;/code&gt; &lt;/a&gt; 포괄적으로.</target>
        </trans-unit>
        <trans-unit id="4c36aee3637e0b2b5bfaa0e70a4ebeb4eee3c90f" translate="yes" xml:space="preserve">
          <source>Between the sending side and the receiving side, the communications system is free to implement its own transfer mechanism for out-of-band buffers. Potential optimizations include the use of shared memory or datatype-dependent compression.</source>
          <target state="translated">송신 측과 수신 측 사이에서, 통신 시스템은 대역 외 버퍼를위한 자체 전송 메커니즘을 자유롭게 구현할 수있다. 잠재적 인 최적화에는 공유 메모리 또는 데이터 유형 종속 압축 사용이 ​​포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc3aa2f92c76e508acf2bfaca08ad2ba1baa2d87" translate="yes" xml:space="preserve">
          <source>Beware of replacing &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; with a &amp;ldquo;file like object&amp;rdquo;</source>
          <target state="translated">&lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; 을&amp;ldquo;file like object&amp;rdquo; 로 바꾸지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c9a0688daec7baa0367d0ff67569d3d33eb4a71a" translate="yes" xml:space="preserve">
          <source>Beyond &lt;code&gt;sys.argv&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sys.argv&lt;/code&gt; 너머</target>
        </trans-unit>
        <trans-unit id="892bf0fc9ced21536073b10f72d8a317557e88d9" translate="yes" xml:space="preserve">
          <source>Binary Data</source>
          <target state="translated">이진 데이터</target>
        </trans-unit>
        <trans-unit id="74dc05f939b4de6df10ded1ad85cd87cf64bc9f7" translate="yes" xml:space="preserve">
          <source>Binary Data Services</source>
          <target state="translated">이진 데이터 서비스</target>
        </trans-unit>
        <trans-unit id="077a15b13db556c78b4bfbf28994d6f478f129e0" translate="yes" xml:space="preserve">
          <source>Binary I/O</source>
          <target state="translated">이진 I / O</target>
        </trans-unit>
        <trans-unit id="0c9ab2e214f4e3d68626fcb0f6f6f4976f56998f" translate="yes" xml:space="preserve">
          <source>Binary I/O (also called &lt;em&gt;buffered I/O&lt;/em&gt;) expects &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; and produces &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects. No encoding, decoding, or newline translation is performed. This category of streams can be used for all kinds of non-text data, and also when manual control over the handling of text data is desired.</source>
          <target state="translated">(또한 바이너리 I / O &lt;em&gt;버퍼 I / O는&lt;/em&gt; ) 기대 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;객체 바이트 - 같은&lt;/a&gt; 및 생산 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체. 인코딩, 디코딩 또는 개행 변환이 수행되지 않습니다. 이 범주의 스트림은 모든 종류의 텍스트가 아닌 데이터에 사용될 수 있으며 텍스트 데이터 처리를 수동으로 제어해야하는 경우에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d18c326fb8b019f2ba7dcc08e612917c6ba14d2" translate="yes" xml:space="preserve">
          <source>Binary Objects</source>
          <target state="translated">이진 객체</target>
        </trans-unit>
        <trans-unit id="9cf3342675aa01229892e963ccc770d42fd0df53" translate="yes" xml:space="preserve">
          <source>Binary Sequence Types &amp;mdash; &lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;memoryview&lt;/code&gt;</source>
          <target state="translated">이진 시퀀스 유형 &amp;mdash; &lt;code&gt;bytes&lt;/code&gt; , &lt;code&gt;bytearray&lt;/code&gt; , &lt;code&gt;memoryview&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5926a354af36f8d3a781a27eef2ef8a43ed8d3ed" translate="yes" xml:space="preserve">
          <source>Binary Sequence Types &amp;mdash; bytes, bytearray, memoryview</source>
          <target state="translated">이진 시퀀스 유형 &amp;mdash; 바이트, 바이트 배열, 메모 리뷰</target>
        </trans-unit>
        <trans-unit id="3926624312f99b7ac129db6c0c454a3ff48903bd" translate="yes" xml:space="preserve">
          <source>Binary Transforms</source>
          <target state="translated">이진 변환</target>
        </trans-unit>
        <trans-unit id="21fe5e3cd9c91723a039c52415394d9d03534dd3" translate="yes" xml:space="preserve">
          <source>Binary buffered objects (instances of &lt;a href=&quot;#io.BufferedReader&quot;&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedWriter&quot;&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedRandom&quot;&gt;&lt;code&gt;BufferedRandom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.BufferedRWPair&quot;&gt;&lt;code&gt;BufferedRWPair&lt;/code&gt;&lt;/a&gt;) are not reentrant. While reentrant calls will not happen in normal situations, they can arise from doing I/O in a &lt;a href=&quot;signal#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; handler. If a thread tries to re-enter a buffered object which it is already accessing, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised. Note this doesn&amp;rsquo;t prohibit a different thread from entering the buffered object.</source>
          <target state="translated">이진 버퍼링 된 객체 ( &lt;a href=&quot;#io.BufferedReader&quot;&gt; &lt;code&gt;BufferedReader&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedWriter&quot;&gt; &lt;code&gt;BufferedWriter&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedRandom&quot;&gt; &lt;code&gt;BufferedRandom&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.BufferedRWPair&quot;&gt; &lt;code&gt;BufferedRWPair&lt;/code&gt; 의&lt;/a&gt; 인스턴스 )는 재진입 할 ​​수 없습니다. 재진입 호출은 정상적인 상황에서는 발생하지 않지만 &lt;a href=&quot;signal#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 처리기 에서 I / O를 수행하면 발생할 수 있습니다 . 스레드가 이미 액세스중인 버퍼링 된 개체를 다시 입력하려고하면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 이것은 다른 스레드가 버퍼링 된 객체에 들어가는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4406f8baf70aa1a1308d895faa78af8d9e41d899" translate="yes" xml:space="preserve">
          <source>Binary buffered objects (instances of &lt;a href=&quot;#io.BufferedReader&quot;&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedWriter&quot;&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedRandom&quot;&gt;&lt;code&gt;BufferedRandom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.BufferedRWPair&quot;&gt;&lt;code&gt;BufferedRWPair&lt;/code&gt;&lt;/a&gt;) protect their internal structures using a lock; it is therefore safe to call them from multiple threads at once.</source>
          <target state="translated">이진 버퍼링 된 객체 ( &lt;a href=&quot;#io.BufferedReader&quot;&gt; &lt;code&gt;BufferedReader&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedWriter&quot;&gt; &lt;code&gt;BufferedWriter&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedRandom&quot;&gt; &lt;code&gt;BufferedRandom&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.BufferedRWPair&quot;&gt; &lt;code&gt;BufferedRWPair&lt;/code&gt; 의&lt;/a&gt; 인스턴스) )는 잠금을 사용하여 내부 구조를 보호합니다. 따라서 여러 스레드에서 한 번에 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="62f7f2783ce89c5bb6d5fe79cd3bd1c11179b462" translate="yes" xml:space="preserve">
          <source>Binary data in any form.</source>
          <target state="translated">모든 형태의 이진 데이터.</target>
        </trans-unit>
        <trans-unit id="b418b66c57a5a2313398824ab306a08b3b9421cc" translate="yes" xml:space="preserve">
          <source>Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device&amp;rsquo;s &amp;ldquo;block size&amp;rdquo; and falling back on &lt;a href=&quot;io#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;io.DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt;. On many systems, the buffer will typically be 4096 or 8192 bytes long.</source>
          <target state="translated">이진 파일은 고정 크기 청크로 버퍼링됩니다. 버퍼의 크기는 기본 장치의 &quot;블록 크기&quot;를 결정하고 &lt;a href=&quot;io#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;io.DEFAULT_BUFFER_SIZE&lt;/code&gt; 로&lt;/a&gt; 떨어지는 휴리스틱을 사용하여 선택됩니다 . 많은 시스템에서 버퍼의 길이는 일반적으로 4096 또는 8192 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="6b48357f7d4a42846626a5244d044b564edfcf86" translate="yes" xml:space="preserve">
          <source>Binary format. Outputs the number in base 2.</source>
          <target state="translated">이진 형식. 밑이 2 인 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="82f1ab06b67bdfb6757c6103375f928cf440f008" translate="yes" xml:space="preserve">
          <source>Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.</source>
          <target state="translated">이진 작업은 스택에서 스택 상단 (TOS)과 두 번째 최상위 스택 항목 (TOS1)을 제거합니다. 그들은 작업을 수행하고 결과를 다시 스택에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="343454e4d9b2acf169be0d953fb0fb79d39cb3cc" translate="yes" xml:space="preserve">
          <source>Binary operations that mix &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; instances with &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; return the type of the first operand. For example: &lt;code&gt;frozenset('ab') |
set('bc')&lt;/code&gt; returns an instance of &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이진 작업은 믹스 것을 &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 과 인스턴스 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 는&lt;/a&gt; 첫 번째 피연산자의 형태를 돌려줍니다. 예를 들면 다음과 같습니다. &lt;code&gt;frozenset('ab') | set('bc')&lt;/code&gt; 는 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1606bce466a3fb6e4e13c59af6b1a64d90c92104" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to key-press event of key if key is given, or to any key-press-event if no key is given. Remark: in order to be able to register key-events, TurtleScreen must have focus. (See method &lt;a href=&quot;#turtle.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">키가 주어진 경우 키 누르기 이벤트에 키를, 키가없는 경우 키 누르기 이벤트에 &lt;em&gt;재미&lt;/em&gt; 를 바인드하십시오 . 비고 : 주요 이벤트를 등록하려면 TurtleScreen에 포커스가 있어야합니다. &lt;a href=&quot;#turtle.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c360811010b1ba8b6a9cf0d69579acc60a3e6bac" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to key-release event of key. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, event bindings are removed. Remark: in order to be able to register key-events, TurtleScreen must have the focus. (See method &lt;a href=&quot;#turtle.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 키의 키 릴리스 이벤트. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 이벤트 바인딩이 제거됩니다. 비고 : 주요 이벤트를 등록하려면 TurtleScreen에 포커스가 있어야합니다. &lt;a href=&quot;#turtle.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88250fa997071f51f9a8c6f6b2b0aff6f79ab7aa" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-button-release events on this turtle. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed.</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 거북이에 마우스 버튼 릴리스 이벤트. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8981cb59d50b3e142bec1ed6694170c1d04c3e93" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-click events on this screen. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed.</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 화면에서 마우스 클릭 이벤트에. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="eae217269ecbcd53a0c67a6d42f2541196eef9ba" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-click events on this turtle. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed. Example for the anonymous turtle, i.e. the procedural way:</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 거북이에 마우스 클릭 이벤트에. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다. 익명의 거북이의 예, 즉 절차 적 방법 :</target>
        </trans-unit>
        <trans-unit id="f2c696385e54300e88da723431117d0a4a8e9d3c" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-move events on this turtle. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed.</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 거북이에 마우스 이동 이벤트. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8afe0450ccf1ed51bd4d76038ec0971fe964de5c" translate="yes" xml:space="preserve">
          <source>Bind a callback for the given event &lt;em&gt;sequence&lt;/em&gt; to the tag &lt;em&gt;tagname&lt;/em&gt;. When an event is delivered to an item, the callbacks for each of the item&amp;rsquo;s tags option are called.</source>
          <target state="translated">주어진 이벤트 &lt;em&gt;시퀀스&lt;/em&gt; 에 대한 콜백을 &lt;em&gt;tagname&lt;/em&gt; 태그에 바인딩합니다 . 이벤트가 항목에 전달되면 각 항목의 태그 옵션에 대한 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="62a0e995f722ce9bd473d6c69d16b2dc42dd47fe" translate="yes" xml:space="preserve">
          <source>Bind a unix socket, raising &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt;&lt;code&gt;unittest.SkipTest&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;exceptions#PermissionError&quot;&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;a href=&quot;exceptions#PermissionError&quot;&gt; &lt;code&gt;PermissionError&lt;/code&gt; &lt;/a&gt; 가 발생 하면 &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt; &lt;code&gt;unittest.SkipTest&lt;/code&gt; 를&lt;/a&gt; 발생시켜 유닉스 소켓을 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="3ec9eed3827520279516114577184ceeb4151b81" translate="yes" xml:space="preserve">
          <source>Bind bye() method to mouse clicks on the Screen.</source>
          <target state="translated">bye () 메서드를 화면에서 마우스 클릭에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="efbdacada9d39467e2d8f8e1aba79f1562fdc7db" translate="yes" xml:space="preserve">
          <source>Bind the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt; to the argument names of the Python function or method &lt;em&gt;func&lt;/em&gt;, as if it was called with them. For bound methods, bind also the first argument (typically named &lt;code&gt;self&lt;/code&gt;) to the associated instance. A dict is returned, mapping the argument names (including the names of the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; arguments, if any) to their values from &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt;. In case of invoking &lt;em&gt;func&lt;/em&gt; incorrectly, i.e. whenever &lt;code&gt;func(*args, **kwds)&lt;/code&gt; would raise an exception because of incompatible signature, an exception of the same type and the same or similar message is raised. For example:</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; 와 &lt;em&gt;kwds&lt;/em&gt; 를 &lt;em&gt;마치&lt;/em&gt; 파이썬 함수 나 메소드 &lt;em&gt;func&lt;/em&gt; 의 인수 이름에 바인딩 된 &lt;em&gt;것처럼&lt;/em&gt; 바인딩 합니다. 바인딩 된 메서드의 경우 첫 번째 인수 (일반적으로 &lt;code&gt;self&lt;/code&gt; )도 연결된 인스턴스에 바인딩 합니다. 인수 이름 ( &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 인수 의 이름 포함 )을 &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;kwds&lt;/em&gt; 의 값에 맵핑하여 dict가 리턴 됩니다. &lt;code&gt;func(*args, **kwds)&lt;/code&gt; 가 호환되지 않는 서명으로 인해 func (* args, ** kwds) 가 예외를 발생시킬 때마다 &lt;em&gt;func를&lt;/em&gt; 잘못 호출하는 경우 , 동일한 유형 및 동일하거나 유사한 메시지의 예외가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="466b061fcff1561dff2e7055a677ac36776d8605" translate="yes" xml:space="preserve">
          <source>Bind the &lt;em&gt;domain&lt;/em&gt; to &lt;em&gt;codeset&lt;/em&gt;, changing the encoding of byte strings returned by the &lt;a href=&quot;#gettext.lgettext&quot;&gt;&lt;code&gt;lgettext()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#gettext.ldgettext&quot;&gt;&lt;code&gt;ldgettext()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#gettext.lngettext&quot;&gt;&lt;code&gt;lngettext()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#gettext.ldngettext&quot;&gt;&lt;code&gt;ldngettext()&lt;/code&gt;&lt;/a&gt; functions. If &lt;em&gt;codeset&lt;/em&gt; is omitted, then the current binding is returned.</source>
          <target state="translated">&lt;a href=&quot;#gettext.lgettext&quot;&gt; &lt;code&gt;lgettext()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#gettext.ldgettext&quot;&gt; &lt;code&gt;ldgettext()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#gettext.lngettext&quot;&gt; &lt;code&gt;lngettext()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#gettext.ldngettext&quot;&gt; &lt;code&gt;ldngettext()&lt;/code&gt; &lt;/a&gt; 함수가 반환 한 바이트 문자열의 인코딩을 변경 하여 &lt;em&gt;도메인&lt;/em&gt; 을 &lt;em&gt;codeset에&lt;/em&gt; 바인딩합니다 . 경우 &lt;em&gt;코드 세트가&lt;/em&gt; 생략되어, 현재 반환 바인딩.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971f75ed3a8b9b21ee56302a74bf55b47cdbf22e" translate="yes" xml:space="preserve">
          <source>Bind the &lt;em&gt;domain&lt;/em&gt; to the locale directory &lt;em&gt;localedir&lt;/em&gt;. More concretely, &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; will look for binary &lt;code&gt;.mo&lt;/code&gt; files for the given domain using the path (on Unix): &lt;code&gt;&lt;em&gt;localedir&lt;/em&gt;/&lt;em&gt;language&lt;/em&gt;/LC_MESSAGES/&lt;em&gt;domain&lt;/em&gt;.mo&lt;/code&gt;, where &lt;em&gt;language&lt;/em&gt; is searched for in the environment variables &lt;code id=&quot;index-0&quot;&gt;LANGUAGE&lt;/code&gt;, &lt;code id=&quot;index-1&quot;&gt;LC_ALL&lt;/code&gt;, &lt;code id=&quot;index-2&quot;&gt;LC_MESSAGES&lt;/code&gt;, and &lt;code id=&quot;index-3&quot;&gt;LANG&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;도메인&lt;/em&gt; 을 로케일 디렉토리 &lt;em&gt;localedir에&lt;/em&gt; 바인드하십시오 . 보다 구체적으로 &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 는 경로 (유닉스에서)를 사용하여 지정된 도메인의 바이너리 &lt;code&gt;.mo&lt;/code&gt; 파일을 찾습니다 . &lt;code&gt;&lt;em&gt;localedir&lt;/em&gt;/&lt;em&gt;language&lt;/em&gt;/LC_MESSAGES/&lt;em&gt;domain&lt;/em&gt;.mo&lt;/code&gt; . 여기서 환경 변수 &lt;code id=&quot;index-0&quot;&gt;LANGUAGE&lt;/code&gt; , &lt;code id=&quot;index-1&quot;&gt;LC_ALL&lt;/code&gt; , &lt;code id=&quot;index-2&quot;&gt;LC_MESSAGES&lt;/code&gt; 및 &lt;code id=&quot;index-3&quot;&gt;LANG&lt;/code&gt; 에서 &lt;em&gt;언어&lt;/em&gt; 를 검색합니다. 각기.</target>
        </trans-unit>
        <trans-unit id="6ef7c31f3723921d8fdf4d1ae7e78f574951d17b" translate="yes" xml:space="preserve">
          <source>Bind the socket to &lt;em&gt;address&lt;/em&gt;. The socket must not already be bound. (The format of &lt;em&gt;address&lt;/em&gt; depends on the address family &amp;mdash; refer to the &lt;a href=&quot;socket#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; documentation for more information.) To mark the socket as re-usable (setting the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; option), call the &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;dispatcher&lt;/code&gt;&lt;/a&gt; object&amp;rsquo;s &lt;code&gt;set_reuse_addr()&lt;/code&gt; method.</source>
          <target state="translated">소켓을 &lt;em&gt;주소에&lt;/em&gt; 바인드하십시오 . 소켓이 이미 바인드되어 있지 않아야합니다. ( &lt;em&gt;주소&lt;/em&gt; 형식은 &lt;em&gt;주소&lt;/em&gt; 패밀리에 따라 다릅니다 . 자세한 내용 은 &lt;a href=&quot;socket#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.) 소켓을 재사용 가능으로 표시하려면 ( &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 옵션 설정 ) &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;dispatcher&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;code&gt;set_reuse_addr()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f4492e920673119f99caa126daf7111e8679ef" translate="yes" xml:space="preserve">
          <source>Bind the socket to &lt;em&gt;address&lt;/em&gt;. The socket must not already be bound. (The format of &lt;em&gt;address&lt;/em&gt; depends on the address family &amp;mdash; see above.)</source>
          <target state="translated">소켓을 &lt;em&gt;주소에&lt;/em&gt; 바인드하십시오 . 소켓이 이미 바인드되어 있지 않아야합니다. &lt;em&gt;주소&lt;/em&gt; 형식은 &lt;em&gt;주소&lt;/em&gt; 패밀리에 따라 다릅니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="de75e0400dc3db591ad5734f114577fa0875a522" translate="yes" xml:space="preserve">
          <source>Bind the socket to a free port and return the port number. Relies on ephemeral ports in order to ensure we are using an unbound port. This is important as many tests may be running simultaneously, especially in a buildbot environment. This method raises an exception if the &lt;code&gt;sock.family&lt;/code&gt; is &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sock.type&lt;/code&gt; is &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;, and the socket has &lt;code&gt;SO_REUSEADDR&lt;/code&gt; or &lt;code&gt;SO_REUSEPORT&lt;/code&gt; set on it. Tests should never set these socket options for TCP/IP sockets. The only case for setting these options is testing multicasting via multiple UDP sockets.</source>
          <target state="translated">소켓을 빈 포트에 바인딩하고 포트 번호를 반환하십시오. 언 바운드 포트를 사용하기 위해 임시 포트에 의존합니다. 많은 테스트가 동시에 빌드 봇 환경에서 동시에 실행될 수 있으므로 중요합니다. &lt;code&gt;sock.family&lt;/code&gt; 가 &lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;sock.type&lt;/code&gt; 이 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 이고 소켓에 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 또는 &lt;code&gt;SO_REUSEPORT&lt;/code&gt; 가 설정된 경우이 메소드는 예외를 발생시킵니다 . 테스트는 TCP / IP 소켓에 대해 이러한 소켓 옵션을 설정하지 않아야합니다. 이러한 옵션을 설정하는 유일한 경우는 여러 UDP 소켓을 통한 멀티 캐스팅을 테스트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1fd8b3b29ad1340858fecc05585a82b44392fdd8" translate="yes" xml:space="preserve">
          <source>Bindings and Events</source>
          <target state="translated">바인딩 및 이벤트</target>
        </trans-unit>
        <trans-unit id="f86116810e0f75c5cdd1a62f7f2104592005bc20" translate="yes" xml:space="preserve">
          <source>Bit fields in structures and unions</source>
          <target state="translated">구조와 공용체의 비트 필드</target>
        </trans-unit>
        <trans-unit id="320415496f3946f94011e0ced3cddcdc515c3da5" translate="yes" xml:space="preserve">
          <source>Bit-mask</source>
          <target state="translated">Bit-mask</target>
        </trans-unit>
        <trans-unit id="10b264ac40d76c9c94d3cc50bd7202a39865e32f" translate="yes" xml:space="preserve">
          <source>Bit-mask to extract a character</source>
          <target state="translated">문자를 추출하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="0b5b215b81a34d81da07b12a57a05ded49214f16" translate="yes" xml:space="preserve">
          <source>Bit-mask to extract attributes</source>
          <target state="translated">속성을 추출하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="2061b16edd78d2e593621fabec13afb636e32ce9" translate="yes" xml:space="preserve">
          <source>Bit-mask to extract color-pair field information</source>
          <target state="translated">색상 쌍 필드 정보를 추출하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">비트와</target>
        </trans-unit>
        <trans-unit id="5fef320a5b6e9f946d0c0be2f1804caae7326297" translate="yes" xml:space="preserve">
          <source>Bitwise Exclusive Or</source>
          <target state="translated">비트 단위 독점 또는</target>
        </trans-unit>
        <trans-unit id="92108ddfd25fd3b1ca3cfcbb1ac3acde1d93a1d2" translate="yes" xml:space="preserve">
          <source>Bitwise Inversion</source>
          <target state="translated">비트 반전</target>
        </trans-unit>
        <trans-unit id="c6d024785d8011a85a2c45a248d86ff4be52b077" translate="yes" xml:space="preserve">
          <source>Bitwise Operations on Integer Types</source>
          <target state="translated">정수 유형의 비트 단위 연산</target>
        </trans-unit>
        <trans-unit id="5b0861023775ab83f9aeb2c2b3492420398fae85" translate="yes" xml:space="preserve">
          <source>Bitwise Or</source>
          <target state="translated">비트 단위 또는</target>
        </trans-unit>
        <trans-unit id="2e17feeadb67d1865e9a3b140b95f9721af9f8fa" translate="yes" xml:space="preserve">
          <source>Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two&amp;rsquo;s complement with an infinite number of sign bits.</source>
          <target state="translated">비트 단위 연산은 정수에만 의미가 있습니다. 비트 단위 연산의 결과는 무한한 수의 부호 비트로 2의 보수로 수행되는 것처럼 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="b406fb57b29fc76f71864fbb37f0238045f84d9d" translate="yes" xml:space="preserve">
          <source>Black</source>
          <target state="translated">Black</target>
        </trans-unit>
        <trans-unit id="480135dda7d845bc82b347dfaa91bf347ee099af" translate="yes" xml:space="preserve">
          <source>Blink mode</source>
          <target state="translated">깜박임 모드</target>
        </trans-unit>
        <trans-unit id="cfbe395b6ff593ced03bac36c099d59799a6252c" translate="yes" xml:space="preserve">
          <source>Block device required</source>
          <target state="translated">필요한 블록 장치</target>
        </trans-unit>
        <trans-unit id="40f4277d9e2e9642b7c7082b91e613d62eab845f" translate="yes" xml:space="preserve">
          <source>Block device.</source>
          <target state="translated">장치를 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="2bb009addf624a9cc048897e81f81ead20e469bf" translate="yes" xml:space="preserve">
          <source>Block for &lt;em&gt;delay&lt;/em&gt; seconds.</source>
          <target state="translated">&lt;em&gt;지연 시간&lt;/em&gt; 동안 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="8fb197cebcc8478cf7165d9dc1e9b4feeed49cd6" translate="yes" xml:space="preserve">
          <source>Block until all items in the queue have been gotten and processed.</source>
          <target state="translated">대기열의 모든 항목을 가져 와서 처리 할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="5c76bb4026cbe07b72909b50d70c6d76ce00a1bf" translate="yes" xml:space="preserve">
          <source>Block until all items in the queue have been received and processed.</source>
          <target state="translated">대기열의 모든 항목이 수신되어 처리 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="4270873346fe4ac8413b26a31ec9f3e286371ccc" translate="yes" xml:space="preserve">
          <source>Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls &lt;a href=&quot;#threading.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; to set the flag to true, or until the optional timeout occurs.</source>
          <target state="translated">내부 플래그가 true가 될 때까지 차단하십시오. 시작시 내부 플래그가 true이면 즉시 리턴하십시오. 그렇지 않으면 다른 스레드가 &lt;a href=&quot;#threading.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 플래그를 true로 설정하거나 선택적 시간 종료가 발생할 때까지 차단 하십시오.</target>
        </trans-unit>
        <trans-unit id="d2058396a2147f5165863444e9ce5b13713a8108" translate="yes" xml:space="preserve">
          <source>Blocking (CPU-bound) code should not be called directly. For example, if a function performs a CPU-intensive calculation for 1 second, all concurrent asyncio Tasks and IO operations would be delayed by 1 second.</source>
          <target state="translated">블로킹 (CPU- 바운드) 코드는 직접 호출하면 안됩니다. 예를 들어, 함수가 1 초 동안 CPU를 많이 사용하는 계산을 수행하면 모든 동시 asyncio 작업 및 IO 작업이 1 초 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="323ffdcd95156ec320100a2972820824ccb6d91f" translate="yes" xml:space="preserve">
          <source>BlockingIOError</source>
          <target state="translated">BlockingIOError</target>
        </trans-unit>
        <trans-unit id="92a08db9399061aa0f5eacfe511b7a6126dc9df0" translate="yes" xml:space="preserve">
          <source>BlockingIOError.characters_written</source>
          <target state="translated">BlockingIOError.characters_written</target>
        </trans-unit>
        <trans-unit id="dddf0e18cab12f3c2b4594834412adc72d47d3d6" translate="yes" xml:space="preserve">
          <source>Blocks until all items in the queue have been gotten and processed.</source>
          <target state="translated">대기열의 모든 항목을 가져 와서 처리 할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="7d44bc449c2a26374800a503f10f3d8949505f40" translate="yes" xml:space="preserve">
          <source>Blue</source>
          <target state="translated">Blue</target>
        </trans-unit>
        <trans-unit id="15913dcb3fc24a61ba6adcc4afcd21df3d2a5af6" translate="yes" xml:space="preserve">
          <source>Body-encode the string &lt;em&gt;string&lt;/em&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;string을&lt;/em&gt; 본문으로 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="6718f0f90ac337fe59d6d08c1ec08dbb38b7cc92" translate="yes" xml:space="preserve">
          <source>Bold mode</source>
          <target state="translated">볼드 모드</target>
        </trans-unit>
        <trans-unit id="beddf259d4873df4879b851076af94752cb94065" translate="yes" xml:space="preserve">
          <source>Book by John Grayson (ISBN 1-884777-81-3).</source>
          <target state="translated">존 그레이슨 (ISBN 1-884777-81-3)이 예약 함.</target>
        </trans-unit>
        <trans-unit id="5deb34b87b8d065639971c2d9e0fede0fcbaa391" translate="yes" xml:space="preserve">
          <source>Book by John Ousterhout, the inventor of Tcl.</source>
          <target state="translated">Tcl의 발명가 인 John Ousterhout가 예약합니다.</target>
        </trans-unit>
        <trans-unit id="cba993e6c506a168367bd3edaf5e342b70b7db99" translate="yes" xml:space="preserve">
          <source>Book by Mark Lutz, has excellent coverage of Tkinter.</source>
          <target state="translated">마크 루츠 (Mark Lutz)가 예약했으며, Tkinter에 대한 뛰어난 커버리지를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b03cb2dbfc1444695bab06adfaeb141fdc235f" translate="yes" xml:space="preserve">
          <source>Book by Mark Roseman about building attractive and modern graphical user interfaces with Python and Tkinter.</source>
          <target state="translated">Python 및 Tkinter를 사용하여 매력적이고 현대적인 그래픽 사용자 인터페이스를 구축하는 방법에 대해 Mark Roseman이 예약하십시오.</target>
        </trans-unit>
        <trans-unit id="786bfd749778b9b25aa01178659c90f4e19011ff" translate="yes" xml:space="preserve">
          <source>Bookkeeping functions</source>
          <target state="translated">부기 기능</target>
        </trans-unit>
        <trans-unit id="f8a8b062c380ba221961a2f8e03c873f4208921d" translate="yes" xml:space="preserve">
          <source>Boolean Operations &amp;mdash; &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;</source>
          <target state="translated">부울 작업 - &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e36e8bd93b3ea3b4b742ce8bb2a6ec3b2ab721" translate="yes" xml:space="preserve">
          <source>Boolean Values</source>
          <target state="translated">부울 값</target>
        </trans-unit>
        <trans-unit id="88306a31305db52140bbd33e277c2a177ea102f3" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether or not the module&amp;rsquo;s &amp;ldquo;origin&amp;rdquo; attribute refers to a loadable location.</source>
          <target state="translated">모듈의 &quot;origin&quot;속성이로드 가능한 위치를 나타내는 지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="524796582178b3ce40400d6b1bce1725e41cb620" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the device has been closed.</source>
          <target state="translated">장치가 닫혔는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="7ae5f84c90d6d770c192b8c5eb2f83cd02192067" translate="yes" xml:space="preserve">
          <source>Boolean that should be set before &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.handle_one_request&quot;&gt;&lt;code&gt;handle_one_request()&lt;/code&gt;&lt;/a&gt; returns, indicating if another request may be expected, or if the connection should be shut down.</source>
          <target state="translated">&lt;a href=&quot;#http.server.BaseHTTPRequestHandler.handle_one_request&quot;&gt; &lt;code&gt;handle_one_request()&lt;/code&gt; &lt;/a&gt; 반환 되기 전에 설정해야하는 부울 로, 다른 요청이 필요한지 또는 연결을 종료해야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33269d07fca93166bdf65e0bd7b3092befe1aa4a" translate="yes" xml:space="preserve">
          <source>Boolean value of &lt;code&gt;Enum&lt;/code&gt; classes and members</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 클래스 및 멤버 의 부울 값</target>
        </trans-unit>
        <trans-unit id="cb62ebe2f6b3f6e458c9478ab40f08a930df3242" translate="yes" xml:space="preserve">
          <source>Boolean value that is normally &lt;code&gt;False&lt;/code&gt;, but is set to &lt;code&gt;True&lt;/code&gt; if an &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt;&lt;code&gt;enable()&lt;/code&gt;&lt;/a&gt; command is successfully issued for the &lt;code&gt;UTF8=ACCEPT&lt;/code&gt; capability.</source>
          <target state="translated">일반적으로 부울 값입니다 &lt;code&gt;False&lt;/code&gt; 하지만 설정되어 &lt;code&gt;True&lt;/code&gt; 는 IF &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt; &lt;code&gt;enable()&lt;/code&gt; &lt;/a&gt; 명령이 성공적으로 발행되어 &lt;code&gt;UTF8=ACCEPT&lt;/code&gt; 능력을.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
