<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="f1d67672f1befe30b1ea6b9c0e813f8ca041dc72" translate="yes" xml:space="preserve">
          <source>In most situations, however, there&amp;rsquo;s only one form control with a particular name in a form and then you expect and need only one value associated with this name. So you write a script containing for example this code:</source>
          <target state="translated">그러나 대부분의 상황에서는 양식에 특정 이름을 가진 양식 컨트롤이 하나뿐이므로이 이름과 관련된 값은 하나만 필요합니다. 따라서 다음 코드를 포함하는 스크립트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="183e56009447f48c5edb38c8e56a603f6df422c3" translate="yes" xml:space="preserve">
          <source>In most typical applications, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will take care of formatting and printing any usage or error messages. However, several formatting methods are available:</source>
          <target state="translated">대부분의 일반적인 응용 프로그램에서 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 사용 또는 오류 메시지의 형식을 지정하고 인쇄합니다. 그러나 몇 가지 형식 지정 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6110d599bf96dfc74514b0a56521412fa449261" translate="yes" xml:space="preserve">
          <source>In normal operation it should not be necessary to call this method explicitly. It is used to implement other methods and may be useful for testing private extensions.</source>
          <target state="translated">정상적인 작동에서는이 메소드를 명시 적으로 호출 할 필요가 없습니다. 다른 메소드를 구현하는 데 사용되며 개인용 확장을 테스트하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8321d4dc57900cf19439382b3532766a68fb010" translate="yes" xml:space="preserve">
          <source>In normal operation it should not be necessary to call this method explicitly. It will be implicitly called by the &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;sendmail()&lt;/code&gt;&lt;/a&gt; when necessary.</source>
          <target state="translated">정상적인 작동에서는이 메소드를 명시 적으로 호출 할 필요가 없습니다. 필요한 경우 &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;sendmail()&lt;/code&gt; &lt;/a&gt; 의해 암시 적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a16e8babf22923c28939e3500c17a67bb3cff77f" translate="yes" xml:space="preserve">
          <source>In order for a class to define its own copy implementation, it can define special methods &lt;code&gt;__copy__()&lt;/code&gt; and &lt;code&gt;__deepcopy__()&lt;/code&gt;. The former is called to implement the shallow copy operation; no additional arguments are passed. The latter is called to implement the deep copy operation; it is passed one argument, the &lt;code&gt;memo&lt;/code&gt; dictionary. If the &lt;code&gt;__deepcopy__()&lt;/code&gt; implementation needs to make a deep copy of a component, it should call the &lt;a href=&quot;#copy.deepcopy&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt; function with the component as first argument and the memo dictionary as second argument.</source>
          <target state="translated">클래스가 자체의 복사 구현을 정의하기 위해 특수 메소드 &lt;code&gt;__copy__()&lt;/code&gt; 및 &lt;code&gt;__deepcopy__()&lt;/code&gt; 정의 할 수 있습니다 . 전자는 얕은 복사 작업을 구현하기 위해 호출됩니다. 추가 인수는 전달되지 않습니다. 후자는 깊은 복사 작업을 구현하기 위해 호출됩니다. &lt;code&gt;memo&lt;/code&gt; 사전 이라는 하나의 인수가 전달 됩니다. 는 IF &lt;code&gt;__deepcopy__()&lt;/code&gt; 구현 필요 구성 요소의 전체 복사본을 만들기 위해, 그것은 호출해야 &lt;a href=&quot;#copy.deepcopy&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; &lt;/a&gt; 첫번째 인자와 두번째 인자로 메모 사전과 같은 구성 요소와 기능을.</target>
        </trans-unit>
        <trans-unit id="2e949fa3a8f8fff7c3917f737f8813ee6973dfb5" translate="yes" xml:space="preserve">
          <source>In order to correctly interoperate with the abstract base class machinery, the descriptor must identify itself as abstract using &lt;code&gt;__isabstractmethod__&lt;/code&gt;. In general, this attribute should be &lt;code&gt;True&lt;/code&gt; if any of the methods used to compose the descriptor are abstract. For example, Python&amp;rsquo;s built-in &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; does the equivalent of:</source>
          <target state="translated">추상 기본 클래스 기계와 올바르게 상호 작용하려면 설명 &lt;code&gt;__isabstractmethod__&lt;/code&gt; 사용하여 추상으로 식별해야합니다 . 디스크립터를 구성하는 데 사용 된 메소드가 추상적이면 이 속성은 일반적으로 &lt;code&gt;True&lt;/code&gt; 여야합니다 . 예를 들어 Python의 내장 &lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c467fc7d115d441ac819d2c9cc479eaeade84679" translate="yes" xml:space="preserve">
          <source>In order to find objects and their documentation, &lt;a href=&quot;#module-pydoc&quot;&gt;&lt;code&gt;pydoc&lt;/code&gt;&lt;/a&gt; imports the module(s) to be documented. Therefore, any code on module level will be executed on that occasion. Use an &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; guard to only execute code when a file is invoked as a script and not just imported.</source>
          <target state="translated">&lt;a href=&quot;#module-pydoc&quot;&gt; &lt;code&gt;pydoc&lt;/code&gt; &lt;/a&gt; 은 객체와 문서를 찾기 위해 문서화 할 모듈을 가져옵니다. 따라서 모듈 수준의 모든 코드가 해당 시점에 실행됩니다. 사용 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 파일을 바로 가져올 스크립트로 호출하고 있지 않을 때 가드는 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="397d9ba9a94e1a39ad054c3d3560e0518f095dd9" translate="yes" xml:space="preserve">
          <source>In order to prepare your code for I18N, you need to look at all the strings in your files. Any string that needs to be translated should be marked by wrapping it in &lt;code&gt;_('...')&lt;/code&gt; &amp;mdash; that is, a call to the function &lt;code&gt;_()&lt;/code&gt;. For example:</source>
          <target state="translated">I18N에 대한 코드를 준비하려면 파일의 모든 문자열을 확인해야합니다. 번역해야 할 문자열은 &lt;code&gt;_('...')&lt;/code&gt; 로 묶어서 표시해야합니다. 즉, &lt;code&gt;_()&lt;/code&gt; 함수를 호출합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a53010fccc6cd571ec768b9ab052d773d9305f6" translate="yes" xml:space="preserve">
          <source>In order to preserve backwards compatibility, enum values are also present in the &lt;a href=&quot;http.client#module-http.client&quot;&gt;&lt;code&gt;http.client&lt;/code&gt;&lt;/a&gt; module in the form of constants. The enum name is equal to the constant name (i.e. &lt;code&gt;http.HTTPStatus.OK&lt;/code&gt; is also available as &lt;code&gt;http.client.OK&lt;/code&gt;).</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해 열거 형 값도 상수 형식으로 &lt;a href=&quot;http.client#module-http.client&quot;&gt; &lt;code&gt;http.client&lt;/code&gt; &lt;/a&gt; 모듈에 있습니다. 상기 ENUM 이름 상수 이름과 동일하다 (즉 &lt;code&gt;http.HTTPStatus.OK&lt;/code&gt; 이 또한 가능 &lt;code&gt;http.client.OK&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="481a2a420e5dd7f44eee0da58267e4d5486f1e6a" translate="yes" xml:space="preserve">
          <source>In order to stop comparison from falling back to the default scheme of comparing object addresses, datetime comparison normally raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the other comparand isn&amp;rsquo;t also a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object. However, &lt;code&gt;NotImplemented&lt;/code&gt; is returned instead if the other comparand has a &lt;code&gt;timetuple()&lt;/code&gt; attribute. This hook gives other kinds of date objects a chance at implementing mixed-type comparison. If not, when a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object is compared to an object of a different type, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised unless the comparison is &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. The latter cases return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">비교가 객체 주소를 비교하는 기본 체계로 넘어가는 것을 막기 위해, 다른 비교가 또한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 가 아닌 경우 datetime 비교는 일반적으로 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다 . 그러나 &lt;code&gt;NotImplemented&lt;/code&gt; 는 다른 간 비교가 아니라 가지고 있다면 반환 &lt;code&gt;timetuple()&lt;/code&gt; 속성. 이 후크는 다른 종류의 날짜 개체에 혼합 형식 비교를 구현할 수있는 기회를 제공합니다. 그렇지 않으면 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체를 다른 유형의 객체와 비교할 때 비교가 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 가 아니면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 후자의 경우 각각 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="07c225cf30fe4108ef791e90675347d57b8d70e1" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;date1 &amp;lt; date2&lt;/code&gt; if and only if &lt;code&gt;date1.toordinal() &amp;lt;
date2.toordinal()&lt;/code&gt;. Date comparison raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the other comparand isn&amp;rsquo;t also a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; object. However, &lt;code&gt;NotImplemented&lt;/code&gt; is returned instead if the other comparand has a &lt;code&gt;timetuple()&lt;/code&gt; attribute. This hook gives other kinds of date objects a chance at implementing mixed-type comparison. If not, when a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; object is compared to an object of a different type, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised unless the comparison is &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. The latter cases return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">즉, &lt;code&gt;date1 &amp;lt; date2&lt;/code&gt; if and only if &lt;code&gt;date1.toordinal() &amp;lt; date2.toordinal()&lt;/code&gt; 입니다. 다른 비교 자가 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 개체 가 아닌 경우 날짜 비교에서 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 가&lt;/a&gt; 발생 합니다. 그러나 &lt;code&gt;NotImplemented&lt;/code&gt; 는 다른 간 비교가 아니라 가지고 있다면 반환 &lt;code&gt;timetuple()&lt;/code&gt; 속성. 이 후크는 다른 종류의 날짜 개체에 혼합 형식 비교를 구현할 수있는 기회를 제공합니다. 그렇지 않으면 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 객체를 다른 유형의 객체와 비교할 때 비교가 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 가 아니면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 후자의 경우 각각 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2c07f61ca6c800f6888e2710a82a85e90f50bcc3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;a href=&quot;#textwrap.fill&quot;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/a&gt; accepts exactly the same keyword arguments as &lt;a href=&quot;#textwrap.wrap&quot;&gt;&lt;code&gt;wrap()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;#textwrap.fill&quot;&gt; &lt;code&gt;fill()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#textwrap.wrap&quot;&gt; &lt;code&gt;wrap()&lt;/code&gt; &lt;/a&gt; 과 정확히 동일한 키워드 인수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="1fa9bd11ecdf21c870d5be8de14f439777d27d8a" translate="yes" xml:space="preserve">
          <source>In particularly, &lt;a href=&quot;#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; should be used in preference to the default pseudo-random number generator in the &lt;a href=&quot;random#module-random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; module, which is designed for modelling and simulation, not security or cryptography.</source>
          <target state="translated">특히, 보안 또는 암호화가 아닌 모델링 및 시뮬레이션을 위해 설계된 &lt;a href=&quot;random#module-random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 모듈 의 기본 의사 난수 생성기에 우선하여 &lt;a href=&quot;#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bed46a3402b9eb2783c1eff866fc79b96a61f33e" translate="yes" xml:space="preserve">
          <source>In previous versions &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; did not start the manager&amp;rsquo;s server process if it was not already started.</source>
          <target state="translated">이전 버전에서 &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 는 아직 시작되지 않은 경우 관리자의 서버 프로세스를 시작하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="24635c5fed7456cbfad369f24972f6f06dd072a4" translate="yes" xml:space="preserve">
          <source>In protocols 2 and newer, classes that implements the &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt;&lt;code&gt;__getnewargs_ex__()&lt;/code&gt;&lt;/a&gt; method can dictate the values passed to the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method upon unpickling. The method must return a pair &lt;code&gt;(args, kwargs)&lt;/code&gt; where &lt;em&gt;args&lt;/em&gt; is a tuple of positional arguments and &lt;em&gt;kwargs&lt;/em&gt; a dictionary of named arguments for constructing the object. Those will be passed to the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method upon unpickling.</source>
          <target state="translated">프로토콜 2 이상에서 &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt; &lt;code&gt;__getnewargs_ex__()&lt;/code&gt; &lt;/a&gt; 메소드 를 구현하는 클래스는 피클 링 해제시 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메소드에 전달 된 값을 지시 할 수 있습니다 . 이 메소드는 쌍 &lt;code&gt;(args, kwargs)&lt;/code&gt; 리턴해야합니다. 여기서 &lt;em&gt;args&lt;/em&gt; 는 위치 인수의 튜플이고 오브젝트를 구성하기 위해 명명 된 인수의 사전을 &lt;em&gt;kwargs&lt;/em&gt; 합니다. 언 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메소드 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="6463b988a254956fa89396a7c22c32f2fa351eb6" translate="yes" xml:space="preserve">
          <source>In regular release builds, the default warning filter has the following entries (in order of precedence):</source>
          <target state="translated">정식 릴리스 빌드에서 기본 경고 필터에는 다음과 같은 항목이 있습니다 (우선 순위).</target>
        </trans-unit>
        <trans-unit id="197d3ed98970db4c06270429cf9d72971fdb552f" translate="yes" xml:space="preserve">
          <source>In server mode, a client certificate request is sent to the client. The client may either ignore the request or send a certificate in order perform TLS client cert authentication. If the client chooses to send a certificate, it is verified. Any verification error immediately aborts the TLS handshake.</source>
          <target state="translated">서버 모드에서 클라이언트 인증서 요청이 클라이언트로 전송됩니다. 클라이언트는 TLS 클라이언트 인증서 인증을 수행하기 위해 요청을 무시하거나 인증서를 보낼 수 있습니다. 클라이언트가 인증서를 보내도록 선택하면 확인됩니다. 확인 오류가 있으면 TLS 핸드 셰이크가 즉시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="784d3051d9c6418372556580d85a0525b4b27c71" translate="yes" xml:space="preserve">
          <source>In server mode, if you want to authenticate your clients using the SSL layer (rather than using a higher-level authentication mechanism), you&amp;rsquo;ll also have to specify &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and similarly check the client certificate.</source>
          <target state="translated">서버 모드에서 상위 수준의 인증 메커니즘을 사용하지 않고 SSL 계층을 사용하여 클라이언트를 인증하려는 경우 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 를 지정 하고 마찬가지로 클라이언트 인증서를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fcdfdefb8a40ad8a9c6f3c87a3f6215890319ef" translate="yes" xml:space="preserve">
          <source>In server mode, no certificate is requested from the client, so the client does not send any for client cert authentication.</source>
          <target state="translated">서버 모드에서는 클라이언트에서 인증서를 요청하지 않으므로 클라이언트는 클라이언트 인증서 인증을 위해 아무 것도 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2aaa992863bbf78157aa977a683358ca504509cc" translate="yes" xml:space="preserve">
          <source>In short, those are: a conversion to &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;math#math.trunc&quot;&gt;&lt;code&gt;math.trunc()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;math#math.floor&quot;&gt;&lt;code&gt;math.floor()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;math#math.ceil&quot;&gt;&lt;code&gt;math.ceil()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#divmod&quot;&gt;&lt;code&gt;divmod()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">간단히 말하면 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;math#math.trunc&quot;&gt; &lt;code&gt;math.trunc()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;math#math.floor&quot;&gt; &lt;code&gt;math.floor()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;math#math.ceil&quot;&gt; &lt;code&gt;math.ceil()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#divmod&quot;&gt; &lt;code&gt;divmod()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31dcfc591206e9e4f3d38c565f3b33cf822b6daf" translate="yes" xml:space="preserve">
          <source>In single threaded environments, it is preferable to not use this context at all. Instead, simply create contexts explicitly as described below.</source>
          <target state="translated">단일 스레드 환경에서는이 컨텍스트를 전혀 사용하지 않는 것이 좋습니다. 대신 아래에 설명 된대로 컨텍스트를 명시 적으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="828ef2d26cdb8bf2d36789116eed3ec4cdddbe9d" translate="yes" xml:space="preserve">
          <source>In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are signed, but 8 bit samples are unsigned. So when converting to 8 bit wide samples for these formats, you need to also add 128 to the result:</source>
          <target state="translated">.WAV 파일과 같은 일부 오디오 형식에서는 16, 24 및 32 비트 샘플이 서명되지만 8 비트 샘플은 서명되지 않습니다. 따라서 이러한 형식의 8 비트 폭 샘플로 변환 할 때 결과에 ​​128을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="b38f289e088de73aef52f5145e4194895bf3fc55" translate="yes" xml:space="preserve">
          <source>In some cases, it is desirable not to parse an input source at once, but to feed chunks of the document as they get available. Note that the reader will normally not read the entire file, but read it in chunks as well; still &lt;code&gt;parse()&lt;/code&gt; won&amp;rsquo;t return until the entire document is processed. So these interfaces should be used if the blocking behaviour of &lt;code&gt;parse()&lt;/code&gt; is not desirable.</source>
          <target state="translated">경우에 따라 입력 소스를 한 번에 구문 분석하지 않고 사용 가능한 문서 청크를 공급하는 것이 바람직합니다. 독자는 일반적으로 전체 파일을 읽지 않고 덩어리로 읽습니다. 여전히 전체 문서가 처리 될 때까지 &lt;code&gt;parse()&lt;/code&gt; 가 반환되지 않습니다. 따라서 &lt;code&gt;parse()&lt;/code&gt; 의 블로킹 동작이 바람직하지 않은 경우 이러한 인터페이스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4d666daec390d8674c0e643958a689e1dd07bc25" translate="yes" xml:space="preserve">
          <source>In some cases, it may be appropriate to process part of a request synchronously, but to finish processing in a forked child depending on the request data. This can be implemented by using a synchronous server and doing an explicit fork in the request handler class &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt;&lt;code&gt;handle()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우에 따라 요청의 일부를 동 기적으로 처리하는 것이 좋지만 요청 데이터에 따라 분기 된 하위에서 처리를 완료하는 것이 적절할 수 있습니다. 이는 동기 서버를 사용하고 요청 핸들러 클래스 &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt; &lt;code&gt;handle()&lt;/code&gt; &lt;/a&gt; 메소드 에서 명시 적 포크를 수행하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0c333efd73cd8e595b6e8b60656420e48337e96" translate="yes" xml:space="preserve">
          <source>In some cases, the existing tests may have been written using the &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; module. If so, &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; provides a &lt;code&gt;DocTestSuite&lt;/code&gt; class that can automatically build &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; instances from the existing &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt;-based tests.</source>
          <target state="translated">경우에 따라 기존 테스트가 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 작성되었을 수 있습니다 . 그렇다면 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 기존 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 기반 테스트 에서 &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스를 자동으로 빌드 할 수 있는 &lt;code&gt;DocTestSuite&lt;/code&gt; 클래스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="13ca056dd65f97d35e7322d84682a7bdc64b0f33" translate="yes" xml:space="preserve">
          <source>In some contexts, the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module is used to transfer massive amounts of data. Therefore, it can be important to minimize the number of memory copies, to preserve performance and resource consumption. However, normal operation of the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module, as it transforms a graph-like structure of objects into a sequential stream of bytes, intrinsically involves copying data to and from the pickle stream.</source>
          <target state="translated">일부 상황에서 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 대량의 데이터를 전송하는 데 사용됩니다. 따라서 성능 및 자원 소비를 유지하기 위해 메모리 사본 수를 최소화하는 것이 중요 할 수 있습니다. 그러나 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈 의 정상적인 작동은 그래프와 같은 객체 구조를 순차적 인 바이트 스트림으로 변환하기 때문에 본질적으로 피클 스트림과 데이터를 복사하는 작업을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="762bcb14ce3c58747a56f114dd90a102eeed2096" translate="yes" xml:space="preserve">
          <source>In string-type &lt;em&gt;repl&lt;/em&gt; arguments, in addition to the character escapes and backreferences described above, &lt;code&gt;\g&amp;lt;name&amp;gt;&lt;/code&gt; will use the substring matched by the group named &lt;code&gt;name&lt;/code&gt;, as defined by the &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; syntax. &lt;code&gt;\g&amp;lt;number&amp;gt;&lt;/code&gt; uses the corresponding group number; &lt;code&gt;\g&amp;lt;2&amp;gt;&lt;/code&gt; is therefore equivalent to &lt;code&gt;\2&lt;/code&gt;, but isn&amp;rsquo;t ambiguous in a replacement such as &lt;code&gt;\g&amp;lt;2&amp;gt;0&lt;/code&gt;. &lt;code&gt;\20&lt;/code&gt; would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character &lt;code&gt;'0'&lt;/code&gt;. The backreference &lt;code&gt;\g&amp;lt;0&amp;gt;&lt;/code&gt; substitutes in the entire substring matched by the RE.</source>
          <target state="translated">문자열 유형의 &lt;em&gt;repl&lt;/em&gt; 인수에서 위에 설명 된 문자 이스케이프 및 역 참조 외에도 &lt;code&gt;\g&amp;lt;name&amp;gt;&lt;/code&gt; 은 &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 구문에 정의 된대로 &lt;code&gt;name&lt;/code&gt; 이라는 그룹과 일치하는 하위 문자열을 사용 합니다. &lt;code&gt;\g&amp;lt;number&amp;gt;&lt;/code&gt; 는 해당 그룹 번호를 사용합니다. 따라서 &lt;code&gt;\g&amp;lt;2&amp;gt;&lt;/code&gt; 는 &lt;code&gt;\2&lt;/code&gt; 와 동일 하지만 &lt;code&gt;\g&amp;lt;2&amp;gt;0&lt;/code&gt; 과 같은 대체에서는 모호하지 않습니다 . &lt;code&gt;\20&lt;/code&gt; 은 그룹 2에 대한 참조가 아니라 리터럴 문자 &lt;code&gt;'0'&lt;/code&gt; 이 아닌 그룹 20에 대한 참조로 해석됩니다 . 역 참조 &lt;code&gt;\g&amp;lt;0&amp;gt;&lt;/code&gt; 은 RE와 일치하는 전체 하위 문자열을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="91032350df9be823abddd9974a0ded34862f00b1" translate="yes" xml:space="preserve">
          <source>In the Python DOM API, accessor functions are not required. If provided, they should take the form defined by the Python IDL mapping, but these methods are considered unnecessary since the attributes are accessible directly from Python. &amp;ldquo;Set&amp;rdquo; accessors should never be provided for &lt;code&gt;readonly&lt;/code&gt; attributes.</source>
          <target state="translated">Python DOM API에서는 접근 자 함수가 필요하지 않습니다. 제공되는 경우 Python IDL 맵핑으로 정의 된 양식을 가져야하지만 속성은 Python에서 직접 액세스 할 수 있으므로 이러한 메소드는 불필요한 것으로 간주됩니다. &lt;code&gt;readonly&lt;/code&gt; 속성에 대해서는 &quot;Set&quot;접근자를 제공해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e4271bc7aa921a4604f70acbcc32e5e1ad1a872" translate="yes" xml:space="preserve">
          <source>In the Python use of certificates, a client or server can use a certificate to prove who they are. The other side of a network connection can also be required to produce a certificate, and that certificate can be validated to the satisfaction of the client or server that requires such validation. The connection attempt can be set to raise an exception if the validation fails. Validation is done automatically, by the underlying OpenSSL framework; the application need not concern itself with its mechanics. But the application does usually need to provide sets of certificates to allow this process to take place.</source>
          <target state="translated">Python에서 인증서를 사용할 때 클라이언트 또는 서버는 인증서를 사용하여 인증서를 사용할 수 있습니다. 네트워크 연결의 다른 쪽에서도 인증서를 생성해야 할 수 있으며 해당 유효성 검사가 필요한 클라이언트 나 서버가 만족할 수 있도록 해당 인증서의 유효성을 검사 할 수 있습니다. 유효성 검사에 실패하면 연결 시도에서 예외가 발생하도록 설정할 수 있습니다. 검증은 기본 OpenSSL 프레임 워크에 의해 자동으로 수행됩니다. 응용 프로그램 자체의 메커니즘과 관련이있을 필요는 없습니다. 그러나 응용 프로그램은 일반적으로이 프로세스를 수행 할 수 있도록 인증서 세트를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="54b6896bea707355902a22e27a3a48a322ff4f93" translate="yes" xml:space="preserve">
          <source>In the UTF-8 mode, the encoding is &lt;code&gt;utf-8&lt;/code&gt; on any platform.</source>
          <target state="translated">UTF-8 모드에서 인코딩은 모든 플랫폼에서 &lt;code&gt;utf-8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cee2bffb2eb3a640bd33edd4c2273abf15d7944e" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;em&gt;MandatoryRelease&lt;/em&gt; that has not yet occurred, &lt;em&gt;MandatoryRelease&lt;/em&gt; predicts the release in which the feature will become part of the language.</source>
          <target state="translated">아직 발생하지 않은 &lt;em&gt;MandatoryRelease&lt;/em&gt; 의 경우 &lt;em&gt;MandatoryRelease&lt;/em&gt; 는 기능이 언어의 일부가 될 릴리스를 예측합니다.</target>
        </trans-unit>
        <trans-unit id="b18036aece5d58aa31914b030641e2dd49980e5c" translate="yes" xml:space="preserve">
          <source>In the case of {}-formatting, you can specify formatting flags by placing them after the attribute name, separated from it with a colon. For example: a placeholder of &lt;code&gt;{msecs:03d}&lt;/code&gt; would format a millisecond value of &lt;code&gt;4&lt;/code&gt; as &lt;code&gt;004&lt;/code&gt;. Refer to the &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; documentation for full details on the options available to you.</source>
          <target state="translated">{} 형식화의 경우 속성 이름 뒤에 콜론으로 구분하여 배치하여 형식화 플래그를 지정할 수 있습니다. 예를 들어 자리 표시 자 &lt;code&gt;{msecs:03d}&lt;/code&gt; 는 밀리 초 값 &lt;code&gt;4&lt;/code&gt; 를 &lt;code&gt;004&lt;/code&gt; 형식으로 지정합니다 . 사용 가능한 옵션에 대한 자세한 내용 은 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de630fdc03f685b1b1a89c3374aa3f0cc3e42c5" translate="yes" xml:space="preserve">
          <source>In the case where the metadata file listing files (RECORD or SOURCES.txt) is missing, &lt;code&gt;files()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The caller may wish to wrap calls to &lt;code&gt;files()&lt;/code&gt; in &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable&quot;&gt;always_iterable&lt;/a&gt; or otherwise guard against this condition if the target distribution is not known to have the metadata present.</source>
          <target state="translated">메타 데이터 파일 목록 파일 (RECORD 또는 SOURCES.txt)이 누락 된 경우 &lt;code&gt;files()&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다. 호출자는 &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable&quot;&gt;always_iterable&lt;/a&gt; 에서 &lt;code&gt;files()&lt;/code&gt; 에 대한 호출을 랩핑 하거나 대상 배포에 메타 데이터가없는 것으로 알려진 경우이 조건을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1e2dbd142a208749274bd7580c8ed640f3d885" translate="yes" xml:space="preserve">
          <source>In the default Task implementation, the name will be visible in the &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; output of a task object.</source>
          <target state="translated">기본 작업 구현에서 이름은 작업 객체 의 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 출력에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="535fa5a6ec217819ca7ba659179db533e7a167c0" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; with &lt;em&gt;interpolation&lt;/em&gt; set to &lt;code&gt;BasicInterpolation()&lt;/code&gt; would resolve &lt;code&gt;%(home_dir)s&lt;/code&gt; to the value of &lt;code&gt;home_dir&lt;/code&gt; (&lt;code&gt;/Users&lt;/code&gt; in this case). &lt;code&gt;%(my_dir)s&lt;/code&gt; in effect would resolve to &lt;code&gt;/Users/lumberjack&lt;/code&gt;. All interpolations are done on demand so keys used in the chain of references do not have to be specified in any specific order in the configuration file.</source>
          <target state="translated">위의 예제 에서 &lt;em&gt;보간&lt;/em&gt; 이 &lt;code&gt;BasicInterpolation()&lt;/code&gt; 설정된 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;%(home_dir)s&lt;/code&gt; 를 &lt;code&gt;home_dir&lt;/code&gt; ( 이 경우 &lt;code&gt;/Users&lt;/code&gt; ) 값으로 해석 합니다. &lt;code&gt;%(my_dir)s&lt;/code&gt; 는 실제로 &lt;code&gt;/Users/lumberjack&lt;/code&gt; 로 해석됩니다 . 모든 보간은 요청시 수행되므로 참조 체인에 사용 된 키를 구성 파일에서 특정 순서로 지정할 필요는 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d863919b7beef0b7bffcfd48a2859d814cc5049" translate="yes" xml:space="preserve">
          <source>In the first approach, we read the data out of the fd&amp;rsquo;s buffer, and the byte values give you the signal numbers. This is simple, but in rare cases it can run into a problem: generally the fd will have a limited amount of buffer space, and if too many signals arrive too quickly, then the buffer may become full, and some signals may be lost. If you use this approach, then you should set &lt;code&gt;warn_on_full_buffer=True&lt;/code&gt;, which will at least cause a warning to be printed to stderr when signals are lost.</source>
          <target state="translated">첫 번째 방법에서는 fd의 버퍼에서 데이터를 읽으며 바이트 값은 신호 번호를 제공합니다. 이것은 간단하지만 드문 경우지만 문제가 될 수 있습니다. 일반적으로 fd에는 제한된 버퍼 공간이 있으며 너무 많은 신호가 너무 빨리 도착하면 버퍼가 가득 차서 일부 신호가 손실 될 수 있습니다. 이 방법을 사용하는 경우 &lt;code&gt;warn_on_full_buffer=True&lt;/code&gt; 를 설정해야합니다 .이 경우 신호가 손실 될 때 최소한 stderr에 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="b1f405b7b60dec7ef0ccbbabf3d071abe0435edb" translate="yes" xml:space="preserve">
          <source>In the following &lt;a href=&quot;https://docs.python.org/3.8/_downloads/6b45dc135219d1404be49d606589a11d/tzinfo_examples.py&quot;&gt;&lt;code&gt;tzinfo_examples.py&lt;/code&gt;&lt;/a&gt; file there are some examples of &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; classes:</source>
          <target state="translated">다음 &lt;a href=&quot;https://docs.python.org/3.8/_downloads/6b45dc135219d1404be49d606589a11d/tzinfo_examples.py&quot;&gt; &lt;code&gt;tzinfo_examples.py&lt;/code&gt; &lt;/a&gt; 파일에는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 클래스의 몇 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ff95d881b0899b985ba27eea20bbabb5d0f7f41" translate="yes" xml:space="preserve">
          <source>In the following documentation the argument list for functions is given. Methods, of course, have the additional first argument &lt;em&gt;self&lt;/em&gt; which is omitted here.</source>
          <target state="translated">다음 문서에는 함수의 인수 목록이 제공됩니다. 물론 메소드에는 추가 첫 번째 인수 &lt;em&gt;self&lt;/em&gt; 가 있으며 여기서는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="ccfb56fcc1d858991309ad5c738b0606a30bbfb4" translate="yes" xml:space="preserve">
          <source>In the following example we&amp;rsquo;re going to intentionally cause a &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt;&lt;code&gt;Fault&lt;/code&gt;&lt;/a&gt; by returning a complex type object. The server code:</source>
          <target state="translated">다음 예제에서는 복잡한 유형의 객체를 반환 하여 의도적으로 &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt; &lt;code&gt;Fault&lt;/code&gt; &lt;/a&gt; 을 발생 시킵니다. 서버 코드 :</target>
        </trans-unit>
        <trans-unit id="e2223ff4a598cefedbdd585097e57edaf62fd136" translate="yes" xml:space="preserve">
          <source>In the following example we&amp;rsquo;re going to intentionally cause a &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt;&lt;code&gt;ProtocolError&lt;/code&gt;&lt;/a&gt; by providing an invalid URI:</source>
          <target state="translated">다음 예제에서는 잘못된 URI를 제공하여 의도적으로 &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt; &lt;code&gt;ProtocolError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="1b98fb6821e17d529d323fbb51fcfeba5d9f117e" translate="yes" xml:space="preserve">
          <source>In the following example, the data are rounded, so that each value represents the midpoint of data classes, e.g. 1 is the midpoint of the class 0.5&amp;ndash;1.5, 2 is the midpoint of 1.5&amp;ndash;2.5, 3 is the midpoint of 2.5&amp;ndash;3.5, etc. With the data given, the middle value falls somewhere in the class 3.5&amp;ndash;4.5, and interpolation is used to estimate it:</source>
          <target state="translated">다음 예에서 데이터는 반올림되므로 각 값은 데이터 클래스의 중간 점을 나타냅니다. 예를 들어 1은 클래스 0.5&amp;ndash;1.5의 중간 점, 2는 1.5&amp;ndash;2.5의 중간 점, 3은 2.5&amp;ndash;3.5의 중간 점입니다 주어진 데이터에서 중간 값은 3.5&amp;ndash;4.5 클래스 어딘가에 속하며 보간은이를 추정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="533603ba0650e5f7228aa22ac8ec4f95a8bd54f1" translate="yes" xml:space="preserve">
          <source>In the following example, we are sending a data-stream to the stdin of a CGI and reading the data it returns to us. Note that this example will only work when the Python installation supports SSL.</source>
          <target state="translated">다음 예에서는 CGI의 stdin에 데이터 스트림을 전송하고 반환되는 데이터를 읽습니다. 이 예제는 Python 설치가 SSL을 지원하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1fa008487812ea35726b9061adefa221aa756af2" translate="yes" xml:space="preserve">
          <source>In the following examples, we assume that the relevant functions have already been imported from the &lt;a href=&quot;#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다음 예에서는 관련 기능을 &lt;a href=&quot;#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈 에서 이미 가져 왔다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8f9fe91e9abf59bd1adbaa56c89770d56c827a8d" translate="yes" xml:space="preserve">
          <source>In the following, &lt;em&gt;events&lt;/em&gt; is a bitwise mask indicating which I/O events should be waited for on a given file object. It can be a combination of the modules constants below:</source>
          <target state="translated">다음에서 &lt;em&gt;이벤트&lt;/em&gt; 는 주어진 파일 객체에서 대기해야 할 I / O 이벤트를 나타내는 비트 단위 마스크입니다. 아래 모듈 상수의 조합이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed55c5626284f0ef492f74cae3ebfc7bd5bdeb3" translate="yes" xml:space="preserve">
          <source>In the following, the term &lt;em&gt;referent&lt;/em&gt; means the object which is referred to by a weak reference.</source>
          <target state="translated">이하에서, &lt;em&gt;지시 대상&lt;/em&gt; 이라는 용어 는 약한 참조로 지칭되는 &lt;em&gt;대상을&lt;/em&gt; 의미한다.</target>
        </trans-unit>
        <trans-unit id="26053a87fbd2fcc58b5429c7f78fea5394e32809" translate="yes" xml:space="preserve">
          <source>In the function &lt;code&gt;greeting&lt;/code&gt;, the argument &lt;code&gt;name&lt;/code&gt; is expected to be of type &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and the return type &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. Subtypes are accepted as arguments.</source>
          <target state="translated">함수 &lt;code&gt;greeting&lt;/code&gt; 에서 인수 &lt;code&gt;name&lt;/code&gt; 은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 유형 이고 반환 유형은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 입니다. 하위 유형은 인수로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8ac6b1e58da82a23a5cbc8050342436b8ca25b0" translate="yes" xml:space="preserve">
          <source>In the ideal case, the code will have a suitable test suite, and the test runner will take care of implicitly enabling all warnings when running tests (the test runner provided by the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; module does this).</source>
          <target state="translated">이상적인 경우 코드에 적합한 테스트 스위트가 있으며 테스트 러너는 테스트를 실행할 때 모든 경고를 암시 적으로 활성화합니다 ( &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 모듈에서 제공하는 테스트 러너 가이를 수행함 ).</target>
        </trans-unit>
        <trans-unit id="eaf314b605ee1e93c7ef662a0fcaed6c7faecc98" translate="yes" xml:space="preserve">
          <source>In the next example (simple implementation of &lt;a href=&quot;shutil#shutil.rmtree&quot;&gt;&lt;code&gt;shutil.rmtree()&lt;/code&gt;&lt;/a&gt;), walking the tree bottom-up is essential, &lt;a href=&quot;#os.rmdir&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t allow deleting a directory before the directory is empty:</source>
          <target state="translated">다음 예제 ( &lt;a href=&quot;shutil#shutil.rmtree&quot;&gt; &lt;code&gt;shutil.rmtree()&lt;/code&gt; &lt;/a&gt; 의 간단한 구현 )에서 트리를 위로 걷는 것은 필수적이며, &lt;a href=&quot;#os.rmdir&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt; 은 디렉토리가 비어 있기 전에 디렉토리를 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="274c72518f8a919afc6da55f424febbdf2ea74bb" translate="yes" xml:space="preserve">
          <source>In the next example, walking the tree bottom-up is essential: &lt;a href=&quot;#os.rmdir&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t allow deleting a directory before the directory is empty:</source>
          <target state="translated">다음 예제에서는 트리를 상향식으로 걷는 것이 필수적입니다. &lt;a href=&quot;#os.rmdir&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt; 은 디렉토리가 비어 있기 전에 디렉토리를 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="17c1ee7708d83a788fb54edf47914b0f5328b88f" translate="yes" xml:space="preserve">
          <source>In the option list above, &amp;ldquo;a set&amp;rdquo; refers to any collection or iterable of strings, no ordering is expected.</source>
          <target state="translated">위의 옵션 목록에서 &quot;집합&quot;은 문자열의 모음 또는 반복 가능한 항목을 나타내며 순서는 없습니다.</target>
        </trans-unit>
        <trans-unit id="54385cf5bdff670b83f3d300aefcf33fbb344d3c" translate="yes" xml:space="preserve">
          <source>In the previous section, you learned to write following code anytime you expected a user to post more than one value under one name:</source>
          <target state="translated">이전 섹션에서는 사용자가 하나의 이름으로 둘 이상의 값을 게시 할 것으로 예상 될 때마다 다음 코드를 작성하는 방법을 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="233a7a8805657d96bca6651321789f9af3a538c2" translate="yes" xml:space="preserve">
          <source>In the second approach, we use the wakeup fd &lt;em&gt;only&lt;/em&gt; for wakeups, and ignore the actual byte values. In this case, all we care about is whether the fd&amp;rsquo;s buffer is empty or non-empty; a full buffer doesn&amp;rsquo;t indicate a problem at all. If you use this approach, then you should set &lt;code&gt;warn_on_full_buffer=False&lt;/code&gt;, so that your users are not confused by spurious warning messages.</source>
          <target state="translated">두 번째 방법에서는 wakeup fd를 wakeup &lt;em&gt;에만&lt;/em&gt; 사용 하고 실제 바이트 값은 무시합니다. 이 경우, 우리가 신경 쓰는 것은 fd의 버퍼가 비어 있는지 비어 있지 않은지입니다. 가득 찬 버퍼는 전혀 문제를 나타내지 않습니다. 이 방법을 사용하는 경우 사용자가 잘못된 경고 메시지로 혼동되지 않도록 &lt;code&gt;warn_on_full_buffer=False&lt;/code&gt; 를 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="89bc0401466a52c7fb4e1247c6f71a447d41beff" translate="yes" xml:space="preserve">
          <source>In the serializer, the &lt;em&gt;allow_nan&lt;/em&gt; parameter can be used to alter this behavior. In the deserializer, the &lt;em&gt;parse_constant&lt;/em&gt; parameter can be used to alter this behavior.</source>
          <target state="translated">시리얼 라이저에서 &lt;em&gt;allow_nan&lt;/em&gt; 매개 변수를 사용하여이 동작을 변경할 수 있습니다. deserializer에서 &lt;em&gt;parse_constant&lt;/em&gt; 매개 변수를 사용하여이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38626b257d0d2b41bc10b255929643d1d13e8835" translate="yes" xml:space="preserve">
          <source>In the simple case then, you need only add the following bit of code to the main driver file of your application:</source>
          <target state="translated">간단한 경우 응용 프로그램의 기본 드라이버 파일에 다음 코드 만 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="cf29865f18bcaf9638d0168c8132a6142805a764" translate="yes" xml:space="preserve">
          <source>In the table &lt;em&gt;s&lt;/em&gt; is an instance of a mutable sequence type, &lt;em&gt;t&lt;/em&gt; is any iterable object and &lt;em&gt;x&lt;/em&gt; is an arbitrary object that meets any type and value restrictions imposed by &lt;em&gt;s&lt;/em&gt; (for example, &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; only accepts integers that meet the value restriction &lt;code&gt;0 &amp;lt;= x &amp;lt;= 255&lt;/code&gt;).</source>
          <target state="translated">표에서 &lt;em&gt;s&lt;/em&gt; 는 변경 가능한 시퀀스 유형의 인스턴스이고, &lt;em&gt;t&lt;/em&gt; 는 반복 가능한 객체이고 &lt;em&gt;x&lt;/em&gt; 는 &lt;em&gt;s&lt;/em&gt; 에 의해 부과 된 모든 유형 및 값 제한을 충족시키는 임의의 객체입니다 (예 : &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 는 값 제한 &lt;code&gt;0 &amp;lt;= x &amp;lt;= 255&lt;/code&gt; 을 만족하는 정수만 허용 함). x &amp;lt;= 255 ).</target>
        </trans-unit>
        <trans-unit id="bd508f1ee529ccf68344f530644e56df47707298" translate="yes" xml:space="preserve">
          <source>In the tree above, each cell &lt;em&gt;k&lt;/em&gt; is topping &lt;code&gt;2*k+1&lt;/code&gt; and &lt;code&gt;2*k+2&lt;/code&gt;. In a usual binary tournament we see in sports, each cell is the winner over the two cells it tops, and we can trace the winner down the tree to see all opponents s/he had. However, in many computer applications of such tournaments, we do not need to trace the history of a winner. To be more memory efficient, when a winner is promoted, we try to replace it by something else at a lower level, and the rule becomes that a cell and the two cells it tops contain three different items, but the top cell &amp;ldquo;wins&amp;rdquo; over the two topped cells.</source>
          <target state="translated">위의 트리에서 각 셀 &lt;em&gt;k&lt;/em&gt; 는 &lt;code&gt;2*k+1&lt;/code&gt; 및 &lt;code&gt;2*k+2&lt;/code&gt; 를 토핑 합니다. 우리가 스포츠에서 볼 수있는 일반적인 이진 토너먼트에서, 각 셀은 맨 위에있는 두 개의 셀보다 승자가되며 트리에서 우승자를 추적하여 모든 상대를 볼 수 있습니다. 그러나 이러한 토너먼트의 많은 컴퓨터 응용 프로그램에서 우승자의 이력을 추적 할 필요는 없습니다. 메모리 효율성을 높이기 위해 승자가 승격되면 하위 레벨에서 다른 것으로 대체하려고 시도합니다. 규칙은 셀과 셀의 두 셀에 서로 다른 세 개의 항목이 포함되지만 최상위 셀은 &quot;승리합니다&quot; 두 개의 상단 셀 위에.</target>
        </trans-unit>
        <trans-unit id="1defc52a5fe9f0a43f30bd5d3e26fbc4e063c451" translate="yes" xml:space="preserve">
          <source>In the typical usage of a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; object, the &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method is invoked by a &lt;code&gt;TestRunner&lt;/code&gt; rather than by the end-user test harness.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 객체 의 일반적인 사용법 에서 &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메서드는 최종 사용자 테스트 하니스가 아닌 &lt;code&gt;TestRunner&lt;/code&gt; 에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e430d29f738b72ec9b1e05af5395066734b68a2" translate="yes" xml:space="preserve">
          <source>In these tuples, &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt;, &lt;em&gt;proto&lt;/em&gt; are all integers and are meant to be passed to the &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; function. &lt;em&gt;canonname&lt;/em&gt; will be a string representing the canonical name of the &lt;em&gt;host&lt;/em&gt; if &lt;code&gt;AI_CANONNAME&lt;/code&gt; is part of the &lt;em&gt;flags&lt;/em&gt; argument; else &lt;em&gt;canonname&lt;/em&gt; will be empty. &lt;em&gt;sockaddr&lt;/em&gt; is a tuple describing a socket address, whose format depends on the returned &lt;em&gt;family&lt;/em&gt; (a &lt;code&gt;(address, port)&lt;/code&gt; 2-tuple for &lt;a href=&quot;#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;(address, port, flow info, scope id)&lt;/code&gt; 4-tuple for &lt;a href=&quot;#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;), and is meant to be passed to the &lt;a href=&quot;#socket.socket.connect&quot;&gt;&lt;code&gt;socket.connect()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 튜플에서 &lt;em&gt;family&lt;/em&gt; , &lt;em&gt;type&lt;/em&gt; , &lt;em&gt;proto&lt;/em&gt; 는 모두 정수이며 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 함수에 전달됩니다 . &lt;em&gt;AI_CANONNAME&lt;/em&gt; 이 &lt;em&gt;flags&lt;/em&gt; 인수의 일부인 경우 &lt;code&gt;AI_CANONNAME&lt;/code&gt; 은 &lt;em&gt;호스트&lt;/em&gt; 의 표준 이름을 나타내는 문자열입니다 . 그렇지 않으면 &lt;em&gt;캐논 이름&lt;/em&gt; 이 비어 있습니다. &lt;em&gt;SOCKADDR는&lt;/em&gt; 포맷이 반환에 따라 소켓 주소를 기술하는 튜플 인 &lt;em&gt;가족&lt;/em&gt; (a &lt;code&gt;(address, port)&lt;/code&gt; 2 튜플 &lt;a href=&quot;#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;(address, port, flow info, scope id)&lt;/code&gt; 4 튜플 &lt;a href=&quot;#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; &lt;/a&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;)이며 &lt;a href=&quot;#socket.socket.connect&quot;&gt; &lt;code&gt;socket.connect()&lt;/code&gt; &lt;/a&gt; 메소드 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f03f8295d4401efbee1454b689f377054911af8" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;MyDict&lt;/code&gt; has a single parameter, &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;MyDict&lt;/code&gt; 에는 단일 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cbbe287f089dc8f706ae99f0052a682074dcad2" translate="yes" xml:space="preserve">
          <source>In this case all warnings are caught and no errors are raised.</source>
          <target state="translated">이 경우 모든 경고가 발생하고 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c62940c22ee32d3fd980aa25414be64f0948aab" translate="yes" xml:space="preserve">
          <source>In this case if either warning was not raised, or some other warning was raised, &lt;a href=&quot;#test.support.check_warnings&quot;&gt;&lt;code&gt;check_warnings()&lt;/code&gt;&lt;/a&gt; would raise an error.</source>
          <target state="translated">이 경우 경고가 발생하지 않거나 다른 경고가 발생하면 &lt;a href=&quot;#test.support.check_warnings&quot;&gt; &lt;code&gt;check_warnings()&lt;/code&gt; &lt;/a&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb0757ca7b63d5e5a2bcaf0b7ed3ffc59abc635d" translate="yes" xml:space="preserve">
          <source>In this case no &lt;code&gt;*&lt;/code&gt; specifiers may occur in a format (since they require a sequential parameter list).</source>
          <target state="translated">이 경우 &lt;code&gt;*&lt;/code&gt; 지정자는 형식으로 발생할 수 없습니다 (순차 매개 변수 목록이 필요하므로).</target>
        </trans-unit>
        <trans-unit id="c4457d16ba5e9b6c681760e973da7e71471b05ca" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;#dataclasses.fields&quot;&gt;&lt;code&gt;fields()&lt;/code&gt;&lt;/a&gt; will return &lt;a href=&quot;#dataclasses.Field&quot;&gt;&lt;code&gt;Field&lt;/code&gt;&lt;/a&gt; objects for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, but not for &lt;code&gt;database&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;a href=&quot;#dataclasses.fields&quot;&gt; &lt;code&gt;fields()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 에 대한 &lt;a href=&quot;#dataclasses.Field&quot;&gt; &lt;code&gt;Field&lt;/code&gt; &lt;/a&gt; 객체를 반환 하지만 &lt;code&gt;database&lt;/code&gt; 에 대해서는 반환 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="79e6ea472a32e4246827af3631820637ed0278c5" translate="yes" xml:space="preserve">
          <source>In this case, you are marking translatable strings with the function &lt;code&gt;N_()&lt;/code&gt;, which won&amp;rsquo;t conflict with any definition of &lt;code&gt;_()&lt;/code&gt;. However, you will need to teach your message extraction program to look for translatable strings marked with &lt;code&gt;N_()&lt;/code&gt;. &lt;strong&gt;xgettext&lt;/strong&gt;, &lt;strong&gt;pygettext&lt;/strong&gt;, &lt;code&gt;pybabel extract&lt;/code&gt;, and &lt;strong&gt;xpot&lt;/strong&gt; all support this through the use of the &lt;code&gt;-k&lt;/code&gt; command-line switch. The choice of &lt;code&gt;N_()&lt;/code&gt; here is totally arbitrary; it could have just as easily been &lt;code&gt;MarkThisStringForTranslation()&lt;/code&gt;.</source>
          <target state="translated">이 경우 번역 가능한 문자열을 &lt;code&gt;N_()&lt;/code&gt; 함수로 표시하면 &lt;code&gt;_()&lt;/code&gt; 의 정의와 충돌하지 않습니다 . 그러나 &lt;code&gt;N_()&lt;/code&gt; 으로 표시된 번역 가능한 문자열을 찾도록 메시지 추출 프로그램을 가르쳐야합니다 . &lt;strong&gt;xgettext&lt;/strong&gt; , &lt;strong&gt;pygettext&lt;/strong&gt; , &lt;code&gt;pybabel extract&lt;/code&gt; 및 &lt;strong&gt;xpot은&lt;/strong&gt; 모두 &lt;code&gt;-k&lt;/code&gt; 명령 줄 스위치를 사용하여이를 지원합니다 . 여기서 &lt;code&gt;N_()&lt;/code&gt; 의 선택 은 완전히 임의적입니다. &lt;code&gt;MarkThisStringForTranslation()&lt;/code&gt; 처럼 쉽게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08bfb79410a7dd7df492ec826030edd1454851bb" translate="yes" xml:space="preserve">
          <source>In this documentation the term &amp;ldquo;coroutine&amp;rdquo; can be used for two closely related concepts:</source>
          <target state="translated">이 문서에서 &quot;코 루틴&quot;이라는 용어는 두 가지 밀접한 관련 개념에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdbd41293f905fe5e804f0cde22491ea56d4aad3" translate="yes" xml:space="preserve">
          <source>In this example we monkey patch &lt;code&gt;method&lt;/code&gt; to return &lt;code&gt;sentinel.some_object&lt;/code&gt;:</source>
          <target state="translated">이 예제에서 우리는 &lt;code&gt;sentinel.some_object&lt;/code&gt; 를 반환하는 패치 &lt;code&gt;method&lt;/code&gt; 을 원숭이 로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="0cb1f4c4966c211b894b9eddb03c77f1514eec4f" translate="yes" xml:space="preserve">
          <source>In this example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be included in the added &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method, which will be defined as:</source>
          <target state="translated">이 예제에서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 추가 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드에 포함되며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5b3d5cd546b56dd82f8608e853a7baf739475096" translate="yes" xml:space="preserve">
          <source>In this example, the string &lt;code&gt;'writing a log message'&lt;/code&gt; is marked as a candidate for translation, while the strings &lt;code&gt;'mylog.txt'&lt;/code&gt; and &lt;code&gt;'w'&lt;/code&gt; are not.</source>
          <target state="translated">이 예에서 문자열 &lt;code&gt;'writing a log message'&lt;/code&gt; 은 번역 후보로 표시되지만 문자열 &lt;code&gt;'mylog.txt'&lt;/code&gt; 및 &lt;code&gt;'w'&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7def4d1e263f8bcd184ca5ff886690b3b0a0295" translate="yes" xml:space="preserve">
          <source>In this example, the unpickler imports the &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt; function and then apply the string argument &amp;ldquo;echo hello world&amp;rdquo;. Although this example is inoffensive, it is not difficult to imagine one that could damage your system.</source>
          <target state="translated">이 예제에서 unpickler는 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 함수를 가져온 다음 문자열 인수 &quot;echo hello world&quot;를 적용합니다. 이 예제는 공격적이지 않지만 시스템을 손상시킬 수있는 것을 상상하기는 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e522fd7d7c94512496913a1631fcf4f5c248305d" translate="yes" xml:space="preserve">
          <source>In this example, we create a gzip&amp;rsquo;ed tar-file archive containing all files found in the &lt;code&gt;.ssh&lt;/code&gt; directory of the user:</source>
          <target state="translated">이 예에서는 사용자 의 &lt;code&gt;.ssh&lt;/code&gt; 디렉토리에있는 모든 파일을 포함하는 gzip의 tar 파일 아카이브를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6ad2b90f1a4c574c3b7216fa3f340a8bbed08661" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll use the following helper function to display match objects a little more gracefully:</source>
          <target state="translated">이 예에서는 다음 도우미 함수를 사용하여 일치 객체를 조금 더 우아하게 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ba2da0e1a0b23d485c22fd691fbc6b825bea722c" translate="yes" xml:space="preserve">
          <source>In this module, shared memory refers to &amp;ldquo;System V style&amp;rdquo; shared memory blocks (though is not necessarily implemented explicitly as such) and does not refer to &amp;ldquo;distributed shared memory&amp;rdquo;. This style of shared memory permits distinct processes to potentially read and write to a common (or shared) region of volatile memory. Processes are conventionally limited to only have access to their own process memory space but shared memory permits the sharing of data between processes, avoiding the need to instead send messages between processes containing that data. Sharing data directly via memory can provide significant performance benefits compared to sharing data via disk or socket or other communications requiring the serialization/deserialization and copying of data.</source>
          <target state="translated">이 모듈에서 공유 메모리는 &quot;System V 스타일&quot;공유 메모리 블록을 나타내며 (반드시 명시 적으로 구현할 필요는 없지만) &quot;분산 공유 메모리&quot;를 나타내지 않습니다. 이 스타일의 공유 메모리는 개별 프로세스가 휘발성 메모리의 공통 (또는 공유) 영역을 읽고 쓸 수 있도록합니다. 프로세스는 일반적으로 자신의 프로세스 메모리 공간에만 액세스 할 수 있도록 제한되지만 공유 메모리는 프로세스간에 데이터를 공유 할 수 있으므로 해당 데이터를 포함하는 프로세스간에 메시지를 대신 보낼 필요가 없습니다. 메모리를 통해 직접 데이터를 공유하면 디스크 또는 소켓을 통해 데이터를 공유하거나 데이터의 직렬화 / 직렬화 및 복사가 필요한 다른 통신과 비교할 때 상당한 성능 이점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3672efb81510d5a09d403c05abc447f604c84f" translate="yes" xml:space="preserve">
          <source>In this section, &amp;ldquo;a becomes b&amp;rdquo; means that b can be used as a replacement for a.</source>
          <target state="translated">이 섹션에서 &quot;a가 b가 됨&quot;은 b가 a의 대체품으로 사용될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="21e480a14f4cd9a1149fed8cca6a4c7d111a42ea" translate="yes" xml:space="preserve">
          <source>In this section, &amp;lsquo;C&amp;rsquo; refers to the</source>
          <target state="translated">이 섹션에서 'C'는</target>
        </trans-unit>
        <trans-unit id="876936e3c1b8574b0dd98372c0c2aa05d7cc3d86" translate="yes" xml:space="preserve">
          <source>In this section, we describe the general mechanisms available to you to define, customize, and control how class instances are pickled and unpickled.</source>
          <target state="translated">이 섹션에서는 클래스 인스턴스의 피클 링 및 피클 링 해제 방법을 정의, 사용자 정의 및 제어하는 ​​데 사용할 수있는 일반적인 메커니즘에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="609a689db13972f91eaeffe399356954f6e29a03" translate="yes" xml:space="preserve">
          <source>In those examples, note that when an in-place method is called, the computation and assignment are performed in two separate steps. The in-place functions listed below only do the first step, calling the in-place method. The second step, assignment, is not handled.</source>
          <target state="translated">이러한 예에서, 내부 메소드가 호출되면 계산 및 지정이 두 개의 개별 단계로 수행됩니다. 아래 나열된 인플레 이스 함수는 인플레 이스 메소드를 호출하는 첫 번째 단계 만 수행합니다. 두 번째 단계 인 할당은 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3e67f78459f05a24ed8968a34d4f51980839f13" translate="yes" xml:space="preserve">
          <source>In traditional Unix the field &lt;code&gt;pw_passwd&lt;/code&gt; usually contains a password encrypted with a DES derived algorithm (see module &lt;a href=&quot;crypt#module-crypt&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt;). However most modern unices use a so-called &lt;em&gt;shadow password&lt;/em&gt; system. On those unices the &lt;em&gt;pw_passwd&lt;/em&gt; field only contains an asterisk (&lt;code&gt;'*'&lt;/code&gt;) or the letter &lt;code&gt;'x'&lt;/code&gt; where the encrypted password is stored in a file &lt;code&gt;/etc/shadow&lt;/code&gt; which is not world readable. Whether the &lt;em&gt;pw_passwd&lt;/em&gt; field contains anything useful is system-dependent. If available, the &lt;a href=&quot;spwd#module-spwd&quot;&gt;&lt;code&gt;spwd&lt;/code&gt;&lt;/a&gt; module should be used where access to the encrypted password is required.</source>
          <target state="translated">전통적인 유닉스에서 &lt;code&gt;pw_passwd&lt;/code&gt; 필드 는 일반적으로 DES 파생 알고리즘으로 암호화 된 비밀번호를 포함합니다 (모듈 &lt;a href=&quot;crypt#module-crypt&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt; 참조 ). 그러나 대부분의 현대 유니 세서는 소위 &lt;em&gt;섀도 패스워드&lt;/em&gt; 시스템을 사용합니다. 이 &lt;em&gt;유니 세스&lt;/em&gt; 에서 &lt;em&gt;pw_passwd&lt;/em&gt; 필드에는 별표 ( &lt;code&gt;'*'&lt;/code&gt; ) 또는 암호화 된 비밀번호가 &lt;code&gt;/etc/shadow&lt;/code&gt; 파일 ( 세계에서 읽을 수없는 파일)에 저장된 &lt;code&gt;'x'&lt;/code&gt; 문자 만 포함 됩니다 . &lt;em&gt;pw_passwd&lt;/em&gt; 필드에 유용한 것이 포함되어 있는지 여부 는 시스템에 따라 다릅니다. 사용 가능한 경우 암호화 된 비밀번호에 액세스해야하는 경우 &lt;a href=&quot;spwd#module-spwd&quot;&gt; &lt;code&gt;spwd&lt;/code&gt; &lt;/a&gt; 모듈을 사용해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4db947ef6cd05225fe3e644d287ef1d201b7690c" translate="yes" xml:space="preserve">
          <source>In-memory binary streams are also available as &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">메모리 내 이진 스트림은 &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 객체 로도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6cfcf9ff1be78ddbf5f88cac85851468eeaa139" translate="yes" xml:space="preserve">
          <source>In-memory streams</source>
          <target state="translated">인 메모리 스트림</target>
        </trans-unit>
        <trans-unit id="f1e0a688070a40f2e2db3ffb57db4a1558ede0ec" translate="yes" xml:space="preserve">
          <source>In-memory text streams are also available as &lt;a href=&quot;#io.StringIO&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">인 메모리 텍스트 스트림은 &lt;a href=&quot;#io.StringIO&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; 객체 로도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="62f47cd6536074a736c1c116ad6886a50b7748af" translate="yes" xml:space="preserve">
          <source>In-place Operators</source>
          <target state="translated">내부 연산자</target>
        </trans-unit>
        <trans-unit id="8fde0e675981692ca7b1da663a1cf0845aae8f30" translate="yes" xml:space="preserve">
          <source>In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.</source>
          <target state="translated">인플레 이스 작업은 TOS 및 TOS1을 제거하고 스택에서 결과를 다시 푸시한다는 점에서 이진 작업과 같습니다. 그러나 TOS1이이를 지원하면 작업이 제자리에서 수행되며 결과 TOS는 발생할 수 있습니다. 원래 TOS1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8af4b79f6c3a07f98f4ba1fb79d2c37561daffe3" translate="yes" xml:space="preserve">
          <source>Inability to resolve to an internal or external object.</source>
          <target state="translated">내부 또는 외부 개체를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a6c755eb982a2f54a4da7973c3f73c77717a36d" translate="yes" xml:space="preserve">
          <source>Incomplete Types</source>
          <target state="translated">불완전한 유형</target>
        </trans-unit>
        <trans-unit id="e6fd210ecfa24de959ef25c81cb5be14a187e9d4" translate="yes" xml:space="preserve">
          <source>Increment the line number and end line number of each node in the tree starting at &lt;em&gt;node&lt;/em&gt; by &lt;em&gt;n&lt;/em&gt;. This is useful to &amp;ldquo;move code&amp;rdquo; to a different location in a file.</source>
          <target state="translated">시작 트리 내의 각 노드의 라인 수 및 종료 라인 수를 증가 &lt;em&gt;노드&lt;/em&gt; 가 &lt;em&gt;N을&lt;/em&gt; . 이것은 파일의 다른 위치로 &quot;코드를 이동&quot;하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fc380757d8f1313c5e79738a01b95f0245ea2bcd" translate="yes" xml:space="preserve">
          <source>Incremental (de)compression</source>
          <target state="translated">증분 (de) 압축</target>
        </trans-unit>
        <trans-unit id="c0e4d91a0ac93c5179d6274198eca54354c0112e" translate="yes" xml:space="preserve">
          <source>Incremental Configuration</source>
          <target state="translated">증분 구성</target>
        </trans-unit>
        <trans-unit id="714de6e8dcb31cacd8f82e698735cc996d909c17" translate="yes" xml:space="preserve">
          <source>Incremental Encoding and Decoding</source>
          <target state="translated">증분 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="a70d136600a290d7d648bcefe4f894034d7a33c9" translate="yes" xml:space="preserve">
          <source>Incremental compression:</source>
          <target state="translated">증분 압축 :</target>
        </trans-unit>
        <trans-unit id="a7f4a498ec26fd59fab8b07468072d9f25dbafa4" translate="yes" xml:space="preserve">
          <source>Incremental encoder and decoder classes or factory functions. These have to provide the interface defined by the base classes &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt;&lt;code&gt;IncrementalEncoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt;&lt;code&gt;IncrementalDecoder&lt;/code&gt;&lt;/a&gt;, respectively. Incremental codecs can maintain state.</source>
          <target state="translated">증분 형 엔코더 및 디코더 클래스 또는 팩토리 기능. 이들은 각각 기본 클래스 &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt; &lt;code&gt;IncrementalEncoder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt; &lt;code&gt;IncrementalDecoder&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 인터페이스를 제공해야합니다 . 증분 코덱은 상태를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc78b0aec9ec9307500e4e82c03e65603530f3f" translate="yes" xml:space="preserve">
          <source>IncrementalDecoder Objects</source>
          <target state="translated">IncrementalDecoder 객체</target>
        </trans-unit>
        <trans-unit id="eda65be020f7ce434c41db14bb91b12c39b505b4" translate="yes" xml:space="preserve">
          <source>IncrementalEncoder Objects</source>
          <target state="translated">IncrementalEncoder 객체</target>
        </trans-unit>
        <trans-unit id="4807b06d3e0ef5d4c1c771970fa1c0c8a1d5ba1f" translate="yes" xml:space="preserve">
          <source>IncrementalParser Objects</source>
          <target state="translated">IncrementalParser 객체</target>
        </trans-unit>
        <trans-unit id="f757e0a955188780b83c7c9c785807ad53aaa78c" translate="yes" xml:space="preserve">
          <source>Increments bytecode counter by &lt;em&gt;delta&lt;/em&gt;.</source>
          <target state="translated">바이트 코드 카운터를 &lt;em&gt;델타&lt;/em&gt; 단위로 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="9f38f8487043353879d3ca62212ab364189a37fc" translate="yes" xml:space="preserve">
          <source>Increments the progress bar&amp;rsquo;s value by &lt;em&gt;amount&lt;/em&gt;.</source>
          <target state="translated">진행률 표시 줄의 값을 &lt;em&gt;amount&lt;/em&gt; 단위로 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="bc9cdd48c3b4bc260e24e340e9220a7006377fb5" translate="yes" xml:space="preserve">
          <source>Indent Region</source>
          <target state="translated">들여 쓰기 지역</target>
        </trans-unit>
        <trans-unit id="fb4844c6e4e3fdb04af9405295e30a7c41ae4efc" translate="yes" xml:space="preserve">
          <source>IndentationError</source>
          <target state="translated">IndentationError</target>
        </trans-unit>
        <trans-unit id="3cd6cb1c3ba0aa8ae172917a71df16fc02b82ac0" translate="yes" xml:space="preserve">
          <source>Independent of its category, each concrete stream object will also have various capabilities: it can be read-only, write-only, or read-write. It can also allow arbitrary random access (seeking forwards or backwards to any location), or only sequential access (for example in the case of a socket or pipe).</source>
          <target state="translated">범주와 상관없이 각 콘크리트 스트림 개체에는 다양한 기능이 있습니다. 읽기 전용, 쓰기 전용 또는 읽기 / 쓰기가 가능합니다. 또한 임의의 임의 액세스 (모든 위치로 앞뒤로 탐색) 또는 순차적 액세스 (예 : 소켓 또는 파이프의 경우) 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="383b324a3291b51f1e54ef9c0d763010fbc5e171" translate="yes" xml:space="preserve">
          <source>IndexError</source>
          <target state="translated">IndexError</target>
        </trans-unit>
        <trans-unit id="04f77b5a53e8914ea949c0d3dbe59ff927176c3a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment</source>
          <target state="translated">인덱스 할당</target>
        </trans-unit>
        <trans-unit id="181136c2e116ea448074c254b778be7e9dec6c9a" translate="yes" xml:space="preserve">
          <source>Indexed Deletion</source>
          <target state="translated">인덱스 삭제</target>
        </trans-unit>
        <trans-unit id="6dabd048a18ebfcff9a07def85323d4996693e98" translate="yes" xml:space="preserve">
          <source>Indexed databases of objects; uses &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인덱스 된 객체 데이터베이스; &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; 을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="6face659f95ee23785ce3d17089bd3d63183d57c" translate="yes" xml:space="preserve">
          <source>Indicate that a formerly enqueued task is complete.</source>
          <target state="translated">이전에 대기중인 작업이 완료되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9433ffdce775eecb1add8a4a73f1d9fde76ac24a" translate="yes" xml:space="preserve">
          <source>Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each &lt;a href=&quot;#queue.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; used to fetch a task, a subsequent call to &lt;a href=&quot;#queue.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; tells the queue that the processing on the task is complete.</source>
          <target state="translated">이전에 대기중인 작업이 완료되었음을 나타냅니다. 큐 소비자 스레드에서 사용합니다. 태스크를 페치하는 데 사용 된 각 &lt;a href=&quot;#queue.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 에 대해 후속 &lt;a href=&quot;#queue.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출 은 태스크 처리가 완료되었음을 큐에 알립니다.</target>
        </trans-unit>
        <trans-unit id="ccfdc69dc0a7d14a2b1d58743e040b3b8aaf8ad5" translate="yes" xml:space="preserve">
          <source>Indicate that a formerly enqueued task is complete. Used by queue consumers. For each &lt;a href=&quot;#multiprocessing.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; used to fetch a task, a subsequent call to &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; tells the queue that the processing on the task is complete.</source>
          <target state="translated">이전에 대기중인 작업이 완료되었음을 나타냅니다. 큐 소비자가 사용합니다. 태스크를 페치하는 데 사용 된 각 &lt;a href=&quot;#multiprocessing.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 에 대해 후속 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출 은 태스크 처리가 완료되었음을 큐에 알립니다.</target>
        </trans-unit>
        <trans-unit id="4ca6309605e634742c386580b3f395d337f036d3" translate="yes" xml:space="preserve">
          <source>Indicate that no more data will be put on this queue by the current process. The background thread will quit once it has flushed all buffered data to the pipe. This is called automatically when the queue is garbage collected.</source>
          <target state="translated">현재 프로세스에서이 큐에 더 이상 데이터를 넣지 않음을 나타냅니다. 버퍼링 된 모든 데이터를 파이프로 플러시하면 백그라운드 스레드가 종료됩니다. 큐가 가비지 수집 될 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="254811cd35f7a531bb479a6926167434a7f0d4ff" translate="yes" xml:space="preserve">
          <source>Indicate that the &lt;em&gt;num&lt;/em&gt; screen lines, starting at line &lt;em&gt;beg&lt;/em&gt;, are corrupted and should be completely redrawn on the next &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">행 &lt;em&gt;beg&lt;/em&gt; 에서 시작 하는 &lt;em&gt;num&lt;/em&gt; 화면 행 이 손상되었으며 다음 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 호출 에서 완전히 다시 그려야 함을 나타냅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f187f4b63c4e285d79b6d0cf7c7d659b0be99d5" translate="yes" xml:space="preserve">
          <source>Indicates if a message of severity &lt;em&gt;level&lt;/em&gt; would be processed by this logger. This method checks first the module-level level set by &lt;code&gt;logging.disable(level)&lt;/code&gt; and then the logger&amp;rsquo;s effective level as determined by &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt;&lt;code&gt;getEffectiveLevel()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 로거가 심각도 &lt;em&gt;수준&lt;/em&gt; 의 메시지를 처리 할지 여부를 나타냅니다 . 이 메소드는 먼저 &lt;code&gt;logging.disable(level)&lt;/code&gt; 의해 설정된 모듈 레벨 레벨을 확인한 다음 &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt; &lt;code&gt;getEffectiveLevel()&lt;/code&gt; &lt;/a&gt; 의해 결정된 로거의 유효 레벨을 점검합니다 .</target>
        </trans-unit>
        <trans-unit id="c5c853728e2e1fe3705b4dcef5fcbee47c970151" translate="yes" xml:space="preserve">
          <source>Indicates that an application on 64-bit Windows should operate on the 32-bit registry view.</source>
          <target state="translated">64 비트 Windows의 응용 프로그램이 32 비트 레지스트리보기에서 작동해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be2a690bd039486d70a78d040e16e00e5454af4b" translate="yes" xml:space="preserve">
          <source>Indicates that an application on 64-bit Windows should operate on the 64-bit registry view.</source>
          <target state="translated">64 비트 Windows의 응용 프로그램이 64 비트 레지스트리보기에서 작동해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44029812f3a615dab4b941a3d7aa5ae966773df5" translate="yes" xml:space="preserve">
          <source>Indicates that an operation was requested that does not make sense. If not trapped, returns &lt;code&gt;NaN&lt;/code&gt;. Possible causes include:</source>
          <target state="translated">의미가없는 작업이 요청되었음을 나타냅니다. 갇히지 않으면 &lt;code&gt;NaN&lt;/code&gt; 을 반환 합니다. 가능한 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e5e3976df705a424101261da27cd2fde9d3de10" translate="yes" xml:space="preserve">
          <source>Indicates that rounding occurred and the result is not exact.</source>
          <target state="translated">반올림이 발생했으며 결과가 정확하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cc981c0e44e076ce06474425971fe7b0ad7144fe" translate="yes" xml:space="preserve">
          <source>Indicates the effective level for this logger. If a value other than &lt;code&gt;NOTSET&lt;/code&gt; has been set using &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt;&lt;code&gt;setLevel()&lt;/code&gt;&lt;/a&gt;, it is returned. Otherwise, the hierarchy is traversed towards the root until a value other than &lt;code&gt;NOTSET&lt;/code&gt; is found, and that value is returned. The value returned is an integer, typically one of &lt;code&gt;logging.DEBUG&lt;/code&gt;, &lt;code&gt;logging.INFO&lt;/code&gt; etc.</source>
          <target state="translated">이 로거의 유효 레벨을 나타냅니다. &lt;code&gt;NOTSET&lt;/code&gt; 이외의 값 이 &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt; &lt;code&gt;setLevel()&lt;/code&gt; &lt;/a&gt; 사용하여 설정 되면 값 이 리턴됩니다. 그렇지 않으면 &lt;code&gt;NOTSET&lt;/code&gt; 이외의 값을 찾을 때까지 계층 구조가 루트쪽으로 이동하여 해당 값이 반환됩니다. 반환되는 값은 정수입니다. 일반적으로 &lt;code&gt;logging.DEBUG&lt;/code&gt; , &lt;code&gt;logging.INFO&lt;/code&gt; 등 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="c05b1808b79cd233f656fe2bcfce9be7819d7036" translate="yes" xml:space="preserve">
          <source>Indicates the exponent is larger than &lt;code&gt;Emax&lt;/code&gt; after rounding has occurred. If not trapped, the result depends on the rounding mode, either pulling inward to the largest representable finite number or rounding outward to &lt;code&gt;Infinity&lt;/code&gt;. In either case, &lt;a href=&quot;#decimal.Inexact&quot;&gt;&lt;code&gt;Inexact&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decimal.Rounded&quot;&gt;&lt;code&gt;Rounded&lt;/code&gt;&lt;/a&gt; are also signaled.</source>
          <target state="translated">반올림이 발생한 후 지수가 &lt;code&gt;Emax&lt;/code&gt; 보다 큼을 나타냅니다 . 갇히지 않으면 결과는 반올림 모드에 따라 달라집니다. 표현 가능한 최대 유한 수로 안쪽으로 당기거나 &lt;code&gt;Infinity&lt;/code&gt; 바깥쪽으로 반올림 합니다. 두 경우 모두 &lt;a href=&quot;#decimal.Inexact&quot;&gt; &lt;code&gt;Inexact&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.Rounded&quot;&gt; &lt;code&gt;Rounded&lt;/code&gt; &lt;/a&gt; 도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f77f7a5be2f4f6bec024a7ca688eadb9d8cde39" translate="yes" xml:space="preserve">
          <source>Indicates the fastest compression method (less compression).</source>
          <target state="translated">가장 빠른 압축 방법을 나타냅니다 (낮은 압축).</target>
        </trans-unit>
        <trans-unit id="d526feb8426100dd5e8960080eb37e1f6c7c0e18" translate="yes" xml:space="preserve">
          <source>Indicates the format that the module uses. Version 0 is the historical format, version 1 shares interned strings and version 2 uses a binary format for floating point numbers. Version 3 adds support for object instancing and recursion. The current version is 4.</source>
          <target state="translated">모듈이 사용하는 형식을 나타냅니다. 버전 0은 기록 형식이며, 버전 1은 내부 문자열을 공유하며 버전 2는 부동 소수점 숫자에 이진 형식을 사용합니다. 버전 3은 객체 인스 턴싱 및 재귀에 대한 지원을 추가합니다. 현재 버전은 4입니다.</target>
        </trans-unit>
        <trans-unit id="f9f6bc8bf59e204af2bcdfb956cb28921fb1424b" translate="yes" xml:space="preserve">
          <source>Indicates the slowest compression method (best compression).</source>
          <target state="translated">가장 느린 압축 방법을 나타냅니다 (최상의 압축).</target>
        </trans-unit>
        <trans-unit id="aac4c15b0b527f0bc39db2750782e41d6353de23" translate="yes" xml:space="preserve">
          <source>Indicates unpack completion. Raises an &lt;a href=&quot;#xdrlib.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; exception if all of the data has not been unpacked.</source>
          <target state="translated">포장 풀기 완료를 나타냅니다. 발생시킵니다 &lt;a href=&quot;#xdrlib.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 모든 데이터가 압축 해제되지 않은 경우 예외.</target>
        </trans-unit>
        <trans-unit id="a7b874949185225675d995e483ef8e34af9b6cac" translate="yes" xml:space="preserve">
          <source>Indicates when to change to and back from DST. The format of the start and end dates are one of the following:</source>
          <target state="translated">DST와의 교환시기를 나타냅니다. 시작 날짜와 종료 날짜의 형식은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9f62777df7523c5650cedcd6ae329dd3027c6d33" translate="yes" xml:space="preserve">
          <source>Indicates whether the current platform and implementation provides a symlink attack resistant version of &lt;a href=&quot;#shutil.rmtree&quot;&gt;&lt;code&gt;rmtree()&lt;/code&gt;&lt;/a&gt;. Currently this is only true for platforms supporting fd-based directory access functions.</source>
          <target state="translated">현재 플랫폼 및 구현에서 &lt;a href=&quot;#shutil.rmtree&quot;&gt; &lt;code&gt;rmtree()&lt;/code&gt; &lt;/a&gt; 공격 방지 버전의 rmtree ()를 제공하는지 여부를 나타냅니다 . 현재 이것은 fd 기반 디렉토리 액세스 기능을 지원하는 플랫폼에서만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3de1857c33236705a23bac0cbecb919c2388633f" translate="yes" xml:space="preserve">
          <source>Indicates whether the named &lt;em&gt;section&lt;/em&gt; is present in the configuration. The &lt;em&gt;default section&lt;/em&gt; is not acknowledged.</source>
          <target state="translated">명명 된 &lt;em&gt;섹션&lt;/em&gt; 이 구성에 있는지 여부를 나타냅니다 . &lt;em&gt;기본 부분은&lt;/em&gt; 인정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74f019ba984a0205ae5ca7d205233a0d659108ee" translate="yes" xml:space="preserve">
          <source>Individual flags should have values that are powers of two (1, 2, 4, 8, &amp;hellip;), while combinations of flags won&amp;rsquo;t:</source>
          <target state="translated">개별 플래그는 2의 거듭 제곱 (1, 2, 4, 8,&amp;hellip;) 값을 가져야하지만 플래그 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb56100c551a80a406351b1238fb04cd7a795a80" translate="yes" xml:space="preserve">
          <source>Individual traps are set using the dictionary in the &lt;code&gt;traps&lt;/code&gt; field of a context:</source>
          <target state="translated">개별 트랩은 컨텍스트 의 &lt;code&gt;traps&lt;/code&gt; 필드 에서 사전을 사용하여 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d7a2f3db28391fcf21d52da3f6b53e0db11323d" translate="yes" xml:space="preserve">
          <source>Individual warnings filters are specified as a sequence of fields separated by colons:</source>
          <target state="translated">개별 경고 필터는 콜론으로 구분 된 일련의 필드로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="11d6c70d3b61eb2adec653bae13969c8702afd21" translate="yes" xml:space="preserve">
          <source>Infinite and NaN Number Values</source>
          <target state="translated">무한 및 NaN 숫자 값</target>
        </trans-unit>
        <trans-unit id="fdae9d30d05df13f4736716cf3012faf5a343e86" translate="yes" xml:space="preserve">
          <source>Infinite and NaN number values are accepted and output;</source>
          <target state="translated">무한 및 NaN 숫자 값이 허용되고 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="208f6a4e901648e152bff0d37fcf84f2558c7fa3" translate="yes" xml:space="preserve">
          <source>Infinities can be constructed directly with: &lt;code&gt;Decimal('Infinity')&lt;/code&gt;. Also, they can arise from dividing by zero when the &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt; signal is not trapped. Likewise, when the &lt;a href=&quot;#decimal.Overflow&quot;&gt;&lt;code&gt;Overflow&lt;/code&gt;&lt;/a&gt; signal is not trapped, infinity can result from rounding beyond the limits of the largest representable number.</source>
          <target state="translated">&lt;code&gt;Decimal('Infinity')&lt;/code&gt; 직접 구성 할 수 있습니다 . 또한 &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; &lt;/a&gt; 신호가 트랩되지 않은 경우 0으로 나누면 발생할 수 있습니다 . 마찬가지로, &lt;a href=&quot;#decimal.Overflow&quot;&gt; &lt;code&gt;Overflow&lt;/code&gt; &lt;/a&gt; 신호가 트래핑되지 않으면 최대 표현 가능한 수의 한계를 초과하는 반올림으로 인해 무한대가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5b789236efcc14059ac13c746c6bf63a446511" translate="yes" xml:space="preserve">
          <source>Info-ZIP Home Page</source>
          <target state="translated">Info-ZIP 홈페이지</target>
        </trans-unit>
        <trans-unit id="f1a9ffafc271a884fe1c56d1e91026a9afac1d59" translate="yes" xml:space="preserve">
          <source>Information about how the &lt;a href=&quot;#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module can be used to replace these modules and functions can be found in the following sections.</source>
          <target state="translated">&lt;a href=&quot;#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 이러한 모듈 및 기능을 대체 하는 방법에 대한 정보 는 다음 섹션에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73dc9ae5bb811ec4a81b13ac14f9d0600c74bdc0" translate="yes" xml:space="preserve">
          <source>Information about the Info-ZIP project&amp;rsquo;s ZIP archive programs and development libraries.</source>
          <target state="translated">Info-ZIP 프로젝트의 ZIP 보관 프로그램 및 개발 라이브러리에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="5dca2a23bec2c3f3823dba848b63caa3ddd34f46" translate="yes" xml:space="preserve">
          <source>Information about the declarations needed to process a document.</source>
          <target state="translated">문서를 처리하는 데 필요한 선언에 대한 정보</target>
        </trans-unit>
        <trans-unit id="37721dc7ffd07b44f936ed4938598a4206ad258c" translate="yes" xml:space="preserve">
          <source>Information about the notations and entities declared by a document (including the external subset if the parser uses it and can provide the information) is available from a &lt;code&gt;DocumentType&lt;/code&gt; object. The &lt;code&gt;DocumentType&lt;/code&gt; for a document is available from the &lt;code&gt;Document&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;doctype&lt;/code&gt; attribute; if there is no &lt;code&gt;DOCTYPE&lt;/code&gt; declaration for the document, the document&amp;rsquo;s &lt;code&gt;doctype&lt;/code&gt; attribute will be set to &lt;code&gt;None&lt;/code&gt; instead of an instance of this interface.</source>
          <target state="translated">문서에 의해 선언 된 표기법 및 엔티티에 대한 정보 (구문 파서가 사용하고 정보를 제공 할 수있는 경우 외부 서브 세트 포함)는 &lt;code&gt;DocumentType&lt;/code&gt; 객체 에서 사용할 수 있습니다 . &lt;code&gt;DocumentType&lt;/code&gt; 의 DocumentType 은 &lt;code&gt;Document&lt;/code&gt; 객체의 &lt;code&gt;doctype&lt;/code&gt; 속성 에서 사용할 수 있습니다 . 문서에 대한 &lt;code&gt;DOCTYPE&lt;/code&gt; 선언 이없는 경우이 인터페이스의 인스턴스 대신 문서의 &lt;code&gt;doctype&lt;/code&gt; 속성이 &lt;code&gt;None&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cce32b3d49301f675170423df0e3a5fe42a9f458" translate="yes" xml:space="preserve">
          <source>Information about the version of the zlib library in use is available through the following constants:</source>
          <target state="translated">사용중인 zlib 라이브러리 버전에 대한 정보는 다음 상수를 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc195259320a72e072f4ede32b54adf6cc49ee6" translate="yes" xml:space="preserve">
          <source>Informs the logging system to perform an orderly shutdown by flushing and closing all handlers. This should be called at application exit and no further use of the logging system should be made after this call.</source>
          <target state="translated">모든 핸들러를 플러시하고 닫아서 로깅 시스템에 순차적으로 종료하도록 지시합니다. 애플리케이션 종료시 호출해야하며이 호출 후에는 로깅 시스템을 더 이상 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="8c3b7e7bdfb6a623a8eb23a0493ea3c67706b89d" translate="yes" xml:space="preserve">
          <source>Inheritance of File Descriptors</source>
          <target state="translated">파일 디스크립터의 상속</target>
        </trans-unit>
        <trans-unit id="6bce323c70ebeda273b76b4deb2d56162be0c2e0" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Mapping&quot;&gt;&lt;code&gt;Mapping&lt;/code&gt;&lt;/a&gt; methods and &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;popitem&lt;/code&gt;, &lt;code&gt;clear&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;setdefault&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Mapping&quot;&gt; &lt;code&gt;Mapping&lt;/code&gt; &lt;/a&gt; 메소드 및 &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;popitem&lt;/code&gt; , &lt;code&gt;clear&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;setdefault&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06211f7ed37f2fb2fd3d0b096255e56986486d8f" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; methods</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="6c8ee095532c52fa04b5b2f4774ee70078537885" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; methods and &lt;code&gt;append&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;__iadd__&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt; 메소드 및 &lt;code&gt;append&lt;/code&gt; , &lt;code&gt;reverse&lt;/code&gt; , &lt;code&gt;extend&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;__iadd__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d51fda0d61054bbf60003067c334dea455e6a456" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; methods and &lt;code&gt;clear&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;__ior__&lt;/code&gt;, &lt;code&gt;__iand__&lt;/code&gt;, &lt;code&gt;__ixor__&lt;/code&gt;, and &lt;code&gt;__isub__&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 메서드 및 &lt;code&gt;clear&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;__ior__&lt;/code&gt; , &lt;code&gt;__iand__&lt;/code&gt; , &lt;code&gt;__ixor__&lt;/code&gt; 및 &lt;code&gt;__isub__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="379c6401d036c1fd4201479a5a98fa61950fb477" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; methods, &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, and &lt;code&gt;newlines&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 메서드, &lt;code&gt;encoding&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; 및 줄 &lt;code&gt;newlines&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f9245eee96edcd8825a2046422c07072497cf0f" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; methods, &lt;code&gt;read&lt;/code&gt;, and &lt;code&gt;readall&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 메서드, &lt;code&gt;read&lt;/code&gt; 및 &lt;code&gt;readall&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a95bfb8966052c1a0ceee8247e352fac2cbbb068" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; methods, &lt;code&gt;readinto&lt;/code&gt;, and &lt;code&gt;readinto1&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 메서드 &lt;code&gt;readinto&lt;/code&gt; 및 &lt;code&gt;readinto1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2f86a0622771a4fe382df1bdcb5afbbe667c715" translate="yes" xml:space="preserve">
          <source>Inherits</source>
          <target state="translated">Inherits</target>
        </trans-unit>
        <trans-unit id="b22e7705af8c8d03aae22d1b8adde6a0eccc1637" translate="yes" xml:space="preserve">
          <source>Inherits from</source>
          <target state="translated">에서 상속</target>
        </trans-unit>
        <trans-unit id="2bc75738f31d4cad0d4af9bafd60101443b8a470" translate="yes" xml:space="preserve">
          <source>Init file</source>
          <target state="translated">초기화 파일</target>
        </trans-unit>
        <trans-unit id="a84f9ff878eec42e40bd18840ce1e8b26a925aef" translate="yes" xml:space="preserve">
          <source>Init-only variables</source>
          <target state="translated">초기화 전용 변수</target>
        </trans-unit>
        <trans-unit id="f5d6a89f24c042aeeed4c674d462173e914e969f" translate="yes" xml:space="preserve">
          <source>Init-only variables without default values, if any exist, must be specified on the call to &lt;a href=&quot;#dataclasses.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt; so that they can be passed to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;__post_init__()&lt;/code&gt;.</source>
          <target state="translated">기본값이없는 초기화 전용 변수 &lt;a href=&quot;#dataclasses.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;__post_init__()&lt;/code&gt; 로 전달 될 수 있도록 replace () 호출에 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ae7812ad31389ab36e054e9b5c81ee4355c0c33" translate="yes" xml:space="preserve">
          <source>Initial turtle heading</source>
          <target state="translated">초기 거북이 제목</target>
        </trans-unit>
        <trans-unit id="9c053c5a31de248a3fe3887d73e022ca74699147" translate="yes" xml:space="preserve">
          <source>Initialize curses and call another callable object, &lt;em&gt;func&lt;/em&gt;, which should be the rest of your curses-using application. If the application raises an exception, this function will restore the terminal to a sane state before re-raising the exception and generating a traceback. The callable object &lt;em&gt;func&lt;/em&gt; is then passed the main window &amp;lsquo;stdscr&amp;rsquo; as its first argument, followed by any other arguments passed to &lt;code&gt;wrapper()&lt;/code&gt;. Before calling &lt;em&gt;func&lt;/em&gt;, &lt;code&gt;wrapper()&lt;/code&gt; turns on cbreak mode, turns off echo, enables the terminal keypad, and initializes colors if the terminal has color support. On exit (whether normally or by exception) it restores cooked mode, turns on echo, and disables the terminal keypad.</source>
          <target state="translated">저주를 초기화하고 호출 가능한 다른 응용 프로그램 인 &lt;em&gt;func를&lt;/em&gt; 호출 하십시오. 응용 프로그램에서 예외가 발생하면이 기능은 예외를 다시 발생시키고 역 추적을 생성하기 전에 터미널을 정상 상태로 복원합니다. 호출 가능한 객체 &lt;em&gt;func&lt;/em&gt; 는 주 창 'stdscr'을 첫 번째 인수로 전달한 다음 &lt;code&gt;wrapper()&lt;/code&gt; 전달 된 다른 인수를 전달합니다 . 호출하기 전에 &lt;em&gt;FUNC&lt;/em&gt; , &lt;code&gt;wrapper()&lt;/code&gt; CBREAK 모드에 대한 회전은, 에코 오프 회전은, 터미널 키패드를 가능하게하고, 터미널 색상 지원이있는 경우 색상을 초기화한다. 종료시 (정상 또는 예외 여부에 관계없이) 쿠킹 모드를 복원하고 에코를 켜고 터미널 키패드를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3c39102c3fa06222a5c163727b0377eb39a67e1f" translate="yes" xml:space="preserve">
          <source>Initialize the internal data structures. If given, &lt;em&gt;files&lt;/em&gt; must be a sequence of file names which should be used to augment the default type map. If omitted, the file names to use are taken from &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt;&lt;code&gt;knownfiles&lt;/code&gt;&lt;/a&gt;; on Windows, the current registry settings are loaded. Each file named in &lt;em&gt;files&lt;/em&gt; or &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt;&lt;code&gt;knownfiles&lt;/code&gt;&lt;/a&gt; takes precedence over those named before it. Calling &lt;a href=&quot;#mimetypes.init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/a&gt; repeatedly is allowed.</source>
          <target state="translated">내부 데이터 구조를 초기화하십시오. 주어진 경우, &lt;em&gt;파일&lt;/em&gt; 은 기본 유형 맵을 기능 보강하는 데 사용해야하는 일련의 파일 이름이어야합니다. 생략하면 사용할 파일 이름은 &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt; &lt;code&gt;knownfiles&lt;/code&gt; &lt;/a&gt; 파일에서 가져옵니다 . Windows에서는 현재 레지스트리 설정이로드됩니다. &lt;em&gt;파일&lt;/em&gt; 또는 &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt; &lt;code&gt;knownfiles&lt;/code&gt; &lt;/a&gt; 파일로 명명 된 각 파일은 이전에 명명 된 &lt;em&gt;파일&lt;/em&gt; 보다 우선합니다. &lt;a href=&quot;#mimetypes.init&quot;&gt; &lt;code&gt;init()&lt;/code&gt; &lt;/a&gt; 반복해서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67a777e10b60c9589ca15590b09a5cec97aaa843" translate="yes" xml:space="preserve">
          <source>Initialize the library. Return a &lt;a href=&quot;#curses-window-objects&quot;&gt;window&lt;/a&gt; object which represents the whole screen.</source>
          <target state="translated">라이브러리를 초기화하십시오. 전체 화면을 나타내는 &lt;a href=&quot;#curses-window-objects&quot;&gt;창&lt;/a&gt; 개체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="48428a849fbd7ccb672616c8d11dd86f3867404a" translate="yes" xml:space="preserve">
          <source>Initialize the random number generator.</source>
          <target state="translated">난수 생성기를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="70995d6f7eecb673c201a63dd47d29c6584b9166" translate="yes" xml:space="preserve">
          <source>Initialize the terminal. &lt;em&gt;term&lt;/em&gt; is a string giving the terminal name, or &lt;code&gt;None&lt;/code&gt;; if omitted or &lt;code&gt;None&lt;/code&gt;, the value of the &lt;code id=&quot;index-1&quot;&gt;TERM&lt;/code&gt; environment variable will be used. &lt;em&gt;fd&lt;/em&gt; is the file descriptor to which any initialization sequences will be sent; if not supplied or &lt;code&gt;-1&lt;/code&gt;, the file descriptor for &lt;code&gt;sys.stdout&lt;/code&gt; will be used.</source>
          <target state="translated">터미널을 초기화하십시오. &lt;em&gt;term&lt;/em&gt; 은 터미널 이름을 나타내는 문자열이거나 &lt;code&gt;None&lt;/code&gt; 입니다 . 생략되거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code id=&quot;index-1&quot;&gt;TERM&lt;/code&gt; 환경 변수 의 값 이 사용됩니다. &lt;em&gt;fd&lt;/em&gt; 는 초기화 시퀀스가 ​​전송 될 파일 &lt;em&gt;디스크립터&lt;/em&gt; 입니다. 제공되지 않거나 &lt;code&gt;-1&lt;/code&gt; 이면 &lt;code&gt;sys.stdout&lt;/code&gt; 의 파일 디스크립터 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab79211166494a5373743e60ba9599daf58a2af2" translate="yes" xml:space="preserve">
          <source>Initializers of the correct type can also be specified:</source>
          <target state="translated">올바른 유형의 이니셜 라이저도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc9f180e9eb479c565d2e3c4fd6ce05ca9e580e" translate="yes" xml:space="preserve">
          <source>Initializes a thread lock which can be used to serialize access to underlying I/O functionality which may not be threadsafe.</source>
          <target state="translated">스레드 안전하지 않을 수있는 기본 I / O 기능에 대한 액세스를 직렬화하는 데 사용할 수있는 스레드 잠금을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3852a908d7c934410ea309c7ea1ea46af8743103" translate="yes" xml:space="preserve">
          <source>Initializes instance of &lt;a href=&quot;#difflib.HtmlDiff&quot;&gt;&lt;code&gt;HtmlDiff&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#difflib.HtmlDiff&quot;&gt; &lt;code&gt;HtmlDiff&lt;/code&gt; &lt;/a&gt; 인스턴스를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="f5885aef6f5096d972360ad2af443e94000e495a" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;a href=&quot;#logging.Handler&quot;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt; instance by setting its level, setting the list of filters to the empty list and creating a lock (using &lt;a href=&quot;#logging.Handler.createLock&quot;&gt;&lt;code&gt;createLock()&lt;/code&gt;&lt;/a&gt;) for serializing access to an I/O mechanism.</source>
          <target state="translated">레벨을 설정하고 필터 목록을 빈 목록 으로 설정하고 I / O 메커니즘에 대한 액세스를 직렬화하기위한 잠금을 작성 ( &lt;a href=&quot;#logging.Handler.createLock&quot;&gt; &lt;code&gt;createLock()&lt;/code&gt; &lt;/a&gt; ) 하여 &lt;a href=&quot;#logging.Handler&quot;&gt; &lt;code&gt;Handler&lt;/code&gt; &lt;/a&gt; 인스턴스를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="891e93a281cdc0ae8bd4cb4966bc1555092cc9eb" translate="yes" xml:space="preserve">
          <source>Initializes the given module object in accordance with &lt;a href=&quot;https://www.python.org/dev/peps/pep-0489&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 489&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0489&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 489&lt;/strong&gt;&lt;/a&gt; 에 따라 지정된 모듈 객체를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="76391f6bbc3769470e5c6904d1885bcf07a8f838" translate="yes" xml:space="preserve">
          <source>Initializes the handler with a buffer of the specified capacity. Here, &lt;em&gt;capacity&lt;/em&gt; means the number of logging records buffered.</source>
          <target state="translated">지정된 용량의 버퍼로 핸들러를 초기화합니다. 여기서 &lt;em&gt;capacity&lt;/em&gt; 는 버퍼링 된 로깅 레코드 수를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6a4659852d66e1b08bbacb99cd059b9b5779e858" translate="yes" xml:space="preserve">
          <source>Initially &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; defined Python static type system as using &lt;em&gt;nominal subtyping&lt;/em&gt;. This means that a class &lt;code&gt;A&lt;/code&gt; is allowed where a class &lt;code&gt;B&lt;/code&gt; is expected if and only if &lt;code&gt;A&lt;/code&gt; is a subclass of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">처음에 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 484는&lt;/strong&gt;&lt;/a&gt;&lt;em&gt; 공칭 서브&lt;/em&gt; 타이핑을 사용하여 Python 정적 유형 시스템을 정의했습니다 . 이 수단은 클래스 것을 &lt;code&gt;A&lt;/code&gt; 를 클래스 허용 여기서 &lt;code&gt;B&lt;/code&gt; 는 경우에만, 예상 &lt;code&gt;A&lt;/code&gt; 는 의 서브 &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651e55be975986e7fd15535125aa6f9af6b714d3" translate="yes" xml:space="preserve">
          <source>Initially, when a program is started, the locale is the &lt;code&gt;C&lt;/code&gt; locale, no matter what the user&amp;rsquo;s preferred locale is. There is one exception: the &lt;a href=&quot;#locale.LC_CTYPE&quot;&gt;&lt;code&gt;LC_CTYPE&lt;/code&gt;&lt;/a&gt; category is changed at startup to set the current locale encoding to the user&amp;rsquo;s preferred locale encoding. The program must explicitly say that it wants the user&amp;rsquo;s preferred locale settings for other categories by calling &lt;code&gt;setlocale(LC_ALL, '')&lt;/code&gt;.</source>
          <target state="translated">처음에 프로그램이 시작되면 사용자가 선호하는 로캘이 무엇이든 로캘은 &lt;code&gt;C&lt;/code&gt; 로캘입니다. 한 가지 예외가 있습니다. &lt;a href=&quot;#locale.LC_CTYPE&quot;&gt; &lt;code&gt;LC_CTYPE&lt;/code&gt; &lt;/a&gt; 범주는 시작시 현재 로캘 인코딩을 사용자가 선호하는 로캘 인코딩으로 설정하도록 변경됩니다. 프로그램은 &lt;code&gt;setlocale(LC_ALL, '')&lt;/code&gt; 을 호출하여 다른 카테고리에 대해 사용자가 선호하는 로케일 설정을 원한다고 명시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b6d8ad6283ed79c07a911360e0d9b48d60fca9b3" translate="yes" xml:space="preserve">
          <source>Initiate a transfer over the data connection. If the transfer is active, send an &lt;code&gt;EPRT&lt;/code&gt; or &lt;code&gt;PORT&lt;/code&gt; command and the transfer command specified by &lt;em&gt;cmd&lt;/em&gt;, and accept the connection. If the server is passive, send an &lt;code&gt;EPSV&lt;/code&gt; or &lt;code&gt;PASV&lt;/code&gt; command, connect to it, and start the transfer command. Either way, return the socket for the connection.</source>
          <target state="translated">데이터 연결을 통한 전송을 시작하십시오. 전송이 활성화 된 경우 &lt;code&gt;EPRT&lt;/code&gt; 또는 &lt;code&gt;PORT&lt;/code&gt; 명령과 &lt;em&gt;cmd로&lt;/em&gt; 지정된 전송 명령을 전송 하고 연결을 수락하십시오. 서버가 수동 인 경우 &lt;code&gt;EPSV&lt;/code&gt; 또는 &lt;code&gt;PASV&lt;/code&gt; 명령을 전송하고 연결 한 후 전송 명령을 시작하십시오. 어느 쪽이든 연결 소켓을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="a3b934f82fa9691663fe5cc49e6c91ec415ce86a" translate="yes" xml:space="preserve">
          <source>Inode number.</source>
          <target state="translated">아이 노드 번호.</target>
        </trans-unit>
        <trans-unit id="61f3e06ef66f729eb248fc28dbd015725fbd26d3" translate="yes" xml:space="preserve">
          <source>Inode protection mode.</source>
          <target state="translated">아이 노드 보호 모드.</target>
        </trans-unit>
        <trans-unit id="abc398c151cedbf682a4e32b5fe1f87a91547da5" translate="yes" xml:space="preserve">
          <source>Input methods</source>
          <target state="translated">입력 방법</target>
        </trans-unit>
        <trans-unit id="3bac6667a1606f6aae5b9d31130c86a61ea3e529" translate="yes" xml:space="preserve">
          <source>Input parameter which defaults to the integer zero.</source>
          <target state="translated">기본값은 정수 0입니다.</target>
        </trans-unit>
        <trans-unit id="f0dadaeaa1a0521f244cb0c7817109df239c4e4a" translate="yes" xml:space="preserve">
          <source>Input/ouput</source>
          <target state="translated">Input/ouput</target>
        </trans-unit>
        <trans-unit id="cfb6ac42c15bfc315aef836b57bb90c22f4f147f" translate="yes" xml:space="preserve">
          <source>InputSource Objects</source>
          <target state="translated">입력 소스 객체</target>
        </trans-unit>
        <trans-unit id="98cceba3103286deb746764afbe409454e752550" translate="yes" xml:space="preserve">
          <source>Inputs as in &lt;a href=&quot;#turtle.pencolor&quot;&gt;&lt;code&gt;pencolor()&lt;/code&gt;&lt;/a&gt;, set both, fillcolor and pencolor, to the given value.</source>
          <target state="translated">&lt;a href=&quot;#turtle.pencolor&quot;&gt; &lt;code&gt;pencolor()&lt;/code&gt; &lt;/a&gt; 에서와 같이 입력하고 fillcolor와 pencolor를 모두 주어진 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="5c6157626eaa443a7d46529cadb0898d243cf4bf" translate="yes" xml:space="preserve">
          <source>Insert ## in front of selected lines.</source>
          <target state="translated">선택한 줄 앞에 ##을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="771d3a8e81fd09fb95d718f0e07e3c3ed54b1cb1" translate="yes" xml:space="preserve">
          <source>Insert &lt;em&gt;nlines&lt;/em&gt; lines into the specified window above the current line. The &lt;em&gt;nlines&lt;/em&gt; bottom lines are lost. For negative &lt;em&gt;nlines&lt;/em&gt;, delete &lt;em&gt;nlines&lt;/em&gt; lines starting with the one under the cursor, and move the remaining lines up. The bottom &lt;em&gt;nlines&lt;/em&gt; lines are cleared. The current cursor position remains the same.</source>
          <target state="translated">&lt;em&gt;nlines&lt;/em&gt; 행을 현재 행 위의 지정된 창에 삽입하십시오 . &lt;em&gt;NLINES&lt;/em&gt; 수익성이 손실됩니다. 음수 &lt;em&gt;nlines의&lt;/em&gt; 경우 커서 아래에있는 것으로 시작하여 &lt;em&gt;nlines&lt;/em&gt; 행을 삭제 하고 나머지 행을 위로 이동하십시오. 하단 &lt;em&gt;NLINES&lt;/em&gt; 라인은 삭제됩니다. 현재 커서 위치는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab25aba32579e4cbe82e3445dbc2750c5f19e2d" translate="yes" xml:space="preserve">
          <source>Insert &lt;em&gt;x&lt;/em&gt; in &lt;em&gt;a&lt;/em&gt; in sorted order. This is equivalent to &lt;code&gt;a.insert(bisect.bisect_left(a, x, lo, hi), x)&lt;/code&gt; assuming that &lt;em&gt;a&lt;/em&gt; is already sorted. Keep in mind that the O(log n) search is dominated by the slow O(n) insertion step.</source>
          <target state="translated">삽입 &lt;em&gt;X&lt;/em&gt; 에 정렬 된 순서. 이것은 &lt;em&gt;a&lt;/em&gt; 가 이미 정렬되어 있다고 가정하면 &lt;code&gt;a.insert(bisect.bisect_left(a, x, lo, hi), x)&lt;/code&gt; . O (log n) 검색은 느린 O (n) 삽입 단계에 의해 지배됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ffe19f9b53fcc062222865d04ee695208ba7423" translate="yes" xml:space="preserve">
          <source>Insert &lt;em&gt;x&lt;/em&gt; into the deque at position &lt;em&gt;i&lt;/em&gt;.</source>
          <target state="translated">위치 &lt;em&gt;i&lt;/em&gt; 의 데크에 &lt;em&gt;x&lt;/em&gt; 를 삽입하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e69d0858508dfc3e6620fa59f50ef0662785e9c6" translate="yes" xml:space="preserve">
          <source>Insert CGI variables for the current request into the &lt;code&gt;environ&lt;/code&gt; attribute.</source>
          <target state="translated">현재 요청에 대한 CGI 변수를 &lt;code&gt;environ&lt;/code&gt; 속성에 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="11cf289408f544e7431d78ef915fdb066ede3d6a" translate="yes" xml:space="preserve">
          <source>Insert a blank line at cursor location.</source>
          <target state="translated">커서 위치에 빈 줄을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="428b27b44b5679a5100cbb0f2b51ce75dd8a5bf2" translate="yes" xml:space="preserve">
          <source>Insert a blank line under the cursor. All following lines are moved down by one line.</source>
          <target state="translated">커서 아래에 빈 줄을 삽입하십시오. 다음 줄은 모두 한 줄 아래로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8cc41d420c2a48fb3dbe04ee4c88fa790360f745" translate="yes" xml:space="preserve">
          <source>Insert a character string (as many characters as will fit on the line) before the character under the cursor, up to &lt;em&gt;n&lt;/em&gt; characters. If &lt;em&gt;n&lt;/em&gt; is zero or negative, the entire string is inserted. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to &lt;em&gt;y&lt;/em&gt;, &lt;em&gt;x&lt;/em&gt;, if specified).</source>
          <target state="translated">커서 아래의 문자 앞에 최대 &lt;em&gt;n&lt;/em&gt; 자 까지 문자열을 입력하십시오 (행에 맞는 문자 수). 경우 &lt;em&gt;n이&lt;/em&gt; 제로 또는 네거티브 전체 문자열을 삽입한다. 커서 오른쪽의 모든 문자가 오른쪽으로 이동하고 줄의 가장 오른쪽 문자가 손실됩니다. 커서 위치는 변경되지 않습니다 ( 지정된 경우 &lt;em&gt;y&lt;/em&gt; , &lt;em&gt;x로&lt;/em&gt; 이동 한 후 ).</target>
        </trans-unit>
        <trans-unit id="52ef5c0b09949330d13e4bb951c2c108148e5ec6" translate="yes" xml:space="preserve">
          <source>Insert a character string (as many characters as will fit on the line) before the character under the cursor. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to &lt;em&gt;y&lt;/em&gt;, &lt;em&gt;x&lt;/em&gt;, if specified).</source>
          <target state="translated">커서 아래의 문자 앞에 문자 문자열 (행에 맞는 문자 수)을 삽입하십시오. 커서 오른쪽의 모든 문자가 오른쪽으로 이동하고 줄의 가장 오른쪽 문자가 손실됩니다. 커서 위치는 변경되지 않습니다 ( 지정된 경우 &lt;em&gt;y&lt;/em&gt; , &lt;em&gt;x로&lt;/em&gt; 이동 한 후 ).</target>
        </trans-unit>
        <trans-unit id="2cd230c1b957b61fbeafaadd6ef3bd7966d963f4" translate="yes" xml:space="preserve">
          <source>Insert a new child node before an existing child. It must be the case that &lt;em&gt;refChild&lt;/em&gt; is a child of this node; if not, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. &lt;em&gt;newChild&lt;/em&gt; is returned. If &lt;em&gt;refChild&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, it inserts &lt;em&gt;newChild&lt;/em&gt; at the end of the children&amp;rsquo;s list.</source>
          <target state="translated">기존 자식 앞에 새 자식 노드를 삽입하십시오. &lt;em&gt;refChild&lt;/em&gt; 가이 노드의 자식 인 경우 여야 합니다. 그렇지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;em&gt;newChild&lt;/em&gt; 가 반환됩니다. 경우 &lt;em&gt;refChild의가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 그것은 삽입 &lt;em&gt;를 newChild를&lt;/em&gt; 아이들의 목록의 끝에서.</target>
        </trans-unit>
        <trans-unit id="dbbded73e99c71141ac74230b61b365295b11341" translate="yes" xml:space="preserve">
          <source>Insert a new item with value &lt;em&gt;x&lt;/em&gt; in the array before position &lt;em&gt;i&lt;/em&gt;. Negative values are treated as being relative to the end of the array.</source>
          <target state="translated">위치 &lt;em&gt;i&lt;/em&gt; 앞에 배열에 값이 &lt;em&gt;x 인&lt;/em&gt; 새 항목을 삽입하십시오 . 음수 값은 배열의 끝을 기준으로 처리됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6442b4677754abf24013415cfc0b02328c37bf8d" translate="yes" xml:space="preserve">
          <source>Insert a simple entry into the list of &lt;a href=&quot;#warning-filter&quot;&gt;warnings filter specifications&lt;/a&gt;. The meaning of the function parameters is as for &lt;a href=&quot;#warnings.filterwarnings&quot;&gt;&lt;code&gt;filterwarnings()&lt;/code&gt;&lt;/a&gt;, but regular expressions are not needed as the filter inserted always matches any message in any module as long as the category and line number match.</source>
          <target state="translated">&lt;a href=&quot;#warning-filter&quot;&gt;경고 필터 사양&lt;/a&gt; 목록에 간단한 항목을 삽입하십시오 . 함수 매개 변수의 의미는 &lt;a href=&quot;#warnings.filterwarnings&quot;&gt; &lt;code&gt;filterwarnings()&lt;/code&gt; &lt;/a&gt; 와 같지만 삽입 된 필터는 범주 및 줄 번호가 일치하는 한 모듈의 모든 메시지와 항상 일치하므로 정규식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be8c8abeab9182b5ad4c0936ac5747b095eb532b" translate="yes" xml:space="preserve">
          <source>Insert an &lt;em&gt;ms&lt;/em&gt; millisecond pause in output.</source>
          <target state="translated">출력에 &lt;em&gt;ms&lt;/em&gt; 밀리 초 일시 중지를 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="73267e5ac5110513448a2a6d6f16738aaf106dd8" translate="yes" xml:space="preserve">
          <source>Insert an entry into the list of &lt;a href=&quot;#warning-filter&quot;&gt;warnings filter specifications&lt;/a&gt;. The entry is inserted at the front by default; if &lt;em&gt;append&lt;/em&gt; is true, it is inserted at the end. This checks the types of the arguments, compiles the &lt;em&gt;message&lt;/em&gt; and &lt;em&gt;module&lt;/em&gt; regular expressions, and inserts them as a tuple in the list of warnings filters. Entries closer to the front of the list override entries later in the list, if both match a particular warning. Omitted arguments default to a value that matches everything.</source>
          <target state="translated">&lt;a href=&quot;#warning-filter&quot;&gt;경고 필터 사양&lt;/a&gt; 목록에 항목을 삽입하십시오 . 항목은 기본적으로 앞에 삽입됩니다. 경우 &lt;em&gt;APPEND는&lt;/em&gt; 사실, 그것은 마지막에 삽입됩니다. 인수의 유형을 확인하고 &lt;em&gt;메시지&lt;/em&gt; 및 &lt;em&gt;모듈&lt;/em&gt; 정규식을 컴파일 한 후 경고 필터 목록에 튜플로 삽입합니다. 목록 앞쪽에 더 가까운 항목은 둘 다 특정 경고와 일치하면 목록의 뒷부분에있는 항목보다 우선합니다. 생략 된 인수의 기본값은 모든 항목과 일치하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="ff80a5974b23d77a5c2b2ad834261e49b5ed7b09" translate="yes" xml:space="preserve">
          <source>Insert char or enter insert mode</source>
          <target state="translated">문자 삽입 또는 삽입 모드로 들어가기</target>
        </trans-unit>
        <trans-unit id="e1b4dd9343d0aec1500078fcc20dfa87ecdaec8c" translate="yes" xml:space="preserve">
          <source>Insert contents of the system-wide clipboard into the current window.</source>
          <target state="translated">시스템 전체 클립 보드의 내용을 현재 창에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="1d9d9fcb3881a1a7b2f39fbd44148815f8ffb775" translate="yes" xml:space="preserve">
          <source>Insert line</source>
          <target state="translated">라인 삽입</target>
        </trans-unit>
        <trans-unit id="85b1c3bfc9615f38c45334ce27a2c3874f427470" translate="yes" xml:space="preserve">
          <source>Insert text into the line buffer at the cursor position. This calls &lt;code&gt;rl_insert_text()&lt;/code&gt; in the underlying library, but ignores the return value.</source>
          <target state="translated">커서 위치에서 라인 버퍼에 텍스트를 삽입하십시오. 기본 라이브러리에서 &lt;code&gt;rl_insert_text()&lt;/code&gt; 를 호출 하지만 반환 값은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="321a83365ddb728f137f24e4d0374b111b7a89d6" translate="yes" xml:space="preserve">
          <source>Inserts &lt;em&gt;subelement&lt;/em&gt; at the given position in this element. Raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;subelement&lt;/em&gt; is not an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 요소의 지정된 위치에 &lt;em&gt;하위 요소&lt;/em&gt; 를 삽입합니다 . 발생시킵니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 경우 &lt;em&gt;하위 요소가&lt;/em&gt; 없는 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07136851031cb8faca3df628c368a5d3f07c5e9a" translate="yes" xml:space="preserve">
          <source>Inserts a pane at the specified position.</source>
          <target state="translated">지정된 위치에 구획을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="603a69de2ef615fc4774dc5a531b0478d24bd0ba" translate="yes" xml:space="preserve">
          <source>Install a timer that calls &lt;em&gt;fun&lt;/em&gt; after &lt;em&gt;t&lt;/em&gt; milliseconds.</source>
          <target state="translated">&lt;em&gt;t&lt;/em&gt; 밀리 초 후에 &lt;em&gt;재미있게&lt;/em&gt; 호출되는 타이머를 설치하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d804377ba7463dd5b6eaba5ccaaad14a63c4069" translate="yes" xml:space="preserve">
          <source>Install all of your application&amp;rsquo;s dependencies into the &lt;code&gt;myapp&lt;/code&gt; directory, using pip:</source>
          <target state="translated">pip를 사용하여 모든 애플리케이션의 종속성을 &lt;code&gt;myapp&lt;/code&gt; 디렉토리에 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="520b157afbe331621bce1a360a6f018e0e187fbb" translate="yes" xml:space="preserve">
          <source>Install an &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt; instance as the default global opener. Installing an opener is only necessary if you want urlopen to use that opener; otherwise, simply call &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt;&lt;code&gt;OpenerDirector.open()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt;. The code does not check for a real &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt;, and any class with the appropriate interface will work.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; &lt;/a&gt; 인스턴스를 기본 글로벌 오프너로 설치하십시오 . 오프너 설치는 urlopen이 해당 오프너를 사용하도록하려는 경우에만 필요합니다. 그렇지 않으면 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt; &lt;code&gt;OpenerDirector.open()&lt;/code&gt; &lt;/a&gt; 호출 하십시오 . 코드는 실제 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; 를&lt;/a&gt; 확인하지 않으며 적절한 인터페이스를 가진 클래스가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="455b086ac3298a91870a87090996554bb11b3083" translate="yes" xml:space="preserve">
          <source>Install the control-c handler. When a &lt;code&gt;signal.SIGINT&lt;/code&gt; is received (usually in response to the user pressing control-c) all registered results have &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; called.</source>
          <target state="translated">control-c 핸들러를 설치하십시오. &lt;code&gt;signal.SIGINT&lt;/code&gt; 가 수신 되면 (보통 control-c를 누르는 사용자에 대한 응답으로) 등록 된 모든 결과에는 &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9844ff0d9d22475c61112c01b5f0c916b24483" translate="yes" xml:space="preserve">
          <source>Installation paths</source>
          <target state="translated">설치 경로</target>
        </trans-unit>
        <trans-unit id="e23f8bdbda721b9cbed1f844f7307a95d9b58116" translate="yes" xml:space="preserve">
          <source>Installing Python Modules</source>
          <target state="translated">파이썬 모듈 설치</target>
        </trans-unit>
        <trans-unit id="a5aa044edf2a4b23b0600882b63f3573a49708ee" translate="yes" xml:space="preserve">
          <source>Installing Python Modules (Legacy version)</source>
          <target state="translated">Python 모듈 설치 (레거시 버전)</target>
        </trans-unit>
        <trans-unit id="71e27cbe55c7ee739cd8deca3e2c0f21cd96ea3e" translate="yes" xml:space="preserve">
          <source>Installing your CGI script on a Unix system</source>
          <target state="translated">유닉스 시스템에 CGI 스크립트 설치</target>
        </trans-unit>
        <trans-unit id="c1d91ffedb22549df648586a28db755e96527174" translate="yes" xml:space="preserve">
          <source>Installs activation scripts appropriate to the platform into the virtual environment.</source>
          <target state="translated">플랫폼에 적합한 활성화 스크립트를 가상 환경에 설치합니다.</target>
        </trans-unit>
        <trans-unit id="02d9da332f931b3a6a11cc4f1b01fd46bbfd85c7" translate="yes" xml:space="preserve">
          <source>Instance attributes (read-only):</source>
          <target state="translated">인스턴스 속성 (읽기 전용) :</target>
        </trans-unit>
        <trans-unit id="cef505a4b9b67a0b31ca83b3b269c5533fa33c8d" translate="yes" xml:space="preserve">
          <source>Instance method</source>
          <target state="translated">인스턴스 방법</target>
        </trans-unit>
        <trans-unit id="7a3c19110538625e1e983c1581301c5d59f09ead" translate="yes" xml:space="preserve">
          <source>Instance methods:</source>
          <target state="translated">인스턴스 메소드 :</target>
        </trans-unit>
        <trans-unit id="f5e5a85bed7028b78978acbd1aaddcd815f1c067" translate="yes" xml:space="preserve">
          <source>Instance of the &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; class intended to be shared. If no customization of the &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; is needed, this instance can be used instead of repeatedly creating new instances.</source>
          <target state="translated">공유하려는 &lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스입니다 . &lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; 를&lt;/a&gt; 사용자 정의 할 필요가 없는 경우 새 인스턴스를 반복해서 작성하는 대신이 인스턴스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66006b01de7b00fd125d534c85307c7025d31754" translate="yes" xml:space="preserve">
          <source>Instances are a context manager that raises &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt;&lt;code&gt;ResourceDenied&lt;/code&gt;&lt;/a&gt; if the specified exception type is raised. Any keyword arguments are treated as attribute/value pairs to be compared against any exception raised within the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. Only if all pairs match properly against attributes on the exception is &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt;&lt;code&gt;ResourceDenied&lt;/code&gt;&lt;/a&gt; raised.</source>
          <target state="translated">인스턴스는 지정된 예외 유형이 발생 하면 &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt; &lt;code&gt;ResourceDenied&lt;/code&gt; 를&lt;/a&gt; 발생 시키는 컨텍스트 관리자입니다 . 키워드 인수는 속성 / 값 쌍으로 처리되어 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 발생한 예외와 비교 됩니다. 모든 쌍이 예외의 속성과 올바르게 일치하는 경우에만 &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt; &lt;code&gt;ResourceDenied&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c702b9ba47b1a29abe7f9b14424131410786fc9" translate="yes" xml:space="preserve">
          <source>Instances are created in the usual way, by calling the class:</source>
          <target state="translated">인스턴스는 클래스를 호출하여 일반적인 방식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e36624384482780c99f8cf1e80e08d4dbffcccda" translate="yes" xml:space="preserve">
          <source>Instances are replaced with an appropriate value for Enum members.</source>
          <target state="translated">인스턴스는 Enum 멤버에 적절한 값으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="977046f0ab67d4d0e4e35706464d8171ca16252f" translate="yes" xml:space="preserve">
          <source>Instances have a single attribute:</source>
          <target state="translated">인스턴스에는 단일 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4676b1bcc4624e7da45d7a5ff8eacd0bf3c33c" translate="yes" xml:space="preserve">
          <source>Instances have one method in addition to those of &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">인스턴스에는 &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; &lt;/a&gt; 객체 에 추가하여 한 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9356878128c51826b54b444b3b3d1f7304b466d9" translate="yes" xml:space="preserve">
          <source>Instances have the following methods and attributes:</source>
          <target state="translated">인스턴스에는 다음과 같은 메서드와 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4836c2b7b89edcfc83e32a7e01ec4c9ebbb5e79a" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; subclasses have some public instance variables:</source>
          <target state="translated">&lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 서브 클래스의 인스턴스 에는 몇 가지 공용 인스턴스 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fbdb8f7a773261c049a9a5c3586d5acb9eee33" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt;&lt;code&gt;FileCookieJar&lt;/code&gt;&lt;/a&gt; raise this exception on failure to load cookies from a file. &lt;a href=&quot;#http.cookiejar.LoadError&quot;&gt;&lt;code&gt;LoadError&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt; &lt;code&gt;FileCookieJar&lt;/code&gt; &lt;/a&gt; 인스턴스는 파일에서 쿠키를로드하지 못하면이 예외를 발생시킵니다. &lt;a href=&quot;#http.cookiejar.LoadError&quot;&gt; &lt;code&gt;LoadError&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0c3af14ce90e18c0cd86060643d0a376c7566d62" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#netrc.netrc&quot;&gt;&lt;code&gt;netrc&lt;/code&gt;&lt;/a&gt; have public instance variables:</source>
          <target state="translated">&lt;a href=&quot;#netrc.netrc&quot;&gt; &lt;code&gt;netrc&lt;/code&gt; &lt;/a&gt; 인스턴스 에는 공개 인스턴스 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e3aee8ff0d6c01108a6a06292032304f1239fb" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#poplib.POP3_SSL&quot;&gt;&lt;code&gt;POP3_SSL&lt;/code&gt;&lt;/a&gt; have no additional methods. The interface of this subclass is identical to its parent.</source>
          <target state="translated">&lt;a href=&quot;#poplib.POP3_SSL&quot;&gt; &lt;code&gt;POP3_SSL&lt;/code&gt; &lt;/a&gt; 인스턴스 에는 추가 방법이 없습니다. 이 서브 클래스의 인터페이스는 부모와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6a270da5a938701cf4bfb5b00e63f7b889296e57" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; provide the following operations:</source>
          <target state="translated">&lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="99ef98d14b1f3f5f16c5b4358f8ece80d4b0bb22" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; are compared to instances of &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; based on their members. For example, &lt;code&gt;set('abc') == frozenset('abc')&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt; and so does &lt;code&gt;set('abc') in set([frozenset('abc')])&lt;/code&gt;.</source>
          <target state="translated">의 인스턴스 &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 의 경우에 비교 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 자신의 회원을 기반으로. 예를 들어 &lt;code&gt;set('abc') == frozenset('abc')&lt;/code&gt; 는 &lt;code&gt;True&lt;/code&gt; 를 반환 하므로 &lt;code&gt;set('abc') in set([frozenset('abc')])&lt;/code&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="5bad8405386be273c519f37d5de7d1af43fd2371" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; subclasses have some public instance variables which either control lexical analysis or can be used for debugging:</source>
          <target state="translated">&lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 서브 클래스의 인스턴스에는 어휘 분석을 제어하거나 디버깅에 사용할 수있는 공용 인스턴스 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a114067119bf39dea4018ea438842b0e1df5bc4" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; must be created using the &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6232c7c11311e2dbaabeb35f7f01aef1268d5f26" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#statistics.NormalDist&quot;&gt;&lt;code&gt;NormalDist&lt;/code&gt;&lt;/a&gt; support addition, subtraction, multiplication and division by a constant. These operations are used for translation and scaling. For example:</source>
          <target state="translated">&lt;a href=&quot;#statistics.NormalDist&quot;&gt; &lt;code&gt;NormalDist&lt;/code&gt; &lt;/a&gt; 인스턴스는 덧셈, 뺄셈, 곱셈 및 나누기를 상수로 지원합니다. 이러한 작업은 변환 및 확장에 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4fca6b7030888ac58e9781d764d833f2fa42ad1" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#xml.sax.xmlreader.IncrementalParser&quot;&gt;&lt;code&gt;IncrementalParser&lt;/code&gt;&lt;/a&gt; offer the following additional methods:</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.IncrementalParser&quot;&gt; &lt;code&gt;IncrementalParser&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음과 같은 추가 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c9c13ace643e3c6e869ce828dec5a9ec44914c1b" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#xml.sax.xmlreader.Locator&quot;&gt;&lt;code&gt;Locator&lt;/code&gt;&lt;/a&gt; provide these methods:</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.Locator&quot;&gt; &lt;code&gt;Locator&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="804f8454e9538af6b77807d86e343f3fb23e2b60" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;ast.expr&lt;/code&gt; and &lt;code&gt;ast.stmt&lt;/code&gt; subclasses have &lt;a href=&quot;#ast.AST.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ast.AST.col_offset&quot;&gt;&lt;code&gt;col_offset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ast.AST.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ast.AST.col_offset&quot;&gt;&lt;code&gt;col_offset&lt;/code&gt;&lt;/a&gt; attributes. The &lt;a href=&quot;#ast.AST.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ast.AST.end_lineno&quot;&gt;&lt;code&gt;end_lineno&lt;/code&gt;&lt;/a&gt; are the first and last line numbers of source text span (1-indexed so the first line is line 1) and the &lt;a href=&quot;#ast.AST.col_offset&quot;&gt;&lt;code&gt;col_offset&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ast.AST.end_col_offset&quot;&gt;&lt;code&gt;end_col_offset&lt;/code&gt;&lt;/a&gt; are the corresponding UTF-8 byte offsets of the first and last tokens that generated the node. The UTF-8 offset is recorded because the parser uses UTF-8 internally.</source>
          <target state="translated">&lt;code&gt;ast.expr&lt;/code&gt; 및 &lt;code&gt;ast.stmt&lt;/code&gt; 서브 클래스의 인스턴스 에는 &lt;a href=&quot;#ast.AST.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ast.AST.col_offset&quot;&gt; &lt;code&gt;col_offset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ast.AST.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ast.AST.col_offset&quot;&gt; &lt;code&gt;col_offset&lt;/code&gt; &lt;/a&gt; 속성이 있습니다. &lt;a href=&quot;#ast.AST.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ast.AST.end_lineno&quot;&gt; &lt;code&gt;end_lineno&lt;/code&gt; 는&lt;/a&gt; 원본 텍스트 범위 (첫 번째 행은 행 1 정도로 1 인덱스)과의 처음과 마지막 라인 숫자 &lt;a href=&quot;#ast.AST.col_offset&quot;&gt; &lt;code&gt;col_offset&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ast.AST.end_col_offset&quot;&gt; &lt;code&gt;end_col_offset&lt;/code&gt; &lt;/a&gt; 상기 노드를 생성하는 첫 번째 및 마지막 토큰 UTF-8 바이트 오프셋을 대응되는 . 파서는 UTF-8을 내부적으로 사용하기 때문에 UTF-8 오프셋이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="5d95f68c80ce0e510ee590b3846279063b4a2aa5" translate="yes" xml:space="preserve">
          <source>Instances of Action (or return value of any callable to the &lt;code&gt;action&lt;/code&gt; parameter) should have attributes &amp;ldquo;dest&amp;rdquo;, &amp;ldquo;option_strings&amp;rdquo;, &amp;ldquo;default&amp;rdquo;, &amp;ldquo;type&amp;rdquo;, &amp;ldquo;required&amp;rdquo;, &amp;ldquo;help&amp;rdquo;, etc. defined. The easiest way to ensure these attributes are defined is to call &lt;code&gt;Action.__init__&lt;/code&gt;.</source>
          <target state="translated">작업 인스턴스 (또는 &lt;code&gt;action&lt;/code&gt; 매개 변수 에 대한 호출 가능한 값 반환 )에는 &quot;dest&quot;, &quot;option_strings&quot;, &quot;default&quot;, &quot;type&quot;, &quot;required&quot;, &quot;help&quot;등의 속성이 정의되어 있어야합니다. 이러한 속성을 정의하는 가장 쉬운 방법은 &lt;code&gt;Action.__init__&lt;/code&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8d188b0cbbecd67a4203389ad78cd336997dc157" translate="yes" xml:space="preserve">
          <source>Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt; (in general, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; are sufficient, if you want the conventional meanings of the comparison operators).</source>
          <target state="translated">방법의 충분한 클래스가 정의하지 않는 한 클래스의 인스턴스는, 같은 클래스의 다른 인스턴스 또는 개체의 다른 유형에 대한 주문 할 수없는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; (일반적으로 , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 이면 충분합니다 (비교 연산자의 일반적인 의미를 원한다면).</target>
        </trans-unit>
        <trans-unit id="6b5dcf1058b351c38261d04ca320dda4b3f25f2d" translate="yes" xml:space="preserve">
          <source>Instances of class &lt;code&gt;_Feature&lt;/code&gt; have two corresponding methods, &lt;code&gt;getOptionalRelease()&lt;/code&gt; and &lt;code&gt;getMandatoryRelease()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_Feature&lt;/code&gt; 클래스의 인스턴스에는 &lt;code&gt;getOptionalRelease()&lt;/code&gt; 및 &lt;code&gt;getMandatoryRelease()&lt;/code&gt; 두 가지 해당 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6c634a0edffb9d61a7365311bea34ffe79ec57" translate="yes" xml:space="preserve">
          <source>Instances of foreign functions are also C compatible data types; they represent C function pointers.</source>
          <target state="translated">외부 함수의 인스턴스도 C 호환 데이터 유형입니다. 그것들은 C 함수 포인터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a8afbcc19adfe2bbe9b22c2815e4299724822e37" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; class have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9546d42fe8710c49b46e747a53a869881a8867" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; class represent the logical test units in the &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; universe. This class is intended to be used as a base class, with specific tests being implemented by concrete subclasses. This class implements the interface needed by the test runner to allow it to drive the tests, and methods that the test code can use to check for and report various kinds of failure.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스는 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 유니버스 의 논리적 테스트 단위를 나타냅니다 . 이 클래스는 구체적인 서브 클래스에 의해 구현되는 특정 테스트와 함께 기본 클래스로 사용됩니다. 이 클래스는 테스트 실행에 필요한 인터페이스를 구현하여 테스트를 수행하고 테스트 코드가 다양한 종류의 오류를 확인하고보고하는 데 사용할 수있는 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c68784d7b74127503c1abd5f3c46123eaca45a23" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; class are returned by the &lt;a href=&quot;#zipfile.ZipFile.getinfo&quot;&gt;&lt;code&gt;getinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#zipfile.ZipFile.infolist&quot;&gt;&lt;code&gt;infolist()&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; objects. Each object stores information about a single member of the ZIP archive.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스는 &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;#zipfile.ZipFile.getinfo&quot;&gt; &lt;code&gt;getinfo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#zipfile.ZipFile.infolist&quot;&gt; &lt;code&gt;infolist()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 반환됩니다 . 각 오브젝트는 ZIP 아카이브의 단일 멤버에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7bcb1ef59d54b0ecd47451fa339ebb50def36131" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;DatagramTransport&lt;/em&gt; class are returned from the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_datagram_endpoint&quot;&gt;&lt;code&gt;loop.create_datagram_endpoint()&lt;/code&gt;&lt;/a&gt; event loop method.</source>
          <target state="translated">&lt;em&gt;DatagramTransport&lt;/em&gt; 클래스의 인스턴스는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_datagram_endpoint&quot;&gt; &lt;code&gt;loop.create_datagram_endpoint()&lt;/code&gt; &lt;/a&gt; 이벤트 루프 메서드 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="586088455e5044d9a461dfedd040a8e305fa706e" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;ReadTransport&lt;/em&gt; class are returned from the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt;&lt;code&gt;loop.connect_read_pipe()&lt;/code&gt;&lt;/a&gt; event loop method and are also used by subprocess-related methods like &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 인스턴스 &lt;em&gt;ReadTransport의&lt;/em&gt; 클래스에서 반환 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt; &lt;code&gt;loop.connect_read_pipe()&lt;/code&gt; &lt;/a&gt; 이벤트 루프 방법과도 같은 구성 프로세스 관련 메소드에 의해 사용된다 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c1f936b1157bd672393e5f1fcb46b2dc8e3cf90" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;SubprocessTransport&lt;/em&gt; class are returned from event loop methods &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_shell&quot;&gt;&lt;code&gt;loop.subprocess_shell()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;SubprocessTransport&lt;/em&gt; 클래스의 인스턴스는 이벤트 루프 메서드 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_shell&quot;&gt; &lt;code&gt;loop.subprocess_shell()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="67256cc8f2e8e404f6172497df055c8737b58bdb" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;Transport&lt;/em&gt; class are returned from or used by event loop methods like &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_connection&quot;&gt;&lt;code&gt;loop.create_unix_connection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.sendfile&quot;&gt;&lt;code&gt;loop.sendfile()&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">&lt;em&gt;Transport&lt;/em&gt; 클래스의 인스턴스는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_connection&quot;&gt; &lt;code&gt;loop.create_unix_connection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.sendfile&quot;&gt; &lt;code&gt;loop.sendfile()&lt;/code&gt; &lt;/a&gt; 등과 같은 이벤트 루프 메소드에서 리턴되거나 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5fb2b433087bffe30f4818f8930283b1d33a135" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;WriteTransport&lt;/em&gt; class are returned from the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;loop.connect_write_pipe()&lt;/code&gt;&lt;/a&gt; event loop method and are also used by subprocess-related methods like &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 인스턴스 &lt;em&gt;WriteTransport의&lt;/em&gt; 클래스에서 반환 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;loop.connect_write_pipe()&lt;/code&gt; &lt;/a&gt; 이벤트 루프 방법과도 같은 구성 프로세스 관련 메소드에 의해 사용된다 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cbaede1df11dc6a6a6c405d9432098c3bd45c5c" translate="yes" xml:space="preserve">
          <source>Instances of these classes have no public methods. Functions exported by the shared library can be accessed as attributes or by index. Please note that accessing the function through an attribute caches the result and therefore accessing it repeatedly returns the same object each time. On the other hand, accessing it through an index returns a new object each time:</source>
          <target state="translated">이 클래스의 인스턴스에는 공개 메소드가 없습니다. 공유 라이브러리에서 내 보낸 함수는 속성 또는 인덱스로 액세스 할 수 있습니다. 속성을 통해 함수에 액세스하면 결과가 캐시되므로 반복적으로 액세스하면 매번 같은 객체가 반복적으로 반환됩니다. 반면에 인덱스를 통해 액세스하면 매번 새 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1a4d2d21f791021b6819e5841a2fccc5056ea44a" translate="yes" xml:space="preserve">
          <source>Instances of this class behave like &lt;a href=&quot;#ctypes.CDLL&quot;&gt;&lt;code&gt;CDLL&lt;/code&gt;&lt;/a&gt; instances, except that the Python GIL is &lt;em&gt;not&lt;/em&gt; released during the function call, and after the function execution the Python error flag is checked. If the error flag is set, a Python exception is raised.</source>
          <target state="translated">이 클래스의 인스턴스 는 함수 호출 중에 Python GIL이 해제 &lt;em&gt;되지 않고&lt;/em&gt; 함수 실행 후 Python 오류 플래그가 확인 된다는 점을 제외하고 &lt;a href=&quot;#ctypes.CDLL&quot;&gt; &lt;code&gt;CDLL&lt;/code&gt; &lt;/a&gt; 인스턴스 처럼 작동합니다 . 오류 플래그가 설정되면 Python 예외가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0b4eb84d866c4aa98cf000e08ff3a6c3d081018" translate="yes" xml:space="preserve">
          <source>Instances of this class can be used as both a context manager:</source>
          <target state="translated">이 클래스의 인스턴스는 컨텍스트 관리자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f609df77c7087014c66efc5131badef500e89bea" translate="yes" xml:space="preserve">
          <source>Instances of this class have &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt;&lt;code&gt;__call__()&lt;/code&gt;&lt;/a&gt; methods identical in signature to &lt;a href=&quot;#codeop.compile_command&quot;&gt;&lt;code&gt;compile_command()&lt;/code&gt;&lt;/a&gt;; the difference is that if the instance compiles program text containing a &lt;code&gt;__future__&lt;/code&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</source>
          <target state="translated">이 클래스의 인스턴스는 서명에서 &lt;a href=&quot;#codeop.compile_command&quot;&gt; &lt;code&gt;compile_command()&lt;/code&gt; &lt;/a&gt; 와 동일한 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt; &lt;code&gt;__call__()&lt;/code&gt; &lt;/a&gt; 메소드를 갖습니다 . 차이점은 인스턴스가 &lt;code&gt;__future__&lt;/code&gt; 문이 포함 된 프로그램 텍스트를 컴파일하는 경우 해당 인스턴스 는 실행중인 명령문을 사용하여 모든 후속 프로그램 텍스트를 '기억'하고 컴파일한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="925a0c7a76a57e11d3f263578f0021165d4947c0" translate="yes" xml:space="preserve">
          <source>Instances of this class have &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt;&lt;code&gt;__call__()&lt;/code&gt;&lt;/a&gt; methods identical in signature to the built-in function &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, but with the difference that if the instance compiles program text containing a &lt;a href=&quot;__future__#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</source>
          <target state="translated">이 클래스의 인스턴스는 내장 함수 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 과 동일한 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt; &lt;code&gt;__call__()&lt;/code&gt; &lt;/a&gt; 메소드를 갖지만 인스턴스가 &lt;a href=&quot;__future__#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; 문을 포함하는 프로그램 텍스트를 컴파일 할 경우 인스턴스는 '기억'되고 다음 프로그램을 사용하여 모든 후속 프로그램 텍스트를 컴파일합니다. 성명서.</target>
        </trans-unit>
        <trans-unit id="3cea02a40f1382d313c478a7d347bf77afc22680" translate="yes" xml:space="preserve">
          <source>Instances of this class have attributes &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;lineno&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; for easier access to the details. &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; of the exception instance returns only the message.</source>
          <target state="translated">이 클래스의 인스턴스 에는 세부 정보에 쉽게 액세스 할 수 있도록 &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;lineno&lt;/code&gt; , &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 속성이 있습니다 . 예외 인스턴스의 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 은 메시지 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9552998fad2e04265127b613f40d80668c89fe3" translate="yes" xml:space="preserve">
          <source>Instances of this class represent loaded shared libraries. Functions in these libraries use the standard C calling convention, and are assumed to return &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타냅니다. 이 라이브러리의 함수는 표준 C 호출 규칙을 사용하며 &lt;code&gt;int&lt;/code&gt; 를 리턴하는 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1092250393de1231514a87858fe06d28af28725a" translate="yes" xml:space="preserve">
          <source>Instant User&amp;rsquo;s Manual</source>
          <target state="translated">인스턴트 사용자 설명서</target>
        </trans-unit>
        <trans-unit id="574cb265821ad17477fe1f76be69bb3a65511224" translate="yes" xml:space="preserve">
          <source>Instantiate a socket from data obtained from the &lt;a href=&quot;#socket.socket.share&quot;&gt;&lt;code&gt;socket.share()&lt;/code&gt;&lt;/a&gt; method. The socket is assumed to be in blocking mode.</source>
          <target state="translated">&lt;a href=&quot;#socket.socket.share&quot;&gt; &lt;code&gt;socket.share()&lt;/code&gt; &lt;/a&gt; 메소드 에서 얻은 데이터에서 소켓을 인스턴스화하십시오 . 소켓은 차단 모드에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6cc2c38c57dd41a65fc68bb18ba93a896f33546b" translate="yes" xml:space="preserve">
          <source>Instantiate the bytes object &lt;em&gt;str&lt;/em&gt; with the supplied parameters, where &lt;em&gt;str&lt;/em&gt; should be a parameterized string obtained from the terminfo database. E.g. &lt;code&gt;tparm(tigetstr(&quot;cup&quot;), 5, 3)&lt;/code&gt; could result in &lt;code&gt;b'\033[6;4H'&lt;/code&gt;, the exact result depending on terminal type.</source>
          <target state="translated">제공된 매개 변수를 사용 하여 바이트 오브젝트 &lt;em&gt;str&lt;/em&gt; 을 인스턴스화하십시오 . 여기서 &lt;em&gt;str&lt;/em&gt; 은 terminfo 데이터베이스에서 얻은 매개 변수화 된 문자열이어야합니다. 예를 들어 &lt;code&gt;tparm(tigetstr(&quot;cup&quot;), 5, 3)&lt;/code&gt; 은 터미널 유형에 따라 정확한 결과 인 &lt;code&gt;b'\033[6;4H'&lt;/code&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be1f69e0247ba6c30dc81d6522ec5b9dfbbb54e4" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;autospec=True&lt;/code&gt; you can pass &lt;code&gt;autospec=some_object&lt;/code&gt; to use an arbitrary object as the spec instead of the one being replaced.</source>
          <target state="translated">&lt;code&gt;autospec=some_object&lt;/code&gt; &lt;code&gt;autospec=True&lt;/code&gt; 대신 autospec = some_object 를 전달 하여 대체되는 스펙 대신 임의의 오브젝트를 스펙으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5c2e9f6e6835a11ba9448dc7766ab78368e93af" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;parser.readfp(fp)&lt;/code&gt; use &lt;code&gt;parser.read_file(readline_generator(fp))&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;parser.readfp(fp)&lt;/code&gt; 를 사용 &lt;code&gt;parser.read_file(readline_generator(fp))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3335f1cb058452ae970d6a5f6d030ab421d2b7a5" translate="yes" xml:space="preserve">
          <source>Instead of passing &lt;code&gt;True&lt;/code&gt; as the value for the punctuation_chars parameter, you can pass a string with specific characters, which will be used to determine which characters constitute punctuation. For example:</source>
          <target state="translated">punctuation_chars 매개 변수의 값으로 &lt;code&gt;True&lt;/code&gt; 를 전달하는 대신 특정 문자가 포함 된 문자열을 전달하면 문장 부호를 구성하는 문자를 결정하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfe94486b315d1f59be6456fc99c6885002b55bd" translate="yes" xml:space="preserve">
          <source>Instead of printing the output at the end of the profile run, you can save the results to a file by specifying a filename to the &lt;code&gt;run()&lt;/code&gt; function:</source>
          <target state="translated">프로파일 실행이 끝날 때 출력을 인쇄하는 대신 &lt;code&gt;run()&lt;/code&gt; 함수에 파일 이름을 지정하여 결과를 파일에 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6962965673ba6e30d7da60e2b13234969e6aa223" translate="yes" xml:space="preserve">
          <source>Instead of reading the profile data from a file, a &lt;code&gt;cProfile.Profile&lt;/code&gt; or &lt;a href=&quot;#profile.Profile&quot;&gt;&lt;code&gt;profile.Profile&lt;/code&gt;&lt;/a&gt; object can be used as the profile data source.</source>
          <target state="translated">파일에서 프로파일 데이터를 읽는 대신 &lt;code&gt;cProfile.Profile&lt;/code&gt; 또는 &lt;a href=&quot;#profile.Profile&quot;&gt; &lt;code&gt;profile.Profile&lt;/code&gt; &lt;/a&gt; 오브젝트를 프로파일 데이터 소스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84f3292cd4df9827802ae460d7bf0d817b1c06d4" translate="yes" xml:space="preserve">
          <source>Instead one should protect the &amp;ldquo;entry point&amp;rdquo; of the program by using &lt;code&gt;if
__name__ == '__main__':&lt;/code&gt; as follows:</source>
          <target state="translated">대신 다음과 같이 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 을 사용하여 프로그램의&amp;ldquo;입력 지점&amp;rdquo;을 보호해야 합니다.</target>
        </trans-unit>
        <trans-unit id="96d5f6e166357195ec9d7a25ec7a7cc3761d5193" translate="yes" xml:space="preserve">
          <source>Instead, it is better to search a list of precomputed keys to find the index of the record in question:</source>
          <target state="translated">대신 미리 계산 된 키 목록을 검색하여 해당 레코드의 색인을 찾는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0c218a2e12a68573c0a6efe87b144bd67b29216" translate="yes" xml:space="preserve">
          <source>Instead, use the DB-API&amp;rsquo;s parameter substitution. Put &lt;code&gt;?&lt;/code&gt; as a placeholder wherever you want to use a value, and then provide a tuple of values as the second argument to the cursor&amp;rsquo;s &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt;&lt;code&gt;execute()&lt;/code&gt;&lt;/a&gt; method. (Other database modules may use a different placeholder, such as &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;:1&lt;/code&gt;.) For example:</source>
          <target state="translated">대신 DB-API의 매개 변수 대체를 사용하십시오. 넣어 &lt;code&gt;?&lt;/code&gt; 값을 사용하려는 위치마다 자리 표시 자로 사용하고 커서의 &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt; &lt;code&gt;execute()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 두 번째 인수로 값의 튜플을 제공하십시오 . (다른 데이터베이스 모듈은 &lt;code&gt;%s&lt;/code&gt; 또는 &lt;code&gt;:1&lt;/code&gt; 과 같은 다른 자리 표시자를 사용할 수 있습니다 .) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c639969c05d984ea055d9d4f757063936b210288" translate="yes" xml:space="preserve">
          <source>Instructions for non-Unix systems will vary; check your HTTP server&amp;rsquo;s documentation (it will usually have a section on CGI scripts).</source>
          <target state="translated">비 유닉스 시스템에 대한 지침은 다양합니다. HTTP 서버 설명서를 확인하십시오 (일반적으로 CGI 스크립트에 대한 섹션이 있음).</target>
        </trans-unit>
        <trans-unit id="1442021d1e6e277098afc29be0d45b6f7adc68dc" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.reader&quot;&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/a&gt; to perform no special processing of quote characters.</source>
          <target state="translated">에 지시 &lt;a href=&quot;#csv.reader&quot;&gt; &lt;code&gt;reader&lt;/code&gt; &lt;/a&gt; 인용 문자의 특별한 처리를 수행 없습니다.</target>
        </trans-unit>
        <trans-unit id="047e505fbfb736e9c1925bb8f8dfaa7c490f8277" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to never quote fields. When the current &lt;em&gt;delimiter&lt;/em&gt; occurs in output data it is preceded by the current &lt;em&gt;escapechar&lt;/em&gt; character. If &lt;em&gt;escapechar&lt;/em&gt; is not set, the writer will raise &lt;a href=&quot;#csv.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; if any characters that require escaping are encountered.</source>
          <target state="translated">&lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 객체가 필드를 인용하지 않도록 지시 합니다. 출력 데이터에서 현재 &lt;em&gt;분리 문자&lt;/em&gt; 가 발생하면 현재 &lt;em&gt;이스케이프&lt;/em&gt; 문자 가 앞에옵니다 . 경우 &lt;em&gt;escapechar가&lt;/em&gt; 설정되어 있지 않은, 작가는 올릴 것이다 &lt;a href=&quot;#csv.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 탈출이 필요한 모든 문자가 발생하는 경우.</target>
        </trans-unit>
        <trans-unit id="1b10705ce857dbeced06f0e80b06d1258b1c3559" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to only quote those fields which contain special characters such as &lt;em&gt;delimiter&lt;/em&gt;, &lt;em&gt;quotechar&lt;/em&gt; or any of the characters in &lt;em&gt;lineterminator&lt;/em&gt;.</source>
          <target state="translated">에 지시 &lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 단지 같은 특수 문자를 포함하는 필드를 인용 객체를 &lt;em&gt;구분&lt;/em&gt; , &lt;em&gt;quotechar&lt;/em&gt; 또는 문자의 &lt;em&gt;lineterminator을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a28899561f1860e0cebbdf8e6feef81d417287ee" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to quote all fields.</source>
          <target state="translated">&lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 객체가 모든 필드를 인용하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="0e13df308f51e63d2ca55d3485fd8b7d669b80d7" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to quote all non-numeric fields.</source>
          <target state="translated">숫자가 아닌 모든 필드를 인용하도록 &lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 객체에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="68a9f1416c044b9eb3ae50c77e7087fc5bdcfec6" translate="yes" xml:space="preserve">
          <source>Instructs the reader to convert all non-quoted fields to type &lt;em&gt;float&lt;/em&gt;.</source>
          <target state="translated">인용되지 않은 모든 필드를 &lt;em&gt;float&lt;/em&gt; 유형으로 변환하도록 리더에 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="9f9ac0fbc7f32aa66d8b0df0a6752da89865807f" translate="yes" xml:space="preserve">
          <source>IntEnum</source>
          <target state="translated">IntEnum</target>
        </trans-unit>
        <trans-unit id="a7dcebc39b9a6200e72e040ddb4b56fbab680190" translate="yes" xml:space="preserve">
          <source>IntFlag</source>
          <target state="translated">IntFlag</target>
        </trans-unit>
        <trans-unit id="32597b26633647b2d319add4525291d5919eb5f2" translate="yes" xml:space="preserve">
          <source>Integer expiry date in seconds since epoch, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. See also the &lt;a href=&quot;#http.cookiejar.Cookie.is_expired&quot;&gt;&lt;code&gt;is_expired()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">시대, 또는 이후 초 정수 유효 기간 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#http.cookiejar.Cookie.is_expired&quot;&gt; &lt;code&gt;is_expired()&lt;/code&gt; &lt;/a&gt; 메소드 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="370fb883669c7c619884fcfa764167a7b1ba29d8" translate="yes" xml:space="preserve">
          <source>Integer or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Netscape cookies have &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; 0. &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; cookies have a &lt;code&gt;version&lt;/code&gt; cookie-attribute of 1. However, note that &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; may &amp;lsquo;downgrade&amp;rsquo; RFC 2109 cookies to Netscape cookies, in which case &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; is 0.</source>
          <target state="translated">정수 또는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Netscape 쿠키는 &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 0입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 쿠키는 &lt;code&gt;version&lt;/code&gt; 쿠키 속성이 1입니다. 그러나 &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; 는 RFC 2109 쿠키를 Netscape 쿠키로 '다운 그레이드'할 수 있으며,이 경우 &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b2586bd79fe20fc085091ee4c039323ab91a2931" translate="yes" xml:space="preserve">
          <source>Integer specifying the handle of the Python DLL.</source>
          <target state="translated">파이썬 DLL의 핸들을 지정하는 정수.</target>
        </trans-unit>
        <trans-unit id="4be890d08d451686a7899dac00d8db91fbaa5012" translate="yes" xml:space="preserve">
          <source>Integer value to control debugging output. The initialize value is taken from the module variable &lt;code&gt;Debug&lt;/code&gt;. Values greater than three trace each command.</source>
          <target state="translated">디버깅 출력을 제어하기위한 정수 값입니다. 초기화 값은 모듈 변수 &lt;code&gt;Debug&lt;/code&gt; 에서 가져옵니다 . 3보다 큰 값은 각 명령을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="0af14c05371406c3bfd30e44309da86d10408fca" translate="yes" xml:space="preserve">
          <source>Integers can be added to or subtracted from address objects. Some examples:</source>
          <target state="translated">주소 개체에 정수를 더하거나 뺄 수 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="d6ab8a868612d7d4c1a82a75ee51d447ac3ad36d" translate="yes" xml:space="preserve">
          <source>Integration with the warnings module</source>
          <target state="translated">경고 모듈과 통합</target>
        </trans-unit>
        <trans-unit id="542505ecbda45c153abc5ccd78db35ec4f174034" translate="yes" xml:space="preserve">
          <source>Interact with process:</source>
          <target state="translated">프로세스와 상호 작용 :</target>
        </trans-unit>
        <trans-unit id="a7b5cc2308bf821e6cd84802cf3b9067390dca9f" translate="yes" xml:space="preserve">
          <source>Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate. The optional &lt;em&gt;input&lt;/em&gt; argument should be data to be sent to the child process, or &lt;code&gt;None&lt;/code&gt;, if no data should be sent to the child. If streams were opened in text mode, &lt;em&gt;input&lt;/em&gt; must be a string. Otherwise, it must be bytes.</source>
          <target state="translated">프로세스와 상호 작용 : stdin에 데이터를 보냅니다. 파일 끝에 도달 할 때까지 stdout 및 stderr에서 데이터를 읽습니다. 프로세스가 종료 될 때까지 기다리십시오. 선택적 &lt;em&gt;입력&lt;/em&gt; 인수는 자식 프로세스로 전송 될 데이터이거나 자식으로 데이터를 보내지 않아야하는 경우 &lt;code&gt;None&lt;/code&gt; 이어야합니다. 스트림이 텍스트 모드에서 열린 경우 &lt;em&gt;입력&lt;/em&gt; 은 문자열이어야합니다. 그렇지 않으면 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c32c2296489969b7635662c3bc8e006192df7595" translate="yes" xml:space="preserve">
          <source>Interacting with Subprocesses</source>
          <target state="translated">서브 프로세스와 상호 작용</target>
        </trans-unit>
        <trans-unit id="0fa8e4485c2202467e61698e8d5ba21575b8a864" translate="yes" xml:space="preserve">
          <source>Interaction function, emulates a very dumb Telnet client.</source>
          <target state="translated">상호 작용 기능은 매우 멍청한 Telnet 클라이언트를 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="ecb2b41b88adb0386e2e88e0cb9c56f459a0f7eb" translate="yes" xml:space="preserve">
          <source>Interactive Console Objects</source>
          <target state="translated">대화식 콘솔 객체</target>
        </trans-unit>
        <trans-unit id="3cfa87a88446a39b489c704cac79d06af1b86206" translate="yes" xml:space="preserve">
          <source>Interactive Interpreter Objects</source>
          <target state="translated">대화 형 인터프리터 객체</target>
        </trans-unit>
        <trans-unit id="2cadb5b7ff0248d2b78142447a263943598198ad" translate="yes" xml:space="preserve">
          <source>Interesting examples</source>
          <target state="translated">흥미로운 예</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="8f852726c2cf35cbc0da9c364c92d16e46188ec0" translate="yes" xml:space="preserve">
          <source>Interface for a sequence of nodes.</source>
          <target state="translated">일련의 노드를위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="1c4db4b0abc2834a17fec9e2358468e1c7283350" translate="yes" xml:space="preserve">
          <source>Interface for associating a SAX event with a document location. A locator object will return valid results only during calls to DocumentHandler methods; at any other time, the results are unpredictable. If information is not available, methods may return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">SAX 이벤트를 문서 위치에 관련시키기위한 인터페이스입니다. 로케이터 객체는 DocumentHandler 메서드를 호출하는 동안에 만 유효한 결과를 반환합니다. 다른 경우에는 결과를 예측할 수 없습니다. 정보가없는 경우 메소드는 &lt;code&gt;None&lt;/code&gt; 을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5aa34ab8218f9e4e220f7344dabd8786a5fdb30e" translate="yes" xml:space="preserve">
          <source>Interface objects</source>
          <target state="translated">인터페이스 객체</target>
        </trans-unit>
        <trans-unit id="8815c1714243ec8fd3c5703aaa179285d61a547d" translate="yes" xml:space="preserve">
          <source>Interface objects are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;, so they can be used as keys in dictionaries.</source>
          <target state="translated">인터페이스 객체는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;해시 가능&lt;/a&gt; 하므로 사전에서 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2972dba464e3ec39c3f8d844bc8f4665db76466" translate="yes" xml:space="preserve">
          <source>Interface objects can be compared with the usual set of logical operators.</source>
          <target state="translated">인터페이스 객체는 일반적인 논리 연산자 세트와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5af8df7a7a4069a4a7e8da32faa2198a5bc0ef82" translate="yes" xml:space="preserve">
          <source>Interface objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</source>
          <target state="translated">인터페이스 객체는 일부 연산자를 지원합니다. 달리 명시하지 않는 한, 연산자는 호환 가능한 개체 (예 : IPv4를 사용하는 IPv4, IPv6을 사용하는 IPv6) 사이에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="009aeb4117871f36b8d07dbea81e88efde3f84c2" translate="yes" xml:space="preserve">
          <source>Interface representing a bidirectional transport, such as a TCP connection.</source>
          <target state="translated">TCP 연결과 같은 양방향 전송을 나타내는 인터페이스</target>
        </trans-unit>
        <trans-unit id="bae0f7875489c70ff870e51bf1acd5af5cd84f7f" translate="yes" xml:space="preserve">
          <source>Interface summary:</source>
          <target state="translated">인터페이스 요약 :</target>
        </trans-unit>
        <trans-unit id="0d7c663f31a9f2ac91921862b41886ab434c27c9" translate="yes" xml:space="preserve">
          <source>Interface to the scheduler</source>
          <target state="translated">스케줄러에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="e3596470b1be1228bdbe04e547e2ae1f770f41b2" translate="yes" xml:space="preserve">
          <source>Interface to the underlying implementation.</source>
          <target state="translated">기본 구현에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="fb0b9bed2c76a555927ef2712dd54850772edaa0" translate="yes" xml:space="preserve">
          <source>Interface used by the parser to present error and warning messages to the application. The methods of this object control whether errors are immediately converted to exceptions or are handled in some other way.</source>
          <target state="translated">응용 프로그램에 오류 및 경고 메시지를 표시하기 위해 파서에서 사용하는 인터페이스입니다. 이 객체의 메소드는 오류가 즉시 예외로 변환되는지 또는 다른 방식으로 처리되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7e3a30fb53d88d0640de6d5babfe7057584ac5ad" translate="yes" xml:space="preserve">
          <source>Interfaces are accessed through instance objects. Applications should not instantiate the classes themselves; they should use the creator functions available on the &lt;code&gt;Document&lt;/code&gt; object. Derived interfaces support all operations (and attributes) from the base interfaces, plus any new operations.</source>
          <target state="translated">인터페이스는 인스턴스 객체를 통해 액세스됩니다. 응용 프로그램은 클래스 자체를 인스턴스화해서는 안됩니다. &lt;code&gt;Document&lt;/code&gt; 객체 에서 사용 가능한 작성자 기능을 사용해야 합니다. 파생 인터페이스는 기본 인터페이스의 모든 작업 (및 특성)과 새로운 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="70e0c022e8ef3548815e6ce09157b2f9fed238ce" translate="yes" xml:space="preserve">
          <source>Intermixed parsing</source>
          <target state="translated">혼합 파싱</target>
        </trans-unit>
        <trans-unit id="9881c711f8b7d79a62e6a62f87a03b1baa3849a7" translate="yes" xml:space="preserve">
          <source>Internal Objects</source>
          <target state="translated">내부 객체</target>
        </trans-unit>
        <trans-unit id="a047b417e339277c6847b0fd6036b5d0c0ae1549" translate="yes" xml:space="preserve">
          <source>Internal attributes.</source>
          <target state="translated">내부 속성.</target>
        </trans-unit>
        <trans-unit id="8846061f5d538bb327da6a9444390ad20122717a" translate="yes" xml:space="preserve">
          <source>Internally, function creates a &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; with protocol &lt;em&gt;ssl_version&lt;/em&gt; and &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt;&lt;code&gt;SSLContext.options&lt;/code&gt;&lt;/a&gt; set to &lt;em&gt;cert_reqs&lt;/em&gt;. If parameters &lt;em&gt;keyfile&lt;/em&gt;, &lt;em&gt;certfile&lt;/em&gt;, &lt;em&gt;ca_certs&lt;/em&gt; or &lt;em&gt;ciphers&lt;/em&gt; are set, then the values are passed to &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt;&lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt;&lt;code&gt;SSLContext.load_verify_locations()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 생성 함수 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 프로토콜과 &lt;em&gt;ssl_version&lt;/em&gt; 및 &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt; &lt;code&gt;SSLContext.options&lt;/code&gt; &lt;/a&gt; 설정 &lt;em&gt;cert_reqs를&lt;/em&gt; . &lt;em&gt;keyfile&lt;/em&gt; , &lt;em&gt;certfile&lt;/em&gt; , &lt;em&gt;ca_certs&lt;/em&gt; 또는 &lt;em&gt;ciphers&lt;/em&gt; 매개 변수 가 설정되면 값이 &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt; &lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt; &lt;code&gt;SSLContext.load_verify_locations()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="580ada3f664fbd8faa4d39879e7b77c24136608a" translate="yes" xml:space="preserve">
          <source>Internally, those three types of queues use locks to temporarily block competing threads; however, they are not designed to handle reentrancy within a thread.</source>
          <target state="translated">내부적으로이 세 가지 유형의 큐는 잠금을 사용하여 경쟁 스레드를 일시적으로 차단합니다. 그러나 스레드 내에서 재진입을 처리하도록 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0acc2a482d5d44565ff4ebc0b9139b2dc39c506b" translate="yes" xml:space="preserve">
          <source>International currency symbol.</source>
          <target state="translated">국제 통화 기호.</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="54c981b9e80576e421c708ac83d965bd9c4c3152" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) refers to the operation by which a program is made aware of multiple languages. Localization (L10N) refers to the adaptation of your program, once internationalized, to the local language and cultural habits. In order to provide multilingual messages for your Python programs, you need to take the following steps:</source>
          <target state="translated">국제화 (I18N)는 프로그램이 여러 언어를 인식하도록하는 작업을 말합니다. 현지화 (L10N)는 국제화 된 프로그램이 현지 언어 및 문화적 습관에 적응 한 것을 말합니다. Python 프로그램에 다국어 메시지를 제공하려면 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="75170006f623fbe183bf840cf6119bbd14972198" translate="yes" xml:space="preserve">
          <source>Internationalization services. The locale setting affects the interpretation of many format specifiers in &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">국제화 서비스. 로케일 설정은 &lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 의 많은 형식 지정자의 해석에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="230139ad0ce1adb0b931fe547c69c78a03a243e2" translate="yes" xml:space="preserve">
          <source>Internationalizing your programs and modules</source>
          <target state="translated">프로그램 및 모듈 국제화</target>
        </trans-unit>
        <trans-unit id="d790826b4ae3ed725698ee4ed89c70a28abd95d5" translate="yes" xml:space="preserve">
          <source>Interned strings are not immortal; you must keep a reference to the return value of &lt;a href=&quot;#sys.intern&quot;&gt;&lt;code&gt;intern()&lt;/code&gt;&lt;/a&gt; around to benefit from it.</source>
          <target state="translated">억지로 묶인 줄은 불멸의 것이 아닙니다. 이점을 얻으려면 &lt;a href=&quot;#sys.intern&quot;&gt; &lt;code&gt;intern()&lt;/code&gt; &lt;/a&gt; 의 반환 값에 대한 참조를 유지해야 합니다.</target>
        </trans-unit>
        <trans-unit id="66c06c11d179e39c42e5e800f99b57865822cf68" translate="yes" xml:space="preserve">
          <source>Internet</source>
          <target state="translated">Internet</target>
        </trans-unit>
        <trans-unit id="8f1678405b5bf8f7b3c9be250ba0b2b4566bc2af" translate="yes" xml:space="preserve">
          <source>Internet Data</source>
          <target state="translated">인터넷 데이터</target>
        </trans-unit>
        <trans-unit id="c1aebf7c813f788884574a6f7046f553aa035ab6" translate="yes" xml:space="preserve">
          <source>Internet Data Handling</source>
          <target state="translated">인터넷 데이터 처리</target>
        </trans-unit>
        <trans-unit id="efedd1f6d18388871beb5b8937b0af027d8bf044" translate="yes" xml:space="preserve">
          <source>Internet Protocols and Support</source>
          <target state="translated">인터넷 프로토콜 및 지원</target>
        </trans-unit>
        <trans-unit id="57c33a7c8b9764293298d03366937218c60d2a49" translate="yes" xml:space="preserve">
          <source>Interpolation behaviour may be customized by providing a custom handler through the &lt;em&gt;interpolation&lt;/em&gt; argument. &lt;code&gt;None&lt;/code&gt; can be used to turn off interpolation completely, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; provides a more advanced variant inspired by &lt;code&gt;zc.buildout&lt;/code&gt;. More on the subject in the &lt;a href=&quot;#interpolation-of-values&quot;&gt;dedicated documentation section&lt;/a&gt;.</source>
          <target state="translated">보간 동작은 &lt;em&gt;보간&lt;/em&gt; 인수를 통해 사용자 지정 처리기를 제공하여 사용자 지정할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 완전히 보간을 해제 사용할 수 없습니다, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; 에서 영감을 고급 변형 제공 &lt;code&gt;zc.buildout&lt;/code&gt; 을 . 더 자세한 내용은 &lt;a href=&quot;#interpolation-of-values&quot;&gt;전용 문서 섹션을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f615e3d514dcbd13ad91a79d1d845b1973ce635" translate="yes" xml:space="preserve">
          <source>Interpolation behaviour may be customized by providing a custom handler through the &lt;em&gt;interpolation&lt;/em&gt; argument. &lt;code&gt;None&lt;/code&gt; can be used to turn off interpolation completely, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; provides a more advanced variant inspired by &lt;code&gt;zc.buildout&lt;/code&gt;. More on the subject in the &lt;a href=&quot;#interpolation-of-values&quot;&gt;dedicated documentation section&lt;/a&gt;. &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt;&lt;code&gt;RawConfigParser&lt;/code&gt;&lt;/a&gt; has a default value of &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">보간 동작은 &lt;em&gt;보간&lt;/em&gt; 인수를 통해 사용자 지정 처리기를 제공하여 사용자 지정할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 완전히 보간을 해제 사용할 수 없습니다, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; 에서 영감을 고급 변형 제공 &lt;code&gt;zc.buildout&lt;/code&gt; 을 . 더 자세한 내용은 &lt;a href=&quot;#interpolation-of-values&quot;&gt;전용 문서 섹션을 참조하십시오&lt;/a&gt; . &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt; &lt;code&gt;RawConfigParser&lt;/code&gt; &lt;/a&gt; 의 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd2b15bb1774a577513ecc617124a7b368669881" translate="yes" xml:space="preserve">
          <source>Interpolation of values</source>
          <target state="translated">값의 보간</target>
        </trans-unit>
        <trans-unit id="d568ce51e6576d8c0979772561e24281b364cfad" translate="yes" xml:space="preserve">
          <source>Interpret the argument as though it had been typed in response to the prompt. This may be overridden, but should not normally need to be; see the &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt;&lt;code&gt;precmd()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#cmd.Cmd.postcmd&quot;&gt;&lt;code&gt;postcmd()&lt;/code&gt;&lt;/a&gt; methods for useful execution hooks. The return value is a flag indicating whether interpretation of commands by the interpreter should stop. If there is a &lt;code&gt;do_*()&lt;/code&gt; method for the command &lt;em&gt;str&lt;/em&gt;, the return value of that method is returned, otherwise the return value from the &lt;a href=&quot;#cmd.Cmd.default&quot;&gt;&lt;code&gt;default()&lt;/code&gt;&lt;/a&gt; method is returned.</source>
          <target state="translated">프롬프트에 대한 응답으로 입력 한 것처럼 인수를 해석하십시오. 재정의 될 수도 있지만 일반적으로 그럴 필요는 없습니다. 유용한 실행 후크에 대해서는 &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt; &lt;code&gt;precmd()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cmd.Cmd.postcmd&quot;&gt; &lt;code&gt;postcmd()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 . 리턴 값은 인터프리터의 명령 해석이 중지되어야하는지 여부를 나타내는 플래그입니다. &lt;em&gt;str&lt;/em&gt; 명령에 &lt;code&gt;do_*()&lt;/code&gt; 메소드 가있는 경우 해당 메소드의 리턴 값이 리턴되고, 그렇지 않으면 &lt;a href=&quot;#cmd.Cmd.default&quot;&gt; &lt;code&gt;default()&lt;/code&gt; &lt;/a&gt; 메소드 의 리턴 값 이 리턴됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d3c148819e9e54cd74c9c94b3ef056e575eee05" translate="yes" xml:space="preserve">
          <source>Interpreters</source>
          <target state="translated">Interpreters</target>
        </trans-unit>
        <trans-unit id="46d6db31f6f2547122e3f17c21631f666601ba12" translate="yes" xml:space="preserve">
          <source>Interrupt Execution</source>
          <target state="translated">인터럽트 실행</target>
        </trans-unit>
        <trans-unit id="8815302accf46070d40572381df17ae0b24087f8" translate="yes" xml:space="preserve">
          <source>Interrupted system call should be restarted</source>
          <target state="translated">중단 된 시스템 호출을 다시 시작해야합니다</target>
        </trans-unit>
        <trans-unit id="b06a3395105be1465d6b1697af03d4431eac6c71" translate="yes" xml:space="preserve">
          <source>Interrupted system call.</source>
          <target state="translated">시스템 호출이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="09dc03559a67ff5107d10fad944393ea3f877c07" translate="yes" xml:space="preserve">
          <source>InterruptedError</source>
          <target state="translated">InterruptedError</target>
        </trans-unit>
        <trans-unit id="0943ef2ada12e3e7dc287b50717ddb75bc6da8ed" translate="yes" xml:space="preserve">
          <source>Interruption</source>
          <target state="translated">Interruption</target>
        </trans-unit>
        <trans-unit id="4e36c74154decbcc22ec9de613c329458fb47795" translate="yes" xml:space="preserve">
          <source>Interruption during the decompression, such as pressing control-C or killing the decompression process may result in incomplete decompression of the archive.</source>
          <target state="translated">control-C를 누르거나 압축 해제 프로세스를 종료하는 등 압축 해제 중 중단으로 인해 아카이브 압축이 풀릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c071214f97d5c4afff6973aa5aa8c312d9737c" translate="yes" xml:space="preserve">
          <source>Intro from the Apache HTTP Server documentation</source>
          <target state="translated">Apache HTTP Server 문서에서 소개</target>
        </trans-unit>
        <trans-unit id="74f37218ef8634d6f18ddbe27efca22ced57c811" translate="yes" xml:space="preserve">
          <source>Introduced the &lt;code&gt;__prepare__&lt;/code&gt; namespace hook</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; 네임 스페이스 후크를 도입했습니다</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="12b2799a6c697d71c79a7458b9ff32a936f76a1a" translate="yes" xml:space="preserve">
          <source>Introduction to the profilers</source>
          <target state="translated">프로파일 러 소개</target>
        </trans-unit>
        <trans-unit id="0047e79057a6dadcd1958b908f6296f6079753b9" translate="yes" xml:space="preserve">
          <source>Introspecting callables with the Signature object</source>
          <target state="translated">Signature 객체를 사용하여 콜 러블 검사</target>
        </trans-unit>
        <trans-unit id="b3b4d20d3dfe4ef78d0bf43a93aa7f57bae176c5" translate="yes" xml:space="preserve">
          <source>Introspection</source>
          <target state="translated">Introspection</target>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="translated">잘못된 인수</target>
        </trans-unit>
        <trans-unit id="f8d3e8e47ede7d1e1d63b90adac4163f137f5fbd" translate="yes" xml:space="preserve">
          <source>Invalid arguments</source>
          <target state="translated">잘못된 인수</target>
        </trans-unit>
        <trans-unit id="0659862d18cc2aab0d2c79d54ece0b588cefda81" translate="yes" xml:space="preserve">
          <source>Invalid exchange</source>
          <target state="translated">잘못된 교환</target>
        </trans-unit>
        <trans-unit id="b7ebb17aae68fc96bde7bec88689e59f80c276a6" translate="yes" xml:space="preserve">
          <source>Invalid internal state of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 의 내부 상태가 잘못되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e5a79f3df5c8af3ba8a7813c333e1a6a9466a6b5" translate="yes" xml:space="preserve">
          <source>Invalid request code</source>
          <target state="translated">잘못된 요청 코드</target>
        </trans-unit>
        <trans-unit id="921238b4baa4c7c3a24c3d63e0e9afc770fd916a" translate="yes" xml:space="preserve">
          <source>Invalid request descriptor</source>
          <target state="translated">잘못된 요청 설명자</target>
        </trans-unit>
        <trans-unit id="ac9eda2543c0cdfa22d49b3ce87554f9fa67c95e" translate="yes" xml:space="preserve">
          <source>Invalid request: descriptor not open</source>
          <target state="translated">잘못된 요청 : 설명자가 열리지 않습니다</target>
        </trans-unit>
        <trans-unit id="6684b6eeddecb3f9f1296f418af07f2108c4ba7a" translate="yes" xml:space="preserve">
          <source>Invalid slot</source>
          <target state="translated">유효하지 않은 슬롯</target>
        </trans-unit>
        <trans-unit id="ac39f10f2b107f4005a05fd5034e22c350ce91cd" translate="yes" xml:space="preserve">
          <source>Invalidate the internal caches of finders stored at &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt;. If a finder implements &lt;code&gt;invalidate_caches()&lt;/code&gt; then it will be called to perform the invalidation. This function should be called if any modules are created/installed while your program is running to guarantee all finders will notice the new module&amp;rsquo;s existence.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; 에&lt;/a&gt; 저장된 파인더의 내부 캐시를 무효화하십시오 . 파인더가 &lt;code&gt;invalidate_caches()&lt;/code&gt; 를 구현 하면 무효화를 수행하기 위해 호출됩니다. 모든 파인더가 새로운 모듈의 존재를 알 수 있도록 프로그램이 실행되는 동안 모듈이 작성 / 설치된 경우이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba67563ea1b90363b3f3e36d5c60e13c4df6670d" translate="yes" xml:space="preserve">
          <source>Invert all the digits in &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x의&lt;/em&gt; 모든 자리수를 &lt;em&gt;뒤집습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fd084280a98a8cc9427a473124b409ada9c6b2a3" translate="yes" xml:space="preserve">
          <source>Invisible or blank mode</source>
          <target state="translated">보이지 않거나 공백 모드</target>
        </trans-unit>
        <trans-unit id="3bf010a72c53420609032016c83dfcf503ce6948" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt;&lt;code&gt;ZipFile.open()&lt;/code&gt;&lt;/a&gt; on the current path. Accepts the same arguments as &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt;&lt;code&gt;ZipFile.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 경로에서 &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt; &lt;code&gt;ZipFile.open()&lt;/code&gt; &lt;/a&gt; 을 호출 하십시오. &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt; &lt;code&gt;ZipFile.open()&lt;/code&gt; &lt;/a&gt; 과 동일한 인수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="423894e2a4eefe4fc84b32affe9b7e263601406b" translate="yes" xml:space="preserve">
          <source>Invoke a callback &lt;em&gt;after&lt;/em&gt; the given time.</source>
          <target state="translated">주어진 시간 &lt;em&gt;후에&lt;/em&gt; 콜백 &lt;em&gt;을&lt;/em&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d5c67cd19bdfed187292858862c10f228bb5045" translate="yes" xml:space="preserve">
          <source>Invoke a callback &lt;em&gt;at&lt;/em&gt; the given time.</source>
          <target state="translated">주어진 시간에 콜백 &lt;em&gt;을&lt;/em&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="76c3be08bb7afa5e12d91ae6bbae4d9ceb1bf847" translate="yes" xml:space="preserve">
          <source>Invoke a callback soon.</source>
          <target state="translated">콜백을 곧 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="02465213be1ac7e5af0e05eec89ae1f987088775" translate="yes" xml:space="preserve">
          <source>Invoke the built-in help system. (This function is intended for interactive use.) If no argument is given, the interactive help system starts on the interpreter console. If the argument is a string, then the string is looked up as the name of a module, function, class, method, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is generated.</source>
          <target state="translated">내장 된 도움말 시스템을 호출하십시오. (이 기능은 대화식으로 사용하기위한 것입니다.) 인수가 없으면 대화식 도움말 시스템이 인터프리터 콘솔에서 시작됩니다. 인수가 문자열 인 경우 문자열은 모듈, 함수, 클래스, 메소드, 키워드 또는 문서 주제의 이름으로 조회되며 도움말 페이지가 콘솔에 인쇄됩니다. 인수가 다른 종류의 객체 인 경우 객체의 도움말 페이지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6844b46c8699594aabdbedb9cb340a297a5875b2" translate="yes" xml:space="preserve">
          <source>Invoked as a script, the &lt;a href=&quot;#module-pstats&quot;&gt;&lt;code&gt;pstats&lt;/code&gt;&lt;/a&gt; module is a statistics browser for reading and examining profile dumps. It has a simple line-oriented interface (implemented using &lt;a href=&quot;cmd#module-cmd&quot;&gt;&lt;code&gt;cmd&lt;/code&gt;&lt;/a&gt;) and interactive help.</source>
          <target state="translated">스크립트로 호출 된 &lt;a href=&quot;#module-pstats&quot;&gt; &lt;code&gt;pstats&lt;/code&gt; &lt;/a&gt; 모듈은 프로파일 덤프를 읽고 검사하기위한 통계 브라우저입니다. 간단한 라인 지향 인터페이스 ( &lt;a href=&quot;cmd#module-cmd&quot;&gt; &lt;code&gt;cmd&lt;/code&gt; 를&lt;/a&gt; 사용하여 구현 됨 )와 대화식 도움말이 있습니다.</target>
        </trans-unit>
        <trans-unit id="726a8b660b71615a82f862249de26d56cd18e129" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;True&lt;/code&gt; if the stream is closed.</source>
          <target state="translated">가 &lt;code&gt;True&lt;/code&gt; 스트림이 닫혀있는 경우.</target>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="translated">디렉토리인가</target>
        </trans-unit>
        <trans-unit id="b9271431abbe409f3af4140e02d0f15a9328cd88" translate="yes" xml:space="preserve">
          <source>Is a generic constructor that takes the string &lt;em&gt;name&lt;/em&gt; of the desired algorithm as its first parameter. It also exists to allow access to the above listed hashes as well as any other algorithms that your OpenSSL library may offer. The named constructors are much faster than &lt;a href=&quot;#hashlib.new&quot;&gt;&lt;code&gt;new()&lt;/code&gt;&lt;/a&gt; and should be preferred.</source>
          <target state="translated">원하는 알고리즘 의 문자열 &lt;em&gt;이름&lt;/em&gt; 을 첫 번째 매개 변수로 사용 하는 일반 생성자입니다 . 또한 위에 나열된 해시와 OpenSSL 라이브러리가 제공 할 수있는 다른 알고리즘에 액세스 할 수 있습니다. 명명 된 생성자는 &lt;a href=&quot;#hashlib.new&quot;&gt; &lt;code&gt;new()&lt;/code&gt; &lt;/a&gt; 보다 훨씬 빠르 므로 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="0bf5e0f29c754cc24aba94217c9a03a8d1bd88d7" translate="yes" xml:space="preserve">
          <source>Is a named type file</source>
          <target state="translated">명명 된 형식 파일입니다</target>
        </trans-unit>
        <trans-unit id="bee2b08fdf889353624d0f8c23e090efd5200001" translate="yes" xml:space="preserve">
          <source>Is called after the &lt;code&gt;end()&lt;/code&gt; callback of an element that declared a namespace prefix mapping, with the name of the &lt;em&gt;prefix&lt;/em&gt; that went out of scope.</source>
          <target state="translated">범위를 벗어난 &lt;em&gt;접두사&lt;/em&gt; 이름으로 네임 스페이스 접두사 매핑을 선언 한 요소 의 &lt;code&gt;end()&lt;/code&gt; 콜백 후에 호출 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30d2df16b87401fece6e95883b5b9ea7ed5ee83b" translate="yes" xml:space="preserve">
          <source>Is called whenever the parser encounters a new namespace declaration, before the &lt;code&gt;start()&lt;/code&gt; callback for the opening element that defines it. &lt;em&gt;prefix&lt;/em&gt; is &lt;code&gt;''&lt;/code&gt; for the default namespace and the declared namespace prefix name otherwise. &lt;em&gt;uri&lt;/em&gt; is the namespace URI.</source>
          <target state="translated">파서가 새 네임 스페이스 선언을 발견 할 때마다 이를 정의하는 여는 요소에 대한 &lt;code&gt;start()&lt;/code&gt; 콜백 전에 호출됩니다. &lt;em&gt;접두사&lt;/em&gt; 는 기본 네임 스페이스의 경우 &lt;code&gt;''&lt;/code&gt; 이고 선언 된 네임 스페이스 접 두부 이름의 경우 '' 입니다. &lt;em&gt;uri&lt;/em&gt; 는 네임 스페이스 URI입니다.</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faccc474f96ec465b21b84d73c34160d716e3f91" translate="yes" xml:space="preserve">
          <source>Is raised by &lt;a href=&quot;#tarfile.TarInfo.frombuf&quot;&gt;&lt;code&gt;TarInfo.frombuf()&lt;/code&gt;&lt;/a&gt; if the buffer it gets is invalid.</source>
          <target state="translated">버퍼가 유효하지 않은 경우 &lt;a href=&quot;#tarfile.TarInfo.frombuf&quot;&gt; &lt;code&gt;TarInfo.frombuf()&lt;/code&gt; &lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="18a7000c3669054a5c3429b5bca7b29f3a62b417" translate="yes" xml:space="preserve">
          <source>Is raised for &lt;em&gt;non-fatal&lt;/em&gt; errors when using &lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt;&lt;code&gt;TarFile.extract()&lt;/code&gt;&lt;/a&gt;, but only if &lt;code&gt;TarFile.errorlevel&lt;/code&gt;&lt;code&gt;== 2&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt; &lt;code&gt;TarFile.extract()&lt;/code&gt; &lt;/a&gt; 사용할 때 &lt;em&gt;치명적이지 않은&lt;/em&gt; 오류 가 발생 하지만 &lt;code&gt;TarFile.errorlevel&lt;/code&gt; &lt;code&gt;== 2&lt;/code&gt; 경우에만 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="18715da6dd78d77038e6918bcd213c664251a25c" translate="yes" xml:space="preserve">
          <source>Is raised for the limitations that are typical for stream-like &lt;a href=&quot;#tarfile.TarFile&quot;&gt;&lt;code&gt;TarFile&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">스트림과 같은 &lt;a href=&quot;#tarfile.TarFile&quot;&gt; &lt;code&gt;TarFile&lt;/code&gt; &lt;/a&gt; 객체에 일반적인 제한 사항으로 인해 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b4dfe73679ab1a5e17ff73652a8048ca83d1123c" translate="yes" xml:space="preserve">
          <source>Is raised when a compression method is not supported or when the data cannot be decoded properly.</source>
          <target state="translated">압축 방법이 지원되지 않거나 데이터를 올바르게 디코딩 할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c229c84cdb83be81adf3d14e2f27db1ff9323b8" translate="yes" xml:space="preserve">
          <source>Is raised when a tar archive is opened, that either cannot be handled by the &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module or is somehow invalid.</source>
          <target state="translated">tar 아카이브가 열릴 때 발생합니다. tar 아카이브는 &lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈 로 처리 할 수 ​​없거나 어떤 식 으로든 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d9f275d0e44d3c8f374404212109840194aa96b" translate="yes" xml:space="preserve">
          <source>Is the specified record to be logged? Returns zero for no, nonzero for yes. If deemed appropriate, the record may be modified in-place by this method.</source>
          <target state="translated">지정된 레코드가 기록됩니까? 아니요는 0을, 예는 0이 아닌 값을 반환합니다. 적절하다고 판단되면이 방법으로 레코드를 제자리에서 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8d1927814fec93e6de191ddf4a54f49e0a8a5f4" translate="yes" xml:space="preserve">
          <source>IsADirectoryError</source>
          <target state="translated">IsADirectoryError</target>
        </trans-unit>
        <trans-unit id="5aaeb6752e0a30b5836a9fdc9113966711e2d7a5" translate="yes" xml:space="preserve">
          <source>Issue a warning, or maybe ignore it or raise an exception. The &lt;em&gt;category&lt;/em&gt; argument, if given, must be a &lt;a href=&quot;#warning-categories&quot;&gt;warning category class&lt;/a&gt;; it defaults to &lt;a href=&quot;exceptions#UserWarning&quot;&gt;&lt;code&gt;UserWarning&lt;/code&gt;&lt;/a&gt;. Alternatively, &lt;em&gt;message&lt;/em&gt; can be a &lt;a href=&quot;exceptions#Warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; instance, in which case &lt;em&gt;category&lt;/em&gt; will be ignored and &lt;code&gt;message.__class__&lt;/code&gt; will be used. In this case, the message text will be &lt;code&gt;str(message)&lt;/code&gt;. This function raises an exception if the particular warning issued is changed into an error by the &lt;a href=&quot;#warning-filter&quot;&gt;warnings filter&lt;/a&gt;. The &lt;em&gt;stacklevel&lt;/em&gt; argument can be used by wrapper functions written in Python, like this:</source>
          <target state="translated">경고를 발행하거나 무시하거나 예외를 발생시킬 수 있습니다. &lt;em&gt;카테고리&lt;/em&gt; 인수는, 주어진 경우이어야 &lt;a href=&quot;#warning-categories&quot;&gt;경고 카테고리 클래스&lt;/a&gt; ; 기본값은 &lt;a href=&quot;exceptions#UserWarning&quot;&gt; &lt;code&gt;UserWarning&lt;/code&gt; &lt;/a&gt; 입니다. 또는 &lt;em&gt;message&lt;/em&gt; 는 &lt;a href=&quot;exceptions#Warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; 인스턴스 일 수 &lt;code&gt;message.__class__&lt;/code&gt; 경우 &lt;em&gt;category&lt;/em&gt; 는 무시되고 message .__ class__ 가 사용됩니다. 이 경우 메시지 텍스트는 &lt;code&gt;str(message)&lt;/code&gt; 입니다. &lt;a href=&quot;#warning-filter&quot;&gt;경고 필터에&lt;/a&gt; 의해 발행 된 특정 경고가 오류로 변경되면이 기능은 예외를 발생시킵니다 . &lt;em&gt;stacklevel의&lt;/em&gt; 인수는이 같은 파이썬으로 작성된 래퍼 함수, 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2acc379f1d9efba7c573cb292f79779105a94baa" translate="yes" xml:space="preserve">
          <source>Issue an &lt;code&gt;SMTP&lt;/code&gt;&lt;code&gt;AUTH&lt;/code&gt; command for the specified authentication &lt;em&gt;mechanism&lt;/em&gt;, and handle the challenge response via &lt;em&gt;authobject&lt;/em&gt;.</source>
          <target state="translated">문제 &lt;code&gt;SMTP&lt;/code&gt; &lt;code&gt;AUTH&lt;/code&gt; 의 지정된 인증 용 명령 &lt;em&gt;기구&lt;/em&gt; , 비아 도전 응답 처리 &lt;em&gt;authobject를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="131d53be7d06b29d352aeb037a9507988702c57d" translate="yes" xml:space="preserve">
          <source>Issue with file descriptors</source>
          <target state="translated">파일 디스크립터 관련 문제</target>
        </trans-unit>
        <trans-unit id="e46c8a5eede1acdf3c821975f3ebca0b3fba6963" translate="yes" xml:space="preserve">
          <source>It also defines names for some object types that are used by the standard Python interpreter, but not exposed as builtins like &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; are.</source>
          <target state="translated">또한 표준 Python 인터프리터가 사용하지만 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 같은 내장으로 노출되지 않는 일부 객체 유형의 이름을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="03d0fa505bb145a8b508318b5166e2f593fc8b4f" translate="yes" xml:space="preserve">
          <source>It also has children nodes over which we can iterate:</source>
          <target state="translated">또한 우리가 반복 할 수있는 자식 노드가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ba93dd24e6158dc460f6e66524c0fca4f667b666" translate="yes" xml:space="preserve">
          <source>It also looks for &lt;code&gt;*.pkg&lt;/code&gt; files beginning where &lt;code&gt;*&lt;/code&gt; matches the &lt;em&gt;name&lt;/em&gt; argument. This feature is similar to &lt;code&gt;*.pth&lt;/code&gt; files (see the &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module for more information), except that it doesn&amp;rsquo;t special-case lines starting with &lt;code&gt;import&lt;/code&gt;. A &lt;code&gt;*.pkg&lt;/code&gt; file is trusted at face value: apart from checking for duplicates, all entries found in a &lt;code&gt;*.pkg&lt;/code&gt; file are added to the path, regardless of whether they exist on the filesystem. (This is a feature.)</source>
          <target state="translated">또한 &lt;code&gt;*&lt;/code&gt; 가 &lt;em&gt;name&lt;/em&gt; 인수 와 일치하는 &lt;code&gt;*.pkg&lt;/code&gt; 파일을 찾습니다 . 이 기능은 &lt;code&gt;import&lt;/code&gt; 로 시작하는 특수한 경우가 아니라는 점을 제외하고 &lt;code&gt;*.pth&lt;/code&gt; 파일 과 유사 합니다 (자세한 내용은 &lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 모듈 참조 ) . &lt;code&gt;*.pkg&lt;/code&gt; 파일은 액면 그대로 신뢰 : 떨어져 중복 검사에서 모든 항목이 발견 &lt;code&gt;*.pkg&lt;/code&gt; 관계없이 파일 시스템에 존재하는지 여부의 경로에 추가되는 파일입니다. (이것은 기능입니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac049eee8e098efbf97dcda725fb4ce89501bd33" translate="yes" xml:space="preserve">
          <source>It also supports certain of Python&amp;rsquo;s built-in operators through &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">또한 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt; &lt;code&gt;__ne__()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 특정 Python 내장 연산자를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="b08324cda6eda4c504aa9a823d617b47aa532d2d" translate="yes" xml:space="preserve">
          <source>It also supports certain of Python&amp;rsquo;s built-in operators through rich comparison and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">또한 풍부한 비교 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 메소드를 통해 특정 Python 내장 연산자를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="1186ed492c366eaa388b29b3083c0e6d09f9e556" translate="yes" xml:space="preserve">
          <source>It also understands &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, and &lt;code&gt;-Infinity&lt;/code&gt; as their corresponding &lt;code&gt;float&lt;/code&gt; values, which is outside the JSON spec.</source>
          <target state="translated">또한 &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;Infinity&lt;/code&gt; 및 &lt;code&gt;-Infinity&lt;/code&gt; 를 해당하는 &lt;code&gt;float&lt;/code&gt; 값 으로 이해 합니다. 이는 JSON 사양 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec1493a57b4d7fa45bea1b3298210ad9be4bf5b" translate="yes" xml:space="preserve">
          <source>It can also be used to restore the actual files to known working file objects in case they have been overwritten with a broken object. However, the preferred way to do this is to explicitly save the previous stream before replacing it, and restore the saved object.</source>
          <target state="translated">또한 손상된 파일로 덮어 쓴 경우 실제 파일을 알려진 작업 파일 객체로 복원하는 데 사용할 수 있습니다. 그러나이를 수행하기 위해 선호되는 방법은 이전 스트림을 교체하기 전에 명시 적으로 저장하고 저장된 오브젝트를 복원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60f3acc604f0bf942399f638a855b169564bcc7f" translate="yes" xml:space="preserve">
          <source>It defines a &lt;a href=&quot;#selectors.BaseSelector&quot;&gt;&lt;code&gt;BaseSelector&lt;/code&gt;&lt;/a&gt; abstract base class, along with several concrete implementations (&lt;a href=&quot;#selectors.KqueueSelector&quot;&gt;&lt;code&gt;KqueueSelector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#selectors.EpollSelector&quot;&gt;&lt;code&gt;EpollSelector&lt;/code&gt;&lt;/a&gt;&amp;hellip;), that can be used to wait for I/O readiness notification on multiple file objects. In the following, &amp;ldquo;file object&amp;rdquo; refers to any object with a &lt;code&gt;fileno()&lt;/code&gt; method, or a raw file descriptor. See &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">여러 파일 객체에서 I / O 준비 알림을 기다리는 데 사용할 수있는 몇 가지 구체적인 구현 ( &lt;a href=&quot;#selectors.KqueueSelector&quot;&gt; &lt;code&gt;KqueueSelector&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#selectors.EpollSelector&quot;&gt; &lt;code&gt;EpollSelector&lt;/code&gt; &lt;/a&gt; &amp;hellip;) 과 함께 &lt;a href=&quot;#selectors.BaseSelector&quot;&gt; &lt;code&gt;BaseSelector&lt;/code&gt; &lt;/a&gt; 추상 기본 클래스를 정의 합니다. 다음에서 &quot;파일 개체&quot;는 &lt;code&gt;fileno()&lt;/code&gt; 메서드 또는 원시 파일 설명자를 가진 모든 개체를 나타냅니다 . &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a86490549662868112f136678359ce261e7fbf4a" translate="yes" xml:space="preserve">
          <source>It defines the following items:</source>
          <target state="translated">다음 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="86cf8e626a8b6c0e4daf5e5c5001af4e595a1aaf" translate="yes" xml:space="preserve">
          <source>It detects the encoding from the presence of a UTF-8 BOM or an encoding cookie as specified in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0263&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 263&lt;/strong&gt;&lt;/a&gt;. If both a BOM and a cookie are present, but disagree, a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; will be raised. Note that if the BOM is found, &lt;code&gt;'utf-8-sig'&lt;/code&gt; will be returned as an encoding.</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0263&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 263에&lt;/strong&gt;&lt;/a&gt; 지정된 UTF-8 BOM 또는 인코딩 쿠키가있는 경우 인코딩을 감지합니다 . BOM과 쿠키가 모두 존재하지만 동의하지 않으면 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. BOM이 발견되면 &lt;code&gt;'utf-8-sig'&lt;/code&gt; 가 인코딩으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6d7e8dc33830431ce4274e88f610528d52ec30" translate="yes" xml:space="preserve">
          <source>It extends the existing &lt;em&gt;ustar&lt;/em&gt; format with extra headers for information that cannot be stored otherwise. There are two flavours of pax headers: Extended headers only affect the subsequent file header, global headers are valid for the complete archive and affect all following files. All the data in a pax header is encoded in &lt;em&gt;UTF-8&lt;/em&gt; for portability reasons.</source>
          <target state="translated">다른 방법으로 저장할 수없는 정보를 위해 추가 헤더를 사용 하여 기존 &lt;em&gt;ustar&lt;/em&gt; 형식을 확장합니다 . pax 헤더에는 두 가지 종류가 있습니다. 확장 헤더는 후속 파일 헤더에만 영향을 미치며 전역 헤더는 전체 아카이브에 유효하며 다음 파일 모두에 영향을 미칩니다. pax 헤더의 모든 데이터는 이식성의 이유로 &lt;em&gt;UTF-8&lt;/em&gt; 로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ffd7e38afe55390aae7754992e18f89ae1644e1" translate="yes" xml:space="preserve">
          <source>It has no other methods besides the ones inherited from &lt;code&gt;ttk.Widget&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttk.Widget&lt;/code&gt; 에서 상속 된 메소드 외에 다른 메소드는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0951e90496403cdeaa51c98298faafd64552fecb" translate="yes" xml:space="preserve">
          <source>It has one attribute, &lt;code&gt;data&lt;/code&gt;, that can be used to retrieve the Python bytes object stored in it.</source>
          <target state="translated">여기에는 하나의 속성 &lt;code&gt;data&lt;/code&gt; 가 있으며 여기에 저장된 Python bytes 객체를 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3780db06a7fc7e80db01f0dc24e060618d78221a" translate="yes" xml:space="preserve">
          <source>It has one attribute, &lt;code&gt;data&lt;/code&gt;, which can be used to retrieve the int value of the UID. &lt;code&gt;data&lt;/code&gt; must be in the range &lt;code&gt;0 &amp;lt;= data &amp;lt; 2**64&lt;/code&gt;.</source>
          <target state="translated">UID의 int 값을 검색하는 데 사용할 수있는 &lt;code&gt;data&lt;/code&gt; 속성이 하나 있습니다. &lt;code&gt;data&lt;/code&gt; 는 &lt;code&gt;0 &amp;lt;= data &amp;lt; 2**64&lt;/code&gt; 범위에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="23306eadb9dad4ad03f07be8c0a83f188ab18bb4" translate="yes" xml:space="preserve">
          <source>It is a simplified &lt;a href=&quot;#multiprocessing.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; type, very close to a locked &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잠긴 &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; 매우 가까운 단순화 된 &lt;a href=&quot;#multiprocessing.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5ae066ca641a4bc8990133345ec5ed5570fe1167" translate="yes" xml:space="preserve">
          <source>It is advisable to use the &lt;a href=&quot;#nntplib.decode_header&quot;&gt;&lt;code&gt;decode_header()&lt;/code&gt;&lt;/a&gt; function on header values when they may contain non-ASCII characters:</source>
          <target state="translated">ASCII가 아닌 문자를 포함 할 수있는 헤더 값에 &lt;a href=&quot;#nntplib.decode_header&quot;&gt; &lt;code&gt;decode_header()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="753d5be67d0389392a814b65b9ab13072b3bc426" translate="yes" xml:space="preserve">
          <source>It is allowable for many weak references to be constructed for the same object. Callbacks registered for each weak reference will be called from the most recently registered callback to the oldest registered callback.</source>
          <target state="translated">동일한 객체에 대해 많은 약한 참조를 구성 할 수 있습니다. 각 약한 참조에 대해 등록 된 콜백은 가장 최근에 등록 된 콜백에서 가장 오래된 등록 된 콜백으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c594fee7fb081acf751161f581d98f6ddeb8a51f" translate="yes" xml:space="preserve">
          <source>It is also legal to pass strings as parameters; these should be keys in &lt;code&gt;sys.modules&lt;/code&gt;. Each associated module will be scanned by &lt;code&gt;unittest.TestLoader.loadTestsFromModule()&lt;/code&gt;. This is usually seen in the following &lt;code&gt;test_main()&lt;/code&gt; function:</source>
          <target state="translated">문자열을 매개 변수로 전달하는 것도 합법적입니다. 이것들은 &lt;code&gt;sys.modules&lt;/code&gt; 의 키 여야합니다 . 연관된 각 모듈은 &lt;code&gt;unittest.TestLoader.loadTestsFromModule()&lt;/code&gt; 의해 스캔됩니다 . 일반적으로 다음 &lt;code&gt;test_main()&lt;/code&gt; 함수 에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9198580629b375ecb6cd20a7e7294c4ca6e5fd99" translate="yes" xml:space="preserve">
          <source>It is also possible to achieve the same result without using the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; approach.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;컨텍스트 관리자&lt;/a&gt; 접근 방식 을 사용하지 않고도 동일한 결과를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1255f8f5c1717c7558bffa794a4d3503ba88bf1" translate="yes" xml:space="preserve">
          <source>It is also possible to check the production of exceptions, warnings, and log messages using the following methods:</source>
          <target state="translated">다음 방법을 사용하여 예외, 경고 및 로그 메시지의 생성을 점검 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfda1e856e7a541fee3a382fde7564093efe53b2" translate="yes" xml:space="preserve">
          <source>It is also possible to create temporary directories; see the &lt;a href=&quot;tempfile#module-tempfile&quot;&gt;&lt;code&gt;tempfile&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile.mkdtemp()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">임시 디렉토리를 작성할 수도 있습니다. &lt;a href=&quot;tempfile#module-tempfile&quot;&gt; &lt;code&gt;tempfile&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6422bf6800c39267f0e3ec0b62764a762df242b2" translate="yes" xml:space="preserve">
          <source>It is also possible to name the combinations:</source>
          <target state="translated">조합의 이름을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="798d456bd66adc337600fb619c61f4bd509b080b" translate="yes" xml:space="preserve">
          <source>It is also possible to stop all patches which have been started by using &lt;a href=&quot;#unittest.mock.patch.stopall&quot;&gt;&lt;code&gt;patch.stopall()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch.stopall&quot;&gt; &lt;code&gt;patch.stopall()&lt;/code&gt; &lt;/a&gt; 을 사용하여 시작된 모든 패치를 중지 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc27f258f5c82cae432552d9efba051f52376ec" translate="yes" xml:space="preserve">
          <source>It is also possible to use a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; as a file for both reading and writing. For strings &lt;a href=&quot;#io.StringIO&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; can be used like a file opened in text mode. &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt; can be used like a file opened in binary mode. Both provide full read-write capabilities with random access.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like 객체&lt;/a&gt; 를 읽고 쓸 수있는 파일 로 사용할 수도 있습니다 . 문자열의 경우 &lt;a href=&quot;#io.StringIO&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; 는 텍스트 모드에서 열린 파일처럼 사용할 수 있습니다. &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 는 바이너리 모드로 열린 파일처럼 사용할 수 있습니다. 둘 다 임의 액세스와 함께 전체 읽기 / 쓰기 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="58451ee77d03223f613fe1da224a8696f7ed0741" translate="yes" xml:space="preserve">
          <source>It is also possible to use indexes different from 0, but you must know what you&amp;rsquo;re doing, just as in C: You can access or change arbitrary memory locations. Generally you only use this feature if you receive a pointer from a C function, and you &lt;em&gt;know&lt;/em&gt; that the pointer actually points to an array instead of a single item.</source>
          <target state="translated">0과 다른 인덱스를 사용하는 것도 가능하지만 C에서와 같이 수행중인 작업을 알아야합니다. 임의의 메모리 위치에 액세스하거나 변경할 수 있습니다. 일반적으로 당신이 C 함수에서 포인터를받을 경우에만이 기능을 사용하여, 당신은 &lt;em&gt;알고&lt;/em&gt; 포인터가 실제로 배열 대신에 단일 항목을 가리키는 것이다.</target>
        </trans-unit>
        <trans-unit id="7f8863324723aab745603c612674ad8820136acc" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;code&gt;changes&lt;/code&gt; to contain any fields that are defined as having &lt;code&gt;init=False&lt;/code&gt;. A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised in this case.</source>
          <target state="translated">&lt;code&gt;init=False&lt;/code&gt; 로 정의 된 필드 를 &lt;code&gt;changes&lt;/code&gt; 에 포함 시키는 것은 오류입니다 . &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 이 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c40beea80b192f98b4ef0d6e82a60946f7b0973f" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;em&gt;buffer_callback&lt;/em&gt; is not None and &lt;em&gt;protocol&lt;/em&gt; is None or smaller than 5.</source>
          <target state="translated">&lt;em&gt;buffer_callback&lt;/em&gt; 이 None이 아니고 &lt;em&gt;protocol&lt;/em&gt; 이 None이거나 5보다 작은 경우 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="400a0f3110c595609b6c3b419668f8a9a2d9e88b" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;em&gt;themename&lt;/em&gt; already exists. If &lt;em&gt;parent&lt;/em&gt; is specified, the new theme will inherit styles, elements and layouts from the parent theme. If &lt;em&gt;settings&lt;/em&gt; are present they are expected to have the same syntax used for &lt;a href=&quot;#tkinter.ttk.Style.theme_settings&quot;&gt;&lt;code&gt;theme_settings()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;테마 이름이&lt;/em&gt; 이미 존재 하면 오류 입니다. 경우 &lt;em&gt;부모가&lt;/em&gt; 지정되면, 새로운 테마는 부모 테마의 스타일 요소와 레이아웃을 상속합니다. &lt;em&gt;설정&lt;/em&gt; 이 존재 하면 &lt;a href=&quot;#tkinter.ttk.Style.theme_settings&quot;&gt; &lt;code&gt;theme_settings()&lt;/code&gt; &lt;/a&gt; 와 동일한 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3cc9474ae763da1597037edc834b029615b066bd" translate="yes" xml:space="preserve">
          <source>It is an error to specify tuples for both &lt;em&gt;times&lt;/em&gt; and &lt;em&gt;ns&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;times&lt;/em&gt; 와 &lt;em&gt;ns에&lt;/em&gt; 대해 튜플을 지정하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="4b49de4f66d59503ff78e81f00969dd43035654c" translate="yes" xml:space="preserve">
          <source>It is assumed that &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; is a sequence. Items of &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; that are not strings referring to existing directories are ignored. Unicode items on &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; that cause errors when used as filenames may cause this function to raise an exception (in line with &lt;a href=&quot;os.path#os.path.isdir&quot;&gt;&lt;code&gt;os.path.isdir()&lt;/code&gt;&lt;/a&gt; behavior).</source>
          <target state="translated">&lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;/a&gt; 는 시퀀스 라고 가정합니다 . 기존 디렉토리를 참조하는 문자열이 아닌 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 의&lt;/a&gt; 항목 은 무시됩니다. 파일 이름으로 사용될 때 오류를 발생시키는 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 의&lt;/a&gt; 유니 코드 항목은 이 함수로 인해 예외가 발생할 수 있습니다 ( &lt;a href=&quot;os.path#os.path.isdir&quot;&gt; &lt;code&gt;os.path.isdir()&lt;/code&gt; &lt;/a&gt; 동작에 따라).</target>
        </trans-unit>
        <trans-unit id="0198f7955aa686bfda71617994f6d44009f39351" translate="yes" xml:space="preserve">
          <source>It is difficult to provide complete flexibility for incremental configuration. For example, because objects such as filters and formatters are anonymous, once a configuration is set up, it is not possible to refer to such anonymous objects when augmenting a configuration.</source>
          <target state="translated">증분 구성을위한 완전한 유연성을 제공하기는 어렵습니다. 예를 들어 필터 및 포맷터와 같은 개체는 익명이므로 구성이 설정되면 구성을 보강 할 때 이러한 익명 개체를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b8d428b0665acaca4a8a5c4e599c5757fb9e58f" translate="yes" xml:space="preserve">
          <source>It is for historical reasons that &lt;em&gt;dirname&lt;/em&gt; is named as such rather than &lt;em&gt;path&lt;/em&gt;.</source>
          <target state="translated">역사적인 이유로 &lt;em&gt;dirname&lt;/em&gt; 이 &lt;em&gt;path가&lt;/em&gt; 아닌 이름으로 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8aa1103190ac27a640efe27d8f90def24b585ee7" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to call &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; in some library routine, since as a side effect it affects the entire program. Saving and restoring it is almost as bad: it is expensive and affects other threads that happen to run before the settings have been restored.</source>
          <target state="translated">일반적으로 일부 라이브러리 루틴에서 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것은 좋지 않습니다 . 부작용으로 전체 프로그램에 영향을 미치기 때문입니다. 저장 및 복원은 거의 나쁩니다. 비용이 많이 들고 설정이 복원되기 전에 실행되는 다른 스레드에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="99fa0df2b3316d6bf82c33997b4364c06d01242a" translate="yes" xml:space="preserve">
          <source>It is generally not very useful to reload built-in or dynamically loaded modules. Reloading &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; and other key modules is not recommended. In many cases extension modules are not designed to be initialized more than once, and may fail in arbitrary ways when reloaded.</source>
          <target state="translated">일반적으로 내장 또는 동적으로로드 된 모듈을 다시로드하는 것은 그리 유용하지 않습니다. &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 및 기타 주요 모듈을 다시로드 하지 않는 것이 좋습니다. 대부분의 경우 확장 모듈은 두 번 이상 초기화되도록 설계되지 않았으며 다시로드 할 때 임의의 방식으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb0ca349a42e3b12e5d41231c5073aad2d937d17" translate="yes" xml:space="preserve">
          <source>It is illegal to move an item under one of its descendants. If &lt;em&gt;index&lt;/em&gt; is less than or equal to zero, &lt;em&gt;item&lt;/em&gt; is moved to the beginning; if greater than or equal to the number of children, it is moved to the end. If &lt;em&gt;item&lt;/em&gt; was detached it is reattached.</source>
          <target state="translated">하위 항목 중 하나로 항목을 이동하는 것은 불법입니다. 경우 &lt;em&gt;인덱스&lt;/em&gt; 보다 작거나 0 인, &lt;em&gt;제품의&lt;/em&gt; 선두로 이동한다; 자식 수보다 크거나 같은 경우 끝으로 이동합니다. 경우 &lt;em&gt;항목을&lt;/em&gt; 분리했다가 다시 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="95714223e048e09765010a9f06704454985fe259" translate="yes" xml:space="preserve">
          <source>It is important to ensure that &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; do not own any references to &lt;em&gt;obj&lt;/em&gt;, either directly or indirectly, since otherwise &lt;em&gt;obj&lt;/em&gt; will never be garbage collected. In particular, &lt;em&gt;func&lt;/em&gt; should not be a bound method of &lt;em&gt;obj&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;func&lt;/em&gt; , &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;kwargs&lt;/em&gt; 가 직접 또는 간접적으로 &lt;em&gt;obj에&lt;/em&gt; 대한 참조를 소유하지 않는 것이 중요합니다. 그렇지 않으면 &lt;em&gt;obj&lt;/em&gt; 가비지 수집되지 않습니다. 특히 &lt;em&gt;func&lt;/em&gt; 은 &lt;em&gt;obj&lt;/em&gt; 의 바인딩 된 메소드가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb8f43a85dd413c6cde8de7ffa05ec877b1e553b" translate="yes" xml:space="preserve">
          <source>It is important to note that modules in the &lt;a href=&quot;#module-xml&quot;&gt;&lt;code&gt;xml&lt;/code&gt;&lt;/a&gt; package require that there be at least one SAX-compliant XML parser available. The Expat parser is included with Python, so the &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; module will always be available.</source>
          <target state="translated">&lt;a href=&quot;#module-xml&quot;&gt; &lt;code&gt;xml&lt;/code&gt; &lt;/a&gt; 패키지의 모듈 에는 사용 가능한 SAX 호환 XML 파서가 하나 이상 있어야합니다. Expat 구문 분석기는 Python에 포함되어 있으므로 &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; &lt;/a&gt; 모듈을 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c82506febe72f22188b7f00df4e1ec93e22d7a" translate="yes" xml:space="preserve">
          <source>It is important to note that most regular expression operations are available as module-level functions and methods on &lt;a href=&quot;#re-objects&quot;&gt;compiled regular expressions&lt;/a&gt;. The functions are shortcuts that don&amp;rsquo;t require you to compile a regex object first, but miss some fine-tuning parameters.</source>
          <target state="translated">대부분의 정규 표현식 작업은 &lt;a href=&quot;#re-objects&quot;&gt;컴파일 된 정규 표현식&lt;/a&gt; 에서 모듈 수준 함수 및 메서드로 사용할 수 있습니다 . 함수는 먼저 정규식 객체를 컴파일 할 필요는 없지만 일부 미세 조정 매개 변수를 놓치는 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="624e6ff33f7bfbc731179c57fb95772ca83eb019" translate="yes" xml:space="preserve">
          <source>It is limited to 100 frames and 100 threads.</source>
          <target state="translated">100 개의 프레임과 100 개의 스레드로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4093ccc8e1fc34ca326724ab26e7be0883220a09" translate="yes" xml:space="preserve">
          <source>It is meant to be used for functions that may accept any kind of string without allowing different kinds of strings to mix. For example:</source>
          <target state="translated">다른 종류의 문자열을 섞지 않고 모든 종류의 문자열을 받아 들일 수있는 함수에 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cb324071c8468030d58c64739521f9f962b39e8" translate="yes" xml:space="preserve">
          <source>It is not necessary to call &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; to change a key. Registry changes are flushed to disk by the registry using its lazy flusher. Registry changes are also flushed to disk at system shutdown. Unlike &lt;a href=&quot;#winreg.CloseKey&quot;&gt;&lt;code&gt;CloseKey()&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; method returns only when all the data has been written to the registry. An application should only call &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; if it requires absolute certainty that registry changes are on disk.</source>
          <target state="translated">키를 변경하기 위해 &lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 를 호출 할 필요는 없습니다 . 레지스트리 변경은 지연 플러 셔를 사용하여 레지스트리에 의해 디스크로 플러시됩니다. 시스템 종료시 레지스트리 변경 사항도 디스크로 플러시됩니다. 달리 &lt;a href=&quot;#winreg.CloseKey&quot;&gt; &lt;code&gt;CloseKey()&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 모든 데이터가 레지스트리에 기록 된 유일한 방법 돌아갑니다. 레지스트리 변경 사항이 디스크에 있는지 확실하게 요구할 경우 응용 프로그램은 &lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 만 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cda47d8387a594b66517d4092e4e115ad892fbe9" translate="yes" xml:space="preserve">
          <source>It is not possible to change the encoding or newline if some data has already been read from the stream. On the other hand, changing encoding after write is possible.</source>
          <target state="translated">스트림에서 일부 데이터를 이미 읽은 경우 인코딩 또는 줄 바꿈을 변경할 수 없습니다. 한편, 기록 후의 인코딩 변경이 가능하다.</target>
        </trans-unit>
        <trans-unit id="d740e3156e0552c31a2af22e49ad436d6f79d68d" translate="yes" xml:space="preserve">
          <source>It is not possible to create truly immutable Python objects. However, by passing &lt;code&gt;frozen=True&lt;/code&gt; to the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator you can emulate immutability. In that case, dataclasses will add &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;__setattr__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delattr__&quot;&gt;&lt;code&gt;__delattr__()&lt;/code&gt;&lt;/a&gt; methods to the class. These methods will raise a &lt;a href=&quot;#dataclasses.FrozenInstanceError&quot;&gt;&lt;code&gt;FrozenInstanceError&lt;/code&gt;&lt;/a&gt; when invoked.</source>
          <target state="translated">불변의 파이썬 객체를 생성하는 것은 불가능합니다. 그러나 &lt;code&gt;frozen=True&lt;/code&gt; 를 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 데코레이터에 전달하면 불변성을 에뮬레이션 할 수 있습니다. 이 경우 데이터 클래스는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;__setattr__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delattr__&quot;&gt; &lt;code&gt;__delattr__()&lt;/code&gt; &lt;/a&gt; 메서드를 클래스에 추가합니다. 이 메소드는 호출 될 때 &lt;a href=&quot;#dataclasses.FrozenInstanceError&quot;&gt; &lt;code&gt;FrozenInstanceError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="55c8b8a4e69ed2aef84c5a02c66e3da2e510e6b7" translate="yes" xml:space="preserve">
          <source>It is not possible to interrupt the &lt;code&gt;acquire()&lt;/code&gt; method on a lock &amp;mdash; the &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exception will happen after the lock has been acquired.</source>
          <target state="translated">잠금 에서는 &lt;code&gt;acquire()&lt;/code&gt; 메소드 를 중단 할 수 없습니다 . 잠금이 획득 된 후 &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="24ff4ffa82b2b892ee254ff767fd50df824c9ec4" translate="yes" xml:space="preserve">
          <source>It is not recommended to instantiate &lt;em&gt;StreamReader&lt;/em&gt; objects directly; use &lt;a href=&quot;#asyncio.open_connection&quot;&gt;&lt;code&gt;open_connection()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.start_server&quot;&gt;&lt;code&gt;start_server()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;em&gt;StreamReader&lt;/em&gt; 객체를 직접 인스턴스화하지 않는 것이 좋습니다 . 사용 &lt;a href=&quot;#asyncio.open_connection&quot;&gt; &lt;code&gt;open_connection()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.start_server&quot;&gt; &lt;code&gt;start_server()&lt;/code&gt; &lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="9c8eb1dc59babd5bb45a6542412c6c2dbef60bec" translate="yes" xml:space="preserve">
          <source>It is not recommended to instantiate &lt;em&gt;StreamWriter&lt;/em&gt; objects directly; use &lt;a href=&quot;#asyncio.open_connection&quot;&gt;&lt;code&gt;open_connection()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.start_server&quot;&gt;&lt;code&gt;start_server()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;em&gt;StreamWriter&lt;/em&gt; 객체를 직접 인스턴스화하지 않는 것이 좋습니다 . 사용 &lt;a href=&quot;#asyncio.open_connection&quot;&gt; &lt;code&gt;open_connection()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.start_server&quot;&gt; &lt;code&gt;start_server()&lt;/code&gt; &lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="f7c86d9042354a4a12010ffbf2e6c79a46e63619" translate="yes" xml:space="preserve">
          <source>It is occasionally desirable to catch exceptions from an &lt;code&gt;__enter__&lt;/code&gt; method implementation, &lt;em&gt;without&lt;/em&gt; inadvertently catching exceptions from the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement body or the context manager&amp;rsquo;s &lt;code&gt;__exit__&lt;/code&gt; method. By using &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; the steps in the context management protocol can be separated slightly in order to allow this:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 본문 또는 컨텍스트 관리자의 &lt;code&gt;__exit__&lt;/code&gt; 메소드 에서 실수로 예외를 catch &lt;em&gt;하지 않고 &lt;/em&gt; &lt;code&gt;__enter__&lt;/code&gt; 메소드 구현 에서 예외를 포착하는 것이 때때로 바람직합니다 . &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 을 사용 하여 컨텍스트 관리 프로토콜의 단계를 약간 분리하여이를 허용 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17abe925d75df3e6434e095da340d7b3d585efbb" translate="yes" xml:space="preserve">
          <source>It is possible (but not likely) that the parser stops parsing with a successful outcome before reaching the end of the source; in this case, trailing symbols may be ignored instead of causing an error. For example, a backslash followed by two newlines may be followed by arbitrary garbage. This will be fixed once the API for the parser is better.</source>
          <target state="translated">파서가 소스의 끝에 도달하기 전에 성공적인 결과로 파싱을 중지하는 것이 가능하지만 (아마도) 가능하지는 않습니다. 이 경우 오류를 발생시키는 대신 후행 기호가 무시 될 수 있습니다. 예를 들어, 백 슬래시 다음에 두 줄 바꿈 뒤에 임의 가비지가 올 수 있습니다. 파서의 API가 더 좋으면 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d4dc91e3e444d1207eacfb1b8c9b7d64f669d0" translate="yes" xml:space="preserve">
          <source>It is possible that you want to use a different prefix for your tests. You can inform the patchers of the different prefix by setting &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt;:</source>
          <target state="translated">테스트에 다른 접두사를 사용하고 싶을 수도 있습니다. 당신은 설정에 의해 다른 접두사의 구혈 알릴 수 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="b78bc02a5d38d5ce034759672aa988ab58493d7c" translate="yes" xml:space="preserve">
          <source>It is possible to assign a callable Python object that is not a ctypes type, in this case the function is assumed to return a C &lt;code&gt;int&lt;/code&gt;, and the callable will be called with this integer, allowing further processing or error checking. Using this is deprecated, for more flexible post processing or error checking use a ctypes data type as &lt;a href=&quot;#ctypes._FuncPtr.restype&quot;&gt;&lt;code&gt;restype&lt;/code&gt;&lt;/a&gt; and assign a callable to the &lt;a href=&quot;#ctypes._FuncPtr.errcheck&quot;&gt;&lt;code&gt;errcheck&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">ctypes 유형이 아닌 호출 가능한 Python 객체를 할당 할 수 있습니다.이 경우 함수는 C &lt;code&gt;int&lt;/code&gt; 를 리턴하는 것으로 가정 되며이 정수 로 호출 가능 객체가 호출되어 추가 처리 또는 오류 검사가 가능합니다. 더 유연한 사후 처리 또는 오류 검사를 위해 ctypes 데이터 유형을 &lt;a href=&quot;#ctypes._FuncPtr.restype&quot;&gt; &lt;code&gt;restype&lt;/code&gt; 으로 사용&lt;/a&gt; 하고 호출 가능을 &lt;a href=&quot;#ctypes._FuncPtr.errcheck&quot;&gt; &lt;code&gt;errcheck&lt;/code&gt; &lt;/a&gt; 속성에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a0369df82e65498d9a61cbbea72fb5715a7cfcd6" translate="yes" xml:space="preserve">
          <source>It is possible to construct malicious pickle data which will &lt;strong&gt;execute arbitrary code during unpickling&lt;/strong&gt;. Never unpickle data that could have come from an untrusted source, or that could have been tampered with.</source>
          <target state="translated">&lt;strong&gt;unpickling 동안 임의의 코드&lt;/strong&gt; 를 &lt;strong&gt;실행&lt;/strong&gt; 하는 악성 pickle 데이터를 구성 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 신뢰할 수없는 출처에서 가져 왔거나 변조되었을 수있는 데이터는 절대로 피클 링하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6ffefb08180256f54248ce087946347d3dc7ebe6" translate="yes" xml:space="preserve">
          <source>It is possible to crash the Python interpreter when loading a database with a sufficiently large/complex entry due to stack depth limitations in Python&amp;rsquo;s AST compiler.</source>
          <target state="translated">Python의 AST 컴파일러의 스택 깊이 제한으로 인해 충분히 크거나 복잡한 항목이있는 데이터베이스를로드 할 때 Python 인터프리터가 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e9b153eb1d2d572d629baf0a1dcd8a08f67d846" translate="yes" xml:space="preserve">
          <source>It is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Python&amp;rsquo;s AST compiler.</source>
          <target state="translated">파이썬 AST 컴파일러의 스택 깊이 제한으로 인해 파이썬 인터프리터가 충분히 크거나 복잡한 문자열로 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="667abe8e68a549284d45ff70fd062fc2cf5fac92" translate="yes" xml:space="preserve">
          <source>It is possible to crash the Python interpreter with a sufficiently large/complex string when compiling to an AST object due to stack depth limitations in Python&amp;rsquo;s AST compiler.</source>
          <target state="translated">Python의 AST 컴파일러의 스택 깊이 제한으로 인해 AST 객체로 컴파일 할 때 충분히 큰 / 복잡한 문자열로 Python 인터프리터가 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f5b20068a1b037beccc1359b62759b16ab15b78" translate="yes" xml:space="preserve">
          <source>It is possible to create shared objects using shared memory which can be inherited by child processes.</source>
          <target state="translated">자식 프로세스가 상속 할 수있는 공유 메모리를 사용하여 공유 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5f47167a007557bb807d93cb531c2ebd09d5d5" translate="yes" xml:space="preserve">
          <source>It is possible to create structures and unions containing bit fields. Bit fields are only possible for integer fields, the bit width is specified as the third item in the &lt;code&gt;_fields_&lt;/code&gt; tuples:</source>
          <target state="translated">비트 필드를 포함하는 구조체와 공용체를 만들 수 있습니다. 비트 필드는 정수 필드에만 가능하며 비트 너비는 &lt;code&gt;_fields_&lt;/code&gt; 튜플 에서 세 번째 항목으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="db8a275af694f0dd377aeb7a61522ec616a0f705" translate="yes" xml:space="preserve">
          <source>It is possible to declare the return type of a callable without specifying the call signature by substituting a literal ellipsis for the list of arguments in the type hint: &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt;.</source>
          <target state="translated">유형 힌트의 인수 목록에 리터럴 줄임표를 대입하여 Call signature &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; 호출하여 호출 서명을 지정하지 않고 호출 가능의 리턴 유형을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66dbfac9c9ecbf0f3ba234b858bf45197be29989" translate="yes" xml:space="preserve">
          <source>It is possible to define sub-subclasses of structure types, they inherit the fields of the base class plus the &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; defined in the sub-subclass, if any.</source>
          <target state="translated">구조 유형 의 서브 서브 클래스를 정의 할 수 있으며, 서브 클래스에 정의 된 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 와 기본 클래스의 필드를 상속합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="52e02a5e8d810a438d07f3c505bb28740bdb60d9" translate="yes" xml:space="preserve">
          <source>It is possible to define sub-subclasses of structures, they inherit the fields of the base class. If the subclass definition has a separate &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; variable, the fields specified in this are appended to the fields of the base class.</source>
          <target state="translated">구조의 하위 서브 클래스를 정의 할 수 있으며 기본 클래스의 필드를 상속합니다. 서브 클래스 정의에 별도의 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 변수 가 있으면 여기에 지정된 필드가 기본 클래스의 필드에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="479dec54822844d5952dff407e0c75c4abf7dfbc" translate="yes" xml:space="preserve">
          <source>It is possible to define the &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; class variable &lt;em&gt;after&lt;/em&gt; the class statement that defines the Structure subclass, this allows creating data types that directly or indirectly reference themselves:</source>
          <target state="translated">그것은 정의 할 수있다 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; 의&lt;/a&gt; 클래스 변수 &lt;em&gt;후에&lt;/em&gt; 구조 서브 클래스를 정의하는 문장이 직접 또는 간접적으로 자신을 참조 데이터 타입을 만들 수있게 :</target>
        </trans-unit>
        <trans-unit id="41dc430c996cb5dba1d5b954f315a11cad50c234" translate="yes" xml:space="preserve">
          <source>It is possible to modify how Enum members are pickled/unpickled by defining &lt;a href=&quot;pickle#object.__reduce_ex__&quot;&gt;&lt;code&gt;__reduce_ex__()&lt;/code&gt;&lt;/a&gt; in the enumeration class.</source>
          <target state="translated">열거 클래스에서 &lt;a href=&quot;pickle#object.__reduce_ex__&quot;&gt; &lt;code&gt;__reduce_ex__()&lt;/code&gt; &lt;/a&gt; 를 정의하여 열거 멤버를 선택 / 선택 해제하는 방법을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c6a93b23d9d0ef75736ca0a792ff0ce4b6aa42c" translate="yes" xml:space="preserve">
          <source>It is possible to provide a setup statement that is executed only once at the beginning:</source>
          <target state="translated">처음에 한 번만 실행되는 설정 명령문을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aaa2207bb2559e1c452bea74e3b02c4226e1a08" translate="yes" xml:space="preserve">
          <source>It is possible to run a manager server on one machine and have clients use it from other machines (assuming that the firewalls involved allow it).</source>
          <target state="translated">한 시스템에서 관리자 서버를 실행하고 클라이언트가 다른 시스템에서 사용하도록 할 수 있습니다 (관련 방화벽이 허용한다고 가정).</target>
        </trans-unit>
        <trans-unit id="57b2132f9f4ecae5672296c54e7165dcd43d470b" translate="yes" xml:space="preserve">
          <source>It is possible to specify the required argument types of functions exported from DLLs by setting the &lt;code&gt;argtypes&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;argtypes&lt;/code&gt; 속성 을 설정하여 DLL에서 내 보낸 함수의 필수 인수 유형을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="870efee18a65f0470db8320acfa65e0397dea3dc" translate="yes" xml:space="preserve">
          <source>It is preferred that tests that use the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; module follow a few guidelines. One is to name the test module by starting it with &lt;code&gt;test_&lt;/code&gt; and end it with the name of the module being tested. The test methods in the test module should start with &lt;code&gt;test_&lt;/code&gt; and end with a description of what the method is testing. This is needed so that the methods are recognized by the test driver as test methods. Also, no documentation string for the method should be included. A comment (such as &lt;code&gt;# Tests function returns only True or False&lt;/code&gt;) should be used to provide documentation for test methods. This is done because documentation strings get printed out if they exist and thus what test is being run is not stated.</source>
          <target state="translated">&lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 테스트 는 몇 가지 지침을 따르는 것이 좋습니다. 하나는 &lt;code&gt;test_&lt;/code&gt; 로 시작하여 테스트 모듈의 이름을 지정하고 테스트중인 모듈 의 이름으로 종료하는 것입니다. 테스트 모듈의 테스트 메소드는 &lt;code&gt;test_&lt;/code&gt; 로 시작하여 테스트중인 메소드에 대한 설명으로 끝나야합니다. 이는 메소드가 테스트 드라이버에 의해 테스트 메소드로 인식되도록하기 위해 필요합니다. 또한 메소드에 대한 문서 문자열을 포함하지 않아야합니다. 테스트 메소드에 대한 문서를 제공하려면 주석 (예 : &lt;code&gt;# Tests function returns only True or False&lt;/code&gt; )을 사용해야합니다. 이것은 문서화 문자열이 존재하는 경우 인쇄되어 실행중인 테스트가 명시되지 않았기 때문에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4437dd782d3aa5f4d33ce55912438ab2de9ddb49" translate="yes" xml:space="preserve">
          <source>It is probably best to stick to using queues or pipes for communication between processes rather than using the lower level synchronization primitives.</source>
          <target state="translated">하위 레벨 동기화 기본 요소를 사용하는 대신 프로세스 간 통신에 큐 또는 파이프를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3513dd531e92db2dd18418ab9200aa8630263c69" translate="yes" xml:space="preserve">
          <source>It is recommended that you use TestCase implementations to group tests together according to the features they test. &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; provides a mechanism for this: the &lt;em&gt;test suite&lt;/em&gt;, represented by &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; class. In most cases, calling &lt;a href=&quot;#unittest.main&quot;&gt;&lt;code&gt;unittest.main()&lt;/code&gt;&lt;/a&gt; will do the right thing and collect all the module&amp;rsquo;s test cases for you and execute them.</source>
          <target state="translated">TestCase 구현을 사용하여 테스트하는 기능에 따라 테스트를 그룹화하는 것이 좋습니다. &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 클래스로 표시되는 &lt;em&gt;테스트 스위트를&lt;/em&gt; 위한 메커니즘을 제공합니다 . 대부분의 경우 &lt;a href=&quot;#unittest.main&quot;&gt; &lt;code&gt;unittest.main()&lt;/code&gt; &lt;/a&gt; 을 호출 하면 올바른 작업을 수행하고 모든 모듈의 테스트 사례를 수집하여 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7ee962c8bcd7baffe9ba130a3118c335c829f4d0" translate="yes" xml:space="preserve">
          <source>It is responsible for calling all the cleanup functions added by &lt;a href=&quot;#unittest.TestCase.addCleanup&quot;&gt;&lt;code&gt;addCleanup()&lt;/code&gt;&lt;/a&gt;. If you need cleanup functions to be called &lt;em&gt;prior&lt;/em&gt; to &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt;&lt;code&gt;tearDown()&lt;/code&gt;&lt;/a&gt; then you can call &lt;a href=&quot;#unittest.TestCase.doCleanups&quot;&gt;&lt;code&gt;doCleanups()&lt;/code&gt;&lt;/a&gt; yourself.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.addCleanup&quot;&gt; &lt;code&gt;addCleanup()&lt;/code&gt; &lt;/a&gt; 에 의해 추가 된 모든 정리 함수를 호출합니다 . &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt; &lt;code&gt;tearDown()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 이전&lt;/em&gt; 에 정리 함수를 호출 &lt;a href=&quot;#unittest.TestCase.doCleanups&quot;&gt; &lt;code&gt;doCleanups()&lt;/code&gt; &lt;/a&gt; 직접 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66da881a51744abc2d365ae7a19e8866de644b04" translate="yes" xml:space="preserve">
          <source>It is responsible for calling all the cleanup functions added by &lt;code&gt;addCleanupClass()&lt;/code&gt;. If you need cleanup functions to be called &lt;em&gt;prior&lt;/em&gt; to &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt;&lt;code&gt;tearDownClass()&lt;/code&gt;&lt;/a&gt; then you can call &lt;code&gt;doCleanupsClass()&lt;/code&gt; yourself.</source>
          <target state="translated">&lt;code&gt;addCleanupClass()&lt;/code&gt; 에 의해 추가 된 모든 정리 함수를 호출합니다 . &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt; &lt;code&gt;tearDownClass()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 이전&lt;/em&gt; 에 정리 함수를 호출 &lt;code&gt;doCleanupsClass()&lt;/code&gt; 직접 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44bfa96d5424e117886453b18001094b089f64bd" translate="yes" xml:space="preserve">
          <source>It is responsible for calling all the cleanup functions added by &lt;code&gt;addCleanupModule()&lt;/code&gt;. If you need cleanup functions to be called &lt;em&gt;prior&lt;/em&gt; to &lt;code&gt;tearDownModule()&lt;/code&gt; then you can call &lt;a href=&quot;#unittest.doModuleCleanups&quot;&gt;&lt;code&gt;doModuleCleanups()&lt;/code&gt;&lt;/a&gt; yourself.</source>
          <target state="translated">&lt;code&gt;addCleanupModule()&lt;/code&gt; 에 의해 추가 된 모든 정리 함수를 호출합니다 . &lt;code&gt;tearDownModule()&lt;/code&gt; &lt;em&gt;이전&lt;/em&gt; 에 정리 함수를 호출 &lt;a href=&quot;#unittest.doModuleCleanups&quot;&gt; &lt;code&gt;doModuleCleanups()&lt;/code&gt; &lt;/a&gt; 직접 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40d076e54c14795bf1009ae955624fb9ee075980" translate="yes" xml:space="preserve">
          <source>It is set for &lt;code&gt;SELECT&lt;/code&gt; statements without any matching rows as well.</source>
          <target state="translated">일치하는 행이없는 &lt;code&gt;SELECT&lt;/code&gt; 문에도 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4892c14dd8e03e95f7b9a46c2b927e82c3de81e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#opcode-END_FINALLY&quot;&gt;&lt;code&gt;END_FINALLY&lt;/code&gt;&lt;/a&gt;, but doesn&amp;rsquo;t change the bytecode counter nor raise an exception. Used for implementing &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#break&quot;&gt;&lt;code&gt;break&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#continue&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#opcode-END_FINALLY&quot;&gt; &lt;code&gt;END_FINALLY&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 바이트 코드 카운터를 변경하거나 예외를 발생시키지 않습니다. 구현에 사용 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#break&quot;&gt; &lt;code&gt;break&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#continue&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="42d9754d1dda336bfe25a9c6e63c2992d8307a7e" translate="yes" xml:space="preserve">
          <source>It is straightforward to create an ordered dictionary variant that remembers the order the keys were &lt;em&gt;last&lt;/em&gt; inserted. If a new entry overwrites an existing entry, the original insertion position is changed and moved to the end:</source>
          <target state="translated">키가 &lt;em&gt;마지막으로&lt;/em&gt; 삽입 된 순서를 기억하는 정렬 된 사전 변형을 작성하는 것은 간단합니다 . 새 항목이 기존 항목을 덮어 쓰면 원래 삽입 위치가 변경되고 끝으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b290678be018032e40bcd30baa36d13bcef66f17" translate="yes" xml:space="preserve">
          <source>It is the application&amp;rsquo;s responsibility to ensure that all whitespace and special characters are quoted appropriately to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;shell injection&lt;/a&gt; vulnerabilities. The &lt;a href=&quot;shlex#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; function can be used to properly escape whitespace and special characters in strings that are going to be used to construct shell commands.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;쉘 삽입&lt;/a&gt; 취약점 을 피하기 위해 모든 공백과 특수 문자가 적절하게 인용되도록하는 것은 응용 프로그램의 책임 입니다. &lt;a href=&quot;shlex#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 기능이 제대로 구조 쉘 명령에 사용하려고하는 문자열의 공백 및 특수 문자를 이스케이프하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83308bc4ef3c9f055207277d114b19f86e753316" translate="yes" xml:space="preserve">
          <source>It is the application&amp;rsquo;s responsibility to ensure that all whitespace and special characters are quoted appropriately to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;shell injection&lt;/a&gt; vulnerabilities. The &lt;a href=&quot;shlex#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; function can be used to properly escape whitespace and special shell characters in strings that are going to be used to construct shell commands.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;쉘 삽입&lt;/a&gt; 취약점 을 피하기 위해 모든 공백과 특수 문자가 적절하게 인용되도록하는 것은 응용 프로그램의 책임 입니다. &lt;a href=&quot;shlex#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 기능이 제대로 구조 쉘 명령에 사용하려고하는 문자열의 공백 및 특수 쉘 문자를 이스케이프하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba77524bde6cf6c11d179f96eb65e17908025854" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ellipsis&lt;/code&gt; 또는 &lt;code&gt;...&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c82f78122d7edace8ca573121d93f7a6333cafc" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 으로 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a8ce0b24fe78f15c89a4a9c4becf84652288522" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NotImplemented&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="841555ab84a821d8592d3ba16982eb976c179de0" translate="yes" xml:space="preserve">
          <source>It makes it clear that the &lt;code&gt;cm&lt;/code&gt; applies to the whole function, rather than just a piece of it (and saving an indentation level is nice, too).</source>
          <target state="translated">&lt;code&gt;cm&lt;/code&gt; 이 기능의 일부가 아니라 전체 기능에 적용 된다는 것을 분명히 합니다 (그리고 들여 쓰기 수준을 저장하는 것도 좋습니다).</target>
        </trans-unit>
        <trans-unit id="cceaba8129fdd9cb6ff7d523e835d1be2a3900bb" translate="yes" xml:space="preserve">
          <source>It makes little sense to catch synchronous errors like &lt;code&gt;SIGFPE&lt;/code&gt; or &lt;code&gt;SIGSEGV&lt;/code&gt; that are caused by an invalid operation in C code. Python will return from the signal handler to the C code, which is likely to raise the same signal again, causing Python to apparently hang. From Python 3.3 onwards, you can use the &lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt;&lt;code&gt;faulthandler&lt;/code&gt;&lt;/a&gt; module to report on synchronous errors.</source>
          <target state="translated">C 코드에서 유효하지 않은 조작으로 인한 &lt;code&gt;SIGFPE&lt;/code&gt; 또는 &lt;code&gt;SIGSEGV&lt;/code&gt; 와 같은 동기 오류를 잡는 것은 의미가 없습니다. 파이썬은 신호 처리기에서 C 코드로 돌아 오는데, 같은 신호를 다시 발생 시켜서 파이썬이 멈출 것입니다. Python 3.3부터는 오류 &lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt; &lt;code&gt;faulthandler&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 동기 오류를보고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38e76705e1c36e7060b372d7e192caca143da51c" translate="yes" xml:space="preserve">
          <source>It may also be useful to have an &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; assign attributes to an already existing object, rather than a new &lt;a href=&quot;#argparse.Namespace&quot;&gt;&lt;code&gt;Namespace&lt;/code&gt;&lt;/a&gt; object. This can be achieved by specifying the &lt;code&gt;namespace=&lt;/code&gt; keyword argument:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 가 새로운 &lt;a href=&quot;#argparse.Namespace&quot;&gt; &lt;code&gt;Namespace&lt;/code&gt; &lt;/a&gt; 객체가 아닌 기존 객체에 속성을 할당하도록하는 것도 유용 할 수 있습니다 . &lt;code&gt;namespace=&lt;/code&gt; 키워드 인수를 지정하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="fba1d56f7a7c046d3fc4bbe63e3336e206c6db2d" translate="yes" xml:space="preserve">
          <source>It may be preferable to simply create the barrier with a sensible &lt;em&gt;timeout&lt;/em&gt; value to automatically guard against one of the threads going awry.</source>
          <target state="translated">스레드 중 하나가 잘못 진행되는 것을 자동으로 막기 위해 적절한 &lt;em&gt;시간 초과&lt;/em&gt; 값으로 장벽을 만드는 것이 바람직 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed6a077b4756775b9b29b2ea1e03ac9d700dfd8e" translate="yes" xml:space="preserve">
          <source>It must be called at most once per thread object. It arranges for the object&amp;rsquo;s &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method to be invoked in a separate thread of control.</source>
          <target state="translated">스레드 오브젝트 당 최대 한 번 호출되어야합니다. 객체의 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드가 별도의 제어 스레드에서 호출 되도록 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="daad8dfada880cb31549425a5ec3431b9222657b" translate="yes" xml:space="preserve">
          <source>It returns bytes, encoded using the &lt;a href=&quot;token#token.ENCODING&quot;&gt;&lt;code&gt;ENCODING&lt;/code&gt;&lt;/a&gt; token, which is the first token sequence output by &lt;a href=&quot;#tokenize.tokenize&quot;&gt;&lt;code&gt;tokenize()&lt;/code&gt;&lt;/a&gt;. If there is no encoding token in the input, it returns a str instead.</source>
          <target state="translated">&lt;a href=&quot;token#token.ENCODING&quot;&gt; &lt;code&gt;ENCODING&lt;/code&gt; &lt;/a&gt; 토큰을 사용하여 인코딩 된 바이트를 반환 하는데, 이는 &lt;a href=&quot;#tokenize.tokenize&quot;&gt; &lt;code&gt;tokenize()&lt;/code&gt; &lt;/a&gt; 의해 출력되는 첫 번째 토큰 시퀀스 입니다. 입력에 인코딩 토큰이 없으면 대신 str을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a8e3c74f6ede201d039fbecf6218111d0e334740" translate="yes" xml:space="preserve">
          <source>It should be noted that not all jumps are allowed &amp;ndash; for instance it is not possible to jump into the middle of a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop or out of a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clause.</source>
          <target state="translated">모든 점프가 허용되는 것은 아닙니다. 예를 들어 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 루프 의 중간으로 들어가 거나 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절에서 벗어날 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d00162c40ad44bcc91c01b39dbf4174206720406" translate="yes" xml:space="preserve">
          <source>It should not be used to indicate that an operator or method is not meant to be supported at all &amp;ndash; in that case either leave the operator / method undefined or, if a subclass, set it to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연산자 또는 메소드가 전혀 지원되지 않음을 표시하는 데 사용해서는 안됩니다.이 경우 연산자 / 메소드를 정의되지 않은 상태로 두거나 서브 클래스 인 경우이를 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ded5b6e9599dd1f5438c1647424ab89dfd2b577" translate="yes" xml:space="preserve">
          <source>It should return a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; 를&lt;/a&gt; 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="726e6dfbe6b42488d80277b74ab1981ea0eb48c8" translate="yes" xml:space="preserve">
          <source>It starts by constructing up to four directories from a head and a tail part. For the head part, it uses &lt;code&gt;sys.prefix&lt;/code&gt; and &lt;code&gt;sys.exec_prefix&lt;/code&gt;; empty heads are skipped. For the tail part, it uses the empty string and then &lt;code&gt;lib/site-packages&lt;/code&gt; (on Windows) or &lt;code&gt;lib/python&lt;em&gt;X.Y&lt;/em&gt;/site-packages&lt;/code&gt; (on Unix and Macintosh). For each of the distinct head-tail combinations, it sees if it refers to an existing directory, and if so, adds it to &lt;code&gt;sys.path&lt;/code&gt; and also inspects the newly added path for configuration files.</source>
          <target state="translated">머리와 꼬리 부분에서 최대 4 개의 디렉토리를 구성하는 것으로 시작합니다. 헤드 부분의 경우 &lt;code&gt;sys.prefix&lt;/code&gt; 및 &lt;code&gt;sys.exec_prefix&lt;/code&gt; 를 사용합니다 . 빈 머리는 건너 뜁니다. 꼬리 부분의 경우 빈 문자열을 사용한 다음 &lt;code&gt;lib/site-packages&lt;/code&gt; (Windows) 또는 &lt;code&gt;lib/python&lt;em&gt;X.Y&lt;/em&gt;/site-packages&lt;/code&gt; (Unix 및 Macintosh)를 사용합니다. 고유 한 헤드-테일 조합 각각에 대해 기존 디렉토리를 참조하는지 확인하고, 그렇다면 디렉토리를 &lt;code&gt;sys.path&lt;/code&gt; 에 추가하고 새로 추가 된 경로에 구성 파일을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="60e34e8fb6e7795d3b1478935c49f2271750a6ed" translate="yes" xml:space="preserve">
          <source>It supports mapping access by column name and index, iteration, representation, equality testing and &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열 이름 및 색인, 반복, 표시, 동등성 테스트 및 &lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 별로 맵핑 액세스를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="8ef92e73f369396214e54307628eb69b792a4bbe" translate="yes" xml:space="preserve">
          <source>It tries to keep the merits of the old turtle module and to be (nearly) 100% compatible with it. This means in the first place to enable the learning programmer to use all the commands, classes and methods interactively when using the module from within IDLE run with the &lt;code&gt;-n&lt;/code&gt; switch.</source>
          <target state="translated">그것은 오래된 거북이 모듈의 장점을 유지하고 (거의) 100 % 호환되도록 노력합니다. 이것은 학습 프로그래머가 IDLE 내에서 &lt;code&gt;-n&lt;/code&gt; 스위치로 실행하여 모듈을 사용할 때 모든 명령, 클래스 및 메소드를 대화식으로 사용할 수있게하는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="5596437c51c08dd529f0316d43b2b71c787f8abe" translate="yes" xml:space="preserve">
          <source>It uses core algorithm from &lt;a href=&quot;https://cr.yp.to/chacha.html&quot;&gt;ChaCha&lt;/a&gt; cipher designed by &lt;em&gt;Daniel J. Bernstein&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Daniel J. Bernstein이&lt;/em&gt; 디자인 한 &lt;a href=&quot;https://cr.yp.to/chacha.html&quot;&gt;ChaCha&lt;/a&gt; 암호의 핵심 알고리즘을 사용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3aba2968f744adcc41a20aa7e792d5ccd239a3f" translate="yes" xml:space="preserve">
          <source>It will also ignore the module name used in Python 3 doctest reports. Hence both of these variations will work with the flag specified, regardless of whether the test is run under Python 2.7 or Python 3.2 (or later versions):</source>
          <target state="translated">또한 Python 3 doctest 보고서에 사용 된 모듈 이름은 무시합니다. 따라서 테스트가 Python 2.7 또는 Python 3.2 (또는 이후 버전)에서 실행되는지 여부에 관계없이 이러한 변형은 모두 지정된 플래그와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="66a19358efe30907a9def33ebebbf43009608227" translate="yes" xml:space="preserve">
          <source>It will be called to process server continuation responses; the &lt;em&gt;response&lt;/em&gt; argument it is passed will be &lt;code&gt;bytes&lt;/code&gt;. It should return &lt;code&gt;bytes&lt;/code&gt;&lt;em&gt;data&lt;/em&gt; that will be base64 encoded and sent to the server. It should return &lt;code&gt;None&lt;/code&gt; if the client abort response &lt;code&gt;*&lt;/code&gt; should be sent instead.</source>
          <target state="translated">서버 연속 응답을 처리하기 위해 호출됩니다. 전달 되는 &lt;em&gt;응답&lt;/em&gt; 인수는 &lt;code&gt;bytes&lt;/code&gt; 입니다. base64로 인코딩되어 서버로 전송 될 &lt;code&gt;bytes&lt;/code&gt; &lt;em&gt;데이터&lt;/em&gt; 를 리턴해야 합니다. 클라이언트 중단 응답 &lt;code&gt;*&lt;/code&gt; 을 대신 보내야하는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b1ff9842d9447462c9c388a1d83d9a69c4059c5" translate="yes" xml:space="preserve">
          <source>It will call readline a maximum of twice, and return the encoding used (as a string) and a list of any lines (not decoded from bytes) it has read in.</source>
          <target state="translated">readline을 최대 두 번 호출하고 사용 된 인코딩 (문자열)과 읽은 모든 행 목록 (바이트에서 디코딩되지 않음)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e412de0ab51fcff0e7d659b968642619518d0a22" translate="yes" xml:space="preserve">
          <source>It works reliably even when the asyncio event loop is run in a non-main OS thread.</source>
          <target state="translated">asyncio 이벤트 루프가 기본이 아닌 OS 스레드에서 실행될 때에도 안정적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="318fb7d25f2176c7734d91b6446e33df1e3f8f6a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to roll your own skipping decorators by making a decorator that calls &lt;a href=&quot;#unittest.skip&quot;&gt;&lt;code&gt;skip()&lt;/code&gt;&lt;/a&gt; on the test when it wants it to be skipped. This decorator skips the test unless the passed object has a certain attribute:</source>
          <target state="translated">건너 뛰기를 원할 때 테스트에서 &lt;a href=&quot;#unittest.skip&quot;&gt; &lt;code&gt;skip()&lt;/code&gt; &lt;/a&gt; 을 호출하는 데코레이터를 만들어 자신 만의 건너 뛰기 데코레이터를 쉽게 굴릴 수 있습니다. 이 데코레이터는 전달 된 객체에 특정 속성이 없으면 테스트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="cf33e52507dbef8f4d67e44c287b62148de7d34c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not possible to parse empty strings, even if quoted.</source>
          <target state="translated">인용 된 경우에도 빈 문자열을 구문 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e071ef257a84829dddd1b2021f2e352991af9cff" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to loop over every key in the database using this method and the &lt;a href=&quot;#dbm.gnu.gdbm.nextkey&quot;&gt;&lt;code&gt;nextkey()&lt;/code&gt;&lt;/a&gt; method. The traversal is ordered by &lt;code&gt;gdbm&lt;/code&gt;&amp;rsquo;s internal hash values, and won&amp;rsquo;t be sorted by the key values. This method returns the starting key.</source>
          <target state="translated">이 메소드와 &lt;a href=&quot;#dbm.gnu.gdbm.nextkey&quot;&gt; &lt;code&gt;nextkey()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 데이터베이스의 모든 키를 반복 할 수 있습니다 . 순회는 &lt;code&gt;gdbm&lt;/code&gt; 의 내부 해시 값으로 정렬되며 키 값으로 정렬되지 않습니다. 이 메소드는 시작 키를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="79cf85d9f5bddaece698e10c86a31d6561698206" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s tempting to calculate mean and standard deviation from the result vector and report these. However, this is not very useful. In a typical case, the lowest value gives a lower bound for how fast your machine can run the given code snippet; higher values in the result vector are typically not caused by variability in Python&amp;rsquo;s speed, but by other processes interfering with your timing accuracy. So the &lt;a href=&quot;functions#min&quot;&gt;&lt;code&gt;min()&lt;/code&gt;&lt;/a&gt; of the result is probably the only number you should be interested in. After that, you should look at the entire vector and apply common sense rather than statistics.</source>
          <target state="translated">결과 벡터와의 평균 및 표준 편차를 계산하여보고하려고합니다. 그러나 이것은별로 유용하지 않습니다. 일반적으로 가장 낮은 값은 머신이 주어진 코드 스 니펫을 얼마나 빨리 실행할 수 있는지에 대한 하한을 제공합니다. 결과 벡터에서 더 높은 값은 일반적으로 파이썬 속도의 변동성으로 인한 것이 아니라 타이밍 정확도를 방해하는 다른 프로세스에 의해 발생합니다. 따라서 결과 의 &lt;a href=&quot;functions#min&quot;&gt; &lt;code&gt;min()&lt;/code&gt; &lt;/a&gt; 는 아마도 관심을 가질만한 유일한 숫자 일 것입니다. 그 후 전체 벡터를보고 통계보다는 상식을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b5c2cece26ef74815cda706410d529a21bd417" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very helpful to use this feature during script development. The reports produced by &lt;a href=&quot;cgitb#module-cgitb&quot;&gt;&lt;code&gt;cgitb&lt;/code&gt;&lt;/a&gt; provide information that can save you a lot of time in tracking down bugs. You can always remove the &lt;code&gt;cgitb&lt;/code&gt; line later when you have tested your script and are confident that it works correctly.</source>
          <target state="translated">스크립트 개발 중에이 기능을 사용하면 매우 도움이됩니다. &lt;a href=&quot;cgitb#module-cgitb&quot;&gt; &lt;code&gt;cgitb&lt;/code&gt; 가&lt;/a&gt; 생성 한 보고서는 버그를 추적하는 데 많은 시간을 절약 할 수있는 정보를 제공합니다. 스크립트를 테스트하고 올바르게 작동한다고 확신 할 때 언제든지 &lt;code&gt;cgitb&lt;/code&gt; 행을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22c515398dd54e978c320c9deb0d0268d495ea20" translate="yes" xml:space="preserve">
          <source>Italic mode</source>
          <target state="translated">이탤릭 모드</target>
        </trans-unit>
        <trans-unit id="5cbdcd93f424472e328e1a57f47a17f48c00f33b" translate="yes" xml:space="preserve">
          <source>Item Options</source>
          <target state="translated">아이템 옵션</target>
        </trans-unit>
        <trans-unit id="6202f13083abbb77f81ad8a1985547e0eaade10c" translate="yes" xml:space="preserve">
          <source>Item&amp;rsquo;s option values may be displayed in a different order than the order in which they are stored.</source>
          <target state="translated">항목의 옵션 값은 저장된 순서와 다른 순서로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="814115a7a4ce068e1e313aab07088369d6491578" translate="yes" xml:space="preserve">
          <source>Iterating over a message object tree is fairly easy with the &lt;a href=&quot;email.compat32-message#email.message.Message.walk&quot;&gt;&lt;code&gt;Message.walk&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;#module-email.iterators&quot;&gt;&lt;code&gt;email.iterators&lt;/code&gt;&lt;/a&gt; module provides some useful higher level iterations over message object trees.</source>
          <target state="translated">&lt;a href=&quot;email.compat32-message#email.message.Message.walk&quot;&gt; &lt;code&gt;Message.walk&lt;/code&gt; &lt;/a&gt; 메소드를 사용하면 메시지 객체 트리를 반복하는 것이 매우 쉽습니다 . &lt;a href=&quot;#module-email.iterators&quot;&gt; &lt;code&gt;email.iterators&lt;/code&gt; 의&lt;/a&gt; 모듈은 메시지 오브젝트 나무를 통해 유용한 높은 수준의 반복을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dc41d23f9c2b8b34eed362c2d5a66ec1341fc2fe" translate="yes" xml:space="preserve">
          <source>Iterating over the members of an enum does not provide the aliases:</source>
          <target state="translated">열거 형 멤버를 반복해도 별명은 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09a13476ca8a54e634b1c965592cc50659e1d997" translate="yes" xml:space="preserve">
          <source>Iterating views while adding or deleting entries in the dictionary may raise a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; or fail to iterate over all entries.</source>
          <target state="translated">사전에서 항목을 추가하거나 삭제하는 동안보기를 반복하면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 가 발생&lt;/a&gt; 하거나 모든 항목을 반복하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="c8de7b3a4ba4a49d433b993cb2d78885338309d1" translate="yes" xml:space="preserve">
          <source>Iteratively unpack from the buffer &lt;em&gt;buffer&lt;/em&gt; according to the format string &lt;em&gt;format&lt;/em&gt;. This function returns an iterator which will read equally-sized chunks from the buffer until all its contents have been consumed. The buffer&amp;rsquo;s size in bytes must be a multiple of the size required by the format, as reflected by &lt;a href=&quot;#struct.calcsize&quot;&gt;&lt;code&gt;calcsize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식 문자열 &lt;em&gt;형식&lt;/em&gt; 에 따라 버퍼 &lt;em&gt;버퍼&lt;/em&gt; 에서 반복적으로 압축을 풉니 다 . 이 함수는 모든 내용이 소비 될 때까지 버퍼에서 동일한 크기의 청크를 읽는 반복자를 반환합니다. 바이트 단위의 버퍼 크기는 &lt;a href=&quot;#struct.calcsize&quot;&gt; &lt;code&gt;calcsize()&lt;/code&gt; &lt;/a&gt; 의해 반영되는 형식에 필요한 크기의 배수 여야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="4bf9de45ad47d7c5378d6a6b4878a23abb027cf7" translate="yes" xml:space="preserve">
          <source>Iterator Types</source>
          <target state="translated">반복자 유형</target>
        </trans-unit>
        <trans-unit id="46761e79cfdea0019d907a53f45846a1ee9a6345" translate="yes" xml:space="preserve">
          <source>Itertool functions</source>
          <target state="translated">Itertool 기능</target>
        </trans-unit>
        <trans-unit id="6e54a0513216ff9ab3f49477b340232097393b29" translate="yes" xml:space="preserve">
          <source>Itertools Recipes</source>
          <target state="translated">Itertools 레시피</target>
        </trans-unit>
        <trans-unit id="dc3bdbc56788fad2aa8a182d78a9cdd53617a14d" translate="yes" xml:space="preserve">
          <source>Its file,line position.</source>
          <target state="translated">파일, 줄 위치.</target>
        </trans-unit>
        <trans-unit id="715aa3328be5ee249a0969744b5351374ea7673e" translate="yes" xml:space="preserve">
          <source>Its methods create and return &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt; for a number of commonly used data types to be synchronized across processes. This notably includes shared lists and dictionaries.</source>
          <target state="translated">이 메소드는 프로세스간에 동기화 할 수 있도록 일반적으로 사용되는 여러 데이터 유형에 대한 &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;프록시 오브젝트&lt;/a&gt; 를 작성하고 리턴 합니다. 여기에는 특히 공유 목록과 사전이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2fff28012a7534f73380035c0ede53d295420a3b" translate="yes" xml:space="preserve">
          <source>JPEG data in JFIF or Exif formats</source>
          <target state="translated">JFIF 또는 Exif 형식의 JPEG 데이터</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="e73d3511fce24ebc291cfc1a0bf8fb3055e4b3c0" translate="yes" xml:space="preserve">
          <source>JSON is a subset of &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; 1.2. The JSON produced by this module&amp;rsquo;s default settings (in particular, the default &lt;em&gt;separators&lt;/em&gt; value) is also a subset of YAML 1.0 and 1.1. This module can thus also be used as a YAML serializer.</source>
          <target state="translated">JSON은 &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; 1.2 의 하위 집합입니다 . 이 모듈의 기본 설정 (특히 기본 &lt;em&gt;구분 기호&lt;/em&gt; 값) 으로 생성 된 JSON 도 YAML 1.0 및 1.1의 하위 집합입니다. 따라서이 모듈은 YAML 시리얼 라이저로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74477a71066c32a03e3b5e0f372cb2d16bb5ab67" translate="yes" xml:space="preserve">
          <source>JSON is a text serialization format (it outputs unicode text, although most of the time it is then encoded to &lt;code&gt;utf-8&lt;/code&gt;), while pickle is a binary serialization format;</source>
          <target state="translated">JSON은 텍스트 직렬화 형식이며 (유니 코드 텍스트를 출력하지만 대부분 &lt;code&gt;utf-8&lt;/code&gt; 로 인코딩 되지만) pickle은 이진 직렬화 형식입니다.</target>
        </trans-unit>
        <trans-unit id="88798c723bcb212288a6869233d3bcfab4c6e224" translate="yes" xml:space="preserve">
          <source>JSON is human-readable, while pickle is not;</source>
          <target state="translated">JSON은 사람이 읽을 수 있지만 pickle은 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="26dcb3da6e496d8fa3c185868f494af19a08c8d6" translate="yes" xml:space="preserve">
          <source>JSON is interoperable and widely used outside of the Python ecosystem, while pickle is Python-specific;</source>
          <target state="translated">JSON은 Python 에코 시스템 외부에서 상호 운용 가능하고 널리 사용되는 반면, pickle은 Python 전용입니다.</target>
        </trans-unit>
        <trans-unit id="b58d3fed6d6262143493b847936ace0c088070e9" translate="yes" xml:space="preserve">
          <source>JSON, by default, can only represent a subset of the Python built-in types, and no custom classes; pickle can represent an extremely large number of Python types (many of them automatically, by clever usage of Python&amp;rsquo;s introspection facilities; complex cases can be tackled by implementing &lt;a href=&quot;#pickle-inst&quot;&gt;specific object APIs&lt;/a&gt;);</source>
          <target state="translated">JSON은 기본적으로 Python 내장 유형의 서브 세트 만 나타낼 수 있으며 사용자 정의 클래스는 없습니다. pickle은 매우 많은 수의 Python 유형을 나타낼 수 있습니다 (Python의 내부 검사 기능을 영리하게 사용하여 많은 유형이 자동으로 수행됩니다. 복잡한 &lt;a href=&quot;#pickle-inst&quot;&gt;객체&lt;/a&gt; 는 특정 객체 API 를 구현하여 해결할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="3c157bbba1c3c6dd4684d9e17bd5cbdd293fa040" translate="yes" xml:space="preserve">
          <source>James Henstridge</source>
          <target state="translated">제임스 헨스트리지</target>
        </trans-unit>
        <trans-unit id="aae47823aad5375bf33ac2c5178d07c30af7b55d" translate="yes" xml:space="preserve">
          <source>January 1 of year 1 is called day number 1, January 2 of year 1 is called day number 2, and so on. &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt;</source>
          <target state="translated">1 년 1 월 1 일은 1 일 1이라고하고, 1 년 1 월 2 일은 2 일이라고합니다. &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="db10f36d9223f6e5b2b87cbc94ecdb4f6367b21d" translate="yes" xml:space="preserve">
          <source>Japanese, Korean, Simplified Chinese, Western Europe, Greek</source>
          <target state="translated">일본어, 한국어, 중국어 간체, 서유럽, 그리스어</target>
        </trans-unit>
        <trans-unit id="da19e6ace2ea93a2694470984913cc9be9f8a78a" translate="yes" xml:space="preserve">
          <source>Java Platform</source>
          <target state="translated">자바 플랫폼</target>
        </trans-unit>
        <trans-unit id="24e07b1280211517893038a57e2fa614b51c83cb" translate="yes" xml:space="preserve">
          <source>Join a &lt;em&gt;thread&lt;/em&gt; within &lt;em&gt;timeout&lt;/em&gt;. Raise an &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if thread is still alive after &lt;em&gt;timeout&lt;/em&gt; seconds.</source>
          <target state="translated">&lt;em&gt;제한 시간&lt;/em&gt; 내에 &lt;em&gt;스레드를&lt;/em&gt; 결합하십시오 . 올립니다 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 스레드가 여전히 후 살아 경우 &lt;em&gt;시간 제한&lt;/em&gt; (초).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86ec87f8fcd9ef64d26787f07fb5fc64981fb9d0" translate="yes" xml:space="preserve">
          <source>Join adjacent text nodes so that all stretches of text are stored as single &lt;code&gt;Text&lt;/code&gt; instances. This simplifies processing text from a DOM tree for many applications.</source>
          <target state="translated">모든 텍스트 스트레치가 단일 &lt;code&gt;Text&lt;/code&gt; 인스턴스 로 저장되도록 인접한 텍스트 노드를 결합하십시오 . 이는 많은 응용 프로그램에서 DOM 트리의 텍스트 처리를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="60f2e868ffb015b783bfe34cd024cda4ded92d88" translate="yes" xml:space="preserve">
          <source>Join one or more path components intelligently. The return value is the concatenation of &lt;em&gt;path&lt;/em&gt; and any members of &lt;em&gt;*paths&lt;/em&gt; with exactly one directory separator (&lt;code&gt;os.sep&lt;/code&gt;) following each non-empty part except the last, meaning that the result will only end in a separator if the last part is empty. If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.</source>
          <target state="translated">하나 이상의 경로 구성 요소를 지능적으로 결합하십시오. 리턴 값의 연결 한 &lt;em&gt;경로&lt;/em&gt; 중 어느 멤버 &lt;em&gt;* 경로&lt;/em&gt; 정확히 하나 개의 디렉토리 분리 (함께 &lt;code&gt;os.sep&lt;/code&gt; 마지막 부분이 비어있는 경우 결과가 단지 세퍼레이터로 끝나는 것을 의미 마지막을 제외한 각각의 비어 있지 않은 부분 다음) . 구성 요소가 절대 경로 인 경우 이전의 모든 구성 요소가 버리고 절대 경로 구성 요소에서 결합이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="eaf8550cd527a4aa5bcd750c5566f8a76a8a1f3f" translate="yes" xml:space="preserve">
          <source>Join the background thread. This can only be used after &lt;a href=&quot;#multiprocessing.Queue.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; has been called. It blocks until the background thread exits, ensuring that all data in the buffer has been flushed to the pipe.</source>
          <target state="translated">백그라운드 스레드에 참여하십시오. &lt;a href=&quot;#multiprocessing.Queue.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 가 호출 된 후에 만 사용할 수 있습니다 . 백그라운드 스레드가 종료 될 때까지 차단하여 버퍼의 모든 데이터가 파이프로 플러시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fffc9a5e23a3f1b2ccacd3e4adf7ea7865062fbf" translate="yes" xml:space="preserve">
          <source>Joining processes that use queues</source>
          <target state="translated">큐를 사용하는 프로세스 결합</target>
        </trans-unit>
        <trans-unit id="80c8c7d106ea49237f4b6ea2c4ae9879166d4287" translate="yes" xml:space="preserve">
          <source>Joining zombie processes</source>
          <target state="translated">좀비 프로세스 참여</target>
        </trans-unit>
        <trans-unit id="e3d34ba51db462866353060a6c3f2d483d8c7643" translate="yes" xml:space="preserve">
          <source>Juan David Ib&amp;aacute;&amp;ntilde;ez Palomar</source>
          <target state="translated">후안 데이비드 이바네즈 팔로마</target>
        </trans-unit>
        <trans-unit id="e51d02293aa68e17eecb8aa544b483cf96c6fa49" translate="yes" xml:space="preserve">
          <source>Just returns 10, as this is Decimal, :)</source>
          <target state="translated">이것은 10 진수이므로 10을 반환합니다. :)</target>
        </trans-unit>
        <trans-unit id="4f1fddc4dabd32f2e61ca9f91e0ca2bb68fd646f" translate="yes" xml:space="preserve">
          <source>Just returns self, this method is only to comply with the Decimal Specification.</source>
          <target state="translated">그냥 self를 반환합니다.이 방법은 Decimal Specification에만 따릅니다.</target>
        </trans-unit>
        <trans-unit id="47d7416fd642efd47199c18f79129bbd51455d2c" translate="yes" xml:space="preserve">
          <source>KEY_DC</source>
          <target state="translated">KEY_DC</target>
        </trans-unit>
        <trans-unit id="033f3bd76e9037ed2eacdf745e1f381ae09e1e6e" translate="yes" xml:space="preserve">
          <source>KEY_END</source>
          <target state="translated">KEY_END</target>
        </trans-unit>
        <trans-unit id="e8b0bdc4a205564ace3e67b5d2590e9a7b3ebe0f" translate="yes" xml:space="preserve">
          <source>KEY_HOME</source>
          <target state="translated">KEY_HOME</target>
        </trans-unit>
        <trans-unit id="1ed0f4c565cdf40018aa6d1a7f2dffe8a57d07b7" translate="yes" xml:space="preserve">
          <source>KEY_IC</source>
          <target state="translated">KEY_IC</target>
        </trans-unit>
        <trans-unit id="f9606cdd29d726a1efc9306cd6515a746d5e9de8" translate="yes" xml:space="preserve">
          <source>KEY_NPAGE</source>
          <target state="translated">KEY_NPAGE</target>
        </trans-unit>
        <trans-unit id="817be3fc68df61d26f925ae492d47665d4ff3127" translate="yes" xml:space="preserve">
          <source>KEY_PPAGE</source>
          <target state="translated">KEY_PPAGE</target>
        </trans-unit>
        <trans-unit id="580b34c07a9b803a5f68c0e7990ba58269a92490" translate="yes" xml:space="preserve">
          <source>Kahan, W: Branch cuts for complex elementary functions; or, Much ado about nothing&amp;rsquo;s sign bit. In Iserles, A., and Powell, M. (eds.), The state of the art in numerical analysis. Clarendon Press (1987) pp165&amp;ndash;211.</source>
          <target state="translated">Kahan, W : 복잡한 초등 함수를위한 분기 컷; 또는 아무것도 부호 비트에 대해 너무 열망합니다. Iserles, A. 및 Powell, M. (eds.)에서 수치 분석의 최신 기술. Clarendon Press (1987) pp165&amp;ndash;211.</target>
        </trans-unit>
        <trans-unit id="b9fedaa07b209e1f7a9c2d83295a76fe49f3b49f" translate="yes" xml:space="preserve">
          <source>Kazakh</source>
          <target state="translated">Kazakh</target>
        </trans-unit>
        <trans-unit id="24a946a3338502270c212fb158dbe6bb77ee0309" translate="yes" xml:space="preserve">
          <source>Keep a database of &lt;code&gt;(realm, uri) -&amp;gt; (user, password)&lt;/code&gt; mappings.</source>
          <target state="translated">&lt;code&gt;(realm, uri) -&amp;gt; (user, password)&lt;/code&gt; 맵핑 의 데이터베이스를 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="37bfb81baa66440423c45f18f727362864a6cfce" translate="yes" xml:space="preserve">
          <source>Keep a database of &lt;code&gt;(realm, uri) -&amp;gt; (user, password)&lt;/code&gt; mappings. A realm of &lt;code&gt;None&lt;/code&gt; is considered a catch-all realm, which is searched if no other realm fits.</source>
          <target state="translated">&lt;code&gt;(realm, uri) -&amp;gt; (user, password)&lt;/code&gt; 맵핑 의 데이터베이스를 유지하십시오 . &lt;code&gt;None&lt;/code&gt; 영역은 범용 영역으로 간주되며 다른 영역에 맞지 않으면 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="03de4413ffacf22791c546e17121674eadf9916d" translate="yes" xml:space="preserve">
          <source>Keep in mind that if the node you&amp;rsquo;re operating on has child nodes you must either transform the child nodes yourself or call the &lt;code&gt;generic_visit()&lt;/code&gt; method for the node first.</source>
          <target state="translated">작업중인 노드에 자식 노드가있는 경우 자식 노드를 직접 변환하거나 노드의 &lt;code&gt;generic_visit()&lt;/code&gt; 메서드를 먼저 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c563af2eb52c22befb802b194ed5fde24ca2d3a7" translate="yes" xml:space="preserve">
          <source>Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays doesn&amp;rsquo;t &lt;em&gt;copy&lt;/em&gt; the sub-object, instead it retrieves a wrapper object accessing the root-object&amp;rsquo;s underlying buffer.</source>
          <target state="translated">Structure, Unions 및 Arrays에서 하위 객체를 검색하면 하위 객체가 &lt;em&gt;복사&lt;/em&gt; 되지 않고 대신 루트 객체의 기본 버퍼에 액세스하는 래퍼 객체가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="4298e303439a440ab55bf7bbf886c709ae66ef29" translate="yes" xml:space="preserve">
          <source>Keeping references to frame objects, as found in the first element of the frame records these functions return, can cause your program to create reference cycles. Once a reference cycle has been created, the lifespan of all objects which can be accessed from the objects which form the cycle can become much longer even if Python&amp;rsquo;s optional cycle detector is enabled. If such cycles must be created, it is important to ensure they are explicitly broken to avoid the delayed destruction of objects and increased memory consumption which occurs.</source>
          <target state="translated">이러한 함수가 반환하는 프레임 레코드의 첫 번째 요소에있는 프레임 객체에 대한 참조를 유지하면 프로그램이 참조주기를 만들 수 있습니다. 참조 사이클이 생성되면 파이썬의 선택적 사이클 검출기가 활성화되어 있어도 사이클을 형성하는 객체에서 액세스 할 수있는 모든 객체의 수명이 훨씬 더 길어질 수 있습니다. 이러한주기를 작성해야하는 경우, 오브젝트의 지연된 소멸 및 발생하는 메모리 소비 증가를 피하기 위해 명시 적으로 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="52a345e99e64b9ca6f928d5687177a892525371b" translate="yes" xml:space="preserve">
          <source>Kent Beck&amp;rsquo;s original paper on testing frameworks using the pattern shared by &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; 가&lt;/a&gt; 공유 한 패턴을 사용한 프레임 워크 테스트에 대한 Kent Beck의 원본 논문 .</target>
        </trans-unit>
        <trans-unit id="7267bbd8e2137364d4939e2071439e42d40f32fb" translate="yes" xml:space="preserve">
          <source>Kevent Objects</source>
          <target state="translated">Kevent 객체</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="dbab391d4ec83ba2f4394be31de35a61669a5996" translate="yes" xml:space="preserve">
          <source>Key and values are always stored as bytes. This means that when strings are used they are implicitly converted to the default encoding before being stored.</source>
          <target state="translated">키와 값은 항상 바이트로 저장됩니다. 이는 문자열이 사용될 때 저장되기 전에 기본 인코딩으로 암시 적으로 변환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2f019ec46ab9548a295fae40fb32bbf280932bb8" translate="yes" xml:space="preserve">
          <source>Key bindings</source>
          <target state="translated">키 바인딩</target>
        </trans-unit>
        <trans-unit id="f0cc3ad4ee33d02515db5713788523cd4cf74945" translate="yes" xml:space="preserve">
          <source>Key constant</source>
          <target state="translated">키 상수</target>
        </trans-unit>
        <trans-unit id="6bbbfa7e022b93aaca86b7e55f8cf9f9e9f25683" translate="yes" xml:space="preserve">
          <source>Key derivation</source>
          <target state="translated">키 파생</target>
        </trans-unit>
        <trans-unit id="4c6694a69ad0f467a3eb48c707287ff83fc7df0b" translate="yes" xml:space="preserve">
          <source>Key derivation and key stretching algorithms are designed for secure password hashing. Naive algorithms such as &lt;code&gt;sha1(password)&lt;/code&gt; are not resistant against brute-force attacks. A good password hashing function must be tunable, slow, and include a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_%28cryptography%29&quot;&gt;salt&lt;/a&gt;.</source>
          <target state="translated">키 파생 및 키 확장 알고리즘은 안전한 암호 해싱을 위해 설계되었습니다. &lt;code&gt;sha1(password)&lt;/code&gt; 과 같은 고유 알고리즘 은 무차별 대입 공격에 대해 내성이 없습니다. 좋은 암호 해싱 기능은 조정 가능하고 느리며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_%28cryptography%29&quot;&gt;salt를&lt;/a&gt; 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="99214c71e9133c70244f001bb7de7d4fe414b3a5" translate="yes" xml:space="preserve">
          <source>KeyboardInterrupt</source>
          <target state="translated">KeyboardInterrupt</target>
        </trans-unit>
        <trans-unit id="aba6df4879209d36e1a5a7eb8f2829348bfc1607" translate="yes" xml:space="preserve">
          <source>Keycap</source>
          <target state="translated">Keycap</target>
        </trans-unit>
        <trans-unit id="f431dd90bf1296fd6be5fc2fecca2fe9d70abb5f" translate="yes" xml:space="preserve">
          <source>Keyed hashing</source>
          <target state="translated">키 해싱</target>
        </trans-unit>
        <trans-unit id="914eeba5ce4ce3c00e9428b28f9ccf6cf0cce211" translate="yes" xml:space="preserve">
          <source>Keyed hashing can be used for authentication as a faster and simpler replacement for &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Hash-based message authentication code&lt;/a&gt; (HMAC). BLAKE2 can be securely used in prefix-MAC mode thanks to the indifferentiability property inherited from BLAKE.</source>
          <target state="translated">키 기반 해싱은 HMAC ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Hash-based Message Authentication Code&lt;/a&gt; )를 더 빠르고 간단하게 대체 할 수 있도록 인증에 사용할 수 있습니다 . BLAKE2는 BLAKE에서 상속 된 미분 속성 덕분에 접두사 -MAC 모드에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9548bb855e07b59b91626cc17d69c771e2e87b2" translate="yes" xml:space="preserve">
          <source>Keys and values are iterated over in insertion order. This allows the creation of &lt;code&gt;(value, key)&lt;/code&gt; pairs using &lt;a href=&quot;functions#zip&quot;&gt;&lt;code&gt;zip()&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;pairs = zip(d.values(), d.keys())&lt;/code&gt;. Another way to create the same list is &lt;code&gt;pairs = [(v, k) for (k, v) in d.items()]&lt;/code&gt;.</source>
          <target state="translated">키와 값은 삽입 순서대로 반복됩니다. &lt;a href=&quot;functions#zip&quot;&gt; &lt;code&gt;zip()&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;pairs = zip(d.values(), d.keys())&lt;/code&gt; 사용하여 &lt;code&gt;(value, key)&lt;/code&gt; 쌍을 만들 수 있습니다 . 동일한 목록을 만드는 또 다른 방법 &lt;code&gt;pairs = [(v, k) for (k, v) in d.items()]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c300864ed75026c1eb88a7a83759898d09c397b8" translate="yes" xml:space="preserve">
          <source>Keys are referred to by integer constants with names starting with &lt;code&gt;KEY_&lt;/code&gt;. The exact keycaps available are system dependent.</source>
          <target state="translated">키는 이름이 &lt;code&gt;KEY_&lt;/code&gt; 로 시작하는 정수 상수로 참조됩니다 . 사용 가능한 정확한 키 캡은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="228f5d286dcdd48b2fc18dd8734bb35bc953ff86" translate="yes" xml:space="preserve">
          <source>Keys in key/value pairs of JSON are always of the type &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. When a dictionary is converted into JSON, all the keys of the dictionary are coerced to strings. As a result of this, if a dictionary is converted into JSON and then back into a dictionary, the dictionary may not equal the original one. That is, &lt;code&gt;loads(dumps(x)) != x&lt;/code&gt; if x has non-string keys.</source>
          <target state="translated">JSON의 키 / 값 쌍의 키는 항상 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 유형 입니다. 사전이 JSON으로 변환되면 사전의 모든 키가 문자열로 강제 변환됩니다. 그 결과 사전이 JSON으로 변환 된 다음 사전으로 다시 돌아 가면 사전이 원래 사전과 같지 않을 수 있습니다. 즉, x에 문자열이 아닌 키가 있으면 &lt;code&gt;loads(dumps(x)) != x&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="439a459f8af4300a3a5b519bbed313651ca1e4c1" translate="yes" xml:space="preserve">
          <source>Keys views are set-like since their entries are unique and hashable. If all values are hashable, so that &lt;code&gt;(key, value)&lt;/code&gt; pairs are unique and hashable, then the items view is also set-like. (Values views are not treated as set-like since the entries are generally not unique.) For set-like views, all of the operations defined for the abstract base class &lt;a href=&quot;collections.abc#collections.abc.Set&quot;&gt;&lt;code&gt;collections.abc.Set&lt;/code&gt;&lt;/a&gt; are available (for example, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt;).</source>
          <target state="translated">키보기는 항목이 고유하고 해시 가능하므로 설정이 비슷합니다. &lt;code&gt;(key, value)&lt;/code&gt; 쌍이 고유하고 해시 가능 하도록 모든 값을 해시 가능 하면 항목보기도 설정됩니다. (값보기는 일반적으로 항목이 고유하지 않으므로 값보기로 설정되지 않습니다.) 세트 유사보기의 경우 추상 기본 클래스 &lt;a href=&quot;collections.abc#collections.abc.Set&quot;&gt; &lt;code&gt;collections.abc.Set&lt;/code&gt; 에&lt;/a&gt; 대해 정의 된 모든 조작 을 사용할 수 있습니다 (예 : &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="72035afe680b44899ee30976fd5b486a93144c83" translate="yes" xml:space="preserve">
          <source>Keystroke</source>
          <target state="translated">Keystroke</target>
        </trans-unit>
        <trans-unit id="a0256d5e54265d1b99c70a9f07e115e966a973da" translate="yes" xml:space="preserve">
          <source>Keywords can be used in the &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt;&lt;code&gt;patch.dict()&lt;/code&gt;&lt;/a&gt; call to set values in the dictionary:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt; &lt;code&gt;patch.dict()&lt;/code&gt; &lt;/a&gt; 호출 에서 키워드를 사용 하여 사전에 값을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b473142e64b2d483a80088f0192d814677f79849" translate="yes" xml:space="preserve">
          <source>Kill the child.</source>
          <target state="translated">아이를 죽여라.</target>
        </trans-unit>
        <trans-unit id="dfb8d10a715be56498bf3463ceb602e0c5f6cdfd" translate="yes" xml:space="preserve">
          <source>Kill the subprocess and close all pipes.</source>
          <target state="translated">서브 프로세스를 종료하고 모든 파이프를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="bcef2d72d27a3ff305fd835a27596403d70aa65a" translate="yes" xml:space="preserve">
          <source>Kill the subprocess by calling the &lt;a href=&quot;#asyncio.SubprocessTransport.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.SubprocessTransport.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 서브 프로세스를 종료하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eea27376f6c77dd4e7d334cd247a3c6708d22ec" translate="yes" xml:space="preserve">
          <source>Kill the subprocess.</source>
          <target state="translated">하위 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="9f19c6828b717749bb8b678b96baba09b9afe4b9" translate="yes" xml:space="preserve">
          <source>Kills the child. On Posix OSs the function sends SIGKILL to the child. On Windows &lt;a href=&quot;#subprocess.Popen.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;#subprocess.Popen.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아이를 죽입니다. Posix OS에서이 기능은 SIGKILL을 자식에게 보냅니다. Windows에서 &lt;a href=&quot;#subprocess.Popen.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#subprocess.Popen.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="dec66c5bf0f7fe4cc038ac871def8eb1ac31c146" translate="yes" xml:space="preserve">
          <source>Korean</source>
          <target state="translated">Korean</target>
        </trans-unit>
        <trans-unit id="6f4d7efd09292b580160cf054a1eb415aa098b83" translate="yes" xml:space="preserve">
          <source>Kqueue Objects</source>
          <target state="translated">큐케 오브젝트</target>
        </trans-unit>
        <trans-unit id="1ae87da77ec3d4df1eb9c1cc7937078e8fd86235" translate="yes" xml:space="preserve">
          <source>L-System</source>
          <target state="translated">L-System</target>
        </trans-unit>
        <trans-unit id="4935e8e440452679bb6e8677598051c98309501a" translate="yes" xml:space="preserve">
          <source>LIFO</source>
          <target state="translated">LIFO</target>
        </trans-unit>
        <trans-unit id="8f692914bc66ead997b8bc1788f89a45c63f1006" translate="yes" xml:space="preserve">
          <source>LIFO Queue</source>
          <target state="translated">LIFO 대기열</target>
        </trans-unit>
        <trans-unit id="e0ac7d929c8c9064651f3a5b472a916a78c16845" translate="yes" xml:space="preserve">
          <source>LOG_ALERT</source>
          <target state="translated">LOG_ALERT</target>
        </trans-unit>
        <trans-unit id="00a42081f87dfdb7c8750d2dc99a1c5a47afe15c" translate="yes" xml:space="preserve">
          <source>LOG_AUTH</source>
          <target state="translated">LOG_AUTH</target>
        </trans-unit>
        <trans-unit id="b059e128bbbf4abbc726cbc5b3dc15823fa1d3b0" translate="yes" xml:space="preserve">
          <source>LOG_AUTHPRIV</source>
          <target state="translated">LOG_AUTHPRIV</target>
        </trans-unit>
        <trans-unit id="3ea8e1cd8bec535a6b614c37476a25af434a2a64" translate="yes" xml:space="preserve">
          <source>LOG_CRIT</source>
          <target state="translated">LOG_CRIT</target>
        </trans-unit>
        <trans-unit id="e14c128e15575171dccf2a786c6c56cfe90aabfb" translate="yes" xml:space="preserve">
          <source>LOG_CRON</source>
          <target state="translated">LOG_CRON</target>
        </trans-unit>
        <trans-unit id="2db1ea382ae920e08017868d8ca7dc74f1e87577" translate="yes" xml:space="preserve">
          <source>LOG_DAEMON</source>
          <target state="translated">LOG_DAEMON</target>
        </trans-unit>
        <trans-unit id="e9132069aa3cd9868136c9eab4c9121997cd9261" translate="yes" xml:space="preserve">
          <source>LOG_DEBUG</source>
          <target state="translated">LOG_DEBUG</target>
        </trans-unit>
        <trans-unit id="5cbc989f5f6b54b988f6cf238d1dfcafddfe5df0" translate="yes" xml:space="preserve">
          <source>LOG_EMERG</source>
          <target state="translated">LOG_EMERG</target>
        </trans-unit>
        <trans-unit id="c25ebb67e3f524ee4cfb9f242122b115231b2969" translate="yes" xml:space="preserve">
          <source>LOG_ERR</source>
          <target state="translated">LOG_ERR</target>
        </trans-unit>
        <trans-unit id="7076f8e47c7f564a083cced7437884fc3de9c20e" translate="yes" xml:space="preserve">
          <source>LOG_FTP</source>
          <target state="translated">LOG_FTP</target>
        </trans-unit>
        <trans-unit id="508d693347703c9b1449225c00b44e2e84f15cce" translate="yes" xml:space="preserve">
          <source>LOG_INFO</source>
          <target state="translated">LOG_INFO</target>
        </trans-unit>
        <trans-unit id="147a80a7b7486a934d7581b0f33986ae6651bd87" translate="yes" xml:space="preserve">
          <source>LOG_KERN</source>
          <target state="translated">LOG_KERN</target>
        </trans-unit>
        <trans-unit id="4bf6ef93839f6872c9f92acc4f4b838c163bdc96" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL0</source>
          <target state="translated">LOG_LOCAL0</target>
        </trans-unit>
        <trans-unit id="1d85977d2d454e9c3494e61168702f4cbecf12c8" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL1</source>
          <target state="translated">LOG_LOCAL1</target>
        </trans-unit>
        <trans-unit id="e587b1ef1b9f3479ac96923decd64231690910bb" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL2</source>
          <target state="translated">LOG_LOCAL2</target>
        </trans-unit>
        <trans-unit id="ae76a49e2672fc55b235abad25133bc1cc0b3ad5" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL3</source>
          <target state="translated">LOG_LOCAL3</target>
        </trans-unit>
        <trans-unit id="a46daeebb6f0fc83ba853556f660485fc6464822" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL4</source>
          <target state="translated">LOG_LOCAL4</target>
        </trans-unit>
        <trans-unit id="f1df950575fc4b0c0074a0abb00861a8e08a3ed6" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL5</source>
          <target state="translated">LOG_LOCAL5</target>
        </trans-unit>
        <trans-unit id="a5d06673189a0f5f9d67757287d862777d523941" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL6</source>
          <target state="translated">LOG_LOCAL6</target>
        </trans-unit>
        <trans-unit id="f51ad7929d644389ddc043e95d9d787a20eb0f61" translate="yes" xml:space="preserve">
          <source>LOG_LOCAL7</source>
          <target state="translated">LOG_LOCAL7</target>
        </trans-unit>
        <trans-unit id="1ca5af74225a0e933cda1a23779b6b9b7534a5c0" translate="yes" xml:space="preserve">
          <source>LOG_LPR</source>
          <target state="translated">LOG_LPR</target>
        </trans-unit>
        <trans-unit id="3266bdf7a824a1128c05ff0a6eacbb163573bfdb" translate="yes" xml:space="preserve">
          <source>LOG_MAIL</source>
          <target state="translated">LOG_MAIL</target>
        </trans-unit>
        <trans-unit id="f460581d8a89631890f08c7c200582c071d9f348" translate="yes" xml:space="preserve">
          <source>LOG_NEWS</source>
          <target state="translated">LOG_NEWS</target>
        </trans-unit>
        <trans-unit id="fd9c5faaf23df86fefa8b46f512c8f9f2f910ea4" translate="yes" xml:space="preserve">
          <source>LOG_NOTICE</source>
          <target state="translated">LOG_NOTICE</target>
        </trans-unit>
        <trans-unit id="00b0b0f7b44d7be30d92b1245948b1df8d49d79b" translate="yes" xml:space="preserve">
          <source>LOG_SYSLOG</source>
          <target state="translated">LOG_SYSLOG</target>
        </trans-unit>
        <trans-unit id="cf326c7cb4d0b7bd59e5815a628a819974d8b6a6" translate="yes" xml:space="preserve">
          <source>LOG_USER</source>
          <target state="translated">LOG_USER</target>
        </trans-unit>
        <trans-unit id="b69a6c99cd1a6e6314b53f763c30ba82bc041bc6" translate="yes" xml:space="preserve">
          <source>LOG_UUCP</source>
          <target state="translated">LOG_UUCP</target>
        </trans-unit>
        <trans-unit id="d0479a4f305480aef0fe90fae83a03f4865e7fd9" translate="yes" xml:space="preserve">
          <source>LOG_WARNING</source>
          <target state="translated">LOG_WARNING</target>
        </trans-unit>
        <trans-unit id="74341e3c271df3c784e595b804b1f90be0f80429" translate="yes" xml:space="preserve">
          <source>Label</source>
          <target state="translated">Label</target>
        </trans-unit>
        <trans-unit id="011416c82c132a4f52517e4bbdc2375314f6f840" translate="yes" xml:space="preserve">
          <source>Label Options</source>
          <target state="translated">라벨 옵션</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="db07be184479f34078cd4fc76d248dc0975720e9" translate="yes" xml:space="preserve">
          <source>Languages</source>
          <target state="translated">Languages</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">대용량 파일 지원</target>
        </trans-unit>
        <trans-unit id="314cf2f01043a4a7510f794394e0b8c96cda1587" translate="yes" xml:space="preserve">
          <source>Large file support is enabled in Python when the size of an &lt;code&gt;off_t&lt;/code&gt; is larger than a &lt;code&gt;long&lt;/code&gt; and the &lt;code&gt;long long&lt;/code&gt; is at least as large as an &lt;code&gt;off_t&lt;/code&gt;. It may be necessary to configure and compile Python with certain compiler flags to enable this mode. For example, it is enabled by default with recent versions of Irix, but with Solaris 2.6 and 2.7 you need to do something like:</source>
          <target state="translated">의 크기 때 큰 파일 지원은 파이썬에서 사용 가능 &lt;code&gt;off_t&lt;/code&gt; 는 (A)보다 큰 &lt;code&gt;long&lt;/code&gt; 와는 &lt;code&gt;long long&lt;/code&gt; 큰로서 적어도입니다 &lt;code&gt;off_t&lt;/code&gt; . 이 모드를 활성화하려면 특정 컴파일러 플래그로 Python을 구성하고 컴파일해야 할 수도 있습니다. 예를 들어, 최신 버전의 Irix에서는 기본적으로 활성화되어 있지만 Solaris 2.6 및 2.7에서는 다음과 같은 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4101486e371d681731851bb447c9aa495b0e247" translate="yes" xml:space="preserve">
          <source>Later, calling &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will return an object with two attributes, &lt;code&gt;integers&lt;/code&gt; and &lt;code&gt;accumulate&lt;/code&gt;. The &lt;code&gt;integers&lt;/code&gt; attribute will be a list of one or more ints, and the &lt;code&gt;accumulate&lt;/code&gt; attribute will be either the &lt;a href=&quot;functions#sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; function, if &lt;code&gt;--sum&lt;/code&gt; was specified at the command line, or the &lt;a href=&quot;functions#max&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt; function if it was not.</source>
          <target state="translated">나중에 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 &lt;code&gt;integers&lt;/code&gt; 와 &lt;code&gt;accumulate&lt;/code&gt; 이라는 두 가지 속성을 가진 객체가 반환됩니다 . &lt;code&gt;integers&lt;/code&gt; 특성은 하나 개 이상의 INT의리스트 될 것이며, &lt;code&gt;accumulate&lt;/code&gt; 특성은 어느 것 &lt;a href=&quot;functions#sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; 경우, 함수 &lt;code&gt;--sum&lt;/code&gt; 는 명령 줄에 지정되거나 하였다 &lt;a href=&quot;functions#max&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt; 가 아니었다면 기능.</target>
        </trans-unit>
        <trans-unit id="220d5efc8654e9aa0bf6695beee6bfe664735911" translate="yes" xml:space="preserve">
          <source>Latin-1 encoding with &lt;code&gt;\uXXXX&lt;/code&gt; and &lt;code&gt;\UXXXXXXXX&lt;/code&gt; for other code points. Existing backslashes are not escaped in any way. It is used in the Python pickle protocol.</source>
          <target state="translated">다른 코드 포인트의 경우 &lt;code&gt;\uXXXX&lt;/code&gt; 및 &lt;code&gt;\UXXXXXXXX&lt;/code&gt; 를 사용한 라틴 -1 인코딩 기존 백 슬래시는 어떤 방식으로도 이스케이프되지 않습니다. 파이썬 피클 프로토콜에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="28e6f54e33a1151bfd4c7cc4affd14df3525f2db" translate="yes" xml:space="preserve">
          <source>Layouts</source>
          <target state="translated">Layouts</target>
        </trans-unit>
        <trans-unit id="5304207bb67ab38f044a44e136564dadeaba0897" translate="yes" xml:space="preserve">
          <source>Leave cbreak mode. Return to normal &amp;ldquo;cooked&amp;rdquo; mode with line buffering.</source>
          <target state="translated">파단 모드를 종료합니다. 라인 버퍼링을 사용하여 일반 &quot;요리&quot;모드로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9b35aee8d3da8fd183e13a370b032dec769e9344" translate="yes" xml:space="preserve">
          <source>Leave echo mode. Echoing of input characters is turned off.</source>
          <target state="translated">에코 모드를 종료하십시오. 입력 문자 반향이 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="f604f6318f737fd0cd2341f0f6cdfab969737efb" translate="yes" xml:space="preserve">
          <source>Leave newline mode. Disable translation of return into newline on input, and disable low-level translation of newline into newline/return on output (but this does not change the behavior of &lt;code&gt;addch('\n')&lt;/code&gt;, which always does the equivalent of return and line feed on the virtual screen). With translation off, curses can sometimes speed up vertical motion a little; also, it will be able to detect the return key on input.</source>
          <target state="translated">줄 바꿈 모드를 종료하십시오. 입력시 줄 바꿈으로의 변환 번역을 비활성화하고 출력에서 ​​줄 바꿈 / 줄 바꿈으로의 줄 바꿈 변환을 비활성화합니다 (그러나 이것은 항상 리턴 및 줄 바꿈과 동일한 &lt;code&gt;addch('\n')&lt;/code&gt; 의 동작을 변경하지는 않습니다. 가상 화면에서). 번역이 꺼져 있으면 저주로 인해 세로 동작이 약간 빨라질 수 있습니다. 또한 입력시 리턴 키를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df80f393f0c1283bf1c2011a3966c84e42251e69" translate="yes" xml:space="preserve">
          <source>Leave raw mode. Return to normal &amp;ldquo;cooked&amp;rdquo; mode with line buffering.</source>
          <target state="translated">원시 모드를 그대로 둡니다. 라인 버퍼링을 사용하여 일반 &quot;요리&quot;모드로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="494064e70529e54389ad678d759801779c5c72df" translate="yes" xml:space="preserve">
          <source>Left Shift</source>
          <target state="translated">왼쪽 시프트</target>
        </trans-unit>
        <trans-unit id="fa2ddfd65f207446dfb5c03f954efaeb99e51fad" translate="yes" xml:space="preserve">
          <source>Left highlight</source>
          <target state="translated">왼쪽 하이라이트</target>
        </trans-unit>
        <trans-unit id="7459e2ff70b4a74b12b3b42dcc8898f1325c4607" translate="yes" xml:space="preserve">
          <source>Left side</source>
          <target state="translated">왼쪽</target>
        </trans-unit>
        <trans-unit id="4f21b710206cb813c042db5adab0dd62ed395300" translate="yes" xml:space="preserve">
          <source>Left-arrow</source>
          <target state="translated">Left-arrow</target>
        </trans-unit>
        <trans-unit id="fe4e2dded8cbb24225a5077d86ac26e1a4e77daa" translate="yes" xml:space="preserve">
          <source>Legacy API Examples</source>
          <target state="translated">레거시 API 예제</target>
        </trans-unit>
        <trans-unit id="f9e9858ae5963ad7d5dac67bab79e2781ada4b1d" translate="yes" xml:space="preserve">
          <source>Legacy API:</source>
          <target state="translated">레거시 API :</target>
        </trans-unit>
        <trans-unit id="e874dde2b7bd15782fc71bda63adbb0435cd8ff4" translate="yes" xml:space="preserve">
          <source>Legacy Shell Invocation Functions</source>
          <target state="translated">레거시 쉘 호출 함수</target>
        </trans-unit>
        <trans-unit id="97830814b9202ba41e9b45589de2504e635919fe" translate="yes" xml:space="preserve">
          <source>Legacy interface</source>
          <target state="translated">레거시 인터페이스</target>
        </trans-unit>
        <trans-unit id="f3f33501b9f5989df40734cc741026886ffb8ebc" translate="yes" xml:space="preserve">
          <source>Legacy variant of the &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt;. It has interpolation disabled by default and allows for non-string section names, option names, and values via its unsafe &lt;code&gt;add_section&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; methods, as well as the legacy &lt;code&gt;defaults=&lt;/code&gt; keyword argument handling.</source>
          <target state="translated">의 레거시 변형 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; &lt;/a&gt; . 보간법은 기본적으로 비활성화되어 있으며 안전하지 않은 &lt;code&gt;add_section&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 메소드 를 통해 문자열이 아닌 섹션 이름, 옵션 이름 및 값 과 레거시 &lt;code&gt;defaults=&lt;/code&gt; 키워드 인수 처리를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="66133ee14edcb4e3bbb34ddd9f2cd0c81d9a82cf" translate="yes" xml:space="preserve">
          <source>Legal values are points of the compass: &lt;code&gt;&quot;n&quot;&lt;/code&gt;, &lt;code&gt;&quot;ne&quot;&lt;/code&gt;, &lt;code&gt;&quot;e&quot;&lt;/code&gt;, &lt;code&gt;&quot;se&quot;&lt;/code&gt;, &lt;code&gt;&quot;s&quot;&lt;/code&gt;, &lt;code&gt;&quot;sw&quot;&lt;/code&gt;, &lt;code&gt;&quot;w&quot;&lt;/code&gt;, &lt;code&gt;&quot;nw&quot;&lt;/code&gt;, and also &lt;code&gt;&quot;center&quot;&lt;/code&gt;.</source>
          <target state="translated">올바른 값은 나침반의 포인트입니다 : &lt;code&gt;&quot;n&quot;&lt;/code&gt; , &lt;code&gt;&quot;ne&quot;&lt;/code&gt; , &lt;code&gt;&quot;e&quot;&lt;/code&gt; , &lt;code&gt;&quot;se&quot;&lt;/code&gt; , &lt;code&gt;&quot;s&quot;&lt;/code&gt; , &lt;code&gt;&quot;sw&quot;&lt;/code&gt; , &lt;code&gt;&quot;w&quot;&lt;/code&gt; , &lt;code&gt;&quot;nw&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;center&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="905f604fb13f295392bda39869104e2dd79e9fb2" translate="yes" xml:space="preserve">
          <source>Legal values are the strings: &lt;code&gt;&quot;left&quot;&lt;/code&gt;, &lt;code&gt;&quot;center&quot;&lt;/code&gt;, &lt;code&gt;&quot;right&quot;&lt;/code&gt;, and &lt;code&gt;&quot;fill&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;right&quot;&lt;/code&gt; 값은 &lt;code&gt;&quot;left&quot;&lt;/code&gt; , &lt;code&gt;&quot;center&quot;&lt;/code&gt; , &quot;right&quot; 및 &lt;code&gt;&quot;fill&quot;&lt;/code&gt; 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="eb67484bf01ce5ec849415f285da75abc22265be" translate="yes" xml:space="preserve">
          <source>Legal values are: &lt;code&gt;'left'&lt;/code&gt;, &lt;code&gt;'right'&lt;/code&gt;, &lt;code&gt;'top'&lt;/code&gt;, &lt;code&gt;'bottom'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'right'&lt;/code&gt; 값은 &lt;code&gt;'left'&lt;/code&gt; , 'right' , &lt;code&gt;'top'&lt;/code&gt; , &lt;code&gt;'bottom'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18beaa17df62904395685f10cb89a3d8e9391154" translate="yes" xml:space="preserve">
          <source>Legal values: &lt;code&gt;'x'&lt;/code&gt;, &lt;code&gt;'y'&lt;/code&gt;, &lt;code&gt;'both'&lt;/code&gt;, &lt;code&gt;'none'&lt;/code&gt;.</source>
          <target state="translated">유효한 값 : &lt;code&gt;'x'&lt;/code&gt; , &lt;code&gt;'y'&lt;/code&gt; , &lt;code&gt;'both'&lt;/code&gt; , &lt;code&gt;'none'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="d45a6f38f95efbaf3f9f3b999e990d1c6f2db236" translate="yes" xml:space="preserve">
          <source>Length modifier (optional).</source>
          <target state="translated">길이 수정 자 (선택 사항).</target>
        </trans-unit>
        <trans-unit id="180a1018d9273fb3a58e3f201de1ac8a5b80b58d" translate="yes" xml:space="preserve">
          <source>Length of the network prefix, in bits.</source>
          <target state="translated">네트워크 접두사의 길이 (비트)입니다.</target>
        </trans-unit>
        <trans-unit id="2c777c5db20151b1efdf932bcbcfebad8c2efc68" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume we initialize a table as in the example given above:</source>
          <target state="translated">위에서 주어진 예제에서와 같이 테이블을 초기화한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="6b2e260007a1afb18b8a8c65668c11667d2da6f9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back to the &lt;code&gt;Point&lt;/code&gt; class. We stored the x and y coordinates separated via semicolons as strings in SQLite.</source>
          <target state="translated">&lt;code&gt;Point&lt;/code&gt; 클래스 로 돌아 갑시다 . 세미콜론을 통해 분리 된 x 및 y 좌표를 SQLite에서 문자열로 저장했습니다.</target>
        </trans-unit>
        <trans-unit id="cbaa1370b8e486f03058ade144aaa5ce766835fc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the above example and run two &lt;code&gt;say_after&lt;/code&gt; coroutines &lt;em&gt;concurrently&lt;/em&gt;:</source>
          <target state="translated">위의 예제를 수정하고 두 개의 &lt;code&gt;say_after&lt;/code&gt; 코 루틴을 &lt;em&gt;동시에&lt;/em&gt; 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a4e1bbd9caa78a7f8e196d6165ef1a43653ca2ce" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we want to add one to each country&amp;rsquo;s rank, and add an &lt;code&gt;updated&lt;/code&gt; attribute to the rank element:</source>
          <target state="translated">각 국가의 순위에 하나씩 추가하고 &lt;code&gt;updated&lt;/code&gt; 속성을 순위 요소 에 추가한다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="78596e300b339fafdb3e77e4a728b5374ceee9c7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you wanted to get the version string for a package you&amp;rsquo;ve installed using &lt;code&gt;pip&lt;/code&gt;. We start by creating a virtual environment and installing something into it:</source>
          <target state="translated">&lt;code&gt;pip&lt;/code&gt; 를 사용하여 설치 한 패키지의 버전 문자열을 원한다고 가정 해 봅시다 . 우리는 가상 환경을 만들고 무언가를 설치하는 것으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d5ae7ea3899f66437fb7e1aa7d7675f030894483" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say your module is called &amp;ldquo;spam&amp;rdquo; and the module&amp;rsquo;s various natural language translation &lt;code&gt;.mo&lt;/code&gt; files reside in &lt;code&gt;/usr/share/locale&lt;/code&gt; in GNU &lt;strong&gt;gettext&lt;/strong&gt; format. Here&amp;rsquo;s what you would put at the top of your module:</source>
          <target state="translated">모듈이 &quot;스팸&quot;이고 모듈의 다양한 자연 언어 변환 &lt;code&gt;.mo&lt;/code&gt; 파일이 &lt;code&gt;/usr/share/locale&lt;/code&gt; 에 GNU &lt;strong&gt;gettext&lt;/strong&gt; 형식으로 존재 한다고 가정 해 봅시다 . 다음은 모듈 맨 위에 놓을 내용입니다.</target>
        </trans-unit>
        <trans-unit id="04863fa8b8b6c7cb4b82a58c35cc416cac590f6a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a very basic configuration file that looks like this:</source>
          <target state="translated">다음과 같은 매우 기본적인 구성 파일을 보자.</target>
        </trans-unit>
        <trans-unit id="5ecd68b4c43876be669cbe3592b08b9f4742b506" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try it. We create two instances of &lt;code&gt;cell&lt;/code&gt;, and let them point to each other, and finally follow the pointer chain a few times:</source>
          <target state="translated">해 봅시다. &lt;code&gt;cell&lt;/code&gt; 의 두 인스턴스를 만들고 서로 가리 키도록하고 마지막으로 몇 번 포인터 체인을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="22165bce4fbe52f349dc3381930ba2ac63b3a5cb" translate="yes" xml:space="preserve">
          <source>Letting your object adapt itself</source>
          <target state="translated">객체가 스스로 적응하도록</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="6460ec4ddfef711100217c8f9826fd70701f2f56" translate="yes" xml:space="preserve">
          <source>Level 2 halted</source>
          <target state="translated">정지 된 레벨 2</target>
        </trans-unit>
        <trans-unit id="60e40c81795763b2a8e72d44e5ad0f9199edc4bb" translate="yes" xml:space="preserve">
          <source>Level 2 not synchronized</source>
          <target state="translated">레벨 2 동기화되지 않음</target>
        </trans-unit>
        <trans-unit id="345040e0c10ed0376f2b7122fc4d53bc220369de" translate="yes" xml:space="preserve">
          <source>Level 3 halted</source>
          <target state="translated">정지 된 레벨 3</target>
        </trans-unit>
        <trans-unit id="d42164449cc05890457a5e7c44effb895c6def14" translate="yes" xml:space="preserve">
          <source>Level 3 reset</source>
          <target state="translated">레벨 3 리셋</target>
        </trans-unit>
        <trans-unit id="d7e796b80646b51566de3ce1d4e141f4e53a4ec8" translate="yes" xml:space="preserve">
          <source>Levels are internally integers (as they need to be compared in the logging logic). This function is used to convert between an integer level and the level name displayed in the formatted log output by means of the &lt;code&gt;%(levelname)s&lt;/code&gt; format specifier (see &lt;a href=&quot;#logrecord-attributes&quot;&gt;LogRecord attributes&lt;/a&gt;).</source>
          <target state="translated">레벨은 내부적으로 정수입니다 (로깅 논리에서 비교해야 함). 이 함수는 &lt;code&gt;%(levelname)s&lt;/code&gt; 형식 지정자 를 사용하여 형식화 된 로그 출력에 표시되는 정수 레벨과 레벨 이름 사이를 변환하는 데 사용됩니다 ( &lt;a href=&quot;#logrecord-attributes&quot;&gt;LogRecord 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2d6380feb8c38ce90806082088bb8c2c55e37b83" translate="yes" xml:space="preserve">
          <source>Lexical scanner for Python source code.</source>
          <target state="translated">Python 소스 코드 용 어휘 스캐너.</target>
        </trans-unit>
        <trans-unit id="392b455093b9fc95f72712c44846e250fe613928" translate="yes" xml:space="preserve">
          <source>LibreSSL &amp;gt;= 2.6.1 no longer supports NPN. The methods &lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt;&lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLSocket.selected_npn_protocol&quot;&gt;&lt;code&gt;SSLSocket.selected_npn_protocol()&lt;/code&gt;&lt;/a&gt; are not available.</source>
          <target state="translated">LibreSSL&amp;gt; = 2.6.1은 더 이상 NPN을 지원하지 않습니다. &lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt; &lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLSocket.selected_npn_protocol&quot;&gt; &lt;code&gt;SSLSocket.selected_npn_protocol()&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="091cd70ef41f8240bd7c6a2fadb08e949b8160af" translate="yes" xml:space="preserve">
          <source>LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for LibreSSL. Some features are not available when the ssl module is compiled with LibreSSL.</source>
          <target state="translated">LibreSSL은 OpenSSL 1.0.1의 포크입니다. ssl 모듈은 LibreSSL을 제한적으로 지원합니다. ssl 모듈이 LibreSSL로 컴파일 된 경우 일부 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8509e2f82d3801c911e6a35b8391debf72767e0a" translate="yes" xml:space="preserve">
          <source>LibreSSL support</source>
          <target state="translated">LibreSSL 지원</target>
        </trans-unit>
        <trans-unit id="d0454f8c64fa3e4e75abdf2e0c77b01474c4f39a" translate="yes" xml:space="preserve">
          <source>Licensed under the PSF License.</source>
          <target state="translated">PSF 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="033df3d297c22e077f87acc4e5b0f910192e40c2" translate="yes" xml:space="preserve">
          <source>Lifecycle</source>
          <target state="translated">Lifecycle</target>
        </trans-unit>
        <trans-unit id="b7f9700444d85258af9741b1a784bb114500ccb1" translate="yes" xml:space="preserve">
          <source>Lifts second and third stack item one position up, moves top down to position three.</source>
          <target state="translated">두 번째 및 세 번째 스택 항목을 한 위치 위로 들어 올리고 위에서 아래로 3 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="128b57bf19d7494cf2406f4c9ad03a774a89db95" translate="yes" xml:space="preserve">
          <source>Lifts second, third and forth stack items one position up, moves top down to position four.</source>
          <target state="translated">두 번째, 세 번째 및 네 번째 스택 항목을 한 위치 위로 들어 올리고 위에서 아래로 4 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="769c851ff34e416533a93e1c54c044431fc336ec" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#aifc.aifc.writeframes&quot;&gt;&lt;code&gt;writeframes()&lt;/code&gt;&lt;/a&gt;, except that the header of the audio file is not updated.</source>
          <target state="translated">오디오 파일의 헤더가 업데이트되지 않는다는 점을 제외하고 &lt;a href=&quot;#aifc.aifc.writeframes&quot;&gt; &lt;code&gt;writeframes()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5fba8ee1e116abbedfbf12ff32b815bda67a39bf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#bytes.find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt;, but raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when the subsequence is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#bytes.find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 하지만, 인상 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 서브 순서가 발견되지 않을 때.</target>
        </trans-unit>
        <trans-unit id="18e9f70e3e0c024db75f15d3f7632da5d6ffb708" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#bytes.rfind&quot;&gt;&lt;code&gt;rfind()&lt;/code&gt;&lt;/a&gt; but raises &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when the subsequence &lt;em&gt;sub&lt;/em&gt; is not found.</source>
          <target state="translated">&lt;a href=&quot;#bytes.rfind&quot;&gt; &lt;code&gt;rfind()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 &lt;em&gt;하위&lt;/em&gt; 시퀀스 &lt;em&gt;하위&lt;/em&gt; 를 찾을 수 없으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가&lt;/a&gt; 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ed4630498d706bd9a3292cd5d7227b98132b4ad" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#curses.window.erase&quot;&gt;&lt;code&gt;erase()&lt;/code&gt;&lt;/a&gt;, but also cause the whole window to be repainted upon next call to &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#curses.window.erase&quot;&gt; &lt;code&gt;erase()&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 전체 창에 다음 호출에 다시 그려되도록 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b526a2ea540c4c9b052eb050e52db56633e28e9c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s verbosity can be set with the &lt;code&gt;-v&lt;/code&gt; command-line switch or with the optional keyword argument &lt;em&gt;verbose&lt;/em&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 의 상세는 설정할 수 있습니다 &lt;code&gt;-v&lt;/code&gt; 명령 줄 스위치 또는 선택적 키워드 인수와 함께 &lt;em&gt;자세한&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c342450b7fbacddc0eb255ffe6a69e6f64b16e54" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt;, if a combination of &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; members results in no flags being set, the boolean evaluation is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 와 같이 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 멤버 조합으로 플래그가 설정되지 않으면 부울 평가는 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a363ed4c02cbe749a71b8d13e6dc4264d840b400" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt;, but returns a tuple of the data connection and the expected size of the data. If the expected size could not be computed, &lt;code&gt;None&lt;/code&gt; will be returned as the expected size. &lt;em&gt;cmd&lt;/em&gt; and &lt;em&gt;rest&lt;/em&gt; means the same thing as in &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 데이터 연결의 튜플과 데이터의 예상 크기를 반환합니다. 예상 크기를 계산할 수 없으면 예상 크기로 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. &lt;em&gt;cmd&lt;/em&gt; 및 &lt;em&gt;rest&lt;/em&gt; 는 &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 와 동일한 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="fed2080b9205761ae5ca1cb77a5a3913089b3943" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#gettext.gettext&quot;&gt;&lt;code&gt;gettext()&lt;/code&gt;&lt;/a&gt;, but consider plural forms. If a translation is found, apply the plural formula to &lt;em&gt;n&lt;/em&gt;, and return the resulting message (some languages have more than two plural forms). If no translation is found, return &lt;em&gt;singular&lt;/em&gt; if &lt;em&gt;n&lt;/em&gt; is 1; return &lt;em&gt;plural&lt;/em&gt; otherwise.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#gettext.gettext&quot;&gt; &lt;code&gt;gettext()&lt;/code&gt; &lt;/a&gt; 하지만, 복수 형태를 고려한다. 번역이 발견되면 복수 수식을 &lt;em&gt;n에&lt;/em&gt; 적용하고 결과 메시지를 반환합니다 (일부 언어는 복수형이 두 개 이상임). 변환이 없으면 &lt;em&gt;n&lt;/em&gt; 이 1 이면 &lt;em&gt;특이&lt;/em&gt; 값을 반환합니다 . 반환 &lt;em&gt;복수&lt;/em&gt; 그렇지.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58099ee55f530af16bd98fd8c56efead48c30f96" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#gettext.gettext&quot;&gt;&lt;code&gt;gettext()&lt;/code&gt;&lt;/a&gt;, but look the message up in the specified &lt;em&gt;domain&lt;/em&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#gettext.gettext&quot;&gt; &lt;code&gt;gettext()&lt;/code&gt; &lt;/a&gt; 하지만, 지정된에서 메시지를 검색 &lt;em&gt;도메인&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc1846db165a1893d5de2a35351debcae960593" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#gettext.ngettext&quot;&gt;&lt;code&gt;ngettext()&lt;/code&gt;&lt;/a&gt;, but look the message up in the specified &lt;em&gt;domain&lt;/em&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#gettext.ngettext&quot;&gt; &lt;code&gt;ngettext()&lt;/code&gt; &lt;/a&gt; 하지만, 지정된에서 메시지를 검색 &lt;em&gt;도메인&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="68113eaaf87f00b3b1aab0ac0cfe07087577d9b5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#hashlib.hash.digest&quot;&gt;&lt;code&gt;digest()&lt;/code&gt;&lt;/a&gt; except the digest is returned as a string object of double length, containing only hexadecimal digits. This may be used to exchange the value safely in email or other non-binary environments.</source>
          <target state="translated">다이제스트는 16 진수 문자열 만 포함하는 두 배 길이의 문자열 객체로 반환되는 것을 제외하고 &lt;a href=&quot;#hashlib.hash.digest&quot;&gt; &lt;code&gt;digest()&lt;/code&gt; &lt;/a&gt; 와 유사 합니다. 전자 메일 또는 기타 이진이 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6c8b81ebf600e9993da2ea7be87e2a91a7b9a0b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#hashlib.shake.digest&quot;&gt;&lt;code&gt;digest()&lt;/code&gt;&lt;/a&gt; except the digest is returned as a string object of double length, containing only hexadecimal digits. This may be used to exchange the value safely in email or other non-binary environments.</source>
          <target state="translated">다이제스트는 16 진수 문자열 만 포함하는 두 배 길이의 문자열 객체로 반환되는 것을 제외하고 &lt;a href=&quot;#hashlib.shake.digest&quot;&gt; &lt;code&gt;digest()&lt;/code&gt; &lt;/a&gt; 와 유사 합니다. 전자 메일 또는 기타 이진이 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="459945a9891e20c8dab70ede4f27fdf482e29c75" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#hmac.digest&quot;&gt;&lt;code&gt;digest()&lt;/code&gt;&lt;/a&gt; except the digest is returned as a string twice the length containing only hexadecimal digits. This may be used to exchange the value safely in email or other non-binary environments.</source>
          <target state="translated">&lt;a href=&quot;#hmac.digest&quot;&gt; &lt;code&gt;digest()&lt;/code&gt; &lt;/a&gt; 와 같이 digest 는 16 진수 만 포함하는 길이의 두 배인 문자열로 리턴됩니다. 전자 메일 또는 기타 이진이 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34ceda7fd93b02c772dcafa4d07c2be2558ca4c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;, multiple reads may be issued to the underlying raw stream, unless the latter is interactive.</source>
          <target state="translated">&lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 , 기본 스트림이 대화식이 아닌 한 여러 개의 읽기가 기본 원시 스트림에 발행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6711f9956856aade671cd7cf16a76fd76e19023" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pathlib.Path.chmod&quot;&gt;&lt;code&gt;Path.chmod()&lt;/code&gt;&lt;/a&gt; but, if the path points to a symbolic link, the symbolic link&amp;rsquo;s mode is changed rather than its target&amp;rsquo;s.</source>
          <target state="translated">&lt;a href=&quot;#pathlib.Path.chmod&quot;&gt; &lt;code&gt;Path.chmod()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 경로가 심볼릭 링크를 가리키는 경우 심볼릭 링크의 모드가 대상이 아닌 모드로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c80f0d44ded10dcee28c34bbfff9e27a30074634" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pathlib.Path.stat&quot;&gt;&lt;code&gt;Path.stat()&lt;/code&gt;&lt;/a&gt; but, if the path points to a symbolic link, return the symbolic link&amp;rsquo;s information rather than its target&amp;rsquo;s.</source>
          <target state="translated">&lt;a href=&quot;#pathlib.Path.stat&quot;&gt; &lt;code&gt;Path.stat()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 경로가 심볼릭 링크를 가리키는 경우 대상이 아닌 심볼릭 링크의 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76a03d0f714bbde9a8aae83d5eb4974b1956cc4b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#py_compile.PycInvalidationMode.CHECKED_HASH&quot;&gt;&lt;code&gt;CHECKED_HASH&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;.pyc&lt;/code&gt; file includes a hash of the source file content. However, Python will at runtime assume the &lt;code&gt;.pyc&lt;/code&gt; file is up to date and not validate the &lt;code&gt;.pyc&lt;/code&gt; against the source file at all.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#py_compile.PycInvalidationMode.CHECKED_HASH&quot;&gt; &lt;code&gt;CHECKED_HASH&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;.pyc&lt;/code&gt; 파일은 소스 파일 내용의 해시를 포함한다. 그러나 파이썬은 런타임에 &lt;code&gt;.pyc&lt;/code&gt; 파일이 최신 상태 라고 가정 하고 소스 파일에 대해 &lt;code&gt;.pyc&lt;/code&gt; 의 유효성을 전혀 검사하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a425706908190a3e1f79c502de35dede3098f552" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#quopri.decode&quot;&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/a&gt;, except that it accepts a source &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and returns the corresponding decoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#quopri.decode&quot;&gt; &lt;code&gt;decode()&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 소스 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 받아들이고 해당 디코딩 된 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 반환 한다는 점이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="54098cdee562ba9f230b42f10f40d70cf45edbf7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#quopri.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt;, except that it accepts a source &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and returns the corresponding encoded &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. By default, it sends a &lt;code&gt;False&lt;/code&gt; value to &lt;em&gt;quotetabs&lt;/em&gt; parameter of the &lt;a href=&quot;#quopri.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#quopri.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 소스 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 받아들이고 해당 인코딩 된 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 반환 한다는 점이 다릅니다 . 기본적으로 &lt;a href=&quot;#quopri.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; 함수 의 &lt;em&gt;quotetabs&lt;/em&gt; 매개 변수에 &lt;code&gt;False&lt;/code&gt; 값을 보냅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b01d2bf404c98230b8ffd33055a42cf110e8594d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#signal.sigwaitinfo&quot;&gt;&lt;code&gt;sigwaitinfo()&lt;/code&gt;&lt;/a&gt;, but takes an additional &lt;em&gt;timeout&lt;/em&gt; argument specifying a timeout. If &lt;em&gt;timeout&lt;/em&gt; is specified as &lt;code&gt;0&lt;/code&gt;, a poll is performed. Returns &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if a timeout occurs.</source>
          <target state="translated">&lt;a href=&quot;#signal.sigwaitinfo&quot;&gt; &lt;code&gt;sigwaitinfo()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 &lt;em&gt;시간 초과를&lt;/em&gt; 지정 하는 추가 &lt;em&gt;시간 초과&lt;/em&gt; 인수를 사용합니다. &lt;em&gt;시간 종료&lt;/em&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 지정 되면 폴링이 수행됩니다. 시간 초과가 발생하면 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9b428dc227aecdac34a941af1b4c9e314010ceaa" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt;&lt;code&gt;SSLContext.maximum_version&lt;/code&gt;&lt;/a&gt; except it is the lowest supported version or &lt;a href=&quot;#ssl.TLSVersion.MINIMUM_SUPPORTED&quot;&gt;&lt;code&gt;TLSVersion.MINIMUM_SUPPORTED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 낮은 지원 버전 또는 &lt;a href=&quot;#ssl.TLSVersion.MINIMUM_SUPPORTED&quot;&gt; &lt;code&gt;TLSVersion.MINIMUM_SUPPORTED&lt;/code&gt; 를&lt;/a&gt; 제외하고 &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt; &lt;code&gt;SSLContext.maximum_version&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="034005e547ceeaab4b84301bb039ff5010f896a4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#str.find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt;, but raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when the substring is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#str.find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 하지만, 인상 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 문자열이 발견되지 않을 때.</target>
        </trans-unit>
        <trans-unit id="fffbdca90984707f8b141e5ee4a5c9e6f40bdf60" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#str.rfind&quot;&gt;&lt;code&gt;rfind()&lt;/code&gt;&lt;/a&gt; but raises &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when the substring &lt;em&gt;sub&lt;/em&gt; is not found.</source>
          <target state="translated">&lt;a href=&quot;#str.rfind&quot;&gt; &lt;code&gt;rfind()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 하위 문자열 &lt;em&gt;하위&lt;/em&gt; 를 찾을 수 없으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가&lt;/a&gt; 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2116b8fb57e3a35c142acd106bb28c5cbe992968" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#string.Template.substitute&quot;&gt;&lt;code&gt;substitute()&lt;/code&gt;&lt;/a&gt;, except that if placeholders are missing from &lt;em&gt;mapping&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt;, instead of raising a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception, the original placeholder will appear in the resulting string intact. Also, unlike with &lt;a href=&quot;#string.Template.substitute&quot;&gt;&lt;code&gt;substitute()&lt;/code&gt;&lt;/a&gt;, any other appearances of the &lt;code&gt;$&lt;/code&gt; will simply return &lt;code&gt;$&lt;/code&gt; instead of raising &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#string.Template.substitute&quot;&gt; &lt;code&gt;substitute()&lt;/code&gt; &lt;/a&gt; , 자리가 누락 된 경우를 제외 &lt;em&gt;매핑&lt;/em&gt; 및 &lt;em&gt;kwds&lt;/em&gt; , 대신에 제기 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 예외를 원래 자리 그대로 결과 문자열에 표시됩니다. 또한 &lt;a href=&quot;#string.Template.substitute&quot;&gt; &lt;code&gt;substitute()&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;$&lt;/code&gt; 의 다른 모양은 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 를 발생시키는 대신 &lt;code&gt;$&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ff608d7698e75a8850f2bbedb753f4de4a82170d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#subprocess.getstatusoutput&quot;&gt;&lt;code&gt;getstatusoutput()&lt;/code&gt;&lt;/a&gt;, except the exit code is ignored and the return value is a string containing the command&amp;rsquo;s output. Example:</source>
          <target state="translated">&lt;a href=&quot;#subprocess.getstatusoutput&quot;&gt; &lt;code&gt;getstatusoutput()&lt;/code&gt; &lt;/a&gt; 처럼 , 종료 코드를 무시하고 반환 값이 명령의 출력을 포함하는 문자열입니다 제외. 예:</target>
        </trans-unit>
        <trans-unit id="09325b0b81777f3949622af36b1caae2105c533a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt; but converts to local time. If &lt;em&gt;secs&lt;/em&gt; is not provided or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the current time as returned by &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; is used. The dst flag is set to &lt;code&gt;1&lt;/code&gt; when DST applies to the given time.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; 현지 시간으로 만 변환합니다. 경우 &lt;em&gt;초이&lt;/em&gt; 제공되지 않거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 반환 된 현재 시간 &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 사용되지 않는다. DST가 지정된 시간에 적용되면 dst 플래그는 &lt;code&gt;1&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="e80bfe37b04d21e1316c6e6f6ac9868e0d1c6f93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#tokenize.tokenize&quot;&gt;&lt;code&gt;tokenize()&lt;/code&gt;&lt;/a&gt;, the &lt;em&gt;readline&lt;/em&gt; argument is a callable returning a single line of input. However, &lt;a href=&quot;#tokenize.generate_tokens&quot;&gt;&lt;code&gt;generate_tokens()&lt;/code&gt;&lt;/a&gt; expects &lt;em&gt;readline&lt;/em&gt; to return a str object rather than bytes.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#tokenize.tokenize&quot;&gt; &lt;code&gt;tokenize()&lt;/code&gt; &lt;/a&gt; 상기 &lt;em&gt;의 readline&lt;/em&gt; 인수가 입력 한 선을 반환하는 호출이다. 그러나 &lt;a href=&quot;#tokenize.generate_tokens&quot;&gt; &lt;code&gt;generate_tokens()&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;readline&lt;/em&gt; 이 바이트가 아닌 str 객체를 반환 할 것으로 예상 합니다.</target>
        </trans-unit>
        <trans-unit id="1e25dc1f7a41401d6d2742977c0ec0eb4a4dab04" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt; but also tests that &lt;em&gt;regex&lt;/em&gt; matches on the string representation of the raised exception. &lt;em&gt;regex&lt;/em&gt; may be a regular expression object or a string containing a regular expression suitable for use by &lt;a href=&quot;re#re.search&quot;&gt;&lt;code&gt;re.search()&lt;/code&gt;&lt;/a&gt;. Examples:</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 &lt;em&gt;정규 표현식&lt;/em&gt; 이 발생한 예외의 문자열 표현과 일치 하는지 테스트합니다 . &lt;em&gt;정규식&lt;/em&gt; 은 정규 표현식 객체이거나 &lt;a href=&quot;re#re.search&quot;&gt; &lt;code&gt;re.search()&lt;/code&gt; &lt;/a&gt; 에서 사용하기에 적합한 정규 표현식을 포함하는 문자열 일 수 있습니다. . 예 :</target>
        </trans-unit>
        <trans-unit id="88c91522876cdaf737cb13dc3682f59d6bfc40fe" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt;&lt;code&gt;assertWarns()&lt;/code&gt;&lt;/a&gt; but also tests that &lt;em&gt;regex&lt;/em&gt; matches on the message of the triggered warning. &lt;em&gt;regex&lt;/em&gt; may be a regular expression object or a string containing a regular expression suitable for use by &lt;a href=&quot;re#re.search&quot;&gt;&lt;code&gt;re.search()&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt; &lt;code&gt;assertWarns()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 트리거 된 경고 메시지에서 &lt;em&gt;정규식이&lt;/em&gt; 일치 하는지 테스트합니다 . &lt;em&gt;정규식&lt;/em&gt; 정규식 객체 또는하여 사용하기에 적합한 정규 표현이 포함 된 문자열 일 수있다 &lt;a href=&quot;re#re.search&quot;&gt; &lt;code&gt;re.search()&lt;/code&gt; &lt;/a&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="71a6e3160e25bc7af2abbb4914c6e0c300c2d496" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#urllib.parse.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;, but accepts a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object rather than a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, and does not perform string-to-bytes encoding.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#urllib.parse.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt; 하지만, 받아 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; (A)보다 오히려 객체 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 을&lt;/a&gt; 하고, 문자열에이 - 바이트 인코딩 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33be7d39b7d017d814cc31038c4a163e3894971c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#urllib.parse.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;, but also replace spaces by plus signs, as required for quoting HTML form values when building up a query string to go into a URL. Plus signs in the original string are escaped unless they are included in &lt;em&gt;safe&lt;/em&gt;. It also does not have &lt;em&gt;safe&lt;/em&gt; default to &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#urllib.parse.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 URL로 이동하기 위해 쿼리 문자열을 작성할 때 HTML 양식 값을 인용하는 데 필요한대로 공백을 더하기 부호로 바꿉니다. &lt;em&gt;안전에&lt;/em&gt; 포함되어 있지 않으면 원래 문자열의 더하기 부호가 이스케이프됩니다 . 또한 &lt;em&gt;안전한&lt;/em&gt; 기본값은 &lt;code&gt;'/'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="775c6c98d7b915a29eecf32e7d3a27905fc4598c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#urllib.parse.unquote&quot;&gt;&lt;code&gt;unquote()&lt;/code&gt;&lt;/a&gt;, but also replace plus signs by spaces, as required for unquoting HTML form values.</source>
          <target state="translated">&lt;a href=&quot;#urllib.parse.unquote&quot;&gt; &lt;code&gt;unquote()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 HTML 양식 값의 인용을 해제하는 데 필요한 경우 더하기 부호를 공백으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="f1cf5e7750804a8602426bc1702f1b0873f828cb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asynchat.async_chat&quot;&gt;&lt;code&gt;async_chat&lt;/code&gt;&lt;/a&gt; defines a set of events that are generated by an analysis of socket conditions after a &lt;code&gt;select()&lt;/code&gt; call. Once the polling loop has been started the &lt;a href=&quot;#asynchat.async_chat&quot;&gt;&lt;code&gt;async_chat&lt;/code&gt;&lt;/a&gt; object&amp;rsquo;s methods are called by the event-processing framework with no action on the part of the programmer.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;asyncore#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asynchat.async_chat&quot;&gt; &lt;code&gt;async_chat&lt;/code&gt; 는&lt;/a&gt; 후 소켓 조건의 분석에 의해 생성되는 이벤트 집합 정의 &lt;code&gt;select()&lt;/code&gt; 호출. 폴링 루프가 시작되면 &lt;a href=&quot;#asynchat.async_chat&quot;&gt; &lt;code&gt;async_chat&lt;/code&gt; &lt;/a&gt; 오브젝트의 메소드는 프로그래머 측의 조치없이 이벤트 처리 프레임 워크에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ccba539e91e292f5838b503000ab1e741be5ca28" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; except that the elements of the &lt;em&gt;iterable&lt;/em&gt; are expected to be iterables that are unpacked as arguments.</source>
          <target state="translated">&lt;em&gt;iterable&lt;/em&gt; 의 요소가 인수로 압축 해제 된 iterable이어야 한다는 점을 제외하고 &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 과 유사 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="779b5a441a3fe2beee9d18262802a4b2251c9ae8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;signal#signal.signal&quot;&gt;&lt;code&gt;signal.signal()&lt;/code&gt;&lt;/a&gt;, this function must be invoked in the main thread.</source>
          <target state="translated">&lt;a href=&quot;signal#signal.signal&quot;&gt; &lt;code&gt;signal.signal()&lt;/code&gt; &lt;/a&gt; 과 마찬가지로이 함수는 기본 스레드에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4567b33a2aaefbaca856883085dae36ad2796c3c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;connect(address)&lt;/code&gt;, but return an error indicator instead of raising an exception for errors returned by the C-level &lt;code&gt;connect()&lt;/code&gt; call (other problems, such as &amp;ldquo;host not found,&amp;rdquo; can still raise exceptions). The error indicator is &lt;code&gt;0&lt;/code&gt; if the operation succeeded, otherwise the value of the &lt;code&gt;errno&lt;/code&gt; variable. This is useful to support, for example, asynchronous connects.</source>
          <target state="translated">마찬가지로 &lt;code&gt;connect(address)&lt;/code&gt; ,하지만 C 수준에 의해 반환 된 오류에 대한 예외 올리는 대신 오류 표시를 반환 &lt;code&gt;connect()&lt;/code&gt; (여전히 예외를 올릴 수있다 &quot;호스트를 찾을 수 없음&quot;과 같은 다른 문제) 호출을. 조작이 성공하면 오류 표시기는 &lt;code&gt;0&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;errno&lt;/code&gt; 변수 의 값입니다 . 예를 들어 비동기 연결을 지원하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6e4099930d90cd8e644b9d1a35ce1781b7e55be5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;formatdate&lt;/code&gt;, but the input is a &lt;a href=&quot;datetime#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance. If it is a naive datetime, it is assumed to be &amp;ldquo;UTC with no information about the source timezone&amp;rdquo;, and the conventional &lt;code&gt;-0000&lt;/code&gt; is used for the timezone. If it is an aware &lt;code&gt;datetime&lt;/code&gt;, then the numeric timezone offset is used. If it is an aware timezone with offset zero, then &lt;em&gt;usegmt&lt;/em&gt; may be set to &lt;code&gt;True&lt;/code&gt;, in which case the string &lt;code&gt;GMT&lt;/code&gt; is used instead of the numeric timezone offset. This provides a way to generate standards conformant HTTP date headers.</source>
          <target state="translated">&lt;code&gt;formatdate&lt;/code&gt; 와 비슷 하지만 입력은 &lt;a href=&quot;datetime#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. 순진한 날짜 시간 인 경우 &quot;원본 시간대에 대한 정보가없는 UTC&quot;인 것으로 가정하고 표준 시간대에 대해 &lt;code&gt;-0000&lt;/code&gt; 을 사용합니다. 인식하는 &lt;code&gt;datetime&lt;/code&gt; 인 경우 숫자 시간대 오프셋이 사용됩니다. 오프셋이 0 인 인식 시간대 인 경우 &lt;em&gt;usegmt&lt;/em&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정할 수 있습니다 .이 경우 숫자 시간대 오프셋 대신 문자열 &lt;code&gt;GMT&lt;/code&gt; 가 사용됩니다. 이는 표준 준수 HTTP 날짜 헤더를 생성하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e9a1056335b6d3c9144b41d21fddbcb8e38867e3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;max(self, other)&lt;/code&gt; except that the context rounding rule is applied before returning and that &lt;code&gt;NaN&lt;/code&gt; values are either signaled or ignored (depending on the context and whether they are signaling or quiet).</source>
          <target state="translated">컨텍스트 반올림 규칙이 반환되기 전에 적용되고 &lt;code&gt;NaN&lt;/code&gt; 값이 시그널링되거나 무시 된다는 점을 제외하고 &lt;code&gt;max(self, other)&lt;/code&gt; 와 유사 합니다 (컨텍스트 에 따라 그리고 신호 또는 조용한 지 여부에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="117f781381f825f29b7d7c7a130438f9e5b689da" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;min(self, other)&lt;/code&gt; except that the context rounding rule is applied before returning and that &lt;code&gt;NaN&lt;/code&gt; values are either signaled or ignored (depending on the context and whether they are signaling or quiet).</source>
          <target state="translated">컨텍스트 반올림 규칙이 리턴되기 전에 적용되고 &lt;code&gt;NaN&lt;/code&gt; 값이 시그널링되거나 무시 된다는 점을 제외하고는 &lt;code&gt;min(self, other)&lt;/code&gt; 과 유사 합니다 (컨텍스트 에 따라 그리고 신호 또는 조용한 지 여부에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="7679621dea96b42673a5ec004c0be808374679d1" translate="yes" xml:space="preserve">
          <source>Like a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; object, &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; assumes the current Gregorian calendar extended in both directions; like a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object, &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; assumes there are exactly 3600*24 seconds in every day.</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 객체 와 마찬가지로 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 은 현재 Gregorian 달력이 양방향으로 확장 된 것으로 가정합니다. &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 와 마찬가지로 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 은 매일 정확히 3600 * 24 초가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="10db946781916518b11ce546b2af0588ae19c249" translate="yes" xml:space="preserve">
          <source>Like all decorators, it is also possible to call &lt;code&gt;staticmethod&lt;/code&gt; as a regular function and do something with its result. This is needed in some cases where you need a reference to a function from a class body and you want to avoid the automatic transformation to instance method. For these cases, use this idiom:</source>
          <target state="translated">모든 데코레이터와 마찬가지로 &lt;code&gt;staticmethod&lt;/code&gt; 를 일반 함수로 호출 하고 그 결과로 무언가를 할 수도 있습니다. 이것은 클래스 본문에서 함수에 대한 참조가 필요하고 인스턴스 메소드로 자동 변환하지 않으려는 경우에 필요합니다. 이 경우이 관용구를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="870a5dd7d5496171ef6a3e2aaab1057264f79b83" translate="yes" xml:space="preserve">
          <source>Like function objects, bound method objects support getting arbitrary attributes. However, since method attributes are actually stored on the underlying function object (&lt;code&gt;meth.__func__&lt;/code&gt;), setting method attributes on bound methods is disallowed. Attempting to set an attribute on a method results in an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; being raised. In order to set a method attribute, you need to explicitly set it on the underlying function object:</source>
          <target state="translated">함수 객체와 마찬가지로 바인딩 된 메소드 객체는 임의의 속성 가져 오기를 지원합니다. 그러나 메소드 속성은 실제로 기본 함수 오브젝트 ( &lt;code&gt;meth.__func__&lt;/code&gt; ) 에 저장되므로 바인딩 된 메소드에 메소드 속성을 설정할 수 없습니다. 메소드에서 속성을 설정하려고 시도하면 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 메소드 속성을 설정하려면 기본 함수 객체에서 메소드 속성을 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1583a91516920ea6d292abedef0a0d4133d1f95d" translate="yes" xml:space="preserve">
          <source>Like other collections, sets support &lt;code&gt;x in set&lt;/code&gt;, &lt;code&gt;len(set)&lt;/code&gt;, and &lt;code&gt;for x in
set&lt;/code&gt;. Being an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing, slicing, or other sequence-like behavior.</source>
          <target state="translated">다른 컬렉션과 마찬가지로 세트는 &lt;code&gt;x in set&lt;/code&gt; , &lt;code&gt;len(set)&lt;/code&gt; 및 &lt;code&gt;for x in set&lt;/code&gt; 합니다. 순서가없는 컬렉션이기 때문에 집합은 요소 위치 나 삽입 순서를 기록하지 않습니다. 따라서 세트는 인덱싱, 슬라이싱 또는 기타 시퀀스와 유사한 동작을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="619848ebfcfc900a4a75f4e75c5ae31dd1e46688" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;#pdbcommand-p&quot;&gt;&lt;code&gt;p&lt;/code&gt;&lt;/a&gt; command, except the value of the expression is pretty-printed using the &lt;a href=&quot;pprint#module-pprint&quot;&gt;&lt;code&gt;pprint&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#pdbcommand-p&quot;&gt; &lt;code&gt;p&lt;/code&gt; &lt;/a&gt; 명령 과 마찬가지로 표현식의 값은 &lt;a href=&quot;pprint#module-pprint&quot;&gt; &lt;code&gt;pprint&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 예쁘게 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f637d2b0e3d0bc308b91dbb540751ed9989d02f" translate="yes" xml:space="preserve">
          <source>Likewise, the &lt;a href=&quot;#decimal.setcontext&quot;&gt;&lt;code&gt;setcontext()&lt;/code&gt;&lt;/a&gt; function automatically assigns its target to the current thread.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#decimal.setcontext&quot;&gt; &lt;code&gt;setcontext()&lt;/code&gt; &lt;/a&gt; 함수는 대상을 현재 스레드에 자동으로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="16f0b939506acc96b15c52be3f403f4c577d5555" translate="yes" xml:space="preserve">
          <source>Limit on the number of characters in the representation of the string. Note that the &amp;ldquo;normal&amp;rdquo; representation of the string is used as the character source: if escape sequences are needed in the representation, these may be mangled when the representation is shortened. The default is &lt;code&gt;30&lt;/code&gt;.</source>
          <target state="translated">문자열 표현에서 문자 수 제한. 문자열의 &quot;정상&quot;표현이 문자 소스로 사용됩니다. 표현에 이스케이프 시퀀스가 ​​필요한 경우 표현이 단축 될 때 이스케이프가 엉망이 될 수 있습니다. 기본값은 &lt;code&gt;30&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="e0da5f32d1b078b4674313813ea6b1be4783c1f3" translate="yes" xml:space="preserve">
          <source>Limits on the number of entries represented for the named object type. The default is &lt;code&gt;4&lt;/code&gt; for &lt;a href=&quot;#reprlib.Repr.maxdict&quot;&gt;&lt;code&gt;maxdict&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;5&lt;/code&gt; for &lt;a href=&quot;#reprlib.Repr.maxarray&quot;&gt;&lt;code&gt;maxarray&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;6&lt;/code&gt; for the others.</source>
          <target state="translated">명명 된 객체 유형에 대해 표시되는 항목 수를 제한합니다. 기본값은 &lt;code&gt;4&lt;/code&gt; 에 대한 &lt;a href=&quot;#reprlib.Repr.maxdict&quot;&gt; &lt;code&gt;maxdict&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;5&lt;/code&gt; 에 대한 &lt;a href=&quot;#reprlib.Repr.maxarray&quot;&gt; &lt;code&gt;maxarray&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;code&gt;6&lt;/code&gt; 다른 사람을 위해.</target>
        </trans-unit>
        <trans-unit id="5cba8dfc960db4abee81cde524f36a4c3a10d9d1" translate="yes" xml:space="preserve">
          <source>Line 5 and 6 correspond to the arguments of the method &lt;code&gt;Screen.screensize()&lt;/code&gt;.</source>
          <target state="translated">5 행과 6 행은 &lt;code&gt;Screen.screensize()&lt;/code&gt; 메소드의 인수에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="2abd199292d800fa3a80bd3c37bdfccc94f580e6" translate="yes" xml:space="preserve">
          <source>Line Feed</source>
          <target state="translated">줄 바꿈</target>
        </trans-unit>
        <trans-unit id="8063848dd725bd56f98d4d78213b9bcdc4a7dc13" translate="yes" xml:space="preserve">
          <source>Line Separator</source>
          <target state="translated">선 구분자</target>
        </trans-unit>
        <trans-unit id="2e24c77fd923a41a63ac5dc6de543f323222cd3c" translate="yes" xml:space="preserve">
          <source>Line Tabulation</source>
          <target state="translated">라인 표</target>
        </trans-unit>
        <trans-unit id="b6aab80f18f5fed0b9153b69b8095064354fb00e" translate="yes" xml:space="preserve">
          <source>Line buffer</source>
          <target state="translated">라인 버퍼</target>
        </trans-unit>
        <trans-unit id="4f23e2d073d67acea8f123b42f84af035e27248d" translate="yes" xml:space="preserve">
          <source>Line feed</source>
          <target state="translated">줄 바꿈</target>
        </trans-unit>
        <trans-unit id="562aae5d9e971e10b07ca699f4f04a970c307d4c" translate="yes" xml:space="preserve">
          <source>Line number (&lt;code&gt;int&lt;/code&gt;) of the filter. If &lt;em&gt;lineno&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the filter matches any line number.</source>
          <target state="translated">필터의 줄 번호 ( &lt;code&gt;int&lt;/code&gt; )입니다. 경우 &lt;em&gt;LINENO가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 필터는 행 번호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="aeb38dd24a3a71da272f1f779d0387791de3d81e" translate="yes" xml:space="preserve">
          <source>Line number (&lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">줄 번호 ( &lt;code&gt;int&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2ff2293358a32428ec942d4555635cc880cd4d12" translate="yes" xml:space="preserve">
          <source>Line number at which an error occurred.</source>
          <target state="translated">오류가 발생한 줄 번호.</target>
        </trans-unit>
        <trans-unit id="b4da991f94a24c99137fffe4424265997efd6ed0" translate="yes" xml:space="preserve">
          <source>Line number on which the error was detected. The first line is numbered &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">오류가 감지 된 줄 번호 첫 번째 줄의 번호는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69f2575cae166f7e141a5f9bfed26ae7b3477899" translate="yes" xml:space="preserve">
          <source>Line-endings are implemented using the codec&amp;rsquo;s &lt;a href=&quot;#codecs.decode&quot;&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/a&gt; method and are included in the list entries if &lt;em&gt;keepends&lt;/em&gt; is true.</source>
          <target state="translated">줄 끝은 코덱의 &lt;a href=&quot;#codecs.decode&quot;&gt; &lt;code&gt;decode()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 구현되며 &lt;em&gt;keepends&lt;/em&gt; 가 true 인 경우 목록 항목에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="302f1117893400c611682ce09d6a46e296f097b2" translate="yes" xml:space="preserve">
          <source>Lines are returned with any newlines intact, which means that the last line in a file may not have one.</source>
          <target state="translated">줄 바꿈은 그대로 유지됩니다. 즉, 파일의 마지막 줄에 줄이 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf75ffeff8d12fdd995dd6674c85fc5ee7a38554" translate="yes" xml:space="preserve">
          <source>Lines are separated by calling &lt;code&gt;text.splitlines(True)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;text.splitlines(True)&lt;/code&gt; 를 호출하여 행을 구분합니다 .</target>
        </trans-unit>
        <trans-unit id="b6185854ec82c5419438640c3884931bbe6dbd4b" translate="yes" xml:space="preserve">
          <source>Lines beginning with &amp;lsquo;&lt;code&gt;?&lt;/code&gt;&amp;rsquo; attempt to guide the eye to intraline differences, and were not present in either input sequence. These lines can be confusing if the sequences contain tab characters.</source>
          <target state="translated">' &lt;code&gt;?&lt;/code&gt; 로 시작하는 줄 눈을 인라인 차이로 유도하려고 시도했지만 입력 시퀀스에는 없었습니다. 시퀀스에 탭 문자가 포함되어 있으면 이러한 행이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1119cda9075f6ea9b6d77bc2c527e01b0505ac69" translate="yes" xml:space="preserve">
          <source>Lines containing only whitespace are ignored in the input and normalized to a single newline character in the output.</source>
          <target state="translated">공백 만 포함 된 행은 입력에서 무시되고 출력에서 ​​단일 개행 문자로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="8f51211d5882b7b1d7f5bacb8c562304994eec22" translate="yes" xml:space="preserve">
          <source>Link has been severed</source>
          <target state="translated">링크가 끊어졌습니다</target>
        </trans-unit>
        <trans-unit id="2e5686329f75b06ffaef20d4254ffaa821209705" translate="yes" xml:space="preserve">
          <source>Link number out of range</source>
          <target state="translated">링크 번호가 범위를 벗어남</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="0a2eda05e77dfe3f8ca694538c7808e144972c9f" translate="yes" xml:space="preserve">
          <source>Linux extended attributes</source>
          <target state="translated">Linux 확장 속성</target>
        </trans-unit>
        <trans-unit id="65238285b798b8c333fd4b7618bf5f86a3d5d9d0" translate="yes" xml:space="preserve">
          <source>Linux-only support for TIPC is available using the &lt;code&gt;AF_TIPC&lt;/code&gt; address family. TIPC is an open, non-IP based networked protocol designed for use in clustered computer environments. Addresses are represented by a tuple, and the fields depend on the address type. The general tuple form is &lt;code&gt;(addr_type, v1, v2, v3 [, scope])&lt;/code&gt;, where:</source>
          <target state="translated">TIPC에 대한 Linux 전용 지원은 &lt;code&gt;AF_TIPC&lt;/code&gt; 주소 계열을 사용하여 사용할 수 있습니다 . TIPC는 클러스터 컴퓨터 환경에서 사용하도록 설계된 개방형 비 IP 기반 네트워크 프로토콜입니다. 주소는 튜플로 표시되며 필드는 주소 유형에 따라 다릅니다. 일반적인 튜플 형식은 &lt;code&gt;(addr_type, v1, v2, v3 [, scope])&lt;/code&gt; . 여기서 :</target>
        </trans-unit>
        <trans-unit id="6756f8fa45c66ce66565b44aeff373a153af3d17" translate="yes" xml:space="preserve">
          <source>List a directory in a standardized format by using &lt;code&gt;MLSD&lt;/code&gt; command (&lt;a href=&quot;https://tools.ietf.org/html/rfc3659.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 3659&lt;/strong&gt;&lt;/a&gt;). If &lt;em&gt;path&lt;/em&gt; is omitted the current directory is assumed. &lt;em&gt;facts&lt;/em&gt; is a list of strings representing the type of information desired (e.g. &lt;code&gt;[&quot;type&quot;, &quot;size&quot;, &quot;perm&quot;]&lt;/code&gt;). Return a generator object yielding a tuple of two elements for every file found in path. First element is the file name, the second one is a dictionary containing facts about the file name. Content of this dictionary might be limited by the &lt;em&gt;facts&lt;/em&gt; argument but server is not guaranteed to return all requested facts.</source>
          <target state="translated">&lt;code&gt;MLSD&lt;/code&gt; 명령 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3659.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 3659&lt;/strong&gt;&lt;/a&gt; ) 을 사용하여 표준화 된 형식으로 디렉토리를 나열하십시오 . 경우 &lt;em&gt;경로가&lt;/em&gt; 생략 현재 디렉토리가 가정한다. &lt;em&gt;facts&lt;/em&gt; 는 원하는 정보 유형을 나타내는 문자열 목록입니다 (예 : &lt;code&gt;[&quot;type&quot;, &quot;size&quot;, &quot;perm&quot;]&lt;/code&gt; ). 경로에서 발견 된 모든 파일에 대해 두 요소의 튜플을 생성하는 생성기 객체를 반환합니다. 첫 번째 요소는 파일 이름이고 두 번째 요소는 파일 이름에 대한 사실을 포함하는 사전입니다. 이 사전의 내용은 &lt;em&gt;facts&lt;/em&gt; 인수에 의해 제한 될 수 있지만 서버는 요청 된 모든 facts를 리턴한다고 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="12fba910c861b6473d219e30cab4ab0ddbb8c795" translate="yes" xml:space="preserve">
          <source>List all source code for the current function or frame. Interesting lines are marked as for &lt;a href=&quot;#pdbcommand-list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 기능 또는 프레임에 대한 모든 소스 코드를 나열하십시오. 재미있는 줄은 &lt;a href=&quot;#pdbcommand-list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d70266b0617125a334eb682496c42690e2f3d04c" translate="yes" xml:space="preserve">
          <source>List files in a tarfile.</source>
          <target state="translated">tarfile에 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="5c622661583046960e0bb8731c1346ad7495dcc3" translate="yes" xml:space="preserve">
          <source>List files in a zipfile.</source>
          <target state="translated">zip 파일로 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="fa6a27ccedf9df11c9e8acab0ae9e0767d6f65fc" translate="yes" xml:space="preserve">
          <source>List mailbox names in &lt;em&gt;directory&lt;/em&gt; matching &lt;em&gt;pattern&lt;/em&gt;. &lt;em&gt;directory&lt;/em&gt; defaults to the top-level mail folder, and &lt;em&gt;pattern&lt;/em&gt; defaults to match anything. Returned data contains a list of &lt;code&gt;LIST&lt;/code&gt; responses.</source>
          <target state="translated">&lt;em&gt;디렉토리&lt;/em&gt; 일치 &lt;em&gt;패턴으로&lt;/em&gt; 메일 함 이름을 나열하십시오 . &lt;em&gt;디렉토리&lt;/em&gt; 는 최상위 메일 폴더로 기본 설정 되며 &lt;em&gt;패턴은&lt;/em&gt; 기본적으로 모든 항목과 일치합니다. 리턴 된 데이터는 &lt;code&gt;LIST&lt;/code&gt; 응답 목록을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="800331fecdd25e9674ace0cfb84a1e1381cf18b8" translate="yes" xml:space="preserve">
          <source>List of &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt; objects the server is listening on.</source>
          <target state="translated">서버가 청취중인 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket&lt;/code&gt; &lt;/a&gt; 객체의 목록</target>
        </trans-unit>
        <trans-unit id="4bbdd0f3d0f330c45f8c92c42b67ed3353e81dd6" translate="yes" xml:space="preserve">
          <source>List of Unix shell-style wildcard test name patterns that test methods have to match to be included in test suites (see &lt;code&gt;-v&lt;/code&gt; option).</source>
          <target state="translated">테스트 스위트에 포함하기 위해 테스트 메소드가 일치해야하는 Unix 쉘 스타일 와일드 카드 테스트 이름 패턴 목록 ( &lt;code&gt;-v&lt;/code&gt; 옵션 참조 ).</target>
        </trans-unit>
        <trans-unit id="57db87f824923c6a6e85c41dda54ae743e739bdc" translate="yes" xml:space="preserve">
          <source>List of all features.</source>
          <target state="translated">모든 기능 목록.</target>
        </trans-unit>
        <trans-unit id="da2bc44930e06125e26f0c874633811a8e00c51a" translate="yes" xml:space="preserve">
          <source>List of all known property names.</source>
          <target state="translated">알려진 모든 속성 이름 목록</target>
        </trans-unit>
        <trans-unit id="faa04fad93c99ece21b96a05b9ce1aa911971898" translate="yes" xml:space="preserve">
          <source>List of directories ignored by &lt;a href=&quot;#filecmp.dircmp&quot;&gt;&lt;code&gt;dircmp&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">기본적 으로 &lt;a href=&quot;#filecmp.dircmp&quot;&gt; &lt;code&gt;dircmp&lt;/code&gt; 에&lt;/a&gt; 의해 무시되는 디렉토리 목록 .</target>
        </trans-unit>
        <trans-unit id="c9d8bdccc79a7bea28f18186c6779f053049d3e4" translate="yes" xml:space="preserve">
          <source>List of modes (most common values) of discrete or nomimal data.</source>
          <target state="translated">이산 또는 공칭 데이터의 모드 (가장 일반적인 값) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="2a6187ce53594c8b41f9b2648356dcd783d1eb99" translate="yes" xml:space="preserve">
          <source>List of strings for where to find submodules, if a package (&lt;code&gt;None&lt;/code&gt; otherwise).</source>
          <target state="translated">패키지 인 경우 하위 모듈을 찾을 수있는 문자열 목록입니다 ( 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f7e2b9e05ac716cd69cc94c5137d7e7daf29a300" translate="yes" xml:space="preserve">
          <source>List of supported TLS channel binding types. Strings in this list can be used as arguments to &lt;a href=&quot;#ssl.SSLSocket.get_channel_binding&quot;&gt;&lt;code&gt;SSLSocket.get_channel_binding()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지원되는 TLS 채널 바인딩 유형 목록 이리스트의 캐릭터 라인은 &lt;a href=&quot;#ssl.SSLSocket.get_channel_binding&quot;&gt; &lt;code&gt;SSLSocket.get_channel_binding()&lt;/code&gt; &lt;/a&gt; 인수로서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfd0c4da7e055fb85f316a12860955e2e611d96f" translate="yes" xml:space="preserve">
          <source>List of type map file names commonly installed. These files are typically named &lt;code&gt;mime.types&lt;/code&gt; and are installed in different locations by different packages.</source>
          <target state="translated">일반적으로 설치되는 유형 맵 파일 이름 목록 이러한 파일의 이름은 일반적으로 &lt;code&gt;mime.types&lt;/code&gt; 이며 다른 패키지로 다른 위치에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="252590ef4c3c27b7d91456da231c614540d98ed0" translate="yes" xml:space="preserve">
          <source>List source code for the current file. Without arguments, list 11 lines around the current line or continue the previous listing. With &lt;code&gt;.&lt;/code&gt; as argument, list 11 lines around the current line. With one argument, list 11 lines around at that line. With two arguments, list the given range; if the second argument is less than the first, it is interpreted as a count.</source>
          <target state="translated">현재 파일의 소스 코드를 나열합니다. 인수없이 현재 줄 주위에 11 줄을 나열하거나 이전 목록을 계속합니다. 로 &lt;code&gt;.&lt;/code&gt; 인수로 현재 줄 주변에 11 줄을 나열하십시오. 하나의 인수로 해당 줄에 11 줄을 나열하십시오. 두 개의 인수로 주어진 범위를 나열하십시오. 두 번째 인수가 첫 번째 인수보다 작 으면 카운트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b76073e5ceffc46ca02895c2b2a65a33093b7119" translate="yes" xml:space="preserve">
          <source>List subscribed mailbox names in directory matching pattern. &lt;em&gt;directory&lt;/em&gt; defaults to the top level directory and &lt;em&gt;pattern&lt;/em&gt; defaults to match any mailbox. Returned data are tuples of message part envelope and data.</source>
          <target state="translated">가입 한 사서함 이름을 디렉토리 일치 패턴으로 나열합니다. &lt;em&gt;directory는&lt;/em&gt; 기본적으로 최상위 디렉터리이고 &lt;em&gt;pattern은&lt;/em&gt; 모든 사서함과 일치합니다. 반환 된 데이터는 메시지 부분 봉투와 데이터의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="14794f6edf5dd70913a0dc13a15f54d846587e12" translate="yes" xml:space="preserve">
          <source>Listen for connections made to the socket. The &lt;em&gt;backlog&lt;/em&gt; argument specifies the maximum number of queued connections and should be at least 1; the maximum value is system-dependent (usually 5).</source>
          <target state="translated">소켓에 대한 연결을 청취하십시오. &lt;em&gt;잔고&lt;/em&gt; 인수 대기 최대 연결 개수를 지정하고 적어도 하나이어야한다; 최대 값은 시스템에 따라 다릅니다 (일반적으로 5).</target>
        </trans-unit>
        <trans-unit id="59788472d65c6cb0cdf054e71f5b32c462ddafe5" translate="yes" xml:space="preserve">
          <source>Listener objects have the following read-only properties:</source>
          <target state="translated">리스너 객체에는 다음과 같은 읽기 전용 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca23c866857250c984c4db4e11455584d8f239e" translate="yes" xml:space="preserve">
          <source>Listeners and Clients</source>
          <target state="translated">청취자와 고객</target>
        </trans-unit>
        <trans-unit id="98711f268cb1239cc73201ecb0f34f28471e2e46" translate="yes" xml:space="preserve">
          <source>Listing Python source files in this directory tree:</source>
          <target state="translated">이 디렉토리 트리에 Python 소스 파일 나열 :</target>
        </trans-unit>
        <trans-unit id="78d2fd98237accde24de6f88a6a1f729f5aa17b3" translate="yes" xml:space="preserve">
          <source>Listing subdirectories:</source>
          <target state="translated">하위 디렉토리 나열 :</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="d704786c02f4fcaf4a2e891ff8e18bad45ac10fd" translate="yes" xml:space="preserve">
          <source>Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application).</source>
          <target state="translated">목록은 일반적으로 동종 항목의 컬렉션을 저장하는 데 사용되는 변경 가능한 시퀀스입니다 (정확한 유사도는 응용 프로그램에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="c32ca8f5ba63672fe4a8182a4b217ecc9b9eb14c" translate="yes" xml:space="preserve">
          <source>Lists implement all of the &lt;a href=&quot;#typesseq-common&quot;&gt;common&lt;/a&gt; and &lt;a href=&quot;#typesseq-mutable&quot;&gt;mutable&lt;/a&gt; sequence operations. Lists also provide the following additional method:</source>
          <target state="translated">리스트는 &lt;a href=&quot;#typesseq-common&quot;&gt;공통&lt;/a&gt; 적이고 &lt;a href=&quot;#typesseq-mutable&quot;&gt;변경 가능한&lt;/a&gt; 시퀀스 연산을 모두 구현합니다 . 목록은 다음과 같은 추가 방법도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fc6230b3f52b454e7bfc16f6d295dbd8a3f5614d" translate="yes" xml:space="preserve">
          <source>Lists may be constructed in several ways:</source>
          <target state="translated">리스트는 여러 가지 방법으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4b615b7707ee69f129d6b1543d98fed8ea5861c" translate="yes" xml:space="preserve">
          <source>Lists the names of all open windows; select one to bring it to the foreground (deiconifying it if necessary).</source>
          <target state="translated">열려있는 모든 창의 이름을 나열합니다. 하나를 선택하여 전경으로 가져옵니다 (필요한 경우 아이콘을 해제)</target>
        </trans-unit>
        <trans-unit id="2b17c112445a7674729b2ac41ba9f07dc0cb6826" translate="yes" xml:space="preserve">
          <source>Load MIME information from a file named &lt;em&gt;filename&lt;/em&gt;. This uses &lt;a href=&quot;#mimetypes.MimeTypes.readfp&quot;&gt;&lt;code&gt;readfp()&lt;/code&gt;&lt;/a&gt; to parse the file.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일&lt;/em&gt; 에서 MIME 정보를로드하십시오 . &lt;a href=&quot;#mimetypes.MimeTypes.readfp&quot;&gt; &lt;code&gt;readfp()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 파일을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="792824da62ac18b629f8e6b4e61bfdae14c5fd20" translate="yes" xml:space="preserve">
          <source>Load MIME type information from an open file &lt;em&gt;fp&lt;/em&gt;. The file must have the format of the standard &lt;code&gt;mime.types&lt;/code&gt; files.</source>
          <target state="translated">열린 파일 &lt;em&gt;fp&lt;/em&gt; 에서 MIME 유형 정보를로드하십시오 . 파일은 표준 &lt;code&gt;mime.types&lt;/code&gt; 파일 형식이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="0fd53188415ccfe79d44d4578cf2a8334a3d823f" translate="yes" xml:space="preserve">
          <source>Load MIME type information from the Windows registry.</source>
          <target state="translated">Windows 레지스트리에서 MIME 유형 정보를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="d2ab95731c56b9a24f873b538755b0e5ea0d2829" translate="yes" xml:space="preserve">
          <source>Load a plist from a bytes object. See &lt;a href=&quot;#plistlib.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; for an explanation of the keyword arguments.</source>
          <target state="translated">bytes 객체에서 plist를로드하십시오. 키워드 인수에 대한 설명은 &lt;a href=&quot;#plistlib.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b08eb074a7b195edaa59eaed1cf5e8727d68fee" translate="yes" xml:space="preserve">
          <source>Load a private key and the corresponding certificate. The &lt;em&gt;certfile&lt;/em&gt; string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate&amp;rsquo;s authenticity. The &lt;em&gt;keyfile&lt;/em&gt; string, if present, must point to a file containing the private key in. Otherwise the private key will be taken from &lt;em&gt;certfile&lt;/em&gt; as well. See the discussion of &lt;a href=&quot;#ssl-certificates&quot;&gt;Certificates&lt;/a&gt; for more information on how the certificate is stored in the &lt;em&gt;certfile&lt;/em&gt;.</source>
          <target state="translated">개인 키와 해당 인증서를로드하십시오. &lt;em&gt;certfile의&lt;/em&gt; 문자열은 인증서뿐만 아니라 인증서의 신뢰성을 구축하는 데 필요한 CA 인증서의 수를 포함하는 PEM 형식의 단일 파일에 대한 경로 여야합니다. &lt;em&gt;키 파일&lt;/em&gt; 문자열이 존재하는 경우에 개인 키를 포함하는 파일을 가리켜 야합니다. 그렇지 않으면 개인 키에서 이동합니다 &lt;em&gt;certfile&lt;/em&gt; 뿐만 아니라. 인증서가 &lt;em&gt;certfile에&lt;/em&gt; 저장되는 방법에 대한 자세한 정보 는 &lt;a href=&quot;#ssl-certificates&quot;&gt;인증서&lt;/a&gt; 설명을 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0df7eb62baff888bf529433e660c5a399082980" translate="yes" xml:space="preserve">
          <source>Load a readline history file, and append it to the history list. The default filename is &lt;code&gt;~/.history&lt;/code&gt;. This calls &lt;code&gt;read_history()&lt;/code&gt; in the underlying library.</source>
          <target state="translated">리드 라인 히스토리 파일을로드하고 히스토리 목록에 추가하십시오. 기본 파일 이름은 &lt;code&gt;~/.history&lt;/code&gt; 입니다. 기본 라이브러리에서 &lt;code&gt;read_history()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="8f58087190f63144704a753ee6b80f3cc73b183c" translate="yes" xml:space="preserve">
          <source>Load a set of &amp;ldquo;certification authority&amp;rdquo; (CA) certificates used to validate other peers&amp;rsquo; certificates when &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; is other than &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt;. At least one of &lt;em&gt;cafile&lt;/em&gt; or &lt;em&gt;capath&lt;/em&gt; must be specified.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt; 가 CERT_NONE 이 아닌 경우 다른 피어의 인증서를 확인하는 데 사용되는 일련의 &quot;인증 기관&quot;(CA) 인증서를 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; . &lt;em&gt;cafile&lt;/em&gt; 또는 &lt;em&gt;capath&lt;/em&gt; 중 하나 이상을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6425be74b314ff59dd5ac88cdafe03db1813ef76" translate="yes" xml:space="preserve">
          <source>Load a set of default &amp;ldquo;certification authority&amp;rdquo; (CA) certificates from a filesystem path defined when building the OpenSSL library. Unfortunately, there&amp;rsquo;s no easy way to know whether this method succeeds: no error is returned if no certificates are to be found. When the OpenSSL library is provided as part of the operating system, though, it is likely to be configured properly.</source>
          <target state="translated">OpenSSL 라이브러리를 빌드 할 때 정의 된 파일 시스템 경로에서 기본 &quot;인증 기관&quot;(CA) 인증서 세트를로드하십시오. 불행히도이 방법의 성공 여부를 쉽게 알 수있는 방법은 없습니다. 인증서를 찾지 못하면 오류가 반환되지 않습니다. 그러나 OpenSSL 라이브러리가 운영 체제의 일부로 제공되면 올바르게 구성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b124fe19c645c5969eaba65d28b149a48d7f5bc8" translate="yes" xml:space="preserve">
          <source>Load a set of default &amp;ldquo;certification authority&amp;rdquo; (CA) certificates from default locations. On Windows it loads CA certs from the &lt;code&gt;CA&lt;/code&gt; and &lt;code&gt;ROOT&lt;/code&gt; system stores. On other systems it calls &lt;a href=&quot;#ssl.SSLContext.set_default_verify_paths&quot;&gt;&lt;code&gt;SSLContext.set_default_verify_paths()&lt;/code&gt;&lt;/a&gt;. In the future the method may load CA certificates from other locations, too.</source>
          <target state="translated">기본 위치에서 기본 &quot;인증 기관&quot;(CA) 인증서 세트를로드하십시오. Windows에서는 &lt;code&gt;CA&lt;/code&gt; 및 &lt;code&gt;ROOT&lt;/code&gt; 시스템 저장소 에서 CA 인증서를로드 합니다. 다른 시스템에서는 &lt;a href=&quot;#ssl.SSLContext.set_default_verify_paths&quot;&gt; &lt;code&gt;SSLContext.set_default_verify_paths()&lt;/code&gt; &lt;/a&gt; 호출합니다 . 앞으로이 방법은 다른 위치에서도 CA 인증서를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="792f87e11df87af3501d49b8d196fb913af1e572" translate="yes" xml:space="preserve">
          <source>Load a shared library into the process and return it. This method always returns a new instance of the library.</source>
          <target state="translated">프로세스에 공유 라이브러리를로드하고 리턴하십시오. 이 메소드는 항상 라이브러리의 새 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c3ea81eee343a4d2df989dde2d08b3714fcbfd81" translate="yes" xml:space="preserve">
          <source>Load a snapshot from a file.</source>
          <target state="translated">파일에서 스냅 샷을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="1c7f519dc3373f6a0d8fc97719f2948be78a3852" translate="yes" xml:space="preserve">
          <source>Load configuration from any object that provides a dict-like &lt;code&gt;items()&lt;/code&gt; method. Keys are section names, values are dictionaries with keys and values that should be present in the section. If the used dictionary type preserves order, sections and their keys will be added in order. Values are automatically converted to strings.</source>
          <target state="translated">dict-like &lt;code&gt;items()&lt;/code&gt; 메소드 를 제공하는 모든 오브젝트에서 구성을로드하십시오 . 키는 섹션 이름이며, 값은 섹션에 있어야하는 키와 값이있는 사전입니다. 사용 된 사전 유형이 순서를 유지하면 섹션과 해당 키가 순서대로 추가됩니다. 값은 자동으로 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="609771080ece00742363664de393857bf53c63b0" translate="yes" xml:space="preserve">
          <source>Load cookies from a file.</source>
          <target state="translated">파일에서 쿠키를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="d415a74437b2a8fde46291994b8fb27e74daafc0" translate="yes" xml:space="preserve">
          <source>Load the key generation parameters for Diffie-Hellman (DH) key exchange. Using DH key exchange improves forward secrecy at the expense of computational resources (both on the server and on the client). The &lt;em&gt;dhfile&lt;/em&gt; parameter should be the path to a file containing DH parameters in PEM format.</source>
          <target state="translated">Diffie-Hellman (DH) 키 교환을위한 키 생성 매개 변수를로드하십시오. DH 키 교환을 사용하면 계산 리소스 (서버 및 클라이언트 모두)를 희생하여 순방향 보안이 향상됩니다. 그만큼&lt;em&gt;dhfile의&lt;/em&gt; 매개 변수는 PEM 형식의 DH 파라미터를 포함하는 파일의 경로해야한다.</target>
        </trans-unit>
        <trans-unit id="48d42fbf167299e3dd1e195e2e77c87b6142971f" translate="yes" xml:space="preserve">
          <source>Load the module specified by &lt;em&gt;fullname&lt;/em&gt;. &lt;em&gt;fullname&lt;/em&gt; must be the fully qualified (dotted) module name. It returns the imported module, or raises &lt;a href=&quot;#zipimport.ZipImportError&quot;&gt;&lt;code&gt;ZipImportError&lt;/code&gt;&lt;/a&gt; if it wasn&amp;rsquo;t found.</source>
          <target state="translated">&lt;em&gt;fullname으로&lt;/em&gt; 지정된 모듈을로드하십시오 . &lt;em&gt;fullname&lt;/em&gt; 은 완전한 (점으로 표시된) 모듈 이름이어야합니다. 가져온 모듈을 반환하거나 &lt;a href=&quot;#zipimport.ZipImportError&quot;&gt; &lt;code&gt;ZipImportError&lt;/code&gt; 를 발생시킵니다.&lt;/a&gt; 경우 발생 .</target>
        </trans-unit>
        <trans-unit id="a3b67eabfacc63af222593625d5483dccb09f499" translate="yes" xml:space="preserve">
          <source>Load the type map given in the file &lt;em&gt;filename&lt;/em&gt;, if it exists. The type map is returned as a dictionary mapping filename extensions, including the leading dot (&lt;code&gt;'.'&lt;/code&gt;), to strings of the form &lt;code&gt;'type/subtype'&lt;/code&gt;. If the file &lt;em&gt;filename&lt;/em&gt; does not exist or cannot be read, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 파일에 지정된 유형 맵 (있는 경우)을로드하십시오 . 형식 맵은 선행 점 ( &lt;code&gt;'.'&lt;/code&gt; )을 포함하여 &lt;code&gt;'type/subtype'&lt;/code&gt; 형식 의 문자열에 대한 사전 매핑 파일 이름 확장자로 반환됩니다 . 파일 파일 &lt;em&gt;이름&lt;/em&gt; 이 없거나 읽을 수없는 경우 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f23b0ce31d15663c44713bcd66b9c0b09a0934" translate="yes" xml:space="preserve">
          <source>Loadable extensions are disabled by default. See &lt;a href=&quot;#f1&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">로드 가능한 확장 프로그램은 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;#f1&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="3c47f6edd5e2c7e153595d9012f90395b664fad9" translate="yes" xml:space="preserve">
          <source>Loadable extensions are disabled by default. See &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">로드 가능한 확장 프로그램은 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="e571b5d989d6291a8883f0e57e8a8c8f1bd18e89" translate="yes" xml:space="preserve">
          <source>Loaders that wish to support resource reading are expected to provide a method called &lt;code&gt;get_resource_reader(fullname)&lt;/code&gt; which returns an object implementing this ABC&amp;rsquo;s interface. If the module specified by fullname is not a package, this method should return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. An object compatible with this ABC should only be returned when the specified module is a package.</source>
          <target state="translated">리소스 읽기를 지원하려는 로더는 이 ABC의 인터페이스를 구현하는 객체를 반환하는 &lt;code&gt;get_resource_reader(fullname)&lt;/code&gt; 라는 메서드를 제공해야합니다 . fullname으로 지정된 모듈이 패키지가 아닌 경우이 메소드는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 리턴해야합니다. . 이 ABC와 호환되는 객체는 지정된 모듈이 패키지 인 경우에만 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="378ce4564cfc961412915083fc6fe3d3a3ac4043" translate="yes" xml:space="preserve">
          <source>Loaders that wish to support resource reading should implement a &lt;code&gt;get_resource_reader(fullname)&lt;/code&gt; method as specified by &lt;a href=&quot;#importlib.abc.ResourceReader&quot;&gt;&lt;code&gt;importlib.abc.ResourceReader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리소스 읽기를 지원하려는 로더는 &lt;a href=&quot;#importlib.abc.ResourceReader&quot;&gt; &lt;code&gt;importlib.abc.ResourceReader&lt;/code&gt; 에&lt;/a&gt; 지정된 &lt;code&gt;get_resource_reader(fullname)&lt;/code&gt; 메소드를 구현해야합니다. .</target>
        </trans-unit>
        <trans-unit id="3a57f41eadfd6d867f90958cecb3a4047f1a4c3d" translate="yes" xml:space="preserve">
          <source>Loading a library through any of these objects raises an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;ctypes.dlopen&lt;/code&gt; with string argument &lt;code&gt;name&lt;/code&gt;, the name used to load the library.</source>
          <target state="translated">이러한 객체를 통해 라이브러리 를로드하면 라이브러리를로드하는 데 사용되는 &lt;code&gt;name&lt;/code&gt; 인 string argument name 과 함께 &lt;a href=&quot;sys#auditing&quot;&gt;감사 이벤트 &lt;/a&gt; &lt;code&gt;ctypes.dlopen&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="6157b16025e97d941d88dc209da06d6279f10e6e" translate="yes" xml:space="preserve">
          <source>Loading and running tests</source>
          <target state="translated">테스트로드 및 실행</target>
        </trans-unit>
        <trans-unit id="0f19a79e96a975070aa13b1f20b3d2bdd4d9dc24" translate="yes" xml:space="preserve">
          <source>Loading dynamic link libraries</source>
          <target state="translated">동적 링크 라이브러리로드</target>
        </trans-unit>
        <trans-unit id="d59529dbda456f2b5d95ed314e6b490be68e48e9" translate="yes" xml:space="preserve">
          <source>Loading shared libraries</source>
          <target state="translated">공유 라이브러리로드</target>
        </trans-unit>
        <trans-unit id="b90fef70cb5c4d40f44b0f88151132cf53bf667b" translate="yes" xml:space="preserve">
          <source>Loads a method named &lt;code&gt;co_names[namei]&lt;/code&gt; from TOS object. TOS is popped and method and TOS are pushed when interpreter can call unbound method directly. TOS will be used as the first argument (&lt;code&gt;self&lt;/code&gt;) by &lt;a href=&quot;#opcode-CALL_METHOD&quot;&gt;&lt;code&gt;CALL_METHOD&lt;/code&gt;&lt;/a&gt;. Otherwise, &lt;code&gt;NULL&lt;/code&gt; and method is pushed (method is bound method or something else).</source>
          <target state="translated">TOS 오브젝트에서 &lt;code&gt;co_names[namei]&lt;/code&gt; 라는 메소드를로드 합니다. 인터프리터가 언 바운드 메소드를 직접 호출 할 수있는 경우 TOS가 팝업되고 메소드 및 TOS가 푸시됩니다. TOS는 &lt;a href=&quot;#opcode-CALL_METHOD&quot;&gt; &lt;code&gt;CALL_METHOD&lt;/code&gt; &lt;/a&gt; 에서 첫 번째 인수 ( &lt;code&gt;self&lt;/code&gt; )로 사용 됩니다 . 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 및 메소드가 푸시됩니다 (메소드가 메소드 또는 바인드 된 메소드입니다).</target>
        </trans-unit>
        <trans-unit id="d27df2a4a2d21c1753293f40979140c7e27016e1" translate="yes" xml:space="preserve">
          <source>Loads all symbols not starting with &lt;code&gt;'_'&lt;/code&gt; directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements &lt;code&gt;from module import *&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'_'&lt;/code&gt; 로 시작하지 않는 모든 기호를 모듈 TOS에서 로컬 네임 스페이스로 직접 로드합니다 . 모든 이름을로드 한 후 모듈이 팝업됩니다. 이 opcode는 &lt;code&gt;from module import *&lt;/code&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="a73db01bcd9bbe68ec1dd85d66ba7ce5f2794388" translate="yes" xml:space="preserve">
          <source>Loads an external XML section into this element tree. &lt;em&gt;source&lt;/em&gt; is a file name or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. &lt;em&gt;parser&lt;/em&gt; is an optional parser instance. If not given, the standard &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; parser is used. Returns the section root element.</source>
          <target state="translated">이 요소 트리에 외부 XML 섹션을로드합니다. &lt;em&gt;source&lt;/em&gt; 는 파일 이름 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 입니다. &lt;em&gt;파서&lt;/em&gt; 는 선택적 파서 인스턴스입니다. 지정하지 않으면 표준 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 파서가 사용됩니다. 섹션 루트 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f8a05fa121c3dfddca1eb9b12000164796d7f86" translate="yes" xml:space="preserve">
          <source>Loads the attribute &lt;code&gt;co_names[namei]&lt;/code&gt; from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt;&lt;code&gt;STORE_FAST&lt;/code&gt;&lt;/a&gt; instruction.</source>
          <target state="translated">TOS에있는 모듈에서 &lt;code&gt;co_names[namei]&lt;/code&gt; 속성을로드합니다 . 결과 객체는 스택에 푸시되어 &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt; &lt;code&gt;STORE_FAST&lt;/code&gt; &lt;/a&gt; 명령 에 의해 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b348168c8362df88f869811fab229492225da54" translate="yes" xml:space="preserve">
          <source>Loads the cell contained in slot &lt;em&gt;i&lt;/em&gt; of the cell and free variable storage. Pushes a reference to the object the cell contains on the stack.</source>
          <target state="translated">셀의 슬롯 &lt;em&gt;i&lt;/em&gt; 에 포함 된 셀과 사용 가능한 가변 스토리지를 로드합니다 . 셀에 스택에 포함 된 객체에 대한 참조를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="07317685209bae8dc29b1177be533689623566aa" translate="yes" xml:space="preserve">
          <source>Loads the global named &lt;code&gt;co_names[namei]&lt;/code&gt; onto the stack.</source>
          <target state="translated">&lt;code&gt;co_names[namei]&lt;/code&gt; 라는 전역 이름을 스택에 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="5e4196f78acb5e15163031bb305c6c69a7881387" translate="yes" xml:space="preserve">
          <source>Local currency symbol.</source>
          <target state="translated">현지 통화 기호.</target>
        </trans-unit>
        <trans-unit id="52009a3ea27db65f1cc4de20822dd34262e8738c" translate="yes" xml:space="preserve">
          <source>Local processes can also access that queue, using the code from above on the client to access it remotely:</source>
          <target state="translated">로컬 프로세스는 클라이언트에서 위의 코드를 사용하여 원격으로 액세스하여 해당 큐에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e985f42b4f2cb4a242c933c6cd4f71c10094544" translate="yes" xml:space="preserve">
          <source>Locale category for formatting numbers. The functions &lt;a href=&quot;#locale.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#locale.atoi&quot;&gt;&lt;code&gt;atoi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#locale.atof&quot;&gt;&lt;code&gt;atof()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#locale.str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module are affected by that category. All other numeric formatting operations are not affected.</source>
          <target state="translated">숫자 서식의 로캘 범주입니다. &lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;a href=&quot;#locale.format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#locale.atoi&quot;&gt; &lt;code&gt;atoi()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#locale.atof&quot;&gt; &lt;code&gt;atof()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#locale.str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 함수 는 해당 카테고리의 영향을받습니다. 다른 모든 숫자 서식 작업은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e89698268d6ca826988ca2828f9a33ea91d9b28a" translate="yes" xml:space="preserve">
          <source>Locale category for formatting of monetary values. The available options are available from the &lt;a href=&quot;#locale.localeconv&quot;&gt;&lt;code&gt;localeconv()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">화폐 값의 서식을 지정하는 로캘 범주입니다. 사용 가능한 옵션은 &lt;a href=&quot;#locale.localeconv&quot;&gt; &lt;code&gt;localeconv()&lt;/code&gt; &lt;/a&gt; 함수 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="04a64c4c278c2187092935ce39d2099f68cb48c8" translate="yes" xml:space="preserve">
          <source>Locale category for message display. Python currently does not support application specific locale-aware messages. Messages displayed by the operating system, like those returned by &lt;a href=&quot;os#os.strerror&quot;&gt;&lt;code&gt;os.strerror()&lt;/code&gt;&lt;/a&gt; might be affected by this category.</source>
          <target state="translated">메시지 표시를위한 로케일 범주. Python은 현재 응용 프로그램 별 로캘 인식 메시지를 지원하지 않습니다. &lt;a href=&quot;os#os.strerror&quot;&gt; &lt;code&gt;os.strerror()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 것과 같이 운영 체제에 의해 표시되는 메시지 는이 범주의 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd49d042ef959ad8740ad1439b50170f4a67803" translate="yes" xml:space="preserve">
          <source>Locale category for sorting strings. The functions &lt;a href=&quot;#locale.strcoll&quot;&gt;&lt;code&gt;strcoll()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#locale.strxfrm&quot;&gt;&lt;code&gt;strxfrm()&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module are affected.</source>
          <target state="translated">문자열 정렬을위한 로캘 범주입니다. &lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;a href=&quot;#locale.strcoll&quot;&gt; &lt;code&gt;strcoll()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#locale.strxfrm&quot;&gt; &lt;code&gt;strxfrm()&lt;/code&gt; &lt;/a&gt; 함수 가 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="cbbf73bf0b11794a60e800b47ab121a2dee00b07" translate="yes" xml:space="preserve">
          <source>Locale category for the character type functions. Depending on the settings of this category, the functions of module &lt;a href=&quot;string#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; dealing with case change their behaviour.</source>
          <target state="translated">문자 유형 함수의 로케일 범주. 이 범주의 설정에 따라 대 / 소문자를 처리하는 모듈 &lt;a href=&quot;string#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 의 기능이 동작을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b3402d90af0a871f59ee54dff6e494f7c57e091c" translate="yes" xml:space="preserve">
          <source>Locale category for the formatting of time. The function &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; follows these conventions.</source>
          <target state="translated">시간 형식에 대한 로캘 범주입니다. &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 함수 는 이러한 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="73b793f3c64332c43debe3f45fccfa2080cec4a8" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s abbreviated month name.</source>
          <target state="translated">로케일의 약식 월 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c9afac89d2e328ab0ed56be9db5cfa0260851bff" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s abbreviated weekday name.</source>
          <target state="translated">로케일의 약식 요일 이름.</target>
        </trans-unit>
        <trans-unit id="46905c93036f1fc91beab4f6536669f4aa997a97" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s appropriate date and time representation.</source>
          <target state="translated">로케일의 적절한 날짜 및 시간 표현</target>
        </trans-unit>
        <trans-unit id="13dd4044599b17dfb922c37d1bc883f07809d332" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s appropriate date representation.</source>
          <target state="translated">로케일의 적절한 날짜 표현.</target>
        </trans-unit>
        <trans-unit id="36487e73126def0235c7c9de6ec2356b44418976" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s appropriate time representation.</source>
          <target state="translated">로케일의 적절한 시간 표현.</target>
        </trans-unit>
        <trans-unit id="f2fefc48256fa82bb994918d97f4d1273ceaaa82" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s equivalent of either AM or PM.</source>
          <target state="translated">로케일은 AM 또는 PM에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="6fd390382c5edc4503dc946a153a0cfc7197d046" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s full month name.</source>
          <target state="translated">로캘의 전체 월 이름입니다.</target>
        </trans-unit>
        <trans-unit id="07ec6fcd65ab62d1a5fc3d4b40fc1f0d429bee74" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s full weekday name.</source>
          <target state="translated">로케일의 전체 요일 이름.</target>
        </trans-unit>
        <trans-unit id="f1fb667e5d929e9a2ab0404441ece3a2b8b4ac94" translate="yes" xml:space="preserve">
          <source>Localizing your application</source>
          <target state="translated">응용 프로그램 현지화</target>
        </trans-unit>
        <trans-unit id="7e70bb97fb52037a6fc3c4f3daae9b44f1e4190f" translate="yes" xml:space="preserve">
          <source>Localizing your module</source>
          <target state="translated">모듈 현지화</target>
        </trans-unit>
        <trans-unit id="d2e95cdee60c00152032441855294fcdb5f25216" translate="yes" xml:space="preserve">
          <source>Locate the insertion point for &lt;em&gt;x&lt;/em&gt; in &lt;em&gt;a&lt;/em&gt; to maintain sorted order. The parameters &lt;em&gt;lo&lt;/em&gt; and &lt;em&gt;hi&lt;/em&gt; may be used to specify a subset of the list which should be considered; by default the entire list is used. If &lt;em&gt;x&lt;/em&gt; is already present in &lt;em&gt;a&lt;/em&gt;, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first parameter to &lt;code&gt;list.insert()&lt;/code&gt; assuming that &lt;em&gt;a&lt;/em&gt; is already sorted.</source>
          <target state="translated">의 삽입 지점의 위치 &lt;em&gt;X를&lt;/em&gt; 에 정렬 된 순서를 유지하기 위해. &lt;em&gt;lo&lt;/em&gt; 및 &lt;em&gt;hi&lt;/em&gt; 파라미터 는 고려되어야 할리스트의 서브 세트를 지정하는데 사용될 수있다. 기본적으로 전체 목록이 사용됩니다. 경우 &lt;em&gt;, X는&lt;/em&gt; 이미 존재 , 삽입 점은 기존 항목 (왼쪽에) 이전이어야한다. 반환 값은 &lt;em&gt;a&lt;/em&gt; 가 이미 정렬되어 있다고 가정하면 &lt;code&gt;list.insert()&lt;/code&gt; 의 첫 번째 매개 변수로 사용하기에 적합합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c21d4b6cbd99b64624c0ae81363ca97a7b37eac" translate="yes" xml:space="preserve">
          <source>Locates a bitmap file of the name &lt;code&gt;name.xpm&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; in one of the bitmap directories (see the &lt;a href=&quot;#tkinter.tix.tixCommand.tix_addbitmapdir&quot;&gt;&lt;code&gt;tix_addbitmapdir()&lt;/code&gt;&lt;/a&gt; method). By using &lt;a href=&quot;#tkinter.tix.tixCommand.tix_getbitmap&quot;&gt;&lt;code&gt;tix_getbitmap()&lt;/code&gt;&lt;/a&gt;, you can avoid hard coding the pathnames of the bitmap files in your application. When successful, it returns the complete pathname of the bitmap file, prefixed with the character &lt;code&gt;@&lt;/code&gt;. The returned value can be used to configure the &lt;code&gt;bitmap&lt;/code&gt; option of the Tk and Tix widgets.</source>
          <target state="translated">비트 맵 디렉토리 중 하나에서 이름 &lt;code&gt;name.xpm&lt;/code&gt; 또는 &lt;code&gt;name&lt;/code&gt; 의 비트 맵 파일을 찾습니다 ( &lt;a href=&quot;#tkinter.tix.tixCommand.tix_addbitmapdir&quot;&gt; &lt;code&gt;tix_addbitmapdir()&lt;/code&gt; &lt;/a&gt; 메소드 참조). &lt;a href=&quot;#tkinter.tix.tixCommand.tix_getbitmap&quot;&gt; &lt;code&gt;tix_getbitmap()&lt;/code&gt; &lt;/a&gt; 을 사용 하면 애플리케이션에서 비트 맵 파일의 경로 이름을 하드 코딩하지 않아도 됩니다. 성공하면 비트 맵 파일의 전체 경로 이름을 앞에 &lt;code&gt;@&lt;/code&gt; 문자가 붙습니다 . 리턴 된 값을 사용 하여 Tk 및 Tix 위젯 의 &lt;code&gt;bitmap&lt;/code&gt; 옵션 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a6c0b8acf24a16e33c0f64184c64947bcfef879" translate="yes" xml:space="preserve">
          <source>Locates an image file of the name &lt;code&gt;name.xpm&lt;/code&gt;, &lt;code&gt;name.xbm&lt;/code&gt; or &lt;code&gt;name.ppm&lt;/code&gt; in one of the bitmap directories (see the &lt;a href=&quot;#tkinter.tix.tixCommand.tix_addbitmapdir&quot;&gt;&lt;code&gt;tix_addbitmapdir()&lt;/code&gt;&lt;/a&gt; method above). If more than one file with the same name (but different extensions) exist, then the image type is chosen according to the depth of the X display: xbm images are chosen on monochrome displays and color images are chosen on color displays. By using &lt;a href=&quot;#tkinter.tix.tixCommand.tix_getimage&quot;&gt;&lt;code&gt;tix_getimage()&lt;/code&gt;&lt;/a&gt;, you can avoid hard coding the pathnames of the image files in your application. When successful, this method returns the name of the newly created image, which can be used to configure the &lt;code&gt;image&lt;/code&gt; option of the Tk and Tix widgets.</source>
          <target state="translated">비트 맵 디렉토리 중 하나에서 &lt;code&gt;name.xpm&lt;/code&gt; , &lt;code&gt;name.xbm&lt;/code&gt; 또는 &lt;code&gt;name.ppm&lt;/code&gt; 이름의 이미지 파일을 찾습니다 &lt;a href=&quot;#tkinter.tix.tixCommand.tix_addbitmapdir&quot;&gt; &lt;code&gt;tix_addbitmapdir()&lt;/code&gt; &lt;/a&gt; 위 의 tix_addbitmapdir () 메서드 참조). 이름이 같지만 확장자가 다른 파일이 둘 이상있는 경우 X 디스플레이의 깊이에 따라 이미지 유형이 선택됩니다. xbm 이미지는 흑백 디스플레이에서 선택되고 컬러 이미지는 컬러 디스플레이에서 선택됩니다. &lt;a href=&quot;#tkinter.tix.tixCommand.tix_getimage&quot;&gt; &lt;code&gt;tix_getimage()&lt;/code&gt; &lt;/a&gt; 를 사용 하면 애플리케이션에서 이미지 파일의 경로 이름을 하드 코딩하지 않아도 됩니다. 성공하면이 메소드는 새로 작성된 이미지의 이름을 리턴하며, 이는 Tk 및 Tix 위젯 의 &lt;code&gt;image&lt;/code&gt; 옵션 을 구성하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8b0e21f5b3f01d9c1a093dcc7aebc48a221cf7a" translate="yes" xml:space="preserve">
          <source>Locator Objects</source>
          <target state="translated">로케이터 객체</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="5a9e42ea8ddb21d85da434d1d4df2d2f1efa57a3" translate="yes" xml:space="preserve">
          <source>Lock Objects</source>
          <target state="translated">객체 잠금</target>
        </trans-unit>
        <trans-unit id="06f960cf76802c9e596f5a165b9c306033b8c337" translate="yes" xml:space="preserve">
          <source>Lock objects have the following methods:</source>
          <target state="translated">잠금 객체에는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0222c4646a5cac92401d4d0c07f15b59f773661e" translate="yes" xml:space="preserve">
          <source>Lock part of a file based on file descriptor &lt;em&gt;fd&lt;/em&gt; from the C runtime. Raises &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; on failure. The locked region of the file extends from the current file position for &lt;em&gt;nbytes&lt;/em&gt; bytes, and may continue beyond the end of the file. &lt;em&gt;mode&lt;/em&gt; must be one of the &lt;code&gt;LK_*&lt;/code&gt; constants listed below. Multiple regions in a file may be locked at the same time, but may not overlap. Adjacent regions are not merged; they must be unlocked individually.</source>
          <target state="translated">C 런타임에서 파일 디스크립터 &lt;em&gt;fd&lt;/em&gt; 를 기반으로 파일의 일부를 잠그십시오 . 발생시킵니다 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 실패. 파일의 잠긴 영역은 현재 파일 위치에서 &lt;em&gt;nbytes&lt;/em&gt; 바이트 까지 확장되며 파일 끝을 넘어 계속 될 수 있습니다. &lt;em&gt;mode&lt;/em&gt; 는 아래 나열된 &lt;code&gt;LK_*&lt;/code&gt; 상수 중 하나 여야합니다 . 파일의 여러 영역이 동시에 잠겨있을 수 있지만 겹치지 않을 수 있습니다. 인접한 지역은 병합되지 않습니다. 개별적으로 잠금 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="c528eeea30f8c7cdbf3dd9c943be567de116bc9e" translate="yes" xml:space="preserve">
          <source>Lock program segments into memory. The value of &lt;em&gt;op&lt;/em&gt; (defined in &lt;code&gt;&amp;lt;sys/lock.h&amp;gt;&lt;/code&gt;) determines which segments are locked.</source>
          <target state="translated">프로그램 세그먼트를 메모리에 잠급니다. &lt;em&gt;op&lt;/em&gt; 값 ( &lt;code&gt;&amp;lt;sys/lock.h&amp;gt;&lt;/code&gt; 에 정의 됨 )에 따라 잠길 세그먼트가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d14148792cb2e70e25dadd8e130df4def697650f" translate="yes" xml:space="preserve">
          <source>Locks also support the &lt;a href=&quot;#with-locks&quot;&gt;context management protocol&lt;/a&gt;.</source>
          <target state="translated">잠금은 &lt;a href=&quot;#with-locks&quot;&gt;컨텍스트 관리 프로토콜&lt;/a&gt; 도 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e4911bad28d3fb7972d5e7251b010d8af4491853" translate="yes" xml:space="preserve">
          <source>Locks the specified bytes. If the bytes cannot be locked, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 바이트를 잠급니다. 바이트를 잠글 수 없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9271e320c4c74de58382f17a37df89d94c970942" translate="yes" xml:space="preserve">
          <source>Locks the specified bytes. If the bytes cannot be locked, the program immediately tries again after 1 second. If, after 10 attempts, the bytes cannot be locked, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 바이트를 잠급니다. 바이트를 잠글 수 없으면 프로그램은 1 초 후에 즉시 다시 시도합니다. 10 번의 시도 후에 바이트를 잠글 수 없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf1602b3907bd203c789fd778d5036f56eb7eaa5" translate="yes" xml:space="preserve">
          <source>Log in as the given &lt;em&gt;user&lt;/em&gt;. The &lt;em&gt;passwd&lt;/em&gt; and &lt;em&gt;acct&lt;/em&gt; parameters are optional and default to the empty string. If no &lt;em&gt;user&lt;/em&gt; is specified, it defaults to &lt;code&gt;'anonymous'&lt;/code&gt;. If &lt;em&gt;user&lt;/em&gt; is &lt;code&gt;'anonymous'&lt;/code&gt;, the default &lt;em&gt;passwd&lt;/em&gt; is &lt;code&gt;'anonymous@'&lt;/code&gt;. This function should be called only once for each instance, after a connection has been established; it should not be called at all if a host and user were given when the instance was created. Most FTP commands are only allowed after the client has logged in. The &lt;em&gt;acct&lt;/em&gt; parameter supplies &amp;ldquo;accounting information&amp;rdquo;; few systems implement this.</source>
          <target state="translated">주어진 &lt;em&gt;사용자&lt;/em&gt; 로 로그인하십시오 . &lt;em&gt;passwd를&lt;/em&gt; 하고 &lt;em&gt;ACCT&lt;/em&gt; 매개 변수는 빈 문자열을 선택하고 기본입니다. &lt;em&gt;사용자&lt;/em&gt; 를 지정 하지 않으면 기본값은 &lt;code&gt;'anonymous'&lt;/code&gt; 입니다. 경우 &lt;em&gt;사용자&lt;/em&gt; 입니다 &lt;code&gt;'anonymous'&lt;/code&gt; 기본 &lt;em&gt;passwd 파일이&lt;/em&gt; 있다 &lt;code&gt;'anonymous@'&lt;/code&gt; . 이 함수는 연결이 설정된 후 각 인스턴스에 대해 한 번만 호출해야합니다. 인스턴스가 작성 될 때 호스트와 사용자가 제공된 경우 전혀 호출되지 않아야합니다. 대부분의 FTP 명령은 클라이언트가 로그인 한 후에 만 ​​허용됩니다. &lt;em&gt;acct&lt;/em&gt; 매개 변수는 &quot;계정 정보&quot;를 제공합니다. 이를 구현하는 시스템은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="492759de42716d33cbac9e1b9827c65dd042298c" translate="yes" xml:space="preserve">
          <source>Log in on an SMTP server that requires authentication. The arguments are the username and the password to authenticate with. If there has been no previous &lt;code&gt;EHLO&lt;/code&gt; or &lt;code&gt;HELO&lt;/code&gt; command this session, this method tries ESMTP &lt;code&gt;EHLO&lt;/code&gt; first. This method will return normally if the authentication was successful, or may raise the following exceptions:</source>
          <target state="translated">인증이 필요한 SMTP 서버에 로그인하십시오. 인수는 인증 할 사용자 이름 및 비밀번호입니다. 이 세션에 이전 &lt;code&gt;EHLO&lt;/code&gt; 또는 &lt;code&gt;HELO&lt;/code&gt; 명령이 없는 경우이 방법은 먼저 ESMTP &lt;code&gt;EHLO&lt;/code&gt; 를 시도합니다 . 인증에 성공하면이 메소드가 정상적으로 리턴되거나 다음 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d77829d521e5852593ca42255d86ed2e7f8595be" translate="yes" xml:space="preserve">
          <source>Log normal distribution. If you take the natural logarithm of this distribution, you&amp;rsquo;ll get a normal distribution with mean &lt;em&gt;mu&lt;/em&gt; and standard deviation &lt;em&gt;sigma&lt;/em&gt;. &lt;em&gt;mu&lt;/em&gt; can have any value, and &lt;em&gt;sigma&lt;/em&gt; must be greater than zero.</source>
          <target state="translated">정규 분포를 기록합니다. 이 분포의 자연 로그를 취하면 평균 &lt;em&gt;mu&lt;/em&gt; 및 표준 편차 &lt;em&gt;sigma를&lt;/em&gt; 갖는 정규 분포를 얻게 됩니다. &lt;em&gt;mu&lt;/em&gt; 는 값을 가질 수 있으며 &lt;em&gt;sigma&lt;/em&gt; 는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="ec346ba8e376063f18c76a6a36fb7ed2f33b4610" translate="yes" xml:space="preserve">
          <source>Log options:</source>
          <target state="translated">로그 옵션 :</target>
        </trans-unit>
        <trans-unit id="e403e316611e44a9d6be336eddc9b9eb85594a3c" translate="yes" xml:space="preserve">
          <source>Log the &lt;em&gt;exc_info&lt;/em&gt; tuple in the server log. &lt;em&gt;exc_info&lt;/em&gt; is a &lt;code&gt;(type, value,
traceback)&lt;/code&gt; tuple. The default implementation simply writes the traceback to the request&amp;rsquo;s &lt;code&gt;wsgi.errors&lt;/code&gt; stream and flushes it. Subclasses can override this method to change the format or retarget the output, mail the traceback to an administrator, or whatever other action may be deemed suitable.</source>
          <target state="translated">로그 &lt;em&gt;exc_info의&lt;/em&gt; 서버 로그에서 튜플. &lt;em&gt;exc_info&lt;/em&gt; 는 &lt;code&gt;(type, value, traceback)&lt;/code&gt; 튜플입니다. 기본 구현은 단순히 추적을 요청의 &lt;code&gt;wsgi.errors&lt;/code&gt; 스트림에 기록하고 플러시합니다. 서브 클래스는이 메소드를 대체하여 형식을 변경하거나 출력 대상을 재 지정하거나, 추적을 관리자에게 메일로 보내거나, 다른 조치가 적절하다고 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc4e6d3876ad4a8a803d61a2a77cd5334fce93af" translate="yes" xml:space="preserve">
          <source>LogRecord Objects</source>
          <target state="translated">LogRecord 객체</target>
        </trans-unit>
        <trans-unit id="ccb5e46040b27f71ccff505e9a6e009e5d62de5b" translate="yes" xml:space="preserve">
          <source>LogRecord attributes</source>
          <target state="translated">LogRecord 속성</target>
        </trans-unit>
        <trans-unit id="fbead21275199ebeec83dafe0173b0929df9cb34" translate="yes" xml:space="preserve">
          <source>Logger Objects</source>
          <target state="translated">로거 객체</target>
        </trans-unit>
        <trans-unit id="b5fc3005221abc4dacb66646e66e5f0b75230d22" translate="yes" xml:space="preserve">
          <source>LoggerAdapter Objects</source>
          <target state="translated">LoggerAdapter 객체</target>
        </trans-unit>
        <trans-unit id="15832f53aca8e4c130be5e20c44213f1a721a48e" translate="yes" xml:space="preserve">
          <source>Loggers expose the interface that application code directly uses.</source>
          <target state="translated">로거는 응용 프로그램 코드가 직접 사용하는 인터페이스를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="efa3718c7750545c2778f507e22c3d6f661d113d" translate="yes" xml:space="preserve">
          <source>Loggers have the following attributes and methods. Note that Loggers should &lt;em&gt;NEVER&lt;/em&gt; be instantiated directly, but always through the module-level function &lt;code&gt;logging.getLogger(name)&lt;/code&gt;. Multiple calls to &lt;a href=&quot;#logging.getLogger&quot;&gt;&lt;code&gt;getLogger()&lt;/code&gt;&lt;/a&gt; with the same name will always return a reference to the same Logger object.</source>
          <target state="translated">로거에는 다음과 같은 속성과 메소드가 있습니다. 로거는 것을 참고 &lt;em&gt;결코&lt;/em&gt; 모듈 수준의 기능을 통해 직접하지만, 항상 인스턴스화되지 &lt;code&gt;logging.getLogger(name)&lt;/code&gt; . 이름이 같은 &lt;a href=&quot;#logging.getLogger&quot;&gt; &lt;code&gt;getLogger()&lt;/code&gt; &lt;/a&gt; 를 여러 번 호출 하면 항상 동일한 Logger 객체에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="718fbafd7688e11a4939390c7cefcf0e84b52cd7" translate="yes" xml:space="preserve">
          <source>Logging Cookbook</source>
          <target state="translated">로깅 요리 책</target>
        </trans-unit>
        <trans-unit id="1fbc43bf18b2478288c7467471047ecb56ddfd53" translate="yes" xml:space="preserve">
          <source>Logging Levels</source>
          <target state="translated">로깅 수준</target>
        </trans-unit>
        <trans-unit id="1b01df6b50483f653377a29c09e0331101f1c193" translate="yes" xml:space="preserve">
          <source>Logging options of subsequent &lt;a href=&quot;#module-syslog&quot;&gt;&lt;code&gt;syslog()&lt;/code&gt;&lt;/a&gt; calls can be set by calling &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#module-syslog&quot;&gt;&lt;code&gt;syslog()&lt;/code&gt;&lt;/a&gt; will call &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; with no arguments if the log is not currently open.</source>
          <target state="translated">후속 &lt;a href=&quot;#module-syslog&quot;&gt; &lt;code&gt;syslog()&lt;/code&gt; &lt;/a&gt; 호출 의 로깅 옵션은 &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 를 호출하여 설정할 수 있습니다 . 로그가 현재 열려 있지 않은 경우 &lt;a href=&quot;#module-syslog&quot;&gt; &lt;code&gt;syslog()&lt;/code&gt; &lt;/a&gt; 는 인수없이 &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f2c3bb3b5b0e703c74d0f552f84bc84df36cf3d0" translate="yes" xml:space="preserve">
          <source>Logical operands</source>
          <target state="translated">논리 피연산자</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="68ee364c110a032900740118e24926681c70b88f" translate="yes" xml:space="preserve">
          <source>Login name</source>
          <target state="translated">로그인 이름</target>
        </trans-unit>
        <trans-unit id="4793b19c165be78b5755bf851fe44408b3928735" translate="yes" xml:space="preserve">
          <source>Logs a message with integer level &lt;em&gt;level&lt;/em&gt; on this logger. The other arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 수준과 메시지 로그 &lt;em&gt;수준&lt;/em&gt; 이 로거에 있습니다. 다른 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="568da12654cb50668fd7df8728fdffeea5db8e4f" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;CRITICAL&lt;/code&gt; on the root logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">루트 로거에서 &lt;code&gt;CRITICAL&lt;/code&gt; 레벨의 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="13c90355ef29e3a334c5bf4bf41ddcfe4ea3bd96" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;CRITICAL&lt;/code&gt; on this logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 로거에서 &lt;code&gt;CRITICAL&lt;/code&gt; 레벨의 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="36f562459e6b0a68f0056bc85b76d0713156dd98" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;DEBUG&lt;/code&gt; on the root logger. The &lt;em&gt;msg&lt;/em&gt; is the message format string, and the &lt;em&gt;args&lt;/em&gt; are the arguments which are merged into &lt;em&gt;msg&lt;/em&gt; using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)</source>
          <target state="translated">루트 로거에서 &lt;code&gt;DEBUG&lt;/code&gt; 레벨의 메시지를 기록합니다. &lt;em&gt;MSG는&lt;/em&gt; 메시지 형식 문자열이며, &lt;em&gt;인수가&lt;/em&gt; 병합 된 인수입니다 &lt;em&gt;MSG&lt;/em&gt; 연산자를 서식 문자열을 사용. (이것은 단일 사전 인수와 함께 형식 문자열에서 키워드를 사용할 수 있음을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="5a4c1194427cd766c51025f3e34a599a0511d4b3" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;DEBUG&lt;/code&gt; on this logger. The &lt;em&gt;msg&lt;/em&gt; is the message format string, and the &lt;em&gt;args&lt;/em&gt; are the arguments which are merged into &lt;em&gt;msg&lt;/em&gt; using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)</source>
          <target state="translated">이 로거에서 &lt;code&gt;DEBUG&lt;/code&gt; 레벨의 메시지를 기록합니다. &lt;em&gt;MSG는&lt;/em&gt; 메시지 형식 문자열이며, &lt;em&gt;인수가&lt;/em&gt; 병합 된 인수입니다 &lt;em&gt;MSG&lt;/em&gt; 연산자를 서식 문자열을 사용. (이것은 단일 사전 인수와 함께 형식 문자열에서 키워드를 사용할 수 있음을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="f28267fec34519242b4f0b061529a74d9fd484db" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;ERROR&lt;/code&gt; on the root logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">루트 로거에서 수준이 &lt;code&gt;ERROR&lt;/code&gt; 인 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="063c8e0d066708dfaf5ffe371aa8fb8c4cc02f3c" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;ERROR&lt;/code&gt; on the root logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;. Exception info is added to the logging message. This function should only be called from an exception handler.</source>
          <target state="translated">루트 로거에서 수준이 &lt;code&gt;ERROR&lt;/code&gt; 인 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 . 예외 정보가 로깅 메시지에 추가됩니다. 이 함수는 예외 처리기에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6423ebbe3708cdc9d0f73b8e0a2a041b8f7201cd" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;ERROR&lt;/code&gt; on this logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 로거에서 레벨 &lt;code&gt;ERROR&lt;/code&gt; 의 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="88872c80d5ab754d614298ef5b916093cae7f7b7" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;ERROR&lt;/code&gt; on this logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;. Exception info is added to the logging message. This method should only be called from an exception handler.</source>
          <target state="translated">이 로거에서 레벨 &lt;code&gt;ERROR&lt;/code&gt; 의 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 . 예외 정보가 로깅 메시지에 추가됩니다. 이 메소드는 예외 핸들러에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0dc5301e94745236f4d358120d631126efcea6a" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;INFO&lt;/code&gt; on the root logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">루트 로거에서 &lt;code&gt;INFO&lt;/code&gt; 레벨의 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="581dd2f78c21b5e17b02fc079ab480e252bfcc1d" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;INFO&lt;/code&gt; on this logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 로거에서 &lt;code&gt;INFO&lt;/code&gt; 레벨의 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f2f699842300d31569b0cd131e0992c77e4125c" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;WARNING&lt;/code&gt; on the root logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">루트 로거에서 &lt;code&gt;WARNING&lt;/code&gt; 수준으로 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff4a3eae062ed036b2645240bea04e5509ea296a" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;code&gt;WARNING&lt;/code&gt; on this logger. The arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 로거에 &lt;code&gt;WARNING&lt;/code&gt; 수준으로 메시지를 기록합니다. 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="2899f8a5fde47519ab2a228961dc0b080847aeb5" translate="yes" xml:space="preserve">
          <source>Logs a message with level &lt;em&gt;level&lt;/em&gt; on the root logger. The other arguments are interpreted as for &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수준있는 메시지 로그 &lt;em&gt;수준&lt;/em&gt; 루트 로거에 있습니다. 다른 인수는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="e88c984feb01158e83ba8164af3f59c55939f49a" translate="yes" xml:space="preserve">
          <source>Logs an accepted (successful) request. &lt;em&gt;code&lt;/em&gt; should specify the numeric HTTP code associated with the response. If a size of the response is available, then it should be passed as the &lt;em&gt;size&lt;/em&gt; parameter.</source>
          <target state="translated">수락 된 (성공적인) 요청을 기록합니다. &lt;em&gt;코드&lt;/em&gt; 는 응답과 관련된 숫자 HTTP 코드를 지정해야합니다. 응답 크기가 사용 가능한 경우 &lt;em&gt;크기&lt;/em&gt; 매개 변수 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6dd21f141766e9553b34ec63e21d85a3b49703" translate="yes" xml:space="preserve">
          <source>Logs an arbitrary message to &lt;code&gt;sys.stderr&lt;/code&gt;. This is typically overridden to create custom error logging mechanisms. The &lt;em&gt;format&lt;/em&gt; argument is a standard printf-style format string, where the additional arguments to &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.log_message&quot;&gt;&lt;code&gt;log_message()&lt;/code&gt;&lt;/a&gt; are applied as inputs to the formatting. The client ip address and current date and time are prefixed to every message logged.</source>
          <target state="translated">임의의 메시지를 &lt;code&gt;sys.stderr&lt;/code&gt; 에 기록합니다 . 이는 일반적으로 사용자 정의 오류 로깅 메커니즘을 생성하기 위해 재정의됩니다. &lt;em&gt;형식&lt;/em&gt; 인수에 대한 추가 인수 표준의 printf 스타일의 형식 문자열입니다 &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.log_message&quot;&gt; &lt;code&gt;log_message()&lt;/code&gt; &lt;/a&gt; 형식으로 입력으로 적용됩니다. 클라이언트 IP 주소와 현재 날짜 및 시간은 기록 된 모든 메시지 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="e90924ba66bc7d377e31aed21afb101cba9a37c3" translate="yes" xml:space="preserve">
          <source>Logs an error when a request cannot be fulfilled. By default, it passes the message to &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.log_message&quot;&gt;&lt;code&gt;log_message()&lt;/code&gt;&lt;/a&gt;, so it takes the same arguments (&lt;em&gt;format&lt;/em&gt; and additional values).</source>
          <target state="translated">요청을 이행 할 수 없을 때 오류를 기록합니다. 기본적으로 메시지를 &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.log_message&quot;&gt; &lt;code&gt;log_message()&lt;/code&gt; &lt;/a&gt; 로 전달하므로 동일한 인수 ( &lt;em&gt;형식&lt;/em&gt; 및 추가 값)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8ac632028735d423f992df756452f653d52c9aa" translate="yes" xml:space="preserve">
          <source>Look on the current line. with the cursor, and the line above for a filename and line number. If found, open the file if not already open, and show the line. Use this to view source lines referenced in an exception traceback and lines found by Find in Files. Also available in the context menu of the Shell window and Output windows.</source>
          <target state="translated">현재 줄을보십시오. 파일 이름과 줄 번호는 커서와 위의 줄을 사용하십시오. 발견 된 경우 파일이 아직 열려 있지 않으면 파일을 열고 행을 표시하십시오. 이를 사용하여 예외 역 추적에서 참조 된 소스 행과 파일에서 찾기에서 찾은 행을보십시오. 셸 창의 출력 메뉴 및 상황에 맞는 메뉴에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="830541a609e4aebb4ca0ddc42697347ba279e0a5" translate="yes" xml:space="preserve">
          <source>Look up a handler function based on the &lt;code&gt;mimetype&lt;/code&gt; of &lt;em&gt;msg&lt;/em&gt; (see next paragraph), call it, passing through all arguments, and return the result of the call. The expectation is that the handler will extract the payload from &lt;em&gt;msg&lt;/em&gt; and return an object that encodes information about the extracted data.</source>
          <target state="translated">에 기초 핸들러 함수 조회 &lt;code&gt;mimetype&lt;/code&gt; 의 &lt;em&gt;MSG를&lt;/em&gt; (다음 단락 참조), 모든 인수 통과를 호출하고 호출 결과를 반환합니다. 핸들러는 &lt;em&gt;msg&lt;/em&gt; 에서 페이로드를 추출하고 추출 된 데이터에 대한 정보를 인코딩하는 오브젝트를 리턴 할 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="02580224a4c7c76c987379f2bada22e0530b5592" translate="yes" xml:space="preserve">
          <source>Look up character by name. If a character with the given name is found, return the corresponding character. If not found, &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">이름별로 문자를 찾습니다. 주어진 이름을 가진 문자가 발견되면 해당 문자를 반환합니다. 찾을 수 없으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ab30e49eb23103b13863785d8c5f988a831d12c9" translate="yes" xml:space="preserve">
          <source>Look up the &lt;em&gt;context&lt;/em&gt; and &lt;em&gt;message&lt;/em&gt; id in the catalog and return the corresponding message string, as a Unicode string. If there is no entry in the catalog for the &lt;em&gt;message&lt;/em&gt; id and &lt;em&gt;context&lt;/em&gt;, and a fallback has been set, the look up is forwarded to the fallback&amp;rsquo;s &lt;a href=&quot;#gettext.pgettext&quot;&gt;&lt;code&gt;pgettext()&lt;/code&gt;&lt;/a&gt; method. Otherwise, the &lt;em&gt;message&lt;/em&gt; id is returned.</source>
          <target state="translated">위 봐 &lt;em&gt;컨텍스트&lt;/em&gt; 및 &lt;em&gt;메시지&lt;/em&gt; 카탈로그에 ID를하고 유니 코드 문자열로, 해당 메시지 문자열을 반환합니다. 카탈로그에 &lt;em&gt;메시지&lt;/em&gt; id 및 &lt;em&gt;context에&lt;/em&gt; 대한 항목이없고 &lt;a href=&quot;#gettext.pgettext&quot;&gt; &lt;code&gt;pgettext()&lt;/code&gt; &lt;/a&gt; 백이 설정된 경우 찾아보기는 폴 백의 pgettext () 메소드로 전달됩니다 . 그렇지 않으면 &lt;em&gt;메시지&lt;/em&gt; ID가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cb02656c464ac3ccae9eccf0e89b321d6923bdd6" translate="yes" xml:space="preserve">
          <source>Look up the &lt;em&gt;message&lt;/em&gt; id in the catalog and return the corresponding message string, as a Unicode string. If there is no entry in the catalog for the &lt;em&gt;message&lt;/em&gt; id, and a fallback has been set, the look up is forwarded to the fallback&amp;rsquo;s &lt;a href=&quot;#gettext.NullTranslations.gettext&quot;&gt;&lt;code&gt;gettext()&lt;/code&gt;&lt;/a&gt; method. Otherwise, the &lt;em&gt;message&lt;/em&gt; id is returned.</source>
          <target state="translated">위 봐 &lt;em&gt;메시지&lt;/em&gt; 카탈로그에 ID를하고 유니 코드 문자열로, 해당 메시지 문자열을 반환합니다. 카탈로그에 &lt;em&gt;메시지&lt;/em&gt; ID에 대한 항목이없고 폴 백이 설정된 경우 조회는 &lt;a href=&quot;#gettext.NullTranslations.gettext&quot;&gt; &lt;code&gt;gettext()&lt;/code&gt; &lt;/a&gt; 메소드로 전달됩니다 . 그렇지 않으면 &lt;em&gt;메시지&lt;/em&gt; ID가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a556474e1ed457b70864b01a7298696a2ec2dd" translate="yes" xml:space="preserve">
          <source>Look up the codec for the given encoding and return its &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; class or factory function.</source>
          <target state="translated">주어진 인코딩에 대한 코덱을 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 해당 StreamReader 클래스 또는 팩토리 함수를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9d4ddc4438742263e3d5627291450220ce8cb31b" translate="yes" xml:space="preserve">
          <source>Look up the codec for the given encoding and return its &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; class or factory function.</source>
          <target state="translated">주어진 인코딩에 대한 코덱을 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 클래스 또는 팩토리 함수를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c84e896663516d28c7c27bb365ae80312c5e169f" translate="yes" xml:space="preserve">
          <source>Look up the codec for the given encoding and return its decoder function.</source>
          <target state="translated">주어진 인코딩에 대한 코덱을 찾고 디코더 기능을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb641b1a229c64cd02ce2ebfc05ae8a7c13b0596" translate="yes" xml:space="preserve">
          <source>Look up the codec for the given encoding and return its encoder function.</source>
          <target state="translated">주어진 인코딩에 대한 코덱을 찾아서 해당 인코더 기능을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3655c5a141ca4acde5ad365207e8691d73d266bf" translate="yes" xml:space="preserve">
          <source>Look up the codec for the given encoding and return its incremental decoder class or factory function.</source>
          <target state="translated">주어진 인코딩에 대한 코덱을 찾고 증분 디코더 클래스 또는 팩토리 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6cc163fdbcd56d75ce77c6d6d85dc890d18b4429" translate="yes" xml:space="preserve">
          <source>Look up the codec for the given encoding and return its incremental encoder class or factory function.</source>
          <target state="translated">주어진 인코딩에 대한 코덱을 찾아 증분 인코더 클래스 또는 팩토리 함수를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="78b595ac3ee12e89b27df3b7a98465df00426911" translate="yes" xml:space="preserve">
          <source>Looks up the codec info in the Python codec registry and returns a &lt;a href=&quot;#codecs.CodecInfo&quot;&gt;&lt;code&gt;CodecInfo&lt;/code&gt;&lt;/a&gt; object as defined below.</source>
          <target state="translated">Python 코덱 레지스트리에서 코덱 정보를 조회하고 아래 정의 된대로 &lt;a href=&quot;#codecs.CodecInfo&quot;&gt; &lt;code&gt;CodecInfo&lt;/code&gt; &lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="cf82cd9963518dc21fb6c641a8de40d76056d5d3" translate="yes" xml:space="preserve">
          <source>Lookup &lt;em&gt;name&lt;/em&gt; in the table and return a &lt;a href=&quot;#symtable.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">테이블에서 &lt;em&gt;이름&lt;/em&gt; 을 조회 하고 &lt;a href=&quot;#symtable.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4485ea3acbc6dbce3acdb006f3d986acb5ab231" translate="yes" xml:space="preserve">
          <source>LookupError</source>
          <target state="translated">LookupError</target>
        </trans-unit>
        <trans-unit id="630ea782b7785663fd9d4f73dba3d3c77a23c0bd" translate="yes" xml:space="preserve">
          <source>Lookups search the underlying mappings successively until a key is found. In contrast, writes, updates, and deletions only operate on the first mapping.</source>
          <target state="translated">조회는 키를 찾을 때까지 기본 매핑을 연속적으로 검색합니다. 반대로 쓰기, 업데이트 및 삭제는 첫 번째 매핑에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="153299db674345d8f2ca5d3d4f9e8e37247d6bf3" translate="yes" xml:space="preserve">
          <source>Loop over the format_string and return an iterable of tuples (&lt;em&gt;literal_text&lt;/em&gt;, &lt;em&gt;field_name&lt;/em&gt;, &lt;em&gt;format_spec&lt;/em&gt;, &lt;em&gt;conversion&lt;/em&gt;). This is used by &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt; to break the string into either literal text, or replacement fields.</source>
          <target state="translated">format_string을 반복하고 튜플의 iterable ( &lt;em&gt;literal_text&lt;/em&gt; , &lt;em&gt;field_name&lt;/em&gt; , &lt;em&gt;format_spec&lt;/em&gt; , &lt;em&gt;conversion&lt;/em&gt; )을 리턴하십시오 . 이것은 &lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt; 에서 문자열을 리터럴 텍스트 또는 대체 필드로 나누는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="817f983a7edb7dba44fd8f3324b46953d7169631" translate="yes" xml:space="preserve">
          <source>Low highlight</source>
          <target state="translated">낮은 하이라이트</target>
        </trans-unit>
        <trans-unit id="127b603a1ef011bb89cc88a210069e24596383d1" translate="yes" xml:space="preserve">
          <source>Low level interface to kevent</source>
          <target state="translated">kevent에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="2eb47f09ef951de4242da56b37e0a0774375475b" translate="yes" xml:space="preserve">
          <source>Low median of data.</source>
          <target state="translated">중앙값이 낮습니다.</target>
        </trans-unit>
        <trans-unit id="8780223be91d8d1f6aff0eae226f7e6a9f597e78" translate="yes" xml:space="preserve">
          <source>Low-level API Index</source>
          <target state="translated">저수준 API 색인</target>
        </trans-unit>
        <trans-unit id="b38b638f8a783319921b9ded343024596436ca9a" translate="yes" xml:space="preserve">
          <source>Low-level APIs</source>
          <target state="translated">저수준 API</target>
        </trans-unit>
        <trans-unit id="8b09ad35d513c57449768a8b41dddbe56fe84f67" translate="yes" xml:space="preserve">
          <source>Low-level I/O multiplexing module.</source>
          <target state="translated">저수준 I / O 멀티플렉싱 모듈.</target>
        </trans-unit>
        <trans-unit id="598bc2f6658057b428f7e2f3e606eae47ac8e6d8" translate="yes" xml:space="preserve">
          <source>Low-level methods corresponding to the standard SMTP/ESMTP commands &lt;code&gt;HELP&lt;/code&gt;, &lt;code&gt;RSET&lt;/code&gt;, &lt;code&gt;NOOP&lt;/code&gt;, &lt;code&gt;MAIL&lt;/code&gt;, &lt;code&gt;RCPT&lt;/code&gt;, and &lt;code&gt;DATA&lt;/code&gt; are also supported. Normally these do not need to be called directly, so they are not documented here. For details, consult the module code.</source>
          <target state="translated">표준 SMTP / ESMTP 명령 &lt;code&gt;HELP&lt;/code&gt; , &lt;code&gt;RSET&lt;/code&gt; , &lt;code&gt;NOOP&lt;/code&gt; , &lt;code&gt;MAIL&lt;/code&gt; , &lt;code&gt;RCPT&lt;/code&gt; 및 &lt;code&gt;DATA&lt;/code&gt; 에 해당하는 저수준 방법 도 지원됩니다. 일반적으로 이들은 직접 호출 할 필요가 없으므로 여기에 설명되어 있지 않습니다. 자세한 내용은 모듈 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="26766bff9d94e6567e710b2fea4f1511b662ea0d" translate="yes" xml:space="preserve">
          <source>Low-level terminal control interface.</source>
          <target state="translated">저수준 터미널 제어 인터페이스.</target>
        </trans-unit>
        <trans-unit id="3037eb1a5f56e2da85ac8efecced594163214b23" translate="yes" xml:space="preserve">
          <source>Low-level time related functions.</source>
          <target state="translated">저수준 시간 관련 기능.</target>
        </trans-unit>
        <trans-unit id="d9dd367f9bd9200fa80c2b2e15b69f5c2fd12a8e" translate="yes" xml:space="preserve">
          <source>Low-level transport abstraction over subprocesses. Returned by &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_shell&quot;&gt;&lt;code&gt;loop.subprocess_shell()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">하위 프로세스에 대한 저수준 전송 추상화 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_shell&quot;&gt; &lt;code&gt;loop.subprocess_shell()&lt;/code&gt; &lt;/a&gt; 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="173e5fb322f03059e57865273bd7201fd7a87b77" translate="yes" xml:space="preserve">
          <source>Lower left of keypad</source>
          <target state="translated">키패드의 왼쪽 하단</target>
        </trans-unit>
        <trans-unit id="1122f5f9b82dc0f050f315c32b632f532a7d070a" translate="yes" xml:space="preserve">
          <source>Lower right of keypad</source>
          <target state="translated">키패드의 오른쪽 하단</target>
        </trans-unit>
        <trans-unit id="30c535ddb40e2b13bc291a7dfa8a8275334e95e7" translate="yes" xml:space="preserve">
          <source>Lowercase ASCII characters are those byte values in the sequence &lt;code&gt;b'abcdefghijklmnopqrstuvwxyz'&lt;/code&gt;. Uppercase ASCII characters are those byte values in the sequence &lt;code&gt;b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt;.</source>
          <target state="translated">소문자 ASCII 문자는 시퀀스 &lt;code&gt;b'abcdefghijklmnopqrstuvwxyz'&lt;/code&gt; 의 바이트 값입니다 . 대문자 ASCII 문자는 시퀀스 &lt;code&gt;b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt; 의 바이트 값입니다 .</target>
        </trans-unit>
        <trans-unit id="50b863a5a287224249b5146b1cb8597ee4786665" translate="yes" xml:space="preserve">
          <source>Lowercase ASCII characters are those byte values in the sequence &lt;code&gt;b'abcdefghijklmnopqrstuvwxyz'&lt;/code&gt;. Uppercase ASCII characters are those byte values in the sequence &lt;code&gt;b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt;. All other byte values are uncased.</source>
          <target state="translated">소문자 ASCII 문자는 시퀀스 &lt;code&gt;b'abcdefghijklmnopqrstuvwxyz'&lt;/code&gt; 의 바이트 값입니다 . 대문자 ASCII 문자는 시퀀스 &lt;code&gt;b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt; 의 바이트 값입니다 . 다른 모든 바이트 값은 uncased입니다.</target>
        </trans-unit>
        <trans-unit id="2d097e417a0011309b9e3799cef284519c47f119" translate="yes" xml:space="preserve">
          <source>M. Matsumoto and T. Nishimura, &amp;ldquo;Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator&amp;rdquo;, ACM Transactions on Modeling and Computer Simulation Vol. 8, No. 1, January pp.3&amp;ndash;30 1998.</source>
          <target state="translated">M. Matsumoto와 T. Nishimura,&amp;ldquo;Mersenne Twister : 623 차원으로 균일하게 분포 된 균일 한 의사 난수 생성기&amp;rdquo;, ACM의 모델링 및 컴퓨터 시뮬레이션 Vol. 8 월 1 일 1 월 pp. 3&amp;ndash;30 1998.</target>
        </trans-unit>
        <trans-unit id="f9326dba9c79149b2bfa04e09a817e946200edd7" translate="yes" xml:space="preserve">
          <source>MADV_* Constants</source>
          <target state="translated">MADV_ * 상수</target>
        </trans-unit>
        <trans-unit id="0d8e8b084c29a8155c26beb49eacf204d8ae1d30" translate="yes" xml:space="preserve">
          <source>MAIL</source>
          <target state="translated">MAIL</target>
        </trans-unit>
        <trans-unit id="83f776c9895fa9933e9c8f01b0f9175fe4aba8f4" translate="yes" xml:space="preserve">
          <source>MH &amp;amp; nmh: Email for Users &amp;amp; Programmers</source>
          <target state="translated">MH 및 nmh : 사용자 및 프로그래머를위한 이메일</target>
        </trans-unit>
        <trans-unit id="bfb78b95660e8a4437c74324bc0e18e512f5e11a" translate="yes" xml:space="preserve">
          <source>MH is a directory-based mailbox format invented for the MH Message Handling System, a mail user agent. Each message in an MH mailbox resides in its own file. An MH mailbox may contain other MH mailboxes (called &lt;em&gt;folders&lt;/em&gt;) in addition to messages. Folders may be nested indefinitely. MH mailboxes also support &lt;em&gt;sequences&lt;/em&gt;, which are named lists used to logically group messages without moving them to sub-folders. Sequences are defined in a file called &lt;code&gt;.mh_sequences&lt;/code&gt; in each folder.</source>
          <target state="translated">MH는 메일 사용자 에이전트 인 MH 메시지 처리 시스템을 위해 고안된 디렉토리 기반 사서함 형식입니다. MH 사서함의 각 메시지는 자체 파일에 있습니다. MH 사서함에는 메시지 외에 다른 MH 사서함 ( &lt;em&gt;폴더&lt;/em&gt; 라고 함)이 포함될 수 있습니다 . 폴더는 무기한 중첩 될 수 있습니다. MH 메일 함은 또한 메시지를 하위 폴더로 이동하지 않고 논리적으로 그룹화하는 데 사용되는 명명 된 목록 인 &lt;em&gt;시퀀스&lt;/em&gt; 를 지원 &lt;em&gt;합니다&lt;/em&gt; . 시퀀스는 각 폴더의 &lt;code&gt;.mh_sequences&lt;/code&gt; 파일에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c05b8eba754105622f4f66f9c667c959eac038c" translate="yes" xml:space="preserve">
          <source>MH messages do not support marks or flags in the traditional sense, but they do support sequences, which are logical groupings of arbitrary messages. Some mail reading programs (although not the standard &lt;strong&gt;mh&lt;/strong&gt; and &lt;strong&gt;nmh&lt;/strong&gt;) use sequences in much the same way flags are used with other formats, as follows:</source>
          <target state="translated">MH 메시지는 전통적인 의미에서 마크 또는 플래그를 지원하지 않지만 임의 메시지의 논리적 그룹 인 시퀀스를 지원합니다. 일부 메일 읽기 프로그램 (표준 &lt;strong&gt;mh&lt;/strong&gt; 및 &lt;strong&gt;nmh는 아님&lt;/strong&gt; )은 다음과 같이 플래그를 다른 형식과 함께 사용하는 것과 같은 방식으로 시퀀스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="65da9389c1a77e41f94256ff46e83b4558f0d2c0" translate="yes" xml:space="preserve">
          <source>MIME headers all start with the prefix &amp;lsquo;Content-&amp;lsquo;. Each specific header has a certain value, described under the class for that header. Some can also take a list of supplemental parameters, which have a common format. This class serves as a base for all the MIME headers that take parameters.</source>
          <target state="translated">MIME 헤더는 모두 접두사 'Content-'로 시작합니다. 각 특정 헤더에는 해당 헤더의 클래스 아래에 설명 된 특정 값이 있습니다. 일부는 공통 형식을 가진 보충 매개 변수 목록을 취할 수도 있습니다. 이 클래스는 매개 변수를 사용하는 모든 MIME 헤더의 기반으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e780567389e1a67ac39a9aa3a2da100125cc437a" translate="yes" xml:space="preserve">
          <source>MIMEVersionHeader</source>
          <target state="translated">MIMEVersionHeader</target>
        </trans-unit>
        <trans-unit id="ac2781a30c636477d2571979c4dc8ae62e55b4a1" translate="yes" xml:space="preserve">
          <source>MMDF</source>
          <target state="translated">MMDF</target>
        </trans-unit>
        <trans-unit id="66116c893240b072c88886bdaaa797c52d0bc63e" translate="yes" xml:space="preserve">
          <source>MMDF is a single-file mailbox format invented for the Multichannel Memorandum Distribution Facility, a mail transfer agent. Each message is in the same form as an mbox message but is bracketed before and after by lines containing four Control-A (&lt;code&gt;'\001'&lt;/code&gt;) characters. As with the mbox format, the beginning of each message is indicated by a line whose first five characters are &amp;ldquo;From &amp;ldquo;, but additional occurrences of &amp;ldquo;From &amp;rdquo; are not transformed to &amp;ldquo;&amp;gt;From &amp;rdquo; when storing messages because the extra message separator lines prevent mistaking such occurrences for the starts of subsequent messages.</source>
          <target state="translated">MMDF는 메일 전송 에이전트 인 Multichannel Memorandum Distribution Facility를 위해 개발 된 단일 파일 사서함 형식입니다. 각 메시지는 mbox 메시지와 같은 형식이지만 4 개의 Control-A ( &lt;code&gt;'\001'&lt;/code&gt; ) 문자를 포함하는 줄로 앞뒤에 괄호로 묶습니다 . mbox 형식과 마찬가지로, 각 메시지의 시작은 첫 5 개의 문자가 &quot;From&quot;인 행으로 표시되지만 추가 메시지 구분선이 방해하기 때문에 메시지를 저장할 때 추가 &quot;From&quot;은 &quot;&amp;gt; From&quot;으로 변환되지 않습니다. 후속 메시지의 시작에 대해 이러한 발생을 착각합니다.</target>
        </trans-unit>
        <trans-unit id="5481121da443813ed3ac24e7900056c8bc0a3492" translate="yes" xml:space="preserve">
          <source>MS Windows</source>
          <target state="translated">MS 윈도우</target>
        </trans-unit>
        <trans-unit id="7603491c0dcf610a151e7e878f3e66902074b1e1" translate="yes" xml:space="preserve">
          <source>MS Windows Specific Services</source>
          <target state="translated">MS Windows 전용 서비스</target>
        </trans-unit>
        <trans-unit id="6f96f1c42882c7292e1fca57e1b53cd688b380b1" translate="yes" xml:space="preserve">
          <source>Mac OS Platform</source>
          <target state="translated">맥 OS 플랫폼</target>
        </trans-unit>
        <trans-unit id="7bd9422fbcc45a81bb4afd061a341076dea802f9" translate="yes" xml:space="preserve">
          <source>Mac OS X can return:</source>
          <target state="translated">Mac OS X은 다음을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ff28b996370a24ecb0833ef2246817e7ffb3e42" translate="yes" xml:space="preserve">
          <source>Machine is not on the network</source>
          <target state="translated">컴퓨터가 네트워크에 없습니다</target>
        </trans-unit>
        <trans-unit id="bf55ab1cf5927f19f45290600b680716e5e32f16" translate="yes" xml:space="preserve">
          <source>Magenta (purplish red)</source>
          <target state="translated">자홍 (자홍색)</target>
        </trans-unit>
        <trans-unit id="32c97d0530e5003fff0bec696fd2fde110dbea71" translate="yes" xml:space="preserve">
          <source>Magic Mock</source>
          <target state="translated">매직 모의</target>
        </trans-unit>
        <trans-unit id="ba97bef2f5190237815682cb5c24de6d99b343b8" translate="yes" xml:space="preserve">
          <source>Magic methods &lt;em&gt;should&lt;/em&gt; be looked up on the class rather than the instance. Different versions of Python are inconsistent about applying this rule. The supported protocol methods should work with all supported versions of Python.</source>
          <target state="translated">매직 메소드 &lt;em&gt;는&lt;/em&gt; 인스턴스가 아닌 클래스에서 &lt;em&gt;찾아야&lt;/em&gt; 합니다. 이 규칙을 적용하는 데 다른 버전의 Python이 일치하지 않습니다. 지원되는 프로토콜 메소드는 지원되는 모든 버전의 Python에서 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="b04bd0c1375cb0c437085dcd22b5d776344cd11e" translate="yes" xml:space="preserve">
          <source>Magic methods that are supported but not setup by default in &lt;code&gt;MagicMock&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;MagicMock&lt;/code&gt; 에서 지원되지만 기본적으로 설정되지 않은 매직 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a1c07f78b75414a75fc974ca16b8c197d751801" translate="yes" xml:space="preserve">
          <source>MagicMock and magic method support</source>
          <target state="translated">MagicMock 및 매직 메소드 지원</target>
        </trans-unit>
        <trans-unit id="528cb2c5c793842fe4f6bbd5e875eb9ace62e872" translate="yes" xml:space="preserve">
          <source>Mailbox objects</source>
          <target state="translated">사서함 개체</target>
        </trans-unit>
        <trans-unit id="86634cd900d76e4a94c7afdeafd4189dde9eb547" translate="yes" xml:space="preserve">
          <source>Mailcap files are used to configure how MIME-aware applications such as mail readers and Web browsers react to files with different MIME types. (The name &amp;ldquo;mailcap&amp;rdquo; is derived from the phrase &amp;ldquo;mail capability&amp;rdquo;.) For example, a mailcap file might contain a line like &lt;code&gt;video/mpeg; xmpeg %s&lt;/code&gt;. Then, if the user encounters an email message or Web document with the MIME type &lt;em&gt;video/mpeg&lt;/em&gt;, &lt;code&gt;%s&lt;/code&gt; will be replaced by a filename (usually one belonging to a temporary file) and the &lt;strong&gt;xmpeg&lt;/strong&gt; program can be automatically started to view the file.</source>
          <target state="translated">Mailcap 파일은 메일 리더 및 웹 브라우저와 같은 MIME 인식 응용 프로그램이 다른 MIME 유형의 파일에 반응하는 방식을 구성하는 데 사용됩니다. 예를 들어, mailcap 파일은 &lt;code&gt;video/mpeg; xmpeg %s&lt;/code&gt; 와 같은 줄을 포함 할 수 있습니다 . xmpeg % s . 그런 다음 사용자에게 MIME 유형이 &lt;em&gt;video / mpeg&lt;/em&gt; 인 전자 메일 메시지 또는 웹 문서가 표시 되면 &lt;code&gt;%s&lt;/code&gt; 는 파일 이름 (일반적으로 임시 파일에 속하는 파일 이름)으로 &lt;strong&gt;바뀌고 xmpeg&lt;/strong&gt; 프로그램을 자동으로 시작하여 파일을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="451a9be697ddead11775c85e4cdec2e8e1e7fccf" translate="yes" xml:space="preserve">
          <source>Maildir is a directory-based mailbox format invented for the qmail mail transfer agent and now widely supported by other programs. Messages in a Maildir mailbox are stored in separate files within a common directory structure. This design allows Maildir mailboxes to be accessed and modified by multiple unrelated programs without data corruption, so file locking is unnecessary.</source>
          <target state="translated">Maildir은 qmail 메일 전송 에이전트 용으로 개발되었으며 현재 다른 프로그램에서 널리 지원되는 디렉토리 기반 사서함 형식입니다. Maildir 메일함에있는 메시지는 공통 디렉토리 구조 내에서 별도의 파일에 저장됩니다. 이 디자인을 사용하면 데이터 손상없이 여러 관련없는 프로그램이 Maildir 사서함에 액세스하고 수정할 수 있으므로 파일 잠금이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b40e5216a6cda56e75561046f7fd7ba0f11c7e63" translate="yes" xml:space="preserve">
          <source>Maildir mailboxes contain three subdirectories, namely: &lt;code&gt;tmp&lt;/code&gt;, &lt;code&gt;new&lt;/code&gt;, and &lt;code&gt;cur&lt;/code&gt;. Messages are created momentarily in the &lt;code&gt;tmp&lt;/code&gt; subdirectory and then moved to the &lt;code&gt;new&lt;/code&gt; subdirectory to finalize delivery. A mail user agent may subsequently move the message to the &lt;code&gt;cur&lt;/code&gt; subdirectory and store information about the state of the message in a special &amp;ldquo;info&amp;rdquo; section appended to its file name.</source>
          <target state="translated">Maildir 메일 박스에는 세 개의 서브 디렉토리, 즉 &lt;code&gt;tmp&lt;/code&gt; , &lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;cur&lt;/code&gt; 가 있습니다. 메시지는 &lt;code&gt;tmp&lt;/code&gt; 서브 디렉토리에 잠시 작성된 후 전달을 완료 하기 위해 &lt;code&gt;new&lt;/code&gt; 서브 디렉토리 로 이동됩니다 . 메일 사용자 에이전트는 이후 메시지를 &lt;code&gt;cur&lt;/code&gt; 서브 디렉토리 로 이동하고 메시지 상태에 대한 정보를 파일 이름에 추가 된 특수한 &quot;정보&quot;섹션에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71f497ebb214b9ce15eb874a873e5a71df6ed9c7" translate="yes" xml:space="preserve">
          <source>Maildir mailboxes do not support (or require) locking, so these methods do nothing.</source>
          <target state="translated">Maildir 사서함은 잠금을 지원하지 않거나 필요로하지 않으므로 이러한 방법은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc72f9949f161493c90aa33b348af41b8717a0cf" translate="yes" xml:space="preserve">
          <source>MailmanProxy Objects</source>
          <target state="translated">MailmanProxy 객체</target>
        </trans-unit>
        <trans-unit id="e4e1dbd94f7dcdd2adca3669f8c832e535d92107" translate="yes" xml:space="preserve">
          <source>Main module explicit relative imports</source>
          <target state="translated">메인 모듈 명시 적 상대 수입</target>
        </trans-unit>
        <trans-unit id="a63ee5a0ffd4ee7e4f1505d1af22daf8da80898f" translate="yes" xml:space="preserve">
          <source>Main options</source>
          <target state="translated">주요 옵션</target>
        </trans-unit>
        <trans-unit id="29c2fbf90a10af24cbd4c4648db9d6379273181c" translate="yes" xml:space="preserve">
          <source>Mainly because of backwards compatibility concerns, &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; provides also a legacy API with explicit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; methods. While there are valid use cases for the methods outlined below, mapping protocol access is preferred for new projects. The legacy API is at times more advanced, low-level and downright counterintuitive.</source>
          <target state="translated">주로 이전 버전과의 호환성 문제로 인해 &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 는 명시적인 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 메소드가 있는 레거시 API도 제공 합니다. 아래에 설명 된 방법에 대한 유효한 사용 사례가 있지만 새 프로젝트에는 프로토콜 액세스 매핑이 선호됩니다. 레거시 API는 때때로 고급, 저수준 및 완전히 반 직관적입니다.</target>
        </trans-unit>
        <trans-unit id="4823e55cd98dad58bd2be122640b91ad2d5ed814" translate="yes" xml:space="preserve">
          <source>Major cross-platform (Windows, Mac OS X, Unix-like) GUI toolkits are available for Python:</source>
          <target state="translated">Python에 주요 크로스 플랫폼 (Windows, Mac OS X, Unix 계열) GUI 툴킷을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d238209c2cada151fcd2a72d589d9730730983" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt; and case-insensitive matching dependent on the current locale. This flag can be used only with bytes patterns. The use of this flag is discouraged as the locale mechanism is very unreliable, it only handles one &amp;ldquo;culture&amp;rdquo; at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages. Corresponds to the inline flag &lt;code&gt;(?L)&lt;/code&gt;.</source>
          <target state="translated">제조사 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; 와 현재 지역에 따라 대소 문자를 구별하지 않는다. 이 플래그는 바이트 패턴에만 사용할 수 있습니다. 로케일 메커니즘이 매우 신뢰할 수 없으므로 한 번에 하나의 &quot;문화&quot;만 처리하며 8 비트 로케일에서만 작동하므로이 플래그를 사용하지 않는 것이 좋습니다. 유니 코드 매칭은 파이썬 3에서 유니 코드 (str) 패턴에 대해 기본적으로 이미 활성화되어 있으며 다른 로케일 / 언어를 처리 할 수 ​​있습니다. 인라인 플래그 &lt;code&gt;(?L)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4094168c6f13dde8d4a1402e6d2e892f00c22016" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt; and &lt;code&gt;\S&lt;/code&gt; perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns. Corresponds to the inline flag &lt;code&gt;(?a)&lt;/code&gt;.</source>
          <target state="translated">제조사 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 &lt;code&gt;\S&lt;/code&gt; ASCII 전용 유니 코드 정합 대신 매칭 수행한다. 이것은 유니 코드 패턴에서만 의미가 있으며 바이트 패턴에서는 무시됩니다. 인라인 플래그 &lt;code&gt;(?a)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2859945e3ed955c0801940559aa8f2fa3e430461" translate="yes" xml:space="preserve">
          <source>Make an entry into the &lt;code&gt;ControlCondition&lt;/code&gt; table for this control.</source>
          <target state="translated">이 컨트롤 의 &lt;code&gt;ControlCondition&lt;/code&gt; 테이블에 항목을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e78f1ddb4700c5c26bc5d606246d4a1ea1478dca" translate="yes" xml:space="preserve">
          <source>Make an entry into the &lt;code&gt;ControlEvent&lt;/code&gt; table for this control.</source>
          <target state="translated">이 컨트롤 의 &lt;code&gt;ControlEvent&lt;/code&gt; 테이블에 항목을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="22e44c261988ea1b3403fdf3cfd43ae89d29b9c4" translate="yes" xml:space="preserve">
          <source>Make an entry into the &lt;code&gt;EventMapping&lt;/code&gt; table for this control.</source>
          <target state="translated">이 컨트롤 의 &lt;code&gt;EventMapping&lt;/code&gt; 테이블에 항목을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4968d67864606429422562e4bfe072750713dd88" translate="yes" xml:space="preserve">
          <source>Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to:</source>
          <target state="translated">반복자가 iterable에서 요소를 리턴하고 각 사본을 저장하도록하십시오. iterable이 소진되면 저장된 사본에서 요소를 리턴하십시오. 무기한 반복합니다. 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9ae1a5a9224338d48d85639bd5fbf1307db3d17" translate="yes" xml:space="preserve">
          <source>Make an iterator that aggregates elements from each of the iterables.</source>
          <target state="translated">각 반복 가능한 요소에서 요소를 집계하는 반복자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4ecc79480f8b7a91f54bcaea359c899bb7d5a944" translate="yes" xml:space="preserve">
          <source>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with &lt;em&gt;fillvalue&lt;/em&gt;. Iteration continues until the longest iterable is exhausted. Roughly equivalent to:</source>
          <target state="translated">각 반복 가능한 요소에서 요소를 집계하는 반복자를 작성하십시오. &lt;em&gt;이터 러블의&lt;/em&gt; 길이가 고르지 않으면 누락 된 값이 &lt;em&gt;fillvalue&lt;/em&gt; 로 채워 &lt;em&gt;집니다&lt;/em&gt; . 가장 긴 iterable이 소진 될 때까지 반복이 계속됩니다. 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6d54f93918e62244f26c512e7a161b6bca8eb5a" translate="yes" xml:space="preserve">
          <source>Make an iterator that computes the function using arguments obtained from the iterable. Used instead of &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; when argument parameters are already grouped in tuples from a single iterable (the data has been &amp;ldquo;pre-zipped&amp;rdquo;). The difference between &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#itertools.starmap&quot;&gt;&lt;code&gt;starmap()&lt;/code&gt;&lt;/a&gt; parallels the distinction between &lt;code&gt;function(a,b)&lt;/code&gt; and &lt;code&gt;function(*c)&lt;/code&gt;. Roughly equivalent to:</source>
          <target state="translated">iterable에서 얻은 인수를 사용하여 함수를 계산하는 반복자를 만듭니다. 인수 매개 변수가 이미 단일 iterable의 튜플로 그룹화되어있을 때 &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 대신 사용됩니다 (데이터가&amp;ldquo;미리 압축 된&amp;rdquo;). 차이 &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#itertools.starmap&quot;&gt; &lt;code&gt;starmap()&lt;/code&gt; &lt;/a&gt; 의 차이 평행 &lt;code&gt;function(a,b)&lt;/code&gt; 및 &lt;code&gt;function(*c)&lt;/code&gt; . 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c96615ae41b720b59370f4efd4451ca2077afbf" translate="yes" xml:space="preserve">
          <source>Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce &lt;em&gt;any&lt;/em&gt; output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to:</source>
          <target state="translated">술어가 true 인 한 iterable에서 요소를 삭제하는 반복자를 작성하십시오. 그 후 모든 요소를 ​​반환합니다. 참고 반복자는 생성하지 않습니다 &lt;em&gt;어떤&lt;/em&gt; 술어가 먼저 거짓이 될 때까지이 긴 시동 시간을 가질 수 있도록 출력을. 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="892281d3f769ea7deb689777f71449bced9b383a" translate="yes" xml:space="preserve">
          <source>Make an iterator that filters elements from &lt;em&gt;data&lt;/em&gt; returning only those that have a corresponding element in &lt;em&gt;selectors&lt;/em&gt; that evaluates to &lt;code&gt;True&lt;/code&gt;. Stops when either the &lt;em&gt;data&lt;/em&gt; or &lt;em&gt;selectors&lt;/em&gt; iterables has been exhausted. Roughly equivalent to:</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 평가 되는 &lt;em&gt;선택자에&lt;/em&gt; 해당 요소가있는 요소 만 리턴하는 &lt;em&gt;데이터&lt;/em&gt; 에서 요소를 필터링하는 반복자를 작성하십시오 . &lt;em&gt;데이터&lt;/em&gt; 또는 &lt;em&gt;선택기&lt;/em&gt; 이터 러블이 소진되면 중지합니다 . 대략 다음과 같습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ffb72f4d4622e4e02475b473a321a110e46112f1" translate="yes" xml:space="preserve">
          <source>Make an iterator that filters elements from iterable returning only those for which the predicate is &lt;code&gt;False&lt;/code&gt;. If &lt;em&gt;predicate&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, return the items that are false. Roughly equivalent to:</source>
          <target state="translated">술어가 &lt;code&gt;False&lt;/code&gt; 인 요소 만 리턴하여 반복 가능한 요소를 필터링하는 반복자를 작성하십시오 . &lt;em&gt;술어&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 , 거짓 인 항목을 리턴하십시오. 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a957feb62063c86973f86240f6f0031887c5e9cb" translate="yes" xml:space="preserve">
          <source>Make an iterator that returns &lt;em&gt;object&lt;/em&gt; over and over again. Runs indefinitely unless the &lt;em&gt;times&lt;/em&gt; argument is specified. Used as argument to &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; for invariant parameters to the called function. Also used with &lt;a href=&quot;functions#zip&quot;&gt;&lt;code&gt;zip()&lt;/code&gt;&lt;/a&gt; to create an invariant part of a tuple record.</source>
          <target state="translated">반복해서 &lt;em&gt;객체&lt;/em&gt; 를 반환하는 반복자를 만듭니다 . &lt;em&gt;times&lt;/em&gt; 인수가 지정 되지 않으면 무한정 실행됩니다 . 불변 매개 변수에 대한 호출 된 함수에 대한 &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 인수로 사용됩니다 . &lt;a href=&quot;functions#zip&quot;&gt; &lt;code&gt;zip()&lt;/code&gt; &lt;/a&gt; 과 함께 사용 하여 튜플 레코드의 고정 부분을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5b008cc279ea80916bda0cbd332d0aa7ba0556ec" translate="yes" xml:space="preserve">
          <source>Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional &lt;em&gt;func&lt;/em&gt; argument).</source>
          <target state="translated">누적 합계 또는 다른 이진 함수의 누적 결과 (선택적 &lt;em&gt;func&lt;/em&gt; 인수 를 통해 지정)를 반환하는 반복자를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9f714338584f0b2134e7468a019823beae5537be" translate="yes" xml:space="preserve">
          <source>Make an iterator that returns consecutive keys and groups from the &lt;em&gt;iterable&lt;/em&gt;. The &lt;em&gt;key&lt;/em&gt; is a function computing a key value for each element. If not specified or is &lt;code&gt;None&lt;/code&gt;, &lt;em&gt;key&lt;/em&gt; defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function.</source>
          <target state="translated">&lt;em&gt;iterable&lt;/em&gt; 에서 연속 키와 그룹을 리턴하는 반복자를 작성하십시오 . &lt;em&gt;키는&lt;/em&gt; 각각의 요소에 대한 키 값을 계산하는 함수이다. 지정되지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;em&gt;키는&lt;/em&gt; 기본적으로 ID 함수로 설정되며 요소를 변경하지 않고 반환합니다. 일반적으로 iterable은 동일한 키 기능으로 이미 정렬되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="59c6932f4ea38a9adb405d00c88d62c4ce199417" translate="yes" xml:space="preserve">
          <source>Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to:</source>
          <target state="translated">첫 번째 iterable에서 요소가 소진 될 때까지 요소를 리턴하는 iterator를 작성하고 모든 iterables가 소진 될 때까지 다음 iterable로 진행하십시오. 연속 시퀀스를 단일 시퀀스로 처리하는 데 사용됩니다. 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db17bd2fa6e28e684f31b9a14e54b77456d66135" translate="yes" xml:space="preserve">
          <source>Make an iterator that returns elements from the iterable as long as the predicate is true. Roughly equivalent to:</source>
          <target state="translated">술어가 true 인 한 iterable에서 요소를 리턴하는 반복자를 작성하십시오. 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0843933413e67d1e5cac3980b5f29ff765b66dc1" translate="yes" xml:space="preserve">
          <source>Make an iterator that returns evenly spaced values starting with number &lt;em&gt;start&lt;/em&gt;. Often used as an argument to &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; to generate consecutive data points. Also, used with &lt;a href=&quot;functions#zip&quot;&gt;&lt;code&gt;zip()&lt;/code&gt;&lt;/a&gt; to add sequence numbers. Roughly equivalent to:</source>
          <target state="translated">number &lt;em&gt;start로&lt;/em&gt; 시작하여 균일 한 간격의 값을 반환하는 반복자를 만듭니다 . 연속적인 데이터 포인트를 생성 하기 위해 &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 에 대한 인수로 사용되는 경우가 많습니다 . 또한 시퀀스 번호를 추가하기 위해 &lt;a href=&quot;functions#zip&quot;&gt; &lt;code&gt;zip()&lt;/code&gt; &lt;/a&gt; 과 함께 사용됩니다 . 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4994f0ea994acf88c67fba065692eb6b5778a17e" translate="yes" xml:space="preserve">
          <source>Make an iterator that returns selected elements from the iterable. If &lt;em&gt;start&lt;/em&gt; is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless &lt;em&gt;step&lt;/em&gt; is set higher than one which results in items being skipped. If &lt;em&gt;stop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, &lt;a href=&quot;#itertools.islice&quot;&gt;&lt;code&gt;islice()&lt;/code&gt;&lt;/a&gt; does not support negative values for &lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, or &lt;em&gt;step&lt;/em&gt;. Can be used to extract related fields from data where the internal structure has been flattened (for example, a multi-line report may list a name field on every third line). Roughly equivalent to:</source>
          <target state="translated">이터 러블에서 선택된 요소를 반환하는 이터레이터를 만듭니다. &lt;em&gt;start&lt;/em&gt; 가 0이 아닌 경우 iterable의 요소는 시작에 도달 할 때까지 건너 뜁니다. 이후에 &lt;em&gt;step&lt;/em&gt; 이 1보다 높게 설정되어 항목을 건너 뛰지 않으면 요소가 연속적으로 반환 됩니다. 경우 &lt;em&gt;정지&lt;/em&gt; 하지 &lt;code&gt;None&lt;/code&gt; 반복자가 소진 될 때까지 전혀 있다면, 반복, 계속; 그렇지 않으면 지정된 위치에서 멈 춥니 다. 일반 슬라이싱과 달리 &lt;a href=&quot;#itertools.islice&quot;&gt; &lt;code&gt;islice()&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;start&lt;/em&gt; , &lt;em&gt;stop&lt;/em&gt; 또는 &lt;em&gt;step에&lt;/em&gt; 음수 값을 지원하지 않습니다.&lt;em&gt;&lt;/em&gt;. 내부 구조가 평탄화 된 데이터에서 관련 필드를 추출하는 데 사용할 수 있습니다 (예 : 여러 줄 보고서는 세 번째 줄마다 이름 필드를 나열 할 수 있음). 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="617ef530212f8cbf0f6f805993299c48051459de" translate="yes" xml:space="preserve">
          <source>Make sure &lt;em&gt;nframes&lt;/em&gt; is correct, and close the file if it was opened by &lt;a href=&quot;#module-wave&quot;&gt;&lt;code&gt;wave&lt;/code&gt;&lt;/a&gt;. This method is called upon object collection. It will raise an exception if the output stream is not seekable and &lt;em&gt;nframes&lt;/em&gt; does not match the number of frames actually written.</source>
          <target state="translated">&lt;em&gt;nframe&lt;/em&gt; 이 올바른지 확인 하고 파일을 &lt;a href=&quot;#module-wave&quot;&gt; &lt;code&gt;wave&lt;/code&gt; &lt;/a&gt; 로 연 경우 파일을 닫습니다 . 이 메소드는 객체 수집시 호출됩니다. 출력 스트림을 검색 할 수없고 &lt;em&gt;nframe&lt;/em&gt; 이 실제로 작성된 프레임 수와 일치하지 않으면 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="c69a4de6caa709ef6bb8a12e9677e657aca1ef6b" translate="yes" xml:space="preserve">
          <source>Make sure all possible values are tested including invalid ones. This makes sure that not only all valid values are acceptable but also that improper values are handled correctly.</source>
          <target state="translated">유효하지 않은 값을 포함하여 가능한 모든 값을 테스트하십시오. 이렇게하면 유효한 모든 값을 사용할 수있을뿐만 아니라 부적절한 값을 올바르게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a627b5bf841e1ea88d28165d37b866a0870f3704" translate="yes" xml:space="preserve">
          <source>Make sure that any files your script needs to read or write are readable or writable, respectively, by &amp;ldquo;others&amp;rdquo; &amp;mdash; their mode should be &lt;code&gt;0o644&lt;/code&gt; for readable and &lt;code&gt;0o666&lt;/code&gt; for writable. This is because, for security reasons, the HTTP server executes your script as user &amp;ldquo;nobody&amp;rdquo;, without any special privileges. It can only read (write, execute) files that everybody can read (write, execute). The current directory at execution time is also different (it is usually the server&amp;rsquo;s cgi-bin directory) and the set of environment variables is also different from what you get when you log in. In particular, don&amp;rsquo;t count on the shell&amp;rsquo;s search path for executables (&lt;code id=&quot;index-2&quot;&gt;PATH&lt;/code&gt;) or the Python module search path (&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;PYTHONPATH&lt;/code&gt;&lt;/a&gt;) to be set to anything interesting.</source>
          <target state="translated">스크립트가 읽거나 쓸 필요가있는 파일을 각각 &quot;기타&quot;로 읽을 수 있거나 쓰기 가능한지 확인하십시오. 읽을 수있는 모드는 &lt;code&gt;0o666&lt;/code&gt; 이고 쓰기 가능 하도록 &lt;code&gt;0o644&lt;/code&gt; 이어야합니다 . 이는 보안상의 이유로 HTTP 서버가 특별한 권한없이 스크립트를&amp;ldquo;nobody&amp;rdquo;사용자로 실행하기 때문입니다. 모든 사람이 읽을 수있는 (쓰기, 실행) 파일 만 읽을 수 있습니다 (쓰기, 실행). 실행시 현재 디렉토리도 다릅니다 (일반적으로 서버의 cgi-bin 디렉토리 임). 환경 변수 세트는 로그인 할 때 얻는 것과 다릅니다. 특히, 쉘의 검색 경로를 고려하지 마십시오. 실행 파일 ( &lt;code id=&quot;index-2&quot;&gt;PATH&lt;/code&gt; ) 또는 Python 모듈 검색 경로 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;PYTHONPATH&lt;/code&gt; &lt;/a&gt; )를 흥미로운 것으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5de2f6daf567300ef46271ec132a2987bda55e91" translate="yes" xml:space="preserve">
          <source>Make sure that the main module can be safely imported by a new Python interpreter without causing unintended side effects (such a starting a new process).</source>
          <target state="translated">의도하지 않은 부작용 (예 : 새로운 프로세스 시작)을 유발하지 않고 새로운 Python 인터프리터가 메인 모듈을 안전하게 가져올 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9731ad27072d870a7da69ae18e9bb36d5c3dbee3" translate="yes" xml:space="preserve">
          <source>Make sure that your script is readable and executable by &amp;ldquo;others&amp;rdquo;; the Unix file mode should be &lt;code&gt;0o755&lt;/code&gt; octal (use &lt;code&gt;chmod 0755 filename&lt;/code&gt;). Make sure that the first line of the script contains &lt;code&gt;#!&lt;/code&gt; starting in column 1 followed by the pathname of the Python interpreter, for instance:</source>
          <target state="translated">스크립트가 &quot;others&quot;에 의해 읽고 실행 가능한지 확인하십시오. 유닉스 파일 모드는 &lt;code&gt;0o755&lt;/code&gt; 8 진수 여야합니다 ( &lt;code&gt;chmod 0755 filename&lt;/code&gt; 사용 ). 스크립트의 첫 줄에 &lt;code&gt;#!&lt;/code&gt; 포함되어 있는지 확인하십시오 ! 예를 들어 1 열에서 시작하여 파이썬 인터프리터의 경로 이름 이옵니다.</target>
        </trans-unit>
        <trans-unit id="b965c16ca041ae1288bd1a67be9784d3d10d7ad4" translate="yes" xml:space="preserve">
          <source>Make sure the Python interpreter exists and is executable by &amp;ldquo;others&amp;rdquo;.</source>
          <target state="translated">Python 인터프리터가 존재하고 &quot;others&quot;에 의해 실행 가능한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cbab57598b799819458d4a0023b9d15232b16ecd" translate="yes" xml:space="preserve">
          <source>Make sure to clean up after your tests (such as close and remove all temporary files).</source>
          <target state="translated">테스트 후 정리하십시오 (예 : 모든 임시 파일 닫기 및 제거).</target>
        </trans-unit>
        <trans-unit id="c886a4dcc067f50183f6d9e536df375c4dda88c4" translate="yes" xml:space="preserve">
          <source>Make sure you keep references to &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt;&lt;code&gt;CFUNCTYPE()&lt;/code&gt;&lt;/a&gt; objects as long as they are used from C code. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t, and if you don&amp;rsquo;t, they may be garbage collected, crashing your program when a callback is made.</source>
          <target state="translated">C 코드에서 사용되는 한 &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt; &lt;code&gt;CFUNCTYPE()&lt;/code&gt; &lt;/a&gt; 객체에 대한 참조를 유지해야합니다 . &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 그렇지 않으며 콜백하지 않으면 가비지 수집되어 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d98adddef5c8372a92668121d843f7b67ce4928" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;'.'&lt;/code&gt; special character match any character at all, including a newline; without this flag, &lt;code&gt;'.'&lt;/code&gt; will match anything &lt;em&gt;except&lt;/em&gt; a newline. Corresponds to the inline flag &lt;code&gt;(?s)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'.'&lt;/code&gt; 를 만드십시오 . 특수 문자는 개행을 포함하여 모든 문자와 일치합니다. 이 플래그가 없으면 &lt;code&gt;'.'&lt;/code&gt; 개행을 &lt;em&gt;제외한&lt;/em&gt; 모든 항목과 일치 합니다. 인라인 플래그 &lt;code&gt;(?s)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1821d7bf0229ac06606d233650d7f9a8ac16a46b" translate="yes" xml:space="preserve">
          <source>Make the path absolute, resolving any symlinks. A new path object is returned:</source>
          <target state="translated">심볼릭 링크를 해결하여 경로를 절대적으로 만듭니다. 새로운 경로 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bb60557d6278b81f58c0e2a368efe17839683f2c" translate="yes" xml:space="preserve">
          <source>Make the turtle invisible. It&amp;rsquo;s a good idea to do this while you&amp;rsquo;re in the middle of doing some complex drawing, because hiding the turtle speeds up the drawing observably.</source>
          <target state="translated">거북이가 보이지 않게하십시오. 거북이를 숨기면 드로잉 속도가 눈에 띄게 빨라지므로 복잡한 드로잉을하는 동안이 작업을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8425653f95186dae7b16793ba9c5e6c775aa6fa7" translate="yes" xml:space="preserve">
          <source>Make the turtle visible.</source>
          <target state="translated">거북이가 보이게합니다.</target>
        </trans-unit>
        <trans-unit id="2b104edc6adc907e507b80dfe4df5940691e17d0" translate="yes" xml:space="preserve">
          <source>Make this feature the current feature of &lt;a href=&quot;#module-msilib&quot;&gt;&lt;code&gt;msilib&lt;/code&gt;&lt;/a&gt;. New components are automatically added to the default feature, unless a feature is explicitly specified.</source>
          <target state="translated">이 기능을 &lt;a href=&quot;#module-msilib&quot;&gt; &lt;code&gt;msilib&lt;/code&gt; &lt;/a&gt; 의 현재 기능으로 만드십시오 . 기능을 명시 적으로 지정하지 않으면 새 구성 요소가 기본 기능에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="817dde39e08bc70031f6cc0c99bde032f0727edc" translate="yes" xml:space="preserve">
          <source>Make this path a symbolic link to &lt;em&gt;target&lt;/em&gt;. Under Windows, &lt;em&gt;target_is_directory&lt;/em&gt; must be true (default &lt;code&gt;False&lt;/code&gt;) if the link&amp;rsquo;s target is a directory. Under POSIX, &lt;em&gt;target_is_directory&lt;/em&gt;&amp;rsquo;s value is ignored.</source>
          <target state="translated">이 경로를 &lt;em&gt;target에&lt;/em&gt; 대한 심볼릭 링크로 만드십시오 . Windows 에서 링크의 대상이 디렉토리 인 경우 &lt;em&gt;target_is_directory&lt;/em&gt; 는 true (기본값 &lt;code&gt;False&lt;/code&gt; ) 여야합니다 . POSIX에서는 &lt;em&gt;target_is_directory&lt;/em&gt; 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0589ca0705dbb10c03f08251a6b8ad92b9066e42" translate="yes" xml:space="preserve">
          <source>Makes a normal distribution instance with &lt;em&gt;mu&lt;/em&gt; and &lt;em&gt;sigma&lt;/em&gt; parameters estimated from the &lt;em&gt;data&lt;/em&gt; using &lt;a href=&quot;#statistics.fmean&quot;&gt;&lt;code&gt;fmean()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#statistics.stdev&quot;&gt;&lt;code&gt;stdev()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#statistics.fmean&quot;&gt; &lt;code&gt;fmean()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#statistics.stdev&quot;&gt; &lt;code&gt;stdev()&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;em&gt;데이터&lt;/em&gt; 에서 추정 된 &lt;em&gt;mu&lt;/em&gt; 및 &lt;em&gt;sigma&lt;/em&gt; 매개 변수를 사용하여 정규 분포 인스턴스를 만듭니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74478c83d77f7f9d3b16b8e25a30c78af412de6d" translate="yes" xml:space="preserve">
          <source>Making a Phonebook</source>
          <target state="translated">전화 번호부 만들기</target>
        </trans-unit>
        <trans-unit id="5c927175b3add69e1fe7dc7bfe7e29837fc73c90" translate="yes" xml:space="preserve">
          <source>Making a Windows executable</source>
          <target state="translated">Windows 실행 파일 만들기</target>
        </trans-unit>
        <trans-unit id="855506ce6753b0d9a5b09ffd99dfc10fa3696ea0" translate="yes" xml:space="preserve">
          <source>Manager Widgets</source>
          <target state="translated">관리자 위젯</target>
        </trans-unit>
        <trans-unit id="2a361c4c32a8b1dcdd56014985b930dd04f772a1" translate="yes" xml:space="preserve">
          <source>Manager processes will be shutdown as soon as they are garbage collected or their parent process exits. The manager classes are defined in the &lt;a href=&quot;#module-multiprocessing.managers&quot;&gt;&lt;code&gt;multiprocessing.managers&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">관리자 프로세스는 가비지 수집되거나 부모 프로세스가 종료되는 즉시 종료됩니다. 관리자 클래스는 &lt;a href=&quot;#module-multiprocessing.managers&quot;&gt; &lt;code&gt;multiprocessing.managers&lt;/code&gt; &lt;/a&gt; 모듈에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f7b3cfa4fbefb6a7d1086c0a97bc4ea23175a55" translate="yes" xml:space="preserve">
          <source>Managers</source>
          <target state="translated">Managers</target>
        </trans-unit>
        <trans-unit id="146be58ae4c0ee3d8c972415be0e7c22bae315f6" translate="yes" xml:space="preserve">
          <source>Managers provide a way to create data which can be shared between different processes, including sharing over a network between processes running on different machines. A manager object controls a server process which manages &lt;em&gt;shared objects&lt;/em&gt;. Other processes can access the shared objects by using proxies.</source>
          <target state="translated">관리자는 다른 시스템에서 실행되는 프로세스간에 네트워크를 통한 공유를 포함하여 다른 프로세스간에 공유 할 수있는 데이터를 작성하는 방법을 제공합니다. 관리자 객체는 &lt;em&gt;공유 객체&lt;/em&gt; 를 관리하는 서버 프로세스를 제어 &lt;em&gt;합니다&lt;/em&gt; . 다른 프로세스는 프록시를 사용하여 공유 객체에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da4dac0b16742ede0cd08c5d71857dc8b235645" translate="yes" xml:space="preserve">
          <source>Manual Context Management</source>
          <target state="translated">수동 컨텍스트 관리</target>
        </trans-unit>
        <trans-unit id="5be972ee604abf1abcdd9643e605d5e6677470aa" translate="yes" xml:space="preserve">
          <source>Manual settings</source>
          <target state="translated">수동 설정</target>
        </trans-unit>
        <trans-unit id="343daa0eb5e43f021e62c3c8801d5b10743a76d4" translate="yes" xml:space="preserve">
          <source>Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.</source>
          <target state="translated">Linux 문서에 문서화 된 이러한 형식의 많은 상수도 소켓 모듈에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a81759bd6fd007d62861d3fabb2bd9fbcb88bd" translate="yes" xml:space="preserve">
          <source>Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module. They are generally used in arguments to the &lt;code&gt;setsockopt()&lt;/code&gt; and &lt;code&gt;getsockopt()&lt;/code&gt; methods of socket objects. In most cases, only those symbols that are defined in the Unix header files are defined; for a few symbols, default values are provided.</source>
          <target state="translated">소켓 및 / 또는 IP 프로토콜에 대한 Unix 문서에 설명 된 이러한 형식의 많은 상수도 소켓 모듈에 정의되어 있습니다. 일반적으로 소켓 객체 의 &lt;code&gt;setsockopt()&lt;/code&gt; 및 &lt;code&gt;getsockopt()&lt;/code&gt; 메소드에 대한 인수로 사용 됩니다. 대부분의 경우 Unix 헤더 파일에 정의 된 기호 만 정의됩니다. 일부 기호의 경우 기본값이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="510dd560760442cac504a2b167911b6a0ab8aa23" translate="yes" xml:space="preserve">
          <source>Many non-threadsafe asyncio APIs (such as &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_at&quot;&gt;&lt;code&gt;loop.call_at()&lt;/code&gt;&lt;/a&gt; methods) raise an exception if they are called from a wrong thread.</source>
          <target state="translated">스레드로부터 안전하지 않은 많은 asyncio API (예 : &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_at&quot;&gt; &lt;code&gt;loop.call_at()&lt;/code&gt; &lt;/a&gt; 메서드)가 잘못된 스레드에서 호출되면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="815297a48147fd3991e217e62ae1a5520c0cbce5" translate="yes" xml:space="preserve">
          <source>Many of the above classes also have a &lt;code&gt;Unique&lt;/code&gt; variant (for example, &lt;code&gt;UniqueUnstructuredHeader&lt;/code&gt;). The only difference is that in the &lt;code&gt;Unique&lt;/code&gt; variant, &lt;a href=&quot;#email.headerregistry.BaseHeader.max_count&quot;&gt;&lt;code&gt;max_count&lt;/code&gt;&lt;/a&gt; is set to 1.</source>
          <target state="translated">위의 많은 클래스에는 &lt;code&gt;Unique&lt;/code&gt; 변형 (예 : &lt;code&gt;UniqueUnstructuredHeader&lt;/code&gt; )이 있습니다. &lt;code&gt;Unique&lt;/code&gt; 변형 은 고유 변형에서 &lt;a href=&quot;#email.headerregistry.BaseHeader.max_count&quot;&gt; &lt;code&gt;max_count&lt;/code&gt; &lt;/a&gt; 가 1로 설정되어 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2163dea9d3d8731a332014be1542cdabce604244" translate="yes" xml:space="preserve">
          <source>Many of the character sets support the same languages. They vary in individual characters (e.g. whether the EURO SIGN is supported or not), and in the assignment of characters to code positions. For the European languages in particular, the following variants typically exist:</source>
          <target state="translated">많은 문자 집합이 동일한 언어를 지원합니다. 개별 문자 (예 : EURO SIGN 지원 여부)와 코드 위치에 문자를 지정할 때마다 다릅니다. 특히 유럽 언어의 경우 일반적으로 다음과 같은 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ccfa60e5e5281ef43935b1343f2bf376660936" translate="yes" xml:space="preserve">
          <source>Many of the following methods take an optional keyword-only argument &lt;em&gt;file&lt;/em&gt;. When the &lt;em&gt;file&lt;/em&gt; argument is supplied, it must be either a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened for binary writing, or the name of an on-disk file to be written to. The method will then write any data returned by the server (except for the response line and the terminating dot) to the file; any list of lines, tuples or objects that the method normally returns will be empty.</source>
          <target state="translated">다음의 많은 메소드는 선택적 키워드 전용 인수 &lt;em&gt;파일을 사용합니다&lt;/em&gt; . 때 &lt;em&gt;파일&lt;/em&gt; 인수가 제공되고, 그것은이어야합니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 바이너리 쓰기 위해 열, 또는에 기록 할 수있는 디스크에있는 파일의 이름. 그런 다음이 메소드는 서버가 응답 행과 종료 점을 제외한 모든 데이터를 파일에 기록합니다. 메소드가 정상적으로 리턴하는 행, 튜플 또는 오브젝트 목록은 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa4bc0d6f566c5f847060ae6ead4557c906984b" translate="yes" xml:space="preserve">
          <source>Many of the not-very-useful (private to &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt; rather than the thing being mocked) underscore and double underscore prefixed attributes have been filtered from the result of calling &lt;a href=&quot;functions#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt;. If you dislike this behaviour you can switch it off by setting the module level switch &lt;a href=&quot;#unittest.mock.FILTER_DIR&quot;&gt;&lt;code&gt;FILTER_DIR&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">유용하지 않은 ( &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 아닌 Mock 전용 ) 밑줄 및 이중 밑줄 접두어 속성이 &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;functions#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 을 호출 한 결과에서 필터링되었습니다 . 이 동작이 마음에 들지 않으면 모듈 레벨 스위치 &lt;a href=&quot;#unittest.mock.FILTER_DIR&quot;&gt; &lt;code&gt;FILTER_DIR&lt;/code&gt; &lt;/a&gt; 을 설정하여 스위치를 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9a47225407eea7973acc57a86154fda62e2e8ed" translate="yes" xml:space="preserve">
          <source>Many operations have an &amp;ldquo;in-place&amp;rdquo; version. Listed below are functions providing a more primitive access to in-place operators than the usual syntax does; for example, the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-statement&quot;&gt;statement&lt;/a&gt;&lt;code&gt;x += y&lt;/code&gt; is equivalent to &lt;code&gt;x = operator.iadd(x, y)&lt;/code&gt;. Another way to put it is to say that &lt;code&gt;z = operator.iadd(x, y)&lt;/code&gt; is equivalent to the compound statement &lt;code&gt;z = x; z += y&lt;/code&gt;.</source>
          <target state="translated">많은 작업에는 &quot;제자리&quot;버전이 있습니다. 아래는 일반적인 구문보다 내부 연산자에 대한보다 기본적인 액세스를 제공하는 함수입니다. 예를 들어, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-statement&quot;&gt;명령문 &lt;/a&gt; &lt;code&gt;x += y&lt;/code&gt; 는 &lt;code&gt;x = operator.iadd(x, y)&lt;/code&gt; . 또 다른 방법은 &lt;code&gt;z = operator.iadd(x, y)&lt;/code&gt; 는 복합 명령문 &lt;code&gt;z = x; z += y&lt;/code&gt; 와 같다는 것입니다 . z + = y 입니다.</target>
        </trans-unit>
        <trans-unit id="0775e95d12acf1c76496fc0019dec4ccce66e92a" translate="yes" xml:space="preserve">
          <source>Many other operations also produce lists, including the &lt;a href=&quot;functions#sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; built-in.</source>
          <target state="translated">다른 많은 연산들도 &lt;a href=&quot;functions#sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 내장을 포함하여 목록을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="3892486ba2ca4c1adde5de5ad35763a15238b251" translate="yes" xml:space="preserve">
          <source>Many programs split up their functionality into a number of sub-commands, for example, the &lt;code&gt;svn&lt;/code&gt; program can invoke sub-commands like &lt;code&gt;svn
checkout&lt;/code&gt;, &lt;code&gt;svn update&lt;/code&gt;, and &lt;code&gt;svn commit&lt;/code&gt;. Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; supports the creation of such sub-commands with the &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt;&lt;code&gt;add_subparsers()&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt;&lt;code&gt;add_subparsers()&lt;/code&gt;&lt;/a&gt; method is normally called with no arguments and returns a special action object. This object has a single method, &lt;code&gt;add_parser()&lt;/code&gt;, which takes a command name and any &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; constructor arguments, and returns an &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; object that can be modified as usual.</source>
          <target state="translated">예를 들어, &lt;code&gt;svn&lt;/code&gt; 프로그램은 &lt;code&gt;svn checkout&lt;/code&gt; , &lt;code&gt;svn update&lt;/code&gt; 및 &lt;code&gt;svn commit&lt;/code&gt; 과 같은 하위 명령을 호출 할 수 있습니다 . 이 방법으로 기능을 분할하는 것은 프로그램이 다른 종류의 명령 줄 인수를 요구하는 여러 가지 다른 기능을 수행 할 때 특히 좋은 아이디어가 될 수 있습니다. &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt; &lt;code&gt;add_subparsers()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 이러한 하위 명령 작성을 지원합니다 . &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt; &lt;code&gt;add_subparsers()&lt;/code&gt; &lt;/a&gt; 메소드는 일반적으로 인수 및 반환 특별 조치 객체라고합니다. 이 객체에는 &lt;code&gt;add_parser()&lt;/code&gt; 단일 메소드 가 있으며 명령 이름과&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 생성자 인수를 사용하여평소대로 수정할 수있는&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 객체를반환합니다.</target>
        </trans-unit>
        <trans-unit id="842c3a3980d59e2ccc8a6587608bb5e288adaa34" translate="yes" xml:space="preserve">
          <source>Many sites disable SMTP &lt;code&gt;VRFY&lt;/code&gt; in order to foil spammers.</source>
          <target state="translated">많은 사이트 에서 스패머를 제거하기 위해 SMTP &lt;code&gt;VRFY&lt;/code&gt; 를 사용하지 않도록 설정 합니다 .</target>
        </trans-unit>
        <trans-unit id="84d090f9a4b10c8e70604e91d362e68e7d1715a8" translate="yes" xml:space="preserve">
          <source>Map character sets to their email properties.</source>
          <target state="translated">문자 세트를 이메일 특성에 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="7c158793b0576eb0e99170737dcf651e9b593ba3" translate="yes" xml:space="preserve">
          <source>Mapping Basic Tk into Tkinter</source>
          <target state="translated">기본 Tk를 Tkinter로 매핑</target>
        </trans-unit>
        <trans-unit id="29b99d5bba5dcab3d3f32602bec9b94930d68f31" translate="yes" xml:space="preserve">
          <source>Mapping Operators to Functions</source>
          <target state="translated">연산자를 함수에 매핑</target>
        </trans-unit>
        <trans-unit id="18d3adef974e9e8a9c707b5522d4ceef6e880500" translate="yes" xml:space="preserve">
          <source>Mapping Protocol Access</source>
          <target state="translated">매핑 프로토콜 액세스</target>
        </trans-unit>
        <trans-unit id="ebd82d89b582db2203963681055d49cb2fdde5e8" translate="yes" xml:space="preserve">
          <source>Mapping Types &amp;mdash; &lt;code&gt;dict&lt;/code&gt;</source>
          <target state="translated">매핑 유형 &amp;mdash; &lt;code&gt;dict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5781654b4505c67ba0da3a9924958b822ec242bc" translate="yes" xml:space="preserve">
          <source>Mapping Types &amp;mdash; dict</source>
          <target state="translated">매핑 유형 &amp;mdash; dict</target>
        </trans-unit>
        <trans-unit id="0bf0ef93e58f3620e84487a6484aef9dbeeb1def" translate="yes" xml:space="preserve">
          <source>Mapping class that references keys weakly. Entries in the dictionary will be discarded when there is no longer a strong reference to the key. This can be used to associate additional data with an object owned by other parts of an application without adding attributes to those objects. This can be especially useful with objects that override attribute accesses.</source>
          <target state="translated">키를 약하게 참조하는 매핑 클래스 더 이상 키에 대한 참조가 없으면 사전의 항목이 삭제됩니다. 이 속성을 사용하면 해당 객체에 속성을 추가하지 않고도 응용 프로그램의 다른 부분이 소유 한 객체와 추가 데이터를 연결할 수 있습니다. 이것은 속성 액세스를 재정의하는 객체에 특히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7046eea20884db0b40984559cdb957133a9a851" translate="yes" xml:space="preserve">
          <source>Mapping class that references values weakly. Entries in the dictionary will be discarded when no strong reference to the value exists any more.</source>
          <target state="translated">값을 약하게 참조하는 매핑 클래스 값에 대한 참조가 더 이상 존재하지 않으면 사전의 항목이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="15922488c98b6104b02093ae02b8e9a1520e3912" translate="yes" xml:space="preserve">
          <source>Mapping key (optional), consisting of a parenthesised sequence of characters (for example, &lt;code&gt;(somename)&lt;/code&gt;).</source>
          <target state="translated">괄호로 묶은 일련의 문자 (예 : &lt;code&gt;(somename)&lt;/code&gt; ) 로 구성된 맵핑 키 (선택 사항 ).</target>
        </trans-unit>
        <trans-unit id="ffbd3fab4e4bbef4f2e2b4baa2dbf3d3454ab70b" translate="yes" xml:space="preserve">
          <source>Mapping protocol access is a generic name for functionality that enables using custom objects as if they were dictionaries. In case of &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt;, the mapping interface implementation is using the &lt;code&gt;parser['section']['option']&lt;/code&gt; notation.</source>
          <target state="translated">매핑 프로토콜 액세스는 사용자 지정 개체를 마치 사전처럼 사용할 수 있도록하는 기능의 일반적인 이름입니다. 경우 &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 매핑 인터페이스 구현은 사용 &lt;code&gt;parser['section']['option']&lt;/code&gt; 표기.</target>
        </trans-unit>
        <trans-unit id="fc5f87a388e33c8327e76fb56366eadca8297613" translate="yes" xml:space="preserve">
          <source>Maps a logging level name to a syslog priority name. You may need to override this if you are using custom levels, or if the default algorithm is not suitable for your needs. The default algorithm maps &lt;code&gt;DEBUG&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt;, &lt;code&gt;ERROR&lt;/code&gt; and &lt;code&gt;CRITICAL&lt;/code&gt; to the equivalent syslog names, and all other level names to &amp;lsquo;warning&amp;rsquo;.</source>
          <target state="translated">로깅 레벨 이름을 syslog 우선 순위 이름에 맵핑합니다. 사용자 지정 수준을 사용하거나 기본 알고리즘이 사용자의 요구에 적합하지 않은 경우이를 재정의해야 할 수도 있습니다. 기본 알고리즘은 &lt;code&gt;DEBUG&lt;/code&gt; , &lt;code&gt;INFO&lt;/code&gt; , &lt;code&gt;WARNING&lt;/code&gt; , &lt;code&gt;ERROR&lt;/code&gt; 및 &lt;code&gt;CRITICAL&lt;/code&gt; 을 해당 syslog 이름에 매핑 하고 다른 모든 레벨 이름은 'warning'에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="76ccf4240d86fc261192b90e86fb8e3d610a0808" translate="yes" xml:space="preserve">
          <source>Marc-Andr&amp;eacute; Lemburg</source>
          <target state="translated">마크 안드레 렘 부르크</target>
        </trans-unit>
        <trans-unit id="31e9697d43a1a66f2e45db652019fb9a6216df22" translate="yes" xml:space="preserve">
          <source>Mark</source>
          <target state="translated">Mark</target>
        </trans-unit>
        <trans-unit id="78b4b0fca0a8558cdba8df445fed06a9f493ddd2" translate="yes" xml:space="preserve">
          <source>Mark a protocol class as a runtime protocol.</source>
          <target state="translated">프로토콜 클래스를 런타임 프로토콜로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="bdc16c3d4446aea587c961d5bd660311653c4972" translate="yes" xml:space="preserve">
          <source>Mark all lines in the window as unchanged since the last call to &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 를 마지막으로 호출 한 후 창의 모든 행을 변경되지 않은 것으로 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="b902da44d0895caa8231cc9e0384c86417f1ce22" translate="yes" xml:space="preserve">
          <source>Mark for refresh but wait. This function updates the data structure representing the desired state of the window, but does not force an update of the physical screen. To accomplish that, call &lt;a href=&quot;#curses.doupdate&quot;&gt;&lt;code&gt;doupdate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로 고침을 표시하지만 기다리십시오. 이 기능은 원하는 창의 상태를 나타내는 데이터 구조를 업데이트하지만 실제 화면을 강제로 업데이트하지는 않습니다. 이를 위해 &lt;a href=&quot;#curses.doupdate&quot;&gt; &lt;code&gt;doupdate()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e559ee62a3983226dcbd83616d76d03181ae0a0b" translate="yes" xml:space="preserve">
          <source>Mark the Future as &lt;em&gt;done&lt;/em&gt; and set an exception.</source>
          <target state="translated">미래를 &lt;em&gt;완료&lt;/em&gt; 로 표시하고 예외를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="645ca0c18193b0ded87798fc215d9dd6ea2d332b" translate="yes" xml:space="preserve">
          <source>Mark the Future as &lt;em&gt;done&lt;/em&gt; and set its result.</source>
          <target state="translated">미래를 &lt;em&gt;완료&lt;/em&gt; 로 표시 하고 결과를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a99df56423ec62f1dfba367c986811c41a5f6a69" translate="yes" xml:space="preserve">
          <source>Mark the breakpoint as disabled.</source>
          <target state="translated">중단 점을 비활성화 된 것으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e3cef4076875b3fcfd897d8fd8f8b835f2539450" translate="yes" xml:space="preserve">
          <source>Mark the breakpoint as enabled.</source>
          <target state="translated">중단 점을 활성화 된 것으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ef57eb325f600134e0961a71843953dac27f2aa5" translate="yes" xml:space="preserve">
          <source>Mark the socket closed. The underlying system resource (e.g. a file descriptor) is also closed when all file objects from &lt;a href=&quot;#socket.socket.makefile&quot;&gt;&lt;code&gt;makefile()&lt;/code&gt;&lt;/a&gt; are closed. Once that happens, all future operations on the socket object will fail. The remote end will receive no more data (after queued data is flushed).</source>
          <target state="translated">소켓을 닫은 상태로 표시하십시오. &lt;a href=&quot;#socket.socket.makefile&quot;&gt; &lt;code&gt;makefile()&lt;/code&gt; &lt;/a&gt; 모든 파일 객체가 닫히면 기본 시스템 리소스 (예 : 파일 설명자)도 닫힙니다. 그런 다음 소켓 개체에 대한 모든 이후 작업이 실패합니다. 리모트 엔드는 더 이상 데이터를받지 않습니다 (대기 된 데이터를 비운 후).</target>
        </trans-unit>
        <trans-unit id="91570de3be09b7c281d418e67e319eb7eac4ceb0" translate="yes" xml:space="preserve">
          <source>Mark the test as an expected failure. If the test fails it will be considered a success. If the test passes, it will be considered a failure.</source>
          <target state="translated">테스트를 예상 실패로 표시하십시오. 테스트에 실패하면 성공한 것으로 간주됩니다. 테스트에 통과하면 실패로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fb33120620b42e4c6568086b4548bf56c1a0ef93" translate="yes" xml:space="preserve">
          <source>Marked as important</source>
          <target state="translated">중요한 것으로 표시</target>
        </trans-unit>
        <trans-unit id="07e5aae18cb637acd22f163aa224ab431ff10cb0" translate="yes" xml:space="preserve">
          <source>Marked for subsequent deletion</source>
          <target state="translated">후속 삭제 표시</target>
        </trans-unit>
        <trans-unit id="4e44d1a49ab6471526e55a08a843c13a0050773d" translate="yes" xml:space="preserve">
          <source>Martin von L&amp;ouml;wis</source>
          <target state="translated">마틴 폰 로이스</target>
        </trans-unit>
        <trans-unit id="3a6db205066d4b1bbdc6724346fcfa1af498ef02" translate="yes" xml:space="preserve">
          <source>Mask for file owner permissions.</source>
          <target state="translated">파일 소유자 권한 마스크.</target>
        </trans-unit>
        <trans-unit id="b5fc0001fa738ddce48f31c45c0d3794679d1545" translate="yes" xml:space="preserve">
          <source>Mask for group permissions.</source>
          <target state="translated">그룹 권한 마스크.</target>
        </trans-unit>
        <trans-unit id="450210d9790fb16d1dbe9733f4212fbc9774479d" translate="yes" xml:space="preserve">
          <source>Mask for permissions for others (not in group).</source>
          <target state="translated">다른 사람 (그룹이 아님)에 대한 권한 마스크.</target>
        </trans-unit>
        <trans-unit id="0826b4ceb6778b296bb3f36f65361f0cb844377a" translate="yes" xml:space="preserve">
          <source>Match &lt;em&gt;test&lt;/em&gt; to patterns set in &lt;a href=&quot;#test.support.set_match_tests&quot;&gt;&lt;code&gt;set_match_tests()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#test.support.set_match_tests&quot;&gt; &lt;code&gt;set_match_tests()&lt;/code&gt; &lt;/a&gt; 설정된 패턴과 &lt;em&gt;테스트&lt;/em&gt; 를 일치 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="bb305e9c61f18de73442b09968fd63313bd41a06" translate="yes" xml:space="preserve">
          <source>Match Objects</source>
          <target state="translated">객체 일치</target>
        </trans-unit>
        <trans-unit id="93224cb05b372360e7ead31f8491156ed05f4cc5" translate="yes" xml:space="preserve">
          <source>Match objects always have a boolean value of &lt;code&gt;True&lt;/code&gt;. Since &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; return &lt;code&gt;None&lt;/code&gt; when there is no match, you can test whether there was a match with a simple &lt;code&gt;if&lt;/code&gt; statement:</source>
          <target state="translated">일치 개체는 항상 부울 값이 &lt;code&gt;True&lt;/code&gt; 입니다. 이후 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;None&lt;/code&gt; 일치가 없다, 당신은 간단한와 일치 여부를 테스트 할 수 있습니다 &lt;code&gt;if&lt;/code&gt; 문 :</target>
        </trans-unit>
        <trans-unit id="c7d3fdaa1b461ec568f838ede0d4a6626d22e9f8" translate="yes" xml:space="preserve">
          <source>Match objects support the following methods and attributes:</source>
          <target state="translated">일치 개체는 다음과 같은 방법과 특성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="949fae956dd5c3ab00023592a8026f4d3f8d83a0" translate="yes" xml:space="preserve">
          <source>Match this path against the provided glob-style pattern. Return &lt;code&gt;True&lt;/code&gt; if matching is successful, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">제공된 glob 스타일 패턴과이 경로를 일치시킵니다. 반환 &lt;code&gt;True&lt;/code&gt; 매칭, 성공하면 &lt;code&gt;False&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="179f5245f2bff101b819b11ca265a7859b9b8741" translate="yes" xml:space="preserve">
          <source>Matches Unicode whitespace characters (which includes &lt;code&gt;[ \t\n\r\f\v]&lt;/code&gt;, and also many other characters, for example the non-breaking spaces mandated by typography rules in many languages). If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used, only &lt;code&gt;[ \t\n\r\f\v]&lt;/code&gt; is matched.</source>
          <target state="translated">유니 코드 공백 문자 ( &lt;code&gt;[ \t\n\r\f\v]&lt;/code&gt; ) 및 기타 여러 문자 (예 : 여러 언어의 타이포그래피 규칙에 의해 규정 된 비 공백 공백 포함)와 일치 합니다. 경우] &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 의&lt;/a&gt; 플래그가 사용되는, 단지 &lt;code&gt;[ \t\n\r\f\v]&lt;/code&gt; 일치한다.</target>
        </trans-unit>
        <trans-unit id="6d38947cd9f594564bec8a24b3a93f3632f7ac2c" translate="yes" xml:space="preserve">
          <source>Matches Unicode word characters; this includes most characters that can be part of a word in any language, as well as numbers and the underscore. If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used, only &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt; is matched.</source>
          <target state="translated">유니 코드 단어 문자와 일치합니다. 여기에는 숫자와 밑줄뿐만 아니라 모든 언어로 단어의 일부가 될 수있는 대부분의 문자가 포함됩니다. 경우] &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 의&lt;/a&gt; 플래그가 사용되는, 단지 &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt; 일치한다.</target>
        </trans-unit>
        <trans-unit id="a02ff78bb9f573d06ae9b31f950bd8ca71d47da4" translate="yes" xml:space="preserve">
          <source>Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes &lt;code&gt;[0-9]&lt;/code&gt;, and also many other digit characters. If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used only &lt;code&gt;[0-9]&lt;/code&gt; is matched.</source>
          <target state="translated">모든 유니 코드 10 진수 (즉, 유니 코드 문자 범주 [Nd]의 모든 문자)와 일치합니다. 여기에는 &lt;code&gt;[0-9]&lt;/code&gt; 및 다른 많은 숫자가 포함됩니다. 경우] &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 의&lt;/a&gt; 플래그만을 사용되는 &lt;code&gt;[0-9]&lt;/code&gt; 와 일치한다.</target>
        </trans-unit>
        <trans-unit id="6faa8f9895eeaa59ee824b76c6784280c5d25e28" translate="yes" xml:space="preserve">
          <source>Matches any character which is not a decimal digit. This is the opposite of &lt;code&gt;\d&lt;/code&gt;. If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used this becomes the equivalent of &lt;code&gt;[^0-9]&lt;/code&gt;.</source>
          <target state="translated">10 진수가 아닌 문자를 찾습니다. 이것은 &lt;code&gt;\d&lt;/code&gt; 와 반대입니다 . &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 인&lt;/a&gt; 경우 플래그가 사용되는이 동등해진다 &lt;code&gt;[^0-9]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="506ee12774fd4c8b11b499d0991f2faec4d49031" translate="yes" xml:space="preserve">
          <source>Matches any character which is not a whitespace character. This is the opposite of &lt;code&gt;\s&lt;/code&gt;. If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used this becomes the equivalent of &lt;code&gt;[^ \t\n\r\f\v]&lt;/code&gt;.</source>
          <target state="translated">공백 문자가 아닌 모든 문자와 일치합니다. 이것은 &lt;code&gt;\s&lt;/code&gt; 와 반대입니다 . 경우] &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 의&lt;/a&gt; 플래그가 사용되는이 동등해진다 &lt;code&gt;[^ \t\n\r\f\v]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb667e499cd951fea4ed70cad16b482c6b171c37" translate="yes" xml:space="preserve">
          <source>Matches any character which is not a word character. This is the opposite of &lt;code&gt;\w&lt;/code&gt;. If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used this becomes the equivalent of &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;. If the &lt;a href=&quot;#re.LOCALE&quot;&gt;&lt;code&gt;LOCALE&lt;/code&gt;&lt;/a&gt; flag is used, matches characters which are neither alphanumeric in the current locale nor the underscore.</source>
          <target state="translated">단어 문자가 아닌 모든 문자와 일치합니다. 이것은 &lt;code&gt;\w&lt;/code&gt; 와 반대입니다 . 경우] &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 의&lt;/a&gt; 플래그가 사용되는이 동등해진다 &lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt; . 경우 &lt;a href=&quot;#re.LOCALE&quot;&gt; &lt;code&gt;LOCALE&lt;/code&gt; &lt;/a&gt; 플래그를 사용, 현재 로케일이나 밑줄의 숫자도 문자를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d684d6a5303e5b104e9d7e1feebac2fca2e629fd" translate="yes" xml:space="preserve">
          <source>Matches any decimal digit; this is equivalent to &lt;code&gt;[0-9]&lt;/code&gt;.</source>
          <target state="translated">십진수와 일치합니다. 이것은 &lt;code&gt;[0-9]&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1ec81b9258c564d40fd0ace5573c147f0fc89717" translate="yes" xml:space="preserve">
          <source>Matches characters considered alphanumeric in the ASCII character set; this is equivalent to &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;. If the &lt;a href=&quot;#re.LOCALE&quot;&gt;&lt;code&gt;LOCALE&lt;/code&gt;&lt;/a&gt; flag is used, matches characters considered alphanumeric in the current locale and the underscore.</source>
          <target state="translated">ASCII 문자 집합에서 영숫자로 간주되는 문자를 찾습니다. 이것은 &lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;#re.LOCALE&quot;&gt; &lt;code&gt;LOCALE&lt;/code&gt; 의&lt;/a&gt; 경우 플래그를 사용, 현재 로케일 및 밑줄에 숫자로 간주 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="79e224040ee5cddbfb21a4d52e1d10cdcc916f03" translate="yes" xml:space="preserve">
          <source>Matches characters considered whitespace in the ASCII character set; this is equivalent to &lt;code&gt;[ \t\n\r\f\v]&lt;/code&gt;.</source>
          <target state="translated">ASCII 문자 세트에서 공백으로 간주되는 문자와 일치합니다. 이것은 &lt;code&gt;[ \t\n\r\f\v]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5760ea3990de7a6de7c5094a464f1ee8146a643" translate="yes" xml:space="preserve">
          <source>Matches if &lt;code&gt;...&lt;/code&gt; doesn&amp;rsquo;t match next. This is a &lt;em&gt;negative lookahead assertion&lt;/em&gt;. For example, &lt;code&gt;Isaac (?!Asimov)&lt;/code&gt; will match &lt;code&gt;'Isaac '&lt;/code&gt; only if it&amp;rsquo;s &lt;em&gt;not&lt;/em&gt; followed by &lt;code&gt;'Asimov'&lt;/code&gt;.</source>
          <target state="translated">일치하는 경우는 &lt;code&gt;...&lt;/code&gt; 다음에 일치하지 않습니다. 이것은 &lt;em&gt;부정적 예측&lt;/em&gt; 입니다. 예를 들어, &lt;code&gt;Isaac (?!Asimov)&lt;/code&gt; 일치 &lt;code&gt;'Isaac '&lt;/code&gt; 이 유일하면 &lt;em&gt;되지&lt;/em&gt; 다음 &lt;code&gt;'Asimov'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="645a3b740373b49f15f59d4fb0d89acad2b7e416" translate="yes" xml:space="preserve">
          <source>Matches if &lt;code&gt;...&lt;/code&gt; matches next, but doesn&amp;rsquo;t consume any of the string. This is called a &lt;em&gt;lookahead assertion&lt;/em&gt;. For example, &lt;code&gt;Isaac (?=Asimov)&lt;/code&gt; will match &lt;code&gt;'Isaac '&lt;/code&gt; only if it&amp;rsquo;s followed by &lt;code&gt;'Asimov'&lt;/code&gt;.</source>
          <target state="translated">일치하는 경우는 &lt;code&gt;...&lt;/code&gt; 다음 일치하지만 문자열 중 하나를 소비하지 않습니다. 이를 &lt;em&gt;미리보기 어설 션&lt;/em&gt; 이라고합니다 . 예를 들어, &lt;code&gt;Isaac (?=Asimov)&lt;/code&gt; 은 &lt;code&gt;'Asimov'&lt;/code&gt; 뒤에 오는 경우에만 &lt;code&gt;'Isaac '&lt;/code&gt; 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="9841ece5b3fb751e15c8bcf3e454136a92d6ad87" translate="yes" xml:space="preserve">
          <source>Matches if the current position in the string is not preceded by a match for &lt;code&gt;...&lt;/code&gt;. This is called a &lt;em&gt;negative lookbehind assertion&lt;/em&gt;. Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched.</source>
          <target state="translated">문자열의 현재 위치 앞에 &lt;code&gt;...&lt;/code&gt; 와 일치하지 않는 경우 일치합니다 . 이것을 &lt;em&gt;네거티브 룩 베어 어설 션&lt;/em&gt; 이라고합니다 . 포지티브 lookbehind 어설 션과 마찬가지로 포함 된 패턴은 고정 길이의 문자열과 만 일치해야합니다. 네거티브 lookbehind 어설 션으로 시작하는 패턴은 검색중인 문자열의 시작 부분에서 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ac2333577ba84b6d03fe92bd867d24bbd26ed7" translate="yes" xml:space="preserve">
          <source>Matches if the current position in the string is preceded by a match for &lt;code&gt;...&lt;/code&gt; that ends at the current position. This is called a &lt;em&gt;positive lookbehind assertion&lt;/em&gt;. &lt;code&gt;(?&amp;lt;=abc)def&lt;/code&gt; will find a match in &lt;code&gt;'abcdef'&lt;/code&gt;, since the lookbehind will back up 3 characters and check if the contained pattern matches. The contained pattern must only match strings of some fixed length, meaning that &lt;code&gt;abc&lt;/code&gt; or &lt;code&gt;a|b&lt;/code&gt; are allowed, but &lt;code&gt;a*&lt;/code&gt; and &lt;code&gt;a{3,4}&lt;/code&gt; are not. Note that patterns which start with positive lookbehind assertions will not match at the beginning of the string being searched; you will most likely want to use the &lt;a href=&quot;#re.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; function rather than the &lt;a href=&quot;#re.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">문자열의 현재 위치 앞에 현재 위치에서 끝나는 &lt;code&gt;...&lt;/code&gt; 에 대한 일치가 있으면 일치합니다 . 이를 &lt;em&gt;긍정적 인 비하인드 어설 션&lt;/em&gt; 이라고합니다 . &lt;code&gt;(?&amp;lt;=abc)def&lt;/code&gt; 는 &lt;code&gt;'abcdef'&lt;/code&gt; 에서 일치하는 항목을 찾습니다. lookbehind는 3자를 백업하고 포함 된 패턴이 일치하는지 확인합니다. 포함 된 패턴은 고정 길이의 문자열에만 일치해야합니다. 즉 &lt;code&gt;abc&lt;/code&gt; 또는 &lt;code&gt;a|b&lt;/code&gt; 는 허용되지만 &lt;code&gt;a*&lt;/code&gt; 및 &lt;code&gt;a{3,4}&lt;/code&gt; 는 허용되지 않습니다. 긍정적 인 lookbehind 어설 션으로 시작하는 패턴은 검색중인 문자열의 시작 부분과 일치하지 않습니다. &lt;a href=&quot;#re.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 를 사용하고 싶을 것입니다.&lt;a href=&quot;#re.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 함수가 아닌 함수 :</target>
        </trans-unit>
        <trans-unit id="8552016e487b5c84ddf4be20f70b50e5f4e56d47" translate="yes" xml:space="preserve">
          <source>Matches only at the end of the string.</source>
          <target state="translated">문자열의 끝에서만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="de268deff53557a1f18b43b0cc932e4c34479169" translate="yes" xml:space="preserve">
          <source>Matches only at the start of the string.</source>
          <target state="translated">문자열의 시작 부분에서만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c08d22497155abd5fe50f74938140c4799fbcef4" translate="yes" xml:space="preserve">
          <source>Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, &lt;code&gt;(.+) \1&lt;/code&gt; matches &lt;code&gt;'the the'&lt;/code&gt; or &lt;code&gt;'55 55'&lt;/code&gt;, but not &lt;code&gt;'thethe'&lt;/code&gt; (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of &lt;em&gt;number&lt;/em&gt; is 0, or &lt;em&gt;number&lt;/em&gt; is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value &lt;em&gt;number&lt;/em&gt;. Inside the &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt; of a character class, all numeric escapes are treated as characters.</source>
          <target state="translated">같은 번호의 그룹 내용과 일치합니다. 그룹은 예를 들어 1부터 번호가 매겨 &lt;code&gt;(.+) \1&lt;/code&gt; 매치 &lt;code&gt;'the the'&lt;/code&gt; 또는 &lt;code&gt;'55 55'&lt;/code&gt; 가 아닌 &lt;code&gt;'thethe'&lt;/code&gt; (군 후의 공간을 참고). 이 특수 시퀀스는 처음 99 개 그룹 중 하나와 일치하는 데만 사용할 수 있습니다. 의 첫 번째 숫자 경우 &lt;em&gt;숫자가&lt;/em&gt; 0, 또는 &lt;em&gt;숫자가&lt;/em&gt; 3 진수 자리, 그것은 그룹 일치하는 것으로 해석되지만되지 않습니다 진수 값과 문자로 &lt;em&gt;번호&lt;/em&gt; . 문자 클래스 의 &lt;code&gt;'['&lt;/code&gt; 및 &lt;code&gt;']'&lt;/code&gt; 내 에서 모든 숫자 이스케이프는 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb5aca7d251d2a0725128c63c23538a7b27cad2" translate="yes" xml:space="preserve">
          <source>Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, &lt;code&gt;\b&lt;/code&gt; is defined as the boundary between a &lt;code&gt;\w&lt;/code&gt; and a &lt;code&gt;\W&lt;/code&gt; character (or vice versa), or between &lt;code&gt;\w&lt;/code&gt; and the beginning/end of the string. This means that &lt;code&gt;r'\bfoo\b'&lt;/code&gt; matches &lt;code&gt;'foo'&lt;/code&gt;, &lt;code&gt;'foo.'&lt;/code&gt;, &lt;code&gt;'(foo)'&lt;/code&gt;, &lt;code&gt;'bar foo baz'&lt;/code&gt; but not &lt;code&gt;'foobar'&lt;/code&gt; or &lt;code&gt;'foo3'&lt;/code&gt;.</source>
          <target state="translated">빈 문자열과 일치하지만 단어의 시작 또는 끝에 만 있습니다. 단어는 일련의 단어 문자로 정의됩니다. 공식적으로 &lt;code&gt;\b&lt;/code&gt; 는 &lt;code&gt;\w&lt;/code&gt; 와 &lt;code&gt;\W&lt;/code&gt; 문자 사이의 경계 (또는 그 반대로) 또는 &lt;code&gt;\w&lt;/code&gt; 와 문자열의 시작 / 끝 사이의 경계로 정의됩니다 . 이는 &lt;code&gt;r'\bfoo\b'&lt;/code&gt; 가 &lt;code&gt;'foo'&lt;/code&gt; , &lt;code&gt;'foo.'&lt;/code&gt; ' 와 일치 함을 의미합니다 . , &lt;code&gt;'(foo)'&lt;/code&gt; , &lt;code&gt;'bar foo baz'&lt;/code&gt; 이지만 &lt;code&gt;'foobar'&lt;/code&gt; 또는 &lt;code&gt;'foo3'&lt;/code&gt; 은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c04099b042264b3596a7797564409e8942492883" translate="yes" xml:space="preserve">
          <source>Matches the empty string, but only when it is &lt;em&gt;not&lt;/em&gt; at the beginning or end of a word. This means that &lt;code&gt;r'py\B'&lt;/code&gt; matches &lt;code&gt;'python'&lt;/code&gt;, &lt;code&gt;'py3'&lt;/code&gt;, &lt;code&gt;'py2'&lt;/code&gt;, but not &lt;code&gt;'py'&lt;/code&gt;, &lt;code&gt;'py.'&lt;/code&gt;, or &lt;code&gt;'py!'&lt;/code&gt;. &lt;code&gt;\B&lt;/code&gt; is just the opposite of &lt;code&gt;\b&lt;/code&gt;, so word characters in Unicode patterns are Unicode alphanumerics or the underscore, although this can be changed by using the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag. Word boundaries are determined by the current locale if the &lt;a href=&quot;#re.LOCALE&quot;&gt;&lt;code&gt;LOCALE&lt;/code&gt;&lt;/a&gt; flag is used.</source>
          <target state="translated">빈 문자열과 일치하지만 단어의 시작이나 끝에 &lt;em&gt;있지 않은&lt;/em&gt; 경우에만 일치합니다 . 이것은 &lt;code&gt;r'py\B'&lt;/code&gt; 가 &lt;code&gt;'python'&lt;/code&gt; , &lt;code&gt;'py3'&lt;/code&gt; , &lt;code&gt;'py2'&lt;/code&gt; ' 와 일치 하지만 &lt;code&gt;'py'&lt;/code&gt; , &lt;code&gt;'py.'&lt;/code&gt; '와는 일치 하지 않음을 의미 합니다. 또는 &lt;code&gt;'py!'&lt;/code&gt; . &lt;code&gt;\B&lt;/code&gt; 는 &lt;code&gt;\b&lt;/code&gt; 와 반대 이므로 유니 코드 패턴의 단어 문자는 유니 코드 영숫자 또는 밑줄이지만 &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 변경할 수 있습니다 . &lt;a href=&quot;#re.LOCALE&quot;&gt; &lt;code&gt;LOCALE&lt;/code&gt; &lt;/a&gt; 플래그가 사용되는 경우 현재 로케일에 의해 단어 경계가 결정 됩니다.</target>
        </trans-unit>
        <trans-unit id="8ce88cc650b7fe8f97b845a2321d7c2b877f1d7c" translate="yes" xml:space="preserve">
          <source>Matches the end of the string or just before the newline at the end of the string, and in &lt;a href=&quot;#re.MULTILINE&quot;&gt;&lt;code&gt;MULTILINE&lt;/code&gt;&lt;/a&gt; mode also matches before a newline. &lt;code&gt;foo&lt;/code&gt; matches both &amp;lsquo;foo&amp;rsquo; and &amp;lsquo;foobar&amp;rsquo;, while the regular expression &lt;code&gt;foo$&lt;/code&gt; matches only &amp;lsquo;foo&amp;rsquo;. More interestingly, searching for &lt;code&gt;foo.$&lt;/code&gt; in &lt;code&gt;'foo1\nfoo2\n'&lt;/code&gt; matches &amp;lsquo;foo2&amp;rsquo; normally, but &amp;lsquo;foo1&amp;rsquo; in &lt;a href=&quot;#re.MULTILINE&quot;&gt;&lt;code&gt;MULTILINE&lt;/code&gt;&lt;/a&gt; mode; searching for a single &lt;code&gt;$&lt;/code&gt; in &lt;code&gt;'foo\n'&lt;/code&gt; will find two (empty) matches: one just before the newline, and one at the end of the string.</source>
          <target state="translated">문자열의 끝에서 또는 문자열의 끝 에서 개행 직전과 일치 하고 &lt;a href=&quot;#re.MULTILINE&quot;&gt; &lt;code&gt;MULTILINE&lt;/code&gt; &lt;/a&gt; 모드에서도 개행 전에 일치합니다. &lt;code&gt;foo&lt;/code&gt; 는 'foo'및 'foobar'와 모두 일치하지만 정규식 &lt;code&gt;foo$&lt;/code&gt; 는 'foo'와만 일치합니다. 더 흥미롭게도 &lt;code&gt;'foo1\nfoo2\n'&lt;/code&gt; 에서 &lt;code&gt;foo.$&lt;/code&gt; 를 검색하면 'foo2'는 일반적으로 일치하지만 &lt;a href=&quot;#re.MULTILINE&quot;&gt; &lt;code&gt;MULTILINE&lt;/code&gt; &lt;/a&gt; 모드 에서는 'foo1'과 일치 합니다. &lt;code&gt;'foo\n'&lt;/code&gt; 에서 단일 &lt;code&gt;$&lt;/code&gt; 를 검색 하면 두 개 (빈)가 있습니다. 하나는 개행 직전과 다른 하나는 문자열 끝에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f40daaf0bea10cd0df0f8186bdb340e8b731567" translate="yes" xml:space="preserve">
          <source>Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the &lt;code&gt;\number&lt;/code&gt; special sequence, described below. To match the literals &lt;code&gt;'('&lt;/code&gt; or &lt;code&gt;')'&lt;/code&gt;, use &lt;code&gt;\(&lt;/code&gt; or &lt;code&gt;\)&lt;/code&gt;, or enclose them inside a character class: &lt;code&gt;[(]&lt;/code&gt;, &lt;code&gt;[)]&lt;/code&gt;.</source>
          <target state="translated">괄호 안에있는 정규식과 일치하며 그룹의 시작과 끝을 나타냅니다. 그룹의 내용은 일치가 수행 된 후에 검색 될 수 있으며 아래에 설명 된 &lt;code&gt;\number&lt;/code&gt; 특수 시퀀스 를 사용하여 문자열에서 나중에 일치 될 수 있습니다 . 리터럴에 맞게 &lt;code&gt;'('&lt;/code&gt; 또는 &lt;code&gt;')'&lt;/code&gt; 사용을 &lt;code&gt;\(&lt;/code&gt; 또는 &lt;code&gt;\)&lt;/code&gt; , 또는 문자 클래스의 내부를 둘러싸 : &lt;code&gt;[(]&lt;/code&gt; , &lt;code&gt;[)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b4c6577035e177562eb7b5ddae73d04f12d9983" translate="yes" xml:space="preserve">
          <source>Math argument out of domain of func</source>
          <target state="translated">func 도메인 외부의 수학 인수</target>
        </trans-unit>
        <trans-unit id="10aa065593dbf60ae5f473eae4958b71572dc4ff" translate="yes" xml:space="preserve">
          <source>Math result not representable</source>
          <target state="translated">표현할 수없는 수학 결과</target>
        </trans-unit>
        <trans-unit id="50d207959d02b2a34b183cd7d25f1e0c68bf9ddb" translate="yes" xml:space="preserve">
          <source>Matrix Multiplication</source>
          <target state="translated">행렬 곱셈</target>
        </trans-unit>
        <trans-unit id="e6d0832e2740dd4bc270c8fb3b3635030afe668d" translate="yes" xml:space="preserve">
          <source>Maximum digest size that the hash function can output.</source>
          <target state="translated">해시 함수가 출력 할 수있는 최대 다이제스트 크기입니다.</target>
        </trans-unit>
        <trans-unit id="8b4aa5d3e601b7665580a557fd7d301ef9dff186" translate="yes" xml:space="preserve">
          <source>Maximum key size.</source>
          <target state="translated">최대 키 크기</target>
        </trans-unit>
        <trans-unit id="014ad729ec1a3537d14c4c998116e97cae28939e" translate="yes" xml:space="preserve">
          <source>Maximum key value</source>
          <target state="translated">최대 키 값</target>
        </trans-unit>
        <trans-unit id="fa26260fb5c11969aae03fca4bf169c742f8d389" translate="yes" xml:space="preserve">
          <source>Maximum number of characters in the representation for an integer. Digits are dropped from the middle. The default is &lt;code&gt;40&lt;/code&gt;.</source>
          <target state="translated">정수 표현의 최대 문자 수입니다. 가운데에서 숫자가 삭제됩니다. 기본값은 &lt;code&gt;40&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f05dad23c52cc0273d437ffe0b4a8a5b8a0e80ef" translate="yes" xml:space="preserve">
          <source>Maximum number of days between changes</source>
          <target state="translated">변경 사이의 최대 일수</target>
        </trans-unit>
        <trans-unit id="16b74af98dc16ddf608395028b518cb175ab18cd" translate="yes" xml:space="preserve">
          <source>Maximum number of frames stored in the traceback of &lt;a href=&quot;#tracemalloc.Snapshot.traces&quot;&gt;&lt;code&gt;traces&lt;/code&gt;&lt;/a&gt;: result of the &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; when the snapshot was taken.</source>
          <target state="translated">트레이스의 &lt;a href=&quot;#tracemalloc.Snapshot.traces&quot;&gt; &lt;code&gt;traces&lt;/code&gt; &lt;/a&gt; 백에 저장된 최대 프레임 수 : 스냅 샷을 만들 때 &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt; 결과 .</target>
        </trans-unit>
        <trans-unit id="3750177b2f369715ab06bcee508f2caa6b2a6f98" translate="yes" xml:space="preserve">
          <source>Maximum size of a deque or &lt;code&gt;None&lt;/code&gt; if unbounded.</source>
          <target state="translated">deque의 최대 크기 또는 제한이없는 경우 &lt;code&gt;None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="edc09d71b5252f3ee59a839aac0b3a820b72242c" translate="yes" xml:space="preserve">
          <source>May be set to &amp;ldquo;normal&amp;rdquo; or &amp;ldquo;disabled&amp;rdquo; to control the &amp;ldquo;disabled&amp;rdquo; state bit. This is a write-only option: setting it changes the widget state, but the &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt;&lt;code&gt;Widget.state()&lt;/code&gt;&lt;/a&gt; method does not affect this option.</source>
          <target state="translated">&quot;비활성화&quot;상태 비트를 제어하기 위해 &quot;정상&quot;또는 &quot;비활성화&quot;로 설정 될 수 있습니다. 이것은 쓰기 전용 옵션입니다.이를 설정하면 위젯 상태가 변경되지만 &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt; &lt;code&gt;Widget.state()&lt;/code&gt; &lt;/a&gt; 메소드는이 옵션에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44a80b227c8f186870813bca412da9ebe084f150" translate="yes" xml:space="preserve">
          <source>May be used to specify a custom widget style.</source>
          <target state="translated">사용자 정의 위젯 스타일을 지정하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c4d73c6f4d4e4fbb6fe638e8af4924410068ed" translate="yes" xml:space="preserve">
          <source>May raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">올릴 수 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="16093585733797b25f46218a91e9a1ef038fedd8" translate="yes" xml:space="preserve">
          <source>Measures of spread</source>
          <target state="translated">스프레드 측정</target>
        </trans-unit>
        <trans-unit id="b628e9468e6b5c28d9838c0202c4f602cfb4f6b1" translate="yes" xml:space="preserve">
          <source>Measures the agreement between two normal probability distributions. Returns a value between 0.0 and 1.0 giving &lt;a href=&quot;https://www.rasch.org/rmt/rmt101r.htm&quot;&gt;the overlapping area for the two probability density functions&lt;/a&gt;.</source>
          <target state="translated">두 정규 확률 분포 간의 일치를 측정합니다. &lt;a href=&quot;https://www.rasch.org/rmt/rmt101r.htm&quot;&gt;두 확률 밀도 함수에 대해 겹치는 영역을&lt;/a&gt; 제공 하여 0.0과 1.0 사이의 값을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2898c2eb7b2e66e1c44ea89bdae559774210425b" translate="yes" xml:space="preserve">
          <source>Median (middle value) of data.</source>
          <target state="translated">데이터의 중간 값 (중간 값).</target>
        </trans-unit>
        <trans-unit id="b6a8553e4cbb05abe2fbc605e92f832712ef5d58" translate="yes" xml:space="preserve">
          <source>Median, or 50th percentile, of grouped data.</source>
          <target state="translated">그룹화 된 데이터의 중앙값 또는 50 번째 백분위 수</target>
        </trans-unit>
        <trans-unit id="47c80fcea8456971f1641f17561f060ec99c498a" translate="yes" xml:space="preserve">
          <source>Member values can be anything: &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, etc.. If the exact value is unimportant you may use &lt;a href=&quot;#enum.auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt; instances and an appropriate value will be chosen for you. Care must be taken if you mix &lt;a href=&quot;#enum.auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt; with other values.</source>
          <target state="translated">멤버 값은 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 등이 될 수 있습니다. 정확한 값이 중요하지 않은 경우 &lt;a href=&quot;#enum.auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용할 수 있으며 적절한 값이 선택됩니다. &lt;a href=&quot;#enum.auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; 을 다른 값과 혼합 할 경우주의를 기울여야합니다 .</target>
        </trans-unit>
        <trans-unit id="f10615a852f71e51e70484e62589e76d80a6cbee" translate="yes" xml:space="preserve">
          <source>Members of &lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt;&lt;code&gt;call_args_list&lt;/code&gt;&lt;/a&gt; are &lt;a href=&quot;#unittest.mock.call&quot;&gt;&lt;code&gt;call&lt;/code&gt;&lt;/a&gt; objects. These can be unpacked as tuples to get at the individual arguments. See &lt;a href=&quot;#calls-as-tuples&quot;&gt;calls as tuples&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt; &lt;code&gt;call_args_list&lt;/code&gt; 의&lt;/a&gt; 멤버 는 &lt;a href=&quot;#unittest.mock.call&quot;&gt; &lt;code&gt;call&lt;/code&gt; &lt;/a&gt; 객체입니다. 이들은 개별 인수를 얻기 위해 튜플로 압축을 풀 수 있습니다. &lt;a href=&quot;#calls-as-tuples&quot;&gt;튜플로 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd0eafe15e6e45f2a4f843e0333ccf3a417c5e3c" translate="yes" xml:space="preserve">
          <source>Members of &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt;&lt;code&gt;method_calls&lt;/code&gt;&lt;/a&gt; are &lt;a href=&quot;#unittest.mock.call&quot;&gt;&lt;code&gt;call&lt;/code&gt;&lt;/a&gt; objects. These can be unpacked as tuples to get at the individual arguments. See &lt;a href=&quot;#calls-as-tuples&quot;&gt;calls as tuples&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt; &lt;code&gt;method_calls&lt;/code&gt; 의&lt;/a&gt; 멤버 는 &lt;a href=&quot;#unittest.mock.call&quot;&gt; &lt;code&gt;call&lt;/code&gt; &lt;/a&gt; 객체입니다. 이들은 개별 인수를 얻기 위해 튜플로 압축을 풀 수 있습니다. &lt;a href=&quot;#calls-as-tuples&quot;&gt;튜플로 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba39158a8386393f5da73f9deb9c5f902a6dd693" translate="yes" xml:space="preserve">
          <source>Members of &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; are &lt;a href=&quot;#unittest.mock.call&quot;&gt;&lt;code&gt;call&lt;/code&gt;&lt;/a&gt; objects. These can be unpacked as tuples to get at the individual arguments. See &lt;a href=&quot;#calls-as-tuples&quot;&gt;calls as tuples&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; 의&lt;/a&gt; 멤버 는 &lt;a href=&quot;#unittest.mock.call&quot;&gt; &lt;code&gt;call&lt;/code&gt; &lt;/a&gt; 객체입니다. 이들은 개별 인수를 얻기 위해 튜플로 압축을 풀 수 있습니다. &lt;a href=&quot;#calls-as-tuples&quot;&gt;튜플로 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d52065f33aba0940b046e017d4e1dcd357c9062" translate="yes" xml:space="preserve">
          <source>Members of the population need not be &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; or unique. If the population contains repeats, then each occurrence is a possible selection in the sample.</source>
          <target state="translated">모집단 구성원은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;해시 가능&lt;/a&gt; 하거나 고유 하지 않아도 됩니다. 모집단에 반복이 포함되어 있으면 표본에서 각 항목을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e0dfc18cc7a4d06e7cad57a7f6fafa7090ff04a" translate="yes" xml:space="preserve">
          <source>Memory BIO Support</source>
          <target state="translated">메모리 바이오 지원</target>
        </trans-unit>
        <trans-unit id="e80f9fe1d0c17d864aa78913d1c28ea30f56c51b" translate="yes" xml:space="preserve">
          <source>Memory Views</source>
          <target state="translated">메모리 뷰</target>
        </trans-unit>
        <trans-unit id="f72fc48377945075aece3d0f77f039dde8e3ab08" translate="yes" xml:space="preserve">
          <source>Memory-mapped file objects behave like both &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; and like &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. You can use mmap objects in most places where &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; are expected; for example, you can use the &lt;a href=&quot;re#module-re&quot;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt; module to search through a memory-mapped file. You can also change a single byte by doing &lt;code&gt;obj[index] = 97&lt;/code&gt;, or change a subsequence by assigning to a slice: &lt;code&gt;obj[i1:i2] = b'...'&lt;/code&gt;. You can also read and write data starting at the current file position, and &lt;code&gt;seek()&lt;/code&gt; through the file to different positions.</source>
          <target state="translated">메모리 매핑 된 파일 객체는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 및 파일 객체처럼 동작 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;합니다&lt;/a&gt; . &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 이 필요한 대부분의 장소에서 mmap 객체를 사용할 수 있습니다 . 예를 들어 &lt;a href=&quot;re#module-re&quot;&gt; &lt;code&gt;re&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 메모리 매핑 된 파일을 검색 할 수 있습니다 . &lt;code&gt;obj[index] = 97&lt;/code&gt; 사용하여 단일 바이트를 변경하거나 슬라이스에 할당하여 하위 시퀀스를 변경할 수도 있습니다 : &lt;code&gt;obj[i1:i2] = b'...'&lt;/code&gt; . 현재 파일 위치에서 시작하여 데이터를 읽고 쓸 수 있으며 파일을 통해 다른 위치로 &lt;code&gt;seek()&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05dce2bca4952d4d30be9caea65daf4119c522a0" translate="yes" xml:space="preserve">
          <source>Memory-mapped file objects support the following methods:</source>
          <target state="translated">메모리 매핑 된 파일 객체는 다음 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ccdfc54c3dfcff33f3b84cd29c470c9f9dd72513" translate="yes" xml:space="preserve">
          <source>MemoryError</source>
          <target state="translated">MemoryError</target>
        </trans-unit>
        <trans-unit id="042180098555538da1846becefee4991e4e008c7" translate="yes" xml:space="preserve">
          <source>MemoryHandler</source>
          <target state="translated">MemoryHandler</target>
        </trans-unit>
        <trans-unit id="3a9d4b4b179ca00907fee8d914427c890923e689" translate="yes" xml:space="preserve">
          <source>Menu indexes (menu.invoke(), menu.entryconfig(), etc.)</source>
          <target state="translated">메뉴 인덱스 (menu.invoke (), menu.entryconfig () 등)</target>
        </trans-unit>
        <trans-unit id="e7c3800e31ff2e7695b9f5bed95a6de6715dca44" translate="yes" xml:space="preserve">
          <source>Menus</source>
          <target state="translated">Menus</target>
        </trans-unit>
        <trans-unit id="cc82aa47255cb19590a5531d1e61e840f195f669" translate="yes" xml:space="preserve">
          <source>Merge in data from another &lt;a href=&quot;#trace.CoverageResults&quot;&gt;&lt;code&gt;CoverageResults&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">다른 &lt;a href=&quot;#trace.CoverageResults&quot;&gt; &lt;code&gt;CoverageResults&lt;/code&gt; &lt;/a&gt; 객체의 데이터를 병합 합니다.</target>
        </trans-unit>
        <trans-unit id="fc96ea9dd703090ebbbff6f4d36c249d4f4d2c14" translate="yes" xml:space="preserve">
          <source>Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;iterator&lt;/a&gt; over the sorted values.</source>
          <target state="translated">정렬 된 여러 입력을 단일 정렬 된 출력으로 병합합니다 (예 : 타임 스탬프가 지정된 항목을 여러 로그 파일에서 병합). 정렬 된 값에 대한 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;반복자&lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
