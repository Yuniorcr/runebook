<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="9e04e3f91bf11b867e737db3820385321c5dd5a3" translate="yes" xml:space="preserve">
          <source>Force bytes held in the buffer into the raw stream. A &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; should be raised if the raw stream blocks.</source>
          <target state="translated">버퍼에 유지 된 바이트를 원시 스트림으로 강제합니다. &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 는&lt;/a&gt; 원시 스트림 블록 경우에 발생한다.</target>
        </trans-unit>
        <trans-unit id="3814643afec1943c4c3295af6d5883427e7464b5" translate="yes" xml:space="preserve">
          <source>Force processing of all buffered data as if it were followed by an end-of-file mark. This method may be redefined by a derived class to define additional processing at the end of the input, but the redefined version should always call the &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt;&lt;code&gt;HTMLParser&lt;/code&gt;&lt;/a&gt; base class method &lt;a href=&quot;#html.parser.HTMLParser.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마치 파일 끝 표시가있는 것처럼 모든 버퍼링 된 데이터를 강제 처리합니다. 이 메소드는 파생 클래스에서 재정 의하여 입력 끝에 추가 처리를 정의 할 수 있지만 재정의 된 버전은 항상 &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt; &lt;code&gt;HTMLParser&lt;/code&gt; &lt;/a&gt; 기본 클래스 메소드 &lt;a href=&quot;#html.parser.HTMLParser.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="af599334f590af897809afaeb762277ded4e96df" translate="yes" xml:space="preserve">
          <source>Force rebuild even if timestamps are up-to-date.</source>
          <target state="translated">타임 스탬프가 최신 인 경우에도 강제로 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9a64202427e8fe21214e70464bd1aec2542b9f21" translate="yes" xml:space="preserve">
          <source>Force the &lt;code&gt;malloc()&lt;/code&gt; heap to clean itself up and return unused blocks to the operating system. On failure, this raises &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;malloc()&lt;/code&gt; 힙을 강제 로 정리하고 사용하지 않는 블록을 운영 체제로 리턴하십시오. 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="19d31fd6b2df693dc550368a6c845c371544b270" translate="yes" xml:space="preserve">
          <source>Force use of &lt;code&gt;CRAM-MD5&lt;/code&gt; authentication when identifying the client to protect the password. Will only work if the server &lt;code&gt;CAPABILITY&lt;/code&gt; response includes the phrase &lt;code&gt;AUTH=CRAM-MD5&lt;/code&gt;.</source>
          <target state="translated">강제 사용 &lt;code&gt;CRAM-MD5&lt;/code&gt; 의 인증 암호를 보호하기 위해 클라이언트를 식별 할 때. 서버 &lt;code&gt;CAPABILITY&lt;/code&gt; 응답에 &lt;code&gt;AUTH=CRAM-MD5&lt;/code&gt; 문구가 포함 된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ab13cdc95de3d7531cb31f5ddbb861e2d8b77785" translate="yes" xml:space="preserve">
          <source>Force write of everything to disk.</source>
          <target state="translated">디스크에 모든 것을 강제로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="a2d96a80900bc13facf56d7742e8d8ff57e15a8c" translate="yes" xml:space="preserve">
          <source>Force write of file with filedescriptor &lt;em&gt;fd&lt;/em&gt; to disk. Does not force update of metadata.</source>
          <target state="translated">파일 &lt;em&gt;디스크립터 fd&lt;/em&gt; 를 가진 파일 을 디스크에 강제로 쓰십시오 . 메타 데이터를 강제로 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c49957cff34733d16e38876ce4dd54c1c1dc339" translate="yes" xml:space="preserve">
          <source>Force write of file with filedescriptor &lt;em&gt;fd&lt;/em&gt; to disk. On Unix, this calls the native &lt;code&gt;fsync()&lt;/code&gt; function; on Windows, the MS &lt;code&gt;_commit()&lt;/code&gt; function.</source>
          <target state="translated">파일 &lt;em&gt;디스크립터 fd&lt;/em&gt; 를 가진 파일 을 디스크에 강제로 쓰십시오 . 유닉스에서는 네이티브 &lt;code&gt;fsync()&lt;/code&gt; 함수를 호출합니다 . Windows에서는 MS &lt;code&gt;_commit()&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b57f0c15791c6915cb3fe418d16a695f3e93406f" translate="yes" xml:space="preserve">
          <source>Forces the field to be centered within the available space.</source>
          <target state="translated">사용 가능한 공간 내에서 필드를 중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="89bf2d916edc333230584e34f64cea573d2cc13c" translate="yes" xml:space="preserve">
          <source>Forces the field to be left-aligned within the available space (this is the default for most objects).</source>
          <target state="translated">사용 가능한 공간 내에서 필드가 왼쪽 정렬되도록합니다 (대부분의 개체에 대한 기본값 임).</target>
        </trans-unit>
        <trans-unit id="72cd2faf3a66abe4dfd120a3b0bee5e88182838a" translate="yes" xml:space="preserve">
          <source>Forces the field to be right-aligned within the available space (this is the default for numbers).</source>
          <target state="translated">사용 가능한 공간 내에서 필드가 오른쪽 정렬되도록합니다 (이는 숫자의 기본값 임).</target>
        </trans-unit>
        <trans-unit id="02886633a6050534b2f499dba88d89c2fa0ba3d6" translate="yes" xml:space="preserve">
          <source>Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form &amp;lsquo;+000000120&amp;rsquo;. This alignment option is only valid for numeric types. It becomes the default when &amp;lsquo;0&amp;rsquo; immediately precedes the field width.</source>
          <target state="translated">패딩을 부호 뒤에 (있는 경우), 숫자 앞에 배치합니다. '+000000120'형식으로 필드를 인쇄하는 데 사용됩니다. 이 정렬 옵션은 숫자 유형에만 유효합니다. '0'이 필드 너비 바로 앞에 오면 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="92a345d72de9b39978fa7f3c0773802f918e7f9d" translate="yes" xml:space="preserve">
          <source>Foreign functions</source>
          <target state="translated">외국 기능</target>
        </trans-unit>
        <trans-unit id="e9b0e4d2b6b7914c709024acdcc872d645aad7b3" translate="yes" xml:space="preserve">
          <source>Foreign functions can also be created by instantiating function prototypes. Function prototypes are similar to function prototypes in C; they describe a function (return type, argument types, calling convention) without defining an implementation. The factory functions must be called with the desired result type and the argument types of the function, and can be used as decorator factories, and as such, be applied to functions through the &lt;code&gt;@wrapper&lt;/code&gt; syntax. See &lt;a href=&quot;#ctypes-callback-functions&quot;&gt;Callback functions&lt;/a&gt; for examples.</source>
          <target state="translated">함수 프로토 타입을 인스턴스화하여 외부 함수를 작성할 수도 있습니다. 함수 프로토 타입은 C의 함수 프로토 타입과 유사합니다. 구현을 정의하지 않고 함수 (반환 유형, 인수 유형, 호출 규칙)를 설명합니다. 팩토리 함수는 원하는 결과 유형과 함수의 인수 유형으로 호출해야하며 데코레이터 팩토리로 사용할 수 있으며 &lt;code&gt;@wrapper&lt;/code&gt; 구문을 통해 함수에 적용 할 수 있습니다 . 예제는 &lt;a href=&quot;#ctypes-callback-functions&quot;&gt;콜백 함수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab6062a9bf3c1239139985c0532b99c45de86a25" translate="yes" xml:space="preserve">
          <source>Fork a child process, using a new pseudo-terminal as the child&amp;rsquo;s controlling terminal. Return a pair of &lt;code&gt;(pid, fd)&lt;/code&gt;, where &lt;em&gt;pid&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt; in the child, the new child&amp;rsquo;s process id in the parent, and &lt;em&gt;fd&lt;/em&gt; is the file descriptor of the master end of the pseudo-terminal. For a more portable approach, use the &lt;a href=&quot;pty#module-pty&quot;&gt;&lt;code&gt;pty&lt;/code&gt;&lt;/a&gt; module. If an error occurs &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">새로운 의사 터미널을 자식의 제어 터미널로 사용하여 자식 프로세스를 포크하십시오. &lt;code&gt;(pid, fd)&lt;/code&gt; 쌍을 리턴하십시오 . 여기서 &lt;em&gt;pid&lt;/em&gt; 는 자식에서 &lt;code&gt;0&lt;/code&gt; 이고 부모의 새 자식 프로세스 ID이며 &lt;em&gt;fd&lt;/em&gt; 는 의사 터미널의 마스터 엔드의 파일 디스크립터입니다. 보다 편리한 접근 방식을 위해서는 &lt;a href=&quot;pty#module-pty&quot;&gt; &lt;code&gt;pty&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 . 오류가 발생하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e0d97d3344fdceb7bc86849ce6036b4be1a30227" translate="yes" xml:space="preserve">
          <source>Fork a child process. Return &lt;code&gt;0&lt;/code&gt; in the child and the child&amp;rsquo;s process id in the parent. If an error occurs &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">자식 프로세스를 포크하십시오. 자식에는 &lt;code&gt;0&lt;/code&gt; 을, 부모에는 자식 프로세스 ID를 반환 합니다. 오류가 발생하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c3f80da59ba5e11794147586cf0ae148cfe6834" translate="yes" xml:space="preserve">
          <source>Fork. Connect the child&amp;rsquo;s controlling terminal to a pseudo-terminal. Return value is &lt;code&gt;(pid, fd)&lt;/code&gt;. Note that the child gets &lt;em&gt;pid&lt;/em&gt; 0, and the &lt;em&gt;fd&lt;/em&gt; is &lt;em&gt;invalid&lt;/em&gt;. The parent&amp;rsquo;s return value is the &lt;em&gt;pid&lt;/em&gt; of the child, and &lt;em&gt;fd&lt;/em&gt; is a file descriptor connected to the child&amp;rsquo;s controlling terminal (and also to the child&amp;rsquo;s standard input and output).</source>
          <target state="translated">포크. 어린이의 제어 터미널을 의사 터미널에 연결하십시오. 반환 값은 &lt;code&gt;(pid, fd)&lt;/code&gt; 입니다. 자식은 &lt;em&gt;pid&lt;/em&gt; 0을 받고 &lt;em&gt;fd&lt;/em&gt; 는 &lt;em&gt;유효하지 않습니다&lt;/em&gt; . 부모의 반환 값은 자식 의 &lt;em&gt;pid&lt;/em&gt; 이고 &lt;em&gt;fd&lt;/em&gt; 는 자식의 제어 터미널 (및 자식의 표준 입력 및 출력)에 연결된 파일 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="6e6d282a9a8ae97493898a42e4495ac86a104597" translate="yes" xml:space="preserve">
          <source>Forking and threading versions of each type of server can be created using these mix-in classes. For instance, &lt;a href=&quot;#socketserver.ThreadingUDPServer&quot;&gt;&lt;code&gt;ThreadingUDPServer&lt;/code&gt;&lt;/a&gt; is created as follows:</source>
          <target state="translated">이러한 혼합 클래스를 사용하여 각 서버 유형의 포크 및 스레딩 버전을 작성할 수 있습니다. 예를 들어 &lt;a href=&quot;#socketserver.ThreadingUDPServer&quot;&gt; &lt;code&gt;ThreadingUDPServer&lt;/code&gt; &lt;/a&gt; 는 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6232d936da3d991295fc973ffc88f6d3ca50c6ac" translate="yes" xml:space="preserve">
          <source>Form Feed</source>
          <target state="translated">용지 공급</target>
        </trans-unit>
        <trans-unit id="a8d1615368c5065046bab0898a96fbe6dca3de1c" translate="yes" xml:space="preserve">
          <source>Form Geometry Manager</source>
          <target state="translated">양식 형상 관리자</target>
        </trans-unit>
        <trans-unit id="55550d89e7ca43740394fa9c2e706f8405aa15d0" translate="yes" xml:space="preserve">
          <source>Form feed</source>
          <target state="translated">용지 공급</target>
        </trans-unit>
        <trans-unit id="bb19b54a8d464023b04f51da8fb6284d19d9c645" translate="yes" xml:space="preserve">
          <source>Formally, the Python zip application format is therefore:</source>
          <target state="translated">따라서 공식적으로 Python zip 애플리케이션 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="0b7058a284208f0fb334e10da7ad7849788c227c" translate="yes" xml:space="preserve">
          <source>Format Characters</source>
          <target state="translated">형식 문자</target>
        </trans-unit>
        <trans-unit id="270eba9fa5ca72ba811b960e20a70b4f961e511a" translate="yes" xml:space="preserve">
          <source>Format Paragraph</source>
          <target state="translated">형식 단락</target>
        </trans-unit>
        <trans-unit id="cdfbc79810d02d00dae00668258cb47d02812341" translate="yes" xml:space="preserve">
          <source>Format Specification Mini-Language</source>
          <target state="translated">형식 사양 미니 언어</target>
        </trans-unit>
        <trans-unit id="e0e31adb6cc861ffe4700cf93625baf412604bf7" translate="yes" xml:space="preserve">
          <source>Format String Syntax</source>
          <target state="translated">형식 문자열 구문</target>
        </trans-unit>
        <trans-unit id="f82f3ba2d1f13d26a5fb68ab9ee065f776ab30d9" translate="yes" xml:space="preserve">
          <source>Format Strings</source>
          <target state="translated">형식 문자열</target>
        </trans-unit>
        <trans-unit id="edf2592d9cfc0320ac33dfd0ca3fb8b951ab5d54" translate="yes" xml:space="preserve">
          <source>Format a form in HTML.</source>
          <target state="translated">HTML 형식으로 서식을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fb1728865c9987d6065233b0aabfe29331bc6f32" translate="yes" xml:space="preserve">
          <source>Format a pretty argument spec from the four values returned by &lt;a href=&quot;#inspect.getargvalues&quot;&gt;&lt;code&gt;getargvalues()&lt;/code&gt;&lt;/a&gt;. The format* arguments are the corresponding optional formatting functions that are called to turn names and values into strings.</source>
          <target state="translated">&lt;a href=&quot;#inspect.getargvalues&quot;&gt; &lt;code&gt;getargvalues()&lt;/code&gt; &lt;/a&gt; 반환 한 4 개의 값에서 예쁜 인수 스펙을 형식화하십시오 . format * 인수는 이름과 값을 문자열로 변환하기 위해 호출되는 해당 선택적 형식 지정 함수입니다.</target>
        </trans-unit>
        <trans-unit id="89d6eedb8bb9193b1b9778a5ab136660fa0cf4cd" translate="yes" xml:space="preserve">
          <source>Format a pretty argument spec from the values returned by &lt;a href=&quot;#inspect.getfullargspec&quot;&gt;&lt;code&gt;getfullargspec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#inspect.getfullargspec&quot;&gt; &lt;code&gt;getfullargspec()&lt;/code&gt; &lt;/a&gt; 반환 한 값에서 예쁜 인수 사양을 포맷합니다 .</target>
        </trans-unit>
        <trans-unit id="6684becb04a53e35be19fdc4a2836b5c2f0ba283" translate="yes" xml:space="preserve">
          <source>Format a stack trace and the exception information. The arguments have the same meaning as the corresponding arguments to &lt;a href=&quot;#traceback.print_exception&quot;&gt;&lt;code&gt;print_exception()&lt;/code&gt;&lt;/a&gt;. The return value is a list of strings, each ending in a newline and some containing internal newlines. When these lines are concatenated and printed, exactly the same text is printed as does &lt;a href=&quot;#traceback.print_exception&quot;&gt;&lt;code&gt;print_exception()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스택 추적 및 예외 정보를 형식화하십시오. 인수는 &lt;a href=&quot;#traceback.print_exception&quot;&gt; &lt;code&gt;print_exception()&lt;/code&gt; &lt;/a&gt; 해당하는 인수와 동일한 의미를 갖습니다 . 반환 값은 각각 줄 바꿈으로 끝나고 일부는 내부 줄 바꿈으로 끝나는 문자열 목록입니다. 이 행들이 연결되어 인쇄 될 때 &lt;a href=&quot;#traceback.print_exception&quot;&gt; &lt;code&gt;print_exception()&lt;/code&gt; &lt;/a&gt; 과 정확히 동일한 텍스트가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="efb013790256b8ef5e9b3a1315d0eba0e7855b24" translate="yes" xml:space="preserve">
          <source>Format a warning the standard way. This returns a string which may contain embedded newlines and ends in a newline. &lt;em&gt;line&lt;/em&gt; is a line of source code to be included in the warning message; if &lt;em&gt;line&lt;/em&gt; is not supplied, &lt;a href=&quot;#warnings.formatwarning&quot;&gt;&lt;code&gt;formatwarning()&lt;/code&gt;&lt;/a&gt; will try to read the line specified by &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;lineno&lt;/em&gt;.</source>
          <target state="translated">표준 방식으로 경고의 형식을 지정하십시오. 임베드 된 개행 문자를 포함하고 개행 문자로 끝나는 문자열을 리턴합니다. &lt;em&gt;line&lt;/em&gt; 은 경고 메시지에 포함될 소스 코드 라인입니다. 경우 &lt;em&gt;라인이&lt;/em&gt; 제공되지 않으면 &lt;a href=&quot;#warnings.formatwarning&quot;&gt; &lt;code&gt;formatwarning()&lt;/code&gt; &lt;/a&gt; 로 지정된 행 읽으려고합니다 &lt;em&gt;파일 이름&lt;/em&gt; 및 &lt;em&gt;LINENO를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="27f07db4717ed9daeb0ea1cfa7002355a47df647" translate="yes" xml:space="preserve">
          <source>Format characters have the following meaning; the conversion between C and Python values should be obvious given their types. The &amp;lsquo;Standard size&amp;rsquo; column refers to the size of the packed value in bytes when using standard size; that is, when the format string starts with one of &lt;code&gt;'&amp;lt;'&lt;/code&gt;, &lt;code&gt;'&amp;gt;'&lt;/code&gt;, &lt;code&gt;'!'&lt;/code&gt; or &lt;code&gt;'='&lt;/code&gt;. When using native size, the size of the packed value is platform-dependent.</source>
          <target state="translated">형식 문자는 다음과 같은 의미를 갖습니다. C와 Python 값 사이의 변환은 유형이 주어지면 분명해야합니다. '표준 크기'열은 표준 크기를 사용할 때 압축 된 값의 크기 (바이트)를 나타냅니다. 즉, 형식 문자열이 &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'!'&lt;/code&gt; 중 하나로 시작하는 경우 또는 &lt;code&gt;'='&lt;/code&gt; . 기본 크기를 사용할 때 압축 된 값의 크기는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a82c3163ea3ab9e53fb2cea07cd209bfb937d3de" translate="yes" xml:space="preserve">
          <source>Format examples</source>
          <target state="translated">형식 예</target>
        </trans-unit>
        <trans-unit id="1ac9d89f980b709d2eee4c28343a724ae6f0be53" translate="yes" xml:space="preserve">
          <source>Format menu (Editor window only)</source>
          <target state="translated">형식 메뉴 (편집기 창만 해당)</target>
        </trans-unit>
        <trans-unit id="5bff82abd36d7764c58ff2df3512a31d36fa2e37" translate="yes" xml:space="preserve">
          <source>Format of Version 5 Babyl Files</source>
          <target state="translated">버전 5 Babyl 파일의 형식</target>
        </trans-unit>
        <trans-unit id="1f49759e2e13c3e9c99136a9ebb248df955d8330" translate="yes" xml:space="preserve">
          <source>Format strings are the mechanism used to specify the expected layout when packing and unpacking data. They are built up from &lt;a href=&quot;#format-characters&quot;&gt;Format Characters&lt;/a&gt;, which specify the type of data being packed/unpacked. In addition, there are special characters for controlling the &lt;a href=&quot;#struct-alignment&quot;&gt;Byte Order, Size, and Alignment&lt;/a&gt;.</source>
          <target state="translated">형식 문자열은 데이터를 압축 및 압축 해제 할 때 예상되는 레이아웃을 지정하는 데 사용되는 메커니즘입니다. 이들은 포장 / 포장 해제 할 데이터 유형을 지정하는 &lt;a href=&quot;#format-characters&quot;&gt;형식 문자&lt;/a&gt; 로 구성됩니다. 또한 &lt;a href=&quot;#struct-alignment&quot;&gt;바이트 순서, 크기 및 정렬&lt;/a&gt; 을 제어하기위한 특수 문자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="977d2603bbd7ce88ed46464ff7b8c4d0bd0777d9" translate="yes" xml:space="preserve">
          <source>Format strings contain &amp;ldquo;replacement fields&amp;rdquo; surrounded by curly braces &lt;code&gt;{}&lt;/code&gt;. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">형식 문자열에는 중괄호 &lt;code&gt;{}&lt;/code&gt; 로 둘러싸인&amp;ldquo;대체 필드&amp;rdquo;가 포함 됩니다. 중괄호에 포함되지 않은 것은 리터럴 텍스트로 간주되며 변경되지 않은 채 출력으로 복사됩니다. 리터럴 텍스트에 중괄호 문자를 포함해야하는 경우 &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; 를 두 배로 늘려서 이스케이프 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="ada86ab71a0296a81d385ffe9ebda7450e9141f1" translate="yes" xml:space="preserve">
          <source>Format the current directory in HTML.</source>
          <target state="translated">현재 디렉토리를 HTML로 포맷하십시오.</target>
        </trans-unit>
        <trans-unit id="6887032ead2866abfbc852a1baf00f3a87abe4e3" translate="yes" xml:space="preserve">
          <source>Format the exception part of a traceback. The arguments are the exception type and value such as given by &lt;code&gt;sys.last_type&lt;/code&gt; and &lt;code&gt;sys.last_value&lt;/code&gt;. The return value is a list of strings, each ending in a newline. Normally, the list contains a single string; however, for &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; exceptions, it contains several lines that (when printed) display detailed information about where the syntax error occurred. The message indicating which exception occurred is the always last string in the list.</source>
          <target state="translated">역 추적의 예외 부분을 형식화하십시오. 인수는 &lt;code&gt;sys.last_type&lt;/code&gt; 및 &lt;code&gt;sys.last_value&lt;/code&gt; 에서 제공 한 예외 유형 및 값 입니다. 반환 값은 각각 줄 바꿈으로 끝나는 문자열 목록입니다. 일반적으로 목록에는 단일 문자열이 포함됩니다. 그러나 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 예외의 경우, 구문 오류가 발생한 위치에 대한 자세한 정보를 표시하는 몇 줄이 인쇄됩니다. 발생한 예외를 나타내는 메시지는 목록에서 항상 마지막 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a52a79ddad57812b440010d5464618dca805c815" translate="yes" xml:space="preserve">
          <source>Format the exception part of the traceback.</source>
          <target state="translated">역 추적의 예외 부분을 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="133a6862d1cae1284919a2f001c0aeacdd72c000" translate="yes" xml:space="preserve">
          <source>Format the exception.</source>
          <target state="translated">예외를 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="42596a2d24fc2c73e65e7068f53abc165c76e75c" translate="yes" xml:space="preserve">
          <source>Format the shell environment in HTML.</source>
          <target state="translated">쉘 환경을 HTML로 포맷하십시오.</target>
        </trans-unit>
        <trans-unit id="908af1ba6a5e39aff8925f6fe6975073286cfd06" translate="yes" xml:space="preserve">
          <source>Format the traceback as a list of lines with newlines. Use the &lt;a href=&quot;linecache#module-linecache&quot;&gt;&lt;code&gt;linecache&lt;/code&gt;&lt;/a&gt; module to retrieve lines from the source code. If &lt;em&gt;limit&lt;/em&gt; is set, format the &lt;em&gt;limit&lt;/em&gt; most recent frames if &lt;em&gt;limit&lt;/em&gt; is positive. Otherwise, format the &lt;code&gt;abs(limit)&lt;/code&gt; oldest frames. If &lt;em&gt;most_recent_first&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the order of the formatted frames is reversed, returning the most recent frame first instead of last.</source>
          <target state="translated">줄 바꿈이있는 행 목록으로 역 추적을 형식화하십시오. &lt;a href=&quot;linecache#module-linecache&quot;&gt; &lt;code&gt;linecache&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 소스 코드에서 라인을 검색 하십시오 . 경우에 &lt;em&gt;제한이&lt;/em&gt; 설정되어 포맷 &lt;em&gt;제한을&lt;/em&gt; 경우 가장 최근의 프레임을 &lt;em&gt;제한&lt;/em&gt; 긍정적이다. 그렇지 않으면 &lt;code&gt;abs(limit)&lt;/code&gt; 가장 오래된 프레임을 포맷하십시오 . 경우 &lt;em&gt;most_recent_first가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 포맷 된 프레임의 순서는 먼저 대신 마지막으로 가장 최근의 프레임을 반환, 반전됩니다.</target>
        </trans-unit>
        <trans-unit id="e94ffc42a625185c4ee1b07594bd1b3720789d8e" translate="yes" xml:space="preserve">
          <source>Formats a floating point number using the same format as the built-in function &lt;code&gt;str(float)&lt;/code&gt;, but takes the decimal point into account.</source>
          <target state="translated">내장 함수 &lt;code&gt;str(float)&lt;/code&gt; 와 동일한 형식을 사용하여 부동 소수점 숫자를 형식화 하지만 소수점을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="026a04261cdb2c80deece60787b101a3f57e7a0b" translate="yes" xml:space="preserve">
          <source>Formats a number &lt;em&gt;val&lt;/em&gt; according to the current &lt;a href=&quot;#locale.LC_MONETARY&quot;&gt;&lt;code&gt;LC_MONETARY&lt;/code&gt;&lt;/a&gt; settings.</source>
          <target state="translated">현재 &lt;a href=&quot;#locale.LC_MONETARY&quot;&gt; &lt;code&gt;LC_MONETARY&lt;/code&gt; &lt;/a&gt; 설정 에 따라 숫자 &lt;em&gt;값&lt;/em&gt; 을 형식화 합니다.</target>
        </trans-unit>
        <trans-unit id="eacb6e288f5f9db17404ead37a2ec0529507d79d" translate="yes" xml:space="preserve">
          <source>Formats a number &lt;em&gt;val&lt;/em&gt; according to the current &lt;a href=&quot;#locale.LC_NUMERIC&quot;&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt;&lt;/a&gt; setting. The format follows the conventions of the &lt;code&gt;%&lt;/code&gt; operator. For floating point values, the decimal point is modified if appropriate. If &lt;em&gt;grouping&lt;/em&gt; is true, also takes the grouping into account.</source>
          <target state="translated">현재 &lt;a href=&quot;#locale.LC_NUMERIC&quot;&gt; &lt;code&gt;LC_NUMERIC&lt;/code&gt; &lt;/a&gt; 설정 에 따라 숫자 &lt;em&gt;값&lt;/em&gt; 을 형식화 합니다. 형식은 &lt;code&gt;%&lt;/code&gt; 연산자 의 규칙을 따릅니다 . 부동 소수점 값의 경우 적절한 경우 소수점이 수정됩니다. &lt;em&gt;그룹화&lt;/em&gt; 가 참 이면 &lt;em&gt;그룹화&lt;/em&gt; 도 고려합니다.</target>
        </trans-unit>
        <trans-unit id="e0112f00a08e9d79ead751aada10a7ecf020a0c9" translate="yes" xml:space="preserve">
          <source>Formats the record and sends it to the specified addressees.</source>
          <target state="translated">레코드를 포맷하고 지정된 수신자에게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e3d51e4f2fd3c854b2bc53b4f04b934fba801ca8" translate="yes" xml:space="preserve">
          <source>Formats the specified exception information (a standard exception tuple as returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;) as a string. This default implementation just uses &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt;&lt;code&gt;traceback.print_exception()&lt;/code&gt;&lt;/a&gt;. The resulting string is returned.</source>
          <target state="translated">지정된 예외 정보 ( &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 반환 한 표준 예외 튜플 )를 문자열로 형식화 합니다. 이 기본 구현은 &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt; &lt;code&gt;traceback.print_exception()&lt;/code&gt; &lt;/a&gt; 만 사용합니다 . 결과 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="478091ac3ec3684574c3babf6b432088610f3d97" translate="yes" xml:space="preserve">
          <source>Formats the specified stack information (a string as returned by &lt;a href=&quot;traceback#traceback.print_stack&quot;&gt;&lt;code&gt;traceback.print_stack()&lt;/code&gt;&lt;/a&gt;, but with the last newline removed) as a string. This default implementation just returns the input value.</source>
          <target state="translated">지정된 스택 정보 ( &lt;a href=&quot;traceback#traceback.print_stack&quot;&gt; &lt;code&gt;traceback.print_stack()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 문자열 이지만 마지막 줄 바꿈이 제거 된 문자열)를 문자열로 형식화합니다. 이 기본 구현은 입력 값만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c7560c39c5c5ff187fc628a573d6335f1647305" translate="yes" xml:space="preserve">
          <source>Formatter Objects</source>
          <target state="translated">포맷터 객체</target>
        </trans-unit>
        <trans-unit id="fbbd31613f1e2dcbd79221469710d04b5144430c" translate="yes" xml:space="preserve">
          <source>Formatters specify the layout of log records in the final output.</source>
          <target state="translated">포맷터는 최종 출력에서 ​​로그 레코드의 레이아웃을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b447427aa08f3dda2bd0b3397dc8f0988f032e14" translate="yes" xml:space="preserve">
          <source>Formatting is performed using &lt;code&gt;PyObject_Format()&lt;/code&gt;. The result is pushed on the stack.</source>
          <target state="translated">&lt;code&gt;PyObject_Format()&lt;/code&gt; 사용하여 형식화가 수행됩니다 . 결과는 스택에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="fbf057be17177f97ad4833a585c800edbe99787a" translate="yes" xml:space="preserve">
          <source>Formatting methods for specific types are implemented as methods with a name based on the type name. In the method name, &lt;strong&gt;TYPE&lt;/strong&gt; is replaced by &lt;code&gt;'_'.join(type(obj).__name__.split())&lt;/code&gt;. Dispatch to these methods is handled by &lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt;&lt;code&gt;repr1()&lt;/code&gt;&lt;/a&gt;. Type-specific methods which need to recursively format a value should call &lt;code&gt;self.repr1(subobj, level - 1)&lt;/code&gt;.</source>
          <target state="translated">특정 형식의 형식 지정 방법은 형식 이름을 기반으로 이름이있는 메서드로 구현됩니다. 메소드 이름에서 &lt;strong&gt;TYPE&lt;/strong&gt; 은 &lt;code&gt;'_'.join(type(obj).__name__.split())&lt;/code&gt; 로 대체됩니다 . 이 메소드에 대한 디스패치는 &lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt; &lt;code&gt;repr1()&lt;/code&gt; &lt;/a&gt; 의해 처리됩니다 . 값을 재귀 적으로 형식화해야하는 유형별 메소드는 &lt;code&gt;self.repr1(subobj, level - 1)&lt;/code&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="53ee3b12a8116f5062f23c10d0f0f41886e86fc4" translate="yes" xml:space="preserve">
          <source>Fortunately, once you have managed to get your script to execute &lt;em&gt;some&lt;/em&gt; code, you can easily send tracebacks to the Web browser using the &lt;a href=&quot;cgitb#module-cgitb&quot;&gt;&lt;code&gt;cgitb&lt;/code&gt;&lt;/a&gt; module. If you haven&amp;rsquo;t done so already, just add the lines:</source>
          <target state="translated">다행스럽게도 스크립트에서 &lt;em&gt;일부&lt;/em&gt; 코드 를 실행하도록 관리 한 후에는 &lt;a href=&quot;cgitb#module-cgitb&quot;&gt; &lt;code&gt;cgitb&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 웹 브라우저에 쉽게 추적을 보낼 수 있습니다 . 아직 수행하지 않은 경우 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5e96e7529d107df0e1753fe21bd01b67d79778d3" translate="yes" xml:space="preserve">
          <source>Forwarded</source>
          <target state="translated">Forwarded</target>
        </trans-unit>
        <trans-unit id="f20aa79556158af01d19fe1bdfaaba61f2eba597" translate="yes" xml:space="preserve">
          <source>Forwarded, resent, or bounced</source>
          <target state="translated">전달, 재전송 또는 반송</target>
        </trans-unit>
        <trans-unit id="204adbe299b86a188ab068c84642d64fb57b9d04" translate="yes" xml:space="preserve">
          <source>Four input formats are allowed:</source>
          <target state="translated">네 가지 입력 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="95a1f04add15be7ebf45b9a37b275d6fe1eeba76" translate="yes" xml:space="preserve">
          <source>Fragment identifier</source>
          <target state="translated">조각 식별자</target>
        </trans-unit>
        <trans-unit id="91b0658329efa06d4da89c23a162b41dfcee5202" translate="yes" xml:space="preserve">
          <source>Frame</source>
          <target state="translated">Frame</target>
        </trans-unit>
        <trans-unit id="2c1869f6cb698c92bcc04970dc1fb69c51e4202e" translate="yes" xml:space="preserve">
          <source>Frame of a traceback.</source>
          <target state="translated">역 추적 프레임.</target>
        </trans-unit>
        <trans-unit id="ae12c8f249c1108618862d4a780aa0e958c8d187" translate="yes" xml:space="preserve">
          <source>FrameSummary Objects</source>
          <target state="translated">FrameSummary 객체</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="77cece0affae2ecaefc39ef0c2a8e23ee328ebc0" translate="yes" xml:space="preserve">
          <source>Frameworks expecting callback functions of specific signatures might be type hinted using &lt;code&gt;Callable[[Arg1Type, Arg2Type], ReturnType]&lt;/code&gt;.</source>
          <target state="translated">특정 서명의 콜백 함수를 예상하는 프레임 워크는 &lt;code&gt;Callable[[Arg1Type, Arg2Type], ReturnType]&lt;/code&gt; 사용하여 유형 힌트를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d751d8aea744f19dc0702494fa4a87cea4624802" translate="yes" xml:space="preserve">
          <source>Fran&amp;ccedil;ois Pinard</source>
          <target state="translated">프랑수아 피 나르</target>
        </trans-unit>
        <trans-unit id="676e349fb10a9ac7e26e69e9ff9f61aa2b453ac6" translate="yes" xml:space="preserve">
          <source>Fredrik Lundh elaborated and revised the class interface descriptions, to get them current with Tk 4.2.</source>
          <target state="translated">Fredrik Lundh는 클래스 인터페이스 설명을 정교하게 수정하여 Tk 4.2로 최신 정보를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="f7a46b2d862652fa6dd4ca177b3c94b34e0551df" translate="yes" xml:space="preserve">
          <source>Fredrik Lundh&amp;rsquo;s &amp;ldquo;unofficial errata, intended to clarify certain details in the XML-RPC specification, as well as hint at &amp;lsquo;best practices&amp;rsquo; to use when designing your own XML-RPC implementations.&amp;rdquo;</source>
          <target state="translated">Fredrik Lundh의&amp;ldquo;비공식 정오표는 XML-RPC 사양의 특정 세부 사항을 명확하게 설명하고 자신의 XML-RPC 구현을 설계 할 때 사용할 모범 사례에 대한 힌트를 제공합니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="7941894bbf9320910711bb27aa31db4822f37203" translate="yes" xml:space="preserve">
          <source>Freeze all the objects tracked by gc - move them to a permanent generation and ignore all the future collections. This can be used before a POSIX fork() call to make the gc copy-on-write friendly or to speed up collection. Also collection before a POSIX fork() call may free pages for future allocation which can cause copy-on-write too so it&amp;rsquo;s advised to disable gc in parent process and freeze before fork and enable gc in child process.</source>
          <target state="translated">gc로 추적 한 모든 객체를 고정합니다. 영구적으로 이동하고 향후 모든 컬렉션을 무시합니다. POSIX fork () 호출 전에 gc copy-on-write를 작성하거나 수집 속도를 높이기 위해 사용할 수 있습니다. 또한 POSIX fork () 호출 이전의 콜렉션은 나중에 할당하기 위해 페이지를 비울 수 있으므로 쓰기 중 복사도 발생할 수 있으므로 부모 프로세스에서 gc를 비활성화하고 포크 전에 동결하고 자식 프로세스에서 gc를 활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f9f6dd59fd9d87ed4234e22a85d44c72d20b660" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions About Fetchmail</source>
          <target state="translated">Fetchmail에 대한 질문과 대답</target>
        </trans-unit>
        <trans-unit id="931016677a60f24d5b6710c6675421493cdd480f" translate="yes" xml:space="preserve">
          <source>Frequently Used Arguments</source>
          <target state="translated">자주 사용되는 인수</target>
        </trans-unit>
        <trans-unit id="c8315ccb47f6bf0d7a511f023cc6a139ae985bb3" translate="yes" xml:space="preserve">
          <source>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O&amp;rsquo;Reilly Media, 2009. The third edition of the book no longer covers Python at all, but the first edition covered writing good regular expression patterns in great detail.</source>
          <target state="translated">프리들, 제프리 정규 표현식 마스터하기. 3 판, O'Reilly Media, 2009.이 책의 제 3 판은 더 이상 파이썬을 다루지 않지만, 제 1 판은 좋은 정규 표현 패턴을 매우 자세하게 작성하는 것을 다루었습니다.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="843e5f9670f08c69a59833608d59b51cae8ce9fc" translate="yes" xml:space="preserve">
          <source>From Python 2.5 onward, it&amp;rsquo;s much more convenient to cut in at the Abstract Syntax Tree (AST) generation and compilation stage, using the &lt;a href=&quot;ast#module-ast&quot;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Python 2.5부터는 &lt;a href=&quot;ast#module-ast&quot;&gt; &lt;code&gt;ast&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 AST (Abstract Syntax Tree) 생성 및 컴파일 단계에서 잘라내는 것이 훨씬 편리 합니다.</target>
        </trans-unit>
        <trans-unit id="020414031327a3ef7db22111fd1b439df6d9523d" translate="yes" xml:space="preserve">
          <source>From Python 3.2 onwards, a &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance can also be constructed directly from a &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 3.2부터 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 에서 직접 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f429dea18858dc76e2dafe218fb1bd41640f703" translate="yes" xml:space="preserve">
          <source>From Python 3.2 onwards, you can also construct a &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; instance directly from a &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">Python 3.2부터는 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 직접 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 인스턴스를 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a9212b07590ed38d2383035c9834db7561be821" translate="yes" xml:space="preserve">
          <source>From Python 3.2 onwards, you can also construct a &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; instance directly from a &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 3.2부터는 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 에서 직접 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 인스턴스를 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4eb3439bf7316847977346c0d104584a3402e3c" translate="yes" xml:space="preserve">
          <source>From an iterable of integers: &lt;code&gt;bytearray(range(20))&lt;/code&gt;</source>
          <target state="translated">반복 가능한 정수에서 : &lt;code&gt;bytearray(range(20))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d65ee2397bd4b1147e1b46eacb2bf3de76b34db" translate="yes" xml:space="preserve">
          <source>From an iterable of integers: &lt;code&gt;bytes(range(20))&lt;/code&gt;</source>
          <target state="translated">반복 가능한 정수에서 : &lt;code&gt;bytes(range(20))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce6f98bc32d8c08752e339ab6b8ff93f135e878c" translate="yes" xml:space="preserve">
          <source>From file itself</source>
          <target state="translated">파일 자체에서</target>
        </trans-unit>
        <trans-unit id="5948b3c8804d9acb15720ae7c2746d371d0a6dd0" translate="yes" xml:space="preserve">
          <source>From the application view, this means that any header obtained through the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; is a header object with extra attributes, whose string value is the fully decoded unicode value of the header. Likewise, a header may be assigned a new value, or a new header created, using a unicode string, and the policy will take care of converting the unicode string into the correct RFC encoded form.</source>
          <target state="translated">응용 프로그램보기에서 이는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 를 통해 얻은 모든 헤더 가 추가 속성이있는 헤더 객체이며 문자열 값은 헤더의 완전히 디코딩 된 유니 코드 값입니다. 마찬가지로, 유니 코드 문자열을 사용하여 헤더에 새 값 또는 새 헤더를 할당 할 수 있으며, 정책은 유니 코드 문자열을 올바른 RFC 인코딩 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="21179744e0644e6bf06e66ec0ad650d68bce7278" translate="yes" xml:space="preserve">
          <source>From the perspective of this ABC, a &lt;em&gt;resource&lt;/em&gt; is a binary artifact that is shipped within a package. Typically this is something like a data file that lives next to the &lt;code&gt;__init__.py&lt;/code&gt; file of the package. The purpose of this class is to help abstract out the accessing of such data files so that it does not matter if the package and its data file(s) are stored in a e.g. zip file versus on the file system.</source>
          <target state="translated">이 ABC의 관점에서 &lt;em&gt;자원&lt;/em&gt; 은 패키지 내에 제공되는 이진 아티팩트입니다. 일반적으로 이것은 패키지 의 &lt;code&gt;__init__.py&lt;/code&gt; 파일 옆에있는 데이터 파일과 같습니다 . 이 클래스의 목적은 패키지 및 해당 데이터 파일이 zip 파일과 파일 시스템에 저장되어 있는지 여부와 상관없이 이러한 데이터 파일에 대한 액세스를 추상화하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c3d589e23cb112ec1a392aed611bb2ec8fdbc0b4" translate="yes" xml:space="preserve">
          <source>From the top down:</source>
          <target state="translated">위에서 아래로 :</target>
        </trans-unit>
        <trans-unit id="4e50569cef50379ee448e1f2b049fa0157a0bc2d" translate="yes" xml:space="preserve">
          <source>Frozen instances</source>
          <target state="translated">고정 된 인스턴스</target>
        </trans-unit>
        <trans-unit id="d25dcf5f0613027176cc69f800b0a4c3bde6be0d" translate="yes" xml:space="preserve">
          <source>Full details of the class creation process supported by these functions</source>
          <target state="translated">이 기능들이 지원하는 클래스 생성 과정에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="657da8017607a10cc9f2aa3b39c739a2321091a5" translate="yes" xml:space="preserve">
          <source>Full documentation</source>
          <target state="translated">전체 문서</target>
        </trans-unit>
        <trans-unit id="d13f42e2080d339be6d0c5783d644631e98b32e6" translate="yes" xml:space="preserve">
          <source>Full pathname of the source file where the logging call was issued (if available).</source>
          <target state="translated">로깅 호출이 발행 된 소스 파일의 전체 경로 이름 (사용 가능한 경우).</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="5afa679cb93c0bd650f0afd89a95239d9f992f6b" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; can parse 2-digit years when given &lt;code&gt;%y&lt;/code&gt; format code. When 2-digit years are parsed, they are converted according to the POSIX and ISO C standards: values 69&amp;ndash;99 are mapped to 1969&amp;ndash;1999, and values 0&amp;ndash;68 are mapped to 2000&amp;ndash;2068.</source>
          <target state="translated">&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 함수 는 &lt;code&gt;%y&lt;/code&gt; 형식 코드가 주어지면 2 자리 연도를 구문 분석 할 수 있습니다 . 2 자리 연도를 구문 분석 할 때 POSIX 및 ISO C 표준에 따라 변환됩니다. 값 69&amp;ndash;99는 1969&amp;ndash;1999에, 0-68 값은 2000&amp;ndash;2068에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0ca544d7457648c14cce40272868cda27ebf4451" translate="yes" xml:space="preserve">
          <source>Function Objects</source>
          <target state="translated">함수 객체</target>
        </trans-unit>
        <trans-unit id="734d7223ffe438b863c3d4ed08f1962984a9515e" translate="yes" xml:space="preserve">
          <source>Function details</source>
          <target state="translated">기능 세부 사항</target>
        </trans-unit>
        <trans-unit id="bd1db34fa306e69fb02c3351244f932d38da00d3" translate="yes" xml:space="preserve">
          <source>Function keys. Up to 64 function keys are supported.</source>
          <target state="translated">기능 키. 최대 64 개의 기능 키가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1775d6d229c09c127b9640c5b78d4c4c6d982d34" translate="yes" xml:space="preserve">
          <source>Function not implemented</source>
          <target state="translated">구현되지 않은 기능</target>
        </trans-unit>
        <trans-unit id="1ab2eabce4bce0325608c94002ed583542a65dba" translate="yes" xml:space="preserve">
          <source>Function objects are created by function definitions. The only operation on a function object is to call it: &lt;code&gt;func(argument-list)&lt;/code&gt;.</source>
          <target state="translated">함수 객체는 함수 정의에 의해 생성됩니다. 함수 객체에 대한 유일한 연산은 그것을 호출하는 것입니다 : &lt;code&gt;func(argument-list)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44d21b2d2a609265eca39ae0493e9003be8fed96" translate="yes" xml:space="preserve">
          <source>Function prototypes</source>
          <target state="translated">함수 프로토 타입</target>
        </trans-unit>
        <trans-unit id="dee4cfd77aac5369a6e89ce97088e5be1bcd0c57" translate="yes" xml:space="preserve">
          <source>Function prototypes created by these factory functions can be instantiated in different ways, depending on the type and number of the parameters in the call:</source>
          <target state="translated">이러한 팩토리 함수로 작성된 함수 프로토 타입은 호출의 매개 변수 유형 및 수에 따라 다른 방식으로 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="364902d4170f1b19b4532663e7d91e3f1dc0864f" translate="yes" xml:space="preserve">
          <source>Function to be used to compare method names when sorting them in &lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt;&lt;code&gt;getTestCaseNames()&lt;/code&gt;&lt;/a&gt; and all the &lt;code&gt;loadTestsFrom*()&lt;/code&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt; &lt;code&gt;getTestCaseNames()&lt;/code&gt; &lt;/a&gt; 및 모든 &lt;code&gt;loadTestsFrom*()&lt;/code&gt; 메소드 에서 메소드 이름을 정렬 할 때 메소드 이름을 비교하는 데 사용되는 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="a052eea89f50224a7569eae8a87ea1a83e18f9d3" translate="yes" xml:space="preserve">
          <source>Functional API</source>
          <target state="translated">기능적 API</target>
        </trans-unit>
        <trans-unit id="d58bef8c404893294e965bc9372c8872c43f8fda" translate="yes" xml:space="preserve">
          <source>Functional Programming</source>
          <target state="translated">기능적 프로그래밍</target>
        </trans-unit>
        <trans-unit id="7f8a9380207393fc9db2b2b2593936320bf03503" translate="yes" xml:space="preserve">
          <source>Functional Programming Modules</source>
          <target state="translated">기능적 프로그래밍 모듈</target>
        </trans-unit>
        <trans-unit id="62daf931ffeccc7257bc3a492560ec903684c927" translate="yes" xml:space="preserve">
          <source>Functionality within this package requires that the &lt;code&gt;__main__&lt;/code&gt; module be importable by the children. This is covered in &lt;a href=&quot;#multiprocessing-programming&quot;&gt;Programming guidelines&lt;/a&gt; however it is worth pointing out here. This means that some examples, such as the &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;multiprocessing.pool.Pool&lt;/code&gt;&lt;/a&gt; examples will not work in the interactive interpreter. For example:</source>
          <target state="translated">이 패키지의 기능을 사용하려면 &lt;code&gt;__main__&lt;/code&gt; 모듈을 하위에서 가져올 수 있어야합니다 . 이것은 &lt;a href=&quot;#multiprocessing-programming&quot;&gt;프로그래밍 지침&lt;/a&gt; 에서 다루지 만 여기서 지적 할 가치가 있습니다. 이는 &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;multiprocessing.pool.Pool&lt;/code&gt; &lt;/a&gt; 예제 와 같은 일부 예제 가 대화식 인터프리터에서 작동하지 않음을 의미합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="13fe3097140d48f45796f13a773a611406bf8724" translate="yes" xml:space="preserve">
          <source>Functions and Exceptions</source>
          <target state="translated">기능과 예외</target>
        </trans-unit>
        <trans-unit id="4dde1747c55cbb65aed850307ffa6149bfedba82" translate="yes" xml:space="preserve">
          <source>Functions and classes provided:</source>
          <target state="translated">제공되는 기능 및 클래스 :</target>
        </trans-unit>
        <trans-unit id="20b1e6d5deb339e7436ae27526f0a0d790e768e8" translate="yes" xml:space="preserve">
          <source>Functions are accessed as attributes of dll objects:</source>
          <target state="translated">함수는 dll 객체의 속성으로 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc9f4ae68f16fcbe0530e1139c1d5ccbd47a458" translate="yes" xml:space="preserve">
          <source>Functions for integers</source>
          <target state="translated">정수 함수</target>
        </trans-unit>
        <trans-unit id="5aeda873fe4d68e6f1f8db4aabf74a1ac2058809" translate="yes" xml:space="preserve">
          <source>Functions for sequences</source>
          <target state="translated">시퀀스 함수</target>
        </trans-unit>
        <trans-unit id="921bac2868750926523aa803476aa0880a75d1f2" translate="yes" xml:space="preserve">
          <source>Functions or methods being mocked will have their arguments checked to ensure that they are called with the correct signature.</source>
          <target state="translated">조롱되는 함수 또는 메소드는 올바른 서명으로 호출되도록 인수를 점검합니다.</target>
        </trans-unit>
        <trans-unit id="3e1ed89bdc06bad6024febc65146a33f87bcd499" translate="yes" xml:space="preserve">
          <source>Functions registered for execution before forking are called in reverse registration order. Functions registered for execution after forking (either in the parent or in the child) are called in registration order.</source>
          <target state="translated">포크 전에 실행을 위해 등록 된 기능은 역 등록 순서로 호출됩니다. 분기 후 (부모 또는 자식) 실행을 위해 등록 된 기능은 등록 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31b99da682255324534f87c3b41fa2d80eb3d3d0" translate="yes" xml:space="preserve">
          <source>Functions that convert doctests to Python code, and possibly run the synthesized code under the debugger:</source>
          <target state="translated">doctest를 Python 코드로 변환하고 디버거에서 합성 된 코드를 실행할 수있는 함수 :</target>
        </trans-unit>
        <trans-unit id="c244de50efd900af23f95e74816e4a77ce0046dd" translate="yes" xml:space="preserve">
          <source>Functions with output parameters will automatically return the output parameter value if there is a single one, or a tuple containing the output parameter values when there are more than one, so the GetWindowRect function now returns a RECT instance, when called.</source>
          <target state="translated">출력 매개 변수가있는 함수는 출력 매개 변수 값이 하나 인 경우 또는 출력 매개 변수 값이 하나 이상인 튜플이있는 경우 자동으로 출력 매개 변수 값을 리턴하므로 GetWindowRect 함수는 이제 호출 될 때 RECT 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b0e6e4325e12bb480ddedba753c0f8ff52392cb8" translate="yes" xml:space="preserve">
          <source>Functions, Constants, and Exceptions</source>
          <target state="translated">함수, 상수 및 예외</target>
        </trans-unit>
        <trans-unit id="b4fb46cd353c41a8b5f72483a104c7283e890b98" translate="yes" xml:space="preserve">
          <source>Fundamental data types</source>
          <target state="translated">기본 데이터 유형</target>
        </trans-unit>
        <trans-unit id="75dfbb4ae8b96227bde6c5115b67cdcd67dd0280" translate="yes" xml:space="preserve">
          <source>Fundamental data types, when returned as foreign function call results, or, for example, by retrieving structure field members or array items, are transparently converted to native Python types. In other words, if a foreign function has a &lt;code&gt;restype&lt;/code&gt; of &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt;, you will always receive a Python bytes object, &lt;em&gt;not&lt;/em&gt; a &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">외래 함수 호출 결과로 반환되거나 구조 필드 멤버 또는 배열 항목을 검색하는 등의 기본 데이터 형식은 기본 Python 형식으로 투명하게 변환됩니다. 즉, 외부 함수의 &lt;code&gt;restype&lt;/code&gt; 이 &lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; 인스턴스가 &lt;em&gt;아닌&lt;/em&gt; Python bytes 객체를 항상받습니다 .</target>
        </trans-unit>
        <trans-unit id="aed766328b20ea5d898558b5e226e4031f0fcb56" translate="yes" xml:space="preserve">
          <source>Further Examples</source>
          <target state="translated">추가 예</target>
        </trans-unit>
        <trans-unit id="15f5c4496b8b834674cbc8ab8fb26c5c51e088ee" translate="yes" xml:space="preserve">
          <source>Further documentation on these functions can be found in the Platform API documentation.</source>
          <target state="translated">이러한 기능에 대한 추가 문서는 플랫폼 API 설명서에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf65796b579e013fd0c63bc3940e46318e678ee0" translate="yes" xml:space="preserve">
          <source>Further explanation is available in the FAQ entry &lt;a href=&quot;https://docs.python.org/3.8/faq/programming.html#faq-multidimensional-list&quot;&gt;How do I create a multidimensional list?&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 FAQ 항목에서 확인할 수 &lt;a href=&quot;https://docs.python.org/3.8/faq/programming.html#faq-multidimensional-list&quot;&gt;있습니다. 다차원 목록은 어떻게 만듭니 까? &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="629fce60fcf94411565c6cc87f1eb2b8f5946829" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;add_parser&lt;/code&gt; supports an additional &lt;code&gt;aliases&lt;/code&gt; argument, which allows multiple strings to refer to the same subparser. This example, like &lt;code&gt;svn&lt;/code&gt;, aliases &lt;code&gt;co&lt;/code&gt; as a shorthand for &lt;code&gt;checkout&lt;/code&gt;:</source>
          <target state="translated">또한 &lt;code&gt;add_parser&lt;/code&gt; 는 추가 &lt;code&gt;aliases&lt;/code&gt; 인수를 지원 하므로 여러 문자열이 동일한 하위 구문 분석기를 참조 할 수 있습니다. 이 예는, 같은 &lt;code&gt;svn&lt;/code&gt; , 별칭 &lt;code&gt;co&lt;/code&gt; 위한 속기로 &lt;code&gt;checkout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36c32ddb93b70b3b0d66489f7cc081835756def8" translate="yes" xml:space="preserve">
          <source>Furthermore, all functions without a return type or parameter types will implicitly default to using &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 반환 유형이나 매개 변수 유형이없는 모든 함수는 기본적으로 &lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8f0c49f21362241b8542d0a3c68222c26cf5407b" translate="yes" xml:space="preserve">
          <source>Furthermore, any functions and classes defined by the executed code are not guaranteed to work correctly after a &lt;a href=&quot;#module-runpy&quot;&gt;&lt;code&gt;runpy&lt;/code&gt;&lt;/a&gt; function has returned. If that limitation is not acceptable for a given use case, &lt;a href=&quot;importlib#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; is likely to be a more suitable choice than this module.</source>
          <target state="translated">또한 실행 된 코드로 정의 된 함수 및 클래스는 &lt;a href=&quot;#module-runpy&quot;&gt; &lt;code&gt;runpy&lt;/code&gt; &lt;/a&gt; 함수가 리턴 된 후에 올바르게 작동하지 않을 수 있습니다 . 주어진 사용 사례에 대해 이러한 제한이 허용되지 않는 경우 &lt;a href=&quot;importlib#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 가이 모듈보다 더 적합한 선택 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0555f6f9e263f192be068a009836d2a2523e37d9" translate="yes" xml:space="preserve">
          <source>Furthermore, there is not a compelling case for arbitrarily altering the object graph of loggers, handlers, filters, formatters at run-time, once a configuration is set up; the verbosity of loggers and handlers can be controlled just by setting levels (and, in the case of loggers, propagation flags). Changing the object graph arbitrarily in a safe way is problematic in a multi-threaded environment; while not impossible, the benefits are not worth the complexity it adds to the implementation.</source>
          <target state="translated">또한, 일단 구성이 설정되면 런타임에 로거, 핸들러, 필터, 포맷터의 객체 그래프를 임의로 변경하는 강력한 사례는 없습니다. 로거 및 처리기의 세부 정보는 레벨을 설정하여 (및 로거의 경우 전파 플래그) 설정하여 제어 할 수 있습니다. 안전한 방식으로 객체 그래프를 임의로 변경하는 것은 멀티 스레드 환경에서 문제가됩니다. 불가능하지는 않지만 그 이점은 구현에 추가되는 복잡성에 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="46806aa64dafed90bfb876c61bba7987d063cf08" translate="yes" xml:space="preserve">
          <source>Fused multiply-add. Return self*other+third with no rounding of the intermediate product self*other.</source>
          <target state="translated">융합 곱셈 추가. 중간 제품 자체의 반올림없이 self * other + third를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="ed8b6a30978a9c952f9c9df10088a33c954813bd" translate="yes" xml:space="preserve">
          <source>Future Functions</source>
          <target state="translated">향후 기능</target>
        </trans-unit>
        <trans-unit id="040c5373d5621aa737e101cc596fa0199c9dc5ff" translate="yes" xml:space="preserve">
          <source>Future Object</source>
          <target state="translated">미래의 목표</target>
        </trans-unit>
        <trans-unit id="7afdbd06b8b7618d0daf7e6ccc98c609e58e8e9f" translate="yes" xml:space="preserve">
          <source>Future Objects</source>
          <target state="translated">미래 객체</target>
        </trans-unit>
        <trans-unit id="18e4acee739b17a1065f82661408ae77421afefb" translate="yes" xml:space="preserve">
          <source>Future is an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-awaitable&quot;&gt;awaitable&lt;/a&gt; object. Coroutines can await on Future objects until they either have a result or an exception set, or until they are cancelled.</source>
          <target state="translated">미래는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-awaitable&quot;&gt;기다릴 수있는&lt;/a&gt; 대상입니다. 코 루틴은 결과 또는 예외 세트가 있거나 취소 될 때까지 Future 객체를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3feb6a8fec72549860ff9b054d1b990159ab9d6c" translate="yes" xml:space="preserve">
          <source>Future objects in asyncio are needed to allow callback-based code to be used with async/await.</source>
          <target state="translated">콜백 기반 코드를 async / await와 함께 사용하려면 asyncio의 향후 객체가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c35a0717de250776c3a109889f261085ce97" translate="yes" xml:space="preserve">
          <source>Future objects, sometimes exposed by libraries and some asyncio APIs, can be awaited:</source>
          <target state="translated">때때로 라이브러리 및 일부 asyncio API에 의해 노출되는 미래의 객체를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5fcc0b7fc3f9b4a713a58338f8eab747e7ec9c4" translate="yes" xml:space="preserve">
          <source>Future statements</source>
          <target state="translated">향후 진술</target>
        </trans-unit>
        <trans-unit id="293b9c2c76d6969ac75fae9cc6bc05878d13b9ce" translate="yes" xml:space="preserve">
          <source>Future statements are specified by bits which can be bitwise ORed together to specify multiple statements. The bitfield required to specify a given feature can be found as the &lt;code&gt;compiler_flag&lt;/code&gt; attribute on the &lt;code&gt;_Feature&lt;/code&gt; instance in the &lt;a href=&quot;__future__#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">미래의 진술은 비트로 지정되어 여러 개의 진술을 지정하기 위해 함께 비트 OR 될 수 있습니다. 지정된 기능을 지정하는 데 필요한 비트 필드 는 &lt;a href=&quot;__future__#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;code&gt;_Feature&lt;/code&gt; 인스턴스에서 &lt;code&gt;compiler_flag&lt;/code&gt; 속성 으로 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="943e868a2624e15afba6299f4ed4ded48727c51e" translate="yes" xml:space="preserve">
          <source>FutureWarning</source>
          <target state="translated">FutureWarning</target>
        </trans-unit>
        <trans-unit id="965db80f650641f51dead99c13720e4035c9ef70" translate="yes" xml:space="preserve">
          <source>Futures</source>
          <target state="translated">Futures</target>
        </trans-unit>
        <trans-unit id="4c25945d461c0634df34d19c19a37fb40386b467" translate="yes" xml:space="preserve">
          <source>GEN_CLOSED: Execution has completed.</source>
          <target state="translated">GEN_CLOSED : 실행이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="650b3ffe0606ed0d5caee29b91e192c6db844113" translate="yes" xml:space="preserve">
          <source>GEN_CREATED: Waiting to start execution.</source>
          <target state="translated">GEN_CREATED : 실행을 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="b1fe62534e6aac45bba898aa978e224194a8f480" translate="yes" xml:space="preserve">
          <source>GEN_RUNNING: Currently being executed by the interpreter.</source>
          <target state="translated">GEN_RUNNING : 현재 통역사에서 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="2643066350ead1c0a8664b7667b6b4bc694078a2" translate="yes" xml:space="preserve">
          <source>GEN_SUSPENDED: Currently suspended at a yield expression.</source>
          <target state="translated">GEN_SUSPENDED : 현재 수익률 표현식에서 일시 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="a246c5f8bb908d1c393f6923487aecfa272e691b" translate="yes" xml:space="preserve">
          <source>GIF 87a and 89a Files</source>
          <target state="translated">GIF 87a 및 89a 파일</target>
        </trans-unit>
        <trans-unit id="29b0c001de448507eeda37b597ce4ce0ec650ba5" translate="yes" xml:space="preserve">
          <source>GNOME uses a version of the &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module by James Henstridge, but this version has a slightly different API. Its documented usage was:</source>
          <target state="translated">그놈은 James Henstridge 의 &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈 버전을 사용 하지만이 버전은 API가 약간 다릅니다. 문서화 된 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6520e025af22317712e26a57b07cbcd978f6fae" translate="yes" xml:space="preserve">
          <source>GNU &lt;strong&gt;gettext&lt;/strong&gt; API</source>
          <target state="translated">GNU &lt;strong&gt;gettext&lt;/strong&gt; API</target>
        </trans-unit>
        <trans-unit id="0852894f9b2a41ca0b12f6e51a66ede0a0cffce6" translate="yes" xml:space="preserve">
          <source>GNU tar format.</source>
          <target state="translated">GNU 타르 형식.</target>
        </trans-unit>
        <trans-unit id="77104d0ac72d310bfb0a065e06a3dcbeab2ef352" translate="yes" xml:space="preserve">
          <source>GNU tar manual, Basic Tar Format</source>
          <target state="translated">GNU 타르 매뉴얼, 기본 타르 형식</target>
        </trans-unit>
        <trans-unit id="f1c7eabb625a30cd8386b723eb7564d690dc3bda" translate="yes" xml:space="preserve">
          <source>GUI classes</source>
          <target state="translated">GUI 클래스</target>
        </trans-unit>
        <trans-unit id="cdac0a16fe6c8715769cabffbcf5b111542185f3" translate="yes" xml:space="preserve">
          <source>Gamma distribution. (&lt;em&gt;Not&lt;/em&gt; the gamma function!) Conditions on the parameters are &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt; and &lt;code&gt;beta &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">감마 분포. ( 감마 기능이 &lt;em&gt;아닙니다&lt;/em&gt; !) 매개 변수의 조건은 &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt; 및 &lt;code&gt;beta &amp;gt; 0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c36f27f079aad3d99c9aa2c98a958440131d7a5" translate="yes" xml:space="preserve">
          <source>Gathering statistics about garbage collection, such as how often various generations are collected, and how long the collection takes.</source>
          <target state="translated">다양한 세대가 수집되는 빈도 및 수집 시간과 같은 가비지 수집에 대한 통계 수집</target>
        </trans-unit>
        <trans-unit id="94e14ba841dd9989631b47b319bec6cacb6f1eea" translate="yes" xml:space="preserve">
          <source>Gaussian distribution. &lt;em&gt;mu&lt;/em&gt; is the mean, and &lt;em&gt;sigma&lt;/em&gt; is the standard deviation. This is slightly faster than the &lt;a href=&quot;#random.normalvariate&quot;&gt;&lt;code&gt;normalvariate()&lt;/code&gt;&lt;/a&gt; function defined below.</source>
          <target state="translated">가우스 분포. &lt;em&gt;mu&lt;/em&gt; 는 평균이고 &lt;em&gt;sigma&lt;/em&gt; 는 표준 편차입니다. 이것은 아래 정의 된 &lt;a href=&quot;#random.normalvariate&quot;&gt; &lt;code&gt;normalvariate()&lt;/code&gt; &lt;/a&gt; 함수 보다 약간 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="d5884a44b6d020c29a2f374e66fdf68d2522d7a5" translate="yes" xml:space="preserve">
          <source>General calendar related functions.</source>
          <target state="translated">일반 캘린더 관련 기능.</target>
        </trans-unit>
        <trans-unit id="c55d5d54d0be20d8b60e13b1e058e6199fc67a9b" translate="yes" xml:space="preserve">
          <source>General calendar-related functions. &lt;a href=&quot;calendar#calendar.timegm&quot;&gt;&lt;code&gt;timegm()&lt;/code&gt;&lt;/a&gt; is the inverse of &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt; from this module.</source>
          <target state="translated">일반적인 캘린더 관련 기능. &lt;a href=&quot;calendar#calendar.timegm&quot;&gt; &lt;code&gt;timegm()&lt;/code&gt; &lt;/a&gt; 은이 모듈 의 &lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; 의 역입니다 .</target>
        </trans-unit>
        <trans-unit id="9ceee6648db6ad65058c1365753f6d071c93ac56" translate="yes" xml:space="preserve">
          <source>General format. For a given precision &lt;code&gt;p &amp;gt;= 1&lt;/code&gt;, this rounds the number to &lt;code&gt;p&lt;/code&gt; significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude.</source>
          <target state="translated">일반적인 형식. 주어진 정밀도 &lt;code&gt;p &amp;gt;= 1&lt;/code&gt; , 이것은 숫자를 &lt;code&gt;p&lt;/code&gt; 유효 숫자 로 반올림 한 다음 그 크기에 따라 고정 소수점 형식 또는 과학적 표기법으로 결과를 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="f322561eef774a62c9210e7625ce378d4c97d613" translate="yes" xml:space="preserve">
          <source>General format. Same as &lt;code&gt;'g'&lt;/code&gt; except switches to &lt;code&gt;'E'&lt;/code&gt; if the number gets too large. The representations of infinity and NaN are uppercased, too.</source>
          <target state="translated">일반적인 형식. 숫자가 너무 커지면 &lt;code&gt;'E'&lt;/code&gt; 로 전환한다는 점을 제외하고 &lt;code&gt;'g'&lt;/code&gt; 와 동일 합니다. 무한대와 NaN의 표현도 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="ede442e713df309353f00b1e6c5eca3991f17a5a" translate="yes" xml:space="preserve">
          <source>General properties</source>
          <target state="translated">일반 속성</target>
        </trans-unit>
        <trans-unit id="bf6bda4587aff077462187186bdf6576ccc550c7" translate="yes" xml:space="preserve">
          <source>General rules</source>
          <target state="translated">일반적인 규칙</target>
        </trans-unit>
        <trans-unit id="068195143092a9c76f7f35d028344c892962b8b0" translate="yes" xml:space="preserve">
          <source>General strictness switches:</source>
          <target state="translated">일반 엄격 스위치 :</target>
        </trans-unit>
        <trans-unit id="e4a6b871e250a74d5d8b375dda6c5463d02ee60e" translate="yes" xml:space="preserve">
          <source>Generally synchronization primitives are not as necessary in a multiprocess program as they are in a multithreaded program. See the documentation for &lt;a href=&quot;threading#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">일반적으로 동기화 프리미티브는 다중 스레드 프로그램에서와 같이 다중 프로세스 프로그램에서 필요하지 않습니다. &lt;a href=&quot;threading#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="18a9756dceb01305df40a47834a42c5432a22e44" translate="yes" xml:space="preserve">
          <source>Generally, argument defaults are specified either by passing a default to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; or by calling the &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt;&lt;code&gt;set_defaults()&lt;/code&gt;&lt;/a&gt; methods with a specific set of name-value pairs. Sometimes however, it may be useful to specify a single parser-wide default for arguments. This can be accomplished by passing the &lt;code&gt;argument_default=&lt;/code&gt; keyword argument to &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;. For example, to globally suppress attribute creation on &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; calls, we supply &lt;code&gt;argument_default=SUPPRESS&lt;/code&gt;:</source>
          <target state="translated">일반적으로 인수 기본값은 기본값을 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 에 전달 하거나 특정 이름-값 쌍 세트로 &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt; &lt;code&gt;set_defaults()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 지정됩니다. 그러나 때로는 인수에 단일 파서 전체 기본값을 지정하는 것이 유용 할 수 있습니다. &lt;code&gt;argument_default=&lt;/code&gt; 키워드 인수를 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 에 전달하면 됩니다. 예를 들어 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 호출에서 속성 생성을 전역 적으로 억제하려면 &lt;code&gt;argument_default=SUPPRESS&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="760d892cb151b00c2aba0b8d86a8bb2cd386807c" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;SIGABRT&lt;/code&gt; signal to the current process. On Unix, the default behavior is to produce a core dump; on Windows, the process immediately returns an exit code of &lt;code&gt;3&lt;/code&gt;. Be aware that calling this function will not call the Python signal handler registered for &lt;code&gt;SIGABRT&lt;/code&gt; with &lt;a href=&quot;signal#signal.signal&quot;&gt;&lt;code&gt;signal.signal()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 프로세스에 대한 &lt;code&gt;SIGABRT&lt;/code&gt; 신호를 생성하십시오 . 유닉스에서 기본 동작은 코어 덤프를 생성하는 것입니다. Windows에서 프로세스는 즉시 종료 코드 &lt;code&gt;3&lt;/code&gt; 을 리턴합니다 . 이 함수를 호출하면 등록 된 파이썬 신호 처리기를 호출하지 않습니다주의 &lt;code&gt;SIGABRT&lt;/code&gt; 와 &lt;a href=&quot;signal#signal.signal&quot;&gt; &lt;code&gt;signal.signal()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58a95565098b688544062529a9855e160d91e91d" translate="yes" xml:space="preserve">
          <source>Generate a CAB file, add it as a stream to the MSI file, put it into the &lt;code&gt;Media&lt;/code&gt; table, and remove the generated file from the disk.</source>
          <target state="translated">CAB 파일을 생성하여 MSI 파일에 스트림으로 추가 한 후 &lt;code&gt;Media&lt;/code&gt; 테이블에 넣고 디스크에서 생성 된 파일을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="5329a732ca7f35819388ce77de62767aca915104" translate="yes" xml:space="preserve">
          <source>Generate a UUID based on the MD5 hash of a namespace identifier (which is a UUID) and a name (which is a string).</source>
          <target state="translated">네임 스페이스 식별자 (UUID)와 이름 (문자열)의 MD5 해시를 기반으로 UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e254e1d1587616df23d81a95de4537b712650d32" translate="yes" xml:space="preserve">
          <source>Generate a UUID based on the SHA-1 hash of a namespace identifier (which is a UUID) and a name (which is a string).</source>
          <target state="translated">네임 스페이스 식별자 (UUID)와 이름 (문자열)의 SHA-1 해시를 기반으로 UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3e2dda6f18229b616248722abe6bc7c08b0ae156" translate="yes" xml:space="preserve">
          <source>Generate a UUID from a host ID, sequence number, and the current time. If &lt;em&gt;node&lt;/em&gt; is not given, &lt;a href=&quot;#uuid.getnode&quot;&gt;&lt;code&gt;getnode()&lt;/code&gt;&lt;/a&gt; is used to obtain the hardware address. If &lt;em&gt;clock_seq&lt;/em&gt; is given, it is used as the sequence number; otherwise a random 14-bit sequence number is chosen.</source>
          <target state="translated">호스트 ID, 시퀀스 번호 및 현재 시간에서 UUID를 생성하십시오. 경우 &lt;em&gt;노드가&lt;/em&gt; 특정되지 않고, &lt;a href=&quot;#uuid.getnode&quot;&gt; &lt;code&gt;getnode()&lt;/code&gt; &lt;/a&gt; 하드웨어 어드레스를 획득하기 위해 사용된다. 경우 &lt;em&gt;clock_seq가&lt;/em&gt; 주어진다, 이는 일련 번호로 사용된다; 그렇지 않으면 임의의 14 비트 시퀀스 번호가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fe41ab241f1f685b0dbb424e0207c19044174796" translate="yes" xml:space="preserve">
          <source>Generate a hard-to-guess temporary URL containing a security token suitable for password recovery applications:</source>
          <target state="translated">비밀번호 복구 애플리케이션에 적합한 보안 토큰을 포함하여 추측하기 어려운 임시 URL을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c2ffe2e554218a5f937438f8460923a2c93a492c" translate="yes" xml:space="preserve">
          <source>Generate a random UUID.</source>
          <target state="translated">임의의 UUID를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="eeabda0fa004edbf77932a794b4287d23b30cd9b" translate="yes" xml:space="preserve">
          <source>Generate a stereo fragment from a mono fragment. Each pair of samples in the stereo fragment are computed from the mono sample, whereby left channel samples are multiplied by &lt;em&gt;lfactor&lt;/em&gt; and right channel samples by &lt;em&gt;rfactor&lt;/em&gt;.</source>
          <target state="translated">모노 프래그먼트에서 스테레오 프래그먼트를 생성합니다. 스테레오 프래그먼트의 각 샘플 쌍은 모노 샘플에서 계산되므로 왼쪽 채널 샘플에는 &lt;em&gt;lfactor가&lt;/em&gt; , 오른쪽 채널 샘플에는 &lt;em&gt;rfactor&lt;/em&gt; 가 &lt;em&gt;곱해집니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0de2380f61c8b3b5ce97b16629785ba2f3c883" translate="yes" xml:space="preserve">
          <source>Generate a ten-character alphanumeric password with at least one lowercase character, at least one uppercase character, and at least three digits:</source>
          <target state="translated">하나 이상의 소문자, 하나 이상의 대문자 및 3 자리 이상의 10 자리 영숫자 암호를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d737efc68fd8c95bb0b04bfa067c27c815266bd2" translate="yes" xml:space="preserve">
          <source>Generate an &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;XKCD-style passphrase&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://xkcd.com/936/&quot;&gt;XKCD 스타일 비밀번호 문구를&lt;/a&gt; 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5254e77c49e3726b9ce7afa0602745d90779e6d7" translate="yes" xml:space="preserve">
          <source>Generate an eight-character alphanumeric password:</source>
          <target state="translated">8 자리 영숫자 비밀번호를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9c47bb489aa92718ba831cc71a1f8f2e2fe4b431" translate="yes" xml:space="preserve">
          <source>Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory &lt;em&gt;top&lt;/em&gt; (including &lt;em&gt;top&lt;/em&gt; itself), it yields a 3-tuple &lt;code&gt;(dirpath, dirnames,
filenames)&lt;/code&gt;.</source>
          <target state="translated">트리를 하향식 또는 상향식으로 걸어 디렉토리 트리에서 파일 이름을 생성하십시오. 디렉토리 &lt;em&gt;상단을&lt;/em&gt; 루트로하는 트리의 각 디렉토리 ( &lt;em&gt;상단&lt;/em&gt; 자체 포함 )에 대해 3 개의 튜플 &lt;code&gt;(dirpath, dirnames, filenames)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a176b8716da502b7a00a24adf4a150b1dcaccace" translate="yes" xml:space="preserve">
          <source>Generated just after setting the focus item to open=False.</source>
          <target state="translated">포커스 항목을 open = False로 설정 한 직후 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0376f849b020636ee4b54a60454a83645273bf92" translate="yes" xml:space="preserve">
          <source>Generated just before settings the focus item to open=True.</source>
          <target state="translated">포커스 항목을 열기 = 참으로 설정하기 직전에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="725cd661f4740654b5db99af933817749928d8b8" translate="yes" xml:space="preserve">
          <source>Generated pseudo-random byte sequences will be unique if they are of sufficient length, but are not necessarily unpredictable. They can be used for non-cryptographic purposes and for certain purposes in cryptographic protocols, but usually not for key generation etc.</source>
          <target state="translated">생성 된 의사 랜덤 바이트 시퀀스는 길이가 충분하지만 반드시 예측할 수없는 경우 고유합니다. 비 암호화 목적 및 암호화 프로토콜의 특정 목적으로 사용될 수 있지만 일반적으로 키 생성에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ead06510ef285ebb7f6220395aade6782b29c550" translate="yes" xml:space="preserve">
          <source>Generated whenever the selection changes.</source>
          <target state="translated">선택이 변경 될 때마다 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b0bc8d38af1670401a998afe93ec1319cc1b94a4" translate="yes" xml:space="preserve">
          <source>Generates &lt;em&gt;n&lt;/em&gt; random samples for a given mean and standard deviation. Returns a &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">주어진 평균 및 표준 편차에 대해 &lt;em&gt;n 개의&lt;/em&gt; 랜덤 샘플을 생성 합니다. &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 값 의 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="eac497b73b4148960c71a958d63bde7183c58b8a" translate="yes" xml:space="preserve">
          <source>Generates a string representation of an XML element, including all subelements. &lt;em&gt;element&lt;/em&gt; is an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; instance. &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is the output encoding (default is US-ASCII). Use &lt;code&gt;encoding=&quot;unicode&quot;&lt;/code&gt; to generate a Unicode string (otherwise, a bytestring is generated). &lt;em&gt;method&lt;/em&gt; is either &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, &lt;code&gt;&quot;html&quot;&lt;/code&gt; or &lt;code&gt;&quot;text&quot;&lt;/code&gt; (default is &lt;code&gt;&quot;xml&quot;&lt;/code&gt;). &lt;em&gt;xml_declaration&lt;/em&gt;, &lt;em&gt;default_namespace&lt;/em&gt; and &lt;em&gt;short_empty_elements&lt;/em&gt; has the same meaning as in &lt;a href=&quot;#xml.etree.ElementTree.ElementTree.write&quot;&gt;&lt;code&gt;ElementTree.write()&lt;/code&gt;&lt;/a&gt;. Returns an (optionally) encoded string containing the XML data.</source>
          <target state="translated">모든 하위 요소를 포함하여 XML 요소의 문자열 표현을 생성합니다. &lt;em&gt;element&lt;/em&gt; 는 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. &lt;em&gt;인코딩 &lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 은 출력 인코딩입니다 (기본값은 US-ASCII). 사용 &lt;code&gt;encoding=&quot;unicode&quot;&lt;/code&gt; 유니 코드 문자열 (그렇지 않으면 bytestring 생성되는)를 생성한다. &lt;em&gt;method&lt;/em&gt; 는 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; , &lt;code&gt;&quot;html&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;text&quot;&lt;/code&gt; 입니다 (기본값은 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; ). &lt;em&gt;xml_declaration&lt;/em&gt; , &lt;em&gt;default_namespace&lt;/em&gt; 및 &lt;em&gt;short_empty_elements&lt;/em&gt; 는 &lt;a href=&quot;#xml.etree.ElementTree.ElementTree.write&quot;&gt; &lt;code&gt;ElementTree.write()&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 .XML 데이터를 포함하는 (선택적) 인코딩 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6204d45d6bba3d8356ab2594a70a820efafd7b4b" translate="yes" xml:space="preserve">
          <source>Generates a string representation of an XML element, including all subelements. &lt;em&gt;element&lt;/em&gt; is an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; instance. &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt; is the output encoding (default is US-ASCII). Use &lt;code&gt;encoding=&quot;unicode&quot;&lt;/code&gt; to generate a Unicode string (otherwise, a bytestring is generated). &lt;em&gt;method&lt;/em&gt; is either &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, &lt;code&gt;&quot;html&quot;&lt;/code&gt; or &lt;code&gt;&quot;text&quot;&lt;/code&gt; (default is &lt;code&gt;&quot;xml&quot;&lt;/code&gt;). &lt;em&gt;xml_declaration&lt;/em&gt;, &lt;em&gt;default_namespace&lt;/em&gt; and &lt;em&gt;short_empty_elements&lt;/em&gt; has the same meaning as in &lt;a href=&quot;#xml.etree.ElementTree.ElementTree.write&quot;&gt;&lt;code&gt;ElementTree.write()&lt;/code&gt;&lt;/a&gt;. Returns a list of (optionally) encoded strings containing the XML data. It does not guarantee any specific sequence, except that &lt;code&gt;b&quot;&quot;.join(tostringlist(element)) == tostring(element)&lt;/code&gt;.</source>
          <target state="translated">모든 하위 요소를 포함하여 XML 요소의 문자열 표현을 생성합니다. &lt;em&gt;element&lt;/em&gt; 는 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. &lt;em&gt;인코딩 &lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt; 은 출력 인코딩입니다 (기본값은 US-ASCII). 사용 &lt;code&gt;encoding=&quot;unicode&quot;&lt;/code&gt; 유니 코드 문자열 (그렇지 않으면 bytestring 생성되는)를 생성한다. &lt;em&gt;method&lt;/em&gt; 는 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; , &lt;code&gt;&quot;html&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;text&quot;&lt;/code&gt; 입니다 (기본값은 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; ). &lt;em&gt;xml_declaration&lt;/em&gt; , &lt;em&gt;default_namespace&lt;/em&gt; 및 &lt;em&gt;short_empty_elements&lt;/em&gt; 는 &lt;a href=&quot;#xml.etree.ElementTree.ElementTree.write&quot;&gt; &lt;code&gt;ElementTree.write()&lt;/code&gt; &lt;/a&gt; 에서와 동일한 의미를 갖습니다.. XML 데이터를 포함하는 (선택적) 인코딩 된 문자열 목록을 리턴합니다. &lt;code&gt;b&quot;&quot;.join(tostringlist(element)) == tostring(element)&lt;/code&gt; 이외의 특정 순서는 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="708786a80761c18bb49de75d753c2402b77bb538" translate="yes" xml:space="preserve">
          <source>Generating Symbol Tables</source>
          <target state="translated">심볼 테이블 생성</target>
        </trans-unit>
        <trans-unit id="47e3a19806fd6ae855bc1e14ecf253bfc6c478ca" translate="yes" xml:space="preserve">
          <source>Generating a plist:</source>
          <target state="translated">plist 생성 :</target>
        </trans-unit>
        <trans-unit id="cbad253020b7e1c56a37eb457d6613f3ba57d4a8" translate="yes" xml:space="preserve">
          <source>Generating tokens</source>
          <target state="translated">토큰 생성</target>
        </trans-unit>
        <trans-unit id="e3833cf62cfdb901cbd45270e457754bafbc5c12" translate="yes" xml:space="preserve">
          <source>Generator Types</source>
          <target state="translated">발전기 유형</target>
        </trans-unit>
        <trans-unit id="f1c6dab37c8f8bbc2a1a1c78f437217210eb50ad" translate="yes" xml:space="preserve">
          <source>Generator-based Coroutines</source>
          <target state="translated">발전기 기반 코 루틴</target>
        </trans-unit>
        <trans-unit id="9318bd97ef11f214febd817fed04cbde02eb2197" translate="yes" xml:space="preserve">
          <source>Generator-based coroutines predate async/await syntax. They are Python generators that use &lt;code&gt;yield from&lt;/code&gt; expressions to await on Futures and other coroutines.</source>
          <target state="translated">생성기 기반 코 루틴은 비동기 / 대기 구문보다 우선합니다. 그들은 미래의 코 루틴을 기다리기 위해 식의 &lt;code&gt;yield from&lt;/code&gt; 을 사용하는 파이썬 생성기입니다 .</target>
        </trans-unit>
        <trans-unit id="c463bc7eba03866e87736c2166b5208e94578261" translate="yes" xml:space="preserve">
          <source>Generator-based coroutines should be decorated with &lt;a href=&quot;#asyncio.coroutine&quot;&gt;&lt;code&gt;@asyncio.coroutine&lt;/code&gt;&lt;/a&gt;, although this is not enforced.</source>
          <target state="translated">생성기 기반 코 루틴은 &lt;a href=&quot;#asyncio.coroutine&quot;&gt; &lt;code&gt;@asyncio.coroutine&lt;/code&gt; &lt;/a&gt; 으로 장식해야 하지만, 적용되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="091c54c4935a2ee35bc6aef14311233891434110" translate="yes" xml:space="preserve">
          <source>GeneratorExit</source>
          <target state="translated">GeneratorExit</target>
        </trans-unit>
        <trans-unit id="0e0fbaa97fbe2d5968844c44481eeeeaa9d8cf4d" translate="yes" xml:space="preserve">
          <source>Generic Operating System Services</source>
          <target state="translated">일반 운영 체제 서비스</target>
        </trans-unit>
        <trans-unit id="4ef339fbad9266b6e7fe779f770b71d1ef6059da" translate="yes" xml:space="preserve">
          <source>Generic element structure builder. This builder converts a sequence of start, data, end, comment and pi method calls to a well-formed element structure. You can use this class to build an element structure using a custom XML parser, or a parser for some other XML-like format.</source>
          <target state="translated">일반 요소 구조 빌더. 이 빌더는 start, data, end, comment 및 pi 메소드 호출 순서를 올바른 형식의 요소 구조로 변환합니다. 이 클래스를 사용하여 사용자 정의 XML 파서를 사용하거나 다른 XML 형식의 파서를 사용하여 요소 구조를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03071c1aabb41ff2ab0d6cc5a458c21d1dd11e1c" translate="yes" xml:space="preserve">
          <source>Generic implementation of the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;&lt;code&gt;load_tests&lt;/code&gt; protocol for use in test packages. &lt;em&gt;pkg_dir&lt;/em&gt; is the root directory of the package; &lt;em&gt;loader&lt;/em&gt;, &lt;em&gt;standard_tests&lt;/em&gt;, and &lt;em&gt;pattern&lt;/em&gt; are the arguments expected by &lt;code&gt;load_tests&lt;/code&gt;. In simple cases, the test package&amp;rsquo;s &lt;code&gt;__init__.py&lt;/code&gt; can be the following:</source>
          <target state="translated">테스트 패키지에 사용하기위한 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; &lt;code&gt;load_tests&lt;/code&gt; 프로토콜 의 일반적인 구현 . &lt;em&gt;pkg_dir&lt;/em&gt; 은 패키지의 루트 디렉토리입니다. &lt;em&gt;loader&lt;/em&gt; , &lt;em&gt;standard_tests&lt;/em&gt; 및 &lt;em&gt;pattern&lt;/em&gt; 은 &lt;code&gt;load_tests&lt;/code&gt; 에 의해 예상되는 인수 입니다. 간단한 경우 테스트 패키지의 &lt;code&gt;__init__.py&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="293fd67a1e9b6b131f8a1081860292ba633bb726" translate="yes" xml:space="preserve">
          <source>Generic interface to &lt;code&gt;dbm&lt;/code&gt;-style databases.</source>
          <target state="translated">&lt;code&gt;dbm&lt;/code&gt; 스타일 데이터베이스에 대한 일반 인터페이스</target>
        </trans-unit>
        <trans-unit id="ccb8e82277924f89b0be2c9144f908b084a885ad" translate="yes" xml:space="preserve">
          <source>Generic type &lt;code&gt;IO[AnyStr]&lt;/code&gt; and its subclasses &lt;code&gt;TextIO(IO[str])&lt;/code&gt; and &lt;code&gt;BinaryIO(IO[bytes])&lt;/code&gt; represent the types of I/O streams such as returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 유형 &lt;code&gt;IO[AnyStr]&lt;/code&gt; 및 해당 서브 클래스 &lt;code&gt;TextIO(IO[str])&lt;/code&gt; 및 &lt;code&gt;BinaryIO(IO[bytes])&lt;/code&gt; 는 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의해 리턴되는 I / O 스트림의 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a3b7c04b18cd92e8bd3dbd66ec9303b0a0d542df" translate="yes" xml:space="preserve">
          <source>Generic version of &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as &lt;a href=&quot;#typing.Sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#typing.Iterable&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; 의&lt;/a&gt; 일반 버전 . 반환 유형에 주석을 달 때 유용합니다. 인수에 주석을 &lt;a href=&quot;#typing.Iterable&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#typing.Sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt; 또는 Iterable 과 같은 추상 컬렉션 유형을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="0945c1dff6718f21aa4e4deeaab1b0eddc4c4cdc" translate="yes" xml:space="preserve">
          <source>Generics can be parameterized by using a new factory available in typing called &lt;a href=&quot;#typing.TypeVar&quot;&gt;&lt;code&gt;TypeVar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#typing.TypeVar&quot;&gt; &lt;code&gt;TypeVar&lt;/code&gt; &lt;/a&gt; 라는 타이핑에서 사용 가능한 새로운 팩토리를 사용하여 제네릭을 매개 변수화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f99913680f7b744ab9431fbca519442e0fa1092" translate="yes" xml:space="preserve">
          <source>Geometric mean of data.</source>
          <target state="translated">데이터의 기하 평균.</target>
        </trans-unit>
        <trans-unit id="da91388c72d3e31da19dcd85c97374197748485d" translate="yes" xml:space="preserve">
          <source>German</source>
          <target state="translated">German</target>
        </trans-unit>
        <trans-unit id="5e3619ade03466db61cd043463581c6cfbb2ff29" translate="yes" xml:space="preserve">
          <source>Get HTTP headers</source>
          <target state="translated">HTTP 헤더 가져 오기</target>
        </trans-unit>
        <trans-unit id="f09a08050952ccfb3acada1aca77f75efbcddc68" translate="yes" xml:space="preserve">
          <source>Get Mac OS version information and return it as tuple &lt;code&gt;(release, versioninfo,
machine)&lt;/code&gt; with &lt;em&gt;versioninfo&lt;/em&gt; being a tuple &lt;code&gt;(version, dev_stage,
non_release_version)&lt;/code&gt;.</source>
          <target state="translated">맥 OS 버전 정보를 확인하고 튜플로 반환 &lt;code&gt;(release, versioninfo, machine)&lt;/code&gt; 와 &lt;em&gt;VERSIONINFO&lt;/em&gt; 튜플 인 &lt;code&gt;(version, dev_stage, non_release_version)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="925b109ddf15351d05a8dddb0cb2a1abe8a6314b" translate="yes" xml:space="preserve">
          <source>Get a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; object for &lt;em&gt;module_or_name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;module_or_name&lt;/em&gt; 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 객체를 &lt;em&gt;가져옵니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="72d86f39c38483c75cc09653c3ddc241de805a8b" translate="yes" xml:space="preserve">
          <source>Get a character, returning a string instead of an integer, as &lt;a href=&quot;#curses.window.getch&quot;&gt;&lt;code&gt;getch()&lt;/code&gt;&lt;/a&gt; does. Function keys, keypad keys and other special keys return a multibyte string containing the key name. In no-delay mode, raise an exception if there is no input.</source>
          <target state="translated">&lt;a href=&quot;#curses.window.getch&quot;&gt; &lt;code&gt;getch()&lt;/code&gt; &lt;/a&gt; 와 같이 정수 대신 문자열을 반환하여 문자를 가져 옵니다 . 기능 키, 키패드 키 및 기타 특수 키는 키 이름이 포함 된 멀티 바이트 문자열을 반환합니다. 지연 없음 모드에서 입력이 없으면 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6900a0c6cf3e15082dad7841462c7795b199570e" translate="yes" xml:space="preserve">
          <source>Get a character. Note that the integer returned does &lt;em&gt;not&lt;/em&gt; have to be in ASCII range: function keys, keypad keys and so on are represented by numbers higher than 255. In no-delay mode, return &lt;code&gt;-1&lt;/code&gt; if there is no input, otherwise wait until a key is pressed.</source>
          <target state="translated">캐릭터를 얻으십시오. 반환 된 정수는 ASCII 범위 일 필요 는 &lt;em&gt;없습니다&lt;/em&gt; . 기능 키, 키패드 키 등은 255보다 큰 숫자로 표시됩니다. 지연없는 모드에서는 입력이 없으면 &lt;code&gt;-1&lt;/code&gt; 을 반환하고 , 그렇지 않으면 키가 될 때까지 기다립니다 를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="93b9156a4fc2066890c20b75a92de09ebab9456c" translate="yes" xml:space="preserve">
          <source>Get a child process watcher object.</source>
          <target state="translated">자식 프로세스 감시자 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="39098f6d062afd1a16e563ea56384bfbee189021" translate="yes" xml:space="preserve">
          <source>Get a description for a single group &lt;em&gt;group&lt;/em&gt;. If more than one group matches (if &amp;lsquo;group&amp;rsquo; is a real wildmat string), return the first match. If no group matches, return an empty string.</source>
          <target state="translated">단일 그룹 &lt;em&gt;그룹에&lt;/em&gt; 대한 설명을 가져옵니다 . 둘 이상의 그룹이 일치하면 ( 'group'이 실제 와일드 매트 문자열 인 경우) 첫 번째 일치를 리턴하십시오. 일치하는 그룹이 없으면 빈 문자열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6df154c15550831d92d53462e0064abdf70ba6e4" translate="yes" xml:space="preserve">
          <source>Get a format string for &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; to represent a date in a locale-specific era-based way.</source>
          <target state="translated">로케일 별 시대 기반 방식으로 날짜를 나타내는 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 의 형식 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="21a8f80cea6f42070d455f9a01f487c95110be35" translate="yes" xml:space="preserve">
          <source>Get a format string for &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; to represent a time in a locale-specific era-based way.</source>
          <target state="translated">로케일 별 시대 기반 방식으로 시간을 나타내는 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 의 형식 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="36cacd63f5269b7f2289c301e7939d05fc6f8a5c" translate="yes" xml:space="preserve">
          <source>Get a format string for &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; to represent date and time in a locale-specific era-based way.</source>
          <target state="translated">로케일 별 시대 기반 방식으로 날짜 및 시간을 나타내는 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 의 형식 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7d7dfbaa516474dd4c7e1837620af5c2c9270f58" translate="yes" xml:space="preserve">
          <source>Get a format string for &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; to represent time in the am/pm format.</source>
          <target state="translated">시간을 am / pm 형식으로 나타내는 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 의 형식 문자열을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="779b4604d3285273845eec25f955cd191148bbb6" translate="yes" xml:space="preserve">
          <source>Get a list of enabled ciphers. The list is in order of cipher priority. See &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">활성화 된 암호 목록을 가져옵니다. 이 목록은 암호 우선 순위입니다. &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e7ce190d87e4a26bc8ee72ce60dccb04d75c9a2" translate="yes" xml:space="preserve">
          <source>Get a list of frame records for a frame and all outer frames. These frames represent the calls that lead to the creation of &lt;em&gt;frame&lt;/em&gt;. The first entry in the returned list represents &lt;em&gt;frame&lt;/em&gt;; the last entry represents the outermost call on &lt;em&gt;frame&lt;/em&gt;&amp;rsquo;s stack.</source>
          <target state="translated">프레임 및 모든 외부 프레임에 대한 프레임 레코드 목록을 가져옵니다. 이 프레임의 창조로 이어질 호출 대표 &lt;em&gt;프레임을&lt;/em&gt; . 반환 된 목록의 첫 번째 항목은 &lt;em&gt;프레임을&lt;/em&gt; 나타냅니다 . 마지막 항목은 &lt;em&gt;프레임&lt;/em&gt; 스택 의 가장 바깥 쪽 호출을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7f4c093b2f65ea31077045cdbdc6cb56aae52fea" translate="yes" xml:space="preserve">
          <source>Get a list of frame records for a traceback&amp;rsquo;s frame and all inner frames. These frames represent calls made as a consequence of &lt;em&gt;frame&lt;/em&gt;. The first entry in the list represents &lt;em&gt;traceback&lt;/em&gt;; the last entry represents where the exception was raised.</source>
          <target state="translated">역 추적 프레임과 모든 내부 프레임에 대한 프레임 레코드 목록을 가져옵니다. 이 프레임의 결과로 만들어 호출 대표 &lt;em&gt;프레임을&lt;/em&gt; . 목록의 첫 번째 항목은 &lt;em&gt;역 추적을&lt;/em&gt; 나타냅니다 . 마지막 항목은 예외가 발생한 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f1cb38ae88663b4d14fae92b17af5d048a78c197" translate="yes" xml:space="preserve">
          <source>Get a list of loaded &amp;ldquo;certification authority&amp;rdquo; (CA) certificates. If the &lt;code&gt;binary_form&lt;/code&gt; parameter is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; each list entry is a dict like the output of &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt;&lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt;&lt;/a&gt;. Otherwise the method returns a list of DER-encoded certificates. The returned list does not contain certificates from &lt;em&gt;capath&lt;/em&gt; unless a certificate was requested and loaded by a SSL connection.</source>
          <target state="translated">로드 된 &quot;인증 기관&quot;(CA) 인증서 목록을 가져옵니다. &lt;code&gt;binary_form&lt;/code&gt; 매개 변수가 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 이면 각 목록 항목은 &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt; &lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt; &lt;/a&gt; 의 출력과 같은 dict 입니다. 그렇지 않으면이 메소드는 DER 인코딩 된 인증서 목록을 리턴합니다. SSL 연결에 의해 인증서가 요청되고로드되지 않은 경우, 리턴 된 목록에는 &lt;em&gt;capath&lt;/em&gt; 의 인증서가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4d5e35a9ec661b8b336617dd56388e3578f9bcaf" translate="yes" xml:space="preserve">
          <source>Get a list of records for a frame and all higher (calling) and lower frames, and the size of the higher part.</source>
          <target state="translated">프레임 및 모든 상위 (호출) 및 하위 프레임에 대한 레코드 목록과 상위 부분의 크기를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b607418b2f9f5fc800736360b9d80cde873b574c" translate="yes" xml:space="preserve">
          <source>Get a regular expression that can be used with the regex function to recognize a positive response to a yes/no question.</source>
          <target state="translated">예 / 아니오 질문에 대한 긍정적 인 응답을 인식하기 위해 정규식 함수와 함께 사용할 수있는 정규식을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="79a142b2d506f97b9fb5762c6cdf9c0302dc08af" translate="yes" xml:space="preserve">
          <source>Get a regular expression that can be used with the regex(3) function to recognize a negative response to a yes/no question.</source>
          <target state="translated">예 / 아니오 질문에 대한 부정적인 응답을 인식하기 위해 regex (3) 함수와 함께 사용할 수있는 정규식을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d3eeac88da2cc27ce1e1ed87177dc3dfa221e00e" translate="yes" xml:space="preserve">
          <source>Get a representation of up to 100 values used to represent the values 0 to 99.</source>
          <target state="translated">0에서 99까지의 값을 나타내는 데 사용되는 최대 100 개의 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="64b3b1f3e933b44a31fc73a92cc1c78260a70a72" translate="yes" xml:space="preserve">
          <source>Get a resource from a package.</source>
          <target state="translated">패키지에서 리소스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7fe7caecfd8320cedfe667b5784ba16646cca4d6" translate="yes" xml:space="preserve">
          <source>Get a string that can be used as a format string for &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; to represent a date in a locale-specific way.</source>
          <target state="translated">로케일 별 방식으로 날짜를 나타내는 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 의 형식 문자열로 사용할 수있는 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="311be40c8088b83ef5389b49e19888ce42e3323e" translate="yes" xml:space="preserve">
          <source>Get a string that can be used as a format string for &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; to represent a time in a locale-specific way.</source>
          <target state="translated">로케일 별 방식으로 시간을 나타 내기 위해 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 의 형식 문자열로 사용할 수있는 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2716d1bcbc1da0920dc17276d3e242e7949d040e" translate="yes" xml:space="preserve">
          <source>Get a string that can be used as a format string for &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; to represent date and time in a locale-specific way.</source>
          <target state="translated">로케일 별 방식으로 날짜 및 시간을 표시하기 위해 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 의 형식 문자열로 사용할 수있는 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c22c4986b7973b0bdf63cc50710f9ea10065ba7b" translate="yes" xml:space="preserve">
          <source>Get a string that represents the era used in the current locale.</source>
          <target state="translated">현재 로케일에 사용 된 시대를 나타내는 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8ecbeb2948a064a1d000fcce4ea7595bf126a0a3" translate="yes" xml:space="preserve">
          <source>Get a string with the name of the character encoding used in the selected locale.</source>
          <target state="translated">선택한 로케일에 사용 된 문자 인코딩의 이름으로 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3e20e2ff8c2d677c284ec272725f5d83c5c4213a" translate="yes" xml:space="preserve">
          <source>Get a wide character. Return a character for most keys, or an integer for function keys, keypad keys, and other special keys. In no-delay mode, raise an exception if there is no input.</source>
          <target state="translated">넓은 캐릭터를 얻으십시오. 대부분의 키의 문자 또는 기능 키, 키패드 키 및 기타 특수 키의 정수를 반환합니다. 지연 없음 모드에서 입력이 없으면 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f7d2c3adbad9eae4cd085407b57af1cda7e455a0" translate="yes" xml:space="preserve">
          <source>Get additional version information from the Windows Registry and return a tuple &lt;code&gt;(release, version, csd, ptype)&lt;/code&gt; referring to OS release, version number, CSD level (service pack) and OS type (multi/single processor).</source>
          <target state="translated">Windows 레지스트리에서 추가 버전 정보를 얻고 OS 릴리스, 버전 번호, CSD 레벨 (서비스 팩) 및 OS 유형 (멀티 / 단일 프로세서)을 참조 하는 튜플 &lt;code&gt;(release, version, csd, ptype)&lt;/code&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="9deb349b97a97850ba9998a4ae913d86c706f166" translate="yes" xml:space="preserve">
          <source>Get an &lt;em&gt;option&lt;/em&gt; value for the named &lt;em&gt;section&lt;/em&gt;. If &lt;em&gt;vars&lt;/em&gt; is provided, it must be a dictionary. The &lt;em&gt;option&lt;/em&gt; is looked up in &lt;em&gt;vars&lt;/em&gt; (if provided), &lt;em&gt;section&lt;/em&gt;, and in &lt;em&gt;DEFAULTSECT&lt;/em&gt; in that order. If the key is not found and &lt;em&gt;fallback&lt;/em&gt; is provided, it is used as a fallback value. &lt;code&gt;None&lt;/code&gt; can be provided as a &lt;em&gt;fallback&lt;/em&gt; value.</source>
          <target state="translated">가져 오기 &lt;em&gt;옵션&lt;/em&gt; 명명 된 가치 &lt;em&gt;섹션을&lt;/em&gt; . 경우 &lt;em&gt;바르가&lt;/em&gt; 제공되고, 그것은 사전 있어야합니다. &lt;em&gt;옵션&lt;/em&gt; 에서 조회됩니다 &lt;em&gt;바르&lt;/em&gt; (있는 경우), &lt;em&gt;섹션&lt;/em&gt; , 그리고에 &lt;em&gt;DEFAULTSECT&lt;/em&gt; 순서대로. 키를 찾을 수없고 &lt;em&gt;폴 백이&lt;/em&gt; 제공되면 폴백 값으로 사용됩니다. &lt;code&gt;None&lt;/code&gt; A와 제공 할 수없는 &lt;em&gt;대체&lt;/em&gt; 값.</target>
        </trans-unit>
        <trans-unit id="08f3c39de28bbb234f03726aa9b5ed3ded2bd201" translate="yes" xml:space="preserve">
          <source>Get an attribute, raising &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt;&lt;code&gt;unittest.SkipTest&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 가 발생 하면 &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt; &lt;code&gt;unittest.SkipTest&lt;/code&gt; 를&lt;/a&gt; 발생시키는 속성을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="01ae41efe44d095c763c4c0a0f3afb34f4d7e286" translate="yes" xml:space="preserve">
          <source>Get an event loop instance (current or via the policy).</source>
          <target state="translated">현재 또는 정책을 통해 이벤트 루프 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="09e57fb7d36421267708207c1d86d1574ffc7414" translate="yes" xml:space="preserve">
          <source>Get channel binding data for current connection, as a bytes object. Returns &lt;code&gt;None&lt;/code&gt; if not connected or the handshake has not been completed.</source>
          <target state="translated">현재 연결에 대한 채널 바인딩 데이터를 bytes 객체로 가져옵니다. 연결되지 않았거나 핸드 셰이크가 완료되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3f64df69cb849e00861c89ea45d6eb10e222793a" translate="yes" xml:space="preserve">
          <source>Get current state of a coroutine object. The function is intended to be used with coroutine objects created by &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; functions, but will accept any coroutine-like object that has &lt;code&gt;cr_running&lt;/code&gt; and &lt;code&gt;cr_frame&lt;/code&gt; attributes.</source>
          <target state="translated">코 루틴 오브젝트의 현재 상태를 가져옵니다. 이 함수는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성 된 코 루틴 객체와 함께 사용 되지만 &lt;code&gt;cr_running&lt;/code&gt; 및 &lt;code&gt;cr_frame&lt;/code&gt; 속성 을 가진 코 루틴 유사 객체를 받아들 입니다.</target>
        </trans-unit>
        <trans-unit id="3bb4f5a84c2768dc4799d08ccb39e5edf77da68e" translate="yes" xml:space="preserve">
          <source>Get current state of a generator-iterator.</source>
          <target state="translated">생성기-반복기의 현재 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d23ebf469da242376e8f1406637cf81a48764515" translate="yes" xml:space="preserve">
          <source>Get information about a frame or traceback object. A &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;Traceback(filename, lineno, function, code_context, index)&lt;/code&gt; is returned.</source>
          <target state="translated">프레임 또는 트레이스 백 객체에 대한 정보를 얻습니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;라는 튜플 &lt;/a&gt; &lt;code&gt;Traceback(filename, lineno, function, code_context, index)&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="b5c10f03a20464d9e4021f1c2f9a0a198366fccb" translate="yes" xml:space="preserve">
          <source>Get information about arguments passed into a particular frame. A &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;ArgInfo(args, varargs, keywords, locals)&lt;/code&gt; is returned. &lt;em&gt;args&lt;/em&gt; is a list of the argument names. &lt;em&gt;varargs&lt;/em&gt; and &lt;em&gt;keywords&lt;/em&gt; are the names of the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; arguments or &lt;code&gt;None&lt;/code&gt;. &lt;em&gt;locals&lt;/em&gt; is the locals dictionary of the given frame.</source>
          <target state="translated">특정 프레임으로 전달 된 인수에 대한 정보를 얻습니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;라는 이름의 튜플 &lt;/a&gt; &lt;code&gt;ArgInfo(args, varargs, keywords, locals)&lt;/code&gt; 반환됩니다. &lt;em&gt;args&lt;/em&gt; 는 인수 이름의 목록입니다. &lt;em&gt;varargs&lt;/em&gt; 및 &lt;em&gt;키워드&lt;/em&gt; 는 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 인수 의 이름 또는 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;em&gt;locals&lt;/em&gt; 는 주어진 프레임의 지역 사전입니다.</target>
        </trans-unit>
        <trans-unit id="82b4c672b45ae2ae6c3a3440d2312eaaed338213" translate="yes" xml:space="preserve">
          <source>Get information on the specified clock as a namespace object. Supported clock names and the corresponding functions to read their value are:</source>
          <target state="translated">지정된 시계에 대한 정보를 네임 스페이스 객체로 가져옵니다. 지원되는 시계 이름과 해당 값을 읽는 해당 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b8c4ad525dab4788364bb3a3c2c58bb4651d6cd" translate="yes" xml:space="preserve">
          <source>Get line &lt;em&gt;lineno&lt;/em&gt; from file named &lt;em&gt;filename&lt;/em&gt;. This function will never raise an exception &amp;mdash; it will return &lt;code&gt;''&lt;/code&gt; on errors (the terminating newline character will be included for lines that are found).</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일&lt;/em&gt; 에서 &lt;em&gt;lineno&lt;/em&gt; 라인을 가져 &lt;em&gt;옵니다&lt;/em&gt; . 이 함수는 예외를 발생시키지 않으며 오류시 &lt;code&gt;''&lt;/code&gt; 를 반환 합니다 (발견 된 줄에는 종료 줄 바꿈 문자가 포함됨).</target>
        </trans-unit>
        <trans-unit id="56abfe685ae982167bb48299cfb9366af1b3abe6" translate="yes" xml:space="preserve">
          <source>Get mailbox status. The result is a tuple of 2 integers: &lt;code&gt;(message count,
mailbox size)&lt;/code&gt;.</source>
          <target state="translated">사서함 상태를 가져옵니다. 결과는 &lt;code&gt;(message count, mailbox size)&lt;/code&gt; 의 두 정수 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="7725098627fdeaae6f27cbee4c8b4b5dc41d897e" translate="yes" xml:space="preserve">
          <source>Get or set the current default isolation level. &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; for autocommit mode or one of &amp;ldquo;DEFERRED&amp;rdquo;, &amp;ldquo;IMMEDIATE&amp;rdquo; or &amp;ldquo;EXCLUSIVE&amp;rdquo;. See section &lt;a href=&quot;#sqlite3-controlling-transactions&quot;&gt;Controlling Transactions&lt;/a&gt; for a more detailed explanation.</source>
          <target state="translated">현재 기본 격리 수준을 가져 오거나 설정하십시오. 자동 커밋 모드 또는 &quot;DEFERRED&quot;, &quot;IMMEDIATE&quot;또는 &quot;EXCLUSIVE&quot;중 하나에 해당 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . 보다 자세한 설명은 &lt;a href=&quot;#sqlite3-controlling-transactions&quot;&gt;거래 관리&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bc03417d6cbea7e3ecb6629fad7db83a931b0a6" translate="yes" xml:space="preserve">
          <source>Get program scheduling priority. The value &lt;em&gt;which&lt;/em&gt; is one of &lt;a href=&quot;#os.PRIO_PROCESS&quot;&gt;&lt;code&gt;PRIO_PROCESS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.PRIO_PGRP&quot;&gt;&lt;code&gt;PRIO_PGRP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#os.PRIO_USER&quot;&gt;&lt;code&gt;PRIO_USER&lt;/code&gt;&lt;/a&gt;, and &lt;em&gt;who&lt;/em&gt; is interpreted relative to &lt;em&gt;which&lt;/em&gt; (a process identifier for &lt;a href=&quot;#os.PRIO_PROCESS&quot;&gt;&lt;code&gt;PRIO_PROCESS&lt;/code&gt;&lt;/a&gt;, process group identifier for &lt;a href=&quot;#os.PRIO_PGRP&quot;&gt;&lt;code&gt;PRIO_PGRP&lt;/code&gt;&lt;/a&gt;, and a user ID for &lt;a href=&quot;#os.PRIO_USER&quot;&gt;&lt;code&gt;PRIO_USER&lt;/code&gt;&lt;/a&gt;). A zero value for &lt;em&gt;who&lt;/em&gt; denotes (respectively) the calling process, the process group of the calling process, or the real user ID of the calling process.</source>
          <target state="translated">프로그램 예약 우선 순위를 가져옵니다. 값 중 하나 &lt;a href=&quot;#os.PRIO_PROCESS&quot;&gt; &lt;code&gt;PRIO_PROCESS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.PRIO_PGRP&quot;&gt; &lt;code&gt;PRIO_PGRP&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.PRIO_USER&quot;&gt; &lt;code&gt;PRIO_USER&lt;/code&gt; &lt;/a&gt; 및 상대 해석 &lt;em&gt;하는&lt;/em&gt; (위한 프로세스 식별자 &lt;a href=&quot;#os.PRIO_PROCESS&quot;&gt; &lt;code&gt;PRIO_PROCESS&lt;/code&gt; &lt;/a&gt; 위한 프로세스 그룹 식별자 &lt;a href=&quot;#os.PRIO_PGRP&quot;&gt; &lt;code&gt;PRIO_PGRP&lt;/code&gt; &lt;/a&gt; 및위한 사용자 ID &lt;a href=&quot;#os.PRIO_USER&quot;&gt; &lt;code&gt;PRIO_USER&lt;/code&gt; &lt;/a&gt; ). 호출 프로세스, 호출 프로세스의 프로세스 그룹 또는 호출 프로세스의 실제 사용자 ID를 (각각) 나타내는 &lt;em&gt;누가&lt;/em&gt; 값이 0 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d02c37308a4ca42011190869a6abe80a460bff7" translate="yes" xml:space="preserve">
          <source>Get source code segment of the &lt;em&gt;source&lt;/em&gt; that generated &lt;em&gt;node&lt;/em&gt;. If some location information (&lt;code&gt;lineno&lt;/code&gt;, &lt;code&gt;end_lineno&lt;/code&gt;, &lt;code&gt;col_offset&lt;/code&gt;, or &lt;code&gt;end_col_offset&lt;/code&gt;) is missing, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;노드&lt;/em&gt; 를 생성 한 &lt;em&gt;소스&lt;/em&gt; 의 소스 코드 세그먼트를 가져 &lt;em&gt;옵니다&lt;/em&gt; . 일부 위치 정보 ( &lt;code&gt;lineno&lt;/code&gt; , &lt;code&gt;end_lineno&lt;/code&gt; , &lt;code&gt;col_offset&lt;/code&gt; 또는 &lt;code&gt;end_col_offset&lt;/code&gt; )가 없으면 &lt;code&gt;None&lt;/code&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d32ba11b8ed874a1d107cf2469497841bdeac2d" translate="yes" xml:space="preserve">
          <source>Get statistics about quantities of loaded X.509 certificates, count of X.509 certificates flagged as CA certificates and certificate revocation lists as dictionary.</source>
          <target state="translated">로드 된 X.509 인증서의 수량, CA 인증서로 플래그 된 X.509 인증서 수 및 인증서 해지 목록을 사전으로 통계를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5cca3416b42404100e335aaac411014a84493036" translate="yes" xml:space="preserve">
          <source>Get statistics about the SSL sessions created or managed by this context. A dictionary is returned which maps the names of each &lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html&quot;&gt;piece of information&lt;/a&gt; to their numeric values. For example, here is the total number of hits and misses in the session cache since the context was created:</source>
          <target state="translated">이 컨텍스트에서 작성하거나 관리하는 SSL 세션에 대한 통계를 가져옵니다. 각 &lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html&quot;&gt;정보&lt;/a&gt; 의 이름을 숫자 값으로 매핑하는 사전이 반환 됩니다. 예를 들어, 컨텍스트가 작성된 이후 세션 캐시에서 총 히트 및 누락 수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0034d7cf901bfe3dc98a8e569a5fa6dfdc2d9a7f" translate="yes" xml:space="preserve">
          <source>Get statistics as a sorted list of &lt;a href=&quot;#tracemalloc.Statistic&quot;&gt;&lt;code&gt;Statistic&lt;/code&gt;&lt;/a&gt; instances grouped by &lt;em&gt;key_type&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;key_type&lt;/em&gt; 별로 그룹화 된 &lt;a href=&quot;#tracemalloc.Statistic&quot;&gt; &lt;code&gt;Statistic&lt;/code&gt; &lt;/a&gt; 인스턴스 의 정렬 된 목록으로 통계 를 &lt;em&gt;가져옵니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="71a0d0c6b96d9e27bc9d9b0133075d626bb1a8a5" translate="yes" xml:space="preserve">
          <source>Get the &amp;ldquo;inheritable&amp;rdquo; flag of the specified file descriptor (a boolean).</source>
          <target state="translated">지정된 파일 디스크립터 (부울)의 &quot;상속 가능한&quot;플래그를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6da89fa1ba2bf713a2515d037096219c1c84b16e" translate="yes" xml:space="preserve">
          <source>Get the &amp;ldquo;inheritable&amp;rdquo; flag of the specified handle (a boolean).</source>
          <target state="translated">지정된 핸들 (부울)의 &quot;상속 가능한&quot;플래그를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="99a204199f8ab11de39c4cefe33c73816977b3b5" translate="yes" xml:space="preserve">
          <source>Get the &lt;a href=&quot;os#fd-inheritance&quot;&gt;inheritable flag&lt;/a&gt; of the socket&amp;rsquo;s file descriptor or socket&amp;rsquo;s handle: &lt;code&gt;True&lt;/code&gt; if the socket can be inherited in child processes, &lt;code&gt;False&lt;/code&gt; if it cannot.</source>
          <target state="translated">소켓의 파일 기술자 또는 소켓 핸들 의 &lt;a href=&quot;os#fd-inheritance&quot;&gt;상속 가능한 플래그&lt;/a&gt; 를 가져옵니다. 소켓이 자식 프로세스에서 상속 될 수 있으면 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다.</target>
        </trans-unit>
        <trans-unit id="a11594e7f4440dd22817c1d42fb3dfdf5a8fae93" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;ACL&lt;/code&gt;s for &lt;em&gt;mailbox&lt;/em&gt;. The method is non-standard, but is supported by the &lt;code&gt;Cyrus&lt;/code&gt; server.</source>
          <target state="translated">가져 오기 &lt;code&gt;ACL&lt;/code&gt; 에 대한들 &lt;em&gt;사서함&lt;/em&gt; . 이 방법은 비표준이지만 &lt;code&gt;Cyrus&lt;/code&gt; 서버에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="62ed1935a345fb89b1f42290845822923a2d4e23" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;quota&lt;/code&gt;&lt;em&gt;root&lt;/em&gt;&amp;rsquo;s resource usage and limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.</source>
          <target state="translated">&lt;code&gt;quota&lt;/code&gt; &lt;em&gt;루트&lt;/em&gt; 의 리소스 사용량 및 한도를 가져 옵니다 . 이 방법은 rfc2087에 정의 된 IMAP4 QUOTA 확장의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="3a961039695bf6ec70838cd0a62ba649bc21c194" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;high&lt;/em&gt; and &lt;em&gt;low&lt;/em&gt; watermarks for write flow control. Return a tuple &lt;code&gt;(low, high)&lt;/code&gt; where &lt;em&gt;low&lt;/em&gt; and &lt;em&gt;high&lt;/em&gt; are positive number of bytes.</source>
          <target state="translated">가져 오기 &lt;em&gt;높은&lt;/em&gt; 및 &lt;em&gt;낮은&lt;/em&gt; 쓰기 흐름 제어를위한 워터 마크를. 튜플 반환 &lt;code&gt;(low, high)&lt;/code&gt; &lt;em&gt;낮은&lt;/em&gt; 및 &lt;em&gt;높은&lt;/em&gt; 바이트의 양수됩니다.</target>
        </trans-unit>
        <trans-unit id="950213a057a7b0f3c148a395b7d76a1a57669d58" translate="yes" xml:space="preserve">
          <source>Get the abbreviated name of the n-th day of the week.</source>
          <target state="translated">요일 n 번째 날의 약칭을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2606b866e21df1e456ea346f3ba77c930e8e772e" translate="yes" xml:space="preserve">
          <source>Get the abbreviated name of the n-th month.</source>
          <target state="translated">n 번째 달의 약칭을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cd047d70fed736913d2d4ddb822753146b7e0c61" translate="yes" xml:space="preserve">
          <source>Get the beginning or ending index of the completion scope. These indexes are the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; arguments passed to the &lt;code&gt;rl_attempted_completion_function&lt;/code&gt; callback of the underlying library.</source>
          <target state="translated">완료 범위의 시작 또는 끝 색인을 가져옵니다. 이 인덱스는 기본 라이브러리 의 &lt;code&gt;rl_attempted_completion_function&lt;/code&gt; 콜백에 전달 된 &lt;em&gt;시작&lt;/em&gt; 및 &lt;em&gt;끝&lt;/em&gt; 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="2a36e6bb528c0dc3b81202199caa718a57570eb8" translate="yes" xml:space="preserve">
          <source>Get the blocking mode of the file descriptor: &lt;code&gt;False&lt;/code&gt; if the &lt;a href=&quot;#os.O_NONBLOCK&quot;&gt;&lt;code&gt;O_NONBLOCK&lt;/code&gt;&lt;/a&gt; flag is set, &lt;code&gt;True&lt;/code&gt; if the flag is cleared.</source>
          <target state="translated">파일 기술자의 블록 모드를 가져옵니다 : &lt;code&gt;False&lt;/code&gt; 경우 &lt;a href=&quot;#os.O_NONBLOCK&quot;&gt; &lt;code&gt;O_NONBLOCK&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정되어 &lt;code&gt;True&lt;/code&gt; 플래그을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="8d75e1fa5d5d51e274fc8468c8ced8caf9883e2e" translate="yes" xml:space="preserve">
          <source>Get the byte stream for this input source.</source>
          <target state="translated">이 입력 소스의 바이트 스트림을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2dd1f4352605a34e9229c97f7a82c7f75c343dc1" translate="yes" xml:space="preserve">
          <source>Get the character encoding of this InputSource.</source>
          <target state="translated">이 InputSource의 문자 인코딩을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="95de35f00d3f32900bfe5c66c4ea0aaa669628f3" translate="yes" xml:space="preserve">
          <source>Get the character stream for this input source.</source>
          <target state="translated">이 입력 소스의 문자 스트림을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="18faa6d92447d0677d396db1eec4f83e30d32ce8" translate="yes" xml:space="preserve">
          <source>Get the completer function, or &lt;code&gt;None&lt;/code&gt; if no completer function has been set.</source>
          <target state="translated">완료 기능을 얻거나 완료 기능이 설정되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 옵니다 .</target>
        </trans-unit>
        <trans-unit id="c9552545be668379a153f9b3e0012ad6492851ac" translate="yes" xml:space="preserve">
          <source>Get the currency symbol, preceded by &amp;ldquo;-&amp;rdquo; if the symbol should appear before the value, &amp;ldquo;+&amp;rdquo; if the symbol should appear after the value, or &amp;ldquo;.&amp;rdquo; if the symbol should replace the radix character.</source>
          <target state="translated">값 앞에 기호를 표시하려면 &quot;-&quot;가 앞에 오는 통화 기호를, 값 뒤에 기호가 나타나면 &quot;+&quot;를 가져 오거나 &quot;.&quot; 기호가 기수 문자를 대체해야하는 경우</target>
        </trans-unit>
        <trans-unit id="af676806212458a98a5fcaf1ecd37e932430adf7" translate="yes" xml:space="preserve">
          <source>Get the current coroutine origin tracking depth, as set by &lt;a href=&quot;#sys.set_coroutine_origin_tracking_depth&quot;&gt;&lt;code&gt;set_coroutine_origin_tracking_depth()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sys.set_coroutine_origin_tracking_depth&quot;&gt; &lt;code&gt;set_coroutine_origin_tracking_depth()&lt;/code&gt; &lt;/a&gt; 의해 설정된 현재 코 루틴 원점 추적 깊이를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="21bc3e18b69cedb70fba9d2d7af46bb81851c651" translate="yes" xml:space="preserve">
          <source>Get the current debug mode.</source>
          <target state="translated">현재 디버그 모드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9147306d385a899f0990612dc38a5e8cbd44b174" translate="yes" xml:space="preserve">
          <source>Get the current event loop. If there is no current event loop set in the current OS thread and &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt;&lt;code&gt;set_event_loop()&lt;/code&gt;&lt;/a&gt; has not yet been called, asyncio will create a new event loop and set it as the current one.</source>
          <target state="translated">현재 이벤트 루프를 가져옵니다. 현재 OS 스레드에 현재 이벤트 루프가 설정되어 있지 않고 &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt; &lt;code&gt;set_event_loop()&lt;/code&gt; &lt;/a&gt; 가 아직 호출되지 않은 경우 asyncio는 새 이벤트 루프를 생성하여 현재 이벤트 루프로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9fbacbbcf2b837c80ba45aea42673fc9e4cf458a" translate="yes" xml:space="preserve">
          <source>Get the current exception handler.</source>
          <target state="translated">현재 예외 처리기를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4197cb00152b09fb11f3cc03418b4e6a301eb8da" translate="yes" xml:space="preserve">
          <source>Get the current size and peak size of memory blocks traced by the &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module as a tuple: &lt;code&gt;(current: int, peak: int)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt; 모듈에 의해 추적 된 메모리 블록의 현재 크기와 최대 크기를 튜플 : &lt;code&gt;(current: int, peak: int)&lt;/code&gt; 로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="626d548bdef64d0a48f07c8cda0a11f5c10bcbfc" translate="yes" xml:space="preserve">
          <source>Get the debug mode (&lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;) of the event loop.</source>
          <target state="translated">이벤트 루프 의 디버그 모드 ( &lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; )를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8ded36169c7cff99c312b7341fa1bdec62461193" translate="yes" xml:space="preserve">
          <source>Get the default value for a namespace attribute, as set by either &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; or by &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt;&lt;code&gt;set_defaults()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt; &lt;code&gt;set_defaults()&lt;/code&gt; &lt;/a&gt; 의해 설정된 네임 스페이스 속성의 기본값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="fd913673fefa31b516e470f7cb6bcbec7e7a99e1" translate="yes" xml:space="preserve">
          <source>Get the documentation string for an object, cleaned up with &lt;a href=&quot;#inspect.cleandoc&quot;&gt;&lt;code&gt;cleandoc()&lt;/code&gt;&lt;/a&gt;. If the documentation string for an object is not provided and the object is a class, a method, a property or a descriptor, retrieve the documentation string from the inheritance hierarchy.</source>
          <target state="translated">&lt;a href=&quot;#inspect.cleandoc&quot;&gt; &lt;code&gt;cleandoc()&lt;/code&gt; &lt;/a&gt; 정리 된 객체의 문서 문자열을 가져옵니다 . 객체의 문서 문자열이 제공되지 않고 객체가 클래스, 메서드, 속성 또는 설명자인 경우 상속 계층 구조에서 설명서 문자열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="26444a9c7dae84ae670e89b9e343f089a402bf15" translate="yes" xml:space="preserve">
          <source>Get the event loop for the current context.</source>
          <target state="translated">현재 컨텍스트에 대한 이벤트 루프를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="10b306fb1b873fece8b5be20d28de802e14a266d" translate="yes" xml:space="preserve">
          <source>Get the factory &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_task&quot;&gt;&lt;code&gt;loop.create_task()&lt;/code&gt;&lt;/a&gt; uses to create &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Tasks&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">팩토리 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_task&quot;&gt; &lt;code&gt;loop.create_task()&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Tasks&lt;/code&gt; &lt;/a&gt; 를 만드는 데 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d3e5d5493d44e924f29fef4accb44b80d73eed0d" translate="yes" xml:space="preserve">
          <source>Get the hardware address as a 48-bit positive integer. The first time this runs, it may launch a separate program, which could be quite slow. If all attempts to obtain the hardware address fail, we choose a random 48-bit number with the multicast bit (least significant bit of the first octet) set to 1 as recommended in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 4122&lt;/strong&gt;&lt;/a&gt;. &amp;ldquo;Hardware address&amp;rdquo; means the MAC address of a network interface. On a machine with multiple network interfaces, universally administered MAC addresses (i.e. where the second least significant bit of the first octet is &lt;em&gt;unset&lt;/em&gt;) will be preferred over locally administered MAC addresses, but with no other ordering guarantees.</source>
          <target state="translated">하드웨어 주소를 48 비트 양의 정수로 가져옵니다. 처음 실행하면 별도의 프로그램이 시작될 수 있으며 속도가 느릴 수 있습니다. 하드웨어 주소를 얻기위한 모든 시도가 실패하면 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 4122&lt;/strong&gt;&lt;/a&gt; 에서 권장하는 &lt;strong&gt;대로&lt;/strong&gt; 멀티 캐스트 비트 (첫 번째 옥텟의 가장 작은 비트)가 1로 설정된 임의의 48 비트 숫자를 선택합니다 . &quot;하드웨어 주소&quot;는 네트워크 인터페이스의 MAC 주소를 의미합니다. 다중 네트워크 인터페이스가있는 머신에서 범용 관리 MAC 주소 (즉, 첫 번째 옥텟의 두 번째 최하위 비트가 &lt;em&gt;설정되지 않은 경우&lt;/em&gt; )는 로컬 관리 MAC 주소보다 선호되지만 다른 순서 보증은 없습니다.</target>
        </trans-unit>
        <trans-unit id="86bdc03571623456348b97e7751c036a41840cbf" translate="yes" xml:space="preserve">
          <source>Get the list of &lt;code&gt;quota&lt;/code&gt;&lt;code&gt;roots&lt;/code&gt; for the named &lt;em&gt;mailbox&lt;/em&gt;. This method is part of the IMAP4 QUOTA extension defined in rfc2087.</source>
          <target state="translated">명명 된 &lt;em&gt;사서함&lt;/em&gt; 의 &lt;code&gt;quota&lt;/code&gt; &lt;code&gt;roots&lt;/code&gt; 목록 을 가져옵니다 . 이 방법은 rfc2087에 정의 된 IMAP4 QUOTA 확장의 일부입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9a0f4fdae3a78828ee0d60e9492707425bddc34" translate="yes" xml:space="preserve">
          <source>Get the mapping of external name references in a Python function or method &lt;em&gt;func&lt;/em&gt; to their current values. A &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;ClosureVars(nonlocals, globals, builtins, unbound)&lt;/code&gt; is returned. &lt;em&gt;nonlocals&lt;/em&gt; maps referenced names to lexical closure variables, &lt;em&gt;globals&lt;/em&gt; to the function&amp;rsquo;s module globals and &lt;em&gt;builtins&lt;/em&gt; to the builtins visible from the function body. &lt;em&gt;unbound&lt;/em&gt; is the set of names referenced in the function that could not be resolved at all given the current module globals and builtins.</source>
          <target state="translated">Python 함수 또는 메소드 &lt;em&gt;func&lt;/em&gt; 에서 외부 이름 참조를 현재 값에 맵핑하십시오 . &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;라는 이름의 튜플 &lt;/a&gt; &lt;code&gt;ClosureVars(nonlocals, globals, builtins, unbound)&lt;/code&gt; 반환됩니다. &lt;em&gt;nonlocals&lt;/em&gt; 는 참조 된 이름을 어휘 폐쇄 변수에, &lt;em&gt;전역&lt;/em&gt; 은 함수의 모듈 전역에, &lt;em&gt;내장&lt;/em&gt; 은 함수 본문에서 볼 수있는 내장에 매핑 합니다. &lt;em&gt;unbound&lt;/em&gt; 는 함수에서 참조 된 이름 집합으로, 현재 모듈 전역 및 내장에서 전혀 해석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c22b31eb9439f4414864003fe23d0a2bf9e90c0a" translate="yes" xml:space="preserve">
          <source>Get the mapping of live local variables in &lt;em&gt;generator&lt;/em&gt; to their current values. A dictionary is returned that maps from variable names to values. This is the equivalent of calling &lt;a href=&quot;functions#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; in the body of the generator, and all the same caveats apply.</source>
          <target state="translated">&lt;em&gt;생성기&lt;/em&gt; 의 활성 지역 변수를 현재 값 에 매핑 합니다. 변수 이름에서 값으로 매핑되는 사전이 반환됩니다. 이것은 생성기 본문에서 &lt;a href=&quot;functions#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것과 동일하며 모든 동일한 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="beed10cfe2d77794b1bbb3bbdc91c0102b02eadb" translate="yes" xml:space="preserve">
          <source>Get the maximum number of frames stored in the traceback of a trace.</source>
          <target state="translated">트레이스의 트레이스 백에 저장된 최대 프레임 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="875f24fe095e6b18c21feed2477aac6da64b14a3" translate="yes" xml:space="preserve">
          <source>Get the maximum priority value for &lt;em&gt;policy&lt;/em&gt;. &lt;em&gt;policy&lt;/em&gt; is one of the scheduling policy constants above.</source>
          <target state="translated">&lt;em&gt;policy&lt;/em&gt; 의 최대 우선 순위 값을 가져 &lt;em&gt;오십시오&lt;/em&gt; . &lt;em&gt;policy&lt;/em&gt; 는 위의 스케줄링 정책 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d831a3fe762715d892a6266acc85d2860eacbda6" translate="yes" xml:space="preserve">
          <source>Get the memory usage in bytes of the &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module used to store traces of memory blocks. Return an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 블록의 트레이스를 저장하는 데 사용 된 &lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt; 모듈 의 메모리 사용량을 바이트 단위로 가져 옵니다 . 돌아 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fca68a5a7ae5234cb479afea741b6da40bf623c" translate="yes" xml:space="preserve">
          <source>Get the minimum priority value for &lt;em&gt;policy&lt;/em&gt;. &lt;em&gt;policy&lt;/em&gt; is one of the scheduling policy constants above.</source>
          <target state="translated">&lt;em&gt;policy&lt;/em&gt; 의 최소 ​​우선 순위 값을 확보하십시오 . &lt;em&gt;policy&lt;/em&gt; 는 위의 스케줄링 정책 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d8ac71296ef3a58835643bd261a8ccd491ad148f" translate="yes" xml:space="preserve">
          <source>Get the name of the n-th day of the week.</source>
          <target state="translated">요일 n 번째 날의 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="177c736ff7d8d1f378de31fc0c8a6a656a7d692b" translate="yes" xml:space="preserve">
          <source>Get the name of the n-th month.</source>
          <target state="translated">n 번째 달의 이름을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="cdf70fb867a7db976d8f951c29595f87261634f2" translate="yes" xml:space="preserve">
          <source>Get the names and default values of a Python function&amp;rsquo;s parameters. A &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; is returned:</source>
          <target state="translated">Python 함수 매개 변수의 이름과 기본값을 가져옵니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;라는 이름의 튜플이&lt;/a&gt; 반환됩니다</target>
        </trans-unit>
        <trans-unit id="f96a65f3bc54287ada72c5b7fe9623f023a380a0" translate="yes" xml:space="preserve">
          <source>Get the names and default values of a Python function&amp;rsquo;s parameters. A &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;ArgSpec(args, varargs, keywords, defaults)&lt;/code&gt; is returned. &lt;em&gt;args&lt;/em&gt; is a list of the parameter names. &lt;em&gt;varargs&lt;/em&gt; and &lt;em&gt;keywords&lt;/em&gt; are the names of the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; parameters or &lt;code&gt;None&lt;/code&gt;. &lt;em&gt;defaults&lt;/em&gt; is a tuple of default argument values or &lt;code&gt;None&lt;/code&gt; if there are no default arguments; if this tuple has &lt;em&gt;n&lt;/em&gt; elements, they correspond to the last &lt;em&gt;n&lt;/em&gt; elements listed in &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">Python 함수 매개 변수의 이름과 기본값을 가져옵니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;라는 이름의 튜플 &lt;/a&gt; &lt;code&gt;ArgSpec(args, varargs, keywords, defaults)&lt;/code&gt; 반환됩니다. &lt;em&gt;args&lt;/em&gt; 는 매개 변수 이름의 목록입니다. &lt;em&gt;varargs&lt;/em&gt; 및 &lt;em&gt;키워드&lt;/em&gt; 는 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 매개 변수 이름 또는 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;em&gt;기본값&lt;/em&gt; 은 기본 인수 값의 튜플이거나 기본 인수가 없으면 &lt;code&gt;None&lt;/code&gt; 입니다 . 이 튜플에 &lt;em&gt;n 개의&lt;/em&gt; 요소 가 있으면 &lt;em&gt;args에&lt;/em&gt; 나열된 마지막 &lt;em&gt;n 개의&lt;/em&gt; 요소에 해당합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="338f1e4cd4abd99d9096cc0a0fe019657231fcb8" translate="yes" xml:space="preserve">
          <source>Get the object wrapped by &lt;em&gt;func&lt;/em&gt;. It follows the chain of &lt;code&gt;__wrapped__&lt;/code&gt; attributes returning the last object in the chain.</source>
          <target state="translated">&lt;em&gt;func에&lt;/em&gt; 의해 감싸 진 객체를 가져옵니다 . 체인의 마지막 개체를 반환하는 &lt;code&gt;__wrapped__&lt;/code&gt; 특성 체인을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="eeb0543617fc198eb7f84637ea5bfb7ba0fb9e29" translate="yes" xml:space="preserve">
          <source>Get the profiler function as set by &lt;a href=&quot;#sys.setprofile&quot;&gt;&lt;code&gt;setprofile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sys.setprofile&quot;&gt; &lt;code&gt;setprofile()&lt;/code&gt; &lt;/a&gt; 의해 설정된 프로파일 러 함수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d1faa97d2137acdfa90b6bf60ff4c74956dba073" translate="yes" xml:space="preserve">
          <source>Get the radix character (decimal dot, decimal comma, etc.).</source>
          <target state="translated">기수 문자 (10 진수 점, 10 진수 쉼표 등)를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c01a5ccde9ac49c55eb2b32526014a7b15ecf2ae" translate="yes" xml:space="preserve">
          <source>Get the separator character for thousands (groups of three digits).</source>
          <target state="translated">천 단위 구분 기호 문자 (3 자리 그룹)를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0e78eed124f99dc526d554a9b3edaa9f5e91b866" translate="yes" xml:space="preserve">
          <source>Get the size of the terminal window.</source>
          <target state="translated">터미널 창의 크기를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0a9e259bb5fda4714972337dc041313d9ac70f7b" translate="yes" xml:space="preserve">
          <source>Get the status of a file or a file descriptor. Perform the equivalent of a &lt;code&gt;stat()&lt;/code&gt; system call on the given path. &lt;em&gt;path&lt;/em&gt; may be specified as either a string or bytes &amp;ndash; directly or indirectly through the &lt;a href=&quot;#os.PathLike&quot;&gt;&lt;code&gt;PathLike&lt;/code&gt;&lt;/a&gt; interface &amp;ndash; or as an open file descriptor. Return a &lt;a href=&quot;#os.stat_result&quot;&gt;&lt;code&gt;stat_result&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">파일 또는 파일 설명 자의 상태를 가져옵니다. 주어진 경로에서 &lt;code&gt;stat()&lt;/code&gt; 시스템 호출 과 동등한 작업을 수행하십시오 . &lt;em&gt;path&lt;/em&gt; 는 &lt;a href=&quot;#os.PathLike&quot;&gt; &lt;code&gt;PathLike&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 직접 또는 간접적으로 문자열 또는 바이트 또는 열린 파일 설명 자로 지정할 수 있습니다. &lt;a href=&quot;#os.stat_result&quot;&gt; &lt;code&gt;stat_result&lt;/code&gt; &lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0ca243f70cf806ef62d1afffa88dfc484f305191" translate="yes" xml:space="preserve">
          <source>Get the status of the file descriptor &lt;em&gt;fd&lt;/em&gt;. Return a &lt;a href=&quot;#os.stat_result&quot;&gt;&lt;code&gt;stat_result&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">파일 기술자 &lt;em&gt;fd&lt;/em&gt; 의 상태를 가져옵니다 . &lt;a href=&quot;#os.stat_result&quot;&gt; &lt;code&gt;stat_result&lt;/code&gt; &lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8dd3f7ebeb39e689a6b4f2254d583df995061fb3" translate="yes" xml:space="preserve">
          <source>Get the trace function as set by &lt;a href=&quot;#sys.settrace&quot;&gt;&lt;code&gt;settrace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sys.settrace&quot;&gt; &lt;code&gt;settrace()&lt;/code&gt; &lt;/a&gt; 로 설정된 추적 함수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2bb9c949f80db687c4f3b3bcb5ae6488810e0e05" translate="yes" xml:space="preserve">
          <source>Get the traceback of a memory block</source>
          <target state="translated">메모리 블록의 역 추적</target>
        </trans-unit>
        <trans-unit id="96491598d89e33d5f629f33a8e143413fe56b6b3" translate="yes" xml:space="preserve">
          <source>Get the traceback where the Python object &lt;em&gt;obj&lt;/em&gt; was allocated. Return a &lt;a href=&quot;#tracemalloc.Traceback&quot;&gt;&lt;code&gt;Traceback&lt;/code&gt;&lt;/a&gt; instance, or &lt;code&gt;None&lt;/code&gt; if the &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module is not tracing memory allocations or did not trace the allocation of the object.</source>
          <target state="translated">Python 객체 &lt;em&gt;obj&lt;/em&gt; 가 할당 된 역 추적을 가져옵니다 . &lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt; 모듈이 메모리 할당을 추적하지 않거나 개체 할당을 추적하지 않은 경우 &lt;a href=&quot;#tracemalloc.Traceback&quot;&gt; &lt;code&gt;Traceback&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 하거나 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e0cd0d7d768a7bc89269e2610f57234df9dc174c" translate="yes" xml:space="preserve">
          <source>Get the type of completion being attempted. This returns the &lt;code&gt;rl_completion_type&lt;/code&gt; variable in the underlying library as an integer.</source>
          <target state="translated">시도중인 완료 유형을 가져옵니다. 기본 라이브러리 의 &lt;code&gt;rl_completion_type&lt;/code&gt; 변수를 정수로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="14634fd7695059ed33b02f9c5c68979403fb0a78" translate="yes" xml:space="preserve">
          <source>Get up to &lt;em&gt;size&lt;/em&gt; random bytes. The function can return less bytes than requested.</source>
          <target state="translated">임의의 바이트 &lt;em&gt;크기&lt;/em&gt; 까지 가져옵니다 . 이 함수는 요청한 것보다 적은 바이트를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01cc5b73e04d7942d8b95f16fb4f30afb296c429" translate="yes" xml:space="preserve">
          <source>Get user/password for given realm and URI, if any. This method will return &lt;code&gt;(None, None)&lt;/code&gt; if there is no matching user/password.</source>
          <target state="translated">제공된 영역 및 URI에 대한 사용자 / 암호를 가져옵니다 (있는 경우). 일치하는 사용자 / 암호가 없으면 이 메소드는 &lt;code&gt;(None, None)&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="8cc37b119889ac835c7737c5753d9caa568b7839" translate="yes" xml:space="preserve">
          <source>Gets the element attribute named &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt; 라는 요소 속성을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="760100f396e380d5b81eb981f228550498eeda61" translate="yes" xml:space="preserve">
          <source>Gets the options maintained by the Tix scheme mechanism.</source>
          <target state="translated">Tix 체계 메커니즘에 의해 유지 관리되는 옵션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="54f6b9f42996ad493427dc7a89ff5033c4ae88a3" translate="yes" xml:space="preserve">
          <source>Getting and Setting the Policy</source>
          <target state="translated">정책 얻기 및 설정</target>
        </trans-unit>
        <trans-unit id="de41be2be50480bb76b3f0a07f5885974cbf1c6f" translate="yes" xml:space="preserve">
          <source>Given &lt;em&gt;field_name&lt;/em&gt; as returned by &lt;a href=&quot;#string.Formatter.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in &lt;a href=&quot;https://www.python.org/dev/peps/pep-3101&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3101&lt;/strong&gt;&lt;/a&gt;, such as &amp;ldquo;0[name]&amp;rdquo; or &amp;ldquo;label.title&amp;rdquo;. &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; are as passed in to &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt;. The return value &lt;em&gt;used_key&lt;/em&gt; has the same meaning as the &lt;em&gt;key&lt;/em&gt; parameter to &lt;a href=&quot;#string.Formatter.get_value&quot;&gt;&lt;code&gt;get_value()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#string.Formatter.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 &lt;em&gt;field_name이&lt;/em&gt; 주어지면 (위 참조) 포맷 할 객체로 변환하십시오. 튜플 (obj, used_key)을 반환합니다. 기본 버전은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3101&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3101에&lt;/strong&gt;&lt;/a&gt; 정의 된 형식의 문자열 ( 예 : &quot;0 [name]&quot;또는 &quot;label.title&quot;)을 사용합니다. &lt;em&gt;args&lt;/em&gt; 와 &lt;em&gt;kwargs&lt;/em&gt; 는 &lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt; 으로 전달됩니다 . 반환 값 &lt;em&gt;used_key&lt;/em&gt; 는 &lt;a href=&quot;#string.Formatter.get_value&quot;&gt; &lt;code&gt;get_value()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;키&lt;/em&gt; 매개 변수 와 동일한 의미를 갖습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f55d836d4948d424938d2512af324936d2aeb59" translate="yes" xml:space="preserve">
          <source>Given a &lt;em&gt;sequence&lt;/em&gt; produced by &lt;a href=&quot;#difflib.Differ.compare&quot;&gt;&lt;code&gt;Differ.compare()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#difflib.ndiff&quot;&gt;&lt;code&gt;ndiff()&lt;/code&gt;&lt;/a&gt;, extract lines originating from file 1 or 2 (parameter &lt;em&gt;which&lt;/em&gt;), stripping off line prefixes.</source>
          <target state="translated">&lt;a href=&quot;#difflib.Differ.compare&quot;&gt; &lt;code&gt;Differ.compare()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#difflib.ndiff&quot;&gt; &lt;code&gt;ndiff()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 &lt;em&gt;시퀀스&lt;/em&gt; 가 주어지면 파일 1 또는 2 (매개 변수 &lt;em&gt;which&lt;/em&gt; )에서 시작하여 행 접두사를 제거하는 행을 추출하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="05595a6c90f0a99ee3d09b89a7cd936fde90ed53" translate="yes" xml:space="preserve">
          <source>Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded string version of the same certificate.</source>
          <target state="translated">DER로 인코딩 된 바이트 바이트로 인증서가 주어지면 동일한 인증서의 PEM으로 인코딩 된 문자열 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a46c2f2901d1cbae641511ae251e6f2a6550436" translate="yes" xml:space="preserve">
          <source>Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of bytes for that same certificate.</source>
          <target state="translated">인증서가 ASCII PEM 문자열로 제공되면 동일한 인증서에 대해 DER로 인코딩 된 바이트 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f45ddf3586cd5194519fa8686d71f3049a3d0b96" translate="yes" xml:space="preserve">
          <source>Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations:</source>
          <target state="translated">하나 이상의 풍부한 비교 순서 방법을 정의하는 클래스가 주어지면이 클래스 데코레이터가 나머지를 제공합니다. 이렇게하면 가능한 모든 풍부한 비교 연산을 지정하는 데 드는 노력이 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="f7b3e25f5e05ce99668bfb371e67ba352cbbde2c" translate="yes" xml:space="preserve">
          <source>Given a list of tuples or &lt;a href=&quot;#traceback.FrameSummary&quot;&gt;&lt;code&gt;FrameSummary&lt;/code&gt;&lt;/a&gt; objects as returned by &lt;a href=&quot;#traceback.extract_tb&quot;&gt;&lt;code&gt;extract_tb()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#traceback.extract_stack&quot;&gt;&lt;code&gt;extract_stack()&lt;/code&gt;&lt;/a&gt;, return a list of strings ready for printing. Each string in the resulting list corresponds to the item with the same index in the argument list. Each string ends in a newline; the strings may contain internal newlines as well, for those items whose source text line is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#traceback.extract_tb&quot;&gt; &lt;code&gt;extract_tb()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#traceback.extract_stack&quot;&gt; &lt;code&gt;extract_stack()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 튜플 또는 &lt;a href=&quot;#traceback.FrameSummary&quot;&gt; &lt;code&gt;FrameSummary&lt;/code&gt; &lt;/a&gt; 객체 목록이 제공되면 인쇄 할 준비가 된 문자열 목록을 반환합니다. 결과 목록의 각 문자열은 인수 목록에서 동일한 색인을 가진 항목에 해당합니다. 각 문자열은 줄 바꿈으로 끝납니다. 소스 텍스트 행이 &lt;code&gt;None&lt;/code&gt; 이 아닌 항목의 문자열에는 내부 개행 문자도 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e790336403204248eacd64786fa774cb6247304" translate="yes" xml:space="preserve">
          <source>Given a string &lt;code&gt;cfg://handlers.myhandler.mykey.123&lt;/code&gt;, this will resolve to &lt;code&gt;config_dict['handlers']['myhandler']['mykey']['123']&lt;/code&gt;. If the string is specified as &lt;code&gt;cfg://handlers.myhandler.mykey[123]&lt;/code&gt;, the system will attempt to retrieve the value from &lt;code&gt;config_dict['handlers']['myhandler']['mykey'][123]&lt;/code&gt;, and fall back to &lt;code&gt;config_dict['handlers']['myhandler']['mykey']['123']&lt;/code&gt; if that fails.</source>
          <target state="translated">문자열을 감안할 때 &lt;code&gt;cfg://handlers.myhandler.mykey.123&lt;/code&gt; ,이에 해결할 수 &lt;code&gt;config_dict['handlers']['myhandler']['mykey']['123']&lt;/code&gt; . 문자열이 지정된 경우 &lt;code&gt;cfg://handlers.myhandler.mykey[123]&lt;/code&gt; , 시스템에서 값 검색을 시도합니다 &lt;code&gt;config_dict['handlers']['myhandler']['mykey'][123]&lt;/code&gt; , 가을 실패하면 &lt;code&gt;config_dict['handlers']['myhandler']['mykey']['123']&lt;/code&gt; 로 돌아가십시오 .</target>
        </trans-unit>
        <trans-unit id="d84b01d7456dcc777d8a082e4eabece2ca9ed79a" translate="yes" xml:space="preserve">
          <source>Given a string representing one Unicode character, return an integer representing the Unicode code point of that character. For example, &lt;code&gt;ord('a')&lt;/code&gt; returns the integer &lt;code&gt;97&lt;/code&gt; and &lt;code&gt;ord('&amp;euro;')&lt;/code&gt; (Euro sign) returns &lt;code&gt;8364&lt;/code&gt;. This is the inverse of &lt;a href=&quot;#chr&quot;&gt;&lt;code&gt;chr()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나의 유니 코드 문자를 나타내는 문자열이 주어진 경우 해당 문자의 유니 코드 코드 포인트를 나타내는 정수를 반환하십시오. 예를 들어 &lt;code&gt;ord('a')&lt;/code&gt; 는 정수 &lt;code&gt;97&lt;/code&gt; 을 반환 하고 &lt;code&gt;ord('&amp;euro;')&lt;/code&gt; (Euro sign)은 &lt;code&gt;8364&lt;/code&gt; 를 반환합니다 . 이것은 &lt;a href=&quot;#chr&quot;&gt; &lt;code&gt;chr()&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="1e6e2f86433a718f222be5f912b3a524bf362339" translate="yes" xml:space="preserve">
          <source>Given the &lt;em&gt;path&lt;/em&gt; to a &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; file name, return the associated source code file path. For example, if &lt;em&gt;path&lt;/em&gt; is &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.pyc&lt;/code&gt; the returned path would be &lt;code&gt;/foo/bar/baz.py&lt;/code&gt;. &lt;em&gt;path&lt;/em&gt; need not exist, however if it does not conform to &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-24&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://www.python.org/dev/peps/pep-0488&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;PEP 488&lt;/strong&gt;&lt;/a&gt; format, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. If &lt;code&gt;sys.implementation.cache_tag&lt;/code&gt; is not defined, &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; 파일 이름에 대한 &lt;em&gt;경로&lt;/em&gt; 가 주어지면 연관된 소스 코드 파일 경로를 리턴하십시오. 예를 들어 &lt;em&gt;path&lt;/em&gt; 가 &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.pyc&lt;/code&gt; 인 경우 반환되는 경로는 &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; 입니다. &lt;em&gt;경로&lt;/em&gt; 가 존재할 필요는 없지만 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-24&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0488&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;PEP 488&lt;/strong&gt;&lt;/a&gt; 형식을 준수하지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 경우 &lt;code&gt;sys.implementation.cache_tag&lt;/code&gt; 가 정의되어 있지 않은, &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08ed0d8e8bad29829940b285ece41c02bdf11fd1" translate="yes" xml:space="preserve">
          <source>Given the address &lt;code&gt;addr&lt;/code&gt; of an SSL-protected server, as a (&lt;em&gt;hostname&lt;/em&gt;, &lt;em&gt;port-number&lt;/em&gt;) pair, fetches the server&amp;rsquo;s certificate, and returns it as a PEM-encoded string. If &lt;code&gt;ssl_version&lt;/code&gt; is specified, uses that version of the SSL protocol to attempt to connect to the server. If &lt;code&gt;ca_certs&lt;/code&gt; is specified, it should be a file containing a list of root certificates, the same format as used for the same parameter in &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;. The call will attempt to validate the server certificate against that set of root certificates, and will fail if the validation attempt fails.</source>
          <target state="translated">주소 주어 &lt;code&gt;addr&lt;/code&gt; A (와 같은 SSL로 보호 된 서버를 &lt;em&gt;호스트 이름&lt;/em&gt; , &lt;em&gt;포트 번호&lt;/em&gt; ) 한 쌍, 서버의 인증서를 가져옵니다 및 PEM 인코딩 된 문자열로 반환을. &lt;code&gt;ssl_version&lt;/code&gt; 이 지정된 경우 해당 버전의 SSL 프로토콜을 사용하여 서버에 연결을 시도하십시오. &lt;code&gt;ca_certs&lt;/code&gt; 가 지정된 경우 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 의 동일한 매개 변수에 사용 된 형식과 동일한 형식의 루트 인증서 목록을 포함하는 파일이어야합니다 . 호출은 해당 루트 인증서 세트에 대해 서버 인증서의 유효성을 검증하려고 시도하고 유효성 검증 시도가 실패하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ed1cc9e34fb1d371b7d753410f4cb40d45c04f7f" translate="yes" xml:space="preserve">
          <source>Given the following test function:</source>
          <target state="translated">다음과 같은 테스트 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9ccf5a3550325aa609fd4d8289371b325a3aab2b" translate="yes" xml:space="preserve">
          <source>Giving a name to the &amp;ldquo;no flags set&amp;rdquo; condition does not change its boolean value:</source>
          <target state="translated">&quot;no flags set&quot;조건에 이름을 부여해도 부울 값이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e2578c8d3e2264288e1d7a420984d59a44f0d09" translate="yes" xml:space="preserve">
          <source>Glob the given relative &lt;em&gt;pattern&lt;/em&gt; in the directory represented by this path, yielding all matching files (of any kind):</source>
          <target state="translated">이 경로로 표시되는 디렉토리에서 주어진 상대 &lt;em&gt;패턴&lt;/em&gt; 을 지정 하여 모든 종류의 일치하는 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="70ae8e14e7d7a8122e7468fd602556f9b4388301" translate="yes" xml:space="preserve">
          <source>Global variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="763165ef1af70712caac84a0ad4d0d255c31eed2" translate="yes" xml:space="preserve">
          <source>Go to File/Line</source>
          <target state="translated">파일 / 라인으로 이동</target>
        </trans-unit>
        <trans-unit id="98a2592d28e0bc9b3ae17e6fc5fd6e49205211a0" translate="yes" xml:space="preserve">
          <source>Go to Line</source>
          <target state="translated">라인으로 이동</target>
        </trans-unit>
        <trans-unit id="7b92a290556d84784e64aaddf1fbea6d40138fe0" translate="yes" xml:space="preserve">
          <source>Go to file/line</source>
          <target state="translated">파일 / 라인으로 이동</target>
        </trans-unit>
        <trans-unit id="eead8cc449a5fdb49abd4cc5eb6d4c8fb413f5a1" translate="yes" xml:space="preserve">
          <source>Go to left edge of window.</source>
          <target state="translated">창의 왼쪽 가장자리로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="563cd67337a9db639ff613ae3b62460c15808b8b" translate="yes" xml:space="preserve">
          <source>Go to right edge (stripspaces off) or end of line (stripspaces on).</source>
          <target state="translated">오른쪽 가장자리 (스트립 스페이스 꺼짐) 또는 줄 끝 (스트립 스페이스 켜짐)으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="46f9595417e3e508f5e81f695930a38e4fb89c1b" translate="yes" xml:space="preserve">
          <source>Graphical User Interfaces with Tk</source>
          <target state="translated">Tk를 사용한 그래픽 사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="7e1a78fc7119624ad45bbfba5788d2e14052b1c6" translate="yes" xml:space="preserve">
          <source>Group ID of the user who originally stored this member.</source>
          <target state="translated">이 멤버를 처음 저장 한 사용자의 그룹 ID입니다.</target>
        </trans-unit>
        <trans-unit id="7c12f123a309d736f2ff94b7014ed4186a9c5e23" translate="yes" xml:space="preserve">
          <source>Group Separator</source>
          <target state="translated">그룹 구분</target>
        </trans-unit>
        <trans-unit id="f5868c9eb60476a70674ffb21a653d9b1b541f04" translate="yes" xml:space="preserve">
          <source>Group database entries are reported as a tuple-like object, whose attributes correspond to the members of the &lt;code&gt;group&lt;/code&gt; structure (Attribute field below, see &lt;code&gt;&amp;lt;pwd.h&amp;gt;&lt;/code&gt;):</source>
          <target state="translated">그룹 데이터베이스 항목은 속성이 &lt;code&gt;group&lt;/code&gt; 구조 의 멤버에 해당하는 튜플과 유사한 객체로보고됩니다 (아래 속성 필드, &lt;code&gt;&amp;lt;pwd.h&amp;gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">그룹에 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">그룹에 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">그룹에 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc1013ffa9a8c2a7ebc3e1c3f775829468dd76b2" translate="yes" xml:space="preserve">
          <source>Group id of the owner.</source>
          <target state="translated">소유자의 그룹 ID</target>
        </trans-unit>
        <trans-unit id="8149aea9d2347b3cab2f08f676e4e22ad9daae9c" translate="yes" xml:space="preserve">
          <source>Group identifier of the file owner.</source>
          <target state="translated">파일 소유자의 그룹 식별자.</target>
        </trans-unit>
        <trans-unit id="3a5ba5e4d64a0b9c657db67debb9a8fb91f77421" translate="yes" xml:space="preserve">
          <source>Group name.</source>
          <target state="translated">그룹 이름.</target>
        </trans-unit>
        <trans-unit id="73fb2dd5cc2643e9f02bc351410b98713e0c50c9" translate="yes" xml:space="preserve">
          <source>Group separator</source>
          <target state="translated">그룹 분리기</target>
        </trans-unit>
        <trans-unit id="cbe6cbbb63fb55bfe88f791b01a0841ea8d25a95" translate="yes" xml:space="preserve">
          <source>Group separator used for monetary values.</source>
          <target state="translated">통화 값에 사용되는 그룹 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="bdfa8009f2b9366fe1470f6950953385bb537b83" translate="yes" xml:space="preserve">
          <source>Grouping tests</source>
          <target state="translated">그룹화 테스트</target>
        </trans-unit>
        <trans-unit id="763f4b22517ce2940bbeade6d76120551ce59fff" translate="yes" xml:space="preserve">
          <source>Guess the extension for a file based on its MIME type, given by &lt;em&gt;type&lt;/em&gt;. The return value is a string giving a filename extension, including the leading dot (&lt;code&gt;'.'&lt;/code&gt;). The extension is not guaranteed to have been associated with any particular data stream, but would be mapped to the MIME type &lt;em&gt;type&lt;/em&gt; by &lt;a href=&quot;#mimetypes.guess_type&quot;&gt;&lt;code&gt;guess_type()&lt;/code&gt;&lt;/a&gt;. If no extension can be guessed for &lt;em&gt;type&lt;/em&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">주어진의 MIME 유형에 따라 파일의 확장자, 추측 &lt;em&gt;유형을&lt;/em&gt; . 반환 값은 선행 점 ( &lt;code&gt;'.'&lt;/code&gt; )을 포함하여 파일 이름 확장자를 제공하는 문자열 입니다. 확장은 특정 데이터 스트림과 연관이 보장되지 않지만, MIME 타입에 매핑 될 것이다 &lt;em&gt;유형&lt;/em&gt; 으로 &lt;a href=&quot;#mimetypes.guess_type&quot;&gt; &lt;code&gt;guess_type()&lt;/code&gt; &lt;/a&gt; . &lt;em&gt;type&lt;/em&gt; 에 대해 확장명을 추측 할 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6ccac2e946e402380d6bff133365e1d281155811" translate="yes" xml:space="preserve">
          <source>Guess the extensions for a file based on its MIME type, given by &lt;em&gt;type&lt;/em&gt;. The return value is a list of strings giving all possible filename extensions, including the leading dot (&lt;code&gt;'.'&lt;/code&gt;). The extensions are not guaranteed to have been associated with any particular data stream, but would be mapped to the MIME type &lt;em&gt;type&lt;/em&gt; by &lt;a href=&quot;#mimetypes.guess_type&quot;&gt;&lt;code&gt;guess_type()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진의 MIME 유형에 따라 파일에 대한 확장을 추측 &lt;em&gt;유형&lt;/em&gt; . 반환 값은 선행 점 ( &lt;code&gt;'.'&lt;/code&gt; )을 포함하여 가능한 모든 파일 이름 확장자를 제공하는 문자열 목록입니다 . 확장은 특정 데이터 스트림과 연관이 보장되지 않지만, MIME 타입에 매핑 될 것이다 &lt;em&gt;유형&lt;/em&gt; 으로 &lt;a href=&quot;#mimetypes.guess_type&quot;&gt; &lt;code&gt;guess_type()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a84a6acc761ddfa3d7bc427639d3f7d94a20bd3e" translate="yes" xml:space="preserve">
          <source>Guess the type of a file based on its filename, path or URL, given by &lt;em&gt;url&lt;/em&gt;. URL can be a string or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;url에&lt;/em&gt; 의해 주어진 파일 이름, 경로 또는 URL을 기반으로 파일 유형을 추측하십시오 . URL은 문자열 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한 객체 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8da0077fda7c3873b2109d7ff97c49289bade98b" translate="yes" xml:space="preserve">
          <source>Guides and Tutorials</source>
          <target state="translated">가이드 및 튜토리얼</target>
        </trans-unit>
        <trans-unit id="2ce51484b12a05894f2f9727173e21a3b67e36f9" translate="yes" xml:space="preserve">
          <source>Gustavo Niemeyer</source>
          <target state="translated">구스타보 니마 이어</target>
        </trans-unit>
        <trans-unit id="50d7c437b1b17589574e811d5085ed34a4b22340" translate="yes" xml:space="preserve">
          <source>HELO</source>
          <target state="translated">HELO</target>
        </trans-unit>
        <trans-unit id="ee7929cef18bd1007cbda8ca0208846f8487ec62" translate="yes" xml:space="preserve">
          <source>HELP</source>
          <target state="translated">HELP</target>
        </trans-unit>
        <trans-unit id="7b58c8c80353422c3ae74a11c240a7ae53c8ea23" translate="yes" xml:space="preserve">
          <source>HKEY_* Constants</source>
          <target state="translated">HKEY_ * 상수</target>
        </trans-unit>
        <trans-unit id="a6a018281adec46cfdc4ecaba3d91384521c02b2" translate="yes" xml:space="preserve">
          <source>HTMLParser Methods</source>
          <target state="translated">HTMLParser 메소드</target>
        </trans-unit>
        <trans-unit id="83800fbcaacbc135f6269ae99e3235f1de3f5cf5" translate="yes" xml:space="preserve">
          <source>HTTP cookie classes, principally useful for server-side code. The &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http.cookies#module-http.cookies&quot;&gt;&lt;code&gt;http.cookies&lt;/code&gt;&lt;/a&gt; modules do not depend on each other.</source>
          <target state="translated">HTTP 쿠키 클래스는 주로 서버 측 코드에 유용합니다. &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http.cookies#module-http.cookies&quot;&gt; &lt;code&gt;http.cookies&lt;/code&gt; &lt;/a&gt; 모듈은 서로에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7044d88f7a2347a2f5b8dbb82ed197be53ebf64a" translate="yes" xml:space="preserve">
          <source>HTTP cookie handling for web &lt;em&gt;clients&lt;/em&gt;. The &lt;a href=&quot;http.cookiejar#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#module-http.cookies&quot;&gt;&lt;code&gt;http.cookies&lt;/code&gt;&lt;/a&gt; modules do not depend on each other.</source>
          <target state="translated">웹 &lt;em&gt;클라이언트를&lt;/em&gt; 위한 HTTP 쿠키 처리 . &lt;a href=&quot;http.cookiejar#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#module-http.cookies&quot;&gt; &lt;code&gt;http.cookies&lt;/code&gt; &lt;/a&gt; 모듈은 서로에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b613f0c29f1f2272729222b79dd0363bf366e91" translate="yes" xml:space="preserve">
          <source>HTTP protocol version used by server. 10 for HTTP/1.0, 11 for HTTP/1.1.</source>
          <target state="translated">서버가 사용하는 HTTP 프로토콜 버전. HTTP / 1.0의 경우 10, HTTP / 1.1의 경우 11</target>
        </trans-unit>
        <trans-unit id="4786bcad00754f90607cd03b51ae4f2dfc8958ec" translate="yes" xml:space="preserve">
          <source>HTTP status codes</source>
          <target state="translated">HTTP 상태 코드</target>
        </trans-unit>
        <trans-unit id="b9c5e6f4000e0c7c081dcb3f748956d95b414dc8" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.2.1</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.2.1</target>
        </trans-unit>
        <trans-unit id="55ce7ae41bf5482f4b02d07a75916731331b4ed7" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.4.1</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.4.1</target>
        </trans-unit>
        <trans-unit id="37a2b8e98ce9a80ff50cc2187f3d5f66d4acf192" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.4.2</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.4.2</target>
        </trans-unit>
        <trans-unit id="4c4886664f75483fc582d91c7885848287888d95" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.4.3</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.4.3</target>
        </trans-unit>
        <trans-unit id="24d12da9a592b38862e6bb5010136705da6a12e0" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.4.4</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.4.4</target>
        </trans-unit>
        <trans-unit id="bc2df2a2575cf8642877678203bd4860c3893ed2" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.4.5</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.4.5</target>
        </trans-unit>
        <trans-unit id="a04d14d65cbc4a943cd4f902fac7148c0f14008b" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.2.2</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.2.2</target>
        </trans-unit>
        <trans-unit id="60d7f81d19333e5f74e5e2e3d6de6347b79c2b62" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.4.7</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.4.7</target>
        </trans-unit>
        <trans-unit id="8ac7152bb59f9e6637cda1fc09f358e6db1eb3b3" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.1</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.1</target>
        </trans-unit>
        <trans-unit id="e307f3ae76be18f3cf56334d2d1203897c84c6ad" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-24&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.2</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-24&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.2</target>
        </trans-unit>
        <trans-unit id="ee054e8754930b1255d65d88b0043dc9abf8e0d4" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.3</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.3</target>
        </trans-unit>
        <trans-unit id="39a70a33114bc2491f95a95af6970771b5372ba1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-26&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.4</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-26&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.4</target>
        </trans-unit>
        <trans-unit id="384a5fc0754896060e5523e9ce8e1e038c2bb546" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-27&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.5</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-27&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.5</target>
        </trans-unit>
        <trans-unit id="03716883f4ec8e56d07cf1ed63059674945a1990" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-28&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.6</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-28&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.6</target>
        </trans-unit>
        <trans-unit id="f9958b9874f5f09f1d26017ef8c8b19a1d5b34a9" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-30&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.7</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-30&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.7</target>
        </trans-unit>
        <trans-unit id="f6b89763f9eecf951499a41c4f4e0c65e612b9ed" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-31&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.8</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-31&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.8</target>
        </trans-unit>
        <trans-unit id="84de879f447b29b467c932ff8b9ce36e8e1a4f7b" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-32&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.9</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-32&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.9</target>
        </trans-unit>
        <trans-unit id="2b6fd84ea11b2f50a32335158a9ab3686eb9f2f9" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-33&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.10</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-33&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.10</target>
        </trans-unit>
        <trans-unit id="335ff0bcffd8b0fd0de1378d22cd8e84e89a4261" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-35&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.11</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-35&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.11</target>
        </trans-unit>
        <trans-unit id="e01d39961a26d5b9c9f6dd4ebe218724de832d1e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-36&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.12</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-36&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.12</target>
        </trans-unit>
        <trans-unit id="11a8ebffb476f28642499a3354379840b4e688ed" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-37&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.13</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-37&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.13</target>
        </trans-unit>
        <trans-unit id="8e61d87a1209863b433f52f01e48ec24085ebde7" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-39&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.14</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-39&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.14</target>
        </trans-unit>
        <trans-unit id="cd573541605da49c903c6cc03bf2f770fd72ff49" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.3.1</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.3.1</target>
        </trans-unit>
        <trans-unit id="e607a0572ff848176765a17465646cd7950bdd53" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-44&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.5.15</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-44&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.5.15</target>
        </trans-unit>
        <trans-unit id="3150efe460b4acc154ce6666bc5e252941006cb4" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-49&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.6.1</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-49&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.6.1</target>
        </trans-unit>
        <trans-unit id="c1ee3d04c1d4b378d8083b355afbe1b1fe506ef6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.3.2</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.3.2</target>
        </trans-unit>
        <trans-unit id="f79ee66680bc43a42866e96f43db95cc0ed8752d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-50&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.6.2</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-50&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.6.2</target>
        </trans-unit>
        <trans-unit id="99e7084ca12948106471b49b2622d019645afab7" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-51&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.6.3</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-51&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.6.3</target>
        </trans-unit>
        <trans-unit id="e4759171c1fb4967d60b990bb93676987a5cf4b3" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-52&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.6.4</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-52&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.6.4</target>
        </trans-unit>
        <trans-unit id="2fac3411ccae7fcec4f1663d7e5bae7f78f4f902" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-53&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.6.5</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-53&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.6.5</target>
        </trans-unit>
        <trans-unit id="30145c38c7c08a7aa07868063aec66cda90b7250" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-54&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.6.6</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-54&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.6.6</target>
        </trans-unit>
        <trans-unit id="ad10d61f8497e284c4e42f54b87d7befb7f7bb4a" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.3.3</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.3.3</target>
        </trans-unit>
        <trans-unit id="570e8e441bb712b3ceaf16252a0b5f014e0d1b50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.3.4</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.3.4</target>
        </trans-unit>
        <trans-unit id="ffad6c577656adc8500d58706fc5478fe1bef909" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.3.5</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.3.5</target>
        </trans-unit>
        <trans-unit id="b02e682b1572382c00b992fa789f6d9af0faa90e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt;, Section 6.3.6</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 7231&lt;/strong&gt;&lt;/a&gt; , 섹션 6.3.6</target>
        </trans-unit>
        <trans-unit id="750f03d3a04b5b9fb5badbdc798f143092e85f5a" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232.html&quot; id=&quot;index-18&quot;&gt;&lt;strong&gt;RFC 7232&lt;/strong&gt;&lt;/a&gt;, Section 4.1</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232.html&quot; id=&quot;index-18&quot;&gt;&lt;strong&gt;RFC 7232&lt;/strong&gt;&lt;/a&gt; , 섹션 4.1</target>
        </trans-unit>
        <trans-unit id="aa8c1ccd1c55a0e2f0c2a76c3826c6ef56d61275" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232.html&quot; id=&quot;index-34&quot;&gt;&lt;strong&gt;RFC 7232&lt;/strong&gt;&lt;/a&gt;, Section 4.2</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232.html&quot; id=&quot;index-34&quot;&gt;&lt;strong&gt;RFC 7232&lt;/strong&gt;&lt;/a&gt; , 섹션 4.2</target>
        </trans-unit>
        <trans-unit id="4adc18410cbba25856c6bdd9448a7ad840bf05fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7233.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7233&lt;/strong&gt;&lt;/a&gt;, Section 4.1</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;https://tools.ietf.org/html/rfc7233.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7233&lt;/strong&gt;&lt;/a&gt; , 섹션 4.1</target>
        </trans-unit>
        <trans-unit id="c20505e0555301a7bc4ee1331f3b2d926b5473fd" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Authentication &lt;a href=&quot;https://tools.ietf.org/html/rfc7235.html&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;RFC 7235&lt;/strong&gt;&lt;/a&gt;, Section 3.1</source>
          <target state="translated">HTTP / 1.1 인증 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235.html&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;RFC 7235&lt;/strong&gt;&lt;/a&gt; , 섹션 3.1</target>
        </trans-unit>
        <trans-unit id="69cf6de3769ba9d495eb3b6efa56d5f7957cdb38" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Authentication &lt;a href=&quot;https://tools.ietf.org/html/rfc7235.html&quot; id=&quot;index-29&quot;&gt;&lt;strong&gt;RFC 7235&lt;/strong&gt;&lt;/a&gt;, Section 3.2</source>
          <target state="translated">HTTP / 1.1 인증 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235.html&quot; id=&quot;index-29&quot;&gt;&lt;strong&gt;RFC 7235&lt;/strong&gt;&lt;/a&gt; , 섹션 3.2</target>
        </trans-unit>
        <trans-unit id="a660a28415a0784612682b4336f837d4de547889" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Range Requests &lt;a href=&quot;https://tools.ietf.org/html/rfc7233.html&quot; id=&quot;index-38&quot;&gt;&lt;strong&gt;RFC 7233&lt;/strong&gt;&lt;/a&gt;, Section 4.4</source>
          <target state="translated">HTTP / 1.1 범위 요청 &lt;a href=&quot;https://tools.ietf.org/html/rfc7233.html&quot; id=&quot;index-38&quot;&gt;&lt;strong&gt;RFC 7233&lt;/strong&gt;&lt;/a&gt; , 섹션 4.4</target>
        </trans-unit>
        <trans-unit id="c8aff230069c68b6481e911a7a37adbc1649f530" translate="yes" xml:space="preserve">
          <source>HTTP/2 &lt;a href=&quot;https://tools.ietf.org/html/rfc7540.html&quot; id=&quot;index-40&quot;&gt;&lt;strong&gt;RFC 7540&lt;/strong&gt;&lt;/a&gt;, Section 9.1.2</source>
          <target state="translated">HTTP / 2 &lt;a href=&quot;https://tools.ietf.org/html/rfc7540.html&quot; id=&quot;index-40&quot;&gt;&lt;strong&gt;RFC 7540&lt;/strong&gt;&lt;/a&gt; , 섹션 9.1.2</target>
        </trans-unit>
        <trans-unit id="9d26016dae7061b85a9ca989c851ab31c4415626" translate="yes" xml:space="preserve">
          <source>HTTPBasicAuthHandler Objects</source>
          <target state="translated">HTTPBasicAuthHandler 객체</target>
        </trans-unit>
        <trans-unit id="128e3ebc7076bef1925dd717a403a4dc3d9659f4" translate="yes" xml:space="preserve">
          <source>HTTPConnection Objects</source>
          <target state="translated">HTTPConnection 객체</target>
        </trans-unit>
        <trans-unit id="992be6a3f16ce33effbee02a1156178fc68cb00e" translate="yes" xml:space="preserve">
          <source>HTTPCookieProcessor Objects</source>
          <target state="translated">HTTPCookieProcessor 객체</target>
        </trans-unit>
        <trans-unit id="1e8ebe01f2e245be530b383e742fd400bed10252" translate="yes" xml:space="preserve">
          <source>HTTPDigestAuthHandler Objects</source>
          <target state="translated">HTTPDigestAuthHandler 객체</target>
        </trans-unit>
        <trans-unit id="f0b6e00c82a6ffc0f054e5c4ca84fd58770cdaf0" translate="yes" xml:space="preserve">
          <source>HTTPErrorProcessor Objects</source>
          <target state="translated">HTTPErrorProcessor 객체</target>
        </trans-unit>
        <trans-unit id="79343075e3ae1afb1578a564ea8e6d0d84b3eee2" translate="yes" xml:space="preserve">
          <source>HTTPHandler</source>
          <target state="translated">HTTPHandler</target>
        </trans-unit>
        <trans-unit id="a08a17af60574eff9b7ee5ac7b2db3a31d02f832" translate="yes" xml:space="preserve">
          <source>HTTPHandler Objects</source>
          <target state="translated">HTTPHandler 객체</target>
        </trans-unit>
        <trans-unit id="447f588678db2da1df1b94aa5459163954ff9120" translate="yes" xml:space="preserve">
          <source>HTTPMessage Objects</source>
          <target state="translated">HTTPMessage 객체</target>
        </trans-unit>
        <trans-unit id="301815c67c8cd0ad1a930659ccda2ea0cd020278" translate="yes" xml:space="preserve">
          <source>HTTPPasswordMgr Objects</source>
          <target state="translated">HTTPPasswordMgr 객체</target>
        </trans-unit>
        <trans-unit id="3c6fce6dce26799f5d8d6e86061bb672133362b3" translate="yes" xml:space="preserve">
          <source>HTTPPasswordMgrWithPriorAuth Objects</source>
          <target state="translated">HTTPPasswordMgrWithPriorAuth 객체</target>
        </trans-unit>
        <trans-unit id="c368139a6cae206daecec5d01f7387777ed6220b" translate="yes" xml:space="preserve">
          <source>HTTPRedirectHandler Objects</source>
          <target state="translated">HTTPRedirectHandler 객체</target>
        </trans-unit>
        <trans-unit id="65a9b485d9c99e924fdb190254a5a76d482c4751" translate="yes" xml:space="preserve">
          <source>HTTPResponse Objects</source>
          <target state="translated">HTTPResponse 객체</target>
        </trans-unit>
        <trans-unit id="47ab16ab140fbbc7564373cc76986157e8f07f7c" translate="yes" xml:space="preserve">
          <source>HTTPS support is only available if Python was compiled with SSL support (through the &lt;a href=&quot;ssl#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">HTTPS 지원은 Python이 SSL 지원 ( &lt;a href=&quot;ssl#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 모듈을 통해)으로 컴파일 된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="987667d8eaeca62f8d43a6cb0520e0a03563e9fc" translate="yes" xml:space="preserve">
          <source>HTTPSHandler Objects</source>
          <target state="translated">HTTPSHandler 객체</target>
        </trans-unit>
        <trans-unit id="321702e8b1e7bda4040e4dd8768fe5092626cce6" translate="yes" xml:space="preserve">
          <source>Handle DTD events.</source>
          <target state="translated">DTD 이벤트를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="56d20071c05406e234f9cf1190e9affc6ac1aedb" translate="yes" xml:space="preserve">
          <source>Handle a &lt;em&gt;defect&lt;/em&gt; found on &lt;em&gt;obj&lt;/em&gt;. When the email package calls this method, &lt;em&gt;defect&lt;/em&gt; will always be a subclass of &lt;code&gt;Defect&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 에서 발견 된 &lt;em&gt;결함을&lt;/em&gt; 처리하십시오 . 전자 메일 패키지가이 메소드를 호출하면, &lt;em&gt;결함&lt;/em&gt; 은 항상 &lt;code&gt;Defect&lt;/code&gt; 의 서브 클래스가 됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="107e56fca7a09c74f23045e39860024fb9eaed74" translate="yes" xml:space="preserve">
          <source>Handle a notation declaration event.</source>
          <target state="translated">표기법 선언 이벤트를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="6d380080eaa511f673e257b847cc06cd190a3031" translate="yes" xml:space="preserve">
          <source>Handle a record.</source>
          <target state="translated">기록을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="1308c12d298ebc17be8e6f7205d8f3bfc4b593f5" translate="yes" xml:space="preserve">
          <source>Handle an XML-RPC request. If &lt;em&gt;request_text&lt;/em&gt; is given, it should be the POST data provided by the HTTP server, otherwise the contents of stdin will be used.</source>
          <target state="translated">XML-RPC 요청을 처리하십시오. 경우 &lt;em&gt;request_text가&lt;/em&gt; 주어, 그렇지 않으면 표준 입력의 내용이 사용되는 HTTP 서버에서 제공하는 POST 데이터를해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d8e258c0b6e5d1168969c669327feb855d41c04" translate="yes" xml:space="preserve">
          <source>Handle an authentication request by getting a user/password pair, and re-trying the request. &lt;em&gt;authreq&lt;/em&gt; should be the name of the header where the information about the realm is included in the request, &lt;em&gt;host&lt;/em&gt; specifies the URL and path to authenticate for, &lt;em&gt;req&lt;/em&gt; should be the (failed) &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object, and &lt;em&gt;headers&lt;/em&gt; should be the error headers.</source>
          <target state="translated">사용자 / 암호 쌍을 가져오고 요청을 다시 시도하여 인증 요청을 처리하십시오. &lt;em&gt;authreq&lt;/em&gt; 는 영역에 대한 정보가 요청에 포함 된 헤더의 이름이어야하고, &lt;em&gt;호스트&lt;/em&gt; 는 인증 할 URL과 경로를 지정하고, &lt;em&gt;req&lt;/em&gt; 는 (실패한) &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 오브젝트이고 &lt;em&gt;헤더&lt;/em&gt; 는 오류 헤더 여야합니다.</target>
        </trans-unit>
        <trans-unit id="062e437b01efebe8849f8f8ced1f07810ec988e5" translate="yes" xml:space="preserve">
          <source>Handle an error of the given protocol. This will call the registered error handlers for the given protocol with the given arguments (which are protocol specific). The HTTP protocol is a special case which uses the HTTP response code to determine the specific error handler; refer to the &lt;code&gt;http_error_&amp;lt;type&amp;gt;()&lt;/code&gt; methods of the handler classes.</source>
          <target state="translated">주어진 프로토콜의 오류를 처리하십시오. 이것은 주어진 인수 (프로토콜 특정)와 함께 주어진 프로토콜에 대해 등록 된 오류 처리기를 호출합니다. HTTP 프로토콜은 HTTP 응답 코드를 사용하여 특정 오류 처리기를 결정하는 특수한 경우입니다. 핸들러 클래스 의 &lt;code&gt;http_error_&amp;lt;type&amp;gt;()&lt;/code&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a276c3fe5b84b1615109b01fd49c20d2b394e289" translate="yes" xml:space="preserve">
          <source>Handle an unparsed entity declaration event.</source>
          <target state="translated">구문 분석되지 않은 엔티티 선언 이벤트를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="88220eb8720a2bc1735b528b203386438a372258" translate="yes" xml:space="preserve">
          <source>Handle an unraisable exception.</source>
          <target state="translated">합당한 예외를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="1060bc6c7b88726a08b50df11671c5366cd9d24c" translate="yes" xml:space="preserve">
          <source>Handle authentication with the proxy. &lt;em&gt;password_mgr&lt;/em&gt;, if given, should be something that is compatible with &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt;; refer to section &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr Objects&lt;/a&gt; for information on the interface that must be supported.</source>
          <target state="translated">프록시로 인증을 처리하십시오. &lt;em&gt;password_mgr&lt;/em&gt; 이 지정된 경우 &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt; 과 호환 가능한 것이어야합니다 . 지원해야하는 인터페이스에 대한 정보는 &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr 오브젝트&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16dc31a241c55ceeae234120336a22eafb971e87" translate="yes" xml:space="preserve">
          <source>Handle authentication with the remote host. &lt;em&gt;password_mgr&lt;/em&gt;, if given, should be something that is compatible with &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt;; refer to section &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr Objects&lt;/a&gt; for information on the interface that must be supported. HTTPBasicAuthHandler will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when presented with a wrong Authentication scheme.</source>
          <target state="translated">원격 호스트로 인증을 처리하십시오. &lt;em&gt;password_mgr&lt;/em&gt; 이 지정된 경우 &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt; 과 호환 가능한 것이어야합니다 . 지원해야하는 인터페이스에 대한 정보는 &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr 오브젝트&lt;/a&gt; 섹션을 참조하십시오 . 잘못된 인증 체계가 표시 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; HTTPBasicAuthHandler가 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="099ecb73fd6f904c0f4b5605d72f0a36103ca94d" translate="yes" xml:space="preserve">
          <source>Handle authentication with the remote host. &lt;em&gt;password_mgr&lt;/em&gt;, if given, should be something that is compatible with &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt;; refer to section &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr Objects&lt;/a&gt; for information on the interface that must be supported. When both Digest Authentication Handler and Basic Authentication Handler are both added, Digest Authentication is always tried first. If the Digest Authentication returns a 40x response again, it is sent to Basic Authentication handler to Handle. This Handler method will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when presented with an authentication scheme other than Digest or Basic.</source>
          <target state="translated">원격 호스트로 인증을 처리하십시오. &lt;em&gt;password_mgr&lt;/em&gt; 이 지정된 경우 &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt; 과 호환 가능한 것이어야합니다 . 지원해야하는 인터페이스에 대한 정보는 &lt;a href=&quot;#http-password-mgr&quot;&gt;HTTPPasswordMgr 오브젝트&lt;/a&gt; 섹션을 참조하십시오 . 다이제스트 인증 처리기와 기본 인증 처리기가 모두 추가되면 다이제스트 인증이 항상 먼저 시도됩니다. 다이제스트 인증이 다시 40x 응답을 반환하면 기본 인증 처리기로 보내 처리됩니다. 이 처리기 메서드는 다이제스트 또는 기본 이외의 인증 체계가 제공 될 때 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2e877e234920ac6dd114466dccb707642ee7aca1" translate="yes" xml:space="preserve">
          <source>Handle how a breakpoint must be removed when it is a temporary one.</source>
          <target state="translated">중단 점이 일시적인 경우 중단 점을 제거하는 방법을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="c275e80e41cb467befe8a992aa8ef142dc1b4cd4" translate="yes" xml:space="preserve">
          <source>Handle objects can be converted to an integer (e.g., using the built-in &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt; function), in which case the underlying Windows handle value is returned. You can also use the &lt;a href=&quot;#winreg.PyHKEY.Detach&quot;&gt;&lt;code&gt;Detach()&lt;/code&gt;&lt;/a&gt; method to return the integer handle, and also disconnect the Windows handle from the handle object.</source>
          <target state="translated">핸들 객체를 정수로 변환 할 수 있습니다 (예 : 내장 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt; 함수 사용).이 경우 기본 Windows 핸들 값이 반환됩니다. 당신은 또한 사용할 수 &lt;a href=&quot;#winreg.PyHKEY.Detach&quot;&gt; &lt;code&gt;Detach()&lt;/code&gt; &lt;/a&gt; 핸들 객체에서 윈도우 핸들을 정수 핸들을 반환하고, 또한 분리 방법.</target>
        </trans-unit>
        <trans-unit id="8385c6fa8af7de5af62c9fd3a69dd17642c7c9d1" translate="yes" xml:space="preserve">
          <source>Handle objects provide semantics for &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__bool__&quot;&gt;&lt;code&gt;__bool__()&lt;/code&gt;&lt;/a&gt; &amp;ndash; thus</source>
          <target state="translated">핸들 객체는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__bool__&quot;&gt; &lt;code&gt;__bool__()&lt;/code&gt; &lt;/a&gt; 의미를 제공합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="2afaf4f89a5a11064c833154986f2f5a84c15945" translate="yes" xml:space="preserve">
          <source>Handle requests until an explicit &lt;a href=&quot;#socketserver.BaseServer.shutdown&quot;&gt;&lt;code&gt;shutdown()&lt;/code&gt;&lt;/a&gt; request. Poll for shutdown every &lt;em&gt;poll_interval&lt;/em&gt; seconds. Ignores the &lt;a href=&quot;#socketserver.BaseServer.timeout&quot;&gt;&lt;code&gt;timeout&lt;/code&gt;&lt;/a&gt; attribute. It also calls &lt;a href=&quot;#socketserver.BaseServer.service_actions&quot;&gt;&lt;code&gt;service_actions()&lt;/code&gt;&lt;/a&gt;, which may be used by a subclass or mixin to provide actions specific to a given service. For example, the &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt;&lt;code&gt;ForkingMixIn&lt;/code&gt;&lt;/a&gt; class uses &lt;a href=&quot;#socketserver.BaseServer.service_actions&quot;&gt;&lt;code&gt;service_actions()&lt;/code&gt;&lt;/a&gt; to clean up zombie child processes.</source>
          <target state="translated">명시 적 &lt;a href=&quot;#socketserver.BaseServer.shutdown&quot;&gt; &lt;code&gt;shutdown()&lt;/code&gt; &lt;/a&gt; 요청까지 요청을 처리하십시오 . &lt;em&gt;poll_interval&lt;/em&gt; 초 마다 시스템 종료를 폴링합니다 . &lt;a href=&quot;#socketserver.BaseServer.timeout&quot;&gt; &lt;code&gt;timeout&lt;/code&gt; &lt;/a&gt; 속성을 무시 합니다. 또한 &lt;a href=&quot;#socketserver.BaseServer.service_actions&quot;&gt; &lt;code&gt;service_actions()&lt;/code&gt; &lt;/a&gt; 호출 하는데, 서브 클래스 또는 믹스 인에서 특정 서비스에 특정한 동작을 제공하는 데 사용될 수 있습니다. 예를 들어 &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt; &lt;code&gt;ForkingMixIn&lt;/code&gt; &lt;/a&gt; 클래스는 &lt;a href=&quot;#socketserver.BaseServer.service_actions&quot;&gt; &lt;code&gt;service_actions()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 좀비 자식 프로세스를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="bb6c587f11689be2d6937f95e7f78dacb7880c2d" translate="yes" xml:space="preserve">
          <source>Handle uncaught exception raised by &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;Thread.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;Thread.run()&lt;/code&gt; &lt;/a&gt; 의해 발생 된 포착되지 않은 예외를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="be02a9f775c20e09c3a657bc25211bd693cc8d23" translate="yes" xml:space="preserve">
          <source>Handler Objects</source>
          <target state="translated">핸들러 객체</target>
        </trans-unit>
        <trans-unit id="7eb34507475372acbffdf6d92308c8251b5e3824" translate="yes" xml:space="preserve">
          <source>Handlers have the following attributes and methods. Note that &lt;a href=&quot;#logging.Handler&quot;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt; is never instantiated directly; this class acts as a base for more useful subclasses. However, the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method in subclasses needs to call &lt;a href=&quot;#logging.Handler.__init__&quot;&gt;&lt;code&gt;Handler.__init__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">핸들러에는 다음과 같은 속성과 메소드가 있습니다. 참고 &lt;a href=&quot;#logging.Handler&quot;&gt; &lt;code&gt;Handler&lt;/code&gt; &lt;/a&gt; 인스턴스를 직접 생성되지 않습니다; 이 클래스는보다 유용한 서브 클래스의 기본 역할을합니다. 그러나 서브 클래스 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;#logging.Handler.__init__&quot;&gt; &lt;code&gt;Handler.__init__()&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d46c9ae22acb5d3645908e5bf4511d544f3a6b7" translate="yes" xml:space="preserve">
          <source>Handlers send the log records (created by loggers) to the appropriate destination.</source>
          <target state="translated">핸들러는 로거가 작성한 로그 레코드를 적절한 대상으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="84b8e969da65bf24a329495e90cf29dd7b94f19e" translate="yes" xml:space="preserve">
          <source>Handlers with a method named like &lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt; are called to handle the request. This stage ends when a handler either returns a non-&lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; value (ie. a response), or raises an exception (usually &lt;a href=&quot;urllib.error#urllib.error.URLError&quot;&gt;&lt;code&gt;URLError&lt;/code&gt;&lt;/a&gt;). Exceptions are allowed to propagate.</source>
          <target state="translated">&lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt; 과 같은 이름의 메소드를 가진 핸들러가 요청을 처리하기 위해 호출됩니다. 이 단계는 핸들러가 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 아닌 값 (예 : 응답)을 반환 하거나 예외 (보통 &lt;a href=&quot;urllib.error#urllib.error.URLError&quot;&gt; &lt;code&gt;URLError&lt;/code&gt; &lt;/a&gt; )를 발생 시킬 때 종료됩니다 . 예외 전파가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bcb894d769a4dd64c40d2bdb7b0ee4952c58f5b" translate="yes" xml:space="preserve">
          <source>Handles a doctype declaration. &lt;em&gt;name&lt;/em&gt; is the doctype name. &lt;em&gt;pubid&lt;/em&gt; is the public identifier. &lt;em&gt;system&lt;/em&gt; is the system identifier. This method does not exist on the default &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt;&lt;code&gt;TreeBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">doctype 선언을 처리합니다. &lt;em&gt;name&lt;/em&gt; 은 doctype 이름입니다. &lt;em&gt;pubid&lt;/em&gt; 는 공개 식별자입니다. &lt;em&gt;system&lt;/em&gt; 은 시스템 식별자입니다. 이 메서드는 기본 &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt; &lt;code&gt;TreeBuilder&lt;/code&gt; &lt;/a&gt; 클래스에 없습니다.</target>
        </trans-unit>
        <trans-unit id="56c022088fb27c6c5c9d8bcb3c440786808ef179" translate="yes" xml:space="preserve">
          <source>Handles a record by passing it to all handlers associated with this logger and its ancestors (until a false value of &lt;em&gt;propagate&lt;/em&gt; is found). This method is used for unpickled records received from a socket, as well as those created locally. Logger-level filtering is applied using &lt;a href=&quot;#logging.Logger.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 로거 및 해당 상위와 연관된 모든 핸들러에 레코드를 전달하여 레코드를 처리합니다 (잘못된 값의 &lt;em&gt;전파&lt;/em&gt; 가 발견 될 때까지 ). 이 방법은 소켓에서 수신 된 피클 링되지 않은 레코드와 로컬로 작성된 레코드에 사용됩니다. 로거 수준 필터링은 &lt;a href=&quot;#logging.Logger.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 사용하여 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c3b04664d696d0fa7762642ed6eccefdf4d892c" translate="yes" xml:space="preserve">
          <source>Handles an error which has occurred during &lt;a href=&quot;#logging.handlers.SocketHandler.emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. The most likely cause is a lost connection. Closes the socket so that we can retry on the next event.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.SocketHandler.emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; 중에 발생한 오류를 처리합니다 . 가장 가능성이 높은 원인은 연결이 끊어진 것입니다. 다음 이벤트에서 다시 시도 할 수 있도록 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="d7568474b0c5d0deb421b6274fcb2bf0af693b7b" translate="yes" xml:space="preserve">
          <source>Handles the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header.</source>
          <target state="translated">&lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="2ba87bc15b853d0b3254ce18760f988d9c907655" translate="yes" xml:space="preserve">
          <source>Handling Stateful Objects</source>
          <target state="translated">상태 저장 객체 처리</target>
        </trans-unit>
        <trans-unit id="d4c17076488bf64b63db8111e44b0dde598cfc0f" translate="yes" xml:space="preserve">
          <source>Handling positional arguments.</source>
          <target state="translated">위치 인수 처리.</target>
        </trans-unit>
        <trans-unit id="80fe32e67eb7aed793b1d67d211a8198a39506a3" translate="yes" xml:space="preserve">
          <source>Handling zero-or-more and one-or-more style arguments.</source>
          <target state="translated">0 개 이상의 스타일 인수 처리</target>
        </trans-unit>
        <trans-unit id="914fc1ca59d60f8b53aaaa51e2728e761cc31a75" translate="yes" xml:space="preserve">
          <source>Handy Reference</source>
          <target state="translated">편리한 참조</target>
        </trans-unit>
        <trans-unit id="0d8a35cbc11bb2986e111bb7048bc661f162a028" translate="yes" xml:space="preserve">
          <source>Hang up happened on the assoc. fd</source>
          <target state="translated">협회에서 끊어졌습니다. fd</target>
        </trans-unit>
        <trans-unit id="28ac25e382cbf0d1025fd3f532ff2aeb20012d52" translate="yes" xml:space="preserve">
          <source>Harmonic mean of data.</source>
          <target state="translated">고조파 데이터 평균.</target>
        </trans-unit>
        <trans-unit id="5d5f0cfcaa9f574e8a332a820d4d9d82eea71bb3" translate="yes" xml:space="preserve">
          <source>Has two optional arguments which must be specified as keyword arguments.</source>
          <target state="translated">키워드 인수로 지정해야하는 두 개의 선택적 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="2a9a23956b6c95b1bda07fb332057044e9c2584a" translate="yes" xml:space="preserve">
          <source>Hash algorithms</source>
          <target state="translated">해시 알고리즘</target>
        </trans-unit>
        <trans-unit id="e146edfef10cc2f76cac45cb7eeb8f7a5d679e6a" translate="yes" xml:space="preserve">
          <source>Hash objects from this module follow the API of standard library&amp;rsquo;s &lt;a href=&quot;#module-hashlib&quot;&gt;&lt;code&gt;hashlib&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">이 모듈의 해시 객체는 표준 라이브러리의 &lt;a href=&quot;#module-hashlib&quot;&gt; &lt;code&gt;hashlib&lt;/code&gt; &lt;/a&gt; 객체 의 API를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="c6aeab0420dd390a78c9b7dfabcf5a39921d254c" translate="yes" xml:space="preserve">
          <source>Hash objects with different digest sizes have completely different outputs (shorter hashes are &lt;em&gt;not&lt;/em&gt; prefixes of longer hashes); BLAKE2b and BLAKE2s produce different outputs even if the output length is the same:</source>
          <target state="translated">다이제스트 크기가 다른 해시 객체의 출력은 완전히 다릅니다 (짧은 해시는 긴 해시의 접두사 가 &lt;em&gt;아님&lt;/em&gt; ). BLAKE2b와 BLAKE2는 출력 길이가 동일하더라도 다른 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ad92929e3b14f9ded46f9153491efe74c6f63f1f" translate="yes" xml:space="preserve">
          <source>Hashing Methods</source>
          <target state="translated">해싱 방법</target>
        </trans-unit>
        <trans-unit id="303fce0ac745167c9c8a05f3e0aa201a3f84b7a1" translate="yes" xml:space="preserve">
          <source>Hashing of numeric types</source>
          <target state="translated">숫자 형 해시</target>
        </trans-unit>
        <trans-unit id="b194cf3788207606ecc3b2e7d17d26585f5d57e6" translate="yes" xml:space="preserve">
          <source>Hashlib provides the following constant attributes:</source>
          <target state="translated">Hashlib는 다음과 같은 상수 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8503ede3ea63ea360679c1a7bb9c6feb415c1aeb" translate="yes" xml:space="preserve">
          <source>Have fun!</source>
          <target state="translated">즐기세요!</target>
        </trans-unit>
        <trans-unit id="78f963073bec4db63e808e2d6e30b53085d9d799" translate="yes" xml:space="preserve">
          <source>Having two enum members with the same name is invalid:</source>
          <target state="translated">이름이 같은 열거 형 멤버가 두 개있는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="956e067b3f83c675f83b89ad77530a84a25325b3" translate="yes" xml:space="preserve">
          <source>Header folding is controlled by the &lt;a href=&quot;#email.policy.EmailPolicy.refold_source&quot;&gt;&lt;code&gt;refold_source&lt;/code&gt;&lt;/a&gt; policy setting. A value is considered to be a &amp;lsquo;source value&amp;rsquo; if and only if it does not have a &lt;code&gt;name&lt;/code&gt; attribute (having a &lt;code&gt;name&lt;/code&gt; attribute means it is a header object of some sort). If a source value needs to be refolded according to the policy, it is converted into a header object by passing the &lt;em&gt;name&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt; with any CR and LF characters removed to the &lt;code&gt;header_factory&lt;/code&gt;. Folding of a header object is done by calling its &lt;code&gt;fold&lt;/code&gt; method with the current policy.</source>
          <target state="translated">헤더 접기는 &lt;a href=&quot;#email.policy.EmailPolicy.refold_source&quot;&gt; &lt;code&gt;refold_source&lt;/code&gt; &lt;/a&gt; 정책 설정에 의해 제어됩니다 . &lt;code&gt;name&lt;/code&gt; 속성 이없는 경우에만 값이 '소스 값'으로 간주됩니다 ( &lt;code&gt;name&lt;/code&gt; 속성이있는 경우 일종의 헤더 객체임을 의미). 정책에 따라 소스 값을 다시 접어야 하는 경우 CR 및 LF 문자가 제거 된 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 을 &lt;code&gt;header_factory&lt;/code&gt; 로 전달하여 헤더 오브젝트로 변환 합니다 . 현재 정책으로 &lt;code&gt;fold&lt;/code&gt; 메서드를 호출하면 헤더 개체를 접을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6901a3735f0255d8719b4fb97692a6865119569f" translate="yes" xml:space="preserve">
          <source>Header-encode a &lt;em&gt;string&lt;/em&gt; by converting it first to bytes.</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 을 먼저 바이트로 변환 하여 헤더를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="5fe13d069f9bcd0482900a73296e2aa37b5e706a" translate="yes" xml:space="preserve">
          <source>Header-encode the string &lt;em&gt;string&lt;/em&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;string을&lt;/em&gt; 헤더 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a7ea6a21e332b0e60f835d8a4c6db06db904c6b7" translate="yes" xml:space="preserve">
          <source>Headers are folded using the &lt;a href=&quot;email.header#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; folding algorithm, which preserves existing line breaks in the value, and wraps each resulting line to the &lt;code&gt;max_line_length&lt;/code&gt;. If &lt;code&gt;cte_type&lt;/code&gt; is &lt;code&gt;7bit&lt;/code&gt;, non-ascii binary data is CTE encoded using the &lt;code&gt;unknown-8bit&lt;/code&gt; charset. Otherwise the original source header is used, with its existing line breaks and any (RFC invalid) binary data it may contain.</source>
          <target state="translated">헤더는 값의 기존 줄 바꿈을 유지하고 각 결과 줄을 &lt;code&gt;max_line_length&lt;/code&gt; 로 랩핑 하는 &lt;a href=&quot;email.header#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 폴딩 알고리즘을 사용하여 폴딩 됩니다. 경우 &lt;code&gt;cte_type&lt;/code&gt; 가 인 &lt;code&gt;7bit&lt;/code&gt; , 비 ASCII 이진 데이터 CTE를 사용하여 인코딩 &lt;code&gt;unknown-8bit&lt;/code&gt; 문자셋. 그렇지 않으면 기존의 줄 바꿈 및 포함 할 수있는 (RFC 유효하지 않은) 이진 데이터와 함께 원본 소스 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe8caffa7403f60ddcd1cc993c5dd8678905a97" translate="yes" xml:space="preserve">
          <source>Headers are folded using the &lt;a href=&quot;email.header#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; folding algorithm, which preserves existing line breaks in the value, and wraps each resulting line to the &lt;code&gt;max_line_length&lt;/code&gt;. Non-ASCII binary data are CTE encoded using the &lt;code&gt;unknown-8bit&lt;/code&gt; charset.</source>
          <target state="translated">헤더는 값의 기존 줄 바꿈을 유지하고 각 결과 줄을 &lt;code&gt;max_line_length&lt;/code&gt; 로 랩핑 하는 &lt;a href=&quot;email.header#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 폴딩 알고리즘을 사용하여 폴딩 됩니다. 비 ASCII 이진 데이터는 &lt;code&gt;unknown-8bit&lt;/code&gt; 문자 집합을 사용하여 CTE로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="a98bc6401562f58049cacbc1e7407670111c1e89" translate="yes" xml:space="preserve">
          <source>Headers are represented by customized subclasses of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. The particular class used to represent a given header is determined by the &lt;a href=&quot;email.policy#email.policy.EmailPolicy.header_factory&quot;&gt;&lt;code&gt;header_factory&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; in effect when the headers are created. This section documents the particular &lt;code&gt;header_factory&lt;/code&gt; implemented by the email package for handling &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; compliant email messages, which not only provides customized header objects for various header types, but also provides an extension mechanism for applications to add their own custom header types.</source>
          <target state="translated">헤더는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 의&lt;/a&gt; 사용자 정의 된 서브 클래스로 표시됩니다 . 주어진 헤더를 나타내는 데 사용되는 특정 클래스 는 헤더가 생성 될 때 유효한 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;email.policy#email.policy.EmailPolicy.header_factory&quot;&gt; &lt;code&gt;header_factory&lt;/code&gt; &lt;/a&gt; 에 의해 결정됩니다 . 이 섹션에서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 호환 전자 메일 메시지 를 처리하기 위해 전자 메일 패키지로 구현 된 특정 &lt;code&gt;header_factory&lt;/code&gt; 에 대해 설명합니다. &lt;strong&gt;RFC 5322&lt;/strong&gt; 호환 전자 메일 메시지는 다양한 헤더 유형에 대해 사용자 정의 된 헤더 객체를 제공 할뿐만 아니라 응용 프로그램이 고유 한 사용자 정의 헤더 유형을 추가 할 수있는 확장 메커니즘을 제공합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e393fa6a2b7360dfa38d3d9b9332735fa20c75f1" translate="yes" xml:space="preserve">
          <source>Heap elements can be tuples. This is useful for assigning comparison values (such as task priorities) alongside the main record being tracked:</source>
          <target state="translated">힙 요소는 튜플 일 수 있습니다. 이는 추적중인 기본 레코드와 함께 비교 값 (예 : 작업 우선 순위)을 지정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f05c2ca1637855efab589e3146dfd91ec2b8dfd7" translate="yes" xml:space="preserve">
          <source>Heaps are also very useful in big disk sorts. You most probably all know that a big sort implies producing &amp;ldquo;runs&amp;rdquo; (which are pre-sorted sequences, whose size is usually related to the amount of CPU memory), followed by a merging passes for these runs, which merging is often very cleverly organised &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. It is very important that the initial sort produces the longest runs possible. Tournaments are a good way to achieve that. If, using all the memory available to hold a tournament, you replace and percolate items that happen to fit the current run, you&amp;rsquo;ll produce runs which are twice the size of the memory for random input, and much better for input fuzzily ordered.</source>
          <target state="translated">힙은 큰 디스크 정렬에도 매우 유용합니다. 대부분의 경우 큰 정렬은 &quot;실행&quot;(크기가 일반적으로 CPU 메모리 크기와 관련된 사전 정렬 된 시퀀스)을 생성 한 다음 이러한 실행에 대한 병합 패스를 의미하며, 이러한 병합은 종종 매우 영리합니다. 조직 &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; . 초기 정렬이 가능한 한 가장 긴 실행을 생성하는 것이 매우 중요합니다. 토너먼트는이를 달성하기위한 좋은 방법입니다. 토너먼트를 개최하는 데 사용할 수있는 모든 메모리를 사용하여 현재 런에 맞게 발생하는 항목을 교체하고 percolate하는 경우 임의의 입력을 위해 메모리 크기의 두 배인 런을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94253428243000d37b9f634428431d09481c1836" translate="yes" xml:space="preserve">
          <source>Heaps are arrays for which &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt; and &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; for all &lt;em&gt;k&lt;/em&gt;, counting elements from 0. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that &lt;code&gt;a[0]&lt;/code&gt; is always its smallest element.</source>
          <target state="translated">힙 배열되어있는 &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt; 및 &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; 모든 &lt;em&gt;K&lt;/em&gt; , 비교를 위해서 0부터 카운트 요소 비 기존 요소는 무한한 것으로 간주됩니다. 힙의 흥미로운 특성은 a &lt;code&gt;a[0]&lt;/code&gt; 이 항상 가장 작은 요소라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0958aba14742bb54b868bb2e7efefba45a47ee7" translate="yes" xml:space="preserve">
          <source>Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which &lt;code&gt;heap[k] &amp;lt;= heap[2*k+1]&lt;/code&gt; and &lt;code&gt;heap[k] &amp;lt;= heap[2*k+2]&lt;/code&gt; for all &lt;em&gt;k&lt;/em&gt;, counting elements from zero. For the sake of comparison, non-existing elements are considered to be infinite. The interesting property of a heap is that its smallest element is always the root, &lt;code&gt;heap[0]&lt;/code&gt;.</source>
          <target state="translated">힙은 모든 부모 노드가 자식 값보다 작거나 같은 이진 트리입니다. 이러한 구현에서 사용되는 배열 &lt;code&gt;heap[k] &amp;lt;= heap[2*k+1]&lt;/code&gt; 과 &lt;code&gt;heap[k] &amp;lt;= heap[2*k+2]&lt;/code&gt; 모든 &lt;em&gt;K&lt;/em&gt; , 0으로부터 카운팅 소자. 비교를 위해 존재하지 않는 요소는 무한한 것으로 간주됩니다. 힙의 흥미로운 특성은 가장 작은 요소가 항상 루트 인 &lt;code&gt;heap[0]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="59b3a81a6811a92bb1cf8fec2fbe19d8c89c6cf1" translate="yes" xml:space="preserve">
          <source>Height of the terminal window in characters.</source>
          <target state="translated">문자로 된 터미널 창의 높이.</target>
        </trans-unit>
        <trans-unit id="ecb0bdc009a4e94b619f238e5c038184e5a5c5ef" translate="yes" xml:space="preserve">
          <source>Hello World with call_soon()</source>
          <target state="translated">call_soon ()이있는 Hello World</target>
        </trans-unit>
        <trans-unit id="2ef7bde608ce5404e97d5f042f95f89f1c232871" translate="yes" xml:space="preserve">
          <source>Hello World!</source>
          <target state="translated">안녕하세요 세계!</target>
        </trans-unit>
        <trans-unit id="c47ae15370cfe1ed2781eedc1dc2547d12d9e972" translate="yes" xml:space="preserve">
          <source>Help</source>
          <target state="translated">Help</target>
        </trans-unit>
        <trans-unit id="28e7dce7cb9f9601d24981a334e76f6c313bf469" translate="yes" xml:space="preserve">
          <source>Help and configuration</source>
          <target state="translated">도움말 및 구성</target>
        </trans-unit>
        <trans-unit id="a18d02323a87b03f7466d8b1da693ffe43a62734" translate="yes" xml:space="preserve">
          <source>Help and preferences</source>
          <target state="translated">도움말 및 환경 설정</target>
        </trans-unit>
        <trans-unit id="1e5e41c77d62a1f28e9ed2f5576b34dc1f7958ab" translate="yes" xml:space="preserve">
          <source>Help menu (Shell and Editor)</source>
          <target state="translated">도움말 메뉴 (쉘 및 편집기)</target>
        </trans-unit>
        <trans-unit id="793e97ee72773880ffe54983bbdef3032df6fc32" translate="yes" xml:space="preserve">
          <source>Help menu entry &amp;ldquo;IDLE Help&amp;rdquo; displays a formatted html version of the IDLE chapter of the Library Reference. The result, in a read-only tkinter text window, is close to what one sees in a web browser. Navigate through the text with a mousewheel, the scrollbar, or up and down arrow keys held down. Or click the TOC (Table of Contents) button and select a section header in the opened box.</source>
          <target state="translated">도움말 메뉴 항목 &quot;IDLE 도움말&quot;은 라이브러리 참조의 IDLE 장 형식의 html 버전을 표시합니다. 읽기 전용 tkinter 텍스트 창에서 결과는 웹 브라우저에서 보는 것과 비슷합니다. 마우스 휠, 스크롤바 또는 위쪽 및 아래쪽 화살표 키를 누른 상태로 텍스트를 탐색하십시오. 또는 목차 (목차) 단추를 클릭하고 열린 상자에서 섹션 머리글을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="b11a1a8fed4583088aeda48052c86ca844eebd01" translate="yes" xml:space="preserve">
          <source>Help menu entry &amp;ldquo;Python Docs&amp;rdquo; opens the extensive sources of help, including tutorials, available at &lt;code&gt;docs.python.org/x.y&lt;/code&gt;, where &amp;lsquo;x.y&amp;rsquo; is the currently running Python version. If your system has an off-line copy of the docs (this may be an installation option), that will be opened instead.</source>
          <target state="translated">도움말 메뉴 항목 &quot;Python Docs&quot;는 &lt;code&gt;docs.python.org/x.y&lt;/code&gt; 에있는 자습서를 포함하여 광범위한 도움말 소스를 엽니 다. 여기서 'x.y'는 현재 실행중인 Python 버전입니다. 시스템에 문서의 오프라인 사본이있는 경우 (설치 옵션 일 수 있음) 대신 열립니다.</target>
        </trans-unit>
        <trans-unit id="dfb5d6579c133dffbacf19caeed708a180fc034d" translate="yes" xml:space="preserve">
          <source>Help sources</source>
          <target state="translated">도움말 소스</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="9f94e06f2e8ee19ef9699de5b8431b151fa4c9ee" translate="yes" xml:space="preserve">
          <source>Helper to print a traceback from the timed code.</source>
          <target state="translated">시간이 지정된 코드에서 역 추적을 인쇄하는 도우미</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="9bad4c938651ee76ce6a287a012d5591687a09bc" translate="yes" xml:space="preserve">
          <source>Hence an &lt;em&gt;iterable&lt;/em&gt; of &lt;code&gt;[(1,2), (3, 4)]&lt;/code&gt; results in &lt;code&gt;[func(1,2),
func(3,4)]&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;em&gt;반복 가능&lt;/em&gt; 의 &lt;code&gt;[(1,2), (3, 4)]&lt;/code&gt; 의 결과 &lt;code&gt;[func(1,2), func(3,4)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b44d2a2afad6e9544558991fb0f0fd1e144d478b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;floatnumber&lt;/code&gt; is the form of a Python floating-point literal, described in &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#floating&quot;&gt;Floating point literals&lt;/a&gt;. Case is not significant, so, for example, &amp;ldquo;inf&amp;rdquo;, &amp;ldquo;Inf&amp;rdquo;, &amp;ldquo;INFINITY&amp;rdquo; and &amp;ldquo;iNfINity&amp;rdquo; are all acceptable spellings for positive infinity.</source>
          <target state="translated">여기 &lt;code&gt;floatnumber&lt;/code&gt; 에 기재된 파이썬 부동 소수점 리터럴의 형태 인 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#floating&quot;&gt;점 리터럴 떠&lt;/a&gt; . 대소 문자는 중요하지 않으므로 예를 들어 &quot;inf&quot;, &quot;Inf&quot;, &quot;INFINITY&quot;및 &quot;iNfINity&quot;는 모두 양의 무한대에 허용되는 철자입니다.</target>
        </trans-unit>
        <trans-unit id="e9577fd9feab5cb1e4b56a6d0ea9de1dd1d4a07d" translate="yes" xml:space="preserve">
          <source>Here all warnings will be caught, and the test code tests the captured warnings directly.</source>
          <target state="translated">여기서 모든 경고가 포착되고 테스트 코드는 캡처 된 경고를 직접 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="d4cbf6d694573a6b35a8882624d22cfd46ff632e" translate="yes" xml:space="preserve">
          <source>Here are a few examples of how to use the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package to read, write, and send simple email messages, as well as more complex MIME messages.</source>
          <target state="translated">다음은 &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지 를 사용하여 간단한 전자 메일 메시지와 복잡한 MIME 메시지를 읽고 쓰고 보내는 방법에 대한 몇 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c9c7cc8a120a0af672345b3356e3d523999fbe1c" translate="yes" xml:space="preserve">
          <source>Here are a few recipes that serve as utility functions and that demonstrate ways to work with the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">다음은 유틸리티 함수 역할을하고 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 클래스 작업 방법을 보여주는 몇 가지 레시피입니다 .</target>
        </trans-unit>
        <trans-unit id="cc7e228700c1b92ad7ac1415ee4e043abb38dd76" translate="yes" xml:space="preserve">
          <source>Here are four minimal example programs using the TCP/IP protocol: a server that echoes all data that it receives back (servicing only one client), and a client using it. Note that a server must perform the sequence &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#socket.socket.bind&quot;&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#socket.socket.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#socket.socket.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; (possibly repeating the &lt;a href=&quot;#socket.socket.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; to service more than one client), while a client only needs the sequence &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#socket.socket.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt;. Also note that the server does not &lt;a href=&quot;#socket.socket.sendall&quot;&gt;&lt;code&gt;sendall()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#socket.socket.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; on the socket it is listening on but on the new socket returned by &lt;a href=&quot;#socket.socket.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음은 TCP / IP 프로토콜을 사용하는 최소 4 개의 프로그램 예입니다. 수신하는 모든 데이터를 에코하는 서버 (하나의 클라이언트에만 서비스)와이를 사용하는 클라이언트. 서버가 시퀀스 수행해야합니다 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#socket.socket.bind&quot;&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#socket.socket.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#socket.socket.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; (아마도이 반복 &lt;a href=&quot;#socket.socket.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 클라이언트는 시퀀스가 필요하지만, 서비스에 하나 이상의 클라이언트) &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#socket.socket.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; . 또한 서버 는 청취중인 소켓에서 &lt;a href=&quot;#socket.socket.sendall&quot;&gt; &lt;code&gt;sendall()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#socket.socket.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 를 보내지 않지만 &lt;a href=&quot;#socket.socket.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 반환 한 새 소켓 에서는 sendall () / recv () 를 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="848203b6ef6b35a2defc3dccc96affca56775c19" translate="yes" xml:space="preserve">
          <source>Here are some additional useful header related methods:</source>
          <target state="translated">추가적인 유용한 헤더 관련 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90a7aeffda70ad496e94cfcc706ad61c2e0aaa10" translate="yes" xml:space="preserve">
          <source>Here are some additional useful methods:</source>
          <target state="translated">몇 가지 유용한 추가 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac2adcb2af1c2b090a1c0d1be0dc3af785419f4" translate="yes" xml:space="preserve">
          <source>Here are some examples for Windows. Note that &lt;code&gt;msvcrt&lt;/code&gt; is the MS standard C library containing most standard C functions, and uses the cdecl calling convention:</source>
          <target state="translated">다음은 Windows 용 예제입니다. 참고 것을 &lt;code&gt;msvcrt&lt;/code&gt; 대부분의 표준 C의 기능을 포함하는 MS의 표준 C 라이브러리이며, 호출 규칙을 cdecl 규칙을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="5f862bd79424f8f419f9104ffde0b99c655fec57" translate="yes" xml:space="preserve">
          <source>Here are some examples of typical usage of the &lt;a href=&quot;#module-tempfile&quot;&gt;&lt;code&gt;tempfile&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">다음은 &lt;a href=&quot;#module-tempfile&quot;&gt; &lt;code&gt;tempfile&lt;/code&gt; &lt;/a&gt; 모듈 의 일반적인 사용법에 대한 몇 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="421e4af8c302f92252068c4e665eb8048a72f5d5" translate="yes" xml:space="preserve">
          <source>Here are some examples of typical usage of the &lt;a href=&quot;#module-uuid&quot;&gt;&lt;code&gt;uuid&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">다음은 &lt;a href=&quot;#module-uuid&quot;&gt; &lt;code&gt;uuid&lt;/code&gt; &lt;/a&gt; 모듈 의 일반적인 사용법에 대한 몇 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="d96b3e058a1f9b5592e9360379e20ef013857e85" translate="yes" xml:space="preserve">
          <source>Here are some examples of typical usage:</source>
          <target state="translated">다음은 일반적인 사용법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="12ec0a6b54e682604fd1f54622b08efce3df4999" translate="yes" xml:space="preserve">
          <source>Here are some notes on the parsing semantics:</source>
          <target state="translated">구문 분석 시맨틱에 대한 참고 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3edc31d64bca5d6336f03a57993926d153773bd" translate="yes" xml:space="preserve">
          <source>Here are some other methods and attributes you may wish to override. This list is only a summary, however, and does not include every method that can be overridden. You should consult the docstrings and source code for additional information before attempting to create a customized &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">재정의하려는 다른 방법과 속성은 다음과 같습니다. 그러나이 목록은 요약 일 뿐이며 재정의 할 수있는 모든 방법을 포함하지는 않습니다. 사용자 정의 된 &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 서브 클래스 를 작성하기 전에 추가 정보는 docstring 및 소스 코드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="850baf30242031506b0e614d9eb98d9a7955b34d" translate="yes" xml:space="preserve">
          <source>Here are the classes:</source>
          <target state="translated">수업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6fe11950cf6fa846a750dbaed423167118cf8e0" translate="yes" xml:space="preserve">
          <source>Here are the encoding functions provided:</source>
          <target state="translated">제공된 인코딩 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b95c5e82df057126a3c36996dbffbc4c5362267f" translate="yes" xml:space="preserve">
          <source>Here are the methods of the &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 클래스 의 메소드는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ed31d258ad18f9d3c2b6b8464a85b09de67bd9b4" translate="yes" xml:space="preserve">
          <source>Here are the rules governing implicit creation of a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method. Note that you cannot both have an explicit &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method in your dataclass and set &lt;code&gt;unsafe_hash=True&lt;/code&gt;; this will result in a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드 의 암시 적 생성을 관리하는 규칙 입니다. 데이터 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 에 명시적인 __hash __ () 메소드를 둘 수 없으며 &lt;code&gt;unsafe_hash=True&lt;/code&gt; 를 설정할 수 없습니다 . 이로 인해 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="8c196634973a8d99ccdf18cbc5696310bd7964c7" translate="yes" xml:space="preserve">
          <source>Here are the rules in detail:</source>
          <target state="translated">자세한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="557b26034ea3c92b6163bb318046d2bddeae00b9" translate="yes" xml:space="preserve">
          <source>Here are two small examples of how it can be used. To list some statistics about a newsgroup and print the subjects of the last 10 articles:</source>
          <target state="translated">다음은 사용 방법에 대한 두 가지 작은 예입니다. 뉴스 그룹에 대한 일부 통계를 나열하고 최근 10 개 기사의 주제를 인쇄하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="179d40c94384439c79c1a720dc54f39e17c70bfb" translate="yes" xml:space="preserve">
          <source>Here is a RECT structure which contains two POINTs named &lt;em&gt;upperleft&lt;/em&gt; and &lt;em&gt;lowerright&lt;/em&gt;:</source>
          <target state="translated">다음은 &lt;em&gt;topleft&lt;/em&gt; 와 &lt;em&gt;lowerright&lt;/em&gt; 라는 두 개의 POINT를 포함하는 RECT 구조입니다 .</target>
        </trans-unit>
        <trans-unit id="b11c4199d90d38db06d33ee228fd632c8e05e0b6" translate="yes" xml:space="preserve">
          <source>Here is a basic echo server that uses the &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;dispatcher&lt;/code&gt;&lt;/a&gt; class to accept connections and dispatches the incoming connections to a handler:</source>
          <target state="translated">다음은 &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;dispatcher&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 연결을 수락하고 수신 연결을 핸들러로 디스패치 하는 기본 에코 서버입니다 .</target>
        </trans-unit>
        <trans-unit id="89e92dab799df20513ba190ff69a355bbb907809" translate="yes" xml:space="preserve">
          <source>Here is a comprehensive example presenting how persistent ID can be used to pickle external objects by reference.</source>
          <target state="translated">다음은 퍼시 스턴트 ID를 사용하여 외부 객체를 참조하여 피클 링하는 방법을 보여주는 포괄적 인 예입니다.</target>
        </trans-unit>
        <trans-unit id="aedf046734d92d5ea82f1b03a1f6ccdaf708f3e6" translate="yes" xml:space="preserve">
          <source>Here is a minimal example (without error checking) that opens a mailbox and retrieves and prints all messages:</source>
          <target state="translated">다음은 우편함을 열고 모든 메시지를 검색하고 인쇄하는 최소한의 예 (오류 검사 없음)입니다.</target>
        </trans-unit>
        <trans-unit id="858763321472e2f89573939e2e2b2ebbc0e0b92e" translate="yes" xml:space="preserve">
          <source>Here is a minimal example program. It uses the &lt;a href=&quot;#signal.alarm&quot;&gt;&lt;code&gt;alarm()&lt;/code&gt;&lt;/a&gt; function to limit the time spent waiting to open a file; this is useful if the file is for a serial device that may not be turned on, which would normally cause the &lt;a href=&quot;os#os.open&quot;&gt;&lt;code&gt;os.open()&lt;/code&gt;&lt;/a&gt; to hang indefinitely. The solution is to set a 5-second alarm before opening the file; if the operation takes too long, the alarm signal will be sent, and the handler raises an exception.</source>
          <target state="translated">다음은 최소한의 예제 프로그램입니다. &lt;a href=&quot;#signal.alarm&quot;&gt; &lt;code&gt;alarm()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 파일을 열기 위해 대기하는 시간을 제한합니다. 이것은 파일이 켜져 있지 않을 수있는 직렬 장치 용 파일 인 경우에 유용하며, 일반적으로 &lt;a href=&quot;os#os.open&quot;&gt; &lt;code&gt;os.open()&lt;/code&gt; &lt;/a&gt; 이 무기한 정지됩니다. 해결책은 파일을 열기 전에 5 초 알람을 설정하는 것입니다. 작업이 너무 오래 걸리면 알람 신호가 전송되고 핸들러가 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="4b5a1b75d30a7b9670ad29284b16f1578dc79c1c" translate="yes" xml:space="preserve">
          <source>Here is a more advanced example, it uses the &lt;code&gt;strchr&lt;/code&gt; function, which expects a string pointer and a char, and returns a pointer to a string:</source>
          <target state="translated">다음은보다 고급적인 예입니다. &lt;code&gt;strchr&lt;/code&gt; 함수를 사용 하여 문자열 포인터와 문자를 예상하고 문자열에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95cef5f0126a27e10141faf5133f1bcbbd2d52f4" translate="yes" xml:space="preserve">
          <source>Here is a sample session with the turtle shell showing the help functions, using blank lines to repeat commands, and the simple record and playback facility:</source>
          <target state="translated">다음은 도움말 기능을 보여주는 거북이 셸과 빈 줄을 사용하여 명령을 반복하는 간단한 세션과 간단한 레코드 및 재생 기능입니다.</target>
        </trans-unit>
        <trans-unit id="5ea82f3080f5f08a1cf6ae1393c3531d56e8c858" translate="yes" xml:space="preserve">
          <source>Here is a short script to test three string methods:</source>
          <target state="translated">다음은 세 가지 문자열 메서드를 테스트하는 간단한 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="c1d0b87a033dc901ab5b05a6a511ade5fd204b7c" translate="yes" xml:space="preserve">
          <source>Here is a simple echo server implementation:</source>
          <target state="translated">간단한 에코 서버 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="783c88dec80dbc359cd0a54cb73ef2e8956c06df" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a POINT structure, which contains two integers named &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt;, and also shows how to initialize a structure in the constructor:</source>
          <target state="translated">다음은 POINT 구조의 간단한 예입니다. 여기에는 &lt;em&gt;x&lt;/em&gt; 및 &lt;em&gt;y&lt;/em&gt; 라는 두 개의 정수가 포함 되며 생성자에서 구조를 초기화하는 방법도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a220f7a767cad9812c7f5e9e71729724691d793a" translate="yes" xml:space="preserve">
          <source>Here is a simple example where we allow pickling and reconstructing a given class:</source>
          <target state="translated">다음은 주어진 클래스를 피클 링하고 재구성 할 수있는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="66492cba692800cf02c93560d0a4ae5260cd7a45" translate="yes" xml:space="preserve">
          <source>Here is a simplified example of using the &lt;code&gt;subdirs&lt;/code&gt; attribute to search recursively through two directories to show common different files:</source>
          <target state="translated">다음은 &lt;code&gt;subdirs&lt;/code&gt; 속성을 사용하여 공통된 다른 파일을 표시하기 위해 두 디렉토리를 반복적으로 검색 하는 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1a1651c42d3d327851c93c93b01b9268244b9102" translate="yes" xml:space="preserve">
          <source>Here is a trivial example where we implement a &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; subclass able to participate in out-of-band buffer pickling:</source>
          <target state="translated">다음은 대역 외 버퍼 산세에 참여할 수 있는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 하위 클래스를 구현하는 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4083b0132c7f289dc2cfe594fe0062d0a2928f45" translate="yes" xml:space="preserve">
          <source>Here is a very basic HTTP client that uses the &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;dispatcher&lt;/code&gt;&lt;/a&gt; class to implement its socket handling:</source>
          <target state="translated">다음은 &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;dispatcher&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 소켓 처리를 구현 하는 매우 기본적인 HTTP 클라이언트입니다 .</target>
        </trans-unit>
        <trans-unit id="9681060e036ebeaa6ecc1812f0a2f746613da2c5" translate="yes" xml:space="preserve">
          <source>Here is an XML example that incorporates two namespaces, one with the prefix &amp;ldquo;fictional&amp;rdquo; and the other serving as the default namespace:</source>
          <target state="translated">다음은 두 개의 네임 스페이스 (하나는 접두사 &quot;fictional&quot;이 있고 다른 네임 스페이스는 기본 네임 스페이스로 사용됨)를 통합 한 XML 예제입니다.</target>
        </trans-unit>
        <trans-unit id="0137522adaa7f5c187c163e2786035a7e02c8078" translate="yes" xml:space="preserve">
          <source>Here is an example how &lt;code&gt;HTMLCalendar&lt;/code&gt; can be customized:</source>
          <target state="translated">다음은 &lt;code&gt;HTMLCalendar&lt;/code&gt; 를 사용자 정의 할 수있는 방법의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="bcefb4d49c909a6b98daaf5656641cc671df0062" translate="yes" xml:space="preserve">
          <source>Here is an example of a TCP echo client written using asyncio streams:</source>
          <target state="translated">다음은 asyncio 스트림을 사용하여 작성된 TCP 에코 클라이언트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="926e62c32ff349304967e48a181cbc5cd0a5da18" translate="yes" xml:space="preserve">
          <source>Here is an example of a somewhat artificial data type, a structure containing 4 POINTs among other stuff:</source>
          <target state="translated">다음은 다소 인공적인 데이터 유형의 예이며 다른 것들 중에서 4 개의 포인트를 포함하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="1942a35fca33fb69eb410e653fed29f38ff15dac" translate="yes" xml:space="preserve">
          <source>Here is an example of an unpickler allowing only few safe classes from the &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; module to be loaded:</source>
          <target state="translated">다음은 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 모듈 에서 몇 개의 안전한 클래스 만 로드 할 수있는 언 피커의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1f6e174ce0930d3a688e6d301ba445e413a2bbb8" translate="yes" xml:space="preserve">
          <source>Here is an example of doing a &lt;code&gt;PUT&lt;/code&gt; request using &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 일 예이다 &lt;code&gt;PUT&lt;/code&gt; 의 사용 요청 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="63ad9e85ec02c74d345d067024e9c8bf8c414e3c" translate="yes" xml:space="preserve">
          <source>Here is an example of how to use a Template:</source>
          <target state="translated">템플릿을 사용하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1f9b5f62c8ca8b8cc7088a5760fdc9620a09236" translate="yes" xml:space="preserve">
          <source>Here is an example of how you would catch one of these exceptions:</source>
          <target state="translated">다음은 이러한 예외 중 하나를 잡는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="cdea6c32a97f82e690ca75ac4f0f1c74eb11d810" translate="yes" xml:space="preserve">
          <source>Here is an example session that shows how to &lt;code&gt;POST&lt;/code&gt; requests:</source>
          <target state="translated">다음은 요청 을 &lt;code&gt;POST&lt;/code&gt; 하는 방법을 보여주는 예제 세션입니다 .</target>
        </trans-unit>
        <trans-unit id="b4e1b4a71bce105f36f4683385341397898087cc" translate="yes" xml:space="preserve">
          <source>Here is an example session that uses the &lt;code&gt;GET&lt;/code&gt; method to retrieve a URL containing parameters:</source>
          <target state="translated">다음은 &lt;code&gt;GET&lt;/code&gt; 메소드를 사용하여 매개 변수가 포함 된 URL을 검색하는 세션 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f87b25be67df6c09e308fe796ffe42b228c4a0f4" translate="yes" xml:space="preserve">
          <source>Here is an example session that uses the &lt;code&gt;GET&lt;/code&gt; method:</source>
          <target state="translated">다음은 &lt;code&gt;GET&lt;/code&gt; 메소드 를 사용하는 예제 세션입니다 .</target>
        </trans-unit>
        <trans-unit id="f01802ba30e14aa2f7ef06fd05eb038cefe62ea7" translate="yes" xml:space="preserve">
          <source>Here is an example session that uses the &lt;code&gt;HEAD&lt;/code&gt; method. Note that the &lt;code&gt;HEAD&lt;/code&gt; method never returns any data.</source>
          <target state="translated">다음은 &lt;code&gt;HEAD&lt;/code&gt; 메소드 를 사용하는 예제 세션입니다 . 있습니다 &lt;code&gt;HEAD&lt;/code&gt; 의 방법은 데이터를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7637c0fb791cb33301b7c50ec5939de2528983d7" translate="yes" xml:space="preserve">
          <source>Here is an example that imports a module from a ZIP archive - note that the &lt;a href=&quot;#module-zipimport&quot;&gt;&lt;code&gt;zipimport&lt;/code&gt;&lt;/a&gt; module is not explicitly used.</source>
          <target state="translated">다음은 ZIP 아카이브에서 모듈을 가져 오는 예입니다. &lt;a href=&quot;#module-zipimport&quot;&gt; &lt;code&gt;zipimport&lt;/code&gt; &lt;/a&gt; 모듈은 명시 적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63b8653a775ca02f4de9cf85a3ea50f01399ce67" translate="yes" xml:space="preserve">
          <source>Here is an example transformer that rewrites all occurrences of name lookups (&lt;code&gt;foo&lt;/code&gt;) to &lt;code&gt;data['foo']&lt;/code&gt;:</source>
          <target state="translated">다음은 모든 이름 조회 ( &lt;code&gt;foo&lt;/code&gt; )를 &lt;code&gt;data['foo']&lt;/code&gt; 에 다시 쓰는 변환기의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4c22ac49a0c9c7336e5edbfbe2e372032dc66845" translate="yes" xml:space="preserve">
          <source>Here is an example type (Windows):</source>
          <target state="translated">다음은 예제 유형입니다 (Windows).</target>
        </trans-unit>
        <trans-unit id="0e4f971444f1d77e09759bbb6d4eb09fd55bc2d3" translate="yes" xml:space="preserve">
          <source>Here is an example with a non-byte format:</source>
          <target state="translated">다음은 바이트가 아닌 형식의 예입니다.</target>
        </trans-unit>
        <trans-unit id="3222c631b1d6a91645cefd87ad0f0babb9291a43" translate="yes" xml:space="preserve">
          <source>Here is an example, a format for dates compatible with that specified in the &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; Internet email standard. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">다음은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 인터넷 이메일 표준에 지정된 형식과 호환되는 날짜 형식의 예 입니다. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e1dafbc069fa301268390cf627b3ca5c064c24e" translate="yes" xml:space="preserve">
          <source>Here is how the above snippet can be fixed:</source>
          <target state="translated">위의 스 니펫을 수정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0193f048235ff1d1526f09d38ae6b2bf5b52e26a" translate="yes" xml:space="preserve">
          <source>Here is one way you can handle this situation:</source>
          <target state="translated">이 상황을 처리 할 수있는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbb8b723b6c194f091fb87df1d26aab4a18efa52" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; class description:</source>
          <target state="translated">다음은 &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 클래스 설명입니다.</target>
        </trans-unit>
        <trans-unit id="43a4df7c9db3f85bfab609815a30ff46e6d1db35" translate="yes" xml:space="preserve">
          <source>Here is the API for the &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; &lt;/a&gt; 의 API는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="312593d370700c530b8c77ba64f5bf70d0d4e0d1" translate="yes" xml:space="preserve">
          <source>Here is the list of handlers that can be set. To set a handler on an &lt;code&gt;xmlparser&lt;/code&gt; object &lt;em&gt;o&lt;/em&gt;, use &lt;code&gt;o.handlername = func&lt;/code&gt;. &lt;em&gt;handlername&lt;/em&gt; must be taken from the following list, and &lt;em&gt;func&lt;/em&gt; must be a callable object accepting the correct number of arguments. The arguments are all strings, unless otherwise stated.</source>
          <target state="translated">설정할 수있는 핸들러 목록은 다음과 같습니다. &lt;code&gt;xmlparser&lt;/code&gt; 객체 &lt;em&gt;o&lt;/em&gt; 에 핸들러를 설정하려면 &lt;code&gt;o.handlername = func&lt;/code&gt; 사용 하십시오 . &lt;em&gt;handlername&lt;/em&gt; 은 다음 목록에서 &lt;em&gt;가져와야&lt;/em&gt; 하며 &lt;em&gt;func&lt;/em&gt; 는 올바른 수의 인수를 허용하는 호출 가능한 객체 여야합니다. 달리 명시되지 않는 한 인수는 모두 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="44f421add6ba0457382d5aadb027259940af6a3d" translate="yes" xml:space="preserve">
          <source>Here is the list of the defects that the &lt;a href=&quot;email.parser#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; can find while parsing messages. Note that the defects are added to the message where the problem was found, so for example, if a message nested inside a &lt;em&gt;multipart/alternative&lt;/em&gt; had a malformed header, that nested message object would have a defect, but the containing messages would not.</source>
          <target state="translated">다음은 메시지를 구문 분석하는 동안 &lt;a href=&quot;email.parser#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt; 가 찾을 수 있는 결함 목록입니다 . 결함이 문제가 발견 된 메시지에 추가되므로, 예를 들어 &lt;em&gt;멀티 파트 / 대체&lt;/em&gt; 내부에 중첩 된 메시지에 잘못된 헤더가있는 경우 해당 중첩 메시지 개체에 결함이 있지만 포함 메시지는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d14bc3f810050260ad93db46eca920d45cd6587" translate="yes" xml:space="preserve">
          <source>Here is the wrapping with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; 를&lt;/a&gt; 사용한 래핑은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d8d136ce4fcf131b38249ad4b4cdd7b36aab6b59" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;message&lt;/code&gt; parts are not &lt;code&gt;multiparts&lt;/code&gt;, but they do contain subparts. &lt;code&gt;is_multipart()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;walk&lt;/code&gt; descends into the subparts.</source>
          <target state="translated">여기서 &lt;code&gt;message&lt;/code&gt; 부분은 &lt;code&gt;multiparts&lt;/code&gt; 가 아니지만 하위 부분을 포함합니다. &lt;code&gt;is_multipart()&lt;/code&gt; 반환 &lt;code&gt;True&lt;/code&gt; 과 &lt;code&gt;walk&lt;/code&gt; 하위 부분으로 하강합니다.</target>
        </trans-unit>
        <trans-unit id="f8c5b2d5d4895e63936c3e39f9ea5a092742e33a" translate="yes" xml:space="preserve">
          <source>Here the fields, accessed through &lt;code&gt;form[key]&lt;/code&gt;, are themselves instances of &lt;code&gt;FieldStorage&lt;/code&gt; (or &lt;code&gt;MiniFieldStorage&lt;/code&gt;, depending on the form encoding). The &lt;code&gt;value&lt;/code&gt; attribute of the instance yields the string value of the field. The &lt;code&gt;getvalue()&lt;/code&gt; method returns this string value directly; it also accepts an optional second argument as a default to return if the requested key is not present.</source>
          <target state="translated">여기서 &lt;code&gt;form[key]&lt;/code&gt; 통해 액세스되는 필드는 필드 &lt;code&gt;FieldStorage&lt;/code&gt; (또는 양식 인코딩에 따라 &lt;code&gt;MiniFieldStorage&lt;/code&gt; )의 인스턴스입니다 . 인스턴스 의 &lt;code&gt;value&lt;/code&gt; 속성은 필드의 문자열 값을 산출합니다. &lt;code&gt;getvalue()&lt;/code&gt; 메소드는 직접 문자열 값을 반환 또한 요청 된 키가없는 경우 리턴하는 선택적 두 번째 인수를 기본값으로 채택합니다.</target>
        </trans-unit>
        <trans-unit id="6427d6dc542f2fe91c5f973e0fbee08e0775e6b1" translate="yes" xml:space="preserve">
          <source>Here we are telling &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt; to use the RFC correct line separator characters when creating the binary string to feed into &lt;code&gt;sendmail's&lt;/code&gt;&lt;code&gt;stdin&lt;/code&gt;, where the default policy would use &lt;code&gt;\n&lt;/code&gt; line separators.</source>
          <target state="translated">여기서는 &lt;code&gt;sendmail's&lt;/code&gt; &lt;code&gt;stdin&lt;/code&gt; 에 공급할 이진 문자열을 만들 때 기본 정책이 &lt;code&gt;\n&lt;/code&gt; 행 구분 기호 를 사용하는 경우 RFC 올바른 행 구분 기호 문자를 사용하도록 &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; 에&lt;/a&gt; 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="54089b0f798d064b6d27440468c160d6be3d5a87" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a complete but small example module:</source>
          <target state="translated">다음은 완전하지만 작은 예제 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="deb069a2481d34b576a644f623c5cdd014912641" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a function that prompts for a password with echoing turned off. Note the technique using a separate &lt;a href=&quot;#termios.tcgetattr&quot;&gt;&lt;code&gt;tcgetattr()&lt;/code&gt;&lt;/a&gt; call and a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; statement to ensure that the old tty attributes are restored exactly no matter what happens:</source>
          <target state="translated">다음은 에코가 해제 된 암호를 묻는 기능입니다. 별도의 &lt;a href=&quot;#termios.tcgetattr&quot;&gt; &lt;code&gt;tcgetattr()&lt;/code&gt; &lt;/a&gt; 호출과 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 문을 사용하여 이전 tty 속성이 어떻게 되든 정확하게 복원되도록하는 기술에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="6674d68cc38ec668a73b9a90f473982a8cb3962a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a sample session using the &lt;a href=&quot;#ftplib.FTP_TLS&quot;&gt;&lt;code&gt;FTP_TLS&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">&lt;a href=&quot;#ftplib.FTP_TLS&quot;&gt; &lt;code&gt;FTP_TLS&lt;/code&gt; &lt;/a&gt; 클래스를 사용한 샘플 세션은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b965a2500a417c17e252df58aa948ceb534c9ecf" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a sample session using the &lt;a href=&quot;#module-ftplib&quot;&gt;&lt;code&gt;ftplib&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-ftplib&quot;&gt; &lt;code&gt;ftplib&lt;/code&gt; &lt;/a&gt; 모듈을 사용한 샘플 세션은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f08d50bf7a9f9628e3dfc06b109485deda2e28cc" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a shorter example using a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; 를 사용하는 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="9dda69001f51d32dcd158718121626161a3763b1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a table showing which versions in a client (down the side) can connect to which versions in a server (along the top):</source>
          <target state="translated">다음은 클라이언트의 어떤 버전 (아래쪽)이 서버의 어떤 버전 (위쪽)에 연결할 수 있는지 보여주는 표입니다.</target>
        </trans-unit>
        <trans-unit id="96026c277ce40c4cdd39c60d4a2b06b7e1e42842" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of both styles:</source>
          <target state="translated">다음은 두 스타일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="2e7bb34249467c365c51e5881f607b0336fcd6fe" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of computing an inverse for &lt;code&gt;38&lt;/code&gt; modulo &lt;code&gt;97&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;38&lt;/code&gt; 모듈로 &lt;code&gt;97&lt;/code&gt; 에 대한 역수를 계산하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="76246c5edc6c07c691c2ccc2d065398990a99ecd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of doing this for a context manager that accepts resource acquisition and release functions, along with an optional validation function, and maps them to the context management protocol:</source>
          <target state="translated">다음은 선택적 유효성 검증 기능과 함께 자원 확보 및 릴리스 기능을 승인하고이를 컨텍스트 관리 프로토콜에 맵핑하는 컨텍스트 관리자에 대해이를 수행하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="6972a9388d5a46c9aaecbb359917ffc8f7f4389d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of hashing a minimal tree with two leaf nodes:</source>
          <target state="translated">다음은 두 개의 리프 노드로 최소 트리를 해싱하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="70402f4d7b8b4f0408298cad94624fc0f6c8e0e1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how asyncio can run a shell command and obtain its result:</source>
          <target state="translated">다음은 asyncio가 셸 명령을 실행하고 결과를 얻는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="86ceb4f04a6903fd4ae47ac5dd9b2e83e0478d72" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to create an HTML message with an alternative plain text version. To make things a bit more interesting, we include a related image in the html part, and we save a copy of what we are going to send to disk, as well as sending it.</source>
          <target state="translated">다음은 대체 일반 텍스트 버전으로 HTML 메시지를 작성하는 방법의 예입니다. 좀 더 재미있게하기 위해, html 부분에 관련 이미지를 포함시키고, 디스크로 보낼 것의 사본을 보내거나 보낼 것입니다.</target>
        </trans-unit>
        <trans-unit id="10477766db4d4994ddeccf936edb955ea8a8956e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to send a MIME message containing a bunch of family pictures that may be residing in a directory:</source>
          <target state="translated">다음은 디렉토리에있을 수있는 가족 사진을 포함하는 MIME 메시지를 보내는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="66824fe559b5fa4e6945d482d0b46be90bee75d5" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to send the entire contents of a directory as an email message: &lt;a href=&quot;#id3&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">다음은 디렉토리의 전체 내용을 전자 메일 메시지로 보내는 방법의 예입니다. &lt;a href=&quot;#id3&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa965e6e6082f3cdbd60fcddb869e401f5052f16" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to unpack a MIME message like the one above, into a directory of files:</source>
          <target state="translated">다음은 위와 같은 MIME 메시지를 파일 디렉토리에 압축 해제하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="ffbb9d384a13892dc11f3dbd35da43e2b51be8b9" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how you might use &lt;a href=&quot;#email.message_from_bytes&quot;&gt;&lt;code&gt;message_from_bytes()&lt;/code&gt;&lt;/a&gt; at an interactive Python prompt:</source>
          <target state="translated">다음 은 대화식 Python 프롬프트에서 &lt;a href=&quot;#email.message_from_bytes&quot;&gt; &lt;code&gt;message_from_bytes()&lt;/code&gt; &lt;/a&gt; 를 사용하는 방법에 대한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8cf6f62163178581796424c7a9a02f1f7e9fb2fa" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of it in use:</source>
          <target state="translated">사용중인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bdb2cef4a98e2dcf73f5700dd318281ea7481bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of typical usage for this API:</source>
          <target state="translated">이 API의 일반적인 사용법 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9713683791f9c6f99a0e91da9917c7974bb232d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that demonstrates some of the XPath capabilities of the module. We&amp;rsquo;ll be using the &lt;code&gt;countrydata&lt;/code&gt; XML document from the &lt;a href=&quot;#elementtree-parsing-xml&quot;&gt;Parsing XML&lt;/a&gt; section:</source>
          <target state="translated">다음은 모듈의 XPath 기능 중 일부를 보여주는 예입니다. &lt;a href=&quot;#elementtree-parsing-xml&quot;&gt;파싱 ​​XML&lt;/a&gt; 섹션 에서 &lt;code&gt;countrydata&lt;/code&gt; XML 문서를 사용할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="cb47414132a1661346f2cf123a39f4ccf00798b7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that demonstrates use of the XInclude module. To include an XML document in the current document, use the &lt;code&gt;{http://www.w3.org/2001/XInclude}include&lt;/code&gt; element and set the &lt;strong&gt;parse&lt;/strong&gt; attribute to &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, and use the &lt;strong&gt;href&lt;/strong&gt; attribute to specify the document to include.</source>
          <target state="translated">다음은 XInclude 모듈 사용을 보여주는 예입니다. 현재 문서에 XML 문서를 포함 시키려면 &lt;code&gt;{http://www.w3.org/2001/XInclude}include&lt;/code&gt; 요소를 사용하고 &lt;strong&gt;구문 분석&lt;/strong&gt; 속성을 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; 로 설정 하고 &lt;strong&gt;href&lt;/strong&gt; 속성을 사용하여 포함 할 문서를 지정하십시오. .</target>
        </trans-unit>
        <trans-unit id="709f58d0a032f4f2fd538e028e1bf2d5bba72072" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that prints the MIME type of every part of a multipart message structure:</source>
          <target state="translated">다음은 멀티 파트 메시지 구조의 모든 부분에 대한 MIME 유형을 인쇄하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="706b810952f86acc8d676e08674be3f570661c4c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that shows how to modify pickling behavior for a class. The &lt;code&gt;TextReader&lt;/code&gt; class opens a text file, and returns the line number and line contents each time its &lt;code&gt;readline()&lt;/code&gt; method is called. If a &lt;code&gt;TextReader&lt;/code&gt; instance is pickled, all attributes &lt;em&gt;except&lt;/em&gt; the file object member are saved. When the instance is unpickled, the file is reopened, and reading resumes from the last location. The &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#object.__getstate__&quot;&gt;&lt;code&gt;__getstate__()&lt;/code&gt;&lt;/a&gt; methods are used to implement this behavior.</source>
          <target state="translated">다음은 클래스의 피클 링 동작을 수정하는 방법을 보여주는 예입니다. &lt;code&gt;TextReader&lt;/code&gt; 를의 클래스는 텍스트 파일을 열고, 행 번호와 라인 내용의 때마다 반환 &lt;code&gt;readline()&lt;/code&gt; 메소드가 호출된다. 경우 &lt;code&gt;TextReader&lt;/code&gt; 를의 인스턴스가 절인되어, 모든 속성 &lt;em&gt;을 제외한&lt;/em&gt; 파일 객체 멤버는 저장됩니다. 인스턴스가 피클 링되지 않으면 파일이 다시 열리고 마지막 위치부터 다시 시작됩니다. &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#object.__getstate__&quot;&gt; &lt;code&gt;__getstate__()&lt;/code&gt; &lt;/a&gt; 방법이 동작을 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8109b877000b870b322f3f396b556ca2e7627e4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the same example as before, but considering blanks to be junk. That prevents &lt;code&gt;' abcd'&lt;/code&gt; from matching the &lt;code&gt;' abcd'&lt;/code&gt; at the tail end of the second sequence directly. Instead only the &lt;code&gt;'abcd'&lt;/code&gt; can match, and matches the leftmost &lt;code&gt;'abcd'&lt;/code&gt; in the second sequence:</source>
          <target state="translated">이전과 같은 예이지만 공백을 정크로 간주합니다. 그러면 &lt;code&gt;' abcd'&lt;/code&gt; 가 두 번째 시퀀스의 꼬리 끝에서 &lt;code&gt;' abcd'&lt;/code&gt; 와 직접 일치 하지 않습니다 . 대신 &lt;code&gt;'abcd'&lt;/code&gt; 만 일치 하고 두 번째 시퀀스에서 가장 왼쪽의 &lt;code&gt;'abcd'&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="4db73af24839df174d254d19165dc6b71cd36feb" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;spam.ham&lt;/code&gt; module is returned from &lt;a href=&quot;#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt;. From this object, the names to import are retrieved and assigned to their respective names.</source>
          <target state="translated">여기서 &lt;code&gt;spam.ham&lt;/code&gt; 모듈은 &lt;a href=&quot;#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 에서 반환됩니다 . 이 객체에서 가져올 이름을 검색하여 해당 이름으로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="29017850c0ee8b88df141fa0569f666bcbc4fbcf" translate="yes" xml:space="preserve">
          <source>Here, you want to mark the strings in the &lt;code&gt;animals&lt;/code&gt; list as being translatable, but you don&amp;rsquo;t actually want to translate them until they are printed.</source>
          <target state="translated">여기서 &lt;code&gt;animals&lt;/code&gt; 목록 의 문자열을 번역 가능한 것으로 표시하고 싶지만 실제로 인쇄 될 때까지 번역하고 싶지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a472603c4793ba32a26895360ca1c167352b47b" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9.</source>
          <target state="translated">16 진수 형식. 9보다 큰 숫자에 소문자를 사용하여 16 진수로 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6dae4fd41d115d12c3ce48b5466486b2c13fb380" translate="yes" xml:space="preserve">
          <source>Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9.</source>
          <target state="translated">16 진수 형식. 9보다 큰 자릿수에 대문자를 사용하여 16 진수로 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6ab8e16a9942b4cc932e601bc438522c8cc2f9ab" translate="yes" xml:space="preserve">
          <source>Hide the panel. This does not delete the object, it just makes the window on screen invisible.</source>
          <target state="translated">패널을 숨 깁니다. 개체를 삭제하지 않고 화면의 창을 보이지 않게합니다.</target>
        </trans-unit>
        <trans-unit id="975b00c7afb7ab7c68c7138afb2f613f421d8011" translate="yes" xml:space="preserve">
          <source>Hides the tab specified by &lt;em&gt;tab_id&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;tab_id로&lt;/em&gt; 지정된 탭을 숨 깁니다 .</target>
        </trans-unit>
        <trans-unit id="fc588738c60ecb4b4a8aba29ccba016b1c955025" translate="yes" xml:space="preserve">
          <source>Hides the window. Another window will be activated.</source>
          <target state="translated">창을 숨 깁니다. 다른 창이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e16da0d6095b36a564a8943ec4d9d0b7f4859225" translate="yes" xml:space="preserve">
          <source>Hierarchical ListBox</source>
          <target state="translated">계층리스트 박스</target>
        </trans-unit>
        <trans-unit id="d3d148e78aea31488c9234ddf73cf485b8c09186" translate="yes" xml:space="preserve">
          <source>Hierarchical path</source>
          <target state="translated">계층 적 경로</target>
        </trans-unit>
        <trans-unit id="5d60881335567c9090b8c4245ea4e81ecb33da15" translate="yes" xml:space="preserve">
          <source>High median of data.</source>
          <target state="translated">데이터의 중간 값이 높습니다.</target>
        </trans-unit>
        <trans-unit id="6282a11a5eca3c9a65529cea745db1d70b87d28f" translate="yes" xml:space="preserve">
          <source>High priority read/write. Allows block-based filesystems to use polling of the device, which provides lower latency, but may use additional resources.</source>
          <target state="translated">우선 순위가 높은 읽기 / 쓰기. 블록 기반 파일 시스템이 장치의 폴링을 사용하도록 허용하므로 대기 시간은 단축되지만 추가 리소스가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a87a2489640795cc234e71d98784b569f68d6c1" translate="yes" xml:space="preserve">
          <source>High-level API Index</source>
          <target state="translated">고급 API 색인</target>
        </trans-unit>
        <trans-unit id="3a945e4de6304d6bdbf4f30080b6be3140c870fe" translate="yes" xml:space="preserve">
          <source>High-level APIs</source>
          <target state="translated">고급 API</target>
        </trans-unit>
        <trans-unit id="418113d56ae3ac7d324cf436937deab0a3a252fe" translate="yes" xml:space="preserve">
          <source>High-level APIs to work with network IO.</source>
          <target state="translated">네트워크 IO와 작동하는 고급 API.</target>
        </trans-unit>
        <trans-unit id="b70e4a5c864a275c250115363446ef5404321ea2" translate="yes" xml:space="preserve">
          <source>High-level Module Interface</source>
          <target state="translated">고급 모듈 인터페이스</target>
        </trans-unit>
        <trans-unit id="7654a4bda6a850b2d646ed42a943709375af4e66" translate="yes" xml:space="preserve">
          <source>High-level async/await object to receive network data.</source>
          <target state="translated">네트워크 데이터를 수신하기위한 높은 수준의 비동기 / 대기 객체.</target>
        </trans-unit>
        <trans-unit id="4062c19052bd6f8e57b9924a18dbaadbde67c050" translate="yes" xml:space="preserve">
          <source>High-level async/await object to send network data.</source>
          <target state="translated">네트워크 데이터를 보내기위한 높은 수준의 비동기 / 대기 객체.</target>
        </trans-unit>
        <trans-unit id="2311abfb64cb296285cf9c7ba19e1fc3798a93fa" translate="yes" xml:space="preserve">
          <source>High-level utilities to create and read compressed and archived files are also provided. They rely on the &lt;a href=&quot;zipfile#module-zipfile&quot;&gt;&lt;code&gt;zipfile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;tarfile#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">압축 및 아카이브 된 파일을 작성하고 읽는 고급 유틸리티도 제공됩니다. 그들은 &lt;a href=&quot;zipfile#module-zipfile&quot;&gt; &lt;code&gt;zipfile&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;tarfile#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="56deb8932e61f797ed677a061b4f0f80922f76d6" translate="yes" xml:space="preserve">
          <source>High-performance serialization of built-in types.</source>
          <target state="translated">내장 유형의 고성능 직렬화.</target>
        </trans-unit>
        <trans-unit id="dfb97476260bc6e078c0bc5f5b524817d1b955cb" translate="yes" xml:space="preserve">
          <source>High-resolution per-process timer from the CPU.</source>
          <target state="translated">CPU의 고해상도 프로세스 별 타이머.</target>
        </trans-unit>
        <trans-unit id="ad402f6ce49e651e75ee74d257e55d8a8d2867a5" translate="yes" xml:space="preserve">
          <source>Higher Level Interface</source>
          <target state="translated">높은 수준의 인터페이스</target>
        </trans-unit>
        <trans-unit id="137f307b8ef5696b386b347dfd64aebeeefd159a" translate="yes" xml:space="preserve">
          <source>Higher-level operations on pathnames are defined in the &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">경로 이름에 대한 상위 레벨 조작은 &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 모듈에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3771c52715fb43b3e757ae1a3d984d3cda0f28a9" translate="yes" xml:space="preserve">
          <source>Highlight the surrounding parenthesis.</source>
          <target state="translated">주변 괄호를 강조 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="fabedad26856d16459739a389abdcea783e78b9b" translate="yes" xml:space="preserve">
          <source>Hilbert &amp;amp; Koch curves</source>
          <target state="translated">힐버트 앤 코흐 곡선</target>
        </trans-unit>
        <trans-unit id="540c634e3749d6c586b2a2f144b6702b6d534584" translate="yes" xml:space="preserve">
          <source>Hint: if you want to specify default values for a specific section, use &lt;code&gt;read_dict()&lt;/code&gt; before you read the actual file.</source>
          <target state="translated">힌트 : 특정 섹션에 기본값을 지정 하려면 실제 파일을 읽기 전에 &lt;code&gt;read_dict()&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="3d1f110ffacfcfd0164c3693450d07c42f1a288c" translate="yes" xml:space="preserve">
          <source>Hints: dynamic execution of statements is supported by the &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; functions returns the current global and local dictionary, respectively, which may be useful to pass around for use by &lt;a href=&quot;#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">힌트 : 명령문의 동적 실행은 &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 함수에 의해 지원됩니다 . &lt;a href=&quot;#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 함수에 의해 리턴 사용 주위 통과하는 것이 유용 할 수는 각각 현재의 글로벌 및 로컬 사전, &lt;a href=&quot;#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="977f72f33fd0f7ecd2f6fdfcaed6ab6f202170b2" translate="yes" xml:space="preserve">
          <source>History file</source>
          <target state="translated">히스토리 파일</target>
        </trans-unit>
        <trans-unit id="b0479c60429c78f9c90b30067d18270acd2fcd91" translate="yes" xml:space="preserve">
          <source>History list</source>
          <target state="translated">히스토리리스트</target>
        </trans-unit>
        <trans-unit id="b4e97ef75c73cb49dbe471f2a8fc87f85f477bfa" translate="yes" xml:space="preserve">
          <source>Hm. We certainly expected the last statement to print &lt;code&gt;3 4 1 2&lt;/code&gt;. What happened? Here are the steps of the &lt;code&gt;rc.a, rc.b = rc.b, rc.a&lt;/code&gt; line above:</source>
          <target state="translated">흠. 우리는 마지막 진술이 &lt;code&gt;3 4 1 2&lt;/code&gt; 를 인쇄 할 것으로 예상했다 . 어떻게 된 거예요? 위의 &lt;code&gt;rc.a, rc.b = rc.b, rc.a&lt;/code&gt; 행 의 단계는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="84380fa08840c12769a5e603533d5049bf656770" translate="yes" xml:space="preserve">
          <source>Holds a list of strings containing the addresses identified in the &amp;ldquo;RCPT TO:&amp;rdquo; lines from the client.</source>
          <target state="translated">클라이언트에서 &quot;RCPT TO :&quot;행에 식별 된 주소가 포함 된 문자열 목록을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="b1594c5d044abc97b4f02f7439bee39849e8d91b" translate="yes" xml:space="preserve">
          <source>Holds a list of the line strings (decoded using UTF-8) received from the client. The lines have their &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; line ending translated to &lt;code&gt;&quot;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">클라이언트로부터 수신 한 행 문자열 (UTF-8을 사용하여 디코딩 된) 목록을 보유합니다. 행의 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 행은 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="756edd3ad364172179fc4bd28c47aba2e28ee462" translate="yes" xml:space="preserve">
          <source>Holds a string containing all of the data sent by the client during the DATA state, up to but not including the terminating &lt;code&gt;&quot;\r\n.\r\n&quot;&lt;/code&gt;.</source>
          <target state="translated">DATA 상태 동안 클라이언트가 보낸 모든 데이터를 포함하는 문자열을 보유합니다. 종료하는 &lt;code&gt;&quot;\r\n.\r\n&quot;&lt;/code&gt; 까지는 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="173c57b2edd8e26c070f7e3dc3845383b5f7e22f" translate="yes" xml:space="preserve">
          <source>Holds a string containing the address identified in the &amp;ldquo;MAIL FROM:&amp;rdquo; line from the client.</source>
          <target state="translated">클라이언트의 &quot;MAIL FROM :&quot;행에 식별 된 주소가 포함 된 문자열을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="3e97286c991e6ccb42a2a1d0c99c5d6bbf6ae803" translate="yes" xml:space="preserve">
          <source>Holds a string containing the greeting sent by the client in its &amp;ldquo;HELO&amp;rdquo;.</source>
          <target state="translated">클라이언트가 &quot;HELO&quot;로 보낸 인사말을 포함하는 문자열을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="cd7148d74352a877af7eb8ce8dea2f82f4e06603" translate="yes" xml:space="preserve">
          <source>Holds an instance of the class specified by the &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.MessageClass&quot;&gt;&lt;code&gt;MessageClass&lt;/code&gt;&lt;/a&gt; class variable. This instance parses and manages the headers in the HTTP request. The &lt;a href=&quot;http.client#http.client.parse_headers&quot;&gt;&lt;code&gt;parse_headers()&lt;/code&gt;&lt;/a&gt; function from &lt;a href=&quot;http.client#module-http.client&quot;&gt;&lt;code&gt;http.client&lt;/code&gt;&lt;/a&gt; is used to parse the headers and it requires that the HTTP request provide a valid &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; style header.</source>
          <target state="translated">&lt;a href=&quot;#http.server.BaseHTTPRequestHandler.MessageClass&quot;&gt; &lt;code&gt;MessageClass&lt;/code&gt; &lt;/a&gt; 클래스 변수로 지정된 클래스의 인스턴스를 보유 합니다. 이 인스턴스는 HTTP 요청에서 헤더를 구문 분석하고 관리합니다. &lt;a href=&quot;http.client#http.client.parse_headers&quot;&gt; &lt;code&gt;parse_headers()&lt;/code&gt; &lt;/a&gt; 에서 기능 &lt;a href=&quot;http.client#module-http.client&quot;&gt; &lt;code&gt;http.client&lt;/code&gt; 는&lt;/a&gt; 헤더를 구문 분석하는 데 사용되며 그것은 HTTP 요청이 유효한 제공해야합니다 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 스타일의 헤더를.</target>
        </trans-unit>
        <trans-unit id="9265fe64481830dee7db00b81cb03da2a4116e1c" translate="yes" xml:space="preserve">
          <source>Holds the &lt;a href=&quot;#smtpd.SMTPServer&quot;&gt;&lt;code&gt;SMTPServer&lt;/code&gt;&lt;/a&gt; that spawned this channel.</source>
          <target state="translated">이 채널을 생성 한 &lt;a href=&quot;#smtpd.SMTPServer&quot;&gt; &lt;code&gt;SMTPServer&lt;/code&gt; &lt;/a&gt; 를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="e6689fb001eadb907fa93d352c8361eba9cb20a4" translate="yes" xml:space="preserve">
          <source>Holds the address of the client, the second value returned by &lt;a href=&quot;socket#socket.socket.accept&quot;&gt;&lt;code&gt;socket.accept&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;socket#socket.socket.accept&quot;&gt; &lt;code&gt;socket.accept&lt;/code&gt; 에서&lt;/a&gt; 리턴 한 두 번째 값인 클라이언트의 주소를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="119d2c3ab03cae2266b2eb5305549d108edb800b" translate="yes" xml:space="preserve">
          <source>Holds the current state of the channel. This will be either &lt;code&gt;COMMAND&lt;/code&gt; initially and then &lt;code&gt;DATA&lt;/code&gt; after the client sends a &amp;ldquo;DATA&amp;rdquo; line.</source>
          <target state="translated">채널의 현재 상태를 유지합니다. 이 중 하나가 될 것 &lt;code&gt;COMMAND&lt;/code&gt; 를 처음 다음 &lt;code&gt;DATA&lt;/code&gt; 클라이언트가 &quot;DATA&quot;라인을 전송 한 후.</target>
        </trans-unit>
        <trans-unit id="8f000494374b62d38904da327ccc63a75a5a6e7e" translate="yes" xml:space="preserve">
          <source>Holds the fully-qualified domain name of the server as returned by &lt;a href=&quot;socket#socket.getfqdn&quot;&gt;&lt;code&gt;socket.getfqdn()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.getfqdn&quot;&gt; &lt;code&gt;socket.getfqdn()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 서버의 완전한 도메인 이름을 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="7770cf3e40c26a8548c1a22aecf430e6fd9a88f6" translate="yes" xml:space="preserve">
          <source>Holds the name of the client peer as returned by &lt;code&gt;conn.getpeername()&lt;/code&gt; where &lt;code&gt;conn&lt;/code&gt; is &lt;a href=&quot;#smtpd.SMTPChannel.conn&quot;&gt;&lt;code&gt;conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 의해 반환되는 클라이언트 피어의 이름을 저장 &lt;code&gt;conn.getpeername()&lt;/code&gt; 곳 &lt;code&gt;conn&lt;/code&gt; IS &lt;a href=&quot;#smtpd.SMTPChannel.conn&quot;&gt; &lt;code&gt;conn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c43acfb18827d1f4ab3a7fb4b51beb5556091b5e" translate="yes" xml:space="preserve">
          <source>Holds the socket object connecting to the client.</source>
          <target state="translated">클라이언트에 연결하는 소켓 오브젝트를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="9f502739ab97f32f0169d7d2a89836a8f3d60183" translate="yes" xml:space="preserve">
          <source>Home down or bottom (lower left)</source>
          <target state="translated">홈 다운 또는 하단 (왼쪽 아래)</target>
        </trans-unit>
        <trans-unit id="b1ad0ce4fc4f46bb58f19b70095b12ebe09c3089" translate="yes" xml:space="preserve">
          <source>Home key (upward+left arrow)</source>
          <target state="translated">홈 키 (위쪽 + 왼쪽 화살표)</target>
        </trans-unit>
        <trans-unit id="82cc12384e3a382be4706e4e097a96b4d36d7997" translate="yes" xml:space="preserve">
          <source>Home page of &lt;strong&gt;nmh&lt;/strong&gt;, an updated version of the original &lt;strong&gt;mh&lt;/strong&gt;.</source>
          <target state="translated">원래 &lt;strong&gt;mh&lt;/strong&gt; 의 업데이트 된 버전 인 &lt;strong&gt;nmh의&lt;/strong&gt; 홈 페이지 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6283e72fcc111c07fd35510504e83a1879e65314" translate="yes" xml:space="preserve">
          <source>Home page of the Expat project.</source>
          <target state="translated">Expat 프로젝트의 홈 페이지.</target>
        </trans-unit>
        <trans-unit id="bd9948dcc8a1b00e0cac588a4f60d2df9c17fd17" translate="yes" xml:space="preserve">
          <source>Hook method executed just after a command dispatch is finished. This method is a stub in &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt;; it exists to be overridden by subclasses. &lt;em&gt;line&lt;/em&gt; is the command line which was executed, and &lt;em&gt;stop&lt;/em&gt; is a flag which indicates whether execution will be terminated after the call to &lt;a href=&quot;#cmd.Cmd.postcmd&quot;&gt;&lt;code&gt;postcmd()&lt;/code&gt;&lt;/a&gt;; this will be the return value of the &lt;a href=&quot;#cmd.Cmd.onecmd&quot;&gt;&lt;code&gt;onecmd()&lt;/code&gt;&lt;/a&gt; method. The return value of this method will be used as the new value for the internal flag which corresponds to &lt;em&gt;stop&lt;/em&gt;; returning false will cause interpretation to continue.</source>
          <target state="translated">명령 디스패치가 완료된 직후에 실행되는 후크 메소드. 이 방법은 &lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 의 스텁입니다 . 서브 클래스에 의해 대체됩니다. &lt;em&gt;line&lt;/em&gt; 은 실행 된 명령 행이고 &lt;em&gt;stop&lt;/em&gt; 은 &lt;a href=&quot;#cmd.Cmd.postcmd&quot;&gt; &lt;code&gt;postcmd()&lt;/code&gt; &lt;/a&gt; 호출 후 실행이 종료되는지 여부를 나타내는 플래그입니다 . 이것은 &lt;a href=&quot;#cmd.Cmd.onecmd&quot;&gt; &lt;code&gt;onecmd()&lt;/code&gt; &lt;/a&gt; 메소드 의 리턴 값입니다 . 이 메소드의 리턴 값은 &lt;em&gt;stop에&lt;/em&gt; 해당하는 내부 플래그의 새 값으로 사용됩니다 . false를 반환하면 해석이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="449ea143caf53c5e39b0355dcec294af589bb71b" translate="yes" xml:space="preserve">
          <source>Hook method executed just before the command line &lt;em&gt;line&lt;/em&gt; is interpreted, but after the input prompt is generated and issued. This method is a stub in &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt;; it exists to be overridden by subclasses. The return value is used as the command which will be executed by the &lt;a href=&quot;#cmd.Cmd.onecmd&quot;&gt;&lt;code&gt;onecmd()&lt;/code&gt;&lt;/a&gt; method; the &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt;&lt;code&gt;precmd()&lt;/code&gt;&lt;/a&gt; implementation may re-write the command or simply return &lt;em&gt;line&lt;/em&gt; unchanged.</source>
          <target state="translated">훅 메소드는 명령 행하기 전에 실행 &lt;em&gt;라인이&lt;/em&gt; 해석됩니다 만, 입력 프롬프트 후에 생성 및 발급됩니다. 이 방법은 &lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 의 스텁입니다 . 서브 클래스에 의해 대체됩니다. 리턴 값은 &lt;a href=&quot;#cmd.Cmd.onecmd&quot;&gt; &lt;code&gt;onecmd()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 실행될 명령으로 사용됩니다 . &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt; &lt;code&gt;precmd()&lt;/code&gt; &lt;/a&gt; 실행 명령을 다시 작성하거나 리턴 할 수 &lt;em&gt;라인&lt;/em&gt; 변경.</target>
        </trans-unit>
        <trans-unit id="9045e8acde6cdc71927bf33200a8d7172ae0f172" translate="yes" xml:space="preserve">
          <source>Hook method executed once when &lt;a href=&quot;#cmd.Cmd.cmdloop&quot;&gt;&lt;code&gt;cmdloop()&lt;/code&gt;&lt;/a&gt; is about to return. This method is a stub in &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt;; it exists to be overridden by subclasses.</source>
          <target state="translated">&lt;a href=&quot;#cmd.Cmd.cmdloop&quot;&gt; &lt;code&gt;cmdloop()&lt;/code&gt; &lt;/a&gt; 가 리턴 되려고 할 때 후크 메소드가 한 번 실행됩니다 . 이 방법은 &lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 의 스텁입니다 . 서브 클래스에 의해 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="087ffacadf4afb6c47c00dbd186afdecd1130959" translate="yes" xml:space="preserve">
          <source>Hook method executed once when &lt;a href=&quot;#cmd.Cmd.cmdloop&quot;&gt;&lt;code&gt;cmdloop()&lt;/code&gt;&lt;/a&gt; is called. This method is a stub in &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt;; it exists to be overridden by subclasses.</source>
          <target state="translated">&lt;a href=&quot;#cmd.Cmd.cmdloop&quot;&gt; &lt;code&gt;cmdloop()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 후크 메소드가 한 번 실행됩니다 . 이 방법은 &lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 의 스텁입니다 . 서브 클래스에 의해 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2e93e3cb2e42c7a2289b69a4580ae9d70a03b2" translate="yes" xml:space="preserve">
          <source>Hooks are added using the &lt;a href=&quot;#sys.addaudithook&quot;&gt;&lt;code&gt;sys.addaudithook()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt;&lt;code&gt;PySys_AddAuditHook()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">후크는 &lt;a href=&quot;#sys.addaudithook&quot;&gt; &lt;code&gt;sys.addaudithook()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt; &lt;code&gt;PySys_AddAuditHook()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 추가 됩니다.</target>
        </trans-unit>
        <trans-unit id="5eda08bad54f52c7bdb5179cf6a75b60587955cd" translate="yes" xml:space="preserve">
          <source>Horizontal highlight</source>
          <target state="translated">수평 하이라이트</target>
        </trans-unit>
        <trans-unit id="a5a7e131a5cb8762553101bda765297974113fa2" translate="yes" xml:space="preserve">
          <source>Host is down</source>
          <target state="translated">호스트가 다운되었습니다</target>
        </trans-unit>
        <trans-unit id="191f7808ee27d0914021b6bf49daf82e21931c8e" translate="yes" xml:space="preserve">
          <source>Host name (lower case)</source>
          <target state="translated">호스트 이름 (소문자)</target>
        </trans-unit>
        <trans-unit id="b5e18f2451a0719cbdf851704cee573f6887f1e1" translate="yes" xml:space="preserve">
          <source>Hostname of the server: &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; type, or &lt;code&gt;None&lt;/code&gt; for server-side socket or if the hostname was not specified in the constructor.</source>
          <target state="translated">서버의 호스트 이름 : &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 유형 또는 서버 측 소켓의 경우 또는 생성자에 호스트 이름이 지정되지 않은 경우 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="425c6644ee61c9a230fcbf65d7494b117f494021" translate="yes" xml:space="preserve">
          <source>Hour (12-hour clock) as a decimal number [01,12].</source>
          <target state="translated">십진수로 표시되는 시간 (12 시간제) [01,12].</target>
        </trans-unit>
        <trans-unit id="f59212d5750be40abbdaa5bbb82d3fdc34b42955" translate="yes" xml:space="preserve">
          <source>Hour (12-hour clock) as a zero-padded decimal number.</source>
          <target state="translated">0으로 채워진 10 진수로 표시되는 시간 (12 시간제)입니다.</target>
        </trans-unit>
        <trans-unit id="fb9eb08a7d5aa5786e2bc10ef029f16e805c8a84" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) as a decimal number [00,23].</source>
          <target state="translated">십진수로 된 시간 (24 시간제) [00,23].</target>
        </trans-unit>
        <trans-unit id="00929e29b383160b1e2458e720fcf861fdf67571" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) as a zero-padded decimal number.</source>
          <target state="translated">0으로 채워진 10 진수로 표시되는 시간 (24 시간제)입니다.</target>
        </trans-unit>
        <trans-unit id="9e25a34e635a123f8958bbe26e7c4843278597fb" translate="yes" xml:space="preserve">
          <source>Hours</source>
          <target state="translated">Hours</target>
        </trans-unit>
        <trans-unit id="2093b61ef7ae08159816a865e810be957ff212f4" translate="yes" xml:space="preserve">
          <source>Hours (zero-based)</source>
          <target state="translated">시간 (0부터 시작)</target>
        </trans-unit>
        <trans-unit id="8cecc82d72d68f9151cb0901cfe40eeac15bfca6" translate="yes" xml:space="preserve">
          <source>How It Works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="3cf8194af8b431024aea161c0d72843e4d494297" translate="yes" xml:space="preserve">
          <source>How Tk and Tkinter are Related</source>
          <target state="translated">Tk와 Tkinter의 관계</target>
        </trans-unit>
        <trans-unit id="786543e016a5fcb5bd0820fa60ef4b7c492ab041" translate="yes" xml:space="preserve">
          <source>How To Use This Section</source>
          <target state="translated">이 섹션을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="b6a3579a533572ecb0e0f96eccc0c564589a41d7" translate="yes" xml:space="preserve">
          <source>How are Docstring Examples Recognized?</source>
          <target state="translated">독 스트링 예제는 어떻게 인식됩니까?</target>
        </trans-unit>
        <trans-unit id="8b82a90e60fe771b243b5707683f611d5a457c14" translate="yes" xml:space="preserve">
          <source>How are Enums different?</source>
          <target state="translated">열거 형은 어떻게 다릅니 까?</target>
        </trans-unit>
        <trans-unit id="b49c247604ffa94c5e6d2020bc2401f351cdc8a4" translate="yes" xml:space="preserve">
          <source>How many bytes should tokens use?</source>
          <target state="translated">토큰은 몇 바이트를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="06cb3a2370ac3af4084ddb6774ba1f927d10f1da" translate="yes" xml:space="preserve">
          <source>How the compiler treats future imports.</source>
          <target state="translated">컴파일러가 향후 가져 오기를 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="9621e5b402eaf2bc653d7acbb6c0fc8aec7dbcee" translate="yes" xml:space="preserve">
          <source>How to configure Screen and Turtles</source>
          <target state="translated">화면과 거북이를 구성하는 방법</target>
        </trans-unit>
        <trans-unit id="8a47b2e2c48117dfb7843cebb091861bfbbbe021" translate="yes" xml:space="preserve">
          <source>How to create an archive and reset the user information using the &lt;em&gt;filter&lt;/em&gt; parameter in &lt;a href=&quot;#tarfile.TarFile.add&quot;&gt;&lt;code&gt;TarFile.add()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#tarfile.TarFile.add&quot;&gt; &lt;code&gt;TarFile.add()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;필터&lt;/em&gt; 매개 변수를 사용하여 아카이브를 작성하고 사용자 정보를 재설정하는 방법 :</target>
        </trans-unit>
        <trans-unit id="e8fa6daa5f75642da8422e72ceb883cde131d7f0" translate="yes" xml:space="preserve">
          <source>How to create an uncompressed tar archive from a list of filenames:</source>
          <target state="translated">파일 이름 목록에서 압축되지 않은 tar 아카이브를 작성하는 방법 :</target>
        </trans-unit>
        <trans-unit id="54799d0a1acb21e18739c385fc568caa565a6484" translate="yes" xml:space="preserve">
          <source>How to extract a subset of a tar archive with &lt;a href=&quot;#tarfile.TarFile.extractall&quot;&gt;&lt;code&gt;TarFile.extractall()&lt;/code&gt;&lt;/a&gt; using a generator function instead of a list:</source>
          <target state="translated">목록 대신 생성기 함수를 사용하여 &lt;a href=&quot;#tarfile.TarFile.extractall&quot;&gt; &lt;code&gt;TarFile.extractall()&lt;/code&gt; &lt;/a&gt; 사용하여 tar 아카이브의 서브 세트를 추출하는 방법 :</target>
        </trans-unit>
        <trans-unit id="125dc6e327af012b85b1699c8d0b4aea4fd5aa6e" translate="yes" xml:space="preserve">
          <source>How to extract an entire tar archive to the current working directory:</source>
          <target state="translated">전체 tar 아카이브를 현재 작업 디렉토리로 추출하는 방법 :</target>
        </trans-unit>
        <trans-unit id="6187ce11d668add52961b9aad04fcebce97277f5" translate="yes" xml:space="preserve">
          <source>How to read a gzip compressed tar archive and display some member information:</source>
          <target state="translated">gzip 압축 tar 아카이브를 읽고 일부 멤버 정보를 표시하는 방법 :</target>
        </trans-unit>
        <trans-unit id="6979f33c643743b3e1710eb3c8b04ebe15229773" translate="yes" xml:space="preserve">
          <source>How to use help</source>
          <target state="translated">도움말 사용법</target>
        </trans-unit>
        <trans-unit id="0ca8006d50f8b1fe3fcd3fbdbf73e28bca7fec95" translate="yes" xml:space="preserve">
          <source>How you use the &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module in your code depends on whether you are internationalizing a single module or your entire application. The next two sections will discuss each case.</source>
          <target state="translated">코드에서 &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 방법 은 단일 모듈 또는 전체 애플리케이션을 국제화하는지 여부에 따라 다릅니다. 다음 두 섹션에서는 각 사례에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cc2d951db9dd240ca5bf48d29a4e5261e13b4412" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;#asyncio.Protocol.eof_received&quot;&gt;&lt;code&gt;protocol.eof_received()&lt;/code&gt;&lt;/a&gt; is called at most once. Once &lt;code&gt;eof_received()&lt;/code&gt; is called, &lt;code&gt;data_received()&lt;/code&gt; is not called anymore.</source>
          <target state="translated">그러나 &lt;a href=&quot;#asyncio.Protocol.eof_received&quot;&gt; &lt;code&gt;protocol.eof_received()&lt;/code&gt; &lt;/a&gt; 가 최대 한 번 호출됩니다. 일단 &lt;code&gt;eof_received()&lt;/code&gt; , 호출 &lt;code&gt;data_received()&lt;/code&gt; 더 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0a858d192763a36609cbf2152f0a6b9ea1b92e5" translate="yes" xml:space="preserve">
          <source>However, a more generic mechanism is needed for user-defined objects which are not known to the &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; module. For example, consider &lt;a href=&quot;logging.handlers#logging.handlers.MemoryHandler&quot;&gt;&lt;code&gt;logging.handlers.MemoryHandler&lt;/code&gt;&lt;/a&gt;, which takes a &lt;code&gt;target&lt;/code&gt; argument which is another handler to delegate to. Since the system already knows about this class, then in the configuration, the given &lt;code&gt;target&lt;/code&gt; just needs to be the object id of the relevant target handler, and the system will resolve to the handler from the id. If, however, a user defines a &lt;code&gt;my.package.MyHandler&lt;/code&gt; which has an &lt;code&gt;alternate&lt;/code&gt; handler, the configuration system would not know that the &lt;code&gt;alternate&lt;/code&gt; referred to a handler. To cater for this, a generic resolution system allows the user to specify:</source>
          <target state="translated">그러나 &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 모듈에 알려지지 않은 사용자 정의 개체에는보다 일반적인 메커니즘이 필요 합니다. 예를 들어, &lt;a href=&quot;logging.handlers#logging.handlers.MemoryHandler&quot;&gt; &lt;code&gt;logging.handlers.MemoryHandler&lt;/code&gt; 를&lt;/a&gt; 고려해보십시오 . 이는 위임 할 다른 핸들러 인 &lt;code&gt;target&lt;/code&gt; 인수를 사용합니다. 시스템은 이미이 클래스에 대해 알고 있으므로 구성에서 지정된 &lt;code&gt;target&lt;/code&gt; 은 관련 대상 핸들러의 오브젝트 ID 일 뿐이며 시스템은 ID에서 핸들러로 해석됩니다. 그러나, 사용자가 정의하는 경우 &lt;code&gt;my.package.MyHandler&lt;/code&gt; 가 &lt;code&gt;alternate&lt;/code&gt; 핸들러를 구성 시스템은 알지 못 할 &lt;code&gt;alternate&lt;/code&gt; 핸들러를 참조하십시오. 이를 위해 일반 해상도 시스템을 사용하면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f378a310ff84ad7919807057388f38c47b1c65e4" translate="yes" xml:space="preserve">
          <source>However, consider the alternative scenario where instead of &lt;code&gt;from a import
SomeClass&lt;/code&gt; module b does &lt;code&gt;import a&lt;/code&gt; and &lt;code&gt;some_function&lt;/code&gt; uses &lt;code&gt;a.SomeClass&lt;/code&gt;. Both of these import forms are common. In this case the class we want to patch is being looked up in the module and so we have to patch &lt;code&gt;a.SomeClass&lt;/code&gt; instead:</source>
          <target state="translated">그러나 대신에 다른 시나리오를 고려 &lt;code&gt;from a import SomeClass&lt;/code&gt; 수행 모듈 B &lt;code&gt;import a&lt;/code&gt; 하고 &lt;code&gt;some_function&lt;/code&gt; 가 사용 &lt;code&gt;a.SomeClass&lt;/code&gt; 을 . 이 두 가지 가져 오기 양식이 일반적입니다. 이 경우 패치하려는 클래스가 모듈에서 검색되므로 &lt;code&gt;a.SomeClass&lt;/code&gt; 를 대신 패치 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="439bf14282c72fd1ed84e1410444feb63481ab8b" translate="yes" xml:space="preserve">
          <source>However, global variables which are just module level constants cause no problems.</source>
          <target state="translated">그러나 모듈 수준 상수 인 전역 변수는 문제를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8da1514a7f4d0b15655c2472b7999f9854a1d368" translate="yes" xml:space="preserve">
          <source>However, handling of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; methods is notoriously implementation specific, since it depends on internal details of the interpreter&amp;rsquo;s garbage collector implementation.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; 메서드 처리 는 인터프리터의 가비지 수집기 구현에 대한 내부 세부 정보에 의존하기 때문에 구현별로 악명이 높습니다.</target>
        </trans-unit>
        <trans-unit id="524385f4308742264684061a603d78f1b65969ea" translate="yes" xml:space="preserve">
          <source>However, if you are writing a library (and do not control in which context its code will be executed), be aware that the standard streams may be replaced with file-like objects like &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; which do not support the &lt;code&gt;buffer&lt;/code&gt; attribute.</source>
          <target state="translated">그러나 라이브러리를 작성하는 경우 (코드가 실행될 컨텍스트를 제어하지 않는 경우) 표준 스트림은 &lt;code&gt;buffer&lt;/code&gt; 속성을 지원하지 않는 &lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 와 같은 파일과 유사한 객체로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b769de1746f60e4baa053e7572f0057d9c8fe3d0" translate="yes" xml:space="preserve">
          <source>However, if you really do need to use some shared data then &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; provides a couple of ways of doing so.</source>
          <target state="translated">그러나 실제로 공유 데이터를 사용해야하는 경우 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 은 몇 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="23eebfaf8db57314d57e41112830f6a06b63dacc" translate="yes" xml:space="preserve">
          <source>However, in a Windows path, changing the local root doesn&amp;rsquo;t discard the previous drive setting:</source>
          <target state="translated">그러나 Windows 경로에서 로컬 루트를 변경해도 이전 드라이브 설정은 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f42d2d8c9bca01face2f0640d30c8b6b4f7aef41" translate="yes" xml:space="preserve">
          <source>However, it is possible to create a &lt;a href=&quot;#typing.NewType&quot;&gt;&lt;code&gt;NewType()&lt;/code&gt;&lt;/a&gt; based on a &amp;lsquo;derived&amp;rsquo; &lt;code&gt;NewType&lt;/code&gt;:</source>
          <target state="translated">그러나 '파생' &lt;code&gt;NewType&lt;/code&gt; 을 기반으로 &lt;a href=&quot;#typing.NewType&quot;&gt; &lt;code&gt;NewType()&lt;/code&gt; &lt;/a&gt; 을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d78b154c37b0dfd16aaf863d992caf9a3e8512e0" translate="yes" xml:space="preserve">
          <source>However, should you want to customize the building of your test suite, you can do it yourself:</source>
          <target state="translated">그러나 테스트 스위트의 빌드를 사용자 정의하려는 경우 직접 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e105ff00b24b9693a483aad8940ba6101edec1f" translate="yes" xml:space="preserve">
          <source>However, since the SSL (and TLS) protocol has its own framing atop of TCP, the SSL sockets abstraction can, in certain respects, diverge from the specification of normal, OS-level sockets. See especially the &lt;a href=&quot;#ssl-nonblocking&quot;&gt;notes on non-blocking sockets&lt;/a&gt;.</source>
          <target state="translated">그러나 SSL (및 TLS) 프로토콜에는 TCP 위에 자체 프레이밍이 있으므로 SSL 소켓 추상화는 특정 측면에서 정상적인 OS 수준 소켓 사양과 다를 수 있습니다. &lt;a href=&quot;#ssl-nonblocking&quot;&gt;비 차단 소켓에&lt;/a&gt; 대한 참고 사항을 특히 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8fede9e85907b8edc885805dba8e1a629627b87" translate="yes" xml:space="preserve">
          <source>However, the &lt;a href=&quot;#module-multiprocessing.connection&quot;&gt;&lt;code&gt;multiprocessing.connection&lt;/code&gt;&lt;/a&gt; module allows some extra flexibility. It basically gives a high level message oriented API for dealing with sockets or Windows named pipes. It also has support for &lt;em&gt;digest authentication&lt;/em&gt; using the &lt;a href=&quot;hmac#module-hmac&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; module, and for polling multiple connections at the same time.</source>
          <target state="translated">그러나 &lt;a href=&quot;#module-multiprocessing.connection&quot;&gt; &lt;code&gt;multiprocessing.connection&lt;/code&gt; &lt;/a&gt; 모듈은 추가적인 유연성을 제공합니다. 기본적으로 소켓 또는 Windows 명명 된 파이프를 처리하기위한 고급 메시지 지향 API를 제공합니다. 또한 &lt;a href=&quot;hmac#module-hmac&quot;&gt; &lt;code&gt;hmac&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 &lt;em&gt;다이제스트 인증&lt;/em&gt; 을 지원 하고 동시에 여러 연결을 폴링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6a9f983b8ff7cdac272806e8c7920846eea877" translate="yes" xml:space="preserve">
          <source>However, they still can&amp;rsquo;t be compared to standard &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; enumerations:</source>
          <target state="translated">그러나 여전히 표준 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 형 열거 형 과 비교할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91333f2e4bfca97b3f05dfcc743022c8782b7559" translate="yes" xml:space="preserve">
          <source>However, to match the shell as closely as possible, it is recommended to always use &lt;code&gt;posix&lt;/code&gt; and &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt;&lt;code&gt;whitespace_split&lt;/code&gt;&lt;/a&gt; when using &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt;&lt;code&gt;punctuation_chars&lt;/code&gt;&lt;/a&gt;, which will negate &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt;&lt;code&gt;wordchars&lt;/code&gt;&lt;/a&gt; entirely.</source>
          <target state="translated">그러나 밀접하게 가능한 쉘에 맞게 항상 사용을 권장 &lt;code&gt;posix&lt;/code&gt; 및 &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt; &lt;code&gt;whitespace_split&lt;/code&gt; &lt;/a&gt; 사용하는 경우 &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt; &lt;code&gt;punctuation_chars&lt;/code&gt; &lt;/a&gt; 부정하는 것, &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt; &lt;code&gt;wordchars&lt;/code&gt; 을&lt;/a&gt; 완전히합니다.</target>
        </trans-unit>
        <trans-unit id="9b74bb3116de6c2b6f2b5b3489fa54307c65fc89" translate="yes" xml:space="preserve">
          <source>However, two enum members are allowed to have the same value. Given two members A and B with the same value (and A defined first), B is an alias to A. By-value lookup of the value of A and B will return A. By-name lookup of B will also return A:</source>
          <target state="translated">그러나 두 열거 형 멤버는 동일한 값을 가질 수 있습니다. 같은 값을 가진 두 멤버 A와 B (그리고 A가 먼저 정의 됨)가 주어지면 B는 A의 별칭입니다. A와 B 값의 값별 조회는 A를 반환합니다. B의 이름 별 조회도 A를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d317839ba4e2c85ee86b52a46ee27291e7f15167" translate="yes" xml:space="preserve">
          <source>However, when using a proxy for a namespace object, an attribute beginning with &lt;code&gt;'_'&lt;/code&gt; will be an attribute of the proxy and not an attribute of the referent:</source>
          <target state="translated">그러나 네임 스페이스 객체에 프록시를 사용하는 경우 &lt;code&gt;'_'&lt;/code&gt; 로 시작 하는 속성은 참조 속성이 아닌 프록시 속성이됩니다.</target>
        </trans-unit>
        <trans-unit id="9db1c257cbf6348bd2bdc6bec9835ad1ee2611cd" translate="yes" xml:space="preserve">
          <source>Human-readable time when the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; was created. By default this is of the form &amp;lsquo;2003-07-08 16:49:45,896&amp;rsquo; (the numbers after the comma are millisecond portion of the time).</source>
          <target state="translated">&lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 가 작성된 사람이 읽을 수있는 시간 입니다. 기본적으로 '2003-07-08 16 : 49 : 45,896'형식입니다 (쉼표 뒤의 숫자는 시간의 밀리 초입니다).</target>
        </trans-unit>
        <trans-unit id="9c8511b78ed54aa0fa96cb081001b1a2bf46efeb" translate="yes" xml:space="preserve">
          <source>Human-readable version of &lt;a href=&quot;#wave.Wave_read.getcomptype&quot;&gt;&lt;code&gt;getcomptype()&lt;/code&gt;&lt;/a&gt;. Usually &lt;code&gt;'not compressed'&lt;/code&gt; parallels &lt;code&gt;'NONE'&lt;/code&gt;.</source>
          <target state="translated">사람이 읽을 수있는 &lt;a href=&quot;#wave.Wave_read.getcomptype&quot;&gt; &lt;code&gt;getcomptype()&lt;/code&gt; &lt;/a&gt; 버전 . 일반적으로 &lt;code&gt;'not compressed'&lt;/code&gt; &lt;code&gt;'NONE'&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="add9ea21e0134d1a6dc92640398cf0190b05790e" translate="yes" xml:space="preserve">
          <source>Hung up</source>
          <target state="translated">전화를 끊다</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">쌍곡선 함수</target>
        </trans-unit>
        <trans-unit id="de2470c480abd98424dacb0f44f27ca062690dfb" translate="yes" xml:space="preserve">
          <source>I will present an example here which uses the standard C library&amp;rsquo;s &lt;code&gt;qsort()&lt;/code&gt; function, that is used to sort items with the help of a callback function. &lt;code&gt;qsort()&lt;/code&gt; will be used to sort an array of integers:</source>
          <target state="translated">콜백 함수를 사용하여 항목을 정렬 하는 데 사용되는 표준 C 라이브러리의 &lt;code&gt;qsort()&lt;/code&gt; 함수 를 사용하는 예제를 여기에 표시합니다 . &lt;code&gt;qsort()&lt;/code&gt; 는 정수 배열을 정렬하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9c3553918e97b386614c46b9394f4b8471c979" translate="yes" xml:space="preserve">
          <source>I/O Base Classes</source>
          <target state="translated">I / O 기본 클래스</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">입출력 오류</target>
        </trans-unit>
        <trans-unit id="2711395734586dad19e3e7e6bf6c599633c758e2" translate="yes" xml:space="preserve">
          <source>I/O operations may fail even when &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; indicates that they would succeed, particularly for operations on network filesystems which may have permissions semantics beyond the usual POSIX permission-bit model.</source>
          <target state="translated">&lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; 가 성공할 것임을 나타내는 경우에도 특히 I / O 작업이 실패 할 수 있습니다. 특히 일반적인 POSIX 권한 비트 모델 이외의 권한 의미가있는 네트워크 파일 시스템에서의 작업의 경우.</target>
        </trans-unit>
        <trans-unit id="f7d467a87245290159a1b6af42928666730653f6" translate="yes" xml:space="preserve">
          <source>IANA</source>
          <target state="translated">IANA</target>
        </trans-unit>
        <trans-unit id="fd1cdb7e9dcbc4982fb094e6764772bf3b00e12c" translate="yes" xml:space="preserve">
          <source>IANA TLS: Transport Layer Security (TLS) Parameters</source>
          <target state="translated">IANA TLS : TLS (Transport Layer Security) 매개 변수</target>
        </trans-unit>
        <trans-unit id="5936f115af9d290a0d4c51a3b370fe51eb023734" translate="yes" xml:space="preserve">
          <source>IANA timezone database</source>
          <target state="translated">IANA 시간대 데이터베이스</target>
        </trans-unit>
        <trans-unit id="bce52158db4ea934391bad4260ff69db81d9b587" translate="yes" xml:space="preserve">
          <source>IBM&amp;rsquo;s General Decimal Arithmetic Specification, &lt;a href=&quot;http://speleotrove.com/decimal/decarith.html&quot;&gt;The General Decimal Arithmetic Specification&lt;/a&gt;.</source>
          <target state="translated">IBM의 일반 십진 산술 스펙, &lt;a href=&quot;http://speleotrove.com/decimal/decarith.html&quot;&gt;일반 십진 산술 스펙&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d384f46aa316c46d9da3980789c420f3f02914f" translate="yes" xml:space="preserve">
          <source>IBM037, IBM039</source>
          <target state="translated">IBM037, IBM039</target>
        </trans-unit>
        <trans-unit id="25c9f2e3939dfc2b3f7f8e99803711ba0f10dd8f" translate="yes" xml:space="preserve">
          <source>IBM775</source>
          <target state="translated">IBM775</target>
        </trans-unit>
        <trans-unit id="2e03293740ecf9023db87941f55d98d607008460" translate="yes" xml:space="preserve">
          <source>IBM864</source>
          <target state="translated">IBM864</target>
        </trans-unit>
        <trans-unit id="d0c6332e03ed7288ab9fabcfcbe8f7d47ead9f1d" translate="yes" xml:space="preserve">
          <source>IDL Type</source>
          <target state="translated">IDL 유형</target>
        </trans-unit>
        <trans-unit id="6bf8911095af71a660308ff2f022e3f091e35f17" translate="yes" xml:space="preserve">
          <source>IDL attributes map to instance attributes. For compatibility with the OMG IDL language mapping for Python, an attribute &lt;code&gt;foo&lt;/code&gt; can also be accessed through accessor methods &lt;code&gt;_get_foo()&lt;/code&gt; and &lt;code&gt;_set_foo()&lt;/code&gt;. &lt;code&gt;readonly&lt;/code&gt; attributes must not be changed; this is not enforced at runtime.</source>
          <target state="translated">IDL 속성은 인스턴스 속성에 매핑됩니다. Python 용 OMG IDL 언어 매핑과의 호환성을 위해 접근 자 메소드 &lt;code&gt;_get_foo()&lt;/code&gt; 및 &lt;code&gt;_set_foo()&lt;/code&gt; 통해 속성 &lt;code&gt;foo&lt;/code&gt; 에 액세스 할 수 있습니다 . &lt;code&gt;readonly&lt;/code&gt; 속성은 변경하지 않아야합니다. 런타임에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4646e9f2b71a8bdc5087acabdc0352b0d257af74" translate="yes" xml:space="preserve">
          <source>IDLE</source>
          <target state="translated">IDLE</target>
        </trans-unit>
        <trans-unit id="619274f5a3734b1f62b9c727af1d75beec311b03" translate="yes" xml:space="preserve">
          <source>IDLE Help</source>
          <target state="translated">유휴 도움말</target>
        </trans-unit>
        <trans-unit id="898dce9ecf90e7e7d5d02cf64e27fe2734513168" translate="yes" xml:space="preserve">
          <source>IDLE assumes that files with a known .py* extension contain Python code and that other files do not. Run Python code with the Run menu.</source>
          <target state="translated">IDLE은 알려진 .py * 확장자를 가진 파일에 Python 코드가 포함되어 있고 다른 파일은 포함하지 않는다고 가정합니다. 실행 메뉴를 사용하여 Python 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="75bbc791a4aa40f6497c42cba8acc7f613d3b8cb" translate="yes" xml:space="preserve">
          <source>IDLE contains an extension facility. Preferences for extensions can be changed with the Extensions tab of the preferences dialog. See the beginning of config-extensions.def in the idlelib directory for further information. The only current default extension is zzdummy, an example also used for testing.</source>
          <target state="translated">IDLE에는 확장 기능이 포함되어 있습니다. 기본 설정 대화 상자의 확장 탭에서 확장에 대한 기본 설정을 변경할 수 있습니다. 자세한 정보는 idlelib 디렉토리에서 config-extensions.def 시작을 참조하십시오. 현재 기본 확장명은 zzdummy 뿐이며 테스트에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ea11f11dfc2e4dc9fcce02ad959e9a853a35043" translate="yes" xml:space="preserve">
          <source>IDLE has the following features:</source>
          <target state="translated">IDLE에는 다음과 같은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f3701f5db6a9639148f6560d8fff5476184868" translate="yes" xml:space="preserve">
          <source>IDLE has two main window types, the Shell window and the Editor window. It is possible to have multiple editor windows simultaneously. On Windows and Linux, each has its own top menu. Each menu documented below indicates which window type it is associated with.</source>
          <target state="translated">IDLE에는 셸 창과 편집기 창이라는 두 가지 기본 창 유형이 있습니다. 여러 개의 편집기 창을 동시에 가질 수 있습니다. Windows 및 Linux에서는 각각 고유 한 최상위 메뉴가 있습니다. 아래에 문서화 된 각 메뉴는 연관된 창 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44fac21ae0e0592212109932c2b71c550bd61ce6" translate="yes" xml:space="preserve">
          <source>IDLE is Python&amp;rsquo;s Integrated Development and Learning Environment.</source>
          <target state="translated">IDLE은 Python의 통합 개발 및 학습 환경입니다.</target>
        </trans-unit>
        <trans-unit id="6e56c2de541f27a1c04500e97b2142294c0794aa" translate="yes" xml:space="preserve">
          <source>IDLE is intentionally different from standard Python in order to facilitate development of tkinter programs. Enter &lt;code&gt;import tkinter as tk;
root = tk.Tk()&lt;/code&gt; in standard Python and nothing appears. Enter the same in IDLE and a tk window appears. In standard Python, one must also enter &lt;code&gt;root.update()&lt;/code&gt; to see the window. IDLE does the equivalent in the background, about 20 times a second, which is about every 50 milliseconds. Next enter &lt;code&gt;b = tk.Button(root, text='button'); b.pack()&lt;/code&gt;. Again, nothing visibly changes in standard Python until one enters &lt;code&gt;root.update()&lt;/code&gt;.</source>
          <target state="translated">IDLE은 tkinter 프로그램 개발을 용이하게하기 위해 표준 Python과 의도적으로 다릅니다. &lt;code&gt;import tkinter as tk; root = tk.Tk()&lt;/code&gt; 입력하십시오 . 표준 파이썬에서는 root = tk.Tk () 가 나타나지 않습니다. IDLE에 동일하게 입력하면 tk 창이 나타납니다. 표준 파이썬에서는 창을 보려면 &lt;code&gt;root.update()&lt;/code&gt; 를 입력해야합니다 . IDLE은 초당 약 20 회 (50 밀리 초마다) 백그라운드에서 동등한 기능을 수행합니다. 다음으로 &lt;code&gt;b = tk.Button(root, text='button'); b.pack()&lt;/code&gt; . 다시 말하지만, &lt;code&gt;root.update()&lt;/code&gt; 들어갈 때까지 표준 Python에서 아무것도 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8d796c27be2cf21ed59c8759c905bc23b350d7b4" translate="yes" xml:space="preserve">
          <source>IDLE may open editor windows when it starts, depending on settings and how you start IDLE. Thereafter, use the File menu. There can be only one open editor window for a given file.</source>
          <target state="translated">설정 및 IDLE 시작 방법에 따라 IDLE이 시작될 때 편집기 창을 열 수 있습니다. 그런 다음 파일 메뉴를 사용하십시오. 주어진 파일에 대해 열린 편집기 창이 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="253f821a5f3a1c94a0536918c1450667d7b406ce" translate="yes" xml:space="preserve">
          <source>IDLE on macOS</source>
          <target state="translated">macOS의 유휴</target>
        </trans-unit>
        <trans-unit id="07b20364b24d2a4a15afcdbe6b5431a328e5b391" translate="yes" xml:space="preserve">
          <source>IDLE uses a socket to communicate between the IDLE GUI process and the user code execution process. A connection must be established whenever the Shell starts or restarts. (The latter is indicated by a divider line that says &amp;lsquo;RESTART&amp;rsquo;). If the user process fails to connect to the GUI process, it displays a &lt;code&gt;Tk&lt;/code&gt; error box with a &amp;lsquo;cannot connect&amp;rsquo; message that directs the user here. It then exits.</source>
          <target state="translated">IDLE은 소켓을 사용하여 IDLE GUI 프로세스와 사용자 코드 실행 프로세스간에 통신합니다. 셸을 시작하거나 다시 시작할 때마다 연결을 설정해야합니다. 후자는 'RESTART'라고 표시된 구분선으로 표시됩니다. 사용자 프로세스가 GUI 프로세스에 연결하지 못하면 여기에 사용자를 지시하는 '연결할 수 없음'메시지와 함께 &lt;code&gt;Tk&lt;/code&gt; 오류 상자가 표시됩니다 . 그런 다음 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="294f9b9e7d21007e31d5bb92fc308b2f7b9ed947" translate="yes" xml:space="preserve">
          <source>IDLE&amp;rsquo;s standard stream replacements are not inherited by subprocesses created in the execution process, whether directly by user code or by modules such as multiprocessing. If such subprocess use &lt;code&gt;input&lt;/code&gt; from sys.stdin or &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; to sys.stdout or sys.stderr, IDLE should be started in a command line window. The secondary subprocess will then be attached to that window for input and output.</source>
          <target state="translated">IDLE의 표준 스트림 대체는 사용자 코드 또는 멀티 프로세싱과 같은 모듈에 의해 실행 프로세스에서 작성된 서브 프로세스에 의해 상속되지 않습니다. 이러한 서브 프로세스 가 sys.stdin의 &lt;code&gt;input&lt;/code&gt; 을 사용 하거나 sys.stdout 또는 sys.stderr에 &lt;code&gt;print&lt;/code&gt; 하거나 &lt;code&gt;write&lt;/code&gt; 명령 행 창에서 IDLE을 시작해야합니다. 그러면 보조 하위 프로세스가 입력 및 출력을 위해 해당 창에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="aea80ada688c48062d55019e094cc1143e3a0adc" translate="yes" xml:space="preserve">
          <source>IETF</source>
          <target state="translated">IETF</target>
        </trans-unit>
        <trans-unit id="f9c9fbbc612c61efdc44101bdc0b4c61f818bba4" translate="yes" xml:space="preserve">
          <source>IIS can be configured to pass the correct &lt;code&gt;PATH_INFO&lt;/code&gt;, but this causes another bug where &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; is wrong. Luckily this variable is rarely used and is not guaranteed by WSGI. On IIS&amp;lt;7, though, the setting can only be made on a vhost level, affecting all other script mappings, many of which break when exposed to the &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; bug. For this reason IIS&amp;lt;7 is almost never deployed with the fix. (Even IIS7 rarely uses it because there is still no UI for it.)</source>
          <target state="translated">IIS는 올바른 &lt;code&gt;PATH_INFO&lt;/code&gt; 를 전달하도록 구성 할 수 있지만 &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; 가 잘못된 다른 버그가 발생 합니다. 운 좋게도이 변수는 거의 사용되지 않으며 WSGI에서 보장하지 않습니다. 그러나 IIS &amp;lt;7에서는이 설정을 가상 호스트 수준에서만 수행 할 수 있으며 다른 모든 스크립트 매핑에 영향을 미치며 대부분은 &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; 버그에 노출되면 중단됩니다 . 이러한 이유로 IIS &amp;lt;7은 거의 수정 사항으로 배포되지 않습니다. (IIS7조차도 UI가 없기 때문에 거의 사용하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="dc5982d33dd23bd8d90805fafc24a3114eaf3d91" translate="yes" xml:space="preserve">
          <source>IMAP (Internet Message Access Protocol) client</source>
          <target state="translated">IMAP (Internet Message Access Protocol) 클라이언트</target>
        </trans-unit>
        <trans-unit id="ee980c33b9d65ac696be3577604e43ad769530f5" translate="yes" xml:space="preserve">
          <source>IMAP4 Example</source>
          <target state="translated">IMAP4 예</target>
        </trans-unit>
        <trans-unit id="0bf33cf42855fe39a37a956bf4ca9bce143662b0" translate="yes" xml:space="preserve">
          <source>IMAP4 Objects</source>
          <target state="translated">IMAP4 객체</target>
        </trans-unit>
        <trans-unit id="54a2e0f83d696897f7938ff4e902b96cfe7ebe39" translate="yes" xml:space="preserve">
          <source>IMAP4 server errors cause this exception to be raised. This is a sub-class of &lt;a href=&quot;#imaplib.IMAP4.error&quot;&gt;&lt;code&gt;IMAP4.error&lt;/code&gt;&lt;/a&gt;. Note that closing the instance and instantiating a new one will usually allow recovery from this exception.</source>
          <target state="translated">IMAP4 서버 오류로 인해이 예외가 발생합니다. 이것은 &lt;a href=&quot;#imaplib.IMAP4.error&quot;&gt; &lt;code&gt;IMAP4.error&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . 인스턴스를 닫고 새 인스턴스를 인스턴스화하면 일반적으로이 예외에서 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="2ccb5c6f3f5eedcfc4714430d8777d910b94fd71" translate="yes" xml:space="preserve">
          <source>IP Addresses</source>
          <target state="translated">IP 주소</target>
        </trans-unit>
        <trans-unit id="9e3725069a7ec82ac5ffec06a0726dc4f7d933d6" translate="yes" xml:space="preserve">
          <source>IP Network definitions</source>
          <target state="translated">IP 네트워크 정의</target>
        </trans-unit>
        <trans-unit id="0c1d08e522b1ada055f757b0f439e1183ee338ed" translate="yes" xml:space="preserve">
          <source>ISO 8601 week as a decimal number with Monday as the first day of the week. Week 01 is the week containing Jan 4.</source>
          <target state="translated">월요일을 요일의 첫 번째 요일로하는 ISO 8601 주 (10 진수) 주 01은 1 월 4 일이 포함 된 주입니다.</target>
        </trans-unit>
        <trans-unit id="f8995e635cfe9c3a98e07c9ba781f0a6358cb3c9" translate="yes" xml:space="preserve">
          <source>ISO 8601 weekday as a decimal number where 1 is Monday.</source>
          <target state="translated">평일 1은 월요일 인 ISO 8601 평일입니다.</target>
        </trans-unit>
        <trans-unit id="514bf155d39ffefb08418af80af6de7e45130d9e" translate="yes" xml:space="preserve">
          <source>ISO 8601 year with century representing the year that contains the greater part of the ISO week (&lt;code&gt;%V&lt;/code&gt;).</source>
          <target state="translated">ISO 주 ( &lt;code&gt;%V&lt;/code&gt; ) 의 대부분을 포함하는 연도를 나타내는 세기가있는 ISO 8601 연도입니다 .</target>
        </trans-unit>
        <trans-unit id="f55f5622b2b522bc805cc41ff05e2c603a2bf278" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999. &amp;ldquo;Programming languages &amp;ndash; C.&amp;rdquo; A public draft of this standard is available at &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&lt;/a&gt;.</source>
          <target state="translated">ISO / IEC 9899 : 1999. &amp;ldquo;프로그래밍 언어 &amp;ndash; C&amp;rdquo; 이 표준의 공개 초안은 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4908b12c142b7bd671d43e5185556c158bb0999c" translate="yes" xml:space="preserve">
          <source>Icelandic</source>
          <target state="translated">Icelandic</target>
        </trans-unit>
        <trans-unit id="acd1e6f9426d838c20ce10c0d69c37b84f105784" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; except that &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; also attempts to preserve file metadata.</source>
          <target state="translated">동일 &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 하는 것을 제외 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 또한 파일의 메타 데이터를 보존하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3b67836a7558b5c8eb65d018d9c3da891c5dbd61" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#time.CLOCK_MONOTONIC&quot;&gt;&lt;code&gt;CLOCK_MONOTONIC&lt;/code&gt;&lt;/a&gt;, except it also includes any time that the system is suspended.</source>
          <target state="translated">와 동일 &lt;a href=&quot;#time.CLOCK_MONOTONIC&quot;&gt; &lt;code&gt;CLOCK_MONOTONIC&lt;/code&gt; &lt;/a&gt; , 또한 시스템이 일시 중단되는 모든 시간을 포함 예외입니다.</target>
        </trans-unit>
        <trans-unit id="82e2063541c7fa099ab5e5a901852b54a66c49b9" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#decimal.Decimal.to_integral_value&quot;&gt;&lt;code&gt;to_integral_value()&lt;/code&gt;&lt;/a&gt; method. The &lt;code&gt;to_integral&lt;/code&gt; name has been kept for compatibility with older versions.</source>
          <target state="translated">&lt;a href=&quot;#decimal.Decimal.to_integral_value&quot;&gt; &lt;code&gt;to_integral_value()&lt;/code&gt; &lt;/a&gt; 메소드와 동일합니다 . &lt;code&gt;to_integral&lt;/code&gt; 이름은 이전 버전과의 호환성을 위해 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="46f3fa216b3c32403a41514a86cd404ca3c83cb5" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#re.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; function, using the compiled pattern.</source>
          <target state="translated">컴파일 된 패턴을 사용 하는 &lt;a href=&quot;#re.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a45d4848c68ab0522b00bbc2c7242ac143f0b900" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#re.sub&quot;&gt;&lt;code&gt;sub()&lt;/code&gt;&lt;/a&gt; function, using the compiled pattern.</source>
          <target state="translated">컴파일 된 패턴을 사용 하는 &lt;a href=&quot;#re.sub&quot;&gt; &lt;code&gt;sub()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c6bfdcc3ee2262d164aa72a90a32911e18ec94a5" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#re.subn&quot;&gt;&lt;code&gt;subn()&lt;/code&gt;&lt;/a&gt; function, using the compiled pattern.</source>
          <target state="translated">컴파일 된 패턴을 사용하여 &lt;a href=&quot;#re.subn&quot;&gt; &lt;code&gt;subn()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c2f8627bc91378e78cf995740ad3e1715d475219" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.iter_unpack&quot;&gt;&lt;code&gt;iter_unpack()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. The buffer&amp;rsquo;s size in bytes must be a multiple of &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 형식을 사용 하는 &lt;a href=&quot;#struct.iter_unpack&quot;&gt; &lt;code&gt;iter_unpack()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. 바이트 단위의 버퍼 크기는 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 의 배수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d21eeb3027709bab3da92975257519368ad08d9e" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.pack&quot;&gt;&lt;code&gt;pack()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. (&lt;code&gt;len(result)&lt;/code&gt; will equal &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.pack&quot;&gt; &lt;code&gt;pack()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. ( &lt;code&gt;len(result)&lt;/code&gt; 는 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; 와&lt;/a&gt; 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="c3375660e2fad4e52469c1195b329fc8e41df84c" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.pack_into&quot;&gt;&lt;code&gt;pack_into()&lt;/code&gt;&lt;/a&gt; function, using the compiled format.</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.pack_into&quot;&gt; &lt;code&gt;pack_into()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="0d39ae1b34f63264f0cee42f0a4d4a1a122e5077" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.unpack&quot;&gt;&lt;code&gt;unpack()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. The buffer&amp;rsquo;s size in bytes must equal &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.unpack&quot;&gt; &lt;code&gt;unpack()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. 바이트 단위의 버퍼 크기는 size와 같아야 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fe688fb8f7fbdc7bcfef76db53d21a9a791cad" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.unpack_from&quot;&gt;&lt;code&gt;unpack_from()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. The buffer&amp;rsquo;s size in bytes, starting at position &lt;em&gt;offset&lt;/em&gt;, must be at least &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.unpack_from&quot;&gt; &lt;code&gt;unpack_from()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. 위치 &lt;em&gt;offset&lt;/em&gt; 에서 시작하는 버퍼 크기 (바이트 )는 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 이상이어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="01924aa1a07ec0c16adf4b5d09634cea505a484d" translate="yes" xml:space="preserve">
          <source>Identifier of the device on which this file resides.</source>
          <target state="translated">이 파일이 상주하는 장치의 식별자.</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">식별자 제거</target>
        </trans-unit>
        <trans-unit id="1e75596418519eaa6fe966ace8634031be7fdfca" translate="yes" xml:space="preserve">
          <source>Identify the client using a plaintext password. The &lt;em&gt;password&lt;/em&gt; will be quoted.</source>
          <target state="translated">일반 텍스트 비밀번호를 사용하여 클라이언트를 식별하십시오. &lt;em&gt;암호가&lt;/em&gt; 인용 될 것이다.</target>
        </trans-unit>
        <trans-unit id="20298f2cb970734bced6da962363cfab14944346" translate="yes" xml:space="preserve">
          <source>Identify yourself to an ESMTP server using &lt;code&gt;EHLO&lt;/code&gt;. The hostname argument defaults to the fully qualified domain name of the local host. Examine the response for ESMTP option and store them for use by &lt;a href=&quot;#smtplib.SMTP.has_extn&quot;&gt;&lt;code&gt;has_extn()&lt;/code&gt;&lt;/a&gt;. Also sets several informational attributes: the message returned by the server is stored as the &lt;code&gt;ehlo_resp&lt;/code&gt; attribute, &lt;code&gt;does_esmtp&lt;/code&gt; is set to true or false depending on whether the server supports ESMTP, and &lt;code&gt;esmtp_features&lt;/code&gt; will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any).</source>
          <target state="translated">&lt;code&gt;EHLO&lt;/code&gt; 를 사용하여 ESMTP 서버에 자신을 식별하십시오 . hostname 인수의 기본값은 로컬 호스트의 완전한 도메인 이름입니다. ESMTP 옵션에 대한 응답을 검사하고 &lt;a href=&quot;#smtplib.SMTP.has_extn&quot;&gt; &lt;code&gt;has_extn()&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있도록 저장하십시오 . 또한 몇 가지 정보 속성을 설정합니다. 서버가 반환 한 메시지는 &lt;code&gt;ehlo_resp&lt;/code&gt; 속성 으로 저장되고 &lt;code&gt;does_esmtp&lt;/code&gt; 는 서버가 ESMTP를 지원하는지에 따라 true 또는 false로 설정되며 &lt;code&gt;esmtp_features&lt;/code&gt; 는이 서버의 SMTP 서비스 확장명을 포함하는 사전이됩니다. 지원 및 해당 매개 변수 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="1a6cc0c49eff29b1de2a0094d71e3e849917c5a5" translate="yes" xml:space="preserve">
          <source>Identify yourself to the SMTP server using &lt;code&gt;HELO&lt;/code&gt;. The hostname argument defaults to the fully qualified domain name of the local host. The message returned by the server is stored as the &lt;code&gt;helo_resp&lt;/code&gt; attribute of the object.</source>
          <target state="translated">&lt;code&gt;HELO&lt;/code&gt; 를 사용하여 SMTP 서버에 자신을 식별하십시오 . hostname 인수의 기본값은 로컬 호스트의 완전한 도메인 이름입니다. 서버가 리턴 한 메시지 는 오브젝트 의 &lt;code&gt;helo_resp&lt;/code&gt; 속성으로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="bf6a9618acf9bc1e72899605a417801bb69aeed6" translate="yes" xml:space="preserve">
          <source>Idle defaults to black on white text, but colors text with special meanings. For the shell, these are shell output, shell error, user output, and user error. For Python code, at the shell prompt or in an editor, these are keywords, builtin class and function names, names following &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt;, strings, and comments. For any text window, these are the cursor (when present), found text (when possible), and selected text.</source>
          <target state="translated">유휴는 흰색 텍스트에서 기본적으로 검은 색이지만 특수한 의미로 텍스트를 채색합니다. 쉘의 경우 쉘 출력, 쉘 오류, 사용자 출력 및 사용자 오류입니다. Python 코드의 경우 쉘 프롬프트 또는 편집기에서 키워드, 내장 클래스 및 함수 이름, &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;def&lt;/code&gt; 다음에 오는 이름 , 문자열 및 주석입니다. 모든 텍스트 창에서 커서 (있는 경우), 찾은 텍스트 (가능한 경우) 및 선택한 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="4dbc654d77cb8c9c5dc993be159da8b61b1ecd5b" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;from&amp;rdquo; is used as the value of &lt;em&gt;etype&lt;/em&gt;, &lt;a href=&quot;#tkinter.ttk.Style.element_create&quot;&gt;&lt;code&gt;element_create()&lt;/code&gt;&lt;/a&gt; will clone an existing element. &lt;em&gt;args&lt;/em&gt; is expected to contain a themename, from which the element will be cloned, and optionally an element to clone from. If this element to clone from is not specified, an empty element will be used. &lt;em&gt;kw&lt;/em&gt; is discarded.</source>
          <target state="translated">&quot;from&quot;이 &lt;em&gt;etype&lt;/em&gt; 값으로 사용 되면 &lt;a href=&quot;#tkinter.ttk.Style.element_create&quot;&gt; &lt;code&gt;element_create()&lt;/code&gt; &lt;/a&gt; 는 기존 요소를 복제합니다. &lt;em&gt;args&lt;/em&gt; 는 요소가 복제 될 테마 이름과 선택적으로 복제 할 요소를 포함해야합니다. 복제 할이 요소를 지정하지 않으면 빈 요소가 사용됩니다. &lt;em&gt;kw&lt;/em&gt; 는 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="f944010bcb8e6d344f99a27fdf59f6cb446f5d23" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;image&amp;rdquo; is used, &lt;em&gt;args&lt;/em&gt; should contain the default image name followed by statespec/value pairs (this is the imagespec), and &lt;em&gt;kw&lt;/em&gt; may have the following options:</source>
          <target state="translated">&quot;image&quot;를 사용하는 경우 &lt;em&gt;args&lt;/em&gt; 는 기본 이미지 이름 뒤에 statespec / value 쌍 (imagespec)을 포함해야하며 &lt;em&gt;kw&lt;/em&gt; 는 다음 옵션을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14802572f6d100ba7a53b320def8eef6093842e7" translate="yes" xml:space="preserve">
          <source>If 0 bytes are returned, and &lt;em&gt;size&lt;/em&gt; was not 0, this indicates end of file. If the object is in non-blocking mode and no bytes are available, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">0 바이트가 리턴되고 &lt;em&gt;크기&lt;/em&gt; 가 0이 아닌 경우 파일의 끝을 나타냅니다. 객체가 비 블로킹 모드에 있고 사용 가능한 바이트가 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c02c4acde96b174846ba50faba8ca5546f01adef" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#asyncio.loop.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; is called before &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;run_forever()&lt;/code&gt;&lt;/a&gt; is called, the loop will poll the I/O selector once with a timeout of zero, run all callbacks scheduled in response to I/O events (and those that were already scheduled), and then exit.</source>
          <target state="translated">경우 &lt;a href=&quot;#asyncio.loop.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 전에 호출된다 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;run_forever()&lt;/code&gt; &lt;/a&gt; 라고, 루프가 I에 대한 응답으로 예정된 모든 콜백을 실행, 0의 타임 아웃 번 I / O 선택을 폴링 / O 이벤트 (이미 계획 한 것), 그리고 그런 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="05e8eca43c8b5bd5bc36cb778852fb6cfcbe90e4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#asyncio.loop.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; is called while &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;run_forever()&lt;/code&gt;&lt;/a&gt; is running, the loop will run the current batch of callbacks and then exit. Note that new callbacks scheduled by callbacks will not run in this case; instead, they will run the next time &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;run_forever()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#asyncio.loop.run_until_complete&quot;&gt;&lt;code&gt;run_until_complete()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">경우 &lt;a href=&quot;#asyncio.loop.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 동안이라고 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;run_forever()&lt;/code&gt; &lt;/a&gt; 실행되고, 루프는 현재 콜백 배치 한 후 종료를 실행합니다. 이 경우 콜백으로 예약 된 새 콜백은 실행되지 않습니다. 대신 다음에 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;run_forever()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#asyncio.loop.run_until_complete&quot;&gt; &lt;code&gt;run_until_complete()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1678f57ce6088308b33179279e335b67a5b9075" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#cmdoption-timeit-n&quot;&gt;&lt;code&gt;-n&lt;/code&gt;&lt;/a&gt; is not given, a suitable number of loops is calculated by trying successive powers of 10 until the total time is at least 0.2 seconds.</source>
          <target state="translated">경우 &lt;a href=&quot;#cmdoption-timeit-n&quot;&gt; &lt;code&gt;-n&lt;/code&gt; 이&lt;/a&gt; 주어지지 루프의 적절한 수는 총 시간은 적어도 0.2 초까지 (10)의 연속적인 힘을 시도하여 계산된다.</target>
        </trans-unit>
        <trans-unit id="582ba31da26c45d3b235552a7d51ae121320d8b0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;None&lt;/code&gt;, it is called without arguments to provide a default value for the given &lt;em&gt;key&lt;/em&gt;, this value is inserted in the dictionary for the &lt;em&gt;key&lt;/em&gt;, and returned.</source>
          <target state="translated">&lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 주어진 &lt;em&gt;키에&lt;/em&gt; 대한 기본값을 제공하기 위해 인수없이 호출되며 ,이 값은 &lt;em&gt;키&lt;/em&gt; 의 사전에 삽입되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9cde1ada951bb0301fa7df4ab6c0c9e7ef70a81d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; is used just as a simple decorator with no parameters, it acts as if it has the default values documented in this signature. That is, these three uses of &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; are equivalent:</source>
          <target state="translated">경우 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 바로 매개 변수없이 간단한 장식으로 사용, 그것은이 서명에 설명 된 기본 값이있는 경우 역할을합니다. 즉, 다음 세 가지 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06790524e2c9624dd66bf4e80174a491c71a47d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance &lt;em&gt;d&lt;/em&gt; is naive, this is the same as &lt;code&gt;d.timetuple()&lt;/code&gt; except that &lt;code&gt;tm_isdst&lt;/code&gt; is forced to 0 regardless of what &lt;code&gt;d.dst()&lt;/code&gt; returns. DST is never in effect for a UTC time.</source>
          <target state="translated">&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스 &lt;em&gt;d&lt;/em&gt; 가 순진한 경우 &lt;code&gt;d.dst()&lt;/code&gt; 반환 하는 내용에 관계없이 &lt;code&gt;tm_isdst&lt;/code&gt; 가 0으로 설정 된다는 점을 제외하면 &lt;code&gt;d.timetuple()&lt;/code&gt; 과 같습니다 . DST는 UTC 시간 동안 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e0c40c35052a5f701990cfae358459eb5e545e6" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.dst(self)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.dst(self)&lt;/code&gt; , 후자는 반환하지 않을 경우 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 일일보다 작은 크기로 개체를.</target>
        </trans-unit>
        <trans-unit id="f8caa4545a15722244f6b65e83c6c19542a6ab44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.tzname(self)&lt;/code&gt;, raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a string object,</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 이&lt;/a&gt; 있다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.tzname(self)&lt;/code&gt; 후자는 반환하지 않는 경우, 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 문자열 객체를,</target>
        </trans-unit>
        <trans-unit id="009d47938690bf44a446761016995961a2f2f6ff" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.utcoffset(self)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.utcoffset(self)&lt;/code&gt; , 후자는 반환하지 않을 경우 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 일일보다 작은 크기로 개체를.</target>
        </trans-unit>
        <trans-unit id="aa3f64ecaf560bd1451a3c877d9f543b04fcbe06" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; does not return &lt;code&gt;None&lt;/code&gt;, a string is appended, giving the UTC offset:</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 문자열은 UTC 오프셋을주는 추가됩니다 :</target>
        </trans-unit>
        <trans-unit id="e7fddffca5059ab1879694ef1968947dba191d2e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.dst(None)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt;, or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.dst(None)&lt;/code&gt; , 후자는 반환하지 않습니다 경우 예외 제기 &lt;code&gt;None&lt;/code&gt; , 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 작은 일일 이상의 크기를 가진 개체를.</target>
        </trans-unit>
        <trans-unit id="f9853982dbae22fa9c2c2cdec0356caa1586b4dd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.tzname(None)&lt;/code&gt;, or raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a string object.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 가&lt;/a&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.tzname(None)&lt;/code&gt; , 또는 예외가 발생 후자는 반환하지 않습니다 경우 &lt;code&gt;None&lt;/code&gt; 또는 문자열 개체를.</target>
        </trans-unit>
        <trans-unit id="01eb5a0fb7bdeeed7668f56b440e9918155d69bd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.utcoffset(None)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.utcoffset(None)&lt;/code&gt; , 후자는 반환하지 않을 경우 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 일일보다 작은 크기로 개체를.</target>
        </trans-unit>
        <trans-unit id="bf4cf586488675e2ebba410a57aa3e353d6385cd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; does not return &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt;&lt;code&gt;dst()&lt;/code&gt;&lt;/a&gt; should not return &lt;code&gt;None&lt;/code&gt; either.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt; &lt;code&gt;dst()&lt;/code&gt; &lt;/a&gt; 반환하지 안 &lt;code&gt;None&lt;/code&gt; 하나를.</target>
        </trans-unit>
        <trans-unit id="9011595808dcf4d293ad800bfc6c37bf4507550c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#decimal.setcontext&quot;&gt;&lt;code&gt;setcontext()&lt;/code&gt;&lt;/a&gt; has not been called before &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; will automatically create a new context for use in the current thread.</source>
          <target state="translated">경우 &lt;a href=&quot;#decimal.setcontext&quot;&gt; &lt;code&gt;setcontext()&lt;/code&gt; &lt;/a&gt; 전에 호출되지 않은 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; , 다음 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 자동으로 현재 스레드에서 사용하기위한 새로운 컨텍스트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="21415457c1d139549ef89f97140496dfdfab045c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;8bit&lt;/code&gt;, non-ASCII binary data is converted back into bytes. Headers with binary data are not refolded, regardless of the &lt;code&gt;refold_header&lt;/code&gt; setting, since there is no way to know whether the binary data consists of single byte characters or multibyte characters.</source>
          <target state="translated">경우 &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 이&lt;/a&gt; 입니다 &lt;code&gt;8bit&lt;/code&gt; 아닌 ASCII 이진 데이터를 바이트로 변환 돌아왔다. 이진 데이터가 단일 바이트 문자인지 멀티 바이트 문자로 구성되어 있는지 알 수있는 방법이 없기 때문에 &lt;code&gt;refold_header&lt;/code&gt; 설정에 관계없이 이진 데이터가있는 헤더는 다시 접히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4c20a0126fb2339f46306a2ced37ad168e88f98" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#gc.DEBUG_SAVEALL&quot;&gt;&lt;code&gt;DEBUG_SAVEALL&lt;/code&gt;&lt;/a&gt; is set, then all unreachable objects will be added to this list rather than freed.</source>
          <target state="translated">경우 &lt;a href=&quot;#gc.DEBUG_SAVEALL&quot;&gt; &lt;code&gt;DEBUG_SAVEALL&lt;/code&gt; 이&lt;/a&gt; 설정되어, 모든 도달 할 수없는 개체가이 목록에 추가보다는 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="5b0b664a2e9905229df91a5d790cbb723cbe0e9d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt;&lt;code&gt;domain_return_ok()&lt;/code&gt;&lt;/a&gt; returns true for the cookie domain, &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt; is called for the cookie path. Otherwise, &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt; are never called for that cookie domain. If &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt; returns true, &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt; is called with the &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; object itself for a full check. Otherwise, &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt; is never called for that cookie path.</source>
          <target state="translated">경우 &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt; &lt;code&gt;domain_return_ok()&lt;/code&gt; &lt;/a&gt; 쿠키 도메인에 대해 true를 반환 &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; 쿠키 경로라고합니다. 그렇지 않으면 해당 쿠키 도메인에 대해 &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않습니다. 경우 &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; true를 반환 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; 불려 &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 전체 검사에 대한 개체 자체. 그렇지 않으면 해당 쿠키 경로에 대해 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9948b67acbf113dce0d3f91e1cc50fba431b125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;spec.loader.create_module&lt;/code&gt;&lt;/a&gt; does not return &lt;code&gt;None&lt;/code&gt;, then any pre-existing attributes will not be reset. Also, no &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; will be raised if triggered while accessing &lt;strong&gt;spec&lt;/strong&gt; or setting an attribute on the module.</source>
          <target state="translated">경우 &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;spec.loader.create_module&lt;/code&gt; 는&lt;/a&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 그 다음 어떤 사전 기존의 속성이 초기화되지 않습니다. 또한 &lt;strong&gt;스펙에&lt;/strong&gt; 액세스 하거나 모듈에서 속성을 설정하는 동안 트리거되면 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 가 발생 하지 않습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d25bfcae1ced7878a90923a3bbc911ce54352476" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#importlib.abc.MetaPathFinder.find_spec&quot;&gt;&lt;code&gt;find_spec()&lt;/code&gt;&lt;/a&gt; is defined, backwards-compatible functionality is provided.</source>
          <target state="translated">경우 &lt;a href=&quot;#importlib.abc.MetaPathFinder.find_spec&quot;&gt; &lt;code&gt;find_spec()&lt;/code&gt; &lt;/a&gt; 정의되어, 이전 버전과 호환 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f015a253da746e1e2dd5daec6dd710fa4d38756c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#importlib.abc.PathEntryFinder.find_spec&quot;&gt;&lt;code&gt;find_spec()&lt;/code&gt;&lt;/a&gt; is defined then backwards-compatible functionality is provided.</source>
          <target state="translated">&lt;a href=&quot;#importlib.abc.PathEntryFinder.find_spec&quot;&gt; &lt;code&gt;find_spec()&lt;/code&gt; &lt;/a&gt; 이 정의 되면 이전 버전과 호환되는 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9b326804ec799be875e38c1a2930a4c25cd8cef4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#memoryview.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; is one of the native format specifiers from the &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module, indexing with an integer or a tuple of integers is also supported and returns a single &lt;em&gt;element&lt;/em&gt; with the correct type. One-dimensional memoryviews can be indexed with an integer or a one-integer tuple. Multi-dimensional memoryviews can be indexed with tuples of exactly &lt;em&gt;ndim&lt;/em&gt; integers where &lt;em&gt;ndim&lt;/em&gt; is the number of dimensions. Zero-dimensional memoryviews can be indexed with the empty tuple.</source>
          <target state="translated">경우 &lt;a href=&quot;#memoryview.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; 로부터 기본 형식 지정자 중 하나 인 &lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 도 지원됩니다 정수 또는 정수의 튜플로 색인 모듈, 단일 반환 &lt;em&gt;요소&lt;/em&gt; 올바른 유형을. 1 차원 메모 리뷰는 정수 또는 1 정수 터플을 사용하여 인덱스 할 수 있습니다. 다차원 메모 리뷰는 정확히 &lt;em&gt;ndim&lt;/em&gt; 정수의 튜플을 사용하여 인덱스 할 수 있습니다. 여기서 &lt;em&gt;ndim&lt;/em&gt; 은 차원의 수입니다. 빈 튜플을 사용하여 0 차원 메모리 뷰를 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e778bfa133d88df69f23727150ca404e8c30f386" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#object.__getstate__&quot;&gt;&lt;code&gt;__getstate__()&lt;/code&gt;&lt;/a&gt; returns a false value, the &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt; method will not be called upon unpickling.</source>
          <target state="translated">경우 &lt;a href=&quot;#object.__getstate__&quot;&gt; &lt;code&gt;__getstate__()&lt;/code&gt; &lt;/a&gt; false 값을 반환의 &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; 메소드는 unpickling에 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3e787ee0d7f7e8be6223781b46958dd72b0562d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; is not provided, a modified copy of this mapping may be passed to the appropriate process-creation functions to cause child processes to use a modified environment.</source>
          <target state="translated">경우 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 제공되지 않고,이 맵핑의 수정 된 사본은 자식 프로세스는 수정 된 환경을 사용하게 할 수있는 적절한 프로세스 생성 함수에 전달 될 수있다.</target>
        </trans-unit>
        <trans-unit id="475a717000de0e2b757369a1ff16dc88df2752ce" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt;&lt;code&gt;persistent_id()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;None&lt;/code&gt;, &lt;em&gt;obj&lt;/em&gt; is pickled as usual. Any other value causes &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; to emit the returned value as a persistent ID for &lt;em&gt;obj&lt;/em&gt;. The meaning of this persistent ID should be defined by &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt;&lt;code&gt;Unpickler.persistent_load()&lt;/code&gt;&lt;/a&gt;. Note that the value returned by &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt;&lt;code&gt;persistent_id()&lt;/code&gt;&lt;/a&gt; cannot itself have a persistent ID.</source>
          <target state="translated">경우 &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt; &lt;code&gt;persistent_id()&lt;/code&gt; &lt;/a&gt; 를 반환 &lt;code&gt;None&lt;/code&gt; , &lt;em&gt;OBJ는&lt;/em&gt; 평소와 같이 절인된다. 다른 값을 사용하면 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 가 반환 된 값을 &lt;em&gt;obj&lt;/em&gt; 의 영구 ID로 내 &lt;em&gt;보냅니다&lt;/em&gt; . 이 영구 ID의 의미는 &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt; &lt;code&gt;Unpickler.persistent_load()&lt;/code&gt; &lt;/a&gt; 의해 정의되어야합니다 . &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt; &lt;code&gt;persistent_id()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 값 자체는 지속적 ID를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6eb3f096073e3576908ab443228929f5d208920" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt;&lt;code&gt;whitespace_split&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;, any character not declared to be a word character, whitespace, or a quote will be returned as a single-character token. If it is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will only split words in whitespaces;</source>
          <target state="translated">경우 &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt; &lt;code&gt;whitespace_split&lt;/code&gt; &lt;/a&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 모든 문자는 단어 문자, 공백 선언, 또는 따옴표는 단일 문자 토큰으로 반환하지 않습니다. 이 경우 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 공백 만 분할 말 것이다;</target>
        </trans-unit>
        <trans-unit id="18eeb508085769b9d25fd4a01e99172032cc7b0e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#socket.getdefaulttimeout&quot;&gt;&lt;code&gt;getdefaulttimeout()&lt;/code&gt;&lt;/a&gt; is not &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, sockets returned by the &lt;a href=&quot;#socket.socket.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; method inherit that timeout. Otherwise, the behaviour depends on settings of the listening socket:</source>
          <target state="translated">경우 &lt;a href=&quot;#socket.getdefaulttimeout&quot;&gt; &lt;code&gt;getdefaulttimeout()&lt;/code&gt; &lt;/a&gt; 되지 않습니다 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 소켓에 의해 반환 &lt;a href=&quot;#socket.socket.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 메서드 상속 제한 시간이. 그렇지 않으면 동작은 청취 소켓의 설정에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1595b340863f62eada1ad0f3d8d078a3995d33d4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.CompletedProcess.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; is non-zero, raise a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.CompletedProcess.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 가 0이 아닌 경우 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9911da4fc9a0f7d03f013c47079f09932dd87298" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESHOWWINDOW&quot;&gt;&lt;code&gt;STARTF_USESHOWWINDOW&lt;/code&gt;&lt;/a&gt;, this attribute can be any of the values that can be specified in the &lt;code&gt;nCmdShow&lt;/code&gt; parameter for the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms633548(v=vs.85).aspx&quot;&gt;ShowWindow&lt;/a&gt; function, except for &lt;code&gt;SW_SHOWDEFAULT&lt;/code&gt;. Otherwise, this attribute is ignored.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESHOWWINDOW&quot;&gt; &lt;code&gt;STARTF_USESHOWWINDOW&lt;/code&gt; &lt;/a&gt; 이 속성이 지정 될 수있는 값 중 하나 일 수 &lt;code&gt;nCmdShow&lt;/code&gt; 의 위한 매개 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms633548(v=vs.85).aspx&quot;&gt;이 ShowWindow를&lt;/a&gt; 제외한 기능 &lt;code&gt;SW_SHOWDEFAULT&lt;/code&gt; 를 . 그렇지 않으면이 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="17afb4874f7b74c33ba1f0a22fdede7fd8bbd2cb" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt;, this attribute is the standard error handle for the process. Otherwise, this attribute is ignored and the default for standard error is the console window&amp;rsquo;s buffer.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; &lt;/a&gt; ,이 속성은 프로세스의 표준 오류 핸들입니다. 그렇지 않으면이 속성은 무시되고 표준 오류의 기본값은 콘솔 창의 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="8fb5e8f987ab98575e4a5bf2c5bf6153ecdee636" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt;, this attribute is the standard input handle for the process. If &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt; is not specified, the default for standard input is the keyboard buffer.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; &lt;/a&gt; ,이 속성은 프로세스의 표준 입력 핸들입니다. 경우 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; 가&lt;/a&gt; 지정되지 않은, 표준 입력의 기본은 키보드 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="2459b411dc5f72300ea61c717f86aac25d4f6c97" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt;, this attribute is the standard output handle for the process. Otherwise, this attribute is ignored and the default for standard output is the console window&amp;rsquo;s buffer.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; &lt;/a&gt; ,이 속성은 프로세스의 표준 출력 핸들입니다. 그렇지 않으면이 속성이 무시되고 표준 출력의 기본값은 콘솔 창의 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="0a30adf3ca5293f47c1189f27a38687cc18999e3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; has not been called prior to the call to &lt;a href=&quot;#module-syslog&quot;&gt;&lt;code&gt;syslog()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;openlog()&lt;/code&gt; will be called with no arguments.</source>
          <target state="translated">경우 &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 이전에 호출에 호출되지 &lt;a href=&quot;#module-syslog&quot;&gt; &lt;code&gt;syslog()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;openlog()&lt;/code&gt; 인수없이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fa24a5d03ba78592ea146659696b16ffe43b9a77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#textwrap.TextWrapper.expand_tabs&quot;&gt;&lt;code&gt;expand_tabs&lt;/code&gt;&lt;/a&gt; is false and &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt;&lt;code&gt;replace_whitespace&lt;/code&gt;&lt;/a&gt; is true, each tab character will be replaced by a single space, which is &lt;em&gt;not&lt;/em&gt; the same as tab expansion.</source>
          <target state="translated">경우 &lt;a href=&quot;#textwrap.TextWrapper.expand_tabs&quot;&gt; &lt;code&gt;expand_tabs&lt;/code&gt; 가&lt;/a&gt; 거짓이고 &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt; &lt;code&gt;replace_whitespace&lt;/code&gt; 는&lt;/a&gt; 사실, 각 탭 문자는 하나의 공간으로 대체 될 것이다 &lt;em&gt;되지&lt;/em&gt; 탭 확장과 같은.</target>
        </trans-unit>
        <trans-unit id="401fb6d910d793ac1a606938fd5c1e335d50c524" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt;&lt;code&gt;replace_whitespace&lt;/code&gt;&lt;/a&gt; is false, newlines may appear in the middle of a line and cause strange output. For this reason, text should be split into paragraphs (using &lt;a href=&quot;stdtypes#str.splitlines&quot;&gt;&lt;code&gt;str.splitlines()&lt;/code&gt;&lt;/a&gt; or similar) which are wrapped separately.</source>
          <target state="translated">경우 &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt; &lt;code&gt;replace_whitespace&lt;/code&gt; 은&lt;/a&gt; 거짓, 뉴 라인은 라인의 중간에 나타나는 이상한 출력의 원인이 될 수 있습니다. 이러한 이유로 텍스트는 단락으로 분리되어야하며 ( &lt;a href=&quot;stdtypes#str.splitlines&quot;&gt; &lt;code&gt;str.splitlines()&lt;/code&gt; &lt;/a&gt; 또는 이와 유사한 방법을 사용하여 ) 별도로 감싸 야합니다.</target>
        </trans-unit>
        <trans-unit id="5440dd0e7910d37a11dd3863c46d6c4daaf6a686" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; fails, meaning that &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt;&lt;code&gt;tearDown()&lt;/code&gt;&lt;/a&gt; is not called, then any cleanup functions added will still be called.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 즉, 실패 &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt; &lt;code&gt;tearDown()&lt;/code&gt; &lt;/a&gt; 호출되어 있지 않은 경우, 추가 된 정리 기능은 여전히 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="11e9aa6a0b626486b9748ffe7b0fd4868dfa4de3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; succeeded, &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt;&lt;code&gt;tearDown()&lt;/code&gt;&lt;/a&gt; will be run whether the test method succeeded or not.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 성공 &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt; &lt;code&gt;tearDown()&lt;/code&gt; &lt;/a&gt; 시험 방법의 성공 여부에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2f754fa973712c4da8b8b5a253b88e6d78c5436a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.TestCase.setUpClass&quot;&gt;&lt;code&gt;setUpClass()&lt;/code&gt;&lt;/a&gt; fails, meaning that &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt;&lt;code&gt;tearDownClass()&lt;/code&gt;&lt;/a&gt; is not called, then any cleanup functions added will still be called.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.TestCase.setUpClass&quot;&gt; &lt;code&gt;setUpClass()&lt;/code&gt; &lt;/a&gt; 의미 실패 &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt; &lt;code&gt;tearDownClass()&lt;/code&gt; &lt;/a&gt; 호출되어 있지 않은 경우, 추가 된 정리 기능은 여전히 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a56b554a11ada97428e4f6b7fc43139d2ce66dfd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; is set then it will be called after the call has been recorded, so if &lt;code&gt;side_effect&lt;/code&gt; raises an exception the call is still recorded.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; 가&lt;/a&gt; 다음 설정되어 통화가 기록 된 후에는 그렇다면, 호출 될 &lt;code&gt;side_effect&lt;/code&gt; 는 통화가 여전히 기록되는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0daae280f7ddf940c3563e2d3ab6d3e152cdba08" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; is used as a context manager, the value returned by the context manager is a dictionary where created mocks are keyed by name:</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 콘텍스트 관리자로서 사용되는, 콘텍스트 관리자에 의해 반환 된 값이 생성 모의 객체 이름 키잉되는 사전이다 :</target>
        </trans-unit>
        <trans-unit id="7ea197c7086cd8e399adabc6fac58ed3712540b4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt;&lt;code&gt;origin_server&lt;/code&gt;&lt;/a&gt; is true, this string attribute is used to set the HTTP version of the response set to the client. It defaults to &lt;code&gt;&quot;1.0&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt; &lt;code&gt;origin_server&lt;/code&gt; 는&lt;/a&gt; 사실이 문자열 속성은 클라이언트로 설정 응답의 HTTP 버전을 설정하는 데 사용됩니다. 기본값은 &lt;code&gt;&quot;1.0&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="273da1adde160734ed233b111094a596981762d8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt;&lt;code&gt;buffer_text&lt;/code&gt;&lt;/a&gt; is enabled, the number of bytes stored in the buffer. These bytes represent UTF-8 encoded text. This attribute has no meaningful interpretation when &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt;&lt;code&gt;buffer_text&lt;/code&gt;&lt;/a&gt; is false.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt; &lt;code&gt;buffer_text&lt;/code&gt; &lt;/a&gt; 가 사용 가능한 경우 버퍼에 저장된 바이트 수입니다. 이 바이트는 UTF-8로 인코딩 된 텍스트를 나타냅니다. &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt; &lt;code&gt;buffer_text&lt;/code&gt; 일&lt;/a&gt; 때이 속성은 의미가 없습니다. 가 false 인 .</target>
        </trans-unit>
        <trans-unit id="5969c407e8a5884e8705a2163a3f42bcc5ab4f5f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, any defects encountered will be raised as errors. If &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; (the default), defects will be passed to the &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt;&lt;code&gt;register_defect()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 발생하는 모든 결함이 오류로 발생합니다. 경우 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; (기본), 결함이 전달됩니다 &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt; &lt;code&gt;register_defect()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="fef1119ed2a7515183a2fa43ee13d86ddee0c639" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, lines starting with &lt;em&gt;&amp;ldquo;From &amp;ldquo;&lt;/em&gt; in the body are escaped by putting a &lt;code&gt;&amp;gt;&lt;/code&gt; in front of them. This parameter is used when the message is being serialized by a generator. Default: &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 본문에서 &lt;em&gt;&quot;From&quot;&lt;/em&gt; 으로 시작하는 행 은 앞에 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 넣어서 이스케이프 합니다. 이 매개 변수는 생성자가 메시지를 직렬화 할 때 사용됩니다. 기본값 : &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3847911e0aa3faa42e57a768e6d9c9134161e5d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; is not explicit defined, or if it is set to &lt;code&gt;None&lt;/code&gt;, then &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;may&lt;/em&gt; add an implicit &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method. Although not recommended, you can force &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; to create a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method with &lt;code&gt;unsafe_hash=True&lt;/code&gt;. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.</source>
          <target state="translated">만약 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 명시 적으로 정의되지 않은 경우, 또는로 설정되어있는 경우 &lt;code&gt;None&lt;/code&gt; , 다음 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 할 수 있습니다&lt;/em&gt; 암시 추가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메소드를. 권장되지는 않지만, &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;unsafe_hash=True&lt;/code&gt; 로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드 를 만들 도록 할 수 있습니다 . 클래스가 논리적으로 변경 불가능하지만 변경 될 수있는 경우가 이에 해당합니다. 이것은 특수한 사용 사례이므로 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="e04c3d63f8f0b660bf5ea6424df45f9aabfeea2f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; is defined the value of the enum member will be passed to those methods:</source>
          <target state="translated">경우 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 정의 된 열거 부재의 값은 그 방법으로 전달 될 것이다 :</target>
        </trans-unit>
        <trans-unit id="2a87d22d7e499f0ee61056877808ca82fe9ec45b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data is passed in, the result will also contain only &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data. If &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; data is passed in, the result will contain only &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; data.</source>
          <target state="translated">경우 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 데이터가 전달되고, 결과는 단지 포함 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 을&lt;/a&gt; 데이터를. 경우 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 데이터가 전달되고, 결과는 포함 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 의 데이터를.</target>
        </trans-unit>
        <trans-unit id="aed3bfed2c45e20b453e673260527b4602b0fa6c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; is passed in, it is returned unchanged. Otherwise &lt;a href=&quot;#os.PathLike.__fspath__&quot;&gt;&lt;code&gt;__fspath__()&lt;/code&gt;&lt;/a&gt; is called and its value is returned as long as it is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. In all other cases, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경우 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 전달, 그것은 변화가 반환됩니다. 그렇지 않으면 &lt;a href=&quot;#os.PathLike.__fspath__&quot;&gt; &lt;code&gt;__fspath__()&lt;/code&gt; &lt;/a&gt; 가 호출되고 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 인 경우 해당 값이 반환됩니다 . 다른 모든 경우에는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="caf032867f63b3726a28645ba313d2c3e89d2da5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, or &lt;code&gt;r&lt;/code&gt; is used, all arguments are placed in &lt;code&gt;sys.argv[1:...]&lt;/code&gt; and &lt;code&gt;sys.argv[0]&lt;/code&gt; is set to &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;'-c'&lt;/code&gt;, or &lt;code&gt;'-r'&lt;/code&gt;. No editor window is opened, even if that is the default set in the Options dialog.</source>
          <target state="translated">경우 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , 또는 &lt;code&gt;r&lt;/code&gt; 사용되어, 모든 인수에 배치 &lt;code&gt;sys.argv[1:...]&lt;/code&gt; 및 &lt;code&gt;sys.argv[0]&lt;/code&gt; 으로 설정 &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;'-c'&lt;/code&gt; 또는 &lt;code&gt;'-r'&lt;/code&gt; . 옵션 대화 상자에서 기본값이 설정되어 있어도 편집기 창이 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21627f7daf7e31d0ed2c5b5ad287f10a5bba0e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; is supplied at the command line, the ArgumentParser help will be printed:</source>
          <target state="translated">경우 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 이 명령 줄에서 공급되면, ArgumentParser 도움이 인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="c7a9c72b700c6c23304dc413d4be9c57f931cd8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A &amp;lt;: Complex&lt;/code&gt; and &lt;code&gt;B &amp;lt;: Real&lt;/code&gt; without sharing any other knowledge, then the appropriate shared operation is the one involving the built in &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt;, and both &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; s land there, so &lt;code&gt;a+b
== b+a&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;A &amp;lt;: Complex&lt;/code&gt; 및 &lt;code&gt;B &amp;lt;: Real&lt;/code&gt; 다른 지식을 공유하지 않고, 다음 해당 공유 작업이이 내장 관련된 하나입니다 &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; , 두 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 이의 땅, 그래서 &lt;code&gt;a+b == b+a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b801947cfd092d953ccf6831d669c267f173f35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; defines an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; which accepts &lt;code&gt;b&lt;/code&gt;, all is well.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 수용 &lt;code&gt;b&lt;/code&gt; 모두 잘.</target>
        </trans-unit>
        <trans-unit id="ed23788452e71ff7756d04b76ef0e4ea7b1ec3ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; falls back to the boilerplate code, and it were to return a value from &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, we&amp;rsquo;d miss the possibility that &lt;code&gt;B&lt;/code&gt; defines a more intelligent &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt;, so the boilerplate should return &lt;a href=&quot;constants#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;. (Or &lt;code&gt;A&lt;/code&gt; may not implement &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; at all.)</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 가 다시 상용구 코드에 떨어지면, 그것은에서 값을 반환했다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; , 우리는 가능성 그리워하는 &lt;code&gt;B&lt;/code&gt; 가 더 지능적인 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 상용구가 반환해야하므로, &lt;a href=&quot;constants#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; . 또는 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 를 전혀 구현하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c99da1870c17ce7d3d3018a203be0bafc8dccfae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B &amp;lt;: A&lt;/code&gt;, Python tries &lt;code&gt;B.__radd__&lt;/code&gt; before &lt;code&gt;A.__add__&lt;/code&gt;. This is ok, because it was implemented with knowledge of &lt;code&gt;A&lt;/code&gt;, so it can handle those instances before delegating to &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;B &amp;lt;: A&lt;/code&gt; , 파이썬은 시도 &lt;code&gt;B.__radd__&lt;/code&gt; 하기 전에 &lt;code&gt;A.__add__&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; 에 대한 지식으로 구현 되었으므로 &lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; 에&lt;/a&gt; 위임하기 전에 해당 인스턴스를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0b502541a012336c972c1fd26bc2444183bb6c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, follow &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;, supporting non-ASCII characters in headers by encoding them as &amp;ldquo;encoded words&amp;rdquo;. If &lt;code&gt;True&lt;/code&gt;, follow &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; and use &lt;code&gt;utf-8&lt;/code&gt; encoding for headers. Messages formatted in this way may be passed to SMTP servers that support the &lt;code&gt;SMTPUTF8&lt;/code&gt; extension (&lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 인 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5322에&lt;/strong&gt;&lt;/a&gt; 따라 헤더에서 비 ASCII 문자를&amp;ldquo;인코딩 된 단어&amp;rdquo;로 인코딩하여 지원하십시오. &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6532를&lt;/strong&gt;&lt;/a&gt; 따르고 헤더에 &lt;code&gt;utf-8&lt;/code&gt; 인코딩을 사용하십시오 . 이러한 방식으로 형식화 된 메시지는 &lt;code&gt;SMTPUTF8&lt;/code&gt; 확장 을 지원하는 SMTP 서버 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; ) 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0aa57a54bd4c37d36f82fb559a78314f58cdaa4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SMTPUTF8&lt;/code&gt; is included in &lt;em&gt;mail_options&lt;/em&gt;, and the server supports it, &lt;em&gt;from_addr&lt;/em&gt; and &lt;em&gt;to_addrs&lt;/em&gt; may contain non-ASCII characters.</source>
          <target state="translated">경우 &lt;code&gt;SMTPUTF8&lt;/code&gt; 가 포함되어 &lt;em&gt;mail_options&lt;/em&gt; 하고 서버에서 지원, &lt;em&gt;from_addr&lt;/em&gt; 및 &lt;em&gt;to_addrs는&lt;/em&gt; 비 ASCII 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5dc45558ebcea6d610bad35d84ea39326606ff5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TOS&lt;/code&gt; is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator-iterator&quot;&gt;generator iterator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; object it is left as is. Otherwise, implements &lt;code&gt;TOS = iter(TOS)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;TOS&lt;/code&gt; 는 A는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator-iterator&quot;&gt;발전기 반복자&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 객체 그대로 남아 있습니다. 그렇지 않으면 &lt;code&gt;TOS = iter(TOS)&lt;/code&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="711424b518e686db6f3128ec091800680cf2d7e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, tokens will only be split in whitespaces. This is useful, for example, for parsing command lines with &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt;, getting tokens in a similar way to shell arguments. When used in combination with &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt;&lt;code&gt;punctuation_chars&lt;/code&gt;&lt;/a&gt;, tokens will be split on whitespace in addition to those characters.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 토큰은 공백으로 만 분할됩니다. 예를 들어, &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; 로&lt;/a&gt; 명령 행을 구문 분석 하고 쉘 인수와 유사한 방식으로 토큰을 가져 오는 데 유용합니다 . &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt; &lt;code&gt;punctuation_chars&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 토큰은 해당 문자 외에도 공백으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="17f7ba8d172e5c3d522143611d4e644d4d525629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WIFEXITED(status)&lt;/code&gt; is true, return the integer parameter to the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/exit(2)&quot;&gt;exit(2)&lt;/a&gt;&lt;/em&gt; system call. Otherwise, the return value is meaningless.</source>
          <target state="translated">경우 &lt;code&gt;WIFEXITED(status)&lt;/code&gt; 참의로 정수 매개 변수를 반환 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/exit(2)&quot;&gt;출구 (2)&lt;/a&gt;&lt;/em&gt; 시스템 호출. 그렇지 않으면 반환 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eab713d9f34725181e53e9763d51930268ca8cbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arcname&lt;/code&gt; (or &lt;code&gt;filename&lt;/code&gt;, if &lt;code&gt;arcname&lt;/code&gt; is not given) contains a null byte, the name of the file in the archive will be truncated at the null byte.</source>
          <target state="translated">경우 &lt;code&gt;arcname&lt;/code&gt; (또는 &lt;code&gt;filename&lt;/code&gt; , 경우 &lt;code&gt;arcname&lt;/code&gt; 이 제공되지 않음) 널 바이트를 포함, 아카이브에서 파일의 이름은 널 바이트에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="fe6d01c5807b14dd92c652de9261e96f2f0d4073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an instance of &lt;a href=&quot;#multiprocessing.BufferTooShort&quot;&gt;&lt;code&gt;BufferTooShort&lt;/code&gt;&lt;/a&gt; then &lt;code&gt;e.args[0]&lt;/code&gt; will give the message as a byte string.</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 의 인스턴스 &lt;a href=&quot;#multiprocessing.BufferTooShort&quot;&gt; &lt;code&gt;BufferTooShort&lt;/code&gt; 는&lt;/a&gt; 다음 &lt;code&gt;e.args[0]&lt;/code&gt; , 바이트의 문자열로 메시지를 제공한다.</target>
        </trans-unit>
        <trans-unit id="700a5fc739f38418d59d1b88b3aa6552134ba97a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;frozen&lt;/code&gt; are both true, by default &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; will generate a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method for you. If &lt;code&gt;eq&lt;/code&gt; is true and &lt;code&gt;frozen&lt;/code&gt; is false, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; will be set to &lt;code&gt;None&lt;/code&gt;, marking it unhashable (which it is, since it is mutable). If &lt;code&gt;eq&lt;/code&gt; is false, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; will be left untouched meaning the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method of the superclass will be used (if the superclass is &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, this means it will fall back to id-based hashing).</source>
          <target state="translated">경우 &lt;code&gt;eq&lt;/code&gt; 및 &lt;code&gt;frozen&lt;/code&gt; 기본적으로 사실 모두 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 생성 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 당신을위한 방법을. 경우 &lt;code&gt;eq&lt;/code&gt; 사실과 &lt;code&gt;frozen&lt;/code&gt; 거짓, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 &lt;code&gt;None&lt;/code&gt; 은 unhashable (이 인이 변경할 수 있기 때문에) 표시. 경우 &lt;code&gt;eq&lt;/code&gt; 거짓, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 의미 그대로 남아있을 것이다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 상위 클래스의 메소드 (슈퍼 인 경우 사용되는 &lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; ,이 수단은 ID 기반 해싱 다시 떨어질 것이다).</target>
        </trans-unit>
        <trans-unit id="0b14e032175d28c1ba6eb0b6e2412729c87fd343" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename.py&lt;/code&gt; is specified its contents are tokenized to stdout. Otherwise, tokenization is performed on stdin.</source>
          <target state="translated">경우 &lt;code&gt;filename.py&lt;/code&gt; 가 지정되어 그 내용은 표준 출력 토큰 화된다. 그렇지 않으면, stdin에서 토큰 화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b78ebbf676987b9b08d03411af825fbaec6187a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gather()&lt;/code&gt; is &lt;em&gt;cancelled&lt;/em&gt;, all submitted awaitables (that have not completed yet) are also &lt;em&gt;cancelled&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;code&gt;gather()&lt;/code&gt; 되어 &lt;em&gt;취소&lt;/em&gt; , (아직 완료하지 않은 경우) 모든 제출 awaitables도 있습니다 &lt;em&gt;취소&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="98e2ca390d09cb4c5d93c787d1a1e77d3b50a6b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;load_tests&lt;/code&gt; exists then discovery does &lt;em&gt;not&lt;/em&gt; recurse into the package, &lt;code&gt;load_tests&lt;/code&gt; is responsible for loading all tests in the package.</source>
          <target state="translated">경우 &lt;code&gt;load_tests&lt;/code&gt; 은 다음 발견 않는 존재 &lt;em&gt;하지&lt;/em&gt; 패키지로 재귀 적, &lt;code&gt;load_tests&lt;/code&gt; 는 패키지의 모든 테스트를로드 할 책임이있다.</target>
        </trans-unit>
        <trans-unit id="9a58c1405d0e16b64227f1566491186e0f5dddcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is not supplied, and Enum cannot determine what it is, the new Enum members will not be unpicklable; to keep errors closer to the source, pickling will be disabled.</source>
          <target state="translated">경우 &lt;code&gt;module&lt;/code&gt; 제공되지 않으며, 열거 그것이 무엇인지 확인할 수없는, 새로운 열거 회원 unpicklable되지 않습니다; 오류를 소스에 더 가깝게 유지하기 위해 산 세척이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ab3736d9d355c250769a78d1fa815bd9cfa2ab47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;newline=''&lt;/code&gt; is not specified, newlines embedded inside quoted fields will not be interpreted correctly, and on platforms that use &lt;code&gt;\r\n&lt;/code&gt; linendings on write an extra &lt;code&gt;\r&lt;/code&gt; will be added. It should always be safe to specify &lt;code&gt;newline=''&lt;/code&gt;, since the csv module does its own (&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal&lt;/a&gt;) newline handling.</source>
          <target state="translated">경우 &lt;code&gt;newline=''&lt;/code&gt; 지정되지 않은 인용 필드 내부에 포함 된 개행 문자가 올바르게 해석하고 사용하는 플랫폼되지 않습니다 &lt;code&gt;\r\n&lt;/code&gt; 쓰기에 linendings 추가 &lt;code&gt;\r&lt;/code&gt; 추가됩니다. csv 모듈은 고유 한 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용&lt;/a&gt; ) 개행 처리를 수행하므로 항상 &lt;code&gt;newline=''&lt;/code&gt; 을 지정하는 것이 안전해야합니다 .</target>
        </trans-unit>
        <trans-unit id="abd59bc323474e8d28c3b6cf30956ad3087d1391" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.chflags in os.supports_follow_symlinks&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; can modify the flags of a symbolic link. (&lt;code&gt;os.chflags&lt;/code&gt; is not available on all platforms.)</source>
          <target state="translated">경우 &lt;code&gt;os.chflags in os.supports_follow_symlinks&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 심볼릭 링크의 플래그를 수정할 수 있습니다. ( &lt;code&gt;os.chflags&lt;/code&gt; 는 모든 플랫폼에서 사용할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="8e10e24faf09ce3b9d96dd7e061eb030aca8d0b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.chmod in os.supports_follow_symlinks&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; can modify the permission bits of a symbolic link.</source>
          <target state="translated">경우 &lt;code&gt;os.chmod in os.supports_follow_symlinks&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 심볼릭 링크의 권한 비트를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33018c8d997e147843c0242b5f72f3cc52abfcee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.utime in os.supports_follow_symlinks&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; can modify the last access and modification times of a symbolic link.</source>
          <target state="translated">경우 &lt;code&gt;os.utime in os.supports_follow_symlinks&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 심볼릭 링크의 최종 액세스 및 수정 시간을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05957a485610f250e41b862c6cf8205d2ef4e95" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;proxy&lt;/code&gt; is a proxy whose referent is &lt;code&gt;obj&lt;/code&gt; then the expression</source>
          <target state="translated">경우 &lt;code&gt;proxy&lt;/code&gt; 그 지시 대상이다 프록시 &lt;code&gt;obj&lt;/code&gt; 그 표현은</target>
        </trans-unit>
        <trans-unit id="4198a79dad12cd8b876f2f71ca5d8af1485c0d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;related&lt;/code&gt; is not included in &lt;em&gt;preferencelist&lt;/em&gt;, consider the root part (or subpart of the root part) of any related encountered as a candidate if the (sub-)part matches a preference.</source>
          <target state="translated">경우 &lt;code&gt;related&lt;/code&gt; 포함되어 있지 않습니다 &lt;em&gt;preferencelist&lt;/em&gt; 의 (하위) 부분은 기본 설정을 일치하는 경우라도 후보로 발생 관련의 루트 부분 (또는 루트 부분의 서브 파트)를 고려한다.</target>
        </trans-unit>
        <trans-unit id="876e1c7c8abfc9cc30ff4722fb3870e77a933987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;respect_handler_level&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a handler&amp;rsquo;s level is respected (compared with the level for the message) when deciding whether to pass messages to that handler; otherwise, the behaviour is as in previous Python versions - to always pass each message to each handler.</source>
          <target state="translated">&lt;code&gt;respect_handler_level&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 메시지를 해당 핸들러로 전달할지 여부를 결정할 때 핸들러의 레벨이 존중됩니다 (메시지의 레벨과 비교). 그렇지 않으면 동작은 이전 Python 버전과 동일합니다. 항상 각 메시지를 각 처리기에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b8ba649cc272ffd32fbf67fb183157eb6f6df18c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.tzinfo&lt;/code&gt; is &lt;em&gt;tz&lt;/em&gt;, &lt;code&gt;self.astimezone(tz)&lt;/code&gt; is equal to &lt;em&gt;self&lt;/em&gt;: no adjustment of date or time data is performed. Else the result is local time in the timezone &lt;em&gt;tz&lt;/em&gt;, representing the same UTC time as &lt;em&gt;self&lt;/em&gt;: after &lt;code&gt;astz = dt.astimezone(tz)&lt;/code&gt;, &lt;code&gt;astz - astz.utcoffset()&lt;/code&gt; will have the same date and time data as &lt;code&gt;dt - dt.utcoffset()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;self.tzinfo&lt;/code&gt; 가 있다 &lt;em&gt;TZ&lt;/em&gt; , &lt;code&gt;self.astimezone(tz)&lt;/code&gt; 같은지 &lt;em&gt;자기&lt;/em&gt; : 날짜 또는 시간 데이터에는 조정이 수행되지 않는다. 그렇지 않으면 결과는 시간대의 현지 시간을 &lt;em&gt;TZ&lt;/em&gt; 와 같은 UTC 시간을 나타내는, &lt;em&gt;자기는&lt;/em&gt; : 후 &lt;code&gt;astz = dt.astimezone(tz)&lt;/code&gt; , &lt;code&gt;astz - astz.utcoffset()&lt;/code&gt; 와 같은 날짜 및 시간 데이터해야합니다 &lt;code&gt;dt - dt.utcoffset()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="367bdb474eb8abb8f4c9cfe3276f05ae7bdd8611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setUpModule()&lt;/code&gt; fails, meaning that &lt;code&gt;tearDownModule()&lt;/code&gt; is not called, then any cleanup functions added will still be called.</source>
          <target state="translated">경우 &lt;code&gt;setUpModule()&lt;/code&gt; 실패, 그 의미 &lt;code&gt;tearDownModule()&lt;/code&gt; 호출되지 않습니다를 다음 추가 된 정리 기능은 여전히 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5df6e6854ff33d1db70399b9e7421342b26d1f49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;side_effect&lt;/code&gt; is a function then whatever that function returns is what calls to the mock return. The &lt;code&gt;side_effect&lt;/code&gt; function is called with the same arguments as the mock. This allows you to vary the return value of the call dynamically, based on the input:</source>
          <target state="translated">경우 &lt;code&gt;side_effect&lt;/code&gt; 이 기능은 다음 무엇이든 그 함수가 반환은 모의 리턴 호출 것입니다. &lt;code&gt;side_effect&lt;/code&gt; 의 기능은 모의와 동일한 인자와 함께 호출됩니다. 이를 통해 입력에 따라 호출의 반환 값을 동적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="087e65b3a7a454d1f380ea833e17e5e2da02afee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signal.SIGINT&lt;/code&gt; isn&amp;rsquo;t handled by Python (it was set to &lt;a href=&quot;signal#signal.SIG_DFL&quot;&gt;&lt;code&gt;signal.SIG_DFL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;signal#signal.SIG_IGN&quot;&gt;&lt;code&gt;signal.SIG_IGN&lt;/code&gt;&lt;/a&gt;), this function does nothing.</source>
          <target state="translated">경우 &lt;code&gt;signal.SIGINT&lt;/code&gt; 이 (가로 설정되어 파이썬에 의해 처리되지 &lt;a href=&quot;signal#signal.SIG_DFL&quot;&gt; &lt;code&gt;signal.SIG_DFL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;signal#signal.SIG_IGN&quot;&gt; &lt;code&gt;signal.SIG_IGN&lt;/code&gt; &lt;/a&gt; ),이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f66a0119d36ff434bd176a0f14f955171a2dbfee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;something()&lt;/code&gt; is cancelled by other means (i.e. from within itself) that would also cancel &lt;code&gt;shield()&lt;/code&gt;.</source>
          <target state="translated">다른 방법으로 (즉, 자체에서 &lt;code&gt;something()&lt;/code&gt; 를 취소 하면 &lt;code&gt;shield()&lt;/code&gt; 도 취소 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1aae3855096a38e20d34c3153d0204c6e5add8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sys.stdin&lt;/code&gt; is used more than once, the second and further use will return no lines, except perhaps for interactive use, or if it has been explicitly reset (e.g. using &lt;code&gt;sys.stdin.seek(0)&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;sys.stdin&lt;/code&gt; 가 두 번 이상 사용하는 경우, 두번째 이후 사용, 더 라인을 반환하지 상호 작용 사용 아마도 제외시켰다하거나 있었는지 명시 적으로 초기화됩니다 (예를 들어, 사용 &lt;code&gt;sys.stdin.seek(0)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1540606a988a3eee5d0cd32d98e93f7bdb7662c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sys&lt;/code&gt; is reset by user code, such as with &lt;code&gt;importlib.reload(sys)&lt;/code&gt;, IDLE&amp;rsquo;s changes are lost and input from the keyboard and output to the screen will not work correctly.</source>
          <target state="translated">경우 &lt;code&gt;sys&lt;/code&gt; 같은과 같은 사용자 코드에 의해 리셋 &lt;code&gt;importlib.reload(sys)&lt;/code&gt; , IDLE의 변경 내용이 손실되고 화면에 키보드와 출력의 입력은 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ef4296b0d6745bb7998092ae95ff303a8c4712b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tempdir&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; (the default) at any call to any of the above functions except &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt;&lt;code&gt;gettempprefix()&lt;/code&gt;&lt;/a&gt; it is initialized following the algorithm described in &lt;a href=&quot;#tempfile.gettempdir&quot;&gt;&lt;code&gt;gettempdir()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;tempdir&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 제외한 상기의 모든 기능에 대한 호출의 (디폴트) &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt; &lt;code&gt;gettempprefix()&lt;/code&gt; &lt;/a&gt; 그것의 한 알고리즘은 다음 초기화 &lt;a href=&quot;#tempfile.gettempdir&quot;&gt; &lt;code&gt;gettempdir()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce6afbd1542483776b1f19987aee4fdaea2af84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout &amp;gt; 0&lt;/code&gt;, this specifies the maximum wait time, in seconds. If &lt;code&gt;timeout &amp;lt;= 0&lt;/code&gt;, the call won&amp;rsquo;t block, and will report the currently ready file objects. If &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the call will block until a monitored file object becomes ready.</source>
          <target state="translated">만약 &lt;code&gt;timeout &amp;gt; 0&lt;/code&gt; (초)이 지정하는 최대 대기 시간. 경우 &lt;code&gt;timeout &amp;lt;= 0&lt;/code&gt; , 통화가 차단되지 않으며, 현재 준비 파일 객체를보고합니다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 모니터링 파일 객체가 준비 될 때까지 호출이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="b883d86f843b47e0cc5cb4e22ef7491a75061003" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type_comments=True&lt;/code&gt; is given, the parser is modified to check and return type comments as specified by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;. This is equivalent to adding &lt;code&gt;ast.PyCF_TYPE_COMMENTS&lt;/code&gt; to the flags passed to &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;. This will report syntax errors for misplaced type comments. Without this flag, type comments will be ignored, and the &lt;code&gt;type_comment&lt;/code&gt; field on selected AST nodes will always be &lt;code&gt;None&lt;/code&gt;. In addition, the locations of &lt;code&gt;# type:
ignore&lt;/code&gt; comments will be returned as the &lt;code&gt;type_ignores&lt;/code&gt; attribute of &lt;code&gt;Module&lt;/code&gt; (otherwise it is always an empty list).</source>
          <target state="translated">경우 &lt;code&gt;type_comments=True&lt;/code&gt; 주어진다, 파서는 지정한대로 확인하고 반환 형식 댓글 수정 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP (484)&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP (526)&lt;/strong&gt;&lt;/a&gt; . 이것은 &lt;code&gt;ast.PyCF_TYPE_COMMENTS&lt;/code&gt; 를 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 전달 된 플래그 에 추가하는 것과 같습니다 . 잘못 배치 된 유형 주석에 대한 구문 오류를보고합니다. 이 플래그가 없으면 형식 설명은 무시 되고 선택한 AST 노드 의 &lt;code&gt;type_comment&lt;/code&gt; 필드는 항상 &lt;code&gt;None&lt;/code&gt; 입니다. 또한 &lt;code&gt;# type: ignore&lt;/code&gt; 주석 의 위치는 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;type_ignores&lt;/code&gt; 속성 으로 반환됩니다 (그렇지 않으면 항상 빈 목록 임).</target>
        </trans-unit>
        <trans-unit id="a0593491fc7f673a2fbc8bcde73d064bd5a237d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tzname()&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;%Z&lt;/code&gt; is replaced by an empty string. Otherwise &lt;code&gt;%Z&lt;/code&gt; is replaced by the returned value, which must be a string.</source>
          <target state="translated">경우 &lt;code&gt;tzname()&lt;/code&gt; 를 반환 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;%Z&lt;/code&gt; 빈 문자열로 대체됩니다. 그렇지 않으면 &lt;code&gt;%Z&lt;/code&gt; 는 반환 된 값으로 대체되며, 이는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2650dd8391d760c4b3dcdc53f8ee4bce8296ecf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x = m / n&lt;/code&gt; is a negative rational number define &lt;code&gt;hash(x)&lt;/code&gt; as &lt;code&gt;-hash(-x)&lt;/code&gt;. If the resulting hash is &lt;code&gt;-1&lt;/code&gt;, replace it with &lt;code&gt;-2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x = m / n&lt;/code&gt; 인 네거티브 유리수 정의 &lt;code&gt;hash(x)&lt;/code&gt; 로서 &lt;code&gt;-hash(-x)&lt;/code&gt; . 결과 해시가 &lt;code&gt;-1&lt;/code&gt; 이면 &lt;code&gt;-2&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="93635faa94af4f4c677484e54d0cfef7e6922367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x = m / n&lt;/code&gt; is a nonnegative rational number and &lt;code&gt;n&lt;/code&gt; is divisible by &lt;code&gt;P&lt;/code&gt; (but &lt;code&gt;m&lt;/code&gt; is not) then &lt;code&gt;n&lt;/code&gt; has no inverse modulo &lt;code&gt;P&lt;/code&gt; and the rule above doesn&amp;rsquo;t apply; in this case define &lt;code&gt;hash(x)&lt;/code&gt; to be the constant value &lt;code&gt;sys.hash_info.inf&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;x = m / n&lt;/code&gt; 음이 아닌 유리수이고, &lt;code&gt;n&lt;/code&gt; 에 의해 나누어 &lt;code&gt;P&lt;/code&gt; (단, &lt;code&gt;m&lt;/code&gt; 은 아니다)을 &lt;code&gt;n&lt;/code&gt; 에는 역 모듈이없는 &lt;code&gt;P&lt;/code&gt; 와 적용하지 않고 상기 규칙; 이 경우 &lt;code&gt;hash(x)&lt;/code&gt; 를 상수 값 &lt;code&gt;sys.hash_info.inf&lt;/code&gt; 로 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="575b723cab08b731a281088430618a5e6637507d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x = m / n&lt;/code&gt; is a nonnegative rational number and &lt;code&gt;n&lt;/code&gt; is not divisible by &lt;code&gt;P&lt;/code&gt;, define &lt;code&gt;hash(x)&lt;/code&gt; as &lt;code&gt;m * invmod(n, P) % P&lt;/code&gt;, where &lt;code&gt;invmod(n,
P)&lt;/code&gt; gives the inverse of &lt;code&gt;n&lt;/code&gt; modulo &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x = m / n&lt;/code&gt; 음수가 아닌 유리수이고, &lt;code&gt;n&lt;/code&gt; 에 의해 나누어 아닌 &lt;code&gt;P&lt;/code&gt; 정의 &lt;code&gt;hash(x)&lt;/code&gt; 로서 &lt;code&gt;m * invmod(n, P) % P&lt;/code&gt; , &lt;code&gt;invmod(n, P)&lt;/code&gt; 의 역 제공 &lt;code&gt;n&lt;/code&gt; 모듈로 &lt;code&gt;P&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="00f7d3383e6e96fe7eb1f9df5004df74f9efec98" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;PIPE&lt;/em&gt; is passed to &lt;em&gt;stdin&lt;/em&gt; argument, the &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdin&quot;&gt;&lt;code&gt;Process.stdin&lt;/code&gt;&lt;/a&gt; attribute will point to a &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">경우 &lt;em&gt;파이프&lt;/em&gt; 에 전달 &lt;em&gt;하여 stdin&lt;/em&gt; 인수의 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdin&quot;&gt; &lt;code&gt;Process.stdin&lt;/code&gt; 의&lt;/a&gt; 속성은 가리 킵니다 &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="38a0b86cb262bdd72cf16c86faa970fbee2eca97" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;PIPE&lt;/em&gt; is passed to &lt;em&gt;stdout&lt;/em&gt; or &lt;em&gt;stderr&lt;/em&gt; arguments, the &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdout&quot;&gt;&lt;code&gt;Process.stdout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stderr&quot;&gt;&lt;code&gt;Process.stderr&lt;/code&gt;&lt;/a&gt; attributes will point to &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">경우 &lt;em&gt;파이프&lt;/em&gt; 에 전달되는 &lt;em&gt;표준 출력&lt;/em&gt; 또는 &lt;em&gt;표준 오류&lt;/em&gt; 인수는 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdout&quot;&gt; &lt;code&gt;Process.stdout&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stderr&quot;&gt; &lt;code&gt;Process.stderr&lt;/code&gt; &lt;/a&gt; 속성을 가리 킵니다 &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="a3d56b8626e52a3b745f55fc2379e816f304457a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are of different lengths, or if an error occurs, a timing attack could theoretically reveal information about the types and lengths of &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;&amp;mdash;but not their values.</source>
          <target state="translated">경우 와 &lt;em&gt;b는&lt;/em&gt; 서로 다른 길이의하다 에러가 발생했을 경우, 또는, 타이밍 공격은 이론적으로의 종류와 길이에 대한 정보를 공개 할 수 &lt;em&gt;을&lt;/em&gt; 하고 &lt;em&gt;ㄱ&lt;/em&gt; 그 값을하지 -하지만.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc5c1185931e9b5fe08eb862e8faf706f6f24540" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;a&lt;/em&gt; is an int, it is used directly.</source>
          <target state="translated">경우 &lt;em&gt;A는&lt;/em&gt; int로, 그것은 직접적으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="08098ecc02f15e5298805376eb97d21770273b65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;a&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, the current system time is used. If randomness sources are provided by the operating system, they are used instead of the system time (see the &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt; function for details on availability).</source>
          <target state="translated">경우 &lt;em&gt;A는&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; , 현재 시스템 시간을 사용한다. 운영 체제에서 임의 소스를 제공하는 경우 시스템 시간 대신 소스가 사용됩니다 (사용 가능 여부에 대한 자세한 내용은 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; 함수 참조).</target>
        </trans-unit>
        <trans-unit id="ddd2d43954115612f47582f7f40c2da1ce1c45e3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;addr_type&lt;/em&gt; is &lt;code&gt;TIPC_ADDR_ID&lt;/code&gt;, then &lt;em&gt;v1&lt;/em&gt; is the node, &lt;em&gt;v2&lt;/em&gt; is the reference, and &lt;em&gt;v3&lt;/em&gt; should be set to 0.</source>
          <target state="translated">경우 &lt;em&gt;addr_type가&lt;/em&gt; 있다 &lt;code&gt;TIPC_ADDR_ID&lt;/code&gt; 후 &lt;em&gt;V1&lt;/em&gt; 노드이고, &lt;em&gt;V2는&lt;/em&gt; 기준이며, &lt;em&gt;V3은&lt;/em&gt; 0으로 설정되어야한다.</target>
        </trans-unit>
        <trans-unit id="8daf1756c4685b74aa3a32fb2dad0e27162099fa" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;addr_type&lt;/em&gt; is &lt;code&gt;TIPC_ADDR_NAME&lt;/code&gt;, then &lt;em&gt;v1&lt;/em&gt; is the server type, &lt;em&gt;v2&lt;/em&gt; is the port identifier, and &lt;em&gt;v3&lt;/em&gt; should be 0.</source>
          <target state="translated">경우 &lt;em&gt;addr_type가&lt;/em&gt; 있다 &lt;code&gt;TIPC_ADDR_NAME&lt;/code&gt; 후 &lt;em&gt;V1&lt;/em&gt; 서버 유형 인 &lt;em&gt;V2가&lt;/em&gt; 포트 식별자이며, &lt;em&gt;V3은&lt;/em&gt; 0이어야한다.</target>
        </trans-unit>
        <trans-unit id="5ee8f55dc5cb9c1fddf1d3f67dd30328327823b8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;addr_type&lt;/em&gt; is &lt;code&gt;TIPC_ADDR_NAMESEQ&lt;/code&gt;, then &lt;em&gt;v1&lt;/em&gt; is the server type, &lt;em&gt;v2&lt;/em&gt; is the lower port number, and &lt;em&gt;v3&lt;/em&gt; is the upper port number.</source>
          <target state="translated">경우 &lt;em&gt;addr_type가&lt;/em&gt; 있다 &lt;code&gt;TIPC_ADDR_NAMESEQ&lt;/code&gt; , 다음 &lt;em&gt;V1&lt;/em&gt; 서버 유형이있다 &lt;em&gt;V2가&lt;/em&gt; 낮은 포트 번호이며, &lt;em&gt;V3는&lt;/em&gt; 상단 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="e3c769a1fb511af595c339c328e4e17c4c3ff2b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;aliased&lt;/em&gt; is true, the function will use aliases for various platforms that report system names which differ from their common names, for example SunOS will be reported as Solaris. The &lt;a href=&quot;#platform.system_alias&quot;&gt;&lt;code&gt;system_alias()&lt;/code&gt;&lt;/a&gt; function is used to implement this.</source>
          <target state="translated">경우 &lt;em&gt;별칭이&lt;/em&gt; 사실이다, 함수는 공통 이름과 다를 보고서 시스템 이름이, 예를 들어 SunOS의이 솔라리스로보고됩니다 다양한 플랫폼에 대한 별칭을 사용합니다. &lt;a href=&quot;#platform.system_alias&quot;&gt; &lt;code&gt;system_alias()&lt;/code&gt; &lt;/a&gt; 함수는이를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35db95e9a28719ea3058976c910d71b26ef3098a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;all_frames&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, all frames of the traceback are checked. If &lt;em&gt;all_frames&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, only the most recent frame is checked.</source>
          <target state="translated">&lt;em&gt;all_frames&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 , 역 추적의 모든 프레임이 검사됩니다. 경우 &lt;em&gt;all_frames이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 가장 최근의 프레임이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="3e12368612ae3dc2365f369a9caafd4788de7974" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;allowZip64&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is &lt;code&gt;false&lt;/code&gt;&lt;a href=&quot;#module-zipfile&quot;&gt;&lt;code&gt;zipfile&lt;/code&gt;&lt;/a&gt; will raise an exception when the ZIP file would require ZIP64 extensions.</source>
          <target state="translated">&lt;em&gt;allowZip64&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; (기본값) 인 경우 zip 파일은 zip 파일이 4GiB보다 큰 경우 ZIP64 확장자를 사용하는 ZIP 파일을 생성합니다. 이 경우 &lt;code&gt;false&lt;/code&gt; &lt;a href=&quot;#module-zipfile&quot;&gt; &lt;code&gt;zipfile&lt;/code&gt; &lt;/a&gt; 예외를 발생한다이 ZIP 파일은 ZIP64 확장을 필요로 할 때.</target>
        </trans-unit>
        <trans-unit id="eb1877b149e4a559e04aa18e7cbd9b76903ad1d4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;allow_nan&lt;/em&gt; is false (default: &lt;code&gt;True&lt;/code&gt;), then it will be a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to serialize out of range &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; values (&lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, &lt;code&gt;-inf&lt;/code&gt;) in strict compliance of the JSON specification. If &lt;em&gt;allow_nan&lt;/em&gt; is true, their JavaScript equivalents (&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;) will be used.</source>
          <target state="translated">경우 &lt;em&gt;allow_nan이&lt;/em&gt; (기본값 : 거짓 &lt;code&gt;True&lt;/code&gt; ), 다음이 될 것입니다 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 범위 밖으로 직렬화하는 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 값 ( &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; json으로 사양의 엄격한 준수). 경우 &lt;em&gt;allow_nan는&lt;/em&gt; 사실, 자신의 자바 스크립트 등가물 ( &lt;code&gt;NaN&lt;/code&gt; 를 , &lt;code&gt;Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 는 ) 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="365b8c9a025c7c15e2aa49096f5708db96335579" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;allow_nan&lt;/em&gt; is true (the default), then &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, and &lt;code&gt;-Infinity&lt;/code&gt; will be encoded as such. This behavior is not JSON specification compliant, but is consistent with most JavaScript based encoders and decoders. Otherwise, it will be a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to encode such floats.</source>
          <target state="translated">경우 &lt;em&gt;allow_nan가&lt;/em&gt; true (디폴트), 다음 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;Infinity&lt;/code&gt; 하고, &lt;code&gt;-Infinity&lt;/code&gt; 는 같은 인코딩됩니다. 이 동작은 JSON 사양과 호환되지 않지만 대부분의 JavaScript 기반 인코더 및 디코더와 일치합니다. 그렇지 않으면 그러한 float를 인코딩 하는 것은 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c5a8dca769532cade2fe55bfaac93ebef45b3887" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;altinstall&lt;/em&gt; is set, then &lt;code&gt;pipX&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be installed.</source>
          <target state="translated">경우 &lt;em&gt;altinstall가&lt;/em&gt; 설정되어, 다음 &lt;code&gt;pipX&lt;/code&gt; 는 것입니다 &lt;em&gt;하지&lt;/em&gt; 설치.</target>
        </trans-unit>
        <trans-unit id="50026840e798123dd4e7c9c3c6b090021e307025" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is false then the awaits must be sequential. There can be extra calls before or after the specified awaits.</source>
          <target state="translated">&lt;em&gt;any_order&lt;/em&gt; 가 false 이면 &lt;em&gt;대기&lt;/em&gt; 는 순차적이어야합니다. 지정된 대기 전 또는 후에 추가 호출이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83074f9b97aea52bc40947133bf7966023c0dfb4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is false then the calls must be sequential. There can be extra calls before or after the specified calls.</source>
          <target state="translated">경우 &lt;em&gt;any_order이&lt;/em&gt; 거짓 다음 호출은 순차적으로해야합니다. 지정된 통화 전후에 추가 통화가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f36f468d7fc72d5086c39c28c3ab3335e0b213" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is true then the awaits can be in any order, but they must all appear in &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt;&lt;code&gt;await_args_list&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;any_order&lt;/em&gt; 가 true 이면 &lt;em&gt;awaits&lt;/em&gt; 는 순서에 관계없이 모두 &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt; &lt;code&gt;await_args_list&lt;/code&gt; &lt;/a&gt; 에 나타나야 합니다.</target>
        </trans-unit>
        <trans-unit id="77ac2e901cc5aeaa722f2e4e6b975f2f2972f688" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is true then the calls can be in any order, but they must all appear in &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;any_order이&lt;/em&gt; 사실 다음 호출은 임의의 순서로 될 수 있지만, 그들은 모두에 표시되어야합니다 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b896efed823ebecf1bef68285349fa5d05fe09f8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arcname&lt;/em&gt; is specified, it is used as the name within the archive. If &lt;em&gt;arcname&lt;/em&gt; is not specified, the name will be the same as &lt;em&gt;filename&lt;/em&gt;, but with any drive letter and leading path separators removed.</source>
          <target state="translated">경우 &lt;em&gt;arcname가&lt;/em&gt; 지정되어, 그것은 아카이브 내 이름으로 사용됩니다. 경우 &lt;em&gt;arcname가&lt;/em&gt; 지정되지 않은, 이름과 동일합니다 &lt;em&gt;파일 이름&lt;/em&gt; 만 분리 한 드라이브 문자 및 선행 경로 구분와.</target>
        </trans-unit>
        <trans-unit id="bb3e312374b1b5d8dccea78b576f639dc980f7ee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;atTime&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a &lt;code&gt;datetime.time&lt;/code&gt; instance which specifies the time of day when rollover occurs, for the cases where rollover is set to happen &amp;ldquo;at midnight&amp;rdquo; or &amp;ldquo;on a particular weekday&amp;rdquo;. Note that in these cases, the &lt;em&gt;atTime&lt;/em&gt; value is effectively used to compute the &lt;em&gt;initial&lt;/em&gt; rollover, and subsequent rollovers would be calculated via the normal interval calculation.</source>
          <target state="translated">경우 &lt;em&gt;atTime가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; , 그것은해야합니다 &lt;code&gt;datetime.time&lt;/code&gt; 의 롤오버가 &quot;특정 평일에&quot; &quot;자정&quot;발생하거나 설정되어있는 경우에 롤오버가 발생했을 때 하루의 시간을 지정 인스턴스. 이러한 경우 &lt;em&gt;atTime&lt;/em&gt; 값은 효과적으로 &lt;em&gt;초기&lt;/em&gt; 롤오버 를 계산하는 데 사용 되며 후속 롤오버는 일반 간격 계산을 통해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="64ed490d101bfcd7c524cd7f6470fd6dd92855bd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;authkey&lt;/em&gt; is given and not None, it should be a byte string and will be used as the secret key for an HMAC-based authentication challenge. No authentication is done if &lt;em&gt;authkey&lt;/em&gt; is None. &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt;&lt;code&gt;AuthenticationError&lt;/code&gt;&lt;/a&gt; is raised if authentication fails. See &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;Authentication keys&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;인증 키가&lt;/em&gt; 없음 주어지지되지 않으며, 그것은 바이트 문자열해야하고, HMAC 기반의 인증 요청에 대한 비밀 키로 사용됩니다. &lt;em&gt;authkey&lt;/em&gt; 가 None 이면 인증이 수행되지 않습니다. &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt; &lt;code&gt;AuthenticationError&lt;/code&gt; &lt;/a&gt; 에 실패하면 AuthenticationError 가 발생합니다. &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;인증 키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59231b8d6544c6fca57984e1be4fe078812fe3b1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;aw&lt;/em&gt; is a coroutine it is automatically scheduled as a Task.</source>
          <target state="translated">경우 &lt;em&gt;아이&lt;/em&gt; 코 루틴입니다 자동 태스크로 예정되어있다.</target>
        </trans-unit>
        <trans-unit id="846999a5b8612ebabe5165c0323a01a132f354c4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;backupCount&lt;/em&gt; is nonzero, at most &lt;em&gt;backupCount&lt;/em&gt; files will be kept, and if more would be created when rollover occurs, the oldest one is deleted. The deletion logic uses the interval to determine which files to delete, so changing the interval may leave old files lying around.</source>
          <target state="translated">경우 &lt;em&gt;BACKUPCOUNT는&lt;/em&gt; 최대 0이 아닌입니다 &lt;em&gt;BACKUPCOUNT의&lt;/em&gt; 파일이 유지되고, 더이 생성 될 경우 롤오버가 발생했을 때, 가장 오래된이 삭제됩니다. 삭제 논리는 간격을 사용하여 삭제할 파일을 결정하므로 간격을 변경하면 오래된 파일이 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="254adf80a9b6b968549efbd28f181bb6475f5a82" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;blocking&lt;/em&gt; is false executes the scheduled events due to expire soonest (if any) and then return the deadline of the next scheduled call in the scheduler (if any).</source>
          <target state="translated">경우 &lt;em&gt;차단이&lt;/em&gt; 거짓이 실행 인해 예약 된 이벤트가 조속한 만료 (있는 경우) 다음 스케줄러 (있는 경우)에서 다음 예약 전화의 기한을 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="a72b7baa5a4df5ed7a19b9faf38f50add7609350" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;body&lt;/em&gt; is specified, the specified data is sent after the headers are finished. It may be a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, an open &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, or an iterable of &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;body&lt;/em&gt; is a string, it is encoded as ISO-8859-1, the default for HTTP. If it is a bytes-like object, the bytes are sent as is. If it is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, the contents of the file is sent; this file object should support at least the &lt;code&gt;read()&lt;/code&gt; method. If the file object is an instance of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt;, the data returned by the &lt;code&gt;read()&lt;/code&gt; method will be encoded as ISO-8859-1, otherwise the data returned by &lt;code&gt;read()&lt;/code&gt; is sent as is. If &lt;em&gt;body&lt;/em&gt; is an iterable, the elements of the iterable are sent as is until the iterable is exhausted.</source>
          <target state="translated">경우 &lt;em&gt;몸이&lt;/em&gt; 지정된 헤더를 완료 한 후, 지정된 데이터가 전송됩니다. 그것은있을 수 있습니다 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , 열린 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; , 또는의 반복 가능한 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;몸이&lt;/em&gt; 문자열 인, 그것은 ISO-8859-1, HTTP의 기본값으로 인코딩됩니다. 바이트와 ​​유사한 객체 인 경우 바이트는 그대로 전송됩니다. 그것은 경우 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 오브젝트&lt;/a&gt; , 파일의 내용이 전송됩니다; 이 파일 객체는 최소한 &lt;code&gt;read()&lt;/code&gt; 메소드를 지원해야합니다 . 파일 객체가 &lt;a href=&quot;io#io.TextIOBase&quot;&gt; &lt;code&gt;io.TextIOBase&lt;/code&gt; &lt;/a&gt; 의 인스턴스 인 경우 , &lt;code&gt;read()&lt;/code&gt; 메소드에 의해 반환 된 데이터는 ISO-8859-1로 인코딩되고 그렇지 않으면 &lt;code&gt;read()&lt;/code&gt; 있는 그대로 전송됩니다. 경우 &lt;em&gt;본체&lt;/em&gt; 반복 가능되면, 반복 가능한 요소는 반복 가능한 소진 될 때까지 그대로 전송된다.</target>
        </trans-unit>
        <trans-unit id="a95a187d480705fc824e774d84d0311d36773db9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffer_callback&lt;/em&gt; is None (the default), buffer views are serialized into &lt;em&gt;file&lt;/em&gt; as part of the pickle stream.</source>
          <target state="translated">경우 &lt;em&gt;buffer_callback가&lt;/em&gt; 없음 (디폴트)이없고, 버퍼 뷰에 직렬화 &lt;em&gt;파일&lt;/em&gt; 피클 스트림의 일부로.</target>
        </trans-unit>
        <trans-unit id="2802d994edfbf276788a825388162db7061822a7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffer_callback&lt;/em&gt; is not None, then it can be called any number of times with a buffer view. If the callback returns a false value (such as None), the given buffer is &lt;a href=&quot;#pickle-oob&quot;&gt;out-of-band&lt;/a&gt;; otherwise the buffer is serialized in-band, i.e. inside the pickle stream.</source>
          <target state="translated">&lt;em&gt;buffer_callback&lt;/em&gt; 이 None이 아닌 경우 버퍼 뷰를 사용하여 여러 번 호출 할 수 있습니다. 콜백이 잘못된 값 (예 : None)을 반환하면 지정된 버퍼가 &lt;a href=&quot;#pickle-oob&quot;&gt;대역 외입니다&lt;/a&gt; . 그렇지 않으면 버퍼는 대역 내에서, 즉 피클 스트림 내부에서 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="65eadafe837a031d16efa4765ff11c2ea5982995" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffers&lt;/em&gt; is None (the default), then all data necessary for deserialization must be contained in the pickle stream. This means that the &lt;em&gt;buffer_callback&lt;/em&gt; argument was None when a &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; was instantiated (or when &lt;a href=&quot;#pickle.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pickle.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; was called).</source>
          <target state="translated">경우 &lt;em&gt;버퍼가&lt;/em&gt; 없음 (기본값)입니다, 다음, 직렬화 복원에 필요한 모든 데이터는 피클 스트림에 포함되어야합니다. 이는 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 가 인스턴스화 될 때 (또는 &lt;a href=&quot;#pickle.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pickle.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 &lt;em&gt;buffer_callback&lt;/em&gt; 인수가 없음 &lt;em&gt;임을&lt;/em&gt; 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3072f53b48e04deeb5f6a92a951e4b7b30fd9b43" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffers&lt;/em&gt; is not None, it should be an iterable of buffer-enabled objects that is consumed each time the pickle stream references an &lt;a href=&quot;#pickle-oob&quot;&gt;out-of-band&lt;/a&gt; buffer view. Such buffers have been given in order to the &lt;em&gt;buffer_callback&lt;/em&gt; of a Pickler object.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 가 없음이 아닌 경우 , 피클 스트림 &lt;a href=&quot;#pickle-oob&quot;&gt;이 대역 외&lt;/a&gt; 버퍼 뷰를 참조 할 때마다 사용되는 반복 가능한 버퍼 가능 오브젝트 여야합니다 . 이러한 버퍼는 Pickler 객체 의 &lt;em&gt;buffer_callback&lt;/em&gt; 에 제공되었습니다 .</target>
        </trans-unit>
        <trans-unit id="99e4b8756b05030f0547669e2cd91b89c6443032" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;c&lt;/em&gt; is an instance of &lt;em&gt;C&lt;/em&gt;, &lt;code&gt;c.x&lt;/code&gt; will invoke the getter, &lt;code&gt;c.x = value&lt;/code&gt; will invoke the setter and &lt;code&gt;del c.x&lt;/code&gt; the deleter.</source>
          <target state="translated">경우 &lt;em&gt;C는&lt;/em&gt; 의 인스턴스 &lt;em&gt;C&lt;/em&gt; , &lt;code&gt;c.x&lt;/code&gt; 게터, 호출한다 &lt;code&gt;c.x = value&lt;/code&gt; 세터 및 호출한다 &lt;code&gt;del c.x&lt;/code&gt; Deleter가있다.</target>
        </trans-unit>
        <trans-unit id="c89346ab698759df4344532dd364a8daa21e4b53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;callback&lt;/em&gt; is given and is not &lt;code&gt;None&lt;/code&gt;, it will be called after each trial with two arguments: &lt;code&gt;callback(number, time_taken)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;콜백&lt;/em&gt; 이 제공되고 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 두 번의 인수 &lt;code&gt;callback(number, time_taken)&lt;/code&gt; 와 함께 각 평가판 이후에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="209e198351f5a2406fae647dd06611db91524849" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;callback&lt;/em&gt; is specified then it should be a callable which accepts a single argument. When the result becomes ready &lt;em&gt;callback&lt;/em&gt; is applied to it, that is unless the call failed, in which case the &lt;em&gt;error_callback&lt;/em&gt; is applied instead.</source>
          <target state="translated">&lt;em&gt;콜백&lt;/em&gt; 이 지정 되면 단일 인수를 허용하는 콜 러블이어야합니다. 결과가 준비되면 &lt;em&gt;콜백&lt;/em&gt; 이 적용됩니다. 즉, 콜이 실패하지 않은 경우에는 &lt;em&gt;error_callback&lt;/em&gt; 이 대신 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3329be05687a53fb5199343c2abf71b394411819" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;capture&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the redirection of warnings to the logging system will stop, and warnings will be redirected to their original destinations (i.e. those in effect before &lt;code&gt;captureWarnings(True)&lt;/code&gt; was called).</source>
          <target state="translated">&lt;em&gt;capture&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 , 로깅 시스템으로의 경고 리디렉션이 중지되고 경고는 원래 대상 (즉, &lt;code&gt;captureWarnings(True)&lt;/code&gt; 이 호출 되기 전에 유효한 대상)으로 리디렉션됩니다 .</target>
        </trans-unit>
        <trans-unit id="73194c77e6fb03e0903f0813816661b5e4e396b1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;capture&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, warnings issued by the &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module will be redirected to the logging system. Specifically, a warning will be formatted using &lt;a href=&quot;warnings#warnings.formatwarning&quot;&gt;&lt;code&gt;warnings.formatwarning()&lt;/code&gt;&lt;/a&gt; and the resulting string logged to a logger named &lt;code&gt;'py.warnings'&lt;/code&gt; with a severity of &lt;code&gt;WARNING&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;캡처&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈에서 발행 한 경고 는 로깅 시스템으로 리디렉션됩니다. 특히 경고는 &lt;a href=&quot;warnings#warnings.formatwarning&quot;&gt; &lt;code&gt;warnings.formatwarning()&lt;/code&gt; &lt;/a&gt; 사용하여 형식이 지정 되고 결과 문자열 은 심각도가 &lt;code&gt;WARNING&lt;/code&gt; 인 &lt;code&gt;'py.warnings'&lt;/code&gt; 라는 로거에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f69f734be44d12f98816d1aeb3d6e28ef2ec1b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;capture_output&lt;/em&gt; is true, stdout and stderr will be captured. When used, the internal &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; object is automatically created with &lt;code&gt;stdout=PIPE&lt;/code&gt; and &lt;code&gt;stderr=PIPE&lt;/code&gt;. The &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; arguments may not be supplied at the same time as &lt;em&gt;capture_output&lt;/em&gt;. If you wish to capture and combine both streams into one, use &lt;code&gt;stdout=PIPE&lt;/code&gt; and &lt;code&gt;stderr=STDOUT&lt;/code&gt; instead of &lt;em&gt;capture_output&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;capture_output는&lt;/em&gt; 사실, 표준 출력 및 표준 오류가 캡처됩니다. 사용될 때 내부 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 오브젝트는 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 &lt;code&gt;stderr=PIPE&lt;/code&gt; 로 자동 작성됩니다 . &lt;em&gt;표준 출력&lt;/em&gt; 과 &lt;em&gt;표준 에러&lt;/em&gt; 인수와 동시에 공급되지 않을 수 있습니다 &lt;em&gt;capture_output&lt;/em&gt; . 두 스트림을 모두 캡처하여 하나로 결합하려면 &lt;em&gt;capture_output&lt;/em&gt; 대신 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 &lt;code&gt;stderr=STDOUT&lt;/code&gt; 을 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91d8516461260217396c41f9b221cbdb1d7bcd25" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;chain&lt;/em&gt; is not &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;__cause__&lt;/code&gt; and &lt;code&gt;__context__&lt;/code&gt; will not be formatted.</source>
          <target state="translated">경우 &lt;em&gt;체인이&lt;/em&gt; 없는 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;__cause__&lt;/code&gt; 및 &lt;code&gt;__context__&lt;/code&gt; 는 포맷되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac90c4494a891aa8301770b24d249be59f8193e9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;charset&lt;/em&gt; is provided (which is valid only for &lt;code&gt;str&lt;/code&gt;), encode the string to bytes using the specified character set. The default is &lt;code&gt;utf-8&lt;/code&gt;. If the specified &lt;em&gt;charset&lt;/em&gt; is a known alias for a standard MIME charset name, use the standard charset instead.</source>
          <target state="translated">&lt;em&gt;문자 세트&lt;/em&gt; 가 제공되는 경우 ( &lt;code&gt;str&lt;/code&gt; 에만 유효 ) 지정된 문자 세트를 사용하여 문자열을 바이트로 인코딩하십시오. 기본값은 &lt;code&gt;utf-8&lt;/code&gt; 입니다. 지정된 &lt;em&gt;문자 세트&lt;/em&gt; 가 표준 MIME 문자 세트 이름의 알려진 별명 인 경우 표준 문자 세트를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="76ebf40876e36c44c7a4a24267a19bbe7cda5256" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;check&lt;/em&gt; is true, and the process exits with a non-zero exit code, a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt; exception will be raised. Attributes of that exception hold the arguments, the exit code, and stdout and stderr if they were captured.</source>
          <target state="translated">경우 &lt;em&gt;검사가&lt;/em&gt; 사실이고, 0이 아닌 종료 코드와 함께 프로세스가 종료하는 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생합니다. 해당 예외의 속성은 인수, 종료 코드 및 stdout 및 stderr이 캡처 된 경우 보유합니다.</target>
        </trans-unit>
        <trans-unit id="3067072fcca20de243ec4fbab69b95d01e9a85a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;check_circular&lt;/em&gt; is false (default: &lt;code&gt;True&lt;/code&gt;), then the circular reference check for container types will be skipped and a circular reference will result in an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; (or worse).</source>
          <target state="translated">경우 &lt;em&gt;check_circular가&lt;/em&gt; 거짓 (기본값 :은 &lt;code&gt;True&lt;/code&gt; )이면 컨테이너 타입 원형 기준 검사 건너 뛰고 순환 참조가 될 것이다 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; (또는 악화).</target>
        </trans-unit>
        <trans-unit id="506ca45692a2977cbc33f7b00103c60271d4b598" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;check_circular&lt;/em&gt; is true (the default), then lists, dicts, and custom encoded objects will be checked for circular references during encoding to prevent an infinite recursion (which would cause an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;). Otherwise, no such check takes place.</source>
          <target state="translated">경우 &lt;em&gt;check_circular가&lt;/em&gt; true (디폴트), 다음 목록, dicts 및 사용자 정의 인코딩 된 객체 (AN 원인이되는 무한 재귀를 방지하기 위해 인코딩하는 동안 순환 참조를 검사합니다 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 을&lt;/a&gt; ). 그렇지 않으면 그러한 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29652dd7c4e96908711afe7bf508091b6dae2068" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cid&lt;/em&gt; is specified, add a &lt;em&gt;Content-ID&lt;/em&gt; header with &lt;em&gt;cid&lt;/em&gt; as its value.</source>
          <target state="translated">경우 &lt;em&gt;CID가&lt;/em&gt; 지정하는 추가 &lt;em&gt;컨텐츠 ID&lt;/em&gt; 와 헤더를 &lt;em&gt;CID&lt;/em&gt; 값으로.</target>
        </trans-unit>
        <trans-unit id="575fcd59aad367b156b538716b2f3891b088a393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;clear&lt;/em&gt; is true then the dictionary will be cleared before the new values are set.</source>
          <target state="translated">경우 &lt;em&gt;분명이&lt;/em&gt; 사실 새 값을 설정하기 전에 다음 사전은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d45120b80df607441d6ca3435c79fa5678f78f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;close_fds&lt;/em&gt; is true, all file descriptors except &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; will be closed before the child process is executed. Otherwise when &lt;em&gt;close_fds&lt;/em&gt; is false, file descriptors obey their inheritable flag as described in &lt;a href=&quot;os#fd-inheritance&quot;&gt;Inheritance of File Descriptors&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;close_fds는&lt;/em&gt; 사실이다 제외한 모든 파일 디스크립터 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 는 자식 프로세스가 실행되기 전에 종료됩니다. 그렇지 않은 경우 &lt;em&gt;close_fds이&lt;/em&gt; 거짓에 설명 된대로, 파일 기술자는 상속 플래그를 순종하는 &lt;a href=&quot;os#fd-inheritance&quot;&gt;파일 기술자의 상속&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b29d4c51339df497f6673dde2e116862b6acefa2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;closefd&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given &lt;em&gt;closefd&lt;/em&gt; must be &lt;code&gt;True&lt;/code&gt; (the default) otherwise an error will be raised.</source>
          <target state="translated">경우 &lt;em&gt;closefd이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 과 파일 기술자가 아닌 파일 이름이 부여 된 파일을 닫을 때, 기본 파일 기술자가 열려 유지됩니다. 파일 이름이 &lt;em&gt;closefd이면 &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; (기본값) 여야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2066d93e3b1d41752de819f855fa84984bfaf655" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;column&lt;/em&gt; is specified, returns the bounding box of that cell. If the &lt;em&gt;item&lt;/em&gt; is not visible (i.e., if it is a descendant of a closed item or is scrolled offscreen), returns an empty string.</source>
          <target state="translated">경우 &lt;em&gt;열이&lt;/em&gt; 지정되어, 해당 셀의 경계 상자를 반환합니다. 경우 &lt;em&gt;항목이&lt;/em&gt; 표시되지 않습니다 (이 폐쇄 된 항목의 하위 또는 오프 스크린을 스크롤하는 경우 즉,), 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0213da647cc77316ae40d8c30349f6bd76c97885" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;context&lt;/em&gt; is specified, it must be a &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; instance describing the various SSL options. See &lt;a href=&quot;http.client#http.client.HTTPSConnection&quot;&gt;&lt;code&gt;HTTPSConnection&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">경우 &lt;em&gt;컨텍스트가&lt;/em&gt; 지정되어, 그것은해야합니다 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; 의&lt;/a&gt; 다양한 SSL 옵션을 설명하는 예. 자세한 내용은 &lt;a href=&quot;http.client#http.client.HTTPSConnection&quot;&gt; &lt;code&gt;HTTPSConnection&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7608590b57586e180487b61183db6caeedb6256" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;convert_charrefs&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), all character references (except the ones in &lt;code&gt;script&lt;/code&gt;/&lt;code&gt;style&lt;/code&gt; elements) are automatically converted to the corresponding Unicode characters.</source>
          <target state="translated">경우 &lt;em&gt;convert_charrefs가&lt;/em&gt; 있습니다 &lt;code&gt;True&lt;/code&gt; (기본), (에서 제외한 모든 문자 참조 &lt;code&gt;script&lt;/code&gt; / &lt;code&gt;style&lt;/code&gt; 요소)가 자동으로 해당 유니 코드 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6de5e65f0ef648a4c375cfaa4c0d9dd995bb3618" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;copy_function&lt;/em&gt; is given, it must be a callable that takes two arguments &lt;em&gt;src&lt;/em&gt; and &lt;em&gt;dst&lt;/em&gt;, and will be used to copy &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; if &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt; cannot be used. If the source is a directory, &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt; is called, passing it the &lt;code&gt;copy_function()&lt;/code&gt;. The default &lt;em&gt;copy_function&lt;/em&gt; is &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt;. Using &lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; as the &lt;em&gt;copy_function&lt;/em&gt; allows the move to succeed when it is not possible to also copy the metadata, at the expense of not copying any of the metadata.</source>
          <target state="translated">경우 &lt;em&gt;copy_function이&lt;/em&gt; 주어집니다, 두 개의 인수 소요하는 호출해야 &lt;em&gt;SRC&lt;/em&gt; 와 &lt;em&gt;DST를&lt;/em&gt; , 복사하는 데 사용됩니다 &lt;em&gt;SRC를&lt;/em&gt; 에 &lt;em&gt;이명 령&lt;/em&gt; 경우 &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; 사용할 수 없습니다. 소스가 디렉토리 인 경우, &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 그것에게 전달이라고 &lt;code&gt;copy_function()&lt;/code&gt; . 기본 &lt;em&gt;copy_function&lt;/em&gt; 은 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 입니다. &lt;em&gt;copy_function&lt;/em&gt; 으로 &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 를 사용 하면 메타 데이터를 복사하지 않고 메타 데이터를 복사 할 수없는 경우에도 이동에 성공할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bf033ef6d8a1bf2457829466585d1c77570d91e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;copy_function&lt;/em&gt; is given, it must be a callable that will be used to copy each file. It will be called with the source path and the destination path as arguments. By default, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; is used, but any function that supports the same signature (like &lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt;) can be used.</source>
          <target state="translated">경우 &lt;em&gt;copy_function이&lt;/em&gt; 주어집니다, 각 파일을 복사하는 데 사용할 호출해야합니다. 소스 경로와 대상 경로를 인수로 사용하여 호출됩니다. 기본적으로 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 가 사용되지만 동일한 서명을 지원하는 모든 함수 ( &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0549453cb5d46211e07003c2a7307ea21880714" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;create&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; and the &lt;em&gt;dirname&lt;/em&gt; path exists, it will be treated as an existing maildir without attempting to verify its directory layout.</source>
          <target state="translated">경우 &lt;em&gt;만들&lt;/em&gt; 것입니다 &lt;code&gt;True&lt;/code&gt; 하고 &lt;em&gt;있는 dirname의&lt;/em&gt; 경로가 존재, 그것의 디렉토리 레이아웃을 확인하기 위해 시도하지 않고 기존 MAILDIR로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8898e2cfb55415011220e6c35dcb72cd30c93364" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cte&lt;/em&gt; is set, encode the payload using the specified content transfer encoding, and set the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header to that value. Possible values for &lt;em&gt;cte&lt;/em&gt; are &lt;code&gt;quoted-printable&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;7bit&lt;/code&gt;, &lt;code&gt;8bit&lt;/code&gt;, and &lt;code&gt;binary&lt;/code&gt;. If the input cannot be encoded in the specified encoding (for example, specifying a &lt;em&gt;cte&lt;/em&gt; of &lt;code&gt;7bit&lt;/code&gt; for an input that contains non-ASCII values), raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;cte&lt;/em&gt; 가 설정된 경우 지정된 컨텐츠 전송 인코딩을 사용하여 페이로드를 인코딩하고 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 해당 값으로 설정하십시오. &lt;em&gt;cte에&lt;/em&gt; 가능한 값 은 &lt;code&gt;quoted-printable&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; , &lt;code&gt;7bit&lt;/code&gt; , &lt;code&gt;8bit&lt;/code&gt; 및 &lt;code&gt;binary&lt;/code&gt; 입니다. 입력은 (a 지정, 예를 들어 지정된 인코딩으로 인코딩 될 수없는 경우 &lt;em&gt;CTE&lt;/em&gt; 의 &lt;code&gt;7bit&lt;/code&gt; 비 ASCII 값을 포함하는 입력) 인상 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ac96e90d352b33de98fd5ace363c0516fa39090" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cumulative&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, cumulate size and count of memory blocks of all frames of the traceback of a trace, not only the most recent frame. The cumulative mode can only be used with &lt;em&gt;key_type&lt;/em&gt; equals to &lt;code&gt;'filename'&lt;/code&gt; and &lt;code&gt;'lineno'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;cumulative&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 가장 최근의 프레임뿐만 아니라 트레이스의 트레이스 백에 대한 모든 프레임의 메모리 블록 수와 크기를 계산합니다. 누적 모드는 &lt;em&gt;key_type&lt;/em&gt; 이 &lt;code&gt;'filename'&lt;/code&gt; 및 &lt;code&gt;'lineno'&lt;/code&gt; 와 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eacfbd2cb2014105749c4358d998bb8bd55cbab6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;current_offset&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it refers to an instruction offset in the disassembled code. Setting this means &lt;a href=&quot;#dis.Bytecode.dis&quot;&gt;&lt;code&gt;dis()&lt;/code&gt;&lt;/a&gt; will display a &amp;ldquo;current instruction&amp;rdquo; marker against the specified opcode.</source>
          <target state="translated">&lt;em&gt;current_offset&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 디스 어셈블 된 코드의 명령어 오프셋을 나타냅니다. 이를 설정하면 &lt;a href=&quot;#dis.Bytecode.dis&quot;&gt; &lt;code&gt;dis()&lt;/code&gt; &lt;/a&gt; 는 지정된 opcode에 대해 &quot;현재 명령&quot;마커를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b5d4c33f63f2f37671afb0edc3a13524b04cb537" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cwd&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the function changes the working directory to &lt;em&gt;cwd&lt;/em&gt; before executing the child. &lt;em&gt;cwd&lt;/em&gt; can be a string, bytes or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object. In particular, the function looks for &lt;em&gt;executable&lt;/em&gt; (or for the first item in &lt;em&gt;args&lt;/em&gt;) relative to &lt;em&gt;cwd&lt;/em&gt; if the executable path is a relative path.</source>
          <target state="translated">&lt;em&gt;cwd&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 함수 는 하위를 실행하기 전에 작업 디렉토리를 &lt;em&gt;cwd로&lt;/em&gt; 변경합니다 . &lt;em&gt;cwd&lt;/em&gt; 는 문자열, 바이트 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한&lt;/a&gt; 객체 일 수 있습니다. 특히 함수는 실행 경로가 상대 경로 인 경우 &lt;em&gt;cwd를&lt;/em&gt; 기준으로 &lt;em&gt;실행 파일&lt;/em&gt; (또는 &lt;em&gt;args&lt;/em&gt; 의 첫 번째 항목)을 찾습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="abe309a388dca84dd7a05e235de450c0f31358b8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;d&lt;/em&gt; is aware, &lt;em&gt;d&lt;/em&gt; is normalized to UTC time, by subtracting &lt;code&gt;d.utcoffset()&lt;/code&gt;, and a &lt;a href=&quot;time#time.struct_time&quot;&gt;&lt;code&gt;time.struct_time&lt;/code&gt;&lt;/a&gt; for the normalized time is returned. &lt;code&gt;tm_isdst&lt;/code&gt; is forced to 0. Note that an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; may be raised if &lt;em&gt;d&lt;/em&gt;.year was &lt;code&gt;MINYEAR&lt;/code&gt; or &lt;code&gt;MAXYEAR&lt;/code&gt; and UTC adjustment spills over a year boundary.</source>
          <target state="translated">경우 &lt;em&gt;d는&lt;/em&gt; 인식, &lt;em&gt;D는&lt;/em&gt; 감산하여, UTC 시간으로 정규화 &lt;code&gt;d.utcoffset()&lt;/code&gt; , 및 &lt;a href=&quot;time#time.struct_time&quot;&gt; &lt;code&gt;time.struct_time&lt;/code&gt; &lt;/a&gt; 정규화 시간을 반환한다. &lt;code&gt;tm_isdst&lt;/code&gt; 는 0으로 설정 됩니다. &lt;em&gt;d&lt;/em&gt; .year가 &lt;code&gt;MINYEAR&lt;/code&gt; 또는 &lt;code&gt;MAXYEAR&lt;/code&gt; 이고 UTC 조정이 1 년 동안 유출 되면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="412f0af923015004c94c91a0798c5634f520a8c3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is empty, &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">경우 &lt;em&gt;데이터가&lt;/em&gt; 비어 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1bd76e6354043e84cab72b15b26a288207008710" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is the concatenation of multiple compressed streams, decompress all of the streams.</source>
          <target state="translated">경우 &lt;em&gt;데이터가&lt;/em&gt; 여러 압축 스트림의 연결은, 모든 스트림을 압축 해제.</target>
        </trans-unit>
        <trans-unit id="9dbf42aa701352d3426aa0b9e6d8ce207f8e0f9c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is the concatenation of multiple distinct compressed streams, decompress all of these streams, and return the concatenation of the results.</source>
          <target state="translated">경우 &lt;em&gt;데이터가&lt;/em&gt; 여러 별개의 압축 스트림을 연결 한 다음 모든 스트림을 압축 해제하고, 그 결과의 연결을 반환한다.</target>
        </trans-unit>
        <trans-unit id="3efb743eb6b84a13ce1c37d5a413fec15e776cc1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ddir&lt;/em&gt; is given, it is prepended to the path to each file being compiled for use in compilation time tracebacks, and is also compiled in to the byte-code file, where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed.</source>
          <target state="translated">경우 &lt;em&gt;ddir이&lt;/em&gt; 주어집니다, 컴파일 시간을 역 추적에 사용하기 위해 컴파일되는 각 파일의 경로 앞에 추가되며, 또한이 경우 역 추적 및 기타 메시지에서 사용되는 바이트 코드 파일, 소스를 컴파일한다 바이트 코드 파일이 실행될 때 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0eb4f5a84f724ffad64d00f6c44b99d63a5274b2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ddir&lt;/em&gt; is given, it is prepended to the path to the file being compiled for use in compilation time tracebacks, and is also compiled in to the byte-code file, where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed.</source>
          <target state="translated">경우 &lt;em&gt;ddir이&lt;/em&gt; 주어집니다, 컴파일 시간을 역 추적에 사용하기 위해 컴파일되는 파일의 경로 앞에 추가되며, 또한이 경우 역 추적 및 기타 메시지에서 사용되는 바이트 코드 파일, 소스를 컴파일한다 바이트 코드 파일이 실행될 때 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4c4d1acb8ff67a497d8ef936eb0e07f0337e4c2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;debug&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the event loop will be run in debug mode.</source>
          <target state="translated">경우 &lt;em&gt;디버그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 이벤트 루프는 디버그 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="475c14c8e2569012dc880a97fd4fa51777aa405a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;default_pip&lt;/em&gt; is set, then &lt;code&gt;pip&lt;/code&gt; will be installed in addition to the two regular scripts.</source>
          <target state="translated">경우 &lt;em&gt;default_pip가&lt;/em&gt; 설정되어, 다음 &lt;code&gt;pip&lt;/code&gt; 두 개의 일반 스크립트에 추가로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="1c8c126e6c7b0f2e8bd2913dccf7f6d01c5144a7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;delay&lt;/em&gt; is true, then file opening is deferred until the first call to &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler.emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;지연&lt;/em&gt; 에 해당하는 다음 파일 개구는 첫 번째 호출까지 지연되는 &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler.emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0056a36933eb229c50c4c08ad60c4c6100860930" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;delta&lt;/em&gt; is supplied instead of &lt;em&gt;places&lt;/em&gt; then the difference between &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; must be less or equal to (or greater than) &lt;em&gt;delta&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;장소&lt;/em&gt; 대신 &lt;em&gt;델타&lt;/em&gt; 가 제공되는 경우 &lt;em&gt;first&lt;/em&gt; 와 &lt;em&gt;second&lt;/em&gt; 의 차이는 &lt;em&gt;delta&lt;/em&gt; 보다 작거나 같아야합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c3e614afb3a12f1f008bd5a8a6fdbe9c09e6230" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dereference&lt;/em&gt; is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, add symbolic and hard links to the archive. If it is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, add the content of the target files to the archive. This has no effect on systems that do not support symbolic links.</source>
          <target state="translated">경우 &lt;em&gt;역 참조&lt;/em&gt; 입니다 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , 아카이브에 대한 기호 및 하드 링크를 추가 할 수 있습니다. 이 경우 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; , 아카이브에 대상 파일의 내용을 추가합니다. 이는 심볼릭 링크를 지원하지 않는 시스템에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e297698f3919befb6ad412d44099f294057f3e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dir&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the file will be created in that directory; otherwise, a default directory is used. The default directory is chosen from a platform-dependent list, but the user of the application can control the directory location by setting the &lt;em&gt;TMPDIR&lt;/em&gt;, &lt;em&gt;TEMP&lt;/em&gt; or &lt;em&gt;TMP&lt;/em&gt; environment variables. There is thus no guarantee that the generated filename will have any nice properties, such as not requiring quoting when passed to external commands via &lt;code&gt;os.popen()&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;dir&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 파일은 해당 디렉토리에 작성됩니다. 그렇지 않으면 기본 디렉토리가 사용됩니다. 기본 디렉토리는 플랫폼 종속 목록에서 선택되지만 애플리케이션 사용자는 &lt;em&gt;TMPDIR&lt;/em&gt; , &lt;em&gt;TEMP&lt;/em&gt; 또는 &lt;em&gt;TMP&lt;/em&gt; 환경 변수 를 설정하여 디렉토리 위치를 제어 할 수 있습니다 . 따라서 생성 된 파일 이름에 &lt;code&gt;os.popen()&lt;/code&gt; 통해 외부 명령에 전달 될 때 인용 할 필요가없는 것과 같은 멋진 속성이 있다는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="36e5a4ee826ffb2f15f36ae09720b225045e3a17" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dirname&lt;/em&gt; is a string, a &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; finder is created that searches that directory. If &lt;em&gt;dirname&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, a &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; finder is created that searches the current &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;, plus any modules that are frozen or built-in.</source>
          <target state="translated">경우 &lt;em&gt;dirname은이&lt;/em&gt; 문자열 인하는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 파인더는 검색 디렉토리를 생성됩니다. 경우 &lt;em&gt;이 dirname이&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; 하는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 파인더가 생성되는 검색 현재 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에&lt;/a&gt; 플러스 냉동 또는 내장 된 모든 모듈.</target>
        </trans-unit>
        <trans-unit id="551154ba8498eafba8ea7b74270354b26c0ca404" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;disposition&lt;/em&gt; is set, use it as the value of the &lt;em&gt;Content-Disposition&lt;/em&gt; header. If not specified, and &lt;em&gt;filename&lt;/em&gt; is specified, add the header with the value &lt;code&gt;attachment&lt;/code&gt;. If &lt;em&gt;disposition&lt;/em&gt; is not specified and &lt;em&gt;filename&lt;/em&gt; is also not specified, do not add the header. The only valid values for &lt;em&gt;disposition&lt;/em&gt; are &lt;code&gt;attachment&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;배치가&lt;/em&gt; 설정되면, 값으로 사용 &lt;em&gt;내용 - 처리&lt;/em&gt; 헤더. 지정되지 않고 &lt;em&gt;파일 이름&lt;/em&gt; 이 지정되면 값이 &lt;code&gt;attachment&lt;/code&gt; 인 헤더를 추가하십시오 . 경우 &lt;em&gt;처분이&lt;/em&gt; 지정되지 않고 &lt;em&gt;파일 이름&lt;/em&gt; 도 지정되지 않은 헤더를 추가하지 마십시오. &lt;em&gt;적절한 처분&lt;/em&gt; 값 은 &lt;code&gt;attachment&lt;/code&gt; 및 &lt;code&gt;inline&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ec590024eac4ba112689a063f854bf9db2f78c4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dry_run&lt;/em&gt; is true, no archive is created, but the operations that would be executed are logged to &lt;em&gt;logger&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;dry_run는&lt;/em&gt; 사실, 더 아카이브가 생성되지 않지만, 실행되는 것이 작업에 기록 &lt;em&gt;로거&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="94267f95134956d72ce6e87e0afa84eedaad7aa3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dualstack_ipv6&lt;/em&gt; is true and the platform supports it the socket will be able to accept both IPv4 and IPv6 connections, else it will raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;. Most POSIX platforms and Windows are supposed to support this functionality. When this functionality is enabled the address returned by &lt;a href=&quot;#socket.socket.getpeername&quot;&gt;&lt;code&gt;socket.getpeername()&lt;/code&gt;&lt;/a&gt; when an IPv4 connection occurs will be an IPv6 address represented as an IPv4-mapped IPv6 address. If &lt;em&gt;dualstack_ipv6&lt;/em&gt; is false it will explicitly disable this functionality on platforms that enable it by default (e.g. Linux). This parameter can be used in conjunction with &lt;a href=&quot;#socket.has_dualstack_ipv6&quot;&gt;&lt;code&gt;has_dualstack_ipv6()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경우 &lt;em&gt;dualstack_ipv6이&lt;/em&gt; 사실과 플랫폼을 지원하는 소켓이 모두 IPv4 및 IPv6 연결을 받아 들일 수있을 것입니다, 다른 사람이 인상됩니다 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; . 대부분의 POSIX 플랫폼과 Windows는이 기능을 지원해야합니다. 이 기능이 활성화 되면 IPv4 연결이 발생할 때 &lt;a href=&quot;#socket.socket.getpeername&quot;&gt; &lt;code&gt;socket.getpeername()&lt;/code&gt; &lt;/a&gt; 반환 한 주소는 IPv4 매핑 된 IPv6 주소로 표시되는 IPv6 주소가됩니다. 경우 &lt;em&gt;dualstack_ipv6이&lt;/em&gt; 거짓 명시 적으로 기본 (예를 들어, 리눅스)에 의해 활성화 플랫폼에서이 기능을 비활성화합니다. 이 매개 변수는 &lt;a href=&quot;#socket.has_dualstack_ipv6&quot;&gt; &lt;code&gt;has_dualstack_ipv6()&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9581453393604a0750f4d82252f2e5cd9d18898" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;duplex&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) then the pipe is bidirectional. If &lt;em&gt;duplex&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then the pipe is unidirectional: &lt;code&gt;conn1&lt;/code&gt; can only be used for receiving messages and &lt;code&gt;conn2&lt;/code&gt; can only be used for sending messages.</source>
          <target state="translated">경우 &lt;em&gt;양면&lt;/em&gt; 이다 &lt;code&gt;True&lt;/code&gt; (기본값) 다음 파이프는 양방향입니다. 경우 &lt;em&gt;양면&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 그 파이프는 단방향 : &lt;code&gt;conn1&lt;/code&gt; 이라는이 메시지 만 수신 사용할 수 있으며 &lt;code&gt;conn2&lt;/code&gt; 메시지 만 보내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99baa917d4196e3d9a478f232fed0c3fe22f8f57" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;effective_ids&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; will perform its access checks using the effective uid/gid instead of the real uid/gid. &lt;em&gt;effective_ids&lt;/em&gt; may not be supported on your platform; you can check whether or not it is available using &lt;a href=&quot;#os.supports_effective_ids&quot;&gt;&lt;code&gt;os.supports_effective_ids&lt;/code&gt;&lt;/a&gt;. If it is unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;effective_ids가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; 유효 UID / GID 대신 실제의 UID / GID를 사용하여 액세스 검사를 수행합니다. 플랫폼에서 &lt;em&gt;effective_ids&lt;/em&gt; 가 지원되지 않을 수 있습니다. &lt;a href=&quot;#os.supports_effective_ids&quot;&gt; &lt;code&gt;os.supports_effective_ids&lt;/code&gt; 를&lt;/a&gt; 사용하여 사용 가능한지 여부를 확인할 수 있습니다 . 사용할 수 없으면 사용하면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="607534724be78a927f3354c8bcd6f86f04925384" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encode_chunked&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the result of each iteration of &lt;em&gt;message_body&lt;/em&gt; will be chunk-encoded as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7230&lt;/strong&gt;&lt;/a&gt;, Section 3.3.1. How the data is encoded is dependent on the type of &lt;em&gt;message_body&lt;/em&gt;. If &lt;em&gt;message_body&lt;/em&gt; implements the &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;buffer interface&lt;/a&gt; the encoding will result in a single chunk. If &lt;em&gt;message_body&lt;/em&gt; is a &lt;a href=&quot;collections.abc#collections.abc.Iterable&quot;&gt;&lt;code&gt;collections.abc.Iterable&lt;/code&gt;&lt;/a&gt;, each iteration of &lt;em&gt;message_body&lt;/em&gt; will result in a chunk. If &lt;em&gt;message_body&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, each call to &lt;code&gt;.read()&lt;/code&gt; will result in a chunk. The method automatically signals the end of the chunk-encoded data immediately after &lt;em&gt;message_body&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;encode_chunked가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 각 반복의 결과 &lt;em&gt;MESSAGE_BODY은&lt;/em&gt; 청크 인코딩에 규정 된 것 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7230&lt;/strong&gt;&lt;/a&gt; , 3.3.1 절. 데이터가 인코딩되는 방식은 &lt;em&gt;message_body&lt;/em&gt; 유형에 따라 다릅니다 . 경우 &lt;em&gt;MESSAGE_BODY&lt;/em&gt; 구현하는 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;인터페이스 버퍼&lt;/a&gt; 인코딩은 단일 청크 될 것이다. 경우 &lt;em&gt;MESSAGE_BODY는&lt;/em&gt; A는 &lt;a href=&quot;collections.abc#collections.abc.Iterable&quot;&gt; &lt;code&gt;collections.abc.Iterable&lt;/code&gt; &lt;/a&gt; 의 각 반복 &lt;em&gt;MESSAGE_BODY는&lt;/em&gt; 덩어리가 발생합니다. &lt;em&gt;message_body&lt;/em&gt; 가 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 인 경우 &lt;code&gt;.read()&lt;/code&gt; 호출 할 때마다청크가 발생합니다. 이 메소드는 &lt;em&gt;message_body&lt;/em&gt; 바로 뒤에 청크 인코딩 된 데이터의 끝을 자동으로 알립니다 .</target>
        </trans-unit>
        <trans-unit id="7edf08fcadb288478ca315f1c2600e7b135a30a9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; are specified, or &lt;em&gt;text&lt;/em&gt; (also known as &lt;em&gt;universal_newlines&lt;/em&gt;) is true, the file objects &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; will be opened in text mode using the &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; specified in the call or the defaults for &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류가&lt;/em&gt; 지정, 또는 &lt;em&gt;텍스트&lt;/em&gt; (로도 알려져 &lt;em&gt;universal_newlines 것은&lt;/em&gt; ) 사실, 파일은 객체 &lt;em&gt;표준 입력&lt;/em&gt; , &lt;em&gt;표준 출력&lt;/em&gt; 과 &lt;em&gt;표준 에러는&lt;/em&gt; 사용하여 텍스트 모드에서 열립니다 &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 호출에 지정된 또는에 대한 기본값 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="699e55008224a367497000a7c90840cae537dfba" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; are specified, or &lt;em&gt;text&lt;/em&gt; is true, file objects for stdin, stdout and stderr are opened in text mode using the specified &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; or the &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; default. The &lt;em&gt;universal_newlines&lt;/em&gt; argument is equivalent to &lt;em&gt;text&lt;/em&gt; and is provided for backwards compatibility. By default, file objects are opened in binary mode.</source>
          <target state="translated">경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류가&lt;/em&gt; 지정하거나 &lt;em&gt;텍스트가&lt;/em&gt; 사실, 파일은 표준 입력, 표준 출력을 위해 개체 및 stderr 지정된 사용하여 텍스트 모드에서 열립니다 &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 또는 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 의&lt;/a&gt; 기본. &lt;em&gt;universal_newlines의&lt;/em&gt; 인수에 해당 &lt;em&gt;텍스트&lt;/em&gt; 및 이전 버전과의 호환성을 위해 제공됩니다. 기본적으로 파일 객체는 이진 모드로 열립니다.</target>
        </trans-unit>
        <trans-unit id="52638c3e8d67fa2ec0fd557d0879c7a9e57eca8b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; are specified, or &lt;em&gt;text&lt;/em&gt; is true, the file objects &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; are opened in text mode with the specified encoding and &lt;em&gt;errors&lt;/em&gt;, as described above in &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt;. The &lt;em&gt;universal_newlines&lt;/em&gt; argument is equivalent to &lt;em&gt;text&lt;/em&gt; and is provided for backwards compatibility. By default, file objects are opened in binary mode.</source>
          <target state="translated">경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류가&lt;/em&gt; 지정하거나 &lt;em&gt;텍스트가&lt;/em&gt; 사실, 파일 객체 &lt;em&gt;표준 입력&lt;/em&gt; , &lt;em&gt;표준 출력&lt;/em&gt; 및 &lt;em&gt;표준 오류는&lt;/em&gt; 지정된 인코딩과 함께 텍스트 모드에서 열립니다 &lt;em&gt;오류&lt;/em&gt; 에 전술 한 바와 같이, &lt;a href=&quot;#frequently-used-arguments&quot;&gt;자주 사용하는 인수&lt;/a&gt; . &lt;em&gt;universal_newlines의&lt;/em&gt; 인수에 해당 &lt;em&gt;텍스트&lt;/em&gt; 및 이전 버전과의 호환성을 위해 제공됩니다. 기본적으로 파일 객체는 이진 모드로 열립니다.</target>
        </trans-unit>
        <trans-unit id="63d0f1a5631a1c9c1ee3f2e8299762fd8cd8e7d4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ensure_ascii&lt;/em&gt; is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If &lt;em&gt;ensure_ascii&lt;/em&gt; is false, these characters will be output as-is.</source>
          <target state="translated">경우 &lt;em&gt;ensure_ascii가&lt;/em&gt; true (디폴트), 출력은 들어오는 모든 비 ASCII 문자 이스케이프이 보장됩니다. 경우 &lt;em&gt;ensure_ascii이&lt;/em&gt; 거짓-이기 때문에, 이러한 문자가 출력 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5c427089fb1de4505a7a9e6a8fc25b18c3e6e0c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;env&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a mapping that defines the environment variables for the new process; these are used instead of the default behavior of inheriting the current process&amp;rsquo; environment.</source>
          <target state="translated">&lt;em&gt;env&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 새 프로세스의 환경 변수를 정의하는 맵핑이어야합니다. 이들은 현재 프로세스 환경을 상속하는 기본 동작 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87535ea7e24348fb8f4d57c12202af9ca447538a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;env&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a mapping that defines the environment variables for the new process; these are used instead of the default behavior of inheriting the current process&amp;rsquo; environment. It is passed directly to &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;env&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 새 프로세스의 환경 변수를 정의하는 맵핑이어야합니다. 이들은 현재 프로세스 환경을 상속하는 기본 동작 대신 사용됩니다. &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; 에&lt;/a&gt; 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff8cd5fc3865815194e6f233b530a23aa3eba258" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;error_callback&lt;/em&gt; is specified then it should be a callable which accepts a single argument. If the target function fails, then the &lt;em&gt;error_callback&lt;/em&gt; is called with the exception instance.</source>
          <target state="translated">&lt;em&gt;error_callback&lt;/em&gt; 이 지정 되면 단일 인수를 허용하는 호출 가능이어야합니다. 대상 함수가 실패 하면 예외 인스턴스와 함께 &lt;em&gt;error_callback&lt;/em&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a716812bb95f42a90866514c37dd0d4203eae841" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;errorlevel&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt;, all errors are ignored when using &lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt;&lt;code&gt;TarFile.extract()&lt;/code&gt;&lt;/a&gt;. Nevertheless, they appear as error messages in the debug output, when debugging is enabled. If &lt;code&gt;1&lt;/code&gt;, all &lt;em&gt;fatal&lt;/em&gt; errors are raised as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exceptions. If &lt;code&gt;2&lt;/code&gt;, all &lt;em&gt;non-fatal&lt;/em&gt; errors are raised as &lt;a href=&quot;#tarfile.TarError&quot;&gt;&lt;code&gt;TarError&lt;/code&gt;&lt;/a&gt; exceptions as well.</source>
          <target state="translated">경우 &lt;em&gt;오류 수준이&lt;/em&gt; 이다 &lt;code&gt;0&lt;/code&gt; , 모든 오류는 사용할 때 무시됩니다 &lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt; &lt;code&gt;TarFile.extract()&lt;/code&gt; &lt;/a&gt; . 그럼에도 불구하고 디버깅이 활성화되면 디버그 출력에 오류 메시지로 나타납니다. &lt;code&gt;1&lt;/code&gt; 인 경우 모든 &lt;em&gt;치명적&lt;/em&gt; 오류가 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외로 발생합니다. &lt;code&gt;2&lt;/code&gt; 인 경우 &lt;em&gt;치명적이지 않은&lt;/em&gt; 모든 오류도 &lt;a href=&quot;#tarfile.TarError&quot;&gt; &lt;code&gt;TarError&lt;/code&gt; &lt;/a&gt; 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4cdee59d973926ccbf68873b846e74e0fc64b06e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exc_info&lt;/em&gt; does not evaluate as false, it causes exception information to be added to the logging message. If an exception tuple (in the format returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;) or an exception instance is provided, it is used; otherwise, &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt; is called to get the exception information.</source>
          <target state="translated">경우 &lt;em&gt;exc_info이&lt;/em&gt; 거짓으로 평가하지 않습니다, 그것은 예외 정보 로깅 메시지에 추가됩니다. 예외 튜플 ( &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 반환 한 형식 ) 또는 예외 인스턴스가 제공되면 사용됩니다. 그렇지 않으면 예외 정보를 얻기 위해 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="97d130dcbf3bae5b901a129e219774af57b99697" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exc_type&lt;/em&gt; is &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt;, the exception is silently ignored. Otherwise, the exception is printed out on &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;exc_type가&lt;/em&gt; 있다 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; 없이&lt;/a&gt; , 예외가 자동으로 무시됩니다. 그렇지 않으면 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt; 에 예외가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="d411ffd6142ab0891751015edec151dc77ef2c0a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exist_ok&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default), an &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is raised if the target directory already exists.</source>
          <target state="translated">경우 &lt;em&gt;exist_ok이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본), &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 은&lt;/a&gt; 대상 디렉토리가 이미 존재하는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2db5d05fedef1a16fd234aa31609df5c35a8e34b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exist_ok&lt;/em&gt; is false (the default), &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is raised if the target directory already exists.</source>
          <target state="translated">경우 &lt;em&gt;exist_ok가&lt;/em&gt; false (기본값), &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 은&lt;/a&gt; 대상 디렉토리가 이미 존재하는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="151c18046b0057879a6273bc9b7b8b67d5a66254" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exist_ok&lt;/em&gt; is true, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; exceptions will be ignored (same behavior as the POSIX &lt;code&gt;mkdir -p&lt;/code&gt; command), but only if the last path component is not an existing non-directory file.</source>
          <target state="translated">경우 &lt;em&gt;exist_ok는&lt;/em&gt; 사실, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 의&lt;/a&gt; 예외합니다 (POSIX와 같은 행동을 무시됩니다 &lt;code&gt;mkdir -p&lt;/code&gt; 명령을),하지만 마지막 경로 구성 요소가 기존 디렉토리가 아닌 파일이 아닌 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3700ef2eaa5a7011d3f7e0d02c4ae3309bb21da3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;expand&lt;/em&gt; is set to &lt;code&gt;False&lt;/code&gt;, the path will not be expanded using the variables.</source>
          <target state="translated">경우 &lt;em&gt;확장&lt;/em&gt; 으로 설정 &lt;code&gt;False&lt;/code&gt; , 경로 변수를 사용하여 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3d0c579641706b0f541c875d40a987796ca4535" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;expand&lt;/em&gt; is set to false, the paths will not be expanded.</source>
          <target state="translated">경우 &lt;em&gt;확장&lt;/em&gt; false로 설정, 경로가 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="950957f8e4ed1166943a35b1541f1f3253fb73bb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;factory&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; the default task factory will be set. Otherwise, &lt;em&gt;factory&lt;/em&gt; must be a &lt;em&gt;callable&lt;/em&gt; with the signature matching &lt;code&gt;(loop, coro)&lt;/code&gt;, where &lt;em&gt;loop&lt;/em&gt; is a reference to the active event loop, and &lt;em&gt;coro&lt;/em&gt; is a coroutine object. The callable must return a &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt;&lt;code&gt;asyncio.Future&lt;/code&gt;&lt;/a&gt;-compatible object.</source>
          <target state="translated">경우 &lt;em&gt;공장&lt;/em&gt; 입니다 &lt;code&gt;None&lt;/code&gt; 기본 작업 공장이 설정됩니다. 그렇지 않으면, &lt;em&gt;팩토리&lt;/em&gt; 는 서명 일치 &lt;code&gt;(loop, coro)&lt;/code&gt; 로 &lt;em&gt;호출 가능&lt;/em&gt; 해야합니다. 여기서 &lt;em&gt;loop&lt;/em&gt; 는 활성 이벤트 루프에 대한 참조이고 &lt;em&gt;coro&lt;/em&gt; 는 코 루틴 오브젝트입니다. 콜 &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt; &lt;code&gt;asyncio.Future&lt;/code&gt; &lt;/a&gt; 은 asyncio.Future 호환 객체를 반환해야 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cde1a7a5d298627fbad97256eb936031b2f8b9e2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file&lt;/em&gt; is a string, open the file by that name, otherwise treat it as a file-like object. &lt;em&gt;mode&lt;/em&gt; can be:</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 이 문자열 인 경우 해당 이름으로 파일을 열거 나 그렇지 않으면 파일과 같은 객체로 취급하십시오. &lt;em&gt;모드&lt;/em&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67d175cb8486589a948e2cf74ce3849b7236be76" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file&lt;/em&gt; is not specified, read from &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;파일이&lt;/em&gt; 지정되지 않은, 읽기 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c9ed3d94894a12395907e88bfe7b2901ae44f4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file_encoding&lt;/em&gt; is not given, it defaults to &lt;em&gt;data_encoding&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;file_encoding을&lt;/em&gt; 하기 위해서는 기본적으로 제공되지 &lt;em&gt;data_encoding을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="76758843e2e5c710ae0a6372d1081e6f9d9e89c4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file_or_dir&lt;/em&gt; is a directory and not a symbolic link, then recursively descend the directory tree named by &lt;em&gt;file_or_dir&lt;/em&gt;, checking all &lt;code&gt;.py&lt;/code&gt; files along the way. If &lt;em&gt;file_or_dir&lt;/em&gt; is an ordinary Python source file, it is checked for whitespace related problems. The diagnostic messages are written to standard output using the &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;em&gt;file_or_dir&lt;/em&gt; 이 심볼릭 링크가 아닌 디렉토리 인 경우 &lt;em&gt;file_or_dir&lt;/em&gt; 로 명명 된 디렉토리 트리를 재귀 적으로 &lt;em&gt;내림차순&lt;/em&gt; 으로 모든 &lt;code&gt;.py&lt;/code&gt; 파일을 검사합니다 . 경우 &lt;em&gt;에 나오는 file_or_dir은&lt;/em&gt; 일반 파이썬 소스 파일입니다, 그것은 공백 관련 문제를 확인합니다. 진단 메시지는 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 표준 출력에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="8147d1cd319a466257a1243b03ade84b3c9e406b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filelike&lt;/em&gt; has a &lt;code&gt;close()&lt;/code&gt; method, the returned object will also have a &lt;code&gt;close()&lt;/code&gt; method, and it will invoke the &lt;em&gt;filelike&lt;/em&gt; object&amp;rsquo;s &lt;code&gt;close()&lt;/code&gt; method when called.</source>
          <target state="translated">&lt;em&gt;filelike&lt;/em&gt; 에 &lt;code&gt;close()&lt;/code&gt; 메서드 가 있으면 반환 된 객체에도 &lt;code&gt;close()&lt;/code&gt; 메서드가 있으며 호출 될 때 &lt;em&gt;파일과 같은&lt;/em&gt; 객체의 &lt;code&gt;close()&lt;/code&gt; 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="48cc1454e821d6920b8394ca56ab7ba76323cb6d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object, open the named file directly. Otherwise, &lt;em&gt;filename&lt;/em&gt; should be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, which will be used to read or write the compressed data.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름이&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 직접라는 이름의 파일을 엽니 다. 그렇지 않으면 &lt;em&gt;filename&lt;/em&gt; 은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 여야하며 압축 된 데이터를 읽거나 쓰는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b07d149a1e1e8508bf416df0ffabf52508cd4717" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is a file object (rather than an actual file name), a mode of &lt;code&gt;&quot;w&quot;&lt;/code&gt; does not truncate the file, and is instead equivalent to &lt;code&gt;&quot;a&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이 실제 파일 이름이 아닌 파일 객체 인 경우 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 모드 는 파일을 자르지 않으며 대신 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1c18ac97e77df1feec965478ce33eedf1e1130a6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is a file object (rather than an actual file name), a mode of &lt;code&gt;'w'&lt;/code&gt; does not truncate the file, and is instead equivalent to &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이 실제 파일 이름이 아닌 파일 객체 인 경우 &lt;code&gt;'w'&lt;/code&gt; 모드 는 파일을 자르지 않으며 대신 &lt;code&gt;'a'&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4b4caaad3a0e78f58783527b4ec2b5bee1735031" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is specified, open the file in this &lt;a href=&quot;functions#filemodes&quot;&gt;mode&lt;/a&gt;. Defaults to &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름&lt;/em&gt; 지정이있는 파일 열기 &lt;a href=&quot;functions#filemodes&quot;&gt;모드를&lt;/a&gt; . 기본값은 &lt;code&gt;'a'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6af85c4bc7806c30929d3ef968f1f66afef5d04c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is specified, use it as the value of the &lt;code&gt;filename&lt;/code&gt; parameter of the &lt;em&gt;Content-Disposition&lt;/em&gt; header.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이 지정된 경우 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 의 &lt;code&gt;filename&lt;/code&gt; 매개 변수 값으로 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9df42f67fa743cce97d1afbbf64f8287dc75452d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filenames&lt;/em&gt; is a string, a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;, it is treated as a single filename. If a file named in &lt;em&gt;filenames&lt;/em&gt; cannot be opened, that file will be ignored. This is designed so that you can specify an iterable of potential configuration file locations (for example, the current directory, the user&amp;rsquo;s home directory, and some system-wide directory), and all existing configuration files in the iterable will be read.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름&lt;/em&gt; 문자열입니다하는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로가 같은 객체&lt;/a&gt; 는, 단일의 파일 이름으로 처리됩니다. &lt;em&gt;filenames로 이름&lt;/em&gt; 이 지정된 &lt;em&gt;파일&lt;/em&gt; 을 열 수 없으면 해당 파일은 무시됩니다. 이는 잠재적 인 구성 파일 위치 (예 : 현재 디렉토리, 사용자의 홈 디렉토리 및 일부 시스템 전체 디렉토리)의 반복 가능을 지정할 수 있도록 설계되었으며 반복 가능한 기존의 모든 구성 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cb50194f67b844fcbdfed4147a0e69c6aa03bd88" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fileno&lt;/em&gt; is specified, the values for &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt;, and &lt;em&gt;proto&lt;/em&gt; are auto-detected from the specified file descriptor. Auto-detection can be overruled by calling the function with explicit &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt;, or &lt;em&gt;proto&lt;/em&gt; arguments. This only affects how Python represents e.g. the return value of &lt;a href=&quot;#socket.socket.getpeername&quot;&gt;&lt;code&gt;socket.getpeername()&lt;/code&gt;&lt;/a&gt; but not the actual OS resource. Unlike &lt;a href=&quot;#socket.fromfd&quot;&gt;&lt;code&gt;socket.fromfd()&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;fileno&lt;/em&gt; will return the same socket and not a duplicate. This may help close a detached socket using &lt;a href=&quot;#socket.close&quot;&gt;&lt;code&gt;socket.close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;fileno가&lt;/em&gt; 지정된 경우의 값 &lt;em&gt;가족&lt;/em&gt; , &lt;em&gt;유형&lt;/em&gt; 및 &lt;em&gt;프로토는&lt;/em&gt; 자동으로 감지 지정된 파일 기술자에서입니다. 명시 적 &lt;em&gt;family&lt;/em&gt; , &lt;em&gt;type&lt;/em&gt; 또는 &lt;em&gt;proto&lt;/em&gt; 인수를 사용 하여 함수를 호출하면 자동 감지를 무시할 수 있습니다 . 이것은 파이썬이 표현하는 방법에만 영향을 미칩니다. 예를 들어 &lt;a href=&quot;#socket.socket.getpeername&quot;&gt; &lt;code&gt;socket.getpeername()&lt;/code&gt; &lt;/a&gt; 의 반환 값은 실제 OS 리소스가 아닙니다. 달리 &lt;a href=&quot;#socket.fromfd&quot;&gt; &lt;code&gt;socket.fromfd()&lt;/code&gt; &lt;/a&gt; , &lt;em&gt;fileno는&lt;/em&gt; 같은 소켓이 아닌 중복을 반환합니다. 이것은 &lt;a href=&quot;#socket.close&quot;&gt; &lt;code&gt;socket.close()&lt;/code&gt; &lt;/a&gt; 사용하여 분리 된 소켓을 닫는 데 도움이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cad3934c4f6ad00649995ab7289422c5ddfc6d68" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fileobj&lt;/em&gt; is given, it is used for reading or writing data. If it can be determined, &lt;em&gt;mode&lt;/em&gt; is overridden by &lt;em&gt;fileobj&lt;/em&gt;&amp;rsquo;s mode. &lt;em&gt;fileobj&lt;/em&gt; will be used from position 0.</source>
          <target state="translated">경우 &lt;em&gt;fileobj이&lt;/em&gt; 주어집니다, 그것은 데이터를 읽거나 쓰기 위해 사용된다. 그것이 결정될 수 있다면, &lt;em&gt;모드&lt;/em&gt; 는 &lt;em&gt;fileobj&lt;/em&gt; 의 &lt;em&gt;모드&lt;/em&gt; 로 대체됩니다 . &lt;em&gt;fileobj&lt;/em&gt; 는 위치 0에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d760e902d1a9a9274ea97101800dd62b508b5620" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fileobj&lt;/em&gt; is specified, it is used as an alternative to a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened in binary mode for &lt;em&gt;name&lt;/em&gt;. It is supposed to be at position 0.</source>
          <target state="translated">경우 &lt;em&gt;fileobj가&lt;/em&gt; 지정되어, 그것은 대안으로 사용되는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 에 대한 바이너리 모드로 열 &lt;em&gt;이름&lt;/em&gt; . 위치 0에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dae7cbc850bce550396ab6a5e4f90017603d189c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;files&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; the internal data structure is completely rebuilt to its initial default value. This is a stable operation and will produce the same results when called multiple times.</source>
          <target state="translated">경우 &lt;em&gt;파일&lt;/em&gt; 입니다 &lt;code&gt;None&lt;/code&gt; 내부 데이터 구조가 완전히 초기 기본 값으로 재 구축됩니다. 이는 안정적인 작업이며 여러 번 호출 될 때 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="342f942c82ec8e80a515a3a240295a1556b0f119" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;first_line&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</source>
          <target state="translated">&lt;em&gt;first_line&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 디스 어셈블 된 코드에서 첫 번째 소스 행에 대해보고해야하는 행 번호를 나타냅니다. 그렇지 않으면 소스 라인 정보 (있는 경우)가 디스 어셈블 된 코드 객체에서 직접 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6e5911d01f22e7a53df624823fe8cad9cc059dfb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fix_imports&lt;/em&gt; is true and &lt;em&gt;protocol&lt;/em&gt; is less than 3, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</source>
          <target state="translated">경우 &lt;em&gt;fix_imports가&lt;/em&gt; 사실이고 &lt;em&gt;프로토콜은&lt;/em&gt; 3보다 작은 피클은 피클 데이터 스트림 파이썬 2 읽을 그래서, 파이썬 2에서 사용 된 모듈 이름에 새로운 파이썬 3 명을 매핑 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c458fcb92551aa4179a0ee8c3ec9f897777d84c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; has another value, then the status of the newsgroup should be considered unknown.</source>
          <target state="translated">&lt;em&gt;플래그&lt;/em&gt; 에 다른 값이 있으면 뉴스 그룹의 상태를 알 수없는 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd5ac0ee5de4a2ac67078bdcdfed8efdc0a7e6d9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, after a few milliseconds, an escape sequence will not be interpreted, and will be left in the input stream as is.</source>
          <target state="translated">&lt;em&gt;플래그&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 몇 밀리 초 후에 이스케이프 시퀀스가 ​​해석되지 않고 그대로 입력 스트림에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="05e2c86e5fa6ae70395c93eb2082fe2efd1b66ad" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, curses no longer considers using the hardware insert/delete character feature of the terminal; if &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, use of character insertion and deletion is enabled. When curses is first initialized, use of character insert/delete is enabled by default.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 더 이상 단말기의 하드웨어 삽입 / 삭제 문자 기능을 사용하여 고려 저주 없다 경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 문자 삽입과 삭제의 사용이 활성화됩니다. 저주가 처음 초기화되면 기본적으로 문자 삽입 / 삭제 사용이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="93111a903d42affcb1b92cdf76c31a4ded5864f7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, cursor will always be at &amp;ldquo;cursor position&amp;rdquo; after an update.</source>
          <target state="translated">&lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 , 업데이트 후 커서는 항상 &quot;커서 위치&quot;에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="927b0ac6123fcfbd9d4b43d6b6a0df82d95c5b38" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the effect is the same as calling &lt;a href=&quot;#curses.noqiflush&quot;&gt;&lt;code&gt;noqiflush()&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, or no argument is provided, the queues will be flushed when these control characters are read.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 효과가 호출하는 것과 동일 &lt;a href=&quot;#curses.noqiflush&quot;&gt; &lt;code&gt;noqiflush()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 또는 인수를 제공하지 이러한 제어 문자를 읽을 때 큐를 플러시 할 것이다.</target>
        </trans-unit>
        <trans-unit id="dc34adf1b0cd9cd2daf9fae31e473262b7ba2c27" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#curses.window.getch&quot;&gt;&lt;code&gt;getch()&lt;/code&gt;&lt;/a&gt; will be non-blocking.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#curses.window.getch&quot;&gt; &lt;code&gt;getch()&lt;/code&gt; &lt;/a&gt; 비 차단 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b4b0114fea39b01c456c42a03e99b9d6724d928" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt; will try and use hardware line editing facilities. Otherwise, line insertion/deletion are disabled.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 하려고합니다 사용 하드웨어 라인 설비를 편집. 그렇지 않으면 라인 삽입 / 삭제가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="76906428c5886677b5bf5a701073b0866ac9c47c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, allow 8-bit characters to be input. If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, allow only 7-bit chars.</source>
          <target state="translated">&lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 8 비트 문자를 입력 할 수 있습니다. 경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 만 7 비트 문자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="06fc114a8ed7cdc8c7c9f51b3779e8ccf43597dc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, any change in the window image automatically causes the window to be refreshed; you no longer have to call &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; yourself. However, it may degrade performance considerably, due to repeated calls to wrefresh. This option is disabled by default.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 윈도우 이미지의 모든 변경 사항이 자동으로 갱신 할 수있는 창이 원인; 더 이상 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 직접 호출 할 필요가 없습니다 . 그러나 wrefresh 호출이 반복되어 성능이 크게 저하 될 수 있습니다. 이 옵션은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="06be27fe5690b343d7c782f196aedecd59d5593b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, cursor is left where it is on update, instead of being at &amp;ldquo;cursor position.&amp;rdquo; This reduces cursor movement where possible. If possible the cursor will be made invisible.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; 대신에가되는 업데이트에이고, 커서는 남아 &quot;커서 위치.&quot; 가능한 경우 커서 이동이 줄어 듭니다. 가능하면 커서가 보이지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f3b65bf56ecd36575c4c78068a2150d9cf1c52" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, escape sequences generated by some keys (keypad, function keys) will be interpreted by &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, escape sequences will be left as is in the input stream.</source>
          <target state="translated">&lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 일부 키 (키패드, 기능 키)로 생성 된 이스케이프 시퀀스는 &lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 . &lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 , 이스케이프 시퀀스는 입력 스트림에서 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a2a9d18c81906fc88496c93e2ee95c2ec1e7a5f5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, escape sequences will not be timed out.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 이스케이프 시퀀스 시간이 초과되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffb0dbfa616feb4ae93cd41e04da978adc1b3014" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the next call to &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; will clear the window completely.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; 에 다음 호출 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 완전히 창을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="a8c3c261a3289123c7ec484215dd4ac72bcaec28" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;a href=&quot;#curses.window.syncup&quot;&gt;&lt;code&gt;syncup()&lt;/code&gt;&lt;/a&gt; is called automatically whenever there is a change in the window.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 다음 &lt;a href=&quot;#curses.window.syncup&quot;&gt; &lt;code&gt;syncup()&lt;/code&gt; &lt;/a&gt; 윈도우에 변화가있을 때마다 자동으로 호출된다.</target>
        </trans-unit>
        <trans-unit id="54238747de3a909db924c82086364dce0b3b6035" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is true, turn debugging on. Otherwise, turn debugging off. When debugging is on, commands to be executed are printed, and the shell is given &lt;code&gt;set -x&lt;/code&gt; command to be more verbose.</source>
          <target state="translated">경우 &lt;em&gt;플래그가&lt;/em&gt; true 인, 디버깅을 켜십시오. 그렇지 않으면 디버깅을 끕니다. 디버깅이 설정되면 실행할 명령이 인쇄되고 쉘에 &lt;code&gt;set -x&lt;/code&gt; 명령이 더 자세하게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0a676f79bdec3d8d55c49f7b6418938f946ea982" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fmt&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, use the following default &lt;em&gt;fmt&lt;/em&gt;:</source>
          <target state="translated">경우 &lt;em&gt;FMT가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 다음과 같은 기본 사용 &lt;em&gt;FMT를&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="3b5abf51d5e979202e366a84df39077b1602bd52" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, return &lt;code&gt;True&lt;/code&gt; only if this entry is a directory (without following symlinks); return &lt;code&gt;False&lt;/code&gt; if the entry is any other kind of file or if it doesn&amp;rsquo;t exist anymore.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 를 반환 &lt;code&gt;True&lt;/code&gt; 이 항목이 디렉토리 (다음 심볼릭 링크없이) 인 경우에만; 항목이 다른 종류의 파일이거나 더 이상 존재하지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b449d1a838bf30bc8e83f6404dc93c18180c4e9b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, return &lt;code&gt;True&lt;/code&gt; only if this entry is a file (without following symlinks); return &lt;code&gt;False&lt;/code&gt; if the entry is a directory or other non-file entry, or if it doesn&amp;rsquo;t exist anymore.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 를 반환 &lt;code&gt;True&lt;/code&gt; 이 항목이 파일 (다음 심볼릭 링크없이) 인 경우에만; 항목이 디렉토리 또는 기타 파일이 아닌 항목이거나 더 이상 존재하지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2c810ead4934973b38f7ba460ecc6b76eb321e40" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is false and &lt;em&gt;src&lt;/em&gt; is a symbolic link, a new symbolic link will be created instead of copying the file &lt;em&gt;src&lt;/em&gt; points to.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이며, &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, 새로운 심볼 링크 대신에 파일을 복사하는 생성됩니다 &lt;em&gt;SRC&lt;/em&gt; 에 포인트를.</target>
        </trans-unit>
        <trans-unit id="3791f9b1ad913c64dfe3c483d0e89806dc737039" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is false, and &lt;em&gt;src&lt;/em&gt; and &lt;em&gt;dst&lt;/em&gt; both refer to symbolic links, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; will operate on the symbolic links themselves rather than the files the symbolic links refer to&amp;mdash;reading the information from the &lt;em&gt;src&lt;/em&gt; symbolic link, and writing the information to the &lt;em&gt;dst&lt;/em&gt; symbolic link.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이고 &lt;em&gt;SRC&lt;/em&gt; 와 &lt;em&gt;DST&lt;/em&gt; 모두 기호 링크를 참조 &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 기호 링크에서 작동 자체가 아니라 심볼릭 링크가-읽기의 정보 참조하는 파일보다 &lt;em&gt;SRC&lt;/em&gt; 심볼릭 링크를, 그리고에 대한 정보를 기록 &lt;em&gt;dst&lt;/em&gt; 기호 링크.</target>
        </trans-unit>
        <trans-unit id="05aea198a5b1eab18e23d436268151142cdfb7c9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is false, and &lt;em&gt;src&lt;/em&gt; is a symbolic link, &lt;em&gt;dst&lt;/em&gt; will be created as a symbolic link. If &lt;em&gt;follow_symlinks&lt;/em&gt; is true and &lt;em&gt;src&lt;/em&gt; is a symbolic link, &lt;em&gt;dst&lt;/em&gt; will be a copy of the file &lt;em&gt;src&lt;/em&gt; refers to.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이며, &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, &lt;em&gt;DST는&lt;/em&gt; 심볼릭 링크로 생성됩니다. 경우 &lt;em&gt;follow_symlinks가&lt;/em&gt; 사실이고 &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, &lt;em&gt;DST는&lt;/em&gt; 파일의 복사본이 될 것입니다 &lt;em&gt;SRC가&lt;/em&gt; 에 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ad63af89430c98aa694c40b5d47925c5c967f84b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;force&lt;/em&gt; is true, modules are re-compiled even if the timestamps are up to date.</source>
          <target state="translated">경우 &lt;em&gt;힘은&lt;/em&gt; 사실, 모듈 타임 스탬프가 최신 인 경우에도 재 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="db56c32c75e8f39f5a049b963d87f7483bb3f491" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;format&lt;/em&gt; is specified, use this style for the format string. One of &lt;code&gt;'%'&lt;/code&gt;, &lt;code&gt;'{'&lt;/code&gt; or &lt;code&gt;'$'&lt;/code&gt; for &lt;a href=&quot;stdtypes#old-string-formatting&quot;&gt;printf-style&lt;/a&gt;, &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#string.Template&quot;&gt;&lt;code&gt;string.Template&lt;/code&gt;&lt;/a&gt; respectively. Defaults to &lt;code&gt;'%'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 이 지정된 경우 &lt;em&gt;형식&lt;/em&gt; 문자열에이 스타일을 사용하십시오. 하나의 &lt;code&gt;'%'&lt;/code&gt; , &lt;code&gt;'{'&lt;/code&gt; 또는 &lt;code&gt;'$'&lt;/code&gt; 에 대한 &lt;a href=&quot;stdtypes#old-string-formatting&quot;&gt;printf와 스타일&lt;/a&gt; , &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;string#string.Template&quot;&gt; &lt;code&gt;string.Template&lt;/code&gt; &lt;/a&gt; 각각. 기본값은 &lt;code&gt;'%'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9c993dc4953aefb555e95150b85e635f8eb734c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;format&lt;/em&gt; requires a single argument, &lt;em&gt;values&lt;/em&gt; may be a single non-tuple object. &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt; Otherwise, &lt;em&gt;values&lt;/em&gt; must be a tuple with exactly the number of items specified by the format string, or a single mapping object (for example, a dictionary).</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 에 단일 인수가 필요한 경우 &lt;em&gt;값&lt;/em&gt; 은 단일 비 튜플 객체 일 수 있습니다. &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt; 그렇지 않으면, &lt;em&gt;값&lt;/em&gt; 은 형식 문자열로 지정된 항목 수 또는 단일 맵핑 오브젝트 (예 : 사전)가있는 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc9128599baccee2d3226e85c7c2b9cc2cb9b2f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;format&lt;/em&gt; requires a single argument, &lt;em&gt;values&lt;/em&gt; may be a single non-tuple object. &lt;a href=&quot;#id16&quot; id=&quot;id11&quot;&gt;5&lt;/a&gt; Otherwise, &lt;em&gt;values&lt;/em&gt; must be a tuple with exactly the number of items specified by the format bytes object, or a single mapping object (for example, a dictionary).</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 에 단일 인수가 필요한 경우 &lt;em&gt;값&lt;/em&gt; 은 단일 비 튜플 객체 일 수 있습니다. &lt;a href=&quot;#id16&quot; id=&quot;id11&quot;&gt;5&lt;/a&gt; 그렇지 않으면 &lt;em&gt;값&lt;/em&gt; 은 format bytes 객체에 지정된 항목 수 또는 단일 매핑 객체 (예 : 사전)가있는 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d48e3331edd32ebb17d2aa8d9c936c8508567fe2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;from_addr&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; or &lt;em&gt;to_addrs&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;send_message&lt;/code&gt; fills those arguments with addresses extracted from the headers of &lt;em&gt;msg&lt;/em&gt; as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;: &lt;em&gt;from_addr&lt;/em&gt; is set to the &lt;em&gt;Sender&lt;/em&gt; field if it is present, and otherwise to the &lt;em&gt;From&lt;/em&gt; field. &lt;em&gt;to_addrs&lt;/em&gt; combines the values (if any) of the &lt;em&gt;To&lt;/em&gt;, &lt;em&gt;Cc&lt;/em&gt;, and &lt;em&gt;Bcc&lt;/em&gt; fields from &lt;em&gt;msg&lt;/em&gt;. If exactly one set of &lt;em&gt;Resent-*&lt;/em&gt; headers appear in the message, the regular headers are ignored and the &lt;em&gt;Resent-*&lt;/em&gt; headers are used instead. If the message contains more than one set of &lt;em&gt;Resent-*&lt;/em&gt; headers, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised, since there is no way to unambiguously detect the most recent set of &lt;em&gt;Resent-&lt;/em&gt; headers.</source>
          <target state="translated">경우 &lt;em&gt;from_addr가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; 또는 &lt;em&gt;to_addrs가&lt;/em&gt; 된다 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;send_message&lt;/code&gt; 채우기의 헤더로부터 추출 주소지 인수 &lt;em&gt;MSG&lt;/em&gt; 에 규정 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; : &lt;em&gt;from_addr가&lt;/em&gt; 받는 설정 &lt;em&gt;발신자&lt;/em&gt; 가 존재한다면 필드와 달리 행 &lt;em&gt;에서&lt;/em&gt; 필드. &lt;em&gt;to_addrs&lt;/em&gt; 는 &lt;em&gt;msg&lt;/em&gt; 의 &lt;em&gt;To&lt;/em&gt; , &lt;em&gt;Cc&lt;/em&gt; 및 &lt;em&gt;Bcc&lt;/em&gt; 필드 값 (있는 경우)을 결합합니다 . 정확히 하나의 &lt;em&gt;Resent- *&lt;/em&gt; 헤더 세트가 메시지에 표시되면 일반 헤더는 무시되고&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;Resent- *&lt;/em&gt; 헤더가 대신 사용됩니다. 메시지에 둘 이상의 &lt;em&gt;Resent- *&lt;/em&gt; 헤더 세트가 포함 된 경우 가장 최근 &lt;em&gt;Resent-&lt;/em&gt; 헤더 세트를 명확하게 감지 할 방법이 없으므로 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feea519ba7ec87396ed4869230c2a276f4279c66" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;func&lt;/em&gt; is supplied, it should be a function of two arguments. Elements of the input &lt;em&gt;iterable&lt;/em&gt; may be any type that can be accepted as arguments to &lt;em&gt;func&lt;/em&gt;. (For example, with the default operation of addition, elements may be any addable type including &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">경우 &lt;em&gt;FUNC가&lt;/em&gt; 공급되고, 두 개의 인수의 함수이어야한다. 입력 &lt;em&gt;iterable의&lt;/em&gt; 요소는 &lt;em&gt;func에&lt;/em&gt; 대한 인수로 허용 될 수있는 모든 유형일 수 있습니다 . 예를 들어, 더하기의 기본 연산에서 요소는 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 포함한 추가 가능한 유형일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="164544b1932b60456584e8f1c72c01d2623fcbf2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;gen_func&lt;/em&gt; is a generator function, it will be modified in-place.</source>
          <target state="translated">경우 &lt;em&gt;gen_func가&lt;/em&gt; 발전기 기능은, 그것은 현재 위치에서 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ae0ede519983eaf3ab2b7313089869e4e7d5c637" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;gen_func&lt;/em&gt; is not a generator function, it will be wrapped. If it returns an instance of &lt;a href=&quot;collections.abc#collections.abc.Generator&quot;&gt;&lt;code&gt;collections.abc.Generator&lt;/code&gt;&lt;/a&gt;, the instance will be wrapped in an &lt;em&gt;awaitable&lt;/em&gt; proxy object. All other types of objects will be returned as is.</source>
          <target state="translated">&lt;em&gt;gen_func&lt;/em&gt; 가 생성기 함수가 아닌 경우 랩핑됩니다. &lt;a href=&quot;collections.abc#collections.abc.Generator&quot;&gt; &lt;code&gt;collections.abc.Generator&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하면 인스턴스 는 &lt;em&gt;대기 가능한&lt;/em&gt; 프록시 오브젝트 로 랩핑됩니다 . 다른 모든 유형의 객체는 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf24817a5521bbff63768774eb4199f2d3c3e247" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;generator&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; with no currently associated frame, then an empty dictionary is returned. &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised if &lt;em&gt;generator&lt;/em&gt; is not a Python generator object.</source>
          <target state="translated">경우 &lt;em&gt;발전기&lt;/em&gt; A는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 없이 현재 관련 프레임, 빈 상태 (empty)의 사전이 반환됩니다. &lt;em&gt;generator&lt;/em&gt; 가 Python 생성기 객체가 아닌 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="46bc5fd0aa6bec8a23e0345b1203f16848d81f41" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;handler&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the default exception handler will be set. Otherwise, &lt;em&gt;handler&lt;/em&gt; must be a callable with the signature matching &lt;code&gt;(loop, context)&lt;/code&gt;, where &lt;code&gt;loop&lt;/code&gt; is a reference to the active event loop, and &lt;code&gt;context&lt;/code&gt; is a &lt;code&gt;dict&lt;/code&gt; object containing the details of the exception (see &lt;a href=&quot;#asyncio.loop.call_exception_handler&quot;&gt;&lt;code&gt;call_exception_handler()&lt;/code&gt;&lt;/a&gt; documentation for details about context).</source>
          <target state="translated">경우 &lt;em&gt;핸들러가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 기본 예외 핸들러가 설정됩니다. 그렇지 않으면 &lt;em&gt;핸들러&lt;/em&gt; 는 서명 일치 &lt;code&gt;(loop, context)&lt;/code&gt; 로 호출 가능해야합니다. 여기서 &lt;code&gt;loop&lt;/code&gt; 는 활성 이벤트 루프에 대한 참조이고 &lt;code&gt;context&lt;/code&gt; 는 예외에 대한 세부 사항을 포함 하는 &lt;code&gt;dict&lt;/code&gt; 오브젝트입니다 &lt;a href=&quot;#asyncio.loop.call_exception_handler&quot;&gt; &lt;code&gt;call_exception_handler()&lt;/code&gt; &lt;/a&gt; 컨텍스트에 대한 세부 사항 은 call_exception_handler () 문서 참조 ). ).</target>
        </trans-unit>
        <trans-unit id="f0f448033d3ee18b041c00dcd5e55dde7d7efa40" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;headers&lt;/em&gt; contains neither Content-Length nor Transfer-Encoding, but there is a request body, one of those header fields will be added automatically. If &lt;em&gt;body&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the Content-Length header is set to &lt;code&gt;0&lt;/code&gt; for methods that expect a body (&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;PATCH&lt;/code&gt;). If &lt;em&gt;body&lt;/em&gt; is a string or a bytes-like object that is not also a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file&lt;/a&gt;, the Content-Length header is set to its length. Any other type of &lt;em&gt;body&lt;/em&gt; (files and iterables in general) will be chunk-encoded, and the Transfer-Encoding header will automatically be set instead of Content-Length.</source>
          <target state="translated">경우 &lt;em&gt;헤더&lt;/em&gt; 도 콘텐츠 길이도 전송 인코딩을 포함하지만, 요청 본문이 그 헤더 필드 중 하나가 자동으로 추가됩니다. &lt;em&gt;body&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이면 &lt;em&gt;본문&lt;/em&gt; 을 예상하는 메서드 ( &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 및 &lt;code&gt;PATCH&lt;/code&gt; )에 대해 Content-Length 헤더가 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 경우 &lt;em&gt;몸이&lt;/em&gt; 문자열이나 바이트와 같은 객체도 아닌 것입니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일&lt;/a&gt; , 콘텐츠 길이 헤더의 길이로 설정됩니다. 다른 유형의 &lt;em&gt;본문&lt;/em&gt; (일반적으로 파일 및 이터 러블)은 청크 인코딩되며 전송 길이 헤더는 Content-Length 대신 자동으로 설정됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5623776bc8cb206e64b194eac78038ac0ca5ac63" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;headers&lt;/em&gt; is specified and is a list of strings of the form &lt;code&gt;headername: headervalue&lt;/code&gt; or a list of &lt;code&gt;header&lt;/code&gt; objects (distinguished from strings by having a &lt;code&gt;name&lt;/code&gt; attribute), add the headers to &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;헤더&lt;/em&gt; 지정 및 형식 문자열의 목록은 &lt;code&gt;headername: headervalue&lt;/code&gt; 또는리스트 &lt;code&gt;header&lt;/code&gt; (a함으로써 문자열 구별 개체 &lt;code&gt;name&lt;/code&gt; 속성)에 헤더를 추가 &lt;em&gt;MSG&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="67f11944e8694918226bb92f8c98cd866fee3ff0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;hkey&lt;/em&gt; is not closed using this method (or via &lt;a href=&quot;#winreg.PyHKEY.Close&quot;&gt;&lt;code&gt;hkey.Close()&lt;/code&gt;&lt;/a&gt;), it is closed when the &lt;em&gt;hkey&lt;/em&gt; object is destroyed by Python.</source>
          <target state="translated">경우 &lt;em&gt;HKEY은&lt;/em&gt; 이 방법을 사용하여 폐쇄되지 않은 (또는 비아 &lt;a href=&quot;#winreg.PyHKEY.Close&quot;&gt; &lt;code&gt;hkey.Close()&lt;/code&gt; &lt;/a&gt; )의 경우가 닫혀 &lt;em&gt;HKEY의&lt;/em&gt; 개체 파이썬 의해 파괴된다.</target>
        </trans-unit>
        <trans-unit id="0fe3a2ba8d8de975e9e62d14d77fcd64824c3a2c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;host&lt;/em&gt; is a sequence of strings, the TCP server is bound to all network interfaces specified by the sequence.</source>
          <target state="translated">경우 &lt;em&gt;호스트가&lt;/em&gt; 문자열의 순서되면, TCP 서버는 순서에 의해 지정된 모든 네트워크 인터페이스에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3f345f9c27305214c887b3eec3da087bc1be8192" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;host&lt;/em&gt; is a string, the TCP server is bound to a single network interface specified by &lt;em&gt;host&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;호스트&lt;/em&gt; 문자열입니다는 TCP 서버에 의해 지정된 단일 네트워크 인터페이스에 바인딩 &lt;em&gt;호스트&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2f9d505cd78099d9626b9c1d857032185127ef87" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;host&lt;/em&gt; is an empty string or &lt;code&gt;None&lt;/code&gt;, all interfaces are assumed and a list of multiple sockets will be returned (most likely one for IPv4 and another one for IPv6).</source>
          <target state="translated">경우 &lt;em&gt;호스트가&lt;/em&gt; 빈 문자열이거나 &lt;code&gt;None&lt;/code&gt; , 모든 인터페이스는 (대부분 IPv4의 하나와 IPv6에 대한 또 다른 하나) 가정 및 다중 소켓의 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc492cbe67d58bcc667802df9fc3fe37624b350" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; is negative, the index is relative to the end of sequence &lt;em&gt;s&lt;/em&gt;: &lt;code&gt;len(s) + i&lt;/code&gt; or &lt;code&gt;len(s) + j&lt;/code&gt; is substituted. But note that &lt;code&gt;-0&lt;/code&gt; is still &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;em&gt;I&lt;/em&gt; 또는 &lt;em&gt;J가&lt;/em&gt; 마이너스이고, 인덱스 시퀀스의 끝을 기준으로 &lt;em&gt;S&lt;/em&gt; : &lt;code&gt;len(s) + i&lt;/code&gt; 또는 &lt;code&gt;len(s) + j&lt;/code&gt; 치환된다. 그러나 &lt;code&gt;-0&lt;/code&gt; 은 여전히 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44afe41d193d3ce2b1d38185232d5624b2955990" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ignore&lt;/em&gt; is given, it must be a callable that will receive as its arguments the directory being visited by &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt;, and a list of its contents, as returned by &lt;a href=&quot;os#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt;. Since &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt; is called recursively, the &lt;em&gt;ignore&lt;/em&gt; callable will be called once for each directory that is copied. The callable must return a sequence of directory and file names relative to the current directory (i.e. a subset of the items in its second argument); these names will then be ignored in the copy process. &lt;a href=&quot;#shutil.ignore_patterns&quot;&gt;&lt;code&gt;ignore_patterns()&lt;/code&gt;&lt;/a&gt; can be used to create such a callable that ignores names based on glob-style patterns.</source>
          <target state="translated">경우 &lt;em&gt;무시&lt;/em&gt; 주어, 그것은 방문중인 디렉토리의 인수로받을 것입니다 호출해야합니다 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 에 의해 반환, 그 내용의 목록 &lt;a href=&quot;os#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt; . 이후 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 재귀 적으로 호출되면이 &lt;em&gt;무시&lt;/em&gt; 복사됩니다 각 디렉토리에 대해 한 번 호출됩니다 호출. 호출 가능 파일은 현재 디렉토리와 관련된 디렉토리 및 파일 이름 시퀀스를 반환해야합니다 (즉, 두 번째 인수에있는 항목의 하위 집합). 이러한 이름은 복사 과정에서 무시됩니다. &lt;a href=&quot;#shutil.ignore_patterns&quot;&gt; &lt;code&gt;ignore_patterns()&lt;/code&gt; &lt;/a&gt; 를 사용하여 glob 스타일 패턴을 기반으로 이름을 무시하는 호출 가능 파일을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d785f3192b45198013e900cff1faf46eb9fbd317" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ignore_zeros&lt;/em&gt; is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, treat an empty block as the end of the archive. If it is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, skip empty (and invalid) blocks and try to get as many members as possible. This is only useful for reading concatenated or damaged archives.</source>
          <target state="translated">경우 &lt;em&gt;ignore_zeros이&lt;/em&gt; 있다 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , 아카이브의 마지막으로 빈 블록을 취급합니다. &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 비어 있고 유효하지 않은 블록을 건너 뛰고 가능한 한 많은 멤버를 확보하십시오. 연결되거나 손상된 아카이브를 읽을 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a4a7904c070e056ee4cfdf2fa61877eb76ea87e7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (exclude), ignore memory blocks allocated in a file with a name matching &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt;&lt;code&gt;filename_pattern&lt;/code&gt;&lt;/a&gt; at line number &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (제외), 이름 일치와 파일에 할당 된 메모리 블록을 무시 &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt; &lt;code&gt;filename_pattern&lt;/code&gt; &lt;/a&gt; 줄 번호에서 &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b63248eefccbe6a3d667aec993979939e6087d1e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (exclude), match memory blocks not allocated in the address space &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (제외), 일치하는 메모리 블록 주소 공간에 할당되지 않은 &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49de2929ffeb92d24b9cb57a7b7a1ea592c5170b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (include), match memory blocks allocated in the address space &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 주소 공간 할당 일치하는 메모리 블록 (포함) &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dcfc5893b04256daaa03f0059c6ea1a4e39d096" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (include), only match memory blocks allocated in a file with a name matching &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt;&lt;code&gt;filename_pattern&lt;/code&gt;&lt;/a&gt; at line number &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; (포함), 이름 만 일치와 파일에 할당 된 메모리 블록과 일치 &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt; &lt;code&gt;filename_pattern&lt;/code&gt; &lt;/a&gt; 줄 번호에서 &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58fc395684d347d785cfee92daad9292f6d2e8a8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;indent&lt;/em&gt; is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0, negative, or &lt;code&gt;&quot;&quot;&lt;/code&gt; will only insert newlines. &lt;code&gt;None&lt;/code&gt; (the default) selects the most compact representation. Using a positive integer indent indents that many spaces per level. If &lt;em&gt;indent&lt;/em&gt; is a string (such as &lt;code&gt;&quot;\t&quot;&lt;/code&gt;), that string is used to indent each level.</source>
          <target state="translated">경우 &lt;em&gt;덴트는&lt;/em&gt; 음이 아닌 정수 나 문자열은 다음 JSON 어레이 요소와 물체 부재는 오목 레벨 꽤 인쇄 될 것이다. 들여 쓰기 수준 0, 음수 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 는 줄 바꿈 만 삽입합니다. &lt;code&gt;None&lt;/code&gt; (기본값)은 가장 간단한 표현을 선택합니다. 양의 정수 들여 쓰기를 사용하면 레벨 당 많은 공간이 들여 쓰기됩니다. 경우 &lt;em&gt;들여 쓰기&lt;/em&gt; (같은 문자열 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), 해당 문자열이 각 레벨을 들여 사용된다.</target>
        </trans-unit>
        <trans-unit id="685f4df3ebb7bcdd656a69b4b08c67818137a416" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;infile&lt;/em&gt; is not specified, read from &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;INFILE이&lt;/em&gt; 지정되지 않은, 읽기 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af42a72d9390faa93a1048c54ee6e3245c21c2a3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;initializer&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt; then each worker process will call &lt;code&gt;initializer(*initargs)&lt;/code&gt; when it starts.</source>
          <target state="translated">&lt;em&gt;초기화 프로그램&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 각 작업자 프로세스는 시작할 때 &lt;code&gt;initializer(*initargs)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="fc855a607663f5eac05d5c21762309db29ce88bf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;input&lt;/em&gt; is given, it is passed to the &lt;a href=&quot;#http.cookies.BaseCookie.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;em&gt;입력이&lt;/em&gt; 주어지고 그것은에 전달되는 &lt;a href=&quot;#http.cookies.BaseCookie.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="2b8380ea7e230485aa00a5b7a9d5e448bafe1787" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;isjunk&lt;/em&gt; was omitted or &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt;&lt;code&gt;find_longest_match()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;(i, j, k)&lt;/code&gt; such that &lt;code&gt;a[i:i+k]&lt;/code&gt; is equal to &lt;code&gt;b[j:j+k]&lt;/code&gt;, where &lt;code&gt;alo
&amp;lt;= i &amp;lt;= i+k &amp;lt;= ahi&lt;/code&gt; and &lt;code&gt;blo &amp;lt;= j &amp;lt;= j+k &amp;lt;= bhi&lt;/code&gt;. For all &lt;code&gt;(i', j',
k')&lt;/code&gt; meeting those conditions, the additional conditions &lt;code&gt;k &amp;gt;= k'&lt;/code&gt;, &lt;code&gt;i
&amp;lt;= i'&lt;/code&gt;, and if &lt;code&gt;i == i'&lt;/code&gt;, &lt;code&gt;j &amp;lt;= j'&lt;/code&gt; are also met. In other words, of all maximal matching blocks, return one that starts earliest in &lt;em&gt;a&lt;/em&gt;, and of all those maximal matching blocks that start earliest in &lt;em&gt;a&lt;/em&gt;, return the one that starts earliest in &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;isjunk가&lt;/em&gt; 생략되거나 하였다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt; &lt;code&gt;find_longest_match()&lt;/code&gt; &lt;/a&gt; 복귀 &lt;code&gt;(i, j, k)&lt;/code&gt; 되도록 &lt;code&gt;a[i:i+k]&lt;/code&gt; 같다 &lt;code&gt;b[j:j+k]&lt;/code&gt; , &lt;code&gt;alo &amp;lt;= i &amp;lt;= i+k &amp;lt;= ahi&lt;/code&gt; 및 &lt;code&gt;blo &amp;lt;= j &amp;lt;= j+k &amp;lt;= bhi&lt;/code&gt; . 이러한 조건을 충족하는 모든 &lt;code&gt;(i', j', k')&lt;/code&gt; 에 대해 추가 조건 &lt;code&gt;k &amp;gt;= k'&lt;/code&gt; , &lt;code&gt;i &amp;lt;= i'&lt;/code&gt; 이고 &lt;code&gt;i == i'&lt;/code&gt; 이면 &lt;code&gt;j &amp;lt;= j'&lt;/code&gt; 도 충족됩니다. 다시 말해, 모든 최대 매칭 블록 중에서 가장 빠른 것으로 시작하는 블록과 &lt;em&gt;a&lt;/em&gt; 에서 가장 빠른 시작 블록을 반환 &lt;em&gt;합니다.&lt;/em&gt;&lt;em&gt;b&lt;/em&gt; 에서 가장 빨리 시작하는 것을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="75fee0a269e631f121c00c49961541eaff1b3b2d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;isjunk&lt;/em&gt; was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match.</source>
          <target state="translated">경우 &lt;em&gt;isjunk을&lt;/em&gt; 구비하고, 제 긴 정합 블록은 있지만 정크 요소가 블록에 나타나지 않는 것을 부가적인 제약과, 전술과 같이 결정된다. 그런 다음 양쪽의 정크 요소를 일치시켜 해당 블록을 최대한 확장합니다. 따라서 동일한 정크가 흥미로운 일치 항목에 인접하는 것을 제외하고 결과 블록은 정크와 절대 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab8363bacc86dbccdda686c60e9f57e64899a0a7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;item&lt;/em&gt; is not specified, returns root children.</source>
          <target state="translated">경우 &lt;em&gt;항목이&lt;/em&gt; 지정되지 않은 루트 아이들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="640e4676019d2f35b4e680f21a70d725650c2978" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;item&lt;/em&gt; is specified, returns 1 or 0 depending on whether the specified &lt;em&gt;item&lt;/em&gt; has the given &lt;em&gt;tagname&lt;/em&gt;. Otherwise, returns a list of all items that have the specified tag.</source>
          <target state="translated">&lt;em&gt;item&lt;/em&gt; 이 지정된 경우 지정된 &lt;em&gt;항목&lt;/em&gt; 에 지정된 &lt;em&gt;tagname&lt;/em&gt; 이 있는지에 따라 1 또는 0을 반환합니다 . 그렇지 않으면 지정된 태그가있는 모든 항목의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e440a41e05f93e2a1c6c6399b8430876ac4585da" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;item&lt;/em&gt; is specified, sets the focus item to &lt;em&gt;item&lt;/em&gt;. Otherwise, returns the current focus item, or &amp;lsquo;&amp;rsquo; if there is none.</source>
          <target state="translated">경우 &lt;em&gt;항목이&lt;/em&gt; 지정에 초점 항목을 설정 &lt;em&gt;항목&lt;/em&gt; . 그렇지 않으면 현재 포커스 항목을 반환하거나없는 경우 ''를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bf186b875e926737f447fba52ea416adfe07ffd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;k&lt;/em&gt; is not specified or is None, then &lt;em&gt;k&lt;/em&gt; defaults to &lt;em&gt;n&lt;/em&gt; and the function returns &lt;code&gt;n!&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;K가&lt;/em&gt; 지정 또는 없음입니다되어 있지 않은 경우, &lt;em&gt;케이&lt;/em&gt; 기본값은 &lt;em&gt;N&lt;/em&gt; 과 함수가 반환 &lt;code&gt;n!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e0d95fc7b381f24c17900b74659214f4eeca1c2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;keepends&lt;/em&gt; is false line-endings will be stripped from the lines returned.</source>
          <target state="translated">&lt;em&gt;keepends&lt;/em&gt; 가 false 이면 줄 끝이 반환 된 줄에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="344b03a8bbb6978f881befbb3ab7e00dbc466836" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is a handle returned by &lt;a href=&quot;#winreg.ConnectRegistry&quot;&gt;&lt;code&gt;ConnectRegistry()&lt;/code&gt;&lt;/a&gt;, then the path specified in &lt;em&gt;file_name&lt;/em&gt; is relative to the remote computer.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 &lt;a href=&quot;#winreg.ConnectRegistry&quot;&gt; &lt;code&gt;ConnectRegistry()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 핸들 인 경우 &lt;em&gt;file_name에&lt;/em&gt; 지정된 경로 는 원격 컴퓨터와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3be292f079b8eebf6e1f757e8daea0ea1d6b83" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is in the dictionary, remove it and return its value, else return &lt;em&gt;default&lt;/em&gt;. If &lt;em&gt;default&lt;/em&gt; is not given and &lt;em&gt;key&lt;/em&gt; is not in the dictionary, a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 사전에 있으면 &lt;em&gt;키를&lt;/em&gt; 제거하고 값을 리턴하고 그렇지 않으면 &lt;em&gt;기본값을&lt;/em&gt; 리턴하십시오 . 경우 &lt;em&gt;기본값이&lt;/em&gt; 주어지지하고 &lt;em&gt;키가&lt;/em&gt; 사전에없는하는 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa8380eba14f04ad4419f7fe956d6020b048af57" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is in the dictionary, return its value. If not, insert &lt;em&gt;key&lt;/em&gt; with a value of &lt;em&gt;default&lt;/em&gt; and return &lt;em&gt;default&lt;/em&gt;. &lt;em&gt;default&lt;/em&gt; defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 사전에 있으면 해당 값을 리턴하십시오. 그렇지 않은 경우, 삽입 &lt;em&gt;키&lt;/em&gt; 의 값을 &lt;em&gt;기본&lt;/em&gt; 및 반환 &lt;em&gt;기본&lt;/em&gt; . &lt;em&gt;기본&lt;/em&gt; 기본값 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d7a7b3cf6e17b5ad90262940a29bd912e9ee0f3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is one of the predefined keys, &lt;em&gt;sub_key&lt;/em&gt; may be &lt;code&gt;None&lt;/code&gt;. In that case, the handle returned is the same key handle passed in to the function.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt; 가 사전 정의 된 키 중 하나 인 경우 &lt;em&gt;sub_key&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 이 경우 반환 된 핸들은 함수에 전달 된 것과 동일한 키 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="35e9d157870368f01d939d30e1c0a35b6624a0fe" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; represents a key on a remote computer, the path described by &lt;em&gt;file_name&lt;/em&gt; is relative to the remote computer. The caller of this method must possess the &lt;code&gt;SeBackupPrivilege&lt;/code&gt; security privilege. Note that privileges are different than permissions &amp;ndash; see the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724878%28v=VS.85%29.aspx&quot;&gt;Conflicts Between User Rights and Permissions documentation&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt; 가 원격 컴퓨터의 키를 나타내는 경우 &lt;em&gt;file_name&lt;/em&gt; 으로 설명 된 경로는 원격 컴퓨터와 관련이 있습니다. 이 메소드의 호출자는 &lt;code&gt;SeBackupPrivilege&lt;/code&gt; 보안 권한을 가지고 있어야합니다 . 권한은 권한과 다릅니다 . 자세한 내용은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724878%28v=VS.85%29.aspx&quot;&gt;사용자 권한과 권한 간 충돌 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48e0a5a607822047e064bb2a97449353075f69c6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;keyfile&lt;/em&gt; and &lt;em&gt;certfile&lt;/em&gt; are provided, they are used to create an &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;키 파일&lt;/em&gt; 및 &lt;em&gt;certfile가&lt;/em&gt; 제공됩니다, 그들은는 만드는 데 사용되는 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e59ed370148bc2a0a46b54a3228d31bb0bd9d0f3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dict of the column option values. If &lt;em&gt;option&lt;/em&gt; is specified then the value for that &lt;em&gt;option&lt;/em&gt; is returned. Otherwise, sets the options to the corresponding values.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지 않는, 열 옵션 값의 딕셔너리를 반환합니다. &lt;em&gt;option&lt;/em&gt; 이 지정 되면 해당 &lt;em&gt;옵션&lt;/em&gt; 의 값 이 반환됩니다. 그렇지 않으면 옵션을 해당 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="22c41db084d38f1f4e00c46ef68becd286a4c27a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dict of the heading option values. If &lt;em&gt;option&lt;/em&gt; is specified then the value for that &lt;em&gt;option&lt;/em&gt; is returned. Otherwise, sets the options to the corresponding values.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지 않는, 제목 옵션 값의 딕셔너리를 반환합니다. &lt;em&gt;option&lt;/em&gt; 이 지정 되면 해당 &lt;em&gt;옵션&lt;/em&gt; 의 값 이 반환됩니다. 그렇지 않으면 옵션을 해당 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4d77b28bc9353645c16eb77f2989195d66a0666b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dict of the option settings for &lt;em&gt;tagname&lt;/em&gt;. If &lt;em&gt;option&lt;/em&gt; is specified, returns the value for that &lt;em&gt;option&lt;/em&gt; for the specified &lt;em&gt;tagname&lt;/em&gt;. Otherwise, sets the options to the corresponding values for the given &lt;em&gt;tagname&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지에 대한 옵션 설정의 DICT 반환 &lt;em&gt;태그 이름을&lt;/em&gt; . 경우 &lt;em&gt;옵션을&lt;/em&gt; 지정, 그 값 반환 &lt;em&gt;옵션&lt;/em&gt; 지정된 대한 &lt;em&gt;태그 이름을&lt;/em&gt; . 그렇지 않으면 옵션을 주어진 &lt;em&gt;tagname에&lt;/em&gt; 해당하는 값으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="23258f5a93a28264e5494954dc925f4fb9fe94ea" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dictionary of the tab option values. If &lt;em&gt;option&lt;/em&gt; is specified, returns the value of that &lt;em&gt;option&lt;/em&gt;. Otherwise, sets the options to the corresponding values.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지 탭 옵션 값의 사전을 반환합니다. 경우 &lt;em&gt;옵션을&lt;/em&gt; 지정, 그 값 반환 &lt;em&gt;옵션을&lt;/em&gt; . 그렇지 않으면 옵션을 해당 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5223d4b1bee76d3b490192f2e0c760f67a403d03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;legacy&lt;/em&gt; is true, byte-code files are written to their legacy locations and names, which may overwrite byte-code files created by another version of Python. The default is to write files to their &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; locations and names, which allows byte-code files from multiple versions of Python to coexist.</source>
          <target state="translated">경우 &lt;em&gt;유산은&lt;/em&gt; 사실, 바이트 코드 파일은 파이썬의 다른 버전에 의해 생성 된 바이트 코드 파일을 덮어 쓸 수 있습니다 자신의 기존 위치와 이름에 기록됩니다. 기본값은 파일을 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; 위치 및 이름 에 쓰는 &lt;strong&gt;것이므로&lt;/strong&gt; 여러 버전의 Python의 바이트 코드 파일이 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edac46e04363a344725a2ab2e33375a697b6340a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;legacy&lt;/em&gt; is true, byte-code files are written to their legacy locations and names, which may overwrite byte-code files created by another version of Python. The default is to write files to their &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; locations and names, which allows byte-code files from multiple versions of Python to coexist.</source>
          <target state="translated">경우 &lt;em&gt;유산은&lt;/em&gt; 사실, 바이트 코드 파일은 파이썬의 다른 버전에 의해 생성 된 바이트 코드 파일을 덮어 쓸 수 있습니다 자신의 기존 위치와 이름에 기록됩니다. 기본값은 파일을 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; 위치 및 이름 에 쓰는 &lt;strong&gt;것이므로&lt;/strong&gt; 여러 버전의 Python의 바이트 코드 파일이 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f4f479018d14901ee93b65aaa185ab78cef0218" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;limit&lt;/em&gt; is supplied, only this many frames are taken from &lt;em&gt;frame_gen&lt;/em&gt;. If &lt;em&gt;lookup_lines&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the returned &lt;a href=&quot;#traceback.FrameSummary&quot;&gt;&lt;code&gt;FrameSummary&lt;/code&gt;&lt;/a&gt; objects will not have read their lines in yet, making the cost of creating the &lt;a href=&quot;#traceback.StackSummary&quot;&gt;&lt;code&gt;StackSummary&lt;/code&gt;&lt;/a&gt; cheaper (which may be valuable if it may not actually get formatted). If &lt;em&gt;capture_locals&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; the local variables in each &lt;a href=&quot;#traceback.FrameSummary&quot;&gt;&lt;code&gt;FrameSummary&lt;/code&gt;&lt;/a&gt; are captured as object representations.</source>
          <target state="translated">경우 &lt;em&gt;제한&lt;/em&gt; 공급 만이 많은 프레임에서 가져 &lt;em&gt;frame_gen&lt;/em&gt; . 경우 &lt;em&gt;lookup_lines이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 반환 &lt;a href=&quot;#traceback.FrameSummary&quot;&gt; &lt;code&gt;FrameSummary&lt;/code&gt; &lt;/a&gt; 개체가 생성하는 비용하고, 아직 자신의 라인을 읽을 필요가 없습니다 &lt;a href=&quot;#traceback.StackSummary&quot;&gt; &lt;code&gt;StackSummary&lt;/code&gt; 을&lt;/a&gt; 저렴 (실제로 포맷되지 않을 수 있습니다 경우에 도움이 될 수있다). &lt;em&gt;capture_locals&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 각 &lt;a href=&quot;#traceback.FrameSummary&quot;&gt; &lt;code&gt;FrameSummary&lt;/code&gt; &lt;/a&gt; 의 로컬 변수는 객체 표현으로 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab87e10d3d835d14c47f616a3c51abbf809ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;line_buffering&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;flush()&lt;/code&gt; is implied when a call to write contains a newline character or a carriage return.</source>
          <target state="translated">&lt;em&gt;line_buffering&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 쓰기 호출에 줄 바꾸기 문자 또는 캐리지 리턴이 포함되면 &lt;code&gt;flush()&lt;/code&gt; 가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="723be276409e68c389387a7fa507f58dd05a3b3c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;line_info&lt;/em&gt; is true, line number information will be included for all terminal tokens as a third element of the list representing the token. Note that the line number provided specifies the line on which the token &lt;em&gt;ends&lt;/em&gt;. This information is omitted if the flag is false or omitted.</source>
          <target state="translated">경우 &lt;em&gt;line_info는&lt;/em&gt; 사실, 행 번호 정보를 나타내는 토큰리스트의 세 번째 요소로서 모든 단말 토큰 포함한다. 제공된 줄 번호는 토큰이 &lt;em&gt;끝나는&lt;/em&gt; 줄을 지정합니다 . 플래그가 false이거나 생략되면이 정보는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="a4aca6b106e2f5c8314da4294c104be01489c777" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;line_info&lt;/em&gt; is true, line number information will be included for all terminal tokens as a third element of the list representing the token. This information is omitted if the flag is false or omitted.</source>
          <target state="translated">경우 &lt;em&gt;line_info는&lt;/em&gt; 사실, 행 번호 정보를 나타내는 토큰리스트의 세 번째 요소로서 모든 단말 토큰 포함한다. 플래그가 false이거나 생략되면이 정보는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="33fc9ad31dc069d4994bc5cc54acaf1808e638de" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linesep&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, use it as the separator character between all the lines of the flattened message. If &lt;em&gt;linesep&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), use the value specified in the &lt;em&gt;policy&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;linesep&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 병합 된 메시지의 모든 행 사이의 구분 문자로 사용하십시오. 경우 &lt;em&gt;linesep가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; (기본값)에 지정된 값 사용 &lt;em&gt;정책을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1569426afcc62ae89d6a7fcd1beae10acbe198a6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;locale&lt;/em&gt; is given and not &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; modifies the locale setting for the &lt;em&gt;category&lt;/em&gt;. The available categories are listed in the data description below. &lt;em&gt;locale&lt;/em&gt; may be a string, or an iterable of two strings (language code and encoding). If it&amp;rsquo;s an iterable, it&amp;rsquo;s converted to a locale name using the locale aliasing engine. An empty string specifies the user&amp;rsquo;s default settings. If the modification of the locale fails, the exception &lt;a href=&quot;#locale.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; is raised. If successful, the new locale setting is returned.</source>
          <target state="translated">경우 &lt;em&gt;로케일&lt;/em&gt; 이 아닌 주어 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 수정에게 대한 로케일 설정 &lt;em&gt;범주를&lt;/em&gt; . 사용 가능한 범주는 아래 데이터 설명에 나열되어 있습니다. &lt;em&gt;로케일&lt;/em&gt; 은 문자열이거나 두 개의 문자열 (언어 코드 및 인코딩)의 반복 가능일 수 있습니다. iterable 인 경우, 로케일 별명 엔진을 사용하여 로케일 이름으로 변환됩니다. 빈 문자열은 사용자의 기본 설정을 지정합니다. 로케일 수정이 실패하면 예외 &lt;a href=&quot;#locale.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 성공하면 새 로캘 설정이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="951c3928ce25063e5377b210aad3f1281db3bfa5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;locale&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, the current setting for &lt;em&gt;category&lt;/em&gt; is returned.</source>
          <target state="translated">경우 &lt;em&gt;로케일이&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; , 현재 설정 &lt;em&gt;카테고리가&lt;/em&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="9f4491f562e18db7a7f85c5110ce868482f309ac" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;localedir&lt;/em&gt; is not given, then the default system locale directory is used. &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; If &lt;em&gt;languages&lt;/em&gt; is not given, then the following environment variables are searched: &lt;code id=&quot;index-5&quot;&gt;LANGUAGE&lt;/code&gt;, &lt;code id=&quot;index-6&quot;&gt;LC_ALL&lt;/code&gt;, &lt;code id=&quot;index-7&quot;&gt;LC_MESSAGES&lt;/code&gt;, and &lt;code id=&quot;index-8&quot;&gt;LANG&lt;/code&gt;. The first one returning a non-empty value is used for the &lt;em&gt;languages&lt;/em&gt; variable. The environment variables should contain a colon separated list of languages, which will be split on the colon to produce the expected list of language code strings.</source>
          <target state="translated">경우 &lt;em&gt;localedir가&lt;/em&gt; 지정되어 있지 않은 경우, 기본 시스템 로케일 디렉토리가 사용됩니다. &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;이&lt;/a&gt; 경우 &lt;em&gt;언어가&lt;/em&gt; 지정되어 있지 않은 경우, 다음과 같은 환경 변수가 검색됩니다 : &lt;code id=&quot;index-5&quot;&gt;LANGUAGE&lt;/code&gt; , &lt;code id=&quot;index-6&quot;&gt;LC_ALL&lt;/code&gt; , &lt;code id=&quot;index-7&quot;&gt;LC_MESSAGES&lt;/code&gt; 및 &lt;code id=&quot;index-8&quot;&gt;LANG&lt;/code&gt; . 비어 있지 않은 값을 반환하는 첫 번째 값은 &lt;em&gt;언어&lt;/em&gt; 변수에 사용됩니다. 환경 변수는 콜론으로 구분 된 언어 목록을 포함해야하며, 콜론에서 분할되어 예상되는 언어 코드 문자열 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a0d295e26c689b54481242876c86a7d434af28e8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;localedir&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, then the current binding for &lt;em&gt;domain&lt;/em&gt; is returned. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">경우 &lt;em&gt;localedir를&lt;/em&gt; 생략하거나한다 &lt;code&gt;None&lt;/code&gt; 다음 바인딩 현재 &lt;em&gt;도메인이&lt;/em&gt; 반환된다. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dfea24b57f7d4e4b61af9826d1014c7238d0a2c5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) then a new lock object is created to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is a &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object then that will be used to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then access to the returned object will not be automatically protected by a lock, so it will not necessarily be &amp;ldquo;process-safe&amp;rdquo;.</source>
          <target state="translated">경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; (기본) 다음 새 잠금 객체는 값으로 동기화 액세스에 생성됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; A는 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체가 값으로 동기화 액세스하는 데 사용됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 은 반드시 &quot;공정 안전&quot;이되지 않도록 반환 된 객체에 다음 액세스가 자동으로 잠금으로 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb5a29a93024c0c287ced20dc12603ed825400c5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) then a new recursive lock object is created to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is a &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object then that will be used to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then access to the returned object will not be automatically protected by a lock, so it will not necessarily be &amp;ldquo;process-safe&amp;rdquo;.</source>
          <target state="translated">경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; (기본) 다음 새 재귀 락 객체는 값으로 동기화 액세스에 생성됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; A는 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체가 값으로 동기화 액세스하는 데 사용됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 은 반드시 &quot;공정 안전&quot;이되지 않도록 반환 된 객체에 다음 액세스가 자동으로 잠금으로 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2602fc87b0876ba602ab00278259ea7a79f410d1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is specified then it should be a &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object from &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;lock&lt;/em&gt; 을 지정 하면 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="bab9a02062082eb583249e7a6e16be3658394be6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is supplied then it should be a proxy for a &lt;a href=&quot;threading#threading.Lock&quot;&gt;&lt;code&gt;threading.Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;threading#threading.RLock&quot;&gt;&lt;code&gt;threading.RLock&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;lock&lt;/em&gt; 이 제공 되면 &lt;a href=&quot;threading#threading.Lock&quot;&gt; &lt;code&gt;threading.Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;threading#threading.RLock&quot;&gt; &lt;code&gt;threading.RLock&lt;/code&gt; &lt;/a&gt; 객체 의 프록시 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="590cdff25c02f75a07edf4cd1b5590e71db1db65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;loop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt; is used for getting current loop.</source>
          <target state="translated">경우 &lt;em&gt;루프는&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 전류 루프를 얻기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="937d955e2d780cdb674a48ea2b8300a8b1629db0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;loop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt; function is used to get the current loop.</source>
          <target state="translated">경우 &lt;em&gt;루프가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 상기 &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; 함수는 전류 루프를 얻기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="c63129023a997a153b9588c1c5afcfaec61cc024" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;loop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;&lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt; is used to get the current loop.</source>
          <target state="translated">&lt;em&gt;loop&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 는 현재 루프를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="34f3c105305570e37994220800780f4e1998f389" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;max_length&lt;/em&gt; is nonnegative, returns at most &lt;em&gt;max_length&lt;/em&gt; bytes of decompressed data. If this limit is reached and further output can be produced, the &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;False&lt;/code&gt;. In this case, the next call to &lt;a href=&quot;#bz2.BZ2Decompressor.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; may provide &lt;em&gt;data&lt;/em&gt; as &lt;code&gt;b''&lt;/code&gt; to obtain more of the output.</source>
          <target state="translated">&lt;em&gt;max_length&lt;/em&gt; 가 음수가 아닌 경우 최대 &lt;em&gt;max_length&lt;/em&gt; 바이트의 압축 해제 된 데이터를 반환 합니다. 이 한계에 도달하고 추가 출력을 생성 할 수 있으면 &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성이 &lt;code&gt;False&lt;/code&gt; 로 설정됩니다 . 이 경우, &lt;a href=&quot;#bz2.BZ2Decompressor.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 대한 다음 호출은 더 많은 출력을 얻기 위해 &lt;code&gt;b''&lt;/code&gt; 로 &lt;em&gt;데이터&lt;/em&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe10ae05e553743d5c3d20d35ac3316877086f58" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;max_length&lt;/em&gt; is nonnegative, returns at most &lt;em&gt;max_length&lt;/em&gt; bytes of decompressed data. If this limit is reached and further output can be produced, the &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;False&lt;/code&gt;. In this case, the next call to &lt;a href=&quot;#lzma.LZMADecompressor.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; may provide &lt;em&gt;data&lt;/em&gt; as &lt;code&gt;b''&lt;/code&gt; to obtain more of the output.</source>
          <target state="translated">&lt;em&gt;max_length&lt;/em&gt; 가 음수가 아닌 경우 최대 &lt;em&gt;max_length&lt;/em&gt; 바이트의 압축 해제 된 데이터를 반환 합니다. 이 한계에 도달하고 추가 출력을 생성 할 수 있으면 &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성이 &lt;code&gt;False&lt;/code&gt; 로 설정됩니다 . 이 경우, &lt;a href=&quot;#lzma.LZMADecompressor.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 대한 다음 호출은 더 많은 출력을 얻기 위해 &lt;code&gt;b''&lt;/code&gt; 로 &lt;em&gt;데이터&lt;/em&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10be81d98bdd051152d5d0719d26439da8df03a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxheaderlen&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, refold any header lines that are longer than &lt;em&gt;maxheaderlen&lt;/em&gt;, or if &lt;code&gt;0&lt;/code&gt;, do not rewrap any headers. If &lt;em&gt;manheaderlen&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), wrap headers and other message lines according to the &lt;em&gt;policy&lt;/em&gt; settings.</source>
          <target state="translated">&lt;em&gt;maxheaderlen&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;em&gt;maxheaderlen&lt;/em&gt; 보다 긴 헤더 행을 다시 접 거나 &lt;code&gt;0&lt;/code&gt; 이면 헤더를 다시 &lt;em&gt;랩핑&lt;/em&gt; 하지 마십시오. 경우 &lt;em&gt;manheaderlen는&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; (기본값), 랩 헤더와에 따라 다른 메시지 라인 &lt;em&gt;정책&lt;/em&gt; 설정은.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="422ba7aa2a79e6f2f30ccbe4d45f0fb30ec13a07" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxlen&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, deques may grow to an arbitrary length. Otherwise, the deque is bounded to the specified maximum length. Once a bounded length deque is full, when new items are added, a corresponding number of items are discarded from the opposite end. Bounded length deques provide functionality similar to the &lt;code&gt;tail&lt;/code&gt; filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest.</source>
          <target state="translated">경우 &lt;em&gt;MAXLEN가&lt;/em&gt; 지정되거나 없다되지 &lt;code&gt;None&lt;/code&gt; , deques는 임의의 길이로 성장할 수 있습니다. 그렇지 않으면, deque는 지정된 최대 길이로 제한됩니다. 제한된 길이의 디크가 가득 차면 새 항목이 추가 될 때 해당하는 수의 항목이 반대쪽 끝에서 삭제됩니다. 경계 길이 디케는 Unix 의 &lt;code&gt;tail&lt;/code&gt; 필터 와 유사한 기능을 제공합니다 . 또한 가장 최근 활동 만 관심있는 트랜잭션 및 기타 데이터 풀을 추적하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2aec9f480deb51e518e61c9512cb8347bbb35566" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxlength&lt;/em&gt; is specified and the message is longer than &lt;em&gt;maxlength&lt;/em&gt; then &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised and the connection will no longer be readable.</source>
          <target state="translated">경우 &lt;em&gt;최대 길이가&lt;/em&gt; 지정 메시지가보다 더 오래입니다 &lt;em&gt;최대 길이&lt;/em&gt; 다음 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 발생하지 않습니다 및 연결이 더 이상 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdda2ebb0037d0b6d351503e46dedbec8240b68d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxsize&lt;/em&gt; is less than or equal to zero, the queue size is infinite. If it is an integer greater than &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;await put()&lt;/code&gt; blocks when the queue reaches &lt;em&gt;maxsize&lt;/em&gt; until an item is removed by &lt;a href=&quot;#asyncio.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;MAXSIZE가&lt;/em&gt; 제로와 동일보다 작은 경우, 큐 크기는 무한하다. 그것보다 정수 큰 경우는 &lt;code&gt;0&lt;/code&gt; , 다음 &lt;code&gt;await put()&lt;/code&gt; 블록 큐에 도달 때 &lt;em&gt;maxsize와&lt;/em&gt; 항목이 제거 될 때까지 &lt;a href=&quot;#asyncio.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="476559880ef6db18fddff1363483c9ce4ae594eb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxsize&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt;, the LRU feature is disabled and the cache can grow without bound. The LRU feature performs best when &lt;em&gt;maxsize&lt;/em&gt; is a power-of-two.</source>
          <target state="translated">경우 &lt;em&gt;MAXSIZE가&lt;/em&gt; 설정되어 &lt;code&gt;None&lt;/code&gt; 의 LRU 기능이 비활성화되고 캐시가 경계없이 성장할 수 있습니다. LRU 기능은 &lt;em&gt;maxsize&lt;/em&gt; 가 2의 거듭 제곱 일 때 가장 잘 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdb0dec0e620351e0bbd4aec3590e50d3841d53d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;message&lt;/em&gt; is omitted, the new instance is created in a default, empty state. If &lt;em&gt;message&lt;/em&gt; is an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; instance, its contents are copied; furthermore, any format-specific information is converted insofar as possible if &lt;em&gt;message&lt;/em&gt; is a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance. If &lt;em&gt;message&lt;/em&gt; is a string, a byte string, or a file, it should contain an &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant message, which is read and parsed. Files should be open in binary mode, but text mode files are accepted for backward compatibility.</source>
          <target state="translated">경우 &lt;em&gt;메시지가&lt;/em&gt; 생략되고, 새로운 인스턴스는 기본, 빈 상태로 생성됩니다. 경우 &lt;em&gt;메시지가&lt;/em&gt; 입니다 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; 의&lt;/a&gt; 경우, 그 내용이 복사됩니다; 또한, &lt;em&gt;메시지&lt;/em&gt; 가 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스 인 경우 형식 별 정보는 가능한 한 변환됩니다 . 경우 &lt;em&gt;메시지&lt;/em&gt; 문자열, 바이트 문자열, 또는 파일입니다, 그것은 포함해야 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 를 읽고 구문 분석 호환 메시지를. 파일은 이진 모드로 열어야하지만 텍스트 모드 파일은 이전 버전과의 호환성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdc2a6c5973e55d431189d76aeebd82bf0b0c31" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;method&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; then the default context is returned. Otherwise &lt;em&gt;method&lt;/em&gt; should be &lt;code&gt;'fork'&lt;/code&gt;, &lt;code&gt;'spawn'&lt;/code&gt;, &lt;code&gt;'forkserver'&lt;/code&gt;. &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if the specified start method is not available.</source>
          <target state="translated">경우 &lt;em&gt;방법은&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 다음 기본 컨텍스트가 반환됩니다. 그렇지 않으면 &lt;em&gt;메소드&lt;/em&gt; 는 &lt;code&gt;'fork'&lt;/code&gt; , &lt;code&gt;'spawn'&lt;/code&gt; , &lt;code&gt;'forkserver'&lt;/code&gt; 여야 합니다. 지정된 시작 방법을 사용할 수 없으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ea5b1e7d5baff8f354aa38723d8e2f2c3c8b26f4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;missing_ok&lt;/em&gt; is false (the default), &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt; is raised if the path does not exist.</source>
          <target state="translated">경우 &lt;em&gt;missing_ok가&lt;/em&gt; false (기본값), &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; 는&lt;/a&gt; 경로가 존재하지 않는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99eaa9a1562cd18740313159312a1e81d02af31f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;missing_ok&lt;/em&gt; is true, &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt; exceptions will be ignored (same behavior as the POSIX &lt;code&gt;rm -f&lt;/code&gt; command).</source>
          <target state="translated">경우 &lt;em&gt;missing_ok는&lt;/em&gt; 사실, &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; 의&lt;/a&gt; 예외합니다 (POSIX와 같은 행동을 무시됩니다 &lt;code&gt;rm -f&lt;/code&gt; 명령).</target>
        </trans-unit>
        <trans-unit id="ec95478d66e5bfa1b027996891cada38eb37683d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mode&lt;/em&gt; is &lt;a href=&quot;#os.P_NOWAIT&quot;&gt;&lt;code&gt;P_NOWAIT&lt;/code&gt;&lt;/a&gt;, this function returns the process id of the new process; if &lt;em&gt;mode&lt;/em&gt; is &lt;a href=&quot;#os.P_WAIT&quot;&gt;&lt;code&gt;P_WAIT&lt;/code&gt;&lt;/a&gt;, returns the process&amp;rsquo;s exit code if it exits normally, or &lt;code&gt;-signal&lt;/code&gt;, where &lt;em&gt;signal&lt;/em&gt; is the signal that killed the process. On Windows, the process id will actually be the process handle, so can be used with the &lt;a href=&quot;#os.waitpid&quot;&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">경우 &lt;em&gt;모드&lt;/em&gt; 입니다 &lt;a href=&quot;#os.P_NOWAIT&quot;&gt; &lt;code&gt;P_NOWAIT&lt;/code&gt; &lt;/a&gt; ,이 기능은 새로운 프로세스의 프로세스 ID를 반환 경우 &lt;em&gt;모드&lt;/em&gt; 입니다 &lt;a href=&quot;#os.P_WAIT&quot;&gt; &lt;code&gt;P_WAIT&lt;/code&gt; &lt;/a&gt; 정상적으로, 또는 종료하는 경우, 프로세스의 종료 코드를 반환합니다 &lt;code&gt;-signal&lt;/code&gt; 곳, &lt;em&gt;신호가&lt;/em&gt; 프로세스를 죽인 신호입니다. Windows에서 프로세스 ID는 실제로 프로세스 핸들이므로 &lt;a href=&quot;#os.waitpid&quot;&gt; &lt;code&gt;waitpid()&lt;/code&gt; &lt;/a&gt; 함수 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0375733b9f4f50742e4972b7f050e92927d8849" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'r'&lt;/code&gt;, the input file may be the concatenation of multiple compressed streams.</source>
          <target state="translated">경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'r'&lt;/code&gt; , 입력 파일은 다수의 압축 스트림의 연결 일 수있다.</target>
        </trans-unit>
        <trans-unit id="814277edd95a4cd9bd45db5f9fa454a24e7e3f22" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'w'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;, &lt;em&gt;compresslevel&lt;/em&gt; can be an integer between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt; specifying the level of compression: &lt;code&gt;1&lt;/code&gt; produces the least compression, and &lt;code&gt;9&lt;/code&gt; (default) produces the most compression.</source>
          <target state="translated">경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'w'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; , &lt;em&gt;compresslevel은&lt;/em&gt; 사이의 정수일 수 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;9&lt;/code&gt; : 압축률을 지정하는 &lt;code&gt;1&lt;/code&gt; 최소 압축을 생성하고, &lt;code&gt;9&lt;/code&gt; (기본값)은 가장 압축을 생성한다.</target>
        </trans-unit>
        <trans-unit id="3992701b4ac0def94c8a1290fc024926c3c7f6d8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, no attempt to find the module will be made. This is obscure, of use mostly in testing doctest itself: if &lt;em&gt;module&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, or is &lt;code&gt;None&lt;/code&gt; but cannot be found automatically, then all objects are considered to belong to the (non-existent) module, so all contained objects will (recursively) be searched for doctests.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 이 &lt;code&gt;False&lt;/code&gt; 이면 &lt;em&gt;모듈&lt;/em&gt; 을 찾으려고 시도하지 않습니다. 이것은 주로 자체 doctest가 테스트에 사용하기에, 불분명 다음의 경우 &lt;em&gt;모듈&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 또는없는 &lt;code&gt;None&lt;/code&gt; 있지만, 자동으로 찾을 수없는, 모든 객체는 (존재하지 않는) 모듈에 속하는 것으로 간주됩니다 그래서 모든 포함 된 개체 것이다 (재귀 적으로) doctest를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="342c503a565a339b191d71f66fedb8027cd7cd94" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module&lt;/em&gt; is defined, the &lt;code&gt;__module__&lt;/code&gt; attribute of the named tuple is set to that value.</source>
          <target state="translated">경우에 &lt;em&gt;모듈이&lt;/em&gt; 정의되어 상기 &lt;code&gt;__module__&lt;/code&gt; 명명 튜플의 속성이 값으로 설정된다.</target>
        </trans-unit>
        <trans-unit id="cf7e207e25f4af78f648134ee99a7b39d012d8fc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, then &lt;em&gt;filename&lt;/em&gt; specifies an OS-specific path. The path may be absolute or relative; relative paths are resolved with respect to the current working directory.</source>
          <target state="translated">경우 &lt;em&gt;module_relative은&lt;/em&gt; 이다 &lt;code&gt;False&lt;/code&gt; , 다음 &lt;em&gt;파일 이름&lt;/em&gt; OS에 특정 경로 지정을. 경로는 절대적이거나 상대적 일 수 있습니다. 상대 경로는 현재 작업 디렉토리와 관련하여 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="7f42640a3bf95f21f7a92a899894943811c847d3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, then each filename in &lt;em&gt;paths&lt;/em&gt; specifies an OS-specific path. The path may be absolute or relative; relative paths are resolved with respect to the current working directory.</source>
          <target state="translated">&lt;em&gt;module_relative&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;em&gt;경로의&lt;/em&gt; 각 파일 이름 은 OS 별 경로를 지정합니다. 경로는 절대적이거나 상대적 일 수 있습니다. 상대 경로는 현재 작업 디렉토리와 관련하여 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="0697d5b67fdf347746c9d5703805474938f31243" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), then &lt;em&gt;filename&lt;/em&gt; specifies an OS-independent module-relative path. By default, this path is relative to the calling module&amp;rsquo;s directory; but if the &lt;em&gt;package&lt;/em&gt; argument is specified, then it is relative to that package. To ensure OS-independence, &lt;em&gt;filename&lt;/em&gt; should use &lt;code&gt;/&lt;/code&gt; characters to separate path segments, and may not be an absolute path (i.e., it may not begin with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;em&gt;module_relative가&lt;/em&gt; 인 &lt;code&gt;True&lt;/code&gt; (디폴트), 다음 &lt;em&gt;파일 이름은&lt;/em&gt; OS에 독립적 인 모듈의 상대 경로를 지정한다. 기본적으로이 경로는 호출 모듈의 디렉토리에 상대적입니다. 그러나 &lt;em&gt;package&lt;/em&gt; 인수가 지정되면 해당 패키지와 관련이 있습니다. OS 독립성을 보장하기 위해 &lt;em&gt;filename&lt;/em&gt; 은 &lt;code&gt;/&lt;/code&gt; 문자를 사용 하여 경로 세그먼트를 구분해야하며 절대 경로가 아닐 수 있습니다 (예 : &lt;code&gt;/&lt;/code&gt; 로 시작하지 않을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="8d02f9fb85e6627d59eb80ccf4ea6b3a9b4d8c95" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), then each filename in &lt;em&gt;paths&lt;/em&gt; specifies an OS-independent module-relative path. By default, this path is relative to the calling module&amp;rsquo;s directory; but if the &lt;em&gt;package&lt;/em&gt; argument is specified, then it is relative to that package. To ensure OS-independence, each filename should use &lt;code&gt;/&lt;/code&gt; characters to separate path segments, and may not be an absolute path (i.e., it may not begin with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;em&gt;module_relative는&lt;/em&gt; 인 &lt;code&gt;True&lt;/code&gt; (기본)의 각 파일명 &lt;em&gt;경로&lt;/em&gt; 지정하는 OS 독립 모듈 상대 경로. 기본적으로이 경로는 호출 모듈의 디렉토리에 상대적입니다. 그러나 &lt;em&gt;package&lt;/em&gt; 인수가 지정되면 해당 패키지와 관련이 있습니다. OS 독립성을 보장하기 위해 각 파일 이름은 &lt;code&gt;/&lt;/code&gt; 문자를 사용 하여 경로 세그먼트를 구분해야하며 절대 경로가 아닐 수 있습니다 (즉, &lt;code&gt;/&lt;/code&gt; 로 시작하지 않을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="d91389354c01f8abc2286ef2886fcba27cafd30c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;monetary&lt;/em&gt; is true, the conversion uses monetary thousands separator and grouping strings.</source>
          <target state="translated">경우 &lt;em&gt;통화는&lt;/em&gt; 사실, 변환은 통화 천 단위 구분 및 그룹화 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b66af921caa012e5b11170246ad9eb33b73367d2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mutate_flag&lt;/em&gt; is true (the default), then the buffer is (in effect) passed to the underlying &lt;a href=&quot;#fcntl.ioctl&quot;&gt;&lt;code&gt;ioctl()&lt;/code&gt;&lt;/a&gt; system call, the latter&amp;rsquo;s return code is passed back to the calling Python, and the buffer&amp;rsquo;s new contents reflect the action of the &lt;a href=&quot;#fcntl.ioctl&quot;&gt;&lt;code&gt;ioctl()&lt;/code&gt;&lt;/a&gt;. This is a slight simplification, because if the supplied buffer is less than 1024 bytes long it is first copied into a static buffer 1024 bytes long which is then passed to &lt;a href=&quot;#fcntl.ioctl&quot;&gt;&lt;code&gt;ioctl()&lt;/code&gt;&lt;/a&gt; and copied back into the supplied buffer.</source>
          <target state="translated">경우 &lt;em&gt;mutate_flag가&lt;/em&gt; true (디폴트), 다음 버퍼가 기본으로 전달 (효과)입니다 &lt;a href=&quot;#fcntl.ioctl&quot;&gt; &lt;code&gt;ioctl()&lt;/code&gt; &lt;/a&gt; 시스템 호출의 후자의 리턴 코드가 호출 파이썬 등을 전달하고, 버퍼의 새로운 내용의 액션 반영 &lt;a href=&quot;#fcntl.ioctl&quot;&gt; &lt;code&gt;ioctl()&lt;/code&gt; &lt;/a&gt; . 제공된 버퍼의 길이가 1024 바이트 미만인 경우 먼저 정적 버퍼의 길이가 1024 바이트 인 정적 버퍼로 복사 된 다음 &lt;a href=&quot;#fcntl.ioctl&quot;&gt; &lt;code&gt;ioctl()&lt;/code&gt; &lt;/a&gt; 로 전달되어 제공된 버퍼로 다시 복사 되기 때문에 약간 단순화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9345507ddde308e47622c6e2a66a95ae7670e925" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is a string and is not known, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. If a specific value for &lt;em&gt;name&lt;/em&gt; is not supported by the host system, even if it is included in &lt;code&gt;confstr_names&lt;/code&gt;, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised with &lt;a href=&quot;errno#errno.EINVAL&quot;&gt;&lt;code&gt;errno.EINVAL&lt;/code&gt;&lt;/a&gt; for the error number.</source>
          <target state="translated">경우 &lt;em&gt;이름은&lt;/em&gt; 문자열이며, 알 수없는, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. 에 대한 특정 값 경우 &lt;em&gt;이름&lt;/em&gt; 이 포함 된 경우에도, 호스트 시스템에서 지원하지 않는 &lt;code&gt;confstr_names&lt;/code&gt; , &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 이&lt;/a&gt; 제기되고 &lt;a href=&quot;errno#errno.EINVAL&quot;&gt; &lt;code&gt;errno.EINVAL&lt;/code&gt; &lt;/a&gt; 오류 번호.</target>
        </trans-unit>
        <trans-unit id="1a2e0516f0e84799e5f5202bef0b9a437f74ac1b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is a string and is not known, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. If a specific value for &lt;em&gt;name&lt;/em&gt; is not supported by the host system, even if it is included in &lt;code&gt;pathconf_names&lt;/code&gt;, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised with &lt;a href=&quot;errno#errno.EINVAL&quot;&gt;&lt;code&gt;errno.EINVAL&lt;/code&gt;&lt;/a&gt; for the error number.</source>
          <target state="translated">경우 &lt;em&gt;이름은&lt;/em&gt; 문자열이며, 알 수없는, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. 에 대한 특정 값 경우 &lt;em&gt;이름&lt;/em&gt; 이 포함 된 경우에도, 호스트 시스템에서 지원하지 않는 &lt;code&gt;pathconf_names&lt;/code&gt; , &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 이&lt;/a&gt; 제기되고 &lt;a href=&quot;errno#errno.EINVAL&quot;&gt; &lt;code&gt;errno.EINVAL&lt;/code&gt; &lt;/a&gt; 오류 번호.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
