<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="fe5d317ef27fede7290daa1875858d3a3b83fe46" translate="yes" xml:space="preserve">
          <source>The following methods on bytes and bytearray objects have default behaviours that assume the use of ASCII compatible binary formats, but can still be used with arbitrary binary data by passing appropriate arguments. Note that all of the bytearray methods in this section do &lt;em&gt;not&lt;/em&gt; operate in place, and instead produce new objects.</source>
          <target state="translated">바이트 및 바이트 배열 객체에 대한 다음 메소드는 ASCII 호환 이진 형식의 사용을 가정하는 기본 동작을 갖지만 적절한 인수를 전달하여 임의의 이진 데이터와 함께 계속 사용할 수 있습니다. 이 섹션의 모든 바이트 배열 방법 은 제자리에서 작동 하지 &lt;em&gt;않고&lt;/em&gt; 대신 새 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0fcad2293c26eb0ab407e00568ab4856953388e4" translate="yes" xml:space="preserve">
          <source>The following methods provide the implementations for the corresponding functions of the same names. Using these methods on an instance is slightly more efficient since new &lt;a href=&quot;#pprint.PrettyPrinter&quot;&gt;&lt;code&gt;PrettyPrinter&lt;/code&gt;&lt;/a&gt; objects don&amp;rsquo;t need to be created.</source>
          <target state="translated">다음 메소드는 동일한 이름의 해당 기능에 대한 구현을 제공합니다. 새로운 &lt;a href=&quot;#pprint.PrettyPrinter&quot;&gt; &lt;code&gt;PrettyPrinter&lt;/code&gt; &lt;/a&gt; 객체를 만들 필요가 없으므로 인스턴스에서 이러한 방법을 사용하는 것이 약간 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="0ef20ec7cc268589dd8953c20b7832eaa6411d47" translate="yes" xml:space="preserve">
          <source>The following methods relate to interrogating and manipulating the content (payload) of the message.</source>
          <target state="translated">다음 방법은 메시지의 내용 (페이로드)을 조사하고 조작하는 것과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86cc03f304de911e71fbd54404fc5e768bc509f" translate="yes" xml:space="preserve">
          <source>The following methods support packing arrays and lists:</source>
          <target state="translated">다음 방법은 배열 및 목록 패킹을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ca834dd3a935b41fbbcc1f6b9e703b525f0b589b" translate="yes" xml:space="preserve">
          <source>The following methods support packing strings, bytes, and opaque data:</source>
          <target state="translated">다음 메소드는 문자열, 바이트 및 불투명 데이터 패킹을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8794526f4bbb1ad29beabe1b9ce9f577353fd460" translate="yes" xml:space="preserve">
          <source>The following methods support unpacking arrays and lists:</source>
          <target state="translated">다음 방법은 배열 및 목록 압축 풀기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bd2d2e65eb8063a136f55b38c01873cd38f7c28d" translate="yes" xml:space="preserve">
          <source>The following methods work on the element&amp;rsquo;s children (subelements).</source>
          <target state="translated">다음 방법은 요소의 하위 요소 (하위 요소)에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="091f163787d84de09ceceb500860d69ee8291d18" translate="yes" xml:space="preserve">
          <source>The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream.</source>
          <target state="translated">다음 모듈은 모두 반복자를 생성하고 반환합니다. 일부는 길이가 무한한 스트림을 제공하므로 스트림을 자르는 함수 나 루프를 통해서만 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4d77afab2cb5c0e79177397fed4c21c74e5e9f3" translate="yes" xml:space="preserve">
          <source>The following options are accepted:</source>
          <target state="translated">다음과 같은 옵션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf158b7a38f538cbeb112c3f0a3c620bcbc7a35" translate="yes" xml:space="preserve">
          <source>The following options are supported by labels, buttons and other button-like widgets.</source>
          <target state="translated">다음 옵션은 레이블, 버튼 및 기타 버튼 모양 위젯에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ecbfd24e6bd9b335bee8804e3b42d5788e91743e" translate="yes" xml:space="preserve">
          <source>The following options are supported by widgets that are controlled by a scrollbar.</source>
          <target state="translated">다음 옵션은 스크롤 막대로 제어되는 위젯에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8c6b0b5532833125ec2c30784f44b5a8d87a98" translate="yes" xml:space="preserve">
          <source>The following options are understood:</source>
          <target state="translated">다음과 같은 옵션이 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="8cbfbf5d0e333982b3f3653064e4b24868989a0c" translate="yes" xml:space="preserve">
          <source>The following options may be specified on tags:</source>
          <target state="translated">태그에 다음 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14f97aca91c658ff15a19e1f18483c692dbabe5a" translate="yes" xml:space="preserve">
          <source>The following parameters govern the use of the returned proxy instance. If &lt;em&gt;allow_none&lt;/em&gt; is true, the Python constant &lt;code&gt;None&lt;/code&gt; will be translated into XML; the default behaviour is for &lt;code&gt;None&lt;/code&gt; to raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is a commonly-used extension to the XML-RPC specification, but isn&amp;rsquo;t supported by all clients and servers; see &lt;a href=&quot;https://web.archive.org/web/20130120074804/http://ontosys.com/xml-rpc/extensions.php&quot;&gt;http://ontosys.com/xml-rpc/extensions.php&lt;/a&gt; for a description. The &lt;em&gt;use_builtin_types&lt;/em&gt; flag can be used to cause date/time values to be presented as &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; objects and binary data to be presented as &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects; this flag is false by default. &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; objects may be passed to calls. The &lt;em&gt;headers&lt;/em&gt; parameter is an optional sequence of HTTP headers to send with each request, expressed as a sequence of 2-tuples representing the header name and value. (e.g. &lt;code&gt;[(&amp;lsquo;Header-Name&amp;rsquo;, &amp;lsquo;value&amp;rsquo;)]&lt;/code&gt;). The obsolete &lt;em&gt;use_datetime&lt;/em&gt; flag is similar to &lt;em&gt;use_builtin_types&lt;/em&gt; but it applies only to date/time values.</source>
          <target state="translated">다음 매개 변수는 리턴 된 프록시 인스턴스 사용을 제어합니다. 경우 &lt;em&gt;allow_none는&lt;/em&gt; 사실, 파이썬 상수의 &lt;code&gt;None&lt;/code&gt; XML로 변환되지 않습니다; 디폴트의 ​​동작은 &lt;code&gt;None&lt;/code&gt; 이 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생시키는 것&lt;/a&gt; 입니다. 이것은 XML-RPC 사양에 일반적으로 사용되는 확장이지만 모든 클라이언트와 서버에서 지원되는 것은 아닙니다. 설명 은 &lt;a href=&quot;https://web.archive.org/web/20130120074804/http://ontosys.com/xml-rpc/extensions.php&quot;&gt;http://ontosys.com/xml-rpc/extensions.php&lt;/a&gt; 를 참조하십시오 . &lt;em&gt;use_builtin_types의&lt;/em&gt; 플래그로 표시되게 일자 / 시간 값으로 사용될 수 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; 개체와 같이 제시 될 이진 데이터 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체; 이 플래그는 기본적으로 false입니다. &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;그리고 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 객체는 호출에 전달 될 수있다. &lt;em&gt;헤더&lt;/em&gt; 파라미터는 헤더 이름 및 값을 나타내는 2- 튜플들의 시퀀스로 표현 각각의 요청과 함께 전송하는 HTTP 헤더의 임의의 서열이다. (예 : &lt;code&gt;[(&amp;lsquo;Header-Name&amp;rsquo;, &amp;lsquo;value&amp;rsquo;)]&lt;/code&gt; ). 사용되지 않는 &lt;em&gt;use_datetime의&lt;/em&gt; 플래그는 유사하다 &lt;em&gt;use_builtin_types&lt;/em&gt; 하지만 그것은 단지 날짜 / 시간 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a302c707afd73276e8e9058d62aa49220196f630" translate="yes" xml:space="preserve">
          <source>The following partial example shows how HTTP requests can be read with &lt;a href=&quot;#asynchat.async_chat&quot;&gt;&lt;code&gt;async_chat&lt;/code&gt;&lt;/a&gt;. A web server might create an &lt;code&gt;http_request_handler&lt;/code&gt; object for each incoming client connection. Notice that initially the channel terminator is set to match the blank line at the end of the HTTP headers, and a flag indicates that the headers are being read.</source>
          <target state="translated">다음 부분 예제는 &lt;a href=&quot;#asynchat.async_chat&quot;&gt; &lt;code&gt;async_chat&lt;/code&gt; 으로&lt;/a&gt; HTTP 요청을 읽는 방법을 보여줍니다 . 웹 서버는 들어오는 각 클라이언트 연결에 대해 &lt;code&gt;http_request_handler&lt;/code&gt; 객체를 만들 수 있습니다 . 처음에 채널 터미네이터는 HTTP 헤더 끝에있는 빈 줄과 일치하도록 설정되며 플래그는 헤더를 읽고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="529bcd0a5673a8760212749e93e46bb54c806dd9" translate="yes" xml:space="preserve">
          <source>The following people contributed code, feedback, design suggestions, previous implementations, and valuable experience to the creation of this module:</source>
          <target state="translated">다음 사람들은이 모듈을 만드는 데 코드, 피드백, 디자인 제안, 이전 구현 및 소중한 경험을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="f1a95d5d7d66f8c8b2965b631eb7c94d9497521e" translate="yes" xml:space="preserve">
          <source>The following people have helped with development or contributed their changes to the project and the public domain according to the Creative Commons Public Domain Dedication 1.0 Universal:</source>
          <target state="translated">다음 사람들은 Creative Commons Public Domain Dedication 1.0 Universal에 따라 프로젝트 개발 및 퍼블릭 도메인의 변경에 기여하거나 기여했습니다.</target>
        </trans-unit>
        <trans-unit id="7deb044d7f1c61862fe43de9aaee580268cfe27f" translate="yes" xml:space="preserve">
          <source>The following program acts like the Unix command &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/script(1)&quot;&gt;script(1)&lt;/a&gt;&lt;/em&gt;, using a pseudo-terminal to record all input and output of a terminal session in a &amp;ldquo;typescript&amp;rdquo;.</source>
          <target state="translated">다음 프로그램은 유사 터미널을 사용하여 터미널 세션의 모든 입력 및 출력을 &quot;유형 스크립트&quot;로 기록 하는 Unix 명령 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/script(1)&quot;&gt;스크립트 (1)&lt;/a&gt;&lt;/em&gt; 와 같은 역할 을합니다.</target>
        </trans-unit>
        <trans-unit id="367b0fc456694ac76cd955454753e1633b58d28e" translate="yes" xml:space="preserve">
          <source>The following program defines three handlers that just print out their arguments.</source>
          <target state="translated">다음 프로그램은 인수를 출력하는 세 개의 핸들러를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e15b1b65cbe609f8b69ba051c1225035c56d84c8" translate="yes" xml:space="preserve">
          <source>The following public attributes are available, their name starts with an underscore to not clash with exported function names:</source>
          <target state="translated">다음과 같은 공용 속성을 사용할 수 있으며 이름은 밑줄로 시작하여 내 보낸 함수 이름과 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8fe29cd06e30a4c87636f75391f16d425a8f82b" translate="yes" xml:space="preserve">
          <source>The following public domain dedication applies for both C hash function implementation, extension code, and this documentation:</source>
          <target state="translated">다음 공개 도메인 전용은 C 해시 함수 구현, 확장 코드 및이 문서 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f7cdb3d57aa9709e0fda8b7466db53cfd68f56c" translate="yes" xml:space="preserve">
          <source>The following scheduling policies are exposed if they are supported by the operating system.</source>
          <target state="translated">다음 스케줄링 정책이 운영 체제에서 지원되는 경우 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="171fddce63d63871c20206104dfe6ad4042e61db" translate="yes" xml:space="preserve">
          <source>The following script shows how to extend &lt;a href=&quot;#venv.EnvBuilder&quot;&gt;&lt;code&gt;EnvBuilder&lt;/code&gt;&lt;/a&gt; by implementing a subclass which installs setuptools and pip into a created virtual environment:</source>
          <target state="translated">다음 스크립트는 setuptools 및 pip를 작성된 가상 환경에 설치하는 서브 클래스를 구현하여 &lt;a href=&quot;#venv.EnvBuilder&quot;&gt; &lt;code&gt;EnvBuilder&lt;/code&gt; &lt;/a&gt; 를 확장하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="dea9f9f90b5e4b9e2a870864467c7dd5b595ffcf" translate="yes" xml:space="preserve">
          <source>The following sections describe how each of these are used.</source>
          <target state="translated">다음 섹션에서는 각각의 사용법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3a9decf4afaf4e942958bd6fa23d10328f1d3f93" translate="yes" xml:space="preserve">
          <source>The following sections describe the functionality of the &lt;a href=&quot;#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package. We start with the &lt;a href=&quot;email.message#module-email.message&quot;&gt;&lt;code&gt;message&lt;/code&gt;&lt;/a&gt; object model, which is the primary interface an application will use, and follow that with the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt; components. Then we cover the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; controls, which completes the treatment of the main components of the library.</source>
          <target state="translated">다음 섹션에서는 &lt;a href=&quot;#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지 의 기능에 대해 설명합니다 . 애플리케이션이 사용할 기본 인터페이스 인 &lt;a href=&quot;email.message#module-email.message&quot;&gt; &lt;code&gt;message&lt;/code&gt; &lt;/a&gt; 객체 모델로 시작 하고 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 구성 요소를 사용합니다. 그런 다음 라이브러리의 주요 구성 요소 처리를 완료 하는 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 제어를 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="8d78eda4905b7e8913f55c7ec5dea7f417f7b28c" translate="yes" xml:space="preserve">
          <source>The following sections describe the standard types that are built into the interpreter.</source>
          <target state="translated">다음 섹션에서는 인터프리터에 내장 된 표준 유형에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="45e7aaaad820443f966c2120652d6a91677438aa" translate="yes" xml:space="preserve">
          <source>The following sections walk you through this example.</source>
          <target state="translated">다음 섹션에서는이 예제를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="e3dbd4c3581dc46316fa29b8db92aef3fef69c69" translate="yes" xml:space="preserve">
          <source>The following server code creates a listener which uses &lt;code&gt;'secret password'&lt;/code&gt; as an authentication key. It then waits for a connection and sends some data to the client:</source>
          <target state="translated">다음 서버 코드는 &lt;code&gt;'secret password'&lt;/code&gt; 를 인증 키로 사용하는 리스너를 만듭니다 . 그런 다음 연결을 기다렸다가 클라이언트에 일부 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fd8bdf51f9cef176b447b925157d2f1ec027d433" translate="yes" xml:space="preserve">
          <source>The following simple example demonstrates how a module can initialize a counter from a file when it is imported and save the counter&amp;rsquo;s updated value automatically when the program terminates without relying on the application making an explicit call into this module at termination.</source>
          <target state="translated">다음의 간단한 예제는 모듈이 파일을 가져올 때 파일에서 카운터를 초기화하고 프로그램이 종료시이 모듈을 명시 적으로 호출하는 응용 프로그램에 의존하지 않고 프로그램이 종료 될 때 카운터의 업데이트 된 값을 자동으로 저장하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5bc1d6fdaa59debe0860e4cb7943f36fa41e6822" translate="yes" xml:space="preserve">
          <source>The following snippet gets a copy of the current context and prints all variables and their values that are set in it:</source>
          <target state="translated">다음 스 니펫은 현재 컨텍스트의 사본을 가져 와서 설정된 모든 변수 및 해당 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8de19fc9152a51c81af5ce82d482d53ca254ddd9" translate="yes" xml:space="preserve">
          <source>The following standard error handlers are also made available as module level functions:</source>
          <target state="translated">다음과 같은 표준 오류 처리기가 모듈 수준 함수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f9c0745c9c12b9b826231c8296a58577beafeaa2" translate="yes" xml:space="preserve">
          <source>The following table gives an overview of the known attacks and whether the various modules are vulnerable to them.</source>
          <target state="translated">다음 표는 알려진 공격과 다양한 모듈의 취약성에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1c15607942283b98a1b40e52e5fb242e94cbae81" translate="yes" xml:space="preserve">
          <source>The following table lists characters from the alternate character set. These are inherited from the VT100 terminal, and will generally be available on software emulations such as X terminals. When there is no graphic available, curses falls back on a crude printable ASCII approximation.</source>
          <target state="translated">다음 표는 대체 문자 세트의 문자 목록입니다. 이들은 VT100 터미널에서 상속되며 일반적으로 X 터미널과 같은 소프트웨어 에뮬레이션에서 사용할 수 있습니다. 사용 가능한 그래픽이 없으면 저주가 인쇄 가능한 ASCII 근사치로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="8df88cf415afbc5c718c26e20ba97bfc2c8077e9" translate="yes" xml:space="preserve">
          <source>The following table lists operations available for &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; that do not apply to immutable instances of &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 표는 불변의 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 인스턴스에 적용되지 않는 &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; 에&lt;/a&gt; 사용 가능한 작업 목록 입니다 .</target>
        </trans-unit>
        <trans-unit id="8f000a0a0f538cce6fd72f8e780dd513f81ddd97" translate="yes" xml:space="preserve">
          <source>The following table lists the predefined colors:</source>
          <target state="translated">다음 표는 사전 정의 된 색상을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="199a7716325262afeaf6de476b4454d2fd7515a5" translate="yes" xml:space="preserve">
          <source>The following table shows limits for general parameters (in bytes):</source>
          <target state="translated">다음 표는 일반 매개 변수의 한계 (바이트)를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d73048febc5f10c385f6d2cd27476dbe1173ea55" translate="yes" xml:space="preserve">
          <source>The following table summarizes the ABCs provided by the &lt;a href=&quot;#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">다음 표는 &lt;a href=&quot;#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 모듈에서 제공하는 ABC를 요약 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8a6d68b28d2c6944aaa923dd9703c275b97b4514" translate="yes" xml:space="preserve">
          <source>The following table summarizes the hierarchy of signals:</source>
          <target state="translated">다음 표는 신호의 계층 구조를 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2271cc608551f46a827e799032ab15e1c7a41565" translate="yes" xml:space="preserve">
          <source>The following token type values aren&amp;rsquo;t used by the C tokenizer but are needed for the &lt;a href=&quot;tokenize#module-tokenize&quot;&gt;&lt;code&gt;tokenize&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다음 토큰 유형 값은 C 토크 나이저에서 사용되지 않지만 &lt;a href=&quot;tokenize#module-tokenize&quot;&gt; &lt;code&gt;tokenize&lt;/code&gt; &lt;/a&gt; 모듈에 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="bef6f18ce38f019728dd0666b0d66e0a8d5ae438" translate="yes" xml:space="preserve">
          <source>The following top-level asyncio functions can be used to create and work with streams:</source>
          <target state="translated">다음과 같은 최상위 asyncio 함수를 사용하여 스트림을 만들고 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fad095bbe73ab43b2f492f3f94686d58bb9692" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to customize the child process watcher implementation used by the asyncio event loop:</source>
          <target state="translated">다음 두 함수를 사용하여 asyncio 이벤트 루프에서 사용하는 하위 프로세스 감시자 구현을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f3da66d6e4637688a4f52ed9ccb9cda480e190" translate="yes" xml:space="preserve">
          <source>The following two functions take either a single-character string or integer byte value; they return a value of the same type.</source>
          <target state="translated">다음 두 함수는 단일 문자 문자열 또는 정수 바이트 값을 사용합니다. 그들은 같은 유형의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0183f59493ff21316f06203e6399cd7d1e171fb" translate="yes" xml:space="preserve">
          <source>The following two methods are defined for compatibility with the &lt;a href=&quot;aifc#module-aifc&quot;&gt;&lt;code&gt;aifc&lt;/code&gt;&lt;/a&gt; module, and don&amp;rsquo;t do anything interesting.</source>
          <target state="translated">다음 두 가지 방법은 &lt;a href=&quot;aifc#module-aifc&quot;&gt; &lt;code&gt;aifc&lt;/code&gt; &lt;/a&gt; 모듈 과의 호환성을 위해 정의되어 있으며 흥미로운 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f41619c7aae20d9792891f2e74fb0953c9eada93" translate="yes" xml:space="preserve">
          <source>The following two methods can be called by clients to use a debugger to debug a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-statement&quot;&gt;statement&lt;/a&gt;, given as a string.</source>
          <target state="translated">클라이언트가 디버거를 사용 하여 문자열로 지정된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-statement&quot;&gt;명령문&lt;/a&gt; 을 디버깅하기 위해 다음 두 가지 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08ccbc3d71480f2615b68d36a4a3c3ebf7a593f3" translate="yes" xml:space="preserve">
          <source>The following two methods define a term &amp;ldquo;position&amp;rdquo; which is compatible between them, and is otherwise implementation dependent.</source>
          <target state="translated">다음 두 가지 방법은 &quot;위치&quot;라는 용어를 정의하며,이 둘은 서로 호환되며 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0660568ba9db5386c7ad481fdf3b299b62b3e48f" translate="yes" xml:space="preserve">
          <source>The following types are defined.</source>
          <target state="translated">다음과 같은 유형이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d6f43e13499b38a7ae0ecb769936d345110a69b8" translate="yes" xml:space="preserve">
          <source>The following types can be pickled:</source>
          <target state="translated">다음과 같은 유형을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4636476418bff0e90d252ad8b4efbb9ef1f42f9e" translate="yes" xml:space="preserve">
          <source>The following useful handlers are provided in the package. Note that three of the handlers (&lt;a href=&quot;#logging.StreamHandler&quot;&gt;&lt;code&gt;StreamHandler&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.FileHandler&quot;&gt;&lt;code&gt;FileHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#logging.NullHandler&quot;&gt;&lt;code&gt;NullHandler&lt;/code&gt;&lt;/a&gt;) are actually defined in the &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; module itself, but have been documented here along with the other handlers.</source>
          <target state="translated">패키지에는 다음과 같은 유용한 핸들러가 제공됩니다. 핸들러 중 3 개 ( &lt;a href=&quot;#logging.StreamHandler&quot;&gt; &lt;code&gt;StreamHandler&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.FileHandler&quot;&gt; &lt;code&gt;FileHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#logging.NullHandler&quot;&gt; &lt;code&gt;NullHandler&lt;/code&gt; &lt;/a&gt; )는 실제로 &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 모듈 자체에 정의되어 있지만 다른 핸들러와 함께 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2674cf7f842b409bd68c94890646ec6f4399d09" translate="yes" xml:space="preserve">
          <source>The following utility functions are defined:</source>
          <target state="translated">다음과 같은 유틸리티 기능이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="417d394511e1309a8dae0e325c38f0a8caf3a18c" translate="yes" xml:space="preserve">
          <source>The following values are provided as constant attributes of the hash objects returned by the constructors:</source>
          <target state="translated">다음 값은 생성자가 반환 한 해시 객체의 상수 속성으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1aef3ce4065fb44fb99d2a7c3b157d02f58aec0d" translate="yes" xml:space="preserve">
          <source>The following variables are provided for read-only access (you can mutate the values but should not rebind them):</source>
          <target state="translated">읽기 전용 액세스를 위해 다음 변수가 제공됩니다 (값을 변경할 수는 있지만 리 바인드해서는 안 됨).</target>
        </trans-unit>
        <trans-unit id="bed98bc423abff4881d393f2595bfb18c30ad258" translate="yes" xml:space="preserve">
          <source>The following warnings category classes are currently defined:</source>
          <target state="translated">다음과 같은 경고 범주 클래스가 현재 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56c999175598c3a0646577066314485f95412182" translate="yes" xml:space="preserve">
          <source>The font preferences, highlighting, keys, and general preferences can be changed via Configure IDLE on the Option menu. Non-default user settings are saved in a &lt;code&gt;.idlerc&lt;/code&gt; directory in the user&amp;rsquo;s home directory. Problems caused by bad user configuration files are solved by editing or deleting one or more of the files in &lt;code&gt;.idlerc&lt;/code&gt;.</source>
          <target state="translated">글꼴 기본 설정, 강조 표시, 키 및 일반 기본 설정은 옵션 메뉴의 IDLE 구성을 통해 변경할 수 있습니다. 기본이 아닌 사용자 설정은 사용자 홈 디렉토리의 &lt;code&gt;.idlerc&lt;/code&gt; 디렉토리에 저장됩니다 . 잘못된 사용자 구성 파일로 인한 문제는 &lt;code&gt;.idlerc&lt;/code&gt; 에서 하나 이상의 파일을 편집하거나 삭제하면 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a1ed52da4ac65d01c5a6043c3a96a83c3e6f4e8" translate="yes" xml:space="preserve">
          <source>The foregoing represent the modern (unicode friendly) API of the email package. The remaining sections, starting with the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; class, cover the legacy &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; API that deals much more directly with the details of how email messages are represented. The &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; API does &lt;em&gt;not&lt;/em&gt; hide the details of the RFCs from the application, but for applications that need to operate at that level, they can be useful tools. This documentation is also relevant for applications that are still using the &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; API for backward compatibility reasons.</source>
          <target state="translated">전술 한 내용은 이메일 패키지의 최신 (유니 코드 친화적) API를 나타냅니다. &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 클래스로 시작하는 나머지 섹션 은 전자 메일 메시지가 표현되는 방법에 대한 세부 정보를 훨씬 더 직접 다루는 레거시 &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; API를 다룹니다. &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 의&lt;/a&gt; API는 않습니다 &lt;em&gt;하지&lt;/em&gt; 응용 프로그램에서의 RFC의 세부 사항을 숨길 필요하지만 그 수준에서 작동 할 수 있음을 응용 프로그램에 대한, 그들은 유용한 도구가 될 수 있습니다. 이 문서는 이전 버전과의 호환성을 위해 여전히 &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; API를 사용하는 응용 프로그램과 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9719a694099674e215e94f8bb4b03c9883cc3b74" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;'!'&lt;/code&gt; is available for those poor souls who claim they can&amp;rsquo;t remember whether network byte order is big-endian or little-endian.</source>
          <target state="translated">&lt;code&gt;'!'&lt;/code&gt; 양식 네트워크 바이트 순서가 빅 엔디안인지 리틀 엔디안인지 기억하지 못하는 가난한 영혼이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5dd3c1d4e4c87b360e21a7a86c94ad48c591b4f" translate="yes" xml:space="preserve">
          <source>The format of a MIME document allows for some text between the blank line following the headers, and the first multipart boundary string. Normally, this text is never visible in a MIME-aware mail reader because it falls outside the standard MIME armor. However, when viewing the raw text of the message, or when viewing the message in a non-MIME aware reader, this text can become visible.</source>
          <target state="translated">MIME 문서의 형식은 헤더 다음의 빈 줄과 첫 번째 다중 부분 경계 문자열 사이에 일부 텍스트를 허용합니다. 일반적으로이 텍스트는 표준 MIME 방어구를 벗어나기 때문에 MIME 인식 메일 리더에서 볼 수 없습니다. 그러나 메시지의 원시 텍스트를 보거나 MIME를 인식하지 않는 판독기에서 메시지를 볼 때이 텍스트가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6d7d0fe4f5076068f89a5ef002f30e9fa3a415c" translate="yes" xml:space="preserve">
          <source>The format string passed in the original logging call. Merged with &lt;code&gt;args&lt;/code&gt; to produce &lt;code&gt;message&lt;/code&gt;, or an arbitrary object (see &lt;a href=&quot;https://docs.python.org/3.8/howto/logging.html#arbitrary-object-messages&quot;&gt;Using arbitrary objects as messages&lt;/a&gt;).</source>
          <target state="translated">원래 로깅 호출에 전달 된 형식 문자열 &lt;code&gt;args&lt;/code&gt; 와 병합 하여 &lt;code&gt;message&lt;/code&gt; 또는 임의의 객체 를 생성 합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/howto/logging.html#arbitrary-object-messages&quot;&gt;임의의 객체를 메시지로 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="be25f62349a67e88a6f71056aa170d23e1720b2d" translate="yes" xml:space="preserve">
          <source>The format string used to construct this Struct object.</source>
          <target state="translated">이 Struct 객체를 구성하는 데 사용되는 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ae307c00fd124ab53e7ea3ea2b261a8e4e5be037" translate="yes" xml:space="preserve">
          <source>The format-specific state and behaviors offered by subclasses vary, but in general it is only the properties that are not specific to a particular mailbox that are supported (although presumably the properties are specific to a particular mailbox format). For example, file offsets for single-file mailbox formats and file names for directory-based mailbox formats are not retained, because they are only applicable to the original mailbox. But state such as whether a message has been read by the user or marked as important is retained, because it applies to the message itself.</source>
          <target state="translated">서브 클래스가 제공하는 형식 별 상태 및 동작은 다양하지만 일반적으로 지원되는 특정 사서함에 국한되지 않는 속성 일뿐입니다 (속성은 특정 사서함 형식에 따라 다름). 예를 들어 단일 파일 사서함 형식의 파일 오프셋과 디렉터리 기반 사서함 형식의 파일 이름은 원래 사서함에만 적용 할 수 있으므로 유지되지 않습니다. 그러나 사용자가 메시지를 읽었는지 또는 중요로 표시했는지 여부와 같은 상태는 메시지 자체에 적용되므로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2068792b8c84f3317cef9c46aa469beb4c18671a" translate="yes" xml:space="preserve">
          <source>The formatted representation keeps objects on a single line if it can, and breaks them onto multiple lines if they don&amp;rsquo;t fit within the allowed width. Construct &lt;a href=&quot;#pprint.PrettyPrinter&quot;&gt;&lt;code&gt;PrettyPrinter&lt;/code&gt;&lt;/a&gt; objects explicitly if you need to adjust the width constraint.</source>
          <target state="translated">형식이 지정된 표현은 가능한 경우 객체를 한 줄로 유지하고 허용 된 너비에 맞지 않으면 여러 줄로 나눕니다. 구축 &lt;a href=&quot;#pprint.PrettyPrinter&quot;&gt; &lt;code&gt;PrettyPrinter&lt;/code&gt; 는&lt;/a&gt; 당신이 너비 제약 조건을 조정해야하는 경우 명시 적으로 객체.</target>
        </trans-unit>
        <trans-unit id="65f1a1fcc9353f70b97874c23d158416af799011" translate="yes" xml:space="preserve">
          <source>The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). If the value being printed may be a tuple or dictionary, wrap it in a tuple.</source>
          <target state="translated">여기에 설명 된 형식화 조작은 여러 가지 일반적인 문제를 야기하며 (예 : 튜플 및 사전을 올바르게 표시하지 못하는 등) 많은 오류가 발생합니다. 인쇄되는 값이 튜플 또는 사전 일 수 있으면 튜플에 싸십시오.</target>
        </trans-unit>
        <trans-unit id="736661bf5ae9da6e21319dfbf436b716e730fac9" translate="yes" xml:space="preserve">
          <source>The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;formatted string literals&lt;/a&gt;, the &lt;a href=&quot;#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; interface, or &lt;a href=&quot;string#template-strings&quot;&gt;template strings&lt;/a&gt; may help avoid these errors. Each of these alternatives provides their own trade-offs and benefits of simplicity, flexibility, and/or extensibility.</source>
          <target state="translated">여기에 설명 된 형식화 조작은 여러 가지 일반적인 문제를 야기하며 (예 : 튜플 및 사전을 올바르게 표시하지 못하는 등) 많은 오류가 발생합니다. 최신 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;형식의 문자열 리터럴&lt;/a&gt; , &lt;a href=&quot;#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 인터페이스 또는 &lt;a href=&quot;string#template-strings&quot;&gt;템플릿 문자열을 사용&lt;/a&gt; 하면 이러한 오류를 피할 수 있습니다. 이러한 각 대안은 단순성, 유연성 및 / 또는 확장 성의 장점과 장점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9f4beec66d61f16cdc1211acdb5e32b9a0da1701" translate="yes" xml:space="preserve">
          <source>The fourth keyword argument is &lt;em&gt;extra&lt;/em&gt; which can be used to pass a dictionary which is used to populate the __dict__ of the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example:</source>
          <target state="translated">네 번째 키워드 인수는 &lt;em&gt;추가&lt;/em&gt; 의 __dict__를 채우는 데 사용되는 사전 전달하는 데 사용할 수있는 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 의은&lt;/a&gt; 사용자 정의 속성 로깅 이벤트를 생성합니다. 그런 다음이 사용자 정의 속성을 원하는대로 사용할 수 있습니다. 예를 들어, 로그 된 메시지에 통합 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50c1d55e08881836b2c182107f0d498d07d91b19" translate="yes" xml:space="preserve">
          <source>The frame which surrounds the text and scroll bar widgets.</source>
          <target state="translated">텍스트 및 스크롤 막대 위젯을 둘러싼 프레임입니다.</target>
        </trans-unit>
        <trans-unit id="71946bf5956b0651b1d3fd66ea569f6999a0d1da" translate="yes" xml:space="preserve">
          <source>The frames are always ordered from oldest to newest.</source>
          <target state="translated">프레임은 항상 가장 오래된 것부터 가장 오래된 것으로 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="161ae6ad033364019934ee1a5e00d05069bbe45e" translate="yes" xml:space="preserve">
          <source>The free lists maintained for a number of built-in types are cleared whenever a full collection or collection of the highest generation (2) is run. Not all items in some free lists may be freed due to the particular implementation, in particular &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다수의 내장 유형에 대해 유지 보수되는 무료 목록은 전체 콜렉션 또는 최고 세대의 콜렉션이 실행될 때마다 지워집니다 (2). 특정 구현, 특히 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 로 인해 일부 비어있는 목록의 모든 항목이 해제되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3181ea2680676ac4e3ea5b9f30267230dfb43d97" translate="yes" xml:space="preserve">
          <source>The full details for each codec can also be looked up directly:</source>
          <target state="translated">각 코덱에 대한 자세한 내용도 직접 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3baef1d8e6a5b643e6aa0b077cbe17d9809e771e" translate="yes" xml:space="preserve">
          <source>The full list of supported magic methods is:</source>
          <target state="translated">지원되는 매직 메소드의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a050047df44eb3ec26703753ce3557390dfcef84" translate="yes" xml:space="preserve">
          <source>The full pathname of the file where the logging call was made.</source>
          <target state="translated">로깅 호출이 작성된 파일의 전체 경로 이름</target>
        </trans-unit>
        <trans-unit id="52768adda6d0fcaec4a3d239126958c6e7925060" translate="yes" xml:space="preserve">
          <source>The full set of available metadata is not described here. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0566/&quot;&gt;PEP 566&lt;/a&gt; for additional details.</source>
          <target state="translated">사용 가능한 전체 메타 데이터 세트는 여기에 설명되어 있지 않습니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0566/&quot;&gt;PEP 566&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6a53fa6b4d82cd9340e1e2e41b030339bc39862c" translate="yes" xml:space="preserve">
          <source>The full set of format codes supported varies across platforms, because Python calls the platform C library&amp;rsquo;s &lt;code&gt;strftime()&lt;/code&gt; function, and platform variations are common. To see the full set of format codes supported on your platform, consult the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/strftime(3)&quot;&gt;strftime(3)&lt;/a&gt;&lt;/em&gt; documentation.</source>
          <target state="translated">파이썬이 플랫폼 C 라이브러리의 &lt;code&gt;strftime()&lt;/code&gt; 함수를 호출 하고 플랫폼 변형이 일반적 이기 때문에 지원되는 전체 형식 코드 세트는 플랫폼마다 다릅니다 . 플랫폼에서 지원되는 전체 형식 코드 세트를 보려면 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/strftime(3)&quot;&gt;strftime (3)&lt;/a&gt;&lt;/em&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7a36eaa97599d772f3f39f239cfbecb1e668b83" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#ctypes.get_errno&quot;&gt;&lt;code&gt;ctypes.get_errno()&lt;/code&gt;&lt;/a&gt; returns the value of the ctypes private copy, and the function &lt;a href=&quot;#ctypes.set_errno&quot;&gt;&lt;code&gt;ctypes.set_errno()&lt;/code&gt;&lt;/a&gt; changes the ctypes private copy to a new value and returns the former value.</source>
          <target state="translated">&lt;a href=&quot;#ctypes.get_errno&quot;&gt; &lt;code&gt;ctypes.get_errno()&lt;/code&gt; &lt;/a&gt; 함수 는 ctypes 개인용 사본의 값을 리턴하고 &lt;a href=&quot;#ctypes.set_errno&quot;&gt; &lt;code&gt;ctypes.set_errno()&lt;/code&gt; &lt;/a&gt; 함수 는 ctypes 개인용 사본을 새로운 값으로 변경하고 이전 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a38682aa64e9cc436b589cdea1ec5b09472c86b5" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#turtle.Screen&quot;&gt;&lt;code&gt;Screen()&lt;/code&gt;&lt;/a&gt; returns a singleton object of a &lt;a href=&quot;#turtle.TurtleScreen&quot;&gt;&lt;code&gt;TurtleScreen&lt;/code&gt;&lt;/a&gt; subclass. This function should be used when &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; is used as a standalone tool for doing graphics. As a singleton object, inheriting from its class is not possible.</source>
          <target state="translated">&lt;a href=&quot;#turtle.Screen&quot;&gt; &lt;code&gt;Screen()&lt;/code&gt; &lt;/a&gt; 함수 는 &lt;a href=&quot;#turtle.TurtleScreen&quot;&gt; &lt;code&gt;TurtleScreen&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 싱글 톤 객체를 반환합니다 . 이 기능은 &lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 가 그래픽 작업을위한 독립형 도구로 사용될 때 사용해야 합니다. 단일 객체로서 클래스에서 상속 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b87f0634b41ea1ec18dd7a551e460ae927d90b6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt; which always returns zero is just a special case of constant functions. A faster and more flexible way to create constant functions is to use a lambda function which can supply any constant value (not just zero):</source>
          <target state="translated">함수 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt; 는 항상 0을 반환 일정 기능의 단지 특별한 경우입니다. 상수 함수를 만드는 더 빠르고 유연한 방법은 0이 아닌 상수 값을 제공 할 수있는 람다 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71b8ad460c36f096a3aad56832cd408db71564e1" translate="yes" xml:space="preserve">
          <source>The function accepts a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은 객체를&lt;/a&gt; 받아들 입니다.</target>
        </trans-unit>
        <trans-unit id="9e4b7efae4c2a025a1f28a0d482c804af6e6abc5" translate="yes" xml:space="preserve">
          <source>The function being decorated must return a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;-iterator when called. This iterator must yield exactly one value, which will be bound to the targets in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement&amp;rsquo;s &lt;code&gt;as&lt;/code&gt; clause, if any.</source>
          <target state="translated">데코레이션되는 함수는 호출시 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; -iterator를 리턴해야합니다 . 이 반복자는 정확히 하나의 값을 가져와야하며, &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 &lt;code&gt;as&lt;/code&gt; 절 에서 대상에 바인딩됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="4964e748216323e3b95686ec08b823153b01f6f1" translate="yes" xml:space="preserve">
          <source>The function below takes and returns a string and is annotated as follows:</source>
          <target state="translated">아래 함수는 문자열을 가져 와서 반환하며 다음과 같이 주석이 달립니다.</target>
        </trans-unit>
        <trans-unit id="5ecee13fddbb2ad43c67a6023a70bf572f95a3fb" translate="yes" xml:space="preserve">
          <source>The function can return any of the types supported by SQLite: bytes, str, int, float and &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 함수는 SQLite에서 지원하는 모든 유형 (bytes, str, int, float 및 &lt;code&gt;None&lt;/code&gt; )을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00d27286dafdecef65c8492fc893c6916a3a28d" translate="yes" xml:space="preserve">
          <source>The function factories can be used as decorator factories, so we may as well write:</source>
          <target state="translated">함수 팩토리는 데코레이터 팩토리로 사용할 수 있으므로 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ec5701e77abe81a5878799586d5ba1ca183541d" translate="yes" xml:space="preserve">
          <source>The function has an O(1) complexity, i.e. works equally fast for contexts with a few context variables and for contexts that have a lot of them.</source>
          <target state="translated">이 함수는 O (1) 복잡성을가집니다. 즉, 몇 가지 컨텍스트 변수가있는 컨텍스트와 변수가 많은 컨텍스트에 대해 동일하게 빠르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3c9c3393d80d8e73322ff3dc8fd0ef5bfc0388fd" translate="yes" xml:space="preserve">
          <source>The function imports the module &lt;em&gt;name&lt;/em&gt;, potentially using the given &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; to determine how to interpret the name in a package context. The &lt;em&gt;fromlist&lt;/em&gt; gives the names of objects or submodules that should be imported from the module given by &lt;em&gt;name&lt;/em&gt;. The standard implementation does not use its &lt;em&gt;locals&lt;/em&gt; argument at all, and uses its &lt;em&gt;globals&lt;/em&gt; only to determine the package context of the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">이 함수는 모듈 &lt;em&gt;이름을&lt;/em&gt; 가져 &lt;em&gt;와서&lt;/em&gt; 주어진 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역&lt;/em&gt; 을 사용하여 패키지 컨텍스트에서 이름을 해석하는 방법을 결정합니다. &lt;em&gt;fromlist는&lt;/em&gt; 에 의해 주어진 모듈에서 수입해야 개체 또는 서브 모듈의 이름을 제공 &lt;em&gt;이름을&lt;/em&gt; . 표준 구현은 &lt;em&gt;locals&lt;/em&gt; 인수를 전혀 사용하지 않으며 &lt;em&gt;전역을&lt;/em&gt; 사용 하여 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문의 패키지 컨텍스트를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="6b4d83d80a06e6dbd1200b63632e36990e0a8937" translate="yes" xml:space="preserve">
          <source>The function is basically hooked up to the class, but each &lt;code&gt;Mock&lt;/code&gt; instance is kept isolated from the others.</source>
          <target state="translated">이 함수는 기본적으로 클래스에 연결되어 있지만 각 &lt;code&gt;Mock&lt;/code&gt; 인스턴스는 다른 클래스와 격리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d4f8ef455c11eca2983634ccc2605fc737a1517" translate="yes" xml:space="preserve">
          <source>The function is implemented using a busy loop (non-blocking call and short sleeps). Use the &lt;a href=&quot;asyncio#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; module for an asynchronous wait: see &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;asyncio.create_subprocess_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 통화 중 루프 (비 차단 통화 및 짧은 절전 모드)를 사용하여 구현됩니다. 사용 &lt;a href=&quot;asyncio#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 비동기 대기에 대한 모듈은 다음을 참조 &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;asyncio.create_subprocess_exec&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2955159f98910d80a399f71d31e3b1b90fadb227" translate="yes" xml:space="preserve">
          <source>The function name, or &lt;code&gt;&quot;&amp;lt;lambda&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">함수 이름, 또는 &lt;code&gt;&quot;&amp;lt;lambda&amp;gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="365121208e03505058ab8f130f9bd3bca08359b1" translate="yes" xml:space="preserve">
          <source>The function now returns (exitcode, output) instead of (status, output) as it did in Python 3.3.3 and earlier. exitcode has the same value as &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 Python 3.3.3 및 이전 버전에서와 같이 (상태, 출력) 대신 (종료 코드, 출력)을 반환합니다. exitcode의 값은 &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="24ffb70148ec58a433c4b1d89a0965f0711f4f4d" translate="yes" xml:space="preserve">
          <source>The function provides PKCS#5 password-based key derivation function 2. It uses HMAC as pseudorandom function.</source>
          <target state="translated">이 기능은 PKCS # 5 암호 기반 키 파생 기능 2를 제공합니다. 의사 난수 기능으로 HMAC를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0e2de60a490dd61f01eed040ccc54b9c73ea91cd" translate="yes" xml:space="preserve">
          <source>The function provides scrypt password-based key derivation function as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7914.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 7914&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7914.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 7914에&lt;/strong&gt;&lt;/a&gt; 정의 된 &lt;strong&gt;대로&lt;/strong&gt; 암호 기반 키 파생 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f561d6267c3502d36b88afd7ef1ffa056b70ffea" translate="yes" xml:space="preserve">
          <source>The function relies on the system&amp;rsquo;s &lt;code&gt;file&lt;/code&gt; command to do the actual work. This is available on most if not all Unix platforms and some non-Unix platforms and then only if the executable points to the Python interpreter. Reasonable defaults are used when the above needs are not met.</source>
          <target state="translated">이 기능은 실제 작업을 수행하기 위해 시스템의 &lt;code&gt;file&lt;/code&gt; 명령 에 의존 합니다. 이것은 모든 유닉스 플랫폼 및 일부 비 유닉스 플랫폼이 아닌 대부분의 경우에 사용 가능하며 실행 파일이 Python 인터프리터를 가리키는 경우에만 사용할 수 있습니다. 위의 요구 사항이 충족되지 않으면 합리적인 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d52ea0a133e3b335ca7fab0110722708877e527" translate="yes" xml:space="preserve">
          <source>The function retrieves the name of one subkey each time it is called. It is typically called repeatedly until an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised, indicating, no more values are available.</source>
          <target state="translated">이 함수는 호출 될 때마다 하나의 하위 키 이름을 검색합니다. 일반적으로 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생 하여 더 이상 값을 사용할 수 없음을 나타낼 때까지 반복적으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="2582f1768c74b6155a206d847a340d93a1ea4148" translate="yes" xml:space="preserve">
          <source>The function retrieves the name of one subkey each time it is called. It is typically called repeatedly, until an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised, indicating no more values.</source>
          <target state="translated">이 함수는 호출 될 때마다 하나의 하위 키 이름을 검색합니다. 일반적으로 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생하여 더 이상 값을 표시하지 않을 때까지 반복적으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="68a88dc4460581a1f4b714350b90ad83cf5217dc" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;True&lt;/code&gt; if the handler was successfully removed, &lt;code&gt;False&lt;/code&gt; if there was nothing to remove.</source>
          <target state="translated">이 함수는 반환 &lt;code&gt;True&lt;/code&gt; 핸들러가 성공적으로 제거 된 경우 &lt;code&gt;False&lt;/code&gt; 제거 아무것도 없었다 경우.</target>
        </trans-unit>
        <trans-unit id="8c9b59d5b0268ec4ba28cc4423ac762b8511ebfa" translate="yes" xml:space="preserve">
          <source>The function returns a binary string that is the contents of the specified resource.</source>
          <target state="translated">이 함수는 지정된 리소스의 내용 인 이진 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b50f3d08041041132e0f473696962273773e2908" translate="yes" xml:space="preserve">
          <source>The function returns a list of (cert_bytes, encoding_type, trust) tuples. The encoding_type specifies the encoding of cert_bytes. It is either &lt;code&gt;x509_asn&lt;/code&gt; for X.509 ASN.1 data or &lt;code&gt;pkcs_7_asn&lt;/code&gt; for PKCS#7 ASN.1 data.</source>
          <target state="translated">이 함수는 (cert_bytes, encoding_type, trust) 튜플 목록을 반환합니다. encoding_type은 cert_bytes의 인코딩을 지정합니다. 그것은 하나 인 &lt;code&gt;x509_asn&lt;/code&gt; X.509 ASN.1 데이터 또는 대 &lt;code&gt;pkcs_7_asn&lt;/code&gt; PKCS # 7 ASN.1 데이터.</target>
        </trans-unit>
        <trans-unit id="f1e3d1267f3b1275f1718a97de1785b2d93ae19f" translate="yes" xml:space="preserve">
          <source>The function returns a list of (cert_bytes, encoding_type, trust) tuples. The encoding_type specifies the encoding of cert_bytes. It is either &lt;code&gt;x509_asn&lt;/code&gt; for X.509 ASN.1 data or &lt;code&gt;pkcs_7_asn&lt;/code&gt; for PKCS#7 ASN.1 data. Trust specifies the purpose of the certificate as a set of OIDS or exactly &lt;code&gt;True&lt;/code&gt; if the certificate is trustworthy for all purposes.</source>
          <target state="translated">이 함수는 (cert_bytes, encoding_type, trust) 튜플 목록을 반환합니다. encoding_type은 cert_bytes의 인코딩을 지정합니다. 그것은 하나 인 &lt;code&gt;x509_asn&lt;/code&gt; X.509 ASN.1 데이터 또는 대 &lt;code&gt;pkcs_7_asn&lt;/code&gt; PKCS # 7 ASN.1 데이터. 신뢰는 인증서의 목적을 OIDS 세트로 지정하거나 모든 목적에 대해 인증서를 신뢰할 수있는 경우 정확히 &lt;code&gt;True&lt;/code&gt; 로 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="b9d088b3ab98a7587eb78136dcb713f81c7d61e3" translate="yes" xml:space="preserve">
          <source>The function returns a list of 5-tuples with the following structure:</source>
          <target state="translated">이 함수는 다음 구조를 가진 5 개의 튜플 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37cd4c3b155cc249789a9f5e5caa9fc5922b36b6" translate="yes" xml:space="preserve">
          <source>The function sets temporarily the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale to the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale or the &lt;code&gt;LC_MONETARY&lt;/code&gt; locale if locales are different and numeric or monetary strings are non-ASCII. This temporary change affects other threads.</source>
          <target state="translated">로케일이 다르고 숫자 또는 통화 문자열이 ASCII가 아닌 경우 함수는 일시적으로 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일을 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일 또는 &lt;code&gt;LC_MONETARY&lt;/code&gt; 로케일로 설정합니다. 이 임시 변경은 다른 스레드에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="781903a74446cb87f37b26e0046512b71cb5c6b8" translate="yes" xml:space="preserve">
          <source>The function will return when all futures finish or are cancelled.</source>
          <target state="translated">모든 선물이 끝나거나 취소되면 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c00e0412657827ab360f55b434af658b4db6f97d" translate="yes" xml:space="preserve">
          <source>The function will return when any future finishes by raising an exception. If no future raises an exception then it is equivalent to &lt;code&gt;ALL_COMPLETED&lt;/code&gt;.</source>
          <target state="translated">미래에 예외가 발생하여 함수가 완료되면 함수가 리턴됩니다. 미래에 예외가 발생하지 않으면 &lt;code&gt;ALL_COMPLETED&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b0470e2a163bad2980d4698bead65be03737a88e" translate="yes" xml:space="preserve">
          <source>The function will return when any future finishes or is cancelled.</source>
          <target state="translated">향후 완료되거나 취소되면이 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="649519a40304cc18d6400172e89f487baa3a326e" translate="yes" xml:space="preserve">
          <source>The function will wait until the future is actually cancelled, so the total wait time may exceed the &lt;em&gt;timeout&lt;/em&gt;.</source>
          <target state="translated">이 함수는 미래가 실제로 취소 될 때까지 대기하므로 총 대기 시간이 &lt;em&gt;제한 시간을&lt;/em&gt; 초과 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ce9e44bf29a2729baf1bf10f22356d2b44b74c" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; provide a simple interface to doctest that should be sufficient for most basic uses. For a less formal introduction to these two functions, see sections &lt;a href=&quot;#doctest-simple-testmod&quot;&gt;Simple Usage: Checking Examples in Docstrings&lt;/a&gt; and &lt;a href=&quot;#doctest-simple-testfile&quot;&gt;Simple Usage: Checking Examples in a Text File&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 함수 는 대부분의 기본 용도에 충분한 doctest에 대한 간단한 인터페이스를 제공합니다. 이 두 함수에 대한 덜 공식적인 소개는 &lt;a href=&quot;#doctest-simple-testfile&quot;&gt;간단한 사용법 : 문서 문자열에서 예제 확인&lt;/a&gt; 및 간단한 사용법 : 텍스트 파일에서 예제 &lt;a href=&quot;#doctest-simple-testmod&quot;&gt;확인&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00c81ac863428b895227c7dbcbabc56b872b4575" translate="yes" xml:space="preserve">
          <source>The functions &lt;em&gt;master_read&lt;/em&gt; and &lt;em&gt;stdin_read&lt;/em&gt; are passed a file descriptor which they should read from, and they should always return a byte string. In order to force spawn to return before the child process exits an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; should be thrown.</source>
          <target state="translated">&lt;em&gt;master_read&lt;/em&gt; 및 &lt;em&gt;stdin_read&lt;/em&gt; 함수 는 읽어야하는 파일 디스크립터에 전달되며 항상 바이트 문자열을 리턴해야합니다. 자식 프로세스가 종료되기 전에 스폰을 강제로 반환하려면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e6f1e343fecd40713794869ed00c9336cd2edc2" translate="yes" xml:space="preserve">
          <source>The functions and classes defined in this module use an idealized calendar, the current Gregorian calendar extended indefinitely in both directions. This matches the definition of the &amp;ldquo;proleptic Gregorian&amp;rdquo; calendar in Dershowitz and Reingold&amp;rsquo;s book &amp;ldquo;Calendrical Calculations&amp;rdquo;, where it&amp;rsquo;s the base calendar for all computations. Zero and negative years are interpreted as prescribed by the ISO 8601 standard. Year 0 is 1 BC, year -1 is 2 BC, and so on.</source>
          <target state="translated">이 모듈에 정의 된 함수와 클래스는 이상적인 달력을 사용합니다. 현재 Gregorian 달력은 양방향으로 무한정 확장됩니다. 이것은 Dershowitz와 Reingold의 저서 &quot;Calendrical Calculations&quot;에있는 &quot;Proleptic Gregorian&quot;캘린더의 정의와 일치하며, 모든 계산의 기본 캘린더입니다. 0과 음의 연도는 ISO 8601 표준에 규정 된대로 해석됩니다. 0 년은 BC 1 년, -1 년은 2 BC 등입니다.</target>
        </trans-unit>
        <trans-unit id="ac84bd02776cfbc9e0070dddb62c6f3c30cb39ca" translate="yes" xml:space="preserve">
          <source>The functions and classes in this module make it straightforward to handle various tasks related to IP addresses, including checking whether or not two hosts are on the same subnet, iterating over all hosts in a particular subnet, checking whether or not a string represents a valid IP address or network definition, and so on.</source>
          <target state="translated">이 모듈의 기능과 클래스를 사용하면 두 호스트가 같은 서브넷에 있는지 여부 확인, 특정 서브넷의 모든 호스트를 반복, 문자열이 유효한지 여부 등 IP 주소와 관련된 다양한 작업을 간단하게 처리 할 수 ​​있습니다. IP 주소 또는 네트워크 정의 등</target>
        </trans-unit>
        <trans-unit id="86db04374f3973882749df92eb0988ac8c430f49" translate="yes" xml:space="preserve">
          <source>The functions described below provide the primary interface for this module. If the module has not been initialized, they will call &lt;a href=&quot;#mimetypes.init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/a&gt; if they rely on the information &lt;a href=&quot;#mimetypes.init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/a&gt; sets up.</source>
          <target state="translated">아래 설명 된 기능은이 모듈의 기본 인터페이스를 제공합니다. 모듈이 초기화되지 않은 경우, &lt;a href=&quot;#mimetypes.init&quot;&gt; &lt;code&gt;init()&lt;/code&gt; &lt;/a&gt; 설정 정보에 의존하면 &lt;a href=&quot;#mimetypes.init&quot;&gt; &lt;code&gt;init()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="eb446b8721e0dd6720d36791e2154a88fe9df31d" translate="yes" xml:space="preserve">
          <source>The functions fall into categories that perform object comparisons, logical operations, mathematical operations and sequence operations.</source>
          <target state="translated">함수는 객체 비교, 논리 연산, 수학 연산 및 시퀀스 연산을 수행하는 범주로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="4b4e7bb85a308a49aca1cd55c1346182c6dbd5d8" translate="yes" xml:space="preserve">
          <source>The functions in this module may not handle dates and times before the epoch or far in the future. The cut-off point in the future is determined by the C library; for 32-bit systems, it is typically in 2038.</source>
          <target state="translated">이 모듈의 기능은 신기원 전이나 미래의 날짜와 시간을 처리하지 못할 수 있습니다. 향후 컷오프 지점은 C 라이브러리에 의해 결정됩니다. 32 비트 시스템의 경우 일반적으로 2038입니다.</target>
        </trans-unit>
        <trans-unit id="4658882c980af257f5a9284feda6fc9a8f1cdc2f" translate="yes" xml:space="preserve">
          <source>The functions supplied by this module are actually bound methods of a hidden instance of the &lt;a href=&quot;#random.Random&quot;&gt;&lt;code&gt;random.Random&lt;/code&gt;&lt;/a&gt; class. You can instantiate your own instances of &lt;a href=&quot;#random.Random&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; to get generators that don&amp;rsquo;t share state.</source>
          <target state="translated">이 모듈에서 제공하는 함수는 실제로 &lt;a href=&quot;#random.Random&quot;&gt; &lt;code&gt;random.Random&lt;/code&gt; &lt;/a&gt; 클래스 의 숨겨진 인스턴스에 대한 바인딩 된 메서드입니다 . 상태를 공유하지 않는 생성기를 얻기 위해 자신 만의 &lt;a href=&quot;#random.Random&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt; 인스턴스를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="160f635b54972ccf727a63ffe8a0c78ed1d914ea" translate="yes" xml:space="preserve">
          <source>The general form of a &lt;em&gt;standard format specifier&lt;/em&gt; is:</source>
          <target state="translated">&lt;em&gt;표준 형식 지정자&lt;/em&gt; 의 &lt;em&gt;일반적인 형식&lt;/em&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23eb078e289739ea1e13e4b7a5cf28e0a6e9477b" translate="yes" xml:space="preserve">
          <source>The generated &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; code will call a method named &lt;code&gt;__post_init__()&lt;/code&gt;, if &lt;code&gt;__post_init__()&lt;/code&gt; is defined on the class. It will normally be called as &lt;code&gt;self.__post_init__()&lt;/code&gt;. However, if any &lt;code&gt;InitVar&lt;/code&gt; fields are defined, they will also be passed to &lt;code&gt;__post_init__()&lt;/code&gt; in the order they were defined in the class. If no &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method is generated, then &lt;code&gt;__post_init__()&lt;/code&gt; will not automatically be called.</source>
          <target state="translated">&lt;code&gt;__post_init__()&lt;/code&gt; 이 클래스에 정의되어 있으면 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 코드는 &lt;code&gt;__post_init__()&lt;/code&gt; 이라는 메서드를 호출합니다 . 일반적으로 &lt;code&gt;self.__post_init__()&lt;/code&gt; 로 호출됩니다 . 그러나 &lt;code&gt;InitVar&lt;/code&gt; 필드가 정의되어 &lt;code&gt;__post_init__()&lt;/code&gt; 클래스에 정의 된 순서대로 __post_init __ () 로 전달됩니다 . 경우에는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; , 다음 방법이 생성된다 &lt;code&gt;__post_init__()&lt;/code&gt; 자동으로 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="466f2bf42108a7e87fa06f20f425efecc77f7482" translate="yes" xml:space="preserve">
          <source>The generated &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method for &lt;code&gt;C&lt;/code&gt; will look like:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 에 대해 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71f0c8c526d13f71e83d25d1be9210a33a5a7ad3" translate="yes" xml:space="preserve">
          <source>The generator produces 5-tuples with these members: the token type; the token string; a 2-tuple &lt;code&gt;(srow, scol)&lt;/code&gt; of ints specifying the row and column where the token begins in the source; a 2-tuple &lt;code&gt;(erow, ecol)&lt;/code&gt; of ints specifying the row and column where the token ends in the source; and the line on which the token was found. The line passed (the last tuple item) is the &lt;em&gt;physical&lt;/em&gt; line. The 5 tuple is returned as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; with the field names: &lt;code&gt;type string start end line&lt;/code&gt;.</source>
          <target state="translated">생성기는 다음 멤버를 사용하여 5 개의 튜플을 생성합니다. 토큰 유형; 토큰 문자열; 소스에서 토큰이 시작되는 행과 열을 지정 하는 2 개의 튜플 &lt;code&gt;(srow, scol)&lt;/code&gt; int; 토큰이 소스에서 끝나는 행과 열을 지정 하는 2 튜플 &lt;code&gt;(erow, ecol)&lt;/code&gt; 의 정수; 그리고 토큰이 발견 된 라인. 전달 된 줄 (마지막 튜플 항목)은 &lt;em&gt;실제&lt;/em&gt; 줄입니다. 5 개의 튜플은 필드 이름을 가진 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플&lt;/a&gt; 로 반환됩니다 . &lt;code&gt;type string start end line&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17ee43c509fa42a8f8d550a159deebb456842df1" translate="yes" xml:space="preserve">
          <source>The generator&amp;rsquo;s &lt;code&gt;random()&lt;/code&gt; method will continue to produce the same sequence when the compatible seeder is given the same seed.</source>
          <target state="translated">호환되는 시더에 동일한 시드가 주어지면 생성기의 &lt;code&gt;random()&lt;/code&gt; 메소드는 계속 동일한 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bbaa2259ab2d6ff4f3480ab940fa5e213e0d3c32" translate="yes" xml:space="preserve">
          <source>The geometric mean indicates the central tendency or typical value of the &lt;em&gt;data&lt;/em&gt; using the product of the values (as opposed to the arithmetic mean which uses their sum).</source>
          <target state="translated">기하 평균은 값의 곱을 사용하여 &lt;em&gt;데이터&lt;/em&gt; 의 중심 경향 또는 전형적인 값을 나타냅니다 (합을 사용하는 산술 평균과 반대).</target>
        </trans-unit>
        <trans-unit id="080762b361b4c8a6b2e066a52bd4410b164cfe6c" translate="yes" xml:space="preserve">
          <source>The getEncoding method will return the character encoding for this byte stream, or &lt;code&gt;None&lt;/code&gt; if unknown.</source>
          <target state="translated">getEncoding 메소드는이 바이트 스트림의 문자 인코딩을 리턴하거나 알 수없는 경우 &lt;code&gt;None&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a540a20b25f9284087c487141abf125cae2bb7f1" translate="yes" xml:space="preserve">
          <source>The gid is an integer, name and password are strings, and the member list is a list of strings. (Note that most users are not explicitly listed as members of the group they are in according to the password database. Check both databases to get complete membership information. Also note that a &lt;code&gt;gr_name&lt;/code&gt; that starts with a &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; is likely to be a YP/NIS reference and may not be accessible via &lt;a href=&quot;#grp.getgrnam&quot;&gt;&lt;code&gt;getgrnam()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#grp.getgrgid&quot;&gt;&lt;code&gt;getgrgid()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">gid는 정수이고 이름과 비밀번호는 문자열이며 멤버 목록은 문자열 목록입니다. (대부분의 사용자는 비밀번호 데이터베이스에 따라 자신이 속한 그룹의 구성원으로 명시 적으로 표시되지 않습니다. 두 멤버십을 모두 확인하여 완전한 회원 정보를 얻으십시오. 또한 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 로 시작 하는 &lt;code&gt;gr_name&lt;/code&gt; 은 YP 일 가능성이 있습니다. / NIS 참조이며 &lt;a href=&quot;#grp.getgrnam&quot;&gt; &lt;code&gt;getgrnam()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#grp.getgrgid&quot;&gt; &lt;code&gt;getgrgid()&lt;/code&gt; &lt;/a&gt; 를 통해 액세스 할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="be7824c416843b2ebf60509de5500876287a946e" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;__file__&lt;/code&gt; is added to the globals provided to doctests loaded from a text file using &lt;a href=&quot;#doctest.DocFileSuite&quot;&gt;&lt;code&gt;DocFileSuite()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전역 &lt;code&gt;__file__&lt;/code&gt; 은 &lt;a href=&quot;#doctest.DocFileSuite&quot;&gt; &lt;code&gt;DocFileSuite()&lt;/code&gt; &lt;/a&gt; 사용하여 텍스트 파일에서로드 된 doctest에 제공된 전역에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="011179b225dddb6c141f5d3d52be7a1af2795db2" translate="yes" xml:space="preserve">
          <source>The global character set registry is kept in the module global dictionary &lt;code&gt;CHARSETS&lt;/code&gt;.</source>
          <target state="translated">글로벌 문자 세트 레지스트리는 모듈 글로벌 사전 &lt;code&gt;CHARSETS&lt;/code&gt; 에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="d915b44137f7d4c272246eb284ccef71aecb6923" translate="yes" xml:space="preserve">
          <source>The global charset alias registry is kept in the module global dictionary &lt;code&gt;ALIASES&lt;/code&gt;.</source>
          <target state="translated">글로벌 문자 세트 별명 레지스트리는 모듈 글로벌 사전 &lt;code&gt;ALIASES&lt;/code&gt; 에 보관됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3dbce170a266cfc1ec23c9ce296c1a408d30db8" translate="yes" xml:space="preserve">
          <source>The global dispatch table managed by the &lt;a href=&quot;copyreg#module-copyreg&quot;&gt;&lt;code&gt;copyreg&lt;/code&gt;&lt;/a&gt; module is available as &lt;code&gt;copyreg.dispatch_table&lt;/code&gt;. Therefore, one may choose to use a modified copy of &lt;code&gt;copyreg.dispatch_table&lt;/code&gt; as a private dispatch table.</source>
          <target state="translated">에 의해 관리되는 글로벌 파견 테이블 &lt;a href=&quot;copyreg#module-copyreg&quot;&gt; &lt;code&gt;copyreg&lt;/code&gt; 의&lt;/a&gt; 모듈로 사용할 수 있습니다 &lt;code&gt;copyreg.dispatch_table&lt;/code&gt; . 따라서 수정 된 &lt;code&gt;copyreg.dispatch_table&lt;/code&gt; 사본을 개인 디스패치 테이블로 사용하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f434fd177166e63293f974b10e23bde323f0edad" translate="yes" xml:space="preserve">
          <source>The globals for each &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; is formed by combining &lt;em&gt;globs&lt;/em&gt; and &lt;em&gt;extraglobs&lt;/em&gt; (bindings in &lt;em&gt;extraglobs&lt;/em&gt; override bindings in &lt;em&gt;globs&lt;/em&gt;). A new shallow copy of the globals dictionary is created for each &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;globs&lt;/em&gt; is not specified, then it defaults to the module&amp;rsquo;s &lt;em&gt;__dict__&lt;/em&gt;, if specified, or &lt;code&gt;{}&lt;/code&gt; otherwise. If &lt;em&gt;extraglobs&lt;/em&gt; is not specified, then it defaults to &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">각 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 의 전역 은 &lt;em&gt;glob&lt;/em&gt; 와 &lt;em&gt;extraglob&lt;/em&gt; 를 결합하여 형성됩니다 ( &lt;em&gt;extraglob의&lt;/em&gt; 바인딩은 &lt;em&gt;globs의&lt;/em&gt; 바인딩보다 우선 함 ). 각 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 에 대해 전역 사전의 새 얕은 사본이 작성됩니다 . 경우 &lt;em&gt;globs와는&lt;/em&gt; 다음 모듈의에 기본값을 지정하지 &lt;em&gt;__dict__&lt;/em&gt; 지정된 경우, 또는 &lt;code&gt;{}&lt;/code&gt; 이 없습니다. 경우 &lt;em&gt;extraglobs가&lt;/em&gt; 에, 다음 기본값을 지정하지 않은 &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ed999a4611487b61157dae0201cc7a90208cb62" translate="yes" xml:space="preserve">
          <source>The goal for regression testing is to try to break code. This leads to a few guidelines to be followed:</source>
          <target state="translated">회귀 테스트의 목표는 코드를 위반하는 것입니다. 몇 가지 지침을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="56397f25b8e980842fd42c661829753f61feda6e" translate="yes" xml:space="preserve">
          <source>The goal of the default &lt;code&gt;_generate_next_value_()&lt;/code&gt; methods is to provide the next &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; in sequence with the last &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; provided, but the way it does this is an implementation detail and may change.</source>
          <target state="translated">기본 &lt;code&gt;_generate_next_value_()&lt;/code&gt; 메소드 의 목표는 제공된 마지막 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 함께 다음 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 를 순서대로 제공하는 것이지만이를 수행하는 방법은 구현 세부 사항이며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="621411565dd6b00b4807e619d6b6b63e50f07513" translate="yes" xml:space="preserve">
          <source>The grammar for a replacement field is as follows:</source>
          <target state="translated">대체 필드의 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="116c779d9a5b118ddc605fb4a6c7899ef6092561" translate="yes" xml:space="preserve">
          <source>The groups are returned in the same format as &lt;a href=&quot;#difflib.SequenceMatcher.get_opcodes&quot;&gt;&lt;code&gt;get_opcodes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그룹은 &lt;a href=&quot;#difflib.SequenceMatcher.get_opcodes&quot;&gt; &lt;code&gt;get_opcodes()&lt;/code&gt; &lt;/a&gt; 와 같은 형식으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c80bee2646768da29f2362734e23a94eabb1e7f7" translate="yes" xml:space="preserve">
          <source>The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method &lt;code&gt;SPAM&lt;/code&gt;, the &lt;code&gt;do_SPAM()&lt;/code&gt; method will be called with no arguments. All of the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">핸들러는 요청과 헤더를 구문 분석 한 다음 요청 유형에 특정한 메소드를 호출합니다. 메소드 이름은 요청에서 구성됩니다. 예를 들어, &lt;code&gt;SPAM&lt;/code&gt; 요청 메소드의 경우 &lt;code&gt;do_SPAM()&lt;/code&gt; 메소드가 인수없이 호출됩니다. 모든 관련 정보는 핸들러의 인스턴스 변수에 저장됩니다. 서브 클래스는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드 를 대체하거나 확장 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eb88ec007c1bdda63b6ead05fa379b918cafb33e" translate="yes" xml:space="preserve">
          <source>The handlers raise this exception (or derived exceptions) when they run into a problem. It is a subclass of &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">핸들러는 문제점이 발생하면이 예외 (또는 파생 예외)를 발생시킵니다. &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="bef8e02ff27c1330838ab97c460ba42f4affdf35" translate="yes" xml:space="preserve">
          <source>The handles must be temporarily made inheritable by &lt;a href=&quot;os#os.set_handle_inheritable&quot;&gt;&lt;code&gt;os.set_handle_inheritable()&lt;/code&gt;&lt;/a&gt; when passed to the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor, else &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised with Windows error &lt;code&gt;ERROR_INVALID_PARAMETER&lt;/code&gt; (87).</source>
          <target state="translated">핸들이 일시적으로 상속하셔야합니다 &lt;a href=&quot;os#os.set_handle_inheritable&quot;&gt; &lt;code&gt;os.set_handle_inheritable()&lt;/code&gt; &lt;/a&gt; 에 전달하는 경우 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 생성자, 다른 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 는&lt;/a&gt; Windows 오류로 발생합니다 &lt;code&gt;ERROR_INVALID_PARAMETER&lt;/code&gt; (87).</target>
        </trans-unit>
        <trans-unit id="f0a59447999110092856d412a0fa668c41356124" translate="yes" xml:space="preserve">
          <source>The handling of such prefixes is done in a way analogous to protocol handling: there is a generic mechanism to look for prefixes which match the regular expression &lt;code&gt;^(?P&amp;lt;prefix&amp;gt;[a-z]+)://(?P&amp;lt;suffix&amp;gt;.*)$&lt;/code&gt; whereby, if the &lt;code&gt;prefix&lt;/code&gt; is recognised, the &lt;code&gt;suffix&lt;/code&gt; is processed in a prefix-dependent manner and the result of the processing replaces the string value. If the prefix is not recognised, then the string value will be left as-is.</source>
          <target state="translated">이러한 접두사의 처리는 프로토콜 처리와 유사한 방식으로 수행됩니다. 정규식과 일치하는 접두사를 찾는 일반적인 메커니즘이 있습니다 &lt;code&gt;^(?P&amp;lt;prefix&amp;gt;[a-z]+)://(?P&amp;lt;suffix&amp;gt;.*)$&lt;/code&gt; 경우 생성함으로써, &lt;code&gt;prefix&lt;/code&gt; 인식되면, &lt;code&gt;suffix&lt;/code&gt; 접두사 의존적 방식으로 처리되고, 처리 결과는 문자열 값을 대체한다. 접두사가 인식되지 않으면 문자열 값은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="53fd551aa742c5930436d3dcbf656dd0730743da" translate="yes" xml:space="preserve">
          <source>The harmonic mean is a type of average, a measure of the central location of the data. It is often appropriate when averaging rates or ratios, for example speeds.</source>
          <target state="translated">고조파 평균은 데이터의 중앙 위치를 측정하는 평균 유형입니다. 속도와 같은 비율 또는 비율을 평균 할 때 종종 적합합니다.</target>
        </trans-unit>
        <trans-unit id="ce905947fa6c6d4744637e75f2a2a105b7eefee4" translate="yes" xml:space="preserve">
          <source>The harmonic mean, sometimes called the subcontrary mean, is the reciprocal of the arithmetic &lt;a href=&quot;#statistics.mean&quot;&gt;&lt;code&gt;mean()&lt;/code&gt;&lt;/a&gt; of the reciprocals of the data. For example, the harmonic mean of three values &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt; and &lt;em&gt;c&lt;/em&gt; will be equivalent to &lt;code&gt;3/(1/a + 1/b + 1/c)&lt;/code&gt;. If one of the values is zero, the result will be zero.</source>
          <target state="translated">하도 평균이라고도하는 고조파 평균은 데이터의 역수의 산술 &lt;a href=&quot;#statistics.mean&quot;&gt; &lt;code&gt;mean()&lt;/code&gt; &lt;/a&gt; 의 역수입니다. 예를 들어, 세 값의 조화 평균이 , &lt;em&gt;B&lt;/em&gt; 및 &lt;em&gt;C는&lt;/em&gt; 와 동등 할 것 &lt;code&gt;3/(1/a + 1/b + 1/c)&lt;/code&gt; . 값 중 하나가 0이면 결과는 0입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5a055f529312abd9d8172f8d8529c67933a5509b" translate="yes" xml:space="preserve">
          <source>The header objects and their attributes are described in &lt;a href=&quot;email.headerregistry#module-email.headerregistry&quot;&gt;&lt;code&gt;headerregistry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">헤더 객체 및 해당 속성은 &lt;a href=&quot;email.headerregistry#module-email.headerregistry&quot;&gt; &lt;code&gt;headerregistry&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="674016e76c3cb66c514d5bce46957cc587411fac" translate="yes" xml:space="preserve">
          <source>The header to issue if the help output has a section for documented commands.</source>
          <target state="translated">도움말 출력에 문서화 된 명령 섹션이있는 경우 발행 할 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="db36651f3f7813552c1c4041071864f70dd71672" translate="yes" xml:space="preserve">
          <source>The header to issue if the help output has a section for miscellaneous help topics (that is, there are &lt;code&gt;help_*()&lt;/code&gt; methods without corresponding &lt;code&gt;do_*()&lt;/code&gt; methods).</source>
          <target state="translated">도움말 출력에 기타 도움말 주제에 대한 섹션이있는 경우 발행 할 헤더 (즉, 해당 &lt;code&gt;do_*()&lt;/code&gt; 메소드 가 없는 &lt;code&gt;help_*()&lt;/code&gt; _ * () 메소드가 있음).</target>
        </trans-unit>
        <trans-unit id="b704f03a5a952cd7ddcf867a76abc5bc03137b8d" translate="yes" xml:space="preserve">
          <source>The header to issue if the help output has a section for undocumented commands (that is, there are &lt;code&gt;do_*()&lt;/code&gt; methods without corresponding &lt;code&gt;help_*()&lt;/code&gt; methods).</source>
          <target state="translated">도움말 출력에 문서화되지 않은 명령에 대한 섹션이있는 경우 (즉, 해당 &lt;code&gt;help_*()&lt;/code&gt; 메소드가 없는 &lt;code&gt;do_*()&lt;/code&gt; 메소드 가있는 경우) 발행 할 헤더 입니다.</target>
        </trans-unit>
        <trans-unit id="157613515df46f9ddde850f2b53594e4dd5dc192" translate="yes" xml:space="preserve">
          <source>The headers argument should be a mapping of extra HTTP headers to send with the CONNECT request.</source>
          <target state="translated">headers 인수는 CONNECT 요청과 함께 보낼 추가 HTTP 헤더의 맵핑이어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb47deb0d60cbf8812da4a29bd84682ac99dd542" translate="yes" xml:space="preserve">
          <source>The help for this program will display &lt;code&gt;myprogram.py&lt;/code&gt; as the program name (regardless of where the program was invoked from):</source>
          <target state="translated">이 프로그램의 도움말 은 프로그램 이름으로 &lt;code&gt;myprogram.py&lt;/code&gt; 를 표시 합니다 (프로그램이 호출 된 위치에 관계없이).</target>
        </trans-unit>
        <trans-unit id="4579ce53124671d5adb9cd84001415e65dc5eaac" translate="yes" xml:space="preserve">
          <source>The help option is typically &lt;code&gt;-h/--help&lt;/code&gt;. The exception to this is if the &lt;code&gt;prefix_chars=&lt;/code&gt; is specified and does not include &lt;code&gt;-&lt;/code&gt;, in which case &lt;code&gt;-h&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt; are not valid options. In this case, the first character in &lt;code&gt;prefix_chars&lt;/code&gt; is used to prefix the help options:</source>
          <target state="translated">도움말 옵션은 일반적으로 &lt;code&gt;-h/--help&lt;/code&gt; 입니다. &lt;code&gt;prefix_chars=&lt;/code&gt; 가 지정되고 &lt;code&gt;-&lt;/code&gt; 를 포함하지 않는 경우는 예외입니다.이 경우 &lt;code&gt;-h&lt;/code&gt; 및 &lt;code&gt;--help&lt;/code&gt; 는 유효한 옵션이 아닙니다. 이 경우 &lt;code&gt;prefix_chars&lt;/code&gt; 의 첫 번째 문자 는 도움말 옵션 접 두부에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bbfdf31b6293417c5ce4f7179125682bf1f8ac5f" translate="yes" xml:space="preserve">
          <source>The high median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the larger of the two middle values is returned.</source>
          <target state="translated">높은 중앙값은 항상 데이터 세트의 멤버입니다. 데이터 포인트 수가 홀수이면 중간 값이 반환됩니다. 짝수이면 두 중간 값 중 더 큰 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8a14b75bcba608d6362a105a10d4d34dcdb7ef64" translate="yes" xml:space="preserve">
          <source>The high-level method described above makes use of a simple API which provides mechanisms for third-party virtual environment creators to customize environment creation according to their needs, the &lt;a href=&quot;#venv.EnvBuilder&quot;&gt;&lt;code&gt;EnvBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">위에서 설명한 고급 방법은 타사 가상 환경 제작자가 &lt;a href=&quot;#venv.EnvBuilder&quot;&gt; &lt;code&gt;EnvBuilder&lt;/code&gt; &lt;/a&gt; 클래스 의 필요에 따라 환경 생성을 사용자 지정하는 메커니즘을 제공하는 간단한 API를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="280647272c3bfd8a3b605c491878ebc6dae8a17b" translate="yes" xml:space="preserve">
          <source>The highest possible limit is platform-dependent. A user may need to set the limit higher when they have a program that requires deep recursion and a platform that supports a higher limit. This should be done with care, because a too-high limit can lead to a crash.</source>
          <target state="translated">가능한 최대 한계는 플랫폼에 따라 다릅니다. 사용자는 깊은 재귀가 필요한 프로그램과 더 높은 제한을 지원하는 플랫폼이있는 경우 제한을 더 높게 설정해야 할 수 있습니다. 한계가 너무 높으면 충돌이 발생할 수 있으므로주의해서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="342f901d9152ca3faaae558243c0cdbad893c9cd" translate="yes" xml:space="preserve">
          <source>The home page for &lt;code&gt;Tix&lt;/code&gt;. This includes links to additional documentation and downloads.</source>
          <target state="translated">&lt;code&gt;Tix&lt;/code&gt; 홈페이지 . 여기에는 추가 설명서 및 다운로드 링크가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="050fa76c810338418999cdc63aae7dd43c37dfb8" translate="yes" xml:space="preserve">
          <source>The host and port arguments specify the endpoint of the tunneled connection (i.e. the address included in the CONNECT request, &lt;em&gt;not&lt;/em&gt; the address of the proxy server).</source>
          <target state="translated">호스트 및 포트 인수는 터널링 된 연결의 엔드 포인트 (예 : 프록시 서버의 주소가 &lt;em&gt;아닌&lt;/em&gt; CONNECT 요청에 포함 된 주소)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d97d9e1de4c71a1f7df00793e47f4ea8c76105bc" translate="yes" xml:space="preserve">
          <source>The host mask, as an &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt;&lt;code&gt;IPv4Address&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt; &lt;code&gt;IPv4Address&lt;/code&gt; &lt;/a&gt; 객체 로서의 호스트 마스크 .</target>
        </trans-unit>
        <trans-unit id="2068a7247616e20c79de41643857f4b18b1aec85" translate="yes" xml:space="preserve">
          <source>The hours, minutes and seconds are 0, and the DST flag is -1.</source>
          <target state="translated">시, 분 및 초는 0이고 DST 플래그는 -1입니다.</target>
        </trans-unit>
        <trans-unit id="31f0fc945f713a05340d842d5c51be7d86d5e4f1" translate="yes" xml:space="preserve">
          <source>The ids for loggers are the logger names which would be used programmatically to obtain a reference to those loggers, e.g. &lt;code&gt;foo.bar.baz&lt;/code&gt;. The ids for Formatters and Filters can be any string value (such as &lt;code&gt;brief&lt;/code&gt;, &lt;code&gt;precise&lt;/code&gt; above) and they are transient, in that they are only meaningful for processing the configuration dictionary and used to determine connections between objects, and are not persisted anywhere when the configuration call is complete.</source>
          <target state="translated">로거의 id는 로거에 대한 참조를 얻기 위해 프로그래밍 방식으로 사용되는 로거 이름입니다 (예 : &lt;code&gt;foo.bar.baz&lt;/code&gt; ) . 포매터와 필터 ID는 임의의 문자열 값이 될 수있다 (예 : &lt;code&gt;brief&lt;/code&gt; , &lt;code&gt;precise&lt;/code&gt; 이상) 및 그들이 구성 사전 처리 만 의미있는 물체 간의 연결을 확인하는 데 사용하고, 어디서나 때 유지되지에서 해당 과도하다 구성 호출이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8e1d71f7d4a70791960b261ec245075f8d8fa76" translate="yes" xml:space="preserve">
          <source>The image object can then be used wherever an &lt;code&gt;image&lt;/code&gt; option is supported by some widget (e.g. labels, buttons, menus). In these cases, Tk will not keep a reference to the image. When the last Python reference to the image object is deleted, the image data is deleted as well, and Tk will display an empty box wherever the image was used.</source>
          <target state="translated">그런 다음 일부 위젯 (예 : 레이블, 단추, 메뉴) 에서 &lt;code&gt;image&lt;/code&gt; 옵션을 지원 하는 경우 이미지 객체를 사용할 수 있습니다 . 이 경우 Tk는 이미지에 대한 참조를 유지하지 않습니다. 이미지 객체에 대한 마지막 파이썬 참조가 삭제되면 이미지 데이터도 삭제되며 Tk는 이미지가 사용 된 곳마다 빈 상자를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="337b113c1c85f5e25b9b4e4dffd41726abff3154" translate="yes" xml:space="preserve">
          <source>The implementation adds a few special read-only attributes to several object types, where they are relevant. Some of these are not reported by the &lt;a href=&quot;functions#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; built-in function.</source>
          <target state="translated">구현시 몇 가지 특수한 읽기 전용 특성이 여러 개체 유형에 추가되어 관련이 있습니다. 이들 중 일부는 &lt;a href=&quot;functions#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 내장 함수에 의해보고되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a4d6ea654398459c8d685facdbb983c586debb4e" translate="yes" xml:space="preserve">
          <source>The implementation of I/O streams is organized as a hierarchy of classes. First &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base classes&lt;/a&gt; (ABCs), which are used to specify the various categories of streams, then concrete classes providing the standard stream implementations.</source>
          <target state="translated">I / O 스트림의 구현은 클래스의 계층 구조로 구성됩니다. 다양한 종류의 스트림을 지정하는 데 사용되는 첫 번째 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스&lt;/a&gt; (ABC)는 표준 스트림 구현을 제공하는 구체적인 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="18b1871a9c46cbb234979e72b8ff89db3c9b3526" translate="yes" xml:space="preserve">
          <source>The implementation prompts for this information on the terminal; an application should override this method to use an appropriate interaction model in the local environment.</source>
          <target state="translated">구현은 터미널에서이 정보를 요구합니다. 로컬 환경에서 적절한 상호 작용 모델을 사용하려면 애플리케이션이이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="a958e938ed3164014686a40e65033856ed45814d" translate="yes" xml:space="preserve">
          <source>The import statement</source>
          <target state="translated">수입 명세서</target>
        </trans-unit>
        <trans-unit id="0cdacda9f9de68ead1db809131fa756e459e79e1" translate="yes" xml:space="preserve">
          <source>The index Parameter</source>
          <target state="translated">색인 매개 변수</target>
        </trans-unit>
        <trans-unit id="4f38e66994b597a2ec6b5c5f4e631b0fb7f9dd98" translate="yes" xml:space="preserve">
          <source>The index after the last invalid data in &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 의 마지막 유효하지 않은 데이터 이후의 인덱스 입니다.</target>
        </trans-unit>
        <trans-unit id="384ef63323de341899ee047e539cee7cd052dd31" translate="yes" xml:space="preserve">
          <source>The index in &lt;em&gt;pattern&lt;/em&gt; where compilation failed (may be &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">컴파일이 실패한 &lt;em&gt;패턴&lt;/em&gt; 의 인덱스입니다 ( &lt;code&gt;None&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="0402c2d187e7a9245a1a1c891279c33f38f4a3ef" translate="yes" xml:space="preserve">
          <source>The index notation for Text widgets is very rich and is best described in the Tk man pages.</source>
          <target state="translated">텍스트 위젯에 대한 인덱스 표기법은 매우 풍부하며 Tk 매뉴얼 페이지에 가장 잘 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef64ced167f3b38cf3fee549f5413fcf6cc4f886" translate="yes" xml:space="preserve">
          <source>The individual submodules are described in the following sections.</source>
          <target state="translated">개별 서브 모듈은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="168644c57e62c797ca863dfc8e9f05171d5faeeb" translate="yes" xml:space="preserve">
          <source>The infinities are signed (affine) and can be used in arithmetic operations where they get treated as very large, indeterminate numbers. For instance, adding a constant to infinity gives another infinite result.</source>
          <target state="translated">인피니티는 서명 (병렬)되며 매우 큰 불확실한 숫자로 취급되는 산술 연산에 사용될 수 있습니다. 예를 들어, 무한대에 상수를 추가하면 또 다른 무한한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fcf3d162830313939d6e41b7db91279dd49d4e18" translate="yes" xml:space="preserve">
          <source>The information from this event is not necessary for normal Namespace processing: the SAX XML reader will automatically replace prefixes for element and attribute names when the &lt;code&gt;feature_namespaces&lt;/code&gt; feature is enabled (the default).</source>
          <target state="translated">이 이벤트의 정보는 일반적인 네임 스페이스 처리에 필요하지 않습니다. &lt;code&gt;feature_namespaces&lt;/code&gt; 기능이 활성화되면 (기본값) SAX XML 판독기가 요소 및 속성 이름의 접두사를 자동으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="593947a26d0c7d5417fa282e634caf818fc32d83" translate="yes" xml:space="preserve">
          <source>The information is derived from all of the mailcap files found on the system. Settings in the user&amp;rsquo;s mailcap file &lt;code&gt;$HOME/.mailcap&lt;/code&gt; will override settings in the system mailcap files &lt;code&gt;/etc/mailcap&lt;/code&gt;, &lt;code&gt;/usr/etc/mailcap&lt;/code&gt;, and &lt;code&gt;/usr/local/etc/mailcap&lt;/code&gt;.</source>
          <target state="translated">이 정보는 시스템에있는 모든 메일 캡 파일에서 파생됩니다. 사용자의 메일 캡 파일 &lt;code&gt;$HOME/.mailcap&lt;/code&gt; 설정은 시스템 메일 캡 파일 &lt;code&gt;/etc/mailcap&lt;/code&gt; , &lt;code&gt;/usr/etc/mailcap&lt;/code&gt; 및 &lt;code&gt;/usr/local/etc/mailcap&lt;/code&gt; 의 설정을 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="be4853678dd05f1bef86ae97ab2796f1610c9db8" translate="yes" xml:space="preserve">
          <source>The initial character set specified. Common aliases are converted to their &lt;em&gt;official&lt;/em&gt; email names (e.g. &lt;code&gt;latin_1&lt;/code&gt; is converted to &lt;code&gt;iso-8859-1&lt;/code&gt;). Defaults to 7-bit &lt;code&gt;us-ascii&lt;/code&gt;.</source>
          <target state="translated">지정된 초기 문자 세트입니다. 공통 별명은 &lt;em&gt;공식&lt;/em&gt; 이메일 이름 &lt;em&gt;으로&lt;/em&gt; 변환됩니다 (예 : &lt;code&gt;latin_1&lt;/code&gt; 은 &lt;code&gt;iso-8859-1&lt;/code&gt; 로 변환 됨 ). 기본값은 7 비트 &lt;code&gt;us-ascii&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3af741acb8e70d5c38db45f90abbeef937d0fb02" translate="yes" xml:space="preserve">
          <source>The initial name is set by the constructor. If no explicit name is provided to the constructor, a name of the form &amp;lsquo;Process-N&lt;sub&gt;1&lt;/sub&gt;:N&lt;sub&gt;2&lt;/sub&gt;:&amp;hellip;:N&lt;sub&gt;k&lt;/sub&gt;&amp;rsquo; is constructed, where each N&lt;sub&gt;k&lt;/sub&gt; is the N-th child of its parent.</source>
          <target state="translated">초기 이름은 생성자가 설정합니다. 생성자에 명시적인 이름이 제공되지 않으면 'Process-N &lt;sub&gt;1&lt;/sub&gt; : N &lt;sub&gt;2&lt;/sub&gt; :&amp;hellip; : N &lt;sub&gt;k&lt;/sub&gt; ' 형식의 이름 이 구성됩니다. 여기서 각 N &lt;sub&gt;k&lt;/sub&gt; 는 부모의 N 번째 자식입니다.</target>
        </trans-unit>
        <trans-unit id="01240a600ee2dcef314bf3497a2fa5c42803f278" translate="yes" xml:space="preserve">
          <source>The initial value is inherited from the creating process.</source>
          <target state="translated">초기 값은 작성 프로세스에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="90c24a653f1ed3d0ad85257a774aec129199fba5" translate="yes" xml:space="preserve">
          <source>The initial value of the buffer can be set by providing &lt;em&gt;initial_value&lt;/em&gt;. If newline translation is enabled, newlines will be encoded as if by &lt;a href=&quot;#io.TextIOBase.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;. The stream is positioned at the start of the buffer.</source>
          <target state="translated">버퍼의 초기 값은 &lt;em&gt;initial_value&lt;/em&gt; 를 제공하여 설정할 수 있습니다 . 개행 변환이 사용 가능한 경우, 개행은 마치 &lt;a href=&quot;#io.TextIOBase.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 의해 인코딩됩니다 . 스트림은 버퍼의 시작 부분에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="911ddfa2919987daa1be8a401f583fa6db3f90c4" translate="yes" xml:space="preserve">
          <source>The input arguments.</source>
          <target state="translated">입력 인수</target>
        </trans-unit>
        <trans-unit id="50bf97706065ecec0970089c0032d4e3a715d20c" translate="yes" xml:space="preserve">
          <source>The input is complete; &lt;a href=&quot;#code.compile_command&quot;&gt;&lt;code&gt;compile_command()&lt;/code&gt;&lt;/a&gt; returned a code object. The code is executed by calling the &lt;a href=&quot;#code.InteractiveInterpreter.runcode&quot;&gt;&lt;code&gt;runcode()&lt;/code&gt;&lt;/a&gt; (which also handles run-time exceptions, except for &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt;). &lt;a href=&quot;#code.InteractiveInterpreter.runsource&quot;&gt;&lt;code&gt;runsource()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">입력이 완료되었습니다. &lt;a href=&quot;#code.compile_command&quot;&gt; &lt;code&gt;compile_command()&lt;/code&gt; &lt;/a&gt; 가 코드 객체를 반환했습니다. 코드는 &lt;a href=&quot;#code.InteractiveInterpreter.runcode&quot;&gt; &lt;code&gt;runcode()&lt;/code&gt; &lt;/a&gt; 를 호출하여 실행됩니다 ( &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 제외하고 런타임 예외도 처리 함 ). &lt;a href=&quot;#code.InteractiveInterpreter.runsource&quot;&gt; &lt;code&gt;runsource()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;False&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a1f14ff96f1edbf542cd8d172aacbd7c70213c3" translate="yes" xml:space="preserve">
          <source>The input is incomplete, and more input is required; &lt;a href=&quot;#code.compile_command&quot;&gt;&lt;code&gt;compile_command()&lt;/code&gt;&lt;/a&gt; returned &lt;code&gt;None&lt;/code&gt;. &lt;a href=&quot;#code.InteractiveInterpreter.runsource&quot;&gt;&lt;code&gt;runsource()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">입력이 불완전하고 더 많은 입력이 필요합니다. &lt;a href=&quot;#code.compile_command&quot;&gt; &lt;code&gt;compile_command()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;None&lt;/code&gt; 을 반환했습니다 . &lt;a href=&quot;#code.InteractiveInterpreter.runsource&quot;&gt; &lt;code&gt;runsource()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;True&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1d8a52ee0e926e030e7faf4e9be5c273457a4e42" translate="yes" xml:space="preserve">
          <source>The input is incorrect; &lt;a href=&quot;#code.compile_command&quot;&gt;&lt;code&gt;compile_command()&lt;/code&gt;&lt;/a&gt; raised an exception (&lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;). A syntax traceback will be printed by calling the &lt;a href=&quot;#code.InteractiveInterpreter.showsyntaxerror&quot;&gt;&lt;code&gt;showsyntaxerror()&lt;/code&gt;&lt;/a&gt; method. &lt;a href=&quot;#code.InteractiveInterpreter.runsource&quot;&gt;&lt;code&gt;runsource()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">입력이 잘못되었습니다. &lt;a href=&quot;#code.compile_command&quot;&gt; &lt;code&gt;compile_command()&lt;/code&gt; &lt;/a&gt; 에서 예외가 발생했습니다 ( &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; ). &lt;a href=&quot;#code.InteractiveInterpreter.showsyntaxerror&quot;&gt; &lt;code&gt;showsyntaxerror()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 구문 추적이 인쇄됩니다 . &lt;a href=&quot;#code.InteractiveInterpreter.runsource&quot;&gt; &lt;code&gt;runsource()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;False&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2b1dd645401e5a1f79b707db541edbde2b57ebd3" translate="yes" xml:space="preserve">
          <source>The input stream from which this &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; instance is reading characters.</source>
          <target state="translated">이 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 인스턴스가 문자를 읽는 입력 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="4bdf1c2a1e06caa4f16300713f91090fd4ec6f17" translate="yes" xml:space="preserve">
          <source>The installed completer function is invoked by the &lt;em&gt;entry_func&lt;/em&gt; callback passed to &lt;code&gt;rl_completion_matches()&lt;/code&gt; in the underlying library. The &lt;em&gt;text&lt;/em&gt; string comes from the first parameter to the &lt;code&gt;rl_attempted_completion_function&lt;/code&gt; callback of the underlying library.</source>
          <target state="translated">설치된 완료 함수는 기본 라이브러리의 &lt;code&gt;rl_completion_matches()&lt;/code&gt; 에 전달 된 &lt;em&gt;entry_func&lt;/em&gt; 콜백에 의해 호출됩니다 . &lt;em&gt;텍스트&lt;/em&gt; 문자열은 첫 번째 매개 변수에서 오는 &lt;code&gt;rl_attempted_completion_function&lt;/code&gt; 의 기본 라이브러리의 콜백.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a45c0350113f984aa330a93552ee38009ca4e2b6" translate="yes" xml:space="preserve">
          <source>The instance&amp;rsquo;s values will be different for separate threads.</source>
          <target state="translated">개별 스레드마다 인스턴스 값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7aeee48dd3b208a03dfbddf9c109b56675841d3f" translate="yes" xml:space="preserve">
          <source>The int type implements the &lt;a href=&quot;numbers#numbers.Integral&quot;&gt;&lt;code&gt;numbers.Integral&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt;. In addition, it provides a few more methods:</source>
          <target state="translated">int 타입은 &lt;a href=&quot;numbers#numbers.Integral&quot;&gt; &lt;code&gt;numbers.Integral&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt; 추상 기본 클래스를&lt;/a&gt; 구현합니다 . 또한 몇 가지 방법을 더 제공합니다.</target>
        </trans-unit>
        <trans-unit id="979b8dbfddfc8ab9cbf5ea897f421dd8bf5a702c" translate="yes" xml:space="preserve">
          <source>The integer division operator &lt;code&gt;//&lt;/code&gt; behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather than its floor, so as to preserve the usual identity &lt;code&gt;x == (x // y) * y + x % y&lt;/code&gt;:</source>
          <target state="translated">정수 나누기 연산자는 &lt;code&gt;//&lt;/code&gt; 유사하게 동작하여 일반적인 식별자 &lt;code&gt;x == (x // y) * y + x % y&lt;/code&gt; 를 유지하기 위해 바닥이 아닌 실제 몫의 정수 부분 (0쪽으로 잘림)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca9bbf40760e2c28730193d5cf1a62f8571ee2d" translate="yes" xml:space="preserve">
          <source>The integer index of the last matched capturing group, or &lt;code&gt;None&lt;/code&gt; if no group was matched at all. For example, the expressions &lt;code&gt;(a)b&lt;/code&gt;, &lt;code&gt;((a)(b))&lt;/code&gt;, and &lt;code&gt;((ab))&lt;/code&gt; will have &lt;code&gt;lastindex == 1&lt;/code&gt; if applied to the string &lt;code&gt;'ab'&lt;/code&gt;, while the expression &lt;code&gt;(a)(b)&lt;/code&gt; will have &lt;code&gt;lastindex == 2&lt;/code&gt;, if applied to the same string.</source>
          <target state="translated">마지막으로 일치하는 캡처 그룹의 정수 색인이거나, 그룹이 일치하지 않으면 &lt;code&gt;None&lt;/code&gt; 입니다. 예를 들어, 식 &lt;code&gt;(a)b&lt;/code&gt; , &lt;code&gt;((a)(b))&lt;/code&gt; 및 &lt;code&gt;((ab))&lt;/code&gt; 는 문자열 &lt;code&gt;'ab'&lt;/code&gt; 에 적용되는 경우 &lt;code&gt;lastindex == 1&lt;/code&gt; 이며 식 &lt;code&gt;(a)(b)&lt;/code&gt; 는 유무 &lt;code&gt;lastindex == 2&lt;/code&gt; 같은 스트링에 적용하는 경우.</target>
        </trans-unit>
        <trans-unit id="75451b0732e8ead28c286c690593bd66708fe14e" translate="yes" xml:space="preserve">
          <source>The integer is represented using &lt;em&gt;length&lt;/em&gt; bytes. An &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; is raised if the integer is not representable with the given number of bytes.</source>
          <target state="translated">정수는 &lt;em&gt;길이&lt;/em&gt; 바이트를 사용하여 표현 됩니다. &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 는&lt;/a&gt; 정수가 지정된 바이트 수에 표현할 수없는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fe6db748a1c03f0058af1e2fac43ded456cb44f" translate="yes" xml:space="preserve">
          <source>The integer type is described in &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;Numeric Types &amp;mdash; int, float, complex&lt;/a&gt;.</source>
          <target state="translated">정수 유형은 &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;숫자 유형 (int, float, complex&lt;/a&gt; )에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="163c5d035b77569be69dfb2f1d78884819913773" translate="yes" xml:space="preserve">
          <source>The interactive shell omits the traceback header line for some &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;s. But doctest uses the traceback header line to distinguish exceptions from non-exceptions. So in the rare case where you need to test a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; that omits the traceback header, you will need to manually add the traceback header line to your test example.</source>
          <target state="translated">대화식 쉘은 일부 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 의 역 추적 헤더 행을 생략합니다 . 그러나 doctest는 예외를 제외하고 예외를 구별하기 위해 역 추적 헤더 행을 사용합니다. 따라서 드문 경우이지만 역 추적 헤더가 없는 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 를 테스트해야하는 경우 테스트 예제에 역 추적 헤더 행을 수동으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="a962b729b1c8fdb63836b438e55afdc22f8824ff" translate="yes" xml:space="preserve">
          <source>The interface consists of two simple methods. Using the methods you can process form data in a generic way, without the need to worry whether only one or more values were posted under one name.</source>
          <target state="translated">인터페이스는 두 가지 간단한 방법으로 구성됩니다. 이 방법을 사용하면 하나 이상의 이름 만 하나의 이름으로 게시되었는지 걱정할 필요없이 일반적인 방식으로 양식 데이터를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="51f3e9f1c9a1c82d20480b7eeaf1d9d974cc5b1e" translate="yes" xml:space="preserve">
          <source>The interface is currently defined as follows. The &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt; method takes no argument and shall return either a string or preferably a tuple (the returned object is often referred to as the &amp;ldquo;reduce value&amp;rdquo;).</source>
          <target state="translated">인터페이스는 현재 다음과 같이 정의되어 있습니다. &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 메소드는 어떤 인수를 사용하지 않고 자열 바람직 튜플 하나를 반환한다 (리턴 된 객체는 종종 &quot;값을 감소&quot;으로 칭함).</target>
        </trans-unit>
        <trans-unit id="dc72a584349e9214e08df92c45aef5b1dbf7ab27" translate="yes" xml:space="preserve">
          <source>The interface provided by this module is very similar to that of the &lt;a href=&quot;bz2#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt; module. However, note that &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; thread-safe, unlike &lt;a href=&quot;bz2#bz2.BZ2File&quot;&gt;&lt;code&gt;bz2.BZ2File&lt;/code&gt;&lt;/a&gt;, so if you need to use a single &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; instance from multiple threads, it is necessary to protect it with a lock.</source>
          <target state="translated">이 모듈에서 제공하는 인터페이스는 &lt;a href=&quot;bz2#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 모듈 의 인터페이스와 매우 유사 합니다. 그러나주의 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; 가&lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 스레드 안전 달리 &lt;a href=&quot;bz2#bz2.BZ2File&quot;&gt; &lt;code&gt;bz2.BZ2File&lt;/code&gt; &lt;/a&gt; , 단일 사용할 필요가 그렇다면 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; 의&lt;/a&gt; 여러 스레드에서 예, 잠금을 보호하는 것이 필요하다.</target>
        </trans-unit>
        <trans-unit id="2c7a7160e2db8bd2dd860dc18f56ade5ea2177e1" translate="yes" xml:space="preserve">
          <source>The internal block size of the hash algorithm in bytes.</source>
          <target state="translated">해시 알고리즘의 내부 블록 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="03abd148a400405ca42f9b10fcc4c70063e3a3d5" translate="yes" xml:space="preserve">
          <source>The interpretation of &amp;ldquo;file size&amp;rdquo; changes according to the file type. For plain files this is the size of the file in bytes. For FIFOs and sockets under most flavors of Unix (including Linux in particular), the &amp;ldquo;size&amp;rdquo; is the number of bytes waiting to be read at the time of the call to &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os#os.fstat&quot;&gt;&lt;code&gt;os.fstat()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;os#os.lstat&quot;&gt;&lt;code&gt;os.lstat()&lt;/code&gt;&lt;/a&gt;; this can sometimes be useful, especially for polling one of these special files after a non-blocking open. The meaning of the size field for other character and block devices varies more, depending on the implementation of the underlying system call.</source>
          <target state="translated">&quot;파일 크기&quot;의 해석은 파일 유형에 따라 달라집니다. 일반 파일의 경우 파일 크기 (바이트)입니다. 대부분의 유닉스 계열 (특히 Linux 포함)의 FIFO 및 소켓의 경우,&amp;ldquo;size&amp;rdquo;는 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os#os.fstat&quot;&gt; &lt;code&gt;os.fstat()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.lstat&quot;&gt; &lt;code&gt;os.lstat()&lt;/code&gt; &lt;/a&gt; 호출시 읽히기를 기다리는 바이트 수입니다. .lstat () ; 비 차단 열기 후에 이러한 특수 파일 중 하나를 폴링 할 때 유용 할 수 있습니다. 다른 문자 및 블록 장치에 대한 크기 필드의 의미는 기본 시스템 호출의 구현에 따라 더 다양합니다.</target>
        </trans-unit>
        <trans-unit id="438ad5eaadf08fa55fa89520ff2509c442e60ebb" translate="yes" xml:space="preserve">
          <source>The interpreter is about to execute a new line of code or re-execute the condition of a loop. The local trace function is called; &lt;em&gt;arg&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;; the return value specifies the new local trace function. See &lt;code&gt;Objects/lnotab_notes.txt&lt;/code&gt; for a detailed explanation of how this works. Per-line events may be disabled for a frame by setting &lt;code&gt;f_trace_lines&lt;/code&gt; to &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; on that frame.</source>
          <target state="translated">인터프리터가 새로운 코드 줄을 실행하거나 루프 조건을 다시 실행하려고합니다. 로컬 추적 기능이 호출됩니다. &lt;em&gt;arg&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 입니다 . 리턴 값은 새로운 로컬 추적 기능을 지정합니다. 작동 방식에 대한 자세한 설명은 &lt;code&gt;Objects/lnotab_notes.txt&lt;/code&gt; 를 참조하십시오 . 해당 프레임에서 &lt;code&gt;f_trace_lines&lt;/code&gt; 를 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 로 설정하여 라인 별 이벤트를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05d2d4d36f9b84be941684423f666d5858384c7f" translate="yes" xml:space="preserve">
          <source>The interpreter is about to execute a new opcode (see &lt;a href=&quot;dis#module-dis&quot;&gt;&lt;code&gt;dis&lt;/code&gt;&lt;/a&gt; for opcode details). The local trace function is called; &lt;em&gt;arg&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;; the return value specifies the new local trace function. Per-opcode events are not emitted by default: they must be explicitly requested by setting &lt;code&gt;f_trace_opcodes&lt;/code&gt; to &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; on the frame.</source>
          <target state="translated">인터프리터가 새 opcode를 실행하려고합니다 ( opcode 세부 사항 은 &lt;a href=&quot;dis#module-dis&quot;&gt; &lt;code&gt;dis&lt;/code&gt; &lt;/a&gt; 를 참조 하십시오). 로컬 추적 기능이 호출됩니다. &lt;em&gt;arg&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 입니다 . 리턴 값은 새로운 로컬 추적 기능을 지정합니다. per-opcode 이벤트는 기본적으로 생성되지 않습니다 . 프레임에서 &lt;code&gt;f_trace_opcodes&lt;/code&gt; 를 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 로 설정하여 명시 적으로 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba7c5536ace67e318f08d21d0cb3f1d81aa9054b" translate="yes" xml:space="preserve">
          <source>The interpreter stack</source>
          <target state="translated">인터프리터 스택</target>
        </trans-unit>
        <trans-unit id="3a7917658505e7d533ba455bedd0fed06a48c193" translate="yes" xml:space="preserve">
          <source>The interpreter supports several other kinds of objects. Most of these support only one or two operations.</source>
          <target state="translated">인터프리터는 다른 여러 종류의 객체를 지원합니다. 이들 대부분은 하나 또는 두 개의 작업 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dcf8a72b9d3d3a430d8e38722f72101fcf685b16" translate="yes" xml:space="preserve">
          <source>The interpreter&amp;rsquo;s own prompts and its error messages go to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">인터프리터 자신의 프롬프트와 오류 메시지는 &lt;code&gt;stderr&lt;/code&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="3c5319f23805e5b59e8472cb6037b15ab9f55160" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#email.utils.format_datetime&quot;&gt;&lt;code&gt;format_datetime()&lt;/code&gt;&lt;/a&gt;. Performs the same function as &lt;a href=&quot;#email.utils.parsedate&quot;&gt;&lt;code&gt;parsedate()&lt;/code&gt;&lt;/a&gt;, but on success returns a &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;. If the input date has a timezone of &lt;code&gt;-0000&lt;/code&gt;, the &lt;code&gt;datetime&lt;/code&gt; will be a naive &lt;code&gt;datetime&lt;/code&gt;, and if the date is conforming to the RFCs it will represent a time in UTC but with no indication of the actual source timezone of the message the date comes from. If the input date has any other valid timezone offset, the &lt;code&gt;datetime&lt;/code&gt; will be an aware &lt;code&gt;datetime&lt;/code&gt; with the corresponding a &lt;a href=&quot;datetime#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;datetime#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#email.utils.format_datetime&quot;&gt; &lt;code&gt;format_datetime()&lt;/code&gt; &lt;/a&gt; 의 역수입니다 . &lt;a href=&quot;#email.utils.parsedate&quot;&gt; &lt;code&gt;parsedate()&lt;/code&gt; &lt;/a&gt; 와 동일한 기능을 수행 하지만 성공하면 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 입력 날짜의 시간대가 &lt;code&gt;-0000&lt;/code&gt; 이면 &lt;code&gt;datetime&lt;/code&gt; 은 순진한 &lt;code&gt;datetime&lt;/code&gt; 이되고 날짜가 RFC를 따르는 경우 UTC로 시간을 나타내지 만 메시지의 실제 소스 시간대를 나타내지 않고 날짜가옵니다. 에서. 입력 날짜 오프셋 다른 유효 시간대를 갖는 경우, &lt;code&gt;datetime&lt;/code&gt; 의식적 것이다 &lt;code&gt;datetime&lt;/code&gt; (가)와 대응하는 &lt;a href=&quot;datetime#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;datetime#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f436e82da8db30cb17224562f2fe471acaf805" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#email.utils.parseaddr&quot;&gt;&lt;code&gt;parseaddr()&lt;/code&gt;&lt;/a&gt;, this takes a 2-tuple of the form &lt;code&gt;(realname,
email_address)&lt;/code&gt; and returns the string value suitable for a &lt;em&gt;To&lt;/em&gt; or &lt;em&gt;Cc&lt;/em&gt; header. If the first element of &lt;em&gt;pair&lt;/em&gt; is false, then the second element is returned unmodified.</source>
          <target state="translated">&lt;a href=&quot;#email.utils.parseaddr&quot;&gt; &lt;code&gt;parseaddr()&lt;/code&gt; &lt;/a&gt; 의 반대 인 형식 (실명 &lt;code&gt;(realname, email_address)&lt;/code&gt; 의 2- 튜플을 취하고 &lt;em&gt;To&lt;/em&gt; 또는 &lt;em&gt;Cc&lt;/em&gt; 헤더에 적합한 문자열 값을 리턴합니다 . &lt;em&gt;쌍&lt;/em&gt; 의 첫 번째 요소 가 false이면 두 번째 요소는 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fefd3e04e0fbb3688fc42759eebadd4a2616e337" translate="yes" xml:space="preserve">
          <source>The issue is that even if you mock out the call to &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; it is the &lt;em&gt;returned object&lt;/em&gt; that is used as a context manager (and has &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; called).</source>
          <target state="translated">문제는 당신에 대한 호출을 조롱해도 있다는 것입니다 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 가있다 &lt;em&gt;반환 된 객체&lt;/em&gt; 컨텍스트 매니저로 사용된다 (그리고이 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 라고 함).</target>
        </trans-unit>
        <trans-unit id="ca7575c226a0359045987634aead5418cc5184ef" translate="yes" xml:space="preserve">
          <source>The items and all of their descendants are still present, and may be reinserted at another point in the tree, but will not be displayed.</source>
          <target state="translated">항목과 모든 하위 항목이 여전히 존재하며 트리의 다른 지점에 다시 삽입 될 수 있지만 표시되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a29f27aafd7c4fbc90565afdb89bc57730a7634" translate="yes" xml:space="preserve">
          <source>The items can be any type accepted by the operand&amp;rsquo;s &lt;a href=&quot;#operator.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; method. Dictionaries accept any hashable value. Lists, tuples, and strings accept an index or a slice:</source>
          <target state="translated">항목은 피연산자의 &lt;a href=&quot;#operator.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 메서드 에서 허용하는 모든 유형이 될 수 있습니다 . 사전은 모든 해시 가능 값을 허용합니다. 리스트, 튜플 및 문자열은 인덱스 또는 슬라이스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="bdc953aeb10907bbc5198ee20364c13eebd711e8" translate="yes" xml:space="preserve">
          <source>The iterator generates a series of &lt;a href=&quot;#dis.Instruction&quot;&gt;&lt;code&gt;Instruction&lt;/code&gt;&lt;/a&gt; named tuples giving the details of each operation in the supplied code.</source>
          <target state="translated">반복자 는 제공된 코드의 각 작업에 대한 세부 정보를 제공하는 튜플이라는 일련의 &lt;a href=&quot;#dis.Instruction&quot;&gt; &lt;code&gt;Instruction&lt;/code&gt; &lt;/a&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="9d0f19f81bfdcc59fee1b74fd4d26070697d7379" translate="yes" xml:space="preserve">
          <source>The iterator objects themselves are required to support the following two methods, which together form the &lt;em&gt;iterator protocol&lt;/em&gt;:</source>
          <target state="translated">반복자 객체 자체는 &lt;em&gt;반복자 프로토콜을&lt;/em&gt; 구성하는 다음 두 가지 방법을 지원해야 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c127c0df086cf632c4c5ff7440003447aa245a64" translate="yes" xml:space="preserve">
          <source>The joined output of calls to the &lt;a href=&quot;#codecs.IncrementalEncoder.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#codecs.IncrementalDecoder.decode&quot;&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/a&gt; method is the same as if all the single inputs were joined into one, and this input was encoded/decoded with the stateless encoder/decoder.</source>
          <target state="translated">&lt;a href=&quot;#codecs.IncrementalEncoder.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#codecs.IncrementalDecoder.decode&quot;&gt; &lt;code&gt;decode()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 호출의 결합 된 출력은 모든 단일 입력이 하나로 결합 된 것과 동일하며이 입력은 상태 비 저장 인코더 / 디코더로 인코딩 / 디코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="40164e2efd0e4a1ad74dc48fce25ae3c60346d4b" translate="yes" xml:space="preserve">
          <source>The json module implements a subset of JavaScript syntax which can also be used for this purpose.</source>
          <target state="translated">json 모듈은이 목적으로도 사용될 수있는 JavaScript 구문의 서브 세트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="061bffc3b0c36f0cf3b43e8fa55fc7f1bfb59602" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'()'&lt;/code&gt; has been used as the special key because it is not a valid keyword parameter name, and so will not clash with the names of the keyword arguments used in the call. The &lt;code&gt;'()'&lt;/code&gt; also serves as a mnemonic that the corresponding value is a callable.</source>
          <target state="translated">핵심은 &lt;code&gt;'()'&lt;/code&gt; 유효한 키워드 매개 변수 이름이 아니므로 특수 키로서 사용되어왔다, 그래서 전화에 사용되는 키워드 인자의 이름과 충돌하지 않습니다. 는 &lt;code&gt;'()'&lt;/code&gt; 과 같은 대응하는 값이 호출임을 니모닉로서 기능한다.</target>
        </trans-unit>
        <trans-unit id="4a2fc7414d7e109453be0f1ab99047bcd601ae56" translate="yes" xml:space="preserve">
          <source>The key benefit of having the logging API provided by a standard library module is that all Python modules can participate in logging, so your application log can include your own messages integrated with messages from third-party modules.</source>
          <target state="translated">표준 라이브러리 모듈에서 제공하는 로깅 API를 사용하면 얻을 수있는 주요 이점은 모든 Python 모듈이 로깅에 참여할 수 있으므로 응용 프로그램 로그에 타사 모듈의 메시지와 통합 된 자체 메시지를 포함 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="699442994a289dac727d3c0dce4747dff2f3e0fc" translate="yes" xml:space="preserve">
          <source>The key identified by the &lt;em&gt;key&lt;/em&gt; parameter must have been opened with &lt;a href=&quot;#winreg.KEY_SET_VALUE&quot;&gt;&lt;code&gt;KEY_SET_VALUE&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 매개 변수로 식별 된 &lt;em&gt;키&lt;/em&gt; 는 &lt;a href=&quot;#winreg.KEY_SET_VALUE&quot;&gt; &lt;code&gt;KEY_SET_VALUE&lt;/code&gt; &lt;/a&gt; 액세스 로 열어야 합니다.</target>
        </trans-unit>
        <trans-unit id="09994237c609f442d527a3b937ecbd46cc6b5078" translate="yes" xml:space="preserve">
          <source>The key is to patch out &lt;code&gt;SomeClass&lt;/code&gt; where it is used (or where it is looked up). In this case &lt;code&gt;some_function&lt;/code&gt; will actually look up &lt;code&gt;SomeClass&lt;/code&gt; in module b, where we have imported it. The patching should look like:</source>
          <target state="translated">핵심은 &lt;code&gt;SomeClass&lt;/code&gt; 가 사용되는 곳 (또는 찾는 곳 )을 패치하는 것입니다. 이 경우 &lt;code&gt;some_function&lt;/code&gt; 은 실제로 가져온 모듈 b에서 &lt;code&gt;SomeClass&lt;/code&gt; 를 찾습니다 . 패치는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="fa3481269bf45a1c67f29407c0512754b2986c60" translate="yes" xml:space="preserve">
          <source>The keys are case-insensitive and their default value is &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">키는 대소 문자를 구분하지 않으며 기본값은 &lt;code&gt;''&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03fdaa86777072e03a16a136e354ad81249c970a" translate="yes" xml:space="preserve">
          <source>The keys in the dictionary passed in &lt;em&gt;extra&lt;/em&gt; should not clash with the keys used by the logging system. (See the &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; documentation for more information on which keys are used by the logging system.)</source>
          <target state="translated">&lt;em&gt;추가로&lt;/em&gt; 전달 된 사전 의 키는 로깅 시스템이 사용하는 키와 충돌하지 않아야합니다. 로깅 시스템에서 사용하는 키에 대한 자세한 내용은 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1300d1613b84592f2474c0dcb0a65568bb4315f" translate="yes" xml:space="preserve">
          <source>The keys of the returned data structure &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt; name the metadata keywords, and their values are returned unparsed from the distribution metadata:</source>
          <target state="translated">리턴 된 데이터 구조 &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt; 의 키는 메타 데이터 키워드의 이름을 지정하며 해당 값은 분배 메타 데이터에서 구문 분석되지 않은 상태로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ad3767fc1845f08027609c64c86cdbb4705d70c6" translate="yes" xml:space="preserve">
          <source>The keyword arguments that will be supplied when the &lt;a href=&quot;#functools.partial&quot;&gt;&lt;code&gt;partial&lt;/code&gt;&lt;/a&gt; object is called.</source>
          <target state="translated">&lt;a href=&quot;#functools.partial&quot;&gt; &lt;code&gt;partial&lt;/code&gt; &lt;/a&gt; 객체가 호출 될 때 제공 될 키워드 인수입니다 .</target>
        </trans-unit>
        <trans-unit id="e878f3fc95ba63b2ca9864baa791a7fb92d631e4" translate="yes" xml:space="preserve">
          <source>The lack of memory or disk volume would lead to decompression failed. For example, decompression bombs (aka &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_bomb&quot;&gt;ZIP bomb&lt;/a&gt;) apply to zipfile library that can cause disk volume exhaustion.</source>
          <target state="translated">메모리 나 디스크 볼륨이 없으면 압축 해제에 실패합니다. 예를 들어 압축 해제 폭탄 (일명 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_bomb&quot;&gt;ZIP 폭탄&lt;/a&gt; )은 디스크 볼륨 소진을 유발할 수있는 zipfile 라이브러리에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ffb219d74b6ece8dd161b7424f6185fad907847" translate="yes" xml:space="preserve">
          <source>The language reference for the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문의 언어 참조</target>
        </trans-unit>
        <trans-unit id="68e00f8d6f3a921e236f51de07c124755eb15f37" translate="yes" xml:space="preserve">
          <source>The large data objects to be pickled must implement a &lt;a href=&quot;#object.__reduce_ex__&quot;&gt;&lt;code&gt;__reduce_ex__()&lt;/code&gt;&lt;/a&gt; method specialized for protocol 5 and higher, which returns a &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt;&lt;code&gt;PickleBuffer&lt;/code&gt;&lt;/a&gt; instance (instead of e.g. a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object) for any large data.</source>
          <target state="translated">피클 할 큰 데이터 객체 는 프로토콜 5 이상에 특화된 &lt;a href=&quot;#object.__reduce_ex__&quot;&gt; &lt;code&gt;__reduce_ex__()&lt;/code&gt; &lt;/a&gt; 메서드를 구현해야합니다. 이는 대형 데이터에 대해 &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt; &lt;code&gt;PickleBuffer&lt;/code&gt; &lt;/a&gt; 인스턴스 (예 : &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체)를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9fd6b021ccba4c20527e39206aae9a5762d1f9bf" translate="yes" xml:space="preserve">
          <source>The largest area of mapped memory which the process may occupy.</source>
          <target state="translated">프로세스가 차지할 수있는 가장 큰 매핑 된 메모리 영역입니다.</target>
        </trans-unit>
        <trans-unit id="f252a89846a5b8a765de872bd3fd9eaf81718527" translate="yes" xml:space="preserve">
          <source>The largest year number allowed in a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object. &lt;a href=&quot;#datetime.MAXYEAR&quot;&gt;&lt;code&gt;MAXYEAR&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;9999&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 개체에 허용되는 가장 큰 연도 번호 입니다. &lt;a href=&quot;#datetime.MAXYEAR&quot;&gt; &lt;code&gt;MAXYEAR&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;9999&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="27f336ad56fea8353ecf6927e2ddfbc131d9f99e" translate="yes" xml:space="preserve">
          <source>The last child of the node, if there are any, or &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">노드의 마지막 자식, 어떤, 또는 존재하지 않는 경우는 &lt;code&gt;None&lt;/code&gt; . 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="f5eddea39611a409d920003c195a69723d0a0ff2" translate="yes" xml:space="preserve">
          <source>The last nonempty command prefix seen.</source>
          <target state="translated">비어 있지 않은 마지막 명령 접두사</target>
        </trans-unit>
        <trans-unit id="c93316bbcd638d9105156a87761f25f1c48ed03b" translate="yes" xml:space="preserve">
          <source>The last three lines (starting with &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;) are compared against the exception&amp;rsquo;s type and detail, and the rest are ignored.</source>
          <target state="translated">&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 로&lt;/a&gt; 시작하는 마지막 세 줄 은 예외 유형 및 세부 사항과 비교되고 나머지는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="814cff0678bb087583201e49ec61d6e354b8e223" translate="yes" xml:space="preserve">
          <source>The last triple is a dummy, and has the value &lt;code&gt;(len(a), len(b), 0)&lt;/code&gt;. It is the only triple with &lt;code&gt;n == 0&lt;/code&gt;. If &lt;code&gt;(i, j, n)&lt;/code&gt; and &lt;code&gt;(i', j', n')&lt;/code&gt; are adjacent triples in the list, and the second is not the last triple in the list, then &lt;code&gt;i+n &amp;lt; i'&lt;/code&gt; or &lt;code&gt;j+n &amp;lt; j'&lt;/code&gt;; in other words, adjacent triples always describe non-adjacent equal blocks.</source>
          <target state="translated">마지막 트리플은 더미이며 값은 &lt;code&gt;(len(a), len(b), 0)&lt;/code&gt; 입니다. &lt;code&gt;n == 0&lt;/code&gt; 유일한 트리플입니다 . 경우 &lt;code&gt;(i, j, n)&lt;/code&gt; 및 &lt;code&gt;(i', j', n')&lt;/code&gt; 리스트 내의 인접 트리플이 있으며, 두 번째 그 다음,리스트의 마지막 트리플 아닌 &lt;code&gt;i+n &amp;lt; i'&lt;/code&gt; 또는 &lt;code&gt;j+n &amp;lt; j'&lt;/code&gt; ; 즉, 인접한 트리플은 항상 인접하지 않은 동일한 블록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1b8685c24c17534e39efb60cae137482f9ec418" translate="yes" xml:space="preserve">
          <source>The last variation is &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt;. Like &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; members can be combined using the bitwise operators (&amp;amp;, |, ^, ~). Unlike &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt;, they cannot be combined with, nor compared against, any other &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; enumeration, nor &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. While it is possible to specify the values directly it is recommended to use &lt;a href=&quot;#enum.auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt; as the value and let &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; select an appropriate value.</source>
          <target state="translated">마지막 변형은 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 입니다. 마찬가지로 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 회원은 비트 연산자를 사용하여 결합 (&amp;amp;, |, ^, ~) 할 수있다. &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 와는 달리 , 다른 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 열거 형이나 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 결합하거나 비교할 수 없습니다 . 값을 직접 지정할 수는 있지만 &lt;a href=&quot;#enum.auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; 를 값 으로 사용 하고 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 가 적절한 값을 선택 하도록하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6ab314fce26bc86e9964e587f8e7ca1920ea8436" translate="yes" xml:space="preserve">
          <source>The latest representable &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;datetime(MAXYEAR, 12, 31, 23, 59,
59, 999999, tzinfo=None)&lt;/code&gt;.</source>
          <target state="translated">표시 가능한 최신 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffbd94c8b6731bc985c2a9e5c296d5ad38ae6508" translate="yes" xml:space="preserve">
          <source>The latest representable &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;time(23, 59, 59, 999999)&lt;/code&gt;.</source>
          <target state="translated">가장 최근의 표현 가능한 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;time(23, 59, 59, 999999)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e26fabc7e2019dbb9af113e30e22e959d1e2c3f" translate="yes" xml:space="preserve">
          <source>The latest representable date, &lt;code&gt;date(MAXYEAR, 12, 31)&lt;/code&gt;.</source>
          <target state="translated">표현 가능한 최신 날짜 &lt;code&gt;date(MAXYEAR, 12, 31)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f6c7f13f3607cf918c96b2deadeb84b0dd01cba" translate="yes" xml:space="preserve">
          <source>The latter example&amp;rsquo;s signature is essentially the overloading of &lt;code&gt;(str, str) -&amp;gt; str&lt;/code&gt; and &lt;code&gt;(bytes, bytes) -&amp;gt; bytes&lt;/code&gt;. Also note that if the arguments are instances of some subclass of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, the return type is still plain &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">후자의 예제 서명은 본질적으로 &lt;code&gt;(str, str) -&amp;gt; str&lt;/code&gt; 및 &lt;code&gt;(bytes, bytes) -&amp;gt; bytes&lt;/code&gt; 오버로드입니다 . 또한 인수가 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 일부 서브 클래스의 인스턴스 인 경우 리턴 유형은 여전히 ​​일반 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="660e3f6815f15682cf0ff1377f00b4c6f71b340f" translate="yes" xml:space="preserve">
          <source>The latter two functions perform best for smaller values of &lt;em&gt;n&lt;/em&gt;. For larger values, it is more efficient to use the &lt;a href=&quot;functions#sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; function. Also, when &lt;code&gt;n==1&lt;/code&gt;, it is more efficient to use the built-in &lt;a href=&quot;functions#min&quot;&gt;&lt;code&gt;min()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions#max&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt; functions. If repeated usage of these functions is required, consider turning the iterable into an actual heap.</source>
          <target state="translated">후자의 두 함수는 더 작은 &lt;em&gt;n&lt;/em&gt; 값에 가장 적합합니다 . 값이 클수록 &lt;a href=&quot;functions#sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하는 것이 더 효율적 입니다. 또한 &lt;code&gt;n==1&lt;/code&gt; 인 경우 내장 &lt;a href=&quot;functions#min&quot;&gt; &lt;code&gt;min()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;functions#max&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하는 것이 더 효율적 입니다. 이러한 기능을 반복해서 사용해야하는 경우 iterable을 실제 힙으로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7da03b2d60934473fcacd18e11917c208e302748" translate="yes" xml:space="preserve">
          <source>The least significant bit of the Unicode character is the rightmost x bit.</source>
          <target state="translated">유니 코드 문자의 최하위 비트는 가장 오른쪽에있는 x 비트입니다.</target>
        </trans-unit>
        <trans-unit id="8b3b2afbfe422c8067e3beb6538ca2c59ba607be" translate="yes" xml:space="preserve">
          <source>The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using &lt;code&gt;zip(*[iter(s)]*n)&lt;/code&gt;. This repeats the &lt;em&gt;same&lt;/em&gt; iterator &lt;code&gt;n&lt;/code&gt; times so that each output tuple has the result of &lt;code&gt;n&lt;/code&gt; calls to the iterator. This has the effect of dividing the input into n-length chunks.</source>
          <target state="translated">이터 러블의 왼쪽에서 오른쪽으로 평가 순서가 보장됩니다. 이것은 &lt;code&gt;zip(*[iter(s)]*n)&lt;/code&gt; 사용하여 데이터 계열을 n 길이 그룹으로 클러스터링하는 관용구를 가능하게합니다 . 이것은 &lt;em&gt;동일한&lt;/em&gt; 반복자를 &lt;code&gt;n&lt;/code&gt; 번 반복하여 각 출력 튜플이 반복기에 대한 &lt;code&gt;n&lt;/code&gt; 호출 의 결과를 갖도록 합니다. 이것은 입력을 n 길이의 청크로 나누는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="018d37fa1572d55e5f4db2ae98e5687edc22fd1a" translate="yes" xml:space="preserve">
          <source>The leftmost positional arguments that will be prepended to the positional arguments provided to a &lt;a href=&quot;#functools.partial&quot;&gt;&lt;code&gt;partial&lt;/code&gt;&lt;/a&gt; object call.</source>
          <target state="translated">&lt;a href=&quot;#functools.partial&quot;&gt; &lt;code&gt;partial&lt;/code&gt; &lt;/a&gt; 객체 호출에 제공되는 위치 인수 앞에 추가되는 가장 왼쪽 위치 인수입니다 .</target>
        </trans-unit>
        <trans-unit id="58a8ad59b6dbc81334a8bddecbdb0122eed056fd" translate="yes" xml:space="preserve">
          <source>The legacy &lt;code&gt;urllib.urlopen&lt;/code&gt; function from Python 2.6 and earlier has been discontinued; &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urllib.request.urlopen()&lt;/code&gt;&lt;/a&gt; corresponds to the old &lt;code&gt;urllib2.urlopen&lt;/code&gt;. Proxy handling, which was done by passing a dictionary parameter to &lt;code&gt;urllib.urlopen&lt;/code&gt;, can be obtained by using &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt;&lt;code&gt;ProxyHandler&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">Python 2.6 및 이전 버전 의 레거시 &lt;code&gt;urllib.urlopen&lt;/code&gt; 함수는 중단되었습니다. &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urllib.request.urlopen()&lt;/code&gt; &lt;/a&gt; 은 이전 &lt;code&gt;urllib2.urlopen&lt;/code&gt; 에 해당합니다 . 사전 매개 변수를 &lt;code&gt;urllib.urlopen&lt;/code&gt; 에 전달하여 수행 된 프록시 처리는 &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt; &lt;code&gt;ProxyHandler&lt;/code&gt; &lt;/a&gt; 객체 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d1d77cc2911d451afde6fba83206974589c97ba" translate="yes" xml:space="preserve">
          <source>The legacy interface does not support decoding from strings, but it does provide functions for encoding and decoding to and from &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. It only supports the Base64 standard alphabet, and it adds newlines every 76 characters as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;. Note that if you are looking for &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; support you probably want to be looking at the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package instead.</source>
          <target state="translated">레거시 인터페이스는 문자열에서의 디코딩을 지원하지 않지만 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 와의 인코딩 및 디코딩을위한 기능을 제공 합니다 . Base64 표준 알파벳 만 지원하며 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2045에&lt;/strong&gt;&lt;/a&gt; 따라 76 문자마다 줄 바꿈을 추가합니다 . &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; 지원을 찾고 있다면 &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지를 보고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9c731f90da8199c4d7aaf7dedfda9caeb528883" translate="yes" xml:space="preserve">
          <source>The legacy interface:</source>
          <target state="translated">레거시 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="7a2b470ad9a65f9f0762ea7caf0e4bb9c6add20b" translate="yes" xml:space="preserve">
          <source>The legal values of &lt;em&gt;someOptions&lt;/em&gt; is action dependent. Some actions, like &lt;code&gt;disable&lt;/code&gt;, require no arguments, others, like a text-entry box&amp;rsquo;s &lt;code&gt;delete&lt;/code&gt; command, would need arguments to specify what range of text to delete.</source>
          <target state="translated">&lt;em&gt;someOptions&lt;/em&gt; 의 유효한 값 은 작업에 따라 다릅니다. &lt;code&gt;disable&lt;/code&gt; 과 같은 일부 작업 에는 인수가 필요하지 않으며, 텍스트 입력 상자의 &lt;code&gt;delete&lt;/code&gt; 명령 과 같은 일부 작업에는 삭제할 텍스트 범위를 지정하는 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cb058da6334207304006a424f0f8d9b276871b01" translate="yes" xml:space="preserve">
          <source>The length in bytes of one array item in the internal representation.</source>
          <target state="translated">내부 표현에서 한 배열 항목의 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="923838e2430b00237995974c054b9eeca7a35d28" translate="yes" xml:space="preserve">
          <source>The length of the attribute list.</source>
          <target state="translated">속성 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="dcc9007038f3c59590069b522397660d31cc3ca9" translate="yes" xml:space="preserve">
          <source>The letters &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'L'&lt;/code&gt; and &lt;code&gt;'u'&lt;/code&gt; are mutually exclusive when used as inline flags, so they can&amp;rsquo;t be combined or follow &lt;code&gt;'-'&lt;/code&gt;. Instead, when one of them appears in an inline group, it overrides the matching mode in the enclosing group. In Unicode patterns &lt;code&gt;(?a:...)&lt;/code&gt; switches to ASCII-only matching, and &lt;code&gt;(?u:...)&lt;/code&gt; switches to Unicode matching (default). In byte pattern &lt;code&gt;(?L:...)&lt;/code&gt; switches to locale depending matching, and &lt;code&gt;(?a:...)&lt;/code&gt; switches to ASCII-only matching (default). This override is only in effect for the narrow inline group, and the original matching mode is restored outside of the group.</source>
          <target state="translated">문자 &lt;code&gt;'a'&lt;/code&gt; , &lt;code&gt;'L'&lt;/code&gt; 및 &lt;code&gt;'u'&lt;/code&gt; 는 인라인 플래그로 사용될 때 상호 배타적이므로 결합하거나 &lt;code&gt;'-'&lt;/code&gt; 뒤에 올 수 없습니다 . 대신, 이들 중 하나가 인라인 그룹에 표시되면 둘러싸는 그룹의 일치 모드를 대체합니다. 유니 코드 패턴 &lt;code&gt;(?a:...)&lt;/code&gt; 에서 ASCII 전용 일치로 전환하고 &lt;code&gt;(?u:...)&lt;/code&gt; 는 유니 코드 일치 (기본값)로 전환합니다. 바이트 패턴 &lt;code&gt;(?L:...)&lt;/code&gt; 일치에 따라 로캘로 전환되고 &lt;code&gt;(?a:...)&lt;/code&gt; 는 ASCII 전용 일치 (기본값)로 전환됩니다. 이 재정의는 좁은 인라인 그룹에만 적용되며 원래 일치 모드는 그룹 외부로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="46071ca495d4715a04355ff58ecf5fa1f0b05855" translate="yes" xml:space="preserve">
          <source>The level of debug output to use. This may be set from &lt;code&gt;0&lt;/code&gt; (the default, no output) to &lt;code&gt;3&lt;/code&gt; (the most output). Debugging information is written to &lt;code&gt;sys.stdout&lt;/code&gt;.</source>
          <target state="translated">사용할 디버그 출력 레벨입니다. 이것은 &lt;code&gt;0&lt;/code&gt; (기본값, 출력 없음)에서 &lt;code&gt;3&lt;/code&gt; (가장 높은 출력) 으로 설정 될 수 있습니다 . 디버깅 정보는 &lt;code&gt;sys.stdout&lt;/code&gt; 에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="baa39cf943cc5a970b4e65e88961f67561b53d3d" translate="yes" xml:space="preserve">
          <source>The limit is set by the &lt;a href=&quot;#tracemalloc.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">한계는 &lt;a href=&quot;#tracemalloc.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 함수에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="de2931539dd5e0b81cf4753da72b7bb9e5e06c82" translate="yes" xml:space="preserve">
          <source>The limitation on alphanumeric characters is due to the fact the persistent IDs, in protocol 0, are delimited by the newline character. Therefore if any kind of newline characters occurs in persistent IDs, the resulting pickle will become unreadable.</source>
          <target state="translated">영숫자 문자에 대한 제한은 프로토콜 0의 영구 ID가 줄 바꾸기 문자로 구분되기 때문입니다. 따라서 영구 ID에서 줄 바꿈 문자가 발생하면 결과 피클을 읽을 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="ddb5098bfc67dbb84a691e9b7eca7bfd9f7e071f" translate="yes" xml:space="preserve">
          <source>The line corresponding to &lt;em&gt;pos&lt;/em&gt; (may be &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;pos에&lt;/em&gt; 해당하는 행 ( &lt;code&gt;None&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="385e5e1d301f4330f6498263858864d80026a44e" translate="yes" xml:space="preserve">
          <source>The line corresponding to &lt;em&gt;pos&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;pos에&lt;/em&gt; 해당하는 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="48d3553a202e16a5997c4f8b2230b60e1ea146e6" translate="yes" xml:space="preserve">
          <source>The line number in the file where the definition starts.</source>
          <target state="translated">정의가 시작되는 파일의 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="4df26356a233917c02f1ba2f9c29e670a998c7da" translate="yes" xml:space="preserve">
          <source>The line number in the file where the logging call was made.</source>
          <target state="translated">로깅 호출이 작성된 파일의 행 번호입니다.</target>
        </trans-unit>
        <trans-unit id="867c809f9740a3e765b183977973727b5be7b14f" translate="yes" xml:space="preserve">
          <source>The line number within &lt;a href=&quot;#doctest.DocTest.filename&quot;&gt;&lt;code&gt;filename&lt;/code&gt;&lt;/a&gt; where this &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; begins, or &lt;code&gt;None&lt;/code&gt; if the line number is unavailable. This line number is zero-based with respect to the beginning of the file.</source>
          <target state="translated">이 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 가 시작 되는 &lt;a href=&quot;#doctest.DocTest.filename&quot;&gt; &lt;code&gt;filename&lt;/code&gt; &lt;/a&gt; 내의 행 번호 또는 행 번호를 사용할 수없는 경우 &lt;code&gt;None&lt;/code&gt; 이 줄 번호는 파일 시작과 관련하여 0부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="08c26210946c5aacbd20dec1fdc21d0c5da263b9" translate="yes" xml:space="preserve">
          <source>The line number within the string containing this example where the example begins. This line number is zero-based with respect to the beginning of the containing string.</source>
          <target state="translated">예제가 시작되는이 예제를 포함하는 문자열 내의 줄 번호입니다. 이 줄 번호는 포함 문자열의 시작과 관련하여 0부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e62560adbcb7cd22ddf304c8213f8b0b6f22b20a" translate="yes" xml:space="preserve">
          <source>The line of code (if it exists).</source>
          <target state="translated">코드 줄 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="95a3c39af0392219826bf64d10b7cc0efbd8e5f2" translate="yes" xml:space="preserve">
          <source>The line terminator is always &lt;code&gt;b'\n'&lt;/code&gt; for binary files; for text files, the &lt;em&gt;newline&lt;/em&gt; argument to &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; can be used to select the line terminator(s) recognized.</source>
          <target state="translated">이진 파일 의 경우 줄 종결자는 항상 &lt;code&gt;b'\n'&lt;/code&gt; 입니다. 텍스트 파일의 경우 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;개행&lt;/em&gt; 인수를 사용하여 인식되는 줄 종결자를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5a4052fcf6468b8aa17d3abaad906858e9dd53" translate="yes" xml:space="preserve">
          <source>The list of command line arguments passed to a Python script. &lt;code&gt;argv[0]&lt;/code&gt; is the script name (it is operating system dependent whether this is a full pathname or not). If the command was executed using the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; command line option to the interpreter, &lt;code&gt;argv[0]&lt;/code&gt; is set to the string &lt;code&gt;'-c'&lt;/code&gt;. If no script name was passed to the Python interpreter, &lt;code&gt;argv[0]&lt;/code&gt; is the empty string.</source>
          <target state="translated">명령 행 인수 목록은 Python 스크립트에 전달되었습니다. &lt;code&gt;argv[0]&lt;/code&gt; 은 스크립트 이름입니다 (전체 경로 이름인지 여부에 따라 운영 체제에 따라 다름). 인터프리터에 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 명령 행 옵션을 사용하여 명령을 실행 한 경우 &lt;code&gt;argv[0]&lt;/code&gt; 은 문자열 &lt;code&gt;'-c'&lt;/code&gt; 로 설정됩니다 . Python 인터프리터에 스크립트 이름이 전달되지 않은 경우 &lt;code&gt;argv[0]&lt;/code&gt; 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d757fedef32ac53b069cef108109ef76ce7569db" translate="yes" xml:space="preserve">
          <source>The list of modules described in this chapter is:</source>
          <target state="translated">이 장에서 설명하는 모듈 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89babbe22e696d6e3ea186b12494bd9b032a7f64" translate="yes" xml:space="preserve">
          <source>The list of type-specific methods automatically used by &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt; are summarized in the following table. Note that it&amp;rsquo;s usually not necessary to invoke these methods directly.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; 의해 자동으로 사용되는 유형별 메소드 목록이 다음 표에 요약되어 있습니다. 일반적으로 이러한 메소드를 직접 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ae7e452b330e7268c71ec096a019ddbaf030768" translate="yes" xml:space="preserve">
          <source>The list of values associated with the item.</source>
          <target state="translated">항목과 관련된 값 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7ee87db8625aac53dbfdf92521d5d1d3a282d084" translate="yes" xml:space="preserve">
          <source>The literal string &amp;ldquo;current&amp;rdquo;, which identifies the currently-selected tab</source>
          <target state="translated">현재 선택된 탭을 식별하는 리터럴 문자열 &quot;current&quot;</target>
        </trans-unit>
        <trans-unit id="7b83a337af5775f870f4c9e9c1d798e077c7c26f" translate="yes" xml:space="preserve">
          <source>The literal string &amp;ldquo;end&amp;rdquo;, which returns the number of tabs (only valid for &lt;a href=&quot;#tkinter.ttk.Notebook.index&quot;&gt;&lt;code&gt;Notebook.index()&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">탭 수를 반환하는 리터럴 문자열 &quot;end&quot;( &lt;a href=&quot;#tkinter.ttk.Notebook.index&quot;&gt; &lt;code&gt;Notebook.index()&lt;/code&gt; &lt;/a&gt; 에만 유효 )</target>
        </trans-unit>
        <trans-unit id="00d0aced4a91239bd29d9b019272137964be7681" translate="yes" xml:space="preserve">
          <source>The literal string &lt;code&gt;'cfg://handlers.file'&lt;/code&gt; will be resolved in an analogous way to strings with the &lt;code&gt;ext://&lt;/code&gt; prefix, but looking in the configuration itself rather than the import namespace. The mechanism allows access by dot or by index, in a similar way to that provided by &lt;code&gt;str.format&lt;/code&gt;. Thus, given the following snippet:</source>
          <target state="translated">리터럴 문자열 &lt;code&gt;'cfg://handlers.file'&lt;/code&gt; 은 &lt;code&gt;ext://&lt;/code&gt; 접두사 가있는 문자열과 비슷한 방식으로 해결 되지만 가져 오기 네임 스페이스가 아닌 구성 자체를 찾습니다. 이 메커니즘은 &lt;code&gt;str.format&lt;/code&gt; 에서 제공하는 것과 유사한 방식으로 점 또는 색인으로 액세스 할 수 있습니다 . 따라서 다음 스 니펫이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="4f27712ab758efd6de93f1cb55f0daab924009f0" translate="yes" xml:space="preserve">
          <source>The loader should set several attributes on the module. (Note that some of these attributes can change when a module is reloaded):</source>
          <target state="translated">로더는 모듈에서 여러 속성을 설정해야합니다. (이러한 속성 중 일부는 모듈을 다시로드 할 때 변경 될 수 있습니다) :</target>
        </trans-unit>
        <trans-unit id="53fb5b8026cc6284933ed89e03133964af92d815" translate="yes" xml:space="preserve">
          <source>The loader to use for loading. For namespace packages this should be set to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">로딩에 사용할 로더. 네임 스페이스 패키지의 경우 &lt;code&gt;None&lt;/code&gt; 으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d2a5a08b61bba44e30ad2500923bcca06f9ae4a" translate="yes" xml:space="preserve">
          <source>The loader used to load the module. The &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt;&lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt;&lt;/a&gt; decorator can handle the details for &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt;&lt;code&gt;__package__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로더가 모듈을로드하는 데 사용됩니다. &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt; &lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt; &lt;/a&gt; 데코레이터에 대한 세부 처리 할 수 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt; &lt;code&gt;__package__&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8402dc2e8df2842b8a96ff6565dbba76d783e577" translate="yes" xml:space="preserve">
          <source>The local trace function should return a reference to itself (or to another function for further tracing in that scope), or &lt;code&gt;None&lt;/code&gt; to turn off tracing in that scope.</source>
          <target state="translated">로컬 추적 함수는 자체 (또는 해당 범위의 추가 추적을위한 다른 함수)에 대한 참조를 리턴하거나 해당 범위 에서 추적을 끄려면 &lt;code&gt;None&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fd1d99f3f62d9ca3fd501bdfcd99eab24bbcbf0" translate="yes" xml:space="preserve">
          <source>The locale module exposes the C library&amp;rsquo;s gettext interface on systems that provide this interface. It consists of the functions &lt;code&gt;gettext()&lt;/code&gt;, &lt;code&gt;dgettext()&lt;/code&gt;, &lt;code&gt;dcgettext()&lt;/code&gt;, &lt;code&gt;textdomain()&lt;/code&gt;, &lt;code&gt;bindtextdomain()&lt;/code&gt;, and &lt;code&gt;bind_textdomain_codeset()&lt;/code&gt;. These are similar to the same functions in the &lt;a href=&quot;gettext#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module, but use the C library&amp;rsquo;s binary format for message catalogs, and the C library&amp;rsquo;s search algorithms for locating message catalogs.</source>
          <target state="translated">로케일 모듈은이 인터페이스를 제공하는 시스템에서 C 라이브러리의 gettext 인터페이스를 제공합니다. &lt;code&gt;gettext()&lt;/code&gt; , &lt;code&gt;dgettext()&lt;/code&gt; , &lt;code&gt;dcgettext()&lt;/code&gt; , &lt;code&gt;textdomain()&lt;/code&gt; , &lt;code&gt;bindtextdomain()&lt;/code&gt; 및 &lt;code&gt;bind_textdomain_codeset()&lt;/code&gt; 함수로 구성됩니다 . 이들은 &lt;a href=&quot;gettext#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈 의 동일한 기능과 유사 하지만 메시지 카탈로그에는 C 라이브러리의 2 진 형식과 메시지 카탈로그를 찾기위한 C 라이브러리의 검색 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4ba7e5b4616964368950cfe6530b817573940196" translate="yes" xml:space="preserve">
          <source>The locator allows the application to determine the end position of any document-related event, even if the parser is not reporting an error. Typically, the application will use this information for reporting its own errors (such as character content that does not match an application&amp;rsquo;s business rules). The information returned by the locator is probably not sufficient for use with a search engine.</source>
          <target state="translated">로케이터를 사용하면 구문 분석기가 오류를보고하지 않더라도 애플리케이션이 문서 관련 이벤트의 종료 위치를 판별 할 수 있습니다. 일반적으로 응용 프로그램은이 정보를 사용하여 자체 오류 (예 : 응용 프로그램의 비즈니스 규칙과 일치하지 않는 문자 내용)를보고합니다. 로케이터가 리턴 한 정보는 검색 엔진에 사용하기에 충분하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b541117087a1f8036f57f9c3d3bbdc4c1090859" translate="yes" xml:space="preserve">
          <source>The lock must be acquired before this method is called and released shortly after. If called with an &lt;em&gt;unlocked&lt;/em&gt; lock a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; error is raised.</source>
          <target state="translated">이 메소드를 호출하고 바로 해제하기 전에 잠금을 획득해야합니다. &lt;em&gt;잠금 해제&lt;/em&gt; 잠금으로 호출 하면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7364d43993bfd2a4a57e3ca43b4fcd30ba37faa5" translate="yes" xml:space="preserve">
          <source>The logged message, computed as &lt;code&gt;msg %
args&lt;/code&gt;. This is set when &lt;a href=&quot;#logging.Formatter.format&quot;&gt;&lt;code&gt;Formatter.format()&lt;/code&gt;&lt;/a&gt; is invoked.</source>
          <target state="translated">기록 된 메시지는 &lt;code&gt;msg % args&lt;/code&gt; 로 계산됩니다 . &lt;a href=&quot;#logging.Formatter.format&quot;&gt; &lt;code&gt;Formatter.format()&lt;/code&gt; &lt;/a&gt; 이 호출 될 때 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="9600b2843e41d05ad39313c9f2aa4c63763add6d" translate="yes" xml:space="preserve">
          <source>The logger name.</source>
          <target state="translated">로거 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2f74549631098ca837d37bb682ffc84ef0ff8585" translate="yes" xml:space="preserve">
          <source>The logging level (numeric).</source>
          <target state="translated">로깅 레벨 (숫자).</target>
        </trans-unit>
        <trans-unit id="2aba1c50c9b6d5d787703620a250beb6468cffca" translate="yes" xml:space="preserve">
          <source>The logging message.</source>
          <target state="translated">로깅 메시지</target>
        </trans-unit>
        <trans-unit id="0dccc7449100ad15c16ad79f5e92af3dc6052aa1" translate="yes" xml:space="preserve">
          <source>The logging module is intended to be thread-safe without any special work needing to be done by its clients. It achieves this though using threading locks; there is one lock to serialize access to the module&amp;rsquo;s shared data, and each handler also creates a lock to serialize access to its underlying I/O.</source>
          <target state="translated">로깅 모듈은 클라이언트가 특별한 작업을 수행하지 않아도 스레드로부터 안전합니다. 스레딩 잠금을 사용하여이를 달성합니다. 모듈의 공유 데이터에 대한 액세스를 직렬화하는 하나의 잠금이 있으며 각 핸들러는 기본 I / O에 대한 액세스를 직렬화하기위한 잠금을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="fbd8c2577035aac2745e273303fe716d8af12422" translate="yes" xml:space="preserve">
          <source>The logical operations are also generally applicable to all objects, and support truth tests, identity tests, and boolean operations:</source>
          <target state="translated">논리 연산은 일반적으로 모든 객체에 적용 할 수 있으며 진실 테스트, 신원 테스트 및 부울 연산을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7df6a8d5e02183fb9584ebe06ff76e9b96f074a5" translate="yes" xml:space="preserve">
          <source>The logical parent of the path:</source>
          <target state="translated">경로의 논리적 부모 :</target>
        </trans-unit>
        <trans-unit id="9b104204d7a73a4986c88e0fafeb98a170c6d913" translate="yes" xml:space="preserve">
          <source>The long form of the address representation, with all leading zeroes and groups consisting entirely of zeroes included.</source>
          <target state="translated">주소 표시의 긴 형식으로, 모든 선행 0과 그룹이 완전히 0으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="686df6d1bc1fad24559ce33a7e66dfd21b1ce389" translate="yes" xml:space="preserve">
          <source>The loop must not be running when this function is called. Any pending callbacks will be discarded.</source>
          <target state="translated">이 함수가 호출 될 때 루프가 실행되지 않아야합니다. 보류중인 모든 콜백은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="04b6ef293292796e68ba9b72db25470015a38602" translate="yes" xml:space="preserve">
          <source>The low byte of &lt;em&gt;counts&lt;/em&gt; is the number of values before the list value, the high byte of &lt;em&gt;counts&lt;/em&gt; the number of values after it. The resulting values are put onto the stack right-to-left.</source>
          <target state="translated">낮은 바이트 &lt;em&gt;수&lt;/em&gt; 는 목록 값 이전의 값 수이고 높은 바이트 &lt;em&gt;수는&lt;/em&gt; 그 이후의 값 수입니다. 결과 값은 오른쪽에서 왼쪽으로 스택에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="88e087adce032f73b077b616fdccdde637cf8a30" translate="yes" xml:space="preserve">
          <source>The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned.</source>
          <target state="translated">낮은 중앙값은 항상 데이터 세트의 멤버입니다. 데이터 포인트 수가 홀수이면 중간 값이 반환됩니다. 짝수이면 두 중간 값 중 작은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="348153e59e72f819cf9f80e2f695eeb377d9ff1b" translate="yes" xml:space="preserve">
          <source>The lowercase letters &lt;code&gt;'abcdefghijklmnopqrstuvwxyz'&lt;/code&gt;. This value is not locale-dependent and will not change.</source>
          <target state="translated">소문자 &lt;code&gt;'abcdefghijklmnopqrstuvwxyz'&lt;/code&gt; 입니다. 이 값은 로캘에 따라 다르지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68dd9722b27aa81209d16a358315ce11b2612f07" translate="yes" xml:space="preserve">
          <source>The lowercasing algorithm used is described in section 3.13 of the Unicode Standard.</source>
          <target state="translated">사용 된 소문자 알고리즘은 유니 코드 표준의 3.13 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40ebb0be055b496659fd786d4b5dcbf37866c95" translate="yes" xml:space="preserve">
          <source>The lowest valued entries are retrieved first (the lowest valued entry is the one returned by &lt;code&gt;sorted(list(entries))[0]&lt;/code&gt;). A typical pattern for entries is a tuple in the form: &lt;code&gt;(priority_number, data)&lt;/code&gt;.</source>
          <target state="translated">가장 낮은 값의 항목이 먼저 검색됩니다 (가장 낮은 값의 항목은 &lt;code&gt;sorted(list(entries))[0]&lt;/code&gt; 의해 반환 된 항목입니다 ). 항목의 일반적인 패턴은 &lt;code&gt;(priority_number, data)&lt;/code&gt; 형식의 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="18bdbb4ff9057c05b9f568636d67eb08afd9aac3" translate="yes" xml:space="preserve">
          <source>The magic methods are setup with &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; objects, so you can configure them and use them in the usual way:</source>
          <target state="translated">매직 메소드는 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 객체 로 설정 되므로 일반적인 방법으로 구성하고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="865a67d513776e169c7dda96ed43b5849ab01ce9" translate="yes" xml:space="preserve">
          <source>The mailcap format is documented in &lt;a href=&quot;https://tools.ietf.org/html/rfc1524.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 1524&lt;/strong&gt;&lt;/a&gt;, &amp;ldquo;A User Agent Configuration Mechanism For Multimedia Mail Format Information,&amp;rdquo; but is not an Internet standard. However, mailcap files are supported on most Unix systems.</source>
          <target state="translated">메일 캡 형식은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1524.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 1524&lt;/strong&gt;&lt;/a&gt; , &quot;멀티미디어 메일 형식 정보의 사용자 에이전트 구성 메커니즘&quot;에 설명되어 있지만 인터넷 표준은 아닙니다. 그러나 mailcap 파일은 대부분의 Unix 시스템에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6cc8e446023d86b73fe211c784da84cce64e5aa7" translate="yes" xml:space="preserve">
          <source>The main benefit of using &lt;a href=&quot;#weakref.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; is that it makes it simple to register a callback without needing to preserve the returned finalizer object. For instance</source>
          <target state="translated">&lt;a href=&quot;#weakref.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; 를 사용하면 얻을 수있는 최종 이점은 반환 된 finalizer 객체를 보존 할 필요없이 콜백을 간단하게 등록 할 수 있다는 것입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aa6749fbf672cc61852078669cd1d2c8b91798af" translate="yes" xml:space="preserve">
          <source>The main configuration parser. When &lt;em&gt;defaults&lt;/em&gt; is given, it is initialized into the dictionary of intrinsic defaults. When &lt;em&gt;dict_type&lt;/em&gt; is given, it will be used to create the dictionary objects for the list of sections, for the options within a section, and for the default values.</source>
          <target state="translated">기본 구성 파서 &lt;em&gt;기본값&lt;/em&gt; 이 지정 되면 고유 기본값의 사전으로 초기화됩니다. &lt;em&gt;dict_type&lt;/em&gt; 이 제공 되면 섹션 목록, 섹션 내의 옵션 및 기본값에 대한 사전 오브젝트를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c54c9aa0f2489f35af302e65b10db2bcc3bcc4a" translate="yes" xml:space="preserve">
          <source>The main difference with &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; is that methods &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt;&lt;code&gt;readinto()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.BufferedIOBase.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; will try (respectively) to read as much input as requested or to consume all given output, at the expense of making perhaps more than one system call.</source>
          <target state="translated">&lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 와의 주요 차이점 은 &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt; &lt;code&gt;readinto()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.BufferedIOBase.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 메소드 는 하나 이상의 시스템 호출을 희생하면서 요청 된만큼 많은 입력을 읽거나 주어진 모든 출력을 소비하려고 시도한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="add4c0e062cc808a9ca7701bbfdc7cff5c9ecf93" translate="yes" xml:space="preserve">
          <source>The main intended use for this function is in &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt; functions which wrap the decorated function and return the wrapper. If the wrapper function is not updated, the metadata of the returned function will reflect the wrapper definition rather than the original function definition, which is typically less than helpful.</source>
          <target state="translated">이 함수의 기본 용도는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;데코레이터&lt;/a&gt; 함수에서 데코 레이팅 된 함수를 래핑하고 래퍼를 반환하는 것입니다. 랩퍼 함수가 갱신되지 않은 경우, 리턴 된 함수의 메타 데이터는 원래 함수 정의가 아닌 랩퍼 정의를 반영하므로 일반적으로 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0393c29f0c76cc68d75498c911cd5856119a6e90" translate="yes" xml:space="preserve">
          <source>The major version number as an integer</source>
          <target state="translated">정수인 주 버전 번호</target>
        </trans-unit>
        <trans-unit id="30f21a3c2db9a772b559f8bc77b28a40e6c10c6c" translate="yes" xml:space="preserve">
          <source>The mapping from OMG IDL to Python defines accessor functions for IDL &lt;code&gt;attribute&lt;/code&gt; declarations in much the way the Java mapping does. Mapping the IDL declarations</source>
          <target state="translated">OMG IDL에서 Python 으로의 맵핑은 Java 맵핑과 거의 같은 방식으로 IDL &lt;code&gt;attribute&lt;/code&gt; 선언에 대한 접근 자 함수를 정의합니다 . IDL 선언 매핑</target>
        </trans-unit>
        <trans-unit id="3419e0b499e5db528695a54967ba3f26daf25f53" translate="yes" xml:space="preserve">
          <source>The mapping protocol is implemented on top of the existing legacy API so that subclasses overriding the original interface still should have mappings working as expected.</source>
          <target state="translated">매핑 프로토콜은 기존 레거시 API를 기반으로 구현되므로 원래 인터페이스를 재정의하는 서브 클래스에는 매핑이 예상대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="b710ef0544d30a94e35eeefd82c04ec7bcd8401d" translate="yes" xml:space="preserve">
          <source>The master of an object is implicit in the new name given to it at creation time. In Tkinter, masters are specified explicitly.</source>
          <target state="translated">객체의 마스터는 생성시 지정된 새로운 이름에 내재되어 있습니다. Tkinter에서 마스터는 명시 적으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa43c839cad7c9f8633be4d929c1f71fa21cfe96" translate="yes" xml:space="preserve">
          <source>The mathematical and bitwise operations are the most numerous:</source>
          <target state="translated">수학 및 비트 연산은 가장 많습니다 :</target>
        </trans-unit>
        <trans-unit id="ffd8ab3a9ff10a51a4dccf1570930213eb5db01e" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;&amp;pi;&lt;/em&gt; = 3.141592&amp;hellip;, to available precision.</source>
          <target state="translated">사용 가능한 정밀도까지 수학 상수 &lt;em&gt;&amp;pi;&lt;/em&gt; = 3.141592&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0ac993c9d5a9077494dd0fdf626d7dd10bc2c6da" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;&amp;pi;&lt;/em&gt;, as a float.</source>
          <target state="translated">부동 소수점으로서의 수학 상수 &lt;em&gt;&amp;pi;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="20b3db0ac46a25c5bb1172d3a8fe85f345bf1a43" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;&amp;tau;&lt;/em&gt; = 6.283185&amp;hellip;, to available precision. Tau is a circle constant equal to 2&lt;em&gt;&amp;pi;&lt;/em&gt;, the ratio of a circle&amp;rsquo;s circumference to its radius. To learn more about Tau, check out Vi Hart&amp;rsquo;s video &lt;a href=&quot;https://www.youtube.com/watch?v=jG7vhMMXagQ&quot;&gt;Pi is (still) Wrong&lt;/a&gt;, and start celebrating &lt;a href=&quot;https://tauday.com/&quot;&gt;Tau day&lt;/a&gt; by eating twice as much pie!</source>
          <target state="translated">사용 가능한 정밀도까지 수학 상수 &lt;em&gt;&amp;tau;&lt;/em&gt; = 6.283185&amp;hellip; Tau는 원주와 반지름의 비율 인 2 &lt;em&gt;&amp;pi;&lt;/em&gt; 와 같은 원 상수 입니다. 타우에 대해 자세히 알아 보려면 Vi Hart의 비디오 &lt;a href=&quot;https://www.youtube.com/watch?v=jG7vhMMXagQ&quot;&gt;Pi is (still) Wrong&lt;/a&gt; 을 확인하고 파이를 두 배로 먹어 &lt;a href=&quot;https://tauday.com/&quot;&gt;타우의 날&lt;/a&gt; 을 축하하십시오 !</target>
        </trans-unit>
        <trans-unit id="3d05ec614092ea45e495ef9afe24dfe52026fce0" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;&amp;tau;&lt;/em&gt;, as a float.</source>
          <target state="translated">실수로서의 수학 상수 &lt;em&gt;&amp;tau;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2054053bda405d560ac8acf8fec5d4e60e4eafcb" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;e&lt;/em&gt; = 2.718281&amp;hellip;, to available precision.</source>
          <target state="translated">사용 가능한 정밀도까지 수학 상수 &lt;em&gt;e&lt;/em&gt; = 2.718281&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="30199680754c9073407ce0600edf0ade8930dbd1" translate="yes" xml:space="preserve">
          <source>The mathematical constant &lt;em&gt;e&lt;/em&gt;, as a float.</source>
          <target state="translated">실수로서의 수학 상수 &lt;em&gt;e&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d61fbc018444ee0c8960bf3c439cc42b02c7d456" translate="yes" xml:space="preserve">
          <source>The maximal depth of recursion is limited by &lt;em&gt;depth&lt;/em&gt; unless it is &lt;code&gt;None&lt;/code&gt;. &lt;code&gt;depth=0&lt;/code&gt; means no recursion.</source>
          <target state="translated">재귀의 최대 깊이 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 한 &lt;em&gt;깊이에&lt;/em&gt; 의해 제한됩니다 . &lt;code&gt;depth=0&lt;/code&gt; 은 재귀가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e00f5fdab4cabbe1aeef1488336a1e0638dc481" translate="yes" xml:space="preserve">
          <source>The maximum address space which may be locked in memory.</source>
          <target state="translated">메모리에 잠겨있을 수있는 최대 주소 공간.</target>
        </trans-unit>
        <trans-unit id="3b17a4fdd33906a05337e3c22b37611cee0453bb" translate="yes" xml:space="preserve">
          <source>The maximum amount of processor time (in seconds) that a process can use. If this limit is exceeded, a &lt;code&gt;SIGXCPU&lt;/code&gt; signal is sent to the process. (See the &lt;a href=&quot;signal#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module documentation for information about how to catch this signal and do something useful, e.g. flush open files to disk.)</source>
          <target state="translated">프로세스가 사용할 수있는 최대 프로세서 시간 (초)입니다. 이 한계를 초과하면 &lt;code&gt;SIGXCPU&lt;/code&gt; 신호가 프로세스로 전송됩니다. ( 이 신호를 포착하고 열려있는 파일을 디스크로 플러시하는 등 유용한 작업을 수행하는 방법에 대한 내용은 &lt;a href=&quot;signal#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="4c01edd35d2e4b18fd08aefd6e2bde18481b1d54" translate="yes" xml:space="preserve">
          <source>The maximum area (in bytes) of address space which may be taken by the process.</source>
          <target state="translated">프로세스에서 사용할 수있는 주소 공간의 최대 영역 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="fdaf1377134708ca6390a3f820016575dae71fa7" translate="yes" xml:space="preserve">
          <source>The maximum depth for recursive interpolation for &lt;code&gt;get()&lt;/code&gt; when the &lt;em&gt;raw&lt;/em&gt; parameter is false. This is relevant only when the default &lt;em&gt;interpolation&lt;/em&gt; is used.</source>
          <target state="translated">&lt;em&gt;원시&lt;/em&gt; 매개 변수가 false 일 때 &lt;code&gt;get()&lt;/code&gt; 대한 재귀 보간의 최대 깊이입니다 . 이것은 기본 &lt;em&gt;보간&lt;/em&gt; 이 사용될 때만 관련 됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9cf6df816155f1fcf09ddada21dd48bd2158aa1e" translate="yes" xml:space="preserve">
          <source>The maximum length of any line in the serialized output, not counting the end of line character(s). Default is 78, per &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;. A value of &lt;code&gt;0&lt;/code&gt; or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; indicates that no line wrapping should be done at all.</source>
          <target state="translated">행 끝 문자를 포함하지 않고 직렬화 된 출력에서 ​​행의 최대 길이입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322에&lt;/strong&gt;&lt;/a&gt; 따라 기본값은 78 입니다. &lt;code&gt;0&lt;/code&gt; 또는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 값은 줄 바꿈을 전혀 수행하지 않아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c81128f5386f85cb071f5872dac300fd5514ef2" translate="yes" xml:space="preserve">
          <source>The maximum line length can be specified explicitly via &lt;em&gt;maxlinelen&lt;/em&gt;. For splitting the first line to a shorter value (to account for the field header which isn&amp;rsquo;t included in &lt;em&gt;s&lt;/em&gt;, e.g. &lt;em&gt;Subject&lt;/em&gt;) pass in the name of the field in &lt;em&gt;header_name&lt;/em&gt;. The default &lt;em&gt;maxlinelen&lt;/em&gt; is 76, and the default value for &lt;em&gt;header_name&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, meaning it is not taken into account for the first line of a long, split header.</source>
          <target state="translated">&lt;em&gt;maxlinelen을&lt;/em&gt; 통해 최대 행 길이를 명시 적으로 지정할 수 있습니다 . 분할하는 (에 포함되지 않은 필드 헤더 고려하여 짧은 값으로 제 라인 &lt;em&gt;들&lt;/em&gt; , 예를 들어 &lt;em&gt;제목&lt;/em&gt; )의 필드 이름 전달 &lt;em&gt;헤더 _&lt;/em&gt; . &lt;em&gt;maxlinelen&lt;/em&gt; 의 기본값 은 76이고 &lt;em&gt;header_name&lt;/em&gt; 의 기본값 은 &lt;code&gt;None&lt;/code&gt; 이며, 긴 분할 헤더의 첫 번째 행을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e66eb50147f92af8dd6eba447536917c9a381aba" translate="yes" xml:space="preserve">
          <source>The maximum number of frames to include in tracebacks output by the default &lt;a href=&quot;#wsgiref.handlers.BaseHandler.log_exception&quot;&gt;&lt;code&gt;log_exception()&lt;/code&gt;&lt;/a&gt; method. If &lt;code&gt;None&lt;/code&gt;, all frames are included.</source>
          <target state="translated">기본 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.log_exception&quot;&gt; &lt;code&gt;log_exception()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 출력되는 역 추적에 포함 할 최대 프레임 수입니다 . 경우 &lt;code&gt;None&lt;/code&gt; , 모든 프레임이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="18b95718c02a3057f0e9df850480875ebc92b1c7" translate="yes" xml:space="preserve">
          <source>The maximum number of headers of this type that can have the same &lt;code&gt;name&lt;/code&gt;. A value of &lt;code&gt;None&lt;/code&gt; means unlimited. The &lt;code&gt;BaseHeader&lt;/code&gt; value for this attribute is &lt;code&gt;None&lt;/code&gt;; it is expected that specialized header classes will override this value as needed.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이 같은이 유형의 최대 헤더 수입니다 . &lt;code&gt;None&lt;/code&gt; 값은 무제한을 의미합니다. 이 속성 의 &lt;code&gt;BaseHeader&lt;/code&gt; 값은 &lt;code&gt;None&lt;/code&gt; 입니다 . 특수 헤더 클래스는 필요에 따라이 값을 대체 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="3a19b9bb8cb23af867bbc1480b419b1f7c7c4a4b" translate="yes" xml:space="preserve">
          <source>The maximum number of open file descriptors for the current process.</source>
          <target state="translated">현재 프로세스에 대한 열린 파일 디스크립터의 최대 수입니다.</target>
        </trans-unit>
        <trans-unit id="fb66b7d29ebcdf536a3295c6531102e20cafd4f6" translate="yes" xml:space="preserve">
          <source>The maximum number of processes the current process may create.</source>
          <target state="translated">현재 프로세스가 생성 할 수있는 최대 프로세스 수입니다.</target>
        </trans-unit>
        <trans-unit id="9832b0e10b58ae7eaee525f337f2d0d20c121e81" translate="yes" xml:space="preserve">
          <source>The maximum number of pseudo-terminals created by this user id.</source>
          <target state="translated">이 사용자 ID로 작성된 최대 의사 터미널 수입니다.</target>
        </trans-unit>
        <trans-unit id="468d56b893ca1cec8143921e908a796ab75bf55e" translate="yes" xml:space="preserve">
          <source>The maximum resident set size that should be made available to the process.</source>
          <target state="translated">프로세스에서 사용할 수있는 최대 상주 세트 크기입니다.</target>
        </trans-unit>
        <trans-unit id="cf128709848248da0942adf9e6d9e6ef3ddbd5d3" translate="yes" xml:space="preserve">
          <source>The maximum size (in bytes) of a core file that the current process can create. This may result in the creation of a partial core file if a larger core would be required to contain the entire process image.</source>
          <target state="translated">현재 프로세스가 작성할 수있는 코어 파일의 최대 크기 (바이트)입니다. 더 큰 코어가 전체 프로세스 이미지를 포함해야하는 경우 부분 코어 파일이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfe5e4a5e02cc7c94294a5a445fc46319bfe3b14" translate="yes" xml:space="preserve">
          <source>The maximum size (in bytes) of socket buffer usage for this user. This limits the amount of network memory, and hence the amount of mbufs, that this user may hold at any time.</source>
          <target state="translated">이 사용자에 대한 소켓 버퍼 사용량의 최대 크기 (바이트). 이렇게하면이 사용자가 언제든지 보유 할 수있는 네트워크 메모리 양과 mbuf의 양이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="98418090d364665cf57fd3cd5eca6496cfa69287" translate="yes" xml:space="preserve">
          <source>The maximum size (in bytes) of the call stack for the current process. This only affects the stack of the main thread in a multi-threaded process.</source>
          <target state="translated">현재 프로세스에 대한 호출 스택의 최대 크기 (바이트)입니다. 이것은 다중 스레드 프로세스에서 기본 스레드의 스택에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3bf4f581aecd08f964716440365704ea2052950e" translate="yes" xml:space="preserve">
          <source>The maximum size (in bytes) of the process&amp;rsquo;s heap.</source>
          <target state="translated">프로세스 힙의 최대 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="33eb92cb7c3db0ca5347014823d3ea50b3d841b7" translate="yes" xml:space="preserve">
          <source>The maximum size (in bytes) of the swap space that may be reserved or used by all of this user id&amp;rsquo;s processes. This limit is enforced only if bit 1 of the vm.overcommit sysctl is set. Please see &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/tuning(7)&quot;&gt;tuning(7)&lt;/a&gt;&lt;/em&gt; for a complete description of this sysctl.</source>
          <target state="translated">이 사용자 ID의 모든 프로세스에서 예약하거나 사용할 수있는 스왑 공간의 최대 크기 (바이트)입니다. 이 제한은 vm.overcommit sysctl의 비트 1이 설정된 경우에만 적용됩니다. 이 sysctl에 대한 자세한 설명 은 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/tuning(7)&quot;&gt;tuning (7)&lt;/a&gt;&lt;/em&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89d63439144dced9f1c196a194e65d9d4cde356b" translate="yes" xml:space="preserve">
          <source>The maximum size of a file which the process may create.</source>
          <target state="translated">프로세스가 만들 수있는 파일의 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="259c41c465d4e1d93715f01eed3dd2ce5cdc176c" translate="yes" xml:space="preserve">
          <source>The maximum size the value of an extended attribute can be. Currently, this is 64 KiB on Linux.</source>
          <target state="translated">확장 된 속성의 값이 될 수있는 최대 크기입니다. 현재 이것은 Linux에서 64 KiB입니다.</target>
        </trans-unit>
        <trans-unit id="15c3fec5606dd03036b54707fa1f62bd41c762c1" translate="yes" xml:space="preserve">
          <source>The maximum value allowed for the &lt;em&gt;timeout&lt;/em&gt; parameter of &lt;code&gt;Lock.acquire()&lt;/code&gt;. Specifying a timeout greater than this value will raise an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Lock.acquire()&lt;/code&gt; 의 &lt;em&gt;시간 종료&lt;/em&gt; 매개 변수에 허용되는 최대 값 입니다. 이 값보다 큰 시간 초과를 지정하면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3172059fc2317f828db61c5edf2ebb3ec88dc996" translate="yes" xml:space="preserve">
          <source>The maximum value allowed for the &lt;em&gt;timeout&lt;/em&gt; parameter of blocking functions (&lt;a href=&quot;#threading.Lock.acquire&quot;&gt;&lt;code&gt;Lock.acquire()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#threading.RLock.acquire&quot;&gt;&lt;code&gt;RLock.acquire()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;Condition.wait()&lt;/code&gt;&lt;/a&gt;, etc.). Specifying a timeout greater than this value will raise an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">블로킹 함수 의 &lt;em&gt;제한 시간&lt;/em&gt; 매개 변수에 허용되는 최대 값 ( &lt;a href=&quot;#threading.Lock.acquire&quot;&gt; &lt;code&gt;Lock.acquire()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#threading.RLock.acquire&quot;&gt; &lt;code&gt;RLock.acquire()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;Condition.wait()&lt;/code&gt; &lt;/a&gt; 등). 이 값보다 큰 시간 초과를 지정하면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b79718434ca9ab5f1e1175b084bdcabb1be76928" translate="yes" xml:space="preserve">
          <source>The mbox format is the classic format for storing mail on Unix systems. All messages in an mbox mailbox are stored in a single file with the beginning of each message indicated by a line whose first five characters are &amp;ldquo;From &amp;ldquo;.</source>
          <target state="translated">mbox 형식은 Unix 시스템에 메일을 저장하기위한 기본 형식입니다. mbox 메일함에있는 모든 메시지는 하나의 파일에 저장되며 각 메시지의 시작 부분은 처음 다섯 문자가&amp;ldquo;보낸 사람&amp;rdquo;으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b945c51f9b14e5f28b0e2773473e0c702f3ac3e" translate="yes" xml:space="preserve">
          <source>The mean is strongly affected by outliers and is not a robust estimator for central location: the mean is not necessarily a typical example of the data points. For more robust measures of central location, see &lt;a href=&quot;#statistics.median&quot;&gt;&lt;code&gt;median()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#statistics.mode&quot;&gt;&lt;code&gt;mode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">평균은 특이 치의 영향을 많이받으며 중앙 위치에 대한 강력한 추정치가 아닙니다. 평균이 반드시 데이터 포인트의 전형적인 예는 아닙니다. 중앙 위치에 대한보다 강력한 측정 &lt;a href=&quot;#statistics.median&quot;&gt; &lt;code&gt;median()&lt;/code&gt; &lt;/a&gt; 은 median () 및 &lt;a href=&quot;#statistics.mode&quot;&gt; &lt;code&gt;mode()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="550a36e13b743aa4c4567c44300a1ad1e8b956c7" translate="yes" xml:space="preserve">
          <source>The meaning for &lt;em&gt;attrs&lt;/em&gt; is the same as in &lt;a href=&quot;#http.cookies.BaseCookie.output&quot;&gt;&lt;code&gt;output()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;attrs&lt;/em&gt; 의 의미 는 &lt;a href=&quot;#http.cookies.BaseCookie.output&quot;&gt; &lt;code&gt;output()&lt;/code&gt; &lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c45e027ff968e6c146e95e7c4cbd6f4617905a03" translate="yes" xml:space="preserve">
          <source>The meaning for &lt;em&gt;attrs&lt;/em&gt; is the same as in &lt;a href=&quot;#http.cookies.Morsel.output&quot;&gt;&lt;code&gt;output()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;attrs&lt;/em&gt; 의 의미 는 &lt;a href=&quot;#http.cookies.Morsel.output&quot;&gt; &lt;code&gt;output()&lt;/code&gt; &lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="868de20f7c32b2cd47542209682333406ad71447" translate="yes" xml:space="preserve">
          <source>The meaning of each of these fields is as described in &lt;a href=&quot;#warning-filter&quot;&gt;The Warnings Filter&lt;/a&gt;. When listing multiple filters on a single line (as for &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-2&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt;), the individual filters are separated by commas and the filters listed later take precedence over those listed before them (as they&amp;rsquo;re applied left-to-right, and the most recently applied filters take precedence over earlier ones).</source>
          <target state="translated">이러한 각 필드의 의미는 &lt;a href=&quot;#warning-filter&quot;&gt;경고 필터에&lt;/a&gt; 설명되어 있습니다. 단일 행에 여러 필터를 나열하는 경우 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-2&quot;&gt; &lt;code&gt;PYTHONWARNINGS&lt;/code&gt; &lt;/a&gt; 와 같이) 개별 필터는 쉼표로 구분되며 나중에 나열된 필터가 왼쪽에서 오른쪽으로 적용되고 가장 최근에 적용된 필터보다 먼저 나열된 필터보다 우선합니다 필터는 이전 필터보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="e849457da680ae8c22e5576309ff8a5fa0b259e0" translate="yes" xml:space="preserve">
          <source>The meaning of the variables is the same as that of the return values from &lt;a href=&quot;#sys.exc_info&quot;&gt;&lt;code&gt;exc_info()&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">변수의 의미는 위의 &lt;a href=&quot;#sys.exc_info&quot;&gt; &lt;code&gt;exc_info()&lt;/code&gt; &lt;/a&gt; 의 반환 값의 의미와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c25d6c022b116d44d4a41d054ee02d0e61d92c31" translate="yes" xml:space="preserve">
          <source>The meaning of the various alignment options is as follows:</source>
          <target state="translated">다양한 정렬 옵션의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5bf259f56524d4b3b2c7ae292e7cfc2d00ebf" translate="yes" xml:space="preserve">
          <source>The median is a robust measure of central location and is less affected by the presence of outliers. When the number of data points is odd, the middle data point is returned:</source>
          <target state="translated">중앙값은 중앙 위치에 대한 강력한 측정 값이며 특이 치의 영향을 덜받습니다. 데이터 포인트 수가 홀수 인 경우 중간 데이터 포인트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b307c00274d2715bf6f9437f8c0a6ae07ee164b" translate="yes" xml:space="preserve">
          <source>The member variables to use in these generated methods are defined using &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt; type annotations. For example this code:</source>
          <target state="translated">이러한 생성 된 메소드에 사용할 멤버 변수는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt; 유형 어노테이션을 사용하여 정의 됩니다. 예를 들어이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe72b703179dfb99a16193f12e81e1ca4c7de8a1" translate="yes" xml:space="preserve">
          <source>The message indicating which exception occurred is always the last string in the output.</source>
          <target state="translated">발생한 예외를 나타내는 메시지는 항상 출력의 마지막 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f3414e3d0c8855d4944ae4a9e8fd5959374a9d1f" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;#ssl.SSLSocket.unwrap&quot;&gt;&lt;code&gt;unwrap()&lt;/code&gt;&lt;/a&gt; call does not return anything, unlike for an SSL socket where it returns the underlying socket.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLSocket.unwrap&quot;&gt; &lt;code&gt;unwrap()&lt;/code&gt; &lt;/a&gt; 호출 메소드 는 기본 소켓을 리턴하는 SSL 소켓과 달리 아무것도 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b39c28cfe21e25b2fe481d66ea5a23208143c675" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Screen.mainloop()&lt;/code&gt; has been added. So when working only with Screen and Turtle objects one must not additionally import &lt;code&gt;mainloop()&lt;/code&gt; anymore.</source>
          <target state="translated">&lt;code&gt;Screen.mainloop()&lt;/code&gt; 메소드 가 추가되었습니다. 따라서 Screen 및 Turtle 객체로만 작업 할 때 더 이상 &lt;code&gt;mainloop()&lt;/code&gt; 가져 와서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="58dd8114fae3e2746ad30de805f9fef6eeab9270" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Screen.onkeypress()&lt;/code&gt; has been added as a complement to &lt;code&gt;Screen.onkey()&lt;/code&gt; which in fact binds actions to the keyrelease event. Accordingly the latter has got an alias: &lt;code&gt;Screen.onkeyrelease()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Screen.onkeypress()&lt;/code&gt; 메소드 는 실제로 액션을 키 릴리스 이벤트에 바인딩하는 &lt;code&gt;Screen.onkey()&lt;/code&gt; 의 보완으로 추가되었습니다 . 따라서 후자는 별칭이 &lt;code&gt;Screen.onkeyrelease()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="968b2e6a8b6948a76dfa9e831d419178ced0070a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Turtle.fill()&lt;/code&gt; has been eliminated. The behaviour of &lt;code&gt;begin_fill()&lt;/code&gt; and &lt;code&gt;end_fill()&lt;/code&gt; have changed slightly: now every filling-process must be completed with an &lt;code&gt;end_fill()&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;Turtle.fill()&lt;/code&gt; 메소드 가 제거되었습니다. &lt;code&gt;begin_fill()&lt;/code&gt; 및 &lt;code&gt;end_fill()&lt;/code&gt; 의 동작이 약간 변경되었습니다. 이제 모든 채우기 프로세스를 &lt;code&gt;end_fill()&lt;/code&gt; 호출 로 완료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="035262622de2278bdf132b12c18cf3c653677b5f" translate="yes" xml:space="preserve">
          <source>The method attempts to write the &lt;em&gt;data&lt;/em&gt; to the underlying socket immediately. If that fails, the data is queued in an internal write buffer until it can be sent.</source>
          <target state="translated">이 메소드 는 기본 소켓에 &lt;em&gt;데이터&lt;/em&gt; 를 즉시 쓰려고 시도 합니다. 실패하면 데이터는 전송 될 때까지 내부 쓰기 버퍼에 대기됩니다.</target>
        </trans-unit>
        <trans-unit id="3cf40ed487d91e7457380cd252e90de79708fd63" translate="yes" xml:space="preserve">
          <source>The method can be called an arbitrary number of times while a connection is open.</source>
          <target state="translated">연결이 열려있는 동안이 메소드를 임의의 횟수로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29ab645cf2448985ba39cd190f32ec53a7459b5" translate="yes" xml:space="preserve">
          <source>The method closes the stream and the underlying socket.</source>
          <target state="translated">이 메소드는 스트림과 기본 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="01816c894f7b233ae62d7151cb395312046022fd" translate="yes" xml:space="preserve">
          <source>The method does not perform a cert exchange immediately. The server-side sends a CertificateRequest during the next write event and expects the client to respond with a certificate on the next read event.</source>
          <target state="translated">이 방법은 인증서 교환을 즉시 수행하지 않습니다. 서버 측은 다음 쓰기 이벤트 동안 CertificateRequest를 보내고 클라이언트가 다음 읽기 이벤트에서 인증서로 응답 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="419e915ce3494d855431a170188d460b2d7d3644" translate="yes" xml:space="preserve">
          <source>The method executes the number of Python calls given by the argument, directly and again under the profiler, measuring the time for both. It then computes the hidden overhead per profiler event, and returns that as a float. For example, on a 1.8Ghz Intel Core i5 running Mac OS X, and using Python&amp;rsquo;s time.process_time() as the timer, the magical number is about 4.04e-6.</source>
          <target state="translated">이 메소드는 인수가 제공 한 Python 호출 수를 프로파일 러에서 직접 반복해서 실행하여 둘 다에 대한 시간을 측정합니다. 그런 다음 프로파일 러 이벤트 당 숨겨진 오버 헤드를 계산하여 부동 소수점으로 리턴합니다. 예를 들어, Mac OS X을 실행하고 Python의 time.process_time ()을 타이머로 사용하는 1.8Ghz Intel Core i5에서 마법의 숫자는 약 4.04e-6입니다.</target>
        </trans-unit>
        <trans-unit id="0700da9398eacd929a7c0fe0ff121dbd3c05cd76" translate="yes" xml:space="preserve">
          <source>The method is usually used to check if a Future is not &lt;em&gt;cancelled&lt;/em&gt; before setting a result or an exception for it:</source>
          <target state="translated">이 방법은 일반적으로 결과 또는 예외를 설정하기 전에 미래가 &lt;em&gt;취소&lt;/em&gt; 되지 않았는지 확인하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4cf4161d9bb3d1ad96f25e17375a4359b8351db" translate="yes" xml:space="preserve">
          <source>The method may not store state in the &lt;code&gt;Codec&lt;/code&gt; instance. Use &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; for codecs which have to keep state in order to make decoding efficient.</source>
          <target state="translated">이 메서드는 &lt;code&gt;Codec&lt;/code&gt; 인스턴스에 상태를 저장하지 않을 수 있습니다 . 디코딩 효율성을 높이려면 상태를 유지해야하는 코덱에 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a08138c0bcfef877567ac8386b6733c420584b5" translate="yes" xml:space="preserve">
          <source>The method may not store state in the &lt;code&gt;Codec&lt;/code&gt; instance. Use &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; for codecs which have to keep state in order to make encoding efficient.</source>
          <target state="translated">이 메서드는 &lt;code&gt;Codec&lt;/code&gt; 인스턴스에 상태를 저장하지 않을 수 있습니다 . 인코딩 효율을 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 려면 상태를 유지해야하는 코덱에 StreamWriter 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad825fbf3f4f294e19bd5348abedf12ddc3246f9" translate="yes" xml:space="preserve">
          <source>The method optionally resolves &lt;em&gt;name&lt;/em&gt; relative to the given &lt;em&gt;module&lt;/em&gt;.</source>
          <target state="translated">이 메소드는 선택적 으로 주어진 &lt;em&gt;모듈에&lt;/em&gt; 상대적인 &lt;em&gt;이름&lt;/em&gt; 을 분석합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c433323e1ca328cb9e02211bfe128ac4d1e1435" translate="yes" xml:space="preserve">
          <source>The method raises a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; when called on the same context object from more than one OS thread, or when called recursively.</source>
          <target state="translated">이 메소드 는 둘 이상의 OS 스레드에서 동일한 컨텍스트 오브젝트에서 호출되거나 재귀 적으로 호출 될 때 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="56cdda3811549aac6c6fde1658bb9b7a3746720d" translate="yes" xml:space="preserve">
          <source>The method should be used along with the &lt;code&gt;drain()&lt;/code&gt; method:</source>
          <target state="translated">이 메소드는 &lt;code&gt;drain()&lt;/code&gt; 메소드 와 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="585eb4c0157e3caf086dd969d73a6de334b1cea7" translate="yes" xml:space="preserve">
          <source>The method should be used along with the &lt;code&gt;wait_closed()&lt;/code&gt; method:</source>
          <target state="translated">이 메소드는 &lt;code&gt;wait_closed()&lt;/code&gt; 메소드 와 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="76b503a5a7d6a125a51f118aac931c562926f71b" translate="yes" xml:space="preserve">
          <source>The method should only return a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object, with the preference being for &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 만 리턴해야 하며 환경 설정은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c5e56105cade18e15926c49791daea205907abe9" translate="yes" xml:space="preserve">
          <source>The method should use a greedy read strategy meaning that it should read as much data as is allowed within the definition of the encoding and the given size, e.g. if optional encoding endings or state markers are available on the stream, these should be read too.</source>
          <target state="translated">이 방법은 욕심이 많은 읽기 전략을 사용해야합니다. 즉, 인코딩의 정의 및 지정된 크기 내에서 허용되는만큼의 데이터를 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="824fc392e421ad586bba91aacdb284e674a0b48b" translate="yes" xml:space="preserve">
          <source>The method uses high-performance &lt;a href=&quot;os#os.sendfile&quot;&gt;&lt;code&gt;os.sendfile()&lt;/code&gt;&lt;/a&gt; if available.</source>
          <target state="translated">이 방법은 가능한 경우 고성능 &lt;a href=&quot;os#os.sendfile&quot;&gt; &lt;code&gt;os.sendfile()&lt;/code&gt; &lt;/a&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cc2a40ae8205a9d07f2b34d726a06bef532b3722" translate="yes" xml:space="preserve">
          <source>The method writes a list (or any iterable) of bytes to the underlying socket immediately. If that fails, the data is queued in an internal write buffer until it can be sent.</source>
          <target state="translated">이 메소드는 바이트 목록 (또는 반복 가능)을 기본 소켓에 즉시 씁니다. 실패하면 데이터는 전송 될 때까지 내부 쓰기 버퍼에 대기됩니다.</target>
        </trans-unit>
        <trans-unit id="28afad3806cf9a1749a5a2244379a96aad766b9b" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;Turtle.shearfactor()&lt;/code&gt;, &lt;code&gt;Turtle.shapetransform()&lt;/code&gt; and &lt;code&gt;Turtle.get_shapepoly()&lt;/code&gt; have been added. Thus the full range of regular linear transforms is now available for transforming turtle shapes. &lt;code&gt;Turtle.tiltangle()&lt;/code&gt; has been enhanced in functionality: it now can be used to get or set the tiltangle. &lt;code&gt;Turtle.settiltangle()&lt;/code&gt; has been deprecated.</source>
          <target state="translated">&lt;code&gt;Turtle.shearfactor()&lt;/code&gt; , &lt;code&gt;Turtle.shapetransform()&lt;/code&gt; 및 &lt;code&gt;Turtle.get_shapepoly()&lt;/code&gt; 메소드 가 추가되었습니다. 따라서 이제 일반 선형 변환의 전체 범위를 거북이 모양 변환에 사용할 수 있습니다. &lt;code&gt;Turtle.tiltangle()&lt;/code&gt; 기능이 향상되었습니다. 이제 기울기를 얻거나 설정할 수 있습니다. &lt;code&gt;Turtle.settiltangle()&lt;/code&gt; 은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50eb8eb74557b430c7f7bef208a37346eac89284" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;Turtle.tracer()&lt;/code&gt;, &lt;code&gt;Turtle.window_width()&lt;/code&gt; and &lt;code&gt;Turtle.window_height()&lt;/code&gt; have been eliminated. Methods with these names and functionality are now available only as methods of &lt;code&gt;Screen&lt;/code&gt;. The functions derived from these remain available. (In fact already in Python 2.6 these methods were merely duplications of the corresponding &lt;code&gt;TurtleScreen&lt;/code&gt;/&lt;code&gt;Screen&lt;/code&gt;-methods.)</source>
          <target state="translated">&lt;code&gt;Turtle.tracer()&lt;/code&gt; , &lt;code&gt;Turtle.window_width()&lt;/code&gt; 및 &lt;code&gt;Turtle.window_height()&lt;/code&gt; 메소드 가 제거되었습니다. 이러한 이름과 기능을 가진 메소드는 이제 &lt;code&gt;Screen&lt;/code&gt; 메소드로만 사용할 수 있습니다 . 이들에서 파생 된 기능은 계속 사용할 수 있습니다. (실제로 파이썬 2.6에서이 메소드는 해당 &lt;code&gt;TurtleScreen&lt;/code&gt; / &lt;code&gt;Screen&lt;/code&gt; -methods의 복제물 일뿐입니다.)</target>
        </trans-unit>
        <trans-unit id="ac4777934c6a15af517a89f4ad75f7a72c3ab8e1" translate="yes" xml:space="preserve">
          <source>The methods on bytes and bytearray objects don&amp;rsquo;t accept strings as their arguments, just as the methods on strings don&amp;rsquo;t accept bytes as their arguments. For example, you have to write:</source>
          <target state="translated">바이트 및 바이트 배열 객체의 메소드는 문자열의 메소드가 바이트를 인수로 허용하지 않는 것처럼 문자열을 인수로 허용하지 않습니다. 예를 들어 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b81abcc0375f428186cc2027aa18bd9249e0208" translate="yes" xml:space="preserve">
          <source>The minimum number of bytes which can be written without blocking to a pipe when the pipe has been reported as ready for writing by &lt;a href=&quot;#select.select&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#select.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; or another interface in this module. This doesn&amp;rsquo;t apply to other kind of file-like objects such as sockets.</source>
          <target state="translated">파이프가 &lt;a href=&quot;#select.select&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#select.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt; 또는이 모듈의 다른 인터페이스에서 쓸 준비가 된 것으로보고 될 때 파이프를 차단하지 않고 쓸 수있는 최소 바이트 수입니다 . 소켓과 같은 다른 종류의 파일과 같은 객체에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69014cf2a55f92762b7bea0997f10b48877811c0" translate="yes" xml:space="preserve">
          <source>The minimum or maximum supported SSL or TLS version. These are magic constants. Their values don&amp;rsquo;t reflect the lowest and highest available TLS/SSL versions.</source>
          <target state="translated">지원되는 최소 또는 최대 SSL 또는 TLS 버전입니다. 이것들은 마법 상수입니다. 해당 값은 사용 가능한 최저 및 최고 TLS / SSL 버전을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9d3fce18cbb20787a811d963cb69423a477e4c5" translate="yes" xml:space="preserve">
          <source>The minimum width of the column in pixels. The treeview widget will not make the column any smaller than specified by this option when the widget is resized or the user drags a column.</source>
          <target state="translated">열의 최소 너비 (픽셀)입니다. 위젯의 크기가 조정되거나 사용자가 열을 드래그 할 때 트 리뷰 위젯은이 옵션으로 지정된 것보다 열을 작게 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a9f3bed05faef2986dd2a95d7c0d323acd94f4d" translate="yes" xml:space="preserve">
          <source>The minor version number as an integer</source>
          <target state="translated">부 버전 번호는 정수</target>
        </trans-unit>
        <trans-unit id="bba48e189c01aaa37121faac7385d214d5d64e3d" translate="yes" xml:space="preserve">
          <source>The mix-in class comes first, since it overrides a method defined in &lt;a href=&quot;#socketserver.UDPServer&quot;&gt;&lt;code&gt;UDPServer&lt;/code&gt;&lt;/a&gt;. Setting the various attributes also changes the behavior of the underlying server mechanism.</source>
          <target state="translated">믹스 인 클래스는 &lt;a href=&quot;#socketserver.UDPServer&quot;&gt; &lt;code&gt;UDPServer&lt;/code&gt; 에&lt;/a&gt; 정의 된 메소드를 대체하므로 믹스 클래스가 우선합니다 . 다양한 속성을 설정하면 기본 서버 메커니즘의 동작도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3c63694843eba5485a85009c46ec4f198b86c481" translate="yes" xml:space="preserve">
          <source>The mixer object provides two file-like methods:</source>
          <target state="translated">믹서 객체는 두 가지 파일과 같은 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5560aaaadfff00eb625f5638a1a8eba01711ff23" translate="yes" xml:space="preserve">
          <source>The mock classes and the &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; decorators all take arbitrary keyword arguments for configuration. For the &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; decorators the keywords are passed to the constructor of the mock being created. The keyword arguments are for configuring attributes of the mock:</source>
          <target state="translated">모의 클래스와 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 데코레이터는 모두 구성을 위해 임의의 키워드 인수를 사용합니다. 를 들어 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 키워드가 만든 모의 존재의 생성자에 전달되는 장식. 키워드 인수는 모의 속성을 구성하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9119f0209f25543eed17e7cfe366994f21a3a00f" translate="yes" xml:space="preserve">
          <source>The mode as given in the constructor.</source>
          <target state="translated">생성자에 제공된 모드입니다.</target>
        </trans-unit>
        <trans-unit id="fead8a4568bb22b92817cf465c80286ecf5882eb" translate="yes" xml:space="preserve">
          <source>The mode is unique in that it is the only statistic in this package that also applies to nominal (non-numeric) data:</source>
          <target state="translated">모드는이 패키지에서 명목 (비 숫자) 데이터에도 적용되는 유일한 통계라는 점에서 고유합니다.</target>
        </trans-unit>
        <trans-unit id="5a9c3ad59ac9a555e1de1f8b922f093f31f7d536" translate="yes" xml:space="preserve">
          <source>The model is optional: it can appear once or not at all, as for &lt;code&gt;A?&lt;/code&gt;.</source>
          <target state="translated">모델은 선택 사항입니다. &lt;code&gt;A?&lt;/code&gt; 와 마찬가지로 한 번만 표시되거나 전혀 표시되지 않습니다 . .</target>
        </trans-unit>
        <trans-unit id="ff5d61f00488c70597eb518738f38416f575cf71" translate="yes" xml:space="preserve">
          <source>The model must occur one or more times (like &lt;code&gt;A+&lt;/code&gt;).</source>
          <target state="translated">모델은 한 번 이상 발생해야합니다 (예 &lt;code&gt;A+&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d5b52edc5f1e2cb4521dca3df688323ad595e8b0" translate="yes" xml:space="preserve">
          <source>The model must occur zero or more times, as for &lt;code&gt;A*&lt;/code&gt;.</source>
          <target state="translated">모델은 &lt;code&gt;A*&lt;/code&gt; 와 같이 0 회 이상 발생해야합니다 .</target>
        </trans-unit>
        <trans-unit id="77cba885f17e05c951b2dd5d63fc4e199fd1cd3b" translate="yes" xml:space="preserve">
          <source>The modern interface provides:</source>
          <target state="translated">최신 인터페이스는 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="25133f1724d1d2880378d78f6662e244ccff0530" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt; defines the following exception:</source>
          <target state="translated">모듈 &lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 는 다음 예외를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2443b999e9492f46046323a6f3bb1c0562e20886" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt; defines the following functions:</source>
          <target state="translated">모듈 &lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 는 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2cb329685001bf0118f459c195781fb8d8425f8c" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-curses.panel&quot;&gt;&lt;code&gt;curses.panel&lt;/code&gt;&lt;/a&gt; defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-curses.panel&quot;&gt; &lt;code&gt;curses.panel&lt;/code&gt; &lt;/a&gt; 모듈 은 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4938aeaee503440a6b190c0703735a55f42c4751" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-curses.textpad&quot;&gt;&lt;code&gt;curses.textpad&lt;/code&gt;&lt;/a&gt; defines the following function:</source>
          <target state="translated">&lt;a href=&quot;#module-curses.textpad&quot;&gt; &lt;code&gt;curses.textpad&lt;/code&gt; &lt;/a&gt; 모듈 은 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d06fcda76d4c27cc337a6368bc8902e1c11e7814" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-encodings.idna&quot;&gt;&lt;code&gt;encodings.idna&lt;/code&gt;&lt;/a&gt; also implements the nameprep procedure, which performs certain normalizations on host names, to achieve case-insensitivity of international domain names, and to unify similar characters. The nameprep functions can be used directly if desired.</source>
          <target state="translated">&lt;a href=&quot;#module-encodings.idna&quot;&gt; &lt;code&gt;encodings.idna&lt;/code&gt; &lt;/a&gt; 모듈 은 또한 호스트 이름에 대한 특정 정규화를 수행하여 국제 도메인 이름의 대소 문자를 구분하지 않고 유사한 문자를 통합하는 nameprep 프로 시저를 구현합니다. 원하는 경우 nameprep 기능을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3bd4aa1421879cf9b0033581a365caff952062" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; defines an interactive source code debugger for Python programs. It supports setting (conditional) breakpoints and single stepping at the source line level, inspection of stack frames, source code listing, and evaluation of arbitrary Python code in the context of any stack frame. It also supports post-mortem debugging and can be called under program control.</source>
          <target state="translated">&lt;a href=&quot;#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 모듈 은 Python 프로그램을위한 대화식 소스 코드 디버거를 정의합니다. 소스 라인 레벨에서 (조건부) 중단 점 설정 및 단일 스테핑, 스택 프레임 검사, 소스 코드 목록 및 스택 프레임 컨텍스트에서 임의의 Python 코드 평가를 지원합니다. 또한 사후 디버깅을 지원하며 프로그램 제어하에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e983723789ea50843ec1e624e85924489b7f2738" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; exports the following elements.</source>
          <target state="translated">모듈 &lt;a href=&quot;#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 은 다음 요소를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4186b8db465cd0630f65431378a0685f8c32cc63" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-stringprep&quot;&gt;&lt;code&gt;stringprep&lt;/code&gt;&lt;/a&gt; only exposes the tables from &lt;a href=&quot;https://tools.ietf.org/html/rfc3454.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 3454&lt;/strong&gt;&lt;/a&gt;. As these tables would be very large to represent them as dictionaries or lists, the module uses the Unicode character database internally. The module source code itself was generated using the &lt;code&gt;mkstringprep.py&lt;/code&gt; utility.</source>
          <target state="translated">&lt;a href=&quot;#module-stringprep&quot;&gt; &lt;code&gt;stringprep&lt;/code&gt; &lt;/a&gt; 모듈 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3454.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 3454&lt;/strong&gt;&lt;/a&gt; 의 테이블 만 노출합니다 . 이러한 테이블은 사전 또는 목록으로 표시하기에 매우 크므로 모듈은 내부적으로 유니 코드 문자 데이터베이스를 사용합니다. 모듈 소스 코드 자체는 &lt;code&gt;mkstringprep.py&lt;/code&gt; 유틸리티를 사용하여 생성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3066d03cea2519e31fc6944c2ef0280e8a3f5edf" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;#module-xml.sax.saxutils&quot;&gt;&lt;code&gt;xml.sax.saxutils&lt;/code&gt;&lt;/a&gt; contains a number of classes and functions that are commonly useful when creating SAX applications, either in direct use, or as base classes.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.sax.saxutils&quot;&gt; &lt;code&gt;xml.sax.saxutils&lt;/code&gt; &lt;/a&gt; 모듈 에는 SAX 응용 프로그램을 직접 사용할 때나 기본 클래스로 만들 때 일반적으로 유용한 여러 클래스와 함수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a24325a8da92f6418300a61ad684e7c3219e4b" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;pickletools#module-pickletools&quot;&gt;&lt;code&gt;pickletools&lt;/code&gt;&lt;/a&gt; contains tools for analyzing data streams generated by &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;pickletools#module-pickletools&quot;&gt;&lt;code&gt;pickletools&lt;/code&gt;&lt;/a&gt; source code has extensive comments about opcodes used by pickle protocols.</source>
          <target state="translated">&lt;a href=&quot;pickletools#module-pickletools&quot;&gt; &lt;code&gt;pickletools&lt;/code&gt; &lt;/a&gt; 모듈 에는 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 데이터 스트림을 분석하기위한 도구가 포함되어 있습니다 . &lt;a href=&quot;pickletools#module-pickletools&quot;&gt; &lt;code&gt;pickletools&lt;/code&gt; &lt;/a&gt; 소스 코드에는 pickle 프로토콜에 사용되는 opcode에 대한 광범위한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="87e79ee258eb981db6b59722f4605952f461aff6" translate="yes" xml:space="preserve">
          <source>The module also defines the following classes:</source>
          <target state="translated">이 모듈은 또한 다음 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="dfbfbc47808120cb4d36bd6d5cbe72c7406874fd" translate="yes" xml:space="preserve">
          <source>The module also defines the following utility function:</source>
          <target state="translated">이 모듈은 다음과 같은 유틸리티 기능도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="10da8de05320d7d9ebf7f91666b3ed874229d861" translate="yes" xml:space="preserve">
          <source>The module also offers three general purpose functions based on heaps.</source>
          <target state="translated">이 모듈은 또한 힙 기반의 세 가지 범용 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd45b8cb45b64525fbb0822bfcae6d8d61d1d6e0" translate="yes" xml:space="preserve">
          <source>The module also provides a mapping from numeric codes to names and some functions. The functions mirror definitions in the Python C header files.</source>
          <target state="translated">이 모듈은 또한 숫자 코드에서 이름 및 일부 기능으로의 매핑을 제공합니다. 함수는 Python C 헤더 파일에서 정의를 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="7632aac969612cbc743a75095bf50d39b9f66081" translate="yes" xml:space="preserve">
          <source>The module also provides the following constants which are useful for reading and writing to platform dependent files:</source>
          <target state="translated">이 모듈은 또한 플랫폼 종속 파일을 읽고 쓰는 데 유용한 다음 상수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="26256433c5075bebffac2d143116d0ddcaafdfc1" translate="yes" xml:space="preserve">
          <source>The module also provides the following module level functions:</source>
          <target state="translated">이 모듈은 다음과 같은 모듈 레벨 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c3113214bbd1f1aa3a95681b917ab8b4940c5b52" translate="yes" xml:space="preserve">
          <source>The module defines a large number of constants supplied by the OSS device driver; see &lt;code&gt;&amp;lt;sys/soundcard.h&amp;gt;&lt;/code&gt; on either Linux or FreeBSD for a listing.</source>
          <target state="translated">이 모듈은 OSS 장치 드라이버가 제공하는 많은 상수를 정의합니다. 목록은 Linux 또는 FreeBSD의 &lt;code&gt;&amp;lt;sys/soundcard.h&amp;gt;&lt;/code&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="874b886cf28ca5442c4fa22da2b65c2891e1ea32" translate="yes" xml:space="preserve">
          <source>The module defines several functions, constants, and an exception. Some of the functions are simplified versions of the full featured methods for compiled regular expressions. Most non-trivial applications always use the compiled form.</source>
          <target state="translated">이 모듈은 여러 함수, 상수 및 예외를 정의합니다. 함수 중 일부는 컴파일 된 정규식에 대한 완전한 기능을 갖춘 메서드의 단순화 된 버전입니다. 사소하지 않은 대부분의 응용 프로그램은 항상 컴파일 된 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="22bb70c33812c29fe86af163cf17411e71ac0c78" translate="yes" xml:space="preserve">
          <source>The module defines the following classes, functions and decorators:</source>
          <target state="translated">이 모듈은 다음과 같은 클래스, 함수 및 데코레이터를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fa0bc5b119a58d4964bc11f77b568164a1ee8f73" translate="yes" xml:space="preserve">
          <source>The module defines the following constants:</source>
          <target state="translated">모듈은 다음 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1e2bd5e303f65b85636d423d1c268b91434c1eea" translate="yes" xml:space="preserve">
          <source>The module defines the following exception and functions:</source>
          <target state="translated">이 모듈은 다음 예외 및 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="28331946602f3522c170d92e79d77aadf6102b50" translate="yes" xml:space="preserve">
          <source>The module defines the following exception:</source>
          <target state="translated">모듈은 다음 예외를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="04d197b522c8fb1994897a0502eca8e1b62677d9" translate="yes" xml:space="preserve">
          <source>The module defines the following functions for encoding and decoding with any codec:</source>
          <target state="translated">이 모듈은 모든 코덱으로 인코딩 및 디코딩하기 위해 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="03fb19e5c04074af2e18bbfdaaba5da6c47f9a34" translate="yes" xml:space="preserve">
          <source>The module defines the following functions:</source>
          <target state="translated">모듈은 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="077cfa2f585fd44d642ae51f30fe4f6254171144" translate="yes" xml:space="preserve">
          <source>The module defines the following functions; each enters the debugger in a slightly different way:</source>
          <target state="translated">이 모듈은 다음 기능을 정의합니다. 각각 약간 다른 방식으로 디버거에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="9faf40e36b0fcbb8576f18a93767aef44a3d28fc" translate="yes" xml:space="preserve">
          <source>The module defines the following items:</source>
          <target state="translated">모듈은 다음 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7172f69171db018c6e148890d56725f00ac93410" translate="yes" xml:space="preserve">
          <source>The module defines the following type:</source>
          <target state="translated">모듈은 다음 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="797cb1411b4f0a2f0d2319e98ec5905a710d20f2" translate="yes" xml:space="preserve">
          <source>The module defines the following user-callable items:</source>
          <target state="translated">이 모듈은 다음과 같은 사용자 호출 가능 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f0b5d68256b4702545d5eef364d354d70d851d74" translate="yes" xml:space="preserve">
          <source>The module defines the following variables and functions:</source>
          <target state="translated">모듈은 다음 변수 및 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="846edea72d8187506a3a85ac91eaaf40568fd3d2" translate="yes" xml:space="preserve">
          <source>The module defines the following:</source>
          <target state="translated">모듈은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="23d3546c1aa2d6673cb447d510e6b9aa78754bfa" translate="yes" xml:space="preserve">
          <source>The module defines these functions:</source>
          <target state="translated">모듈은 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b71bb3aab4367a23da4a8face4e42418b941f5a4" translate="yes" xml:space="preserve">
          <source>The module defines three convenience functions and a public class:</source>
          <target state="translated">이 모듈은 세 가지 편의 기능과 공개 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f42cb09269534ec707850d964bd72f320fff3915" translate="yes" xml:space="preserve">
          <source>The module defines two convenience functions:</source>
          <target state="translated">이 모듈은 두 가지 편의 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cbf10bb8aed90ee97ac3f1f31c84be5fe46466e5" translate="yes" xml:space="preserve">
          <source>The module design is centered around three concepts: the decimal number, the context for arithmetic, and signals.</source>
          <target state="translated">모듈 설계는 10 가지 숫자, 산술의 맥락 및 신호의 세 가지 개념을 중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="7ce8d6264a82945a8b381b44276c79dc40baf0f1" translate="yes" xml:space="preserve">
          <source>The module docstring, and all function, class and method docstrings are searched. Objects imported into the module are not searched.</source>
          <target state="translated">모듈 docstring과 모든 함수, 클래스 및 메소드 docstring이 검색됩니다. 모듈로 가져온 개체는 검색되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="144730e48592891534a7774df14c8076adc731ab" translate="yes" xml:space="preserve">
          <source>The module formerly strictly applied the parsing rules described in the &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2068.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2068&lt;/strong&gt;&lt;/a&gt; specifications. It has since been discovered that MSIE 3.0x doesn&amp;rsquo;t follow the character rules outlined in those specs and also many current day browsers and servers have relaxed parsing rules when comes to Cookie handling. As a result, the parsing rules used are a bit less strict.</source>
          <target state="translated">이 모듈은 이전에 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2068&lt;/strong&gt;&lt;/a&gt; 사양에 설명 된 구문 분석 규칙을 엄격하게 적용했습니다 . MSIE 3.0x는 해당 사양에 요약 된 문자 규칙을 따르지 않으며 쿠키 처리와 관련하여 현재의 많은 브라우저와 서버가 구문 분석 규칙을 완화했습니다. 결과적으로 사용되는 구문 분석 규칙은 조금 덜 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="327780fdbc21e230d1a3bec2f2a9a960d5fea278" translate="yes" xml:space="preserve">
          <source>The module has been designed to match the Internet RFC on Relative Uniform Resource Locators. It supports the following URL schemes: &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;ftp&lt;/code&gt;, &lt;code&gt;gopher&lt;/code&gt;, &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;https&lt;/code&gt;, &lt;code&gt;imap&lt;/code&gt;, &lt;code&gt;mailto&lt;/code&gt;, &lt;code&gt;mms&lt;/code&gt;, &lt;code&gt;news&lt;/code&gt;, &lt;code&gt;nntp&lt;/code&gt;, &lt;code&gt;prospero&lt;/code&gt;, &lt;code&gt;rsync&lt;/code&gt;, &lt;code&gt;rtsp&lt;/code&gt;, &lt;code&gt;rtspu&lt;/code&gt;, &lt;code&gt;sftp&lt;/code&gt;, &lt;code&gt;shttp&lt;/code&gt;, &lt;code&gt;sip&lt;/code&gt;, &lt;code&gt;sips&lt;/code&gt;, &lt;code&gt;snews&lt;/code&gt;, &lt;code&gt;svn&lt;/code&gt;, &lt;code&gt;svn+ssh&lt;/code&gt;, &lt;code&gt;telnet&lt;/code&gt;, &lt;code&gt;wais&lt;/code&gt;, &lt;code&gt;ws&lt;/code&gt;, &lt;code&gt;wss&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 상대 균일 자원 로케이터의 인터넷 RFC와 일치하도록 설계되었습니다. 에는 다음과 같은 URL 체계 지원 &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;gopher&lt;/code&gt; , &lt;code&gt;hdl&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;https&lt;/code&gt; , &lt;code&gt;imap&lt;/code&gt; , &lt;code&gt;mailto&lt;/code&gt; , &lt;code&gt;mms&lt;/code&gt; , &lt;code&gt;news&lt;/code&gt; , &lt;code&gt;nntp&lt;/code&gt; , &lt;code&gt;prospero&lt;/code&gt; , &lt;code&gt;rsync&lt;/code&gt; 를 , &lt;code&gt;rtsp&lt;/code&gt; , &lt;code&gt;rtspu&lt;/code&gt; , &lt;code&gt;sftp&lt;/code&gt; , &lt;code&gt;shttp&lt;/code&gt; , &lt;code&gt;sip&lt;/code&gt; , &lt;code&gt;sips&lt;/code&gt; , &lt;code&gt;snews&lt;/code&gt; , &lt;code&gt;svn&lt;/code&gt; , &lt;code&gt;svn+ssh&lt;/code&gt; , &lt;code&gt;telnet&lt;/code&gt; , &lt;code&gt;wais&lt;/code&gt; , &lt;code&gt;ws&lt;/code&gt; , &lt;code&gt;wss&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="76729a25113538074db3b866bb591de93f852e4c" translate="yes" xml:space="preserve">
          <source>The module implements both the normal and wide char variants of the console I/O api. The normal API deals only with ASCII characters and is of limited use for internationalized applications. The wide char API should be used where ever possible.</source>
          <target state="translated">이 모듈은 콘솔 I / O API의 일반 및 넓은 문자 변형을 모두 구현합니다. 일반 API는 ASCII 문자 만 다루며 국제화 된 응용 프로그램에는 제한적으로 사용됩니다. 가능한 한 넓은 char API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="43ce36ef0159d93cc580fcb8d164ea5586169132" translate="yes" xml:space="preserve">
          <source>The module implements three types of queue, which differ only in the order in which the entries are retrieved. In a</source>
          <target state="translated">이 모듈은 3 가지 유형의 대기열을 구현하며 이는 항목을 검색하는 순서 만 다릅니다. 안에</target>
        </trans-unit>
        <trans-unit id="57cf9e8efb9e3806082960f0bfba16594e49075f" translate="yes" xml:space="preserve">
          <source>The module is implemented in C, so tracebacks can be dumped on a crash or when Python is deadlocked.</source>
          <target state="translated">이 모듈은 C로 구현되므로 충돌시 또는 Python이 교착 상태 일 때 역 추적을 덤프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c321b755a7aa4091e7f4f0f69a897d2098d18f55" translate="yes" xml:space="preserve">
          <source>The module is not intended to be a competitor to third-party libraries such as &lt;a href=&quot;https://numpy.org&quot;&gt;NumPy&lt;/a&gt;, &lt;a href=&quot;https://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt;, or proprietary full-featured statistics packages aimed at professional statisticians such as Minitab, SAS and Matlab. It is aimed at the level of graphing and scientific calculators.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;https://numpy.org&quot;&gt;NumPy&lt;/a&gt; , &lt;a href=&quot;https://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; 와 같은 타사 라이브러리 또는 Minitab, SAS 및 Matlab과 같은 전문 통계 전문가를 대상으로하는 독점 기능의 통계 패키지 와 경쟁하기위한 것이 아닙니다 . 그것은 그래프와 과학적인 계산기의 수준을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="bc2e95cd9451b2f645a6d48cdda1e50df7673e41" translate="yes" xml:space="preserve">
          <source>The module itself defines the following classes:</source>
          <target state="translated">모듈 자체는 다음 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5bb598384008e20326380dc11bbe32d2e3c184cc" translate="yes" xml:space="preserve">
          <source>The module provides a lot of functionality and flexibility. If you are unfamiliar with logging, the best way to get to grips with it is to see the tutorials (see the links on the right).</source>
          <target state="translated">이 모듈은 많은 기능과 유연성을 제공합니다. 로깅에 익숙하지 않은 경우이를 파악하는 가장 좋은 방법은 자습서를 보는 것입니다 (오른쪽의 링크 참조).</target>
        </trans-unit>
        <trans-unit id="7bbc30796bf82c1c05869cf1c54c501ab4786bfc" translate="yes" xml:space="preserve">
          <source>The module provides one class and a number of convenience functions. The functions are the normal interface to this module, but some applications may be interested in the class as well.</source>
          <target state="translated">이 모듈은 하나의 클래스와 여러 편의 기능을 제공합니다. 함수는이 모듈에 대한 일반적인 인터페이스이지만 일부 응용 프로그램은 클래스에 관심이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecbbdca511a87b0445a0a413d2ba76a0ce3e03cb" translate="yes" xml:space="preserve">
          <source>The module provides the following classes:</source>
          <target state="translated">이 모듈은 다음과 같은 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3f5bf5944eaee91afafc2c41d0d2f7a13c18742d" translate="yes" xml:space="preserve">
          <source>The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an &amp;ldquo;iterator algebra&amp;rdquo; making it possible to construct specialized tools succinctly and efficiently in pure Python.</source>
          <target state="translated">이 모듈은 자체적으로 또는 조합하여 유용한 빠르고 메모리 효율적인 도구의 핵심 세트를 표준화합니다. 이들은 함께 &quot;반복 대수&quot;를 형성하여 순수 Python에서 간결하고 효율적으로 특수 도구를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb9e4d7a7f1d7376cefe551b30ee86b73aa9553" translate="yes" xml:space="preserve">
          <source>The module supplies the following functions, patterned on those in the standard C library:</source>
          <target state="translated">이 모듈은 표준 C 라이브러리의 기능에 따라 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8fe5969af5cdee1c4049ceb5b572e2560cd4c8d6" translate="yes" xml:space="preserve">
          <source>The module uses a global variable to store the name of the directory used for temporary files returned by &lt;a href=&quot;#tempfile.gettempdir&quot;&gt;&lt;code&gt;gettempdir()&lt;/code&gt;&lt;/a&gt;. It can be set directly to override the selection process, but this is discouraged. All functions in this module take a &lt;em&gt;dir&lt;/em&gt; argument which can be used to specify the directory and this is the recommended approach.</source>
          <target state="translated">모듈은 전역 변수를 사용하여 &lt;a href=&quot;#tempfile.gettempdir&quot;&gt; &lt;code&gt;gettempdir()&lt;/code&gt; &lt;/a&gt; 리턴 한 임시 파일에 사용되는 디렉토리 이름을 저장합니다 . 선택 프로세스를 무시하도록 직접 설정할 수 있지만 권장하지 않습니다. 이 모듈의 모든 함수 는 디렉토리를 지정하는 데 사용할 수 있는 &lt;em&gt;dir&lt;/em&gt; 인수를 사용하며 이는 권장되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="873a3b05cc0bf1b3ee771cf844e30c4aaee942f0" translate="yes" xml:space="preserve">
          <source>The module uses the same names and symbols as defined by Unicode Standard Annex #44, &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;&amp;ldquo;Unicode Character Database&amp;rdquo;&lt;/a&gt;. It defines the following functions:</source>
          <target state="translated">이 모듈은 Unicode Standard Annex # 44, &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;&quot;Unicode Character Database&quot;에서&lt;/a&gt; 정의한 것과 동일한 이름과 기호를 사용합니다 . 다음과 같은 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e0426603301ba7e1a6fdf07a67502a7212daf5ae" translate="yes" xml:space="preserve">
          <source>The module uses traceback objects &amp;mdash; this is the object type that is stored in the &lt;a href=&quot;sys#sys.last_traceback&quot;&gt;&lt;code&gt;sys.last_traceback&lt;/code&gt;&lt;/a&gt; variable and returned as the third item from &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 트레이스 백 객체를 사용합니다. 이것은 &lt;a href=&quot;sys#sys.last_traceback&quot;&gt; &lt;code&gt;sys.last_traceback&lt;/code&gt; &lt;/a&gt; 변수에 저장되고 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 에서 세 번째 항목으로 반환되는 객체 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="c9ff4e08b4b410516a4ba604c2ad0d2319f9bcd3" translate="yes" xml:space="preserve">
          <source>The module&amp;rsquo;s public names (its API) are detected automatically based on whether they match the public name convention and were defined in &lt;em&gt;module&lt;/em&gt;.</source>
          <target state="translated">모듈의 공개 이름 (API)은 공개 이름 규칙과 일치하고 &lt;em&gt;module&lt;/em&gt; 에 정의되어 있는지 여부에 따라 자동으로 감지됩니다 .</target>
        </trans-unit>
        <trans-unit id="64f2b1f04817a07aefdf123adb04ad0457bb4f80" translate="yes" xml:space="preserve">
          <source>The modules described in this chapter deal with disk files and directories. For example, there are modules for reading the properties of files, manipulating paths in a portable way, and creating temporary files. The full list of modules in this chapter is:</source>
          <target state="translated">이 장에서 설명하는 모듈은 디스크 파일 및 디렉토리를 처리합니다. 예를 들어, 파일의 속성을 읽고, 이식 가능한 방식으로 경로를 조작하고, 임시 파일을 작성하기위한 모듈이 있습니다. 이 장의 전체 모듈 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db934eb9e1a19c8294f8b8fd51f11e31549e6d50" translate="yes" xml:space="preserve">
          <source>The modules described in this chapter help you write software. For example, the &lt;a href=&quot;pydoc#module-pydoc&quot;&gt;&lt;code&gt;pydoc&lt;/code&gt;&lt;/a&gt; module takes a module and generates documentation based on the module&amp;rsquo;s contents. The &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; modules contains frameworks for writing unit tests that automatically exercise code and verify that the expected output is produced. &lt;strong&gt;2to3&lt;/strong&gt; can translate Python 2.x source code into valid Python 3.x code.</source>
          <target state="translated">이 장에서 설명하는 모듈은 소프트웨어 작성에 도움이됩니다. 예를 들어, &lt;a href=&quot;pydoc#module-pydoc&quot;&gt; &lt;code&gt;pydoc&lt;/code&gt; &lt;/a&gt; 모듈은 모듈을 가져 와서 모듈의 내용에 따라 문서를 생성합니다. &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; 가&lt;/a&gt; 및 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 모듈은 자동 코드를 행사하고 예상 출력이 생성되는 것을 확인 유닛 테스트를 작성하기위한 프레임 워크를 포함한다. &lt;strong&gt;2to3&lt;/strong&gt; 은 Python 2.x 소스 코드를 유효한 Python 3.x 코드로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e092e37848f0a1fc4fbb491bdcd7194396632b1c" translate="yes" xml:space="preserve">
          <source>The modulus (absolute value) of a complex number &lt;em&gt;x&lt;/em&gt; can be computed using the built-in &lt;a href=&quot;functions#abs&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; function. There is no separate &lt;a href=&quot;#module-cmath&quot;&gt;&lt;code&gt;cmath&lt;/code&gt;&lt;/a&gt; module function for this operation.</source>
          <target state="translated">복소수 &lt;em&gt;x&lt;/em&gt; 의 모듈러스 (절대 값) 는 내장 &lt;a href=&quot;functions#abs&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 계산할 수 있습니다 . 이 작업 에는 별도의 &lt;a href=&quot;#module-cmath&quot;&gt; &lt;code&gt;cmath&lt;/code&gt; &lt;/a&gt; 모듈 기능 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="526f0ffb4f4e5a8eba7594ed625d05dfc267705d" translate="yes" xml:space="preserve">
          <source>The month&amp;rsquo;s head CSS class (used by &lt;code&gt;formatmonthname()&lt;/code&gt;). The default value is &lt;code&gt;&quot;month&quot;&lt;/code&gt;.</source>
          <target state="translated">월 헤드 CSS 클래스입니다 ( &lt;code&gt;formatmonthname()&lt;/code&gt; 의해 사용됨 ). 기본값은 &lt;code&gt;&quot;month&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29a496cdc2a9331c2ac2e678e90aef6f660f6ab5" translate="yes" xml:space="preserve">
          <source>The most common exception raised is &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;. This occurs, for example, when trying to execute a non-existent file. Applications should prepare for &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">가장 일반적인 예외는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 입니다. 예를 들어 존재하지 않는 파일을 실행하려고 할 때 발생합니다. 응용 프로그램은 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외를 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f236c249aa0f9c62bcc369ec81c61a6eb8efb720" translate="yes" xml:space="preserve">
          <source>The most common way to change the way a specific config parser works is to use the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; options:</source>
          <target state="translated">특정 구성 파서의 작동 방식을 변경하는 가장 일반적인 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 옵션 을 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6d76a43b379d5d84db61af7a51ae23477afde169" translate="yes" xml:space="preserve">
          <source>The most interesting thing about Enum members is that they are singletons. &lt;code&gt;EnumMeta&lt;/code&gt; creates them all while it is creating the &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; class itself, and then puts a custom &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; in place to ensure that no new ones are ever instantiated by returning only the existing member instances.</source>
          <target state="translated">Enum 멤버에 대한 가장 흥미로운 점은 싱글 톤이라는 것입니다. &lt;code&gt;EnumMeta&lt;/code&gt; 는 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 클래스 자체를 만드는 동안 모든 것을 만든 다음 기존 멤버 인스턴스 만 반환하여 새 인스턴스가 인스턴스화되지 않도록 사용자 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="d4a7c3338a4e761bd7ca0d534f01fb72fa39a84f" translate="yes" xml:space="preserve">
          <source>The most negative &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object, &lt;code&gt;timedelta(-999999999)&lt;/code&gt;.</source>
          <target state="translated">가장 부정적인 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체, &lt;code&gt;timedelta(-999999999)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="065b9d8aa9a053eb2fe7a09a04119c39efa897ef" translate="yes" xml:space="preserve">
          <source>The most positive &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object, &lt;code&gt;timedelta(days=999999999,
hours=23, minutes=59, seconds=59, microseconds=999999)&lt;/code&gt;.</source>
          <target state="translated">가장 긍정적 인 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체 인 &lt;code&gt;timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2fc1fc1cf5fe2c4bd12bd6e4ce5cdacc7f82bf2b" translate="yes" xml:space="preserve">
          <source>The most powerful tool for doing this is &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt;&lt;code&gt;XMLPullParser&lt;/code&gt;&lt;/a&gt;. It does not require a blocking read to obtain the XML data, and is instead fed with data incrementally with &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.feed&quot;&gt;&lt;code&gt;XMLPullParser.feed()&lt;/code&gt;&lt;/a&gt; calls. To get the parsed XML elements, call &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.read_events&quot;&gt;&lt;code&gt;XMLPullParser.read_events()&lt;/code&gt;&lt;/a&gt;. Here is an example:</source>
          <target state="translated">이를 수행하는 가장 강력한 도구는 &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt; &lt;code&gt;XMLPullParser&lt;/code&gt; &lt;/a&gt; 입니다. XML 데이터를 얻기 위해 블로킹 읽기가 필요하지 않으며 대신 &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.feed&quot;&gt; &lt;code&gt;XMLPullParser.feed()&lt;/code&gt; &lt;/a&gt; 호출을 통해 점진적으로 데이터가 제공됩니다 . 파싱 ​​된 XML 요소를 가져 오려면 &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser.read_events&quot;&gt; &lt;code&gt;XMLPullParser.read_events()&lt;/code&gt; &lt;/a&gt; 호출 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4e41ec1f03689ec5bfa5a8d19acc3479730130" translate="yes" xml:space="preserve">
          <source>The most recent supported protocol in the &lt;code&gt;CAPABILITY&lt;/code&gt; response from the server.</source>
          <target state="translated">서버 의 &lt;code&gt;CAPABILITY&lt;/code&gt; 응답에서 가장 최근에 지원되는 프로토콜입니다 .</target>
        </trans-unit>
        <trans-unit id="927eea60c2a0e72cc4b32dd44e266c02dfd67281" translate="yes" xml:space="preserve">
          <source>The most useful way to define a &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; class is by subclassing from &lt;a href=&quot;#http.cookiejar.DefaultCookiePolicy&quot;&gt;&lt;code&gt;DefaultCookiePolicy&lt;/code&gt;&lt;/a&gt; and overriding some or all of the methods above. &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; itself may be used as a &amp;lsquo;null policy&amp;rsquo; to allow setting and receiving any and all cookies (this is unlikely to be useful).</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 클래스 를 정의하는 가장 유용한 방법 은 &lt;a href=&quot;#http.cookiejar.DefaultCookiePolicy&quot;&gt; &lt;code&gt;DefaultCookiePolicy&lt;/code&gt; &lt;/a&gt; 에서 서브 클래 싱하고 위의 일부 또는 모든 메서드를 재정의하는 것입니다. &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 자체는 '널 정책'으로 사용되어 모든 쿠키를 설정하고 수신 할 수 있습니다 (유용하지는 않음).</target>
        </trans-unit>
        <trans-unit id="3ce4cd7369a4eb79feb821d03c53f93b4bfb15f9" translate="yes" xml:space="preserve">
          <source>The mouse cursor is over the widget and pressing a mouse button will cause some action to occur</source>
          <target state="translated">마우스 커서가 위젯 위에 있으며 마우스 버튼을 누르면 일부 동작이 발생합니다</target>
        </trans-unit>
        <trans-unit id="44bdca45752dc48424aca038859a3e42e33af078" translate="yes" xml:space="preserve">
          <source>The multiset methods are designed only for use cases with positive values. The inputs may be negative or zero, but only outputs with positive values are created. There are no type restrictions, but the value type needs to support addition, subtraction, and comparison.</source>
          <target state="translated">다중 집합 방법은 양수 값을 가진 사용 사례에 대해서만 설계되었습니다. 입력은 음수이거나 0 일 수 있지만 양수 값의 출력 만 작성됩니다. 유형 제한은 없지만 값 유형은 더하기, 빼기 및 비교를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="3648c79f0c384a3cba9219a88d81aad0bc5f8b11" translate="yes" xml:space="preserve">
          <source>The name and value are returned unmodified.</source>
          <target state="translated">이름과 값은 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b826691f5f47e95bb5fa8eb238fbc74cce086503" translate="yes" xml:space="preserve">
          <source>The name is parsed as everything up to the &amp;lsquo;&lt;code&gt;:&lt;/code&gt;&amp;rsquo; and returned unmodified. The value is determined by stripping leading whitespace off the remainder of the first line, joining all subsequent lines together, and stripping any trailing carriage return or linefeed characters.</source>
          <target state="translated">이름은 ' &lt;code&gt;:&lt;/code&gt; ' 까지 모든 것으로 구문 분석되고 수정되지 않은 상태로 리턴됩니다. 값은 첫 번째 행의 나머지 행에서 선행 공백을 제거하고 모든 후속 행을 결합하여 후행 캐리지 리턴 또는 줄 바꿈 문자를 제거하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b50692e1777fdc3c0cea5009d79bb612176f1d8e" translate="yes" xml:space="preserve">
          <source>The name is returned unchanged. If the input value has a &lt;code&gt;name&lt;/code&gt; attribute and it matches &lt;em&gt;name&lt;/em&gt; ignoring case, the value is returned unchanged. Otherwise the &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; are passed to &lt;code&gt;header_factory&lt;/code&gt;, and the resulting header object is returned as the value. In this case a &lt;code&gt;ValueError&lt;/code&gt; is raised if the input value contains CR or LF characters.</source>
          <target state="translated">이름은 변경되지 않고 반환됩니다. 입력 값이있는 경우 &lt;code&gt;name&lt;/code&gt; 속성과 일치 &lt;em&gt;이름&lt;/em&gt; 대소 값은 그대로 리턴된다. 그렇지 않으면 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 이 &lt;code&gt;header_factory&lt;/code&gt; 로 전달되고 결과 헤더 객체가 값으로 반환됩니다. 이 경우 입력 값에 CR 또는 LF 문자가 포함되어 있으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="12d8c7bcddc467b764e4f4421f5577f57726ccd3" translate="yes" xml:space="preserve">
          <source>The name of a child window</source>
          <target state="translated">자식 창의 이름</target>
        </trans-unit>
        <trans-unit id="2524a5cebcbdfb771179b6a0e664c17235b2ec37" translate="yes" xml:space="preserve">
          <source>The name of a directory, or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt; referring to a directory, in which case a new application archive will be created from the content of that directory.</source>
          <target state="translated">디렉토리의 이름 또는 디렉토리를 참조 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한 객체&lt;/a&gt; 입니다.이 경우 해당 디렉토리의 컨텐츠에서 새 애플리케이션 아카이브가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3348a0d948f72103aa59b0cbb79cb0826f47dd61" translate="yes" xml:space="preserve">
          <source>The name of an existing application archive file, or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt; referring to such a file, in which case the file is copied to the target (modifying it to reflect the value given for the &lt;em&gt;interpreter&lt;/em&gt; argument). The file name should include the &lt;code&gt;.pyz&lt;/code&gt; extension, if required.</source>
          <target state="translated">기존 애플리케이션 아카이브 파일의 이름 또는 이러한 파일을 참조 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한 오브젝트&lt;/a&gt; 입니다.이 경우 파일이 대상에 복사됩니다 ( &lt;em&gt;인터프리터&lt;/em&gt; 인수에 제공된 값을 반영하도록 수정 ). 필요한 경우 파일 이름에 &lt;code&gt;.pyz&lt;/code&gt; 확장자 가 포함되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f9f838b30f9b77d8336536f5c6f4b31fe69bc9b8" translate="yes" xml:space="preserve">
          <source>The name of the Python codec used to convert Unicode to the &lt;em&gt;output_charset&lt;/em&gt;. If no conversion codec is necessary, this attribute will have the same value as the &lt;em&gt;input_codec&lt;/em&gt;.</source>
          <target state="translated">유니 코드를 &lt;em&gt;output_charset&lt;/em&gt; 로 변환하는 데 사용되는 Python 코덱의 이름입니다 . 변환 코덱이 필요하지 않은 경우이 속성의 값은 &lt;em&gt;input_codec&lt;/em&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1b7d36949b7dbdaceda289403bc4995730e79876" translate="yes" xml:space="preserve">
          <source>The name of the Python codec used to convert the &lt;em&gt;input_charset&lt;/em&gt; to Unicode. If no conversion codec is necessary, this attribute will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;input_charset&lt;/em&gt; 을 유니 코드 로 변환하는 데 사용되는 Python 코덱의 이름입니다 . 변환 코덱이 필요하지 않은 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20e49cc2b4a055cc134803db32c1f3315bbe22f9" translate="yes" xml:space="preserve">
          <source>The name of the class, function, method, descriptor, or generator instance.</source>
          <target state="translated">클래스, 함수, 메서드, 설명자 또는 생성기 인스턴스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9c2d757ce27c67d976e0bb232ff208d435247d6f" translate="yes" xml:space="preserve">
          <source>The name of the class.</source>
          <target state="translated">수업 이름.</target>
        </trans-unit>
        <trans-unit id="cf0e82e792056159c3d15446c1c3ba19cf054ab2" translate="yes" xml:space="preserve">
          <source>The name of the cookie.</source>
          <target state="translated">쿠키의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="db2786e8b64a4f2a93fc7639bce370526d3004c5" translate="yes" xml:space="preserve">
          <source>The name of the current input file, as initially set at class instantiation time or stacked by later source requests. It may be useful to examine this when constructing error messages.</source>
          <target state="translated">클래스 인스턴스화 시간에 처음 설정되거나 이후 소스 요청에 의해 누적 된 현재 입력 파일의 이름입니다. 오류 메시지를 구성 할 때이를 검사하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87a5c766718310779911b628faec33c39699db12" translate="yes" xml:space="preserve">
          <source>The name of the encoding that raised the error.</source>
          <target state="translated">오류가 발생한 인코딩의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="eccb9096ed9393aa7f6cd784f1b309a8d579285f" translate="yes" xml:space="preserve">
          <source>The name of the encoding used to decode the stream&amp;rsquo;s bytes into strings, and to encode strings into bytes.</source>
          <target state="translated">스트림의 바이트를 문자열로 디코딩하고 문자열을 바이트로 인코딩하는 데 사용되는 인코딩의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c0f51ba3fc7703bf9d455ad50fbda867f667dbbb" translate="yes" xml:space="preserve">
          <source>The name of the encoding.</source>
          <target state="translated">인코딩의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5c6420b071c114d8b7b1869e27cd2b6ac4b63af8" translate="yes" xml:space="preserve">
          <source>The name of the file that this &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; was extracted from; or &lt;code&gt;None&lt;/code&gt; if the filename is unknown, or if the &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; was not extracted from a file.</source>
          <target state="translated">이 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 가 추출 된 파일의 이름입니다 . 또는 파일 이름을 알 수 없거나 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 가 파일에서 추출되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="42c158643e80bd25167c62593a8c6b69e164e4b7" translate="yes" xml:space="preserve">
          <source>The name of the function or method which invoked the logging call.</source>
          <target state="translated">로깅 호출을 호출 한 함수 또는 메소드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8d24347b639fc5c1199b8f3590bff6a146e13c82" translate="yes" xml:space="preserve">
          <source>The name of the function.</source>
          <target state="translated">함수의 이름</target>
        </trans-unit>
        <trans-unit id="d968ec93775a8147339e1197e1ba03690ce8d68c" translate="yes" xml:space="preserve">
          <source>The name of the header (the portion of the field before the &amp;lsquo;:&amp;rsquo;). This is exactly the value passed in the &lt;a href=&quot;email.policy#email.policy.EmailPolicy.header_factory&quot;&gt;&lt;code&gt;header_factory&lt;/code&gt;&lt;/a&gt; call for &lt;em&gt;name&lt;/em&gt;; that is, case is preserved.</source>
          <target state="translated">헤더 이름 ( ':'앞의 필드 부분). 이것은 정확하게 &lt;em&gt;이름&lt;/em&gt; 에 대한 &lt;a href=&quot;email.policy#email.policy.EmailPolicy.header_factory&quot;&gt; &lt;code&gt;header_factory&lt;/code&gt; &lt;/a&gt; 호출에 전달 된 값입니다 . 즉, 대소 문자가 유지됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8acf5f3263f7bad6e8395afeee08162402022f0d" translate="yes" xml:space="preserve">
          <source>The name of the last matched capturing group, or &lt;code&gt;None&lt;/code&gt; if the group didn&amp;rsquo;t have a name, or if no group was matched at all.</source>
          <target state="translated">마지막으로 일치하는 캡처 그룹의 이름이거나, 그룹에 이름이 없거나 일치 하는 그룹이없는 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1115953db6f79d6d319ff201aaf3b93a34c34282" translate="yes" xml:space="preserve">
          <source>The name of the library passed in the constructor.</source>
          <target state="translated">생성자에 전달 된 라이브러리의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="529036ebea438d597d7771e0b1b7f5ecbbc43a65" translate="yes" xml:space="preserve">
          <source>The name of the module defining the class described.</source>
          <target state="translated">설명 된 클래스를 정의하는 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f0fb2bc01c4ab3c3a016eb3065876161a9a89e2c" translate="yes" xml:space="preserve">
          <source>The name of the module defining the function described.</source>
          <target state="translated">설명 된 기능을 정의하는 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3e60b1cae575eba27aff3ee963b8aee956952f99" translate="yes" xml:space="preserve">
          <source>The name of the module that this loader will handle.</source>
          <target state="translated">이 로더가 처리 할 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="19557753c33011dd73657399ac0a84fde8d16a56" translate="yes" xml:space="preserve">
          <source>The name of the module the loader can handle.</source>
          <target state="translated">로더가 처리 할 수있는 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1ebe1facb1fd4eb5a2fae30e51ef2797f815a5ec" translate="yes" xml:space="preserve">
          <source>The name of the module the loader will handle.</source>
          <target state="translated">로더가 처리 할 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="045643cb342912e3d066e6c71398cbb7c278f691" translate="yes" xml:space="preserve">
          <source>The name of the module.</source>
          <target state="translated">모듈의 이름</target>
        </trans-unit>
        <trans-unit id="2c0e0654b87b9148ea27c20e6b8314bf71ef32b0" translate="yes" xml:space="preserve">
          <source>The name of the operating system dependent module imported. The following names have currently been registered: &lt;code&gt;'posix'&lt;/code&gt;, &lt;code&gt;'nt'&lt;/code&gt;, &lt;code&gt;'java'&lt;/code&gt;.</source>
          <target state="translated">가져온 운영 체제 종속 모듈의 이름입니다. &lt;code&gt;'posix'&lt;/code&gt; , &lt;code&gt;'nt'&lt;/code&gt; , &lt;code&gt;'java'&lt;/code&gt; 이름이 현재 등록되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b7d3c96f97340449b07e52cbc60ad345dcd6115c" translate="yes" xml:space="preserve">
          <source>The name of the parameter as a string. The name must be a valid Python identifier.</source>
          <target state="translated">매개 변수의 이름입니다 (문자열). 이름은 유효한 Python 식별자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="86c00c3b8d6532630734b7c2b865667da54ac893" translate="yes" xml:space="preserve">
          <source>The name of the reverse DNS PTR record for the IP address, e.g.:</source>
          <target state="translated">IP 주소에 대한 역방향 DNS PTR 레코드의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2f9a4bd744db6b1b83b9fe31ed14622101524f6" translate="yes" xml:space="preserve">
          <source>The name of the root element as given in the &lt;code&gt;DOCTYPE&lt;/code&gt; declaration, if present.</source>
          <target state="translated">&lt;code&gt;DOCTYPE&lt;/code&gt; 선언에 제공된 루트 요소의 이름입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="4bb0420bbf93f8e01944b2eb4478fbeba0d40ebf" translate="yes" xml:space="preserve">
          <source>The name of the variable. This is a read-only property.</source>
          <target state="translated">변수의 이름입니다. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="84bc55391122ae15beaf2e506a637ac5e87b06d7" translate="yes" xml:space="preserve">
          <source>The name of this module stems from a bit of terminology used by the designers of Modula-3 (amongst others), who use the term &amp;ldquo;marshalling&amp;rdquo; for shipping of data around in a self-contained form. Strictly speaking, &amp;ldquo;to marshal&amp;rdquo; means to convert some data from internal to external form (in an RPC buffer for instance) and &amp;ldquo;unmarshalling&amp;rdquo; for the reverse process.</source>
          <target state="translated">이 모듈의 이름은 Modula-3의 디자이너 (다른 것들 중에서도)가 자체적으로 포함 된 형태로 데이터를 전달하기 위해 &quot;마샬링 (marshalling)&quot;이라는 용어를 사용하는 약간의 용어에서 유래합니다. 엄밀히 말하면, &quot;마샬링&quot;은 일부 데이터를 내부에서 외부 형식 (예 : RPC 버퍼)으로 변환하고 역 프로세스를 위해 &quot;비 정렬 화&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="721dc1da17b4562925fc14e95ff70598fc9e2ba4" translate="yes" xml:space="preserve">
          <source>The name supplied in &lt;em&gt;name&lt;/em&gt; is used as a filename and will be displayed as the target of the corresponding symbolic link in the directory &lt;code&gt;/proc/self/fd/&lt;/code&gt;. The displayed name is always prefixed with &lt;code&gt;memfd:&lt;/code&gt; and serves only for debugging purposes. Names do not affect the behavior of the file descriptor, and as such multiple files can have the same name without any side effects.</source>
          <target state="translated">name으로 제공된 &lt;em&gt;이름&lt;/em&gt; 은 파일 &lt;em&gt;이름&lt;/em&gt; 으로 사용되며 &lt;code&gt;/proc/self/fd/&lt;/code&gt; 디렉토리에서 해당 기호 링크의 대상으로 표시됩니다 . 표시된 이름은 항상 &lt;code&gt;memfd:&lt;/code&gt; 시작하며 디버깅 목적으로 만 사용됩니다. 이름은 파일 디스크립터의 동작에 영향을 미치지 않으며 여러 파일이 부작용없이 동일한 이름을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ebb96c87c8e767368b13796ac08bb015cb86556" translate="yes" xml:space="preserve">
          <source>The named element allows a choice from a number of options; this is used for content models such as &lt;code&gt;(A | B | C)&lt;/code&gt;.</source>
          <target state="translated">명명 된 요소는 여러 옵션 중에서 선택할 수 있습니다. 이는 &lt;code&gt;(A | B | C)&lt;/code&gt; 와 같은 컨텐츠 모델에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9ae23519a49f9ee02d709a2efb2fa7ed671948e" translate="yes" xml:space="preserve">
          <source>The named file must be in the format understood by the class, or &lt;a href=&quot;#http.cookiejar.LoadError&quot;&gt;&lt;code&gt;LoadError&lt;/code&gt;&lt;/a&gt; will be raised. Also, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; may be raised, for example if the file does not exist.</source>
          <target state="translated">명명 된 파일은 클래스가 이해하는 형식이어야합니다 . 그렇지 &lt;a href=&quot;#http.cookiejar.LoadError&quot;&gt; &lt;code&gt;LoadError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 또한 파일이 존재하지 않는 경우와 같이 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0be5215b217f6db183e859a83b666d28dd48000" translate="yes" xml:space="preserve">
          <source>The named module and any modules named in the &lt;em&gt;fresh&lt;/em&gt; and &lt;em&gt;blocked&lt;/em&gt; parameters are saved before starting the import and then reinserted into &lt;code&gt;sys.modules&lt;/code&gt; when the fresh import is complete.</source>
          <target state="translated">명명 된 모듈과의라는 이름의 모듈 &lt;em&gt;신선한&lt;/em&gt; 및 &lt;em&gt;차단&lt;/em&gt; 매개 변수는 가져 오기를 시작하기 전에 저장 한 다음에 다시 삽입 &lt;code&gt;sys.modules&lt;/code&gt; 에 신선한 가져 오기가 완료되면.</target>
        </trans-unit>
        <trans-unit id="c10ae2054ff91f5b2cff60c29617df470fe8793c" translate="yes" xml:space="preserve">
          <source>The namer function is called quite a few times during rollover, so it should be as simple and as fast as possible. It should also return the same output every time for a given input, otherwise the rollover behaviour may not work as expected.</source>
          <target state="translated">롤오버 중에는 네임 러 함수가 상당히 여러 번 호출되므로 최대한 간단하고 빠릅니다. 주어진 입력에 대해 매번 동일한 출력을 반환해야합니다. 그렇지 않으면 롤오버 동작이 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="820a071a36af108968f4240003f19a8875a80d53" translate="yes" xml:space="preserve">
          <source>The names &lt;a href=&quot;#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__debug__&quot;&gt;&lt;code&gt;__debug__&lt;/code&gt;&lt;/a&gt; cannot be reassigned (assignments to them, even as an attribute name, raise &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;), so they can be considered &amp;ldquo;true&amp;rdquo; constants.</source>
          <target state="translated">&lt;a href=&quot;#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#__debug__&quot;&gt; &lt;code&gt;__debug__&lt;/code&gt; &lt;/a&gt; 이름 은 재 할당 할 수 없으며 (속성 이름으로도 할당이 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 발생&lt;/a&gt; )&amp;ldquo;true&amp;rdquo;상수로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1c08d7bb555b2944b88a4c6e840df45656fda30" translate="yes" xml:space="preserve">
          <source>The names in the module namespace are updated to point to any new or changed objects.</source>
          <target state="translated">모듈 네임 스페이스의 이름은 새로운 객체 또는 변경된 객체를 가리 키도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c735eec803d17f6970762d55860960d0fb6133f5" translate="yes" xml:space="preserve">
          <source>The namespace (aka globals) that the examples should be run in. This is a dictionary mapping names to values. Any changes to the namespace made by the examples (such as binding new variables) will be reflected in &lt;a href=&quot;#doctest.DocTest.globs&quot;&gt;&lt;code&gt;globs&lt;/code&gt;&lt;/a&gt; after the test is run.</source>
          <target state="translated">예제를 실행해야하는 네임 스페이스 (일명 글로벌). 이름에 값을 사전으로 매핑합니다. 예제에서 만든 네임 스페이스 (예 : 새 변수 바인딩)에 대한 모든 변경 사항 은 테스트가 실행 된 후 &lt;a href=&quot;#doctest.DocTest.globs&quot;&gt; &lt;code&gt;globs&lt;/code&gt; &lt;/a&gt; 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef74b8b6db43c1099d9ae4fe3925ae098b1ab91c" translate="yes" xml:space="preserve">
          <source>The namespace URI associated with the reserved prefix &lt;code&gt;xml&lt;/code&gt;, as defined by &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;Namespaces in XML&lt;/a&gt; (section 4).</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;XML에서 네임 스페이스&lt;/a&gt; 로 정의 된 예약 된 접 두부 &lt;code&gt;xml&lt;/code&gt; 과 연관된 네임 스페이스 URI (섹션 4).</target>
        </trans-unit>
        <trans-unit id="408b2f2cd1d9203ad9f611d7e05aac0b25d2317f" translate="yes" xml:space="preserve">
          <source>The namespace URI for namespace declarations, as defined by &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Core/core.html&quot;&gt;Document Object Model (DOM) Level 2 Core Specification&lt;/a&gt; (section 1.1.8).</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Core/core.html&quot;&gt;DOM (Document Object Model) 레벨 2 핵심 사양에&lt;/a&gt; 정의 된 네임 스페이스 선언의 네임 스페이스 URI (섹션 1.1.8).</target>
        </trans-unit>
        <trans-unit id="45dc23412cbf664771fbe0fc3a54045a54c2ec7a" translate="yes" xml:space="preserve">
          <source>The namespace associated with the element name. This will be a string or &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">요소 이름과 연관된 네임 스페이스입니다. 이것은 문자열이거나 &lt;code&gt;None&lt;/code&gt; 입니다. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="7ebce889cae0e45b57056d1bd6bb2e5431835025" translate="yes" xml:space="preserve">
          <source>The native equivalent of this function is &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_Audit&quot;&gt;&lt;code&gt;PySys_Audit()&lt;/code&gt;&lt;/a&gt;. Using the native function is preferred when possible.</source>
          <target state="translated">이 함수의 기본 기능은 &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_Audit&quot;&gt; &lt;code&gt;PySys_Audit()&lt;/code&gt; &lt;/a&gt; 입니다. 가능한 경우 기본 기능을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60ffd13b4d06a9663d021d63e24603a96ec31f3b" translate="yes" xml:space="preserve">
          <source>The native integral thread ID of this thread. This is a non-negative integer, or &lt;code&gt;None&lt;/code&gt; if the thread has not been started. See the &lt;a href=&quot;#threading.get_native_id&quot;&gt;&lt;code&gt;get_native_id()&lt;/code&gt;&lt;/a&gt; function. This represents the Thread ID (&lt;code&gt;TID&lt;/code&gt;) as assigned to the thread by the OS (kernel). Its value may be used to uniquely identify this particular thread system-wide (until the thread terminates, after which the value may be recycled by the OS).</source>
          <target state="translated">이 스레드의 기본 통합 스레드 ID입니다. 음수가 아닌 정수이거나 스레드가 시작되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;a href=&quot;#threading.get_native_id&quot;&gt; &lt;code&gt;get_native_id()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 . OS (커널)에 의해 스레드에 할당 된 스레드 ID ( &lt;code&gt;TID&lt;/code&gt; )를 나타냅니다 . 이 값은 시스템 전체에서이 특정 스레드를 고유하게 식별하는 데 사용될 수 있습니다 (스레드가 종료 될 때까지 OS에서 값을 재활용 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="c1d7e2c935c2353b159d29ab4523fe1dc780cda0" translate="yes" xml:space="preserve">
          <source>The need for this class has been partially supplanted by the ability to subclass directly from &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;; however, this class can be easier to work with because the underlying list is accessible as an attribute.</source>
          <target state="translated">이 클래스의 필요성은 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 에서 직접 서브 클래스 할 수있는 기능으로 부분적으로 대체되었습니다 . 그러나 기본 목록에 속성으로 액세스 할 수 있으므로이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a85e2fc33e36b45a037532b612a391af51faf61" translate="yes" xml:space="preserve">
          <source>The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input&amp;rsquo;s iterables are sorted, the product tuples are emitted in sorted order.</source>
          <target state="translated">중첩 된 루프는 모든 반복에서 가장 오른쪽 요소가 진행되는 주행 거리계처럼 순환합니다. 이 패턴은 사전 식 순서를 작성하여 입력의 반복 가능 항목을 정렬하면 제품 튜플이 정렬 된 순서로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab7a50dc8c8b2f98d8a0e6811757f5dee27463d" translate="yes" xml:space="preserve">
          <source>The net mask, as an &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt;&lt;code&gt;IPv4Address&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt; &lt;code&gt;IPv4Address&lt;/code&gt; &lt;/a&gt; 객체 로서의 네트 마스크 .</target>
        </trans-unit>
        <trans-unit id="762e0fb6480b55a6bd61b84ffb74f257b2d5ce49" translate="yes" xml:space="preserve">
          <source>The network (&lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt;&lt;code&gt;IPv4Network&lt;/code&gt;&lt;/a&gt;) this interface belongs to.</source>
          <target state="translated">이 인터페이스가 속한 네트워크 ( &lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt; &lt;code&gt;IPv4Network&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e599de9a3fa5fc46e727150dd83cd10771b0bbe" translate="yes" xml:space="preserve">
          <source>The network IO API is identical to that provided by &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt;, from which &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; also inherits. This allows an SSL socket to be used as a drop-in replacement for a regular socket, making it very easy to add SSL support to an existing application.</source>
          <target state="translated">네트워크 IO API는 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 도 상속 하는 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket&lt;/code&gt; &lt;/a&gt; 에서 제공하는 것과 동일합니다 . 이를 통해 SSL 소켓을 일반 소켓의 드롭 인 대체품으로 사용할 수 있으므로 기존 애플리케이션에 SSL 지원을 매우 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f17d22e63791069b7c92792b65f7a69c02ba8fb7" translate="yes" xml:space="preserve">
          <source>The network address for the network. The network address and the prefix length together uniquely define a network.</source>
          <target state="translated">네트워크의 네트워크 주소입니다. 네트워크 주소와 접두사 길이는 네트워크를 고유하게 정의합니다.</target>
        </trans-unit>
        <trans-unit id="16ba5b21f9d9fddf591b834e660f9b366a42026d" translate="yes" xml:space="preserve">
          <source>The new class instance is based on &lt;em&gt;fileobj&lt;/em&gt;, which can be a regular file, an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; object, or any other object which simulates a file. It defaults to &lt;code&gt;None&lt;/code&gt;, in which case &lt;em&gt;filename&lt;/em&gt; is opened to provide a file object.</source>
          <target state="translated">새 클래스 인스턴스는 일반 파일, &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 객체 또는 파일을 시뮬레이트하는 다른 객체 일 수있는 &lt;em&gt;fileobj를&lt;/em&gt; 기반으로 합니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 이며,이 경우 파일 객체를 제공하기 위해 &lt;em&gt;filename&lt;/em&gt; 이 열립니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="afe4a88a9a98bbf3ddd30841d8ef2299fd65fc2e" translate="yes" xml:space="preserve">
          <source>The new context is copied from a prototype context called &lt;em&gt;DefaultContext&lt;/em&gt;. To control the defaults so that each thread will use the same values throughout the application, directly modify the &lt;em&gt;DefaultContext&lt;/em&gt; object. This should be done &lt;em&gt;before&lt;/em&gt; any threads are started so that there won&amp;rsquo;t be a race condition between threads calling &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">새 컨텍스트는 &lt;em&gt;DefaultContext&lt;/em&gt; 라는 프로토 타입 컨텍스트에서 복사됩니다 . 각 스레드가 응용 프로그램 전체에서 동일한 값을 사용하도록 기본값을 제어하려면 &lt;em&gt;DefaultContext&lt;/em&gt; 객체를 직접 수정하십시오 . &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 호출하는 스레드간에 경쟁 조건이 발생하지 않도록 스레드를 시작 &lt;em&gt;하기 전에&lt;/em&gt; 수행해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37c6e32aa72abcc84337f5ff92ac0e6a43c18f7d" translate="yes" xml:space="preserve">
          <source>The new file descriptor is &lt;a href=&quot;os#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;.</source>
          <target state="translated">새로운 파일 기술자는 &lt;a href=&quot;os#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0df1d27beda7860dd0eb35dd7deeead60554b5" translate="yes" xml:space="preserve">
          <source>The new format syntax also supports new and different options, shown in the following examples.</source>
          <target state="translated">새 형식 구문은 다음 예제와 같이 새 옵션과 다른 옵션도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0f209dbf900c74ca254ac018b69e34786768dc97" translate="yes" xml:space="preserve">
          <source>The new pickle protocol 4 also, in some circumstances, relies on &lt;a href=&quot;stdtypes#definition.__qualname__&quot;&gt;&lt;code&gt;__qualname__&lt;/code&gt;&lt;/a&gt; being set to the location where pickle will be able to find the class. For example, if the class was made available in class SomeData in the global scope:</source>
          <target state="translated">새로운 피클 프로토콜 4는 일부 상황 에서 피클이 클래스를 찾을 수있는 위치로 설정된 &lt;a href=&quot;stdtypes#definition.__qualname__&quot;&gt; &lt;code&gt;__qualname__&lt;/code&gt; &lt;/a&gt; 에 의존합니다 . 예를 들어, 클래스가 전역 범위의 SomeData 클래스에서 사용 가능한 경우 :</target>
        </trans-unit>
        <trans-unit id="436c5ad8644d706cba5625b07da47ead944ad42b" translate="yes" xml:space="preserve">
          <source>The new process has a new console, instead of inheriting its parent&amp;rsquo;s console (the default).</source>
          <target state="translated">새로운 프로세스에는 부모의 콘솔을 상속하는 대신 새로운 콘솔이 있습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="0582af89e51267c8d6a4d04e4de1c15a3710b2fe" translate="yes" xml:space="preserve">
          <source>The newlines attribute of the file objects &lt;a href=&quot;#subprocess.Popen.stdin&quot;&gt;&lt;code&gt;Popen.stdin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#subprocess.Popen.stdout&quot;&gt;&lt;code&gt;Popen.stdout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#subprocess.Popen.stderr&quot;&gt;&lt;code&gt;Popen.stderr&lt;/code&gt;&lt;/a&gt; are not updated by the &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;Popen.communicate()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.Popen.stdin&quot;&gt; &lt;code&gt;Popen.stdin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#subprocess.Popen.stdout&quot;&gt; &lt;code&gt;Popen.stdout&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#subprocess.Popen.stderr&quot;&gt; &lt;code&gt;Popen.stderr&lt;/code&gt; &lt;/a&gt; 파일 객체의 개행 속성은 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;Popen.communicate()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 업데이트되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1a2554779f9c09c476ce23785676057b0b114bb1" translate="yes" xml:space="preserve">
          <source>The newly created file is &lt;a href=&quot;os#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;.</source>
          <target state="translated">새로 작성된 파일은 &lt;a href=&quot;os#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1087030b8a61823a32280b2c3da709e02fd3bbd5" translate="yes" xml:space="preserve">
          <source>The newly created socket is &lt;a href=&quot;os#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;.</source>
          <target state="translated">새로 작성된 소켓은 &lt;a href=&quot;os#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="604294b514f933463d592383822f3ae092d30a41" translate="yes" xml:space="preserve">
          <source>The newly created sockets are &lt;a href=&quot;os#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;.</source>
          <target state="translated">새로 작성된 소켓은 &lt;a href=&quot;os#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09393810885ec9c580c4e469b205008cb689cee8" translate="yes" xml:space="preserve">
          <source>The newly returned object is created by calling the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method of the dataclass. This ensures that &lt;code&gt;__post_init__()&lt;/code&gt;, if present, is also called.</source>
          <target state="translated">새로 리턴 된 오브젝트는 데이터 클래스 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 . 이를 통해 &lt;code&gt;__post_init__()&lt;/code&gt; (있는 경우)도 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ce8224916d68ae87429d998927008c27fd5791ce" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how to create an anonymous map and exchange data between the parent and child processes:</source>
          <target state="translated">다음 예제는 익명 맵을 작성하고 상위 프로세스와 하위 프로세스간에 데이터를 교환하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e3cb18fddf5ee61de6cbb27246553d4bde8b31a2" translate="yes" xml:space="preserve">
          <source>The next example illustrates the use of &lt;a href=&quot;#http.cookiejar.DefaultCookiePolicy&quot;&gt;&lt;code&gt;DefaultCookiePolicy&lt;/code&gt;&lt;/a&gt;. Turn on &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; cookies, be more strict about domains when setting and returning Netscape cookies, and block some domains from setting cookies or having them returned:</source>
          <target state="translated">다음 예는 &lt;a href=&quot;#http.cookiejar.DefaultCookiePolicy&quot;&gt; &lt;code&gt;DefaultCookiePolicy&lt;/code&gt; &lt;/a&gt; 사용을 보여줍니다 . &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 쿠키를 켜고 Netscape 쿠키를 설정 및 리턴 할 때 도메인에 대해 더 엄격하며 일부 도메인이 쿠키를 설정하거나 쿠키를 반환하지 못하게 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="19e16a17a178f5ee9f74b2376beaf6b0f0231354" translate="yes" xml:space="preserve">
          <source>The next example shows how to use the socket interface to communicate to a CAN network using the raw socket protocol. To use CAN with the broadcast manager protocol instead, open a socket with:</source>
          <target state="translated">다음 예제는 소켓 인터페이스를 사용하여 원시 소켓 프로토콜을 사용하여 CAN 네트워크와 통신하는 방법을 보여줍니다. 대신 브로드 캐스트 관리자 프로토콜과 함께 CAN을 사용하려면 다음을 사용하여 소켓을여십시오.</target>
        </trans-unit>
        <trans-unit id="ae5e17bbaaa383ae94d175891435ce933a10243e" translate="yes" xml:space="preserve">
          <source>The next example shows how to write a very simple network sniffer with raw sockets on Windows. The example requires administrator privileges to modify the interface:</source>
          <target state="translated">다음 예제는 Windows에서 원시 소켓으로 매우 간단한 네트워크 스니퍼를 작성하는 방법을 보여줍니다. 이 예에서는 인터페이스를 수정하려면 관리자 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="949e116ea64bbf5a74a3ce5f8f9c13fecc60559c" translate="yes" xml:space="preserve">
          <source>The next step could be to call the &lt;a href=&quot;#module-cgi&quot;&gt;&lt;code&gt;cgi&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s &lt;a href=&quot;test#module-test&quot;&gt;&lt;code&gt;test()&lt;/code&gt;&lt;/a&gt; function from your script: replace its main code with the single statement</source>
          <target state="translated">다음 단계는 스크립트에서 &lt;a href=&quot;#module-cgi&quot;&gt; &lt;code&gt;cgi&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;a href=&quot;test#module-test&quot;&gt; &lt;code&gt;test()&lt;/code&gt; &lt;/a&gt; 함수 를 호출하는 것입니다 . 기본 코드를 단일 명령문으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="fe20b32d6167a0d3df5008b170965eb8443e4d2c" translate="yes" xml:space="preserve">
          <source>The next three sections cover the exceptions the package may raise and the defects (non-compliance with the RFCs) that the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; may detect. Then we cover the &lt;a href=&quot;email.headerregistry#module-email.headerregistry&quot;&gt;&lt;code&gt;headerregistry&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;email.contentmanager#module-email.contentmanager&quot;&gt;&lt;code&gt;contentmanager&lt;/code&gt;&lt;/a&gt; sub-components, which provide tools for doing more detailed manipulation of headers and payloads, respectively. Both of these components contain features relevant to consuming and producing non-trivial messages, but also document their extensibility APIs, which will be of interest to advanced applications.</source>
          <target state="translated">다음 세 섹션에서는 패키지에서 발생할 수있는 예외 및 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 가 감지 할 수 있는 결함 (RFC 준수하지 않음)을 다룹니다 . 그럼 우리가 다루 &lt;a href=&quot;email.headerregistry#module-email.headerregistry&quot;&gt; &lt;code&gt;headerregistry&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;email.contentmanager#module-email.contentmanager&quot;&gt; &lt;code&gt;contentmanager&lt;/code&gt; 의&lt;/a&gt; 각각 헤더와 페이로드의 자세한 조작을 수행하는 도구를 제공하는 하위 구성 요소를. 이 두 구성 요소 모두 사소한 메시지를 소비하고 생성하는 데 관련된 기능을 포함하고 있으며 고급 응용 프로그램에 유용한 확장 성 API도 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="7cb7e9a823926ee6eae86c930b6a6cec97c0b136" translate="yes" xml:space="preserve">
          <source>The next two arguments are only of interest for correct handling of third-party HTTP cookies:</source>
          <target state="translated">다음 두 인수는 타사 HTTP 쿠키를 올바르게 처리하는 데에만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1b34f34440f539818f1baac3c1408321f6e5096" translate="yes" xml:space="preserve">
          <source>The next two examples are identical to the above two, but support both IPv4 and IPv6. The server side will listen to the first address family available (it should listen to both instead). On most of IPv6-ready systems, IPv6 will take precedence and the server may not accept IPv4 traffic. The client side will try to connect to the all addresses returned as a result of the name resolution, and sends traffic to the first one connected successfully.</source>
          <target state="translated">다음 두 예제는 위 두 예제와 동일하지만 IPv4와 IPv6을 모두 지원합니다. 서버 측은 사용 가능한 첫 번째 주소 패밀리를 청취합니다 (대신 두 가지 모두 청취해야 함). 대부분의 IPv6 지원 시스템에서 IPv6가 우선하며 서버는 IPv4 트래픽을 허용하지 않을 수 있습니다. 클라이언트 쪽은 이름 확인 결과 반환 된 모든 주소에 연결을 시도하고 연결된 첫 번째 주소로 트래픽을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d9209588f38b03a1f6b1c8ce4f9ee7e3481b4e99" translate="yes" xml:space="preserve">
          <source>The next variation of &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; provided, &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt;, is also based on &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. The difference being &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; members can be combined using the bitwise operators (&amp;amp;, |, ^, ~) and the result is still an &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; member. However, as the name implies, &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; members also subclass &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; and can be used wherever an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is used. Any operation on an &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; member besides the bit-wise operations will lose the &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; membership.</source>
          <target state="translated">제공되는 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 의 다음 변형 인 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 도 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 기반입니다 . &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버와 의 차이 는 비트 연산자 (&amp;amp;, |, ^, ~)를 사용하여 결합 할 수 있으며 결과는 여전히 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버입니다. 그러나 이름에서 알 수 있듯이 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버는 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 를 서브 클래스로 만들고 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 가 사용될 때마다 사용할 수 있습니다 . 온 모든 작업 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; 의&lt;/a&gt; 비트 현명한 작업 외에 회원은 잃게됩니다 &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; 의&lt;/a&gt; 회원.</target>
        </trans-unit>
        <trans-unit id="9bfabb971f21f3b03bdd4e55a1c114a32f0d2834" translate="yes" xml:space="preserve">
          <source>The node that immediately follows this one with the same parent. See also &lt;a href=&quot;#xml.dom.Node.previousSibling&quot;&gt;&lt;code&gt;previousSibling&lt;/code&gt;&lt;/a&gt;. If this is the last child of the parent, this attribute will be &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">이 노드 바로 뒤에 나오는 노드는 동일한 부모입니다. &lt;a href=&quot;#xml.dom.Node.previousSibling&quot;&gt; &lt;code&gt;previousSibling&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 . 이것이 부모의 마지막 자식 인 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="2255447a78696c6c1192e94d33aacbfee0ad7209" translate="yes" xml:space="preserve">
          <source>The node that immediately precedes this one with the same parent. For instance the element with an end-tag that comes just before the &lt;em&gt;self&lt;/em&gt; element&amp;rsquo;s start-tag. Of course, XML documents are made up of more than just elements so the previous sibling could be text, a comment, or something else. If this node is the first child of the parent, this attribute will be &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">이 노드 바로 앞에있는 노드는 동일한 부모입니다. 예를 들어 종료 태그가있는 요소 는 &lt;em&gt;자체&lt;/em&gt; 요소의 시작 태그 바로 앞에옵니다 . 물론 XML 문서는 단순한 요소 이상의 요소로 구성되므로 이전 형제는 텍스트, 주석 또는 기타 요소 일 수 있습니다. 이 노드가 부모의 첫 번째 자식 인 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="b0f814495b89e5be6f7e13a7d14c950afc264e45" translate="yes" xml:space="preserve">
          <source>The normal form KD (NFKD) will apply the compatibility decomposition, i.e. replace all compatibility characters with their equivalents. The normal form KC (NFKC) first applies the compatibility decomposition, followed by the canonical composition.</source>
          <target state="translated">일반적인 형식 KD (NFKD)는 호환성 분해를 적용합니다. 즉, 모든 호환성 문자를 동등한 것으로 바꿉니다. 정상 형태 KC (NFKC)는 먼저 상용 성 분해를 적용한 다음 표준 조성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f08a0fdb213b3a5135a382e10523519836d12875" translate="yes" xml:space="preserve">
          <source>The number of &lt;em&gt;iterations&lt;/em&gt; should be chosen based on the hash algorithm and computing power. As of 2013, at least 100,000 iterations of SHA-256 are suggested.</source>
          <target state="translated">다수의 &lt;em&gt;반복은&lt;/em&gt; 해시 알고리즘 및 연산 능력에 기초하여 선택되어야한다. 2013 년 현재 최소 100,000 회 SHA-256 반복이 제안됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1959b4f8160cfc9011584560cc6419584c59d2" translate="yes" xml:space="preserve">
          <source>The number of blanks by which to indent a new MARK level.</source>
          <target state="translated">새 MARK 수준을 들여 쓰는 공백 수입니다.</target>
        </trans-unit>
        <trans-unit id="8161ac11297e3d0c275ee4c31859567d0d08fde6" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be allocated for POSIX message queues.</source>
          <target state="translated">POSIX 메시지 큐에 할당 할 수있는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a53c69d2a16e5998876722ec5b5b5c554574067f" translate="yes" xml:space="preserve">
          <source>The number of capturing groups in the pattern.</source>
          <target state="translated">패턴에서 캡처 그룹의 수입니다.</target>
        </trans-unit>
        <trans-unit id="5387b634fc91f3629b3e0f2b901197c0d0b30da7" translate="yes" xml:space="preserve">
          <source>The number of items returned is &lt;code&gt;(n+r-1)! / r! / (n-1)!&lt;/code&gt; when &lt;code&gt;n &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">반환 된 항목 수는 &lt;code&gt;(n+r-1)! / r! / (n-1)!&lt;/code&gt; 경우 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="962c71b0d63d8a7a2bcc653faacf7a50829ba36c" translate="yes" xml:space="preserve">
          <source>The number of items returned is &lt;code&gt;n! / (n-r)!&lt;/code&gt; when &lt;code&gt;0 &amp;lt;= r &amp;lt;= n&lt;/code&gt; or zero when &lt;code&gt;r &amp;gt; n&lt;/code&gt;.</source>
          <target state="translated">반품 된 품목의 수는 &lt;code&gt;n! / (n-r)!&lt;/code&gt; 경우 &lt;code&gt;0 &amp;lt;= r &amp;lt;= n&lt;/code&gt; 또는 제로 때 &lt;code&gt;r &amp;gt; n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ca334363dca871155b191d7531a8192d53ffeb" translate="yes" xml:space="preserve">
          <source>The number of items returned is &lt;code&gt;n! / r! / (n-r)!&lt;/code&gt; when &lt;code&gt;0 &amp;lt;= r &amp;lt;= n&lt;/code&gt; or zero when &lt;code&gt;r &amp;gt; n&lt;/code&gt;.</source>
          <target state="translated">반품 된 품목의 수는 &lt;code&gt;n! / r! / (n-r)!&lt;/code&gt; 경우 &lt;code&gt;0 &amp;lt;= r &amp;lt;= n&lt;/code&gt; 또는 제로 때 &lt;code&gt;r &amp;gt; n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1361808be3e556a2c681229903e6369e9936d1" translate="yes" xml:space="preserve">
          <source>The number of lines read from the source iterator. This is not the same as the number of records returned, as records can span multiple lines.</source>
          <target state="translated">소스 반복기에서 읽은 라인 수입니다. 레코드가 여러 줄에 걸쳐있을 수 있으므로 반환되는 레코드 수와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e522c0ad7ad79e47c0f7383e3548855cd52b4083" translate="yes" xml:space="preserve">
          <source>The number of nodes in the sequence.</source>
          <target state="translated">시퀀스의 노드 수</target>
        </trans-unit>
        <trans-unit id="7f26a147c76475973597eb7ed68b367dd8f6618f" translate="yes" xml:space="preserve">
          <source>The number of rows to fetch per call is specified by the &lt;em&gt;size&lt;/em&gt; parameter. If it is not given, the cursor&amp;rsquo;s arraysize determines the number of rows to be fetched. The method should try to fetch as many rows as indicated by the size parameter. If this is not possible due to the specified number of rows not being available, fewer rows may be returned.</source>
          <target state="translated">호출 당 페치 할 행 수는 &lt;em&gt;size&lt;/em&gt; 매개 변수로 지정됩니다 . 지정되지 않은 경우 커서의 arraysize는 가져올 행 수를 결정합니다. 이 메소드는 size 매개 변수로 표시된만큼 많은 행을 페치하려고 시도해야합니다. 지정된 수의 행을 사용할 수 없어서 이것이 불가능한 경우 더 적은 수의 행이 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63850906fb522ae0ca09abc54b1f75ee8a7b2105" translate="yes" xml:space="preserve">
          <source>The number of signals which the process may queue.</source>
          <target state="translated">프로세스가 큐에 넣을 수있는 신호 수입니다.</target>
        </trans-unit>
        <trans-unit id="47695a60ec93e3722284a641915f2cbef75895c7" translate="yes" xml:space="preserve">
          <source>The number of threads currently waiting in the barrier.</source>
          <target state="translated">현재 배리어에서 대기중인 스레드 수입니다.</target>
        </trans-unit>
        <trans-unit id="fe3287bf2134cfe328b3832b5fc0327b6b10180a" translate="yes" xml:space="preserve">
          <source>The number of threads required to pass the barrier.</source>
          <target state="translated">장벽을 통과하는 데 필요한 스레드 수입니다.</target>
        </trans-unit>
        <trans-unit id="48b155556df8cde48c84bc695714a02b7379303b" translate="yes" xml:space="preserve">
          <source>The number returned by &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; may be converted into a more common time format (i.e. year, month, day, hour, etc&amp;hellip;) in UTC by passing it to &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt; function or in local time by passing it to the &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; function. In both cases a &lt;a href=&quot;#time.struct_time&quot;&gt;&lt;code&gt;struct_time&lt;/code&gt;&lt;/a&gt; object is returned, from which the components of the calendar date may be accessed as attributes.</source>
          <target state="translated">&lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 숫자는 UTC에서 &lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; 함수에 전달하거나 현지 시간에 &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 기능. 두 경우 모두 달력 날짜의 구성 요소에 속성으로 액세스 할 수 있는 &lt;a href=&quot;#time.struct_time&quot;&gt; &lt;code&gt;struct_time&lt;/code&gt; &lt;/a&gt; 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="af7e7400c401b1fb97f42d4204605204411553ab" translate="yes" xml:space="preserve">
          <source>The number system for the &lt;a href=&quot;#module-decimal&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; module provides special values including &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;sNaN&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, and two zeros, &lt;code&gt;+0&lt;/code&gt; and &lt;code&gt;-0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-decimal&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt; 모듈 의 숫자 시스템은 &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;sNaN&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; , &lt;code&gt;Infinity&lt;/code&gt; 및 두 개의 0 &lt;code&gt;+0&lt;/code&gt; 및 &lt;code&gt;-0&lt;/code&gt; 을 포함한 특수 값을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="12a684dbecd685a706ab359cf891a11c75dec792" translate="yes" xml:space="preserve">
          <source>The numeric constant for an uncompressed archive member.</source>
          <target state="translated">압축되지 않은 아카이브 멤버의 숫자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="37e783732d5b9e3bf0fc668760520288331fba75" translate="yes" xml:space="preserve">
          <source>The numeric constant for the BZIP2 compression method. This requires the &lt;a href=&quot;bz2#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">BZIP2 압축 방법의 숫자 상수입니다. &lt;a href=&quot;bz2#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 모듈 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8d8b68f43fe31cc5c1fb45a95cf61b9f53eb1ad2" translate="yes" xml:space="preserve">
          <source>The numeric constant for the LZMA compression method. This requires the &lt;a href=&quot;lzma#module-lzma&quot;&gt;&lt;code&gt;lzma&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">LZMA 압축 방법의 숫자 상수입니다. &lt;a href=&quot;lzma#module-lzma&quot;&gt; &lt;code&gt;lzma&lt;/code&gt; &lt;/a&gt; 모듈 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ba44090efe78021caa4efa072eec5563ab2d9f9d" translate="yes" xml:space="preserve">
          <source>The numeric constant for the usual ZIP compression method. This requires the &lt;a href=&quot;zlib#module-zlib&quot;&gt;&lt;code&gt;zlib&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">일반적인 ZIP 압축 방법의 숫자 상수입니다. &lt;a href=&quot;zlib#module-zlib&quot;&gt; &lt;code&gt;zlib&lt;/code&gt; &lt;/a&gt; 모듈 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c4185627d1ed863cbed4088b20b06ac2ecf24bcf" translate="yes" xml:space="preserve">
          <source>The numeric literals accepted include the digits &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; or any Unicode equivalent (code points with the &lt;code&gt;Nd&lt;/code&gt; property).</source>
          <target state="translated">허용 숫자 리터럴 숫자 등 &lt;code&gt;0&lt;/code&gt; 행 &lt;code&gt;9&lt;/code&gt; 또는 유니 상당합니다 (코드 포인트로 &lt;code&gt;Nd&lt;/code&gt; 속성).</target>
        </trans-unit>
        <trans-unit id="5f59e143dc36e51aacae93fe16316b093356a832" translate="yes" xml:space="preserve">
          <source>The numeric methods (including right hand and in-place variants): &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__sub__&lt;/code&gt;, &lt;code&gt;__mul__&lt;/code&gt;, &lt;code&gt;__matmul__&lt;/code&gt;, &lt;code&gt;__div__&lt;/code&gt;, &lt;code&gt;__truediv__&lt;/code&gt;, &lt;code&gt;__floordiv__&lt;/code&gt;, &lt;code&gt;__mod__&lt;/code&gt;, &lt;code&gt;__divmod__&lt;/code&gt;, &lt;code&gt;__lshift__&lt;/code&gt;, &lt;code&gt;__rshift__&lt;/code&gt;, &lt;code&gt;__and__&lt;/code&gt;, &lt;code&gt;__xor__&lt;/code&gt;, &lt;code&gt;__or__&lt;/code&gt;, and &lt;code&gt;__pow__&lt;/code&gt;</source>
          <target state="translated">숫자 방식 (오른손 및 내부 변형 포함) : &lt;code&gt;__add__&lt;/code&gt; , &lt;code&gt;__sub__&lt;/code&gt; , &lt;code&gt;__mul__&lt;/code&gt; , &lt;code&gt;__matmul__&lt;/code&gt; , &lt;code&gt;__div__&lt;/code&gt; , &lt;code&gt;__truediv__&lt;/code&gt; , &lt;code&gt;__floordiv__&lt;/code&gt; , &lt;code&gt;__mod__&lt;/code&gt; , &lt;code&gt;__divmod__&lt;/code&gt; , &lt;code&gt;__lshift__&lt;/code&gt; , &lt;code&gt;__rshift__&lt;/code&gt; , &lt;code&gt;__and__&lt;/code&gt; , &lt;code&gt;__xor__&lt;/code&gt; , &lt;code&gt;__or__&lt;/code&gt; 및 &lt;code&gt;__pow__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c100dcbc73873c48aee35db62eb559910c260751" translate="yes" xml:space="preserve">
          <source>The numeric tower</source>
          <target state="translated">숫자 탑</target>
        </trans-unit>
        <trans-unit id="88ed3d5a328daed4a91171dfb5cccdd97a19fb1d" translate="yes" xml:space="preserve">
          <source>The numeric values of logging levels are given in the following table. These are primarily of interest if you want to define your own levels, and need them to have specific values relative to the predefined levels. If you define a level with the same numeric value, it overwrites the predefined value; the predefined name is lost.</source>
          <target state="translated">로깅 수준의 숫자 값은 다음 표에 나와 있습니다. 자신의 레벨을 정의하고 사전 정의 된 레벨에 상대적인 특정 값이 필요한 경우 주로 관심 대상입니다. 동일한 숫자 값으로 레벨을 정의하면 사전 정의 된 값을 겹쳐 씁니다. 사전 정의 된 이름이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="bdbb3076731abfe09324b9cd19aefa862ead4017" translate="yes" xml:space="preserve">
          <source>The object also support comparison semantics, so handle objects will compare true if they both reference the same underlying Windows handle value.</source>
          <target state="translated">객체는 또한 비교 시맨틱을 지원하므로 핸들 객체가 모두 동일한 기본 Windows 핸들 값을 참조하면 true를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a0e148153711b276e1aa1492d94c98fa82cc5504" translate="yes" xml:space="preserve">
          <source>The object comparison functions are useful for all objects, and are named after the rich comparison operators they support:</source>
          <target state="translated">객체 비교 함수는 모든 객체에 유용하며 지원하는 풍부한 비교 연산자의 이름을 따서 명명됩니다.</target>
        </trans-unit>
        <trans-unit id="903b12e662a7a1a14d96fff562e28b40c371a833" translate="yes" xml:space="preserve">
          <source>The object must be picklable. Very large pickles (approximately 32 MiB+, though it depends on the OS) may raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">객체는 피클 가능해야합니다. 매우 큰 피클 (OS에 따라 다르지만 대략 32MiB +)은 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fe6875d123fff02a6b92c938eef7f275de297f5" translate="yes" xml:space="preserve">
          <source>The object of this exercise is to get a fairly consistent result. If your computer is &lt;em&gt;very&lt;/em&gt; fast, or your timer function has poor resolution, you might have to pass 100000, or even 1000000, to get consistent results.</source>
          <target state="translated">이 연습의 목적은 상당히 일관된 결과를 얻는 것입니다. 컴퓨터가 &lt;em&gt;매우&lt;/em&gt; 빠르거나 타이머 기능의 해상도가 좋지 않은 경우 일관된 결과를 얻으려면 100000 또는 1000000을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="7db759e5615f9c2b36c177c80ee0bb9f95712f63" translate="yes" xml:space="preserve">
          <source>The object passed as the &lt;em&gt;tzinfo&lt;/em&gt; argument to the &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; constructor, or &lt;code&gt;None&lt;/code&gt; if none was passed.</source>
          <target state="translated">객체는 &lt;em&gt;tzinfo&lt;/em&gt; 인수로 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 생성자 에 전달 되었거나 전달되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="047b8732cb8d384ea4ed809e355adf2b06562681" translate="yes" xml:space="preserve">
          <source>The object passed as the tzinfo argument to the &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; constructor, or &lt;code&gt;None&lt;/code&gt; if none was passed.</source>
          <target state="translated">tzinfo 인수로 객체가 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 생성자 에 전달 되었거나 전달되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6aa60910fc684fb8ab4e8d6a532964dd03281a4f" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;a href=&quot;#dbm.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; supports the same basic functionality as dictionaries; keys and their corresponding values can be stored, retrieved, and deleted, and the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; operator and the &lt;code&gt;keys()&lt;/code&gt; method are available, as well as &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;setdefault()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#dbm.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 오브젝트는 사전과 동일한 기본 기능을 지원합니다. 키와 해당 값은 저장된 검색, 삭제하고, 될 수 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 연산자와 &lt;code&gt;keys()&lt;/code&gt; 방식을 사용할뿐만 아니라, &lt;code&gt;get()&lt;/code&gt; 및 &lt;code&gt;setdefault()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19f47806e7480ee93b8a1ea06979dd9be3cefd4b" translate="yes" xml:space="preserve">
          <source>The object returned by the context manager is a recording helper which keeps tracks of the matching log messages. It has two attributes:</source>
          <target state="translated">컨텍스트 관리자가 리턴 한 오브젝트는 일치하는 로그 메시지를 추적하는 레코딩 헬퍼입니다. 두 가지 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad42de57b21617935b08c3b32f3448c2db7ca64" translate="yes" xml:space="preserve">
          <source>The object that this function returns will be returned from the foreign function call, but it can also check the result value and raise an exception if the foreign function call failed.</source>
          <target state="translated">이 함수가 반환하는 객체는 외부 함수 호출에서 반환되지만 결과 값을 확인하고 외부 함수 호출이 실패하면 예외를 발생시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ba396ea5cfea44624cf1620f8fa70e786573b0" translate="yes" xml:space="preserve">
          <source>The object the codec was attempting to encode or decode.</source>
          <target state="translated">코덱에서 인코딩 또는 디코딩하려는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d2ce035963ef7adf8099f19b2af3c6f11eb0764d" translate="yes" xml:space="preserve">
          <source>The object-oriented interface uses essentially two+two classes:</source>
          <target state="translated">객체 지향 인터페이스는 기본적으로 2 + 2 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="630bdda9d2c68a08c06c47581abacf38447213da" translate="yes" xml:space="preserve">
          <source>The objects returned by &lt;a href=&quot;#dict.keys&quot;&gt;&lt;code&gt;dict.keys()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#dict.values&quot;&gt;&lt;code&gt;dict.values()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#dict.items&quot;&gt;&lt;code&gt;dict.items()&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;view objects&lt;/em&gt;. They provide a dynamic view on the dictionary&amp;rsquo;s entries, which means that when the dictionary changes, the view reflects these changes.</source>
          <target state="translated">&lt;a href=&quot;#dict.keys&quot;&gt; &lt;code&gt;dict.keys()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#dict.values&quot;&gt; &lt;code&gt;dict.values()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#dict.items&quot;&gt; &lt;code&gt;dict.items()&lt;/code&gt; &lt;/a&gt; 가 반환 한 객체 는 &lt;em&gt;뷰 객체&lt;/em&gt; 입니다. 사전의 항목에 대한 동적보기를 제공합니다. 즉, 사전이 변경되면이 변경 사항이보기에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="fcf6d17cdc435a25534caaa9e7b1f6ca68ec4149" translate="yes" xml:space="preserve">
          <source>The obsolete &lt;em&gt;use_datetime&lt;/em&gt; flag is similar to &lt;em&gt;use_builtin_types&lt;/em&gt; but it applies only to date/time values.</source>
          <target state="translated">사용되지 않는 &lt;em&gt;use_datetime의&lt;/em&gt; 플래그는 유사하다 &lt;em&gt;use_builtin_types&lt;/em&gt; 하지만 그것은 단지 날짜 / 시간 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c625e4dbb320fc0f3c12b0adad5a22845ee0fb1" translate="yes" xml:space="preserve">
          <source>The obvious use case is applications that operate in a non-blocking fashion where the XML data is being received from a socket or read incrementally from some storage device. In such cases, blocking reads are unacceptable.</source>
          <target state="translated">명백한 사용 사례는 XML 데이터가 소켓에서 수신되거나 일부 저장 장치에서 점진적으로 읽히는 비 차단 방식으로 작동하는 응용 프로그램입니다. 이러한 경우 차단 읽기는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85426ab81c4bf4f1b8a00b87eae70c4cc2f2f12b" translate="yes" xml:space="preserve">
          <source>The official specification.</source>
          <target state="translated">공식 사양.</target>
        </trans-unit>
        <trans-unit id="47876333704ae7f2772a8428b0724fa0f50dc54c" translate="yes" xml:space="preserve">
          <source>The offset has the form: &lt;code&gt;&amp;plusmn; hh[:mm[:ss]]&lt;/code&gt;. This indicates the value added the local time to arrive at UTC. If preceded by a &amp;lsquo;-&amp;lsquo;, the timezone is east of the Prime Meridian; otherwise, it is west. If no offset follows dst, summer time is assumed to be one hour ahead of standard time.</source>
          <target state="translated">오프셋 형식은 &lt;code&gt;&amp;plusmn; hh[:mm[:ss]]&lt;/code&gt; 입니다. UTC에 도달하기 위해 현지 시간이 추가 된 값을 나타냅니다. 앞에 '-'가 있으면 시간대는 Prime Meridian의 동쪽입니다. 그렇지 않으면 서쪽입니다. dst 다음에 오프셋이 없으면 서머 타임은 표준 시간보다 1 시간 앞서 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1cda92b072d44c5bc0fea7b142ea8855eba2454d" translate="yes" xml:space="preserve">
          <source>The offset of the local (non-DST) timezone, in seconds west of UTC (negative in most of Western Europe, positive in the US, zero in the UK). See note below.</source>
          <target state="translated">UTC (서부 유럽 지역에서는 음수, 미국에서는 양수, 영국에서는 0)에서 서쪽으로 초 단위 인 로컬 (DST 이외) 시간대의 오프셋입니다. 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="77e0480eb79c9af077d792652673e48506ece8df" translate="yes" xml:space="preserve">
          <source>The offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if &lt;code&gt;daylight&lt;/code&gt; is nonzero. See note below.</source>
          <target state="translated">로컬 DST 시간대의 오프셋 (UTC 서쪽에서 초 단위), 정의 된 경우. 현지 DST 시간대가 UTC를 기준으로 동쪽이면 (영국을 포함한 서유럽에서와 같이) 음수입니다. &lt;code&gt;daylight&lt;/code&gt; 이 0이 아닌 경우에만 사용하십시오 . 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="62956501ed2752f838e69aab5951452d9c36c226" translate="yes" xml:space="preserve">
          <source>The old value (or &lt;code&gt;None&lt;/code&gt; if it doesn&amp;rsquo;t exist) will be assigned to the target of the &amp;ldquo;as&amp;rdquo; clause, if there is one.</source>
          <target state="translated">이전 값 (또는 존재하지 않는 경우 &lt;code&gt;None&lt;/code&gt; )은 &quot;as&quot;절의 대상에 값이 할당됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="02978c9e31ff8ed2331dbf95b8403ffb3805aa2c" translate="yes" xml:space="preserve">
          <source>The old values are returned as a tuple: (delay, interval).</source>
          <target state="translated">이전 값은 튜플 (지연, 간격)로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="260d61dd119ba34480a72edcffdce1ad4835e534" translate="yes" xml:space="preserve">
          <source>The old version of JSON specified by the obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc4627.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 4627&lt;/strong&gt;&lt;/a&gt; required that the top-level value of a JSON text must be either a JSON object or array (Python &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;), and could not be a JSON null, boolean, number, or string value. &lt;a href=&quot;https://tools.ietf.org/html/rfc7159.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7159&lt;/strong&gt;&lt;/a&gt; removed that restriction, and this module does not and has never implemented that restriction in either its serializer or its deserializer.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4627.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 4627로&lt;/strong&gt;&lt;/a&gt; 지정된 이전 버전의 JSON 에서는 JSON 텍스트의 최상위 값이 JSON 객체 또는 배열 (Python &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; )이어야하며 JSON null, 부울, 숫자 또는 문자열 값. &lt;a href=&quot;https://tools.ietf.org/html/rfc7159.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7159&lt;/strong&gt;&lt;/a&gt; 는 이러한 제한을 제거 &lt;strong&gt;했으며이&lt;/strong&gt; 모듈은 해당 직렬화 기 또는 직렬화 해제 기에서 해당 제한을 구현하지 않았으며 결코 구현하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5de44321ccacecf1a704c59513695320f99a23f1" translate="yes" xml:space="preserve">
          <source>The old wakeup fd is returned (or -1 if file descriptor wakeup was not enabled). If &lt;em&gt;fd&lt;/em&gt; is -1, file descriptor wakeup is disabled. If not -1, &lt;em&gt;fd&lt;/em&gt; must be non-blocking. It is up to the library to remove any bytes from &lt;em&gt;fd&lt;/em&gt; before calling poll or select again.</source>
          <target state="translated">이전 웨이크 업 fd가 반환됩니다 (또는 파일 설명자 웨이크 업이 활성화되지 않은 경우 -1). 경우 &lt;em&gt;FD는&lt;/em&gt; -1, 파일 기술자 웨이크 업을 사용할 수 없습니다. -1이 아닌 경우 &lt;em&gt;fd&lt;/em&gt; 는 비 블로킹이어야합니다. 폴링을 호출하거나 다시 선택하기 전에 &lt;em&gt;fd&lt;/em&gt; 에서 바이트를 제거하는 것은 라이브러리에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afb8ba3cac22899a672d84ee65b456045ae90ae" translate="yes" xml:space="preserve">
          <source>The one and only root element of the document.</source>
          <target state="translated">문서의 유일한 루트 요소입니다.</target>
        </trans-unit>
        <trans-unit id="7db8d99ba8d024e2fd8c63de0e9c2007b0cf6129" translate="yes" xml:space="preserve">
          <source>The only argument passed to the callback is the statement (as string) that is being executed. The return value of the callback is ignored. Note that the backend does not only run statements passed to the &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt;&lt;code&gt;Cursor.execute()&lt;/code&gt;&lt;/a&gt; methods. Other sources include the transaction management of the Python module and the execution of triggers defined in the current database.</source>
          <target state="translated">콜백에 전달 된 유일한 인수는 실행중인 명령문 (문자열)입니다. 콜백의 반환 값은 무시됩니다. 백엔드는 &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt; &lt;code&gt;Cursor.execute()&lt;/code&gt; &lt;/a&gt; 메소드에 전달 된 명령문 만 실행하지 않습니다 . 다른 소스로는 Python 모듈의 트랜잭션 관리 및 현재 데이터베이스에 정의 된 트리거 실행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eafe33b08ccd21b907088c88e855da1e780d997" translate="yes" xml:space="preserve">
          <source>The only exception is calling the &lt;a href=&quot;#sqlite3.Connection.interrupt&quot;&gt;&lt;code&gt;interrupt()&lt;/code&gt;&lt;/a&gt; method, which only makes sense to call from a different thread.</source>
          <target state="translated">유일한 예외는 다른 스레드에서 호출하는 것이 합리적인 &lt;a href=&quot;#sqlite3.Connection.interrupt&quot;&gt; &lt;code&gt;interrupt()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="46dbf7b89d466c7bb4cae025a94a7bbed275fe27" translate="yes" xml:space="preserve">
          <source>The only exceptions are magic methods and attributes (those that have leading and trailing double underscores). Mock doesn&amp;rsquo;t create these but instead raises an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;. This is because the interpreter will often implicitly request these methods, and gets &lt;em&gt;very&lt;/em&gt; confused to get a new Mock object when it expects a magic method. If you need magic method support see &lt;a href=&quot;#magic-methods&quot;&gt;magic methods&lt;/a&gt;.</source>
          <target state="translated">유일한 예외는 마술 방법과 속성 (이중 및 밑줄이 이중 인 것)입니다. Mock은 이것을 생성하지 않고 대신 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 이는 인터프리터가 종종 암시 적으로 이러한 메소드를 요청하기 때문에 매직 메소드가 필요할 때 새 Mock 객체를 얻는 데 &lt;em&gt;매우&lt;/em&gt; 혼란스러워지기 때문입니다. 당신이 마법 방법의 지원이 필요한 경우 참조 &lt;a href=&quot;#magic-methods&quot;&gt;마술 방법&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f295eee727e8ccd149d6d1d12ca0bd947e422525" translate="yes" xml:space="preserve">
          <source>The only legal parameters for &lt;a href=&quot;#typing.Type&quot;&gt;&lt;code&gt;Type&lt;/code&gt;&lt;/a&gt; are classes, &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#generics&quot;&gt;type variables&lt;/a&gt;, and unions of any of these types. For example:</source>
          <target state="translated">&lt;a href=&quot;#typing.Type&quot;&gt; &lt;code&gt;Type&lt;/code&gt; &lt;/a&gt; 의 유일한 유효한 매개 변수 는 클래스, &lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#generics&quot;&gt;유형 변수&lt;/a&gt; 및 이러한 유형의 조합입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cf3bd572e49e21161d21f99f1eaa1d0a966d3b2" translate="yes" xml:space="preserve">
          <source>The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; built-in.</source>
          <target state="translated">불변 시퀀스 유형에 의해 구현되지 않은 불변 시퀀스 유형이 일반적으로 구현하는 유일한 작업은 &lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt; 내장 지원입니다 .</target>
        </trans-unit>
        <trans-unit id="7625858c35f25c6a209e085caf735f958f7baba7" translate="yes" xml:space="preserve">
          <source>The only special operation on a module is attribute access: &lt;code&gt;m.name&lt;/code&gt;, where &lt;em&gt;m&lt;/em&gt; is a module and &lt;em&gt;name&lt;/em&gt; accesses a name defined in &lt;em&gt;m&lt;/em&gt;&amp;rsquo;s symbol table. Module attributes can be assigned to. (Note that the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement is not, strictly speaking, an operation on a module object; &lt;code&gt;import
foo&lt;/code&gt; does not require a module object named &lt;em&gt;foo&lt;/em&gt; to exist, rather it requires an (external) &lt;em&gt;definition&lt;/em&gt; for a module named &lt;em&gt;foo&lt;/em&gt; somewhere.)</source>
          <target state="translated">모듈에서 유일하게 특수한 조작은 속성 액세스입니다. &lt;code&gt;m.name&lt;/code&gt; , 여기서 &lt;em&gt;m&lt;/em&gt; 은 모듈이며 &lt;em&gt;name&lt;/em&gt; 은 &lt;em&gt;m&lt;/em&gt; 의 기호 표에 정의 된 &lt;em&gt;이름에&lt;/em&gt; 액세스 합니다. 모듈 속성을 할당 할 수 있습니다. (참고 것을 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문이 아니다 엄격히 모듈 개체에 작업을 말하기, &lt;code&gt;import foo&lt;/code&gt; 라는 이름의 모듈 오브젝트를 필요로하지 않는다 &lt;em&gt;foo는&lt;/em&gt; 오히려 그것은 (외부)이 필요 존재하는 &lt;em&gt;정의&lt;/em&gt; 모듈 이름에 대한 &lt;em&gt;푸&lt;/em&gt; 어딘가에.)</target>
        </trans-unit>
        <trans-unit id="a57f2794d9d7678800b1f6104cfddfc1db11bdd1" translate="yes" xml:space="preserve">
          <source>The only way to perform numeric operations according to the locale is to use the special functions defined by this module: &lt;a href=&quot;#locale.atof&quot;&gt;&lt;code&gt;atof()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#locale.atoi&quot;&gt;&lt;code&gt;atoi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#locale.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#locale.str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로케일에 따라 숫자 연산을 수행하는 유일한 방법은이 모듈에 의해 정의 된 특수 함수 &lt;a href=&quot;#locale.atof&quot;&gt; &lt;code&gt;atof()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#locale.atoi&quot;&gt; &lt;code&gt;atoi()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#locale.format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#locale.str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c6f9d3089f7d523d1a9de5719ee1d246264baa6" translate="yes" xml:space="preserve">
          <source>The operating system may set a limit (&lt;a href=&quot;#os.sysconf&quot;&gt;&lt;code&gt;sysconf()&lt;/code&gt;&lt;/a&gt; value &lt;code&gt;'SC_IOV_MAX'&lt;/code&gt;) on the number of buffers that can be used.</source>
          <target state="translated">운영 체제는 사용할 수있는 버퍼 수에 대한 제한 ( &lt;a href=&quot;#os.sysconf&quot;&gt; &lt;code&gt;sysconf()&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;'SC_IOV_MAX'&lt;/code&gt; )을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f5a2165b4bb38c2878350e0299e8e74ec2022b6" translate="yes" xml:space="preserve">
          <source>The operation has been cancelled.</source>
          <target state="translated">작업이 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="37c61370957b9cedf1e9928499ed2d0e26ca38ed" translate="yes" xml:space="preserve">
          <source>The operation has exceeded the given deadline.</source>
          <target state="translated">작업이 지정된 마감 시간을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="3773fb97a23505a03f39bfe5a21142a1963e281d" translate="yes" xml:space="preserve">
          <source>The operation of &lt;a href=&quot;#itertools.groupby&quot;&gt;&lt;code&gt;groupby()&lt;/code&gt;&lt;/a&gt; is similar to the &lt;code&gt;uniq&lt;/code&gt; filter in Unix. It generates a break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function). That behavior differs from SQL&amp;rsquo;s GROUP BY which aggregates common elements regardless of their input order.</source>
          <target state="translated">&lt;a href=&quot;#itertools.groupby&quot;&gt; &lt;code&gt;groupby()&lt;/code&gt; &lt;/a&gt; 의 동작은 Unix 의 &lt;code&gt;uniq&lt;/code&gt; 필터 와 유사합니다 . 키 기능의 값이 변경 될 때마다 중단 또는 새 그룹을 생성합니다 (일반적으로 동일한 키 기능을 사용하여 데이터를 정렬해야하는 이유). 이 동작은 입력 순서에 관계없이 공통 요소를 집계하는 SQL의 GROUP BY와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c77345967d8f3f24b4f6917b884ea7f5ba694bed" translate="yes" xml:space="preserve">
          <source>The operations in the following table are defined on mutable sequence types. The &lt;a href=&quot;collections.abc#collections.abc.MutableSequence&quot;&gt;&lt;code&gt;collections.abc.MutableSequence&lt;/code&gt;&lt;/a&gt; ABC is provided to make it easier to correctly implement these operations on custom sequence types.</source>
          <target state="translated">다음 표의 작업은 변경 가능한 시퀀스 유형에 정의되어 있습니다. &lt;a href=&quot;collections.abc#collections.abc.MutableSequence&quot;&gt; &lt;code&gt;collections.abc.MutableSequence&lt;/code&gt; &lt;/a&gt; ABC는 쉽게 정확하게 정의 시퀀스 유형에 대한 이러한 작업을 구현할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="91b37c7af9bc9254958c9badd3abf39dc1684fab" translate="yes" xml:space="preserve">
          <source>The operations in the following table are supported by most sequence types, both mutable and immutable. The &lt;a href=&quot;collections.abc#collections.abc.Sequence&quot;&gt;&lt;code&gt;collections.abc.Sequence&lt;/code&gt;&lt;/a&gt; ABC is provided to make it easier to correctly implement these operations on custom sequence types.</source>
          <target state="translated">다음 표의 연산은 변경 가능 및 변경 불가능한 대부분의 시퀀스 유형에서 지원됩니다. &lt;a href=&quot;collections.abc#collections.abc.Sequence&quot;&gt; &lt;code&gt;collections.abc.Sequence&lt;/code&gt; &lt;/a&gt; ABC는 쉽게 정확하게 정의 시퀀스 유형에 대한 이러한 작업을 구현할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="73d944e35633cda428cbe28321b2b77943a977ef" translate="yes" xml:space="preserve">
          <source>The option for &lt;a href=&quot;#os.waitpid&quot;&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/a&gt; to return immediately if no child process status is available immediately. The function returns &lt;code&gt;(0, 0)&lt;/code&gt; in this case.</source>
          <target state="translated">하위 프로세스 상태를 즉시 사용할 수없는 경우 &lt;a href=&quot;#os.waitpid&quot;&gt; &lt;code&gt;waitpid()&lt;/code&gt; &lt;/a&gt; 옵션이 즉시 리턴됩니다. 이 경우 함수는 &lt;code&gt;(0, 0)&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6de3dc1b2695c0cf08925c9f6267182da10467df" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;kwargs&lt;/code&gt; entry, when &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;uated in the context of the &lt;code&gt;logging&lt;/code&gt; package&amp;rsquo;s namespace, is the keyword argument dict to the constructor for the handler class. If not provided, it defaults to &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;kwargs&lt;/code&gt; 항목 은 &lt;code&gt;logging&lt;/code&gt; 패키지의 네임 스페이스 컨텍스트에서 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 이 사용될 때 핸들러 클래스의 생성자에 대한 키워드 인수입니다. 제공되지 않은 경우 기본값은 &lt;code&gt;{}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13a375ad852ca915fd072d9419249a16cc053b4f" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;cafile&lt;/em&gt; and &lt;em&gt;capath&lt;/em&gt; parameters specify a set of trusted CA certificates for HTTPS requests. &lt;em&gt;cafile&lt;/em&gt; should point to a single file containing a bundle of CA certificates, whereas &lt;em&gt;capath&lt;/em&gt; should point to a directory of hashed certificate files. More information can be found in &lt;a href=&quot;ssl#ssl.SSLContext.load_verify_locations&quot;&gt;&lt;code&gt;ssl.SSLContext.load_verify_locations()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;cafile&lt;/em&gt; 및 &lt;em&gt;capath&lt;/em&gt; 매개 변수는 HTTPS 요청에 대해 신뢰할 수있는 CA 인증서 세트를 지정합니다. &lt;em&gt;cafile&lt;/em&gt; 은 CA 인증서 번들을 포함하는 단일 파일을 &lt;em&gt;가리켜&lt;/em&gt; 야하며 &lt;em&gt;capath&lt;/em&gt; 는 해시 된 인증서 파일의 디렉토리를 가리켜 야합니다. 자세한 정보는 &lt;a href=&quot;ssl#ssl.SSLContext.load_verify_locations&quot;&gt; &lt;code&gt;ssl.SSLContext.load_verify_locations()&lt;/code&gt; &lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b35f7d2f29e5f2180d8e77b70acb9741f59a8d9" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;compressed&lt;/em&gt; argument determines whether files are compressed. If set to &lt;code&gt;True&lt;/code&gt;, files in the archive are compressed with the deflate method; otherwise, files are stored uncompressed. This argument has no effect when copying an existing archive.</source>
          <target state="translated">선택적인 &lt;em&gt;압축&lt;/em&gt; 인수는 파일 압축 여부를 결정합니다. &lt;code&gt;True&lt;/code&gt; 로 설정 하면 아카이브의 파일이 deflate 메소드로 압축됩니다. 그렇지 않으면 파일이 압축되지 않은 상태로 저장됩니다. 기존 아카이브를 복사 할 때는이 인수가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c1e3c277ac39935967be50b468f981bdfdfa57a" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;constructor&lt;/em&gt; parameter, if provided, is a callable object which can be used to reconstruct the object when called with the tuple of arguments returned by &lt;em&gt;function&lt;/em&gt; at pickling time. &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;em&gt;object&lt;/em&gt; is a class or &lt;em&gt;constructor&lt;/em&gt; is not callable.</source>
          <target state="translated">선택적 &lt;em&gt;생성자&lt;/em&gt; 매개 변수 (제공된 경우)는 피클 링시 &lt;em&gt;함수&lt;/em&gt; 에 의해 리턴 된 인수의 튜플과 함께 호출 될 때 오브젝트를 재구성하는 데 사용할 수있는 호출 가능한 오브젝트입니다 . &lt;em&gt;객체&lt;/em&gt; 가 클래스이거나 &lt;em&gt;생성자&lt;/em&gt; 를 호출 할 수없는 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd4a24914c7793adbdfa0b3596c05058464944fb" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;context&lt;/em&gt; argument supported by most of these functions specifies the number of lines of context to return, which are centered around the current line.</source>
          <target state="translated">이러한 대부분의 함수가 지원하는 선택적 &lt;em&gt;컨텍스트&lt;/em&gt; 인수는 반환 할 컨텍스트 행 수를 지정합니다.이 행 수는 현재 행을 중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="b1f1abcdbd284e66453272eb8a5be5c7e9201c7d" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; parameters specify how to deal with non-ASCII characters, as accepted by the &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;str.encode()&lt;/code&gt;&lt;/a&gt; method. &lt;em&gt;encoding&lt;/em&gt; defaults to &lt;code&gt;'utf-8'&lt;/code&gt;. &lt;em&gt;errors&lt;/em&gt; defaults to &lt;code&gt;'strict'&lt;/code&gt;, meaning unsupported characters raise a &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt;&lt;code&gt;UnicodeEncodeError&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; must not be supplied if &lt;em&gt;string&lt;/em&gt; is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, or a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">선택적 &lt;em&gt;encoding&lt;/em&gt; 및 &lt;em&gt;errors&lt;/em&gt; 매개 변수는 &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;str.encode()&lt;/code&gt; &lt;/a&gt; 메서드 에서 허용하는 비 ASCII 문자를 처리하는 방법을 지정합니다 . &lt;em&gt;인코딩의&lt;/em&gt; 기본값은 &lt;code&gt;'utf-8'&lt;/code&gt; 입니다. &lt;em&gt;오류의&lt;/em&gt; 기본값은 &lt;code&gt;'strict'&lt;/code&gt; 이며, 지원되지 않는 문자는 &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt; &lt;code&gt;UnicodeEncodeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. &lt;em&gt;string&lt;/em&gt; 이 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 이거나 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생한 경우 &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 를 제공하면 안됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d52651b83fb8c2ce192590a93cdcd443fc58c23" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; parameters specify how to decode percent-encoded sequences into Unicode characters, as accepted by the &lt;a href=&quot;stdtypes#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;encoding&lt;/em&gt; 및 &lt;em&gt;errors&lt;/em&gt; 매개 변수는 &lt;a href=&quot;stdtypes#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode()&lt;/code&gt; &lt;/a&gt; 메서드 에서 허용하는대로 퍼센트 인코딩 된 시퀀스를 유니 코드 문자로 디코딩하는 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="c6cb43af4c276c4e243c12913d3915e800c71e09" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;exitmsg&lt;/em&gt; argument specifies an exit message printed when exiting. Pass the empty string to suppress the exit message. If &lt;em&gt;exitmsg&lt;/em&gt; is not given or &lt;code&gt;None&lt;/code&gt;, a default message is printed.</source>
          <target state="translated">선택적인 &lt;em&gt;exitmsg&lt;/em&gt; 인수는 종료시 인쇄되는 종료 메시지를 지정합니다. 종료 메시지를 표시하지 않으려면 빈 문자열을 전달하십시오. 경우 &lt;em&gt;exitmsg이&lt;/em&gt; 주어지지되지 않거나 &lt;code&gt;None&lt;/code&gt; , 기본 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ce349780903fc8ead95f9243483607a1fb9de74f" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;filenames&lt;/em&gt; parameter can be used to cause additional files to be loaded &amp;ldquo;on top&amp;rdquo; of the default database.</source>
          <target state="translated">선택적 &lt;em&gt;파일 이름&lt;/em&gt; 매개 변수를 사용하면 추가 파일을 기본 데이터베이스의 &quot;맨 위에&quot;로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2afc084433a50c8aee38aa46e2a079fe45493d8" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;filter&lt;/em&gt; argument specifies a callback function that is passed a Path object representing the path to the file being added (relative to the source directory). It should return &lt;code&gt;True&lt;/code&gt; if the file is to be added.</source>
          <target state="translated">선택적 &lt;em&gt;필터&lt;/em&gt; 인수는 추가 할 파일의 경로 (소스 디렉토리와 관련)를 나타내는 Path 객체에 전달되는 콜백 함수를 지정합니다. 파일을 추가하려면 &lt;code&gt;True&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7adfa10c0845595ebef1129a659b3a22de006482" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;flag&lt;/em&gt; argument can be:</source>
          <target state="translated">선택적 &lt;em&gt;플래그&lt;/em&gt; 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b0fad8cff8990cf8144da00de90aa4c3d5f814a" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;flag&lt;/em&gt; argument must be one of these values:</source>
          <target state="translated">선택적 &lt;em&gt;플래그&lt;/em&gt; 인수는 다음 값 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1b3549fcf300b3be3698b191796788541c8652d0" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;ident&lt;/em&gt; keyword argument is a string which is prepended to every message, and defaults to &lt;code&gt;sys.argv[0]&lt;/code&gt; with leading path components stripped. The optional &lt;em&gt;logoption&lt;/em&gt; keyword argument (default is 0) is a bit field &amp;ndash; see below for possible values to combine. The optional &lt;em&gt;facility&lt;/em&gt; keyword argument (default is &lt;code&gt;LOG_USER&lt;/code&gt;) sets the default facility for messages which do not have a facility explicitly encoded.</source>
          <target state="translated">선택적 &lt;em&gt;ident&lt;/em&gt; 키워드 인수는 모든 메시지 앞에 추가되는 문자열이며, 선행 경로 구성 요소가 제거 된 상태로 기본값은 &lt;code&gt;sys.argv[0]&lt;/code&gt; 입니다. 선택적 &lt;em&gt;logoption&lt;/em&gt; 키워드 인수 (기본값은 0)는 비트 필드입니다. 가능한 값을 결합하려면 아래를 참조하십시오. 선택적 &lt;em&gt;시설&lt;/em&gt; 키워드 인수 (기본값은 &lt;code&gt;LOG_USER&lt;/code&gt; )는 시설이 명시 적으로 인코딩되지 않은 메시지의 기본 시설을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b66c46da2d489751327253e23117ac1b4cb6af20" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;input&lt;/em&gt; argument is the data (&lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object) that will be sent to the child process.</source>
          <target state="translated">선택적 &lt;em&gt;입력&lt;/em&gt; 인수는 하위 프로세스로 전송 될 데이터 ( &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 오브젝트)입니다.</target>
        </trans-unit>
        <trans-unit id="cb9659b35a23a15fa2ac13b1030a3f18b99e659d" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;limit&lt;/em&gt; argument has the same meaning as for &lt;a href=&quot;#traceback.print_tb&quot;&gt;&lt;code&gt;print_tb()&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;chain&lt;/em&gt; is true (the default), then chained exceptions (the &lt;code&gt;__cause__&lt;/code&gt; or &lt;code&gt;__context__&lt;/code&gt; attributes of the exception) will be printed as well, like the interpreter itself does when printing an unhandled exception.</source>
          <target state="translated">선택적 &lt;em&gt;limit&lt;/em&gt; 인수는 &lt;a href=&quot;#traceback.print_tb&quot;&gt; &lt;code&gt;print_tb()&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 . 경우 &lt;em&gt;체인이&lt;/em&gt; true (디폴트), 다음 체인 예외합니다 ( &lt;code&gt;__cause__&lt;/code&gt; 또는 &lt;code&gt;__context__&lt;/code&gt; 예외의 속성)뿐만 아니라 인쇄됩니다 인터프리터 자체와 같은 처리되지 않은 예외를 인쇄 할 때 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc005c8fd7c6f9b0fc8d7c99b771a2963ec6128f" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;limit&lt;/em&gt; argument sets the maximum number of frames to return; by default all available frames are returned. The ordering of the returned list differs depending on whether a stack or a traceback is returned: the newest frames of a stack are returned, but the oldest frames of a traceback are returned. (This matches the behavior of the traceback module.)</source>
          <target state="translated">선택적인 &lt;em&gt;limit&lt;/em&gt; 인수는 반환 할 최대 프레임 수를 설정합니다. 기본적으로 사용 가능한 모든 프레임이 반환됩니다. 반환 된 목록의 순서는 스택 또는 트레이스 백이 반환되는지 여부에 따라 달라집니다. 스택의 최신 프레임이 반환되지만 트레이스 백의 가장 오래된 프레임이 반환됩니다. (이것은 트레이스 백 모듈의 동작과 일치합니다.)</target>
        </trans-unit>
        <trans-unit id="2e48eb3fc4c4ac3309a398fb53b8ab84156ddcd5" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;lock&lt;/em&gt; argument must be a &lt;a href=&quot;#asyncio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; object or &lt;code&gt;None&lt;/code&gt;. In the latter case a new Lock object is created automatically.</source>
          <target state="translated">선택적 &lt;em&gt;잠금&lt;/em&gt; 인수는 &lt;a href=&quot;#asyncio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 객체 또는 &lt;code&gt;None&lt;/code&gt; 이어야합니다 . 후자의 경우 새로운 Lock 객체가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b42d2cc0d17afc9196b211dfa5e1e450b5e939e1" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;mode&lt;/em&gt; argument is the Unix mode of the file, used only when the database has to be created. It defaults to octal &lt;code&gt;0o666&lt;/code&gt; (and will be modified by the prevailing umask).</source>
          <target state="translated">선택적 &lt;em&gt;mode&lt;/em&gt; 인수는 파일을 생성해야 할 때만 사용되는 파일의 Unix 모드입니다. 기본값은 8 진수 &lt;code&gt;0o666&lt;/code&gt; 이며 기본 umask에 의해 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="029d151e40f320abfb58312618932d44d1d0d877" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;mode&lt;/em&gt; argument is the Unix mode of the file, used only when the database has to be created. It defaults to octal &lt;code&gt;0o666&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;mode&lt;/em&gt; 인수는 파일을 생성해야 할 때만 사용되는 파일의 Unix 모드입니다. 기본값은 8 진수 &lt;code&gt;0o666&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f89c89d7cc14e84a0d940c7efe3085b1dee849e" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;parameters&lt;/em&gt; argument is a sequence of &lt;a href=&quot;#inspect.Parameter&quot;&gt;&lt;code&gt;Parameter&lt;/code&gt;&lt;/a&gt; objects, which is validated to check that there are no parameters with duplicate names, and that the parameters are in the right order, i.e. positional-only first, then positional-or-keyword, and that parameters with defaults follow parameters without defaults.</source>
          <target state="translated">선택적 &lt;em&gt;parameters&lt;/em&gt; 인수는 이름이 중복 된 매개 변수가없고 매개 변수 의 순서 가 올바른지 (예 : 위치 만 먼저, 위치 또는 키워드) 확인하기 위해 유효성 검증되는 일련의 &lt;a href=&quot;#inspect.Parameter&quot;&gt; &lt;code&gt;Parameter&lt;/code&gt; &lt;/a&gt; 오브젝트입니다. 기본값이있는 매개 변수는 기본값이없는 매개 변수를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3c2efe77995187192106dd6a744fa8bed07098b5" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;paramflags&lt;/em&gt; parameter creates foreign function wrappers with much more functionality than the features described above.</source>
          <target state="translated">선택적 &lt;em&gt;paramflags&lt;/em&gt; 매개 변수는 위에서 설명한 기능보다 훨씬 많은 기능을 가진 외부 함수 랩퍼를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="487d54d438198bdbad16eba2ec97ff38172aa6a9" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;pos&lt;/em&gt; and &lt;em&gt;endpos&lt;/em&gt; parameters have the same meaning as for the &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;pos&lt;/em&gt; 및 &lt;em&gt;endpos&lt;/em&gt; 매개 변수는 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7a84450f98705729642aee9ae31e477bc17c9299" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;predicate&lt;/em&gt; argument can be used to control which lines are indented. For example, it is easy to add &lt;em&gt;prefix&lt;/em&gt; to even empty and whitespace-only lines:</source>
          <target state="translated">선택적 &lt;em&gt;술어&lt;/em&gt; 인수는 들여 쓰기되는 행을 제어하는 ​​데 사용할 수 있습니다. 예를 들어, 빈 줄과 공백 줄에만 &lt;em&gt;접두사&lt;/em&gt; 를 추가하는 것이 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="59179432222144e76da812f3f997401dd9db5679" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;protocol&lt;/em&gt; argument, an integer, tells the pickler to use the given protocol; supported protocols are 0 to &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt;&lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt;&lt;/a&gt;. If not specified, the default is &lt;a href=&quot;#pickle.DEFAULT_PROTOCOL&quot;&gt;&lt;code&gt;DEFAULT_PROTOCOL&lt;/code&gt;&lt;/a&gt;. If a negative number is specified, &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt;&lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt;&lt;/a&gt; is selected.</source>
          <target state="translated">선택적 &lt;em&gt;프로토콜&lt;/em&gt; 인수 인 정수는 피커에게 지정된 프로토콜을 사용하도록 지시합니다. 지원되는 프로토콜은 0 ~ &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt; &lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt; &lt;/a&gt; 입니다. 지정하지 않으면 기본값은 &lt;a href=&quot;#pickle.DEFAULT_PROTOCOL&quot;&gt; &lt;code&gt;DEFAULT_PROTOCOL&lt;/code&gt; &lt;/a&gt; 입니다. 음수가 지정되면 &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt; &lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt; &lt;/a&gt; 이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="51d07a48c7b5cc26a17814015f91daa6a78b56e2" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;proxies&lt;/em&gt; parameter should be a dictionary mapping scheme names to proxy URLs, where an empty dictionary turns proxies off completely. Its default value is &lt;code&gt;None&lt;/code&gt;, in which case environmental proxy settings will be used if present, as discussed in the definition of &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt;, above.</source>
          <target state="translated">선택적 &lt;em&gt;프록시&lt;/em&gt; 매개 변수는 빈 사전이 프록시를 완전히 끄는 프록시 URL에 대한 사전 맵핑 체계 이름이어야합니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 이며,이 경우 위 의 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 정의에서 설명한대로 환경 프록시 설정이있는 경우 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7b4762aeb6be50cb5acb0bbcbaca83494d31e4e" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;return_annotation&lt;/em&gt; argument, can be an arbitrary Python object, is the &amp;ldquo;return&amp;rdquo; annotation of the callable.</source>
          <target state="translated">선택적 &lt;em&gt;return_annotation&lt;/em&gt; 인수는 임의의 Python 객체 일 수 있으며 호출 가능 항목의 &quot;반환&quot;주석입니다.</target>
        </trans-unit>
        <trans-unit id="9791e97e7f095a2523ef0cf02aa9f3d40350ebcd" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;source&lt;/em&gt; parameter can be used to initialize the array in a few different ways:</source>
          <target state="translated">선택적 &lt;em&gt;source&lt;/em&gt; 매개 변수를 사용하여 몇 가지 다른 방식으로 배열을 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60b8aa383fe8f256dde67518fd7472e77cc0598f" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;strict&lt;/em&gt; argument has the same meaning as with the &lt;a href=&quot;#mimetypes.guess_type&quot;&gt;&lt;code&gt;guess_type()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">선택적 &lt;em&gt;strict&lt;/em&gt; 인수는 &lt;a href=&quot;#mimetypes.guess_type&quot;&gt; &lt;code&gt;guess_type()&lt;/code&gt; &lt;/a&gt; 함수 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0a8a870ff2656d010f642cb9381fb991c9fbe6f2" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;strict&lt;/em&gt; argument is a flag specifying whether the list of known MIME types is limited to only the official types &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;registered with IANA&lt;/a&gt;. When &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), only the IANA types are supported; when &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, some additional non-standard but commonly used MIME types are also recognized.</source>
          <target state="translated">선택적 &lt;em&gt;strict&lt;/em&gt; 인수는 알려진 MIME 유형 목록이 &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;IANA에 등록 된&lt;/a&gt; 공식 유형으로 만 제한되는지 여부를 지정하는 플래그 입니다. 때 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; (기본값) 만 IANA 유형이 지원됩니다; &lt;em&gt;strict&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 비표준이지만 일반적으로 사용되는 일부 추가 MIME 유형도 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="d631d5a775f639907931a2bb4d9373c258daeb35" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). This actually only works for HTTP, HTTPS and FTP connections.</source>
          <target state="translated">선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수는 연결 시도와 같은 작업을 차단하기위한 시간 초과를 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간 초과 설정이 사용됨). 이것은 실제로 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2faffb1579b0e037a977fbe1deaf0ae8dd4a004f" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;value&lt;/em&gt; argument gives the initial value for the internal counter (&lt;code&gt;1&lt;/code&gt; by default). If the given value is less than &lt;code&gt;0&lt;/code&gt; a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">선택적 &lt;em&gt;값&lt;/em&gt; 인수는 내부 카운터의 초기 값을 제공합니다 ( 기본적으로 &lt;code&gt;1&lt;/code&gt; ). 주어진 값보다 작은 경우에는 &lt;code&gt;0&lt;/code&gt; 을&lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="27c7d00b63717d48144815c6c76db43f7906994c" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;verbose&lt;/em&gt; argument controls how detailed the summary is. If the verbosity is not specified, then the &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s verbosity is used.</source>
          <target state="translated">선택적 &lt;em&gt;verbose&lt;/em&gt; 인수는 요약 세부 사항을 제어합니다. 세부 정보가 지정되지 않은 경우 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 의 세부 정보가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1dc25ec26f6874dc2abe93167acb07ecd5ab080b" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;fd&lt;/code&gt; (default &lt;code&gt;STDOUT_FILENO&lt;/code&gt;, or standard output) specifies which file descriptor should be queried.</source>
          <target state="translated">선택적 인수 &lt;code&gt;fd&lt;/code&gt; (기본 &lt;code&gt;STDOUT_FILENO&lt;/code&gt; 또는 표준 출력)는 조회 할 파일 디스크립터를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="35651ff094b62a3a2a04e7110b3eaf4a7398af5f" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;arg&lt;/em&gt; can be an integer giving the exit status (defaulting to zero), or another type of object. If it is an integer, zero is considered &amp;ldquo;successful termination&amp;rdquo; and any nonzero value is considered &amp;ldquo;abnormal termination&amp;rdquo; by shells and the like. Most systems require it to be in the range 0&amp;ndash;127, and produce undefined results otherwise. Some systems have a convention for assigning specific meanings to specific exit codes, but these are generally underdeveloped; Unix programs generally use 2 for command line syntax errors and 1 for all other kind of errors. If another type of object is passed, &lt;code&gt;None&lt;/code&gt; is equivalent to passing zero, and any other object is printed to &lt;a href=&quot;#sys.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; and results in an exit code of 1. In particular, &lt;code&gt;sys.exit(&quot;some error message&quot;)&lt;/code&gt; is a quick way to exit a program when an error occurs.</source>
          <target state="translated">선택적 인수 &lt;em&gt;arg&lt;/em&gt; 는 종료 상태 (기본값은 0)를 나타내는 정수 또는 다른 유형의 객체 일 수 있습니다. 정수이면 0은 &quot;성공적인 종료&quot;로 간주되고 0이 아닌 값은 쉘 등에 의해 &quot;비정상 종료&quot;로 간주됩니다. 대부분의 시스템은 0-127 범위에 있어야하며 그렇지 않으면 정의되지 않은 결과를 생성합니다. 일부 시스템에는 특정 종료 코드에 특정 의미를 지정하기위한 규칙이 있지만 일반적으로 저개발 상태입니다. 유닉스 프로그램은 일반적으로 명령 줄 구문 오류에 2를 사용하고 다른 모든 종류의 오류에 1을 사용합니다. 다른 유형의 오브젝트가 전달되면 &lt;code&gt;None&lt;/code&gt; 은 0을 전달하는 것과 같고 다른 오브젝트는 &lt;a href=&quot;#sys.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; 에&lt;/a&gt; 인쇄되고 종료 코드는 1이됩니다. &lt;code&gt;sys.exit(&quot;some error message&quot;)&lt;/code&gt; 는 오류가 발생할 때 프로그램을 종료하는 빠른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b85c12e76b3ce55282bb04482401663a22bbd49a" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;autojunk&lt;/em&gt; can be used to disable the automatic junk heuristic.</source>
          <target state="translated">선택적인 인수 인 &lt;em&gt;autojunk&lt;/em&gt; 를 사용하여 자동 정크 휴리스틱을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f79bbfd397d27c41f3752747e77e178290e439c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;completekey&lt;/em&gt; is the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; name of a completion key; it defaults to</source>
          <target state="translated">선택적 인수 &lt;em&gt;completekey&lt;/em&gt; 는 완료 키 의 &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 이름입니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="edd0166f5e246da03becb616498f475276899b64" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;count&lt;/em&gt; is the maximum number of pattern occurrences to be replaced; &lt;em&gt;count&lt;/em&gt; must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so &lt;code&gt;sub('x*', '-', 'abxd')&lt;/code&gt; returns &lt;code&gt;'-a-b--d-'&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;개수&lt;/em&gt; 는 교체 할 최대 패턴 발생 수입니다. &lt;em&gt;count&lt;/em&gt; 는 음이 아닌 정수 여야합니다. 생략하거나 0으로 설정하면 모든 항목이 교체됩니다. 패턴에 대한 빈 일치는 이전 빈 일치에 인접하지 않은 경우에만 대체되므로 &lt;code&gt;sub('x*', '-', 'abxd')&lt;/code&gt; 는 &lt;code&gt;'-a-b--d-'&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="007197ec8a2cf2974cf1f204c0cba442e4bce16f" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;display&lt;/em&gt; defaults to &lt;code&gt;1&lt;/code&gt; and can be set to &lt;code&gt;0&lt;/code&gt; to suppress sending the traceback to the browser. If the argument &lt;em&gt;logdir&lt;/em&gt; is present, the traceback reports are written to files. The value of &lt;em&gt;logdir&lt;/em&gt; should be a directory where these files will be placed. The optional argument &lt;em&gt;context&lt;/em&gt; is the number of lines of context to display around the current line of source code in the traceback; this defaults to &lt;code&gt;5&lt;/code&gt;. If the optional argument &lt;em&gt;format&lt;/em&gt; is &lt;code&gt;&quot;html&quot;&lt;/code&gt;, the output is formatted as HTML. Any other value forces plain text output. The default value is &lt;code&gt;&quot;html&quot;&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;표시의&lt;/em&gt; 기본값은 &lt;code&gt;1&lt;/code&gt; 이며 추적을 브라우저로 보내지 않도록 &lt;code&gt;0&lt;/code&gt; 으로 설정할 수 있습니다 . &lt;em&gt;logdir&lt;/em&gt; 인수 가 존재하면, 역 추적 보고서가 파일에 기록됩니다. &lt;em&gt;logdir&lt;/em&gt; 의 값은 이러한 파일이 위치 할 디렉토리 여야합니다. 선택적 인수 &lt;em&gt;컨텍스트&lt;/em&gt; 는 트레이스 백에서 현재 소스 코드 행 주위에 표시 할 컨텍스트 행 수입니다. 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다. 선택적 인수 &lt;em&gt;형식&lt;/em&gt; 이 &lt;code&gt;&quot;html&quot;&lt;/code&gt; 인 경우 출력은 HTML 형식입니다. 다른 값은 일반 텍스트 출력을 강제합니다. 기본값은 &lt;code&gt;&quot;html&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4058ffb38f75eeab886cb4c4bceee30f7dc1845" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;flags&lt;/em&gt; also controls whether the compiled source is allowed to contain top-level &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;async for&lt;/code&gt; and &lt;code&gt;async with&lt;/code&gt;. When the bit &lt;code&gt;ast.PyCF_ALLOW_TOP_LEVEL_AWAIT&lt;/code&gt; is set, the return code object has &lt;code&gt;CO_COROUTINE&lt;/code&gt; set in &lt;code&gt;co_code&lt;/code&gt;, and can be interactively executed via &lt;code&gt;await eval(code_object)&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;플래그&lt;/em&gt; 는 컴파일 된 소스에 최상위 &lt;code&gt;await&lt;/code&gt; , &lt;code&gt;async for&lt;/code&gt; 및 &lt;code&gt;async with&lt;/code&gt; 가 포함될 수 있는지 여부도 제어합니다 . 비트 때 &lt;code&gt;ast.PyCF_ALLOW_TOP_LEVEL_AWAIT&lt;/code&gt; 가 설정되고, 리턴 코드 객체 갖는다 &lt;code&gt;CO_COROUTINE&lt;/code&gt; 에서 의 집합 &lt;code&gt;co_code&lt;/code&gt; 를 , 그리고 대화를 통해 실행될 수 &lt;code&gt;await eval(code_object)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b24d235886d995066464dc1241876c6f316c91d4" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;i&lt;/em&gt; defaults to &lt;code&gt;-1&lt;/code&gt;, so that by default the last item is removed and returned.</source>
          <target state="translated">선택적 인수 &lt;em&gt;i의&lt;/em&gt; 기본값은 &lt;code&gt;-1&lt;/code&gt; 이므로 기본적으로 마지막 항목이 제거되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b621b2d52bf8161446e23d3c23e8f342b23f4dd5" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;initial_bytes&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; that contains initial data.</source>
          <target state="translated">선택적 인수 &lt;em&gt;initial_bytes&lt;/em&gt; 는 초기 데이터를 포함 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e42a8d2cefe3a4f20592ee996f743f43bac1a227" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;keep_blank_values&lt;/em&gt; is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings. A true value indicates that blanks should be retained as blank strings. The default false value indicates that blank values are to be ignored and treated as if they were not included.</source>
          <target state="translated">선택적 인수 &lt;em&gt;keep_blank_values&lt;/em&gt; 는 퍼센트로 인코딩 된 쿼리의 공백 값을 공백 문자열로 처리해야하는지 여부를 나타내는 플래그입니다. true 값은 공백을 공백 문자열로 유지해야 함을 나타냅니다. 기본 false 값은 공백 값이 무시되고 포함되지 않은 것처럼 처리됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ca0255c69b9b315a63bc27ff96f8bb13d5e275d" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;max_num_fields&lt;/em&gt; is the maximum number of fields to read. If set, then throws a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if there are more than &lt;em&gt;max_num_fields&lt;/em&gt; fields read.</source>
          <target state="translated">선택적 인수 &lt;em&gt;max_num_fields&lt;/em&gt; 는 읽을 최대 필드 수입니다. 설정된 경우 &lt;em&gt;max_num_fields&lt;/em&gt; 이상의 필드를 읽은 경우 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;발생&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="514b043f74d2fc465dec58074f2180b75d368dc7" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;name&lt;/em&gt; specifies the object&amp;rsquo;s name; this name will be used to construct names for the returned &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt;s. If &lt;em&gt;name&lt;/em&gt; is not specified, then &lt;code&gt;obj.__name__&lt;/code&gt; is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;이름&lt;/em&gt; 은 객체 &lt;em&gt;이름을&lt;/em&gt; 지정합니다. 이 이름은 반환 된 &lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 의 이름을 구성하는 데 사용됩니다 . 경우 &lt;em&gt;이름이&lt;/em&gt; 지정되어 있지 않은 경우, &lt;code&gt;obj.__name__&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="61cddf736ae6d12c0d3bb5ee499bb75bfd0c2442" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;parser&lt;/em&gt; specifies the &lt;a href=&quot;#doctest.DocTestParser&quot;&gt;&lt;code&gt;DocTestParser&lt;/code&gt;&lt;/a&gt; object (or a drop-in replacement) that is used to extract doctests from docstrings.</source>
          <target state="translated">선택적 인수 &lt;em&gt;구문 분석기&lt;/em&gt; 는 docstring에서 doctest를 추출하는 데 사용되는 &lt;a href=&quot;#doctest.DocTestParser&quot;&gt; &lt;code&gt;DocTestParser&lt;/code&gt; &lt;/a&gt; 오브젝트 (또는 드롭 인 대체)를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0d72ec9247df1cd0305e14348ae7c7e78e306ed1" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;random&lt;/em&gt; is a 0-argument function returning a random float in [0.0, 1.0); by default, this is the function &lt;a href=&quot;#random.random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;random&lt;/em&gt; 은 [0.0, 1.0)으로 임의의 부동 소수점을 반환하는 0 인수 함수입니다. 기본적으로 이것은 &lt;a href=&quot;#random.random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="471908e527760c937940985bc7ab6b5fbc56dd90" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;sep&lt;/em&gt; (default &lt;code&gt;'T'&lt;/code&gt;) is a one-character separator, placed between the date and time portions of the result. For example:</source>
          <target state="translated">선택적 인수 &lt;em&gt;sep&lt;/em&gt; (기본값 &lt;code&gt;'T'&lt;/code&gt; )는 결과의 날짜와 시간 부분 사이에있는 한 문자 구분 기호입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6078dc1dd882bcafe2606bc389f8fe3bb8a8fea0" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;strict_parsing&lt;/em&gt; is a flag indicating what to do with parsing errors. If false (the default), errors are silently ignored. If true, errors raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">선택적 인수 &lt;em&gt;strict_parsing&lt;/em&gt; 은 구문 분석 오류로 수행 할 작업을 나타내는 플래그입니다. false (기본값)이면 오류가 자동으로 무시됩니다. true이면 오류가 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="57ff14434679779b7626393e005a3fe4d3584339" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;timespec&lt;/em&gt; specifies the number of additional components of the time to include (the default is &lt;code&gt;'auto'&lt;/code&gt;). It can be one of the following:</source>
          <target state="translated">선택적 인수 &lt;em&gt;timespec&lt;/em&gt; 은 포함 할 시간의 추가 구성 요소 수를 지정합니다 (기본값은 &lt;code&gt;'auto'&lt;/code&gt; 입니다 ). 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b614d39325d8f7a11487aa19af1646166702e410" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;em&gt;verbose&lt;/em&gt; can be used to display the objects searched by the finder. It defaults to &lt;code&gt;False&lt;/code&gt; (no output).</source>
          <target state="translated">선택적 인수 &lt;em&gt;verbose&lt;/em&gt; 를 사용하여 파인더가 검색 한 오브젝트를 표시 할 수 있습니다. 기본값은 &lt;code&gt;False&lt;/code&gt; (출력 없음)입니다.</target>
        </trans-unit>
        <trans-unit id="10af946136a130d5b30e416167c2110f84bcfba1" translate="yes" xml:space="preserve">
          <source>The optional argument gives the initial &lt;em&gt;value&lt;/em&gt; for the internal counter; it defaults to &lt;code&gt;1&lt;/code&gt;. If the &lt;em&gt;value&lt;/em&gt; given is less than 0, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">선택적 인수는 내부 카운터 의 초기 &lt;em&gt;값&lt;/em&gt; 을 제공합니다 . 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 는 IF &lt;em&gt;값이&lt;/em&gt; 주어진이 0보다 작은, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80f9adbef3f8b3728449cbd66cc5fce3e359242a" translate="yes" xml:space="preserve">
          <source>The optional argument is a banner or intro string to be issued before the first prompt (this overrides the &lt;a href=&quot;#cmd.Cmd.intro&quot;&gt;&lt;code&gt;intro&lt;/code&gt;&lt;/a&gt; class attribute).</source>
          <target state="translated">선택적 인수는 첫 번째 프롬프트 전에 발행 할 배너 또는 소개 문자열입니다 (이는 &lt;a href=&quot;#cmd.Cmd.intro&quot;&gt; &lt;code&gt;intro&lt;/code&gt; &lt;/a&gt; 클래스 속성을 대체 합니다).</target>
        </trans-unit>
        <trans-unit id="0ca7b0833d38e33a40c85e661ee7c9c7a8f78930" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are sequences to be compared; both default to empty strings. The elements of both sequences must be &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 는 비교할 시퀀스입니다. 둘 다 기본값은 빈 문자열입니다. 두 시퀀스의 요소는 모두 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;해시 가능&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="280d3e72caf4f6c3027aa7ba08454659445a2fa3" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;em&gt;fix_imports&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; are used to control compatibility support for pickle stream generated by Python 2. If &lt;em&gt;fix_imports&lt;/em&gt; is true, pickle will try to map the old Python 2 names to the new names used in Python 3. The &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; tell pickle how to decode 8-bit string instances pickled by Python 2; these default to &amp;lsquo;ASCII&amp;rsquo; and &amp;lsquo;strict&amp;rsquo;, respectively. The &lt;em&gt;encoding&lt;/em&gt; can be &amp;lsquo;bytes&amp;rsquo; to read these 8-bit string instances as bytes objects. Using &lt;code&gt;encoding='latin1'&lt;/code&gt; is required for unpickling NumPy arrays and instances of &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;datetime#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; pickled by Python 2.</source>
          <target state="translated">선택적 인수 &lt;em&gt;fix_imports&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; 및 &lt;em&gt;errors&lt;/em&gt; 는 Python 2에서 생성 된 pickle stream에 대한 호환성 지원을 제어하는 ​​데 사용됩니다. &lt;em&gt;fix_imports&lt;/em&gt; 가 true 인 경우 pickle은 이전 Python 2 이름을 Python 3에서 사용 된 새 이름에 맵핑하려고 시도합니다. &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; Python 2에 의해 절인 8 비트 문자열 인스턴스를 디코딩하는 방법을 pickle에게 알려줍니다. 이들은 각각 'ASCII'및 'strict'로 설정됩니다. &lt;em&gt;인코딩&lt;/em&gt; 바이트 개체로이 8 비트 문자열 인스턴스를 읽기 '바이트'가 될 수 있습니다. 사용 &lt;code&gt;encoding='latin1'&lt;/code&gt; NumPy와 배열과의 인스턴스 unpickling에 필요한 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;datetime#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 와&lt;a href=&quot;datetime#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt;파이썬 2에 의해 절인 시간 .</target>
        </trans-unit>
        <trans-unit id="b90d21eecece05bde07d323f5ae4544c33e89c53" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;em&gt;flags&lt;/em&gt; and &lt;em&gt;dont_inherit&lt;/em&gt; control which &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#future&quot;&gt;future statements&lt;/a&gt; affect the compilation of &lt;em&gt;source&lt;/em&gt;. If neither is present (or both are zero) the code is compiled with those future statements that are in effect in the code that is calling &lt;a href=&quot;#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;. If the &lt;em&gt;flags&lt;/em&gt; argument is given and &lt;em&gt;dont_inherit&lt;/em&gt; is not (or is zero) then the future statements specified by the &lt;em&gt;flags&lt;/em&gt; argument are used in addition to those that would be used anyway. If &lt;em&gt;dont_inherit&lt;/em&gt; is a non-zero integer then the &lt;em&gt;flags&lt;/em&gt; argument is it &amp;ndash; the future statements in effect around the call to compile are ignored.</source>
          <target state="translated">선택적 arguments &lt;em&gt;플래그&lt;/em&gt; 및 &lt;em&gt;dont_inherit는&lt;/em&gt; 어떤 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#future&quot;&gt;미래 명령문&lt;/a&gt; 이 &lt;em&gt;소스&lt;/em&gt; 컴파일에 영향을 미치는지 제어 &lt;em&gt;합니다&lt;/em&gt; . 둘 다 존재하지 않거나 둘 다 0 인 경우, 코드는 &lt;a href=&quot;#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 호출하는 코드에 적용되는 향후 명령문으로 컴파일 됩니다. 는 IF &lt;em&gt;플래그&lt;/em&gt; 인수가 제공되고 &lt;em&gt;dont_inherit은&lt;/em&gt; 다음에 의해 지정된 미래의 문없는 (또는 제로) &lt;em&gt;플래그&lt;/em&gt; 인수 어쨌든 사용되는 것들에 추가하여 사용된다. 경우 &lt;em&gt;dont_inherit이&lt;/em&gt; 다음 비제로 정수입니다 &lt;em&gt;플래그&lt;/em&gt; 인수는이다 - 무시됩니다 컴파일에 대한 호출 주위에 적용되는 미래의 문.</target>
        </trans-unit>
        <trans-unit id="1c074678e55bc706eadde357a56e82a33341af0f" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;em&gt;stdin&lt;/em&gt; and &lt;em&gt;stdout&lt;/em&gt; specify the input and output file objects that the Cmd instance or subclass instance will use for input and output. If not specified, they will default to &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;stdin&lt;/em&gt; 및 &lt;em&gt;stdout&lt;/em&gt; 은 Cmd 인스턴스 또는 서브 클래스 인스턴스가 입력 및 출력에 사용할 입력 및 출력 파일 오브젝트를 지정합니다. 지정하지 않으면 기본값은 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c0a3fb9fd0485751e63083c8010f030163b3f45" translate="yes" xml:space="preserve">
          <source>The optional dictionary argument &lt;em&gt;init_globals&lt;/em&gt; may be used to pre-populate the module&amp;rsquo;s globals dictionary before the code is executed. The supplied dictionary will not be modified. If any of the special global variables below are defined in the supplied dictionary, those definitions are overridden by &lt;a href=&quot;#runpy.run_module&quot;&gt;&lt;code&gt;run_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 사전 인수 &lt;em&gt;init_globals를&lt;/em&gt; 사용하면 코드가 실행되기 전에 모듈의 전역 사전을 미리 채울 수 있습니다. 제공된 사전은 수정되지 않습니다. 아래의 특수 전역 변수가 제공된 사전에 정의되어 &lt;a href=&quot;#runpy.run_module&quot;&gt; &lt;code&gt;run_module()&lt;/code&gt; &lt;/a&gt; 이 해당 정의를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="2d791b4306cfa5a7c3476b135379d33a7c54a9c8" translate="yes" xml:space="preserve">
          <source>The optional dictionary argument &lt;em&gt;init_globals&lt;/em&gt; may be used to pre-populate the module&amp;rsquo;s globals dictionary before the code is executed. The supplied dictionary will not be modified. If any of the special global variables below are defined in the supplied dictionary, those definitions are overridden by &lt;a href=&quot;#runpy.run_path&quot;&gt;&lt;code&gt;run_path()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 사전 인수 &lt;em&gt;init_globals를&lt;/em&gt; 사용하면 코드가 실행되기 전에 모듈의 전역 사전을 미리 채울 수 있습니다. 제공된 사전은 수정되지 않습니다. 아래의 특수 전역 변수가 제공된 사전에 정의되어 &lt;a href=&quot;#runpy.run_path&quot;&gt; &lt;code&gt;run_path()&lt;/code&gt; &lt;/a&gt; 가 해당 정의를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="c0b119afc071dbab13a10cf9b7cf631db10d0a72" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;em&gt;checker&lt;/em&gt; specifies the &lt;a href=&quot;#doctest.OutputChecker&quot;&gt;&lt;code&gt;OutputChecker&lt;/code&gt;&lt;/a&gt; object (or drop-in replacement) that should be used to compare the expected outputs to the actual outputs of doctest examples.</source>
          <target state="translated">선택적 키워드 인수 &lt;em&gt;검사기&lt;/em&gt; 는 예상 출력을 doctest 예제의 실제 출력과 비교하는 데 사용해야 하는 &lt;a href=&quot;#doctest.OutputChecker&quot;&gt; &lt;code&gt;OutputChecker&lt;/code&gt; &lt;/a&gt; 객체 (또는 드롭 인 대체)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="15bab300aeb95a6a0ce45f3654d7b53117d9f5fa" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;em&gt;optionflags&lt;/em&gt; can be used to control how the test runner compares expected output to actual output, and how it displays failures. For more information, see section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt;.</source>
          <target state="translated">선택적 키워드 인수 &lt;em&gt;optionflags&lt;/em&gt; 를 사용하여 테스트 실행기가 예상 출력을 실제 출력과 비교하는 방법 및 실패를 표시하는 방법을 제어 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96b6d4c5c19dfebd08d1079fa3b65e27b6693151" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;em&gt;verbose&lt;/em&gt; controls the &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s verbosity. If &lt;em&gt;verbose&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, then information is printed about each example, as it is run. If &lt;em&gt;verbose&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, then only failures are printed. If &lt;em&gt;verbose&lt;/em&gt; is unspecified, or &lt;code&gt;None&lt;/code&gt;, then verbose output is used iff the command-line switch &lt;code&gt;-v&lt;/code&gt; is used.</source>
          <target state="translated">선택적 키워드 인수 &lt;em&gt;verbose&lt;/em&gt; 는 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;세부 정보를&lt;/em&gt; 제어합니다 . 경우 &lt;em&gt;자세한&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; 이 실행 될 때, 다음 정보는 각 예제에 대해 인쇄됩니다. 경우 &lt;em&gt;자세한 정보가&lt;/em&gt; 있습니다 &lt;code&gt;False&lt;/code&gt; , 만 실패가 인쇄되어 있습니다. 경우 &lt;em&gt;장황가&lt;/em&gt; 지정되어 있지 않은, 또는 &lt;code&gt;None&lt;/code&gt; 다음 상세 출력 명령 줄 스위치 IFF에 사용되지 &lt;code&gt;-v&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="3cb7914061af70176a9cadd39d9548b72cd9c0ab" translate="yes" xml:space="preserve">
          <source>The optional keyword-only &lt;em&gt;default&lt;/em&gt; parameter is returned by &lt;a href=&quot;#contextvars.ContextVar.get&quot;&gt;&lt;code&gt;ContextVar.get()&lt;/code&gt;&lt;/a&gt; when no value for the variable is found in the current context.</source>
          <target state="translated">현재 컨텍스트에서 변수 값을 찾을 수없는 경우 선택적 키워드 전용 &lt;em&gt;기본&lt;/em&gt; 매개 변수는 &lt;a href=&quot;#contextvars.ContextVar.get&quot;&gt; &lt;code&gt;ContextVar.get()&lt;/code&gt; &lt;/a&gt; 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fd0d0d2b4a3f5e7374139c6fda5cad296fbf033" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;em&gt;endpos&lt;/em&gt; limits how far the string will be searched; it will be as if the string is &lt;em&gt;endpos&lt;/em&gt; characters long, so only the characters from &lt;em&gt;pos&lt;/em&gt; to &lt;code&gt;endpos - 1&lt;/code&gt; will be searched for a match. If &lt;em&gt;endpos&lt;/em&gt; is less than &lt;em&gt;pos&lt;/em&gt;, no match will be found; otherwise, if &lt;em&gt;rx&lt;/em&gt; is a compiled regular expression object, &lt;code&gt;rx.search(string, 0, 50)&lt;/code&gt; is equivalent to &lt;code&gt;rx.search(string[:50], 0)&lt;/code&gt;.</source>
          <target state="translated">선택적 매개 변수 &lt;em&gt;endpos&lt;/em&gt; 는 문자열이 검색되는 거리를 제한합니다. 문자열이 &lt;em&gt;endpos&lt;/em&gt; 문자 길이 인 것처럼 &lt;em&gt;pos&lt;/em&gt; 에서 &lt;code&gt;endpos - 1&lt;/code&gt; 까지의 문자 만 검색됩니다. 경우 &lt;em&gt;endpos는이&lt;/em&gt; 보다 적은 &lt;em&gt;POS&lt;/em&gt; , 일치가 발견되지 않습니다; 그렇지 않으면 &lt;em&gt;rx&lt;/em&gt; 가 컴파일 된 정규식 객체 인 경우 &lt;code&gt;rx.search(string, 0, 50)&lt;/code&gt; 은 &lt;code&gt;rx.search(string[:50], 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd06d591623545a7f0948ebe91d224550cc3edc8" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;em&gt;length&lt;/em&gt; sets the initial size of the output buffer.</source>
          <target state="translated">선택적 매개 변수 &lt;em&gt;길이&lt;/em&gt; 는 출력 버퍼의 초기 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="39e84f6cb07d1b639d19390570fae491ee0031c8" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;em&gt;module&lt;/em&gt; is the module that contains the given object. If the module is not specified or is &lt;code&gt;None&lt;/code&gt;, then the test finder will attempt to automatically determine the correct module. The object&amp;rsquo;s module is used:</source>
          <target state="translated">선택적 매개 변수 &lt;em&gt;모듈&lt;/em&gt; 은 주어진 객체를 포함하는 모듈입니다. 모듈이 지정되지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 테스트 파인더가 올바른 모듈을 자동으로 판별하려고 시도합니다. 객체의 모듈이 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="29ef5309f6a96a5241e202f8bb194d1cf1929a0d" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;em&gt;newScmPrio&lt;/em&gt; can be given to reset the priority level of the Tk options set by the Tix schemes.</source>
          <target state="translated">Tix 스킴에 의해 설정된 Tk 옵션의 우선 순위 레벨을 재설정하기 위해 선택적 매개 변수 &lt;em&gt;newScmPrio를 제공&lt;/em&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="081e4d9b1a3e9f630ab40ede36fed947a098a418" translate="yes" xml:space="preserve">
          <source>The optional positional &lt;em&gt;args&lt;/em&gt; will be passed to the callback when it is called. If you want the callback to be called with keyword arguments use &lt;a href=&quot;functools#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 위치 &lt;em&gt;인수&lt;/em&gt; 는 호출 될 때 콜백으로 전달됩니다. 키워드 인수로 콜백을 호출하려면 &lt;a href=&quot;functools#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="668eb47fefd52438e0243b1889054e2490a3c22e" translate="yes" xml:space="preserve">
          <source>The optional second item is the parameter name as string. If this is specified, the foreign function can be called with named parameters.</source>
          <target state="translated">선택적 두 번째 항목은 매개 변수 이름 (문자열)입니다. 이를 지정하면 외부 매개 변수를 명명 된 매개 변수로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05c81d7894f8452dac25fb2733a9c05320f3e15e" translate="yes" xml:space="preserve">
          <source>The optional second parameter &lt;em&gt;pos&lt;/em&gt; gives an index in the string where the search is to start; it defaults to &lt;code&gt;0&lt;/code&gt;. This is not completely equivalent to slicing the string; the &lt;code&gt;'^'&lt;/code&gt; pattern character matches at the real beginning of the string and at positions just after a newline, but not necessarily at the index where the search is to start.</source>
          <target state="translated">선택적 두 번째 매개 변수 &lt;em&gt;pos&lt;/em&gt; 는 검색을 시작할 문자열의 색인을 제공합니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다. 이것은 문자열을 자르는 것과 완전히 동일하지는 않습니다. &lt;code&gt;'^'&lt;/code&gt; 바로 줄 바꿈 후 문자열의 실제 시작과 위치에서 패턴 문자는 일치하지만, 반드시 검색이 시작되는 인덱스.</target>
        </trans-unit>
        <trans-unit id="76e850e120b0be959c9b3d6c7b92a5ed59e98924" translate="yes" xml:space="preserve">
          <source>The optional third item is the default value for this parameter.</source>
          <target state="translated">선택적 세 번째 항목이이 매개 변수의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="60a1f579da15c11aeee7b1010b2d6f89b26ed4f4" translate="yes" xml:space="preserve">
          <source>The options supported by a given widget are listed in that widget&amp;rsquo;s man page, or can be queried at runtime by calling the &lt;code&gt;config()&lt;/code&gt; method without arguments, or by calling the &lt;code&gt;keys()&lt;/code&gt; method on that widget. The return value of these calls is a dictionary whose key is the name of the option as a string (for example, &lt;code&gt;'relief'&lt;/code&gt;) and whose values are 5-tuples.</source>
          <target state="translated">지정된 위젯이 지원하는 옵션은 해당 위젯의 매뉴얼 페이지에 나열되거나 인수없이 &lt;code&gt;config()&lt;/code&gt; 메소드를 호출하거나 해당 위젯 에서 &lt;code&gt;keys()&lt;/code&gt; 메소드를 호출하여 런타임에 조회 할 수 있습니다 . 이러한 호출의 리턴 값은 키가 옵션 이름 인 문자열 (예 : &lt;code&gt;'relief'&lt;/code&gt; )이고 값이 5 튜플 인 사전입니다.</target>
        </trans-unit>
        <trans-unit id="6f92379bc6bff3b3cf0551a98ef88027399670d3" translate="yes" xml:space="preserve">
          <source>The options to the &lt;a href=&quot;#cgitb.enable&quot;&gt;&lt;code&gt;enable()&lt;/code&gt;&lt;/a&gt; function control whether the report is displayed in the browser and whether the report is logged to a file for later analysis.</source>
          <target state="translated">&lt;a href=&quot;#cgitb.enable&quot;&gt; &lt;code&gt;enable()&lt;/code&gt; &lt;/a&gt; 함수에 대한 옵션 은 보고서가 브라우저에 표시되는지 여부와 나중에 분석하기 위해 보고서가 파일에 기록되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a5ac6774087e93b0abf13debc7f04f52108bcd15" translate="yes" xml:space="preserve">
          <source>The optionxform function transforms option names to a canonical form. This should be an idempotent function: if the name is already in canonical form, it should be returned unchanged.</source>
          <target state="translated">optionxform 함수는 옵션 이름을 정식 형식으로 변환합니다. 이는 dem 등원 함수 여야합니다. 이름이 이미 정식 형식 인 경우 변경되지 않은 상태로 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="fedeb12498dc0a0a0daa7f8b91e7ee947a38170d" translate="yes" xml:space="preserve">
          <source>The order in which data values are displayed may be controlled by setting the widget option &lt;code&gt;displaycolumns&lt;/code&gt;. The tree widget can also display column headings. Columns may be accessed by number or symbolic names listed in the widget option columns. See &lt;a href=&quot;#column-identifiers&quot;&gt;Column Identifiers&lt;/a&gt;.</source>
          <target state="translated">위젯 옵션 &lt;code&gt;displaycolumns&lt;/code&gt; 를 설정하여 데이터 값이 표시되는 순서를 제어 할 수 있습니다 . 트리 위젯은 열 제목을 표시 할 수도 있습니다. 위젯 옵션 열에 나열된 숫자 또는 기호 이름으로 열에 액세스 할 수 있습니다. &lt;a href=&quot;#column-identifiers&quot;&gt;열 식별자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83baddffa0f7cfb5cd6adb7522e86b328bf02dca" translate="yes" xml:space="preserve">
          <source>The order in which the various tests will be run is determined by sorting the test method names with respect to the built-in ordering for strings.</source>
          <target state="translated">다양한 테스트가 실행되는 순서는 내장 된 문자열 순서에 따라 테스트 메소드 이름을 정렬하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="42292f890191ffdd58c76862cd81565d76b0393d" translate="yes" xml:space="preserve">
          <source>The order in which these methods are called within each stage is determined by sorting the handler instances.</source>
          <target state="translated">이러한 단계가 각 단계 내에서 호출되는 순서는 핸들러 인스턴스를 정렬하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="06bdd39abab4e75a915cba22464964749e134194" translate="yes" xml:space="preserve">
          <source>The order is reversed: the most recent call is shown first.</source>
          <target state="translated">순서가 반대로됩니다. 가장 최근 통화가 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a6cd757b3866d5d1fb00b34c2843daf22f73d080" translate="yes" xml:space="preserve">
          <source>The order of arguments (link, target) is the reverse of &lt;a href=&quot;os#os.symlink&quot;&gt;&lt;code&gt;os.symlink()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s.</source>
          <target state="translated">인수의 순서 (link, target)는 &lt;a href=&quot;os#os.symlink&quot;&gt; &lt;code&gt;os.symlink()&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="22ebae13e1744671895f0fd794966474c5bc70f1" translate="yes" xml:space="preserve">
          <source>The order of the fields in all of the generated methods is the order in which they appear in the class definition.</source>
          <target state="translated">생성 된 모든 메소드에서 필드의 순서는 클래스 정의에 나타나는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="b302ecf6f9cf49b2ca3262ea42da1d8d1a5d4f4d" translate="yes" xml:space="preserve">
          <source>The order of the printing is based on the last &lt;a href=&quot;#pstats.Stats.sort_stats&quot;&gt;&lt;code&gt;sort_stats()&lt;/code&gt;&lt;/a&gt; operation done on the object (subject to caveats in &lt;a href=&quot;#pstats.Stats.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pstats.Stats.strip_dirs&quot;&gt;&lt;code&gt;strip_dirs()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">인쇄 순서는 객체에 대해 수행 된 마지막 &lt;a href=&quot;#pstats.Stats.sort_stats&quot;&gt; &lt;code&gt;sort_stats()&lt;/code&gt; &lt;/a&gt; 작업을 기반으로 합니다 ( &lt;a href=&quot;#pstats.Stats.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pstats.Stats.strip_dirs&quot;&gt; &lt;code&gt;strip_dirs()&lt;/code&gt; &lt;/a&gt; 사항에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="ed1a692ceb1b9aed38ff2e02d3d8fbd48c44171d" translate="yes" xml:space="preserve">
          <source>The ordering of format characters may have an impact on size since the padding needed to satisfy alignment requirements is different:</source>
          <target state="translated">정렬 요구 사항을 충족시키는 데 필요한 패딩이 다르기 때문에 형식 문자의 순서는 크기에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d088688a3b370980ea94cedecf9cc369fe607106" translate="yes" xml:space="preserve">
          <source>The original URL passed to the constructor.</source>
          <target state="translated">원래 URL이 생성자에 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="5e2f1a999123951c1cdbbd6fb89f2219feb47bd1" translate="yes" xml:space="preserve">
          <source>The original host for the request, without port.</source>
          <target state="translated">포트가없는 요청의 원래 호스트.</target>
        </trans-unit>
        <trans-unit id="2153b6973b156dda830b5a6e8c1928edc3726836" translate="yes" xml:space="preserve">
          <source>The original rationale and specification for this module.</source>
          <target state="translated">이 모듈의 원래 이론적 근거 및 사양.</target>
        </trans-unit>
        <trans-unit id="3c1d78973a4f5bf993cffd68ef197b54fb9d55ff" translate="yes" xml:space="preserve">
          <source>The original specification of the format.</source>
          <target state="translated">형식의 원래 사양입니다.</target>
        </trans-unit>
        <trans-unit id="36b9e17d7f2e8503ed3820ee72a6419f06a8992e" translate="yes" xml:space="preserve">
          <source>The original underlying function is accessible through the &lt;code&gt;__wrapped__&lt;/code&gt; attribute. This is useful for introspection, for bypassing the cache, or for rewrapping the function with a different cache.</source>
          <target state="translated">원래의 기본 기능은 &lt;code&gt;__wrapped__&lt;/code&gt; 속성을 통해 액세스 할 수 있습니다 . 이것은 검사, 캐시 우회 또는 다른 캐시로 함수를 다시 랩핑하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1f5e734ae157beef9dabb5ce27cc3a21d3922b13" translate="yes" xml:space="preserve">
          <source>The other advantage of weakref based finalizers is that they can be used to register finalizers for classes where the definition is controlled by a third party, such as running code when a module is unloaded:</source>
          <target state="translated">weakref 기반 종료 자의 다른 장점은 모듈이 언로드 될 때 코드 실행과 같이 타사에서 정의를 제어하는 ​​클래스에 대해 종료자를 등록하는 데 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b23f8bd154c8799ba585c5a6902590dd8594933" translate="yes" xml:space="preserve">
          <source>The other arguments have the same meaning as in &lt;a href=&quot;#json.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt;, except &lt;em&gt;encoding&lt;/em&gt; which is ignored and deprecated since Python 3.1.</source>
          <target state="translated">다른 인수는 파이썬 3.1부터 무시되고 더 이상 사용되지 않는 &lt;em&gt;인코딩&lt;/em&gt; 을 제외하고 &lt;a href=&quot;#json.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="138f5861a4612c6b38089cf45c9e62492b64b7d1" translate="yes" xml:space="preserve">
          <source>The other place where &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; inspects a type annotation is to determine if a field is an init-only variable. It does this by seeing if the type of a field is of type &lt;code&gt;dataclasses.InitVar&lt;/code&gt;. If a field is an &lt;code&gt;InitVar&lt;/code&gt;, it is considered a pseudo-field called an init-only field. As it is not a true field, it is not returned by the module-level &lt;a href=&quot;#dataclasses.fields&quot;&gt;&lt;code&gt;fields()&lt;/code&gt;&lt;/a&gt; function. Init-only fields are added as parameters to the generated &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method, and are passed to the optional &lt;code&gt;__post_init__()&lt;/code&gt; method. They are not otherwise used by dataclasses.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 가 형식 주석을 검사하는 다른 곳 은 필드가 초기화 전용 변수인지 확인하는 것입니다. 필드 유형이 &lt;code&gt;dataclasses.InitVar&lt;/code&gt; 유형 인지 확인하여이를 수행 합니다. 필드가 &lt;code&gt;InitVar&lt;/code&gt; 인 경우 필드는 init-only 필드라고하는 의사 필드로 간주됩니다. 실제 필드가 아니므로 모듈 레벨 &lt;a href=&quot;#dataclasses.fields&quot;&gt; &lt;code&gt;fields()&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환되지 않습니다 . 초기화 전용 필드는 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메서드에 매개 변수로 추가되며 선택적 &lt;code&gt;__post_init__()&lt;/code&gt; 메서드에 전달됩니다 . 데이터 클래스에서는 달리 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9ecdabaffb0595d8282336914bda13ba527fef0" translate="yes" xml:space="preserve">
          <source>The other possibility is to create a function that converts the type to the string representation and register the function with &lt;a href=&quot;#sqlite3.register_adapter&quot;&gt;&lt;code&gt;register_adapter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 방법은 유형을 문자열 표현으로 변환하고 &lt;a href=&quot;#sqlite3.register_adapter&quot;&gt; &lt;code&gt;register_adapter()&lt;/code&gt; &lt;/a&gt; 함수를 등록 하는 함수를 작성하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c30689f9b028ecc7b44927b0201ecc1a0e446de9" translate="yes" xml:space="preserve">
          <source>The other six arguments are functions that are called to turn argument names, &lt;code&gt;*&lt;/code&gt; argument name, &lt;code&gt;**&lt;/code&gt; argument name, default values, return annotation and individual annotations into strings, respectively.</source>
          <target state="translated">다른 6 개의 인수는 인수 이름, &lt;code&gt;*&lt;/code&gt; 인수 이름, &lt;code&gt;**&lt;/code&gt; 인수 이름, 기본값, 주석 및 개별 주석을 각각 문자열로 변환 하기 위해 호출되는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="4e3374bba6da9adf05084b50cb70cf9e7a79cdd4" translate="yes" xml:space="preserve">
          <source>The other two major components of the package are the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;. The parser takes the serialized version of an email message (a stream of bytes) and converts it into a tree of &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; objects. The generator takes an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; and turns it back into a serialized byte stream. (The parser and generator also handle streams of text characters, but this usage is discouraged as it is too easy to end up with messages that are not valid in one way or another.)</source>
          <target state="translated">패키지의 다른 두 가지 주요 구성 요소는 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 입니다. 파서는 일련의 전자 메일 메시지 버전 (바이트 스트림)을 가져와 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 객체 의 트리로 변환 합니다. 생성기는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 를&lt;/a&gt; 가져 와서 직렬화 된 바이트 스트림으로 되돌립니다. 파서 및 생성기는 텍스트 문자 스트림도 처리하지만이 방법은 유효하지 않은 메시지로 끝나기가 너무 어렵 기 때문에 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fbb08d4859f74e5eef6222cbab680f88900b022" translate="yes" xml:space="preserve">
          <source>The outermost leading and trailing &lt;em&gt;chars&lt;/em&gt; argument values are stripped from the string. Characters are removed from the leading end until reaching a string character that is not contained in the set of characters in &lt;em&gt;chars&lt;/em&gt;. A similar action takes place on the trailing end. For example:</source>
          <target state="translated">가장 바깥 쪽 선행 및 후행 &lt;em&gt;문자&lt;/em&gt; 인수 값이 문자열에서 제거됩니다. 문자의 문자 세트에 포함되지 않은 문자열 문자에 도달 할 때까지 선두에서 제거됩니다 &lt;em&gt;문자를&lt;/em&gt; . 후행에서도 비슷한 동작이 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68b11bf8863fb6840e03133afb634060c59d806f" translate="yes" xml:space="preserve">
          <source>The output for the example would look similar to this:</source>
          <target state="translated">예제의 출력은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="027ddcfdff1a1014a29cd604d7a77e89ff8b8dd8" translate="yes" xml:space="preserve">
          <source>The output from this program is:</source>
          <target state="translated">이 프로그램의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa760c1b26947d513cac59dff953b219b32f781c" translate="yes" xml:space="preserve">
          <source>The output is either a string (&lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;) or binary (&lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;). This is controlled by the &lt;em&gt;encoding&lt;/em&gt; argument. If &lt;em&gt;encoding&lt;/em&gt; is &lt;code&gt;&quot;unicode&quot;&lt;/code&gt;, the output is a string; otherwise, it&amp;rsquo;s binary. Note that this may conflict with the type of &lt;em&gt;file&lt;/em&gt; if it&amp;rsquo;s an open &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;; make sure you do not try to write a string to a binary stream and vice versa.</source>
          <target state="translated">출력은 문자열 ( &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ) 또는 이진 ( &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; )입니다. 이것은 &lt;em&gt;인코딩&lt;/em&gt; 인수에 의해 제어됩니다 . 경우 &lt;em&gt;인코딩&lt;/em&gt; 인 &lt;code&gt;&quot;unicode&quot;&lt;/code&gt; , 출력은 문자열이며; 그렇지 않으면 이진입니다. 열린 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체 인&lt;/a&gt; 경우 &lt;em&gt;파일&lt;/em&gt; 형식과 충돌 할 수 있습니다 . 문자열을 이진 스트림에 쓰거나 그 반대로 쓰려고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dcf5a38c006f26f008c99b2661299c3869a84556" translate="yes" xml:space="preserve">
          <source>The output is intended to be &lt;em&gt;human readable&lt;/em&gt; rather than machine parseable. It may look different on different platforms and this is intended.</source>
          <target state="translated">출력은 기계 구문 분석이 &lt;em&gt;가능&lt;/em&gt; 하지 않고 &lt;em&gt;사람이 읽을 수&lt;/em&gt; 있도록 만들어졌습니다 . 플랫폼마다 다르게 보일 수 있으며 이는 의도 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="019e47670eca13a96ca67c6acb10c4429918c123" translate="yes" xml:space="preserve">
          <source>The output of a CGI script should consist of two sections, separated by a blank line. The first section contains a number of headers, telling the client what kind of data is following. Python code to generate a minimal header section looks like this:</source>
          <target state="translated">CGI 스크립트의 출력은 빈 줄로 구분 된 두 섹션으로 구성되어야합니다. 첫 번째 섹션에는 클라이언트가 어떤 종류의 데이터를 추적하는지 알려주는 많은 헤더가 포함되어 있습니다. 최소 헤더 섹션을 생성하는 Python 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9372d8280e154ef7bd8cce1cb9067cf0ac6b897" translate="yes" xml:space="preserve">
          <source>The output of each example is checked using the &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s output checker, and the results are formatted by the &lt;code&gt;DocTestRunner.report_*()&lt;/code&gt; methods.</source>
          <target state="translated">각 예제 의 출력 은 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 의 출력 검사기를 사용하여 확인 되며 결과는 &lt;code&gt;DocTestRunner.report_*()&lt;/code&gt; 메소드 로 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="585c88899418582ad73321158b0178e16e458068" translate="yes" xml:space="preserve">
          <source>The output of the example should look exactly like for the TCP server example.</source>
          <target state="translated">예제의 출력은 TCP 서버 예제와 정확히 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="00ef8f2fda1209e9f49161aa09f6645d996d526e" translate="yes" xml:space="preserve">
          <source>The output of the example should look something like this:</source>
          <target state="translated">예제의 결과는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="2ddac9a02ca6d6738022c8b8534a979f5593d7ce" translate="yes" xml:space="preserve">
          <source>The output string will &lt;em&gt;not&lt;/em&gt; include time zone information, regardless of whether the input is aware or naive.</source>
          <target state="translated">출력 문자열 에는 입력 인식 여부와 상관없이 시간대 정보가 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6fc487de6f88b00ecc2f348b90e17727ccc9ccff" translate="yes" xml:space="preserve">
          <source>The output will then be:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30e8eaae13d1dea954788334f3c9bd5becb2d6c6" translate="yes" xml:space="preserve">
          <source>The overall structure of the email package can be divided into three major components, plus a fourth component that controls the behavior of the other components.</source>
          <target state="translated">전자 메일 패키지의 전체 구조는 세 가지 주요 구성 요소와 다른 구성 요소의 동작을 제어하는 ​​네 번째 구성 요소로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce355a2a46493371466043965a6b586867e0a7c" translate="yes" xml:space="preserve">
          <source>The pack() method can be called with keyword-option/value pairs that control where the widget is to appear within its container, and how it is to behave when the main application window is resized. Here are some examples:</source>
          <target state="translated">pack () 메서드는 컨테이너 내에서 위젯이 표시되는 위치와 기본 응용 프로그램 창의 크기를 조정할 때의 동작 방식을 제어하는 ​​키워드 옵션 / 값 쌍으로 호출 할 수 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="43d505e6a2e7c36776ba82d594697f730f5d036e" translate="yes" xml:space="preserve">
          <source>The package contents can be roughly split into four parts: low-level CAB routines, low-level MSI routines, higher-level MSI routines, and standard table structures.</source>
          <target state="translated">패키지 내용은 크게 저수준 CAB 루틴, 저수준 MSI 루틴, 고수준 MSI 루틴 및 표준 테이블 구조의 네 부분으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e085f5fbf738e12557a40f2cfd7aded4c065ac" translate="yes" xml:space="preserve">
          <source>The packer is one of Tk&amp;rsquo;s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of the positioning of widgets within their container - their mutual &lt;em&gt;master&lt;/em&gt;. In contrast to the more cumbersome &lt;em&gt;placer&lt;/em&gt; (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - &lt;em&gt;above&lt;/em&gt;, &lt;em&gt;to the left of&lt;/em&gt;, &lt;em&gt;filling&lt;/em&gt;, etc - and works everything out to determine the exact placement coordinates for you.</source>
          <target state="translated">패커는 Tk의 지오메트리 관리 메커니즘 중 하나입니다. 지오메트리 관리자는 컨테이너 내에서 위젯의 위치를 ​​상호 &lt;em&gt;마스터&lt;/em&gt; 로 지정하는 상대적 위치를 지정하는 데 사용됩니다 . 패커는 좀 더 성가신 &lt;em&gt;플레이 서&lt;/em&gt; (일반적으로 덜 사용되며 여기서 다루지 않음)와 달리 &lt;em&gt;위의&lt;/em&gt; , &lt;em&gt;왼쪽의&lt;/em&gt; , &lt;em&gt;채우기&lt;/em&gt; 등과 &lt;em&gt;같은&lt;/em&gt; 정 성적 관계 사양을 취하여 정확한 배치 좌표를 결정하기 위해 모든 것을 작동시킵니다. 당신을 위해.</target>
        </trans-unit>
        <trans-unit id="253cb8189b2936e9dc31ecb164b214955e29b52e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;do_handshake_on_connect&lt;/code&gt; specifies whether to do the SSL handshake automatically after doing a &lt;code&gt;socket.connect()&lt;/code&gt;, or whether the application program will call it explicitly, by invoking the &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; method. Calling &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; explicitly gives the program control over the blocking behavior of the socket I/O involved in the handshake.</source>
          <target state="translated">&lt;code&gt;do_handshake_on_connect&lt;/code&gt; 매개 변수 는 &lt;code&gt;socket.connect()&lt;/code&gt; 수행 한 후 SSL 핸드 셰이크를 자동으로 수행 할지 또는 애플리케이션 프로그램이 &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 명시 적으로 호출할지 여부를 지정합니다 . &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 호출 하면 핸드 셰이크에 관련된 소켓 I / O의 블로킹 동작을 프로그램이 명시 적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e2325d973c251eaad6d5fa92d991f2af2611734" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;server_side&lt;/code&gt; is a boolean which identifies whether server-side or client-side behavior is desired from this socket.</source>
          <target state="translated">&lt;code&gt;server_side&lt;/code&gt; 매개 변수 는이 소켓에서 서버 측 또는 클라이언트 측 동작을 원하는지 식별하는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="823e6e4ffdf11c7805d8ae352770d5ed2e9f8a18" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;suppress_ragged_eofs&lt;/code&gt; specifies how the &lt;code&gt;SSLSocket.recv()&lt;/code&gt; method should signal unexpected EOF from the other end of the connection. If specified as &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; (the default), it returns a normal EOF (an empty bytes object) in response to unexpected EOF errors raised from the underlying socket; if &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, it will raise the exceptions back to the caller.</source>
          <target state="translated">&lt;code&gt;suppress_ragged_eofs&lt;/code&gt; 매개 변수 는 &lt;code&gt;SSLSocket.recv()&lt;/code&gt; 메소드가 연결의 다른 쪽 끝에서 예기치 않은 EOF 신호를 보내는 방법을 지정합니다 . &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; (기본값) 로 지정 되면 기본 소켓에서 발생한 예기치 않은 EOF 오류에 대한 응답으로 일반 EOF (빈 바이트 개체)를 반환합니다. &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 인 경우 예외를 호출자에게 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="425f1ffaff5f611531ca4dc03dbc5808560f4199" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;arg&lt;/em&gt; can be one of an integer, an object supporting the read-only buffer interface (like &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) or an object supporting the read-write buffer interface (like &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">매개 변수 &lt;em&gt;arg&lt;/em&gt; 는 정수, 읽기 전용 버퍼 인터페이스를 지원하는 객체 (예 : &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; ) 또는 읽기 / 쓰기 버퍼 인터페이스를 지원하는 객체 (예 : &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="07f0e19bb360bd19a1a80e689ce45296940e8971" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;reuse_address&lt;/em&gt; is no longer supported, as using &lt;code&gt;SO_REUSEADDR&lt;/code&gt; poses a significant security concern for UDP. Explicitly passing &lt;code&gt;reuse_address=True&lt;/code&gt; will raise an exception.</source>
          <target state="translated">&lt;code&gt;SO_REUSEADDR&lt;/code&gt; 을 사용 하면 UDP에 중요한 보안 문제 가 발생 &lt;em&gt;하므로 reuse_address&lt;/em&gt; 매개 변수 는 더 이상 지원되지 않습니다 . &lt;code&gt;reuse_address=True&lt;/code&gt; 를 명시 적으로 전달 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3d9bf8f3c1e1166d31d759e64e3dbeea2b50d58" translate="yes" xml:space="preserve">
          <source>The parameter interpretation recognizes local and global variable names, constant values, branch targets, and compare operators.</source>
          <target state="translated">매개 변수 해석은 로컬 및 글로벌 변수 이름, 상수 값, 분기 대상 및 비교 연산자를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="4364023a096cfc76a5aaccc26d05253c492b0d07" translate="yes" xml:space="preserve">
          <source>The parameters are as for &lt;code&gt;FileHandler&lt;/code&gt;. The attributes are:</source>
          <target state="translated">매개 변수는 &lt;code&gt;FileHandler&lt;/code&gt; 와 같습니다 . 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="328fb050a12d6f49d22d231e4d9497b6bf6996e1" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 의 매개 변수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4121375e3f99104ec54ea4f3d41c8050dcbed2d1" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt; 대한 매개 변수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b0533de393e7b886a40041244b0c1cf85c2921d" translate="yes" xml:space="preserve">
          <source>The parameters to the constructor are the same as those for &lt;a href=&quot;#urllib.request.URLopener&quot;&gt;&lt;code&gt;URLopener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자의 매개 변수는 &lt;a href=&quot;#urllib.request.URLopener&quot;&gt; &lt;code&gt;URLopener&lt;/code&gt; &lt;/a&gt; 의 매개 변수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3db46ab8cdee19add4d74116b81d433cfd3167ac" translate="yes" xml:space="preserve">
          <source>The parent of the current node, or &lt;code&gt;None&lt;/code&gt; for the document node. The value is always a &lt;code&gt;Node&lt;/code&gt; object or &lt;code&gt;None&lt;/code&gt;. For &lt;code&gt;Element&lt;/code&gt; nodes, this will be the parent element, except for the root element, in which case it will be the &lt;code&gt;Document&lt;/code&gt; object. For &lt;code&gt;Attr&lt;/code&gt; nodes, this is always &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">현재 노드의 부모이거나 문서 노드의 경우 &lt;code&gt;None&lt;/code&gt; 값은 항상 &lt;code&gt;Node&lt;/code&gt; 객체이거나 &lt;code&gt;None&lt;/code&gt; 입니다. 위해 &lt;code&gt;Element&lt;/code&gt; 노드,이는 것이 경우 루트 요소를 제외하고, 부모 요소가됩니다 &lt;code&gt;Document&lt;/code&gt; 객체입니다. 들어 &lt;code&gt;Attr&lt;/code&gt; 의 노드, 이것은 항상 없다 &lt;code&gt;None&lt;/code&gt; . 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="3a3afdd265cba6fd880178e4866ef40903b31ca4" translate="yes" xml:space="preserve">
          <source>The parent package for the module/package. If the module is top-level then it has a value of the empty string. The &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt;&lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt;&lt;/a&gt; decorator can handle the details for &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt;&lt;code&gt;__package__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈 / 패키지의 상위 패키지. 모듈이 최상위 레벨이면 빈 문자열 값을 갖습니다. &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt; &lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt; &lt;/a&gt; 데코레이터에 대한 세부 처리 할 수 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt; &lt;code&gt;__package__&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1adae70f45cb1346a91a2a0f4115caab6117d269" translate="yes" xml:space="preserve">
          <source>The parent process starts a fresh python interpreter process. The child process will only inherit those resources necessary to run the process objects &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method. In particular, unnecessary file descriptors and handles from the parent process will not be inherited. Starting a process using this method is rather slow compared to using &lt;em&gt;fork&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt;.</source>
          <target state="translated">부모 프로세스는 새로운 파이썬 인터프리터 프로세스를 시작합니다. 하위 프로세스는 프로세스 오브젝트 &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드 를 실행하는 데 필요한 자원 만 상속합니다 . 특히, 상위 프로세스의 불필요한 파일 디스크립터 및 핸들은 상속되지 않습니다. 이 방법을 사용하여 프로세스를 시작하면 &lt;em&gt;fork&lt;/em&gt; 또는 &lt;em&gt;forkserver&lt;/em&gt; 를 사용하는 것보다 속도가 느립니다 .</target>
        </trans-unit>
        <trans-unit id="369b3db27e2ba62379ec6c6f36a1ad6fef163ee0" translate="yes" xml:space="preserve">
          <source>The parent process uses &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt; to fork the Python interpreter. The child process, when it begins, is effectively identical to the parent process. All resources of the parent are inherited by the child process. Note that safely forking a multithreaded process is problematic.</source>
          <target state="translated">부모 프로세스는 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 Python 인터프리터를 포크합니다. 자식 프로세스는 시작할 때 부모 프로세스와 사실상 동일합니다. 부모의 모든 리소스는 자식 프로세스에 의해 상속됩니다. 멀티 스레드 프로세스를 안전하게 분기하는 것은 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="595e02418163451e1abf531e59bf4de57ad3c4ec" translate="yes" xml:space="preserve">
          <source>The parse_args() method</source>
          <target state="translated">parse_args () 메소드</target>
        </trans-unit>
        <trans-unit id="1370400415985cb2cf13a044f34b42c6fd02cbfa" translate="yes" xml:space="preserve">
          <source>The parser determined that the document was not &amp;ldquo;standalone&amp;rdquo; though it declared itself to be in the XML declaration, and the &lt;code&gt;NotStandaloneHandler&lt;/code&gt; was set and returned &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">파서는 문서 자체가 XML 선언으로 선언되었지만 문서가 &quot;독립형&quot;이 아니라는 것을 확인했으며 &lt;code&gt;NotStandaloneHandler&lt;/code&gt; 가 설정되어 &lt;code&gt;0&lt;/code&gt; 을 반환했습니다 .</target>
        </trans-unit>
        <trans-unit id="45abc8da4046f26f9e15931202a6cfb3bb8736a5" translate="yes" xml:space="preserve">
          <source>The parser for the binary format raises &lt;code&gt;InvalidFileException&lt;/code&gt; when the file cannot be parsed.</source>
          <target state="translated">파일을 구문 분석 할 수없는 경우 이진 형식의 구문 분석기가 &lt;code&gt;InvalidFileException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="315804a5fe161d8d161d75f269b0b17d66a550b3" translate="yes" xml:space="preserve">
          <source>The parser module defines a single exception, but may also pass other built-in exceptions from other portions of the Python runtime environment. See each function for information about the exceptions it can raise.</source>
          <target state="translated">파서 모듈은 단일 예외를 정의하지만 Python 런타임 환경의 다른 부분에서 다른 기본 제공 예외를 전달할 수도 있습니다. 발생할 수있는 예외에 대한 정보는 각 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47584cab28c64372ee0a66e9d6a85d1c121c012c" translate="yes" xml:space="preserve">
          <source>The part of the &lt;code&gt;tagName&lt;/code&gt; following the colon if there is one, else the entire &lt;code&gt;tagName&lt;/code&gt;. The value is a string.</source>
          <target state="translated">의 부분 &lt;code&gt;tagName&lt;/code&gt; 콜론 다음은 하나, 다른 사람 전체가있는 경우 &lt;code&gt;tagName&lt;/code&gt; . 값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="775fe3289edf96d060db49b7c4beddb50812e922" translate="yes" xml:space="preserve">
          <source>The part of the &lt;code&gt;tagName&lt;/code&gt; preceding the colon if there is one, else the empty string. The value is a string, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">콜론 앞에 있는 &lt;code&gt;tagName&lt;/code&gt; 부분 (있는 경우), 그렇지 않으면 빈 문자열. 값은 문자열이거나 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="301b1af6ca20a6249a998cf35ee08045545a44b5" translate="yes" xml:space="preserve">
          <source>The part of the name following the colon if there is one, else the entire name. This is a read-only attribute.</source>
          <target state="translated">콜론 뒤에있는 이름의 일부 (있는 경우), 그렇지 않으면 전체 이름. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="4b6ccf0c7b353e7f2cec6eae5206ddd756cf2a42" translate="yes" xml:space="preserve">
          <source>The part of the name preceding the colon if there is one, else the empty string.</source>
          <target state="translated">콜론 앞에있는 이름 부분 (있는 경우), 그렇지 않으면 빈 문자열.</target>
        </trans-unit>
        <trans-unit id="62c63b165c6cabcf3fb6d0c615994fd200d6b0b6" translate="yes" xml:space="preserve">
          <source>The particular values &lt;code&gt;sys.hash_info.inf&lt;/code&gt;, &lt;code&gt;-sys.hash_info.inf&lt;/code&gt; and &lt;code&gt;sys.hash_info.nan&lt;/code&gt; are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.)</source>
          <target state="translated">특정 값 &lt;code&gt;sys.hash_info.inf&lt;/code&gt; , &lt;code&gt;-sys.hash_info.inf&lt;/code&gt; 및 &lt;code&gt;sys.hash_info.nan&lt;/code&gt; 은 양의 무한대, 음의 무한대 또는 nan (각각)의 해시 값으로 사용됩니다. (해시 가능한 모든 nan은 해시 값이 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="946eb4b10e46d85a90cbba3ce04154b4eb521ecd" translate="yes" xml:space="preserve">
          <source>The passed in callback is returned from the function, allowing this method to be used as a function decorator.</source>
          <target state="translated">전달 된 콜백은 함수에서 반환되므로이 메소드를 함수 데코레이터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d752ee7919317c8ef5e1cf67a53020b721a4c8d" translate="yes" xml:space="preserve">
          <source>The passed in object is returned from the function, allowing this method to be used as a function decorator.</source>
          <target state="translated">전달 된 객체는 함수에서 반환되므로이 메소드를 함수 데코레이터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f6bc83b260a46ac7e550138dc8f3532aa793b1" translate="yes" xml:space="preserve">
          <source>The patch decorators are used for patching objects only within the scope of the function they decorate. They automatically handle the unpatching for you, even if exceptions are raised. All of these functions can also be used in with statements or as class decorators.</source>
          <target state="translated">패치 데코레이터는 장식하는 기능 범위 내에서만 객체를 패치하는 데 사용됩니다. 예외가 발생하더라도 자동으로 패치 해제를 처리합니다. 이러한 함수는 모두 문장이나 클래스 데코레이터로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7081c6361ff2f82dac43fc3e7d1619bac7f3e3f" translate="yes" xml:space="preserve">
          <source>The patchers</source>
          <target state="translated">패처</target>
        </trans-unit>
        <trans-unit id="befdf46d9ff3d7a1dab0edf47f0724094bd9b1cc" translate="yes" xml:space="preserve">
          <source>The path the finder will search in.</source>
          <target state="translated">파인더가 검색 할 경로입니다.</target>
        </trans-unit>
        <trans-unit id="74622e717d8bc0ccf71b94541baf057d565c1905" translate="yes" xml:space="preserve">
          <source>The path to the bytecode file.</source>
          <target state="translated">바이트 코드 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="35ba4af1a78250ec64c0e2392522fa5eb8e9cfe4" translate="yes" xml:space="preserve">
          <source>The path to the source file.</source>
          <target state="translated">소스 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="33a48412e2e67c67c7e92a4715e6b43be0fd6d15" translate="yes" xml:space="preserve">
          <source>The path to where a compiled version of the module is/should be stored (not set when the attribute would be inappropriate).</source>
          <target state="translated">컴파일 된 버전의 모듈이 저장되는 경로입니다 (속성이 부적절하면 설정되지 않음).</target>
        </trans-unit>
        <trans-unit id="7a8d3812438de73c08083ea24db7366309aa89e4" translate="yes" xml:space="preserve">
          <source>The path to where the module data is stored (not set for built-in modules).</source>
          <target state="translated">모듈 데이터가 저장되는 경로입니다 (내장 모듈에 설정되지 않음).</target>
        </trans-unit>
        <trans-unit id="6d3422ae55b1cae3c297fd0d2a7bb36e7dde778d" translate="yes" xml:space="preserve">
          <source>The pattern is deliberately not stored as a loader attribute so that packages can continue discovery themselves. &lt;em&gt;top_level_dir&lt;/em&gt; is stored so &lt;code&gt;load_tests&lt;/code&gt; does not need to pass this argument in to &lt;code&gt;loader.discover()&lt;/code&gt;.</source>
          <target state="translated">패턴은 의도적으로 로더 속성으로 저장되지 않으므로 패키지가 계속해서 발견을 계속할 수 있습니다. &lt;em&gt;top_level_dir이&lt;/em&gt; 때문에 저장 &lt;code&gt;load_tests&lt;/code&gt; 이 에이 인수를 전달할 필요가 없습니다 &lt;code&gt;loader.discover()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d752d1425dfb41387a9c85ad6aa7411b1b12149" translate="yes" xml:space="preserve">
          <source>The pattern may be a string or a &lt;a href=&quot;#re-objects&quot;&gt;pattern object&lt;/a&gt;.</source>
          <target state="translated">패턴은 문자열 또는 &lt;a href=&quot;#re-objects&quot;&gt;패턴 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4198abc6596ed451fcb1e4b11283fe46e47a9bdd" translate="yes" xml:space="preserve">
          <source>The pattern string from which the pattern object was compiled.</source>
          <target state="translated">패턴 객체가 컴파일 된 패턴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e0f91ca744d391bb72b78aa2afd81f096934a681" translate="yes" xml:space="preserve">
          <source>The philosophy and structure of the two classes is otherwise the same.</source>
          <target state="translated">두 클래스의 철학과 구조는 다른 방식으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="896181308dbe91750b43d1e225e480bee0e585e6" translate="yes" xml:space="preserve">
          <source>The platform does not provide information on whether the UUID was generated safely or not.</source>
          <target state="translated">플랫폼은 UUID가 안전하게 생성되었는지 여부에 대한 정보를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ebc22381e3d1840239ccd9e5f1d63077ee7dfbb" translate="yes" xml:space="preserve">
          <source>The position of the sign (for positive resp. negative values), see below.</source>
          <target state="translated">부호의 위치 (양의 음수 값)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59952542e7942305c827d02265033fc6e9dbe5db" translate="yes" xml:space="preserve">
          <source>The positional argument pattern matches that of &lt;a href=&quot;stdtypes#range&quot;&gt;&lt;code&gt;range()&lt;/code&gt;&lt;/a&gt;. Keyword arguments should not be used because the function may use them in unexpected ways.</source>
          <target state="translated">위치 인수 패턴은 &lt;a href=&quot;stdtypes#range&quot;&gt; &lt;code&gt;range()&lt;/code&gt; &lt;/a&gt; 패턴과 일치합니다 . 함수가 예상치 못한 방식으로 키워드를 사용할 수 있으므로 키워드 인수를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="112fe2d97f81ed80cec8656f5adddd507c3ca3eb" translate="yes" xml:space="preserve">
          <source>The positional-only arguments &lt;em&gt;path&lt;/em&gt;, &lt;em&gt;args&lt;/em&gt;, and &lt;em&gt;env&lt;/em&gt; are similar to &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위치 전용 인수 &lt;em&gt;path&lt;/em&gt; , &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;env&lt;/em&gt; 는 &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3e48c18afdb606d8cb78f91a0899ad96906f15" translate="yes" xml:space="preserve">
          <source>The possible values for &lt;code&gt;'p_sign_posn'&lt;/code&gt; and &lt;code&gt;'n_sign_posn'&lt;/code&gt; are given below.</source>
          <target state="translated">&lt;code&gt;'p_sign_posn'&lt;/code&gt; 및 &lt;code&gt;'n_sign_posn'&lt;/code&gt; 에 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6833954936c8ae7c88396b0dc8d3e749d41eb23" translate="yes" xml:space="preserve">
          <source>The precise rules are as follows: suppose that the result formatted with presentation type &lt;code&gt;'e'&lt;/code&gt; and precision &lt;code&gt;p-1&lt;/code&gt; would have exponent &lt;code&gt;exp&lt;/code&gt;. Then, if &lt;code&gt;m &amp;lt;= exp &amp;lt; p&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is -4 for floats and -6 for &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;Decimals&lt;/code&gt;&lt;/a&gt;, the number is formatted with presentation type &lt;code&gt;'f'&lt;/code&gt; and precision &lt;code&gt;p-1-exp&lt;/code&gt;. Otherwise, the number is formatted with presentation type &lt;code&gt;'e'&lt;/code&gt; and precision &lt;code&gt;p-1&lt;/code&gt;. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the &lt;code&gt;'#'&lt;/code&gt; option is used.</source>
          <target state="translated">정확한 규칙은 다음과 같습니다. 프리젠 테이션 유형 &lt;code&gt;'e'&lt;/code&gt; 및 정밀도 &lt;code&gt;p-1&lt;/code&gt; 로 형식화 된 결과에 지수 &lt;code&gt;exp&lt;/code&gt; 가 있다고 가정하십시오 . 그런 다음 &lt;code&gt;m &amp;lt;= exp &amp;lt; p&lt;/code&gt; , 여기서 &lt;code&gt;m&lt;/code&gt; 은 float의 경우 -4이고 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;Decimals&lt;/code&gt; 의&lt;/a&gt; 경우 -6 이면 숫자는 프리젠 테이션 유형 &lt;code&gt;'f'&lt;/code&gt; 및 정밀도 &lt;code&gt;p-1-exp&lt;/code&gt; 로 형식이 지정됩니다 . 그렇지 않으면 숫자는 프리젠 테이션 유형 &lt;code&gt;'e'&lt;/code&gt; 및 정밀도 &lt;code&gt;p-1&lt;/code&gt; 로 형식이 지정됩니다 . 두 경우 모두 중요하지 않은 후행 0은 유의점에서 제거되고 &lt;code&gt;'#'&lt;/code&gt; 옵션을 사용 하지 않는 한 그 뒤에 남은 자릿수가 없으면 소수점도 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="41fdd41826344d0be40e07a7c74ff491f514c5f0" translate="yes" xml:space="preserve">
          <source>The precision determines the number of digits after the decimal point and defaults to 6.</source>
          <target state="translated">정밀도는 소수점 뒤의 자릿수를 결정하며 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="9b79033d293b6c31c75ffa5814aa5c087d000b3d" translate="yes" xml:space="preserve">
          <source>The precision determines the number of significant digits before and after the decimal point and defaults to 6.</source>
          <target state="translated">정밀도는 소수점 전후의 유효 자릿수를 결정하며 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="3cd6b8e24856e292a10d35639bc3c6b06da2cd2f" translate="yes" xml:space="preserve">
          <source>The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock &amp;ldquo;ticks&amp;rdquo; only 50 or 100 times a second.</source>
          <target state="translated">다양한 실시간 함수의 정밀도는 값이나 인수가 표현되는 단위에서 제안한 것보다 적을 수 있습니다. 예를 들어 대부분의 유닉스 시스템에서 클럭은 초당 50 또는 100 회만 &quot;틱&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="31605b7764d8a03a7877d08fc669e90605f06565" translate="yes" xml:space="preserve">
          <source>The predicate must be a callable which result will be interpreted as a boolean value. The final value is the return value.</source>
          <target state="translated">술어는 호출 가능해야하며 결과는 부울 값으로 해석됩니다. 최종 값은 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="399c6b1dfd67b2c650301b9195aaff4a7832e1a5" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Condition is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">Condition을 사용하는 기본 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="9ee67a620d44fb1681005258c0c62d822ecd2282" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Lock is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">잠금을 사용하는 선호되는 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="9bf6315de2d03fd0877883f3226ad7bcb258a563" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Semaphore is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">세마포어를 사용하는 기본 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="fe4a24206790bdb6dfb50de90139956972f17d56" translate="yes" xml:space="preserve">
          <source>The prefix defines the number of leading bits in an address that are compared to determine whether or not an address is part of a network.</source>
          <target state="translated">접두사는 주소가 네트워크의 일부인지 여부를 판별하기 위해 비교되는 주소의 선행 비트 수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e953212a6913d9281232d06868614a71454e1b60" translate="yes" xml:space="preserve">
          <source>The prefix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 접두사는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​비슷한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e690cd09d2161493928c7ed836c69440297a338" translate="yes" xml:space="preserve">
          <source>The previous section explains how to read CGI form data using the &lt;code&gt;FieldStorage&lt;/code&gt; class. This section describes a higher level interface which was added to this class to allow one to do it in a more readable and intuitive way. The interface doesn&amp;rsquo;t make the techniques described in previous sections obsolete &amp;mdash; they are still useful to process file uploads efficiently, for example.</source>
          <target state="translated">이전 섹션에서는 &lt;code&gt;FieldStorage&lt;/code&gt; 클래스를 사용하여 CGI 양식 데이터를 읽는 방법에 대해 설명합니다 . 이 섹션에서는이 클래스에 추가되어보다 읽기 쉽고 직관적 인 방식으로 수행 할 수있는 고급 인터페이스에 대해 설명합니다. 이 인터페이스는 이전 섹션에서 설명한 기술을 쓸모 없게 만들지 않습니다. 예를 들어 파일 업로드를 효율적으로 처리하는 데 여전히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7523173e59a7046859cb60342d5e26f6d306040f" translate="yes" xml:space="preserve">
          <source>The primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 API 메소드 형식 문자열과 임의의 위치 및 키워드 인수 집합을 사용합니다. &lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt; 을 호출하는 래퍼 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="4d20207a32c469b27878eb965894ae9e5054d063" translate="yes" xml:space="preserve">
          <source>The primary entry point is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;:</source>
          <target state="translated">기본 진입 점은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99dba641bcba4143cddc64727faefe6f987cf349" translate="yes" xml:space="preserve">
          <source>The primary information is passed in &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, which are combined using &lt;code&gt;msg % args&lt;/code&gt; to create the &lt;code&gt;message&lt;/code&gt; field of the record.</source>
          <target state="translated">기본 정보는 &lt;code&gt;msg&lt;/code&gt; 및 &lt;code&gt;args&lt;/code&gt; 로 전달되며 msg &lt;code&gt;msg % args&lt;/code&gt; 를 사용하여 결합 되어 레코드 의 &lt;code&gt;message&lt;/code&gt; 필드 를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="7bfbe0efc6318910175e0591c9d489213ef2eebb" translate="yes" xml:space="preserve">
          <source>The primary use case for &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; is the one given in the class documentation: supporting a variable number of context managers and other cleanup operations in a single &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The variability may come from the number of context managers needed being driven by user input (such as opening a user specified collection of files), or from some of the context managers being optional:</source>
          <target state="translated">&lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 의 기본 유스 케이스 는 클래스 문서에 제공된 것입니다 . 단일 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 으로 가변 수의 컨텍스트 관리자 및 기타 정리 작업 을 지원 합니다. 변수는 사용자 입력 (예 : 사용자 지정 파일 모음 열기)에 의해 구동되어야하는 컨텍스트 관리자의 수 또는 선택적 컨텍스트 관리자 중 일부에서 비롯 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e9483a317900afadce553033a91cd1d47b9bcf" translate="yes" xml:space="preserve">
          <source>The principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.</source>
          <target state="translated">기본 내장 유형은 숫자, 시퀀스, 매핑, 클래스, 인스턴스 및 예외입니다.</target>
        </trans-unit>
        <trans-unit id="53a56e829c4ee5d3a496f807f49d36341548a22a" translate="yes" xml:space="preserve">
          <source>The printing of warning messages is done by calling &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt;, which may be overridden; the default implementation of this function formats the message by calling &lt;a href=&quot;#warnings.formatwarning&quot;&gt;&lt;code&gt;formatwarning()&lt;/code&gt;&lt;/a&gt;, which is also available for use by custom implementations.</source>
          <target state="translated">경고 메시지의 인쇄는 재정의 될 수있는 &lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt; 을 호출하여 수행됩니다 . 이 함수의 기본 구현은 &lt;a href=&quot;#warnings.formatwarning&quot;&gt; &lt;code&gt;formatwarning()&lt;/code&gt; &lt;/a&gt; 을 호출하여 메시지를 형식화하며 , 이는 사용자 정의 구현에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="825b7993e09a5012896880aa81ed2189c1fc5fc3" translate="yes" xml:space="preserve">
          <source>The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation &lt;code&gt;~&lt;/code&gt; has the same priority as the other unary numeric operations (&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;).</source>
          <target state="translated">이진 비트 단위 연산의 우선 순위는 모두 숫자 연산보다 낮고 비교보다 높습니다. 단항 연산 &lt;code&gt;~&lt;/code&gt; 는 다른 단항 숫자 연산 ( &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; ) 과 동일한 우선 순위를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf0a8ae599a694d8728a80398296f63055fcd91" translate="yes" xml:space="preserve">
          <source>The probability distribution function is:</source>
          <target state="translated">확률 분포 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f4b0a33ec009f539e41f7c7861882fe3861eb27" translate="yes" xml:space="preserve">
          <source>The problem is more important with &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; than with the lower-overhead &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;. For this reason, &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; provides a means of calibrating itself for a given platform so that this error can be probabilistically (on the average) removed. After the profiler is calibrated, it will be more accurate (in a least square sense), but it will sometimes produce negative numbers (when call counts are exceptionally low, and the gods of probability work against you :-). ) Do &lt;em&gt;not&lt;/em&gt; be alarmed by negative numbers in the profile. They should &lt;em&gt;only&lt;/em&gt; appear if you have calibrated your profiler, and the results are actually better than without calibration.</source>
          <target state="translated">문제는 오버 헤드가 낮은 &lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; &lt;/a&gt; 보다 &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 더 중요 합니다 . 이러한 이유로, &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 은 특정 플랫폼에 대해 자체 교정 방법을 제공하므로이 오류를 확률 적으로 (평균적으로) 제거 할 수 있습니다. 프로파일 러가 보정 된 후에는 더 정확할 것입니다 (최소한 제곱의 의미에서). 그러나 때로는 음수를 생성합니다 (통화 횟수가 예외적으로 낮고 확률의 신들이 당신을 상대로 :-). )는 마십시오 &lt;em&gt;하지&lt;/em&gt; 프로필의 음수 놀라지. 그들은해야 &lt;em&gt;에만&lt;/em&gt; 당신이 당신의 프로파일 러를 보정 한 경우 표시되며 결과는 실제로 교정이없는 것보다 낫다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7bf59022d95e063a71d9d155d556fa687e8151c" translate="yes" xml:space="preserve">
          <source>The problem with the code is that you should never expect that a client will provide valid input to your scripts. For example, if a curious user appends another &lt;code&gt;user=foo&lt;/code&gt; pair to the query string, then the script would crash, because in this situation the &lt;code&gt;getvalue(&quot;user&quot;)&lt;/code&gt; method call returns a list instead of a string. Calling the &lt;a href=&quot;stdtypes#str.upper&quot;&gt;&lt;code&gt;upper()&lt;/code&gt;&lt;/a&gt; method on a list is not valid (since lists do not have a method of this name) and results in an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">코드의 문제점은 클라이언트가 스크립트에 유효한 입력을 제공 할 것이라고 기 대해서는 안된다는 것입니다. 예를 들어, 궁금한 사용자가 다른 &lt;code&gt;user=foo&lt;/code&gt; 쌍을 쿼리 문자열에 추가 하면 &lt;code&gt;getvalue(&quot;user&quot;)&lt;/code&gt; 메서드 호출이 문자열 대신 목록을 반환 하기 때문에 스크립트가 중단 됩니다. 리스트 에서 &lt;a href=&quot;stdtypes#str.upper&quot;&gt; &lt;code&gt;upper()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것은 유효하지 않으며 (리스트에이 이름의 메소드가 없기 때문에) &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="96fdb4e91d747f7b382ca34963ea4e97a833f290" translate="yes" xml:space="preserve">
          <source>The procedural interface provides functions which are derived from the methods of the classes &lt;a href=&quot;#turtle.Screen&quot;&gt;&lt;code&gt;Screen&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#turtle.Turtle&quot;&gt;&lt;code&gt;Turtle&lt;/code&gt;&lt;/a&gt;. They have the same names as the corresponding methods. A screen object is automatically created whenever a function derived from a Screen method is called. An (unnamed) turtle object is automatically created whenever any of the functions derived from a Turtle method is called.</source>
          <target state="translated">절차 적 인터페이스는 &lt;a href=&quot;#turtle.Screen&quot;&gt; &lt;code&gt;Screen&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#turtle.Turtle&quot;&gt; &lt;code&gt;Turtle&lt;/code&gt; &lt;/a&gt; 클래스의 메소드에서 파생 된 함수를 제공합니다 . 해당 메소드와 이름이 같습니다. Screen 객체는 Screen 메서드에서 파생 된 함수가 호출 될 때마다 자동으로 만들어집니다. Turtle 메소드에서 파생 된 함수가 호출 될 때마다 (이름이없는) turtle 객체가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e489b4dd7453fa49df07a28774b20b3ff3ca536" translate="yes" xml:space="preserve">
          <source>The process ID of the child process.</source>
          <target state="translated">하위 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="150de663b2d1dfe4e98950a0d814ed1d1e220721" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s authentication key (a byte string).</source>
          <target state="translated">프로세스의 인증 키 (바이트 문자열)</target>
        </trans-unit>
        <trans-unit id="17a501bfd01684f2b434b6e89089168e44514201" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s daemon flag, a Boolean value. This must be set before &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">프로세스의 데몬 플래그, 부울 값 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 를 호출 하기 전에 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06c818f8e2a507968c04b9b39e1decda880a5cf5" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s name. The name is a string used for identification purposes only. It has no semantics. Multiple processes may be given the same name.</source>
          <target state="translated">프로세스 이름 이름은 식별 목적으로 만 사용되는 문자열입니다. 의미가 없습니다. 여러 프로세스에 동일한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2ae1e6a3ccabf77f11a716a76fae3c85a9de04b" translate="yes" xml:space="preserve">
          <source>The profiler modules are designed to provide an execution profile for a given program, not for benchmarking purposes (for that, there is &lt;a href=&quot;timeit#module-timeit&quot;&gt;&lt;code&gt;timeit&lt;/code&gt;&lt;/a&gt; for reasonably accurate results). This particularly applies to benchmarking Python code against C code: the profilers introduce overhead for Python code, but not for C-level functions, and so the C code would seem faster than any Python one.</source>
          <target state="translated">프로파일 러 모듈은 벤치마킹 목적이 아닌 주어진 프로그램에 대한 실행 프로파일을 제공하도록 설계되었습니다 ( &lt;a href=&quot;timeit#module-timeit&quot;&gt; &lt;code&gt;timeit&lt;/code&gt; &lt;/a&gt; 정확한 결과를 얻을 수있는 시간이 있습니다). 이것은 특히 C 코드에 대한 Python 코드 벤치마킹에 적용됩니다. 프로파일 러는 Python 코드에 대한 오버 헤드를 도입하지만 C 레벨 함수에는 오버 헤드를 도입하지 않으므로 C 코드는 Python 코드보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="1ad274b67435cbea4d0f0022c9cb8f04c789c28d" translate="yes" xml:space="preserve">
          <source>The profiler of the &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; module subtracts a constant from each event handling time to compensate for the overhead of calling the time function, and socking away the results. By default, the constant is 0. The following procedure can be used to obtain a better constant for a given platform (see &lt;a href=&quot;#profile-limitations&quot;&gt;Limitations&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 모듈 의 프로파일 러는 각 이벤트 처리 시간에서 상수를 빼서 시간 함수 호출의 오버 헤드를 보상하고 결과를 숨 깁니다. 기본적으로 상수는 0입니다. 주어진 플랫폼에 대해 더 나은 상수를 얻기 위해 다음 절차를 사용할 수 있습니다 ( &lt;a href=&quot;#profile-limitations&quot;&gt;제한 사항&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c57ccc0f47b6d649d42fac7c15dd4c76568d4399" translate="yes" xml:space="preserve">
          <source>The prompt issued to solicit input.</source>
          <target state="translated">입력을 요청하는 프롬프트가 발행되었습니다.</target>
        </trans-unit>
        <trans-unit id="83875c7800a2b76dd59acb9bb82a7881a37ecba4" translate="yes" xml:space="preserve">
          <source>The property list (&lt;code&gt;.plist&lt;/code&gt;) file format is a simple serialization supporting basic object types, like dictionaries, lists, numbers and strings. Usually the top level object is a dictionary.</source>
          <target state="translated">속성 목록 ( &lt;code&gt;.plist&lt;/code&gt; ) 파일 형식은 사전, 목록, 숫자 및 문자열과 같은 기본 개체 유형을 지원하는 간단한 직렬화입니다. 일반적으로 최상위 개체는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="a692e4b23f49571c480a6608de6502020e3e6363" translate="yes" xml:space="preserve">
          <source>The proposal and rationale for this feature, including links to earlier implementations and information about similar features in other languages.</source>
          <target state="translated">이전 구현에 대한 링크 및 다른 언어의 유사한 기능에 대한 정보를 포함하여이 기능에 대한 제안 및 근거.</target>
        </trans-unit>
        <trans-unit id="d3279c37a3d4b93f2763c17e116a163fb04d69c0" translate="yes" xml:space="preserve">
          <source>The proposal which described this feature for inclusion in the Python standard library.</source>
          <target state="translated">Python 표준 라이브러리에 포함하기 위해이 기능을 설명한 제안입니다.</target>
        </trans-unit>
        <trans-unit id="6aad5f6edb9228644868ffcfbe2652bf80458149" translate="yes" xml:space="preserve">
          <source>The protocol instance is coupled with the transport by calling its &lt;a href=&quot;asyncio-protocol#asyncio.BaseProtocol.connection_made&quot;&gt;&lt;code&gt;connection_made()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">프로토콜 인스턴스는 &lt;a href=&quot;asyncio-protocol#asyncio.BaseProtocol.connection_made&quot;&gt; &lt;code&gt;connection_made()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 전송과 연결 됩니다.</target>
        </trans-unit>
        <trans-unit id="5bcebb7947c21cec173aaf44168e072aa830c96e" translate="yes" xml:space="preserve">
          <source>The protocol version chosen when constructing the context. This attribute is read-only.</source>
          <target state="translated">컨텍스트를 구성 할 때 선택한 프로토콜 버전입니다. 이 속성은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4b8e37987302667a8c6a5a30086ea70af54f58fc" translate="yes" xml:space="preserve">
          <source>The protocol version of the pickle is detected automatically, so no protocol argument is needed.</source>
          <target state="translated">피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="304bb59bee6afe03568f30f120fa0b442a6c61e2" translate="yes" xml:space="preserve">
          <source>The protocol version of the pickle is detected automatically, so no protocol argument is needed. Bytes past the pickled representation of the object are ignored.</source>
          <target state="translated">피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인수가 필요하지 않습니다. 피클 링 된 객체 표현 이후의 바이트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="27bd7c4faffc395f3247caddbe9693091c3dd829" translate="yes" xml:space="preserve">
          <source>The protocol, options, cipher and other settings may change to more restrictive values anytime without prior deprecation. The values represent a fair balance between compatibility and security.</source>
          <target state="translated">프로토콜, 옵션, 암호 및 기타 설정은 사전 사용 중단없이 언제든지 더 제한적인 값으로 변경 될 수 있습니다. 이 값은 호환성과 보안 간의 적절한 균형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bb42a552b302f1dbded8b49b736ac990615d6f9" translate="yes" xml:space="preserve">
          <source>The proxy types in &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; do nothing to support comparisons by value. So, for instance, we have:</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 의 프록시 유형은 값별 비교를 지원하지 않습니다. 예를 들어 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef765547ec364b540a8f16063c0fa31ef2bb74cb" translate="yes" xml:space="preserve">
          <source>The pseudo-random generators of this module should not be used for security purposes. For security or cryptographic uses, see the &lt;a href=&quot;secrets#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이 모듈의 의사 난수 발생기는 보안 목적으로 사용해서는 안됩니다. 보안 또는 암호화 사용에 대해서는 &lt;a href=&quot;secrets#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7da2517da5604deefcd3b219dc6bc72a5207e5e" translate="yes" xml:space="preserve">
          <source>The public identifier for the external subset of the document type definition. This will be a string or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문서 유형 정의의 외부 서브 세트에 대한 공용 식별자. 이것은 문자열이거나 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4cc24cc4f00882f93419ab13bd6a8c64685b3f66" translate="yes" xml:space="preserve">
          <source>The public methods of the Screen and Turtle classes are documented extensively via docstrings. So these can be used as online-help via the Python help facilities:</source>
          <target state="translated">Screen 및 Turtle 클래스의 공개 메소드는 문서화 문자열을 통해 광범위하게 문서화됩니다. 파이썬 도움말 기능을 통해 온라인 도움말로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bed0ab16eca2867630c9e7cc4d96b74b1c2265f" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;a href=&quot;#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; package is two-fold. One is to provide the implementation of the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement (and thus, by extension, the &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function) in Python source code. This provides an implementation of &lt;code&gt;import&lt;/code&gt; which is portable to any Python interpreter. This also provides an implementation which is easier to comprehend than one implemented in a programming language other than Python.</source>
          <target state="translated">&lt;a href=&quot;#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 패키지 의 목적 은 두 가지입니다. 하나는 파이썬 소스 코드에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문 (따라서 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 함수) 의 구현을 제공하는 것입니다 . 이것은 모든 파이썬 인터프리터에 이식 가능한 &lt;code&gt;import&lt;/code&gt; 구현을 제공합니다 . 또한 파이썬 이외의 프로그래밍 언어로 구현 된 것보다 이해하기 쉬운 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b16dd66cb16f34ace27bac31206afc6d4d2fe723" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;find_library()&lt;/code&gt; function is to locate a library in a way similar to what the compiler or runtime loader does (on platforms with several versions of a shared library the most recent should be loaded), while the ctypes library loaders act like when a program is run, and call the runtime loader directly.</source>
          <target state="translated">&lt;code&gt;find_library()&lt;/code&gt; 함수 의 목적은 컴파일러 또는 런타임 로더가 수행하는 것과 유사한 방식으로 라이브러리를 찾는 것입니다 (최근에로드해야하는 여러 버전의 공유 라이브러리가있는 플랫폼에서). ctypes 라이브러리 로더는 다음과 같이 작동합니다. 프로그램이 실행될 때 런타임 로더를 직접 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="fa702db0cff6f2f3895045c3752a9fbb38f37c5c" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;em&gt;context&lt;/em&gt; argument is determining what to do if &lt;em&gt;value&lt;/em&gt; is a malformed string. If the context traps &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt;, an exception is raised; otherwise, the constructor returns a new Decimal with the value of &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;컨텍스트&lt;/em&gt; 인수 의 목적은 &lt;em&gt;값&lt;/em&gt; 이 조작 된 문자열 인 경우 수행 할 작업을 결정하는 것 입니다. 컨텍스트가 &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; 을&lt;/a&gt; 트랩 하면 예외가 발생합니다. 그렇지 않으면 생성자는 &lt;code&gt;NaN&lt;/code&gt; 값을 가진 새 Decimal을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1d7470421cad5575eb47710dc31f2ce6a15d669a" translate="yes" xml:space="preserve">
          <source>The pysqlite web page &amp;ndash; sqlite3 is developed externally under the name &amp;ldquo;pysqlite&amp;rdquo;.</source>
          <target state="translated">pysqlite 웹 페이지 &amp;ndash; sqlite3은&amp;ldquo;pysqlite&amp;rdquo;라는 이름으로 외부에서 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="df0d2d334ee13950a07c31e697402c72d3e65e9f" translate="yes" xml:space="preserve">
          <source>The quoting is compatible with UNIX shells and with &lt;a href=&quot;#shlex.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">인용은 UNIX 쉘 및 &lt;a href=&quot;#shlex.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; 과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ce58c924d511abccc91112f9868301eab2a2623" translate="yes" xml:space="preserve">
          <source>The range really is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;61&lt;/code&gt;; value &lt;code&gt;60&lt;/code&gt; is valid in timestamps representing &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;leap seconds&lt;/a&gt; and value &lt;code&gt;61&lt;/code&gt; is supported for historical reasons.</source>
          <target state="translated">범위는 실제로 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;61&lt;/code&gt; 입니다 . 값 &lt;code&gt;60&lt;/code&gt; 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;윤초를&lt;/a&gt; 나타내는 타임 스탬프에서 유효 하며 값 &lt;code&gt;61&lt;/code&gt; 은 역사적 이유로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8fd421df5dc2685a581e00c1459b24396ed076e6" translate="yes" xml:space="preserve">
          <source>The raw stream API is described in detail in the docs of &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 스트림 API는 &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 문서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92473e24fa37abfabba3bd84c199a20643551ee1" translate="yes" xml:space="preserve">
          <source>The raw version number of the OpenSSL library, as a single integer:</source>
          <target state="translated">OpenSSL 라이브러리의 원시 버전 번호 (단일 정수) :</target>
        </trans-unit>
        <trans-unit id="f5f4e5aa79fcae7b1a4aee5bb988c8d392ca329d" translate="yes" xml:space="preserve">
          <source>The reason for defaulting to &lt;code&gt;1&lt;/code&gt; as the starting number and not &lt;code&gt;0&lt;/code&gt; is that &lt;code&gt;0&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; in a boolean sense, but enum members all evaluate to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이 아닌 시작 번호로 기본값을 &lt;code&gt;1&lt;/code&gt; 로 설정하는 이유 는 &lt;code&gt;0&lt;/code&gt; 이 부울 의미에서 &lt;code&gt;False&lt;/code&gt; 이지만 열거 형 멤버가 모두 &lt;code&gt;True&lt;/code&gt; 로 평가되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="8b8da247393cb3f901f4c9827fb1c55335da705f" translate="yes" xml:space="preserve">
          <source>The reason for this error. It can be a message string or another exception instance.</source>
          <target state="translated">이 오류의 이유입니다. 메시지 문자열 또는 다른 예외 인스턴스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cdf1c2c1cd73bb92ad5a97181b39bc3deca2b0b" translate="yes" xml:space="preserve">
          <source>The reason the attributes exist is to save you having to subclass - you can use the same callables for instances of &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt;&lt;code&gt;RotatingFileHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt;&lt;code&gt;TimedRotatingFileHandler&lt;/code&gt;&lt;/a&gt;. If either the namer or rotator callable raises an exception, this will be handled in the same way as any other exception during an &lt;code&gt;emit()&lt;/code&gt; call, i.e. via the &lt;code&gt;handleError()&lt;/code&gt; method of the handler.</source>
          <target state="translated">속성이 존재하는 이유는 서브 클래스 를 &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt; &lt;code&gt;TimedRotatingFileHandler&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt; &lt;code&gt;RotatingFileHandler&lt;/code&gt; &lt;/a&gt; 및 TimedRotatingFileHandler 인스턴스에 대해 동일한 콜 러블 을 사용할 수 있습니다 . namer 또는 rotator callable에서 예외가 발생하면 &lt;code&gt;emit()&lt;/code&gt; 호출 중에 다른 예외와 같은 방식으로 처리됩니다 ( 예 : 핸들러 의 &lt;code&gt;handleError()&lt;/code&gt; 메소드를 통해 ) .</target>
        </trans-unit>
        <trans-unit id="89d87c844ed2c3d32ca4dbf0d2608b75aaafce69" translate="yes" xml:space="preserve">
          <source>The recommended &lt;a href=&quot;https://pip.pypa.io/&quot;&gt;pip&lt;/a&gt; installer runs all &lt;code&gt;setup.py&lt;/code&gt; scripts with &lt;code&gt;setuptools&lt;/code&gt;, even if the script itself only imports &lt;code&gt;distutils&lt;/code&gt;. Refer to the &lt;a href=&quot;https://packaging.python.org&quot;&gt;Python Packaging User Guide&lt;/a&gt; for more information.</source>
          <target state="translated">권장되는 &lt;a href=&quot;https://pip.pypa.io/&quot;&gt;pip&lt;/a&gt; 설치 프로그램은 스크립트 자체가 &lt;code&gt;distutils&lt;/code&gt; 만 가져 오더라도 &lt;code&gt;setuptools&lt;/code&gt; 를 사용하여 모든 &lt;code&gt;setup.py&lt;/code&gt; 스크립트를 실행합니다 . 자세한 내용은 &lt;a href=&quot;https://packaging.python.org&quot;&gt;Python Packaging 사용자 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3708eceef9e8fc9b657fbd262aa2dd3c8c9e05c" translate="yes" xml:space="preserve">
          <source>The recommended approach to invoking subprocesses is to use the &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; function for all use cases it can handle. For more advanced use cases, the underlying &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; interface can be used directly.</source>
          <target state="translated">서브 프로세스 호출에 권장되는 접근 방식 은 처리 할 수있는 모든 사용 사례에 대해 &lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것입니다. 고급 사용 사례의 경우 기본 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 인터페이스를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb4dc482b74e7926d22ef923199ab80c945bb99" translate="yes" xml:space="preserve">
          <source>The recommended way to create array types is by multiplying a data type with a positive integer:</source>
          <target state="translated">배열 유형을 만드는 권장 방법은 데이터 유형에 양의 정수를 곱하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="66efc06bb3809b5e55afbd1288c458d0d954c17a" translate="yes" xml:space="preserve">
          <source>The recommended way to create concrete array types is by multiplying any &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; data type with a positive integer. Alternatively, you can subclass this type and define &lt;a href=&quot;#ctypes.Array._length_&quot;&gt;&lt;code&gt;_length_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ctypes.Array._type_&quot;&gt;&lt;code&gt;_type_&lt;/code&gt;&lt;/a&gt; class variables. Array elements can be read and written using standard subscript and slice accesses; for slice reads, the resulting object is &lt;em&gt;not&lt;/em&gt; itself an &lt;a href=&quot;#ctypes.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구체적인 배열 유형을 만드는 권장 방법은 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 데이터 유형에 양의 정수 를 곱하는 것 입니다. 또는이 유형을 서브 클래 싱하고 &lt;a href=&quot;#ctypes.Array._length_&quot;&gt; &lt;code&gt;_length_&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.Array._type_&quot;&gt; &lt;code&gt;_type_&lt;/code&gt; &lt;/a&gt; 클래스 변수를 정의 할 수 있습니다 . 표준 첨자 및 슬라이스 액세스를 사용하여 배열 요소를 읽고 쓸 수 있습니다. 슬라이스 읽기의 경우 결과 객체 자체는 &lt;a href=&quot;#ctypes.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="db258e380ae1e9f11acb7ecd11189586c81b75b9" translate="yes" xml:space="preserve">
          <source>The reconstructed script is returned as a single string. The result is guaranteed to tokenize back to match the input so that the conversion is lossless and round-trips are assured. The guarantee applies only to the token type and token string as the spacing between tokens (column positions) may change.</source>
          <target state="translated">재구성 된 스크립트는 단일 문자열로 반환됩니다. 결과는 입력과 일치하도록 토큰 화하여 변환에 손실이없고 왕복이 보장됩니다. 토큰 (열 위치) 사이의 간격이 변경 될 수 있으므로 보증은 토큰 유형과 토큰 문자열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="57acf8c8e12eab6d4b3a3f62dbb9d6a2820d0c9c" translate="yes" xml:space="preserve">
          <source>The reconstructor (the &lt;code&gt;_reconstruct&lt;/code&gt; class method) returns the buffer&amp;rsquo;s providing object if it has the right type. This is an easy way to simulate zero-copy behaviour on this toy example.</source>
          <target state="translated">재구성 자 ( &lt;code&gt;_reconstruct&lt;/code&gt; 클래스 메소드)는 버퍼의 제공 오브젝트에 올바른 유형이있는 경우이를 제공합니다. 이 장난감 예제에서 무 복사 동작을 시뮬레이션하는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6832c932800d1e21134679897c1c0c648c46cac9" translate="yes" xml:space="preserve">
          <source>The record is formatted, and then sent to the syslog server. If exception information is present, it is &lt;em&gt;not&lt;/em&gt; sent to the server.</source>
          <target state="translated">레코드가 포맷 된 다음 syslog 서버로 전송됩니다. 예외 정보가 있으면 서버로 전송 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0b70780ad8c59629bb44ba0ecc4d77b4f436096b" translate="yes" xml:space="preserve">
          <source>The record&amp;rsquo;s attribute dictionary is used as the operand to a string formatting operation. Returns the resulting string. Before formatting the dictionary, a couple of preparatory steps are carried out. The &lt;em&gt;message&lt;/em&gt; attribute of the record is computed using &lt;em&gt;msg&lt;/em&gt; % &lt;em&gt;args&lt;/em&gt;. If the formatting string contains &lt;code&gt;'(asctime)'&lt;/code&gt;, &lt;a href=&quot;#logging.Formatter.formatTime&quot;&gt;&lt;code&gt;formatTime()&lt;/code&gt;&lt;/a&gt; is called to format the event time. If there is exception information, it is formatted using &lt;a href=&quot;#logging.Formatter.formatException&quot;&gt;&lt;code&gt;formatException()&lt;/code&gt;&lt;/a&gt; and appended to the message. Note that the formatted exception information is cached in attribute &lt;em&gt;exc_text&lt;/em&gt;. This is useful because the exception information can be pickled and sent across the wire, but you should be careful if you have more than one &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; subclass which customizes the formatting of exception information. In this case, you will have to clear the cached value after a formatter has done its formatting, so that the next formatter to handle the event doesn&amp;rsquo;t use the cached value but recalculates it afresh.</source>
          <target state="translated">레코드의 속성 사전은 문자열 형식화 조작의 피연산자로 사용됩니다. 결과 문자열을 반환합니다. 사전을 형식화하기 전에 몇 가지 준비 단계가 수행됩니다. 레코드 의 &lt;em&gt;메시지&lt;/em&gt; 속성은 &lt;em&gt;msg&lt;/em&gt; % &lt;em&gt;args를&lt;/em&gt; 사용하여 계산됩니다 . 서식 문자열이 포함되어있는 경우 &lt;code&gt;'(asctime)'&lt;/code&gt; , &lt;a href=&quot;#logging.Formatter.formatTime&quot;&gt; &lt;code&gt;formatTime()&lt;/code&gt; &lt;/a&gt; 이벤트 시간을 포맷이라고합니다. 예외 정보가 있으면 &lt;a href=&quot;#logging.Formatter.formatException&quot;&gt; &lt;code&gt;formatException()&lt;/code&gt; &lt;/a&gt; 사용하여 형식이 지정 되고 메시지에 추가됩니다. 형식화 된 예외 정보는 &lt;em&gt;exc_text&lt;/em&gt; 속성에 캐시됩니다.&lt;em&gt;&lt;/em&gt;. 이는 예외 정보를 유선으로 전달하고 전송할 수 있기 때문에 유용하지만 예외 정보의 형식을 사용자 정의하는 둘 이상의 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 서브 클래스가있는 경우주의해야합니다 . 이 경우, 포매터가 형식화를 완료 한 후 캐시 된 값을 지워야 이벤트를 처리 할 다음 포매터가 캐시 된 값을 사용하지 않고 새로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7b68d4f5f80393667485b695f7d4fbe0d86fa20c" translate="yes" xml:space="preserve">
          <source>The recorder object also has a &lt;code&gt;reset()&lt;/code&gt; method, which clears the warnings list.</source>
          <target state="translated">레코더 개체에는 &lt;code&gt;reset()&lt;/code&gt; 메서드도있어 경고 목록을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="23f5a856010edc6634a1b395d6da029a99f96511" translate="yes" xml:space="preserve">
          <source>The regex matching flags. This is a combination of the flags given to &lt;a href=&quot;#re.compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, any &lt;code&gt;(?...)&lt;/code&gt; inline flags in the pattern, and implicit flags such as &lt;code&gt;UNICODE&lt;/code&gt; if the pattern is a Unicode string.</source>
          <target state="translated">정규식 일치 플래그. 이것은 주어진 플래그의 조합입니다 &lt;a href=&quot;#re.compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; , 어떤 &lt;code&gt;(?...)&lt;/code&gt; 과 같은 패턴의 인라인 플래그 및 암시 적 플래그 &lt;code&gt;UNICODE&lt;/code&gt; 패턴이 유니 코드 문자열 인 경우.</target>
        </trans-unit>
        <trans-unit id="4908905268dd161df8905009999a17db351541c3" translate="yes" xml:space="preserve">
          <source>The regular &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; was designed to be very good at mapping operations. Tracking insertion order was secondary.</source>
          <target state="translated">일반적인 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 은 매핑 작업에 매우 적합하도록 설계되었습니다. 게재 신청서 추적이 부차적이었습니다.</target>
        </trans-unit>
        <trans-unit id="7968a2059eb096a9ad928a6d8fa459e62e306418" translate="yes" xml:space="preserve">
          <source>The regular expression pattern.</source>
          <target state="translated">정규식 패턴.</target>
        </trans-unit>
        <trans-unit id="338a44466ba170ea38b197685c29de265d361a96" translate="yes" xml:space="preserve">
          <source>The relationships among these processing classes are summarized in the following diagram:</source>
          <target state="translated">이러한 처리 클래스 간의 관계는 다음 다이어그램에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="93eb7f8ce0f82ca28e08352f3f3171f042ffdf18" translate="yes" xml:space="preserve">
          <source>The relative likelihood is computed as the probability of a sample occurring in a narrow range divided by the width of the range (hence the word &amp;ldquo;density&amp;rdquo;). Since the likelihood is relative to other points, its value can be greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">상대적 가능성은 좁은 범위에서 샘플이 발생할 수있는 확률을 범위의 너비 (따라서&amp;ldquo;밀도&amp;rdquo;)로 나눈 값으로 계산됩니다. 가능성은 다른 점과 관련이 있으므로 값은 &lt;code&gt;1.0&lt;/code&gt; 보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe576e550a29800997b9d6a2e646402dca141123" translate="yes" xml:space="preserve">
          <source>The remainder is computed as a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object. (3)</source>
          <target state="translated">나머지는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체 로 계산됩니다 . (삼)</target>
        </trans-unit>
        <trans-unit id="0340c584ccb1afc4873c12a1e31a9be1bffa4f35" translate="yes" xml:space="preserve">
          <source>The remaining &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt; methods are called by the email package code, and are not intended to be called by an application using the email package. A custom policy must implement all of these methods.</source>
          <target state="translated">나머지 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 방법은 전자 메일 패키지 코드로 호출되며 전자 메일 패키지를 사용하는 응용 프로그램에서는 호출되지 않습니다. 사용자 지정 정책은 이러한 모든 방법을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="73a6d6e6fac3d7be26a7b43db8daf15d992cd3a7" translate="yes" xml:space="preserve">
          <source>The remaining challenges revolve around finding a pending task and making changes to its priority or removing it entirely. Finding a task can be done with a dictionary pointing to an entry in the queue.</source>
          <target state="translated">나머지 과제는 보류중인 작업을 찾고 우선 순위를 변경하거나 완전히 제거하는 것과 관련이 있습니다. 대기열에서 항목을 가리키는 사전을 사용하여 작업을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1bc691bd9a1784a04f10810950f779a9ee15eb0" translate="yes" xml:space="preserve">
          <source>The remaining functions are part of the legacy (&lt;code&gt;Compat32&lt;/code&gt;) email API. There is no need to directly use these with the new API, since the parsing and formatting they provide is done automatically by the header parsing machinery of the new API.</source>
          <target state="translated">나머지 기능은 레거시 ( &lt;code&gt;Compat32&lt;/code&gt; ) 이메일 API의 일부입니다 . 이들이 제공하는 파싱 및 포맷팅은 새로운 API의 헤더 파싱 메카니즘에 의해 자동으로 수행되므로, 새로운 API와 함께 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9e96d5ad53b78651123f0aa48586b15b8bc8356" translate="yes" xml:space="preserve">
          <source>The remaining methods are specific to audio mixing:</source>
          <target state="translated">나머지 방법은 오디오 믹싱에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3bfb848b5ec87a5a815658edfcfabd10bf0be1cc" translate="yes" xml:space="preserve">
          <source>The remaining methods will raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; if called after the &lt;a href=&quot;#chunk.Chunk.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method has been called. Before Python 3.3, they used to raise &lt;a href=&quot;exceptions#IOError&quot;&gt;&lt;code&gt;IOError&lt;/code&gt;&lt;/a&gt;, now an alias of &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#chunk.Chunk.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 후 호출되면 나머지 메소드는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다. Python 3.3 이전 에는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 별명 인 &lt;a href=&quot;exceptions#IOError&quot;&gt; &lt;code&gt;IOError&lt;/code&gt; 를 발생&lt;/a&gt;시켰습니다 .</target>
        </trans-unit>
        <trans-unit id="ab4081a709186f53a0d01adb9c1f82670e77f305" translate="yes" xml:space="preserve">
          <source>The remaining text in this section is the original documentation of the module.</source>
          <target state="translated">이 섹션의 나머지 텍스트는 모듈의 원본 문서입니다.</target>
        </trans-unit>
        <trans-unit id="df76983d86e7fd3680429e5d80b3f6559c176cdc" translate="yes" xml:space="preserve">
          <source>The representation of bytearray objects uses the bytes literal format (&lt;code&gt;bytearray(b'...')&lt;/code&gt;) since it is often more useful than e.g. &lt;code&gt;bytearray([46, 46, 46])&lt;/code&gt;. You can always convert a bytearray object into a list of integers using &lt;code&gt;list(b)&lt;/code&gt;.</source>
          <target state="translated">bytearray 객체의 표현은 바이트 리터럴 형식 ( &lt;code&gt;bytearray(b'...')&lt;/code&gt; )을 사용합니다. &lt;code&gt;bytearray([46, 46, 46])&lt;/code&gt; 보다 종종 유용하기 때문 입니다. &lt;code&gt;list(b)&lt;/code&gt; 사용하여 바이트 배열 객체를 항상 정수 목록으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d120b288aa1f00756fb3a349cf99f1b0ed62ed4" translate="yes" xml:space="preserve">
          <source>The representation of bytes objects uses the literal format (&lt;code&gt;b'...'&lt;/code&gt;) since it is often more useful than e.g. &lt;code&gt;bytes([46, 46, 46])&lt;/code&gt;. You can always convert a bytes object into a list of integers using &lt;code&gt;list(b)&lt;/code&gt;.</source>
          <target state="translated">bytes 객체의 표현은 리터럴 형식 ( &lt;code&gt;b'...'&lt;/code&gt; )을 사용하는데, 이는 종종 &lt;code&gt;bytes([46, 46, 46])&lt;/code&gt; 보다 유용하기 때문 입니다. &lt;code&gt;list(b)&lt;/code&gt; 사용하여 bytes 객체를 항상 정수 목록으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="934e4823813e26310eba11e448f6edb5ad9e263d" translate="yes" xml:space="preserve">
          <source>The request is mapped to a local file by interpreting the request as a path relative to the current working directory.</source>
          <target state="translated">요청은 현재 작업 디렉토리에 상대적인 경로로 요청을 해석하여 로컬 파일에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e30ca94027546a99c4c247aa7bc532aac9585a" translate="yes" xml:space="preserve">
          <source>The request will not work as expected if the data object is unable to deliver its content more than once (e.g. a file or an iterable that can produce the content only once) and the request is retried for HTTP redirects or authentication. The &lt;em&gt;data&lt;/em&gt; is sent to the HTTP server right away after the headers. There is no support for a 100-continue expectation in the library.</source>
          <target state="translated">데이터 오브젝트가 컨텐츠를 두 번 이상 (예 : 컨텐츠를 한 번만 생성 할 수있는 파일 또는 반복 가능) 컨텐츠를 전달할 수없고 요청이 HTTP 경로 재 지정 또는 인증을 위해 재 시도되는 경우 요청이 예상대로 작동하지 않습니다. &lt;em&gt;데이터는&lt;/em&gt; 바로 헤더 후 HTTP 서버로 전송됩니다. 라이브러리에서 100- 연속 예상을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d08fb6e54b0bef7db4806e25ba06216ddf869486" translate="yes" xml:space="preserve">
          <source>The requested operation was made on a parser which was finished parsing input, but isn&amp;rsquo;t allowed. This includes attempts to provide additional input or to stop the parser.</source>
          <target state="translated">요청 된 작업이 구문 분석 입력을 완료했지만 허용되지 않는 구문 분석기에서 수행되었습니다. 여기에는 추가 입력을 제공하거나 파서를 중지하려는 시도가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6be492a00d95d8c38d0f08df00ba5cd76c54a3e2" translate="yes" xml:space="preserve">
          <source>The requested operation was made on a suspended parser, but isn&amp;rsquo;t allowed. This includes attempts to provide additional input or to stop the parser.</source>
          <target state="translated">요청한 작업이 일시 중지 된 파서에서 수행되었지만 허용되지 않습니다. 여기에는 추가 입력을 제공하거나 파서를 중지하려는 시도가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e7da8efaff05d5a67bdc583cf83ab65e3004c869" translate="yes" xml:space="preserve">
          <source>The requested read operation did not complete fully.</source>
          <target state="translated">요청한 읽기 작업이 완전히 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1f8cfa9ce8db124d500cff91c25e3e50bf494e54" translate="yes" xml:space="preserve">
          <source>The required &lt;em&gt;name&lt;/em&gt; parameter is used for introspection and debug purposes.</source>
          <target state="translated">필수 &lt;em&gt;이름&lt;/em&gt; 매개 변수는 내부 검사 및 디버그 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c25d69b77c16629632ad85bd39c5b60853e6161" translate="yes" xml:space="preserve">
          <source>The required &lt;em&gt;value&lt;/em&gt; argument is the new value for the context variable.</source>
          <target state="translated">필수 &lt;em&gt;값&lt;/em&gt; 인수는 컨텍스트 변수의 새 값입니다.</target>
        </trans-unit>
        <trans-unit id="902699a10c395c34229cad66f2a25386f0e788eb" translate="yes" xml:space="preserve">
          <source>The reset_mock method resets all the call attributes on a mock object:</source>
          <target state="translated">reset_mock 메소드는 모의 객체의 모든 호출 속성을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="ddf13e446d1b8be7a43739f2d543a173cf27e006" translate="yes" xml:space="preserve">
          <source>The resolution of such persistent IDs is not defined by the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module; it will delegate this resolution to the user-defined methods on the pickler and unpickler, &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt;&lt;code&gt;persistent_id()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt;&lt;code&gt;persistent_load()&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">이러한 영구 ID의 분석은 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈에 의해 정의되지 않습니다 . 그것은 피클 러와 unpickler에 사용자 정의 방식이 해상도를 위임 할 것이다 &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt; &lt;code&gt;persistent_id()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt; &lt;code&gt;persistent_load()&lt;/code&gt; &lt;/a&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="dad2579aacf71b8f66ffcb466c20321d81397aa7" translate="yes" xml:space="preserve">
          <source>The resolution of the monotonic clock on Windows is usually around 15.6 msec. The best resolution is 0.5 msec. The resolution depends on the hardware (availability of &lt;a href=&quot;https://en.wikipedia.org/wiki/High_Precision_Event_Timer&quot;&gt;HPET&lt;/a&gt;) and on the Windows configuration.</source>
          <target state="translated">Windows에서 단조로운 시계의 해상도는 일반적으로 약 15.6msec입니다. 최상의 해상도는 0.5msec입니다. 해결 방법은 하드웨어 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/High_Precision_Event_Timer&quot;&gt;HPET&lt;/a&gt; 사용 가능 여부 ) 및 Windows 구성에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="23afb147c8179b8f68c17fd58f357125e59e0db0" translate="yes" xml:space="preserve">
          <source>The response of the server if available, as a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">사용 가능한 경우 서버의 응답으로 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="95b4a5945a9d59be88563c27320b9c7635065496" translate="yes" xml:space="preserve">
          <source>The rest of the arguments are passed directly to &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나머지 인수는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="052ba8628ec266d089850d398e2dffdd0e02362b" translate="yes" xml:space="preserve">
          <source>The rest of the arguments are passed directly to &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나머지 인수는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ca5b530f7beb3fc6b574e16895459606aeaf92d" translate="yes" xml:space="preserve">
          <source>The result can be limited to a certain &lt;em&gt;depth&lt;/em&gt; (ellipsis is used for deeper contents):</source>
          <target state="translated">결과는 특정 &lt;em&gt;깊이&lt;/em&gt; 로 제한 될 수 있습니다 (더 깊은 내용에는 줄임표가 사용됨).</target>
        </trans-unit>
        <trans-unit id="a9012bf262281e6649bca6a62eaca3e50309e056" translate="yes" xml:space="preserve">
          <source>The result has the following attributes:</source>
          <target state="translated">결과는 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d5ea300b3c43932c2e9cb889e33cb6a294bf5718" translate="yes" xml:space="preserve">
          <source>The result is a new handle to the specified key.</source>
          <target state="translated">결과는 지정된 키에 대한 새로운 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="9024c97c37bab6f072465e9e7695a1952461ee28" translate="yes" xml:space="preserve">
          <source>The result is a tuple of 2 items:</source>
          <target state="translated">결과는 2 개의 항목으로 구성된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="1a572ad972b418d4c59e22b81a05b05d111a4914" translate="yes" xml:space="preserve">
          <source>The result is a tuple of 3 items:</source>
          <target state="translated">결과는 3 개의 항목으로 구성된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="f4bcd3a97a994995588bc014bbbc763f7890e121" translate="yes" xml:space="preserve">
          <source>The result is an integer that holds the value of the handle before it is detached. If the handle is already detached or closed, this will return zero.</source>
          <target state="translated">결과는 핸들이 분리되기 전에 핸들 값을 보유하는 정수입니다. 핸들이 이미 분리 또는 닫혀 있으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc91a99e93e2fcc5cbfe344c6e0c71fb2ef0bf7a" translate="yes" xml:space="preserve">
          <source>The result is an iterator yielding named tuples, exactly like &lt;a href=&quot;#tokenize.tokenize&quot;&gt;&lt;code&gt;tokenize()&lt;/code&gt;&lt;/a&gt;. It does not yield an &lt;a href=&quot;token#token.ENCODING&quot;&gt;&lt;code&gt;ENCODING&lt;/code&gt;&lt;/a&gt; token.</source>
          <target state="translated">결과적으로 &lt;a href=&quot;#tokenize.tokenize&quot;&gt; &lt;code&gt;tokenize()&lt;/code&gt; &lt;/a&gt; 와 같은 이름의 튜플을 생성하는 반복자가 생성 됩니다. &lt;a href=&quot;token#token.ENCODING&quot;&gt; &lt;code&gt;ENCODING&lt;/code&gt; &lt;/a&gt; 토큰을 생성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3227fd92d80664a7f623acd9fc4b4f80817cf727" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object, with a separate cache for &lt;em&gt;follow_symlinks&lt;/em&gt;&lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; along with &lt;a href=&quot;stat#stat.S_ISDIR&quot;&gt;&lt;code&gt;stat.S_ISDIR()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 객체에 캐시되며 &lt;em&gt;follow_symlinks &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 에 대한 별도의 캐시가 있습니다. &lt;a href=&quot;stat#stat.S_ISDIR&quot;&gt; &lt;code&gt;stat.S_ISDIR()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 과 함께 os.stat () 를 호출 하여 최신 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4473ea6bd1dfef0f8e5256127ece39f3a793c098" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object, with a separate cache for &lt;em&gt;follow_symlinks&lt;/em&gt;&lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 객체에 캐시되며 &lt;em&gt;follow_symlinks &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 에 대한 별도의 캐시가 있습니다. 최신 정보를 가져 오려면 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="abbcee36b5dc7353a13842e21fc33ea3c7933bbe" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Caching, system calls made, and exceptions raised are as per &lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt;&lt;code&gt;is_dir()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 오브젝트 에 캐시됩니다 . 캐싱, 시스템 호출 및 예외 발생은 &lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt; &lt;code&gt;is_dir()&lt;/code&gt; &lt;/a&gt; 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3192c8c4ca27941d16ad2ca7a7e1edfbad87bea5" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Call &lt;a href=&quot;os.path#os.path.islink&quot;&gt;&lt;code&gt;os.path.islink()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 오브젝트 에 캐시됩니다 . 최신 정보를 가져 오려면 &lt;a href=&quot;os.path#os.path.islink&quot;&gt; &lt;code&gt;os.path.islink()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="7ec4d3f1d1936a6194d9445a29e0390f42b8ffe0" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Use &lt;code&gt;os.stat(entry.path, follow_symlinks=False).st_ino&lt;/code&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 오브젝트 에 캐시됩니다 . 사용 &lt;code&gt;os.stat(entry.path, follow_symlinks=False).st_ino&lt;/code&gt; 최신 정보를 가져 오기 위해.</target>
        </trans-unit>
        <trans-unit id="5690da7531945b23a6747716ed812a15a6963db0" translate="yes" xml:space="preserve">
          <source>The result is sorted from the biggest to the smallest by: &lt;a href=&quot;#tracemalloc.Statistic.size&quot;&gt;&lt;code&gt;Statistic.size&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt;&lt;code&gt;Statistic.count&lt;/code&gt;&lt;/a&gt; and then by &lt;a href=&quot;#tracemalloc.Statistic.traceback&quot;&gt;&lt;code&gt;Statistic.traceback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">: 결과는 가장 큰에서에 의해 최소로 정렬됩니다 &lt;a href=&quot;#tracemalloc.Statistic.size&quot;&gt; &lt;code&gt;Statistic.size&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt; &lt;code&gt;Statistic.count&lt;/code&gt; &lt;/a&gt; 다음으로 &lt;a href=&quot;#tracemalloc.Statistic.traceback&quot;&gt; &lt;code&gt;Statistic.traceback&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e30839178f92f01b4544ae6c03a099b48de5230b" translate="yes" xml:space="preserve">
          <source>The result is sorted from the biggest to the smallest by: absolute value of &lt;a href=&quot;#tracemalloc.StatisticDiff.size_diff&quot;&gt;&lt;code&gt;StatisticDiff.size_diff&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.StatisticDiff.size&quot;&gt;&lt;code&gt;StatisticDiff.size&lt;/code&gt;&lt;/a&gt;, absolute value of &lt;a href=&quot;#tracemalloc.StatisticDiff.count_diff&quot;&gt;&lt;code&gt;StatisticDiff.count_diff&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt;&lt;code&gt;Statistic.count&lt;/code&gt;&lt;/a&gt; and then by &lt;a href=&quot;#tracemalloc.StatisticDiff.traceback&quot;&gt;&lt;code&gt;StatisticDiff.traceback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 절대 값 : 결과는 최대에서 최소로하여 정렬 &lt;a href=&quot;#tracemalloc.StatisticDiff.size_diff&quot;&gt; &lt;code&gt;StatisticDiff.size_diff&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tracemalloc.StatisticDiff.size&quot;&gt; &lt;code&gt;StatisticDiff.size&lt;/code&gt; &lt;/a&gt; 의 절대치 &lt;a href=&quot;#tracemalloc.StatisticDiff.count_diff&quot;&gt; &lt;code&gt;StatisticDiff.count_diff&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt; &lt;code&gt;Statistic.count&lt;/code&gt; &lt;/a&gt; 다음으로 &lt;a href=&quot;#tracemalloc.StatisticDiff.traceback&quot;&gt; &lt;code&gt;StatisticDiff.traceback&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50b5cd74dc096919d1c4da6da20c54e0531391ea" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;'Sun, 06 Nov 1994 08:49:37 GMT'&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;'Sun, 06 Nov 1994 08:49:37 GMT'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2b0ea3374869382c5626a60af95e870167d18d" translate="yes" xml:space="preserve">
          <source>The result might look something like:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d4f8c61300cb280ac5d234b75011a45b9bc1479" translate="yes" xml:space="preserve">
          <source>The result objects from the &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt;&lt;code&gt;urlsplit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt;&lt;code&gt;urldefrag()&lt;/code&gt;&lt;/a&gt; functions are subclasses of the &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; type. These subclasses add the attributes listed in the documentation for those functions, the encoding and decoding support described in the previous section, as well as an additional method:</source>
          <target state="translated">&lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt; &lt;code&gt;urlsplit()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt; &lt;code&gt;urldefrag()&lt;/code&gt; &lt;/a&gt; 함수 의 결과 객체 는 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 유형의 하위 클래스입니다 . 이 서브 클래스는 해당 함수에 대한 문서에 나열된 속성, 이전 섹션에서 설명한 인코딩 및 디코딩 지원 및 추가 방법을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9496af6babd167973be214aba8ba07e03e05847c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;mock()&lt;/code&gt; is an async function which will have the outcome of &lt;code&gt;side_effect&lt;/code&gt; or &lt;code&gt;return_value&lt;/code&gt; after it has been awaited:</source>
          <target state="translated">&lt;code&gt;mock()&lt;/code&gt; 의 결과 는 비동기 함수이며 &lt;code&gt;side_effect&lt;/code&gt; 또는 &lt;code&gt;return_value&lt;/code&gt; 가 기다린 후에 결과를 얻게됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bc1a9c58cb8683698d580da1969870f58ded608" translate="yes" xml:space="preserve">
          <source>The result of the manipulations is treated as a filename, and returned as the first component of the tuple, with &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; called on it to yield the second component. (Note: this is the reverse of the order of arguments in instance initialization!)</source>
          <target state="translated">조작 결과는 파일 이름으로 처리되고 튜플의 첫 번째 구성 요소로 반환되며 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 호출되어 두 번째 구성 요소가 생성됩니다. (참고 : 이것은 인스턴스 초기화의 인수 순서와 반대입니다!)</target>
        </trans-unit>
        <trans-unit id="c4e4c6d23f69a76d21bae775427f415590d0980e" translate="yes" xml:space="preserve">
          <source>The result of this method remains unchanged if passed back through the original parsing function:</source>
          <target state="translated">이 방법의 결과는 원래 구문 분석 기능을 통해 다시 전달 된 경우 변경되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b224f9d4a8e2657de972e24ed3a8dcad279caaed" translate="yes" xml:space="preserve">
          <source>The result of this search is cached, see the description of &lt;a href=&quot;#tempfile.tempdir&quot;&gt;&lt;code&gt;tempdir&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">이 검색 결과가 캐시 됩니다. 아래 &lt;a href=&quot;#tempfile.tempdir&quot;&gt; &lt;code&gt;tempdir&lt;/code&gt; 에&lt;/a&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">결과:</target>
        </trans-unit>
        <trans-unit id="8adfe478f190ec97428a206efe4a03294cd0ba54" translate="yes" xml:space="preserve">
          <source>The resulting archive contains:</source>
          <target state="translated">결과 아카이브에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="90e2c6b6dcb04800642e191cd676cfaeabfba943" translate="yes" xml:space="preserve">
          <source>The resulting class has an extra attribute &lt;code&gt;__annotations__&lt;/code&gt; giving a dict that maps the field names to the field types. (The field names are in the &lt;code&gt;_fields&lt;/code&gt; attribute and the default values are in the &lt;code&gt;_field_defaults&lt;/code&gt; attribute both of which are part of the namedtuple API.)</source>
          <target state="translated">결과 클래스에는 필드 이름을 필드 유형에 매핑하는 dict를 제공 하는 추가 속성 &lt;code&gt;__annotations__&lt;/code&gt; 이 있습니다. (필드 이름은 &lt;code&gt;_fields&lt;/code&gt; 속성에 있고 기본값은 &lt;code&gt;_field_defaults&lt;/code&gt; 속성에 있으며 둘 다 명명 된 튜플 API의 일부입니다.)</target>
        </trans-unit>
        <trans-unit id="ac591da9469504c2f08a211e0607aa5095412244" translate="yes" xml:space="preserve">
          <source>The resulting file has one additional method, &lt;code&gt;rollover()&lt;/code&gt;, which causes the file to roll over to an on-disk file regardless of its size.</source>
          <target state="translated">결과 파일에는 추가 방법 인 &lt;code&gt;rollover()&lt;/code&gt; 가있어 파일 크기에 관계없이 파일을 디스크상의 파일로 롤오버합니다.</target>
        </trans-unit>
        <trans-unit id="7a519c498f72663eddb55617af16d07f81874708" translate="yes" xml:space="preserve">
          <source>The resulting launcher uses the &amp;ldquo;Limited ABI&amp;rdquo;, so it will run unchanged with any version of Python 3.x. All it needs is for Python (&lt;code&gt;python3.dll&lt;/code&gt;) to be on the user&amp;rsquo;s &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">결과 런처는&amp;ldquo;제한된 ABI&amp;rdquo;를 사용하므로 모든 버전의 Python 3.x에서 변경없이 실행됩니다. Python ( &lt;code&gt;python3.dll&lt;/code&gt; )이 사용자의 &lt;code&gt;PATH&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="041df9dbd79b18f129d74bcb4f756b61fc62aae3" translate="yes" xml:space="preserve">
          <source>The resulting list is sorted alphabetically. For example:</source>
          <target state="translated">결과 목록은 알파벳순으로 정렬됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11ae1369bb9e6629cc72ed8a767763bea61545dd" translate="yes" xml:space="preserve">
          <source>The resulting object can be used as a context manager (see &lt;a href=&quot;#tempfile-examples&quot;&gt;Examples&lt;/a&gt;). On completion of the context or destruction of the file object the temporary file will be removed from the filesystem.</source>
          <target state="translated">결과 객체는 컨텍스트 관리자로 사용할 수 있습니다 ( &lt;a href=&quot;#tempfile-examples&quot;&gt;예&lt;/a&gt; 참조 ). 컨텍스트가 완료되거나 파일 객체가 손상되면 임시 파일이 파일 시스템에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b846db5f32c3790b53bc4bb912c408d3783cc876" translate="yes" xml:space="preserve">
          <source>The resulting profiler will then call &lt;code&gt;your_time_func&lt;/code&gt;. Depending on whether you are using &lt;a href=&quot;#profile.Profile&quot;&gt;&lt;code&gt;profile.Profile&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;cProfile.Profile&lt;/code&gt;, &lt;code&gt;your_time_func&lt;/code&gt;&amp;rsquo;s return value will be interpreted differently:</source>
          <target state="translated">결과 프로파일 러는 &lt;code&gt;your_time_func&lt;/code&gt; 를 호출 합니다 . 사용 여부에 따라 &lt;a href=&quot;#profile.Profile&quot;&gt; &lt;code&gt;profile.Profile&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;cProfile.Profile&lt;/code&gt; 을 , &lt;code&gt;your_time_func&lt;/code&gt; 의 반환 값은 다르게 해석됩니다 :</target>
        </trans-unit>
        <trans-unit id="9db83e41267f4a8fdf365bc69918d1db78163746" translate="yes" xml:space="preserve">
          <source>The resulting string is a series of &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; characters, where both &lt;em&gt;key&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; are quoted using the &lt;em&gt;quote_via&lt;/em&gt; function. By default, &lt;a href=&quot;#urllib.parse.quote_plus&quot;&gt;&lt;code&gt;quote_plus()&lt;/code&gt;&lt;/a&gt; is used to quote the values, which means spaces are quoted as a &lt;code&gt;'+'&lt;/code&gt; character and &amp;lsquo;/&amp;rsquo; characters are encoded as &lt;code&gt;%2F&lt;/code&gt;, which follows the standard for GET requests (&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;). An alternate function that can be passed as &lt;em&gt;quote_via&lt;/em&gt; is &lt;a href=&quot;#urllib.parse.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;, which will encode spaces as &lt;code&gt;%20&lt;/code&gt; and not encode &amp;lsquo;/&amp;rsquo; characters. For maximum control of what is quoted, use &lt;code&gt;quote&lt;/code&gt; and specify a value for &lt;em&gt;safe&lt;/em&gt;.</source>
          <target state="translated">결과 문자열은 &lt;code&gt;'&amp;amp;'&lt;/code&gt; 문자로 구분 된 일련의 &lt;code&gt;key=value&lt;/code&gt; 쌍 이며, 여기서 &lt;em&gt;key&lt;/em&gt; 와 &lt;em&gt;value&lt;/em&gt; 는 &lt;em&gt;quote_via&lt;/em&gt; 함수를 사용하여 인용 됩니다. 기본적으로 &lt;a href=&quot;#urllib.parse.quote_plus&quot;&gt; &lt;code&gt;quote_plus()&lt;/code&gt; &lt;/a&gt; 는 값을 인용하는 데 사용됩니다. 공백은 &lt;code&gt;'+'&lt;/code&gt; 문자 로 인용 되고 '/'문자는 &lt;code&gt;%2F&lt;/code&gt; 로 인코딩되어 GET 요청에 대한 표준을 따릅니다 ( &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; ). &lt;em&gt;quote_via&lt;/em&gt; 로 전달할 수있는 대체 함수 는 &lt;a href=&quot;#urllib.parse.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt; 이며 공백을 &lt;code&gt;%20&lt;/code&gt; 으로 인코딩합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;'/'문자를 인코딩하지 마십시오. 인용되는 내용을 최대한 제어하려면 &lt;code&gt;quote&lt;/code&gt; 를 사용하고 &lt;em&gt;safe&lt;/em&gt; 값을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="134dbdf4e5b3e8f4c11ac5b7031c7464a782c4b0" translate="yes" xml:space="preserve">
          <source>The results printed are</source>
          <target state="translated">인쇄 된 결과는</target>
        </trans-unit>
        <trans-unit id="40b9c6b5f8f1f52e60312075db0d81f7e179965d" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt;&lt;code&gt;SSLContext.wrap_bio()&lt;/code&gt;&lt;/a&gt;, defaults to &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;. The attribute can be overridden on instance of class in order to return a custom subclass of &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt; &lt;code&gt;SSLContext.wrap_bio()&lt;/code&gt; &lt;/a&gt; 의 반환 유형은 기본적으로 &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 서브 클래스를 리턴하기 위해 클래스 인스턴스에서 속성을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89dd3bf6bf7ac8497c6fbc6d05c26cdd36021e83" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;, defaults to &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;. The attribute can be overridden on instance of class in order to return a custom subclass of &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 의 반환 유형은 기본적으로 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 서브 클래스를 리턴하기 위해 클래스 인스턴스에서 속성을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9ec2a98ecd14904d5d3e12031555d453b9272e4" translate="yes" xml:space="preserve">
          <source>The return value and side effect of child mocks can be set in the same way, using dotted notation. As you can&amp;rsquo;t use dotted names directly in a call you have to create a dictionary and unpack it using &lt;code&gt;**&lt;/code&gt;:</source>
          <target state="translated">자식 모의 반환 값과 부작용은 점 표기법을 사용하여 같은 방식으로 설정할 수 있습니다. 호출에서 직접 점으로 구분 된 이름을 사용할 수 없으므로 &lt;code&gt;**&lt;/code&gt; 를 사용하여 사전을 작성하고 압축을 풀어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cfba5477b25ec732aaec2f8665d9842e6b57be0f" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;'fork'&lt;/code&gt;, &lt;code&gt;'spawn'&lt;/code&gt;, &lt;code&gt;'forkserver'&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;. &lt;code&gt;'fork'&lt;/code&gt; is the default on Unix, while &lt;code&gt;'spawn'&lt;/code&gt; is the default on Windows.</source>
          <target state="translated">반환 값은 &lt;code&gt;'fork'&lt;/code&gt; , &lt;code&gt;'spawn'&lt;/code&gt; , &lt;code&gt;'forkserver'&lt;/code&gt; 또는 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;'fork'&lt;/code&gt; 는 Unix의 기본값이고 &lt;code&gt;'spawn'&lt;/code&gt; 은 Windows의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="223d2d76ad021d8b529310c6405479566a8c8808" translate="yes" xml:space="preserve">
          <source>The return value can be used to decide whether to use &lt;code&gt;sys.ps1&lt;/code&gt; or &lt;code&gt;sys.ps2&lt;/code&gt; to prompt the next line.</source>
          <target state="translated">반환 값은 &lt;code&gt;sys.ps1&lt;/code&gt; 또는 &lt;code&gt;sys.ps2&lt;/code&gt; 중 어느 것을 사용 하여 다음 행을 프롬프트 할지를 결정하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c5f5dea7de57114b406e5a2d10e9c9e968c10c" translate="yes" xml:space="preserve">
          <source>The return value consists of two elements: the first is a list of &lt;code&gt;(option,
value)&lt;/code&gt; pairs; the second is the list of program arguments left after the option list was stripped (this is a trailing slice of &lt;em&gt;args&lt;/em&gt;). Each option-and-value pair returned has the option as its first element, prefixed with a hyphen for short options (e.g., &lt;code&gt;'-x'&lt;/code&gt;) or two hyphens for long options (e.g., &lt;code&gt;'--long-option'&lt;/code&gt;), and the option argument as its second element, or an empty string if the option has no argument. The options occur in the list in the same order in which they were found, thus allowing multiple occurrences. Long and short options may be mixed.</source>
          <target state="translated">반환 값은 두 가지 요소로 구성됩니다. 첫 번째는 &lt;code&gt;(option, value)&lt;/code&gt; 쌍 의 목록입니다 . 두 번째는 옵션 목록이 제거 된 후 남은 프로그램 인수 목록입니다 (이것은 후행 &lt;em&gt;args&lt;/em&gt; 조각입니다 ). 반환 된 각 옵션과 값 쌍에는 첫 번째 요소로 옵션이 있으며 짧은 옵션 (예 : &lt;code&gt;'-x'&lt;/code&gt; ) 에는 하이픈이 붙어 있고 긴 옵션 (예 : &lt;code&gt;'--long-option'&lt;/code&gt; )에는 두 개의 하이픈이 붙어 있습니다. 옵션 인자를 두 번째 요소로, 옵션에 인자가없는 경우 빈 문자열 옵션은 찾은 순서대로 목록에서 발생하므로 여러 번 발생할 수 있습니다. 길고 짧은 옵션이 혼합되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b318dc5ec8c485015ebb1f6e03ac8abd47ac343" translate="yes" xml:space="preserve">
          <source>The return value from &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, representing a process that has finished.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 의 반환 값으로 , 완료된 프로세스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="195dd48fbab413248bb85b38523fd13efbbb7f22" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; if the lock is acquired successfully, &lt;code&gt;False&lt;/code&gt; if not (for example if the &lt;em&gt;timeout&lt;/em&gt; expired).</source>
          <target state="translated">잠금이 성공적으로 획득되면 리턴 값은 &lt;code&gt;True&lt;/code&gt; 이고, &lt;code&gt;False&lt;/code&gt; 않으면 False입니다 (예 : &lt;em&gt;시간 종료가&lt;/em&gt; 만료 된 경우).</target>
        </trans-unit>
        <trans-unit id="eda0a021ff1189c021e62f957666234bdf263951" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; if the lock is acquired successfully, &lt;code&gt;False&lt;/code&gt; if not.</source>
          <target state="translated">잠금이 성공적으로 획득되면 리턴 값은 &lt;code&gt;True&lt;/code&gt; 이고, &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다.</target>
        </trans-unit>
        <trans-unit id="e8808521af7a00af7e8d52a0e5473a4b0b4e5fac" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; unless a given &lt;em&gt;timeout&lt;/em&gt; expired, in which case it is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;em&gt;시간 초과가&lt;/em&gt; 만료 되지 않으면 반환 값은 &lt;code&gt;True&lt;/code&gt; 이며,이 경우 &lt;code&gt;False&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4ae8192eff447288a99dac0e9794231ef6500ec" translate="yes" xml:space="preserve">
          <source>The return value is a 3-tuple: &lt;code&gt;metaclass, namespace, kwds&lt;/code&gt;</source>
          <target state="translated">리턴 값은 3 개의 튜플입니다 : &lt;code&gt;metaclass, namespace, kwds&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b945fb04db6f2dc42f9466e62c23e6c77c03488" translate="yes" xml:space="preserve">
          <source>The return value is a 4-tuple: &lt;code&gt;(data, ancdata, msg_flags,
address)&lt;/code&gt;. The &lt;em&gt;data&lt;/em&gt; item is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object holding the non-ancillary data received. The &lt;em&gt;ancdata&lt;/em&gt; item is a list of zero or more tuples &lt;code&gt;(cmsg_level, cmsg_type, cmsg_data)&lt;/code&gt; representing the ancillary data (control messages) received: &lt;em&gt;cmsg_level&lt;/em&gt; and &lt;em&gt;cmsg_type&lt;/em&gt; are integers specifying the protocol level and protocol-specific type respectively, and &lt;em&gt;cmsg_data&lt;/em&gt; is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object holding the associated data. The &lt;em&gt;msg_flags&lt;/em&gt; item is the bitwise OR of various flags indicating conditions on the received message; see your system documentation for details. If the receiving socket is unconnected, &lt;em&gt;address&lt;/em&gt; is the address of the sending socket, if available; otherwise, its value is unspecified.</source>
          <target state="translated">리턴 값은 4 개의 튜플입니다 : &lt;code&gt;(data, ancdata, msg_flags, address)&lt;/code&gt; . &lt;em&gt;데이터&lt;/em&gt; 항목은 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 수신되지 않은 보조 데이터를 보유하는 개체. &lt;em&gt;ancdata&lt;/em&gt; 항목은 0 개 이상의 튜플들의 목록이다 &lt;code&gt;(cmsg_level, cmsg_type, cmsg_data)&lt;/code&gt; 보조 데이터 (제어 메시지) 수신 나타내는 : &lt;em&gt;cmsg_level&lt;/em&gt; 및 &lt;em&gt;cmsg_type는&lt;/em&gt; 각각 프로토콜 레벨 및 특정 프로토콜 타입을 지정하는 정수이고, 그리고 &lt;em&gt;cmsg_data는&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체 관련 데이터를 보유합니다. &lt;em&gt;msg_flags&lt;/em&gt;item은 수신 된 메시지의 조건을 나타내는 다양한 플래그의 비트 단위 OR이며; 자세한 내용은 시스템 설명서를 참조하십시오. 수신 소켓이 연결되지 않은 경우 &lt;em&gt;address&lt;/em&gt; 는 사용 가능한 경우 송신 소켓의 주소입니다. 그렇지 않으면 해당 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec52b14196aa8b67fb13e7dd77583943a73c711f" translate="yes" xml:space="preserve">
          <source>The return value is a 4-tuple: &lt;code&gt;(nbytes, ancdata, msg_flags,
address)&lt;/code&gt;, where &lt;em&gt;nbytes&lt;/em&gt; is the total number of bytes of non-ancillary data written into the buffers, and &lt;em&gt;ancdata&lt;/em&gt;, &lt;em&gt;msg_flags&lt;/em&gt; and &lt;em&gt;address&lt;/em&gt; are the same as for &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 값은 4 개의 튜플입니다 : &lt;code&gt;(nbytes, ancdata, msg_flags, address)&lt;/code&gt; 여기서 &lt;em&gt;nbytes&lt;/em&gt; 는 버퍼에 기록 된 비 보조 데이터의 총 바이트 수이며, &lt;em&gt;ancdata&lt;/em&gt; , &lt;em&gt;msg_flags&lt;/em&gt; 및 &lt;em&gt;address&lt;/em&gt; 는 &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3679d1ebda849b521be84cc43353121c8bf475" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, its items can be accessed by index or as named attributes:</source>
          <target state="translated">반환 값은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 tuple&lt;/a&gt; 이며, 해당 항목은 색인 또는 명명 된 속성으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a21f880bf0c221fb7bd28fe3925cdefb842fe84c" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, which means that its items can be accessed by index or as named attributes, which are:</source>
          <target state="translated">반환 값은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 tuple&lt;/a&gt; 이며, 인덱스 또는 명명 된 속성으로 해당 항목에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f79bebb781377c88d2426bd2e892f766e40af986" translate="yes" xml:space="preserve">
          <source>The return value is a generator of strings, each ending in a newline and some containing internal newlines. &lt;a href=&quot;#traceback.print_exception&quot;&gt;&lt;code&gt;print_exception()&lt;/code&gt;&lt;/a&gt; is a wrapper around this method which just prints the lines to a file.</source>
          <target state="translated">반환 값은 각각 줄 바꿈으로 끝나고 일부는 내부 줄 바꿈으로 끝나는 문자열 생성기입니다. &lt;a href=&quot;#traceback.print_exception&quot;&gt; &lt;code&gt;print_exception()&lt;/code&gt; &lt;/a&gt; 은 파일에 행을 인쇄하는이 메소드의 랩퍼입니다.</target>
        </trans-unit>
        <trans-unit id="a39f9ba7b42bdef3242d2a6379c62a27fc8940a4" translate="yes" xml:space="preserve">
          <source>The return value is a generator of strings, each ending in a newline.</source>
          <target state="translated">리턴 값은 각각 줄 바꾸기로 끝나는 문자열 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="2aa307fb21c6adc415c25262d44c8b663f654493" translate="yes" xml:space="preserve">
          <source>The return value is a string suitable for passing as the &lt;em&gt;salt&lt;/em&gt; argument to &lt;a href=&quot;#module-crypt&quot;&gt;&lt;code&gt;crypt()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 값은 &lt;em&gt;salt&lt;/em&gt; 인수로 &lt;a href=&quot;#module-crypt&quot;&gt; &lt;code&gt;crypt()&lt;/code&gt; &lt;/a&gt; 에 전달하기에 적합한 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="fb4d092528f9e91105a3ac157c24fdb4bd62ec35" translate="yes" xml:space="preserve">
          <source>The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a file descriptor becoming ready, three empty lists are returned.</source>
          <target state="translated">리턴 값은 준비된 오브젝트 목록의 세 가지 즉, 처음 세 인수의 서브 세트입니다. 파일 디스크립터가 준비되지 않고 시간 종료에 도달하면 세 개의 빈 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b21ee42cf5b7e0115206de0a971aa7059c5ad292" translate="yes" xml:space="preserve">
          <source>The return value is a tuple &lt;code&gt;(type, encoding)&lt;/code&gt; where &lt;em&gt;type&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; if the type can&amp;rsquo;t be guessed (missing or unknown suffix) or a string of the form &lt;code&gt;'type/subtype'&lt;/code&gt;, usable for a MIME &lt;em&gt;content-type&lt;/em&gt; header.</source>
          <target state="translated">리턴 값은 튜플 &lt;code&gt;(type, encoding)&lt;/code&gt; 이며 , 유형을 추측 할 수 없거나 (접미사를 알 수 없거나 알 수없는) MIME &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더에 사용할 수있는 &lt;code&gt;'type/subtype'&lt;/code&gt; 형식 의 문자열 인 경우 &lt;em&gt;유형&lt;/em&gt; 은 &lt;code&gt;None&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f4a573600a626a8f185b96ba9102f89d318696f0" translate="yes" xml:space="preserve">
          <source>The return value is an integer in the range 0 to &lt;em&gt;parties&lt;/em&gt; &amp;ndash; 1, different for each thread. This can be used to select a thread to do some special housekeeping, e.g.:</source>
          <target state="translated">리턴 값은 각 스레드마다 다른 0- &lt;em&gt;당사자&lt;/em&gt; &amp;ndash; 1 범위의 정수입니다 . 이것은 특별한 하우스 키핑을위한 스레드를 선택하는데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="68775830b95659615877cbf5628aaf0c84b66aa7" translate="yes" xml:space="preserve">
          <source>The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt;, &lt;code&gt;si_errno&lt;/code&gt;, &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_band&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;siginfo_t&lt;/code&gt; 구조에 포함 된 데이터 , 즉 &lt;code&gt;si_signo&lt;/code&gt; , &lt;code&gt;si_code&lt;/code&gt; , &lt;code&gt;si_errno&lt;/code&gt; , &lt;code&gt;si_pid&lt;/code&gt; , &lt;code&gt;si_uid&lt;/code&gt; , &lt;code&gt;si_status&lt;/code&gt; , &lt;code&gt;si_band&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1dd4f172a531526aa876355a2856ad8c9907382d" translate="yes" xml:space="preserve">
          <source>The return value is the amount of bytes copied. This could be less than the amount requested.</source>
          <target state="translated">리턴 값은 복사 된 바이트의 양입니다. 요청한 금액보다 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="234b77eb5ef9ce8e2fcd0cab178d38c7fe6e2fca" translate="yes" xml:space="preserve">
          <source>The return value is the handle of the opened key. If the function fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">리턴 값은 열린 키의 핸들입니다. 함수가 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc2557edef7b13a49741617f01fcdba9c83af0ab" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes written, which is always equal to the length of &lt;em&gt;buf&lt;/em&gt;.</source>
          <target state="translated">리턴 값은 쓴 바이트 수이며, 항상 &lt;em&gt;buf&lt;/em&gt; 길이와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="62cbe2d5893b50a026494fd6fee07e88125f71a2" translate="yes" xml:space="preserve">
          <source>The return value is the result of the evaluated expression. Syntax errors are reported as exceptions. Example:</source>
          <target state="translated">리턴 값은 평가 된 표현식의 결과입니다. 구문 오류는 예외로보고됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="9b569673d77a40a394325206915c8d678591e80f" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;MagicMock.__iter__()&lt;/code&gt; can be any iterable object and isn&amp;rsquo;t required to be an iterator:</source>
          <target state="translated">&lt;code&gt;MagicMock.__iter__()&lt;/code&gt; 의 반환 값은 반복 가능한 객체 일 수 있으며 반복자 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="c335b6a081673631849b8c4210800ac50f8d01b4" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; has an additional property named &lt;code&gt;exact_type&lt;/code&gt; that contains the exact operator type for &lt;a href=&quot;token#token.OP&quot;&gt;&lt;code&gt;OP&lt;/code&gt;&lt;/a&gt; tokens. For all other token types &lt;code&gt;exact_type&lt;/code&gt; equals the named tuple &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">반환 된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플&lt;/a&gt; 에는 &lt;a href=&quot;token#token.OP&quot;&gt; &lt;code&gt;OP&lt;/code&gt; &lt;/a&gt; 토큰에 대한 정확한 연산자 유형을 포함하는 &lt;code&gt;exact_type&lt;/code&gt; 이라는 추가 속성 이 있습니다 . 다른 모든 토큰 유형의 경우 &lt;code&gt;exact_type&lt;/code&gt; 은 명명 된 튜플 &lt;code&gt;type&lt;/code&gt; 필드 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="218f49d63286506033a67a8dba86f5940020dd19" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; is to be run by the unittest framework and runs each doctest in the module. If any of the doctests fail, then the synthesized unit test fails, and a &lt;code&gt;failureException&lt;/code&gt; exception is raised showing the name of the file containing the test and a (sometimes approximate) line number.</source>
          <target state="translated">반환 된 &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 는 unittest 프레임 워크에 의해 실행되며 모듈에서 각 doctest를 실행합니다. doctest 중 하나라도 실패하면, 합성 된 단위 테스트가 실패하고, 테스트를 포함하는 파일 이름과 (때로는 대략적인) 줄 번호를 나타내는 &lt;code&gt;failureException&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="618fad8d525738d877dbb6063471d43125b8556e" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; is to be run by the unittest framework and runs the interactive examples in each file. If an example in any file fails, then the synthesized unit test fails, and a &lt;code&gt;failureException&lt;/code&gt; exception is raised showing the name of the file containing the test and a (sometimes approximate) line number.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 는 unittest 프레임 워크에 의해 실행되며 각 파일에서 대화식 예제를 실행합니다. 파일의 예제가 실패하면 합성 단위 테스트가 실패 하고 테스트를 포함하는 파일 이름과 (때로는 대략적인) 행 번호를 표시 하는 &lt;code&gt;failureException&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b0b6693ed01480a4045d1615145e7f1cf427145" translate="yes" xml:space="preserve">
          <source>The returned &lt;em&gt;reader&lt;/em&gt; and &lt;em&gt;writer&lt;/em&gt; objects are instances of &lt;a href=&quot;#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">반환 된 &lt;em&gt;판독기&lt;/em&gt; 및 &lt;em&gt;기록기&lt;/em&gt; 개체는 &lt;a href=&quot;#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="1f96113d2cc534f7b7ef202bb144452bc5b31520" translate="yes" xml:space="preserve">
          <source>The returned env-builder is an object which has a method, &lt;code&gt;create&lt;/code&gt;:</source>
          <target state="translated">반환 된 env-builder는 &lt;code&gt;create&lt;/code&gt; 메소드를 가진 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="9970c84bf057aeac8a4c0b64f98b2bef0c7395a9" translate="yes" xml:space="preserve">
          <source>The returned finder is cached in &lt;a href=&quot;sys#sys.path_importer_cache&quot;&gt;&lt;code&gt;sys.path_importer_cache&lt;/code&gt;&lt;/a&gt; if it was newly created by a path hook.</source>
          <target state="translated">리턴 된 파인더는 경로 후크에 의해 새로 작성된 경우 &lt;a href=&quot;sys#sys.path_importer_cache&quot;&gt; &lt;code&gt;sys.path_importer_cache&lt;/code&gt; 에&lt;/a&gt; 캐시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7674772aaa7c3d69c9b57697d013a9667cfcd482" translate="yes" xml:space="preserve">
          <source>The returned function prototype creates functions that use the Python calling convention. The function will &lt;em&gt;not&lt;/em&gt; release the GIL during the call.</source>
          <target state="translated">반환 된 함수 프로토 타입은 Python 호출 규칙을 사용하는 함수를 만듭니다. 이 기능은 호출 중에 GIL을 해제 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="73c626017b30388a1c8db06167f7d17be6ca7ee7" translate="yes" xml:space="preserve">
          <source>The returned function prototype creates functions that use the standard C calling convention. The function will release the GIL during the call. If &lt;em&gt;use_errno&lt;/em&gt; is set to true, the ctypes private copy of the system &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; variable is exchanged with the real &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; value before and after the call; &lt;em&gt;use_last_error&lt;/em&gt; does the same for the Windows error code.</source>
          <target state="translated">반환 된 함수 프로토 타입은 표준 C 호출 규칙을 사용하는 함수를 만듭니다. 이 기능은 호출 중에 GIL을 해제합니다. 경우 &lt;em&gt;use_errno가&lt;/em&gt; true로 설정되어 시스템의 개인 복사하는 ctypes &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 변수가 실제와 교환 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 이전과 통화 후 값; &lt;em&gt;use_last_error&lt;/em&gt; 는 Windows 오류 코드에 대해서도 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eb4feb485235fe9256f397550a46a3fa39024fdd" translate="yes" xml:space="preserve">
          <source>The returned group is itself an iterator that shares the underlying iterable with &lt;a href=&quot;#itertools.groupby&quot;&gt;&lt;code&gt;groupby()&lt;/code&gt;&lt;/a&gt;. Because the source is shared, when the &lt;a href=&quot;#itertools.groupby&quot;&gt;&lt;code&gt;groupby()&lt;/code&gt;&lt;/a&gt; object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list:</source>
          <target state="translated">리턴 된 그룹 자체는 기본 iterable을 &lt;a href=&quot;#itertools.groupby&quot;&gt; &lt;code&gt;groupby()&lt;/code&gt; &lt;/a&gt; 와 공유하는 반복자입니다 . 소스가 공유되므로 &lt;a href=&quot;#itertools.groupby&quot;&gt; &lt;code&gt;groupby()&lt;/code&gt; &lt;/a&gt; 객체가 고급화되면 이전 그룹이 더 이상 표시되지 않습니다. 따라서 해당 데이터가 나중에 필요한 경우 목록으로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a343865b66bc184e10fbb10b32f697cc0caef5f8" translate="yes" xml:space="preserve">
          <source>The returned insertion point &lt;em&gt;i&lt;/em&gt; partitions the array &lt;em&gt;a&lt;/em&gt; into two halves so that &lt;code&gt;all(val &amp;lt; x for val in a[lo:i])&lt;/code&gt; for the left side and &lt;code&gt;all(val &amp;gt;= x for val in a[i:hi])&lt;/code&gt; for the right side.</source>
          <target state="translated">리턴 된 삽입 점 &lt;em&gt;i&lt;/em&gt; 는 배열 &lt;em&gt;a&lt;/em&gt; 를 두 개의 반으로 분할하여 왼쪽에 대해 &lt;code&gt;all(val &amp;lt; x for val in a[lo:i])&lt;/code&gt; 대해 &lt;code&gt;all(val &amp;gt;= x for val in a[i:hi])&lt;/code&gt; 오른쪽에.</target>
        </trans-unit>
        <trans-unit id="669ff275cf0c181691c08c67e29ac61182ca5faf" translate="yes" xml:space="preserve">
          <source>The returned insertion point &lt;em&gt;i&lt;/em&gt; partitions the array &lt;em&gt;a&lt;/em&gt; into two halves so that &lt;code&gt;all(val &amp;lt;= x for val in a[lo:i])&lt;/code&gt; for the left side and &lt;code&gt;all(val &amp;gt; x for val in a[i:hi])&lt;/code&gt; for the right side.</source>
          <target state="translated">리턴 된 삽입 점 &lt;em&gt;i&lt;/em&gt; 는 배열 &lt;em&gt;a&lt;/em&gt; 를 두 개의 반으로 분할하여 왼쪽에 대해 &lt;code&gt;all(val &amp;lt;= x for val in a[lo:i])&lt;/code&gt; &lt;code&gt;all(val &amp;gt; x for val in a[i:hi])&lt;/code&gt; 오른쪽에.</target>
        </trans-unit>
        <trans-unit id="53fe3542ff9fe12d2d3e1cb75fec1f427d2042d1" translate="yes" xml:space="preserve">
          <source>The returned instance is a proxy object with methods that can be used to invoke corresponding RPC calls on the remote server. If the remote server supports the introspection API, the proxy can also be used to query the remote server for the methods it supports (service discovery) and fetch other server-associated metadata.</source>
          <target state="translated">리턴 된 인스턴스는 원격 서버에서 해당 RPC 호출을 호출하는 데 사용할 수있는 메소드가있는 프록시 오브젝트입니다. 원격 서버가 자체 검사 API를 지원하는 경우 프록시를 사용하여 원격 서버에서 지원하는 방법 (서비스 검색)을 쿼리하고 다른 서버 관련 메타 데이터를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7288877f11459f6ab28ff785ec24351c4aa442e" translate="yes" xml:space="preserve">
          <source>The returned iterator raises a &lt;a href=&quot;#concurrent.futures.TimeoutError&quot;&gt;&lt;code&gt;concurrent.futures.TimeoutError&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt; is called and the result isn&amp;rsquo;t available after &lt;em&gt;timeout&lt;/em&gt; seconds from the original call to &lt;a href=&quot;#concurrent.futures.Executor.map&quot;&gt;&lt;code&gt;Executor.map()&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;timeout&lt;/em&gt; can be an int or a float. If &lt;em&gt;timeout&lt;/em&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, there is no limit to the wait time.</source>
          <target state="translated">반환 된 반복자는 &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 가 호출되고 &lt;a href=&quot;#concurrent.futures.Executor.map&quot;&gt; &lt;code&gt;Executor.map()&lt;/code&gt; &lt;/a&gt; 대한 원래 호출에서 &lt;em&gt;시간 초과&lt;/em&gt; 후 초 결과를 사용할 수없는 경우 &lt;a href=&quot;#concurrent.futures.TimeoutError&quot;&gt; &lt;code&gt;concurrent.futures.TimeoutError&lt;/code&gt; &lt;/a&gt;.futures.TimeoutError를 발생 시킵니다 . &lt;em&gt;타임 아웃&lt;/em&gt; 은 int 또는 float 일 수 있습니다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 지정되지되지 않거나 &lt;code&gt;None&lt;/code&gt; , 대기 시간에 제한이 없습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d24b35f2954c9d4ccee793a3bacdf330b843c26a" translate="yes" xml:space="preserve">
          <source>The returned list will be sorted in the order they appeared in the original header list or were added to this instance, and may contain duplicates. Any fields deleted and re-inserted are always appended to the header list. If no fields exist with the given name, returns an empty list.</source>
          <target state="translated">반환 된 목록은 원래 헤더 목록에 표시되거나이 인스턴스에 추가 된 순서대로 정렬되며 중복 항목을 포함 할 수 있습니다. 삭제하고 다시 삽입 한 모든 필드는 항상 헤더 목록에 추가됩니다. 지정된 이름의 필드가 없으면 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cf77cc7d995685ae1853fc00d68172f80697726" translate="yes" xml:space="preserve">
          <source>The returned object can only be used as a foreign function call parameter. It behaves similar to &lt;code&gt;pointer(obj)&lt;/code&gt;, but the construction is a lot faster.</source>
          <target state="translated">리턴 된 오브젝트는 외부 함수 호출 매개 변수로만 사용할 수 있습니다. &lt;code&gt;pointer(obj)&lt;/code&gt; 와 비슷하게 동작 하지만 구성이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="944d9677c5e06b68735cee6e1214d92d8f721c2f" translate="yes" xml:space="preserve">
          <source>The returned object is a file-like object whose &lt;code&gt;_file&lt;/code&gt; attribute is either an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; object (depending on whether binary or text &lt;em&gt;mode&lt;/em&gt; was specified) or a true file object, depending on whether &lt;code&gt;rollover()&lt;/code&gt; has been called. This file-like object can be used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, just like a normal file.</source>
          <target state="translated">반환 된 객체는 &lt;code&gt;_file&lt;/code&gt; 속성이 &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; 객체 (바이너리 또는 텍스트 &lt;em&gt;모드의&lt;/em&gt; 지정 여부에 따라 다름 ) 또는 &lt;code&gt;rollover()&lt;/code&gt; 호출 여부에 따라 실제 파일 객체 인 파일과 유사한 객체입니다 . 이 파일과 유사한 객체는 일반 파일과 마찬가지로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ba4ccce7e74dabed802bdff9234a1122b0c4107" translate="yes" xml:space="preserve">
          <source>The returned object is a true file object on POSIX platforms. On other platforms, it is a file-like object whose &lt;code&gt;file&lt;/code&gt; attribute is the underlying true file object.</source>
          <target state="translated">리턴 된 오브젝트는 POSIX 플랫폼에서 실제 파일 오브젝트입니다. 다른 플랫폼에서는 &lt;code&gt;file&lt;/code&gt; 속성이 기본 실제 파일 객체 인 파일 과 유사한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="2d61336daabebc08319a6841656673dafcebf7ab" translate="yes" xml:space="preserve">
          <source>The returned property object also has the attributes &lt;code&gt;fget&lt;/code&gt;, &lt;code&gt;fset&lt;/code&gt;, and &lt;code&gt;fdel&lt;/code&gt; corresponding to the constructor arguments.</source>
          <target state="translated">반환 된 속성 객체 에는 생성자 인수에 해당하는 속성 &lt;code&gt;fget&lt;/code&gt; , &lt;code&gt;fset&lt;/code&gt; 및 &lt;code&gt;fdel&lt;/code&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1078216c97fc2cb54c2f472e356bef009039e6ee" translate="yes" xml:space="preserve">
          <source>The returned string includes the currency symbol if &lt;em&gt;symbol&lt;/em&gt; is true, which is the default. If &lt;em&gt;grouping&lt;/em&gt; is true (which is not the default), grouping is done with the value. If &lt;em&gt;international&lt;/em&gt; is true (which is not the default), the international currency symbol is used.</source>
          <target state="translated">반환 된 문자열은 &lt;em&gt;symbol&lt;/em&gt; 이 true 인 경우 통화 기호를 포함하며 이것이 기본값입니다. 경우 &lt;em&gt;그룹화&lt;/em&gt; (기본하지 않은) 사실, 값으로 이루어집니다 그룹화합니다. 경우 &lt;em&gt;국제가&lt;/em&gt; (기본값은하지 않은) 사실, 국제 통화 기호가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd8c08933483893f75b8b7fdb1a5319adb8fe8b" translate="yes" xml:space="preserve">
          <source>The returned value is shell-escaped to protect against injection vulnerabilities (see &lt;a href=&quot;#shlex.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">주입 된 취약점으로부터 보호하기 위해 반환 된 값은 셸 이스케이프 처리됩니다 ( &lt;a href=&quot;#shlex.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f6e2d49d3bb8bfbea2c5c7323f9693333c6fa08d" translate="yes" xml:space="preserve">
          <source>The returned value will be a copy of the result of the call or a proxy to a new shared object &amp;ndash; see documentation for the &lt;em&gt;method_to_typeid&lt;/em&gt; argument of &lt;a href=&quot;#multiprocessing.managers.BaseManager.register&quot;&gt;&lt;code&gt;BaseManager.register()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 호출 결과 또는 새 공유 객체에 대한 프록시의 사본입니다 . &lt;a href=&quot;#multiprocessing.managers.BaseManager.register&quot;&gt; &lt;code&gt;BaseManager.register()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;method_to_typeid&lt;/em&gt; 인수에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb70bf1a9ac2dc854c2a93668773c6b77481b4f9" translate="yes" xml:space="preserve">
          <source>The root item may not be deleted.</source>
          <target state="translated">루트 항목은 삭제되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3890ffaf0a29880883c4c861690ab01939538879" translate="yes" xml:space="preserve">
          <source>The root item may not be detached.</source>
          <target state="translated">루트 아이템은 분리되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8724776bb36627ef8324ed2cee8596adf2c111ef" translate="yes" xml:space="preserve">
          <source>The root logger must specify a level and a list of handlers. An example of a root logger section is given below.</source>
          <target state="translated">루트 로거는 레벨 및 핸들러 목록을 지정해야합니다. 루트 로거 섹션의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8aa0536a231f439ca03f4c8eab15fc8b24452be" translate="yes" xml:space="preserve">
          <source>The root of the numeric hierarchy. If you just want to check if an argument &lt;em&gt;x&lt;/em&gt; is a number, without caring what kind, use &lt;code&gt;isinstance(x, Number)&lt;/code&gt;.</source>
          <target state="translated">숫자 계층의 근 인수 &lt;em&gt;x&lt;/em&gt; 가 숫자인지 확인하려면 어떤 종류를 신경 쓰지 않고 &lt;code&gt;isinstance(x, Number)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b3ac7015fd4390c4695675d6ffe8261b0a5c14" translate="yes" xml:space="preserve">
          <source>The routine takes time proportional to &lt;code&gt;len(fragment)&lt;/code&gt;.</source>
          <target state="translated">루틴은 &lt;code&gt;len(fragment)&lt;/code&gt; 비례하여 시간이 걸립니다 .</target>
        </trans-unit>
        <trans-unit id="c458d0b0fe448ae2d0a4d83d7ec4609f7e529b08" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to never expose Future objects in user-facing APIs, and the recommended way to create a Future object is to call &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_future&quot;&gt;&lt;code&gt;loop.create_future()&lt;/code&gt;&lt;/a&gt;. This way alternative event loop implementations can inject their own optimized implementations of a Future object.</source>
          <target state="translated">경험상, 사용자 대상 API에서 Future 객체를 노출하지 않는 것이 좋습니다. Future 객체를 만드는 권장 방법은 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_future&quot;&gt; &lt;code&gt;loop.create_future()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것 입니다. 이런 식으로 대체 이벤트 루프 구현은 자체 최적화 된 Future 객체 구현을 주입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9d329adbb453311cb1f83021747ba8fe74b77e2" translate="yes" xml:space="preserve">
          <source>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, etc.), descriptors (methods are also descriptors), and variable names listed in &lt;code&gt;_ignore_&lt;/code&gt;.</source>
          <target state="translated">허용되는 규칙은 다음과 같습니다. 단일 밑줄로 시작하고 끝나는 이름은 열거 형으로 예약되어 사용할 수 없습니다. 열거 내에 정의 된 다른 모든 속성은 특수 메소드 ( &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 등), 설명자 (메소드도 설명자) 및 &lt;code&gt;_ignore_&lt;/code&gt; 에 나열된 변수 이름을 제외하고이 열거의 멤버가 됩니다.</target>
        </trans-unit>
        <trans-unit id="61698b0a1acd1e3ec12a3341214499d204a64941" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;fallback&lt;/code&gt; argument can be used with the &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt;&lt;code&gt;getint()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt;&lt;code&gt;getfloat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt;&lt;code&gt;getboolean()&lt;/code&gt;&lt;/a&gt; methods, for example:</source>
          <target state="translated">동일한 &lt;code&gt;fallback&lt;/code&gt; 인수를 &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt; &lt;code&gt;getint()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt; &lt;code&gt;getfloat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt; &lt;code&gt;getboolean()&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe0ad54a153c9c16fc953f6457e2a08391e6ddfd" translate="yes" xml:space="preserve">
          <source>The same applies to writing in something other than the system default encoding: specify the encoding argument when opening the output file.</source>
          <target state="translated">시스템 기본 인코딩 이외의 다른 방식으로 쓰기에도 동일하게 적용됩니다. 출력 파일을 열 때 인코딩 인수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ee42da4190d9eab8ed782585f2b56ceaaa52fe60" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#email.policy.EmailPolicy.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;7bit&lt;/code&gt;, except that the returned value is bytes.</source>
          <target state="translated">같은 &lt;a href=&quot;#email.policy.EmailPolicy.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 경우 &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 가&lt;/a&gt; 인 &lt;code&gt;7bit&lt;/code&gt; 리턴 값은 바이트 인 것을 제외.</target>
        </trans-unit>
        <trans-unit id="d0e9d4a97e7a8c08a403fe0b581fce1bbbca7af2" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#email.policy.Policy.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, except that the returned value should be a bytes object rather than a string.</source>
          <target state="translated">동일한는 &lt;a href=&quot;#email.policy.Policy.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; , 리턴 값은 바이트 스트링 아닌 객체가 될 것을 제외한다.</target>
        </trans-unit>
        <trans-unit id="d6e3c5f083440fe9bbf887c7f88bf5f04da824a4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt;&lt;code&gt;imap()&lt;/code&gt;&lt;/a&gt; except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be &amp;ldquo;correct&amp;rdquo;.)</source>
          <target state="translated">같은 &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt; &lt;code&gt;imap()&lt;/code&gt; &lt;/a&gt; 로부터의 결과의 순서는 임의 반복자 고려되어야한다는 점을 제외하고 반환. (작업자 프로세스가 하나만있는 경우에만 주문이 &quot;올바르게&quot;보장됩니다.)</target>
        </trans-unit>
        <trans-unit id="4f0e693b02ea181bbef1c28375701342551141cd" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.sharedctypes.RawArray&quot;&gt;&lt;code&gt;RawArray()&lt;/code&gt;&lt;/a&gt; except that depending on the value of &lt;em&gt;lock&lt;/em&gt; a process-safe synchronization wrapper may be returned instead of a raw ctypes array.</source>
          <target state="translated">동일하게 &lt;a href=&quot;#multiprocessing.sharedctypes.RawArray&quot;&gt; &lt;code&gt;RawArray()&lt;/code&gt; &lt;/a&gt; 의 값에 의존한다는 점을 제외하고 &lt;em&gt;잠금&lt;/em&gt; 프로세스 안전한 동기화 래퍼 대신 원시하는 ctypes 어레이 반환 될 수있다.</target>
        </trans-unit>
        <trans-unit id="6cfb2c05572cc99d847c223df250f30149473f05" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.sharedctypes.RawValue&quot;&gt;&lt;code&gt;RawValue()&lt;/code&gt;&lt;/a&gt; except that depending on the value of &lt;em&gt;lock&lt;/em&gt; a process-safe synchronization wrapper may be returned instead of a raw ctypes object.</source>
          <target state="translated">&lt;em&gt;잠금&lt;/em&gt; 값에 따라 원시 ctypes 오브젝트 대신 프로세스 안전 동기화 랩퍼가 리턴 될 수 있다는 점을 제외하면 &lt;a href=&quot;#multiprocessing.sharedctypes.RawValue&quot;&gt; &lt;code&gt;RawValue()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1a01b84361f53398479056f09464345f02bd043" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;found&amp;rsquo; response.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 'found'응답이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="750e1ad255c0e380db439ef1dab8b7f8f0852e72" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;see other&amp;rsquo; response.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 'see other'응답이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="49feac63317adae6711e747adbff6e95df411957" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;temporary redirect&amp;rsquo; response.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 '임시 리디렉션'응답이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="8230ae470e5c59b6f3c4881b2a39dc38aedffae8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;'d'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'d'&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="916ed3638cece914ee2fc8b1652dfd07c219904b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;'s'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'s'&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="829e5aa2fdb08ee46435ea6cf88e99987eb1e392" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;SMTP&lt;/code&gt; except that &lt;a href=&quot;#email.policy.EmailPolicy.utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;. Useful for serializing messages to a message store without using encoded words in the headers. Should only be used for SMTP transmission if the sender or recipient addresses have non-ASCII characters (the &lt;a href=&quot;smtplib#smtplib.SMTP.send_message&quot;&gt;&lt;code&gt;smtplib.SMTP.send_message()&lt;/code&gt;&lt;/a&gt; method handles this automatically).</source>
          <target state="translated">&lt;a href=&quot;#email.policy.EmailPolicy.utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 것을 제외하고는 &lt;code&gt;SMTP&lt;/code&gt; 와 동일 합니다. 헤더에서 인코딩 된 단어를 사용하지 않고 메시지를 메시지 저장소로 직렬화하는 데 유용합니다. 발신자 또는 수신자 주소에 ASCII가 아닌 문자가있는 경우에만 SMTP 전송에 사용해야합니다 ( &lt;a href=&quot;smtplib#smtplib.SMTP.send_message&quot;&gt; &lt;code&gt;smtplib.SMTP.send_message()&lt;/code&gt; &lt;/a&gt; 메소드에서 자동으로 처리).</target>
        </trans-unit>
        <trans-unit id="532039e29cf202190420d4e6121e0b76b86ef2f9" translate="yes" xml:space="preserve">
          <source>The same as the ellipsis literal &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo;. Special value used mostly in conjunction with extended slicing syntax for user-defined container data types.</source>
          <target state="translated">줄임표 리터럴 &quot; &lt;code&gt;...&lt;/code&gt; &quot; 과 동일합니다 . 사용자 정의 컨테이너 데이터 유형에 대한 확장 슬라이싱 구문과 함께 주로 사용되는 특수 값입니다.</target>
        </trans-unit>
        <trans-unit id="b854b52ef7bd2ccfd324aed6049a603fc8fb7751" translate="yes" xml:space="preserve">
          <source>The same can be done using the &lt;a href=&quot;#timeit.Timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; class and its methods:</source>
          <target state="translated">&lt;a href=&quot;#timeit.Timer&quot;&gt; &lt;code&gt;Timer&lt;/code&gt; &lt;/a&gt; 클래스와 해당 메서드를 사용하여 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4760c18be62a9d7dec114efc1c14ea346862762" translate="yes" xml:space="preserve">
          <source>The same can be done using the &lt;a href=&quot;#zipapp.create_archive&quot;&gt;&lt;code&gt;create_archive()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;#zipapp.create_archive&quot;&gt; &lt;code&gt;create_archive()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 동일하게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b0e747134e643ee7b418317f6324c54e529d2a3" translate="yes" xml:space="preserve">
          <source>The same effect may be had by simply calling the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 인스턴스 를 호출하는 것만으로도 같은 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee95343967fc42163ec543a6a7c5d8e1c5cae20" translate="yes" xml:space="preserve">
          <source>The same example using the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 사용한 동일한 예제 :</target>
        </trans-unit>
        <trans-unit id="f21bc4fc65a842a8845b57c261870ced2cf68832" translate="yes" xml:space="preserve">
          <source>The same pattern can be used for other similar decorators: &lt;code&gt;staticmethod&lt;/code&gt;, &lt;code&gt;abstractmethod&lt;/code&gt;, and others.</source>
          <target state="translated">&lt;code&gt;staticmethod&lt;/code&gt; , &lt;code&gt;abstractmethod&lt;/code&gt; 등의 다른 유사한 데코레이터에도 동일한 패턴을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3dc1e5cb29f2f7aa6277b41a35ebe97be0cfb65" translate="yes" xml:space="preserve">
          <source>The same thing can be achieved in the constructor call to mocks:</source>
          <target state="translated">mock에 대한 생성자 호출에서 동일한 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9af275e54fe0509a959d2873010a1018b8c67266" translate="yes" xml:space="preserve">
          <source>The same, in reverse, has to be applied when converting from 8 to 16, 24 or 32 bit width samples.</source>
          <target state="translated">8 비트에서 16 비트, 24 비트 또는 32 비트 폭의 샘플을 변환 할 때는 반대로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c88a256e1b82c972fc3255b212954b50fdc69e36" translate="yes" xml:space="preserve">
          <source>The sample mean gives an unbiased estimate of the true population mean, so that when taken on average over all the possible samples, &lt;code&gt;mean(sample)&lt;/code&gt; converges on the true mean of the entire population. If &lt;em&gt;data&lt;/em&gt; represents the entire population rather than a sample, then &lt;code&gt;mean(data)&lt;/code&gt; is equivalent to calculating the true population mean &amp;mu;.</source>
          <target state="translated">표본 평균은 실제 모집단 평균의 편견없는 추정값을 제공하므로 가능한 모든 표본에 대해 평균적으로 계산할 때 &lt;code&gt;mean(sample)&lt;/code&gt; 은 전체 모집단의 실제 평균에 수렴됩니다. &lt;em&gt;데이터&lt;/em&gt; 가 표본이 아닌 전체 모집단을 나타내는 경우 &lt;code&gt;mean(data)&lt;/code&gt; 은 실제 모집단 평균 &amp;mu;를 계산하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b6d6ef4afe2bb1824ced5480b576fe34f8770f0" translate="yes" xml:space="preserve">
          <source>The scheduling priority for a scheduling policy.</source>
          <target state="translated">스케줄링 정책의 스케줄링 우선 순위.</target>
        </trans-unit>
        <trans-unit id="a789b28f90e6a13336b5a43d081ce2c14e0e32bb" translate="yes" xml:space="preserve">
          <source>The schema describes a set of logging objects - loggers, handlers, formatters, filters - which are connected to each other in an object graph. Thus, the schema needs to represent connections between the objects. For example, say that, once configured, a particular logger has attached to it a particular handler. For the purposes of this discussion, we can say that the logger represents the source, and the handler the destination, of a connection between the two. Of course in the configured objects this is represented by the logger holding a reference to the handler. In the configuration dict, this is done by giving each destination object an id which identifies it unambiguously, and then using the id in the source object&amp;rsquo;s configuration to indicate that a connection exists between the source and the destination object with that id.</source>
          <target state="translated">스키마는 로거, 핸들러, 포맷터, 필터 등의 로깅 오브젝트 세트를 설명하며, 이는 오브젝트 그래프에서 서로 연결됩니다. 따라서 스키마는 객체 간의 연결을 나타내야합니다. 예를 들어, 일단 구성된 로거가 특정 로거에 특정 핸들러를 첨부했다고 가정하십시오. 이 논의의 목적 상, 로거는 둘 사이의 연결의 소스 및 핸들러를 목적지로 나타냅니다. 물론 구성된 객체에서 이것은 핸들러에 대한 참조를 보유한 로거로 표시됩니다. 구성 명령에서 이는 각 대상 객체에이를 명확하게 식별하는 id를 제공 한 다음 소스 객체 구성의 id를 사용하여 해당 id를 가진 소스와 대상 객체 사이에 연결이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="357034175b5af2bba561f08e5abd996027ed8d5a" translate="yes" xml:space="preserve">
          <source>The schema supports user-defined objects for handlers, filters and formatters. (Loggers do not need to have different types for different instances, so there is no support in this configuration schema for user-defined logger classes.)</source>
          <target state="translated">이 스키마는 처리기, 필터 및 포맷터에 대한 사용자 정의 개체를 지원합니다. 로거는 인스턴스마다 다른 유형을 가질 필요가 없으므로이 구성 스키마에서는 사용자 정의 로거 클래스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5cf05c8728d612453b8e5fe6be79e83aec4e76a" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; in the Python source distribution is a GUI tool for test discovery and execution. This is intended largely for ease of use for those new to unit testing. For production environments it is recommended that tests be driven by a continuous integration system such as &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt;, &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; or &lt;a href=&quot;http://hudson-ci.org/&quot;&gt;Hudson&lt;/a&gt;.</source>
          <target state="translated">Python 소스 배포판의 &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; 스크립트 는 테스트 검색 및 실행을위한 GUI 도구입니다. 이것은 단위 테스트에 익숙하지 않은 사람들을 위해 사용하기 쉽도록 만들어졌습니다. 프로덕션 환경의 경우 &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt; , &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; 또는 &lt;a href=&quot;http://hudson-ci.org/&quot;&gt;Hudson&lt;/a&gt; 과 같은 지속적인 통합 시스템으로 테스트를 수행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="590472629c42696a37ed0e6a09a2aa0815298d38" translate="yes" xml:space="preserve">
          <source>The script &lt;strong&gt;webbrowser&lt;/strong&gt; can be used as a command-line interface for the module. It accepts a URL as the argument. It accepts the following optional parameters: &lt;code&gt;-n&lt;/code&gt; opens the URL in a new browser window, if possible; &lt;code&gt;-t&lt;/code&gt; opens the URL in a new browser page (&amp;ldquo;tab&amp;rdquo;). The options are, naturally, mutually exclusive. Usage example:</source>
          <target state="translated">스크립트 &lt;strong&gt;웹 브라우저&lt;/strong&gt; 는 모듈의 명령 행 인터페이스로 사용될 수 있습니다. URL을 인수로 사용합니다. 다음과 같은 선택적 매개 변수를 승인합니다. &lt;code&gt;-n&lt;/code&gt; 가능한 경우 새 브라우저 창에서 URL을 엽니 다. &lt;code&gt;-t&lt;/code&gt; 는 새 브라우저 페이지 (&amp;ldquo;탭&amp;rdquo;)에서 URL을 엽니 다. 옵션은 당연히 상호 배타적입니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="7abc03b295e1e06c729bb0d780860fe53a6dc23c" translate="yes" xml:space="preserve">
          <source>The script that is going to get analyzed later on (bacon.py):</source>
          <target state="translated">나중에 분석 할 스크립트 (bacon.py) :</target>
        </trans-unit>
        <trans-unit id="ee5b7d667b6a893a07a7bd795cbb225c3559dadb" translate="yes" xml:space="preserve">
          <source>The script that will output the report of bacon.py:</source>
          <target state="translated">bacon.py의 보고서를 출력 할 스크립트 :</target>
        </trans-unit>
        <trans-unit id="5c61673a55b5a1642add6c59c9e42d35514177fa" translate="yes" xml:space="preserve">
          <source>The script&amp;rsquo;s input is connected to the client too, and sometimes the form data is read this way; at other times the form data is passed via the &amp;ldquo;query string&amp;rdquo; part of the URL. This module is intended to take care of the different cases and provide a simpler interface to the Python script. It also provides a number of utilities that help in debugging scripts, and the latest addition is support for file uploads from a form (if your browser supports it).</source>
          <target state="translated">스크립트의 입력은 클라이언트에도 연결되며 때로는 양식 데이터를 이런 식으로 읽습니다. 다른 경우에는 양식 데이터가 URL의 &quot;쿼리 문자열&quot;부분을 통해 전달됩니다. 이 모듈은 다른 경우를 처리하고 Python 스크립트에 대한 간단한 인터페이스를 제공하기위한 것입니다. 또한 스크립트 디버깅에 도움이되는 많은 유틸리티를 제공하며 최신 추가 기능은 양식에서 파일 업로드를 지원합니다 (브라우저에서 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="441a890d73099fc8af230e1050ed5b9319ec7466" translate="yes" xml:space="preserve">
          <source>The scroll bar widget.</source>
          <target state="translated">스크롤 바 위젯.</target>
        </trans-unit>
        <trans-unit id="0b2bbe283f6190e08707f30471c6201f3310ca5a" translate="yes" xml:space="preserve">
          <source>The second argument is the &lt;em&gt;source&lt;/em&gt; of enumeration member names. It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. The last two options enable assigning arbitrary values to enumerations; the others auto-assign increasing integers starting with 1 (use the &lt;code&gt;start&lt;/code&gt; parameter to specify a different starting value). A new class derived from &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is returned. In other words, the above assignment to &lt;code&gt;Animal&lt;/code&gt; is equivalent to:</source>
          <target state="translated">두 번째 인수는 열거 멤버 이름 의 &lt;em&gt;소스&lt;/em&gt; 입니다. 공백으로 구분 된 이름 문자열, 이름 시퀀스, 키 / 값 쌍이있는 2 개의 튜플 시퀀스 또는 이름을 값에 매핑 (예 : 사전) 할 수 있습니다. 마지막 두 옵션은 임의의 값을 열거에 할당 할 수있게합니다. 나머지는 1부터 시작하여 증가하는 정수를 자동 할당합니다 ( &lt;code&gt;start&lt;/code&gt; 매개 변수를 사용하여 다른 시작 값을 지정하십시오). &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 에서 파생 된 새 클래스 가 반환됩니다. 다시 말해, 위의 &lt;code&gt;Animal&lt;/code&gt; 할당 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3efff11fbd76f900b41de117b028cbaa28815d1e" translate="yes" xml:space="preserve">
          <source>The second argument, if present, specifies the file location to copy to (if absent, the location will be a tempfile with a generated name). The third argument, if present, is a callable that will be called once on establishment of the network connection and once after each block read thereafter. The callable will be passed three arguments; a count of blocks transferred so far, a block size in bytes, and the total size of the file. The third argument may be &lt;code&gt;-1&lt;/code&gt; on older FTP servers which do not return a file size in response to a retrieval request.</source>
          <target state="translated">두 번째 인수 (있는 경우)는 복사 할 파일 위치를 지정합니다 (없는 경우 위치는 생성 된 이름을 가진 임시 파일입니다). 존재하는 경우, 세 번째 인수는 네트워크 연결이 설정 될 때 한 번 호출되고 그 이후에 각 블록이 읽은 후에 한 번 호출되는 호출 가능입니다. 콜 러블에는 세 가지 인수가 전달됩니다. 지금까지 전송 된 블록 수, 블록 크기 (바이트) 및 파일의 전체 크기 검색 요청에 대한 응답으로 파일 크기를 반환하지 않는 구형 FTP 서버에서 세 번째 인수는 &lt;code&gt;-1&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc342d27fa2c9d42507affce95a9a6a6d772b584" translate="yes" xml:space="preserve">
          <source>The second case may be used on Mac OS X and FreeBSD where &lt;em&gt;headers&lt;/em&gt; and &lt;em&gt;trailers&lt;/em&gt; are arbitrary sequences of buffers that are written before and after the data from &lt;em&gt;in&lt;/em&gt; is written. It returns the same as the first case.</source>
          <target state="translated">두 번째 경우는 맥 OS X와 FreeBSD에 사용될 수있다 &lt;em&gt;헤더&lt;/em&gt; 와 &lt;em&gt;트레일러&lt;/em&gt; 의 데이터 전후의 기록 버퍼의 임의의 서열이다 &lt;em&gt;에&lt;/em&gt; 기입된다. 첫 번째 경우와 동일하게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f15a93322f7f76be0339398712074ec97be438ed" translate="yes" xml:space="preserve">
          <source>The second form of the constructor sets the corresponding attributes, described below. The attributes default to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if not specified. For backwards compatibility, if three arguments are passed, the &lt;a href=&quot;#BaseException.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; attribute contains only a 2-tuple of the first two constructor arguments.</source>
          <target state="translated">생성자의 두 번째 형식은 아래에 설명 된 해당 속성을 설정합니다. 지정하지 않으면 속성은 기본적으로 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 설정 됩니다. 이전 버전과의 호환성을 위해 세 개의 인수가 전달되면 &lt;a href=&quot;#BaseException.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; 속성에는 처음 두 생성자 인수 중 2 개만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="34296b7537391f3024117b10f7c3a5ff4dd5b9d8" translate="yes" xml:space="preserve">
          <source>The second group of options controls how test failures are reported:</source>
          <target state="translated">두 번째 옵션 그룹은 테스트 실패보고 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a82684db899d668b167ed8174dc94a018b1dcbae" translate="yes" xml:space="preserve">
          <source>The second issue is more general to mocking. If you refactor some of your code, rename members and so on, any tests for code that is still using the &lt;em&gt;old api&lt;/em&gt; but uses mocks instead of the real objects will still pass. This means your tests can all pass even though your code is broken.</source>
          <target state="translated">두 번째 문제는 조롱에 더 일반적입니다. 일부 코드를 리팩터링하고 멤버 이름 등을 변경하면 여전히 &lt;em&gt;이전 API를&lt;/em&gt; 사용하지만 실제 객체 대신 모의 객체를 사용하는 코드 테스트가 계속 됩니다. 즉, 코드가 손상 되어도 테스트를 모두 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e61c328cb69d5d01b94c637cb52d86809c1a81f" translate="yes" xml:space="preserve">
          <source>The second optional keyword argument is &lt;em&gt;stack_info&lt;/em&gt;, which defaults to &lt;code&gt;False&lt;/code&gt;. If true, stack information is added to the logging message, including the actual logging call. Note that this is not the same stack information as that displayed through specifying &lt;em&gt;exc_info&lt;/em&gt;: The former is stack frames from the bottom of the stack up to the logging call in the current thread, whereas the latter is information about stack frames which have been unwound, following an exception, while searching for exception handlers.</source>
          <target state="translated">두 번째 선택적 키워드 인수는 &lt;em&gt;stack_info&lt;/em&gt; 이며 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. true 인 경우 실제 로깅 호출을 포함하여 스택 정보가 로깅 메시지에 추가됩니다. 이것은 &lt;em&gt;exc_info&lt;/em&gt; 지정을 통해 표시되는 것과 동일한 스택 정보는 아닙니다 . 전자는 스택의 맨 아래부터 현재 스레드의 로깅 호출까지 스택 프레임이지만, 후자는 풀린 스택 프레임에 대한 정보입니다. 예외 처리기를 검색하는 동안 예외를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2e4c730e515ea8c7e6ed22283aa940b7c170b41b" translate="yes" xml:space="preserve">
          <source>The second problem is that it &amp;ldquo;takes a while&amp;rdquo; from when an event is dispatched until the profiler&amp;rsquo;s call to get the time actually &lt;em&gt;gets&lt;/em&gt; the state of the clock. Similarly, there is a certain lag when exiting the profiler event handler from the time that the clock&amp;rsquo;s value was obtained (and then squirreled away), until the user&amp;rsquo;s code is once again executing. As a result, functions that are called many times, or call many functions, will typically accumulate this error. The error that accumulates in this fashion is typically less than the accuracy of the clock (less than one clock tick), but it &lt;em&gt;can&lt;/em&gt; accumulate and become very significant.</source>
          <target state="translated">두 번째 문제는 이벤트가 시간이 실제로 얻을 수있는 프로파일 러의 호출까지 전달 될 때부터 &quot;잠시 소요&quot;이다 &lt;em&gt;얻는다&lt;/em&gt; 시계의 상태를. 마찬가지로, 사용자의 코드가 다시 한번 실행될 때까지 시계 값이 획득 된 시점부터 다람쥐가 사라지는 시점부터 프로파일 러 이벤트 핸들러를 종료 할 때 특정 지연이 발생합니다. 결과적으로 여러 번 호출되거나 많은 함수를 호출하는 함수는 일반적으로이 오류를 누적합니다. 이러한 방식으로 누적되는 오류는 일반적으로 클럭 정확도 (1 클럭 미만)보다 적지 만 누적되어 매우 중요해질 &lt;em&gt;수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d32a81f75e96772b4383da9bf4edd54a00fffcf6" translate="yes" xml:space="preserve">
          <source>The second section is usually HTML, which allows the client software to display nicely formatted text with header, in-line images, etc. Here&amp;rsquo;s Python code that prints a simple piece of HTML:</source>
          <target state="translated">두 번째 섹션은 일반적으로 HTML이며, 클라이언트 소프트웨어는 헤더, 인라인 이미지 등으로 멋진 형식의 텍스트를 표시 할 수 있습니다. 다음은 간단한 HTML을 인쇄하는 Python 코드입니다.</target>
        </trans-unit>
        <trans-unit id="3983ca9591946a2e35ceee565ce274efeaded338" translate="yes" xml:space="preserve">
          <source>The second subclass allows for connections created by a child process:</source>
          <target state="translated">두 번째 서브 클래스는 하위 프로세스로 작성된 연결을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5434750abc7b69faf1ffb090ae9381c4aab45452" translate="yes" xml:space="preserve">
          <source>The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement &amp;ldquo;diamond diagrams&amp;rdquo; where multiple base classes implement the same method. Good design dictates that this method have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime).</source>
          <target state="translated">두 번째 사용 사례는 동적 실행 환경에서 협업 다중 상속을 지원하는 것입니다. 이 유스 케이스는 Python에 고유하며 정적으로 컴파일 된 언어 또는 단일 상속 만 지원하는 언어에는 없습니다. 이를 통해 여러 기본 클래스가 동일한 메소드를 구현하는 &quot;다이아몬드 다이어그램&quot;을 구현할 수 있습니다. 좋은 설계는이 메소드가 모든 경우에 동일한 호출 서명을 갖도록 지시합니다 (이 호출 순서는 클래스 계층 구조의 변경에 적응하고 런타임에 알려지지 않은 형제 클래스를 포함 할 수 있기 때문에 런타임에 호출 순서가 결정되기 때문입니다) ).</target>
        </trans-unit>
        <trans-unit id="817bae41c43a2fdb49bd2ccee3ff54cd1276a64e" translate="yes" xml:space="preserve">
          <source>The sections below first document the header base classes and their attributes, followed by the API for modifying the behavior of &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt;, and finally the support classes used to represent the data parsed from structured headers.</source>
          <target state="translated">아래 섹션은 먼저 헤더 기본 클래스와 해당 속성, &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; &lt;/a&gt; 의 동작을 수정하기위한 API 및 구조화 된 헤더에서 구문 분석 된 데이터를 나타내는 데 사용되는 지원 클래스에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fb511a5d628d8dbbb4b6bf34bfa204b91e9c7783" translate="yes" xml:space="preserve">
          <source>The semantics of this API resemble &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;/a&gt;. The first argument of the call to &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is the name of the enumeration.</source>
          <target state="translated">이 API의 시맨틱은 &lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple&lt;/code&gt; &lt;/a&gt; 과 유사 합니다. &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 호출의 첫 번째 인수는 열거 의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="070609838b02b470a8593f64b9dca1e4232bafbd" translate="yes" xml:space="preserve">
          <source>The separator to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 분리자는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a15dc4df39babea8600cb0111121e4e21f2adba" translate="yes" xml:space="preserve">
          <source>The sequence</source>
          <target state="translated">순서</target>
        </trans-unit>
        <trans-unit id="82ce3ee65d071578dc915ee005e2223c40e5f9b4" translate="yes" xml:space="preserve">
          <source>The sequence has an undefined order. Use the &lt;a href=&quot;#tracemalloc.Snapshot.statistics&quot;&gt;&lt;code&gt;Snapshot.statistics()&lt;/code&gt;&lt;/a&gt; method to get a sorted list of statistics.</source>
          <target state="translated">순서는 정의되지 않은 순서입니다. 정렬 된 통계 목록을 가져 오려면 &lt;a href=&quot;#tracemalloc.Snapshot.statistics&quot;&gt; &lt;code&gt;Snapshot.statistics()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e213b00d5ff7dbdcab5c0f7b3a984b54b08ecc6" translate="yes" xml:space="preserve">
          <source>The server classes support the following class variables:</source>
          <target state="translated">서버 클래스는 다음 클래스 변수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2786e902b7d48dcd206d583f8d5ed7f8b2845e8e" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t accept the &lt;em&gt;from_addr&lt;/em&gt;.</source>
          <target state="translated">서버가 &lt;em&gt;from_addr을&lt;/em&gt; 승인하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="56dd79533db4c4efca4e68373ada164e963dde44" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t accept the username/password combination.</source>
          <target state="translated">서버가 사용자 이름 / 암호 조합을 수락하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4911a0a87661df881e8634adaa418fd9f284c0c2" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t reply properly to the &lt;code&gt;HELO&lt;/code&gt; greeting.</source>
          <target state="translated">서버가 &lt;code&gt;HELO&lt;/code&gt; 인사말에 제대로 응답하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="5e0a6b36ffd22e5731e4b5053ab3b1d2dd12a232" translate="yes" xml:space="preserve">
          <source>The server does not support the STARTTLS extension.</source>
          <target state="translated">서버가 STARTTLS 확장을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69216622a0765e77ffc28455a50eaf3e224cceab" translate="yes" xml:space="preserve">
          <source>The server is closed asynchronously, use the &lt;a href=&quot;#asyncio.Server.wait_closed&quot;&gt;&lt;code&gt;wait_closed()&lt;/code&gt;&lt;/a&gt; coroutine to wait until the server is closed.</source>
          <target state="translated">서버가 비동기 적으로 닫힙니다. &lt;a href=&quot;#asyncio.Server.wait_closed&quot;&gt; &lt;code&gt;wait_closed()&lt;/code&gt; &lt;/a&gt; 코 루틴을 사용 하여 서버가 닫힐 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="24fe7057b721b26d1b1fa4ea7e7e689979456761" translate="yes" xml:space="preserve">
          <source>The server refused our &lt;code&gt;HELO&lt;/code&gt; message.</source>
          <target state="translated">서버가 &lt;code&gt;HELO&lt;/code&gt; 메시지를 거부했습니다 .</target>
        </trans-unit>
        <trans-unit id="fa1ff148e95189ffe6cc323c779c0d739606eede" translate="yes" xml:space="preserve">
          <source>The server replied with an unexpected error code (other than a refusal of a recipient).</source>
          <target state="translated">서버가 예기치 않은 오류 코드 (수신자 거부 제외)로 응답했습니다.</target>
        </trans-unit>
        <trans-unit id="34d989e84ddbda8dd5a139555512942415e2023b" translate="yes" xml:space="preserve">
          <source>The set of &lt;em&gt;accessible&lt;/em&gt; functions depends on what modules have been imported into the user process, including those imported by Idle itself, and what definitions have been run, all since the last restart.</source>
          <target state="translated">&lt;em&gt;액세스 가능한&lt;/em&gt; 기능 세트는 유휴 자체에서 가져온 모듈을 포함하여 사용자 프로세스로 가져온 모듈과 마지막 재시작 이후에 실행 된 정의에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="48c2643a6d821c9e78c60b17ecf9140e016a1333" translate="yes" xml:space="preserve">
          <source>The set of all exceptions (as a tuple) that methods of &lt;a href=&quot;#ftplib.FTP&quot;&gt;&lt;code&gt;FTP&lt;/code&gt;&lt;/a&gt; instances may raise as a result of problems with the FTP connection (as opposed to programming errors made by the caller). This set includes the four exceptions listed above as well as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">FTP 연결의 문제점으로 인해 호출자가 작성한 프로그래밍 오류가 아닌 &lt;a href=&quot;#ftplib.FTP&quot;&gt; &lt;code&gt;FTP&lt;/code&gt; &lt;/a&gt; 인스턴스의 메소드가 발생할 수 있는 모든 예외 세트 (튜플)입니다 . 이 세트에는 위에 나열된 네 가지 예외와 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="081bb73a699c6efaecd1c8a3d733213e189df822" translate="yes" xml:space="preserve">
          <source>The set of allowed values can be extended by registering a new named error handler:</source>
          <target state="translated">새로운 명명 된 오류 처리기를 등록하여 허용되는 값 집합을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bdaaae3a7f0eacb814dd25f88847cfdd23e3933" translate="yes" xml:space="preserve">
          <source>The set of allowed values for the &lt;em&gt;errors&lt;/em&gt; argument can be extended with &lt;a href=&quot;#codecs.register_error&quot;&gt;&lt;code&gt;register_error()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;errors&lt;/em&gt; 인수 에 허용되는 값 세트는 &lt;a href=&quot;#codecs.register_error&quot;&gt; &lt;code&gt;register_error()&lt;/code&gt; &lt;/a&gt; 로 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e65a0797dbedaa6af76d1a9826a2a818a37cd72e" translate="yes" xml:space="preserve">
          <source>The settings are: &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt;&lt;code&gt;OP_NO_SSLv2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt;&lt;code&gt;OP_NO_SSLv3&lt;/code&gt;&lt;/a&gt; with high encryption cipher suites without RC4 and without unauthenticated cipher suites. Passing &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt;&lt;code&gt;SERVER_AUTH&lt;/code&gt;&lt;/a&gt; as &lt;em&gt;purpose&lt;/em&gt; sets &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and either loads CA certificates (when at least one of &lt;em&gt;cafile&lt;/em&gt;, &lt;em&gt;capath&lt;/em&gt; or &lt;em&gt;cadata&lt;/em&gt; is given) or uses &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt; to load default CA certificates.</source>
          <target state="translated">설정은 RC4가없고 인증되지 않은 암호 스위트가없는 높은 암호화 암호 스위트가있는 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt; &lt;code&gt;OP_NO_SSLv2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt; &lt;code&gt;OP_NO_SSLv3&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt; &lt;code&gt;SERVER_AUTH&lt;/code&gt; &lt;/a&gt; 를 &lt;em&gt;목적으로&lt;/em&gt; 전달하면 &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; 로&lt;/a&gt; 설정 하고 CA 인증서를로드하거나 ( &lt;em&gt;cafile&lt;/em&gt; , &lt;em&gt;capath&lt;/em&gt; 또는 &lt;em&gt;cadata&lt;/em&gt; 중 하나 이상 이 제공 될 때) &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 기본 CA 인증서를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb18ec6e44e05a517a8cfdcf1bf458112bc1e30" translate="yes" xml:space="preserve">
          <source>The short form of the address representation, with leading zeroes in groups omitted and the longest sequence of groups consisting entirely of zeroes collapsed to a single empty group.</source>
          <target state="translated">그룹에서 선행 0을 생략하고 주소가 0으로 구성된 짧은 형식의 주소 표현은 완전히 0으로 구성되는 가장 긴 그룹 시퀀스가 ​​하나의 빈 그룹으로 축소되었습니다.</target>
        </trans-unit>
        <trans-unit id="f805bdc410d66fc8341d2186ebae9680f77ff29d" translate="yes" xml:space="preserve">
          <source>The sign of the result, if non-zero, is the same as that of the original dividend.</source>
          <target state="translated">0이 아닌 경우 결과의 부호는 원래 배당금의 부호와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab3c6eb2972d1f89e19cb7d944ab96116d4e6c57" translate="yes" xml:space="preserve">
          <source>The sign should follow the value and currency symbol.</source>
          <target state="translated">부호는 값과 통화 기호를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="70ec6f78774cba196da7610b04897fe7592363d5" translate="yes" xml:space="preserve">
          <source>The sign should immediately follow the value.</source>
          <target state="translated">부호는 즉시 값을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="919da334d12a2fc5f18dd4ceab7e1aada7a25231" translate="yes" xml:space="preserve">
          <source>The sign should immediately precede the value.</source>
          <target state="translated">부호는 값 바로 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="1ee0667d587bb1414e44874e7413805eb554c41c" translate="yes" xml:space="preserve">
          <source>The sign should precede the value and currency symbol.</source>
          <target state="translated">부호는 값과 통화 기호 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="7ea136642c5a17d8b5d39f8f1b4e4126da0bc289" translate="yes" xml:space="preserve">
          <source>The signal corresponding to the</source>
          <target state="translated">에 해당하는 신호</target>
        </trans-unit>
        <trans-unit id="fafae547732d3513c2c8c57b95879cfa52d4ca03" translate="yes" xml:space="preserve">
          <source>The signature of this function is dependent on what it calls. For example, the default binding (e.g. &lt;code&gt;pdb.set_trace()&lt;/code&gt;) expects no arguments, but you might bind it to a function that expects additional arguments (positional and/or keyword). The built-in &lt;code&gt;breakpoint()&lt;/code&gt; function passes its &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kws&lt;/code&gt; straight through. Whatever &lt;code&gt;breakpointhooks()&lt;/code&gt; returns is returned from &lt;code&gt;breakpoint()&lt;/code&gt;.</source>
          <target state="translated">이 함수의 서명은 그것이 호출하는 것에 의존합니다. 예를 들어, 기본 바인딩 (예 : &lt;code&gt;pdb.set_trace()&lt;/code&gt; )에는 인수가 필요하지 않지만 추가 인수 (위치 및 / 또는 키워드)가 필요한 함수에 바인딩 할 수 있습니다. 내장 된 &lt;code&gt;breakpoint()&lt;/code&gt; 함수는 &lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kws&lt;/code&gt; 를 직선으로 전달합니다. 무엇이든 &lt;code&gt;breakpointhooks()&lt;/code&gt; 반환하는 것은에서 반환 &lt;code&gt;breakpoint()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a5369a3811941d7b19f88daec4a5ed4519eb65c" translate="yes" xml:space="preserve">
          <source>The signed zeros can result from calculations that underflow. They keep the sign that would have resulted if the calculation had been carried out to greater precision. Since their magnitude is zero, both positive and negative zeros are treated as equal and their sign is informational.</source>
          <target state="translated">부호가있는 0은 언더 플로 계산에서 발생할 수 있습니다. 그들은 계산이 더 정밀하게 수행되었을 때 발생했을 부호를 유지합니다. 크기가 0이므로 양수 및 음수 0은 동일하게 취급되며 부호는 정보 용입니다.</target>
        </trans-unit>
        <trans-unit id="b5a379b2046ce18280ecfda42b964c9631b600d9" translate="yes" xml:space="preserve">
          <source>The significance of a new Decimal is determined solely by the number of digits input. Context precision and rounding only come into play during arithmetic operations.</source>
          <target state="translated">새로운 Decimal의 중요성은 입력 한 자릿수에 의해서만 결정됩니다. 상황 정밀도와 반올림은 산술 연산 중에 만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5c480e405fd8149079611892ee8838388cee67f5" translate="yes" xml:space="preserve">
          <source>The simplest &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; subclass will simply implement a test method (i.e. a method whose name starts with &lt;code&gt;test&lt;/code&gt;) in order to perform specific testing code:</source>
          <target state="translated">가장 간단한 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 서브 클래스는 특정 테스트 코드를 수행하기 위해 단순히 테스트 메소드 (즉, 이름이 &lt;code&gt;test&lt;/code&gt; 로 시작하는 메소드)를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6ef8da768f5e2727f7736cc3454383ef6bb831f4" translate="yes" xml:space="preserve">
          <source>The simplest example of reading a CSV file:</source>
          <target state="translated">CSV 파일을 읽는 가장 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="9b3118dc14604e79ea95cac54e20a71a059c73c8" translate="yes" xml:space="preserve">
          <source>The simplest possible invocation is:</source>
          <target state="translated">가능한 가장 간단한 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a713cae0a63f36592c0cdcb2740d27248af6066e" translate="yes" xml:space="preserve">
          <source>The simplest text encoding (called &lt;code&gt;'latin-1'&lt;/code&gt; or &lt;code&gt;'iso-8859-1'&lt;/code&gt;) maps the code points 0&amp;ndash;255 to the bytes &lt;code&gt;0x0&lt;/code&gt;&amp;ndash;&lt;code&gt;0xff&lt;/code&gt;, which means that a string object that contains code points above &lt;code&gt;U+00FF&lt;/code&gt; can&amp;rsquo;t be encoded with this codec. Doing so will raise a &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt;&lt;code&gt;UnicodeEncodeError&lt;/code&gt;&lt;/a&gt; that looks like the following (although the details of the error message may differ): &lt;code&gt;UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in
position 3: ordinal not in range(256)&lt;/code&gt;.</source>
          <target state="translated">가장 간단한 텍스트 인코딩 ( &lt;code&gt;'latin-1'&lt;/code&gt; 또는 &lt;code&gt;'iso-8859-1'&lt;/code&gt; )은 코드 포인트 0-255를 바이트 &lt;code&gt;0x0&lt;/code&gt; &amp;ndash; &lt;code&gt;0xff&lt;/code&gt; 에 매핑합니다. 즉, &lt;code&gt;U+00FF&lt;/code&gt; 보다 높은 코드 포인트를 포함하는 문자열 객체 는 ' 이 코덱으로 인코딩하지 마십시오. 이렇게하면 다음과 같은 &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt; &lt;code&gt;UnicodeEncodeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 (오류 메시지의 세부 사항이 다를 수 있음). &lt;code&gt;UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in position 3: ordinal not in range(256)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1521438669cce749a2e881659e485a36336dd6cd" translate="yes" xml:space="preserve">
          <source>The simplest way to make a mock raise an exception when called is to make &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; an exception class or instance:</source>
          <target state="translated">호출 될 때 모의가 예외를 발생시키는 가장 간단한 방법은 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 를 예외 클래스 또는 인스턴스 로 만드는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="881f0a260df9ba8efbf5efc927ddd30e7cae61c4" translate="yes" xml:space="preserve">
          <source>The simplest way to start using doctest (but not necessarily the way you&amp;rsquo;ll continue to do it) is to end each module &lt;code&gt;M&lt;/code&gt; with:</source>
          <target state="translated">doctest 사용을 시작하는 가장 간단한 방법은 (그러나 반드시 계속할 필요는 없음) 각 모듈 &lt;code&gt;M&lt;/code&gt; 을 다음과 같이 끝내는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8b54b057c8ffc4d06da8fb7b215fbfa86896bff1" translate="yes" xml:space="preserve">
          <source>The single address encoded by the header value. If the header value actually contains more than one address (which would be a violation of the RFC under the default &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;), accessing this attribute will result in a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">헤더 값으로 인코딩 된 단일 주소입니다. 헤더 값에 실제로 둘 이상의 주소가 포함 된 경우 (기본 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 에서 RFC 위반 )이 속성에 액세스하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="509bf276c918b44de715498fbc395a90c417d509" translate="yes" xml:space="preserve">
          <source>The size field (a 32-bit value, encoded using big-endian byte order) gives the size of the chunk data, not including the 8-byte header.</source>
          <target state="translated">크기 필드 (빅 엔디안 바이트 순서를 사용하여 인코딩 된 32 비트 값)는 8 바이트 헤더를 포함하지 않고 청크 데이터의 크기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e201cfab01f0ab4e9096a6984beacdf66e54219" translate="yes" xml:space="preserve">
          <source>The size in bytes of each element of the memoryview:</source>
          <target state="translated">memoryview의 각 요소의 크기 (바이트) :</target>
        </trans-unit>
        <trans-unit id="266d615bc372b351e64c4e77ca0efca9ec569184" translate="yes" xml:space="preserve">
          <source>The size of any &lt;em&gt;master&lt;/em&gt; widget is determined by the size of the &amp;ldquo;slave widgets&amp;rdquo; inside. The packer is used to control where slave widgets appear inside the master into which they are packed. You can pack widgets into frames, and frames into other frames, in order to achieve the kind of layout you desire. Additionally, the arrangement is dynamically adjusted to accommodate incremental changes to the configuration, once it is packed.</source>
          <target state="translated">임의의 크기 &lt;em&gt;주인&lt;/em&gt; 은 &quot;슬레이브 위젯&quot;내부의 크기에 의해 결정된다 위젯. 패커는 슬레이브 위젯이 패키징 된 마스터 내부에 표시되는 위치를 제어하는 ​​데 사용됩니다. 원하는 종류의 레이아웃을 얻기 위해 위젯을 프레임으로 묶고 다른 프레임으로 묶을 수 있습니다. 또한, 구성은 일단 포장되면 구성의 증분 변경을 수용하도록 동적으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="0ffb029747b436ca658b1039a56350ec7fac8bf4" translate="yes" xml:space="preserve">
          <source>The size of the buffer used when &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt;&lt;code&gt;buffer_text&lt;/code&gt;&lt;/a&gt; is true. A new buffer size can be set by assigning a new integer value to this attribute. When the size is changed, the buffer will be flushed.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt; &lt;code&gt;buffer_text&lt;/code&gt; &lt;/a&gt; 가 true 일 때 사용되는 버퍼의 크기입니다 . 이 속성에 새로운 정수 값을 할당하여 새로운 버퍼 크기를 설정할 수 있습니다. 크기가 변경되면 버퍼가 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae18b13f964bb5f503e73d7da58605cb96240f81" translate="yes" xml:space="preserve">
          <source>The size of the request queue. If it takes a long time to process a single request, any requests that arrive while the server is busy are placed into a queue, up to &lt;a href=&quot;#socketserver.BaseServer.request_queue_size&quot;&gt;&lt;code&gt;request_queue_size&lt;/code&gt;&lt;/a&gt; requests. Once the queue is full, further requests from clients will get a &amp;ldquo;Connection denied&amp;rdquo; error. The default value is usually 5, but this can be overridden by subclasses.</source>
          <target state="translated">요청 큐의 크기입니다. 단일 요청을 처리하는 데 시간이 오래 걸리면 서버가 사용 중일 때 도착한 모든 요청은 최대 &lt;a href=&quot;#socketserver.BaseServer.request_queue_size&quot;&gt; &lt;code&gt;request_queue_size&lt;/code&gt; &lt;/a&gt; 요청 까지 대기열에 배치됩니다 . 대기열이 가득 차면 클라이언트의 추가 요청에 &quot;연결 거부&quot;오류가 발생합니다. 기본값은 일반적으로 5이지만 서브 클래스로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afeaf7758b49b0bcc1c2c4a7eb27cb9ef94f1147" translate="yes" xml:space="preserve">
          <source>The size of the resulting HMAC digest in bytes.</source>
          <target state="translated">결과 HMAC 다이제스트의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="13040a9b4dff3237ab2d730c7d05724f985824ba" translate="yes" xml:space="preserve">
          <source>The size of the resulting hash in bytes.</source>
          <target state="translated">결과 해시의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="b22005a99782de0058b087c6cd11f9d2f0afc9c5" translate="yes" xml:space="preserve">
          <source>The slash operator helps create child paths, similarly to &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">슬래시 연산자는 &lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt; 과 유사하게 하위 경로를 만드는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="57467a0e7d5bab9bfe84eafe9f1864e336216635" translate="yes" xml:space="preserve">
          <source>The slice of &lt;em&gt;s&lt;/em&gt; from &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; is defined as the sequence of items with index &lt;em&gt;k&lt;/em&gt; such that &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; is greater than &lt;code&gt;len(s)&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;0&lt;/code&gt;. If &lt;em&gt;j&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is greater than or equal to &lt;em&gt;j&lt;/em&gt;, the slice is empty.</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; 에서 &lt;em&gt;j&lt;/em&gt; 까지 의 &lt;em&gt;s&lt;/em&gt; 슬라이스는 &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt; 되도록 인덱스 &lt;em&gt;k&lt;/em&gt; 가있는 항목 시퀀스로 정의됩니다 . 경우에 &lt;em&gt;I&lt;/em&gt; 또는 &lt;em&gt;J는&lt;/em&gt; 보다 큰 &lt;code&gt;len(s)&lt;/code&gt; , 사용하는 &lt;code&gt;len(s)&lt;/code&gt; . 경우 &lt;em&gt;i가&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; 사용할 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;em&gt;J는&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; 사용할 &lt;code&gt;len(s)&lt;/code&gt; . 경우 &lt;em&gt;나&lt;/em&gt; 이상인 경우 &lt;em&gt;J&lt;/em&gt; 슬라이스는 비어있다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db14a0b504a58a7eab89d8facc7e4bc4aeddf239" translate="yes" xml:space="preserve">
          <source>The slice of &lt;em&gt;s&lt;/em&gt; from &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; with step &lt;em&gt;k&lt;/em&gt; is defined as the sequence of items with index &lt;code&gt;x = i + n*k&lt;/code&gt; such that &lt;code&gt;0 &amp;lt;= n &amp;lt; (j-i)/k&lt;/code&gt;. In other words, the indices are &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;i+k&lt;/code&gt;, &lt;code&gt;i+2*k&lt;/code&gt;, &lt;code&gt;i+3*k&lt;/code&gt; and so on, stopping when &lt;em&gt;j&lt;/em&gt; is reached (but never including &lt;em&gt;j&lt;/em&gt;). When &lt;em&gt;k&lt;/em&gt; is positive, &lt;em&gt;i&lt;/em&gt; and &lt;em&gt;j&lt;/em&gt; are reduced to &lt;code&gt;len(s)&lt;/code&gt; if they are greater. When &lt;em&gt;k&lt;/em&gt; is negative, &lt;em&gt;i&lt;/em&gt; and &lt;em&gt;j&lt;/em&gt; are reduced to &lt;code&gt;len(s) - 1&lt;/code&gt; if they are greater. If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; are omitted or &lt;code&gt;None&lt;/code&gt;, they become &amp;ldquo;end&amp;rdquo; values (which end depends on the sign of &lt;em&gt;k&lt;/em&gt;). Note, &lt;em&gt;k&lt;/em&gt; cannot be zero. If &lt;em&gt;k&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, it is treated like &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">의 조각 &lt;em&gt;들&lt;/em&gt; 로부터 &lt;em&gt;I&lt;/em&gt; 까지 &lt;em&gt;J&lt;/em&gt; 단계와 &lt;em&gt;K는&lt;/em&gt; 인덱스 항목들의 시퀀스로 정의되고 &lt;code&gt;x = i + n*k&lt;/code&gt; 이되도록 &lt;code&gt;0 &amp;lt;= n &amp;lt; (j-i)/k&lt;/code&gt; . 즉, 인덱스는 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;i+k&lt;/code&gt; , &lt;code&gt;i+2*k&lt;/code&gt; , &lt;code&gt;i+3*k&lt;/code&gt; 때 등, 정지 &lt;em&gt;J가&lt;/em&gt; 도달 할 때 (하지만 결코 포함되지 &lt;em&gt;J&lt;/em&gt; ). 경우 &lt;em&gt;K는&lt;/em&gt; 양수, &lt;em&gt;I&lt;/em&gt; 및 &lt;em&gt;J는&lt;/em&gt; 감소된다 &lt;code&gt;len(s)&lt;/code&gt; 가 큰 경우. &lt;em&gt;K가&lt;/em&gt; 마이너스이고, &lt;em&gt;I&lt;/em&gt; 및 &lt;em&gt;J&lt;/em&gt;더 큰 경우 &lt;code&gt;len(s) - 1&lt;/code&gt; 로 줄어 듭니다 . 경우에 &lt;em&gt;I&lt;/em&gt; 또는 &lt;em&gt;J가&lt;/em&gt; 생략되어 있거나 &lt;code&gt;None&lt;/code&gt; , 그들은 &quot;END&quot;값 (의 부호에 의존하는 단부가 &lt;em&gt;K&lt;/em&gt; ). 참고 &lt;em&gt;k는&lt;/em&gt; 제로가 될 수 없습니다. 경우 &lt;em&gt;K가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 이를처럼 취급 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afdb447ab4240dc7c528e0d82c283987648888fa" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;.</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 인 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 의 가장 작은 차이 입니다.</target>
        </trans-unit>
        <trans-unit id="90720b6f330c793f876d3bf1fd81961094e9877c" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;, although note that arithmetic on &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects is not supported.</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 인 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 가능한 가장 작은 차이는 있지만 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 에 대한 산술 은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afa9031721d8fc24f5ec4d17be75903371aa9acc" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;.</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 가능한 가장 작은 차이 입니다.</target>
        </trans-unit>
        <trans-unit id="a8b267b31e001c792ef50cc23ab663368acac284" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal date objects, &lt;code&gt;timedelta(days=1)&lt;/code&gt;.</source>
          <target state="translated">같지 않은 날짜 객체 인 &lt;code&gt;timedelta(days=1)&lt;/code&gt; 가능한 가장 작은 차이 입니다.</target>
        </trans-unit>
        <trans-unit id="0564cff39070c9ab1eb076afb4a73ed5e6110583" translate="yes" xml:space="preserve">
          <source>The smallest year number allowed in a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object. &lt;a href=&quot;#datetime.MINYEAR&quot;&gt;&lt;code&gt;MINYEAR&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 개체에 허용되는 가장 작은 연도 번호 입니다. &lt;a href=&quot;#datetime.MINYEAR&quot;&gt; &lt;code&gt;MINYEAR&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac827978185abe9e1d5f1031d46773536abfd304" translate="yes" xml:space="preserve">
          <source>The snapshot does not include memory blocks allocated before the &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module started to trace memory allocations.</source>
          <target state="translated">&lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt; 모듈이 메모리 할당 추적을 시작 하기 전에 할당 된 메모리 블록은 스냅 샷에 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3518947197e510fbdae4f25cd9160d2281238301" translate="yes" xml:space="preserve">
          <source>The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a standardized way in &lt;a href=&quot;https://tools.ietf.org/html/rfc4180.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 4180&lt;/strong&gt;&lt;/a&gt;. The lack of a well-defined standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.</source>
          <target state="translated">이른바 CSV (쉼표로 구분 된 값) 형식은 스프레드 시트 및 데이터베이스에 가장 일반적인 가져 오기 및 내보내기 형식입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc4180.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 4180&lt;/strong&gt;&lt;/a&gt; 에서 표준화 된 형식으로 형식을 설명하기 전에 수년 동안 CSV 형식이 사용되었습니다 . 잘 정의 된 표준이 없다는 것은 서로 다른 응용 프로그램에서 생성하고 소비하는 데이터에 미묘한 차이가 있음을 의미합니다. 이러한 차이로 인해 여러 소스에서 CSV 파일을 처리하는 것이 성 가실 수 있습니다. 그럼에도 불구하고 구분 기호와 인용 문자는 다양하지만 전체 형식은 프로그래머가 데이터를 읽고 쓰는 세부 정보를 숨기고 이러한 데이터를 효율적으로 조작 할 수있는 단일 모듈을 작성할 수있을 정도로 유사합니다.</target>
        </trans-unit>
        <trans-unit id="b36cc9ba1945c3f902c1340bc4df70ac928ebe63" translate="yes" xml:space="preserve">
          <source>The socket always appears &amp;lsquo;ready&amp;rsquo; and excess packets are dropped. An &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;errno&lt;/code&gt; set to &lt;a href=&quot;errno#errno.ENOBUFS&quot;&gt;&lt;code&gt;errno.ENOBUFS&lt;/code&gt;&lt;/a&gt; may or may not be raised; if it is raised, it will be reported to &lt;a href=&quot;#asyncio.DatagramProtocol.error_received&quot;&gt;&lt;code&gt;DatagramProtocol.error_received()&lt;/code&gt;&lt;/a&gt; but otherwise ignored.</source>
          <target state="translated">소켓은 항상 '준비'로 나타나고 초과 패킷이 삭제됩니다. &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;errno&lt;/code&gt; 를 로 설정 &lt;a href=&quot;errno#errno.ENOBUFS&quot;&gt; &lt;code&gt;errno.ENOBUFS&lt;/code&gt; 는&lt;/a&gt; 또는 제기되지 않을 수있다 발생하면 &lt;a href=&quot;#asyncio.DatagramProtocol.error_received&quot;&gt; &lt;code&gt;DatagramProtocol.error_received()&lt;/code&gt; &lt;/a&gt; 에보고 되지만 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="580375be802eccfa86b27c314a834daee2716ca5" translate="yes" xml:space="preserve">
          <source>The socket family can be either &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt; depending on &lt;em&gt;host&lt;/em&gt; (or the &lt;em&gt;family&lt;/em&gt; argument, if provided).</source>
          <target state="translated">소켓 패밀리는 &lt;em&gt;호스트&lt;/em&gt; (또는 제공된 경우 &lt;em&gt;패밀리&lt;/em&gt; 인수) 에 따라 &lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb23c07f91f47b0410aeac381022de5cc7bbffa6" translate="yes" xml:space="preserve">
          <source>The socket family can be either &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt;, depending on &lt;em&gt;host&lt;/em&gt; (or the &lt;em&gt;family&lt;/em&gt; argument, if provided).</source>
          <target state="translated">소켓 패밀리는 &lt;em&gt;호스트&lt;/em&gt; (또는 제공된 경우 &lt;em&gt;패밀리&lt;/em&gt; 인수) 에 따라 &lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07fedf17c5be40a26d98bb4e876e8380b9555b75" translate="yes" xml:space="preserve">
          <source>The socket family will be &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt;; socket type will be &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 패밀리는 &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; 입니다&lt;/a&gt; . 소켓 유형은 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b011b1d05810914e76faef6742cb676cbb631c4d" translate="yes" xml:space="preserve">
          <source>The socket family.</source>
          <target state="translated">소켓 패밀리</target>
        </trans-unit>
        <trans-unit id="9d7aba26239da54cf438e8cc238babf966b10025" translate="yes" xml:space="preserve">
          <source>The socket must be bound to an address and listening for connections. The return value is a pair &lt;code&gt;(conn, address)&lt;/code&gt; where &lt;em&gt;conn&lt;/em&gt; is a &lt;em&gt;new&lt;/em&gt; socket object usable to send and receive data on the connection, and &lt;em&gt;address&lt;/em&gt; is the address bound to the socket on the other end of the connection.</source>
          <target state="translated">소켓은 주소에 연결되어 있고 연결을 수신 대기해야합니다. 리턴 값은 쌍 &lt;code&gt;(conn, address)&lt;/code&gt; 이며, &lt;em&gt;conn&lt;/em&gt; 은 연결에서 데이터를 송수신하는 데 사용할 수 있는 &lt;em&gt;새&lt;/em&gt; 소켓 오브젝트이며 &lt;em&gt;address&lt;/em&gt; 는 연결 의 다른 쪽 끝에있는 소켓에 바인드 된 &lt;em&gt;주소&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="638e4e32be2380339f29cabd9e12ac1b0fe0dcf2" translate="yes" xml:space="preserve">
          <source>The socket must be in blocking mode; it can have a timeout, but the file object&amp;rsquo;s internal buffer may end up in an inconsistent state if a timeout occurs.</source>
          <target state="translated">소켓은 차단 모드에 있어야합니다. 시간 초과가있을 수 있지만 시간 초과가 발생하면 파일 객체의 내부 버퍼가 일관성이없는 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d9b4b9003d10f23e4489c6bcfd88b97fc92ec67" translate="yes" xml:space="preserve">
          <source>The socket object on which the server will listen for incoming requests.</source>
          <target state="translated">서버가 들어오는 요청을 청취 할 소켓 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="26023ee861897f5dc0dfc453c9dcce20c871b174" translate="yes" xml:space="preserve">
          <source>The socket protocol.</source>
          <target state="translated">소켓 프로토콜.</target>
        </trans-unit>
        <trans-unit id="e2c94f7721fba4bae8a8259834b5d12fe4ec41fc" translate="yes" xml:space="preserve">
          <source>The socket type will be &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 유형은 &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;SOCK_DGRAM&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4389e8f1de40e8b0d84b0639d44300ab08f5992c" translate="yes" xml:space="preserve">
          <source>The socket type will be &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 유형은 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="76aee9ff5ed1acb81a710cf6c05b57b815c4d8f6" translate="yes" xml:space="preserve">
          <source>The socket type.</source>
          <target state="translated">소켓 타입.</target>
        </trans-unit>
        <trans-unit id="887f45826cd1154d00bb13afc1d5d24e35e6e8ea" translate="yes" xml:space="preserve">
          <source>The sockets that represent existing incoming client connections are left open.</source>
          <target state="translated">기존 수신 클라이언트 연결을 나타내는 소켓이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa5477e7dba26b484b00fa654ca357c05ecf60e" translate="yes" xml:space="preserve">
          <source>The sole value of the type &lt;code&gt;NoneType&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; is frequently used to represent the absence of a value, as when default arguments are not passed to a function. Assignments to &lt;code&gt;None&lt;/code&gt; are illegal and raise a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NoneType&lt;/code&gt; 유형의 유일한 값입니다 . 기본 인수가 함수에 전달되지 않을 때와 같이 &lt;code&gt;None&lt;/code&gt; 은 값이 없음 을 나타내는 데 자주 사용됩니다. &lt;code&gt;None&lt;/code&gt; 으로의 할당 은 불법이며 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="85af829c0490dff673d58821b4d8b8d4f6478909" translate="yes" xml:space="preserve">
          <source>The solution is either to increase precision or to force rounding of inputs using the unary plus operation:</source>
          <target state="translated">해결책은 단항 더하기 연산을 사용하여 정밀도를 높이거나 입력 반올림을 강제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07e7971104c97772932547de9d78450a15b11c66" translate="yes" xml:space="preserve">
          <source>The solution is safe but it has a significant overhead when handling a big number of processes (&lt;em&gt;O(n)&lt;/em&gt; each time a &lt;code&gt;SIGCHLD&lt;/code&gt; is received).</source>
          <target state="translated">솔루션은 안전하지만 많은 프로세스를 처리 할 때 상당한 오버 헤드가 있습니다 ( &lt;code&gt;SIGCHLD&lt;/code&gt; 가 수신 될 때마다 &lt;em&gt;O (n)&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="d4ae167e2456ec13e75cf55d1b00b0bdde55b895" translate="yes" xml:space="preserve">
          <source>The solution is to use Python&amp;rsquo;s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with &lt;code&gt;'r'&lt;/code&gt;. So &lt;code&gt;r&quot;\n&quot;&lt;/code&gt; is a two-character string containing &lt;code&gt;'\'&lt;/code&gt; and &lt;code&gt;'n'&lt;/code&gt;, while &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation.</source>
          <target state="translated">해결책은 정규 표현식 패턴에 Python의 원시 문자열 표기법을 사용하는 것입니다. 백 슬래시는 &lt;code&gt;'r'&lt;/code&gt; 접두사가 붙은 문자열 리터럴에서 특별한 방식으로 처리되지 않습니다 . 따라서 &lt;code&gt;r&quot;\n&quot;&lt;/code&gt; 은 &lt;code&gt;'\'&lt;/code&gt; 및 &lt;code&gt;'n'&lt;/code&gt; 을 포함하는 두 문자 문자열 이고 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 은 줄 바꾸기를 포함하는 한 문자 문자열입니다. 일반적으로 패턴은이 원시 문자열 표기법을 사용하여 Python 코드로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="630211a218ed284023e80ddd9d174a4ffb85cd53" translate="yes" xml:space="preserve">
          <source>The source code for &lt;code&gt;asyncio.run()&lt;/code&gt; can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py&quot;&gt;Lib/asyncio/runners.py&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;asyncio.run()&lt;/code&gt; 의 소스 코드 는 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py&quot;&gt;Lib / asyncio / runners.py&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7c7008356b1938d975233f6572bb32b9d0c6037" translate="yes" xml:space="preserve">
          <source>The source code for asyncio can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/&quot;&gt;Lib/asyncio/&lt;/a&gt;.</source>
          <target state="translated">asyncio의 소스 코드는 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/&quot;&gt;Lib / asyncio /&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4afea0ea275bb3d4fffc9ec00b2df6d074be239a" translate="yes" xml:space="preserve">
          <source>The sp_namp and sp_pwdp items are strings, all others are integers. &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised if the entry asked for cannot be found.</source>
          <target state="translated">sp_namp 및 sp_pwdp 항목은 문자열이고 다른 항목은 모두 정수입니다. 요청한 항목을 찾을 수 없으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d8373511020db5acc21c29f54afacf07efb1307" translate="yes" xml:space="preserve">
          <source>The spec also applies to instantiated classes (i.e. the return value of specced mocks):</source>
          <target state="translated">이 스펙은 인스턴스화 된 클래스 (즉, 지정된 모의 반환 값)에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="958f1bbb6de4a402e06c21a9ae860adbb3f32eb3" translate="yes" xml:space="preserve">
          <source>The spec only applies to the mock itself, so we still have the same issue with any methods on the mock:</source>
          <target state="translated">이 스펙은 모의 자체에만 적용되므로 모의 메소드와 관련하여 여전히 동일한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10e3e2928198f4f7fc663290ec0cccc17419f3f" translate="yes" xml:space="preserve">
          <source>The special attribute &lt;code&gt;__members__&lt;/code&gt; is a read-only ordered mapping of names to members. It includes all names defined in the enumeration, including the aliases:</source>
          <target state="translated">특수 속성 &lt;code&gt;__members__&lt;/code&gt; 는 이름을 멤버에 읽기 전용 순서로 매핑 한 것입니다. 별명을 포함하여 열거에 정의 된 모든 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e8125b61331573562956037df84be471f1f84f34" translate="yes" xml:space="preserve">
          <source>The special behaviour of the console can be overridden by setting the environment variable PYTHONLEGACYWINDOWSSTDIO before starting Python. In that case, the console codepages are used as for any other character device.</source>
          <target state="translated">Python을 시작하기 전에 환경 변수 PYTHONLEGACYWINDOWSSTDIO를 설정하여 콘솔의 특수 동작을 무시할 수 있습니다. 이 경우 콘솔 코드 페이지는 다른 문자 장치처럼 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6872f052fa8d0d34b453f09198a77148fe33e51" translate="yes" xml:space="preserve">
          <source>The special characters are:</source>
          <target state="translated">특수 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a5ee27573a32396d3ae3dc89046e9d91aa80669" translate="yes" xml:space="preserve">
          <source>The special global variables &lt;code&gt;__name__&lt;/code&gt;, &lt;code&gt;__spec__&lt;/code&gt;, &lt;code&gt;__file__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; are set in the globals dictionary before the module code is executed (Note that this is a minimal set of variables - other variables may be set implicitly as an interpreter implementation detail).</source>
          <target state="translated">특수 전역 변수 &lt;code&gt;__name__&lt;/code&gt; , &lt;code&gt;__spec__&lt;/code&gt; , &lt;code&gt;__file__&lt;/code&gt; , &lt;code&gt;__cached__&lt;/code&gt; , &lt;code&gt;__loader__&lt;/code&gt; 및 &lt;code&gt;__package__&lt;/code&gt; 는 모듈 코드가 실행되기 전에 전역 사전에 설정됩니다 (이것은 최소 변수 집합입니다. 다른 변수는 해석기 구현 세부 사항으로 암시 적으로 설정 될 수 있습니다) .</target>
        </trans-unit>
        <trans-unit id="9467123089d6aa38d3e2e72ebf08b05d73247208" translate="yes" xml:space="preserve">
          <source>The special sequences consist of &lt;code&gt;'\'&lt;/code&gt; and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, &lt;code&gt;\$&lt;/code&gt; matches the character &lt;code&gt;'$'&lt;/code&gt;.</source>
          <target state="translated">특수 시퀀스는 &lt;code&gt;'\'&lt;/code&gt; 와 아래 목록의 문자 로 구성 됩니다. 일반 문자가 ASCII 숫자 나 ASCII 문자가 아닌 경우 결과 RE는 두 번째 문자와 일치합니다. 예를 들어, &lt;code&gt;\$&lt;/code&gt; 는 문자 &lt;code&gt;'$'&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1dcbe5116b95cd6dc7867c87774d04cf7173a3e1" translate="yes" xml:space="preserve">
          <source>The specific resources that can be limited are system dependent. They are described in the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit(2)&lt;/a&gt;&lt;/em&gt; man page. The resources listed below are supported when the underlying operating system supports them; resources which cannot be checked or controlled by the operating system are not defined in this module for those platforms.</source>
          <target state="translated">제한 될 수있는 특정 리소스는 시스템에 따라 다릅니다. &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit (2)&lt;/a&gt;&lt;/em&gt; 매뉴얼 페이지에 설명되어 있습니다. 아래에 나열된 리소스는 기본 운영 체제에서 지원할 때 지원됩니다. 운영 체제에서 점검하거나 제어 할 수없는 자원은 해당 플랫폼에 대해이 모듈에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="679e621b066d4106ebdb3517733d1d8a6e844edc" translate="yes" xml:space="preserve">
          <source>The specification of the original Netscape cookie protocol. Though this is still the dominant protocol, the &amp;lsquo;Netscape cookie protocol&amp;rsquo; implemented by all the major browsers (and &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt;) only bears a passing resemblance to the one sketched out in &lt;code&gt;cookie_spec.html&lt;/code&gt;.</source>
          <target state="translated">원래 Netscape 쿠키 프로토콜의 사양. 이것이 여전히 지배적 인 프로토콜이지만 모든 주요 브라우저 (및 &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; )에 의해 구현 된 'Netscape 쿠키 프로토콜' 은 &lt;code&gt;cookie_spec.html&lt;/code&gt; 에 스케치 된 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c8a5ef525a4f38d6c8baa2c8948ff2da032e2bfc" translate="yes" xml:space="preserve">
          <source>The specification provided by the W3C defines the DOM API for Java, ECMAScript, and OMG IDL. The Python mapping defined here is based in large part on the IDL version of the specification, but strict compliance is not required (though implementations are free to support the strict mapping from IDL). See section &lt;a href=&quot;#dom-conformance&quot;&gt;Conformance&lt;/a&gt; for a detailed discussion of mapping requirements.</source>
          <target state="translated">W3C에서 제공하는 사양은 Java, ECMAScript 및 OMG IDL 용 DOM API를 정의합니다. 여기에 정의 된 Python 매핑은 대부분 IDL 버전 사양을 기반으로하지만 엄격한 준수는 필요하지 않습니다 (구현은 IDL의 엄격한 매핑을 자유롭게 지원할 수 있음). 매핑 요구 사항에 대한 자세한 내용은 &lt;a href=&quot;#dom-conformance&quot;&gt;적합성&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a54865c96e9fc0cf2ce3bd609a52643dbb3a5d" translate="yes" xml:space="preserve">
          <source>The specification, background, and examples for the Python &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에 대한 사양, 배경 및 예</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
