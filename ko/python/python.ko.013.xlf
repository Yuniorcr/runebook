<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="68f4145fee7dde76afceb910165924ad14cf0d00" translate="yes" xml:space="preserve">
          <source>Message</source>
          <target state="translated">Message</target>
        </trans-unit>
        <trans-unit id="80b747cc58c65b15d89258f4e17a95d87d10f509" translate="yes" xml:space="preserve">
          <source>Message object structures can be created in one of two ways: they can be created from whole cloth by creating an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object, adding headers using the dictionary interface, and adding payload(s) using &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; and related methods, or they can be created by parsing a serialized representation of the email message.</source>
          <target state="translated">메시지 오브젝트 구조는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 오브젝트 를 작성하고 , 사전 인터페이스를 사용하여 헤더를 추가하고, &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 및 관련 메소드를 사용하여 페이로드를 추가하여 전체 피복에서 작성 될 수 있습니다. 전자 메일 메시지의 직렬화 된 표현을 구문 분석하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7e80a85b81acb5bcf8134a2999833f3f872f8a62" translate="yes" xml:space="preserve">
          <source>Message objects</source>
          <target state="translated">메시지 객체</target>
        </trans-unit>
        <trans-unit id="6bf991e7854ed942e57f7a8ae958526d710e4851" translate="yes" xml:space="preserve">
          <source>Message too long</source>
          <target state="translated">너무 긴 메시지</target>
        </trans-unit>
        <trans-unit id="ae3fac3d770c2302e7b6a1ae541c61804b4bbb02" translate="yes" xml:space="preserve">
          <source>MessageIDHeader</source>
          <target state="translated">MessageIDHeader</target>
        </trans-unit>
        <trans-unit id="8ca731184f3581459cebf23959eca61bfdee5621" translate="yes" xml:space="preserve">
          <source>Messages in a Babyl mailbox have two sets of headers, original headers and so-called visible headers. Visible headers are typically a subset of the original headers that have been reformatted or abridged to be more attractive. Each message in a Babyl mailbox also has an accompanying list of &lt;em&gt;labels&lt;/em&gt;, or short strings that record extra information about the message, and a list of all user-defined labels found in the mailbox is kept in the Babyl options section.</source>
          <target state="translated">Babyl 메일함에있는 메시지에는 원래 헤더와 소위 보이는 헤더라는 두 가지 헤더 세트가 있습니다. 표시 가능한 헤더는 일반적으로보다 매력적으로 재구성되거나 요약 된 원래 헤더의 하위 집합입니다. Babyl 메일함에있는 각 메시지에는 &lt;em&gt;레이블&lt;/em&gt; 에 대한 &lt;em&gt;레이블&lt;/em&gt; 목록 또는 메시지에 대한 추가 정보를 기록하는 짧은 문자열이 있으며, 메일함에있는 모든 사용자 정의 레이블 목록은 Babyl 옵션 섹션에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1677ab0cd3601cac9f7ad62eb5f484d8b6a9b975" translate="yes" xml:space="preserve">
          <source>Messages in an mbox mailbox are stored together in a single file. The sender&amp;rsquo;s envelope address and the time of delivery are typically stored in a line beginning with &amp;ldquo;From &amp;rdquo; that is used to indicate the start of a message, though there is considerable variation in the exact format of this data among mbox implementations. Flags that indicate the state of the message, such as whether it has been read or marked as important, are typically stored in &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers.</source>
          <target state="translated">mbox 메일함에있는 메시지는 단일 파일에 함께 저장됩니다. 발신자의 봉투 주소와 배달 시간은 일반적으로 메시지의 시작을 나타내는 데 사용되는&amp;ldquo;보낸 사람&amp;rdquo;으로 시작하는 행에 저장되지만 mbox 구현간에이 데이터의 정확한 형식에는 상당한 차이가 있습니다. 메시지를 읽었는지 또는 중요하게 표시했는지와 같은 메시지 상태를 나타내는 플래그는 일반적으로 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X- 상태&lt;/em&gt; 헤더에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce502b237ed2952032c06cc66fddcfdbf0466da2" translate="yes" xml:space="preserve">
          <source>Messages may be added to a &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance using the set-like method &lt;a href=&quot;#mailbox.Mailbox.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; and removed using a &lt;code&gt;del&lt;/code&gt; statement or the set-like methods &lt;a href=&quot;#mailbox.Mailbox.remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메시지는 set-like 메소드 &lt;a href=&quot;#mailbox.Mailbox.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스에 추가 되고 &lt;code&gt;del&lt;/code&gt; 문 또는 set-like 메소드 &lt;a href=&quot;#mailbox.Mailbox.remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; 사용하여 제거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b1f88ec82e011a2e8176b28aacc80eda529a767" translate="yes" xml:space="preserve">
          <source>Metaclass for defining Abstract Base Classes (ABCs).</source>
          <target state="translated">ABC (Abstract Base Classes)를 정의하기위한 메타 클래스.</target>
        </trans-unit>
        <trans-unit id="a49c9e99a5c2fca29b2700a9772373e6a22ccee7" translate="yes" xml:space="preserve">
          <source>Metaclasses</source>
          <target state="translated">Metaclasses</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="1ad6284b73b0f911633f1c682d1bd1a0d2a1d3e3" translate="yes" xml:space="preserve">
          <source>Method Name</source>
          <target state="translated">방법 이름</target>
        </trans-unit>
        <trans-unit id="7397c74c7f3015f9c8b78018a46b8693a78d3d77" translate="yes" xml:space="preserve">
          <source>Method called immediately after the test method has been called and the result recorded. This is called before &lt;code&gt;tearDown()&lt;/code&gt;. This is called even if the test method raised an exception, so the implementation in subclasses may need to be particularly careful about checking internal state. Any exception, other than &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt;, raised by this method will be considered an additional error rather than a test failure (thus increasing the total number of reported errors). This method will only be called if the &lt;a href=&quot;#unittest.IsolatedAsyncioTestCase.asyncSetUp&quot;&gt;&lt;code&gt;asyncSetUp()&lt;/code&gt;&lt;/a&gt; succeeds, regardless of the outcome of the test method. The default implementation does nothing.</source>
          <target state="translated">테스트 메소드가 호출 된 직후에 호출 된 메소드가 기록되었습니다. 이것은 &lt;code&gt;tearDown()&lt;/code&gt; 전에 호출 됩니다. 테스트 메소드가 예외를 발생시킨 경우에도 호출되므로 서브 클래스의 구현은 특히 내부 상태 점검에주의해야합니다. 이 메소드에 의해 발생 된 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 이외의 예외 는 테스트 실패가 아닌 추가 오류로 간주되므로보고 된 총 오류 수가 증가합니다. 이 메소드는 테스트 메소드의 결과에 관계없이 &lt;a href=&quot;#unittest.IsolatedAsyncioTestCase.asyncSetUp&quot;&gt; &lt;code&gt;asyncSetUp()&lt;/code&gt; &lt;/a&gt; 성공한 경우에만 호출됩니다 . 기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dbbd8f81d018eed640981cd64112d0d9e54bc10" translate="yes" xml:space="preserve">
          <source>Method called immediately after the test method has been called and the result recorded. This is called even if the test method raised an exception, so the implementation in subclasses may need to be particularly careful about checking internal state. Any exception, other than &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt;, raised by this method will be considered an additional error rather than a test failure (thus increasing the total number of reported errors). This method will only be called if the &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; succeeds, regardless of the outcome of the test method. The default implementation does nothing.</source>
          <target state="translated">테스트 메소드가 호출 된 직후에 호출 된 메소드가 기록되었습니다. 테스트 메소드가 예외를 발생시킨 경우에도 호출되므로 서브 클래스의 구현은 특히 내부 상태 점검에주의해야합니다. 이 메소드에 의해 발생 된 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 이외의 예외 는 테스트 실패가 아닌 추가 오류로 간주되므로보고 된 총 오류 수가 증가합니다. 이 메소드는 테스트 메소드의 결과에 관계없이 &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 성공한 경우에만 호출됩니다 . 기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="649399ca8ea45b90bb86cca66b9e51f7b179886c" translate="yes" xml:space="preserve">
          <source>Method called on an input line when the command prefix is not recognized. If this method is not overridden, it prints an error message and returns.</source>
          <target state="translated">명령 접두사가 인식되지 않을 때 입력 행에서 호출 된 메소드입니다. 이 메서드를 재정의하지 않으면 오류 메시지가 인쇄되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b83ae09e4143ec55d36cfc4cb6caafc420c049b4" translate="yes" xml:space="preserve">
          <source>Method called to complete an input line when no command-specific &lt;code&gt;complete_*()&lt;/code&gt; method is available. By default, it returns an empty list.</source>
          <target state="translated">명령 별 &lt;code&gt;complete_*()&lt;/code&gt; 메소드를 사용할 수 없는 경우 입력 행을 완료하기 위해 메소드가 호출됩니다 . 기본적으로 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e63efa71573eeb573342934f9e04a35f636518cc" translate="yes" xml:space="preserve">
          <source>Method called to prepare the test fixture. This is called after &lt;code&gt;setUp()&lt;/code&gt;. This is called immediately before calling the test method; other than &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt;, any exception raised by this method will be considered an error rather than a test failure. The default implementation does nothing.</source>
          <target state="translated">테스트 픽스처를 준비하기 위해 호출 된 메소드. 이것은 &lt;code&gt;setUp()&lt;/code&gt; 후에 호출 됩니다. 테스트 메소드를 호출하기 직전에 호출됩니다. &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 이외의 경우이 메소드로 발생한 예외는 테스트 실패가 아닌 오류로 간주됩니다. 기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ba475e032ec26577941b02aa8180ec211fee641" translate="yes" xml:space="preserve">
          <source>Method called to prepare the test fixture. This is called immediately before calling the test method; other than &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt;, any exception raised by this method will be considered an error rather than a test failure. The default implementation does nothing.</source>
          <target state="translated">테스트 픽스처를 준비하기 위해 호출 된 메소드. 테스트 메소드를 호출하기 직전에 호출됩니다. &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 이외의 경우이 메소드로 발생한 예외는 테스트 실패가 아닌 오류로 간주됩니다. 기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37a3391d3e50f08fbc5f1dc6bfe9fb76fdbd1e6e" translate="yes" xml:space="preserve">
          <source>Method called when a processing instruction is encountered. The &lt;em&gt;data&lt;/em&gt; parameter will contain the entire processing instruction. For example, for the processing instruction &lt;code&gt;&amp;lt;?proc color='red'&amp;gt;&lt;/code&gt;, this method would be called as &lt;code&gt;handle_pi(&quot;proc color='red'&quot;)&lt;/code&gt;. It is intended to be overridden by a derived class; the base class implementation does nothing.</source>
          <target state="translated">처리 명령이 발견 될 때 호출되는 메소드입니다. &lt;em&gt;데이터&lt;/em&gt; 파라미터는 전체 처리 명령어를 포함한다. 예를 들어, 처리 명령 &lt;code&gt;&amp;lt;?proc color='red'&amp;gt;&lt;/code&gt; 의 경우이 메소드를 &lt;code&gt;handle_pi(&quot;proc color='red'&quot;)&lt;/code&gt; 로 호출 합니다. 파생 클래스에 의해 재정의됩니다. 기본 클래스 구현은 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0288a5f7ccd8cc496ea12f8fbcdaa51a282fa56f" translate="yes" xml:space="preserve">
          <source>Method called when an empty line is entered in response to the prompt. If this method is not overridden, it repeats the last nonempty command entered.</source>
          <target state="translated">프롬프트에 응답하여 빈 줄을 입력 할 때 호출되는 메서드입니다. 이 방법을 재정의하지 않으면 입력 한 마지막 비어 있지 않은 명령이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="e24fcca75d4001a50a3952dc15cf0af185ccf066" translate="yes" xml:space="preserve">
          <source>Method of</source>
          <target state="translated">의 방법</target>
        </trans-unit>
        <trans-unit id="c7659f5d6aa5a918feaa57fcebe08395c1db51d9" translate="yes" xml:space="preserve">
          <source>Method representing the process&amp;rsquo;s activity.</source>
          <target state="translated">프로세스 활동을 나타내는 메소드.</target>
        </trans-unit>
        <trans-unit id="599bc23d73a1edefe369be9db61c7ca34ff8a7cb" translate="yes" xml:space="preserve">
          <source>Method representing the thread&amp;rsquo;s activity.</source>
          <target state="translated">스레드의 활동을 나타내는 메소드.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="8d4aa5000379004bcc4aff6105bab534cc12d577" translate="yes" xml:space="preserve">
          <source>Methods and attributes for &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt;&amp;rsquo;s &amp;ldquo;Optional Platform-Specific File Handling&amp;rdquo; feature:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt; 의&amp;ldquo;선택적 플랫폼 별 파일 처리&amp;rdquo;기능의 방법 및 속성 :</target>
        </trans-unit>
        <trans-unit id="0da2ffd7bd9a87acd1c5cd9576e17a1cb3b019f6" translate="yes" xml:space="preserve">
          <source>Methods and attributes for customizing exception handling:</source>
          <target state="translated">예외 처리를 사용자 정의하기위한 메소드 및 속성 :</target>
        </trans-unit>
        <trans-unit id="1f97bbd5be402e144dea36fabf7319751aeb1da1" translate="yes" xml:space="preserve">
          <source>Methods and properties</source>
          <target state="translated">방법과 속성</target>
        </trans-unit>
        <trans-unit id="b954e3daaa50f78aaaff2c7fa0f441c94145e8b7" translate="yes" xml:space="preserve">
          <source>Methods and their defaults:</source>
          <target state="translated">방법과 기본값 :</target>
        </trans-unit>
        <trans-unit id="7cc2af8c2f86f770582029b10e3b40de2255d2a7" translate="yes" xml:space="preserve">
          <source>Methods are functions that are called using the attribute notation. There are two flavors: built-in methods (such as &lt;code&gt;append()&lt;/code&gt; on lists) and class instance methods. Built-in methods are described with the types that support them.</source>
          <target state="translated">메소드는 속성 표기법을 사용하여 호출되는 함수입니다. 내장 메소드 ( 목록의 &lt;code&gt;append()&lt;/code&gt; 와 같은 )와 클래스 인스턴스 메소드의 두 가지 특징이 있습니다. 내장 메소드는이를 지원하는 유형으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="157469193b5d41d954e73f13258439fe6beb778e" translate="yes" xml:space="preserve">
          <source>Methods described in this subsections are low-level. In regular async/await code consider using the high-level &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_shell&quot;&gt;&lt;code&gt;asyncio.create_subprocess_shell()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;asyncio.create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; convenience functions instead.</source>
          <target state="translated">이 하위 섹션에 설명 된 방법은 저수준입니다. 일반 async / await 코드에서는 대신 고급 &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_shell&quot;&gt; &lt;code&gt;asyncio.create_subprocess_shell()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;asyncio.create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 편의 함수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0965a16d87bebafaef05da87be1917226fdd0b9d" translate="yes" xml:space="preserve">
          <source>Methods implemented via descriptors that also pass one of the other tests return &lt;code&gt;False&lt;/code&gt; from the &lt;a href=&quot;#inspect.ismethoddescriptor&quot;&gt;&lt;code&gt;ismethoddescriptor()&lt;/code&gt;&lt;/a&gt; test, simply because the other tests promise more &amp;ndash; you can, e.g., count on having the &lt;code&gt;__func__&lt;/code&gt; attribute (etc) when an object passes &lt;a href=&quot;#inspect.ismethod&quot;&gt;&lt;code&gt;ismethod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 다른 시험 중 하나를 통과 기술자를 통해 구현 방법은 반환 &lt;code&gt;False&lt;/code&gt; 으로부터 &lt;a href=&quot;#inspect.ismethoddescriptor&quot;&gt; &lt;code&gt;ismethoddescriptor()&lt;/code&gt; &lt;/a&gt; 다른 시험보다 약속 간단하기 때문에, 테스트 - 당신은, 예를 들어, 가진 믿을 수 &lt;code&gt;__func__&lt;/code&gt; 의 속성 (등) 때 개체가 통과 &lt;a href=&quot;#inspect.ismethod&quot;&gt; &lt;code&gt;ismethod()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9100cdec520f2115d829aad91ecbf2d3a3c46d0" translate="yes" xml:space="preserve">
          <source>Methods in the first group (running the test) are:</source>
          <target state="translated">첫 번째 그룹의 방법 (테스트 실행)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a45ab4a3e2a82c9598ef6d35c55326d75ba801c" translate="yes" xml:space="preserve">
          <source>Methods of RawTurtle/Turtle and corresponding functions</source>
          <target state="translated">RawTurtle / Turtle의 방법 및 해당 기능</target>
        </trans-unit>
        <trans-unit id="02c2ec68b20d39a2feafa7d1d898a028041eb4f1" translate="yes" xml:space="preserve">
          <source>Methods of TurtleScreen/Screen</source>
          <target state="translated">TurtleScreen / Screen의 방법</target>
        </trans-unit>
        <trans-unit id="020f9d7bdaf4f831aeffeaaaeea5da2050a62b4e" translate="yes" xml:space="preserve">
          <source>Methods of TurtleScreen/Screen and corresponding functions</source>
          <target state="translated">TurtleScreen / Screen 방법 및 해당 기능</target>
        </trans-unit>
        <trans-unit id="74870948cfdac56fe627ac3f9017759f080dd5ad" translate="yes" xml:space="preserve">
          <source>Methods specific to Screen</source>
          <target state="translated">화면에 특정한 방법</target>
        </trans-unit>
        <trans-unit id="ed10df094e649397ec44790d691389289e610494" translate="yes" xml:space="preserve">
          <source>Methods specific to Screen, not inherited from TurtleScreen</source>
          <target state="translated">TurtleScreen에서 상속되지 않은 Screen 관련 메소드</target>
        </trans-unit>
        <trans-unit id="c659b6a8d84e8b57729160efb981e97738f69a55" translate="yes" xml:space="preserve">
          <source>Microsecond as a decimal number, zero-padded on the left.</source>
          <target state="translated">왼쪽에 0으로 채워진 10 진수의 마이크로 초입니다.</target>
        </trans-unit>
        <trans-unit id="27380d20cf0052fb068648454674c0487d921401" translate="yes" xml:space="preserve">
          <source>Mike Clarkson converted the documentation to LaTeX, and compiled the User Interface chapter of the reference manual.</source>
          <target state="translated">Mike Clarkson은 설명서를 LaTeX로 변환하고 참조 설명서의 사용자 인터페이스 장을 편집했습니다.</target>
        </trans-unit>
        <trans-unit id="27af939f79765f408e27d70736e746c0d48d9a0c" translate="yes" xml:space="preserve">
          <source>Millisecond portion of the time when the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; was created.</source>
          <target state="translated">&lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 가 작성된 시간의 밀리 초 입니다.</target>
        </trans-unit>
        <trans-unit id="dccbd93c0e8d8f9988adced2fe258f1e1532b0c5" translate="yes" xml:space="preserve">
          <source>MimeTypes Objects</source>
          <target state="translated">MimeTypes 객체</target>
        </trans-unit>
        <trans-unit id="9efbdba622b2dadfd43fa42e2a291351db71d49c" translate="yes" xml:space="preserve">
          <source>Minimal number of days between changes</source>
          <target state="translated">변경 사이의 최소 일수</target>
        </trans-unit>
        <trans-unit id="10937ed4b37b67fa14b13edd3d7e271abb8fa9aa" translate="yes" xml:space="preserve">
          <source>Minimum field width (optional). If specified as an &lt;code&gt;'*'&lt;/code&gt; (asterisk), the actual width is read from the next element of the tuple in &lt;em&gt;values&lt;/em&gt;, and the object to convert comes after the minimum field width and optional precision.</source>
          <target state="translated">최소 필드 너비 (선택 사항). &lt;code&gt;'*'&lt;/code&gt; (별표) 로 지정된 경우 실제 너비는 튜플의 다음 요소에서 &lt;em&gt;values&lt;/em&gt; 로 읽히고 변환 할 객체는 최소 필드 너비 및 선택적 정밀도 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="b823f84a7a7baed339dafffa8b2988e08ee82d18" translate="yes" xml:space="preserve">
          <source>Minimum key value</source>
          <target state="translated">최소 키 값</target>
        </trans-unit>
        <trans-unit id="b9bea4e62057406a848ed5d0422b9238d8ab04ce" translate="yes" xml:space="preserve">
          <source>Minimum size in bytes</source>
          <target state="translated">바이트 단위의 최소 크기</target>
        </trans-unit>
        <trans-unit id="6506540f28a982451f07fe2b992f3fdcae62b53d" translate="yes" xml:space="preserve">
          <source>Minus corresponds to the unary prefix minus operator in Python.</source>
          <target state="translated">빼기는 파이썬에서 단항 접두사 빼기 연산자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2b6196c452bc75192cad3b9bbe7b45fccf953c66" translate="yes" xml:space="preserve">
          <source>Minute as a decimal number [00,59].</source>
          <target state="translated">십진수로 된 분 [00,59].</target>
        </trans-unit>
        <trans-unit id="04796ca1f6aacaabf17bb7220586582c19201712" translate="yes" xml:space="preserve">
          <source>Minute as a zero-padded decimal number.</source>
          <target state="translated">0으로 채워진 10 진수로 분.</target>
        </trans-unit>
        <trans-unit id="092f99ea11a34a8490e7a767a83a42fc45634f82" translate="yes" xml:space="preserve">
          <source>Minutes</source>
          <target state="translated">Minutes</target>
        </trans-unit>
        <trans-unit id="edb2ab561b48557288fb17a60a42f5fe203a8b9c" translate="yes" xml:space="preserve">
          <source>Minutes (zero-based)</source>
          <target state="translated">분 (0부터 시작)</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="e34e8783c8b5d62f8e56a6c5cad9c3189996ba14" translate="yes" xml:space="preserve">
          <source>Miscellaneous Services</source>
          <target state="translated">기타 서비스</target>
        </trans-unit>
        <trans-unit id="43274253a78afe031d6f6358c749c28e750ad3ba" translate="yes" xml:space="preserve">
          <source>Miscellaneous System Information</source>
          <target state="translated">기타 시스템 정보</target>
        </trans-unit>
        <trans-unit id="2cacc40bbba670255923cac65963686bb7f6e8fa" translate="yes" xml:space="preserve">
          <source>Miscellaneous Widgets</source>
          <target state="translated">기타 위젯</target>
        </trans-unit>
        <trans-unit id="b80881a19ff8cf751c3f41f6a0bbae4d2fa4b957" translate="yes" xml:space="preserve">
          <source>Miscellaneous methods and attributes:</source>
          <target state="translated">기타 메소드 및 속성 :</target>
        </trans-unit>
        <trans-unit id="1be5ce0f6da11db26ce77b075f6f409fed55bed0" translate="yes" xml:space="preserve">
          <source>Mitigating round-off error with increased precision</source>
          <target state="translated">정밀도 향상으로 반올림 오차 완화</target>
        </trans-unit>
        <trans-unit id="fbb183ab6d5eb981bdb6b26cfc5bc04b44dbf9ef" translate="yes" xml:space="preserve">
          <source>Mix the given &lt;em&gt;bytes&lt;/em&gt; into the SSL pseudo-random number generator. The parameter &lt;em&gt;entropy&lt;/em&gt; (a float) is a lower bound on the entropy contained in string (so you can always use &lt;code&gt;0.0&lt;/code&gt;). See &lt;a href=&quot;https://tools.ietf.org/html/rfc1750.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 1750&lt;/strong&gt;&lt;/a&gt; for more information on sources of entropy.</source>
          <target state="translated">주어진 &lt;em&gt;바이트&lt;/em&gt; 를 SSL 의사 난수 생성기에 혼합하십시오 . 매개 변수 &lt;em&gt;엔트로피&lt;/em&gt; (float)는 문자열에 포함 된 엔트로피의 하한값이므로 항상 &lt;code&gt;0.0&lt;/code&gt; 을 사용할 수 있습니다 . 엔트로피 소스에 대한 자세한 내용 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1750.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 1750&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08cde62b7bf975bbde5b97246a5722dd5b75c745" translate="yes" xml:space="preserve">
          <source>Mixer Device Objects</source>
          <target state="translated">믹서 장치 객체</target>
        </trans-unit>
        <trans-unit id="1cdbdedcba3074069f36e236c409fb7bd1ae38c6" translate="yes" xml:space="preserve">
          <source>Mixin Methods</source>
          <target state="translated">믹스 인 방법</target>
        </trans-unit>
        <trans-unit id="9cb6196c924e579cfebfa9d20714ab12efb27976" translate="yes" xml:space="preserve">
          <source>Mixin Methods and Properties</source>
          <target state="translated">믹스 인 방법 및 속성</target>
        </trans-unit>
        <trans-unit id="eff64571433b5d5f6c30bbfd893c2be61001c6a7" translate="yes" xml:space="preserve">
          <source>Mock Patching Methods</source>
          <target state="translated">모의 패치 방법</target>
        </trans-unit>
        <trans-unit id="a3f6662904906028997ca7c9f0b62eded70f9d87" translate="yes" xml:space="preserve">
          <source>Mock allows you to assign functions (or other Mock instances) to magic methods and they will be called appropriately. The &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; class is just a Mock variant that has all of the magic methods pre-created for you (well, all the useful ones anyway).</source>
          <target state="translated">Mock을 사용하면 함수 (또는 다른 Mock 인스턴스)를 마법 메서드에 할당 할 수 있으며 적절하게 호출됩니다. &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; 의&lt;/a&gt; 클래스는 (잘 모든 유용한 것들 어쨌든) 마법의 방법을 모두 당신을 위해 만든 사전이 단지 모의 변종이다.</target>
        </trans-unit>
        <trans-unit id="cd40a569044d5954e317d074d7665541eb9c7c41" translate="yes" xml:space="preserve">
          <source>Mock for Method Calls on an Object</source>
          <target state="translated">객체의 메소드 호출 모의</target>
        </trans-unit>
        <trans-unit id="ad02912ae468a4be2e695c5d469c4a5f0380c99b" translate="yes" xml:space="preserve">
          <source>Mock has many other ways you can configure it and control its behaviour. For example the &lt;em&gt;spec&lt;/em&gt; argument configures the mock to take its specification from another object. Attempting to access attributes or methods on the mock that don&amp;rsquo;t exist on the spec will fail with an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mock에는 여러 가지 방법으로 구성하고 동작을 제어 할 수 있습니다. 예를 들어 &lt;em&gt;spec&lt;/em&gt; 인수는 mock이 다른 객체에서 사양을 가져 오도록 구성합니다. 스펙에 존재하지 않는 모의 객체에서 속성 또는 메소드에 액세스하려고 시도하면 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 로&lt;/a&gt; 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="6465c7a575090539f19523ea47c493eba308187f" translate="yes" xml:space="preserve">
          <source>Mock is very easy to use and is designed for use with &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;. Mock is based on the &amp;lsquo;action -&amp;gt; assertion&amp;rsquo; pattern instead of &amp;lsquo;record -&amp;gt; replay&amp;rsquo; used by many mocking frameworks.</source>
          <target state="translated">Mock은 사용하기 매우 쉽고 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 와 함께 사용하도록 설계되었습니다 . Mock은 많은 조롱 프레임 워크에서 사용되는 'record-&amp;gt; replay'대신 'action-&amp;gt; assertion'패턴을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a33279ac6a1d4f11a964719fd8b938904220c3f2" translate="yes" xml:space="preserve">
          <source>Mock names and the name attribute</source>
          <target state="translated">모의 이름과 이름 속성</target>
        </trans-unit>
        <trans-unit id="297d74ca0e3cf788f8845b7bffff3c689ae98bb8" translate="yes" xml:space="preserve">
          <source>Mock objects are callable. The call will return the value set as the &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt;&lt;code&gt;return_value&lt;/code&gt;&lt;/a&gt; attribute. The default return value is a new Mock object; it is created the first time the return value is accessed (either explicitly or by calling the Mock) - but it is stored and the same one returned each time.</source>
          <target state="translated">모의 객체는 호출 가능합니다. 호출은 &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt; &lt;code&gt;return_value&lt;/code&gt; &lt;/a&gt; 속성으로 설정된 값을 반환 합니다. 기본 반환 값은 새로운 Mock 객체입니다. 반환 값에 처음으로 액세스 할 때 (명시 적으로 또는 Mock을 호출하여) 만들어 지지만 저장되고 매번 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d9cf297397c83b1c1f81d316fa2ec3e341da36" translate="yes" xml:space="preserve">
          <source>Mock objects create attributes on demand. This allows them to pretend to be objects of any type.</source>
          <target state="translated">모의 객체는 요청시 속성을 만듭니다. 이를 통해 모든 유형의 객체 인 것처럼 가장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e775774d5b183cd27cc35f774581d60bd2a447c3" translate="yes" xml:space="preserve">
          <source>Mock objects that use a class or an instance as a &lt;code&gt;spec&lt;/code&gt; or &lt;code&gt;spec_set&lt;/code&gt; are able to pass &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; tests:</source>
          <target state="translated">클래스 또는 인스턴스를 &lt;code&gt;spec&lt;/code&gt; 또는 &lt;code&gt;spec_set&lt;/code&gt; 으로 사용하는 모의 객체는 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 테스트 를 통과 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9e1deeb7a9ee5f850fe86eecbde6fcdcdde263d" translate="yes" xml:space="preserve">
          <source>Mock subclasses and their attributes</source>
          <target state="translated">모의 서브 클래스와 그 속성</target>
        </trans-unit>
        <trans-unit id="7d6354b13984c9353fd8091e3574d84d2ae7bff2" translate="yes" xml:space="preserve">
          <source>Mock supports the mocking of Python &lt;a href=&quot;#magic-methods&quot;&gt;magic methods&lt;/a&gt;. The easiest way of using magic methods is with the &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; class. It allows you to do things like:</source>
          <target state="translated">Mock은 Python &lt;a href=&quot;#magic-methods&quot;&gt;매직 메소드&lt;/a&gt; 의 조롱을 지원합니다 . 매직 메소드를 사용하는 가장 쉬운 방법은 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 클래스를 사용하는 것입니다. 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442dbf157ba95db3e914bc2e408149e5cd398207" translate="yes" xml:space="preserve">
          <source>Mocking Classes</source>
          <target state="translated">조롱 수업</target>
        </trans-unit>
        <trans-unit id="9c8d301fe549f44ad1715a27813e8f92b2397116" translate="yes" xml:space="preserve">
          <source>Mocking Magic Methods</source>
          <target state="translated">모의 마술 방법</target>
        </trans-unit>
        <trans-unit id="c72f61e205c323791b33c0bccba66e2eb04fbb68" translate="yes" xml:space="preserve">
          <source>Mocking Unbound Methods</source>
          <target state="translated">언 바운드 메소드 조롱</target>
        </trans-unit>
        <trans-unit id="c0498faab975f9dec8b132168e6c508f7f74f956" translate="yes" xml:space="preserve">
          <source>Mocking a Generator Method</source>
          <target state="translated">생성기 메서드 조롱</target>
        </trans-unit>
        <trans-unit id="631d0520a6e791d2c5663b5421225becab5962da" translate="yes" xml:space="preserve">
          <source>Mocking a dictionary with MagicMock</source>
          <target state="translated">MagicMock으로 사전 조롱</target>
        </trans-unit>
        <trans-unit id="a35b06a5a88f1663407e0afcc28d593f48d020de" translate="yes" xml:space="preserve">
          <source>Mocking asynchronous context manager</source>
          <target state="translated">비동기 컨텍스트 관리자 모의</target>
        </trans-unit>
        <trans-unit id="9a90be214817c7625129004dae96c161fa6d1b8f" translate="yes" xml:space="preserve">
          <source>Mocking asynchronous iterators</source>
          <target state="translated">비동기 반복자 조롱</target>
        </trans-unit>
        <trans-unit id="21c9b59bfaaa2939d61edf0de7e54d2b77191fcb" translate="yes" xml:space="preserve">
          <source>Mocking chained calls</source>
          <target state="translated">모의 연쇄 통화</target>
        </trans-unit>
        <trans-unit id="077151c5dfce974cc6f624aaa441016501984bcd" translate="yes" xml:space="preserve">
          <source>Mocking context managers with a &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; is common enough and fiddly enough that a helper function is useful.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; 을&lt;/a&gt; 사용하여 컨텍스트 관리자를 조롱 하는 것은 도우미 기능이 유용 할만큼 충분히 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="7c7ee5cc465310c6d4c3ad7b378ba9b12a5a62d8" translate="yes" xml:space="preserve">
          <source>Mocking imports with patch.dict</source>
          <target state="translated">patch.dict로 수입 모의</target>
        </trans-unit>
        <trans-unit id="365779533ffb4a7f946eeb0ebce48c8d4a000a5b" translate="yes" xml:space="preserve">
          <source>Mocks can also be called with arbitrary keyword arguments. These will be used to set attributes on the mock after it is created. See the &lt;a href=&quot;#unittest.mock.Mock.configure_mock&quot;&gt;&lt;code&gt;configure_mock()&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">임의의 키워드 인수로 Mocks를 호출 할 수도 있습니다. 이것들은 모의 객체가 생성 된 후에 속성을 설정하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;#unittest.mock.Mock.configure_mock&quot;&gt; &lt;code&gt;configure_mock()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2cbdd4fc62fd73dd9af51cb0370400f47d6de4ca" translate="yes" xml:space="preserve">
          <source>Mocks created for you by &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; are automatically given names. To attach mocks that have names to a parent you use the &lt;a href=&quot;#unittest.mock.Mock.attach_mock&quot;&gt;&lt;code&gt;attach_mock()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 mocks 에는 자동으로 이름이 지정됩니다. 부모에게 이름이있는 모의 객체를 첨부하려면 &lt;a href=&quot;#unittest.mock.Mock.attach_mock&quot;&gt; &lt;code&gt;attach_mock()&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="de84d7a663bae517f4b489470b51febd30e66c30" translate="yes" xml:space="preserve">
          <source>Mode &amp;ldquo;standard&amp;rdquo; is compatible with old &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt;. Mode &amp;ldquo;logo&amp;rdquo; is compatible with most Logo turtle graphics. Mode &amp;ldquo;world&amp;rdquo; uses user-defined &amp;ldquo;world coordinates&amp;rdquo;. &lt;strong&gt;Attention&lt;/strong&gt;: in this mode angles appear distorted if &lt;code&gt;x/y&lt;/code&gt; unit-ratio doesn&amp;rsquo;t equal 1.</source>
          <target state="translated">&quot;표준&quot;모드는 오래된 &lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 와 호환됩니다 . &quot;logo&quot;모드는 대부분의 로고 거북이 그래픽과 호환됩니다. &quot;세계&quot;모드는 사용자 정의 된 &quot;세계 좌표&quot;를 사용합니다. &lt;strong&gt;주의&lt;/strong&gt; :이 모드에서는 &lt;code&gt;x/y&lt;/code&gt; 단위 비율이 1이 아닌 경우 각도가 왜곡되어 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="92d399cc66de7cf367f31ade723cb8b6691c5bdf" translate="yes" xml:space="preserve">
          <source>Models which represent a series of models which follow one after the other are indicated with this model type. This is used for models such as &lt;code&gt;(A, B, C)&lt;/code&gt;.</source>
          <target state="translated">일련의 모델을 차례로 나타내는 모델은이 모델 유형으로 표시됩니다. &lt;code&gt;(A, B, C)&lt;/code&gt; 와 같은 모델에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="59ce22dee5a92a32f030e3b34445688bcbabd4d7" translate="yes" xml:space="preserve">
          <source>Modern Tkinter for Busy Python Developers</source>
          <target state="translated">바쁜 Python 개발자를위한 최신 Tkinter</target>
        </trans-unit>
        <trans-unit id="59eeb274f6d5a5d8796b7fb0f22a558b81af0ba0" translate="yes" xml:space="preserve">
          <source>Modern macOS versions are fully supported.</source>
          <target state="translated">최신 macOS 버전이 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="77c81a24b3232f4341cb83b7f39ce945fe4ff3fb" translate="yes" xml:space="preserve">
          <source>Modified by the user</source>
          <target state="translated">사용자가 수정</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="32cd9ef050293cc9b2ea16140453d0cb9eba9e0e" translate="yes" xml:space="preserve">
          <source>Modifies an already registered fd. This has the same effect as &lt;code&gt;register(fd, eventmask)&lt;/code&gt;. Attempting to modify a file descriptor that was never registered causes an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception with errno &lt;code&gt;ENOENT&lt;/code&gt; to be raised.</source>
          <target state="translated">이미 등록 된 fd를 수정합니다. 이것은 &lt;code&gt;register(fd, eventmask)&lt;/code&gt; 와 동일한 효과를 갖습니다 . 등록되지 않은 파일 디스크립터를 수정하려고하면 errno &lt;code&gt;ENOENT&lt;/code&gt; 와 함께 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6cc4f46aa243a25741c6b3f64809ea24113b97cc" translate="yes" xml:space="preserve">
          <source>Modifies the message and/or keyword arguments passed to a logging call in order to insert contextual information. This implementation takes the object passed as &lt;em&gt;extra&lt;/em&gt; to the constructor and adds it to &lt;em&gt;kwargs&lt;/em&gt; using key &amp;lsquo;extra&amp;rsquo;. The return value is a (&lt;em&gt;msg&lt;/em&gt;, &lt;em&gt;kwargs&lt;/em&gt;) tuple which has the (possibly modified) versions of the arguments passed in.</source>
          <target state="translated">컨텍스트 정보를 삽입하기 위해 로깅 호출에 전달 된 메시지 및 / 또는 키워드 인수를 수정합니다. 이 구현은 생성자에 &lt;em&gt;추가&lt;/em&gt; 로 전달 된 객체를 가져 와서 키 'extra'를 사용하여 &lt;em&gt;kwargs에&lt;/em&gt; 추가합니다 . 리턴 값은 ( &lt;em&gt;msg&lt;/em&gt; , &lt;em&gt;kwargs&lt;/em&gt; ) 튜플이며, 전달 된 인수의 버전이 수정되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32de46524638c4aca576e999a7d9c22055939413" translate="yes" xml:space="preserve">
          <source>Modify a registered file descriptor.</source>
          <target state="translated">등록 된 파일 디스크립터를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="4578c669df0697b22dfd8c519fd4e58ce7cdd60a" translate="yes" xml:space="preserve">
          <source>Modify or inquire widget state. If &lt;em&gt;statespec&lt;/em&gt; is specified, sets the widget state according to it and return a new &lt;em&gt;statespec&lt;/em&gt; indicating which flags were changed. If &lt;em&gt;statespec&lt;/em&gt; is not specified, returns the currently-enabled state flags.</source>
          <target state="translated">위젯 상태를 수정하거나 문의하십시오. 경우 &lt;em&gt;statespec는&lt;/em&gt; 지정된 새로운 그것을 반환 따라 위젯의 상태 설정 &lt;em&gt;statespec&lt;/em&gt; 플래그가 변경되었던 나타낸다. 경우 &lt;em&gt;statespec가&lt;/em&gt; 지정되지 않은, 현재 활성화 상태 플래그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e86176ca1442040dd82f620317ec50cbc92d6c8" translate="yes" xml:space="preserve">
          <source>Modify the filename of a log file when rotating.</source>
          <target state="translated">회전 할 때 로그 파일의 파일 이름을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="bf1c865f30cbb3976816405737bd964fbc2fa0de" translate="yes" xml:space="preserve">
          <source>Modify the view, by calling &lt;code&gt;MsiViewModify()&lt;/code&gt;. &lt;em&gt;kind&lt;/em&gt; can be one of &lt;code&gt;MSIMODIFY_SEEK&lt;/code&gt;, &lt;code&gt;MSIMODIFY_REFRESH&lt;/code&gt;, &lt;code&gt;MSIMODIFY_INSERT&lt;/code&gt;, &lt;code&gt;MSIMODIFY_UPDATE&lt;/code&gt;, &lt;code&gt;MSIMODIFY_ASSIGN&lt;/code&gt;, &lt;code&gt;MSIMODIFY_REPLACE&lt;/code&gt;, &lt;code&gt;MSIMODIFY_MERGE&lt;/code&gt;, &lt;code&gt;MSIMODIFY_DELETE&lt;/code&gt;, &lt;code&gt;MSIMODIFY_INSERT_TEMPORARY&lt;/code&gt;, &lt;code&gt;MSIMODIFY_VALIDATE&lt;/code&gt;, &lt;code&gt;MSIMODIFY_VALIDATE_NEW&lt;/code&gt;, &lt;code&gt;MSIMODIFY_VALIDATE_FIELD&lt;/code&gt;, or &lt;code&gt;MSIMODIFY_VALIDATE_DELETE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MsiViewModify()&lt;/code&gt; 를 호출하여보기를 수정하십시오 . &lt;em&gt;종류&lt;/em&gt; 중 하나가 될 수 있습니다 &lt;code&gt;MSIMODIFY_SEEK&lt;/code&gt; , &lt;code&gt;MSIMODIFY_REFRESH&lt;/code&gt; , &lt;code&gt;MSIMODIFY_INSERT&lt;/code&gt; , &lt;code&gt;MSIMODIFY_UPDATE&lt;/code&gt; , &lt;code&gt;MSIMODIFY_ASSIGN&lt;/code&gt; , &lt;code&gt;MSIMODIFY_REPLACE&lt;/code&gt; , &lt;code&gt;MSIMODIFY_MERGE&lt;/code&gt; , &lt;code&gt;MSIMODIFY_DELETE&lt;/code&gt; , &lt;code&gt;MSIMODIFY_INSERT_TEMPORARY&lt;/code&gt; , &lt;code&gt;MSIMODIFY_VALIDATE&lt;/code&gt; , &lt;code&gt;MSIMODIFY_VALIDATE_NEW&lt;/code&gt; , &lt;code&gt;MSIMODIFY_VALIDATE_FIELD&lt;/code&gt; , 또는 &lt;code&gt;MSIMODIFY_VALIDATE_DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf8f52d6faa8b1275eba9c831dbbef1ed90879cc" translate="yes" xml:space="preserve">
          <source>Modifying an XML File</source>
          <target state="translated">XML 파일 수정</target>
        </trans-unit>
        <trans-unit id="84c3d768a8d5770c62abdea208959d6592bb41c2" translate="yes" xml:space="preserve">
          <source>Modifying this dictionary does not affect the string environment passed on by &lt;a href=&quot;os#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;popen()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;system()&lt;/code&gt;&lt;/a&gt;; if you need to change the environment, pass &lt;code&gt;environ&lt;/code&gt; to &lt;a href=&quot;os#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt; or add variable assignments and export statements to the command string for &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;system()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;popen()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 사전을 수정해도 &lt;a href=&quot;os#os.execv&quot;&gt; &lt;code&gt;execv()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;popen()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;system()&lt;/code&gt; &lt;/a&gt; 전달한 문자열 환경에는 영향을 미치지 않습니다 . 환경을 변경해야하는 경우 &lt;code&gt;environ&lt;/code&gt; 을 &lt;a href=&quot;os#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 전달 하거나 변수 지정 및 export 문을 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;system()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;popen()&lt;/code&gt; &lt;/a&gt; 의 명령 문자열에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="978b5a43a650471c75f8350ef7774ba329f2f3fe" translate="yes" xml:space="preserve">
          <source>Module (name portion of &lt;code&gt;filename&lt;/code&gt;).</source>
          <target state="translated">모듈 ( &lt;code&gt;filename&lt;/code&gt; 이름의 이름 부분 )</target>
        </trans-unit>
        <trans-unit id="b4a2aa27448f7d0da42e7887a48a75e0b25fb6eb" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;#module-aifc&quot;&gt;&lt;code&gt;aifc&lt;/code&gt;&lt;/a&gt; defines the following function:</source>
          <target state="translated">모듈 &lt;a href=&quot;#module-aifc&quot;&gt; &lt;code&gt;aifc&lt;/code&gt; &lt;/a&gt; 는 다음 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2e90a7416ba8632b458a1755a2a52518580a6402" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; This describes how to use .pth files to extend &lt;a href=&quot;#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈 &lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 여기에서는 .pth 파일을 사용하여 &lt;a href=&quot;#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;/a&gt; 를 확장하는 방법에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="7ee83fed2e8bf53e577b314dd959ae5c55d31275" translate="yes" xml:space="preserve">
          <source>Module API</source>
          <target state="translated">모듈 API</target>
        </trans-unit>
        <trans-unit id="9c3f2aba6913de8da00faed8e2df2428bb1257b7" translate="yes" xml:space="preserve">
          <source>Module Attributes</source>
          <target state="translated">모듈 속성</target>
        </trans-unit>
        <trans-unit id="d4c1069b1d33fd7a5bbcf140560e3a8a4cc1d1fd" translate="yes" xml:space="preserve">
          <source>Module Contents</source>
          <target state="translated">모듈 내용</target>
        </trans-unit>
        <trans-unit id="6395f8327bd07812babbe38b248c6564d3e3499a" translate="yes" xml:space="preserve">
          <source>Module Functions</source>
          <target state="translated">모듈 기능</target>
        </trans-unit>
        <trans-unit id="34bdda02dde5bc12bbc7235959c04177e16c821e" translate="yes" xml:space="preserve">
          <source>Module Interface</source>
          <target state="translated">모듈 인터페이스</target>
        </trans-unit>
        <trans-unit id="92fdd8d530e964e456294b900fa883ff826caa46" translate="yes" xml:space="preserve">
          <source>Module and package deprecation messages are suppressed during this import if &lt;em&gt;deprecated&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">경우 모듈 및 패키지 중단 메시지는이 가져 오는 동안 억제 &lt;em&gt;되지 않는&lt;/em&gt; 것입니다 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37e90fc9b9d2ea5592629e3ac0763109ff09df33" translate="yes" xml:space="preserve">
          <source>Module and package deprecation messages are suppressed during this import if &lt;em&gt;deprecated&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;. If a module is required on a platform but optional for others, set &lt;em&gt;required_on&lt;/em&gt; to an iterable of platform prefixes which will be compared against &lt;a href=&quot;sys#sys.platform&quot;&gt;&lt;code&gt;sys.platform&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 모듈 및 패키지 중단 메시지는이 가져 오는 동안 억제 &lt;em&gt;되지 않는&lt;/em&gt; 것입니다 &lt;code&gt;True&lt;/code&gt; . 플랫폼에서 모듈이 필요하지만 다른 모듈에서는 옵션 인 경우 &lt;em&gt;required_on&lt;/em&gt; 을 반복 가능한 플랫폼 접두어로 설정 하여 &lt;a href=&quot;sys#sys.platform&quot;&gt; &lt;code&gt;sys.platform&lt;/code&gt; &lt;/a&gt; 과 비교 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fb52752185bff1afa3095dd1ee054b10a8741dd" translate="yes" xml:space="preserve">
          <source>Module contents</source>
          <target state="translated">모듈 내용</target>
        </trans-unit>
        <trans-unit id="92e9d0a965eb0a3f69212e87aeb376c3817bace5" translate="yes" xml:space="preserve">
          <source>Module docs for core modules are assumed to reside in &lt;code&gt;https://docs.python.org/X.Y/library/&lt;/code&gt; where &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; are the major and minor version numbers of the Python interpreter. This can be overridden by setting the &lt;code id=&quot;index-2&quot;&gt;PYTHONDOCS&lt;/code&gt; environment variable to a different URL or to a local directory containing the Library Reference Manual pages.</source>
          <target state="translated">핵심 모듈에 대한 모듈 문서는 &lt;code&gt;https://docs.python.org/X.Y/library/&lt;/code&gt; 에 상주한다고 가정합니다. 여기서 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;Y&lt;/code&gt; 는 Python 인터프리터의 주 버전 및 부 버전 번호입니다. &lt;code id=&quot;index-2&quot;&gt;PYTHONDOCS&lt;/code&gt; 환경 변수를 다른 URL 또는 라이브러리 참조 매뉴얼 페이지를 포함하는 로컬 디렉토리 로 설정하여 이를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ef1dd98e4cfd7a9708f2569eff22f5637fb8bc6" translate="yes" xml:space="preserve">
          <source>Module functions and constants</source>
          <target state="translated">모듈 함수와 상수</target>
        </trans-unit>
        <trans-unit id="9ef7884387f3e4f0b36275d92cdf793323d304a1" translate="yes" xml:space="preserve">
          <source>Module which provides function to parse and escape command lines.</source>
          <target state="translated">명령 줄을 구문 분석하고 이스케이프하는 기능을 제공하는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="c383a8897cd1716700d1c6ce4d55ad2fcebbab29" translate="yes" xml:space="preserve">
          <source>Module-Level Attributes</source>
          <target state="translated">모듈 레벨 속성</target>
        </trans-unit>
        <trans-unit id="f6833370d46becabc41cf08b0e482dee5c655b31" translate="yes" xml:space="preserve">
          <source>Module-Level Functions</source>
          <target state="translated">모듈 수준 기능</target>
        </trans-unit>
        <trans-unit id="72f4be7481838d35b49b8de2e9a7fee6249d8e61" translate="yes" xml:space="preserve">
          <source>Module-level decorators, classes, and functions</source>
          <target state="translated">모듈 수준 데코레이터, 클래스 및 함수</target>
        </trans-unit>
        <trans-unit id="0912cb95ac0d180a81219825c72ec9eb605ea300" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.application&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.application&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb79c7e1617398068225f2820c0c3459cc440e65" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.audio&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.audio&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94725cd99078c801f5574ad6d6ea78ee9a024ea3" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.base&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.base&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ea4be398009cc8d6de590b862d7f3009c1b810f" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.image&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.image&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93b775199744840d67da16eb9ccb4cd9bbae2050" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.message&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.message&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="441e7562ed5fe7a1630841c1a22bdc73a4f3d757" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.multipart&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.multipart&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d510569ecc8d71a91a86a65c09928a0f4ef8f5d5" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.nonmultipart&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.nonmultipart&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="127f26a281cad66280273f6515132d982225e9cf" translate="yes" xml:space="preserve">
          <source>Module: &lt;code&gt;email.mime.text&lt;/code&gt;</source>
          <target state="translated">모듈 : &lt;code&gt;email.mime.text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dc7c7ee2e220614ae05c4256b05b12812ad8cf9" translate="yes" xml:space="preserve">
          <source>ModuleNotFoundError</source>
          <target state="translated">ModuleNotFoundError</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="e118e0912a01f24a429ac2012ae97cc544249d59" translate="yes" xml:space="preserve">
          <source>Modules built into the interpreter are written like this: &lt;code&gt;&amp;lt;module 'sys'
(built-in)&amp;gt;&lt;/code&gt;. If loaded from a file, they are written as &lt;code&gt;&amp;lt;module 'os' from
'/usr/local/lib/pythonX.Y/os.pyc'&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">인터프리터에 내장 된 모듈은 다음과 같이 작성됩니다 : &lt;code&gt;&amp;lt;module 'sys' (built-in)&amp;gt;&lt;/code&gt; . 파일에서로드 된 경우 &lt;code&gt;&amp;lt;module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'&amp;gt;&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1911b7883b819819b6db37c8e8e2824d20e1cc32" translate="yes" xml:space="preserve">
          <source>Modules or packages can customize how tests are loaded from them during normal test runs or test discovery by implementing a function called &lt;code&gt;load_tests&lt;/code&gt;.</source>
          <target state="translated">모듈 또는 패키지는 &lt;code&gt;load_tests&lt;/code&gt; 라는 기능을 구현하여 일반 테스트 실행 또는 테스트 검색 중에 테스트가로드되는 방식을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87a40520b4026078c79efca77f06437b79124739" translate="yes" xml:space="preserve">
          <source>Modulo</source>
          <target state="translated">Modulo</target>
        </trans-unit>
        <trans-unit id="5d0d78dc5224fd4f6862f5f7a9fb54a486fd390b" translate="yes" xml:space="preserve">
          <source>Monitor for completion with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 로 완료를 모니터하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed5abdf1184868f05915cfc662a0097b73af5db0" translate="yes" xml:space="preserve">
          <source>Monitor for completion.</source>
          <target state="translated">완료를 모니터링하십시오.</target>
        </trans-unit>
        <trans-unit id="496c793822576e70e527412a984554382d2aebe7" translate="yes" xml:space="preserve">
          <source>Month (one-based)</source>
          <target state="translated">월 (1 개 기준)</target>
        </trans-unit>
        <trans-unit id="742b33d400ddeeabce686bc1c2413ddb0c448e2a" translate="yes" xml:space="preserve">
          <source>Month as a decimal number [01,12].</source>
          <target state="translated">십진수로 된 월 [01,12].</target>
        </trans-unit>
        <trans-unit id="f2ebd646406d99068e09d2f4e14fbbffed228a7d" translate="yes" xml:space="preserve">
          <source>Month as a zero-padded decimal number.</source>
          <target state="translated">0으로 채워진 10 진수로 된 월입니다.</target>
        </trans-unit>
        <trans-unit id="4b69dcb0d93760210c273e2a1abcde796903be87" translate="yes" xml:space="preserve">
          <source>Month as locale&amp;rsquo;s abbreviated name.</source>
          <target state="translated">로캘의 약식 이름 인 월입니다.</target>
        </trans-unit>
        <trans-unit id="fea5423e8f5a25290885c0d0e12a775f3fd61281" translate="yes" xml:space="preserve">
          <source>Month as locale&amp;rsquo;s full name.</source>
          <target state="translated">로캘의 전체 이름으로 된 월입니다.</target>
        </trans-unit>
        <trans-unit id="e202399e2af6ae3d8e2fdbf89c95c2518eee70d8" translate="yes" xml:space="preserve">
          <source>More advanced customization may be achieved by overriding default values of these parser attributes. The defaults are defined on the classes, so they may be overridden by subclasses or by attribute assignment.</source>
          <target state="translated">이러한 파서 속성의 기본값을 재정 의하여 고급 사용자 지정을 수행 할 수 있습니다. 디폴트는 클래스에서 정의되므로 서브 클래스 또는 속성 지정으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f2ac8fa6191d0a7752f0403130e23050b322b6" translate="yes" xml:space="preserve">
          <source>More complex argument matching</source>
          <target state="translated">더 복잡한 인수 일치</target>
        </trans-unit>
        <trans-unit id="a4edbe5aa58310b4837dc402b6725527f1000abe" translate="yes" xml:space="preserve">
          <source>More condensed:</source>
          <target state="translated">더 응축 :</target>
        </trans-unit>
        <trans-unit id="af27293770923a34ccc5524c23d8989922e0488b" translate="yes" xml:space="preserve">
          <source>More details of &lt;code&gt;hexversion&lt;/code&gt; can be found at &lt;a href=&quot;https://docs.python.org/3.8/c-api/apiabiversion.html#apiabiversion&quot;&gt;API and ABI Versioning&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hexversion&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/c-api/apiabiversion.html#apiabiversion&quot;&gt;API 및 ABI Versioning&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35c58ae0fd8a7e1329fa05386d5d2de6a083afbd" translate="yes" xml:space="preserve">
          <source>More drawing control</source>
          <target state="translated">더 많은 도면 제어</target>
        </trans-unit>
        <trans-unit id="f73f1a20168b82e8d86b3b46baab234a74659e99" translate="yes" xml:space="preserve">
          <source>More examples of working with &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 작업의 더 많은 예 :</target>
        </trans-unit>
        <trans-unit id="bda595d7c3822cdddfd4e7f95e4ba1fe77eef18d" translate="yes" xml:space="preserve">
          <source>More information about color spaces can be found at &lt;a href=&quot;http://poynton.ca/ColorFAQ.html&quot;&gt;http://poynton.ca/ColorFAQ.html&lt;/a&gt; and &lt;a href=&quot;https://www.cambridgeincolour.com/tutorials/color-spaces.htm&quot;&gt;https://www.cambridgeincolour.com/tutorials/color-spaces.htm&lt;/a&gt;.</source>
          <target state="translated">색 공간에 대한 자세한 내용은 &lt;a href=&quot;http://poynton.ca/ColorFAQ.html&quot;&gt;http://poynton.ca/ColorFAQ.html&lt;/a&gt; 및 &lt;a href=&quot;https://www.cambridgeincolour.com/tutorials/color-spaces.htm&quot;&gt;https://www.cambridgeincolour.com/tutorials/color-spaces.htm&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cf8e91c8e08ed18b8e45a5ac7ba72687719075d" translate="yes" xml:space="preserve">
          <source>More information about this feature, including a list of recognized options, can be found in the &lt;a href=&quot;https://www.sqlite.org/uri.html&quot;&gt;SQLite URI documentation&lt;/a&gt;.</source>
          <target state="translated">인식 된 옵션 목록을 포함하여이 기능에 대한 자세한 정보는 &lt;a href=&quot;https://www.sqlite.org/uri.html&quot;&gt;SQLite URI 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f7f884738e96b308c393050b48c8b8755a6d24c" translate="yes" xml:space="preserve">
          <source>More object-oriented interface to dates and times.</source>
          <target state="translated">날짜와 시간에 대한 객체 지향 인터페이스.</target>
        </trans-unit>
        <trans-unit id="b4302b5e109b770c6a0ea76fbd2882a8bc6db8b6" translate="yes" xml:space="preserve">
          <source>More picklability</source>
          <target state="translated">더 많은 피클 가능성</target>
        </trans-unit>
        <trans-unit id="0d62cf081bc641ff89c8b59069e0d5d811e8757a" translate="yes" xml:space="preserve">
          <source>More precisely, if &lt;code&gt;x&lt;/code&gt; is nonzero, then &lt;code&gt;x.bit_length()&lt;/code&gt; is the unique positive integer &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;2**(k-1) &amp;lt;= abs(x) &amp;lt; 2**k&lt;/code&gt;. Equivalently, when &lt;code&gt;abs(x)&lt;/code&gt; is small enough to have a correctly rounded logarithm, then &lt;code&gt;k = 1 + int(log(abs(x), 2))&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is zero, then &lt;code&gt;x.bit_length()&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우보다 정확하게 &lt;code&gt;x&lt;/code&gt; 는 제로가 아닌, 다음 &lt;code&gt;x.bit_length()&lt;/code&gt; 고유 한 양의 정수이고 &lt;code&gt;k&lt;/code&gt; 되도록 &lt;code&gt;2**(k-1) &amp;lt;= abs(x) &amp;lt; 2**k&lt;/code&gt; . 마찬가지로 &lt;code&gt;abs(x)&lt;/code&gt; 가 올바르게 반올림 된 로그를 갖기에 충분히 작은 경우 &lt;code&gt;k = 1 + int(log(abs(x), 2))&lt;/code&gt; 입니다. 경우 &lt;code&gt;x&lt;/code&gt; 는 제로, 다음 &lt;code&gt;x.bit_length()&lt;/code&gt; 반환 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ced1f1a5abe7721a13a8ffbf16d63ff492b8f140" translate="yes" xml:space="preserve">
          <source>More precisely, the expression &lt;code&gt;some_value is Derived(some_value)&lt;/code&gt; is always true at runtime.</source>
          <target state="translated">보다 정확하게 표현하면 &lt;code&gt;some_value is Derived(some_value)&lt;/code&gt; 표현식 은 런타임시 항상 참입니다.</target>
        </trans-unit>
        <trans-unit id="afcfcf646cf0d59e75aa3efa0a7dca7907775b81" translate="yes" xml:space="preserve">
          <source>More sophisticated context managers may be &amp;ldquo;reentrant&amp;rdquo;. These context managers can not only be used in multiple &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements, but may also be used &lt;em&gt;inside&lt;/em&gt; a &lt;code&gt;with&lt;/code&gt; statement that is already using the same context manager.</source>
          <target state="translated">보다 정교한 컨텍스트 관리자는&amp;ldquo;재진입&amp;rdquo;할 수 있습니다. 이 컨텍스트 관리자는 여러 사용할 수 없습니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문장뿐만 아니라 사용될 수있는 &lt;em&gt;내부 &lt;/em&gt; &lt;code&gt;with&lt;/code&gt; 이미 같은 컨텍스트 관리자를 사용하는 문.</target>
        </trans-unit>
        <trans-unit id="bec52d0bf3df1fe2b7028c4e46728b05b6585a7b" translate="yes" xml:space="preserve">
          <source>More sophisticated specification of which elements to look for is possible by using &lt;a href=&quot;#elementtree-xpath&quot;&gt;XPath&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#elementtree-xpath&quot;&gt;XPath&lt;/a&gt; 를 사용하면 찾을 요소를보다 정교하게 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44cce591f12835a93d72e2725773defea428923d" translate="yes" xml:space="preserve">
          <source>Moreover, by subclassing a special class &lt;a href=&quot;#typing.Protocol&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt;, a user can define new custom protocols to fully enjoy structural subtyping (see examples below).</source>
          <target state="translated">또한 특수 클래스 &lt;a href=&quot;#typing.Protocol&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt; 을 서브 클래 싱함으로써 사용자는 구조적 서브 타이핑을 완전히 즐길 수 있도록 새로운 사용자 정의 프로토콜을 정의 할 수 있습니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="c7c6427f00dc397938f8e9415a2f590774699402" translate="yes" xml:space="preserve">
          <source>Moreover, if you output the 0&amp;rsquo;th item on disk and get an input which may not fit in the current tournament (because the value &amp;ldquo;wins&amp;rdquo; over the last output value), it cannot fit in the heap, so the size of the heap decreases. The freed memory could be cleverly reused immediately for progressively building a second heap, which grows at exactly the same rate the first heap is melting. When the first heap completely vanishes, you switch heaps and start a new run. Clever and quite effective!</source>
          <target state="translated">또한 디스크에 0 번째 항목을 출력하고 현재 토너먼트에 맞지 않을 수있는 입력을 받으면 (마지막 출력 값보다 &quot;승리&quot;하므로) 힙에 맞지 않을 수 있습니다. 힙이 줄어 듭니다. 해제 된 메모리는 두 번째 힙을 점진적으로 구축하기 위해 즉시 영리하게 재사용 할 수 있으며, 첫 번째 힙이 녹는 것과 정확히 같은 속도로 증가합니다. 첫 번째 힙이 완전히 사라지면 힙을 전환하고 새 실행을 시작합니다. 영리하고 매우 효과적입니다!</target>
        </trans-unit>
        <trans-unit id="223a97db4a13581b9f40926ba9bf06631a533426" translate="yes" xml:space="preserve">
          <source>Morsel Objects</source>
          <target state="translated">모셀 개체</target>
        </trans-unit>
        <trans-unit id="aab9d541f9999319a8925c74373dfaf9120edff4" translate="yes" xml:space="preserve">
          <source>Morsels are dictionary-like objects, whose set of keys is constant &amp;mdash; the valid &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; attributes, which are</source>
          <target state="translated">모셀은 사전과 유사한 객체로, 키 세트가 일정한 유효한 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="12e365ba43d20a735f475457d6d67ad170f2ddc0" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; actions add some value as an attribute of the object returned by &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt;. The name of this attribute is determined by the &lt;code&gt;dest&lt;/code&gt; keyword argument of &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt;. For positional argument actions, &lt;code&gt;dest&lt;/code&gt; is normally supplied as the first argument to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대부분의 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 작업은 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 반환 한 객체의 속성으로 일부 값을 추가 합니다. 이 속성의 이름은 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;dest&lt;/code&gt; 키워드 인수에 의해 결정됩니다 . 위치 인수 작업의 경우 일반적으로 &lt;code&gt;dest&lt;/code&gt; 는 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b8a1ba8e18b5f5019a5d4312dc314b8b2c9954f" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclasses should be able to inherit the default &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt;&lt;code&gt;fromutc()&lt;/code&gt;&lt;/a&gt; implementation without problems. It&amp;rsquo;s strong enough to handle fixed-offset time zones, and time zones accounting for both standard and daylight time, and the latter even if the DST transition times differ in different years. An example of a time zone the default &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt;&lt;code&gt;fromutc()&lt;/code&gt;&lt;/a&gt; implementation may not handle correctly in all cases is one where the standard offset (from UTC) depends on the specific date and time passed, which can happen for political reasons. The default implementations of &lt;code&gt;astimezone()&lt;/code&gt; and &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt;&lt;code&gt;fromutc()&lt;/code&gt;&lt;/a&gt; may not produce the result you want if the result is one of the hours straddling the moment the standard offset changes.</source>
          <target state="translated">대부분의 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스는 기본 &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt; &lt;code&gt;fromutc()&lt;/code&gt; &lt;/a&gt; 구현을 문제없이 상속 할 수 있어야합니다 . 고정 오프셋 표준 시간대와 표준 시간대 및 일광 절약 시간을 모두 고려한 표준 시간대와 DST 전환 시간이 서로 다른 연도를 다룰 수있는 표준 시간대를 처리 할 수있을 정도로 강력합니다. 표준 &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt; &lt;code&gt;fromutc()&lt;/code&gt; &lt;/a&gt; 구현이 모든 경우에 올바르게 처리되지 않을 수있는 시간대의 예는 UTC로부터의 표준 오프셋이 전달 된 특정 날짜 및 시간에 따라 달라지는 정치적 예입니다. 표준 오프셋이 변경되는 순간에 결과가 시간 중 하나 인 경우 &lt;code&gt;astimezone()&lt;/code&gt; 및 &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt; &lt;code&gt;fromutc()&lt;/code&gt; &lt;/a&gt; 의 기본 구현으로 원하는 결과를 얻지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa3c05e44820db4266ade0ef0b637c16f15b20d4" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; methods will raise either &lt;a href=&quot;#ssl.SSLWantWriteError&quot;&gt;&lt;code&gt;SSLWantWriteError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt;&lt;code&gt;SSLWantReadError&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; if an I/O operation would block. &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt;&lt;code&gt;SSLWantReadError&lt;/code&gt;&lt;/a&gt; will be raised if a read operation on the underlying socket is necessary, and &lt;a href=&quot;#ssl.SSLWantWriteError&quot;&gt;&lt;code&gt;SSLWantWriteError&lt;/code&gt;&lt;/a&gt; for a write operation on the underlying socket. Note that attempts to &lt;em&gt;write&lt;/em&gt; to an SSL socket may require &lt;em&gt;reading&lt;/em&gt; from the underlying socket first, and attempts to &lt;em&gt;read&lt;/em&gt; from the SSL socket may require a prior &lt;em&gt;write&lt;/em&gt; to the underlying socket.</source>
          <target state="translated">I / O 작업이 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 되면 대부분의 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 메소드는 BlockingIOError 대신 &lt;a href=&quot;#ssl.SSLWantWriteError&quot;&gt; &lt;code&gt;SSLWantWriteError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt; &lt;code&gt;SSLWantReadError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . 기본 소켓에서 읽기 작업이 필요한 경우 &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt; &lt;code&gt;SSLWantReadError&lt;/code&gt; &lt;/a&gt; 가 발생하고 기본 소켓 에서 쓰기 작업을하려면 &lt;a href=&quot;#ssl.SSLWantWriteError&quot;&gt; &lt;code&gt;SSLWantWriteError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 시도 할 수 있습니다 &lt;em&gt;쓸&lt;/em&gt; 필요 수있는 SSL 소켓에 &lt;em&gt;읽기&lt;/em&gt; 먼저 기본 소켓에서, 그리고 시도하는 &lt;em&gt;읽기&lt;/em&gt; 이전이 필요할 수 있습니다 SSL 소켓에서 &lt;em&gt;쓰기&lt;/em&gt; 기본 소켓을.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd522bac8b9e11ce49eeb2583e8f07839a03488c" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;asyncio#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; scheduling functions don&amp;rsquo;t allow passing keyword arguments. To do that, use &lt;a href=&quot;functools#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대부분의 &lt;a href=&quot;asyncio#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 예약 기능은 키워드 인수 전달을 허용하지 않습니다. 그렇게하려면 &lt;a href=&quot;functools#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd51bb63feffbfa7148f18472384cc0b94c13ee7" translate="yes" xml:space="preserve">
          <source>Most HTTP servers buffer the output from CGI scripts until the script is completed. This means that it is not possible to display a progress report on the client&amp;rsquo;s display while the script is running.</source>
          <target state="translated">대부분의 HTTP 서버는 스크립트가 완료 될 때까지 CGI 스크립트의 출력을 버퍼링합니다. 이는 스크립트가 실행되는 동안 클라이언트의 디스플레이에 진행률 보고서를 표시 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="89262a759f5c4450ccbba1d7e972a20eb9d6f62d" translate="yes" xml:space="preserve">
          <source>Most Python users will &lt;em&gt;not&lt;/em&gt; want to use this module directly, but instead use the cross-version tools maintained by the Python Packaging Authority. In particular, &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/&quot;&gt;setuptools&lt;/a&gt; is an enhanced alternative to &lt;a href=&quot;#module-distutils&quot;&gt;&lt;code&gt;distutils&lt;/code&gt;&lt;/a&gt; that provides:</source>
          <target state="translated">대부분의 파이썬 사용자는 것입니다 &lt;em&gt;하지&lt;/em&gt; 직접 모듈을 사용하지만, 대신 파이썬 포장 당국에 의해 유지되는 버전 간 도구를 사용하려고합니다. 특히 &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/&quot;&gt;setuptools&lt;/a&gt; 는 다음을 제공 하는 &lt;a href=&quot;#module-distutils&quot;&gt; &lt;code&gt;distutils&lt;/code&gt; &lt;/a&gt; 의 향상된 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="b4ff9c4f943c838658554972d2715c1911832530" translate="yes" xml:space="preserve">
          <source>Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types.</source>
          <target state="translated">대부분의 내장 유형은 형식 스펙에 대해 다음 옵션을 구현하지만 일부 형식 옵션은 숫자 유형에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4671a5faa2bb50d6521e2b74a0ac603b3e8ea2c0" translate="yes" xml:space="preserve">
          <source>Most built-in types support a common formatting mini-language, which is described in the next section.</source>
          <target state="translated">대부분의 기본 제공 형식은 다음 섹션에서 설명하는 공통 서식 미니 언어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9f333f2038f1ecde46179e5361647a36ea955c1a" translate="yes" xml:space="preserve">
          <source>Most calls to the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; constructor will use the &lt;code&gt;description=&lt;/code&gt; keyword argument. This argument gives a brief description of what the program does and how it works. In help messages, the description is displayed between the command-line usage string and the help messages for the various arguments:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 생성자 에 대한 대부분의 호출 은 &lt;code&gt;description=&lt;/code&gt; 키워드 인수를 사용합니다 . 이 인수는 프로그램의 기능과 작동 방식에 대한 간략한 설명을 제공합니다. 도움말 메시지에서 명령 행 사용법 문자열과 다양한 인수에 대한 도움말 메시지 사이에 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d721b333c77edec8818b7d94960eeed847aceea5" translate="yes" xml:space="preserve">
          <source>Most command-line options will use &lt;code&gt;-&lt;/code&gt; as the prefix, e.g. &lt;code&gt;-f/--foo&lt;/code&gt;. Parsers that need to support different or additional prefix characters, e.g. for options like &lt;code&gt;+f&lt;/code&gt; or &lt;code&gt;/foo&lt;/code&gt;, may specify them using the &lt;code&gt;prefix_chars=&lt;/code&gt; argument to the ArgumentParser constructor:</source>
          <target state="translated">대부분의 명령 줄 옵션을 사용합니다 &lt;code&gt;-&lt;/code&gt; 접두사, 예를 들어 같은 &lt;code&gt;-f/--foo&lt;/code&gt; . &lt;code&gt;+f&lt;/code&gt; 또는 &lt;code&gt;/foo&lt;/code&gt; 와 같은 옵션과 같이 다른 또는 추가 접두사 문자를 지원해야하는 파서 는 ArgumentParser 생성자에 &lt;code&gt;prefix_chars=&lt;/code&gt; 인수를 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c59d2f4304b47bbe5f9025fc2719f37eb21fc59" translate="yes" xml:space="preserve">
          <source>Most commands are available as &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;tkinter.ttk#module-tkinter.ttk&quot;&gt;&lt;code&gt;tkinter.ttk&lt;/code&gt;&lt;/a&gt; classes. Change &amp;lsquo;8.6&amp;rsquo; to match the version of your Tcl/Tk installation.</source>
          <target state="translated">대부분의 명령은 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;tkinter.ttk#module-tkinter.ttk&quot;&gt; &lt;code&gt;tkinter.ttk&lt;/code&gt; &lt;/a&gt; 클래스 로 사용 가능 합니다. Tcl / Tk 설치 버전과 일치하도록 '8.6'을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="09e1be6a3a08fdd80447facaa6e35fc4dcf067a7" translate="yes" xml:space="preserve">
          <source>Most configuration options apply to all windows or all future windows. The option items below only apply to the active window.</source>
          <target state="translated">대부분의 구성 옵션은 모든 창 또는 모든 미래 창에 적용됩니다. 아래의 옵션 항목은 활성 창에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d738b94492588389087414a01d9272752be1e6c" translate="yes" xml:space="preserve">
          <source>Most context managers are written in a way that means they can only be used effectively in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement once. These single use context managers must be created afresh each time they&amp;rsquo;re used - attempting to use them a second time will trigger an exception or otherwise not work correctly.</source>
          <target state="translated">대부분의 컨텍스트 관리자는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에서 한 번만 효과적으로 사용할 수 있다는 의미로 작성되었습니다 . 이 단일 사용 컨텍스트 관리자는 사용될 때마다 새로 작성해야합니다. 두 번째로 사용하려고하면 예외가 발생하거나 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="acd4fa21da07450f40a52f6949201b55436a1a6a" translate="yes" xml:space="preserve">
          <source>Most implementations of &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt;&lt;code&gt;dst()&lt;/code&gt;&lt;/a&gt; will probably look like one of these two:</source>
          <target state="translated">대부분의 &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt; &lt;code&gt;dst()&lt;/code&gt; &lt;/a&gt; 구현은 다음 두 가지 중 하나와 비슷할 것입니다.</target>
        </trans-unit>
        <trans-unit id="aea2023d714ec31a854470fd3ecf8d9355c053c4" translate="yes" xml:space="preserve">
          <source>Most importantly, a good understanding of the Python grammar processed by the internal parser is required. For full information on the language syntax, refer to &lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;The Python Language Reference&lt;/a&gt;. The parser itself is created from a grammar specification defined in the file &lt;code&gt;Grammar/Grammar&lt;/code&gt; in the standard Python distribution. The parse trees stored in the ST objects created by this module are the actual output from the internal parser when created by the &lt;a href=&quot;#parser.expr&quot;&gt;&lt;code&gt;expr()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#parser.suite&quot;&gt;&lt;code&gt;suite()&lt;/code&gt;&lt;/a&gt; functions, described below. The ST objects created by &lt;a href=&quot;#parser.sequence2st&quot;&gt;&lt;code&gt;sequence2st()&lt;/code&gt;&lt;/a&gt; faithfully simulate those structures. Be aware that the values of the sequences which are considered &amp;ldquo;correct&amp;rdquo; will vary from one version of Python to another as the formal grammar for the language is revised. However, transporting code from one Python version to another as source text will always allow correct parse trees to be created in the target version, with the only restriction being that migrating to an older version of the interpreter will not support more recent language constructs. The parse trees are not typically compatible from one version to another, though source code has usually been forward-compatible within a major release series.</source>
          <target state="translated">가장 중요한 것은 내부 파서가 처리하는 파이썬 문법을 잘 이해해야한다는 것입니다. 언어 구문에 대한 자세한 내용 &lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;은 Python 언어 참조를 참조하십시오&lt;/a&gt; . 파서 자체는 표준 Python 배포판의 &lt;code&gt;Grammar/Grammar&lt;/code&gt; 파일에 정의 된 문법 사양에서 생성됩니다 . 이 모듈로 작성된 ST 오브젝트에 저장된 구문 분석 트리는 아래 설명 된 &lt;a href=&quot;#parser.expr&quot;&gt; &lt;code&gt;expr()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#parser.suite&quot;&gt; &lt;code&gt;suite()&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성 될 때 내부 구문 분석기의 실제 출력입니다 . &lt;a href=&quot;#parser.sequence2st&quot;&gt; &lt;code&gt;sequence2st()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 ST 객체이러한 구조를 충실히 시뮬레이션합니다. &quot;정확한&quot;것으로 간주되는 시퀀스의 값은 언어의 공식 문법이 개정 될 때 파이썬 버전마다 다를 수 있습니다. 그러나 소스 텍스트로 한 Python 버전에서 다른 Python 버전으로 코드를 전송하면 항상 대상 버전에서 올바른 구문 분석 트리를 만들 수 있으며, 이전 버전의 인터프리터로 마이그레이션하면 최신 언어 구문이 지원되지 않습니다. 파싱 ​​트리는 일반적으로 한 버전에서 다른 버전으로 호환되지 않지만 소스 코드는 일반적으로 주요 릴리스 시리즈에서 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="91b41d0992c76daa7e6ce1cb34f492287f10c4f0" translate="yes" xml:space="preserve">
          <source>Most locales do not define this value. An example of a locale which does define this value is the Japanese one. In Japan, the traditional representation of dates includes the name of the era corresponding to the then-emperor&amp;rsquo;s reign.</source>
          <target state="translated">대부분의 로캘은이 값을 정의하지 않습니다. 이 값을 정의하는 로케일의 예는 일본어입니다. 일본에서 전통적인 날짜 표시에는 당시 황제의 통치에 해당하는 시대의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7e2559cd2f7c66c93f9db240a7fc5efb17e9d6cc" translate="yes" xml:space="preserve">
          <source>Most messages with a content type of &lt;em&gt;message/*&lt;/em&gt; (such as &lt;em&gt;message/delivery-status&lt;/em&gt; and &lt;em&gt;message/rfc822&lt;/em&gt;) will also be parsed as container object containing a list payload of length 1. Their &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; method will return &lt;code&gt;True&lt;/code&gt;. The single element yielded by &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt;&lt;code&gt;iter_parts()&lt;/code&gt;&lt;/a&gt; will be a sub-message object.</source>
          <target state="translated">내용 유형이 &lt;em&gt;message / *&lt;/em&gt; 인 &lt;em&gt;메시지&lt;/em&gt; (예 : &lt;em&gt;message / delivery-status&lt;/em&gt; 및 &lt;em&gt;message / rfc822&lt;/em&gt; )는 대부분 길이 1의 목록 페이로드를 포함하는 컨테이너 객체로 구문 분석됩니다. &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다. &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt; &lt;code&gt;iter_parts()&lt;/code&gt; &lt;/a&gt; 의해 생성 된 단일 요소는 하위 메시지 개체가됩니다.</target>
        </trans-unit>
        <trans-unit id="0bbab5f6cfbae51ba73420b5d82749fd2992f95e" translate="yes" xml:space="preserve">
          <source>Most non-&lt;em&gt;multipart&lt;/em&gt; type messages are parsed as a single message object with a string payload. These objects will return &lt;code&gt;False&lt;/code&gt; for &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt;&lt;code&gt;iter_parts()&lt;/code&gt;&lt;/a&gt; will yield an empty list.</source>
          <target state="translated">&lt;em&gt;멀티 파트가&lt;/em&gt; 아닌 유형의 메시지는 대부분 문자열 페이로드가있는 단일 메시지 객체로 구문 분석됩니다. 이 객체는 &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; 대해 &lt;code&gt;False&lt;/code&gt; 를 반환 하고 &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt; &lt;code&gt;iter_parts()&lt;/code&gt; &lt;/a&gt; 는 빈 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c2841625ce82d29906f55ae50358119d7bcc13ad" translate="yes" xml:space="preserve">
          <source>Most of connection oriented event loop methods (such as &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt;) usually accept a &lt;em&gt;protocol_factory&lt;/em&gt; argument used to create a &lt;em&gt;Protocol&lt;/em&gt; object for an accepted connection, represented by a &lt;em&gt;Transport&lt;/em&gt; object. Such methods usually return a tuple of &lt;code&gt;(transport, protocol)&lt;/code&gt;.</source>
          <target state="translated">대부분의 연결 지향 이벤트 루프 메소드 (예 : &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; )는 일반적으로 &lt;em&gt;전송&lt;/em&gt; 오브젝트로 표시되는 승인 된 연결에 대한 &lt;em&gt;Protocol&lt;/em&gt; 오브젝트 를 작성하는 데 사용되는 &lt;em&gt;protocol_factory&lt;/em&gt; 인수를 승인 합니다. 이러한 메소드는 일반적으로 &lt;code&gt;(transport, protocol)&lt;/code&gt; 의 튜플을 리턴합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81f7d7d5c7660933a30dd70b5115a9493350bf31" translate="yes" xml:space="preserve">
          <source>Most of the examples in this section refer to a Turtle instance called &lt;code&gt;turtle&lt;/code&gt;.</source>
          <target state="translated">이 섹션의 예제는 대부분 &lt;code&gt;turtle&lt;/code&gt; 이라는 Turtle 인스턴스를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="00f06901ce4c8554bb321be3baaa0d6f5ae7c8b3" translate="yes" xml:space="preserve">
          <source>Most of the examples in this section refer to a TurtleScreen instance called &lt;code&gt;screen&lt;/code&gt;.</source>
          <target state="translated">이 섹션의 대부분의 예제는 &lt;code&gt;screen&lt;/code&gt; 이라는 TurtleScreen 인스턴스를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="6a2fb976c0f061ef5f5627769d911fef317c03b7" translate="yes" xml:space="preserve">
          <source>Most of the random module&amp;rsquo;s algorithms and seeding functions are subject to change across Python versions, but two aspects are guaranteed not to change:</source>
          <target state="translated">임의 모듈의 알고리즘과 시딩 함수의 대부분은 Python 버전에서 변경 될 수 있지만 두 가지 측면은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7745b7926e51bd60c61099df7ea2085b449eedf0" translate="yes" xml:space="preserve">
          <source>Most of the standard escapes supported by Python string literals are also accepted by the regular expression parser:</source>
          <target state="translated">파이썬 문자열 리터럴이 지원하는 대부분의 표준 이스케이프는 정규 표현식 파서에서도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="566d54a039879a714c6a3632228f8ac12ebf75df" translate="yes" xml:space="preserve">
          <source>Most of the time, &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; is all you really need, but a number of additional modules are available as well. The Tk interface is located in a binary module named &lt;code&gt;_tkinter&lt;/code&gt;. This module contains the low-level interface to Tk, and should never be used directly by application programmers. It is usually a shared library (or DLL), but might in some cases be statically linked with the Python interpreter.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 가 실제로 필요한 전부이지만 여러 가지 추가 모듈도 사용할 수 있습니다. Tk 인터페이스는 &lt;code&gt;_tkinter&lt;/code&gt; 라는 이진 모듈에 있습니다. 이 모듈에는 Tk에 대한 저수준 인터페이스가 포함되어 있으므로 응용 프로그램 프로그래머가 직접 사용해서는 안됩니다. 일반적으로 공유 라이브러리 (또는 DLL)이지만 일부 경우 Python 인터프리터와 정적으로 링크 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5bad467beb5b7fbd87a238c1288e8d07b19cf1" translate="yes" xml:space="preserve">
          <source>Most of the time, the attributes of the object returned by &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will be fully determined by inspecting the command-line arguments and the argument actions. &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt;&lt;code&gt;set_defaults()&lt;/code&gt;&lt;/a&gt; allows some additional attributes that are determined without any inspection of the command line to be added:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 객체의 속성은 명령 줄 인수와 인수 작업을 검사하여 완전히 결정됩니다. &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt; &lt;code&gt;set_defaults()&lt;/code&gt; &lt;/a&gt; 사용하면 명령 줄을 검사하지 않고 결정된 몇 가지 추가 속성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1089f5c7ed3d0c68bfe01bebe0674b2ea0fa5e89" translate="yes" xml:space="preserve">
          <source>Most of these reflect information in the XML document that is not of general utility to most DOM users.</source>
          <target state="translated">이들 대부분은 대부분의 DOM 사용자에게 일반적인 유틸리티가 아닌 XML 문서의 정보를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="13b592a4e1b821b7d19f58aba800d1b83c05c87f" translate="yes" xml:space="preserve">
          <source>Most often, CGI scripts live in the server&amp;rsquo;s special &lt;code&gt;cgi-bin&lt;/code&gt; directory. The HTTP server places all sorts of information about the request (such as the client&amp;rsquo;s hostname, the requested URL, the query string, and lots of other goodies) in the script&amp;rsquo;s shell environment, executes the script, and sends the script&amp;rsquo;s output back to the client.</source>
          <target state="translated">대부분의 경우 CGI 스크립트는 서버의 특수 &lt;code&gt;cgi-bin&lt;/code&gt; 디렉토리에 있습니다. HTTP 서버는 스크립트의 쉘 환경에 요청에 대한 모든 종류의 정보 (예 : 클라이언트의 호스트 이름, 요청 된 URL, 쿼리 문자열 및 기타 많은 것들)를 스크립트의 쉘 환경에 저장하고 스크립트를 실행하며 스크립트의 출력을 고객.</target>
        </trans-unit>
        <trans-unit id="84948582795acb691856110e5ae66ef32acdd219" translate="yes" xml:space="preserve">
          <source>Most parsing functions provided by this module require the whole document to be read at once before returning any result. It is possible to use an &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; and feed data into it incrementally, but it is a push API that calls methods on a callback target, which is too low-level and inconvenient for most needs. Sometimes what the user really wants is to be able to parse XML incrementally, without blocking operations, while enjoying the convenience of fully constructed &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">이 모듈이 제공하는 대부분의 구문 분석 기능은 결과를 리턴하기 전에 전체 문서를 한 번에 읽도록 ​​요구합니다. &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 를 사용하여 점진적으로 데이터를 공급 하는 것이 가능 하지만 콜백 대상에서 메소드를 호출하는 푸시 API로, 대부분의 경우 너무 낮은 수준이며 불편합니다. 때로는 사용자가 실제로 원하는 것은 완전히 구성된 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 객체 의 편리함을 즐기면서 작업을 차단하지 않고 XML을 증분 적으로 구문 분석 할 수있는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="793641b11ec9edf6536ef14e14a17a202ba37fd0" translate="yes" xml:space="preserve">
          <source>Most programs adjust the current context only once, at the beginning of the program. And, in many applications, data is converted to &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; with a single cast inside a loop. With context set and decimals created, the bulk of the program manipulates the data no differently than with other Python numeric types.</source>
          <target state="translated">대부분의 프로그램은 프로그램 시작시 현재 컨텍스트를 한 번만 조정합니다. 또한 많은 응용 프로그램에서 데이터는 루프 내에서 단일 캐스트 를 사용하여 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 . 컨텍스트 세트 및 소수를 작성하면 대부분의 프로그램이 다른 Python 숫자 유형과 다르게 데이터를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="bed33f38a8121d67d831a08ac6160cf7fca8b25f" translate="yes" xml:space="preserve">
          <source>Most programs should find that using one of these weak container types or &lt;a href=&quot;#weakref.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; is all they need &amp;ndash; it&amp;rsquo;s not usually necessary to create your own weak references directly. The low-level machinery is exposed by the &lt;a href=&quot;#module-weakref&quot;&gt;&lt;code&gt;weakref&lt;/code&gt;&lt;/a&gt; module for the benefit of advanced uses.</source>
          <target state="translated">대부분의 프로그램은 이러한 약한 컨테이너 유형 중 하나를 사용하거나 &lt;a href=&quot;#weakref.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; 것이 필요한 전부라는 것을 알아야합니다. 일반적으로 자체 약한 참조를 직접 만들 필요는 없습니다. 저수준 기계는 고급 사용을 위해 &lt;a href=&quot;#module-weakref&quot;&gt; &lt;code&gt;weakref&lt;/code&gt; &lt;/a&gt; 모듈에 의해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e33a7247ba2cdbfe9e4c5eadcda0b6fb6940dfb" translate="yes" xml:space="preserve">
          <source>Most tkinter programs run &lt;code&gt;root.mainloop()&lt;/code&gt;, which usually does not return until the tk app is destroyed. If the program is run with &lt;code&gt;python -i&lt;/code&gt; or from an IDLE editor, a &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; shell prompt does not appear until &lt;code&gt;mainloop()&lt;/code&gt; returns, at which time there is nothing left to interact with.</source>
          <target state="translated">대부분의 tkinter 프로그램은 &lt;code&gt;root.mainloop()&lt;/code&gt; 실행 하는데 , 일반적으로 tk 앱이 파괴 될 때까지 반환되지 않습니다. 프로그램이 &lt;code&gt;python -i&lt;/code&gt; 또는 IDLE 편집기에서 실행되는 경우 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 쉘 프롬프트는 &lt;code&gt;mainloop()&lt;/code&gt; 리턴 될 때까지 나타나지 않으며 , 이때 상호 작용할 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="467bcc5b3e2170db615ed243a7771ae192662925" translate="yes" xml:space="preserve">
          <source>Most users should use &lt;a href=&quot;subprocess#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#os.posix_spawn&quot;&gt;&lt;code&gt;posix_spawn()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 사용자는 &lt;a href=&quot;#os.posix_spawn&quot;&gt; &lt;code&gt;posix_spawn()&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;subprocess#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run()&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7022d092d568159a8deb2f5345b042987cdc731a" translate="yes" xml:space="preserve">
          <source>Mouse event has occurred</source>
          <target state="translated">마우스 이벤트가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="59b381f9ae62e71a6e656f888600974d66a2a445" translate="yes" xml:space="preserve">
          <source>Move a &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt;/&lt;a href=&quot;https://www.python.org/dev/peps/pep-0488&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 488&lt;/strong&gt;&lt;/a&gt; pyc file to its legacy pyc location and return the file system path to the legacy pyc file. The &lt;em&gt;source&lt;/em&gt; value is the file system path to the source file. It does not need to exist, however the PEP 3147/488 pyc file must exist.</source>
          <target state="translated">이동 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; / &lt;a href=&quot;https://www.python.org/dev/peps/pep-0488&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 488&lt;/strong&gt;&lt;/a&gt; 는 기존의 pyc 위치로의 pyc 파일과 기존의 pyc 파일에 파일 시스템 경로를 반환합니다. &lt;em&gt;소스&lt;/em&gt; 값은 소스 파일에 파일 시스템 경로입니다. 존재할 필요는 없지만 PEP 3147/488 pyc 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="34fb02884cc45eb332edf96e82c7d3d89690c570" translate="yes" xml:space="preserve">
          <source>Move an existing &lt;em&gt;key&lt;/em&gt; to either end of an ordered dictionary. The item is moved to the right end if &lt;em&gt;last&lt;/em&gt; is true (the default) or to the beginning if &lt;em&gt;last&lt;/em&gt; is false. Raises &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; if the &lt;em&gt;key&lt;/em&gt; does not exist:</source>
          <target state="translated">기존 &lt;em&gt;키&lt;/em&gt; 를 정렬 된 사전의 한쪽 끝으로 이동하십시오 . &lt;em&gt;마지막&lt;/em&gt; 이 참이면 (기본값) 오른쪽으로 이동하고 &lt;em&gt;마지막&lt;/em&gt; 이 거짓 이면 시작으로 이동합니다 . 발생시킵니다 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를을&lt;/a&gt; 경우 &lt;em&gt;키가&lt;/em&gt; 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a9241b7a62db251595ec94a8670f8492cc79c5f0" translate="yes" xml:space="preserve">
          <source>Move and draw</source>
          <target state="translated">이동 및 그리기</target>
        </trans-unit>
        <trans-unit id="ef3b0cebd03fd191bbc4cb8897a06eaaba33d4fe" translate="yes" xml:space="preserve">
          <source>Move cursor to &lt;code&gt;(new_y, new_x)&lt;/code&gt;.</source>
          <target state="translated">커서를 &lt;code&gt;(new_y, new_x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="601b26f56eb7f3dd5627e0542377e2380db7e481" translate="yes" xml:space="preserve">
          <source>Move cursor to the line number requested and make that line visible.</source>
          <target state="translated">요청한 행 번호로 커서를 이동하고 해당 행을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="00de7b574f0ca4dca2db05f7ac95cf8fa926cd45" translate="yes" xml:space="preserve">
          <source>Move operations do nothing if the cursor is at an edge where the movement is not possible. The following synonyms are supported where possible:</source>
          <target state="translated">이동이 불가능한 가장자리에 커서가 있으면 이동 작업이 수행되지 않습니다. 가능한 경우 다음 동의어가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f14c08ec9cc70b053ef1452c74150f8bece0b93f" translate="yes" xml:space="preserve">
          <source>Move the current frame &lt;em&gt;count&lt;/em&gt; (default one) levels down in the stack trace (to a newer frame).</source>
          <target state="translated">스택 추적에서 현재 프레임 &lt;em&gt;수&lt;/em&gt; (기본 1) 레벨을 새 프레임으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1f999beea6e1d8614d33e214187f8c14de783371" translate="yes" xml:space="preserve">
          <source>Move the current frame &lt;em&gt;count&lt;/em&gt; (default one) levels up in the stack trace (to an older frame).</source>
          <target state="translated">스택 추적에서 현재 프레임 &lt;em&gt;수&lt;/em&gt; (기본) 수준을 이전 프레임으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="bddc2d8cac88c0e16d0d15e699390e1c93202c14" translate="yes" xml:space="preserve">
          <source>Move the panel to the screen coordinates &lt;code&gt;(y, x)&lt;/code&gt;.</source>
          <target state="translated">패널을 화면 좌표 &lt;code&gt;(y, x)&lt;/code&gt; 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="366616b5769d49d8c4989ea2123f0635dfd476c9" translate="yes" xml:space="preserve">
          <source>Move the turtle backward by &lt;em&gt;distance&lt;/em&gt;, opposite to the direction the turtle is headed. Do not change the turtle&amp;rsquo;s heading.</source>
          <target state="translated">후방으로 거북 이동 &lt;em&gt;거리&lt;/em&gt; 거북이가 향하고있는 방향에 대향. 거북이의 제목을 바꾸지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5bb8f30d63462cf640df95fdfb728a8ffba5f530" translate="yes" xml:space="preserve">
          <source>Move the turtle forward by the specified &lt;em&gt;distance&lt;/em&gt;, in the direction the turtle is headed.</source>
          <target state="translated">거북이가 향하는 방향으로 거북이를 지정된 &lt;em&gt;거리&lt;/em&gt; 만큼 앞으로 이동시킵니다 .</target>
        </trans-unit>
        <trans-unit id="606392f9ada71eee7694589f863fe49c6c953eb7" translate="yes" xml:space="preserve">
          <source>Move the window inside its parent window. The screen-relative parameters of the window are not changed. This routine is used to display different parts of the parent window at the same physical position on the screen.</source>
          <target state="translated">창을 부모 창으로 이동하십시오. 창의 화면 기준 매개 변수는 변경되지 않습니다. 이 루틴은 부모 창의 다른 부분을 화면에서 동일한 물리적 위치에 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4cc9d6cf91904a69809b29953b1b97a8cb436c" translate="yes" xml:space="preserve">
          <source>Move the window so its upper-left corner is at &lt;code&gt;(new_y, new_x)&lt;/code&gt;.</source>
          <target state="translated">왼쪽 위 모서리가 &lt;code&gt;(new_y, new_x)&lt;/code&gt; 가되도록 창을 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ae1c0cedf7a7f6220f5e9b65d8d117ba2c19e75" translate="yes" xml:space="preserve">
          <source>Move turtle to an absolute position. If the pen is down, draw line. Do not change the turtle&amp;rsquo;s orientation.</source>
          <target state="translated">거북이를 절대 위치로 옮기십시오. 펜이 내려져 있으면 선을 그립니다. 거북이의 방향을 바꾸지 마십시오.</target>
        </trans-unit>
        <trans-unit id="22468681bb2cde570129a7bbf809a05431bc555d" translate="yes" xml:space="preserve">
          <source>Move turtle to the origin &amp;ndash; coordinates (0,0) &amp;ndash; and set its heading to its start-orientation (which depends on the mode, see &lt;a href=&quot;#turtle.mode&quot;&gt;&lt;code&gt;mode()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">거북이를 원점 (좌표 (0,0))으로 이동하고 방향을 시작 방향으로 설정합니다 (모드에 따라 다르며 &lt;a href=&quot;#turtle.mode&quot;&gt; &lt;code&gt;mode()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5be33704c954094f90870e7ed96a149ee7bd9c74" translate="yes" xml:space="preserve">
          <source>Moves &lt;em&gt;item&lt;/em&gt; to position &lt;em&gt;index&lt;/em&gt; in &lt;em&gt;parent&lt;/em&gt;&amp;rsquo;s list of children.</source>
          <target state="translated">&lt;em&gt;부모&lt;/em&gt; 의 자녀 목록 에서 &lt;em&gt;항목&lt;/em&gt; 을 위치 &lt;em&gt;색인&lt;/em&gt; 으로 이동 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d83016dd56e9bf9199d175870ff56ee77659cfb7" translate="yes" xml:space="preserve">
          <source>Mozilla</source>
          <target state="translated">Mozilla</target>
        </trans-unit>
        <trans-unit id="77bb2f79a7eb833c24226c0fc4afbc0065f7bae3" translate="yes" xml:space="preserve">
          <source>Mozilla&amp;rsquo;s Server Side TLS recommendations</source>
          <target state="translated">Mozilla의 서버 측 TLS 권장 사항</target>
        </trans-unit>
        <trans-unit id="34e4e3490cfd5d827b6939f20b6812fc7ab81c0a" translate="yes" xml:space="preserve">
          <source>Much like &lt;a href=&quot;#opcode-LOAD_DEREF&quot;&gt;&lt;code&gt;LOAD_DEREF&lt;/code&gt;&lt;/a&gt; but first checks the locals dictionary before consulting the cell. This is used for loading free variables in class bodies.</source>
          <target state="translated">&lt;a href=&quot;#opcode-LOAD_DEREF&quot;&gt; &lt;code&gt;LOAD_DEREF&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 셀을 참조하기 전에 먼저 지역 사전을 확인하십시오. 이것은 클래스 본문에서 자유 변수를로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="330f90a4a7f8697f732d832206c87a0c80b1e817" translate="yes" xml:space="preserve">
          <source>Multi-dimensional arrays:</source>
          <target state="translated">다차원 배열 :</target>
        </trans-unit>
        <trans-unit id="e286be50d1c645889d37cc60a961288d4708698c" translate="yes" xml:space="preserve">
          <source>Multi-phase extension module initialization</source>
          <target state="translated">다상 확장 모듈 초기화</target>
        </trans-unit>
        <trans-unit id="3a17483ef417b9f9729e4d5407d6224ba50cae48" translate="yes" xml:space="preserve">
          <source>Multi-processing</source>
          <target state="translated">Multi-processing</target>
        </trans-unit>
        <trans-unit id="4df9252fd5d4911ee5eb1c96d25797e8cf043b28" translate="yes" xml:space="preserve">
          <source>Multi-threading</source>
          <target state="translated">Multi-threading</target>
        </trans-unit>
        <trans-unit id="775f46e5feac2a655ca3c0f4647af4e10f6b1405" translate="yes" xml:space="preserve">
          <source>MultiCall Objects</source>
          <target state="translated">멀티 콜 객체</target>
        </trans-unit>
        <trans-unit id="d9e13b473f0ae3bd1e957746112d999190ceed57" translate="yes" xml:space="preserve">
          <source>Multihop attempted</source>
          <target state="translated">멀티 홉 시도</target>
        </trans-unit>
        <trans-unit id="82dabd0bba3a5f611035c568eaa03187a7117693" translate="yes" xml:space="preserve">
          <source>Multimedia</source>
          <target state="translated">Multimedia</target>
        </trans-unit>
        <trans-unit id="4e13023947484ddbe09e9dcd00133156cd68392c" translate="yes" xml:space="preserve">
          <source>Multimedia Services</source>
          <target state="translated">멀티미디어 서비스</target>
        </trans-unit>
        <trans-unit id="bb2ec50bee2ac650f14f5c5ab53fb76fb7fa35c2" translate="yes" xml:space="preserve">
          <source>Multiple commands may be entered on a single line, separated by &lt;code&gt;;;&lt;/code&gt;. (A single &lt;code&gt;;&lt;/code&gt; is not used as it is the separator for multiple commands in a line that is passed to the Python parser.) No intelligence is applied to separating the commands; the input is split at the first &lt;code&gt;;;&lt;/code&gt; pair, even if it is in the middle of a quoted string.</source>
          <target state="translated">한 줄에 여러 명령을 입력 할 수 있으며 &lt;code&gt;;;&lt;/code&gt; . (단일 &lt;code&gt;;&lt;/code&gt; 은 파이썬 파서에 전달되는 행에서 여러 명령의 구분 기호로 사용되지 않습니다.) 명령을 분리하는 데 지능이 적용되지 않습니다. 입력이 처음에 분할됩니다. &lt;code&gt;;;&lt;/code&gt; 따옴표로 묶인 문자열의 중간에 있어도 쌍을 이룹니다.</target>
        </trans-unit>
        <trans-unit id="3d09adb7f1de6110bb767281eb6fabdd98f6a2d7" translate="yes" xml:space="preserve">
          <source>Multiple directives can be used on a single physical line, separated by commas:</source>
          <target state="translated">단일 지시문에 여러 지시문을 쉼표로 구분하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7299187e78acfeb10e1b49723ae100be4c64b0fe" translate="yes" xml:space="preserve">
          <source>Multiple notebooks in a single toplevel may be enabled for traversal, including nested notebooks. However, notebook traversal only works properly if all panes have the notebook they are in as master.</source>
          <target state="translated">중첩 된 전자 필기장을 포함하여 단일 최상위 수준의 여러 전자 필기장을 순회 할 수 있습니다. 그러나 모든 창에 마스터 노트북이있는 노트북이있는 경우에만 노트북 탐색이 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5162321020c32ce61d50bae28086dd890680e982" translate="yes" xml:space="preserve">
          <source>Multiple paths can be given to &lt;code&gt;venv&lt;/code&gt;, in which case an identical virtual environment will be created, according to the given options, at each provided path.</source>
          <target state="translated">&lt;code&gt;venv&lt;/code&gt; 에 여러 경로를 지정할 수 있으며 ,이 경우 제공된 옵션에 따라 제공된 각 경로에서 동일한 가상 환경이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4573ed2f0edb61983a51e72e312c05e99fea31c4" translate="yes" xml:space="preserve">
          <source>Multiple scripts demonstrating different features of the &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; module. Examples can be accessed via the Examples menu. They can also be run standalone.</source>
          <target state="translated">&lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 모듈 의 다른 기능을 보여주는 여러 스크립트 . 예제는 예제 메뉴를 통해 액세스 할 수 있습니다. 독립형으로 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="7a49abf6458e7554b14dad6ea5826909852a08c1" translate="yes" xml:space="preserve">
          <source>Multithreaded version of &lt;a href=&quot;#telnetlib.Telnet.interact&quot;&gt;&lt;code&gt;interact()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#telnetlib.Telnet.interact&quot;&gt; &lt;code&gt;interact()&lt;/code&gt; &lt;/a&gt; 의 멀티 스레드 버전 .</target>
        </trans-unit>
        <trans-unit id="8a86acdcb9f782d0a3ed3f193ab37879a5d757d7" translate="yes" xml:space="preserve">
          <source>Multithreading</source>
          <target state="translated">Multithreading</target>
        </trans-unit>
        <trans-unit id="e84051d950065a19888b9a4b65dd834b3ca5708a" translate="yes" xml:space="preserve">
          <source>Must accept a request from the socket, and return a 2-tuple containing the &lt;em&gt;new&lt;/em&gt; socket object to be used to communicate with the client, and the client&amp;rsquo;s address.</source>
          <target state="translated">소켓의 요청을 수락 하고 클라이언트와 통신하는 데 사용할 &lt;em&gt;새&lt;/em&gt; 소켓 객체와 클라이언트 주소가 포함 된 2 개의 튜플을 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4747a0250917ddc1dc2a0d4fc6b92b4e01de5dd8" translate="yes" xml:space="preserve">
          <source>Must be called if the programmer wants to use colors, and before any other color manipulation routine is called. It is good practice to call this routine right after &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로그래머가 색상을 사용하려면 다른 색상 조작 루틴을 호출하기 전에 호출해야합니다. &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 바로 다음에이 루틴을 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ff7e72021a763f0ee5ccf9301a43b444b5e95394" translate="yes" xml:space="preserve">
          <source>Must be one of: &lt;code&gt;&quot;none&quot;&lt;/code&gt;, &lt;code&gt;&quot;char&quot;&lt;/code&gt;, or &lt;code&gt;&quot;word&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;none&quot;&lt;/code&gt; , &lt;code&gt;&quot;char&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;word&quot;&lt;/code&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf1dc0566c10e0139b5df0505eb1e78b6fd3569" translate="yes" xml:space="preserve">
          <source>Must be raised by &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__anext__&quot;&gt;&lt;code&gt;__anext__()&lt;/code&gt;&lt;/a&gt; method of an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-iterator&quot;&gt;asynchronous iterator&lt;/a&gt; object to stop the iteration.</source>
          <target state="translated">반복을 중지하려면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-iterator&quot;&gt;비동기 반복자&lt;/a&gt; 오브젝트 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__anext__&quot;&gt; &lt;code&gt;__anext__()&lt;/code&gt; &lt;/a&gt; 메소드 로 제기해야합니다 .</target>
        </trans-unit>
        <trans-unit id="adf6c9fd4760a31bfbf5ba31fc932d1f5a3f031e" translate="yes" xml:space="preserve">
          <source>Must be zero.</source>
          <target state="translated">0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae91554455709a10c47572fb3081826f1c8d9b10" translate="yes" xml:space="preserve">
          <source>Must return a Boolean value; if the value is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, the request will be processed, and if it&amp;rsquo;s &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, the request will be denied. This function can be overridden to implement access controls for a server. The default implementation always returns &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">부울 값을 반환해야합니다. 값이 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 요청이 처리되고 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 인 경우 요청이 거부됩니다. 서버에 대한 액세스 제어를 구현하기 위해이 기능을 재정의 할 수 있습니다. 기본 구현은 항상 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6a5c56949118e7bbfa4e5df14253fa9c206b4ced" translate="yes" xml:space="preserve">
          <source>Mutable Sequence Types</source>
          <target state="translated">가변 서열 유형</target>
        </trans-unit>
        <trans-unit id="59a777ead597ed74ce5de4536307c0d1ace10414" translate="yes" xml:space="preserve">
          <source>Mutable default values</source>
          <target state="translated">가변 기본값</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">상호 배제</target>
        </trans-unit>
        <trans-unit id="f1dae7604a00897f0a4fd9c9086372f8cb686e88" translate="yes" xml:space="preserve">
          <source>MyStruct(4, 6)</source>
          <target state="translated">MyStruct (4, 6)</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="f3b6e147d97b483fedd25cc8dfa6e8453dae0246" translate="yes" xml:space="preserve">
          <source>NNTP (Net News Transport Protocol) client</source>
          <target state="translated">NNTP (Net News Transport Protocol) 클라이언트</target>
        </trans-unit>
        <trans-unit id="79c75ca6272ee59fef0850ac71420be0538f2b61" translate="yes" xml:space="preserve">
          <source>NNTP Objects</source>
          <target state="translated">NNTP 객체</target>
        </trans-unit>
        <trans-unit id="d1dc5a1761f453c4a0fd7017ba832bc17fd8ad13" translate="yes" xml:space="preserve">
          <source>NOOP</source>
          <target state="translated">NOOP</target>
        </trans-unit>
        <trans-unit id="51374517cce15cf30e5fafe081ab605aef775d59" translate="yes" xml:space="preserve">
          <source>NTEventLogHandler</source>
          <target state="translated">NTEventLogHandler</target>
        </trans-unit>
        <trans-unit id="96cd9da0c6e1ccdfcc159d790597f9c5ab44b9f9" translate="yes" xml:space="preserve">
          <source>Naive &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instances are assumed to represent local time and this method relies on the platform C &lt;code&gt;mktime()&lt;/code&gt; function to perform the conversion. Since &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; supports wider range of values than &lt;code&gt;mktime()&lt;/code&gt; on many platforms, this method may raise &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; for times far in the past or far in the future.</source>
          <target state="translated">순진한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스는 현지 시간을 나타내는 것으로 가정 되며이 메서드는 플랫폼 C &lt;code&gt;mktime()&lt;/code&gt; 함수를 사용하여 변환을 수행합니다. 이후 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 보다 값 지원하는 넓은 범위 &lt;code&gt;mktime()&lt;/code&gt; 많은 플랫폼에서,이 방법은 제기 할 수 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 먼 과거 나 먼 미래 번.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="c27442e14dcf480c5096062467b3aa70532fef60" translate="yes" xml:space="preserve">
          <source>Name (string)</source>
          <target state="translated">이름 (문자열)</target>
        </trans-unit>
        <trans-unit id="f749babb57e6226126151fa3ff0dcb49a37a4566" translate="yes" xml:space="preserve">
          <source>Name and version of the thread library. It is a string, or &lt;code&gt;None&lt;/code&gt; if this information is unknown.</source>
          <target state="translated">스레드 라이브러리의 이름 및 버전 문자열 &lt;code&gt;None&lt;/code&gt; 정보를 알 수 없으면 None 입니다.</target>
        </trans-unit>
        <trans-unit id="bd0eba018b32a3fc8bf5757f41e9d39ed4d796bd" translate="yes" xml:space="preserve">
          <source>Name not unique on network</source>
          <target state="translated">네트워크에서 고유하지 않은 이름</target>
        </trans-unit>
        <trans-unit id="6b9e670759af04e3a29cb11b387ac0af4c4ba79a" translate="yes" xml:space="preserve">
          <source>Name of a file to accumulate counts over several tracing runs. Should be used with the &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">누적 할 파일 이름은 여러 추적 실행에서 계산됩니다. &lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 옵션 과 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f41d04af7c00689d29db73e5e39ccec3d7f4baa" translate="yes" xml:space="preserve">
          <source>Name of a file where the output should be written.</source>
          <target state="translated">출력을 작성해야하는 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="909d50c1d59e7f6872cd42d8d690e7a67cfddf5e" translate="yes" xml:space="preserve">
          <source>Name of function containing the logging call.</source>
          <target state="translated">로깅 호출을 포함하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a4e437038133290bc84db0a7901dbdac884887ac" translate="yes" xml:space="preserve">
          <source>Name of the &lt;code&gt;ndbm&lt;/code&gt; implementation library used.</source>
          <target state="translated">사용 된 &lt;code&gt;ndbm&lt;/code&gt; 구현 라이브러리의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="b82dd6dc18736a73581a12357aabc36155aa0044" translate="yes" xml:space="preserve">
          <source>Name of the ZIP file.</source>
          <target state="translated">ZIP 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7bd737364faf0eec56bb0fc421ccc3c610d6ed65" translate="yes" xml:space="preserve">
          <source>Name of the archive member.</source>
          <target state="translated">아카이브 멤버의 이름</target>
        </trans-unit>
        <trans-unit id="2c902fcfc808584d112a3ceeb4eb2bc1f3619bea" translate="yes" xml:space="preserve">
          <source>Name of the file in the archive.</source>
          <target state="translated">아카이브에있는 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3f4f64a593b458f13706273b6df06d01e90dabff" translate="yes" xml:space="preserve">
          <source>Name of the file in which the class is defined.</source>
          <target state="translated">클래스가 정의 된 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="52c4cd4fff87ccdc917ab79849a30f112d326420" translate="yes" xml:space="preserve">
          <source>Name of the file in which the function is defined.</source>
          <target state="translated">함수가 정의 된 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="479b58a3698cd8bdd2749e826438a6efb9a37443" translate="yes" xml:space="preserve">
          <source>Name of the kernel filter.</source>
          <target state="translated">커널 필터의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="557389192cfcd5c2bf918ddbf712bd3b1d343b90" translate="yes" xml:space="preserve">
          <source>Name of the lock implementation:</source>
          <target state="translated">잠금 구현 이름 :</target>
        </trans-unit>
        <trans-unit id="e5bcc652602bbe94f6a9ebcc11b4cb38e6c0ea60" translate="yes" xml:space="preserve">
          <source>Name of the logger used to log the call.</source>
          <target state="translated">통화를 기록하는 데 사용되는 로거의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1ac5bb9ec4a87c7e2e4d424b152dffc6dceb92f8" translate="yes" xml:space="preserve">
          <source>Name of the module the loader supports.</source>
          <target state="translated">로더가 지원하는 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="88649ef30eca2eef544db1a703bfa26a7680062b" translate="yes" xml:space="preserve">
          <source>Name of the place from which the module is loaded, e.g. &amp;ldquo;builtin&amp;rdquo; for built-in modules and the filename for modules loaded from source. Normally &amp;ldquo;origin&amp;rdquo; should be set, but it may be &lt;code&gt;None&lt;/code&gt; (the default) which indicates it is unspecified (e.g. for namespace packages).</source>
          <target state="translated">내장 모듈의 경우 &quot;내장&quot;및 소스에서로드 한 모듈의 파일 이름과 같이 모듈이로드 된 장소의 이름입니다. 일반적으로 &quot;원점&quot;을 설정해야하지만 지정되지 않음을 나타내는 &lt;code&gt;None&lt;/code&gt; (기본값) 일 수 있습니다 (예 : 네임 스페이스 패키지).</target>
        </trans-unit>
        <trans-unit id="3add1cd07c9747dd5701cddb479a22e098f8ef27" translate="yes" xml:space="preserve">
          <source>Name of the target file name, which is only present in &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;LNKTYPE&lt;/code&gt; and &lt;code&gt;SYMTYPE&lt;/code&gt;.</source>
          <target state="translated">만 존재하는 대상 파일 이름, 이름 &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; 은&lt;/a&gt; 타입의 객체 &lt;code&gt;LNKTYPE&lt;/code&gt; 및 &lt;code&gt;SYMTYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c8a8acd0a715e63879cf8add7d8952be75bc26b" translate="yes" xml:space="preserve">
          <source>Name of the thread implementation:</source>
          <target state="translated">스레드 구현 이름 :</target>
        </trans-unit>
        <trans-unit id="552b247919a3a4142c7193f3218e6c006dc56731" translate="yes" xml:space="preserve">
          <source>NameError</source>
          <target state="translated">NameError</target>
        </trans-unit>
        <trans-unit id="9aded8be679f83c11f74ee1bff7f85682a20e807" translate="yes" xml:space="preserve">
          <source>Named groups can also be referred to by their index:</source>
          <target state="translated">명명 된 그룹은 색인으로도 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c28e1ee5f518cf29efb67d882148a0b1e5416250" translate="yes" xml:space="preserve">
          <source>Named groups can be referenced in three contexts. If the pattern is &lt;code&gt;(?P&amp;lt;quote&amp;gt;['&quot;]).*?(?P=quote)&lt;/code&gt; (i.e. matching a string quoted with either single or double quotes):</source>
          <target state="translated">명명 된 그룹은 세 가지 컨텍스트에서 참조 할 수 있습니다. 패턴이 &lt;code&gt;(?P&amp;lt;quote&amp;gt;['&quot;]).*?(?P=quote)&lt;/code&gt; (즉, 작은 따옴표 나 큰 따옴표로 인용 된 문자열과 일치) :</target>
        </trans-unit>
        <trans-unit id="f16a4120b764cba8959d773cf7f3b0e19c88a175" translate="yes" xml:space="preserve">
          <source>Named tuple instances do not have per-instance dictionaries, so they are lightweight and require no more memory than regular tuples.</source>
          <target state="translated">명명 된 튜플 인스턴스에는 인스턴스 별 사전이 없으므로 가벼우 며 일반 튜플보다 더 많은 메모리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f512fe216c8d2627c3f288b9c1b60f1f0813d360" translate="yes" xml:space="preserve">
          <source>Named tuples are especially useful for assigning field names to result tuples returned by the &lt;a href=&quot;csv#module-csv&quot;&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sqlite3#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; modules:</source>
          <target state="translated">명명 된 튜플은 &lt;a href=&quot;csv#module-csv&quot;&gt; &lt;code&gt;csv&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sqlite3#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈 에서 반환 된 결과 튜플에 필드 이름을 할당하는 데 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="d560ba60fd40808c605c894ca61edab52b60a8f7" translate="yes" xml:space="preserve">
          <source>Named tuples assign meaning to each position in a tuple and allow for more readable, self-documenting code. They can be used wherever regular tuples are used, and they add the ability to access fields by name instead of position index.</source>
          <target state="translated">명명 된 튜플은 튜플의 각 위치에 의미를 할당하고 더 읽기 쉬운 자체 문서화 코드를 허용합니다. 정규 튜플이 사용되는 곳이라면 어디에서나 사용할 수 있으며 위치 색인 대신 이름으로 필드에 액세스하는 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="138d23bf87d91f2cf8e499a38b28a27198431782" translate="yes" xml:space="preserve">
          <source>NamedNodeMap Objects</source>
          <target state="translated">명명 된 NodeMap 객체</target>
        </trans-unit>
        <trans-unit id="79151ef5523cbb3688933e1d2359c827b97b6dba" translate="yes" xml:space="preserve">
          <source>Names in both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, such that the type differs between the directories, or names for which &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; reports an error.</source>
          <target state="translated">모두 이름 과 &lt;em&gt;B&lt;/em&gt; 유형 디렉토리 다르기 또는 이름이있는되도록, &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 에러를보고한다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a0bec580c91a0db0dd9741e0f59ccc6c55e7006" translate="yes" xml:space="preserve">
          <source>Namespace-aware variant of &lt;a href=&quot;#xml.sax.xmlreader.AttributesImpl&quot;&gt;&lt;code&gt;AttributesImpl&lt;/code&gt;&lt;/a&gt;, which will be passed to &lt;code&gt;startElementNS()&lt;/code&gt;. It is derived from &lt;a href=&quot;#xml.sax.xmlreader.AttributesImpl&quot;&gt;&lt;code&gt;AttributesImpl&lt;/code&gt;&lt;/a&gt;, but understands attribute names as two-tuples of &lt;em&gt;namespaceURI&lt;/em&gt; and &lt;em&gt;localname&lt;/em&gt;. In addition, it provides a number of methods expecting qualified names as they appear in the original document. This class implements the &lt;code&gt;AttributesNS&lt;/code&gt; interface (see section &lt;a href=&quot;#attributes-ns-objects&quot;&gt;The AttributesNS Interface&lt;/a&gt;).</source>
          <target state="translated">네임 스페이스를 인식하는 &lt;a href=&quot;#xml.sax.xmlreader.AttributesImpl&quot;&gt; &lt;code&gt;AttributesImpl&lt;/code&gt; &lt;/a&gt; 변형 으로 &lt;code&gt;startElementNS()&lt;/code&gt; 로 전달됩니다 . 이 &lt;a href=&quot;#xml.sax.xmlreader.AttributesImpl&quot;&gt; &lt;code&gt;AttributesImpl&lt;/code&gt; &lt;/a&gt; 은 AttributesImpl 에서 파생 되지만 &lt;em&gt;네임 스페이스 URI&lt;/em&gt; 및 &lt;em&gt;localname&lt;/em&gt; 의 두 튜플로 속성 이름을 이해합니다 . 또한 원본 문서에 나타나는 정규화 된 이름을 기대하는 여러 가지 방법을 제공합니다. 이 클래스의 구현 &lt;code&gt;AttributesNS&lt;/code&gt; 의 인터페이스 (섹션 참조 &lt;a href=&quot;#attributes-ns-objects&quot;&gt;AttributesNS 인터페이스&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3fac676b9daa5e7147af0e960a2d8869c1122f19" translate="yes" xml:space="preserve">
          <source>Naming your mocks</source>
          <target state="translated">모의 이름 지정</target>
        </trans-unit>
        <trans-unit id="3e8980fc43ff1044a18189e78dedc1df9a62b49e" translate="yes" xml:space="preserve">
          <source>Native byte order is big-endian or little-endian, depending on the host system. For example, Intel x86 and AMD64 (x86-64) are little-endian; Motorola 68000 and PowerPC G5 are big-endian; ARM and Intel Itanium feature switchable endianness (bi-endian). Use &lt;code&gt;sys.byteorder&lt;/code&gt; to check the endianness of your system.</source>
          <target state="translated">기본 바이트 순서는 호스트 시스템에 따라 빅 엔디안 또는 리틀 엔디안입니다. 예를 들어, Intel x86 및 AMD64 (x86-64)는 리틀 엔디안입니다. Motorola 68000과 PowerPC G5는 빅 엔디안입니다. ARM 및 Intel Itanium에는 전환 가능한 엔디안 (bi- 엔디안) 기능이 있습니다. &lt;code&gt;sys.byteorder&lt;/code&gt; 를 사용 하여 시스템의 엔디안을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="48f10fdc477f6339c64bce4467bf56cec228d333" translate="yes" xml:space="preserve">
          <source>Native size and alignment are determined using the C compiler&amp;rsquo;s &lt;code&gt;sizeof&lt;/code&gt; expression. This is always combined with native byte order.</source>
          <target state="translated">기본 크기와 정렬은 C 컴파일러의 &lt;code&gt;sizeof&lt;/code&gt; 표현식을 사용하여 결정됩니다 . 이것은 항상 기본 바이트 순서와 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="517a1d8d49b78127b5bb2acf6015f7707345aa2e" translate="yes" xml:space="preserve">
          <source>Navigating inside a directory tree:</source>
          <target state="translated">디렉토리 트리 내에서 탐색 :</target>
        </trans-unit>
        <trans-unit id="987fc48a30ea30d92d41a6019a3ed94eb415d66d" translate="yes" xml:space="preserve">
          <source>Negation (Arithmetic)</source>
          <target state="translated">부정 (산술)</target>
        </trans-unit>
        <trans-unit id="627e9d13ddc6c294f7ec2e115eee5c51e4b0a37a" translate="yes" xml:space="preserve">
          <source>Negation (Logical)</source>
          <target state="translated">부정 (논리)</target>
        </trans-unit>
        <trans-unit id="b55a8cef5977e78a89ae2e69772eef902ec4a5a5" translate="yes" xml:space="preserve">
          <source>Negative acknowledgement</source>
          <target state="translated">부정적 인정</target>
        </trans-unit>
        <trans-unit id="34c7643d5f745ab08c69c16dd12140498edf58a7" translate="yes" xml:space="preserve">
          <source>Negative shift counts are illegal and cause a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to be raised.</source>
          <target state="translated">음수 이동 횟수가 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32487c26ecab149a196fce5321757c6b3bf4b876" translate="yes" xml:space="preserve">
          <source>Nested structures can also be initialized in the constructor in several ways:</source>
          <target state="translated">중첩 구조는 생성자에서 여러 가지 방법으로 초기화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b24ed9821e96a2648c5646b75130ceb97178a4c" translate="yes" xml:space="preserve">
          <source>Nesting Patch Decorators</source>
          <target state="translated">중첩 패치 데코레이터</target>
        </trans-unit>
        <trans-unit id="ea31f50cab713b0f124052f1b7a16defcb810ab2" translate="yes" xml:space="preserve">
          <source>Nesting Patches</source>
          <target state="translated">중첩 패치</target>
        </trans-unit>
        <trans-unit id="48f4eff85da085dead78d399f32b4afe378e5d2d" translate="yes" xml:space="preserve">
          <source>Nesting arguments and more complex examples:</source>
          <target state="translated">중첩 인수 및보다 복잡한 예 :</target>
        </trans-unit>
        <trans-unit id="387c36a7e2c55b1e37b061b1ad887cc307968414" translate="yes" xml:space="preserve">
          <source>Netscape protocol strictness switches:</source>
          <target state="translated">넷스케이프 프로토콜 엄격 스위치 :</target>
        </trans-unit>
        <trans-unit id="8baad1cbc284c12f56ea33b670eb34325f6b8199" translate="yes" xml:space="preserve">
          <source>Network IO</source>
          <target state="translated">네트워크 IO</target>
        </trans-unit>
        <trans-unit id="82a92bfa4dd74a7c277b6e280e7993e24e6bd37b" translate="yes" xml:space="preserve">
          <source>Network dropped connection because of reset</source>
          <target state="translated">재설정으로 인해 네트워크 연결이 끊어졌습니다.</target>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="translated">네트워크가 다운되었습니다</target>
        </trans-unit>
        <trans-unit id="d34a1412dd6535ceabe7960d72728113a96b875c" translate="yes" xml:space="preserve">
          <source>Network is unreachable</source>
          <target state="translated">네트워크에 연결할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f1187f91a6b9526e3ad1f52e3394c4d7df1155f3" translate="yes" xml:space="preserve">
          <source>Network location part</source>
          <target state="translated">네트워크 위치 부분</target>
        </trans-unit>
        <trans-unit id="a94bfe6962e04d8964bb10b7ee9c6ed49863a34f" translate="yes" xml:space="preserve">
          <source>Network objects</source>
          <target state="translated">네트워크 객체</target>
        </trans-unit>
        <trans-unit id="d002009562d56b5b62febaf56a1d9b00d7976530" translate="yes" xml:space="preserve">
          <source>Network objects can act as containers of addresses. Some examples:</source>
          <target state="translated">네트워크 개체는 주소 컨테이너 역할을 할 수 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="20fcf7eba0d4de1e05964bd5839c098f8acebea8" translate="yes" xml:space="preserve">
          <source>Network objects can be compared with the usual set of logical operators. Network objects are ordered first by network address, then by net mask.</source>
          <target state="translated">네트워크 개체는 일반적인 논리 연산자 집합과 비교할 수 있습니다. 네트워크 객체는 먼저 네트워크 주소로 정렬 된 다음 네트 마스크로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9fb3a6d9875537b1c0c38a2431cc632cb829f8a7" translate="yes" xml:space="preserve">
          <source>Network objects can be iterated to list all the addresses belonging to the network. For iteration, &lt;em&gt;all&lt;/em&gt; hosts are returned, including unusable hosts (for usable hosts, use the &lt;a href=&quot;#ipaddress.IPv4Network.hosts&quot;&gt;&lt;code&gt;hosts()&lt;/code&gt;&lt;/a&gt; method). An example:</source>
          <target state="translated">네트워크에 속하는 모든 주소를 나열하기 위해 네트워크 개체를 반복 할 수 있습니다. 반복의 경우, 사용 불가능한 호스트를 포함하여 &lt;em&gt;모든&lt;/em&gt; 호스트가 리턴됩니다 (사용 가능한 호스트의 경우 &lt;a href=&quot;#ipaddress.IPv4Network.hosts&quot;&gt; &lt;code&gt;hosts()&lt;/code&gt; &lt;/a&gt; 메소드 사용). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1c620c8b990249735711860cb7b51cafd949fab4" translate="yes" xml:space="preserve">
          <source>Network objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</source>
          <target state="translated">네트워크 객체는 일부 연산자를 지원합니다. 달리 명시하지 않는 한, 연산자는 호환 가능한 개체 (예 : IPv4를 사용하는 IPv4, IPv6을 사용하는 IPv6) 사이에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94d3480ab302bd240a4a2e92c94a41facba908a0" translate="yes" xml:space="preserve">
          <source>Networking &amp;amp; Interprocess Communication</source>
          <target state="translated">네트워킹 및 프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="173aff8fcb77fae19c3b7a5cfe41672fc9b21ae0" translate="yes" xml:space="preserve">
          <source>Networking and IPC</source>
          <target state="translated">네트워킹 및 IPC</target>
        </trans-unit>
        <trans-unit id="7696b1c0a533c955797df8c40d2eb34ddf93894d" translate="yes" xml:space="preserve">
          <source>Networking and Interprocess Communication</source>
          <target state="translated">네트워킹 및 프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="4136d3e620eed1009afaac5766d22a562ea45d95" translate="yes" xml:space="preserve">
          <source>Networks as containers of addresses</source>
          <target state="translated">주소 컨테이너로서의 네트워크</target>
        </trans-unit>
        <trans-unit id="1b2021fe3ae1d663f2ee43b16a7c7f0fc183cecc" translate="yes" xml:space="preserve">
          <source>Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of &lt;em&gt;path&lt;/em&gt;, e.g. members that have absolute filenames starting with &lt;code&gt;&quot;/&quot;&lt;/code&gt; or filenames with two dots &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">사전 검사없이 신뢰할 수없는 출처에서 아카이브를 추출하지 마십시오. &lt;code&gt;&quot;/&quot;&lt;/code&gt; 로 시작하는 절대 파일 이름을 가진 멤버 또는 두 개의 점 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 을 가진 파일 이름을 가진 멤버 와 같이 파일은 &lt;em&gt;경로&lt;/em&gt; 외부에서 생성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c62e809819381e83090bced1e2173f918be1f3b0" translate="yes" xml:space="preserve">
          <source>Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of &lt;em&gt;path&lt;/em&gt;, e.g. members that have absolute filenames starting with &lt;code&gt;&quot;/&quot;&lt;/code&gt; or filenames with two dots &lt;code&gt;&quot;..&quot;&lt;/code&gt;. This module attempts to prevent that. See &lt;a href=&quot;#zipfile.ZipFile.extract&quot;&gt;&lt;code&gt;extract()&lt;/code&gt;&lt;/a&gt; note.</source>
          <target state="translated">사전 검사없이 신뢰할 수없는 출처에서 아카이브를 추출하지 마십시오. &lt;code&gt;&quot;/&quot;&lt;/code&gt; 로 시작하는 절대 파일 이름을 가진 멤버 또는 두 개의 점 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 을 가진 파일 이름을 가진 멤버 와 같이 파일은 &lt;em&gt;경로&lt;/em&gt; 외부에서 생성 될 수 있습니다 . 이 모듈은이를 방지하려고 시도합니다. &lt;a href=&quot;#zipfile.ZipFile.extract&quot;&gt; &lt;code&gt;extract()&lt;/code&gt; &lt;/a&gt; 참고를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ccaf85ee75327fc748e39faca2166199011de41a" translate="yes" xml:space="preserve">
          <source>New File</source>
          <target state="translated">새로운 파일</target>
        </trans-unit>
        <trans-unit id="409292424eb18087ed2f720f75aa3dc7008467fa" translate="yes" xml:space="preserve">
          <source>New Import Hooks</source>
          <target state="translated">새로운 수입 훅</target>
        </trans-unit>
        <trans-unit id="f67997d268c1af98301a345d50239d3f892a0eb7" translate="yes" xml:space="preserve">
          <source>New Indent Width</source>
          <target state="translated">새로운 들여 쓰기 너비</target>
        </trans-unit>
        <trans-unit id="12a8cecf358397da137dcdd0fe30e38555ec9cfd" translate="yes" xml:space="preserve">
          <source>New contexts can also be created using the &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; constructor described below. In addition, the module provides three pre-made contexts:</source>
          <target state="translated">아래에 설명 된 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새 컨텍스트를 만들 수도 있습니다 . 또한이 모듈은 사전 작성된 세 가지 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a1d94154a6598cae8341b022c23e40f99e28431" translate="yes" xml:space="preserve">
          <source>New hash objects are created by calling constructor functions:</source>
          <target state="translated">생성자 함수를 호출하여 새 해시 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f0e3ef54012ca2003232ea452f70d451c14796eb" translate="yes" xml:space="preserve">
          <source>New in</source>
          <target state="translated">새로운 기능</target>
        </trans-unit>
        <trans-unit id="3044731cb14928152cff1cf7dc1f4fa6c076e116" translate="yes" xml:space="preserve">
          <source>New in version 3.1.</source>
          <target state="translated">버전 3.1의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="3490f0090dbcdc45af81e4d62ca30e6b962ba596" translate="yes" xml:space="preserve">
          <source>New in version 3.1: Added under the name &lt;code&gt;assertRaisesRegexp&lt;/code&gt;.</source>
          <target state="translated">버전 3.1의 새로운 기능 : &lt;code&gt;assertRaisesRegexp&lt;/code&gt; 라는 이름으로 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5aaafe02546b7ea7e8be1083e6726b39beceb3be" translate="yes" xml:space="preserve">
          <source>New in version 3.1: Added under the name &lt;code&gt;assertRegexpMatches&lt;/code&gt;.</source>
          <target state="translated">버전 3.1의 새로운 기능 : &lt;code&gt;assertRegexpMatches&lt;/code&gt; 라는 이름으로 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0cdd0395e78a0dc6664ff5b4d4ec37a63a481081" translate="yes" xml:space="preserve">
          <source>New in version 3.1: The &lt;code&gt;'surrogateescape'&lt;/code&gt; and &lt;code&gt;'surrogatepass'&lt;/code&gt; error handlers.</source>
          <target state="translated">버전 3.1의 새로운 기능 : &lt;code&gt;'surrogateescape'&lt;/code&gt; 및 &lt;code&gt;'surrogatepass'&lt;/code&gt; 오류 처리기.</target>
        </trans-unit>
        <trans-unit id="32c6d6c31b4876c85b341703ff1176d48fc1033d" translate="yes" xml:space="preserve">
          <source>New in version 3.1: The &lt;code&gt;SEEK_*&lt;/code&gt; constants.</source>
          <target state="translated">버전 3.1의 새로운 기능 : &lt;code&gt;SEEK_*&lt;/code&gt; 상수.</target>
        </trans-unit>
        <trans-unit id="ff81f06c49fb2cc34747b6d94a1ad63a6cf4f4f3" translate="yes" xml:space="preserve">
          <source>New in version 3.1: The &lt;em&gt;skip&lt;/em&gt; argument.</source>
          <target state="translated">버전 3.1의 새로운 기능 : &lt;em&gt;skip&lt;/em&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="aec3464ceeab8cf46a16efea3d5d6d17ad876e19" translate="yes" xml:space="preserve">
          <source>New in version 3.2.</source>
          <target state="translated">버전 3.2의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="db31bd421783154e9fc48afcb4954a828a5d37e2" translate="yes" xml:space="preserve">
          <source>New in version 3.2.3: The &lt;code&gt;hash_randomization&lt;/code&gt; attribute.</source>
          <target state="translated">버전 3.2.3의 새로운 기능 : &lt;code&gt;hash_randomization&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="c0dcdf7c449d4eea6b69af79b67c72ca17c53ff2" translate="yes" xml:space="preserve">
          <source>New in version 3.2: &lt;a href=&quot;#array.array.fromstring&quot;&gt;&lt;code&gt;fromstring()&lt;/code&gt;&lt;/a&gt; is renamed to &lt;a href=&quot;#array.array.frombytes&quot;&gt;&lt;code&gt;frombytes()&lt;/code&gt;&lt;/a&gt; for clarity.</source>
          <target state="translated">3.2 버전의 새로운 기능 : &lt;a href=&quot;#array.array.fromstring&quot;&gt; &lt;code&gt;fromstring()&lt;/code&gt; &lt;/a&gt; 로 이름이 바뀌 &lt;a href=&quot;#array.array.frombytes&quot;&gt; &lt;code&gt;frombytes()&lt;/code&gt; &lt;/a&gt; 명확합니다.</target>
        </trans-unit>
        <trans-unit id="488e827468c8402f0be6892563ca51a7f7278aa7" translate="yes" xml:space="preserve">
          <source>New in version 3.2: &lt;a href=&quot;#array.array.tostring&quot;&gt;&lt;code&gt;tostring()&lt;/code&gt;&lt;/a&gt; is renamed to &lt;a href=&quot;#array.array.tobytes&quot;&gt;&lt;code&gt;tobytes()&lt;/code&gt;&lt;/a&gt; for clarity.</source>
          <target state="translated">버전 3.2의 새로운 기능 : 명확성을 위해 &lt;a href=&quot;#array.array.tostring&quot;&gt; &lt;code&gt;tostring()&lt;/code&gt; &lt;/a&gt; 이름이 &lt;a href=&quot;#array.array.tobytes&quot;&gt; &lt;code&gt;tobytes()&lt;/code&gt; &lt;/a&gt; 로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="65be5f1abc346b5a084ab6611d2dcd14b97b4c5c" translate="yes" xml:space="preserve">
          <source>New in version 3.2: &lt;a href=&quot;#unittest.TestCase.assertNotRegex&quot;&gt;&lt;code&gt;assertNotRegex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;a href=&quot;#unittest.TestCase.assertNotRegex&quot;&gt; &lt;code&gt;assertNotRegex()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b17191ede606c26b4c8116dfbc25448c9f8f280" translate="yes" xml:space="preserve">
          <source>New in version 3.2: &lt;code&gt;pdb.py&lt;/code&gt; now accepts a &lt;code&gt;-c&lt;/code&gt; option that executes commands as if given in a &lt;code&gt;.pdbrc&lt;/code&gt; file, see &lt;a href=&quot;#debugger-commands&quot;&gt;Debugger Commands&lt;/a&gt;.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;code&gt;pdb.py&lt;/code&gt; 는 이제 &lt;code&gt;.pdbrc&lt;/code&gt; 파일에 지정된 것처럼 명령을 실행 하는 &lt;code&gt;-c&lt;/code&gt; 옵션을 허용합니다 ( &lt;a href=&quot;#debugger-commands&quot;&gt;디버거 명령&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="fc5a5d84b89ad5a4ba8ce3020321268ef0fa4d48" translate="yes" xml:space="preserve">
          <source>New in version 3.2: &lt;em&gt;body&lt;/em&gt; can now be an iterable.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;body&lt;/em&gt; 는 이제 반복 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a92a77a7766db733546c9b77cd133915e1079c0" translate="yes" xml:space="preserve">
          <source>New in version 3.2: &lt;em&gt;data&lt;/em&gt; can be an iterable object.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;데이터&lt;/em&gt; 는 반복 가능한 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="492fab092548a082cfe9773b6e25423f9e425e63" translate="yes" xml:space="preserve">
          <source>New in version 3.2: &lt;em&gt;maxtasksperchild&lt;/em&gt;</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;maxtasksperchild&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9af04aa0a51b0152280c245269d849a5d155aaa7" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Added support for the context management protocol.</source>
          <target state="translated">버전 3.2의 새로운 기능 : 컨텍스트 관리 프로토콜에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7e70655ae33c518c88446ef6624470fc4ce9d29" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Added the ability to use &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; as a context manager.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; &lt;/a&gt; 을 컨텍스트 관리자로 사용하는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d09766d62b8d99b219d60b276118965866ee5426" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Automatic addition of the &lt;code&gt;__wrapped__&lt;/code&gt; attribute.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;code&gt;__wrapped__&lt;/code&gt; 속성 자동 추가 .</target>
        </trans-unit>
        <trans-unit id="6a2cb5a7143cca2378773c116c1731a3835404ed" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Context manager support.</source>
          <target state="translated">버전 3.2의 새로운 기능 : 컨텍스트 관리자 지원.</target>
        </trans-unit>
        <trans-unit id="e4691f22ec6af8115c8ef643b32bf896e13020ae" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Copying of the &lt;code&gt;__annotations__&lt;/code&gt; attribute by default.</source>
          <target state="translated">버전 3.2의 새로운 기능 : 기본적으로 &lt;code&gt;__annotations__&lt;/code&gt; 속성 복사</target>
        </trans-unit>
        <trans-unit id="d43b8283dd2a98a7af1fa11e7c76adbd21232c7c" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Optional &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;lineno&lt;/code&gt; attributes and arguments to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; were added.</source>
          <target state="translated">버전 3.2의 새로운 기능 : 선택적 &lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;lineno&lt;/code&gt; 속성과 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 인수 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="fafccb4e9a5405ae3b834787685cd7c2b125b7e3" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Replaces &lt;a href=&quot;#configparser.ConfigParser.readfp&quot;&gt;&lt;code&gt;readfp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;a href=&quot;#configparser.ConfigParser.readfp&quot;&gt; &lt;code&gt;readfp()&lt;/code&gt; &lt;/a&gt; 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="28b0f51bd56d33241ea9b5ddcc94c77be36c2020" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Restoration of the &lt;code&gt;rot_13&lt;/code&gt; text transform.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;code&gt;rot_13&lt;/code&gt; 텍스트 변환의 복원 .</target>
        </trans-unit>
        <trans-unit id="970ab611ee1b762f1709817732af44838b6f66a1" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Restoration of the binary transforms.</source>
          <target state="translated">버전 3.2의 새로운 기능 : 이진 변환의 복원.</target>
        </trans-unit>
        <trans-unit id="9dcceb3168131b28f25a8473e7a17f54fc795c88" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; marker.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 마커.</target>
        </trans-unit>
        <trans-unit id="b402819ef1b2aed8bcd076ddf219c4cc93fd00a5" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;annotate&lt;/em&gt; argument.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;주석&lt;/em&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="e55bd4f980e8fc073a71ff35dfc24e9dd75e20d9" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;autojunk&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;autojunk&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="2de34420d3f8e77e82c57b967288676e7b162df3" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;bjunk&lt;/em&gt; and &lt;em&gt;bpopular&lt;/em&gt; attributes.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;bjunk&lt;/em&gt; 및 &lt;em&gt;bpopular&lt;/em&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="07dfce94408fc7eb43edf07bf810590d083842d0" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;encoding&lt;/em&gt; parameter. Previously, all files were read using the default encoding for &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;인코딩&lt;/em&gt; 매개 변수. 이전에는 모든 파일을 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의 기본 인코딩을 사용하여 읽었습니다 .</target>
        </trans-unit>
        <trans-unit id="e00307d0d1ac1787c787512ca063499efdae81fb" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;exist_ok&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;exist_ok&lt;/em&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="5eff261c50725aaf56234c60b7ad321e0b6d7a28" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;nosigint&lt;/em&gt; argument. Previously, a SIGINT handler was never set by Pdb.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;nosigint&lt;/em&gt; 인수. 이전에는 PDB에서 SIGINT 핸들러를 설정하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d9d3ff17279278f1fbe533d1cb8d4a4e101a51cb" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;optimize&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;최적화&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="e360c3f1e3102b0b5025a254db53852cc697487a" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The &lt;em&gt;short_empty_elements&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.2의 새로운 기능 : &lt;em&gt;short_empty_elements&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="0d065c9ae385620cf6d16a31d56d0cbb370df8a1" translate="yes" xml:space="preserve">
          <source>New in version 3.2: The command-line options &lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; were added.</source>
          <target state="translated">버전 3.2의 새로운 기능 : 명령 행 옵션 &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-f&lt;/code&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a75b199eafd71fb28b679c45575e353e48ba2b36" translate="yes" xml:space="preserve">
          <source>New in version 3.2: This class was previously named &lt;code&gt;_TextTestResult&lt;/code&gt;. The old name still exists as an alias but is deprecated.</source>
          <target state="translated">버전 3.2의 새로운 기능 :이 클래스의 이름은 이전에 &lt;code&gt;_TextTestResult&lt;/code&gt; 입니다. 이전 이름은 여전히 ​​별칭으로 존재하지만 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82b107c9c10c5a55aee4a0e3debb2416f6131861" translate="yes" xml:space="preserve">
          <source>New in version 3.2: This function has been provided, along with &lt;a href=&quot;#logging.getLogRecordFactory&quot;&gt;&lt;code&gt;getLogRecordFactory()&lt;/code&gt;&lt;/a&gt;, to allow developers more control over how the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; representing a logging event is constructed.</source>
          <target state="translated">버전 3.2의 새로운 기능 :이 함수는 &lt;a href=&quot;#logging.getLogRecordFactory&quot;&gt; &lt;code&gt;getLogRecordFactory()&lt;/code&gt; &lt;/a&gt; 와 함께 제공되어 개발자 가 로깅 이벤트를 나타내는 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 를 구성하는 방법을보다 잘 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="196f39022abdb30b19d21c28520cda8cdeace93c" translate="yes" xml:space="preserve">
          <source>New in version 3.2: This function has been provided, along with &lt;a href=&quot;#logging.setLogRecordFactory&quot;&gt;&lt;code&gt;setLogRecordFactory()&lt;/code&gt;&lt;/a&gt;, to allow developers more control over how the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; representing a logging event is constructed.</source>
          <target state="translated">버전 3.2의 새로운 기능 :이 함수는 &lt;a href=&quot;#logging.setLogRecordFactory&quot;&gt; &lt;code&gt;setLogRecordFactory()&lt;/code&gt; &lt;/a&gt; 와 함께 제공되어 개발자 가 로깅 이벤트를 나타내는 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 를 구성하는 방법을보다 잘 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5feff224bf3a58e8d61eacdd8a8522e0dbed87b0" translate="yes" xml:space="preserve">
          <source>New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2.</source>
          <target state="translated">버전 3.2의 새로운 기능 :이 함수는 Python 3.0에서 처음 제거 된 다음 Python 3.2에서 다시 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="da106e3ee3289214b471fcbb56de045708a54150" translate="yes" xml:space="preserve">
          <source>New in version 3.2: Windows support.</source>
          <target state="translated">버전 3.2의 새로운 기능 : Windows 지원.</target>
        </trans-unit>
        <trans-unit id="e656aeccfdd3bd906cae00fa7c0478f89eb5d3a9" translate="yes" xml:space="preserve">
          <source>New in version 3.3.</source>
          <target state="translated">버전 3.3의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="f3e98ffdcb282b0853dcb031735ce601012ab4f1" translate="yes" xml:space="preserve">
          <source>New in version 3.3: &lt;code&gt;clear()&lt;/code&gt; and &lt;code&gt;copy()&lt;/code&gt; methods.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;code&gt;clear()&lt;/code&gt; 및 &lt;code&gt;copy()&lt;/code&gt; 메서드</target>
        </trans-unit>
        <trans-unit id="c5e4a238bfa33077d729fa48ecf1b789826f4102" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added support for specifying &lt;em&gt;path&lt;/em&gt; as a file descriptor on some platforms.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 일부 플랫폼에서 &lt;em&gt;경로&lt;/em&gt; 를 파일 설명 자로 지정하는 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="16af71ee4e36ec0cae6b181b694b7f51956f7a0c" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added support for specifying &lt;em&gt;path&lt;/em&gt; as an open file descriptor for &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 의 열린 파일 디스크립터로 &lt;em&gt;경로&lt;/em&gt; 를 지정하는 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="038d2a2d4a390798684aa8f618e2a86258a63438" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added support for specifying &lt;em&gt;path&lt;/em&gt; as an open file descriptor, and the &lt;em&gt;dir_fd&lt;/em&gt; and &lt;em&gt;follow_symlinks&lt;/em&gt; arguments.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 열린 파일 디스크립터로 &lt;em&gt;경로&lt;/em&gt; 를 지정 하고 &lt;em&gt;dir_fd&lt;/em&gt; 및 &lt;em&gt;follow_symlinks&lt;/em&gt; 인수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c61f8f029e31102256de167c06ecfbdb5b027ab4" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added support for specifying &lt;em&gt;path&lt;/em&gt; as an open file descriptor, and the &lt;em&gt;dir_fd&lt;/em&gt;, &lt;em&gt;follow_symlinks&lt;/em&gt;, and &lt;em&gt;ns&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 열린 파일 디스크립터로 &lt;em&gt;path&lt;/em&gt; 및 &lt;em&gt;dir_fd&lt;/em&gt; , &lt;em&gt;follow_symlinks&lt;/em&gt; 및 &lt;em&gt;ns&lt;/em&gt; 매개 변수 를 지정하는 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c25592d4be380fcbfc21e2a7e95a3669a8c8becd" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added support for specifying &lt;em&gt;path&lt;/em&gt; as an open file descriptor.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 열린 파일 설명 자로 &lt;em&gt;경로&lt;/em&gt; 를 지정하기위한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="76739bbab39d5c2710046bf45eec1397909326fd" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 단항 더하기, 단항 빼기 및 전체 다중 세트 작업에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="046d02c5d1094d36422bcd5465bc69373e23f681" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added the &lt;a href=&quot;#os.stat_result.st_atime_ns&quot;&gt;&lt;code&gt;st_atime_ns&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.stat_result.st_mtime_ns&quot;&gt;&lt;code&gt;st_mtime_ns&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.stat_result.st_ctime_ns&quot;&gt;&lt;code&gt;st_ctime_ns&lt;/code&gt;&lt;/a&gt; members.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;a href=&quot;#os.stat_result.st_atime_ns&quot;&gt; &lt;code&gt;st_atime_ns&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.stat_result.st_mtime_ns&quot;&gt; &lt;code&gt;st_mtime_ns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.stat_result.st_ctime_ns&quot;&gt; &lt;code&gt;st_ctime_ns&lt;/code&gt; &lt;/a&gt; 멤버가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7a588e30cae71f1b15d920765c3d80c0bf7800b8" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added the &lt;em&gt;dir_fd&lt;/em&gt; and &lt;em&gt;follow_symlinks&lt;/em&gt; arguments, specifying a file descriptor instead of a path.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 경로 대신 파일 설명자를 지정 하여 &lt;em&gt;dir_fd&lt;/em&gt; 및 &lt;em&gt;follow_symlinks&lt;/em&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="216100c31adc18c23bb9e9b560bc677eca6633bd" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added the &lt;em&gt;dir_fd&lt;/em&gt; argument, and now allow &lt;em&gt;target_is_directory&lt;/em&gt; on non-Windows platforms.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;em&gt;dir_fd&lt;/em&gt; 인수가 추가 되었으며 이제 Windows 이외의 플랫폼에서 &lt;em&gt;target_is_directory&lt;/em&gt; 를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="cb1fa9f44f4b3e986271d3360090ef64263dfa98" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Added the &lt;em&gt;src_dir_fd&lt;/em&gt;, &lt;em&gt;dst_dir_fd&lt;/em&gt;, and &lt;em&gt;follow_symlinks&lt;/em&gt; arguments.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;em&gt;src_dir_fd&lt;/em&gt; , &lt;em&gt;dst_dir_fd&lt;/em&gt; 및 &lt;em&gt;follow_symlinks&lt;/em&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="690563f7aa9f77702829a99858275338d41ffc11" translate="yes" xml:space="preserve">
          <source>New in version 3.3: All the above &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; subclasses were added.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 위의 모든 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 서브 클래스가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d7c35a84efd3292c4e322bb6cd08bf0c445e5d0c" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Connection objects now support the context management protocol &amp;ndash; see &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;Context Manager Types&lt;/a&gt;. &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; returns the connection object, and &lt;a href=&quot;stdtypes#contextmanager.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;#multiprocessing.connection.Connection.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 연결 객체는 이제 컨텍스트 관리 프로토콜을 지원합니다 (컨텍스트 &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;관리자 유형&lt;/a&gt; 참조) . &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 는 연결 객체를 반환하고 &lt;a href=&quot;stdtypes#contextmanager.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#multiprocessing.connection.Connection.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="43b79ec2cfdf493c4c7ba024e42791b064af21b0" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Formerly, this module was part of the &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 이전에는이 ​​모듈이 &lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈의 일부였습니다 .</target>
        </trans-unit>
        <trans-unit id="7ebcbd28e34b67cd966b999669d0242ada456632" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Listener objects now support the context management protocol &amp;ndash; see &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;Context Manager Types&lt;/a&gt;. &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; returns the listener object, and &lt;a href=&quot;stdtypes#contextmanager.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;#multiprocessing.connection.Listener.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 리스너 객체는 이제 컨텍스트 관리 프로토콜을 지원합니다 (컨텍스트 &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;관리자 유형&lt;/a&gt; 참조) . &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 는 리스너 객체를 반환하고 &lt;a href=&quot;stdtypes#contextmanager.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#multiprocessing.connection.Listener.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="70103fb68f7f0cfa32aba69ba39031a736a2d76b" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Pool objects now support the context management protocol &amp;ndash; see &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;Context Manager Types&lt;/a&gt;. &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; returns the pool object, and &lt;a href=&quot;stdtypes#contextmanager.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 풀 객체는 이제 컨텍스트 관리 프로토콜을 지원합니다 (컨텍스트 &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;관리자 유형&lt;/a&gt; 참조) . &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 는 풀 객체를 반환하고 &lt;a href=&quot;stdtypes#contextmanager.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="0564ad09da5d11fa74ab8521856c7a0ee08a4a38" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Some operating systems could support additional values, like &lt;code&gt;os.SEEK_HOLE&lt;/code&gt; or &lt;code&gt;os.SEEK_DATA&lt;/code&gt;.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 일부 운영 체제는 &lt;code&gt;os.SEEK_HOLE&lt;/code&gt; 또는 &lt;code&gt;os.SEEK_DATA&lt;/code&gt; 와 같은 추가 값을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28848c417a2cec6f368a3d64351da7441b8eda2f" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Some operating systems could support additional values, like &lt;code&gt;os.SEEK_HOLE&lt;/code&gt; or &lt;code&gt;os.SEEK_DATA&lt;/code&gt;. The valid values for a file could depend on it being open in text or binary mode.</source>
          <target state="translated">버전 3.3의 새로운 기능 : 일부 운영 체제는 &lt;code&gt;os.SEEK_HOLE&lt;/code&gt; 또는 &lt;code&gt;os.SEEK_DATA&lt;/code&gt; 와 같은 추가 값을 지원할 수 있습니다. 파일의 유효한 값은 텍스트 또는 이진 모드로 열린 파일에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8db3552cce786db5f51c5e10688a0e7ea38316b" translate="yes" xml:space="preserve">
          <source>New in version 3.3: Support for Chrome/Chromium has been added.</source>
          <target state="translated">버전 3.3의 새로운 기능 : Chrome / Chromium 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e3a14a6878f1d57e3a61755e1e35f512ac6cf6a9" translate="yes" xml:space="preserve">
          <source>New in version 3.3: The &lt;a href=&quot;#range.start&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#range.stop&quot;&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#range.step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;a href=&quot;#range.start&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#range.stop&quot;&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#range.step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="738beaa1df24e84cceeec4368cebe369172c2a07" translate="yes" xml:space="preserve">
          <source>New in version 3.3: The &lt;a href=&quot;#subprocess.SubprocessError&quot;&gt;&lt;code&gt;SubprocessError&lt;/code&gt;&lt;/a&gt; base class was added.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;a href=&quot;#subprocess.SubprocessError&quot;&gt; &lt;code&gt;SubprocessError&lt;/code&gt; &lt;/a&gt; 기본 클래스가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd2ee4ce23d4cda751ffdf5ed2ab607d0320d229" translate="yes" xml:space="preserve">
          <source>New in version 3.3: The &lt;em&gt;dir_fd&lt;/em&gt; argument.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;em&gt;dir_fd&lt;/em&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="8bbb7dcfc93a3256da3e77e30128896f8934e79e" translate="yes" xml:space="preserve">
          <source>New in version 3.3: The &lt;em&gt;dir_fd&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;em&gt;dir_fd&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="8e3679a20a6466e36ee13269b95778590402cdc8" translate="yes" xml:space="preserve">
          <source>New in version 3.3: The &lt;em&gt;follow_symlinks&lt;/em&gt; argument.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;em&gt;follow_symlinks&lt;/em&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="f5a1bcb4d58f63caf511ef4af7b5a61495f919de" translate="yes" xml:space="preserve">
          <source>New in version 3.3: The &lt;em&gt;src_dir_fd&lt;/em&gt; and &lt;em&gt;dst_dir_fd&lt;/em&gt; arguments.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;em&gt;src_dir_fd&lt;/em&gt; 및 &lt;em&gt;dst_dir_fd&lt;/em&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="959865bf3e479ce8479a65e679ed0d30ba7e0c4b" translate="yes" xml:space="preserve">
          <source>New in version 3.3: The &lt;em&gt;timeout&lt;/em&gt; argument was added.</source>
          <target state="translated">버전 3.3의 새로운 기능 : &lt;em&gt;timeout&lt;/em&gt; 인수가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff5f89afe35355ca3e836deef3c91bc2e3c948b4" translate="yes" xml:space="preserve">
          <source>New in version 3.3: This error used to be a subtype of &lt;a href=&quot;exceptions#IOError&quot;&gt;&lt;code&gt;IOError&lt;/code&gt;&lt;/a&gt;, which is now an alias of &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.3의 새로운 기능 :이 오류는 &lt;a href=&quot;exceptions#IOError&quot;&gt; &lt;code&gt;IOError&lt;/code&gt; &lt;/a&gt; 의 하위 유형이었으며 이제는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="41224dc3ad1482785fdd83d4be25d59287870563" translate="yes" xml:space="preserve">
          <source>New in version 3.4.</source>
          <target state="translated">버전 3.4의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="c2d2413b8a3a54c5ac894c0e648d044eed2cfc3a" translate="yes" xml:space="preserve">
          <source>New in version 3.4.2.</source>
          <target state="translated">버전 3.4.2의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="3d45319c8b08d09575a413772fc1dfd31f6be0bd" translate="yes" xml:space="preserve">
          <source>New in version 3.4.4.</source>
          <target state="translated">버전 3.4.4의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="d3fc5c5c6b68de9938f037f211d874194800b33d" translate="yes" xml:space="preserve">
          <source>New in version 3.4: &lt;code&gt;--bind&lt;/code&gt; argument was introduced.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;code&gt;--bind&lt;/code&gt; 인수가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="04e6b7704b4197ee6a706885b339be509977b09a" translate="yes" xml:space="preserve">
          <source>New in version 3.4: &lt;code&gt;fish&lt;/code&gt; and &lt;code&gt;csh&lt;/code&gt; activation scripts.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;code&gt;fish&lt;/code&gt; 및 &lt;code&gt;csh&lt;/code&gt; 활성화 스크립트.</target>
        </trans-unit>
        <trans-unit id="07c6d19e4ee989f8d0d6e80bb2cbc4015ab1781f" translate="yes" xml:space="preserve">
          <source>New in version 3.4: &lt;em&gt;context&lt;/em&gt;</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;em&gt;컨텍스트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="936964700ac0e4fd4816f6dbc756a4bbb96008b9" translate="yes" xml:space="preserve">
          <source>New in version 3.4: Support for detecting non-root mount points on Windows.</source>
          <target state="translated">버전 3.4의 새로운 기능 : Windows에서 루트가 아닌 마운트 포인트 감지 지원.</target>
        </trans-unit>
        <trans-unit id="abf63dbf0eed08509d121c30dc1546ccdf810093" translate="yes" xml:space="preserve">
          <source>New in version 3.4: The &lt;code&gt;-o&lt;/code&gt; command line option.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;code&gt;-o&lt;/code&gt; 명령 줄 옵션.</target>
        </trans-unit>
        <trans-unit id="66caeee5dc102404c5331845b0c15981aad98a8a" translate="yes" xml:space="preserve">
          <source>New in version 3.4: The &lt;em&gt;default&lt;/em&gt; keyword-only argument.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;em&gt;기본&lt;/em&gt; 키워드 전용 인수.</target>
        </trans-unit>
        <trans-unit id="4a4446cd72af1035874858d7979681228958c99b" translate="yes" xml:space="preserve">
          <source>New in version 3.4: The &lt;em&gt;encodings&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; keyword arguments.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 키워드 인수.</target>
        </trans-unit>
        <trans-unit id="6d2024551b24076a993344063174df6ead408974" translate="yes" xml:space="preserve">
          <source>New in version 3.4: The &lt;em&gt;filterfunc&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;em&gt;filterfunc&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="b83a71ae56ef44ebfee3c63e25b3ec77ed9bfc29" translate="yes" xml:space="preserve">
          <source>New in version 3.4: The &lt;em&gt;map&lt;/em&gt; constructor argument.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;em&gt;맵&lt;/em&gt; 생성자 인수.</target>
        </trans-unit>
        <trans-unit id="8101eef7ac9068476ab49bb67e1a8ce316c1da05" translate="yes" xml:space="preserve">
          <source>New in version 3.4: The &lt;em&gt;short_empty_elements&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.4의 새로운 기능 : &lt;em&gt;short_empty_elements&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="9f6e0effa06c3e5c138d8490e703f490b0039368" translate="yes" xml:space="preserve">
          <source>New in version 3.4: is_global</source>
          <target state="translated">버전 3.4의 새로운 기능 : is_global</target>
        </trans-unit>
        <trans-unit id="1f837cd28063a6c218f31e72720b5003175aed01" translate="yes" xml:space="preserve">
          <source>New in version 3.5.</source>
          <target state="translated">버전 3.5의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="1fa95c8a406c55887ed636be5dccd00a7a0fa295" translate="yes" xml:space="preserve">
          <source>New in version 3.5.1.</source>
          <target state="translated">버전 3.5.1의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="8b612aef28c4f185839e563a8a96375f82700410" translate="yes" xml:space="preserve">
          <source>New in version 3.5.2.</source>
          <target state="translated">버전 3.5.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="2c7957076db9f4d38f7ee1ad92950f56a72edea9" translate="yes" xml:space="preserve">
          <source>New in version 3.5.3.</source>
          <target state="translated">버전 3.5.3의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="07321da105ae55ff5d5709eae1f53e75964ddc33" translate="yes" xml:space="preserve">
          <source>New in version 3.5.4.</source>
          <target state="translated">버전 3.5.4의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="3fbc5dfdcbe6f0de84bdbc30382ee50720861f9c" translate="yes" xml:space="preserve">
          <source>New in version 3.5: &lt;code&gt;follow_wrapped&lt;/code&gt; parameter. Pass &lt;code&gt;False&lt;/code&gt; to get a signature of &lt;code&gt;callable&lt;/code&gt; specifically (&lt;code&gt;callable.__wrapped__&lt;/code&gt; will not be used to unwrap decorated callables.)</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;follow_wrapped&lt;/code&gt; 매개 변수. 패스 &lt;code&gt;False&lt;/code&gt; 의 서명을받을 &lt;code&gt;callable&lt;/code&gt; 특히 ( &lt;code&gt;callable.__wrapped__&lt;/code&gt; 장식 callables 랩을 해제하는 데 사용되지 않습니다를.)</target>
        </trans-unit>
        <trans-unit id="9e2d52bce291ba21a1b94d4b005b1cf7dc019b90" translate="yes" xml:space="preserve">
          <source>New in version 3.5: &lt;em&gt;quote_via&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;quote_via&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="0a2103b4477c36713c1b4425a3142a28baa40aa4" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Added &lt;code&gt;is_authenticated&lt;/code&gt; support.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;is_authenticated&lt;/code&gt; 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0178c262a4c0123cec8f5bef7190a7211f72daae" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Added the &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt;&lt;code&gt;st_file_attributes&lt;/code&gt;&lt;/a&gt; member on Windows.</source>
          <target state="translated">버전 3.5의 새로운 기능 : Windows에 &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt; &lt;code&gt;st_file_attributes&lt;/code&gt; &lt;/a&gt; 멤버가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8df129ebe6df04e6f5367d827d4028abd2387a31" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Previously, &lt;a href=&quot;#http.client.BadStatusLine&quot;&gt;&lt;code&gt;BadStatusLine&lt;/code&gt;&lt;/a&gt;&lt;code&gt;('')&lt;/code&gt; was raised.</source>
          <target state="translated">버전 3.5의 새로운 기능 : 이전에는 &lt;a href=&quot;#http.client.BadStatusLine&quot;&gt; &lt;code&gt;BadStatusLine&lt;/code&gt; &lt;/a&gt; &lt;code&gt;('')&lt;/code&gt; 이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="9180aafc542f6e962e2074854b1f38f5061dcdf6" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Previously, a plain &lt;a href=&quot;#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; was raised.</source>
          <target state="translated">버전 3.5의 새로운 기능 : 이전에는 일반 &lt;a href=&quot;#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="3b54ddd1a8adfffd3e1ed259fed23234d3a80add" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Support for internationalized addresses (&lt;code&gt;SMTPUTF8&lt;/code&gt;).</source>
          <target state="translated">버전 3.5의 새로운 기능 : 국제화 된 주소 지원 ( &lt;code&gt;SMTPUTF8&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="146b7ebb3f774b3f489ea95a898318e2a4680f5a" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt;&lt;code&gt;enable()&lt;/code&gt;&lt;/a&gt; method itself, and &lt;a href=&quot;https://tools.ietf.org/html/rfc6855.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 6855&lt;/strong&gt;&lt;/a&gt; support.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt; &lt;code&gt;enable()&lt;/code&gt; &lt;/a&gt; 메소드 자체 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6855.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 6855&lt;/strong&gt;&lt;/a&gt; 지원.</target>
        </trans-unit>
        <trans-unit id="3d5702ae33ccc35d4ec27c96ab0f6748c1bfbbce" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;code&gt;'namereplace'&lt;/code&gt; error handler.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;'namereplace'&lt;/code&gt; 오류 처리기.</target>
        </trans-unit>
        <trans-unit id="c97b2effe0e40cd82111946917872bd69cee668e" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;em&gt;decode_data&lt;/em&gt; and &lt;em&gt;enable_SMTPUTF8&lt;/em&gt; constructor parameters, and the &lt;em&gt;kwargs&lt;/em&gt; parameter to &lt;a href=&quot;#smtpd.SMTPServer.process_message&quot;&gt;&lt;code&gt;process_message()&lt;/code&gt;&lt;/a&gt; when &lt;em&gt;decode_data&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;decode_data&lt;/em&gt; 및 &lt;em&gt;enable_SMTPUTF8&lt;/em&gt; 생성자 매개 변수 및 &lt;em&gt;decode_data&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;em&gt;kwargs&lt;/em&gt; 매개 변수가 &lt;a href=&quot;#smtpd.SMTPServer.process_message&quot;&gt; &lt;code&gt;process_message()&lt;/code&gt; &lt;/a&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="503c88f7cc88d9c109004b72250f22c5abdb8141" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;em&gt;exr&lt;/em&gt; and &lt;em&gt;webp&lt;/em&gt; formats were added.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;exr&lt;/em&gt; 및 &lt;em&gt;webp&lt;/em&gt; 형식이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3cfbf13ed17363441f3df8820387841a221acb2f" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;em&gt;mangle_from_&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;mangle_from_&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="b705147dd17b73bdb5144032054ce3ee0a848bed" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The SMTPUTF8 extension (&lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt;) is now supported.</source>
          <target state="translated">버전 3.5의 새로운 기능 : SMTPUTF8 확장 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; )이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4071071236fe8569928d891b12576f7b86895ed7" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The command-line option &lt;code&gt;--locals&lt;/code&gt;.</source>
          <target state="translated">버전 3.5의 새로운 기능 : 명령 줄 옵션 &lt;code&gt;--locals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f069158efc3960b336f0767e900a4a5a3e81e366" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The name &lt;code&gt;assertNotRegexpMatches&lt;/code&gt; is a deprecated alias for &lt;a href=&quot;#unittest.TestCase.assertNotRegex&quot;&gt;&lt;code&gt;assertNotRegex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;assertNotRegexpMatches&lt;/code&gt; 라는 이름 은 &lt;a href=&quot;#unittest.TestCase.assertNotRegex&quot;&gt; &lt;code&gt;assertNotRegex()&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="19bf2295406fe646f85406c7590ce23f4c62ad62" translate="yes" xml:space="preserve">
          <source>New in version 3.6.</source>
          <target state="translated">버전 3.6의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="90349cc2f262d4c23d65ab39676f28264f9ab398" translate="yes" xml:space="preserve">
          <source>New in version 3.6.0.</source>
          <target state="translated">버전 3.6.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="45594f8e6c19eac8ab677c7056e00b26cfb95c1f" translate="yes" xml:space="preserve">
          <source>New in version 3.6.1.</source>
          <target state="translated">버전 3.6.1의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="5a7ee2ea584d1e3940ee533dbeaa4e452bd13404" translate="yes" xml:space="preserve">
          <source>New in version 3.6.1: The &lt;em&gt;filenames&lt;/em&gt; parameter accepts a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">버전 3.6.1의 새로운 기능 : &lt;em&gt;filenames&lt;/em&gt; 매개 변수는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한 객체를&lt;/a&gt; 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="5e7a6843b86d2ae87bc59ed04e6f809cf47c50e6" translate="yes" xml:space="preserve">
          <source>New in version 3.6.2.</source>
          <target state="translated">버전 3.6.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="80dfc6066f14bf6496d45305c08af7a4c450a97c" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;a href=&quot;#hashlib.blake2b&quot;&gt;&lt;code&gt;blake2b()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#hashlib.blake2s&quot;&gt;&lt;code&gt;blake2s()&lt;/code&gt;&lt;/a&gt; were added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;a href=&quot;#hashlib.blake2b&quot;&gt; &lt;code&gt;blake2b()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#hashlib.blake2s&quot;&gt; &lt;code&gt;blake2s()&lt;/code&gt; &lt;/a&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4340416fdc1fa009b4460cbe3e9816c6f0043daf" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a2feeb245024eb57add73d00ab775abcb904e866" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;%G&lt;/code&gt;, &lt;code&gt;%u&lt;/code&gt; and &lt;code&gt;%V&lt;/code&gt; were added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;%G&lt;/code&gt; , &lt;code&gt;%u&lt;/code&gt; 및 &lt;code&gt;%V&lt;/code&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c218c216bff866c0b87e532df3da0d215cc23a5f" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;EPOLLEXCLUSIVE&lt;/code&gt; was added. It&amp;rsquo;s only supported by Linux Kernel 4.5 or later.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;EPOLLEXCLUSIVE&lt;/code&gt; 가 추가되었습니다. Linux Kernel 4.5 이상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="67f3b398e277e32be1c6a0466247dee478994e07" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;Flag&lt;/code&gt;, &lt;code&gt;IntFlag&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;Flag&lt;/code&gt; , &lt;code&gt;IntFlag&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d27e2376c72696bcc77e2fe6f41dd1602bc5773c" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;_missing_&lt;/code&gt;, &lt;code&gt;_order_&lt;/code&gt;, &lt;code&gt;_generate_next_value_&lt;/code&gt;</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;_missing_&lt;/code&gt; , &lt;code&gt;_order_&lt;/code&gt; , &lt;code&gt;_generate_next_value_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10e005437ad547a8fd8e2ccd4b8b20d9e4c5dff" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; were added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="12ace1f101bca9a308b177329a35f1d66d6db703" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 매개 변수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e301bee116d339912a92c894a8a22f3f1fa59962" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added support for the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; protocol and the &lt;a href=&quot;#os.scandir.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method. If a &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; iterator is neither exhausted nor explicitly closed a &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; will be emitted in its destructor.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;컨텍스트 관리자&lt;/a&gt; 프로토콜 및 &lt;a href=&quot;#os.scandir.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 지원이 추가되었습니다 . 경우 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 반복자는 어느 쪽도 폐쇄 명시 적으로 소모되지도 않은 &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; &lt;/a&gt; 소멸자에서 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="b402613c2d781a5a7bb0dd32b82d79f1ecb4727b" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added the &lt;code&gt;fold&lt;/code&gt; argument.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;fold&lt;/code&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="00930151a8d899f4720871c54b11a77ab5264e8f" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added the &lt;code&gt;prompt&lt;/code&gt; parameter</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;prompt&lt;/code&gt; 매개 변수 추가</target>
        </trans-unit>
        <trans-unit id="5f1a9af93f36ac766f8daa131d6c0d3f78622179" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added the &lt;em&gt;timespec&lt;/em&gt; argument.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;timespec&lt;/em&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7066aa1da03dd2863a3d30aa190f6000662f4314" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Chunked encoding support. The &lt;em&gt;encode_chunked&lt;/em&gt; parameter was added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : 청크 인코딩 지원. &lt;em&gt;encode_chunked&lt;/em&gt; 매개 변수는 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a58ba40e7a25c57becebc3eef2d13a66d5397af8" translate="yes" xml:space="preserve">
          <source>New in version 3.6: SHA3 (Keccak) and SHAKE constructors &lt;code&gt;sha3_224()&lt;/code&gt;, &lt;code&gt;sha3_256()&lt;/code&gt;, &lt;code&gt;sha3_384()&lt;/code&gt;, &lt;code&gt;sha3_512()&lt;/code&gt;, &lt;code&gt;shake_128()&lt;/code&gt;, &lt;code&gt;shake_256()&lt;/code&gt;.</source>
          <target state="translated">버전 3.6의 새로운 기능 : SHA3 (Keccak) 및 SHAKE 생성자 &lt;code&gt;sha3_224()&lt;/code&gt; , &lt;code&gt;sha3_256()&lt;/code&gt; , &lt;code&gt;sha3_384()&lt;/code&gt; , &lt;code&gt;sha3_512()&lt;/code&gt; , &lt;code&gt;shake_128()&lt;/code&gt; , &lt;code&gt;shake_256()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba67193ad20bf5f9e114ef18a7615f3b1a6f3fc7" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">버전 3.6의 새로운 기능 : 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32a8a06257d0d3aa4bc5a3c9830582cf1e8ac1b0" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-27&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details, and for a reference example of a &lt;em&gt;finalizer&lt;/em&gt; method see the implementation of &lt;code&gt;asyncio.Loop.shutdown_asyncgens&lt;/code&gt; in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_events.py&quot;&gt;Lib/asyncio/base_events.py&lt;/a&gt;</source>
          <target state="translated">새로운 버전 3.6 : 참조 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-27&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; 자세한 내용 및의 참조 예를 들어 &lt;em&gt;종료 자&lt;/em&gt; 의 구현 볼 방법 &lt;code&gt;asyncio.Loop.shutdown_asyncgens&lt;/code&gt; 에서 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_events.py&quot;&gt;/ asyncio / base_events.py 해방을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0029940bca23ccdb728fe00850c420e066576083" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0529&quot; id=&quot;index-31&quot;&gt;&lt;strong&gt;PEP 529&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">버전 3.6의 새로운 기능 : 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0529&quot; id=&quot;index-31&quot;&gt;&lt;strong&gt;PEP 529&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4aac78a8599305666d1bcd98d489c9b474ee017" translate="yes" xml:space="preserve">
          <source>New in version 3.6: The &lt;em&gt;strict&lt;/em&gt; argument (pre-3.6 behavior is strict).</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;엄격한&lt;/em&gt; 인수 (3.6 이전 동작이 엄격함).</target>
        </trans-unit>
        <trans-unit id="ed2cdfb400d26244abead12bdb67496c73a450a0" translate="yes" xml:space="preserve">
          <source>New in version 3.6: The &lt;em&gt;thread_name_prefix&lt;/em&gt; argument was added to allow users to control the &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt; names for worker threads created by the pool for easier debugging.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;thread_name_prefix&lt;/em&gt; 인수가 추가되어 사용자가 &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 을 제어 할 수 있습니다. 더 쉬운 디버깅을 위해 풀에서 만든 작업자 스레드 의 스레드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bd28c614713bbf071342d57c2928588052675b48" translate="yes" xml:space="preserve">
          <source>New in version 3.7.</source>
          <target state="translated">버전 3.7의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="ab8b0d832441ec9f8afe55c3080968bfbf5d3b44" translate="yes" xml:space="preserve">
          <source>New in version 3.7.1.</source>
          <target state="translated">버전 3.7.1의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="c9fd11c42763cb36ec0c19d3ced88d96a640764b" translate="yes" xml:space="preserve">
          <source>New in version 3.7.2.</source>
          <target state="translated">버전 3.7.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="9a57a48cac73d938901b1d889265048d7b45f13b" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;--directory&lt;/code&gt; specify alternate directory</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;--directory&lt;/code&gt; 는 대체 디렉토리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2909fbd69c7afbaa6cf6f31b68ba8de890bc59f0" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;A_ITALIC&lt;/code&gt; was added.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;A_ITALIC&lt;/code&gt; 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a466235e323520983f5de7f81ecbc6daa3c3354" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;_ignore_&lt;/code&gt;</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;_ignore_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adde274e405e80348f0778a3079bdac06f47c1e9" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;pdb.py&lt;/code&gt; now accepts a &lt;code&gt;-m&lt;/code&gt; option that execute modules similar to the way &lt;code&gt;python3 -m&lt;/code&gt; does. As with a script, the debugger will pause execution just before the first line of the module.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;pdb.py&lt;/code&gt; 는 &lt;code&gt;python3 -m&lt;/code&gt; 과 유사한 모듈을 실행 하는 &lt;code&gt;-m&lt;/code&gt; 옵션을 허용합니다 . 스크립트와 마찬가지로 디버거는 모듈의 첫 번째 줄 직전에 실행을 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="0348eea632d38a741b35d7722942981b7e29f1ce" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;em&gt;text&lt;/em&gt; was added as a more readable alias for &lt;em&gt;universal_newlines&lt;/em&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;텍스트&lt;/em&gt; 가 &lt;em&gt;universal_newlines에&lt;/em&gt; 대한 읽기 쉬운 별명으로 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5f0baef37767767dd3f2cb730f45d1b063439fc7" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;strong&gt;Important:&lt;/strong&gt; this has been added to asyncio in Python 3.7 &lt;em&gt;on a provisional basis&lt;/em&gt;! This is as an experimental API that might be changed or removed completely in Python 3.8.</source>
          <target state="translated">새로운 버전 3.7 : &lt;strong&gt;중요 :&lt;/strong&gt; 이 파이썬 3.7에 asyncio 추가되었습니다 &lt;em&gt;잠정적으로&lt;/em&gt; ! 이것은 Python 3.8에서 완전히 변경되거나 제거 될 수있는 실험용 API입니다.</target>
        </trans-unit>
        <trans-unit id="f3a4eca7b00b876cf18c98faef57e563aee90833" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added &lt;code&gt;f_fsid&lt;/code&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;f_fsid&lt;/code&gt; 추가 .</target>
        </trans-unit>
        <trans-unit id="acbec27175c9a57e694aea3647f0f2d4e44b15b1" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; and &lt;em&gt;start_serving&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; 및 &lt;em&gt;start_serving&lt;/em&gt; 매개 변수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="02404564795309b1c84708a7dc54ae19f294229e" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;a href=&quot;#os.stat_result.st_fstype&quot;&gt;&lt;code&gt;st_fstype&lt;/code&gt;&lt;/a&gt; member to Solaris/derivatives.</source>
          <target state="translated">버전 3.7의 새로운 기능 : Solaris / 파생에 &lt;a href=&quot;#os.stat_result.st_fstype&quot;&gt; &lt;code&gt;st_fstype&lt;/code&gt; &lt;/a&gt; 멤버를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="4825919b8ce59ba82d22b5bba489218e7eb00e42" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;code&gt;-m&lt;/code&gt; option to &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; 에&lt;/a&gt; &lt;code&gt;-m&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="08036b38411b712da487efc5c9de3f5c019a9bfd" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;em&gt;filter&lt;/em&gt; and &lt;em&gt;compressed&lt;/em&gt; arguments.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;필터&lt;/em&gt; 및 &lt;em&gt;압축&lt;/em&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ce490b7adba761d51637a993e78564658a585b7c" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;em&gt;text&lt;/em&gt; parameter as an alias for &lt;em&gt;universal_newlines&lt;/em&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;텍스트&lt;/em&gt; 매개 변수를 &lt;em&gt;universal_newlines&lt;/em&gt; 의 별명으로 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b546280fb3d0cd05c36e366475e058b3bfb9e3cf" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the SortKey enum.</source>
          <target state="translated">버전 3.7의 새로운 기능 : SortKey 열거 형이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="410aff229467eac243173224687c8e5967e89a41" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Descriptors for nested definitions. They are accessed through the new children attribute. Each has a new parent attribute.</source>
          <target state="translated">버전 3.7의 새로운 기능 : 중첩 정의를위한 설명자. 새 하위 속성을 통해 액세스합니다. 각각 새로운 부모 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30a5ef6e12e6aa72ab9eaa507a8c20cae7e496f" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The &lt;em&gt;filenames&lt;/em&gt; parameter accepts a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;filenames&lt;/em&gt; 매개 변수는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="493a985537bd7b9d798cb8594ee5777373a89a86" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; and &lt;em&gt;start_serving&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; 및 &lt;em&gt;start_serving&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="f67f29ad67b51dd6b7b13f7df829ff2ca08cd222" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="338f24ef253909c3bf5579f812dd70f28bc15ad5" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The built-in &lt;a href=&quot;functions#breakpoint&quot;&gt;&lt;code&gt;breakpoint()&lt;/code&gt;&lt;/a&gt;, when called with defaults, can be used instead of &lt;code&gt;import pdb; pdb.set_trace()&lt;/code&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : 기본적으로 호출 될 때 &lt;code&gt;import pdb; pdb.set_trace()&lt;/code&gt; 대신 내장 된 &lt;a href=&quot;functions#breakpoint&quot;&gt; &lt;code&gt;breakpoint()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 . pdb.set_trace () .</target>
        </trans-unit>
        <trans-unit id="7b44bee6a8a9a71004cf5c288fd7ae64eb6f752b" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The command-line option &lt;code&gt;-k&lt;/code&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : 명령 행 옵션 &lt;code&gt;-k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0aef538c8351307b1d3b281db6329d7cb7bec872" translate="yes" xml:space="preserve">
          <source>New in version 3.7: __breakpointhook__</source>
          <target state="translated">버전 3.7의 새로운 기능 : __breakpointhook__</target>
        </trans-unit>
        <trans-unit id="d47b26a1d8dd776fc7c16b2a5c0deac1fe3b72d5" translate="yes" xml:space="preserve">
          <source>New in version 3.8.</source>
          <target state="translated">버전 3.8의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="cd6669aa182efb34ab7412c772c8149990945b82" translate="yes" xml:space="preserve">
          <source>New in version 3.8: &lt;code&gt;--bind&lt;/code&gt; argument enhanced to support IPv6</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;--bind&lt;/code&gt; 인수가 IPv6을 지원하도록 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="152fbdc9d06de500d8f88db67583d3d091f0e3fe" translate="yes" xml:space="preserve">
          <source>New in version 3.8: &lt;code&gt;ast.PyCF_ALLOW_TOP_LEVEL_AWAIT&lt;/code&gt; can now be passed in flags to enable support for top-level &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;async for&lt;/code&gt;, and &lt;code&gt;async with&lt;/code&gt;.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;ast.PyCF_ALLOW_TOP_LEVEL_AWAIT&lt;/code&gt; 를 플래그로 전달하여 최상위 &lt;code&gt;await&lt;/code&gt; , &lt;code&gt;async for&lt;/code&gt; 및 &lt;code&gt;async with&lt;/code&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f75a638f151f376d645945dad75c62bc6c93b237" translate="yes" xml:space="preserve">
          <source>New in version 3.8: &lt;em&gt;order&lt;/em&gt; can be {&amp;lsquo;C&amp;rsquo;, &amp;lsquo;F&amp;rsquo;, &amp;lsquo;A&amp;rsquo;}. When &lt;em&gt;order&lt;/em&gt; is &amp;lsquo;C&amp;rsquo; or &amp;lsquo;F&amp;rsquo;, the data of the original array is converted to C or Fortran order. For contiguous views, &amp;lsquo;A&amp;rsquo; returns an exact copy of the physical memory. In particular, in-memory Fortran order is preserved. For non-contiguous views, the data is converted to C first. &lt;em&gt;order=None&lt;/em&gt; is the same as &lt;em&gt;order=&amp;rsquo;C&amp;rsquo;&lt;/em&gt;.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;순서&lt;/em&gt; 는 { 'C', 'F', 'A'} 일 수 있습니다. 되면 &lt;em&gt;주문&lt;/em&gt; 'C'또는 'F'인 원의 배열의 데이터는 C 또는 포트란 순서로 변환된다. 연속 된 뷰의 경우 'A'는 실제 메모리의 정확한 사본을 반환합니다. 특히 메모리 내 포트란 순서가 유지됩니다. 연속되지 않은 뷰의 경우 데이터가 먼저 C로 변환됩니다. &lt;em&gt;order = 없음&lt;/em&gt; 은 &lt;em&gt;order = 'C'와 같습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2cff40a0917f8f2171e5ff8c7704c205ac772d99" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added &lt;code&gt;--module&lt;/code&gt; option that allows to run an executable module.</source>
          <target state="translated">버전 3.8의 새로운 기능 : 실행 모듈을 실행할 수있는 &lt;code&gt;--module&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9ec5376ab9dcf06a2c4b76dd85864c5f7f72d6f3" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added &lt;code&gt;451 UNAVAILABLE_FOR_LEGAL_REASONS&lt;/code&gt; status code.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;451 UNAVAILABLE_FOR_LEGAL_REASONS&lt;/code&gt; 상태 코드가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="186ccced30c0596281d99c06878fe06f5cba4d05" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added the &lt;a href=&quot;#os.stat_result.st_reparse_tag&quot;&gt;&lt;code&gt;st_reparse_tag&lt;/code&gt;&lt;/a&gt; member on Windows.</source>
          <target state="translated">버전 3.8의 새로운 기능 : Windows에 &lt;a href=&quot;#os.stat_result.st_reparse_tag&quot;&gt; &lt;code&gt;st_reparse_tag&lt;/code&gt; &lt;/a&gt; 멤버가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="31ad6246322e02482cc2675a0a61de73a9615090" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added the &lt;code&gt;-m&lt;/code&gt; option to &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;-m&lt;/code&gt; 옵션을 &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; 에&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="94e84a13854d39d8a4e632a89b58cf02e628570f" translate="yes" xml:space="preserve">
          <source>New in version 3.8: PowerShell activation scripts installed under POSIX for PowerShell Core support.</source>
          <target state="translated">버전 3.8의 새로운 기능 : PowerShell Core 지원을 위해 POSIX에 설치된 PowerShell 활성화 스크립트.</target>
        </trans-unit>
        <trans-unit id="f6946e0aad7bd1d3aa73545d7a267c0b448f75c6" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Previous versions of CPython would resolve DLLs using the default behavior for the current process. This led to inconsistencies, such as only sometimes searching &lt;code id=&quot;index-25&quot;&gt;PATH&lt;/code&gt; or the current working directory, and OS functions such as &lt;code&gt;AddDllDirectory&lt;/code&gt; having no effect.</source>
          <target state="translated">버전 3.8의 새로운 기능 : 이전 버전의 CPython은 현재 프로세스의 기본 동작을 사용하여 DLL을 분석합니다. 이로 인해 때때로 &lt;code id=&quot;index-25&quot;&gt;PATH&lt;/code&gt; 검색 또는 현재 작업 디렉토리와 같은 &lt;code&gt;AddDllDirectory&lt;/code&gt; 가 발생 했으며 AddDllDirectory 와 같은 OS 기능은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f977a95a81a55a1784f791e2a58c544b6b5481e3" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;dirs_exist_ok&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;dirs_exist_ok&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="b713cbde69ae2c18b39ec28507e206c345a918bd" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;happy_eyeballs_delay&lt;/em&gt; and &lt;em&gt;interleave&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;happy_eyeballs_delay&lt;/em&gt; 및 &lt;em&gt;interleave&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="bce6b595725e42c8ce0117c78ce8cc089343e237" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;strict_timestamps&lt;/em&gt; keyword-only argument</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;strict_timestamps&lt;/em&gt; 키워드 전용 인수</target>
        </trans-unit>
        <trans-unit id="aeec7f4f480fc32e5c189622f501015e66103fc7" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;xml_declaration&lt;/em&gt; and &lt;em&gt;default_namespace&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;xml_declaration&lt;/em&gt; 및 &lt;em&gt;default_namespace&lt;/em&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="4207315e68011a4c07693dcc3f18b88787928c23" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The optional sixth tuple item, &lt;code&gt;(obj, state)&lt;/code&gt;, was added.</source>
          <target state="translated">버전 3.8의 새로운 기능 : 선택적인 여섯 번째 튜플 항목 &lt;code&gt;(obj, state)&lt;/code&gt; 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1101fa4c967ee98df4f4734b3541a4560182d08f" translate="yes" xml:space="preserve">
          <source>New: It is now possible to put items in argtypes which are not ctypes types, but each item must have a &lt;code&gt;from_param()&lt;/code&gt; method which returns a value usable as argument (integer, string, ctypes instance). This allows defining adapters that can adapt custom objects as function parameters.</source>
          <target state="translated">이제 ctypes 유형이 아닌 argtypes에 항목을 넣을 수 있지만 각 항목에는 인수로 사용할 수있는 값 (정수, 문자열, ctypes 인스턴스)을 반환하는 &lt;code&gt;from_param()&lt;/code&gt; 메서드 가 있어야합니다 . 이를 통해 사용자 정의 오브젝트를 기능 매개 변수로 조정할 수있는 어댑터를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="540f7186c4d530bac579f69bb157fd5e121529cc" translate="yes" xml:space="preserve">
          <source>NewType</source>
          <target state="translated">NewType</target>
        </trans-unit>
        <trans-unit id="1f243883e19f81b334c75128a8750ed8afdcc9d0" translate="yes" xml:space="preserve">
          <source>Newer RFC that provides a revised definition of XDR.</source>
          <target state="translated">XDR의 수정 된 정의를 제공하는 최신 RFC</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="3fd8fdbb697f927d539f398a34de5c84c0407d98" translate="yes" xml:space="preserve">
          <source>Next History</source>
          <target state="translated">다음 역사</target>
        </trans-unit>
        <trans-unit id="7012977a58ea8b287c205fbbab7e5434b3642c46" translate="yes" xml:space="preserve">
          <source>Next Line (C1 Control Code)</source>
          <target state="translated">다음 줄 (C1 제어 코드)</target>
        </trans-unit>
        <trans-unit id="4bfc194b68a3369d53aadcddc4f891771d91a3d9" translate="yes" xml:space="preserve">
          <source>Next page</source>
          <target state="translated">다음 페이지</target>
        </trans-unit>
        <trans-unit id="233213a348a3467a9713a7d089885546d38eba8b" translate="yes" xml:space="preserve">
          <source>Next we instantiate a Differ object:</source>
          <target state="translated">다음으로 Differ 객체를 인스턴스화합니다 :</target>
        </trans-unit>
        <trans-unit id="b9fac927a58027f98332aa47670afe3b77e6d6a4" translate="yes" xml:space="preserve">
          <source>Next, we encounter a new person whose feature measurements are known but whose gender is unknown:</source>
          <target state="translated">다음으로, 특징 측정은 알려졌지만 성별을 알 수없는 새로운 사람이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd608f08ab177c1073a159dda57f4a0251fcd9d9" translate="yes" xml:space="preserve">
          <source>No CSI structure available</source>
          <target state="translated">사용 가능한 CSI 구조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf8647669a8695bdc05a11d401d6432a9f88b641" translate="yes" xml:space="preserve">
          <source>No XENIX semaphores available</source>
          <target state="translated">사용 가능한 XENIX 세마포가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c45a435d178e3e2e2c3ba71f0b27f7074852c14" translate="yes" xml:space="preserve">
          <source>No anode</source>
          <target state="translated">양극 없음</target>
        </trans-unit>
        <trans-unit id="b599ea3e9f4d15ca66ad3df24a2527224a8ea2d5" translate="yes" xml:space="preserve">
          <source>No argument is converted, results in a &lt;code&gt;'%'&lt;/code&gt; character in the result.</source>
          <target state="translated">인수가 변환되지 않으며 결과에 &lt;code&gt;'%'&lt;/code&gt; 문자가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">사용 가능한 버퍼 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="099e11888438840a8566c983d5b1e6de2dad8524" translate="yes" xml:space="preserve">
          <source>No child processes</source>
          <target state="translated">자식 프로세스가 없습니다</target>
        </trans-unit>
        <trans-unit id="0cfc430ad5192c2568f967923954cde952307fa4" translate="yes" xml:space="preserve">
          <source>No data available</source>
          <target state="translated">자료 없음</target>
        </trans-unit>
        <trans-unit id="5921088185a40f1dda6c07e51735aa215a517c81" translate="yes" xml:space="preserve">
          <source>No defined value type.</source>
          <target state="translated">정의 된 값 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cb62108d46698f5697c85ab801ad27a8ef1fbf6" translate="yes" xml:space="preserve">
          <source>No distinction between standard and widget-specific options is made in this document. Some options don&amp;rsquo;t apply to some kinds of widgets. Whether a given widget responds to a particular option depends on the class of the widget; buttons have a &lt;code&gt;command&lt;/code&gt; option, labels do not.</source>
          <target state="translated">이 문서에서는 표준 옵션과 위젯 특정 옵션을 구분하지 않습니다. 일부 옵션은 일부 종류의 위젯에는 적용되지 않습니다. 주어진 위젯이 특정 옵션에 응답하는지 여부는 위젯 클래스에 따라 다릅니다. 버튼에는 &lt;code&gt;command&lt;/code&gt; 옵션이 있지만 레이블에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a8258b97ca1863297badad1b0273640969901f7" translate="yes" xml:space="preserve">
          <source>No feature description will ever be deleted from &lt;a href=&quot;#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt;. Since its introduction in Python 2.1 the following features have found their way into the language using this mechanism:</source>
          <target state="translated">&lt;a href=&quot;#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; 에서 기능 설명이 삭제되지 않습니다 . Python 2.1에서 소개 된 이후로 다음 기능은이 메커니즘을 사용하여 언어에 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f45ab0b8375bdf5386e021a0b31d679497a33d5c" translate="yes" xml:space="preserve">
          <source>No message of desired type</source>
          <target state="translated">원하는 유형의 메시지가 없습니다</target>
        </trans-unit>
        <trans-unit id="19ae1fe9004b24354abb4ed1dcb0717c604a6346" translate="yes" xml:space="preserve">
          <source>No modifier is given, so it can appear exactly once, as for &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">수정자가 주어지지 않으므로 &lt;code&gt;A&lt;/code&gt; 와 같이 정확히 한 번만 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7498d9819e38f5924fea12d89303afac91d07387" translate="yes" xml:space="preserve">
          <source>No padding is added when using non-native size and alignment, e.g. with &amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;=&amp;rsquo;, and &amp;lsquo;!&amp;rsquo;.</source>
          <target state="translated">기본이 아닌 크기와 정렬을 사용할 때는 패딩이 추가되지 않습니다 (예 : '&amp;lt;', '&amp;gt;', '='및 '!').</target>
        </trans-unit>
        <trans-unit id="3ab4c24c0255ad55292cf986980b47b2ee3d453f" translate="yes" xml:space="preserve">
          <source>No problem, provided that the traceback is the only output produced by the example: just paste in the traceback. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; Since tracebacks contain details that are likely to change rapidly (for example, exact file paths and line numbers), this is one case where doctest works hard to be flexible in what it accepts.</source>
          <target state="translated">트레이스 백이 예제에서 생성 된 유일한 출력 인 경우 문제가되지 않습니다. 트레이스 백에 붙여 넣기 만하면됩니다. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 트레이스 백에는 빠르게 변경 될 수있는 세부 정보 (예 : 정확한 파일 경로 및 줄 번호)가 포함되어 있기 때문에 doctest가 수용 할 수있는 유연성을 갖추기 어려운 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab134dfa754cd3657dd291f57f80c528eeaa381a" translate="yes" xml:space="preserve">
          <source>No record locks available</source>
          <target state="translated">사용 가능한 레코드 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="62c6526007299ca03f778b5b7ce0d726354cae0d" translate="yes" xml:space="preserve">
          <source>No route to host</source>
          <target state="translated">호스트 경로가 없습니다</target>
        </trans-unit>
        <trans-unit id="5c0580667d6055e92a026b8c67fa943060b2c89d" translate="yes" xml:space="preserve">
          <source>No space left on device</source>
          <target state="translated">기기에 남은 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8affcec2bb7338bba6a528b37e279cb979510364" translate="yes" xml:space="preserve">
          <source>No special efforts are made to achieve exact results. (However, this may change in the future.)</source>
          <target state="translated">정확한 결과를 얻기 위해 특별한 노력을 기울이지 않습니다. (단, 향후 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e5feee0204f5532e0cb04d5be298f4c467c05e6f" translate="yes" xml:space="preserve">
          <source>No such device</source>
          <target state="translated">그런 장치가 없습니다</target>
        </trans-unit>
        <trans-unit id="112765ee706d5c7ea20d7309d6bf892b8a5aa7eb" translate="yes" xml:space="preserve">
          <source>No such device or address</source>
          <target state="translated">그러한 장치 나 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="8a6cb568f806ffae868a77b519003a5df95ec0c3" translate="yes" xml:space="preserve">
          <source>No such file or directory</source>
          <target state="translated">그러한 파일이나 디렉토리가 없습니다</target>
        </trans-unit>
        <trans-unit id="0cf4a772e5ca24befae7ddee66e425eeaa8130aa" translate="yes" xml:space="preserve">
          <source>No such process</source>
          <target state="translated">그런 과정이 없습니다</target>
        </trans-unit>
        <trans-unit id="589aa359449804b5cecdf6ad3c2674828c4925a4" translate="yes" xml:space="preserve">
          <source>No suitable authentication method was found.</source>
          <target state="translated">적합한 인증 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e86c9e3430455ac090ffb5eaf4ae106dd193246" translate="yes" xml:space="preserve">
          <source>No-op in the base class, this method takes file object &lt;em&gt;fp&lt;/em&gt;, and reads the data from the file, initializing its message catalog. If you have an unsupported message catalog file format, you should override this method to parse your format.</source>
          <target state="translated">기본 클래스에서 작동하지 않는이 메소드는 파일 객체 &lt;em&gt;fp를&lt;/em&gt; 가져 와서 파일 에서 데이터를 읽고 메시지 카탈로그를 초기화합니다. 지원되지 않는 메시지 카탈로그 파일 형식이있는 경우이 방법을 재정 의하여 형식을 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="b17a6c458741a86bf04ade61ad9a14f7ac61215b" translate="yes" xml:space="preserve">
          <source>Node Objects</source>
          <target state="translated">노드 객체</target>
        </trans-unit>
        <trans-unit id="7e378cbf407e94014d60a68e1eb16b7d4cc0b6a2" translate="yes" xml:space="preserve">
          <source>Node classes</source>
          <target state="translated">노드 클래스</target>
        </trans-unit>
        <trans-unit id="14144ba530975f0eb39fc2d9e3b0c8023d821c70" translate="yes" xml:space="preserve">
          <source>NodeList Objects</source>
          <target state="translated">NodeList 객체</target>
        </trans-unit>
        <trans-unit id="750728f3a8917784306697d947d7258635f9568e" translate="yes" xml:space="preserve">
          <source>Nodes containing textual content from the document.</source>
          <target state="translated">문서의 텍스트 내용을 포함하는 노드</target>
        </trans-unit>
        <trans-unit id="bdc7ab16126589f949098e57c1b5539a8ac176ed" translate="yes" xml:space="preserve">
          <source>Nomenclature</source>
          <target state="translated">Nomenclature</target>
        </trans-unit>
        <trans-unit id="56c04398e9678198426e682b1f9d96427b74b23b" translate="yes" xml:space="preserve">
          <source>Nominal vs structural subtyping</source>
          <target state="translated">공칭 vs 구조적 서브 타이핑</target>
        </trans-unit>
        <trans-unit id="35d3f82350431652e47bdcf8c933cca085703f88" translate="yes" xml:space="preserve">
          <source>Non-blocking mode is supported through &lt;a href=&quot;#socket.socket.setblocking&quot;&gt;&lt;code&gt;setblocking()&lt;/code&gt;&lt;/a&gt;. A generalization of this based on timeouts is supported through &lt;a href=&quot;#socket.socket.settimeout&quot;&gt;&lt;code&gt;settimeout()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 차단 모드는 &lt;a href=&quot;#socket.socket.setblocking&quot;&gt; &lt;code&gt;setblocking()&lt;/code&gt; &lt;/a&gt; 통해 지원됩니다 . 제한 시간을 기반으로하는 일반화는 &lt;a href=&quot;#socket.socket.settimeout&quot;&gt; &lt;code&gt;settimeout()&lt;/code&gt; &lt;/a&gt; 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c6473f2b77717e9eaefce19afcd71fb87fcc938" translate="yes" xml:space="preserve">
          <source>Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: &lt;code&gt;{'jack', 'sjoerd'}&lt;/code&gt;, in addition to the &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">비어 있지 않은 세트 ( &lt;code&gt;{'jack', 'sjoerd'}&lt;/code&gt; &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 아님) 는 세트 생성자 외에 쉼표로 구분 된 요소 목록을 중괄호 내에 배치하여 만들 수 있습니다 (예 : { 'jack', 'sjoerd'} ) .</target>
        </trans-unit>
        <trans-unit id="4aa0a99e9276d0e78ac1248387e6c6b9c79d9b2a" translate="yes" xml:space="preserve">
          <source>Non-identical instances of a class normally compare as non-equal unless the class defines the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">클래스의 동일하지 않은 인스턴스는 클래스가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 메서드를 정의하지 않는 한 일반적으로 동일하지 않은 것으로 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="5432efc874ee04f0f27783979ffafd974c2144c4" translate="yes" xml:space="preserve">
          <source>Non-quoted escape characters (e.g. &lt;code&gt;'\'&lt;/code&gt;) preserve the literal value of the next character that follows;</source>
          <target state="translated">인용 부호가없는 이스케이프 문자 (예 : &lt;code&gt;'\'&lt;/code&gt; )는 다음에 오는 다음 문자의 리터럴 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="7e5255a130b91c89dba736489c8c648b0ae932c0" translate="yes" xml:space="preserve">
          <source>Nonzero if a DST timezone is defined. See note below.</source>
          <target state="translated">DST 시간대가 정의 된 경우 0이 아닙니다. 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d6248d1d5c865a0048cbc0bf21dcb388cd91a77" translate="yes" xml:space="preserve">
          <source>Nordic languages</source>
          <target state="translated">북유럽 언어</target>
        </trans-unit>
        <trans-unit id="02e21f33972d3ea6d360c18684f08ac13010544f" translate="yes" xml:space="preserve">
          <source>Normal and error output are generally kept separate (on separate lines) from code input and each other. They each get different highlight colors.</source>
          <target state="translated">정상 및 오류 출력은 일반적으로 코드 입력과 서로 분리되어 (별도의 줄에) 유지됩니다. 그들은 각각 다른 하이라이트 색상을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="170f10d24b0b85cf90e96608630df2d96c9b4817" translate="yes" xml:space="preserve">
          <source>Normal attribute</source>
          <target state="translated">일반 속성</target>
        </trans-unit>
        <trans-unit id="f1f743126e0f5dd0902750180da22c23c53778c8" translate="yes" xml:space="preserve">
          <source>Normal distribution. &lt;em&gt;mu&lt;/em&gt; is the mean, and &lt;em&gt;sigma&lt;/em&gt; is the standard deviation.</source>
          <target state="translated">정규 분포. &lt;em&gt;mu&lt;/em&gt; 는 평균이고 &lt;em&gt;sigma&lt;/em&gt; 는 표준 편차입니다.</target>
        </trans-unit>
        <trans-unit id="3d1612e1a01af8e8718757fe0eb13a0da18713da" translate="yes" xml:space="preserve">
          <source>Normal distributions arise from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_limit_theorem&quot;&gt;Central Limit Theorem&lt;/a&gt; and have a wide range of applications in statistics.</source>
          <target state="translated">정규 분포는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_limit_theorem&quot;&gt;중앙 제한 정리&lt;/a&gt; 에서 발생 하며 통계에 광범위한 응용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe823566d89d09d65bf2172f99f78ec17aa83bd8" translate="yes" xml:space="preserve">
          <source>Normal distributions commonly arise in machine learning problems.</source>
          <target state="translated">정규 분포는 일반적으로 기계 학습 문제에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b2153c60470208f45dcfdc29d655f5a4049324a" translate="yes" xml:space="preserve">
          <source>NormalDist objects</source>
          <target state="translated">NormalDist 객체</target>
        </trans-unit>
        <trans-unit id="691b62ff89f4b08738f81953df74ff8ae6e26204" translate="yes" xml:space="preserve">
          <source>Normalize a pathname by collapsing redundant separators and up-level references so that &lt;code&gt;A//B&lt;/code&gt;, &lt;code&gt;A/B/&lt;/code&gt;, &lt;code&gt;A/./B&lt;/code&gt; and &lt;code&gt;A/foo/../B&lt;/code&gt; all become &lt;code&gt;A/B&lt;/code&gt;. This string manipulation may change the meaning of a path that contains symbolic links. On Windows, it converts forward slashes to backward slashes. To normalize case, use &lt;a href=&quot;#os.path.normcase&quot;&gt;&lt;code&gt;normcase()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A//B&lt;/code&gt; , &lt;code&gt;A/B/&lt;/code&gt; , &lt;code&gt;A/./B&lt;/code&gt; 및 &lt;code&gt;A/foo/../B&lt;/code&gt; 모두 &lt;code&gt;A/B&lt;/code&gt; 가 되도록 중복 분리 자와 상위 레벨 참조를 축소하여 경로 이름을 정규화하십시오 . 이 문자열 조작은 기호 링크가 포함 된 경로의 의미를 변경할 수 있습니다. Windows에서는 슬래시를 슬래시로 변환합니다. 대소 문자를 정규화하려면 &lt;a href=&quot;#os.path.normcase&quot;&gt; &lt;code&gt;normcase()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de47e1cb4db52e6f0ace31520ebf2d73cf5200f" translate="yes" xml:space="preserve">
          <source>Normalize the case of a pathname. On Windows, convert all characters in the pathname to lowercase, and also convert forward slashes to backward slashes. On other operating systems, return the path unchanged.</source>
          <target state="translated">경로명의 대소 문자를 정규화하십시오. Windows에서는 경로 이름의 모든 문자를 소문자로 변환하고 슬래시를 백 슬래시로 변환하십시오. 다른 운영 체제에서는 경로를 변경하지 않고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5bb740d481f263379151a90b9e11e2b6fdb345e7" translate="yes" xml:space="preserve">
          <source>Normalize the number by stripping the rightmost trailing zeros and converting any result equal to &lt;code&gt;Decimal('0')&lt;/code&gt; to &lt;code&gt;Decimal('0e0')&lt;/code&gt;. Used for producing canonical values for attributes of an equivalence class. For example, &lt;code&gt;Decimal('32.100')&lt;/code&gt; and &lt;code&gt;Decimal('0.321000e+2')&lt;/code&gt; both normalize to the equivalent value &lt;code&gt;Decimal('32.1')&lt;/code&gt;.</source>
          <target state="translated">가장 오른쪽 후행 0을 제거하고 &lt;code&gt;Decimal('0')&lt;/code&gt; 과 동일한 결과 를 &lt;code&gt;Decimal('0e0')&lt;/code&gt; 로 변환하여 숫자를 정규화하십시오 . 동등 클래스의 속성에 대한 표준 값을 생성하는 데 사용됩니다. 예를 들어 &lt;code&gt;Decimal('32.100')&lt;/code&gt; 및 &lt;code&gt;Decimal('0.321000e+2')&lt;/code&gt; 모두 동등한 값 &lt;code&gt;Decimal('32.1')&lt;/code&gt; 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f52a413a99343944d32b2af1d020b8d0b1acd04" translate="yes" xml:space="preserve">
          <source>Normally &lt;strong&gt;there is no need&lt;/strong&gt; to create Future objects at the application level code.</source>
          <target state="translated">일반적으로 응용 프로그램 수준 코드에서 Future 객체를 만들 &lt;strong&gt;필요는 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d90ea54070ee394f637e437d868344967800111e" translate="yes" xml:space="preserve">
          <source>Normally derived classes don&amp;rsquo;t override the following methods, but they may if they want to redefine the definition of stopping and breakpoints.</source>
          <target state="translated">일반적으로 파생 된 클래스는 다음 메서드를 재정의하지 않지만 중지 및 중단 점 정의를 재정의하려는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7e3e4198625d7397897fc42c4d0f77e2c31eff8" translate="yes" xml:space="preserve">
          <source>Normally it should not be necessary to use this value directly. Specifying the &lt;code&gt;E&lt;/code&gt; modifier in their format strings causes the &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; function to use this information. The format of the returned string is not specified, and therefore you should not assume knowledge of it on different systems.</source>
          <target state="translated">일반적으로이 값을 직접 사용할 필요는 없습니다. 형식 문자열에 &lt;code&gt;E&lt;/code&gt; 수정자를 지정하면 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 함수가이 정보를 사용합니다. 리턴 된 문자열의 형식이 지정되지 않았으므로 다른 시스템에서이를 알고 있다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd8b4f218db00ed4e30efd72f3a335858fe6269" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;#unittest.mock.Mock.__class__&quot;&gt;&lt;code&gt;__class__&lt;/code&gt;&lt;/a&gt; attribute of an object will return its type. For a mock object with a &lt;code&gt;spec&lt;/code&gt;, &lt;code&gt;__class__&lt;/code&gt; returns the spec class instead. This allows mock objects to pass &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; tests for the object they are replacing / masquerading as:</source>
          <target state="translated">일반적으로 객체 의 &lt;a href=&quot;#unittest.mock.Mock.__class__&quot;&gt; &lt;code&gt;__class__&lt;/code&gt; &lt;/a&gt; 속성은 해당 유형을 반환합니다. &lt;code&gt;spec&lt;/code&gt; 을 가진 모의 객체의 경우 &lt;code&gt;__class__&lt;/code&gt; 는 대신 spec 클래스를 반환합니다. 이를 통해 mock 객체 는 다음과 같이 교체 / 가장 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 되는 객체에 대해 isinstance () 테스트 를 통과 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5aa93ae111a762d37226903d82a74d9b1f47e777" translate="yes" xml:space="preserve">
          <source>Normally you should use the socket API methods like &lt;a href=&quot;socket#socket.socket.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.socket.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; instead of these methods.</source>
          <target state="translated">일반적으로 이러한 메소드 대신 &lt;a href=&quot;socket#socket.socket.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;socket#socket.socket.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 와 같은 소켓 API 메소드를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d529dbb8b442b62924e944a3daf4b0e0711efec" translate="yes" xml:space="preserve">
          <source>Normally, however, you do not need to use these additional methods, as &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.set_app&quot;&gt;&lt;code&gt;set_app()&lt;/code&gt;&lt;/a&gt; is normally called by &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt;&lt;code&gt;make_server()&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.get_app&quot;&gt;&lt;code&gt;get_app()&lt;/code&gt;&lt;/a&gt; exists mainly for the benefit of request handler instances.</source>
          <target state="translated">일반적으로, 그러나, 당신은 다음과 같은 추가 방법을 사용할 필요가 없습니다 &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.set_app&quot;&gt; &lt;code&gt;set_app()&lt;/code&gt; &lt;/a&gt; 일반적으로 호출 &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt; &lt;code&gt;make_server()&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.get_app&quot;&gt; &lt;code&gt;get_app()&lt;/code&gt; &lt;/a&gt; 요청 처리기 인스턴스의 이익을 위해 주로 존재한다.</target>
        </trans-unit>
        <trans-unit id="0788443a411022d37bd9d9d545b151030497a024" translate="yes" xml:space="preserve">
          <source>Normally, the generator emits a single string; however, for &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; exceptions, it emits several lines that (when printed) display detailed information about where the syntax error occurred.</source>
          <target state="translated">일반적으로 생성기는 단일 문자열을 방출합니다. 그러나 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 예외의 경우 구문 오류가 발생한 위치에 대한 자세한 정보를 인쇄 할 때 여러 줄을 출력합니다 (인쇄시).</target>
        </trans-unit>
        <trans-unit id="23ff9f150633c592aa535d8b9f1a3400f42cda0e" translate="yes" xml:space="preserve">
          <source>Normally, this method first strips any quotes off the argument. If the result is an absolute pathname, or there was no previous source request in effect, or the previous source was a stream (such as &lt;code&gt;sys.stdin&lt;/code&gt;), the result is left alone. Otherwise, if the result is a relative pathname, the directory part of the name of the file immediately before it on the source inclusion stack is prepended (this behavior is like the way the C preprocessor handles &lt;code&gt;#include
&quot;file.h&quot;&lt;/code&gt;).</source>
          <target state="translated">일반적으로이 메소드는 먼저 인수에서 따옴표를 제거합니다. 결과가 절대 경로 이름이거나 유효한 이전 소스 요청이 없거나 이전 소스가 스트림 (예 : &lt;code&gt;sys.stdin&lt;/code&gt; ) 인 경우 결과는 단독으로 유지됩니다. 그렇지 않으면 결과가 상대 경로 이름 인 경우 소스 포함 스택에서 파일 바로 앞에있는 파일 이름의 디렉토리 부분이 앞에 붙습니다 (이 동작은 C 전처리 기가 &lt;code&gt;#include &quot;file.h&quot;&lt;/code&gt; 처리하는 방식과 같습니다 ).</target>
        </trans-unit>
        <trans-unit id="0fde105c2e0c2c34defc4b3e3f0d9044ebf54e00" translate="yes" xml:space="preserve">
          <source>Normally, when you pass an argument list to the &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; method of an &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;, it &lt;a href=&quot;#prefix-matching&quot;&gt;recognizes abbreviations&lt;/a&gt; of long options.</source>
          <target state="translated">당신이에 인수 목록을 통과 할 때 일반적으로, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 의 방법 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; , 그것은 &lt;a href=&quot;#prefix-matching&quot;&gt;약어 인식&lt;/a&gt; 긴 옵션을.</target>
        </trans-unit>
        <trans-unit id="9db1844f9d4e3e923c05588f67a7669bd03d89f7" translate="yes" xml:space="preserve">
          <source>Normally, you would use the &lt;code&gt;os.path.is*()&lt;/code&gt; functions for testing the type of a file; the functions here are useful when you are doing multiple tests of the same file and wish to avoid the overhead of the &lt;code&gt;stat()&lt;/code&gt; system call for each test. These are also useful when checking for information about a file that isn&amp;rsquo;t handled by &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;, like the tests for block and character devices.</source>
          <target state="translated">일반적으로 파일 유형을 테스트하기 위해 &lt;code&gt;os.path.is*()&lt;/code&gt; 함수를 사용합니다. 여기에있는 함수는 동일한 파일에 대해 여러 테스트를 수행 할 때 유용 하며 각 테스트에 대한 &lt;code&gt;stat()&lt;/code&gt; 시스템 호출 의 오버 헤드를 피하려고합니다 . 블록 및 문자 장치 테스트와 같이 &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 가 처리하지 않는 파일에 대한 정보를 확인할 때도 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="bb0c92aed320c99f3cf5a7b36f620aee6bc3d350" translate="yes" xml:space="preserve">
          <source>Not a XENIX named type file</source>
          <target state="translated">XENIX 명명 된 유형 파일이 아님</target>
        </trans-unit>
        <trans-unit id="16362f559ca4bab86e57b8b31308ce0876579def" translate="yes" xml:space="preserve">
          <source>Not a data message</source>
          <target state="translated">데이터 메시지가 아님</target>
        </trans-unit>
        <trans-unit id="338469a733ebda5aa0e30bb1db80e0e157e51892" translate="yes" xml:space="preserve">
          <source>Not a directory</source>
          <target state="translated">디렉토리가 아님</target>
        </trans-unit>
        <trans-unit id="8c67b4de17834c13bd6e4d2b12aca324d453a11f" translate="yes" xml:space="preserve">
          <source>Not a typewriter</source>
          <target state="translated">타자기가 아님</target>
        </trans-unit>
        <trans-unit id="2c7846a67eb11ab196b9e6f6d7a69ff03be54a85" translate="yes" xml:space="preserve">
          <source>Not all Python object types are supported; in general, only objects whose value is independent from a particular invocation of Python can be written and read by this module. The following types are supported: booleans, integers, floating point numbers, complex numbers, strings, bytes, bytearrays, tuples, lists, sets, frozensets, dictionaries, and code objects, where it should be understood that tuples, lists, sets, frozensets and dictionaries are only supported as long as the values contained therein are themselves supported. The singletons &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;constants#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; can also be marshalled and unmarshalled. For format &lt;em&gt;version&lt;/em&gt; lower than 3, recursive lists, sets and dictionaries cannot be written (see below).</source>
          <target state="translated">모든 Python 객체 유형이 지원되는 것은 아닙니다. 일반적으로 특정 파이썬 호출과 독립적 인 값을 가진 객체 만이 모듈에서 쓰고 읽을 수 있습니다. 부울, 정수, 부동 소수점 숫자, 복소수, 문자열, 바이트, 바이트 배열, 튜플, 목록, 세트, ​​고정 집합, 사전 및 코드 객체 유형이 지원됩니다. 튜플, 목록, 집합, 고정 집합 사전은 여기에 포함 된 값 자체가 지원되는 경우에만 지원됩니다. Singletons &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;constants#Ellipsis&quot;&gt; &lt;code&gt;Ellipsis&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 도 마샬링 및 마샬링 해제 할 수 있습니다. 형식 &lt;em&gt;버전&lt;/em&gt; 이 3보다 낮은 경우 재귀 목록, 집합 및 사전을 쓸 수 없습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="a3e1b1287060e9ba795d51d985b235049aa105ed" translate="yes" xml:space="preserve">
          <source>Not all elements of the XML input will end up as elements of the parsed tree. Currently, this module skips over any XML comments, processing instructions, and document type declarations in the input. Nevertheless, trees built using this module&amp;rsquo;s API rather than parsing from XML text can have comments and processing instructions in them; they will be included when generating XML output. A document type declaration may be accessed by passing a custom &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt;&lt;code&gt;TreeBuilder&lt;/code&gt;&lt;/a&gt; instance to the &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">XML 입력의 모든 요소가 구문 분석 된 트리의 요소로 끝나는 것은 아닙니다. 현재이 모듈은 입력에서 XML 주석, 처리 명령 및 문서 유형 선언을 건너 뜁니다. 그럼에도 불구하고 XML 텍스트를 파싱하는 대신이 모듈의 API를 사용하여 작성된 트리에는 주석과 처리 지침이있을 수 있습니다. XML 출력을 생성 할 때 포함됩니다. 사용자 정의 &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt; &lt;code&gt;TreeBuilder&lt;/code&gt; &lt;/a&gt; 인스턴스를 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 생성자 에 전달하여 문서 유형 선언에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7451951009f7df728b6f3d4aa4cb2d7ba85029ba" translate="yes" xml:space="preserve">
          <source>Not all flags are valid for all versions of &lt;code&gt;gdbm&lt;/code&gt;. The module constant &lt;code&gt;open_flags&lt;/code&gt; is a string of supported flag characters. The exception &lt;a href=&quot;#dbm.gnu.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; is raised if an invalid flag is specified.</source>
          <target state="translated">모든 플래그가 모든 버전의 &lt;code&gt;gdbm&lt;/code&gt; 에 유효한 것은 아닙니다 . 모듈 상수 &lt;code&gt;open_flags&lt;/code&gt; 는 지원되는 플래그 문자의 문자열입니다. 유효하지 않은 플래그가 지정되면 예외 &lt;a href=&quot;#dbm.gnu.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5642009188b00b4b1401ca4b9758d17920df1198" translate="yes" xml:space="preserve">
          <source>Not all objects can be weakly referenced; those objects which can include class instances, functions written in Python (but not in C), instance methods, sets, frozensets, some &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generators&lt;/a&gt;, type objects, sockets, arrays, deques, regular expression pattern objects, and code objects.</source>
          <target state="translated">모든 객체를 약하게 참조 할 수있는 것은 아닙니다. 클래스 인스턴스, Python으로 작성된 함수 (C는 아님), 인스턴스 메소드, 세트, ​​고정 세트, 일부 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; , 유형 객체, 소켓, 배열, deques, 정규 표현식 패턴 객체 및 코드 객체를 포함 할 수있는 객체.</target>
        </trans-unit>
        <trans-unit id="07c849ef61574f048a53a41ad5a4327d9310750e" translate="yes" xml:space="preserve">
          <source>Not all platforms provide the ability to examine and modify symbolic links. Python itself can tell you what functionality is locally available.</source>
          <target state="translated">모든 플랫폼이 심볼릭 링크를 검사하고 수정할 수있는 기능을 제공하지는 않습니다. 파이썬 자체는 어떤 기능이 로컬에서 사용 가능한지 알려줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45153922480b755eeb20a8cd5a5df84141dc176" translate="yes" xml:space="preserve">
          <source>Not available on Windows.</source>
          <target state="translated">Windows에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c2c4692797b1c72c2490c0e81cb931fc786ce55" translate="yes" xml:space="preserve">
          <source>Not currently used.</source>
          <target state="translated">현재 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac08186824133d19452b6a51a06060ff36e3034e" translate="yes" xml:space="preserve">
          <source>Not for complex numbers. Instead convert to floats using &lt;a href=&quot;functions#abs&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; if appropriate.</source>
          <target state="translated">복소수가 아닙니다. 대신 적절한 경우 &lt;a href=&quot;functions#abs&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 사용하여 float로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8587c1a0a933c635a00ae69af27b2446cfdae1c" translate="yes" xml:space="preserve">
          <source>Not knowing the default extraction behaviors can cause unexpected decompression results. For example, when extracting the same archive twice, it overwrites files without asking.</source>
          <target state="translated">기본 추출 동작을 모르면 예기치 않은 압축 해제 결과가 발생할 수 있습니다. 예를 들어, 동일한 아카이브를 두 번 추출하면 묻지 않고 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="edfda3842ea6fbe6f744c728779b1389a38d845f" translate="yes" xml:space="preserve">
          <source>Not read, but previously detected by MUA</source>
          <target state="translated">읽지 않았지만 이전에 MUA에서 감지</target>
        </trans-unit>
        <trans-unit id="68572512d58f5572f216f0e3f449070bb1b9602b" translate="yes" xml:space="preserve">
          <source>NotADirectoryError</source>
          <target state="translated">NotADirectoryError</target>
        </trans-unit>
        <trans-unit id="5ceae088184ecb2a3d44c94c6258a6f897118f5f" translate="yes" xml:space="preserve">
          <source>NotImplemented</source>
          <target state="translated">NotImplemented</target>
        </trans-unit>
        <trans-unit id="8850b3bd61499741c05bd500ea7929ed489941ca" translate="yes" xml:space="preserve">
          <source>NotImplementedError</source>
          <target state="translated">NotImplementedError</target>
        </trans-unit>
        <trans-unit id="028373739f7f8068eb474265d2fb30ef33c2b72c" translate="yes" xml:space="preserve">
          <source>Notable Module Contents</source>
          <target state="translated">주목할만한 모듈 내용</target>
        </trans-unit>
        <trans-unit id="b5ae56c0c64d23ceb8b79ad6407cefba354d2d9f" translate="yes" xml:space="preserve">
          <source>Notably, this &amp;ldquo;ignored by default&amp;rdquo; list includes &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt; (for every module except &lt;code&gt;__main__&lt;/code&gt;), which means developers should make sure to test their code with typically ignored warnings made visible in order to receive timely notifications of future breaking API changes (whether in the standard library or third party packages).</source>
          <target state="translated">특히,이 &quot;기본적으로 무시 됨&quot;목록에는 &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;__main__&lt;/code&gt; 을 제외한 모든 모듈에 대한)이 포함되어 있습니다 . 이는 개발자가 향후 주요 API 변경에 대한 알림을 받기 위해 일반적으로 무시되는 경고로 코드를 테스트해야한다는 것을 의미합니다. 표준 라이브러리 또는 타사 패키지).</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="eaaf5966f427f3dea82bee61a4387fc35eceff0f" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;Decimal.from_float(0.1)&lt;/code&gt; is not the same as &lt;code&gt;Decimal(&amp;lsquo;0.1&amp;rsquo;)&lt;/code&gt;. Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is &lt;code&gt;0x1.999999999999ap-4&lt;/code&gt;. That equivalent value in decimal is &lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Decimal.from_float(0.1)&lt;/code&gt; 은 &lt;code&gt;Decimal(&amp;lsquo;0.1&amp;rsquo;)&lt;/code&gt; 과 다릅니다 . 0.1은 이진 부동 소수점으로 정확하게 표현할 수 없으므로 값은 &lt;code&gt;0x1.999999999999ap-4&lt;/code&gt; 인 가장 가까운 표현 가능한 값으로 저장됩니다 . 해당 10 진수 값은 &lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a228a03ba762c109dde9253a8ec3fc25b50a1c65" translate="yes" xml:space="preserve">
          <source>Note also that being reentrant is &lt;em&gt;not&lt;/em&gt; the same thing as being thread safe. &lt;a href=&quot;#contextlib.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout()&lt;/code&gt;&lt;/a&gt;, for example, is definitely not thread safe, as it makes a global modification to the system state by binding &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; to a different stream.</source>
          <target state="translated">재진입은 스레드 안전과 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어 &lt;a href=&quot;#contextlib.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 을 다른 스트림 에 바인딩하여 시스템 상태를 전역 적으로 수정하므로 스레드로부터 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f61fec861c768279fab36f6f5c37291126c064a6" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; returns the toplevel module here because this is the object that is bound to a name by the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 가 여기에서 최상위 레벨 모듈을 리턴 하는 방법에 주목 하십시오. 이는 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문에 의해 이름에 바인드 된 오브젝트이기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="39a7d5217c5c02cfeb8a4550c216b87b699db0c2" translate="yes" xml:space="preserve">
          <source>Note however that &lt;a href=&quot;#timeit.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt; will automatically determine the number of repetitions only when the command-line interface is used. In the &lt;a href=&quot;#timeit-examples&quot;&gt;Examples&lt;/a&gt; section you can find more advanced examples.</source>
          <target state="translated">그러나 &lt;a href=&quot;#timeit.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 는 명령 행 인터페이스가 사용될 때만 반복 횟수를 자동으로 결정합니다. 에서 &lt;a href=&quot;#timeit-examples&quot;&gt;예&lt;/a&gt; 섹션을 좀 더 고급 예제를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f54f228df230f0474c98b205804fa448f5fe875b" translate="yes" xml:space="preserve">
          <source>Note however that in &lt;a href=&quot;#re.MULTILINE&quot;&gt;&lt;code&gt;MULTILINE&lt;/code&gt;&lt;/a&gt; mode &lt;a href=&quot;#re.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; only matches at the beginning of the string, whereas using &lt;a href=&quot;#re.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; with a regular expression beginning with &lt;code&gt;'^'&lt;/code&gt; will match at the beginning of each line.</source>
          <target state="translated">그러나 &lt;a href=&quot;#re.MULTILINE&quot;&gt; &lt;code&gt;MULTILINE&lt;/code&gt; &lt;/a&gt; 모드에서 &lt;a href=&quot;#re.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 는 문자열의 시작 부분에서만 일치하는 반면 &lt;code&gt;'^'&lt;/code&gt; 로 시작하는 정규 표현식으로 &lt;a href=&quot;#re.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 사용하면 각 행의 시작 부분에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="05beb81acbbd60ea7c3692e5bef7179c9b5915a3" translate="yes" xml:space="preserve">
          <source>Note in particular that an exception will be raised if &lt;em&gt;methodname&lt;/em&gt; has not been &lt;em&gt;exposed&lt;/em&gt;.</source>
          <target state="translated">특히 &lt;em&gt;methodname&lt;/em&gt; 이 &lt;em&gt;노출&lt;/em&gt; 되지 않은 경우 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="bcb9bc5733348cf84603de82545dd9a70a1be5f4" translate="yes" xml:space="preserve">
          <source>Note in particular that options (such as &lt;em&gt;-input&lt;/em&gt;) and arguments (such as &lt;em&gt;eggs.txt&lt;/em&gt;) that are separated by whitespace in the shell go in separate list elements, while arguments that need quoting or backslash escaping when used in the shell (such as filenames containing spaces or the &lt;em&gt;echo&lt;/em&gt; command shown above) are single list elements.</source>
          <target state="translated">특히 셸에서 공백으로 구분 된 옵션 (예 : &lt;em&gt;-input&lt;/em&gt; )과 인수 (예 : &lt;em&gt;eggs.txt&lt;/em&gt; )는 별도의 목록 요소로 이동하고 셸에서 사용될 때 따옴표 나 백 슬래시 이스케이프가 필요한 인수 (예 : 공백이 포함 된 파일 이름 또는 위에 표시된 &lt;em&gt;echo&lt;/em&gt; 명령은 단일 목록 요소입니다.</target>
        </trans-unit>
        <trans-unit id="facb49e906f58a2995d4a0cf64fd63f312feb840" translate="yes" xml:space="preserve">
          <source>Note on SIGPIPE</source>
          <target state="translated">SIGPIPE에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="93d7b55b91dfb84b963b538a0f61240812a059a0" translate="yes" xml:space="preserve">
          <source>Note on VxWorks, this function doesn&amp;rsquo;t return &lt;code&gt;-signal&lt;/code&gt; when the new process is killed. Instead it raises OSError exception.</source>
          <target state="translated">VxWorks에서이 함수는 새 프로세스가 종료 될 때 &lt;code&gt;-signal&lt;/code&gt; 반환하지 않습니다 . 대신 OSError 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e7e41fdb90e46b885d4fc21bb32cf0b77b1568d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; objects only remove an action if all of its option strings are overridden. So, in the example above, the old &lt;code&gt;-f/--foo&lt;/code&gt; action is retained as the &lt;code&gt;-f&lt;/code&gt; action, because only the &lt;code&gt;--foo&lt;/code&gt; option string was overridden.</source>
          <target state="translated">참고 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 은&lt;/a&gt; 자신의 선택 문자열 모두가 무시하는 경우에만 작업을 제거 객체. 따라서 위의 예 에서 &lt;code&gt;--foo&lt;/code&gt; 옵션 문자열 만 재정의 되었으므로 이전 &lt;code&gt;-f/--foo&lt;/code&gt; 동작은 &lt;code&gt;-f&lt;/code&gt; 동작으로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbabc92aff4ed81b97fa59772d1100b9a7b02ef9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#asyncore.dispatcher.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; may raise &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; , even though &lt;a href=&quot;select#select.select&quot;&gt;&lt;code&gt;select.select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;select#select.poll&quot;&gt;&lt;code&gt;select.poll()&lt;/code&gt;&lt;/a&gt; has reported the socket ready for reading.</source>
          <target state="translated">참고 &lt;a href=&quot;#asyncore.dispatcher.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 제기 할 수 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 을&lt;/a&gt; 하더라도, &lt;a href=&quot;select#select.select&quot;&gt; &lt;code&gt;select.select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;select#select.poll&quot;&gt; &lt;code&gt;select.poll()&lt;/code&gt; &lt;/a&gt; 독서에 대한 준비가 소켓을보고했습니다.</target>
        </trans-unit>
        <trans-unit id="21a214d994f16e1f90118d934dbbf9725f16b159" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; called for any operations besides &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;. This means that &lt;code&gt;get()&lt;/code&gt; will, like normal dictionaries, return &lt;code&gt;None&lt;/code&gt; as a default rather than using &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 외에 어떤 작업을 요구 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; . 즉 , 일반 사전과 마찬가지로 &lt;code&gt;get()&lt;/code&gt; 은 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; 를&lt;/a&gt; 사용하지 않고 &lt;code&gt;None&lt;/code&gt; 을 기본값으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0481906125c173c6e85bed62a526281abaa1516a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ&lt;/code&gt;&lt;/a&gt;-generated deltas make no claim to be &lt;strong&gt;minimal&lt;/strong&gt; diffs. To the contrary, minimal diffs are often counter-intuitive, because they synch up anywhere possible, sometimes accidental matches 100 pages apart. Restricting synch points to contiguous matches preserves some notion of locality, at the occasional cost of producing a longer diff.</source>
          <target state="translated">참고 &lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ&lt;/code&gt; &lt;/a&gt; -generated 델타는 어떤 주장이있을 수 있도록 &lt;strong&gt;최소한의&lt;/strong&gt; 차이점. 반대로, 최소한의 차이는 가능한 한 어디서나 동기화되기 때문에 때로는 100 페이지 간격으로 우연히 일치하기 때문에 반 직관적입니다. 동기 점을 연속 경기로 제한하면 더 긴 diff를 생성하는 경우가 많지만 일부 로컬 리티 개념이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="dd69c68c8e1ff03113702c7b4183ad050851c7e0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt;&lt;code&gt;ELLIPSIS&lt;/code&gt;&lt;/a&gt; can also be used to ignore the details of the exception message, but such a test may still fail based on whether or not the module details are printed as part of the exception name. Using &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt;&lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt;&lt;/a&gt; and the details from Python 2.3 is also the only clear way to write a doctest that doesn&amp;rsquo;t care about the exception detail yet continues to pass under Python 2.3 or earlier (those releases do not support &lt;a href=&quot;#doctest-directives&quot;&gt;doctest directives&lt;/a&gt; and ignore them as irrelevant comments). For example:</source>
          <target state="translated">참고 &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt; &lt;code&gt;ELLIPSIS&lt;/code&gt; &lt;/a&gt; 또한 예외 메시지의 내용을 무시하는데 사용될 수 있지만, 그러한 테스트가 여전히 모듈의 세부 사항을 제외 이름의 일부로서 인쇄 여부에 기초하여 실패 할 수있다. &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt; &lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt; &lt;/a&gt; 과 Python 2.3의 세부 정보를 사용하는 것도 예외 세부 사항을 신경 쓰지 않고 Python 2.3 또는 이전 버전에서 계속 통과하는 doctest를 작성하는 유일한 명확한 방법입니다 (이 릴리스는 &lt;a href=&quot;#doctest-directives&quot;&gt;doctest 지시문을&lt;/a&gt; 지원하지 않고 관련이없는 주석으로 무시합니다) ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e63f31f55e12cdee25e7b08fb73243d54374458" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#float.hex&quot;&gt;&lt;code&gt;float.hex()&lt;/code&gt;&lt;/a&gt; is an instance method, while &lt;a href=&quot;#float.fromhex&quot;&gt;&lt;code&gt;float.fromhex()&lt;/code&gt;&lt;/a&gt; is a class method.</source>
          <target state="translated">주의 &lt;a href=&quot;#float.hex&quot;&gt; &lt;code&gt;float.hex()&lt;/code&gt; &lt;/a&gt; 동안 인스턴스 방법 &lt;a href=&quot;#float.fromhex&quot;&gt; &lt;code&gt;float.fromhex()&lt;/code&gt; &lt;/a&gt; 클래스 방법이다.</target>
        </trans-unit>
        <trans-unit id="8a0c31b2a17d1253675bf81f567abe1a01487d1b" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt;&lt;code&gt;domain_return_ok()&lt;/code&gt;&lt;/a&gt; is called for every &lt;em&gt;cookie&lt;/em&gt; domain, not just for the &lt;em&gt;request&lt;/em&gt; domain. For example, the function might be called with both &lt;code&gt;&quot;.example.com&quot;&lt;/code&gt; and &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt; if the request domain is &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt;. The same goes for &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt; &lt;code&gt;domain_return_ok()&lt;/code&gt; &lt;/a&gt; 모든 호출됩니다 &lt;em&gt;쿠키&lt;/em&gt; 에 대한뿐만 아니라, 도메인 &lt;em&gt;요청&lt;/em&gt; 도메인. 예를 들어 요청 도메인이 &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt; 인 경우 &lt;code&gt;&quot;.example.com&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt; 을 사용 하여 함수를 호출 할 수 있습니다 . &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="adc891a129f72cc10502357d2a58f83d2b041536" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#inspect.signature&quot;&gt;&lt;code&gt;signature()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#inspect-signature-object&quot;&gt;Signature Object&lt;/a&gt; provide the recommended API for callable introspection, and support additional behaviours (like positional-only arguments) that are sometimes encountered in extension module APIs. This function is retained primarily for use in code that needs to maintain compatibility with the Python 2 &lt;code&gt;inspect&lt;/code&gt; module API.</source>
          <target state="translated">참고 &lt;a href=&quot;#inspect.signature&quot;&gt; &lt;code&gt;signature()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#inspect-signature-object&quot;&gt;서명 객체가&lt;/a&gt; 호출 성찰에 대한 권장 API를 제공하고, 때로는 확장 모듈의 API에서 발생하는 (위치 만 인수와 같은) 추가 행동을 지원합니다. 이 함수는 주로 Python 2 &lt;code&gt;inspect&lt;/code&gt; 모듈 API 와의 호환성을 유지해야하는 코드에서 사용하기 위해 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddd48ccb5c495507a52bd279914fdcc7d41317f6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#math.frexp&quot;&gt;&lt;code&gt;frexp()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#math.modf&quot;&gt;&lt;code&gt;modf()&lt;/code&gt;&lt;/a&gt; have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an &amp;lsquo;output parameter&amp;rsquo; (there is no such thing in Python).</source>
          <target state="translated">참고 &lt;a href=&quot;#math.frexp&quot;&gt; &lt;code&gt;frexp()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#math.modf&quot;&gt; &lt;code&gt;modf()&lt;/code&gt; &lt;/a&gt; 자신의 C 당량 상이한 호출 / 복귀 패턴이있다 : 그들은 하나의 인자를 가지고 오히려 '출력 변수'를 통해 제 2 복귀 값을 반환하는 것보다, 한 쌍의 값을 반환은 (더 없다 파이썬에서 그런 것들).</target>
        </trans-unit>
        <trans-unit id="c47ac53dbffb6c7e920e0e9c3a5bd7e68f910640" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; does not have OOR (original object return), it constructs a new, equivalent object each time you retrieve an attribute:</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; OOR (원본 객체 반환)이없는, 그것은 새로운, 해당 객체에게 당신이 속성을 검색 할 때마다 구성한다 :</target>
        </trans-unit>
        <trans-unit id="021cbf64fa7daa47a193a25312368fd1063a8ec4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; is actually a factory function which returns an instance of &lt;code&gt;multiprocessing.synchronize.Lock&lt;/code&gt; initialized with a default context.</source>
          <target state="translated">참고 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 반환하는 공장 기능을 실제로 &lt;code&gt;multiprocessing.synchronize.Lock&lt;/code&gt; 기본 컨텍스트로 초기화가.</target>
        </trans-unit>
        <trans-unit id="35bd8a5288450aef9ec563731c03552420d81a78" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; is actually a factory function which returns an instance of &lt;code&gt;multiprocessing.synchronize.RLock&lt;/code&gt; initialized with a default context.</source>
          <target state="translated">참고 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; 가&lt;/a&gt; 의 인스턴스를 반환하는 공장 기능을 실제로 &lt;code&gt;multiprocessing.synchronize.RLock&lt;/code&gt; 기본 컨텍스트로 초기화가.</target>
        </trans-unit>
        <trans-unit id="9325e13fae2a61a60a73c50f96336405ee30e5aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#pkgutil.ImpImporter&quot;&gt;&lt;code&gt;ImpImporter&lt;/code&gt;&lt;/a&gt; does not currently support being used by placement on &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#pkgutil.ImpImporter&quot;&gt; &lt;code&gt;ImpImporter&lt;/code&gt; 은&lt;/a&gt; 현재 지원하지 않습니다는에 배치 사용하고 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="beaaa22c5ee17911c79acb082b3767365455460e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#socketserver.UnixDatagramServer&quot;&gt;&lt;code&gt;UnixDatagramServer&lt;/code&gt;&lt;/a&gt; derives from &lt;a href=&quot;#socketserver.UDPServer&quot;&gt;&lt;code&gt;UDPServer&lt;/code&gt;&lt;/a&gt;, not from &lt;a href=&quot;#socketserver.UnixStreamServer&quot;&gt;&lt;code&gt;UnixStreamServer&lt;/code&gt;&lt;/a&gt; &amp;mdash; the only difference between an IP and a Unix stream server is the address family, which is simply repeated in both Unix server classes.</source>
          <target state="translated">참고 &lt;a href=&quot;#socketserver.UnixDatagramServer&quot;&gt; &lt;code&gt;UnixDatagramServer&lt;/code&gt; 의&lt;/a&gt; 에서 파생 &lt;a href=&quot;#socketserver.UDPServer&quot;&gt; &lt;code&gt;UDPServer&lt;/code&gt; 이&lt;/a&gt; 아니라에서 &lt;a href=&quot;#socketserver.UnixStreamServer&quot;&gt; &lt;code&gt;UnixStreamServer&lt;/code&gt; &lt;/a&gt; 의 IP와 유닉스 스트림 서버 사이의 유일한 차이는 단순히 두 유닉스 서버 클래스 반복되는 주소 패밀리입니다 -.</target>
        </trans-unit>
        <trans-unit id="778f82ffcb2b485246b0e53ae55c103c932424fb" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; is implemented as part of the binding process for explicit dotted attribute lookups such as &lt;code&gt;super().__getitem__(name)&lt;/code&gt;. It does so by implementing its own &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; is undefined for implicit lookups using statements or operators such as &lt;code&gt;super()[name]&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 명시 적 점선 속성에 대한 바인딩 프로세스의 일부로서 구현과 같은 조회 &lt;code&gt;super().__getitem__(name)&lt;/code&gt; . 협력 다중 상속을 지원하는 예측 가능한 순서로 클래스를 검색하기 위해 자체 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 메소드를 구현하여 이를 수행합니다. 따라서 &lt;code&gt;super()[name]&lt;/code&gt; 와 같은 명령문이나 연산자를 사용하여 암시 적 검색에 대해 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d150903542528eb29c182959a6e94d9657319e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; skips over comments in the input instead of creating comment objects for them. An &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; will only contain comment nodes if they have been inserted into to the tree using one of the &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 대신 그들을 위해 주석 객체를 생성의 입력에 주석을 통해 건너 뜁니다. &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; 는&lt;/a&gt; 그들이 중 하나를 사용하여 트리에 삽입 된 경우에만 주석 노드를 포함 할 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="7733b443aa3ad7da3792a2988711f38bba4a2a03" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; skips over processing instructions in the input instead of creating comment objects for them. An &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; will only contain processing instruction nodes if they have been inserted into to the tree using one of the &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 입력에 지시 사항을 처리하는 대신 그들을 위해 주석 객체를 생성 건너 뜁니다. &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; 는&lt;/a&gt; 그들 만이 중 하나를 사용하여 트리에 삽입 된 경우 명령 노드를 처리 포함 할 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="0a0e52a29264a10a0ed33e3ee017893c317f8a46" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt;&lt;code&gt;startPrefixMapping()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt;&lt;code&gt;endPrefixMapping()&lt;/code&gt;&lt;/a&gt; events are not guaranteed to be properly nested relative to each-other: all &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt;&lt;code&gt;startPrefixMapping()&lt;/code&gt;&lt;/a&gt; events will occur before the corresponding &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt;&lt;code&gt;startElement()&lt;/code&gt;&lt;/a&gt; event, and all &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt;&lt;code&gt;endPrefixMapping()&lt;/code&gt;&lt;/a&gt; events will occur after the corresponding &lt;a href=&quot;#xml.sax.handler.ContentHandler.endElement&quot;&gt;&lt;code&gt;endElement()&lt;/code&gt;&lt;/a&gt; event, but their order is not guaranteed.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt; &lt;code&gt;startPrefixMapping()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt; &lt;code&gt;endPrefixMapping()&lt;/code&gt; &lt;/a&gt; 모든 : 이벤트가 각각 올바르게 상자로 보장되지 않습니다 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt; &lt;code&gt;startPrefixMapping()&lt;/code&gt; &lt;/a&gt; 이벤트가 해당 전에 발생 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt; &lt;code&gt;startElement()&lt;/code&gt; &lt;/a&gt; 이벤트, 모든 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt; &lt;code&gt;endPrefixMapping()&lt;/code&gt; &lt;/a&gt; 이벤트는 해당 후 발생 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endElement&quot;&gt; &lt;code&gt;endElement()&lt;/code&gt; &lt;/a&gt; 이벤트이지만 주문이 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="47444f992c8f787e5218f00f598cb803627da402" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;'a:gz'&lt;/code&gt;, &lt;code&gt;'a:bz2'&lt;/code&gt; or &lt;code&gt;'a:xz'&lt;/code&gt; is not possible. If &lt;em&gt;mode&lt;/em&gt; is not suitable to open a certain (compressed) file for reading, &lt;a href=&quot;#tarfile.ReadError&quot;&gt;&lt;code&gt;ReadError&lt;/code&gt;&lt;/a&gt; is raised. Use &lt;em&gt;mode&lt;/em&gt;&lt;code&gt;'r'&lt;/code&gt; to avoid this. If a compression method is not supported, &lt;a href=&quot;#tarfile.CompressionError&quot;&gt;&lt;code&gt;CompressionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">참고 &lt;code&gt;'a:gz'&lt;/code&gt; , &lt;code&gt;'a:bz2'&lt;/code&gt; 또는 &lt;code&gt;'a:xz'&lt;/code&gt; 수 없습니다. 경우 &lt;em&gt;모드를&lt;/em&gt; 읽기 위해 특정 (압축) 파일을 열 수 적합하지 않다, &lt;a href=&quot;#tarfile.ReadError&quot;&gt; &lt;code&gt;ReadError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 이를 피 하려면 &lt;em&gt;모드 &lt;/em&gt; &lt;code&gt;'r'&lt;/code&gt; 을 사용하십시오 . 압축 방법이 지원되지 않으면 &lt;a href=&quot;#tarfile.CompressionError&quot;&gt; &lt;code&gt;CompressionError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1cc69e2c68bc296e588d8f892981cbd43a28c6e1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Lock&lt;/code&gt; is actually a factory function which returns an instance of the most efficient version of the concrete Lock class that is supported by the platform.</source>
          <target state="translated">참고 &lt;code&gt;Lock&lt;/code&gt; 플랫폼에서 지원하는 콘크리트 잠금 클래스의 가장 효율적인 버전의 인스턴스를 반환하는 공장 기능은 사실이다.</target>
        </trans-unit>
        <trans-unit id="ee6451008c83ce88b9e80fafc4e7537e799843ea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;None&lt;/code&gt; as a type hint is a special case and is replaced by &lt;code&gt;type(None)&lt;/code&gt;.</source>
          <target state="translated">유의하십시오 &lt;code&gt;None&lt;/code&gt; 타입 힌트는 특별한 경우에 의해 대체 될 때 &lt;code&gt;type(None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57fae4790fdc5439f742aac77bc9daa66d83e4d4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;None&lt;/code&gt; may be returned if no handler handles the request (though the default installed global &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;#urllib.request.UnknownHandler&quot;&gt;&lt;code&gt;UnknownHandler&lt;/code&gt;&lt;/a&gt; to ensure this never happens).</source>
          <target state="translated">참고 &lt;code&gt;None&lt;/code&gt; 어떤 핸들러가 요청을 처리하지 않는 경우 반환 될 수 있습니다 (기본값은 글로벌 설치하지만 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; 는&lt;/a&gt; 사용 &lt;a href=&quot;#urllib.request.UnknownHandler&quot;&gt; &lt;code&gt;UnknownHandler&lt;/code&gt; 를&lt;/a&gt; 이 일이 결코 보장하기 위해).</target>
        </trans-unit>
        <trans-unit id="236fa39ea36e5dba046de057b39ac4f3d0d57af9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;RLock&lt;/code&gt; is actually a factory function which returns an instance of the most efficient version of the concrete RLock class that is supported by the platform.</source>
          <target state="translated">참고 &lt;code&gt;RLock&lt;/code&gt; 이 플랫폼에서 지원하는 콘크리트 RLock 클래스의 가장 효율적인 버전의 인스턴스를 반환하는 공장 기능은 사실이다.</target>
        </trans-unit>
        <trans-unit id="9ed32062270ce11074feca5a6bc1d17484d5ca1f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Type[C]&lt;/code&gt; is covariant:</source>
          <target state="translated">참고 &lt;code&gt;Type[C]&lt;/code&gt; 공변입니다 :</target>
        </trans-unit>
        <trans-unit id="5b9cfa59b4f04a3b3e5fb4f6cd1086211b01f3d0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;bletch&lt;/code&gt; is omitted because it doesn&amp;rsquo;t exist; the &lt;code&gt;bar&lt;/code&gt; directory precedes the &lt;code&gt;foo&lt;/code&gt; directory because &lt;code&gt;bar.pth&lt;/code&gt; comes alphabetically before &lt;code&gt;foo.pth&lt;/code&gt;; and &lt;code&gt;spam&lt;/code&gt; is omitted because it is not mentioned in either path configuration file.</source>
          <target state="translated">참고 &lt;code&gt;bletch&lt;/code&gt; 가 존재하지 않기 때문에 생략; &lt;code&gt;bar&lt;/code&gt; 디렉토리는 앞에 &lt;code&gt;foo&lt;/code&gt; 때문에 디렉토리를 &lt;code&gt;bar.pth&lt;/code&gt; 이 전에 알파벳 순으로 제공 &lt;code&gt;foo.pth&lt;/code&gt; ; 및 &lt;code&gt;spam&lt;/code&gt; 이 두 경로 구성 파일에 언급되지 않기 때문에 생략하기로한다.</target>
        </trans-unit>
        <trans-unit id="d33be2cd5b4983695dd8516ab51e58c98eb1cabb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;filter(function, iterable)&lt;/code&gt; is equivalent to the generator expression &lt;code&gt;(item for item in iterable if function(item))&lt;/code&gt; if function is not &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;(item for item in iterable if item)&lt;/code&gt; if function is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;filter(function, iterable)&lt;/code&gt; 발전기 식 동등 &lt;code&gt;(item for item in iterable if function(item))&lt;/code&gt; 기능하지 없으면 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;(item for item in iterable if item)&lt;/code&gt; 기능이없는 경우는 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85efeca034605ee9db13f57e747d94bb977067bc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;fork()&lt;/code&gt; calls made by third-party C code may not call those functions, unless it explicitly calls &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_BeforeFork&quot;&gt;&lt;code&gt;PyOS_BeforeFork()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Parent&quot;&gt;&lt;code&gt;PyOS_AfterFork_Parent()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Child&quot;&gt;&lt;code&gt;PyOS_AfterFork_Child()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그 주 &lt;code&gt;fork()&lt;/code&gt; 명시 적으로 호출하지 않는 한, 그 함수를 호출 할 수있는 제 3 자 C 코드에 의해 호출 &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_BeforeFork&quot;&gt; &lt;code&gt;PyOS_BeforeFork()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Parent&quot;&gt; &lt;code&gt;PyOS_AfterFork_Parent()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Child&quot;&gt; &lt;code&gt;PyOS_AfterFork_Child()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ba61f0ef9cfc007a2b6f8bfd3fbe4f04edd595" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;m.start(group)&lt;/code&gt; will equal &lt;code&gt;m.end(group)&lt;/code&gt; if &lt;em&gt;group&lt;/em&gt; matched a null string. For example, after &lt;code&gt;m = re.search('b(c?)', 'cba')&lt;/code&gt;, &lt;code&gt;m.start(0)&lt;/code&gt; is 1, &lt;code&gt;m.end(0)&lt;/code&gt; is 2, &lt;code&gt;m.start(1)&lt;/code&gt; and &lt;code&gt;m.end(1)&lt;/code&gt; are both 2, and &lt;code&gt;m.start(2)&lt;/code&gt; raises an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">참고 &lt;code&gt;m.start(group)&lt;/code&gt; 동일 할 &lt;code&gt;m.end(group)&lt;/code&gt; 경우 &lt;em&gt;그룹&lt;/em&gt; 널 문자열을 매치. 예를 들어 &lt;code&gt;m = re.search('b(c?)', 'cba')&lt;/code&gt; 후에 &lt;code&gt;m.start(0)&lt;/code&gt; 은 1, &lt;code&gt;m.end(0)&lt;/code&gt; 은 2, &lt;code&gt;m.start(1)&lt;/code&gt; 및 &lt;code&gt;m.end(1)&lt;/code&gt; 은 2이고 &lt;code&gt;m.start(2)&lt;/code&gt; 는 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a801fa594d8a089d333c1d08dda4b81a98110981" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;metavar&lt;/code&gt; only changes the &lt;em&gt;displayed&lt;/em&gt; name - the name of the attribute on the &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; object is still determined by the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value.</source>
          <target state="translated">참고 &lt;code&gt;metavar&lt;/code&gt; 이 변경 사항 만 &lt;em&gt;표시&lt;/em&gt; 이름을 -상의 속성의 이름 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 객체는 여전히에 의해 결정된다 &lt;a href=&quot;#dest&quot;&gt;이명 령&lt;/a&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="36e3e839ce2533fb32ef0684d4636235258670ad" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;nargs=1&lt;/code&gt; produces a list of one item. This is different from the default, in which the item is produced by itself.</source>
          <target state="translated">하는 것으로 &lt;code&gt;nargs=1&lt;/code&gt; 한 항목의 목록을 생성합니다. 항목 자체가 생성되는 기본값과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6cb4d80564b60cb42824f340ae271f84acf512f2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;quote(string, safe, encoding, errors)&lt;/code&gt; is equivalent to &lt;code&gt;quote_from_bytes(string.encode(encoding, errors), safe)&lt;/code&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;quote(string, safe, encoding, errors)&lt;/code&gt; 에 해당 &lt;code&gt;quote_from_bytes(string.encode(encoding, errors), safe)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc85143f0c8971e93992f10750203e06ab969614" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;temp0&lt;/code&gt; and &lt;code&gt;temp1&lt;/code&gt; are objects still using the internal buffer of the &lt;code&gt;rc&lt;/code&gt; object above. So executing &lt;code&gt;rc.a = temp0&lt;/code&gt; copies the buffer contents of &lt;code&gt;temp0&lt;/code&gt; into &lt;code&gt;rc&lt;/code&gt; &amp;lsquo;s buffer. This, in turn, changes the contents of &lt;code&gt;temp1&lt;/code&gt;. So, the last assignment &lt;code&gt;rc.b = temp1&lt;/code&gt;, doesn&amp;rsquo;t have the expected effect.</source>
          <target state="translated">참고 &lt;code&gt;temp0&lt;/code&gt; 을 하고 &lt;code&gt;temp1&lt;/code&gt; 여전히 내부 버퍼를 사용하여 객체 &lt;code&gt;rc&lt;/code&gt; 상기 개체. 따라서 &lt;code&gt;rc.a = temp0&lt;/code&gt; 실행 하면 temp0 의 버퍼 내용이 &lt;code&gt;rc&lt;/code&gt; 의 버퍼 에 &lt;code&gt;temp0&lt;/code&gt; 됩니다 . 결과적으로 &lt;code&gt;temp1&lt;/code&gt; 의 내용이 변경 됩니다. 따라서 마지막 할당 &lt;code&gt;rc.b = temp1&lt;/code&gt; 은 예상 된 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f362e945054667a3816f573ef83bd7edea53f2a" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;all&lt;/em&gt;&lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; modifications in the body of the context manager, including replacement of the object, will be reverted at the end of the block.</source>
          <target state="translated">참고 &lt;em&gt;모든 &lt;/em&gt;&lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에의&lt;/a&gt; 물체의 교체를 포함하는 콘텍스트 관리자의 본체에 변형이 상기 블록의 끝에서 복귀한다.</target>
        </trans-unit>
        <trans-unit id="ce5fc6b37538034752807f8815ba613f8bc848ab" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;lock&lt;/em&gt; is a keyword only argument.</source>
          <target state="translated">참고 &lt;em&gt;잠금&lt;/em&gt; 키워드만을 인수입니다.</target>
        </trans-unit>
        <trans-unit id="3b2234a6dca333d6acda4ece1514b447bb223c5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;lock&lt;/em&gt; is a keyword-only argument.</source>
          <target state="translated">참고 것을 &lt;em&gt;잠금&lt;/em&gt; 키워드 전용 인수이다.</target>
        </trans-unit>
        <trans-unit id="3e5897049932333313c37f96477a83c9d676a2c7" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;mapname&lt;/em&gt; is first checked if it is an alias to another name.</source>
          <target state="translated">참고 &lt;em&gt;맵 이름은&lt;/em&gt; 또 다른 이름의 별칭 인 경우 먼저 확인한다.</target>
        </trans-unit>
        <trans-unit id="0bf52d3f07d9f7c54657bde5e8753068a541df3d" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;subtype&lt;/em&gt; is optional; if omitted, then subpart MIME type matching is done only with the main type. &lt;em&gt;maintype&lt;/em&gt; is optional too; it defaults to &lt;em&gt;text&lt;/em&gt;.</source>
          <target state="translated">참고 &lt;em&gt;하위 유형은&lt;/em&gt; 선택 사항입니다; 생략하면 하위 부분 MIME 형식 일치는 기본 형식으로 만 수행됩니다. &lt;em&gt;maintype&lt;/em&gt; 도 옵션입니다. 기본값은 &lt;em&gt;text&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="185bf61bd6bed1a3aeabce3b0e19da1aead89726" translate="yes" xml:space="preserve">
          <source>Note that CGI scripts will be run with UID of user nobody, for security reasons. Problems with the CGI script will be translated to error 403.</source>
          <target state="translated">보안상의 이유로 CGI 스크립트는 nobody 사용자의 UID로 실행됩니다. CGI 스크립트 문제는 오류 403으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2d9d2deaf97052c0294923500df788d9b644ff07" translate="yes" xml:space="preserve">
          <source>Note that DOM attributes may also be manipulated as nodes instead of as simple strings. It is fairly rare that you must do this, however, so this usage is not yet documented.</source>
          <target state="translated">DOM 속성은 간단한 문자열 대신 노드로 조작 될 수도 있습니다. 그러나이 작업을 수행해야하는 경우는 매우 드물기 때문에이 사용법은 아직 문서화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f0c209dc694d0046aa169702d84ba458e5877b53" translate="yes" xml:space="preserve">
          <source>Note that GNU &lt;strong&gt;gettext&lt;/strong&gt; also defines a &lt;code&gt;dcgettext()&lt;/code&gt; method, but this was deemed not useful and so it is currently unimplemented.</source>
          <target state="translated">GNU &lt;strong&gt;gettext&lt;/strong&gt; 는 &lt;code&gt;dcgettext()&lt;/code&gt; 메소드 도 정의 하지만 유용하지 않은 것으로 간주되어 현재 구현되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac3a38393892122ad7e515b32aa73f768974848c" translate="yes" xml:space="preserve">
          <source>Note that IMAP4 message numbers change as the mailbox changes; in particular, after an &lt;code&gt;EXPUNGE&lt;/code&gt; command performs deletions the remaining messages are renumbered. So it is highly advisable to use UIDs instead, with the UID command.</source>
          <target state="translated">사서함이 변경되면 IMAP4 메시지 번호가 변경됩니다. 특히 &lt;code&gt;EXPUNGE&lt;/code&gt; 명령이 삭제를 수행 한 후 나머지 메시지의 번호가 다시 매겨집니다. 따라서 UID 명령과 함께 UID를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="171726c431e5e57c0ba8ef895a87dd12a2775147" translate="yes" xml:space="preserve">
          <source>Note that POP3, though widely supported, is obsolescent. The implementation quality of POP3 servers varies widely, and too many are quite poor. If your mailserver supports IMAP, you would be better off using the &lt;a href=&quot;imaplib#imaplib.IMAP4&quot;&gt;&lt;code&gt;imaplib.IMAP4&lt;/code&gt;&lt;/a&gt; class, as IMAP servers tend to be better implemented.</source>
          <target state="translated">POP3는 널리 지원되지만 사용되지 않습니다. POP3 서버의 구현 품질은 매우 다양하며 너무 많은 것이 매우 열악합니다. 메일 서버가 IMAP를 지원하는 경우 IMAP 서버가 더 잘 구현되는 경향이 있으므로 &lt;a href=&quot;imaplib#imaplib.IMAP4&quot;&gt; &lt;code&gt;imaplib.IMAP4&lt;/code&gt; &lt;/a&gt; 클래스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b0976769a6f63c576221d99c17d735ec72b6244d" translate="yes" xml:space="preserve">
          <source>Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet.</source>
          <target state="translated">파이썬은 신호 NaN을 조용한 NaN과 구별하기 위해 노력하지 않으며 NaN 신호를위한 동작은 지정되지 않은 상태로 남아 있습니다. 일반적인 동작은 모든 NaN을 조용히 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9296f2c1170009e8779568448d5aef2bd32ea765" translate="yes" xml:space="preserve">
          <source>Note that SSL-on-563 is discouraged per &lt;a href=&quot;https://tools.ietf.org/html/rfc4642.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 4642&lt;/strong&gt;&lt;/a&gt;, in favor of STARTTLS as described below. However, some servers only support the former.</source>
          <target state="translated">SSL-on-563은 아래 설명 된 STARTTLS를 위해 &lt;a href=&quot;https://tools.ietf.org/html/rfc4642.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 4642에&lt;/strong&gt;&lt;/a&gt; 따라 사용하지 않는 것이 좋습니다 . 그러나 일부 서버는 전자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0d544a9bc75ffdcf42bb88359222d7a7b4debd33" translate="yes" xml:space="preserve">
          <source>Note that a daemonic process is not allowed to create child processes. Otherwise a daemonic process would leave its children orphaned if it gets terminated when its parent process exits. Additionally, these are &lt;strong&gt;not&lt;/strong&gt; Unix daemons or services, they are normal processes that will be terminated (and not joined) if non-daemonic processes have exited.</source>
          <target state="translated">데몬 프로세스는 자식 프로세스를 만들 수 없습니다. 그렇지 않으면, 부모 프로세스가 종료 될 때 데몬 프로세스가 종료되면 자식 프로세스가 분리됩니다. 또한 이들은 Unix 데몬이나 서비스 가 &lt;strong&gt;아니며&lt;/strong&gt; , 비 프로세스 프로세스가 종료 된 경우 종료되고 결합되지 않는 정상적인 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="b3ab68b2d6d6352eec66994675336fc958445858" translate="yes" xml:space="preserve">
          <source>Note that a queue created using a manager does not have this issue. See &lt;a href=&quot;#multiprocessing-programming&quot;&gt;Programming guidelines&lt;/a&gt;.</source>
          <target state="translated">관리자를 사용하여 생성 된 대기열에는이 문제가 없습니다. &lt;a href=&quot;#multiprocessing-programming&quot;&gt;프로그래밍 지침을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83b09fa4d37d211dda63c2257b5bbfcc0eea346c" translate="yes" xml:space="preserve">
          <source>Note that a single name can be bound to multiple objects. If the result is &lt;code&gt;True&lt;/code&gt;, the name may also be bound to other objects, like an int or list, that does not introduce a new namespace.</source>
          <target state="translated">단일 이름은 여러 개체에 바인딩 될 수 있습니다. 결과가 &lt;code&gt;True&lt;/code&gt; 인 경우 이름은 새 네임 스페이스를 도입하지 않는 int 또는 list와 같은 다른 객체에도 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7182d710470dc2eccc4f80d44d9c3c8590984b" translate="yes" xml:space="preserve">
          <source>Note that accessing the ctypes object through the wrapper can be a lot slower than accessing the raw ctypes object.</source>
          <target state="translated">랩퍼를 통해 ctypes 오브젝트에 액세스하는 것은 원시 ctypes 오브젝트에 액세스하는 것보다 훨씬 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfff56aec00da48d3760fdc8fdc321170625cd65" translate="yes" xml:space="preserve">
          <source>Note that additional file formats which can be decompressed by the &lt;strong&gt;gzip&lt;/strong&gt; and &lt;strong&gt;gunzip&lt;/strong&gt; programs, such as those produced by &lt;strong&gt;compress&lt;/strong&gt; and &lt;strong&gt;pack&lt;/strong&gt;, are not supported by this module.</source>
          <target state="translated">&lt;strong&gt;gzip&lt;/strong&gt; 및 &lt;strong&gt;gunzip&lt;/strong&gt; 프로그램에서 압축 해제 할 수있는 추가 파일 형식 ( 예 : &lt;strong&gt;compress&lt;/strong&gt; 및 &lt;strong&gt;pack으로&lt;/strong&gt; 생성 된 파일 형식) 은이 모듈에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29cc14f3bb61b303c6e569ab997e5a9c2519db07" translate="yes" xml:space="preserve">
          <source>Note that all examples in this section &lt;strong&gt;purposefully&lt;/strong&gt; show how to use the low-level event loop APIs, such as &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;loop.run_forever()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt;. Modern asyncio applications rarely need to be written this way; consider using the high-level functions like &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 모든 예제는 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;loop.run_forever()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 과 같은 저수준 이벤트 루프 API를 사용하는 방법을 &lt;strong&gt;의도적으로&lt;/strong&gt; 보여줍니다 . 최신 asyncio 응용 프로그램은 이런 방식으로 작성 될 필요가 거의 없습니다. &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; 과 같은 고급 기능 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="52b13893f67d7ba58e9280b940186eb07db6ac12" translate="yes" xml:space="preserve">
          <source>Note that all sorts on statistics are in descending order (placing most time consuming items first), where as name, file, and line number searches are in ascending order (alphabetical). The subtle distinction between &lt;code&gt;SortKey.NFL&lt;/code&gt; and &lt;code&gt;SortKey.STDNAME&lt;/code&gt; is that the standard name is a sort of the name as printed, which means that the embedded line numbers get compared in an odd way. For example, lines 3, 20, and 40 would (if the file names were the same) appear in the string order 20, 3 and 40. In contrast, &lt;code&gt;SortKey.NFL&lt;/code&gt; does a numeric compare of the line numbers. In fact, &lt;code&gt;sort_stats(SortKey.NFL)&lt;/code&gt; is the same as &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILENAME, SortKey.LINE)&lt;/code&gt;.</source>
          <target state="translated">통계의 모든 정렬은 이름, 파일 및 줄 번호 검색이 알파벳 순서로 오름차순 (내림차순)으로 내림차순으로 정렬됩니다 (가장 시간이 오래 걸리는 항목 우선). &lt;code&gt;SortKey.NFL&lt;/code&gt; 과 &lt;code&gt;SortKey.STDNAME&lt;/code&gt; 의 미묘한 차이점 은 표준 이름이 인쇄 된 이름의 일종이라는 것입니다. 즉, 포함 된 줄 번호가 이상한 방식으로 비교됩니다. 예를 들어, 3, 20 및 40 행 (파일 이름이 동일한 경우)은 문자열 순서 20, 3 및 40으로 나타납니다. 반면에 &lt;code&gt;SortKey.NFL&lt;/code&gt; 은 행 번호를 숫자로 비교합니다. 실제로 &lt;code&gt;sort_stats(SortKey.NFL)&lt;/code&gt; 은 &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILENAME, SortKey.LINE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0c40fc37a9bf565a857f29ad723c19c596a97f9" translate="yes" xml:space="preserve">
          <source>Note that all these functions check ordinal bit values derived from the character of the string you pass in; they do not actually know anything about the host machine&amp;rsquo;s character encoding.</source>
          <target state="translated">이 모든 함수는 전달한 문자열의 문자에서 파생 된 서수 비트 값을 확인합니다. 실제로 호스트 시스템의 문자 인코딩에 대해서는 아무것도 모릅니다.</target>
        </trans-unit>
        <trans-unit id="0102294a10326ceacdc04ecf27b97bae220074cc" translate="yes" xml:space="preserve">
          <source>Note that alternative event loop implementations might have own limitations; please refer to their documentation.</source>
          <target state="translated">대체 이벤트 루프 구현에는 고유 한 제한이있을 수 있습니다. 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45152f2b702b262fbbfcdce7c55047081266ed37" translate="yes" xml:space="preserve">
          <source>Note that although the naming for the above described class attributes is singular (e.g. &lt;code&gt;cssclass_month&lt;/code&gt;&lt;code&gt;cssclass_noday&lt;/code&gt;), one can replace the single CSS class with a space separated list of CSS classes, for example:</source>
          <target state="translated">위에서 설명한 클래스 속성의 이름은 단수 &lt;code&gt;cssclass_month&lt;/code&gt; (예 : cssclass_month &lt;code&gt;cssclass_noday&lt;/code&gt; ) 단일 CSS 클래스를 공백으로 구분 된 CSS 클래스 목록으로 바꿀 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc788fedc235ef380745686ed580eadd15bb5571" translate="yes" xml:space="preserve">
          <source>Note that an array of &lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt;&lt;code&gt;ctypes.c_char&lt;/code&gt;&lt;/a&gt; has &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;raw&lt;/code&gt; attributes which allow one to use it to store and retrieve strings &amp;ndash; see documentation for &lt;a href=&quot;ctypes#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt; &lt;code&gt;ctypes.c_char&lt;/code&gt; &lt;/a&gt; 배열 에는 &lt;code&gt;value&lt;/code&gt; 과 &lt;code&gt;raw&lt;/code&gt; 속성이 있으므로이를 사용하여 문자열을 저장하고 검색 할 수 있습니다 . &lt;a href=&quot;ctypes#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbc239128181b638fbd4155908a13241b2705d34" translate="yes" xml:space="preserve">
          <source>Note that an array of &lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt;&lt;code&gt;ctypes.c_char&lt;/code&gt;&lt;/a&gt; has &lt;em&gt;value&lt;/em&gt; and &lt;em&gt;raw&lt;/em&gt; attributes which allow one to use it to store and retrieve strings.</source>
          <target state="translated">&lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt; &lt;code&gt;ctypes.c_char&lt;/code&gt; &lt;/a&gt; 배열 에는 &lt;em&gt;값&lt;/em&gt; 과 &lt;em&gt;원시&lt;/em&gt; 속성이 있으므로이를 사용하여 문자열을 저장하고 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0725d9c7542906970da6bf54619129ddce9a488b" translate="yes" xml:space="preserve">
          <source>Note that an equivalent command line interface could be produced with less code and more informative help and error messages by using the &lt;a href=&quot;argparse#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;argparse#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하면 코드가 적고 유익한 도움말 및 오류 메시지를 사용하여 동등한 명령 행 인터페이스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d79de2b4a69fab3541bfc76151735d65f04d953a" translate="yes" xml:space="preserve">
          <source>Note that any arguments not in your user-defined groups will end up back in the usual &amp;ldquo;positional arguments&amp;rdquo; and &amp;ldquo;optional arguments&amp;rdquo; sections.</source>
          <target state="translated">사용자 정의 그룹에없는 인수는 일반적인 &quot;위치 인수&quot;및 &quot;선택적 인수&quot;섹션으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="68a57b0f8502dd0b76f40e988de13524a3dc9d6d" translate="yes" xml:space="preserve">
          <source>Note that any data following the terminator will be available for reading by the channel after &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 터미네이터 다음에 오는 모든 데이터를 채널에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10e132ee6084002c7b0a817968e06f5f4037ab02" translate="yes" xml:space="preserve">
          <source>Note that any string beginning with two backslashes is assumed by default to be an &lt;code&gt;'AF_PIPE'&lt;/code&gt; address rather than an &lt;code&gt;'AF_UNIX'&lt;/code&gt; address.</source>
          <target state="translated">두 개의 백 슬래시로 시작하는 문자열은 기본적으로 &lt;code&gt;'AF_UNIX'&lt;/code&gt; 주소가 아닌 &lt;code&gt;'AF_PIPE'&lt;/code&gt; 주소 로 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="27d20a06c7ebcc2a74c0dcd2eec75504ff20d0c8" translate="yes" xml:space="preserve">
          <source>Note that as an exception is propagated down the chain of callers, an &lt;code&gt;'exception'&lt;/code&gt; event is generated at each level.</source>
          <target state="translated">호출자 체인 아래로 예외가 전파되면 &lt;code&gt;'exception'&lt;/code&gt; 이벤트가 각 레벨에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9800dc40fc6ed2861610fc1c540d6d1d8733fe1" translate="yes" xml:space="preserve">
          <source>Note that calling any method (even inquiries) on a closed stream is undefined. Implementations may raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; in this case.</source>
          <target state="translated">닫힌 스트림에서 모든 메소드 (문의 사항 포함)를 호출하는 것은 정의되어 있지 않습니다. 이 경우 구현시 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7982f207f5b326c1a5b9df38ed760b57b9caf0aa" translate="yes" xml:space="preserve">
          <source>Note that child nodes of nodes that have a custom visitor method won&amp;rsquo;t be visited unless the visitor calls &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt;&lt;code&gt;generic_visit()&lt;/code&gt;&lt;/a&gt; or visits them itself.</source>
          <target state="translated">방문자가 &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt; &lt;code&gt;generic_visit()&lt;/code&gt; &lt;/a&gt; 호출 하거나 직접 방문하지 않으면 사용자 정의 방문자 메소드가있는 노드의 하위 노드는 방문하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2d382ed6dd9eab4df2994bedfb13e3537561f992" translate="yes" xml:space="preserve">
          <source>Note that currently expanded netmasks are not supported. That means &lt;code&gt;2001:db00::0/24&lt;/code&gt; is a valid argument while &lt;code&gt;2001:db00::0/ffff:ff00::&lt;/code&gt; not.</source>
          <target state="translated">현재 확장 된 넷 마스크는 지원되지 않습니다. 그 말 &lt;code&gt;2001:db00::0/24&lt;/code&gt; 유효한 인수입니다 동안 &lt;code&gt;2001:db00::0/ffff:ff00::&lt;/code&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="4db3f43ffbaa9cce83c5e9797f11ee3784e159b1" translate="yes" xml:space="preserve">
          <source>Note that currently mutually exclusive argument groups do not support the &lt;em&gt;title&lt;/em&gt; and &lt;em&gt;description&lt;/em&gt; arguments of &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt;&lt;code&gt;add_argument_group()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 상호 배타적 인 인수 그룹 은 &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt; &lt;code&gt;add_argument_group()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;제목&lt;/em&gt; 및 &lt;em&gt;설명&lt;/em&gt; 인수를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ba81a2a12ca2905b7e3bc3e32ecb856013a86f5" translate="yes" xml:space="preserve">
          <source>Note that descendant processes of the process will &lt;em&gt;not&lt;/em&gt; be terminated &amp;ndash; they will simply become orphaned.</source>
          <target state="translated">프로세스의 하위 프로세스는 종료 &lt;em&gt;되지 않으며&lt;/em&gt; 단순히 고아가됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a3be6e16147e9e8fd7d6862b1baa360c9c8ab4" translate="yes" xml:space="preserve">
          <source>Note that encoding with &lt;a href=&quot;#email.encoders.encode_quopri&quot;&gt;&lt;code&gt;encode_quopri()&lt;/code&gt;&lt;/a&gt; also encodes all tabs and space characters in the data.</source>
          <target state="translated">참고로 인코딩 것을 &lt;a href=&quot;#email.encoders.encode_quopri&quot;&gt; &lt;code&gt;encode_quopri()&lt;/code&gt; &lt;/a&gt; 또한 데이터의 모든 탭과 공백 문자를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="8858707f6b738b8eec7bc257425fec239a5f9e41" translate="yes" xml:space="preserve">
          <source>Note that even for small &lt;code&gt;len(x)&lt;/code&gt;, the total number of permutations of &lt;em&gt;x&lt;/em&gt; can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator.</source>
          <target state="translated">심지어 작은 참고 &lt;code&gt;len(x)&lt;/code&gt; 의 순열의 수 &lt;em&gt;x는&lt;/em&gt; 빠르게 대부분의 난수 발생기의 기간보다 더 성장할 수 있습니다. 이것은 긴 시퀀스의 대부분의 순열이 절대로 생성 될 수 없음을 의미합니다. 예를 들어, 길이가 2080 인 시퀀스는 Mersenne Twister 난수 생성기의 기간 내에 들어갈 수있는 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="c135e18157f388a32703b9e0b8ce0fcf98a88ef9" translate="yes" xml:space="preserve">
          <source>Note that even in &lt;a href=&quot;#re.MULTILINE&quot;&gt;&lt;code&gt;MULTILINE&lt;/code&gt;&lt;/a&gt; mode, &lt;a href=&quot;#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt; will only match at the beginning of the string and not at the beginning of each line.</source>
          <target state="translated">도에 참고 &lt;a href=&quot;#re.MULTILINE&quot;&gt; &lt;code&gt;MULTILINE&lt;/code&gt; &lt;/a&gt; 모드, &lt;a href=&quot;#re.match&quot;&gt; &lt;code&gt;re.match()&lt;/code&gt; &lt;/a&gt; 각 줄의 시작 부분에 문자열의 시작 부분이 아니라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c248f2777a5cff0833e5e1f56ce05642e54cb886" translate="yes" xml:space="preserve">
          <source>Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls.</source>
          <target state="translated">시간이 항상 부동 소수점 숫자로 반환 되더라도 모든 시스템이 1 초보다 정확한 정밀도를 제공하는 것은 아닙니다. 이 함수는 일반적으로 감소하지 않는 값을 반환하지만 시스템 호출이 두 호출간에 다시 설정된 경우 이전 호출보다 낮은 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8979e2f2b1b29e83666a8cd201294ac167294831" translate="yes" xml:space="preserve">
          <source>Note that existing parameter values of headers may be accessed through the &lt;code&gt;params&lt;/code&gt; attribute of the header value (for example, &lt;code&gt;msg['Content-Type'].params['charset']&lt;/code&gt;).</source>
          <target state="translated">헤더의 기존 매개 변수 값은 헤더 값의 &lt;code&gt;params&lt;/code&gt; 속성 (예 : &lt;code&gt;msg['Content-Type'].params['charset']&lt;/code&gt; )을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5786a82a8493b79c96451e2f0e8ff1a491a88f3b" translate="yes" xml:space="preserve">
          <source>Note that expected output now shows that the snippet runs 1 second faster than before:</source>
          <target state="translated">예상 된 결과는 이제 스 니펫이 이전보다 1 초 빠르게 실행됨을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="356743d5b08962bffdeebdb7d374e8d296f8aa3d" translate="yes" xml:space="preserve">
          <source>Note that filters attached to handlers are consulted before an event is emitted by the handler, whereas filters attached to loggers are consulted whenever an event is logged (using &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;, etc.), before sending an event to handlers. This means that events which have been generated by descendant loggers will not be filtered by a logger&amp;rsquo;s filter setting, unless the filter has also been applied to those descendant loggers.</source>
          <target state="translated">핸들러에 연결된 필터는 이벤트가 핸들러에 의해 생성되기 전에 참조되는 반면, 로거에 연결된 필터 는 이벤트가 핸들러에 전송되기 전에 이벤트가 기록 될 때마다 ( &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.info&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; 등을 사용하여 ) 참조 됩니다. 이는 하위 로거에 의해 생성 된 이벤트는 필터가 해당 하위 로거에도 적용되지 않는 한 로거의 필터 설정에 의해 필터링되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61a0f268ab225e4ac517bd285248bf03bd4c499e" translate="yes" xml:space="preserve">
          <source>Note that for backward compatibility, the &lt;code&gt;re.U&lt;/code&gt; flag still exists (as well as its synonym &lt;code&gt;re.UNICODE&lt;/code&gt; and its embedded counterpart &lt;code&gt;(?u)&lt;/code&gt;), but these are redundant in Python 3 since matches are Unicode by default for strings (and Unicode matching isn&amp;rsquo;t allowed for bytes).</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;re.U&lt;/code&gt; 플래그는 여전히 존재하지만 동의어 &lt;code&gt;re.UNICODE&lt;/code&gt; 및 임베디드 대응 물 &lt;code&gt;(?u)&lt;/code&gt; 은 존재하지만 문자열 (및 유니 코드에 대한 일치는 기본적으로 유니 코드이므로 Python 3에서는 중복됩니다) 바이트 일치는 허용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="465c176dc885bd97b79a8361a2bbae22c1b4e34c" translate="yes" xml:space="preserve">
          <source>Note that for processes created by the &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt;&lt;code&gt;create_subprocess_shell()&lt;/code&gt;&lt;/a&gt; function, this attribute is the PID of the spawned shell.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt; &lt;code&gt;create_subprocess_shell()&lt;/code&gt; &lt;/a&gt; 함수로 작성된 프로세스의 경우이 속성은 생성 된 쉘의 PID입니다.</target>
        </trans-unit>
        <trans-unit id="3882e94a24c32a31d35cc2a1b007f11e37659571" translate="yes" xml:space="preserve">
          <source>Note that for some non-Unix systems, &lt;code&gt;sys.prefix&lt;/code&gt; and &lt;code&gt;sys.exec_prefix&lt;/code&gt; are empty, and the path manipulations are skipped; however the import of &lt;code&gt;sitecustomize&lt;/code&gt; and &lt;code&gt;usercustomize&lt;/code&gt; is still attempted.</source>
          <target state="translated">Unix 이외의 일부 시스템의 경우 &lt;code&gt;sys.prefix&lt;/code&gt; 및 &lt;code&gt;sys.exec_prefix&lt;/code&gt; 가 비어 있고 경로 조작을 건너 뜁니다. 그러나 수입 &lt;code&gt;sitecustomize&lt;/code&gt; 및 &lt;code&gt;usercustomize&lt;/code&gt; 은 아직 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="8fd33ef4d4d5e2689d3ced573aea2f56a54160ad" translate="yes" xml:space="preserve">
          <source>Note that for very large time intervals (greater than 270 years on most platforms) this method will lose microsecond accuracy.</source>
          <target state="translated">매우 많은 시간 간격 (대부분의 플랫폼에서 270 년 이상)의 경우이 방법은 마이크로 초 정확도를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="840170e277d815baed7c66a50d417357022d75d1" translate="yes" xml:space="preserve">
          <source>Note that functions (built-in and user-defined) are pickled by &amp;ldquo;fully qualified&amp;rdquo; name reference, not by value. &lt;a href=&quot;#id8&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt; This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function&amp;rsquo;s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised. &lt;a href=&quot;#id9&quot; id=&quot;id4&quot;&gt;3&lt;/a&gt;</source>
          <target state="translated">함수 (내장 및 사용자 정의)는 값이 아니라 &quot;완전한&quot;이름 참조로 선택됩니다. &lt;a href=&quot;#id8&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt; 이는 함수 이름 만 선택되고 함수가 정의 된 모듈의 이름과 함께 선택됩니다. 함수의 코드 나 함수 속성이 모두 선택되지 않습니다. 따라서 정의 해제 모듈은 피클 링 해제 환경에서 가져올 수 있어야하고 모듈에 명명 된 객체가 포함되어 있어야합니다. 그렇지 않으면 예외가 발생합니다. &lt;a href=&quot;#id9&quot; id=&quot;id4&quot;&gt;삼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb1ee9a91608b1283fe0ceec10e559f6fc6844a7" translate="yes" xml:space="preserve">
          <source>Note that if a slash(/) appears in the parameter list of a function, when invoking &lt;a href=&quot;#help&quot;&gt;&lt;code&gt;help()&lt;/code&gt;&lt;/a&gt;, it means that the parameters prior to the slash are positional-only. For more info, see &lt;a href=&quot;https://docs.python.org/3.8/faq/programming.html#faq-positional-only-arguments&quot;&gt;the FAQ entry on positional-only parameters&lt;/a&gt;.</source>
          <target state="translated">함수의 매개 변수 목록에 슬래시 (/)가 표시되면 &lt;a href=&quot;#help&quot;&gt; &lt;code&gt;help()&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 슬래시 이전의 매개 변수는 위치 전용임을 의미합니다. 자세한 내용 &lt;a href=&quot;https://docs.python.org/3.8/faq/programming.html#faq-positional-only-arguments&quot;&gt;은 위치 전용 매개 변수에 대한 FAQ 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ba29bc642962688bd93f7d7440bdc3d09b1a14c" translate="yes" xml:space="preserve">
          <source>Note that if anything goes wrong while importing the callable named by &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt;&lt;code&gt;RuntimeWarning&lt;/code&gt;&lt;/a&gt; is reported and the breakpoint is ignored.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt; 로&lt;/a&gt; 명명 된 호출 가능 파일을 가져 오는 중에 문제 가 발생 하면 &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt; &lt;code&gt;RuntimeWarning&lt;/code&gt; &lt;/a&gt; 이보고되고 중단 점이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d37b5b457c0e579a56a9008b596dcf0daed0c531" translate="yes" xml:space="preserve">
          <source>Note that if the message object has no preamble, the &lt;em&gt;preamble&lt;/em&gt; attribute will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">메시지 오브젝트에 프리앰블이없는 경우 &lt;em&gt;프리앰블&lt;/em&gt; 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c57b574c5b42a4687029f512f3b789f966aa395d" translate="yes" xml:space="preserve">
          <source>Note that if the named field appears more than once in the message&amp;rsquo;s headers, exactly which of those field values will be returned is undefined. Use the &lt;a href=&quot;#email.message.EmailMessage.get_all&quot;&gt;&lt;code&gt;get_all()&lt;/code&gt;&lt;/a&gt; method to get the values of all the extant headers named &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. &lt;a href=&quot;#email.message.EmailMessage.get_all&quot;&gt; &lt;code&gt;get_all()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;em&gt;name&lt;/em&gt; 이라는 모든 기존 헤더의 값을 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="15161d213ea81ba024de0a076644d1272635e94d" translate="yes" xml:space="preserve">
          <source>Note that if the named field appears more than once in the message&amp;rsquo;s headers, exactly which of those field values will be returned is undefined. Use the &lt;a href=&quot;#email.message.Message.get_all&quot;&gt;&lt;code&gt;get_all()&lt;/code&gt;&lt;/a&gt; method to get the values of all the extant named headers.</source>
          <target state="translated">이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. &lt;a href=&quot;#email.message.Message.get_all&quot;&gt; &lt;code&gt;get_all()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 기존의 모든 명명 된 헤더의 값을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="87ae25219d92f70d8ce3d6068ac05c1ccc107875" translate="yes" xml:space="preserve">
          <source>Note that if you have defined any custom logging level higher than &lt;code&gt;CRITICAL&lt;/code&gt; (this is not recommended), you won&amp;rsquo;t be able to rely on the default value for the &lt;em&gt;level&lt;/em&gt; parameter, but will have to explicitly supply a suitable value.</source>
          <target state="translated">&lt;code&gt;CRITICAL&lt;/code&gt; 보다 높은 사용자 정의 로깅 레벨을 정의한 경우 (권장하지 않음) &lt;em&gt;레벨&lt;/em&gt; 매개 변수 의 기본값을 사용할 수는 없지만 적절한 값을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2465633c732bfdca544359da14ee59c714468eb0" translate="yes" xml:space="preserve">
          <source>Note that if you set the &lt;em&gt;shell&lt;/em&gt; argument to &lt;code&gt;True&lt;/code&gt;, this is the process ID of the spawned shell.</source>
          <target state="translated">&lt;em&gt;shell&lt;/em&gt; 인수를 &lt;code&gt;True&lt;/code&gt; 로 설정 하면 생성 된 쉘의 프로세스 ID입니다.</target>
        </trans-unit>
        <trans-unit id="95edd926d0c8f963e4c8a0f19295c25236bc7bfd" translate="yes" xml:space="preserve">
          <source>Note that if you specify an interpreter and then distribute your application archive, you need to ensure that the interpreter used is portable. The Python launcher for Windows supports most common forms of POSIX &lt;code&gt;#!&lt;/code&gt; line, but there are other issues to consider:</source>
          <target state="translated">인터프리터를 지정한 다음 애플리케이션 아카이브를 분배하는 경우 사용 된 인터프리터가 이식 가능한지 확인해야합니다. Windows 용 Python 런처는 가장 일반적인 형태의 POSIX &lt;code&gt;#!&lt;/code&gt; 고려해야 할 다른 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aababa3d966c7b1183bc1e3bb713ff94a4b803c7" translate="yes" xml:space="preserve">
          <source>Note that if you want to send data to the process&amp;rsquo;s stdin, you need to create the Popen object with &lt;code&gt;stdin=PIPE&lt;/code&gt;. Similarly, to get anything other than &lt;code&gt;None&lt;/code&gt; in the result tuple, you need to give &lt;code&gt;stdout=PIPE&lt;/code&gt; and/or &lt;code&gt;stderr=PIPE&lt;/code&gt; too.</source>
          <target state="translated">프로세스의 stdin에 데이터를 보내려면 &lt;code&gt;stdin=PIPE&lt;/code&gt; 를 사용하여 Popen 오브젝트를 작성해야합니다 . 마찬가지로 결과 튜플에서 &lt;code&gt;None&lt;/code&gt; 이외의 값을 얻으려면 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 / 또는 &lt;code&gt;stderr=PIPE&lt;/code&gt; 도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d30eb9f3b524dd91c924b480ac665ceea172bbd3" translate="yes" xml:space="preserve">
          <source>Note that if your server is not listening on UDP port 514, &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt;&lt;code&gt;SysLogHandler&lt;/code&gt;&lt;/a&gt; may appear not to work. In that case, check what address you should be using for a domain socket - it&amp;rsquo;s system dependent. For example, on Linux it&amp;rsquo;s usually &amp;lsquo;/dev/log&amp;rsquo; but on OS/X it&amp;rsquo;s &amp;lsquo;/var/run/syslog&amp;rsquo;. You&amp;rsquo;ll need to check your platform and use the appropriate address (you may need to do this check at runtime if your application needs to run on several platforms). On Windows, you pretty much have to use the UDP option.</source>
          <target state="translated">서버가 UDP 포트 514에서 수신 대기하지 않으면 &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt; &lt;code&gt;SysLogHandler&lt;/code&gt; &lt;/a&gt; 가 작동하지 않는 것처럼 보일 수 있습니다. 이 경우 도메인 소켓에 사용해야하는 주소를 확인하십시오 (시스템에 따라 다름). 예를 들어 Linux에서는 일반적으로 '/ dev / log'이지만 OS / X에서는 '/ var / run / syslog'입니다. 플랫폼을 확인하고 적절한 주소를 사용해야합니다 (응용 프로그램이 여러 플랫폼에서 실행되어야하는 경우 런타임에이 확인을 수행해야 할 수 있음). Windows에서는 UDP 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e6d6ccf640c4a7fd68532b2415ba6bb4f3714d8" translate="yes" xml:space="preserve">
          <source>Note that in all cases, any envelope header present in the message is not included in the mapping interface.</source>
          <target state="translated">모든 경우에 메시지에 존재하는 봉투 헤더는 매핑 인터페이스에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba327349434f8a3d52b3e4e613f26c146b8940c2" translate="yes" xml:space="preserve">
          <source>Note that in order to test something, we use one of the &lt;code&gt;assert*()&lt;/code&gt; methods provided by the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; base class. If the test fails, an exception will be raised with an explanatory message, and &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; will identify the test case as a &lt;em&gt;failure&lt;/em&gt;. Any other exceptions will be treated as &lt;em&gt;errors&lt;/em&gt;.</source>
          <target state="translated">무언가를 테스트하기 위해 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 기본 클래스 에서 제공 하는 &lt;code&gt;assert*()&lt;/code&gt; 메소드 중 하나를 사용 합니다. 테스트가 실패하면 설명 메시지와 함께 예외가 발생하고 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 는 테스트 케이스를 &lt;em&gt;실패한&lt;/em&gt; 것으로 식별합니다 . 다른 예외는 &lt;em&gt;오류&lt;/em&gt; 로 처리됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2963c39aeb1fbe44d9106170763ccfab16bbab6" translate="yes" xml:space="preserve">
          <source>Note that in the first example the return value variable &lt;em&gt;rv&lt;/em&gt; will hold an integer value; in the second example it will hold a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. The structure lay-out for the &lt;em&gt;lockdata&lt;/em&gt; variable is system dependent &amp;mdash; therefore using the &lt;a href=&quot;#fcntl.flock&quot;&gt;&lt;code&gt;flock()&lt;/code&gt;&lt;/a&gt; call may be better.</source>
          <target state="translated">첫 번째 예에서 반환 값 변수 &lt;em&gt;rv&lt;/em&gt; 는 정수 값을 보유합니다. 두 번째 예에서는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 보유 합니다. &lt;em&gt;lockdata&lt;/em&gt; 변수 의 구조 레이아웃 은 시스템에 따라 다르므로 &lt;a href=&quot;#fcntl.flock&quot;&gt; &lt;code&gt;flock()&lt;/code&gt; &lt;/a&gt; 호출을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e76d82ec0cfb558c63a1e08054c8f07fa0699635" translate="yes" xml:space="preserve">
          <source>Note that inclusion in the &lt;em&gt;choices&lt;/em&gt; container is checked after any &lt;a href=&quot;#type&quot;&gt;type&lt;/a&gt; conversions have been performed, so the type of the objects in the &lt;em&gt;choices&lt;/em&gt; container should match the &lt;a href=&quot;#type&quot;&gt;type&lt;/a&gt; specified:</source>
          <target state="translated">&lt;a href=&quot;#type&quot;&gt;유형&lt;/a&gt; 변환이 수행 된 후 &lt;em&gt;선택&lt;/em&gt; 컨테이너에 포함되는지 확인 되므로 &lt;em&gt;선택&lt;/em&gt; 컨테이너 의 객체 &lt;a href=&quot;#type&quot;&gt;유형은&lt;/a&gt; 지정된 유형 과 일치해야 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a424e123046b9f2ba0f16ae4ec8e158536158450" translate="yes" xml:space="preserve">
          <source>Note that installing a signal handler with &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;/a&gt; will reset the restart behaviour to interruptible by implicitly calling &lt;code&gt;siginterrupt()&lt;/code&gt; with a true &lt;em&gt;flag&lt;/em&gt; value for the given signal.</source>
          <target state="translated">&lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal()&lt;/code&gt; &lt;/a&gt; 으로 신호 처리기를 설치 하면 주어진 신호에 대해 true &lt;em&gt;플래그&lt;/em&gt; 값으로 &lt;code&gt;siginterrupt()&lt;/code&gt; 를 암시 적으로 호출하여 재시작 동작을 인터럽트 가능으로 재설정합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9f60fa0720b86d1dcdc718ca772ee8cca933f15" translate="yes" xml:space="preserve">
          <source>Note that it does not allow read/write WAV files.</source>
          <target state="translated">읽기 / 쓰기 WAV 파일은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b37732e38cdf4751eb314377a55436fbd87b874f" translate="yes" xml:space="preserve">
          <source>Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, &lt;code&gt;f(a, b, c)&lt;/code&gt; is a function call with three arguments, while &lt;code&gt;f((a, b, c))&lt;/code&gt; is a function call with a 3-tuple as the sole argument.</source>
          <target state="translated">실제로는 괄호가 아닌 튜플을 만드는 것이 쉼표입니다. 빈 튜플의 경우 또는 구문 모호성을 피하기 위해 필요한 경우를 제외하고 괄호는 선택 사항입니다. 예를 들어, &lt;code&gt;f(a, b, c)&lt;/code&gt; 는 세 개의 인수를 가진 함수 호출이고 &lt;code&gt;f((a, b, c))&lt;/code&gt; 는 유일한 인수로 3- 튜플을 가진 함수 호출입니다.</target>
        </trans-unit>
        <trans-unit id="c1142fa9322d5765d4454b6dfb466ee0b2fdb642" translate="yes" xml:space="preserve">
          <source>Note that it is invalid to set any parameters after calling &lt;code&gt;writeframes()&lt;/code&gt; or &lt;code&gt;writeframesraw()&lt;/code&gt;, and any attempt to do so will raise &lt;a href=&quot;#wave.Error&quot;&gt;&lt;code&gt;wave.Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;writeframes()&lt;/code&gt; 또는 &lt;code&gt;writeframesraw()&lt;/code&gt; 호출 한 후 매개 변수를 설정할 수 없으며 , 그렇게하면 &lt;a href=&quot;#wave.Error&quot;&gt; &lt;code&gt;wave.Error&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8bccd4b29f1a54b5e303c1a916237118b7ad7ec0" translate="yes" xml:space="preserve">
          <source>Note that it may cause high memory usage for very long iterables. Consider using &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt;&lt;code&gt;imap()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.pool.Pool.imap_unordered&quot;&gt;&lt;code&gt;imap_unordered()&lt;/code&gt;&lt;/a&gt; with explicit &lt;em&gt;chunksize&lt;/em&gt; option for better efficiency.</source>
          <target state="translated">매우 긴 iterable에 대해 높은 메모리 사용이 발생할 수 있습니다. 사용을 고려 &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt; &lt;code&gt;imap()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.pool.Pool.imap_unordered&quot;&gt; &lt;code&gt;imap_unordered()&lt;/code&gt; &lt;/a&gt; 명시 적으로 &lt;em&gt;chunksize 영역의&lt;/em&gt; 더 나은 효율성을 위해 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="bc1c75d4508d9bbf24ec9e11eb857898269d1eae" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s already possible to iterate on file objects using &lt;code&gt;for
line in file: ...&lt;/code&gt; without calling &lt;code&gt;file.readlines()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file.readlines()&lt;/code&gt; 를 호출하지 않고 &lt;code&gt;for line in file: ...&lt;/code&gt; 사용하여 파일 객체를 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05a2b045555cd68924e93f59f7b760be26ddd68b" translate="yes" xml:space="preserve">
          <source>Note that many of these have little practical significance in modern usage. The mnemonics derive from teleprinter conventions that predate digital computers.</source>
          <target state="translated">이들 중 많은 것들이 현대적인 사용법에서 실질적인 중요성을 거의 가지고 있지 않습니다. 니모닉은 디지털 컴퓨터 이전의 텔레 프린터 규칙에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="9ed4f4956d2d64f5ed11cfc83c3e2520067e2797" translate="yes" xml:space="preserve">
          <source>Note that methods of asyncio queues don&amp;rsquo;t have a &lt;em&gt;timeout&lt;/em&gt; parameter; use &lt;a href=&quot;asyncio-task#asyncio.wait_for&quot;&gt;&lt;code&gt;asyncio.wait_for()&lt;/code&gt;&lt;/a&gt; function to do queue operations with a timeout.</source>
          <target state="translated">asyncio 대기열의 메서드에는 &lt;em&gt;시간 초과&lt;/em&gt; 매개 변수 가 없습니다 . 사용하는 &lt;a href=&quot;asyncio-task#asyncio.wait_for&quot;&gt; &lt;code&gt;asyncio.wait_for()&lt;/code&gt; &lt;/a&gt; 타임 아웃 큐 연산을 수행 할 함수.</target>
        </trans-unit>
        <trans-unit id="9d7173aaff46eece39c6ad050dacaca07a346492" translate="yes" xml:space="preserve">
          <source>Note that most parent parsers will specify &lt;code&gt;add_help=False&lt;/code&gt;. Otherwise, the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; will see two &lt;code&gt;-h/--help&lt;/code&gt; options (one in the parent and one in the child) and raise an error.</source>
          <target state="translated">대부분의 상위 파서는 &lt;code&gt;add_help=False&lt;/code&gt; 를 지정 합니다. 그렇지 않으면 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 에&lt;/a&gt; 두 개의 &lt;code&gt;-h/--help&lt;/code&gt; 옵션 (부모와 자식에 하나씩)이 표시되고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ec5c2fc42c63d4c02f722210f01d284542c94cdd" translate="yes" xml:space="preserve">
          <source>Note that multiple connection objects may be polled at once by using &lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt;&lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt; &lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt; &lt;/a&gt; 를 사용하여 여러 연결 객체를 한 번에 폴링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5aad7f2fe356ddb37a2958193ffcc95757955613" translate="yes" xml:space="preserve">
          <source>Note that no external programs are called from this function, giving it portability and efficiency.</source>
          <target state="translated">이 함수에서 외부 프로그램을 호출하지 않으므로 이식성과 효율성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="73e56395f79c913850173ac7c4bbd0a531342117" translate="yes" xml:space="preserve">
          <source>Note that no stream repositioning should take place. This method is primarily intended to be able to recover from decoding errors.</source>
          <target state="translated">스트림 재배치가 발생하지 않아야합니다. 이 방법은 주로 디코딩 오류를 복구 할 수 있도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b04c87d02c729d2b34d36ed6364a0bf9a50ea51" translate="yes" xml:space="preserve">
          <source>Note that normalization of negative values may be surprising at first. For example:</source>
          <target state="translated">음수 값의 정규화는 처음에는 놀랍습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08827e39a2581735ab237416a511e4b4882c7aff" translate="yes" xml:space="preserve">
          <source>Note that objects related to one context may not be compatible with processes for a different context. In particular, locks created using the &lt;em&gt;fork&lt;/em&gt; context cannot be passed to processes started using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start methods.</source>
          <target state="translated">한 컨텍스트와 관련된 개체는 다른 컨텍스트의 프로세스와 호환되지 않을 수 있습니다. 특히, &lt;em&gt;포크&lt;/em&gt; 컨텍스트를 사용하여 작성된 잠금 은 &lt;em&gt;스폰&lt;/em&gt; 또는 &lt;em&gt;포크 서버&lt;/em&gt; 시작 메소드를 사용하여 시작된 프로세스로 전달 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eda4961590997a45a1e79372239074265d25ed88" translate="yes" xml:space="preserve">
          <source>Note that objects which have already been dereferenced, but which live in cycles and have not yet been collected by the garbage collector can be listed among the resulting referrers. To get only currently live objects, call &lt;a href=&quot;#gc.collect&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt; before calling &lt;a href=&quot;#gc.get_referrers&quot;&gt;&lt;code&gt;get_referrers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이미 역 참조되었지만주기에 존재하고 가비지 수집기에 의해 아직 수집되지 않은 객체는 결과 참조 자 사이에 나열 될 수 있습니다. 현재 라이브 객체 만 가져 오려면 &lt;a href=&quot;#gc.get_referrers&quot;&gt; &lt;code&gt;get_referrers()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;a href=&quot;#gc.collect&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d01f60caa4137debd7332962680da8372d67729" translate="yes" xml:space="preserve">
          <source>Note that on Windows child processes will only inherit the level of the parent process&amp;rsquo;s logger &amp;ndash; any other customization of the logger will not be inherited.</source>
          <target state="translated">Windows에서 하위 프로세스는 상위 프로세스의 로거 레벨 만 상속합니다. 로거의 다른 사용자 정의는 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71665cc8043f3efa68e4485fe250bc5b29c8a385" translate="yes" xml:space="preserve">
          <source>Note that on some platforms, trying to open a filename using this function, may work and start the operating system&amp;rsquo;s associated program. However, this is neither supported nor portable.</source>
          <target state="translated">일부 플랫폼에서이 기능을 사용하여 파일 이름을 열려고하면 운영 체제와 관련된 프로그램이 작동하고 시작될 수 있습니다. 그러나 이것은 지원되거나 이식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c5a9e4b55caffc98aca4b11598a9c875e9057ec" translate="yes" xml:space="preserve">
          <source>Note that one can also create a shared queue by using a manager object &amp;ndash; see &lt;a href=&quot;#multiprocessing-managers&quot;&gt;Managers&lt;/a&gt;.</source>
          <target state="translated">하나는 관리자 개체를 사용하여 공유 큐를 만들 수 주 - 참조 &lt;a href=&quot;#multiprocessing-managers&quot;&gt;매니저&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11489b229a9332af75273ce34ce4bbce75cf8ef6" translate="yes" xml:space="preserve">
          <source>Note that one can also create synchronization primitives by using a manager object &amp;ndash; see &lt;a href=&quot;#multiprocessing-managers&quot;&gt;Managers&lt;/a&gt;.</source>
          <target state="translated">하나는 관리자 개체를 사용하여 동기화 기본을 만들 수 주 - 참조 &lt;a href=&quot;#multiprocessing-managers&quot;&gt;매니저&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d73f2e5696ae1abc027da2033b4b034e5b6843a" translate="yes" xml:space="preserve">
          <source>Note that operations such as &lt;a href=&quot;#audioop.mul&quot;&gt;&lt;code&gt;mul()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#audioop.max&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt; make no distinction between mono and stereo fragments, i.e. all samples are treated equal. If this is a problem the stereo fragment should be split into two mono fragments first and recombined later. Here is an example of how to do that:</source>
          <target state="translated">&lt;a href=&quot;#audioop.mul&quot;&gt; &lt;code&gt;mul()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#audioop.max&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt; 와 같은 연산 은 모노와 스테레오 프래그먼트를 구별하지 않습니다. 즉, 모든 샘플이 동일하게 취급됩니다. 이것이 문제라면, 스테레오 프래그먼트를 먼저 두 개의 모노 프래그먼트로 나누고 나중에 다시 결합해야합니다. 이를 수행하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b16370266d750c139819b213ca33ad0c71c90be" translate="yes" xml:space="preserve">
          <source>Note that other exceptions may also be raised during unpickling, including (but not necessarily limited to) AttributeError, EOFError, ImportError, and IndexError.</source>
          <target state="translated">속성을 제거하는 동안 AttributeError, EOFError, ImportError 및 IndexError를 포함한 다른 예외도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c14ddea7d8a40390395369e4d9bf692d2a322f31" translate="yes" xml:space="preserve">
          <source>Note that parser-level defaults always override argument-level defaults:</source>
          <target state="translated">파서 수준의 기본값은 항상 인수 수준의 기본값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="7eb9240d51fab27d432be3b59cc8d057375a5d25" translate="yes" xml:space="preserve">
          <source>Note that pickles aren&amp;rsquo;t completely secure. If you are concerned about security, you may want to override this method to implement a more secure mechanism. For example, you can sign pickles using HMAC and then verify them on the receiving end, or alternatively you can disable unpickling of global objects on the receiving end.</source>
          <target state="translated">피클은 완전히 안전하지 않습니다. 보안이 우려되는 경우이 방법을 재정 의하여보다 안전한 메커니즘을 구현할 수 있습니다. 예를 들어, HMAC를 사용하여 피클에 서명 한 다음 수신 측에서이를 피클 링하거나 수신 측에서 전역 객체의 피클 링 해제를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb90d29aeda61d23a983d5f5ed8686703c50549" translate="yes" xml:space="preserve">
          <source>Note that printf prints to the real standard output channel, &lt;em&gt;not&lt;/em&gt; to &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt;, so these examples will only work at the console prompt, not from within &lt;em&gt;IDLE&lt;/em&gt; or &lt;em&gt;PythonWin&lt;/em&gt;:</source>
          <target state="translated">참고 실제 표준 출력 채널의 printf 인쇄, &lt;em&gt;하지&lt;/em&gt; 에 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; , 그래서이 예제하지 않습니다 내에서, 콘솔에서만 작업 프롬프트 &lt;em&gt;IDLE&lt;/em&gt; 또는 &lt;em&gt;를 PythonWin&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="dbe8dc287e2d3ac27238f225b2b077ec51310c3b" translate="yes" xml:space="preserve">
          <source>Note that profiling will only work if the called command/function actually returns. If the interpreter is terminated (e.g. via a &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt; call during the called command/function execution) no profiling results will be printed.</source>
          <target state="translated">프로파일 링은 호출 된 명령 / 함수가 실제로 리턴 된 경우에만 작동합니다. 인터프리터가 종료 된 경우 (예 : 호출 된 명령 / 함수 실행 중 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 호출을 통해 ) 프로파일 링 결과가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de353d4750a5cdba4018be858fb797f69441158f" translate="yes" xml:space="preserve">
          <source>Note that returning instances of private classes is not recommended. It is usually preferable to make such classes public.</source>
          <target state="translated">개인 클래스의 인스턴스를 반환하지 않는 것이 좋습니다. 일반적으로 그러한 수업을 공개하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bae0d8a27b12e898d4d9a61e003f0408e393752d" translate="yes" xml:space="preserve">
          <source>Note that setting and getting an element is potentially non-atomic &amp;ndash; use &lt;a href=&quot;#multiprocessing.sharedctypes.Array&quot;&gt;&lt;code&gt;Array()&lt;/code&gt;&lt;/a&gt; instead to make sure that access is automatically synchronized using a lock.</source>
          <target state="translated">요소를 설정하고 가져 오는 것은 잠재적으로 비원 자적입니다. 대신 Lock &lt;a href=&quot;#multiprocessing.sharedctypes.Array&quot;&gt; &lt;code&gt;Array()&lt;/code&gt; &lt;/a&gt; 사용하여 액세스가 자동으로 동기화되도록 Array () 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fba826635b3c9adedafaa20e7c85f3678b0d3888" translate="yes" xml:space="preserve">
          <source>Note that setting and getting the value is potentially non-atomic &amp;ndash; use &lt;a href=&quot;#multiprocessing.sharedctypes.Value&quot;&gt;&lt;code&gt;Value()&lt;/code&gt;&lt;/a&gt; instead to make sure that access is automatically synchronized using a lock.</source>
          <target state="translated">값 설정 및 가져 오기는 잠재적으로 비원 자적입니다. 대신 잠금을 사용하여 액세스가 자동으로 동기화되도록 하려면 &lt;a href=&quot;#multiprocessing.sharedctypes.Value&quot;&gt; &lt;code&gt;Value()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0a4d937d898d6dae87b372469dc8ecdc5efcd60" translate="yes" xml:space="preserve">
          <source>Note that shared fixtures do not play well with [potential] features like test parallelization and they break test isolation. They should be used with care.</source>
          <target state="translated">공유 픽스쳐는 테스트 병렬화와 같은 [잠재적] 기능과 잘 작동하지 않으며 테스트 격리를 중단합니다. 그들은 조심스럽게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a3a80c8445850d90d40639df2476d5a77bd29df" translate="yes" xml:space="preserve">
          <source>Note that simply calling a coroutine will not schedule it to be executed:</source>
          <target state="translated">단순히 코 루틴을 호출한다고해서 실행되도록 예약되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="68956186d48d42443b6758d13e6916e94a8cef68" translate="yes" xml:space="preserve">
          <source>Note that since all options are disabled by default, and directives apply only to the example they appear in, enabling options (via &lt;code&gt;+&lt;/code&gt; in a directive) is usually the only meaningful choice. However, option flags can also be passed to functions that run doctests, establishing different defaults. In such cases, disabling an option via &lt;code&gt;-&lt;/code&gt; in a directive can be useful.</source>
          <target state="translated">모든 옵션은 기본적으로 비활성화되어 있으며 지시문은 표시되는 예제에만 적용되므로 지시문에서 &lt;code&gt;+&lt;/code&gt; 를 통해 옵션을 활성화 하는 것이 일반적으로 유일하게 의미있는 선택입니다. 그러나 doctest를 실행하는 함수에 옵션 플래그를 전달하여 다른 기본값을 설정할 수도 있습니다. 이러한 경우 지시문에서 &lt;code&gt;-&lt;/code&gt; 를 통해 옵션을 비활성화하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d486f123342853ccfe49cff51f3b937ee427e3c1" translate="yes" xml:space="preserve">
          <source>Note that some platforms including FreeBSD &amp;lt;= 6.3 and Cygwin have known issues when using &lt;code&gt;fork()&lt;/code&gt; from a thread.</source>
          <target state="translated">FreeBSD &amp;lt;= 6.3 및 Cygwin을 포함한 일부 플랫폼 에는 스레드에서 &lt;code&gt;fork()&lt;/code&gt; 를 사용할 때 알려진 문제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4eebda1ed9cbd631d501f51d602004fcc0df5dce" translate="yes" xml:space="preserve">
          <source>Note that some recent versions of the HTML specification do state what order the field values should be supplied in, but knowing whether a request was received from a conforming browser, or even from a browser at all, is tedious and error-prone.</source>
          <target state="translated">HTML 사양의 일부 최신 버전에서는 필드 값을 제공해야하는 순서가 명시되어 있지만, 요청이 적합한 브라우저에서 수신되었는지 또는 전혀 브라우저에서 수신되었는지를 아는 것은 지루하고 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="e49765d68859e961a6e270321dec95f459b3abf4" translate="yes" xml:space="preserve">
          <source>Note that some systems might support ancillary data without providing this function. Also note that setting the buffer size using the results of this function may not precisely limit the amount of ancillary data that can be received, since additional data may be able to fit into the padding area.</source>
          <target state="translated">일부 시스템은이 기능을 제공하지 않고 보조 데이터를 지원할 수 있습니다. 또한이 기능의 결과를 사용하여 버퍼 크기를 설정하면 추가 데이터가 패딩 영역에 들어갈 수 있으므로 수신 할 수있는 보조 데이터의 양이 정확하게 제한되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8a9295a9dbce0828c8e847a08e997833350743" translate="yes" xml:space="preserve">
          <source>Note that tabs and spaces are both treated as whitespace, but they are not equal: the lines &lt;code&gt;&quot;&amp;nbsp; hello&quot;&lt;/code&gt; and &lt;code&gt;&quot;\thello&quot;&lt;/code&gt; are considered to have no common leading whitespace.</source>
          <target state="translated">탭과 공백은 모두 공백으로 취급되지만 동일하지는 않습니다. &lt;code&gt;&quot;&amp;nbsp; hello&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\thello&quot;&lt;/code&gt; 에는 공통 선행 공백이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d9458e3f856c8568d276b2ccc17c59d5c9e0de3b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instances that differ only by the value of the &lt;a href=&quot;#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute are considered equal in comparisons.</source>
          <target state="translated">주의 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 의 값으로 만 다를 경우 &lt;a href=&quot;#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 특성 비교가 동일한 것으로 간주된다.</target>
        </trans-unit>
        <trans-unit id="6e00171800132e17b717121535b8def5b8c707ca" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt;&lt;code&gt;is_alive()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt;&lt;code&gt;exitcode&lt;/code&gt;&lt;/a&gt; methods should only be called by the process that created the process object.</source>
          <target state="translated">주의 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt; &lt;code&gt;is_alive()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt; &lt;code&gt;exitcode&lt;/code&gt; &lt;/a&gt; 방법은 처리 객체를 생성하는 프로세스에 의해 호출되어야한다.</target>
        </trans-unit>
        <trans-unit id="76be1da5963fc00b55ce37e0edfebe2ece5a230b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;save()&lt;/code&gt; method won&amp;rsquo;t save session cookies anyway, unless you ask otherwise by passing a true &lt;em&gt;ignore_discard&lt;/em&gt; argument.</source>
          <target state="translated">참고 그 &lt;code&gt;save()&lt;/code&gt; 방법이 아니다 세션 쿠키 저장 어쨌든 것입니다, 당신은 진정한 전달하여 달리 요청하지 않는 &lt;em&gt;ignore_discard의&lt;/em&gt; 인수를.</target>
        </trans-unit>
        <trans-unit id="8d128adeddb15c243a31ce0c09ab30c3100bf9aa" translate="yes" xml:space="preserve">
          <source>Note that the application code and tag bindings can set the selection however they wish, regardless of the value of this option.</source>
          <target state="translated">응용 프로그램 코드 및 태그 바인딩은이 옵션의 값에 관계없이 원하는대로 선택을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c688652d419206207ca4fcfbba08a17cc1b4d53" translate="yes" xml:space="preserve">
          <source>Note that the audited arguments may not match the names or positions required by the initializer.</source>
          <target state="translated">감사 된 인수는 이니셜 라이저에 필요한 이름 또는 위치와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1deb77e6b0aedeb954896c3aa4ddbd679ed1b4d5" translate="yes" xml:space="preserve">
          <source>Note that the behaviour of &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt;&lt;code&gt;set_event_loop()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#asyncio.new_event_loop&quot;&gt;&lt;code&gt;new_event_loop()&lt;/code&gt;&lt;/a&gt; functions can be altered by &lt;a href=&quot;asyncio-policy#asyncio-policies&quot;&gt;setting a custom event loop policy&lt;/a&gt;.</source>
          <target state="translated">의 행동주의 &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt; &lt;code&gt;set_event_loop()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#asyncio.new_event_loop&quot;&gt; &lt;code&gt;new_event_loop()&lt;/code&gt; &lt;/a&gt; 함수에 의해 변경 될 수 있습니다 &lt;a href=&quot;asyncio-policy#asyncio-policies&quot;&gt;사용자 정의 이벤트 루프 정책을 설정&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c66dde87415197d1cc25303a3cb3f7fea45cb7cf" translate="yes" xml:space="preserve">
          <source>Note that the callable will get its parameters as Python bytestrings, which will normally be encoded in UTF-8.</source>
          <target state="translated">호출 가능 변수는 일반적으로 UTF-8로 인코딩되는 Python 바이트 문자열로 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e0ce1087d446a80a298883ee298079809ee68d3a" translate="yes" xml:space="preserve">
          <source>Note that the decorators are applied from the bottom upwards. This is the standard way that Python applies decorators. The order of the created mocks passed into your test function matches this order.</source>
          <target state="translated">데코레이터는 아래쪽에서 위쪽으로 적용됩니다. 이것은 파이썬이 데코레이터를 적용하는 표준 방식입니다. 테스트 함수에 전달 된 작성된 모의 순서는이 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e97d1070ca60575742bafcaf80da75c01c5d2f24" translate="yes" xml:space="preserve">
          <source>Note that the default &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt;&lt;code&gt;tzinfo.fromutc()&lt;/code&gt;&lt;/a&gt; method can be overridden in a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass to affect the result returned by &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt;&lt;code&gt;astimezone()&lt;/code&gt;&lt;/a&gt;. Ignoring error cases, &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt;&lt;code&gt;astimezone()&lt;/code&gt;&lt;/a&gt; acts like:</source>
          <target state="translated">기본 &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt; &lt;code&gt;tzinfo.fromutc()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 에서 대체되어 &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt; &lt;code&gt;astimezone()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 결과에 영향을 줄 수 있습니다 . 오류 사례를 무시 &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt; &lt;code&gt;astimezone()&lt;/code&gt; &lt;/a&gt; 와 같은 역할을합니다 :</target>
        </trans-unit>
        <trans-unit id="1cdde200b54fdac2ca71696d1fcd9ec16758fa9f" translate="yes" xml:space="preserve">
          <source>Note that the end positions are not required by the compiler and are therefore optional. The end offset is &lt;em&gt;after&lt;/em&gt; the last symbol, for example one can get the source segment of a one-line expression node using &lt;code&gt;source_line[node.col_offset : node.end_col_offset]&lt;/code&gt;.</source>
          <target state="translated">종료 위치는 컴파일러에 필요하지 않으므로 선택 사항입니다. 종료 오프셋은 마지막 심볼 &lt;em&gt;뒤에&lt;/em&gt; 있습니다. 예를 들어 &lt;code&gt;source_line[node.col_offset : node.end_col_offset]&lt;/code&gt; 사용하여 한 줄 표현식 노드의 소스 세그먼트를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eec0865e31dfa1bea83fd13d92d1b7c2e61986db" translate="yes" xml:space="preserve">
          <source>Note that the exact contents of code info strings are highly implementation dependent and they may change arbitrarily across Python VMs or Python releases.</source>
          <target state="translated">코드 정보 문자열의 정확한 내용은 구현에 따라 달라지며 Python VM 또는 Python 릴리스에서 임의로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164b1f59a18e5c8abf18fac5ba8c576d24f04885" translate="yes" xml:space="preserve">
          <source>Note that the exact times you set here may not be returned by a subsequent &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt; call, depending on the resolution with which your operating system records access and modification times; see &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;. The best way to preserve exact times is to use the &lt;em&gt;st_atime_ns&lt;/em&gt; and &lt;em&gt;st_mtime_ns&lt;/em&gt; fields from the &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; result object with the &lt;em&gt;ns&lt;/em&gt; parameter to &lt;code&gt;utime&lt;/code&gt;.</source>
          <target state="translated">여기에서 설정 한 정확한 시간 은 운영 체제가 액세스 및 수정 시간을 기록하는 해상도에 따라 후속 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 호출 로 반환되지 않을 수 있습니다 . &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 정확한 시간을 유지하는 가장 좋은 방법 은 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 결과 객체 의 &lt;em&gt;st_atime_ns&lt;/em&gt; 및 &lt;em&gt;st_mtime_ns&lt;/em&gt; 필드를 &lt;em&gt;ns&lt;/em&gt; 매개 변수 와 함께 &lt;code&gt;utime&lt;/code&gt; 에 사용하는 것 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b5bbdf77d63ecd9abde1ce3e6def80c3014baa1" translate="yes" xml:space="preserve">
          <source>Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string &lt;code&gt;0x3.a7p10&lt;/code&gt; represents the floating-point number &lt;code&gt;(3 + 10./16 + 7./16**2) * 2.0**10&lt;/code&gt;, or &lt;code&gt;3740.0&lt;/code&gt;:</source>
          <target state="translated">지수는 16 진수가 아닌 10 진수로 기록되며 계수를 곱하는 2의 거듭 제곱을 제공합니다. 예를 들어, 16 진 문자열 &lt;code&gt;0x3.a7p10&lt;/code&gt; 은 부동 소수점 숫자 &lt;code&gt;(3 + 10./16 + 7./16**2) * 2.0**10&lt;/code&gt; 또는 &lt;code&gt;3740.0&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eabb40ec8d9514ff31867d76604ec09c63b3f62f" translate="yes" xml:space="preserve">
          <source>Note that the file is always opened in binary mode. To open a compressed file in text mode, use &lt;a href=&quot;#gzip.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; (or wrap your &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">파일은 항상 이진 모드로 열립니다. 텍스트 모드에서 압축 파일을 &lt;a href=&quot;#gzip.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 (또는 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 로&lt;/a&gt; 감싸십시오 ).</target>
        </trans-unit>
        <trans-unit id="2d4d5de3b61f6ba7f6afbe52eb7e703b5895b919" translate="yes" xml:space="preserve">
          <source>Note that the filename separator (&lt;code&gt;'/'&lt;/code&gt; on Unix) is &lt;em&gt;not&lt;/em&gt; special to this module. See module &lt;a href=&quot;glob#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; for pathname expansion (&lt;a href=&quot;glob#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;#fnmatch.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt; to match pathname segments). Similarly, filenames starting with a period are not special for this module, and are matched by the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; patterns.</source>
          <target state="translated">파일 이름 구분 기호 ( UNIX의 경우 &lt;code&gt;'/'&lt;/code&gt; )는 이 모듈에 특별 &lt;em&gt;하지 않습니다&lt;/em&gt; . 경로 이름 확장에 대해서는 모듈 &lt;a href=&quot;glob#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 ( &lt;a href=&quot;glob#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#fnmatch.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 경로 이름 세그먼트를 일치시킵니다). 마찬가지로 마침표로 시작하는 파일 이름은이 모듈에서 특별하지 않으며 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; 패턴.</target>
        </trans-unit>
        <trans-unit id="1992a5171785db5fc3c20b9338bd90d43b3a8008" translate="yes" xml:space="preserve">
          <source>Note that the first type annotation must be enclosed in quotes, making it a &amp;ldquo;forward reference&amp;rdquo;, to hide the &lt;code&gt;expensive_mod&lt;/code&gt; reference from the interpreter runtime. Type annotations for local variables are not evaluated, so the second annotation does not need to be enclosed in quotes.</source>
          <target state="translated">인터프리터 런타임에서 &lt;code&gt;expensive_mod&lt;/code&gt; 참조 를 숨기려면 첫 번째 유형 어노테이션을 따옴표로 묶어야하며&amp;ldquo;앞으로 참조&amp;rdquo;해야 합니다. 지역 변수에 대한 유형 주석은 평가되지 않으므로 두 번째 주석은 따옴표로 묶을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="59a1de269ac77e8f64ef50ba801d5c66b9db1422" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;a href=&quot;#parser.compilest&quot;&gt;&lt;code&gt;compilest()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parser.expr&quot;&gt;&lt;code&gt;expr()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#parser.suite&quot;&gt;&lt;code&gt;suite()&lt;/code&gt;&lt;/a&gt; may raise exceptions which are normally raised by the parsing and compilation process. These include the built in exceptions &lt;a href=&quot;exceptions#MemoryError&quot;&gt;&lt;code&gt;MemoryError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;exceptions#SystemError&quot;&gt;&lt;code&gt;SystemError&lt;/code&gt;&lt;/a&gt;. In these cases, these exceptions carry all the meaning normally associated with them. Refer to the descriptions of each function for detailed information.</source>
          <target state="translated">&lt;a href=&quot;#parser.compilest&quot;&gt; &lt;code&gt;compilest()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#parser.expr&quot;&gt; &lt;code&gt;expr()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#parser.suite&quot;&gt; &lt;code&gt;suite()&lt;/code&gt; &lt;/a&gt; 함수 는 일반적으로 구문 분석 및 컴파일 프로세스에서 발생하는 예외를 발생시킬 수 있습니다. 여기에는 내장 예외 &lt;a href=&quot;exceptions#MemoryError&quot;&gt; &lt;code&gt;MemoryError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#SystemError&quot;&gt; &lt;code&gt;SystemError&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다. 이 경우 이러한 예외는 일반적으로 관련된 모든 의미를 지닙니다. 자세한 정보는 각 기능의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cba8c1dab1231c0e020d29f555ee5fe18e0dc2a0" translate="yes" xml:space="preserve">
          <source>Note that the global side effect on &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; means that this context manager is not suitable for use in library code and most threaded applications. It also has no effect on the output of subprocesses. However, it is still a useful approach for many utility scripts.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 의 글로벌 부작용 은이 컨텍스트 관리자가 라이브러리 코드 및 대부분의 스레드 응용 프로그램에 사용하기에 적합하지 않음을 의미합니다. 또한 서브 프로세스의 출력에는 영향을 미치지 않습니다. 그러나 여전히 많은 유틸리티 스크립트에 유용한 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="256291afcdf663f4ee7f5d169948e8c4e068a3ea" translate="yes" xml:space="preserve">
          <source>Note that the implementation of these methods may involve calls of the parent &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.request.OpenerDirector.error&quot;&gt;&lt;code&gt;error()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이러한 메소드를 구현하려면 상위 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; &lt;/a&gt; 인스턴스의 &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.request.OpenerDirector.error&quot;&gt; &lt;code&gt;error()&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="db96e2903bb03526d487ef5f0e7a28904d91b153" translate="yes" xml:space="preserve">
          <source>Note that the last tuple returned by &lt;code&gt;get_matching_blocks()&lt;/code&gt; is always a dummy, &lt;code&gt;(len(a), len(b), 0)&lt;/code&gt;, and this is the only case in which the last tuple element (number of elements matched) is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_matching_blocks()&lt;/code&gt; 의해 반환 된 마지막 튜플 은 항상 더미 &lt;code&gt;(len(a), len(b), 0)&lt;/code&gt; 이며 마지막 튜플 요소 (일치하는 요소 수)가 &lt;code&gt;0&lt;/code&gt; 인 유일한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="5d9efcbb8db4d5059e437fd61cf5752e8f008ac4" translate="yes" xml:space="preserve">
          <source>Note that the length of this list must be seven items.</source>
          <target state="translated">이 목록의 길이는 7 개의 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cc6ae65cf6a2c6b690528b4be599e5bed47ef7e9" translate="yes" xml:space="preserve">
          <source>Note that the locator will return correct information only during the invocation of the events in this interface. The application should not attempt to use it at any other time.</source>
          <target state="translated">로케이터는이 인터페이스에서 이벤트를 호출하는 동안에 만 올바른 정보를 리턴합니다. 응용 프로그램은 다른 시간에 응용 프로그램을 사용하려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4e632c3015ab8a0ba3453634da1b41b96d4c11e9" translate="yes" xml:space="preserve">
          <source>Note that the man pages list &amp;ldquo;STANDARD OPTIONS&amp;rdquo; and &amp;ldquo;WIDGET SPECIFIC OPTIONS&amp;rdquo; for each widget. The former is a list of options that are common to many widgets, the latter are the options that are idiosyncratic to that particular widget. The Standard Options are documented on the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/options(3)&quot;&gt;options(3)&lt;/a&gt;&lt;/em&gt; man page.</source>
          <target state="translated">매뉴얼 페이지에는 각 위젯에 대한 &quot;표준 옵션&quot;및 &quot;WIDGET 특정 옵션&quot;이 나열되어 있습니다. 전자는 많은 위젯에 공통적 인 옵션 목록이며, 후자는 해당 특정 위젯과 고유 한 옵션입니다. 표준 옵션은 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/options(3)&quot;&gt;options (3)&lt;/a&gt;&lt;/em&gt; 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aa16e828033b4f45947239c8dad63dfd83cf58b" translate="yes" xml:space="preserve">
          <source>Note that the methods of a pool should only ever be used by the process which created it.</source>
          <target state="translated">풀의 메소드는 풀을 작성한 프로세스에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="403f74ccffe9160e93df16ee60fb1936940a68d7" translate="yes" xml:space="preserve">
          <source>Note that the methods of the pool object should only be called by the process which created the pool.</source>
          <target state="translated">풀 객체의 메서드는 풀을 만든 프로세스에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="072ef7e2339f223029bd2baf38337de36c7889d9" translate="yes" xml:space="preserve">
          <source>Note that the object name, &lt;code&gt;.fred&lt;/code&gt;, starts with a dot.</source>
          <target state="translated">객체 이름 &lt;code&gt;.fred&lt;/code&gt; 는 점으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="dd5e150e0b095725b6075fcce13020fbe7fbe7d6" translate="yes" xml:space="preserve">
          <source>Note that the object returned by &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will only contain attributes for the main parser and the subparser that was selected by the command line (and not any other subparsers). So in the example above, when the &lt;code&gt;a&lt;/code&gt; command is specified, only the &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes are present, and when the &lt;code&gt;b&lt;/code&gt; command is specified, only the &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; attributes are present.</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 오브젝트 는 기본 구문 분석기 및 명령 행에 의해 선택된 서브 파서 (다른 서브 파서는 아님)에 대한 속성 만 포함합니다. 따라서 위 예에서 &lt;code&gt;a&lt;/code&gt; 명령이 지정되면 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 속성 만 존재하고 &lt;code&gt;b&lt;/code&gt; 명령이 지정되면 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 속성 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="833ae3938a6f5fe64221af69a439e4759ab70b12" translate="yes" xml:space="preserve">
          <source>Note that the order of the (states, value) sequences for an option does matter, if the order is changed to &lt;code&gt;[('active', 'blue'), ('pressed',
'red')]&lt;/code&gt; in the foreground option, for example, the result would be a blue foreground when the widget were in active or pressed states.</source>
          <target state="translated">전경 옵션에서 순서가 &lt;code&gt;[('active', 'blue'), ('pressed', 'red')]&lt;/code&gt; 로 변경되면 옵션에 대한 (상태, 값) 순서의 순서는 중요합니다. 예를 들어, 위젯이 활성 상태이거나 눌린 상태 일 때 결과는 파란색 전경이됩니다.</target>
        </trans-unit>
        <trans-unit id="01a23cd9ecbf3257e28cf9b896b0dcad21defe07" translate="yes" xml:space="preserve">
          <source>Note that the parser can be extended in limited ways, and of course you can implement your own parser completely from scratch. All of the logic that connects the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package&amp;rsquo;s bundled parser and the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; class is embodied in the &lt;code&gt;policy&lt;/code&gt; class, so a custom parser can create message object trees any way it finds necessary by implementing custom versions of the appropriate &lt;code&gt;policy&lt;/code&gt; methods.</source>
          <target state="translated">파서는 제한적인 방식으로 확장 될 수 있으며 물론 파서는 처음부터 완전히 구현할 수 있습니다. &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지의 번들 파서와 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 클래스 를 연결하는 모든 논리 는 &lt;code&gt;policy&lt;/code&gt; 클래스에 구현되어 있으므로 사용자 정의 파서는 적절한 &lt;code&gt;policy&lt;/code&gt; 방법 의 사용자 정의 버전을 구현하여 원하는 방식으로 메시지 객체 트리를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1eb8965b25ea5257a0aa1f9f0bb3c11a3367f9de" translate="yes" xml:space="preserve">
          <source>Note that the parser only accepts the Unix-style end of line convention. If you are reading the code from a file, make sure to use newline conversion mode to convert Windows or Mac-style newlines.</source>
          <target state="translated">파서는 유닉스 스타일의 End of Line 규칙 만 받아들입니다. 파일에서 코드를 읽는 경우 개행 변환 모드를 사용하여 Windows 또는 Mac 스타일 개행을 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="34bc7518b3bc42848108ade424e482f1e8016982" translate="yes" xml:space="preserve">
          <source>Note that the program name, whether determined from &lt;code&gt;sys.argv[0]&lt;/code&gt; or from the &lt;code&gt;prog=&lt;/code&gt; argument, is available to help messages using the &lt;code&gt;%(prog)s&lt;/code&gt; format specifier.</source>
          <target state="translated">&lt;code&gt;sys.argv[0]&lt;/code&gt; 또는 &lt;code&gt;prog=&lt;/code&gt; 인수 에서 판별 된 프로그램 이름 은 &lt;code&gt;%(prog)s&lt;/code&gt; 형식 지정자를 사용하여 메시지를 돕기 위해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="b19c49eed7c2426d8842fd07e5e1a3d9193ed340" translate="yes" xml:space="preserve">
          <source>Note that the second use of &lt;code&gt;_()&lt;/code&gt; will not identify &amp;ldquo;a&amp;rdquo; as being translatable to the &lt;strong&gt;gettext&lt;/strong&gt; program, because the parameter is not a string literal.</source>
          <target state="translated">&lt;code&gt;_()&lt;/code&gt; 의 두 번째 사용은 매개 변수가 문자열 리터럴이 아니기 때문에 &quot;a&quot;를 &lt;strong&gt;gettext&lt;/strong&gt; 프로그램 으로 변환 할 수있는 것으로 식별 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="750397ea45aa11b67082fae179f2b2c630c4ca79" translate="yes" xml:space="preserve">
          <source>Note that the selection of functions is similar, but not identical, to that in module &lt;a href=&quot;math#module-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. The reason for having two modules is that some users aren&amp;rsquo;t interested in complex numbers, and perhaps don&amp;rsquo;t even know what they are. They would rather have &lt;code&gt;math.sqrt(-1)&lt;/code&gt; raise an exception than return a complex number. Also note that the functions defined in &lt;a href=&quot;#module-cmath&quot;&gt;&lt;code&gt;cmath&lt;/code&gt;&lt;/a&gt; always return a complex number, even if the answer can be expressed as a real number (in which case the complex number has an imaginary part of zero).</source>
          <target state="translated">함수 선택은 &lt;a href=&quot;math#module-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; &lt;/a&gt; 모듈과 유사하지만 동일하지는 않습니다 . 두 개의 모듈을 사용하는 이유는 일부 사용자가 복잡한 숫자에 관심이없고 자신이 무엇인지 모르기 때문입니다. 오히려 &lt;code&gt;math.sqrt(-1)&lt;/code&gt; 가 복소수를 반환하는 것보다 예외를 발생시킵니다. 또한 답을 실수로 표현할 수있는 경우에도 &lt;a href=&quot;#module-cmath&quot;&gt; &lt;code&gt;cmath&lt;/code&gt; 에&lt;/a&gt; 정의 된 함수는 항상 복소수를 반환합니다 (이 경우 복소수의 허수 부분은 0 임).</target>
        </trans-unit>
        <trans-unit id="81dcea5e7b8c2cdc13cbbc4c1f112a24bc49255e" translate="yes" xml:space="preserve">
          <source>Note that the sign of the timezone offset is the opposite of the sign of the &lt;code&gt;time.timezone&lt;/code&gt; variable for the same timezone; the latter variable follows the POSIX standard while this module follows &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">시간대 오프셋의 부호 는 동일한 시간대에 대한 &lt;code&gt;time.timezone&lt;/code&gt; 변수 의 부호와 반대입니다 . 후자의 변수는 POSIX 표준을 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;따르고이&lt;/strong&gt;&lt;/a&gt; 모듈은 &lt;strong&gt;RFC 2822를&lt;/strong&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="e162688246d240a8c716dca372b82c4250936fa7" translate="yes" xml:space="preserve">
          <source>Note that the two instances of class &lt;code&gt;C&lt;/code&gt; share the same class variable &lt;code&gt;x&lt;/code&gt;, as expected.</source>
          <target state="translated">클래스 &lt;code&gt;C&lt;/code&gt; 의 두 인스턴스는 예상대로 동일한 클래스 변수 &lt;code&gt;x&lt;/code&gt; 를 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="cd586d754c27e8997ced1a5ea4a1abad329acacc" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;a href=&quot;#abc.ABC&quot;&gt;&lt;code&gt;ABC&lt;/code&gt;&lt;/a&gt; is still &lt;a href=&quot;#abc.ABCMeta&quot;&gt;&lt;code&gt;ABCMeta&lt;/code&gt;&lt;/a&gt;, therefore inheriting from &lt;a href=&quot;#abc.ABC&quot;&gt;&lt;code&gt;ABC&lt;/code&gt;&lt;/a&gt; requires the usual precautions regarding metaclass usage, as multiple inheritance may lead to metaclass conflicts. One may also define an abstract base class by passing the metaclass keyword and using &lt;a href=&quot;#abc.ABCMeta&quot;&gt;&lt;code&gt;ABCMeta&lt;/code&gt;&lt;/a&gt; directly, for example:</source>
          <target state="translated">&lt;a href=&quot;#abc.ABC&quot;&gt; &lt;code&gt;ABC&lt;/code&gt; &lt;/a&gt; 유형 은 여전히 &lt;a href=&quot;#abc.ABCMeta&quot;&gt; &lt;code&gt;ABCMeta&lt;/code&gt; &lt;/a&gt; 이므로 다중 상속이 메타 클래스 충돌을 일으킬 수 있으므로 &lt;a href=&quot;#abc.ABC&quot;&gt; &lt;code&gt;ABC&lt;/code&gt; &lt;/a&gt; 에서 상속 하려면 메타 클래스 사용에 관한 일반적인 예방 조치가 필요합니다. 메타 클래스 키워드를 전달하고 &lt;a href=&quot;#abc.ABCMeta&quot;&gt; &lt;code&gt;ABCMeta&lt;/code&gt; 를&lt;/a&gt; 직접 사용하여 추상 기본 클래스를 정의 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fc591820a47265f251fd7af3b9597e91511cf6a" translate="yes" xml:space="preserve">
          <source>Note that there are no methods &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;write()&lt;/code&gt;; use &lt;a href=&quot;#socket.socket.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.socket.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; without &lt;em&gt;flags&lt;/em&gt; argument instead.</source>
          <target state="translated">&lt;code&gt;read()&lt;/code&gt; 또는 &lt;code&gt;write()&lt;/code&gt; 메소드는 없습니다 . 사용 &lt;a href=&quot;#socket.socket.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.socket.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 없이 &lt;em&gt;플래그&lt;/em&gt; 대신 인수.</target>
        </trans-unit>
        <trans-unit id="36630936cce6573d3d4dc4a543a2ef65fc12897f" translate="yes" xml:space="preserve">
          <source>Note that there are unavoidable subtleties twice per year in a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass accounting for both standard and daylight time, at the DST transition points. For concreteness, consider US Eastern (UTC -0500), where EDT begins the minute after 1:59 (EST) on the second Sunday in March, and ends the minute after 1:59 (EDT) on the first Sunday in November:</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스에서는 DST 전환 지점에서 표준 및 일광 시간을 모두 고려 하여 매년 두 번 피할 수없는 미묘함이 있습니다 . 구체적으로, EDT는 3 월 둘째 일요일 1시 59 분 (EST) 이후에 시작되고 11 월 첫째 일요일 1시 59 분 (EDT) 이후에 끝나는 미국 동부 (UTC -0500)를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="15592c72a8f6f854d7f0dbccf4a1703e76bd673a" translate="yes" xml:space="preserve">
          <source>Note that there is a nice correspondence between several attributes and methods of &lt;code&gt;os.DirEntry&lt;/code&gt; and of &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt;. In particular, the &lt;code&gt;name&lt;/code&gt; attribute has the same meaning, as do the &lt;code&gt;is_dir()&lt;/code&gt;, &lt;code&gt;is_file()&lt;/code&gt;, &lt;code&gt;is_symlink()&lt;/code&gt; and &lt;code&gt;stat()&lt;/code&gt; methods.</source>
          <target state="translated">참고 여러 속성과 방법 사이의 좋은 대응이 있음을 &lt;code&gt;os.DirEntry&lt;/code&gt; 와의 &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; 은&lt;/a&gt; . 특히 &lt;code&gt;name&lt;/code&gt; 속성은 &lt;code&gt;is_dir()&lt;/code&gt; , &lt;code&gt;is_file()&lt;/code&gt; , &lt;code&gt;is_symlink()&lt;/code&gt; 및 &lt;code&gt;stat()&lt;/code&gt; 메소드 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="8df01b5cba256bfe26308cfbe1ebdc3f6c2def0b" translate="yes" xml:space="preserve">
          <source>Note that there is no need to call this function when &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; 을 사용할 때이 함수를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b57144e5df9df62e17e080fadafa48aa0596258b" translate="yes" xml:space="preserve">
          <source>Note that there is no specific slot for any of these methods in the type structure for Python objects in the Python/C API. Extension types wanting to define these methods must provide them as a normal Python accessible method. Compared to the overhead of setting up the runtime context, the overhead of a single class dictionary lookup is negligible.</source>
          <target state="translated">Python / C API에서 Python 객체의 유형 구조에는 이러한 메소드에 대한 특정 슬롯이 없습니다. 이러한 메소드를 정의하려는 확장 유형은 일반적인 Python 액세스 가능 메소드로 제공해야합니다. 런타임 컨텍스트를 설정하는 오버 헤드와 비교할 때 단일 클래스 사전 검색의 오버 헤드는 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a02df7e02b3ab3b4f010591f5ece20d6e24dd6b" translate="yes" xml:space="preserve">
          <source>Note that there is one additional limitation when using context managers as function decorators: there&amp;rsquo;s no way to access the return value of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt;. If that value is needed, then it is still necessary to use an explicit &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">컨텍스트 관리자를 함수 데코레이터로 사용하는 경우 한 가지 추가 제한 사항이 있습니다. 반환 값 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 에 액세스 할 수있는 방법이 없습니다 . 해당 값이 필요한 경우 명시 적 &lt;code&gt;with&lt;/code&gt; 문 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1a0bc324af393bbb5dd82800c76c036cbda0f5f" translate="yes" xml:space="preserve">
          <source>Note that these checks are enforced only by the static type checker. At runtime, the statement &lt;code&gt;Derived = NewType('Derived', Base)&lt;/code&gt; will make &lt;code&gt;Derived&lt;/code&gt; a function that immediately returns whatever parameter you pass it. That means the expression &lt;code&gt;Derived(some_value)&lt;/code&gt; does not create a new class or introduce any overhead beyond that of a regular function call.</source>
          <target state="translated">이러한 검사는 정적 유형 검사기에서만 시행됩니다. 런타임에 &lt;code&gt;Derived = NewType('Derived', Base)&lt;/code&gt; 은 &lt;code&gt;Derived&lt;/code&gt; 를 전달한 매개 변수를 즉시 반환하는 함수로 만듭니다 . 이는 &lt;code&gt;Derived(some_value)&lt;/code&gt; 표현식 이 새 클래스를 작성하지 않거나 일반 함수 호출보다 오버 헤드를 발생시키지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="472bb74ea73045e483510b2cd999d2e021bf1acc" translate="yes" xml:space="preserve">
          <source>Note that these functions are not meaningful for a multipart message. They must be applied to individual subparts instead, and will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if passed a message whose type is multipart.</source>
          <target state="translated">이러한 기능은 멀티 파트 메시지에는 의미가 없습니다. 그것들은 대신 개별 서브 파트에 적용되어야하며 , 유형이 멀티 파트 인 메시지를 전달하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="30d1675de10cd2d2ad0bc712bec13688a9a6c970" translate="yes" xml:space="preserve">
          <source>Note that these methods must &lt;em&gt;not&lt;/em&gt; be called during parsing, that is, after parse has been called and before it returns.</source>
          <target state="translated">이러한 방법이 있어야합니다 &lt;em&gt;하지&lt;/em&gt; 파스가 호출 된 후,이다 분석, 동안 그것을 반환하기 전에 호출.</target>
        </trans-unit>
        <trans-unit id="d29fa93c8852c067f1d3f1f3ca06f2de2869049f" translate="yes" xml:space="preserve">
          <source>Note that this adds a sixth attribute (&lt;a href=&quot;#platform.processor&quot;&gt;&lt;code&gt;processor&lt;/code&gt;&lt;/a&gt;) not present in the &lt;a href=&quot;os#os.uname&quot;&gt;&lt;code&gt;os.uname()&lt;/code&gt;&lt;/a&gt; result. Also, the attribute names are different for the first two attributes; &lt;a href=&quot;os#os.uname&quot;&gt;&lt;code&gt;os.uname()&lt;/code&gt;&lt;/a&gt; names them &lt;code&gt;sysname&lt;/code&gt; and &lt;code&gt;nodename&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;a href=&quot;os#os.uname&quot;&gt; &lt;code&gt;os.uname()&lt;/code&gt; &lt;/a&gt; 결과 에없는 여섯 번째 속성 ( &lt;a href=&quot;#platform.processor&quot;&gt; &lt;code&gt;processor&lt;/code&gt; &lt;/a&gt; )을 추가합니다 . 또한 속성 이름은 처음 두 속성마다 다릅니다. &lt;a href=&quot;os#os.uname&quot;&gt; &lt;code&gt;os.uname()&lt;/code&gt; &lt;/a&gt; 이름을 &lt;code&gt;sysname&lt;/code&gt; 과 &lt;code&gt;nodename&lt;/code&gt; 으로 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="2d46886958797cfa9907ad4c6425e0ae6791da66" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;em&gt;not&lt;/em&gt; overwrite or delete any existing header with the same name. If you want to ensure that the new header is the only one present in the message with field name &lt;em&gt;name&lt;/em&gt;, delete the field first, e.g.:</source>
          <target state="translated">동일한 이름의 기존 헤더를 덮어 쓰거나 삭제 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 필드 이름이 &lt;em&gt;name&lt;/em&gt; 인 메시지에 새 헤더 만있는 것을 확인 하려면 먼저 필드를 삭제하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="b79b943f472b0275b7ad6a51da0c669884bba25f" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;em&gt;only&lt;/em&gt; returns a meaningful name for actual Python modules - paths that potentially refer to Python packages will still return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 실제 Python 모듈에 대해 의미있는 이름 &lt;em&gt;만&lt;/em&gt; 반환합니다. 잠재적으로 Python 패키지를 참조하는 경로는 여전히 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1e5f27a50e7211ff256009dee22a78b6d7a48364" translate="yes" xml:space="preserve">
          <source>Note that this function does not raise &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt;&lt;code&gt;asyncio.TimeoutError&lt;/code&gt;&lt;/a&gt;. Futures or Tasks that aren&amp;rsquo;t done when the timeout occurs are simply returned in the second set.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt; &lt;code&gt;asyncio.TimeoutError&lt;/code&gt; 를 발생&lt;/a&gt; 시키지 않습니다 . 타임 아웃이 발생했을 때 완료되지 않은 선물 또는 작업은 단순히 두 번째 세트로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e96664f646c10e89d795c433800d7c1e4544c3" translate="yes" xml:space="preserve">
          <source>Note that this function has intimate knowledge of how different libc versions add symbols to the executable is probably only usable for executables compiled using &lt;strong&gt;gcc&lt;/strong&gt;.</source>
          <target state="translated">이 함수는 다른 libc 버전이 실행 파일에 심볼을 추가하는 방법에 대한 친밀한 지식을 가지고 있으며 아마도 &lt;strong&gt;gcc를&lt;/strong&gt; 사용하여 컴파일 된 실행 파일에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f629527ef98fcd33c266ca1c4678e0ef5157a6" translate="yes" xml:space="preserve">
          <source>Note that this function must import all &lt;em&gt;packages&lt;/em&gt; (&lt;em&gt;not&lt;/em&gt; all modules!) on the given &lt;em&gt;path&lt;/em&gt;, in order to access the &lt;code&gt;__path__&lt;/code&gt; attribute to find submodules.</source>
          <target state="translated">이 기능은 모든 수입해야합니다 &lt;em&gt;패키지&lt;/em&gt; ( &lt;em&gt;하지&lt;/em&gt; 주어진 모든 모듈을!) &lt;em&gt;경로에&lt;/em&gt; 액세스하기 위해, &lt;code&gt;__path__&lt;/code&gt; 서브 모듈을 찾을 속성을.</target>
        </trans-unit>
        <trans-unit id="a589457ce4b7eed1abc8c3023b9a61ab3a1a55e6" translate="yes" xml:space="preserve">
          <source>Note that this function will not work with the &amp;lsquo;C&amp;rsquo; locale, so you have to set a locale via &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">이 함수는 'C'로케일에서 작동하지 않으므로 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 통해 로케일을 먼저 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7fbd744392c36926075a26d9e3ab559ef32a1e2" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; a sandbox module - all code is executed in the current process, and any side effects (such as cached imports of other modules) will remain in place after the functions have returned.</source>
          <target state="translated">이것은 샌드 박스 모듈 이 &lt;em&gt;아니라는&lt;/em&gt; 점에 유의하십시오. 모든 코드는 현재 프로세스에서 실행되며 함수가 반환 된 후에도 부작용 (예 : 다른 모듈의 캐시 된 가져 오기)이 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5db5a52cc1e7c561c7837d97bc61981bd4e2bf44" translate="yes" xml:space="preserve">
          <source>Note that this is another reason why you need integration tests as well as unit tests. Testing everything in isolation is all fine and dandy, but if you don&amp;rsquo;t test how your units are &amp;ldquo;wired together&amp;rdquo; there is still lots of room for bugs that tests might have caught.</source>
          <target state="translated">이것이 단위 테스트뿐만 아니라 통합 테스트가 필요한 또 다른 이유입니다. 모든 것을 분리해서 테스트하는 것은 괜찮고 멋지지만, 유닛이 어떻게 서로 연결되어 있는지 테스트하지 않으면 테스트에서 발견 된 버그에 대한 여지가 여전히 많습니다.</target>
        </trans-unit>
        <trans-unit id="b965eef784d4d104baee666239b49d8cae11dad4" translate="yes" xml:space="preserve">
          <source>Note that this is equivalent to &lt;code&gt;bool(expr) is True&lt;/code&gt; and not to &lt;code&gt;expr
is True&lt;/code&gt; (use &lt;code&gt;assertIs(expr, True)&lt;/code&gt; for the latter). This method should also be avoided when more specific methods are available (e.g. &lt;code&gt;assertEqual(a, b)&lt;/code&gt; instead of &lt;code&gt;assertTrue(a == b)&lt;/code&gt;), because they provide a better error message in case of failure.</source>
          <target state="translated">참고이 동등이라고 &lt;code&gt;bool(expr) is True&lt;/code&gt; 하지에 &lt;code&gt;expr is True&lt;/code&gt; (사용 &lt;code&gt;assertIs(expr, True)&lt;/code&gt; 후자의 경우). 이 메소드는 실패 할 경우 더 나은 오류 메시지를 제공하므로 보다 구체적인 메소드를 사용할 수있는 경우 (예 : &lt;code&gt;assertTrue(a == b)&lt;/code&gt; 대신 &lt;code&gt;assertEqual(a, b)&lt;/code&gt; 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="5e6fff084be385dbf0bc1a43435632a2295ef2a7" translate="yes" xml:space="preserve">
          <source>Note that this is not the same concept as an optional argument, which is one that has a default. An optional argument with a default does not require the &lt;code&gt;Optional&lt;/code&gt; qualifier on its type annotation just because it is optional. For example:</source>
          <target state="translated">이것은 선택적 인수와 같은 개념이 아니며 기본값을 갖는 인수입니다. 기본값이있는 선택적 인수 는 선택 적이기 때문에 유형 어노테이션에 &lt;code&gt;Optional&lt;/code&gt; 규정자가 필요하지 않습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="497db1e409c9d5535b9f7799396b336c6bf26c17" translate="yes" xml:space="preserve">
          <source>Note that this is only one way, albeit the most convenient way, to make the &lt;code&gt;_()&lt;/code&gt; function available to your application. Because it affects the entire application globally, and specifically the built-in namespace, localized modules should never install &lt;code&gt;_()&lt;/code&gt;. Instead, they should use this code to make &lt;code&gt;_()&lt;/code&gt; available to their module:</source>
          <target state="translated">이 방법은 가장 편리한 방법이지만 응용 프로그램 에서 &lt;code&gt;_()&lt;/code&gt; 함수를 사용할 수있는 한 가지 방법 일뿐 입니다. 전역 응용 프로그램, 특히 내장 네임 스페이스에 영향을주기 때문에 지역화 된 모듈은 &lt;code&gt;_()&lt;/code&gt; 을 설치하지 않아야합니다 . 대신,이 코드를 사용하여 &lt;code&gt;_()&lt;/code&gt; 을 모듈에서 사용할 수있게해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5dd52f7d1a18d76b5b1670ad4b672dfed972deb" translate="yes" xml:space="preserve">
          <source>Note that this manipulation of &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; is not thread-safe. Other threads may see the partially initialised module, as well as the altered list of arguments. It is recommended that the &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; module be left alone when invoking this function from threaded code.</source>
          <target state="translated">이 &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; 조작은 스레드로부터 안전하지 않습니다. 다른 스레드는 부분적으로 초기화 된 모듈과 변경된 인수 목록을 볼 수 있습니다. 스레드 코드에서이 기능을 호출 할 때는 &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; 모듈을 그대로 두는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ad60b5a4d53caa42fe4b708c2e6654939094b20a" translate="yes" xml:space="preserve">
          <source>Note that this may not be done after authentication information has been transmitted, and authentication occurs by default if possible during a &lt;a href=&quot;#nntplib.NNTP&quot;&gt;&lt;code&gt;NNTP&lt;/code&gt;&lt;/a&gt; object initialization. See &lt;a href=&quot;#nntplib.NNTP.login&quot;&gt;&lt;code&gt;NNTP.login()&lt;/code&gt;&lt;/a&gt; for information on suppressing this behavior.</source>
          <target state="translated">인증 정보가 전송 된 후에는이 작업이 수행되지 않을 수 있으며 &lt;a href=&quot;#nntplib.NNTP&quot;&gt; &lt;code&gt;NNTP&lt;/code&gt; &lt;/a&gt; 객체 초기화 중에 가능한 경우 기본적으로 인증이 수행됩니다 . 이 동작 억제에 대한 정보는 &lt;a href=&quot;#nntplib.NNTP.login&quot;&gt; &lt;code&gt;NNTP.login()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ca198d21563fd5cf167242f8f7abad568ca45e5" translate="yes" xml:space="preserve">
          <source>Note that this may raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; on Unix platforms like Mac OS X where &lt;code&gt;sem_getvalue()&lt;/code&gt; is not implemented.</source>
          <target state="translated">이 올릴 수 있음을 참고 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를&lt;/a&gt; 맥 OS X와 같은 유닉스 플랫폼에서 &lt;code&gt;sem_getvalue()&lt;/code&gt; 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46df65154fc5779c9a8d8169de6b544a5033f917" translate="yes" xml:space="preserve">
          <source>Note that this method differs from &lt;a href=&quot;#email.message.Message.get_charset&quot;&gt;&lt;code&gt;get_charset()&lt;/code&gt;&lt;/a&gt; which returns the &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt; instance for the default encoding of the message body.</source>
          <target state="translated">이 메소드는 메시지 본문의 기본 인코딩에 대한 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하는 &lt;a href=&quot;#email.message.Message.get_charset&quot;&gt; &lt;code&gt;get_charset()&lt;/code&gt; &lt;/a&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7ec37bb1f92cbf01a7d78829d33f077a718bc081" translate="yes" xml:space="preserve">
          <source>Note that this method is automatically added to the class: it is not directly specified in the &lt;code&gt;InventoryItem&lt;/code&gt; definition shown above.</source>
          <target state="translated">이 메소드는 클래스에 자동으로 추가됩니다 . 위에 표시된 &lt;code&gt;InventoryItem&lt;/code&gt; 정의 에 직접 지정되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="2d0305ac41e9e98f465e3a09a7a321fde7592591" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not always format the message the way you want. For example, by default it does not do the mangling of lines that begin with &lt;code&gt;From&lt;/code&gt; that is required by the unix mbox format. For more flexibility, instantiate a &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt; instance and use its &lt;a href=&quot;email.generator#email.generator.BytesGenerator.flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt; method directly. For example:</source>
          <target state="translated">이 방법은 편의상 제공되며 원하는 방식으로 메시지를 항상 형식화하지는 않습니다. 예를 들어, 기본적으로 유닉스 mbox 형식에 필요한 &lt;code&gt;From&lt;/code&gt; 으로 시작하는 행을 조작하지 않습니다 . 유연성을 &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 인스턴스를 인스턴스화 하고 &lt;a href=&quot;email.generator#email.generator.BytesGenerator.flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt; 메소드를 직접 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc1e53b42c929782edab5f61e605edfc1b232f1f" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not always format the message the way you want. For example, by default it does not do the mangling of lines that begin with &lt;code&gt;From&lt;/code&gt; that is required by the unix mbox format. For more flexibility, instantiate a &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; instance and use its &lt;a href=&quot;email.generator#email.generator.Generator.flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt; method directly. For example:</source>
          <target state="translated">이 방법은 편의상 제공되며 원하는 방식으로 메시지를 항상 형식화하지는 않습니다. 예를 들어, 기본적으로 유닉스 mbox 형식에 필요한 &lt;code&gt;From&lt;/code&gt; 으로 시작하는 행을 조작하지 않습니다 . 유연성을 높이 려면 &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 인스턴스를 인스턴스화 하고 &lt;a href=&quot;email.generator#email.generator.Generator.flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt; 메서드를 직접 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="914ac925c90ce0481ed0d7bcee5c22d8232a27d1" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not be the most useful way to serialize messages in your application, especially if you are dealing with multiple messages. See &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;email.generator.BytesGenerator&lt;/code&gt;&lt;/a&gt; for a more flexible API for serializing messages.</source>
          <target state="translated">이 방법은 편의상 제공되며 특히 여러 메시지를 처리하는 경우 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법이 아닐 수 있습니다. 보다 유연한 메시지 직렬화 API는 &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;email.generator.BytesGenerator&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0569aab75ed3c326d1e3ad45e468b2d9a967ffbc" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not be the most useful way to serialize messages in your application, especially if you are dealing with multiple messages. See &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;email.generator.Generator&lt;/code&gt;&lt;/a&gt; for a more flexible API for serializing messages. Note also that this method is restricted to producing messages serialized as &amp;ldquo;7 bit clean&amp;rdquo; when &lt;a href=&quot;email.policy#email.policy.EmailPolicy.utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;, which is the default.</source>
          <target state="translated">이 방법은 편의상 제공되며 특히 여러 메시지를 처리하는 경우 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법이 아닐 수 있습니다. 보다 유연한 메시지 직렬화 API는 &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;email.generator.Generator&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 또한이 방법은 &lt;a href=&quot;email.policy#email.policy.EmailPolicy.utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;False&lt;/code&gt; 인 경우 &quot;7 비트 클린&quot;으로 직렬화 된 메시지를 생성하는 것으로 제한됩니다 ( 기본값).</target>
        </trans-unit>
        <trans-unit id="4863202591f117b45079183ed253d97469614cfd" translate="yes" xml:space="preserve">
          <source>Note that this should be called at most once, and it should be protected inside the &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; clause of the main module.</source>
          <target state="translated">이것은 최대 한 번만 호출해야하며 기본 모듈 의 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 절 내에서 보호되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f023dfbaa5e7784ac868d744c9df4db74a2b0f4" translate="yes" xml:space="preserve">
          <source>Note that this utility does not guarantee complete &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt; compliance; an absence of errors from this module does not necessarily mean that errors do not exist. However, if this module does produce an error, then it is virtually certain that either the server or application is not 100% compliant.</source>
          <target state="translated">이 유틸리티는 완전한 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt; 준수를 보장하지는 않습니다 . 이 모듈에서 오류가 없다고해서 반드시 오류가 없음을 의미하지는 않습니다. 그러나이 모듈에서 오류가 발생하면 서버 나 응용 프로그램이 100 % 호환되지 않는 것이 확실합니다.</target>
        </trans-unit>
        <trans-unit id="392655359709b780ff1bb9da7fb1ff72dc351b8b" translate="yes" xml:space="preserve">
          <source>Note that tracebacks are treated very specially. In particular, in the rewritten example, the use of &lt;code&gt;...&lt;/code&gt; is independent of doctest&amp;rsquo;s &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt;&lt;code&gt;ELLIPSIS&lt;/code&gt;&lt;/a&gt; option. The ellipsis in that example could be left out, or could just as well be three (or three hundred) commas or digits, or an indented transcript of a Monty Python skit.</source>
          <target state="translated">역 추적은 매우 특별하게 처리됩니다. 특히, 재 작성된 예에서 &lt;code&gt;...&lt;/code&gt; 의 사용 은 doctest의 &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt; &lt;code&gt;ELLIPSIS&lt;/code&gt; &lt;/a&gt; 옵션 과 무관 합니다. 이 예제의 줄임표는 생략되거나 쉼표 나 숫자가 3 개 (또는 300 개)이거나 Monty Python skit의 들여 쓰기 된 대본이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953d734e119512ee18a0a9392b9f9b9d6d4df366" translate="yes" xml:space="preserve">
          <source>Note that unclosed single-quoted strings do not cause an error to be raised. They are tokenized as &lt;a href=&quot;token#token.ERRORTOKEN&quot;&gt;&lt;code&gt;ERRORTOKEN&lt;/code&gt;&lt;/a&gt;, followed by the tokenization of their contents.</source>
          <target state="translated">닫지 않은 작은 따옴표로 묶인 문자열로 인해 오류가 발생하지는 않습니다. 그것들은 &lt;a href=&quot;token#token.ERRORTOKEN&quot;&gt; &lt;code&gt;ERRORTOKEN&lt;/code&gt; &lt;/a&gt; 으로 토큰 화되고 그 뒤에 내용의 토큰 화됩니다.</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">최소 필드 너비가 정의되지 않으면 필드 너비는 항상 데이터를 채우는 데이터와 동일한 크기이므로 정렬 옵션은이 경우 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0733676794f7d6ac39c0d22a2a452465ab6a556" translate="yes" xml:space="preserve">
          <source>Note that unlike many other generics in the typing module, the &lt;code&gt;SendType&lt;/code&gt; of &lt;a href=&quot;#typing.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; behaves contravariantly, not covariantly or invariantly.</source>
          <target state="translated">타이핑 모듈의 다른 많은 제네릭과 달리 &lt;code&gt;SendType&lt;/code&gt; of &lt;a href=&quot;#typing.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 는&lt;/a&gt; 공변량 또는 불변성이 아닌 반동적 으로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="a6e9cb78d9006ba4f85f82103063e16f601f2f04" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;a href=&quot;#csv.DictReader&quot;&gt;&lt;code&gt;DictReader&lt;/code&gt;&lt;/a&gt; class, the &lt;em&gt;fieldnames&lt;/em&gt; parameter of the &lt;a href=&quot;#csv.DictWriter&quot;&gt;&lt;code&gt;DictWriter&lt;/code&gt;&lt;/a&gt; class is not optional.</source>
          <target state="translated">달리합니다 &lt;a href=&quot;#csv.DictReader&quot;&gt; &lt;code&gt;DictReader&lt;/code&gt; 의&lt;/a&gt; 클래스의 &lt;em&gt;fieldName에의&lt;/em&gt; 의 매개 변수 &lt;a href=&quot;#csv.DictWriter&quot;&gt; &lt;code&gt;DictWriter&lt;/code&gt; 의&lt;/a&gt; 클래스는 선택 사항이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b92a04f3a0309df577dbc705f08776279130e14e" translate="yes" xml:space="preserve">
          <source>Note that unlike the C structure, the month value is a range of [1, 12], not [0, 11].</source>
          <target state="translated">C 구조와 달리 월 값은 [0, 11]이 아니라 [1, 12]의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="8eede2ce0b3d8e2c9335916e2ca2bc70c1345924" translate="yes" xml:space="preserve">
          <source>Note that unlike the Python &lt;code&gt;sys.version&lt;/code&gt;, the returned value will always include the patchlevel (it defaults to 0).</source>
          <target state="translated">Python &lt;code&gt;sys.version&lt;/code&gt; 과 달리 반환 된 값에는 항상 patchlevel이 포함됩니다 (기본값은 0).</target>
        </trans-unit>
        <trans-unit id="a0e44189a3d936dd2974b45ad2423d66b85bbb11" translate="yes" xml:space="preserve">
          <source>Note that unlike the Python &lt;code&gt;sys.version&lt;/code&gt;, the returned value will always include the patchlevel (it defaults to &lt;code&gt;'0'&lt;/code&gt;).</source>
          <target state="translated">Python &lt;code&gt;sys.version&lt;/code&gt; 과 달리 반환 된 값에는 항상 patchlevel이 포함됩니다 (기본값은 &lt;code&gt;'0'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="faae0ddf62d8d17e4575535b139e839cc1f2ad54" translate="yes" xml:space="preserve">
          <source>Note that urlopen returns a bytes object. This is because there is no way for urlopen to automatically determine the encoding of the byte stream it receives from the HTTP server. In general, a program will decode the returned bytes object to string once it determines or guesses the appropriate encoding.</source>
          <target state="translated">urlopen은 bytes 객체를 반환합니다. 이는 urlopen이 HTTP 서버로부터 수신 한 바이트 스트림의 인코딩을 자동으로 결정할 방법이 없기 때문입니다. 일반적으로 프로그램은 적절한 인코딩을 결정하거나 추측하면 반환 된 바이트 객체를 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="fb5a04375d4dd30682512ce20dc834dd48ae4073" translate="yes" xml:space="preserve">
          <source>Note that using this function may require some external synchronization if there are other threads whose state is unknown. If a barrier is broken it may be better to just leave it and create a new one.</source>
          <target state="translated">상태를 알 수없는 다른 스레드가있는 경우이 기능을 사용하려면 외부 동기화가 필요할 수 있습니다. 방벽이 깨지면 그냥 방치하여 새 방벽을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9c6aed152d7d60b297ac12eb40378b5912ced5a2" translate="yes" xml:space="preserve">
          <source>Note that using this method is subtly different from deleting the old &lt;em&gt;Content-Type&lt;/em&gt; header and adding a new one with the new boundary via &lt;a href=&quot;#email.message.EmailMessage.add_header&quot;&gt;&lt;code&gt;add_header()&lt;/code&gt;&lt;/a&gt;, because &lt;a href=&quot;#email.message.EmailMessage.set_boundary&quot;&gt;&lt;code&gt;set_boundary()&lt;/code&gt;&lt;/a&gt; preserves the order of the &lt;em&gt;Content-Type&lt;/em&gt; header in the list of headers.</source>
          <target state="translated">이 방법을 사용하면 기존의 삭제에서 미묘하게 다릅니다 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더를하고를 통해 새로운 경계와 새로운 추가 &lt;a href=&quot;#email.message.EmailMessage.add_header&quot;&gt; &lt;code&gt;add_header()&lt;/code&gt; &lt;/a&gt; 하기 때문에, &lt;a href=&quot;#email.message.EmailMessage.set_boundary&quot;&gt; &lt;code&gt;set_boundary()&lt;/code&gt; &lt;/a&gt; 의 순서 보존 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더의 목록에서 헤더를.</target>
        </trans-unit>
        <trans-unit id="9bd23778bbf355f16dc2a21579fe2ace4a93366b" translate="yes" xml:space="preserve">
          <source>Note that using this method is subtly different than deleting the old &lt;em&gt;Content-Type&lt;/em&gt; header and adding a new one with the new boundary via &lt;a href=&quot;#email.message.Message.add_header&quot;&gt;&lt;code&gt;add_header()&lt;/code&gt;&lt;/a&gt;, because &lt;a href=&quot;#email.message.Message.set_boundary&quot;&gt;&lt;code&gt;set_boundary()&lt;/code&gt;&lt;/a&gt; preserves the order of the &lt;em&gt;Content-Type&lt;/em&gt; header in the list of headers. However, it does &lt;em&gt;not&lt;/em&gt; preserve any continuation lines which may have been present in the original &lt;em&gt;Content-Type&lt;/em&gt; header.</source>
          <target state="translated">이 방법을 사용하면 기존의 삭제에 비해 미묘하게 다릅니다 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더를하고를 통해 새로운 경계와 새로운 추가 &lt;a href=&quot;#email.message.Message.add_header&quot;&gt; &lt;code&gt;add_header()&lt;/code&gt; &lt;/a&gt; 하기 때문에, &lt;a href=&quot;#email.message.Message.set_boundary&quot;&gt; &lt;code&gt;set_boundary()&lt;/code&gt; &lt;/a&gt; 의 순서 보존 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더의 목록에서 헤더를. 그러나 원본 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 에있을 수있는 연속 선 은 유지 하지 &lt;em&gt;않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c91ae7008ef906071438192c9d712ce1afcb7577" translate="yes" xml:space="preserve">
          <source>Note that via &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; hooks, all attributes are computed lazily, so there is no speed penalty if only those attributes which are lightweight to compute are used.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 후크 를 통해 모든 속성이 느리게 계산되므로 계산하기에 가벼운 속성 만 사용하면 속도가 저하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6620fed817fce6e58ea094966e81cd033a5e4010" translate="yes" xml:space="preserve">
          <source>Note that when instantiating a &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ&lt;/code&gt;&lt;/a&gt; object we may pass functions to filter out line and character &amp;ldquo;junk.&amp;rdquo; See the &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ()&lt;/code&gt;&lt;/a&gt; constructor for details.</source>
          <target state="translated">&lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ&lt;/code&gt; &lt;/a&gt; 객체를 인스턴스화 할 때 함수를 전달하여 줄과 문자&amp;ldquo;정크&amp;rdquo;를 걸러 낼 수 있습니다. 자세한 내용은 &lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ()&lt;/code&gt; &lt;/a&gt; 생성자를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd02f589dec05a4f2acacc6d0ca5ede64ffc86f9" translate="yes" xml:space="preserve">
          <source>Note that when locals are captured, they are also shown in the traceback.</source>
          <target state="translated">로컬이 캡처되면 트레이스 백에도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="502bb316d8bdb001894aeb3898845cca4d8900b3" translate="yes" xml:space="preserve">
          <source>Note that when reading configuration files, whitespace around the option names is stripped before &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt;&lt;code&gt;optionxform()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">구성 파일을 읽을 때 &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt; &lt;code&gt;optionxform()&lt;/code&gt; &lt;/a&gt; 을 호출 하기 전에 옵션 이름 주위의 공백이 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="ea83e7983f7be281ec5a3262ffed3a7df409c2d9" translate="yes" xml:space="preserve">
          <source>Note that when the Unicode patterns &lt;code&gt;[a-z]&lt;/code&gt; or &lt;code&gt;[A-Z]&lt;/code&gt; are used in combination with the &lt;a href=&quot;#re.IGNORECASE&quot;&gt;&lt;code&gt;IGNORECASE&lt;/code&gt;&lt;/a&gt; flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: &amp;lsquo;İ&amp;rsquo; (U+0130, Latin capital letter I with dot above), &amp;lsquo;ı&amp;rsquo; (U+0131, Latin small letter dotless i), &amp;lsquo;ſ&amp;rsquo; (U+017F, Latin small letter long s) and &amp;lsquo;K&amp;rsquo; (U+212A, Kelvin sign). If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used, only letters &amp;lsquo;a&amp;rsquo; to &amp;lsquo;z&amp;rsquo; and &amp;lsquo;A&amp;rsquo; to &amp;lsquo;Z&amp;rsquo; are matched.</source>
          <target state="translated">유니 코드 패턴 &lt;code&gt;[a-z]&lt;/code&gt; 또는 &lt;code&gt;[A-Z]&lt;/code&gt; &lt;a href=&quot;#re.IGNORECASE&quot;&gt; &lt;code&gt;IGNORECASE&lt;/code&gt; &lt;/a&gt; 플래그 와 함께 사용 하면 52 개의 ASCII 문자 및 4 개의 추가 비 ASCII 문자와 일치합니다 : 'İ'(U + 0130, 라틴 대문자 I 위의 점), 'ı'(U + 0131, 라틴 소문자 dotless i), 'ſ'(U + 017F, 라틴 소문자 long s) 및 'K'(U + 212A, 켈빈 기호). 경우] &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 의&lt;/a&gt; 플래그가 'Z'와 'Z'에서 'A'로, 오직 문자 'A'와 일치 사용된다.</target>
        </trans-unit>
        <trans-unit id="941b2bd8c0fceca2a354dab3b47ce6850b8f3e86" translate="yes" xml:space="preserve">
          <source>Note that while &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt;&lt;code&gt;iterparse()&lt;/code&gt;&lt;/a&gt; builds the tree incrementally, it issues blocking reads on &lt;em&gt;source&lt;/em&gt; (or the file it names). As such, it&amp;rsquo;s unsuitable for applications where blocking reads can&amp;rsquo;t be made. For fully non-blocking parsing, see &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt;&lt;code&gt;XMLPullParser&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반면 있습니다 &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt; &lt;code&gt;iterparse()&lt;/code&gt; &lt;/a&gt; 점진적으로 트리를 빌드가 차단 문제에 읽고 &lt;em&gt;소스&lt;/em&gt; (또는 파일 그 이름). 따라서 읽기 차단을 할 수없는 응용 프로그램에는 적합하지 않습니다. 완전 비 차단 구문 분석은 &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt; &lt;code&gt;XMLPullParser&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e2a3769eac1a1d1cf5224599e594a65402067fa" translate="yes" xml:space="preserve">
          <source>Note that widgets do not appear until they have had their geometry specified with a geometry manager. It&amp;rsquo;s a common early mistake to leave out the geometry specification, and then be surprised when the widget is created but nothing appears. A widget will appear only after it has had, for example, the packer&amp;rsquo;s &lt;code&gt;pack()&lt;/code&gt; method applied to it.</source>
          <target state="translated">위젯은 지오메트리 관리자로 지오메트리를 지정할 때까지 표시되지 않습니다. 지오메트리 사양을 생략하고 위젯이 생성되었지만 아무 것도 나타나지 않을 때 놀라는 것은 일반적인 초기 실수입니다. 위젯은 패커의 &lt;code&gt;pack()&lt;/code&gt; 메소드를 적용한 후에 만 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="2968c2dcd25aa32f9a9ffad2dfcf5c7c74536aa8" translate="yes" xml:space="preserve">
          <source>Note that win32 system dlls like &lt;code&gt;kernel32&lt;/code&gt; and &lt;code&gt;user32&lt;/code&gt; often export ANSI as well as UNICODE versions of a function. The UNICODE version is exported with an &lt;code&gt;W&lt;/code&gt; appended to the name, while the ANSI version is exported with an &lt;code&gt;A&lt;/code&gt; appended to the name. The win32 &lt;code&gt;GetModuleHandle&lt;/code&gt; function, which returns a &lt;em&gt;module handle&lt;/em&gt; for a given module name, has the following C prototype, and a macro is used to expose one of them as &lt;code&gt;GetModuleHandle&lt;/code&gt; depending on whether UNICODE is defined or not:</source>
          <target state="translated">&lt;code&gt;kernel32&lt;/code&gt; 및 &lt;code&gt;user32&lt;/code&gt; 와 같은 win32 시스템 dll은 종종 ANSI 및 UNICODE 버전의 함수를 내 보냅니다. 유니 코드 버전은 이름에 &lt;code&gt;W&lt;/code&gt; 가 추가 된 상태로 내보내지고 ANSI 버전은 이름에 &lt;code&gt;A&lt;/code&gt; 가 추가 된 상태로 내보내집니다 . 주어진 모듈 이름에 대한 &lt;em&gt;모듈 핸들&lt;/em&gt; 을 반환하는 win32 &lt;code&gt;GetModuleHandle&lt;/code&gt; 함수 는 다음과 같은 C 프로토 타입을 가지며 매크로는 UNICODE의 정의 여부에 따라 이들 중 하나를 &lt;code&gt;GetModuleHandle&lt;/code&gt; 로 표시하는 데 사용됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e484f1a68e220911d28f836ad1681a6e8b9beab" translate="yes" xml:space="preserve">
          <source>Note that you must have read the whole response before you can send a new request to the server.</source>
          <target state="translated">서버에 새 요청을 보내려면 전체 응답을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="03c8f7f230406149e0b90ed811820d038dcfd819" translate="yes" xml:space="preserve">
          <source>Note that, as with floating point numbers, &lt;code&gt;v is w&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;v == w&lt;/code&gt; for memoryview objects.</source>
          <target state="translated">부동 소수점 숫자와 마찬가지로 &lt;code&gt;v is w&lt;/code&gt; 는 memoryview 객체에 대해 &lt;code&gt;v == w&lt;/code&gt; 를 의미 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="84e31b16758bcc976ec2d505de7ab96563d8cfa9" translate="yes" xml:space="preserve">
          <source>Note that, because of normalization, &lt;code&gt;timedelta.max&lt;/code&gt; &amp;gt; &lt;code&gt;-timedelta.min&lt;/code&gt;. &lt;code&gt;-timedelta.max&lt;/code&gt; is not representable as a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">때문에 정상화의 그 주 &lt;code&gt;timedelta.max&lt;/code&gt; &amp;gt; &lt;code&gt;-timedelta.min&lt;/code&gt; . &lt;code&gt;-timedelta.max&lt;/code&gt; 는 A와 표현할 수없는 것입니다 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d2fa3178c8ace73525d94f281c6241f693463f13" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#runpy.run_module&quot;&gt;&lt;code&gt;run_module()&lt;/code&gt;&lt;/a&gt;, the alterations made to &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; are not optional in this function as these adjustments are essential to allowing the execution of sys.path entries. As the thread-safety limitations still apply, use of this function in threaded code should be either serialised with the import lock or delegated to a separate process.</source>
          <target state="translated">&lt;a href=&quot;#runpy.run_module&quot;&gt; &lt;code&gt;run_module()&lt;/code&gt; &lt;/a&gt; 과 달리 sys.path 항목의 실행을 허용하기 위해 이러한 조정이 필수적 이므로이 기능에서 &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; 에&lt;/a&gt; 대한 변경은 선택 사항이 아닙니다. 스레드 안전성 제한이 여전히 적용되므로 스레드 코드에서이 기능의 사용은 가져 오기 잠금으로 직렬화되거나 별도의 프로세스로 위임되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f1c5a3a10c1525bb6f32e3ae69372905a7415c70" translate="yes" xml:space="preserve">
          <source>Note the difference between &lt;code&gt;'@'&lt;/code&gt; and &lt;code&gt;'='&lt;/code&gt;: both use native byte order, but the size and alignment of the latter is standardized.</source>
          <target state="translated">&lt;code&gt;'@'&lt;/code&gt; 과 &lt;code&gt;'='&lt;/code&gt; 의 차이점에 유의하십시오 . 둘 다 기본 바이트 순서를 사용하지만 후자의 크기와 정렬이 표준화됩니다.</target>
        </trans-unit>
        <trans-unit id="394e74fcbbfae11d61ce5fd9d0741b358dc5b679" translate="yes" xml:space="preserve">
          <source>Note the unusual calling syntax: the &lt;em&gt;first&lt;/em&gt; argument is optional, and the second is required. This is a historical artifact for compatibility with the older &lt;code&gt;linuxaudiodev&lt;/code&gt; module which &lt;a href=&quot;#module-ossaudiodev&quot;&gt;&lt;code&gt;ossaudiodev&lt;/code&gt;&lt;/a&gt; supersedes.</source>
          <target state="translated">특이한 호출 구문에 주목하십시오. &lt;em&gt;첫 번째&lt;/em&gt; 인수는 선택 사항이며 두 &lt;em&gt;번째&lt;/em&gt; 인수는 필수입니다. 이것은 &lt;a href=&quot;#module-ossaudiodev&quot;&gt; &lt;code&gt;ossaudiodev&lt;/code&gt; 가&lt;/a&gt; 대체 하는 이전 &lt;code&gt;linuxaudiodev&lt;/code&gt; 모듈 과의 호환성을위한 역사적 유물입니다 .</target>
        </trans-unit>
        <trans-unit id="7af185c96012df581e5e0886681b5f83b41d3210" translate="yes" xml:space="preserve">
          <source>Note there are performance considerations involved with the &lt;em&gt;size&lt;/em&gt; parameter. For optimal performance, it is usually best to use the arraysize attribute. If the &lt;em&gt;size&lt;/em&gt; parameter is used, then it is best for it to retain the same value from one &lt;a href=&quot;#sqlite3.Cursor.fetchmany&quot;&gt;&lt;code&gt;fetchmany()&lt;/code&gt;&lt;/a&gt; call to the next.</source>
          <target state="translated">&lt;em&gt;size&lt;/em&gt; 매개 변수 와 관련된 성능 고려 사항이 있습니다 . 최적의 성능을 위해서는 일반적으로 arraysize 속성을 사용하는 것이 가장 좋습니다. 경우 &lt;em&gt;크기&lt;/em&gt; 매개 변수가 사용되는이 하나 명의 동일한 값을 유지하기 위해, 그것은 최선 &lt;a href=&quot;#sqlite3.Cursor.fetchmany&quot;&gt; &lt;code&gt;fetchmany()&lt;/code&gt; &lt;/a&gt; 호출 다음에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe587f2f04237cccac255c57a5d7d8af7041796" translate="yes" xml:space="preserve">
          <source>Note, however, that it&amp;rsquo;s not recommended from a security perspective to spit out diagnostics to any old user; ideally, you should have to do something special to enable diagnostic output, which is why the default implementation doesn&amp;rsquo;t include any.</source>
          <target state="translated">그러나 보안 관점에서 이전 사용자에게 진단을 내놓는 것은 권장되지 않습니다. 이상적으로는 진단 출력을 활성화하기 위해 특별한 작업을 수행해야하므로 기본 구현에 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="762ab7548d9281c2411acf4c20182504bff18c33" translate="yes" xml:space="preserve">
          <source>Note, that the data read is buffered in memory, so do not use this method if the data size is large or unlimited.</source>
          <target state="translated">읽은 데이터는 메모리에 버퍼링되므로 데이터 크기가 크거나 무제한 인 경우이 방법을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="88aebce2f9074a5fa8e2b3fc150edc9adfd4b5a6" translate="yes" xml:space="preserve">
          <source>Note, the &lt;em&gt;default&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt; unless explicitly set to &lt;em&gt;0&lt;/em&gt;.</source>
          <target state="translated">은 참고 &lt;em&gt;기본값은&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 을 명시 적으로 설정하지 않으면 &lt;em&gt;0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c1bc85960916ca65e7a3c8ddd82bfd13d344d14f" translate="yes" xml:space="preserve">
          <source>Note, the &lt;em&gt;elem&lt;/em&gt; argument to the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__contains__&quot;&gt;&lt;code&gt;__contains__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt; methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from &lt;em&gt;elem&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__contains__&quot;&gt; &lt;code&gt;__contains__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 및 destroy &lt;a href=&quot;#frozenset.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 &lt;em&gt;elem&lt;/em&gt; 인수 는 세트 일 수 있습니다. 동등한 고정 세트 검색을 지원하기 위해 임시 임시 세트는 &lt;em&gt;elem&lt;/em&gt; 에서 &lt;em&gt;작성&lt;/em&gt; 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ce50e6ce36b2bce4757cdba44683aef09df0f6a" translate="yes" xml:space="preserve">
          <source>Note, the iteration order of a &lt;a href=&quot;#collections.ChainMap&quot;&gt;&lt;code&gt;ChainMap()&lt;/code&gt;&lt;/a&gt; is determined by scanning the mappings last to first:</source>
          <target state="translated">&lt;a href=&quot;#collections.ChainMap&quot;&gt; &lt;code&gt;ChainMap()&lt;/code&gt; &lt;/a&gt; 의 반복 순서 는 맵핑을 마지막에서 처음으로 스캔하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3dedf0fa71983b6357e6e9bae7d93a1fd17b41" translate="yes" xml:space="preserve">
          <source>Note, the non-operator versions of &lt;a href=&quot;#frozenset.union&quot;&gt;&lt;code&gt;union()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.intersection&quot;&gt;&lt;code&gt;intersection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.difference&quot;&gt;&lt;code&gt;difference()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.issubset&quot;&gt;&lt;code&gt;issubset()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.issuperset&quot;&gt;&lt;code&gt;issuperset()&lt;/code&gt;&lt;/a&gt; methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like &lt;code&gt;set('abc') &amp;amp; 'cbs'&lt;/code&gt; in favor of the more readable &lt;code&gt;set('abc').intersection('cbs')&lt;/code&gt;.</source>
          <target state="translated">참고의 비 연산자 버전 &lt;a href=&quot;#frozenset.union&quot;&gt; &lt;code&gt;union()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.intersection&quot;&gt; &lt;code&gt;intersection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.difference&quot;&gt; &lt;code&gt;difference()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.issubset&quot;&gt; &lt;code&gt;issubset()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset.issuperset&quot;&gt; &lt;code&gt;issuperset()&lt;/code&gt; &lt;/a&gt; 메소드와 같은 인자를 반복 가능한 허용한다. 반대로, 연산자 기반의 대응자는 인수를 설정해야합니다. 이것은 더 읽기 쉬운 &lt;code&gt;set('abc').intersection('cbs')&lt;/code&gt; 대신에 &lt;code&gt;set('abc') &amp;amp; 'cbs'&lt;/code&gt; 와 같은 오류가 발생하기 쉬운 구성을 배제합니다 .</target>
        </trans-unit>
        <trans-unit id="051512041c44a2517e704de51f5530d92cd85cdd" translate="yes" xml:space="preserve">
          <source>Note, the non-operator versions of the &lt;a href=&quot;#frozenset.update&quot;&gt;&lt;code&gt;update()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.intersection_update&quot;&gt;&lt;code&gt;intersection_update()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.difference_update&quot;&gt;&lt;code&gt;difference_update()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.symmetric_difference_update&quot;&gt;&lt;code&gt;symmetric_difference_update()&lt;/code&gt;&lt;/a&gt; methods will accept any iterable as an argument.</source>
          <target state="translated">비 연산자 버전의 &lt;a href=&quot;#frozenset.update&quot;&gt; &lt;code&gt;update()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.intersection_update&quot;&gt; &lt;code&gt;intersection_update()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.difference_update&quot;&gt; &lt;code&gt;difference_update()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset.symmetric_difference_update&quot;&gt; &lt;code&gt;symmetric_difference_update()&lt;/code&gt; &lt;/a&gt; 메소드는 반복 가능한 인수를 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="112b3520cc7fea120e7deb94779035341ecfd7d1" translate="yes" xml:space="preserve">
          <source>Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable).</source>
          <target state="translated">툴킷의이 멤버에는 iterable의 길이에 따라 상당한 보조 기억 장치가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a1e86095e2b68b8a7fa1905437c2cc90128cdc" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#socket.gethostname&quot;&gt;&lt;code&gt;gethostname()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t always return the fully qualified domain name; use &lt;a href=&quot;#socket.getfqdn&quot;&gt;&lt;code&gt;getfqdn()&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">참고 : &lt;a href=&quot;#socket.gethostname&quot;&gt; &lt;code&gt;gethostname()&lt;/code&gt; &lt;/a&gt; 은 항상 정규화 된 도메인 이름을 반환하지는 않습니다. 이를 위해 &lt;a href=&quot;#socket.getfqdn&quot;&gt; &lt;code&gt;getfqdn()&lt;/code&gt; &lt;/a&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="940b0549d5a0a4041429b4eecbc4dbeb233620a3" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;The policy keyword should always be specified&lt;/strong&gt;; The default will change to &lt;a href=&quot;email.policy#email.policy.default&quot;&gt;&lt;code&gt;email.policy.default&lt;/code&gt;&lt;/a&gt; in a future version of Python.</source>
          <target state="translated">참고 : &lt;strong&gt;정책 키워드는 항상 지정해야합니다&lt;/strong&gt; . 이후 버전의 Python에서는 기본값이 &lt;a href=&quot;email.policy#email.policy.default&quot;&gt; &lt;code&gt;email.policy.default&lt;/code&gt; &lt;/a&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2cbdd7a2167c420ef2fe1b094a5250391cb7403" translate="yes" xml:space="preserve">
          <source>Note: If you just want to pass a pointer to an object to a foreign function call, you should use &lt;code&gt;byref(obj)&lt;/code&gt; which is much faster.</source>
          <target state="translated">참고 : 객체에 대한 포인터를 외부 함수 호출에 전달하려는 경우 훨씬 빠른 &lt;code&gt;byref(obj)&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="77e52fe2400941c708aa213fb2c6d50d40a1c8b9" translate="yes" xml:space="preserve">
          <source>Note: Some code samples reference the ctypes &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt; type. On platforms where &lt;code&gt;sizeof(long) == sizeof(int)&lt;/code&gt; it is an alias to &lt;a href=&quot;#ctypes.c_long&quot;&gt;&lt;code&gt;c_long&lt;/code&gt;&lt;/a&gt;. So, you should not be confused if &lt;a href=&quot;#ctypes.c_long&quot;&gt;&lt;code&gt;c_long&lt;/code&gt;&lt;/a&gt; is printed if you would expect &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt; &amp;mdash; they are actually the same type.</source>
          <target state="translated">참고 : 일부 코드 샘플은 ctypes &lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; &lt;/a&gt; 유형을 참조합니다 . &lt;code&gt;sizeof(long) == sizeof(int)&lt;/code&gt; 플랫폼에서는 &lt;a href=&quot;#ctypes.c_long&quot;&gt; &lt;code&gt;c_long&lt;/code&gt; &lt;/a&gt; 의 별명 입니다. 그래서, 당신은 경우 혼동해서는 안 &lt;a href=&quot;#ctypes.c_long&quot;&gt; &lt;code&gt;c_long&lt;/code&gt; 은&lt;/a&gt; 당신이 기대하는 경우 인쇄 &lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; 을&lt;/a&gt; 그들은 실제로 같은 유형이다 -.</target>
        </trans-unit>
        <trans-unit id="3e0eb9ee31e1587e739522fcda6c31ae3034a95a" translate="yes" xml:space="preserve">
          <source>Note: The code samples in this tutorial use &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; to make sure that they actually work. Since some code samples behave differently under Linux, Windows, or Mac OS X, they contain doctest directives in comments.</source>
          <target state="translated">참고 :이 학습서의 코드 샘플은 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 를 사용 하여 실제로 작동하는지 확인합니다. 일부 코드 샘플은 Linux, Windows 또는 Mac OS X에서 다르게 작동하므로 주석에 doctest 지시문이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="953b3d8abb71583778699e086e9ed766999d86c8" translate="yes" xml:space="preserve">
          <source>Note: The functions do not require the data given to them to be sorted. However, for reading convenience, most of the examples show sorted sequences.</source>
          <target state="translated">참고 : 함수는 주어진 데이터를 정렬 할 필요가 없습니다. 그러나 읽기 편의를 위해 대부분의 예제는 정렬 된 순서를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a1c53c3229edec4d12d1c96e481f3cb1be441c54" translate="yes" xml:space="preserve">
          <source>Note: an awakened thread does not actually return from its &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; call until it can reacquire the lock. Since &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; does not release the lock, its caller should.</source>
          <target state="translated">참고 : 깨어 난 스레드는 잠금을 다시 얻을 수있을 때까지 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출 에서 실제로 반환되지 않습니다 . 이후 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 잠금을 해제하지 않습니다, 호출자는해야한다.</target>
        </trans-unit>
        <trans-unit id="0a990121c7b5c3a78884ba5ed2602b8ed6c392e4" translate="yes" xml:space="preserve">
          <source>Note: if your enumeration defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; then whatever value(s) were given to the enum member will be passed into those methods. See &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; for an example.</source>
          <target state="translated">참고 : 열거 형에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 을 정의 하면 열거 형 멤버에 제공된 모든 값이 해당 메서드에 전달됩니다. 예를 들어 &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17bfb70d8bc59b6a601bb652e3e1e16fb71419ac" translate="yes" xml:space="preserve">
          <source>Note: loop may be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">참고 : loop는 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcbf716e0a93fc3a46f989b0950001ff549cbbb0" translate="yes" xml:space="preserve">
          <source>Note: the &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; methods don&amp;rsquo;t release the lock; this means that the thread or threads awakened will not return from their &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; call immediately, but only when the thread that called &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; finally relinquishes ownership of the lock.</source>
          <target state="translated">참고 : &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 메소드는 잠금을 해제하지 않습니다. 이것은 깨어 난 스레드가 즉시 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출 에서 반환되지 않으며 , &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 을 호출 한 스레드가 결국 잠금 소유권을 포기한 경우에만 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="20fdf933b6a8eed945310d963fa5e36f40c7100f" translate="yes" xml:space="preserve">
          <source>Note: this function may not be able to retrieve all attributes that getattr can fetch (like dynamically created attributes) and may find attributes that getattr can&amp;rsquo;t (like descriptors that raise AttributeError). It can also return descriptors objects instead of instance members.</source>
          <target state="translated">참고 :이 함수는 getattr이 가져올 수있는 모든 속성 (동적으로 생성 된 속성과 같은)을 검색하지 못할 수 있으며 getattr이 가져올 수없는 속성 (AttributeError를 발생시키는 설명자와 같은)을 찾을 수 있습니다. 또한 인스턴스 멤버 대신 설명자 객체를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe152fdfb8ac8116096c5833a5da72fe28dcdf6" translate="yes" xml:space="preserve">
          <source>Notebook</source>
          <target state="translated">Notebook</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="bd2179fffb660660b08dc66587d54c4693ebd949" translate="yes" xml:space="preserve">
          <source>Notes for type implementors</source>
          <target state="translated">타입 구현자를위한 노트</target>
        </trans-unit>
        <trans-unit id="7d429a334eb57d5c3e2b4354221adcdf790abbaa" translate="yes" xml:space="preserve">
          <source>Notes on Maildir by its inventor. Includes an updated name-creation scheme and details on &amp;ldquo;info&amp;rdquo; semantics.</source>
          <target state="translated">발명가의 Maildir에 대한 참고 사항. 업데이트 된 이름 생성 체계와 &quot;정보&quot;의미에 대한 세부 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="39979ab954b5d6a8f0a293f5c81ebd913e2a234b" translate="yes" xml:space="preserve">
          <source>Notes on Reproducibility</source>
          <target state="translated">재현성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="994bfa04566317a983e1a93b7ff9716e4f306af7" translate="yes" xml:space="preserve">
          <source>Notes on availability</source>
          <target state="translated">가용성에 대한 메모</target>
        </trans-unit>
        <trans-unit id="96ea6c9601efc087de48baaaf665d4181463804b" translate="yes" xml:space="preserve">
          <source>Notes on non-blocking sockets</source>
          <target state="translated">비 차단 소켓에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="3529fba1dfaa4d96d92ade4092c1a3d7d76cb625" translate="yes" xml:space="preserve">
          <source>Notes on socket timeouts</source>
          <target state="translated">소켓 타임 아웃에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4183ad6f00d027788e1933ebd67bd6184f44f2f1" translate="yes" xml:space="preserve">
          <source>Notes on the availability of these functions:</source>
          <target state="translated">이 기능의 가용성에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="4ab3dde9df12858e1f1d64a466b42281fd1c43e0" translate="yes" xml:space="preserve">
          <source>Notes on using &lt;a href=&quot;#collections.abc.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#collections.abc.MutableSet&quot;&gt;&lt;code&gt;MutableSet&lt;/code&gt;&lt;/a&gt; as a mixin:</source>
          <target state="translated">믹스 인으로 &lt;a href=&quot;#collections.abc.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#collections.abc.MutableSet&quot;&gt; &lt;code&gt;MutableSet&lt;/code&gt; &lt;/a&gt; 사용에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="2174435297546a50c24c84751b2ef81fc8fb5831" translate="yes" xml:space="preserve">
          <source>Notes: (1) For most applications the only &lt;em&gt;preferencelist&lt;/em&gt; combinations that really make sense are &lt;code&gt;('plain',)&lt;/code&gt;, &lt;code&gt;('html', 'plain')&lt;/code&gt;, and the default &lt;code&gt;('related', 'html', 'plain')&lt;/code&gt;. (2) Because matching starts with the object on which &lt;code&gt;get_body&lt;/code&gt; is called, calling &lt;code&gt;get_body&lt;/code&gt; on a &lt;code&gt;multipart/related&lt;/code&gt; will return the object itself unless &lt;em&gt;preferencelist&lt;/em&gt; has a non-default value. (3) Messages (or message parts) that do not specify a &lt;em&gt;Content-Type&lt;/em&gt; or whose &lt;em&gt;Content-Type&lt;/em&gt; header is invalid will be treated as if they are of type &lt;code&gt;text/plain&lt;/code&gt;, which may occasionally cause &lt;code&gt;get_body&lt;/code&gt; to return unexpected results.</source>
          <target state="translated">참고 : (1) 대부분의 응용 프로그램에서 실제로 의미가 있는 유일한 &lt;em&gt;기본 설정 목록&lt;/em&gt; 조합은 &lt;code&gt;('plain',)&lt;/code&gt; , &lt;code&gt;('html', 'plain')&lt;/code&gt; 및 기본값 &lt;code&gt;('related', 'html', 'plain')&lt;/code&gt; . (2)하는 목적에 일치 시작하기 때문에 &lt;code&gt;get_body&lt;/code&gt; 이 호출은 호출 &lt;code&gt;get_body&lt;/code&gt; 을 A의 &lt;code&gt;multipart/related&lt;/code&gt; 않는 오브젝트 자체를 반환 &lt;em&gt;preferencelist이&lt;/em&gt; 디폴트가 아닌 값을 갖는다. (3) 메시지 (또는 메시지 부분)를 지정하지 않은 &lt;em&gt;콘텐츠 형식&lt;/em&gt; 또는 &lt;em&gt;내용 - 형식&lt;/em&gt; 헤더가 형의 경우로 처리됩니다 잘못된 &lt;code&gt;text/plain&lt;/code&gt; ,때때로 발생할 수 있습니다 &lt;code&gt;get_body&lt;/code&gt; 는 예기치 않은 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="409919d20a4d8cdab37ba3de46d6036e52228eae" translate="yes" xml:space="preserve">
          <source>Nothing is specified in this locale.</source>
          <target state="translated">이 로케일에 지정된 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5c76d766938924c4560f425f6d8538403d340e8" translate="yes" xml:space="preserve">
          <source>Notice here how we wanted the &lt;em&gt;Subject&lt;/em&gt; field to contain a non-ASCII character? We did this by creating a &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; instance and passing in the character set that the byte string was encoded in. When the subsequent &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance was flattened, the &lt;em&gt;Subject&lt;/em&gt; field was properly &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; encoded. MIME-aware mail readers would show this header using the embedded ISO-8859-1 character.</source>
          <target state="translated">&lt;em&gt;제목&lt;/em&gt; 필드에 비 ASCII 문자를 포함 시키려면 어떻게해야 합니까? &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 인스턴스 를 작성 하고 바이트 문자열이 인코딩 된 문자 세트를 전달 하여이 작업을 수행 했습니다. 후속 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스가 병합되면 &lt;em&gt;Subject&lt;/em&gt; 필드가 올바르게 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2047로&lt;/strong&gt;&lt;/a&gt; 인코딩되었습니다. MIME 인식 메일 리더는 ISO-8859-1 문자를 사용하여이 헤더를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="30aaa667ceadb867eac4109ef078332b809dce4f" translate="yes" xml:space="preserve">
          <source>Notice how the widget field of the event is being accessed in the &lt;code&gt;turn_red()&lt;/code&gt; callback. This field contains the widget that caught the X event. The following table lists the other event fields you can access, and how they are denoted in Tk, which can be useful when referring to the Tk man pages.</source>
          <target state="translated">&lt;code&gt;turn_red()&lt;/code&gt; 콜백 에서 이벤트의 위젯 필드에 액세스하는 방법을 확인하십시오 . 이 필드에는 X 이벤트를 포착 한 위젯이 있습니다. 다음 표에는 액세스 할 수있는 다른 이벤트 필드와 해당 필드가 Tk로 표시되는 방법이 나와 있으며, 이는 Tk 매뉴얼 페이지를 참조 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="96b9beb737cf3231c7449d825ff3410688086c28" translate="yes" xml:space="preserve">
          <source>Notice that applying &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; to a proxy will return the representation of the referent, whereas applying &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; will return the representation of the proxy.</source>
          <target state="translated">인가 알 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 프록시에 적용하는 반면에, 지시 대상의 표현을 반환 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 프록시의 표현을 반환한다.</target>
        </trans-unit>
        <trans-unit id="aa30b318f59f62feb7be7cc735b127ba14e6692b" translate="yes" xml:space="preserve">
          <source>Notice that no typechecking is performed when assigning a value of type &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; to a more precise type. For example, the static type checker did not report an error when assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;s&lt;/code&gt; even though &lt;code&gt;s&lt;/code&gt; was declared to be of type &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and receives an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; value at runtime!</source>
          <target state="translated">&lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 유형의 값을 보다 정확한 유형에 지정할 때는 유형 검사가 수행되지 않습니다 . 할당 할 때 예를 들어, 정적 형식 검사가 오류를보고하지 않았습니다 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;s&lt;/code&gt; 하더라도 &lt;code&gt;s&lt;/code&gt; 타입으로 선언 된 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 수신 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 런타임에 값을!</target>
        </trans-unit>
        <trans-unit id="376b3de67409d19233b0e4907b9f553ccc115c20" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, it&amp;rsquo;s a much smaller set.</source>
          <target state="translated">Windows에서는 훨씬 작은 세트입니다.</target>
        </trans-unit>
        <trans-unit id="2cf0b6869f1edb55f90d57ea0a5832b1aa4e18b8" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this module depends on the actual implementation of the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/crypt(3)&quot;&gt;crypt(3)&lt;/a&gt;&lt;/em&gt; routine in the running system. Therefore, any extensions available on the current implementation will also be available on this module.</source>
          <target state="translated">이 모듈의 동작은 실행중인 시스템에서 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/crypt(3)&quot;&gt;crypt (3)&lt;/a&gt;&lt;/em&gt; 루틴 의 실제 구현에 따라 다릅니다 . 따라서 현재 구현에서 사용 가능한 확장은이 모듈에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0c4d04cc2d3987360c07fbe4eeb4ed6e5e1e21" translate="yes" xml:space="preserve">
          <source>Now add the Shape to the Screen&amp;rsquo;s shapelist and use it:</source>
          <target state="translated">이제 Shape를 Screen의 shapelist에 추가하고 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b5aed1a03f8c35d4b559d5f5099d36802ea5696" translate="yes" xml:space="preserve">
          <source>Now that we have created and saved a configuration file, let&amp;rsquo;s read it back and explore the data it holds.</source>
          <target state="translated">이제 구성 파일을 작성하고 저장 했으므로 파일을 읽고 보유한 데이터를 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="62f8769fc4f592eaaff3b60938b72976e8a63ca6" translate="yes" xml:space="preserve">
          <source>Now the SSL channel is established and the certificate verified, you can proceed to talk with the server:</source>
          <target state="translated">이제 SSL 채널이 설정되고 인증서가 확인되었으므로 서버와 계속 대화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31924ee76d82b9e37715f009e523c241db6e0226" translate="yes" xml:space="preserve">
          <source>Now we can actually compare the two items and return a useful result:</source>
          <target state="translated">이제 실제로 두 항목을 비교하고 유용한 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5eeebbc7cb554fdc7b5389ad448df86c1df182b" translate="yes" xml:space="preserve">
          <source>Now we plug &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;Row&lt;/code&gt;&lt;/a&gt; in:</source>
          <target state="translated">이제 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;Row&lt;/code&gt; &lt;/a&gt; 을 연결합니다 :</target>
        </trans-unit>
        <trans-unit id="8cb4116ac86e771beb460431be65c48158d5f51c" translate="yes" xml:space="preserve">
          <source>Now we want to test &lt;code&gt;some_function&lt;/code&gt; but we want to mock out &lt;code&gt;SomeClass&lt;/code&gt; using &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt;. The problem is that when we import module b, which we will have to do then it imports &lt;code&gt;SomeClass&lt;/code&gt; from module a. If we use &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; to mock out &lt;code&gt;a.SomeClass&lt;/code&gt; then it will have no effect on our test; module b already has a reference to the &lt;em&gt;real&lt;/em&gt;&lt;code&gt;SomeClass&lt;/code&gt; and it looks like our patching had no effect.</source>
          <target state="translated">이제 &lt;code&gt;some_function&lt;/code&gt; 을 테스트하려고 하지만 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;SomeClass&lt;/code&gt; 를 조롱하려고합니다 . 문제는 모듈 b를 가져올 때 모듈 a에서 &lt;code&gt;SomeClass&lt;/code&gt; 를 가져 오는 것입니다. &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;a.SomeClass&lt;/code&gt; 를 조롱하면 테스트에 영향을 미치지 않습니다. 모듈 b는 이미 &lt;em&gt;실제 &lt;/em&gt; &lt;code&gt;SomeClass&lt;/code&gt; 에 대한 참조를 가지고 있으며 패치가 적용되지 않은 것처럼 보입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1ed0c7c2d81859eda6b5cc833464eb0dd988f38" translate="yes" xml:space="preserve">
          <source>Now you need to make the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module know that what you select from the database is actually a point. There are two ways of doing this:</source>
          <target state="translated">이제 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈이 데이터베이스에서 선택한 것이 실제로 포인트라는 것을 알아야합니다. 이를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29ec33880afd873623e441fe4abecf453440c79" translate="yes" xml:space="preserve">
          <source>Now you want to store the point in a single SQLite column. First you&amp;rsquo;ll have to choose one of the supported types first to be used for representing the point. Let&amp;rsquo;s just use str and separate the coordinates using a semicolon. Then you need to give your class a method &lt;code&gt;__conform__(self, protocol)&lt;/code&gt; which must return the converted value. The parameter &lt;em&gt;protocol&lt;/em&gt; will be &lt;code&gt;PrepareProtocol&lt;/code&gt;.</source>
          <target state="translated">이제 포인트를 단일 SQLite 열에 저장하려고합니다. 먼저 점을 나타내는 데 사용할 지원되는 유형 중 하나를 먼저 선택해야합니다. str을 사용하고 세미콜론을 사용하여 좌표를 분리합시다. 그런 다음 클래스에 &lt;code&gt;__conform__(self, protocol)&lt;/code&gt; 메소드를 제공하여 변환 된 값을 리턴해야합니다. 매개 변수 &lt;em&gt;프로토콜&lt;/em&gt; 은 &lt;code&gt;PrepareProtocol&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6befe568a0abd7fa9cb859e17c6a8a729ffcf6a" translate="yes" xml:space="preserve">
          <source>Null-terminated string containing references to environment variables (&lt;code&gt;%PATH%&lt;/code&gt;).</source>
          <target state="translated">환경 변수에 대한 참조를 포함하는 널 종료 문자열 ( &lt;code&gt;%PATH%&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="19a9339a57b70f4cc49edd3bf00a059e1a50c395" translate="yes" xml:space="preserve">
          <source>NullHandler</source>
          <target state="translated">NullHandler</target>
        </trans-unit>
        <trans-unit id="fe1b2483239a18901875b04c1af675561eca1503" translate="yes" xml:space="preserve">
          <source>Number of 512-byte blocks allocated for file. This may be smaller than &lt;a href=&quot;#os.stat_result.st_size&quot;&gt;&lt;code&gt;st_size&lt;/code&gt;&lt;/a&gt;/512 when the file has holes.</source>
          <target state="translated">파일에 할당 된 512 바이트 블록 수 파일에 구멍이있는 경우 &lt;a href=&quot;#os.stat_result.st_size&quot;&gt; &lt;code&gt;st_size&lt;/code&gt; &lt;/a&gt; / 512 보다 작을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bd9aeb87537b2525d0c88b89b62a820757528d3" translate="yes" xml:space="preserve">
          <source>Number of days after password expires until account is disabled</source>
          <target state="translated">계정이 비활성화 될 때까지 비밀번호가 만료 된 후 일 수</target>
        </trans-unit>
        <trans-unit id="365942f74cce88224fdaf80b42555c03a1d840aa" translate="yes" xml:space="preserve">
          <source>Number of days before password expires to warn user about it</source>
          <target state="translated">비밀번호가 만료되어 사용자에게 경고하는 일 수</target>
        </trans-unit>
        <trans-unit id="f1d107706720211290a9386c8812c2312f0e8823" translate="yes" xml:space="preserve">
          <source>Number of days since 1970-01-01 when account expires</source>
          <target state="translated">계정이 만료 된 1970-01-01 이후의 일 수</target>
        </trans-unit>
        <trans-unit id="a9ee5a8328ef8d145926d62850a8557baa3d4537" translate="yes" xml:space="preserve">
          <source>Number of fractional digits used in international formatting of monetary values.</source>
          <target state="translated">통화 값의 국제 형식에 사용되는 소수 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="57778df03c86eae3d7455ab3c46c4fdf052bfc73" translate="yes" xml:space="preserve">
          <source>Number of fractional digits used in local formatting of monetary values.</source>
          <target state="translated">통화 값의 로컬 형식에 사용 된 소수 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="6c3cc540d70dfce9e01f95ffe47d1ef75ac135de" translate="yes" xml:space="preserve">
          <source>Number of hard links.</source>
          <target state="translated">하드 링크 수</target>
        </trans-unit>
        <trans-unit id="c971530ee281315f241b2dd1d6ecd30f91644cee" translate="yes" xml:space="preserve">
          <source>Number of items allowed in the queue.</source>
          <target state="translated">대기열에 허용 된 항목 수</target>
        </trans-unit>
        <trans-unit id="a932b86c0474eba5db591ae5f5240a50c1458767" translate="yes" xml:space="preserve">
          <source>Number of links to the inode.</source>
          <target state="translated">inode에 대한 링크 수</target>
        </trans-unit>
        <trans-unit id="4bc5edcccc10a3e8720986ec609357b1e21973dc" translate="yes" xml:space="preserve">
          <source>Number of memory blocks (&lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">메모리 블록 수 ( &lt;code&gt;int&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4cac858ebc148236e0b1217a291cec1302b7e513" translate="yes" xml:space="preserve">
          <source>Number of memory blocks in the new snapshot (&lt;code&gt;int&lt;/code&gt;): &lt;code&gt;0&lt;/code&gt; if the memory blocks have been released in the new snapshot.</source>
          <target state="translated">새 스냅 샷의 메모리 블록 수 ( &lt;code&gt;int&lt;/code&gt; ) : 새 스냅 샷 에서 메모리 블록이 해제 된 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7bc75d07118ba1efb51d5f92550d75df2499753" translate="yes" xml:space="preserve">
          <source>Number-theoretic and representation functions</source>
          <target state="translated">수 이론 및 표현 함수</target>
        </trans-unit>
        <trans-unit id="27268cbddf6ca05f823a05275d4b43b80d3a4bb3" translate="yes" xml:space="preserve">
          <source>Number. This is the same as &lt;code&gt;'d'&lt;/code&gt;, except that it uses the current locale setting to insert the appropriate number separator characters.</source>
          <target state="translated">번호. 이것과 동일 &lt;code&gt;'d'&lt;/code&gt; 는 적절한 수의 구분 문자를 삽입하기 위해 현재 지역 설정을 사용하는 것을 제외.</target>
        </trans-unit>
        <trans-unit id="2247bb12f37411302dec8137671e6f42f4c568a3" translate="yes" xml:space="preserve">
          <source>Number. This is the same as &lt;code&gt;'g'&lt;/code&gt;, except that it uses the current locale setting to insert the appropriate number separator characters.</source>
          <target state="translated">번호. 이것과 동일 &lt;code&gt;'g'&lt;/code&gt; 는 적절한 수의 구분 문자를 삽입하기 위해 현재 지역 설정을 사용하는 것을 제외.</target>
        </trans-unit>
        <trans-unit id="29ab7f8b0894602500582c7973038069b78c9eaf" translate="yes" xml:space="preserve">
          <source>Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating point numbers. Appending &lt;code&gt;'j'&lt;/code&gt; or &lt;code&gt;'J'&lt;/code&gt; to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts.</source>
          <target state="translated">숫자는 숫자 리터럴 또는 내장 함수 및 연산자의 결과로 생성됩니다. 부호없는 정수 리터럴 (16 진수, 8 진수 및 2 진수 포함)은 정수를 생성합니다. 소수점 또는 지수 부호를 포함하는 숫자 리터럴은 부동 소수점 숫자를 생성합니다. 숫자 리터럴에 &lt;code&gt;'j'&lt;/code&gt; 또는 &lt;code&gt;'J'&lt;/code&gt; 를 추가 하면 허수 (제로 실수 부분이있는 복소수)가 생성되며 정수에 추가하거나 실수로 실수와 허수 부분으로 복소수를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9524713edf06bad44da0de5f83160b3103bf5ebf" translate="yes" xml:space="preserve">
          <source>Numbers of the form &lt;code&gt;I/2.**J&lt;/code&gt; are safe across all platforms, and I often contrive doctest examples to produce numbers of that form:</source>
          <target state="translated">&lt;code&gt;I/2.**J&lt;/code&gt; 형식의 숫자는 모든 플랫폼에서 안전하며 종종 doctest 예제를 작성하여 해당 형식의 숫자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ae5a0b6b4520823e7613d9501888e3d11e368899" translate="yes" xml:space="preserve">
          <source>Numerator of the Fraction in lowest term.</source>
          <target state="translated">가장 낮은 용어에서 분수의 분자.</target>
        </trans-unit>
        <trans-unit id="fe7c15f08e26c4968f404fff756bea4c29d294be" translate="yes" xml:space="preserve">
          <source>Numeric &amp;amp; Mathematical</source>
          <target state="translated">숫자 및 수학</target>
        </trans-unit>
        <trans-unit id="9d18068578c94f717e14cf6e56443bc9d65ccc00" translate="yes" xml:space="preserve">
          <source>Numeric Types &amp;mdash; &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;</source>
          <target state="translated">숫자 형 &amp;mdash; &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;complex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd0376c4852e68845ab3978d24b24f0cc35e578a" translate="yes" xml:space="preserve">
          <source>Numeric Types &amp;mdash; int, float, complex</source>
          <target state="translated">숫자 유형 &amp;mdash; int, float, complex</target>
        </trans-unit>
        <trans-unit id="77321ffd329dae8a0e37ae9894a49ded0d830d86" translate="yes" xml:space="preserve">
          <source>Numeric and Mathematical Modules</source>
          <target state="translated">숫자 및 수학 모듈</target>
        </trans-unit>
        <trans-unit id="bd54554f02877d81fe4bebfe90fa1408d8cb1959" translate="yes" xml:space="preserve">
          <source>Numeric code specifying the problem. This value can be passed to the &lt;a href=&quot;#xml.parsers.expat.ErrorString&quot;&gt;&lt;code&gt;ErrorString()&lt;/code&gt;&lt;/a&gt; function, or compared to one of the constants defined in the &lt;code&gt;errors&lt;/code&gt; object.</source>
          <target state="translated">문제를 지정하는 숫자 코드. 이 값은 &lt;a href=&quot;#xml.parsers.expat.ErrorString&quot;&gt; &lt;code&gt;ErrorString()&lt;/code&gt; &lt;/a&gt; 함수에 전달 되거나 &lt;code&gt;errors&lt;/code&gt; 객체에 정의 된 상수 중 하나와 비교 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="545ad8b75c0d30c78850cca48b34174137396861" translate="yes" xml:space="preserve">
          <source>Numeric conversion methods: &lt;code&gt;__complex__&lt;/code&gt;, &lt;code&gt;__int__&lt;/code&gt;, &lt;code&gt;__float__&lt;/code&gt; and &lt;code&gt;__index__&lt;/code&gt;</source>
          <target state="translated">숫자 변환 방법 : &lt;code&gt;__complex__&lt;/code&gt; , &lt;code&gt;__int__&lt;/code&gt; , &lt;code&gt;__float__&lt;/code&gt; 및 &lt;code&gt;__index__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="871490f5f5a5ca6fd724e46e5e1c4d2eb2c25301" translate="yes" xml:space="preserve">
          <source>Numeric logging level for the message (&lt;code&gt;DEBUG&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt;, &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;CRITICAL&lt;/code&gt;).</source>
          <target state="translated">메시지의 숫자 로깅 레벨 ( &lt;code&gt;DEBUG&lt;/code&gt; , &lt;code&gt;INFO&lt;/code&gt; , &lt;code&gt;WARNING&lt;/code&gt; , &lt;code&gt;ERROR&lt;/code&gt; , &lt;code&gt;CRITICAL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bd50801aaae4c7a3a8229dfe2023c97d0cb617c" translate="yes" xml:space="preserve">
          <source>Numeric value</source>
          <target state="translated">숫자 값</target>
        </trans-unit>
        <trans-unit id="b8563a86b2e247948408ea7ca2751b301105c385" translate="yes" xml:space="preserve">
          <source>Numerical group ID</source>
          <target state="translated">숫자 그룹 ID</target>
        </trans-unit>
        <trans-unit id="d6feb6b63e4e9dedb1044129659dca2566b3a4d5" translate="yes" xml:space="preserve">
          <source>Numerical overflow.</source>
          <target state="translated">숫자 오버플로.</target>
        </trans-unit>
        <trans-unit id="504a627804ef772d9d97c9da6cc14b33a6e1fd94" translate="yes" xml:space="preserve">
          <source>Numerical underflow with result rounded to zero.</source>
          <target state="translated">결과가 0으로 반올림 된 수치 언더 플로우.</target>
        </trans-unit>
        <trans-unit id="dae105dbfe6ba9515db517e2c22306eaf168a3ed" translate="yes" xml:space="preserve">
          <source>Numerical user ID</source>
          <target state="translated">숫자 사용자 ID</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="b8e649f839ee53ebcae7841aed5eddf9904a43fd" translate="yes" xml:space="preserve">
          <source>O flag</source>
          <target state="translated">오 플래그</target>
        </trans-unit>
        <trans-unit id="2081f9b4215b950149c134904322caba1359a7a3" translate="yes" xml:space="preserve">
          <source>OS exceptions</source>
          <target state="translated">OS 예외</target>
        </trans-unit>
        <trans-unit id="495dc72791fecbe14725db696ffa42ad8b5edf3d" translate="yes" xml:space="preserve">
          <source>OSError</source>
          <target state="translated">OSError</target>
        </trans-unit>
        <trans-unit id="70bc67f09c2b2fce50ddd07b8816ca72d8245a13" translate="yes" xml:space="preserve">
          <source>OSError.errno</source>
          <target state="translated">OSError.errno</target>
        </trans-unit>
        <trans-unit id="6b00a948ec3f45fe825b1d53b803425a17d2bac9" translate="yes" xml:space="preserve">
          <source>OSError.filename</source>
          <target state="translated">OSError.filename</target>
        </trans-unit>
        <trans-unit id="87b0b664ad8163e07f5f101b197e001d4dadefba" translate="yes" xml:space="preserve">
          <source>OSError.filename2</source>
          <target state="translated">OSError.filename2</target>
        </trans-unit>
        <trans-unit id="1d64b19f5dacbeca7d89e999fabefa0257b25308" translate="yes" xml:space="preserve">
          <source>OSError.strerror</source>
          <target state="translated">OSError.strerror</target>
        </trans-unit>
        <trans-unit id="1252f72b16eb4033e6a82e45191bc3fa864d0cf2" translate="yes" xml:space="preserve">
          <source>OSError.winerror</source>
          <target state="translated">OSError.winerror</target>
        </trans-unit>
        <trans-unit id="fec57e31aba99aafb11659a650fe7e717b5c39f8" translate="yes" xml:space="preserve">
          <source>Object connections</source>
          <target state="translated">객체 연결</target>
        </trans-unit>
        <trans-unit id="ba195d654d6092a3e9da8ddd541dd8c15779615b" translate="yes" xml:space="preserve">
          <source>Object is remote</source>
          <target state="translated">객체가 원격</target>
        </trans-unit>
        <trans-unit id="59b64b94151b6c193b42629c8e0da5f27de1d3fe" translate="yes" xml:space="preserve">
          <source>Object serialization used by &lt;a href=&quot;#module-shelve&quot;&gt;&lt;code&gt;shelve&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-shelve&quot;&gt; &lt;code&gt;shelve&lt;/code&gt; 가&lt;/a&gt; 사용하는 객체 직렬화 .</target>
        </trans-unit>
        <trans-unit id="94492e219ece2be2aab3f164513645039f660bea" translate="yes" xml:space="preserve">
          <source>Object that is equal to anything. Used to test mixed type comparison.</source>
          <target state="translated">어떤 것과 동등한 객체. 혼합 유형 비교를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f503d8f51f7ba310bf7f45e5162a8633bb6e9f0e" translate="yes" xml:space="preserve">
          <source>Object that is greater than anything (except itself). Used to test mixed type comparison.</source>
          <target state="translated">무엇보다 큰 객체 (자체 제외). 혼합 유형 비교를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0cd36b2dc674025e7e6b6873e4676f84304e54a" translate="yes" xml:space="preserve">
          <source>Object that is less than anything (except itself). Used to test mixed type comparison.</source>
          <target state="translated">무엇보다 작은 객체 (자체 제외). 혼합 유형 비교를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="723f3e7fedc35db64092babeaa58ef63cd3624a6" translate="yes" xml:space="preserve">
          <source>Object that when printed, prints the message &amp;ldquo;Type license() to see the full license text&amp;rdquo;, and when called, displays the full license text in a pager-like fashion (one screen at a time).</source>
          <target state="translated">인쇄 할 때&amp;ldquo;전체 라이센스 텍스트를보기 위해 license type을 입력하십시오&amp;rdquo;라는 메시지를 인쇄하고 호출 될 때 전체 라이센스 텍스트를 호출기와 같은 방식으로 표시합니다 (한 번에 한 화면 씩).</target>
        </trans-unit>
        <trans-unit id="6f46d65c8d10b203bddd0e21c7c84db68306a018" translate="yes" xml:space="preserve">
          <source>Object which represents an entire document.</source>
          <target state="translated">전체 문서를 나타내는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7d97a7f0b05a173dd169071a9c7f47af3300ccc5" translate="yes" xml:space="preserve">
          <source>Object whose attributes correspond roughly to the members of the &lt;code&gt;stat&lt;/code&gt; structure. It is used for the result of &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.fstat&quot;&gt;&lt;code&gt;os.fstat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.lstat&quot;&gt;&lt;code&gt;os.lstat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 &lt;code&gt;stat&lt;/code&gt; 구조 의 멤버와 대략 일치하는 객체입니다 . &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.fstat&quot;&gt; &lt;code&gt;os.fstat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.lstat&quot;&gt; &lt;code&gt;os.lstat()&lt;/code&gt; &lt;/a&gt; 의 결과에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="92ddc22b65e8b5b40d370242a415cbe437e1fb5b" translate="yes" xml:space="preserve">
          <source>Object yielded by &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; to expose the file path and other file attributes of a directory entry.</source>
          <target state="translated">디렉토리 항목의 파일 경로 및 기타 파일 속성을 표시하기 위해 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="b505394857cf752f097451f34e2de726a3519d1d" translate="yes" xml:space="preserve">
          <source>Object-oriented interface to dates and times with similar functionality to the &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 모듈 과 유사한 기능을 가진 날짜 및 시간에 대한 객체 지향 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="0de0194dce47b55f786136e7ca5d1d1e84495b24" translate="yes" xml:space="preserve">
          <source>Objects implementing the &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; interface have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 객체 에는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d203b8faa0a194771d07d8e7b897dfd529a11dc3" translate="yes" xml:space="preserve">
          <source>Objects in the DOM</source>
          <target state="translated">DOM의 객체</target>
        </trans-unit>
        <trans-unit id="1d2961eba3bc82e095ef8f99f120f340ffafacae" translate="yes" xml:space="preserve">
          <source>Objects instantiated from &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt; can only have their value set to bytes or integers.</source>
          <target state="translated">&lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; 에서 인스턴스화 된 객체 는 값을 바이트 또는 정수로만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942293f86c9c554a7407c6e383f6fb514f2d3c50" translate="yes" xml:space="preserve">
          <source>Objects of different types, except different numeric types, never compare equal. The &lt;code&gt;==&lt;/code&gt; operator is always defined but for some object types (for example, class objects) is equivalent to &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt;&lt;code&gt;is&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators are only defined where they make sense; for example, they raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception when one of the arguments is a complex number.</source>
          <target state="translated">다른 숫자 유형을 제외한 다른 유형의 객체는 결코 동일하지 않습니다. &lt;code&gt;==&lt;/code&gt; 의 조작은 항상 정의되어 있지만, 일부 개체 유형 (예를 들면, 클래스 오브젝트)와 동등 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt; &lt;code&gt;is&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 가 의미가 어디에 사업자 만 정의; 예를 들어, 인수 중 하나가 복소수 인 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="844eb425fd6afc3bee0d0b6028be8ef6772711e2" translate="yes" xml:space="preserve">
          <source>Objects of the &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; type are always naive.</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 유형의 개체 는 항상 순진합니다.</target>
        </trans-unit>
        <trans-unit id="bd7f72ab2249f983753a1d861db7908c8fcec575" translate="yes" xml:space="preserve">
          <source>Objects of these types are hashable, meaning that they can be used as dictionary keys.</source>
          <target state="translated">이러한 유형의 객체는 해시 가능하므로 사전 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938221cef57f2475840b0471c4e70257edb6b048" translate="yes" xml:space="preserve">
          <source>Objects of these types are immutable.</source>
          <target state="translated">이러한 유형의 객체는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="41b191879a423d793dfaba6e910a7801ce025caa" translate="yes" xml:space="preserve">
          <source>Objects of these types support efficient pickling via the &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이러한 유형의 객체는 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈을 통한 효율적인 산세를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="5f93dcf2a529620bad38d87c650a52874fefbf22" translate="yes" xml:space="preserve">
          <source>Objects of this class cannot be used to represent timezone information in the locations where different offsets are used in different days of the year or where historical changes have been made to civil time.</source>
          <target state="translated">이 클래스의 객체를 사용하여 연중 다른 날짜에 다른 오프셋이 사용되거나 현지 시간이 역사적으로 변경된 위치의 시간대 정보를 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="214c213394b160163b319993661476db974e76ee" translate="yes" xml:space="preserve">
          <source>Objects returned by &lt;a href=&quot;#aifc.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; when a file is opened for reading have the following methods:</source>
          <target state="translated">읽기 위해 파일을 열 때 &lt;a href=&quot;#aifc.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 객체 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="657eae2282d6e60f1300aee5c59552435401221e" translate="yes" xml:space="preserve">
          <source>Objects returned by &lt;a href=&quot;#aifc.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; when a file is opened for writing have all the above methods, except for &lt;code&gt;readframes()&lt;/code&gt; and &lt;code&gt;setpos()&lt;/code&gt;. In addition the following methods exist. The &lt;code&gt;get*()&lt;/code&gt; methods can only be called after the corresponding &lt;code&gt;set*()&lt;/code&gt; methods have been called. Before the first &lt;code&gt;writeframes()&lt;/code&gt; or &lt;code&gt;writeframesraw()&lt;/code&gt;, all parameters except for the number of frames must be filled in.</source>
          <target state="translated">파일을 쓰기 위해 열 때 &lt;a href=&quot;#aifc.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 반환 한 객체 에는 &lt;code&gt;readframes()&lt;/code&gt; 및 &lt;code&gt;setpos()&lt;/code&gt; 제외한 위의 모든 메서드가 있습니다. 또한 다음과 같은 방법이 있습니다. &lt;code&gt;get*()&lt;/code&gt; 메소드 만이 대응 한 후 호출 할 수 있습니다 &lt;code&gt;set*()&lt;/code&gt; 방법이 호출되고있다. 첫 번째 &lt;code&gt;writeframes()&lt;/code&gt; 또는 &lt;code&gt;writeframesraw()&lt;/code&gt; 전에 프레임 수를 제외한 모든 매개 변수를 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="89396d26028965648a3435a5a9a2e0de20223e3b" translate="yes" xml:space="preserve">
          <source>Objects such as modules and instances have an updateable &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute; however, other objects may have write restrictions on their &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attributes (for example, classes use a &lt;a href=&quot;types#types.MappingProxyType&quot;&gt;&lt;code&gt;types.MappingProxyType&lt;/code&gt;&lt;/a&gt; to prevent direct dictionary updates).</source>
          <target state="translated">모듈 및 인스턴스와 같은 객체에는 업데이트 가능한 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 속성이 있습니다. 그러나 다른 객체의 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 특성 에 대한 쓰기 제한이있을 수 있습니다 (예 : 클래스는 직접 사전 업데이트를 방지하기 위해 &lt;a href=&quot;types#types.MappingProxyType&quot;&gt; &lt;code&gt;types.MappingProxyType&lt;/code&gt; &lt;/a&gt; 을 사용함 ).</target>
        </trans-unit>
        <trans-unit id="24ddcc97acfc6e06b7be05736ede2846c52ff438" translate="yes" xml:space="preserve">
          <source>Objects that when printed or called, print the text of copyright or credits, respectively.</source>
          <target state="translated">인쇄 또는 호출 될 때 각각 저작권 또는 크레디트의 텍스트를 인쇄하는 객체.</target>
        </trans-unit>
        <trans-unit id="6aee9caab0ea803614d4bdec33d7d17a13eeeb34" translate="yes" xml:space="preserve">
          <source>Objects that when printed, print a message like &amp;ldquo;Use quit() or Ctrl-D (i.e. EOF) to exit&amp;rdquo;, and when called, raise &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; with the specified exit code.</source>
          <target state="translated">인쇄시 &quot;quit () 또는 Ctrl-D (예 : EOF)를 사용하여 종료&quot;와 같은 메시지를 인쇄하고 호출되면 지정된 종료 코드를 사용하여 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 를 올리 십시오.</target>
        </trans-unit>
        <trans-unit id="317ff8c9afd265b37a084319109dd329ff7e9ee9" translate="yes" xml:space="preserve">
          <source>Objects to be configured are described by dictionaries which detail their configuration. In some places, the logging system will be able to infer from the context how an object is to be instantiated, but when a user-defined object is to be instantiated, the system will not know how to do this. In order to provide complete flexibility for user-defined object instantiation, the user needs to provide a &amp;lsquo;factory&amp;rsquo; - a callable which is called with a configuration dictionary and which returns the instantiated object. This is signalled by an absolute import path to the factory being made available under the special key &lt;code&gt;'()'&lt;/code&gt;. Here&amp;rsquo;s a concrete example:</source>
          <target state="translated">구성 할 개체는 해당 구성을 자세히 설명하는 사전으로 설명됩니다. 경우에 따라 로깅 시스템은 컨텍스트에서 오브젝트의 인스턴스화 방법을 유추 할 수 있지만 사용자 정의 오브젝트를 인스턴스화 할 때 시스템은이를 수행하는 방법을 알 수 없습니다. 사용자 정의 객체 인스턴스화에 대한 완전한 유연성을 제공하기 위해, 사용자는 구성 팩토리와 함께 호출되고 인스턴스화 된 객체를 반환하는 호출 가능한 '공장'을 제공해야합니다. 이것은 특수 키 &lt;code&gt;'()'&lt;/code&gt; 하에서 사용 가능한 팩토리로의 절대 가져 오기 경로로 표시됩니다 . 구체적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c09d2d2576e2197a44808fdb59140b84b2d6ab6c" translate="yes" xml:space="preserve">
          <source>Objects with this interface are used to receive error and warning information from the &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt;. If you create an object that implements this interface, then register the object with your &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt;, the parser will call the methods in your object to report all warnings and errors. There are three levels of errors available: warnings, (possibly) recoverable errors, and unrecoverable errors. All methods take a &lt;code&gt;SAXParseException&lt;/code&gt; as the only parameter. Errors and warnings may be converted to an exception by raising the passed-in exception object.</source>
          <target state="translated">이 인터페이스를 가진 객체는 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt; 로부터 오류 및 경고 정보를받는 데 사용됩니다 . 이 인터페이스를 구현하는 객체를 만든 다음 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; 에&lt;/a&gt; 객체를 등록 하면 파서는 객체의 메서드를 호출하여 모든 경고와 오류를보고합니다. 사용 가능한 오류 레벨에는 경고, 복구 가능 오류 및 복구 불가능 오류의 세 가지가 있습니다. 모든 메소드는 &lt;code&gt;SAXParseException&lt;/code&gt; 을 유일한 매개 변수로 사용합니다. 전달 된 예외 개체를 발생시켜 오류 및 경고를 예외로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ffd090521623011161357dcee2bcb6fbdee8700" translate="yes" xml:space="preserve">
          <source>Obsolete type &amp;ndash; it is identical to &lt;code&gt;'d'&lt;/code&gt;.</source>
          <target state="translated">더 이상 사용되지 않는 유형 &amp;ndash; &lt;code&gt;'d'&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b63bbfd86cfd7432e9f0106c88858984af190c93" translate="yes" xml:space="preserve">
          <source>Obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt;. Uses &lt;em&gt;Set-Cookie&lt;/em&gt; with version=1.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2965에서&lt;/strong&gt;&lt;/a&gt; 사용되지 않습니다 . 버전이 1 인 &lt;em&gt;Set-Cookie&lt;/em&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3f55ca62e4ccae40aeb50a0b093437b18720a007" translate="yes" xml:space="preserve">
          <source>Obtaining the Event Loop</source>
          <target state="translated">이벤트 루프 얻기</target>
        </trans-unit>
        <trans-unit id="4f99bb290b9222ef321b66eb0aabb138fcf03891" translate="yes" xml:space="preserve">
          <source>Occasionally, it may be useful to disable the addition of this help option. This can be achieved by passing &lt;code&gt;False&lt;/code&gt; as the &lt;code&gt;add_help=&lt;/code&gt; argument to &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경우에 따라이 도움말 옵션 추가를 비활성화하는 것이 유용 할 수 있습니다. 이는 전달에 의해 달성 될 수 &lt;code&gt;False&lt;/code&gt; 은 AS &lt;code&gt;add_help=&lt;/code&gt; 에 인수 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="126a6d3a842a574897ac64e80b2a2f96ded4709a" translate="yes" xml:space="preserve">
          <source>Occurs when a subnormal result is pushed to zero by rounding. &lt;a href=&quot;#decimal.Inexact&quot;&gt;&lt;code&gt;Inexact&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decimal.Subnormal&quot;&gt;&lt;code&gt;Subnormal&lt;/code&gt;&lt;/a&gt; are also signaled.</source>
          <target state="translated">반올림하여 비정상 결과가 0으로 푸시 될 때 발생합니다. &lt;a href=&quot;#decimal.Inexact&quot;&gt; &lt;code&gt;Inexact&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;#decimal.Subnormal&quot;&gt; &lt;code&gt;Subnormal&lt;/code&gt; &lt;/a&gt; 신호도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1d2ba6a8e415086f99e2740841ad13a25c9e365c" translate="yes" xml:space="preserve">
          <source>Occurs when an operation result is subnormal (the exponent is too small). If not trapped, returns the result unchanged.</source>
          <target state="translated">작업 결과가 비정상 일 때 (지수가 너무 작을 때) 발생합니다. 트랩되지 않은 경우 결과를 변경하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b690fa09f4c5b0f36d26f6bb8267ab0f5b1a04e" translate="yes" xml:space="preserve">
          <source>Octal escapes are included in a limited form. If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference. As for string literals, octal escapes are always at most three digits in length.</source>
          <target state="translated">8 진 탈출은 제한된 형태로 포함됩니다. 첫 번째 숫자가 0이거나 3 개의 8 진수가있는 경우 8 진수 이스케이프로 간주됩니다. 그렇지 않으면 그룹 참조입니다. 문자열 리터럴의 경우 8 진 이스케이프의 길이는 항상 최대 3 자리입니다.</target>
        </trans-unit>
        <trans-unit id="e48a55708577c922dfe1c8727c5015fe59dcd19c" translate="yes" xml:space="preserve">
          <source>Octal format. Outputs the number in base 8.</source>
          <target state="translated">8 진 형식. 기수 8의 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="0c41c8a61bc16d4027683f8db82ba66479208909" translate="yes" xml:space="preserve">
          <source>Of course, as email has been deployed worldwide, it has become internationalized, such that language specific character sets can now be used in email messages. The base standard still requires email messages to be transferred using only 7-bit ASCII characters, so a slew of RFCs have been written describing how to encode email containing non-ASCII characters into &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant format. These RFCs include &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;. The &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package supports these standards in its &lt;a href=&quot;#module-email.header&quot;&gt;&lt;code&gt;email.header&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.charset#module-email.charset&quot;&gt;&lt;code&gt;email.charset&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">물론 전자 메일이 전 세계에 배포되면서 언어 별 문자 집합을 전자 메일 메시지에 사용할 수 있도록 국제화되었습니다. 기본 표준에서는 여전히 7 비트 ASCII 문자 만 사용하여 전자 메일 메시지를 전송해야하므로 비 ASCII 문자가 포함 된 전자 메일을 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 호환 형식 으로 인코딩하는 방법을 설명하는 많은 RFC가 작성되었습니다 . 이러한 RFC에는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231이 포함&lt;/strong&gt;&lt;/a&gt; 됩니다. &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는 이러한 표준을 지원 &lt;a href=&quot;#module-email.header&quot;&gt; &lt;code&gt;email.header&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.charset#module-email.charset&quot;&gt; &lt;code&gt;email.charset&lt;/code&gt; &lt;/a&gt; 모듈을.</target>
        </trans-unit>
        <trans-unit id="2afb4718d7f7d394f419ceafea003a6616573fac" translate="yes" xml:space="preserve">
          <source>Of course, the dictionary printed will include all the options available and their values. This is meant only as an example.</source>
          <target state="translated">물론 인쇄 된 사전에는 사용 가능한 모든 옵션과 해당 값이 포함됩니다. 이것은 단지 예일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="57957486097ed91a113e640adfd8aa89098b3192" translate="yes" xml:space="preserve">
          <source>Of course, tokens will be returned which are not valid for shells, and you&amp;rsquo;ll need to implement your own error checks on the returned tokens.</source>
          <target state="translated">물론, 셸에 유효하지 않은 토큰이 반환되며 반환 된 토큰에 대해 자체 오류 검사를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d96c2d35a34921bbc473cf1f63f5c7f7ce87d37" translate="yes" xml:space="preserve">
          <source>Of course, you still have to use your head! For instance, it makes no sense to use a forking server if the service contains state in memory that can be modified by different requests, since the modifications in the child process would never reach the initial state kept in the parent process and passed to each child. In this case, you can use a threading server, but you will probably have to use locks to protect the integrity of the shared data.</source>
          <target state="translated">물론, 여전히 머리를 사용해야합니다! 예를 들어, 하위 프로세스의 수정이 상위 프로세스에 유지 된 초기 상태에 도달하지 않고 각 하위에 전달되므로 서비스에 다른 요청에 의해 수정 될 수있는 메모리의 상태가 서비스에 포함 된 경우 분기 서버를 사용하는 것은 의미가 없습니다. . 이 경우 스레딩 서버를 사용할 수 있지만 공유 데이터의 무결성을 보호하려면 잠금을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a189e90de7a831a297990fcc13eed8180febeaaf" translate="yes" xml:space="preserve">
          <source>Of the following list, symbols that are not used on the current platform are not defined by the module. The specific list of defined symbols is available as &lt;code&gt;errno.errorcode.keys()&lt;/code&gt;. Symbols available can include:</source>
          <target state="translated">다음 목록 중 현재 플랫폼에서 사용되지 않는 기호는 모듈에 의해 정의되지 않습니다. 정의 된 심볼의 특정 목록은 &lt;code&gt;errno.errorcode.keys()&lt;/code&gt; 로 사용할 수 있습니다 . 사용 가능한 기호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6d3eaaecea9032e886e0354de8e806c271d885c" translate="yes" xml:space="preserve">
          <source>Official BLAKE2 website.</source>
          <target state="translated">공식 BLAKE2 웹 사이트.</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="db094d4468a2312d7105c1d93cf46de84f4525c2" translate="yes" xml:space="preserve">
          <source>Often the private key is stored in the same file as the certificate; in this case, only the &lt;code&gt;certfile&lt;/code&gt; parameter to &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt;&lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt; needs to be passed. If the private key is stored with the certificate, it should come before the first certificate in the certificate chain:</source>
          <target state="translated">개인 키는 종종 인증서와 동일한 파일에 저장됩니다. 이 경우 &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt; &lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 대한 &lt;code&gt;certfile&lt;/code&gt; 매개 변수 만 전달하면됩니다. 개인 키가 인증서와 함께 저장되면 인증서 체인의 첫 번째 인증서 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="fbb3c38f7157933f1410deccc0c0bd46be6786fa" translate="yes" xml:space="preserve">
          <source>Old</source>
          <target state="translated">Old</target>
        </trans-unit>
        <trans-unit id="b921270420b7b08f1568f831c3397e52a38fa523" translate="yes" xml:space="preserve">
          <source>Old cookies are kept unless overwritten by newly loaded ones.</source>
          <target state="translated">새로로드 한 쿠키로 덮어 쓰지 않는 한 오래된 쿠키는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7314a38341e89f90dcb4e508f3c78058527250f6" translate="yes" xml:space="preserve">
          <source>Old getter/setter API for &lt;a href=&quot;#threading.Thread.daemon&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt;; use it directly as a property instead.</source>
          <target state="translated">&lt;a href=&quot;#threading.Thread.daemon&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt; 위한 오래된 getter / setter API ; 대신 속성으로 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7dbcb06ab05ba98c6ef08633aa445b5c4081b42" translate="yes" xml:space="preserve">
          <source>Old getter/setter API for &lt;a href=&quot;#threading.Thread.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;; use it directly as a property instead.</source>
          <target state="translated">&lt;a href=&quot;#threading.Thread.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 대한 오래된 getter / setter API ; 대신 속성으로 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a430408287831c43c01068e431ced99daedf6248" translate="yes" xml:space="preserve">
          <source>Older SQLite versions had issues with sharing connections between threads. That&amp;rsquo;s why the Python module disallows sharing connections and cursors between threads. If you still try to do so, you will get an exception at runtime.</source>
          <target state="translated">이전 SQLite 버전에는 스레드 간 연결 공유에 문제가있었습니다. 그렇기 때문에 파이썬 모듈은 스레드 간 연결 및 커서 공유를 허용하지 않습니다. 여전히 그렇게하려고하면 런타임에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b798a5717d947276e99cddcb457e1602f3cac8b9" translate="yes" xml:space="preserve">
          <source>Older high-level API</source>
          <target state="translated">오래된 고급 API</target>
        </trans-unit>
        <trans-unit id="6b7df62ceb94ab7be4fe94caa4bfa594c93034e1" translate="yes" xml:space="preserve">
          <source>Omitting values</source>
          <target state="translated">값 생략</target>
        </trans-unit>
        <trans-unit id="1bb81bb7fe8c54a984481046ff452e9ec4cda5b2" translate="yes" xml:space="preserve">
          <source>On Android or in the UTF-8 mode (&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;utf8&lt;/code&gt; option), always return &lt;code&gt;'UTF-8'&lt;/code&gt;, the locale and the &lt;em&gt;do_setlocale&lt;/em&gt; argument are ignored.</source>
          <target state="translated">Android 또는 UTF-8 모드 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;utf8&lt;/code&gt; 옵션)에서 항상 &lt;code&gt;'UTF-8'&lt;/code&gt; 을 리턴 하면 로케일 및 &lt;em&gt;do_setlocale&lt;/em&gt; 인수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d4464bd203731f640095d017614727a2ce8882aa" translate="yes" xml:space="preserve">
          <source>On Android, the encoding is &lt;code&gt;'utf-8'&lt;/code&gt;.</source>
          <target state="translated">Android에서 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cdac50d7ab041ede3970502d373d1b546c0fc224" translate="yes" xml:space="preserve">
          <source>On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for datagram protocols, because there is no reliable way to detect send failures caused by writing too many packets.</source>
          <target state="translated">BSD 시스템 (macOS, FreeBSD 등)에서는 데이터 그램 프로토콜에 대해 흐름 제어가 지원되지 않습니다. 패킷이 너무 많이 작성되어 전송 실패를 감지하는 확실한 방법이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5df68af755b4ca9998915a72600b113ea0a954b4" translate="yes" xml:space="preserve">
          <source>On Linux &lt;a href=&quot;os#os.sendfile&quot;&gt;&lt;code&gt;os.sendfile()&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Linux에서는 &lt;a href=&quot;os#os.sendfile&quot;&gt; &lt;code&gt;os.sendfile()&lt;/code&gt; &lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b894a54ac738054398c257505814cbf2c23a93f5" translate="yes" xml:space="preserve">
          <source>On Linux, &lt;code&gt;find_library()&lt;/code&gt; tries to run external programs (&lt;code&gt;/sbin/ldconfig&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;objdump&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;) to find the library file. It returns the filename of the library file.</source>
          <target state="translated">Linux에서 &lt;code&gt;find_library()&lt;/code&gt; 는 외부 프로그램 ( &lt;code&gt;/sbin/ldconfig&lt;/code&gt; , &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;objdump&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; )을 실행하여 라이브러리 파일을 찾습니다. 라이브러리 파일의 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7f5823f8fbd988d636ff83e069f2a210239fdad" translate="yes" xml:space="preserve">
          <source>On Linux, if &lt;em&gt;offset&lt;/em&gt; is given as &lt;code&gt;None&lt;/code&gt;, the bytes are read from the current position of &lt;em&gt;in&lt;/em&gt; and the position of &lt;em&gt;in&lt;/em&gt; is updated.</source>
          <target state="translated">경우 리눅스에서 &lt;em&gt;오프셋이&lt;/em&gt; 로 주어진다 &lt;code&gt;None&lt;/code&gt; , 바이트는 현재의 위치에서 읽기 &lt;em&gt;에서&lt;/em&gt; 와의 위치 &lt;em&gt;에&lt;/em&gt; 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e281758369d3e3022dacf8f57e2fcc73ab4a776b" translate="yes" xml:space="preserve">
          <source>On Linux, if the &lt;code&gt;getrandom()&lt;/code&gt; syscall is available, it is used in blocking mode: block until the system urandom entropy pool is initialized (128 bits of entropy are collected by the kernel). See the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0524&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;PEP 524&lt;/strong&gt;&lt;/a&gt; for the rationale. On Linux, the &lt;a href=&quot;#os.getrandom&quot;&gt;&lt;code&gt;getrandom()&lt;/code&gt;&lt;/a&gt; function can be used to get random bytes in non-blocking mode (using the &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt;&lt;code&gt;GRND_NONBLOCK&lt;/code&gt;&lt;/a&gt; flag) or to poll until the system urandom entropy pool is initialized.</source>
          <target state="translated">Linux에서 &lt;code&gt;getrandom()&lt;/code&gt; syscall을 사용할 수 있으면 차단 모드에서 사용됩니다. 시스템 urandom 엔트로피 풀이 초기화 될 때까지 차단합니다 (128 비트의 엔트로피가 커널에 의해 수집 됨). 이론적 근거 는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0524&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;PEP 524&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 . Linux에서 &lt;a href=&quot;#os.getrandom&quot;&gt; &lt;code&gt;getrandom()&lt;/code&gt; &lt;/a&gt; 함수는 비 차단 모드 ( &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt; &lt;code&gt;GRND_NONBLOCK&lt;/code&gt; &lt;/a&gt; 플래그 사용)에서 임의 바이트를 가져 오거나 시스템 urandom 엔트로피 풀이 초기화 될 때까지 폴링 하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34356f543169215adf877047fe8fe6de6815c500" translate="yes" xml:space="preserve">
          <source>On Linux, it is required to specify the filename &lt;em&gt;including&lt;/em&gt; the extension to load a library, so attribute access can not be used to load libraries. Either the &lt;code&gt;LoadLibrary()&lt;/code&gt; method of the dll loaders should be used, or you should load the library by creating an instance of CDLL by calling the constructor:</source>
          <target state="translated">Linux에서는 라이브러리를로드하기위한 확장자를 &lt;em&gt;포함&lt;/em&gt; 하여 파일 이름을 지정해야 하므로 속성 액세스를 사용하여 라이브러리를로드 할 수 없습니다. dll 로더 의 &lt;code&gt;LoadLibrary()&lt;/code&gt; 메소드를 사용하거나 생성자를 호출하여 CDLL 인스턴스를 작성하여 라이브러리를로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc1364db7c80f222c6aa60a25008da922cb7a7e1" translate="yes" xml:space="preserve">
          <source>On Mac OS X (and perhaps other platforms), executable files may be universal files containing multiple architectures.</source>
          <target state="translated">Mac OS X (및 기타 플랫폼)에서 실행 파일은 여러 아키텍처를 포함하는 범용 파일 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3005d61cb9e9c1da2b366641dda8f652e63e021" translate="yes" xml:space="preserve">
          <source>On Mac OS X and FreeBSD, a value of 0 for &lt;em&gt;count&lt;/em&gt; specifies to send until the end of &lt;em&gt;in&lt;/em&gt; is reached.</source>
          <target state="translated">맥 OS X와 FreeBSD에서 0의 값을 &lt;em&gt;카운트&lt;/em&gt; 지정이 종료 될 때까지 보내 &lt;em&gt;에&lt;/em&gt; 도달한다.</target>
        </trans-unit>
        <trans-unit id="47c284398b02650696dc28bb5b5b1f62ce624525" translate="yes" xml:space="preserve">
          <source>On Mac OS X, &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; behavior differs somewhat from other Unix platforms. If the Python interpreter was built with a deployment target of &lt;code&gt;10.5&lt;/code&gt; or earlier, &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; returns the list of effective group ids associated with the current user process; this list is limited to a system-defined number of entries, typically 16, and may be modified by calls to &lt;a href=&quot;#os.setgroups&quot;&gt;&lt;code&gt;setgroups()&lt;/code&gt;&lt;/a&gt; if suitably privileged. If built with a deployment target greater than &lt;code&gt;10.5&lt;/code&gt;, &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; returns the current group access list for the user associated with the effective user id of the process; the group access list may change over the lifetime of the process, it is not affected by calls to &lt;a href=&quot;#os.setgroups&quot;&gt;&lt;code&gt;setgroups()&lt;/code&gt;&lt;/a&gt;, and its length is not limited to 16. The deployment target value, &lt;code&gt;MACOSX_DEPLOYMENT_TARGET&lt;/code&gt;, can be obtained with &lt;a href=&quot;sysconfig#sysconfig.get_config_var&quot;&gt;&lt;code&gt;sysconfig.get_config_var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mac OS X에서 &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 동작은 다른 Unix 플랫폼과 약간 다릅니다. Python 인터프리터가 &lt;code&gt;10.5&lt;/code&gt; 이하 의 배치 대상으로 빌드 된 경우 &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 는 현재 사용자 프로세스와 연관된 유효 그룹 ID 목록을 리턴합니다. 이 목록은 시스템 정의 항목 수 (일반적으로 16 개 &lt;a href=&quot;#os.setgroups&quot;&gt; &lt;code&gt;setgroups()&lt;/code&gt; &lt;/a&gt; 되며 적절한 권한이있는 경우 setgroups ()를 호출하여 수정할 수 있습니다 . 보다 전개 대상 클로 만든 경우 &lt;code&gt;10.5&lt;/code&gt; , &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 프로세스의 유효 사용자 ID와 연관된 사용자의 현재 그룹 액세스 목록을 반환; 그룹 액세스 목록은 프로세스 수명 동안 변경 될 수 있으며 &lt;a href=&quot;#os.setgroups&quot;&gt; &lt;code&gt;setgroups()&lt;/code&gt; &lt;/a&gt; 호출의 영향을받지 않습니다., 길이는 16으로 제한되지 않습니다. 배치 대상 값 &lt;code&gt;MACOSX_DEPLOYMENT_TARGET&lt;/code&gt; 은 &lt;a href=&quot;sysconfig#sysconfig.get_config_var&quot;&gt; &lt;code&gt;sysconfig.get_config_var()&lt;/code&gt; &lt;/a&gt; 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6be300bd70052f23a866a27939e3f7e700d243e4" translate="yes" xml:space="preserve">
          <source>On Mac OS X, &lt;code&gt;sem_timedwait&lt;/code&gt; is unsupported, so calling &lt;code&gt;acquire()&lt;/code&gt; with a timeout will emulate that function&amp;rsquo;s behavior using a sleeping loop.</source>
          <target state="translated">Mac OS X에서는 &lt;code&gt;sem_timedwait&lt;/code&gt; 가 지원되지 않으므로 시간 초과와 함께 &lt;code&gt;acquire()&lt;/code&gt; 를 호출 하면 슬리핑 루프를 사용하여 해당 함수의 동작을 에뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="02ec16ecfd2b354d814f70d8478dc9a7f0630d5a" translate="yes" xml:space="preserve">
          <source>On Mac OS X, the length of &lt;em&gt;groups&lt;/em&gt; may not exceed the system-defined maximum number of effective group ids, typically 16. See the documentation for &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; for cases where it may not return the same group list set by calling setgroups().</source>
          <target state="translated">Mac OS X에서 &lt;em&gt;그룹&lt;/em&gt; 길이 는 시스템 정의 최대 유효 그룹 ID 수 (일반적으로 16)를 초과 할 수 없습니다. setgroups ()를 호출하여 동일한 그룹 목록 세트를 리턴하지 않을 수있는 경우 &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="d466ddfea82165c6998d2732d0fd966668af8aa8" translate="yes" xml:space="preserve">
          <source>On Mac OS X, this is indistinguishable from &lt;a href=&quot;#multiprocessing.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; because &lt;code&gt;sem_getvalue()&lt;/code&gt; is not implemented on that platform.</source>
          <target state="translated">Mac OS X에서는 &lt;code&gt;sem_getvalue()&lt;/code&gt; 가 해당 플랫폼에서 구현되지 않기 때문에 &lt;a href=&quot;#multiprocessing.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; 와&lt;/a&gt; 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="80a13c286aa16dd15254ee11f8acc93c6967fcac" translate="yes" xml:space="preserve">
          <source>On Mac OS systems, the following attributes may also be available:</source>
          <target state="translated">Mac OS 시스템에서 다음 속성을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d8d30d955ec9defda1be84eda85bc8070a5a55" translate="yes" xml:space="preserve">
          <source>On MacOS X, toplevel windows automatically include a built-in size grip by default. Adding a &lt;code&gt;Sizegrip&lt;/code&gt; is harmless, since the built-in grip will just mask the widget.</source>
          <target state="translated">MacOS X에서 최상위 창에는 기본적으로 내장 크기 그립이 자동으로 포함됩니다. 내장 그립이 위젯을 &lt;code&gt;Sizegrip&lt;/code&gt; 때문에 Sizegrip을 추가하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="047a505ac3a0bde5924ac34403621b5a7b16f3e7" translate="yes" xml:space="preserve">
          <source>On OS X, &lt;code&gt;find_library()&lt;/code&gt; tries several predefined naming schemes and paths to locate the library, and returns a full pathname if successful:</source>
          <target state="translated">OS X에서 &lt;code&gt;find_library()&lt;/code&gt; 는 라이브러리를 찾기 위해 사전 정의 된 여러 이름 지정 체계 및 경로를 시도하고 성공하면 전체 경로 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ee3adeb42a6773c0b5a1d764561ba1bd5f6e5c81" translate="yes" xml:space="preserve">
          <source>On OpenSSL 1.1 and newer the cipher dict contains additional fields:</source>
          <target state="translated">OpenSSL 1.1 이상에서 암호문에는 추가 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e86175144551edf0014fe20868235165756774" translate="yes" xml:space="preserve">
          <source>On POSIX platforms the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; socket option is set in order to immediately reuse previous sockets which were bound on the same &lt;em&gt;address&lt;/em&gt; and remained in TIME_WAIT state.</source>
          <target state="translated">POSIX 플랫폼에서 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 소켓 옵션은 동일한 &lt;em&gt;주소&lt;/em&gt; 에 바인드 되어 TIME_WAIT 상태를 유지 한 이전 소켓을 즉시 재사용하기 위해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="14c00f7063151de1165f655a6bb2db8b60c068aa" translate="yes" xml:space="preserve">
          <source>On POSIX platforms, this means that file owner and group are lost as well as ACLs. On Mac OS, the resource fork and other metadata are not used. This means that resources will be lost and file type and creator codes will not be correct. On Windows, file owners, ACLs and alternate data streams are not copied.</source>
          <target state="translated">POSIX 플랫폼에서 이는 파일 소유자 및 그룹과 ACL이 유실되었음을 의미합니다. Mac OS에서는 리소스 포크 및 기타 메타 데이터가 사용되지 않습니다. 이는 리소스가 손실되고 파일 형식과 작성자 코드가 올바르지 않음을 의미합니다. Windows에서는 파일 소유자, ACL 및 대체 데이터 스트림이 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15ae7630db2b82bcf652d24e44fe7ab4a0226a3d" translate="yes" xml:space="preserve">
          <source>On POSIX systems this method sends &lt;code&gt;SIGKILL&lt;/code&gt; to the child process.</source>
          <target state="translated">POSIX 시스템에서이 방법은 &lt;code&gt;SIGKILL&lt;/code&gt; 을 하위 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="7eefcbd33acff5f55854147162274a89ed80a85f" translate="yes" xml:space="preserve">
          <source>On POSIX systems this method sends &lt;code&gt;signal.SIGTERM&lt;/code&gt; to the child process.</source>
          <target state="translated">POSIX 시스템에서이 방법은 &lt;code&gt;signal.SIGTERM&lt;/code&gt; 을 자식 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="d0ff6ad8e999cc10f48eff5c76d5f2a7188b214a" translate="yes" xml:space="preserve">
          <source>On POSIX systems where Python was built with the standard &lt;code&gt;configure&lt;/code&gt; script, this contains the ABI flags as specified by &lt;a href=&quot;https://www.python.org/dev/peps/pep-3149&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3149&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 &lt;code&gt;configure&lt;/code&gt; 스크립트를 사용하여 Python을 빌드 한 POSIX 시스템 에는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3149&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3149에&lt;/strong&gt;&lt;/a&gt; 지정된 ABI 플래그가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="b236dd13a030ed94e044d584c2fe8291e71001b9" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, this method is an alias for &lt;a href=&quot;#asyncio.SubprocessTransport.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX 시스템에서이 기능은 SIGKILL을 서브 프로세스로 보냅니다. Windows에서이 메소드는 &lt;a href=&quot;#asyncio.SubprocessTransport.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f07a49e833d6a2c04f61073e69f1d34ae8d4879c" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, the Windows API function TerminateProcess() is called to stop the subprocess.</source>
          <target state="translated">POSIX 시스템에서이 메소드는 SIGTERM을 서브 프로세스로 보냅니다. Windows에서 Windows API 함수 TerminateProcess ()가 서브 프로세스를 중지하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="39b54d200ee996c99872333f17e610ed05df0ab4" translate="yes" xml:space="preserve">
          <source>On POSIX with &lt;code&gt;shell=True&lt;/code&gt;, the shell defaults to &lt;code&gt;/bin/sh&lt;/code&gt;. If &lt;em&gt;args&lt;/em&gt; is a string, the string specifies the command to execute through the shell. This means that the string must be formatted exactly as it would be when typed at the shell prompt. This includes, for example, quoting or backslash escaping filenames with spaces in them. If &lt;em&gt;args&lt;/em&gt; is a sequence, the first item specifies the command string, and any additional items will be treated as additional arguments to the shell itself. That is to say, &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; does the equivalent of:</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 인 POSIX 에서 쉘의 기본값은 &lt;code&gt;/bin/sh&lt;/code&gt; 입니다. 경우 &lt;em&gt;인수는&lt;/em&gt; 문자열이 문자열은 쉘을 통해 실행 명령을 지정. 이것은 문자열 프롬프트에서 입력 할 때와 똑같은 형식이어야한다는 것을 의미합니다. 예를 들어 공백이 포함 된 인용 또는 백 슬래시 이스케이프 파일 이름이 포함됩니다. 경우 &lt;em&gt;인수는&lt;/em&gt; 순서는 첫 번째 항목은 명령 문자열을 지정하고, 추가 항목은 쉘 자체에 대한 추가 인수로 처리됩니다. 즉, &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 은 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e0fbb44798e8fa6c268c46e281d4b570ead4545d" translate="yes" xml:space="preserve">
          <source>On POSIX, if &lt;em&gt;args&lt;/em&gt; is a string, the string is interpreted as the name or path of the program to execute. However, this can only be done if not passing arguments to the program.</source>
          <target state="translated">POSIX에서 &lt;em&gt;args&lt;/em&gt; 가 문자열이면 문자열은 실행할 프로그램의 이름 또는 경로로 해석됩니다. 그러나 이는 프로그램에 인수를 전달하지 않는 경우에만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="042d4232a3ed266a5bf3c414e7d49bafb86c8327" translate="yes" xml:space="preserve">
          <source>On Solaris and derivatives, the following attributes may also be available:</source>
          <target state="translated">Solaris 및 파생 상품에서 다음 속성을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="80cc19f9b1626f125dbd406b222352afad1074ce" translate="yes" xml:space="preserve">
          <source>On UNIX &lt;em&gt;child watchers&lt;/em&gt; are used for subprocess finish waiting, see &lt;a href=&quot;asyncio-policy#asyncio-watchers&quot;&gt;Process Watchers&lt;/a&gt; for more info.</source>
          <target state="translated">UNIX에서 &lt;em&gt;하위 감시자&lt;/em&gt; 는 하위 프로세스 완료 대기에 사용됩니다 . 자세한 정보는 &lt;a href=&quot;asyncio-policy#asyncio-watchers&quot;&gt;프로세스 감시자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="061033fe6897a382e694d5ebd2c26f0de8aa24b9" translate="yes" xml:space="preserve">
          <source>On UNIX, &lt;a href=&quot;resource#resource.setrlimit&quot;&gt;&lt;code&gt;resource.setrlimit()&lt;/code&gt;&lt;/a&gt; is used to set &lt;a href=&quot;resource#resource.RLIMIT_CORE&quot;&gt;&lt;code&gt;resource.RLIMIT_CORE&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s soft limit to 0 to prevent coredump file creation.</source>
          <target state="translated">UNIX에서 &lt;a href=&quot;resource#resource.setrlimit&quot;&gt; &lt;code&gt;resource.setrlimit()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;resource#resource.RLIMIT_CORE&quot;&gt; &lt;code&gt;resource.RLIMIT_CORE&lt;/code&gt; &lt;/a&gt; 의 소프트 한계를 0으로 설정하여 코어 덤프 파일 작성을 방지 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5303fb5664f54ac196ff0624621bf3e9b937a218" translate="yes" xml:space="preserve">
          <source>On UNIX, non-inheritable file descriptors are closed in child processes at the execution of a new program, other file descriptors are inherited.</source>
          <target state="translated">UNIX에서 상속 불가능한 파일 디스크립터는 새 프로그램 실행시 하위 프로세스에서 닫히고 다른 파일 디스크립터는 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0b4ce9edeaa46004c1ea89a47277ea82f428e7" translate="yes" xml:space="preserve">
          <source>On Unix and Windows, return the argument with an initial component of &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;~user&lt;/code&gt; replaced by that &lt;em&gt;user&lt;/em&gt;&amp;rsquo;s home directory.</source>
          <target state="translated">Unix 및 Windows에서의 초기 구성 요소와 인수를 반환 &lt;code&gt;~&lt;/code&gt; 나 &lt;code&gt;~user&lt;/code&gt; 그 대신 &lt;em&gt;사용자&lt;/em&gt; 의 홈 디렉토리.</target>
        </trans-unit>
        <trans-unit id="b4612ea5389981457aec60b2589e2c3358b80472" translate="yes" xml:space="preserve">
          <source>On Unix using the &lt;em&gt;fork&lt;/em&gt; start method, a child process can make use of a shared resource created in a parent process using a global resource. However, it is better to pass the object as an argument to the constructor for the child process.</source>
          <target state="translated">&lt;em&gt;fork&lt;/em&gt; start 메소드를 사용하는 Unix 에서 하위 프로세스는 글로벌 자원을 사용하여 상위 프로세스에서 작성된 공유 자원을 사용할 수 있습니다. 그러나 자식 프로세스의 생성자에 인수로 객체를 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b0ccbae6c96cdea294fa24abe9f6be651948a8f9" translate="yes" xml:space="preserve">
          <source>On Unix using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start methods will also start a &lt;em&gt;resource tracker&lt;/em&gt; process which tracks the unlinked named system resources (such as named semaphores or &lt;a href=&quot;multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory&quot;&gt;&lt;code&gt;SharedMemory&lt;/code&gt;&lt;/a&gt; objects) created by processes of the program. When all processes have exited the resource tracker unlinks any remaining tracked object. Usually there should be none, but if a process was killed by a signal there may be some &amp;ldquo;leaked&amp;rdquo; resources. (Neither leaked semaphores nor shared memory segments will be automatically unlinked until the next reboot. This is problematic for both objects because the system allows only a limited number of named semaphores, and shared memory segments occupy some space in the main memory.)</source>
          <target state="translated">&lt;em&gt;스폰&lt;/em&gt; 또는 &lt;em&gt;forkserver&lt;/em&gt; start 메소드를 사용하는 Unix 에서는 프로그램 프로세스에 의해 작성된 링크되지 않은 명명 된 시스템 자원 (예 : 명명 된 세마포어 또는 &lt;a href=&quot;multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory&quot;&gt; &lt;code&gt;SharedMemory&lt;/code&gt; &lt;/a&gt; 객체)을 &lt;em&gt;추적&lt;/em&gt; 하는 &lt;em&gt;자원 추적기&lt;/em&gt; 프로세스 도 시작합니다 . 모든 프로세스가 종료되면 리소스 추적기는 나머지 추적 된 개체를 연결 해제합니다. 일반적으로 아무것도 없어야하지만 신호에 의해 프로세스가 종료 된 경우 &quot;누설 된&quot;리소스가있을 수 있습니다. (누적 된 세마포어 나 공유 메모리 세그먼트는 다음에 다시 부팅 할 때까지 자동으로 연결 해제되지 않습니다. 시스템은 제한된 수의 명명 된 세마포어 만 허용하고 공유 메모리 세그먼트는 기본 메모리의 일부 공간을 차지하므로 두 오브젝트 모두에 문제가됩니다.)</target>
        </trans-unit>
        <trans-unit id="4fd6975fe19e134e6847e77c53014ea295e229e5" translate="yes" xml:space="preserve">
          <source>On Unix when a process finishes but has not been joined it becomes a zombie. There should never be very many because each time a new process starts (or &lt;a href=&quot;#multiprocessing.active_children&quot;&gt;&lt;code&gt;active_children()&lt;/code&gt;&lt;/a&gt; is called) all completed processes which have not yet been joined will be joined. Also calling a finished process&amp;rsquo;s &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt;&lt;code&gt;Process.is_alive&lt;/code&gt;&lt;/a&gt; will join the process. Even so it is probably good practice to explicitly join all the processes that you start.</source>
          <target state="translated">프로세스가 완료되었지만 결합되지 않은 Unix에서는 좀비가됩니다. 새 프로세스가 시작될 때마다 (또는 &lt;a href=&quot;#multiprocessing.active_children&quot;&gt; &lt;code&gt;active_children()&lt;/code&gt; &lt;/a&gt; 이 호출 될 때마다 아직 결합되지 않은 완료된 모든 프로세스가 결합 되므로 매우 많지 않아야 합니다 . 또한 완료된 프로세스의 &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt; &lt;code&gt;Process.is_alive&lt;/code&gt; 를&lt;/a&gt; 호출하면 프로세스에 참여합니다. 그럼에도 불구하고 시작하는 모든 프로세스를 명시 적으로 참여시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eac03dafabd5b9228353f47e1be8ab58e5322fe4" translate="yes" xml:space="preserve">
          <source>On Unix, an initial &lt;code&gt;~&lt;/code&gt; is replaced by the environment variable &lt;code id=&quot;index-3&quot;&gt;HOME&lt;/code&gt; if it is set; otherwise the current user&amp;rsquo;s home directory is looked up in the password directory through the built-in module &lt;a href=&quot;pwd#module-pwd&quot;&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/a&gt;. An initial &lt;code&gt;~user&lt;/code&gt; is looked up directly in the password directory.</source>
          <target state="translated">Unix에서는 초기 &lt;code&gt;~&lt;/code&gt; 가 설정되면 환경 변수 &lt;code id=&quot;index-3&quot;&gt;HOME&lt;/code&gt; 으로 대체됩니다 . 그렇지 않으면 현재 사용자의 홈 디렉토리가 내장 모듈 &lt;a href=&quot;pwd#module-pwd&quot;&gt; &lt;code&gt;pwd&lt;/code&gt; 를&lt;/a&gt; 통해 비밀번호 디렉토리에서 검색 됩니다. 초기 &lt;code&gt;~user&lt;/code&gt; 는 비밀번호 디렉토리에서 직접 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="90a3c08a07528042488b78006ddb2bd1f632d904" translate="yes" xml:space="preserve">
          <source>On Unix, command line arguments are passed by bytes from OS. Python decodes them with filesystem encoding and &amp;ldquo;surrogateescape&amp;rdquo; error handler. When you need original bytes, you can get it by &lt;code&gt;[os.fsencode(arg) for arg in sys.argv]&lt;/code&gt;.</source>
          <target state="translated">Unix에서 명령 행 인수는 OS에서 바이트 단위로 전달됩니다. 파이썬은 파일 시스템 인코딩과&amp;ldquo;surrogateescape&amp;rdquo;에러 핸들러로 그것들을 해독합니다. 원래 바이트가 필요할 때 &lt;code&gt;[os.fsencode(arg) for arg in sys.argv]&lt;/code&gt; 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93002bc4f16ed4f7287d3b4688f861b295aba774" translate="yes" xml:space="preserve">
          <source>On Unix, if &lt;em&gt;src&lt;/em&gt; is a file and &lt;em&gt;dst&lt;/em&gt; is a directory or vice-versa, an &lt;a href=&quot;exceptions#IsADirectoryError&quot;&gt;&lt;code&gt;IsADirectoryError&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;exceptions#NotADirectoryError&quot;&gt;&lt;code&gt;NotADirectoryError&lt;/code&gt;&lt;/a&gt; will be raised respectively. If both are directories and &lt;em&gt;dst&lt;/em&gt; is empty, &lt;em&gt;dst&lt;/em&gt; will be silently replaced. If &lt;em&gt;dst&lt;/em&gt; is a non-empty directory, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised. If both are files, &lt;em&gt;dst&lt;/em&gt; it will be replaced silently if the user has permission. The operation may fail on some Unix flavors if &lt;em&gt;src&lt;/em&gt; and &lt;em&gt;dst&lt;/em&gt; are on different filesystems. If successful, the renaming will be an atomic operation (this is a POSIX requirement).</source>
          <target state="translated">Unix에서 &lt;em&gt;src&lt;/em&gt; 가 파일이고 &lt;em&gt;dst&lt;/em&gt; 가 디렉토리이거나 그 반대의 경우 &lt;a href=&quot;exceptions#IsADirectoryError&quot;&gt; &lt;code&gt;IsADirectoryError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#NotADirectoryError&quot;&gt; &lt;code&gt;NotADirectoryError&lt;/code&gt; &lt;/a&gt; 가 각각 발생합니다. 둘 다 디렉토리이고 &lt;em&gt;dst&lt;/em&gt; 가 비어 있으면 &lt;em&gt;dst&lt;/em&gt; 가 자동으로 바뀝니다. 경우 &lt;em&gt;DST가&lt;/em&gt; 비어 있지 않은 디렉토리, &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 둘 다 파일이면 &lt;em&gt;dst&lt;/em&gt; 사용자에게 권한이 있으면 자동으로 바뀝니다. &lt;em&gt;src&lt;/em&gt; 와 &lt;em&gt;dst&lt;/em&gt; 가 다른 파일 시스템에있는 경우 일부 Unix 플레이버에서 작업이 실패 할 수 있습니다 . 성공하면 이름 바꾸기가 원 자성 작업이됩니다 (POSIX 요구 사항).</target>
        </trans-unit>
        <trans-unit id="8780f206d9a466abf25b51a1356f99b2ac3e12d8" translate="yes" xml:space="preserve">
          <source>On Unix, keys and values are decoded with &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler. Use &lt;a href=&quot;#os.getenvb&quot;&gt;&lt;code&gt;os.getenvb()&lt;/code&gt;&lt;/a&gt; if you would like to use a different encoding.</source>
          <target state="translated">Unix에서 키와 값은 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기 로 디코딩됩니다 . 다른 인코딩을 사용 하려면 &lt;a href=&quot;#os.getenvb&quot;&gt; &lt;code&gt;os.getenvb()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2736be53c72c433fb105b8ad845ba0292116edf7" translate="yes" xml:space="preserve">
          <source>On Unix, keys and values use &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler. Use &lt;a href=&quot;#os.environb&quot;&gt;&lt;code&gt;environb&lt;/code&gt;&lt;/a&gt; if you would like to use a different encoding.</source>
          <target state="translated">Unix에서 키와 값은 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기를 사용합니다. 다른 인코딩을 사용 하려면 &lt;a href=&quot;#os.environb&quot;&gt; &lt;code&gt;environb&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0c4f12b4b23fde3793d78231c974ebbe635b6cb" translate="yes" xml:space="preserve">
          <source>On Unix, the &lt;code&gt;myapp.pyz&lt;/code&gt; file is executable as it stands. You can rename the file to remove the &lt;code&gt;.pyz&lt;/code&gt; extension if you prefer a &amp;ldquo;plain&amp;rdquo; command name. On Windows, the &lt;code&gt;myapp.pyz[w]&lt;/code&gt; file is executable by virtue of the fact that the Python interpreter registers the &lt;code&gt;.pyz&lt;/code&gt; and &lt;code&gt;.pyzw&lt;/code&gt; file extensions when installed.</source>
          <target state="translated">Unix에서 &lt;code&gt;myapp.pyz&lt;/code&gt; 파일은 그대로 실행 가능합니다. &quot;일반&quot;명령 이름을 선호하는 경우 파일 이름을 변경하여 &lt;code&gt;.pyz&lt;/code&gt; 확장자 를 제거 할 수 있습니다 . Windows에서 &lt;code&gt;myapp.pyz[w]&lt;/code&gt; 파일은 Python 인터프리터 가 설치 될 때 &lt;code&gt;.pyz&lt;/code&gt; 및 &lt;code&gt;.pyzw&lt;/code&gt; 파일 확장자를 등록한다는 사실 때문에 실행 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f756c834d5e154ecd1fc2f824c744c6fb65726" translate="yes" xml:space="preserve">
          <source>On Unix, the encoding is the locale encoding.</source>
          <target state="translated">Unix에서 인코딩은 로캘 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="4130f28e99fb9d275797c90efd13d5dc34107bb6" translate="yes" xml:space="preserve">
          <source>On Unix, the return value is the exit status of the process encoded in the format specified for &lt;a href=&quot;#os.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;. Note that POSIX does not specify the meaning of the return value of the C &lt;code&gt;system()&lt;/code&gt; function, so the return value of the Python function is system-dependent.</source>
          <target state="translated">Unix에서 리턴 값은 &lt;a href=&quot;#os.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 지정된 형식으로 인코딩 된 프로세스의 종료 상태입니다 . POSIX는 C &lt;code&gt;system()&lt;/code&gt; 함수 의 반환 값의 의미를 지정하지 않으므로 Python 함수의 반환 값은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="db73826f114b93339271a1e0fe842703c96cf902" translate="yes" xml:space="preserve">
          <source>On Unix, this method always requires a system call. On Windows, it only requires a system call if &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; and the entry is a reparse point (for example, a symbolic link or directory junction).</source>
          <target state="translated">Unix에서이 메소드는 항상 시스템 호출이 필요합니다. Windows에서는 &lt;em&gt;follow_symlinks&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 이고 항목이 재분석 지점 (예 : 기호 링크 또는 디렉토리 접합) 인 경우에만 시스템 호출이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="150170a27442f2fab1bfdced209dec9ff8347086" translate="yes" xml:space="preserve">
          <source>On Unix-based systems, &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; uses the system&amp;rsquo;s &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html&quot;&gt;opendir()&lt;/a&gt; and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html&quot;&gt;readdir()&lt;/a&gt; functions. On Windows, it uses the Win32 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx&quot;&gt;FindFirstFileW&lt;/a&gt; and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx&quot;&gt;FindNextFileW&lt;/a&gt; functions.</source>
          <target state="translated">Unix 기반 시스템에서 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 은 시스템의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html&quot;&gt;opendir ()&lt;/a&gt; 및 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html&quot;&gt;readdir ()&lt;/a&gt; 함수를 사용합니다. Windows에서는 Win32 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx&quot;&gt;FindFirstFileW&lt;/a&gt; 및 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx&quot;&gt;FindNextFileW&lt;/a&gt; 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="063f29033f1f42ed60a4000d40548820821c002e" translate="yes" xml:space="preserve">
          <source>On Unix: Wait for completion of a child process given by process id &lt;em&gt;pid&lt;/em&gt;, and return a tuple containing its process id and exit status indication (encoded as for &lt;a href=&quot;#os.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;). The semantics of the call are affected by the value of the integer &lt;em&gt;options&lt;/em&gt;, which should be &lt;code&gt;0&lt;/code&gt; for normal operation.</source>
          <target state="translated">유닉스에서 : 프로세스 ID &lt;em&gt;pid에&lt;/em&gt; 의해 주어진 자식 프로세스의 완료를 기다렸다가 프로세스 ID와 종료 상태 표시 ( &lt;a href=&quot;#os.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 로 인코딩 됨)를 포함하는 튜플을 반환하십시오 . 호출의 시맨틱은 정수 &lt;em&gt;옵션&lt;/em&gt; 값의 영향을받으며 , 정상 작동의 경우 &lt;code&gt;0&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c6664197221cc90bd320057a225826f63dffde52" translate="yes" xml:space="preserve">
          <source>On VT100s and their software emulations, such as X terminal emulators, there are normally at least four function keys (&lt;code&gt;KEY_F1&lt;/code&gt;, &lt;code&gt;KEY_F2&lt;/code&gt;, &lt;code&gt;KEY_F3&lt;/code&gt;, &lt;code&gt;KEY_F4&lt;/code&gt;) available, and the arrow keys mapped to &lt;code&gt;KEY_UP&lt;/code&gt;, &lt;code&gt;KEY_DOWN&lt;/code&gt;, &lt;code&gt;KEY_LEFT&lt;/code&gt; and &lt;code&gt;KEY_RIGHT&lt;/code&gt; in the obvious way. If your machine has a PC keyboard, it is safe to expect arrow keys and twelve function keys (older PC keyboards may have only ten function keys); also, the following keypad mappings are standard:</source>
          <target state="translated">VT100 및 X 터미널 에뮬레이터와 같은 소프트웨어 에뮬레이션에는 일반적으로 사용 가능한 기능 키가 적어도 4 개 ( &lt;code&gt;KEY_F1&lt;/code&gt; , &lt;code&gt;KEY_F2&lt;/code&gt; , &lt;code&gt;KEY_F3&lt;/code&gt; , &lt;code&gt;KEY_F4&lt;/code&gt; )이며 화살표 키는 &lt;code&gt;KEY_UP&lt;/code&gt; , &lt;code&gt;KEY_DOWN&lt;/code&gt; , &lt;code&gt;KEY_LEFT&lt;/code&gt; 및 &lt;code&gt;KEY_RIGHT&lt;/code&gt; 에 명백한 방식으로 매핑됩니다 . 컴퓨터에 PC 키보드가있는 경우 화살표 키와 12 개의 기능 키를 기대하는 것이 안전합니다 (이전 PC 키보드에는 10 개의 기능 키만있을 수 있음). 또한 다음과 같은 키패드 매핑이 표준입니다.</target>
        </trans-unit>
        <trans-unit id="3899987121cefa28d5ca881e747a27db892dca88" translate="yes" xml:space="preserve">
          <source>On VxWorks, os.fork, os.execv and os.spawn*p* are not supported.</source>
          <target state="translated">VxWorks에서는 os.fork, os.execv 및 os.spawn * p *가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ee0d33d4266d631edea6f3c6725804aebe33d95" translate="yes" xml:space="preserve">
          <source>On VxWorks, the encoding is &lt;code&gt;'utf-8'&lt;/code&gt;.</source>
          <target state="translated">VxWorks에서 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="203f05598318fc482dff2c5d330d5adcc5f6680a" translate="yes" xml:space="preserve">
          <source>On Windows &lt;a href=&quot;#shutil.copyfile&quot;&gt;&lt;code&gt;shutil.copyfile()&lt;/code&gt;&lt;/a&gt; uses a bigger default buffer size (1 MiB instead of 64 KiB) and a &lt;a href=&quot;stdtypes#memoryview&quot;&gt;&lt;code&gt;memoryview()&lt;/code&gt;&lt;/a&gt;-based variant of &lt;a href=&quot;#shutil.copyfileobj&quot;&gt;&lt;code&gt;shutil.copyfileobj()&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#shutil.copyfile&quot;&gt; &lt;code&gt;shutil.copyfile()&lt;/code&gt; &lt;/a&gt; 은 더 큰 기본 버퍼 크기 (64 KiB 대신 1 MiB)를 사용하고 &lt;a href=&quot;stdtypes#memoryview&quot;&gt; &lt;code&gt;memoryview()&lt;/code&gt; &lt;/a&gt; 기반의 &lt;a href=&quot;#shutil.copyfileobj&quot;&gt; &lt;code&gt;shutil.copyfileobj()&lt;/code&gt; &lt;/a&gt; 변형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d9ce61f86eb4d4ac3c24d7367b804553ab20d7c" translate="yes" xml:space="preserve">
          <source>On Windows CE only the standard calling convention is used, for convenience the &lt;a href=&quot;#ctypes.WinDLL&quot;&gt;&lt;code&gt;WinDLL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ctypes.OleDLL&quot;&gt;&lt;code&gt;OleDLL&lt;/code&gt;&lt;/a&gt; use the standard calling convention on this platform.</source>
          <target state="translated">Windows CE에서는 표준 호출 규칙 만 사용되며, 편의상 &lt;a href=&quot;#ctypes.WinDLL&quot;&gt; &lt;code&gt;WinDLL&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.OleDLL&quot;&gt; &lt;code&gt;OleDLL&lt;/code&gt; &lt;/a&gt; 은이 플랫폼에서 표준 호출 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0867eba7d4a0405fe6540f206891d83e1500d5af" translate="yes" xml:space="preserve">
          <source>On Windows subprocesses are provided by &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; only (default), &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; has no subprocess support.</source>
          <target state="translated">Windows 하위 프로세스는 &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; (기본값) 만 제공하며 &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 은 하위 프로세스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8900df099d23fe4cefc3ed2ff747e1965dae1b2" translate="yes" xml:space="preserve">
          <source>On Windows systems, the following attributes are also available:</source>
          <target state="translated">Windows 시스템에서는 다음 속성도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddfe0eef2e2f38ebe4f48d369d9ce1a6cca527aa" translate="yes" xml:space="preserve">
          <source>On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the child process.</source>
          <target state="translated">Windows에서는 하위 프로세스를 중지하기 위해 Win32 API 함수 &lt;code&gt;TerminateProcess()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="737fe33437bc6a2ea80e837e0281f2030d4293e1" translate="yes" xml:space="preserve">
          <source>On Windows this method is an alias for &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서이 메소드는 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="2a9d37ebffa50750cbeaa7ad01c13a30b0983c37" translate="yes" xml:space="preserve">
          <source>On Windows with &lt;code&gt;shell=True&lt;/code&gt;, the &lt;code id=&quot;index-2&quot;&gt;COMSPEC&lt;/code&gt; environment variable specifies the default shell. The only time you need to specify &lt;code&gt;shell=True&lt;/code&gt; on Windows is when the command you wish to execute is built into the shell (e.g. &lt;strong&gt;dir&lt;/strong&gt; or &lt;strong&gt;copy&lt;/strong&gt;). You do not need &lt;code&gt;shell=True&lt;/code&gt; to run a batch file or console-based executable.</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 인 Windows 에서 &lt;code id=&quot;index-2&quot;&gt;COMSPEC&lt;/code&gt; 환경 변수는 기본 쉘을 지정합니다. Windows에서 &lt;code&gt;shell=True&lt;/code&gt; 를 지정해야하는 유일한 경우는 실행하려는 명령이 쉘에 내장 된 경우입니다 (예 : &lt;strong&gt;dir&lt;/strong&gt; 또는 &lt;strong&gt;copy&lt;/strong&gt; ). 배치 파일 또는 콘솔 기반 실행 파일을 실행하기 위해 &lt;code&gt;shell=True&lt;/code&gt; 가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="644fd389f0194cebaf7154a9a1f88aabdea9f63c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values:</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 win32 구조적 예외 처리를 사용하여 함수가 유효하지 않은 인수 값으로 호출 될 때 일반 보호 결함으로 인한 충돌을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1b11ed5ae47203f10f9e39c4677ebfc9b376f13c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;/a&gt; can only be called with &lt;code&gt;SIGABRT&lt;/code&gt;, &lt;code&gt;SIGFPE&lt;/code&gt;, &lt;code&gt;SIGILL&lt;/code&gt;, &lt;code&gt;SIGINT&lt;/code&gt;, &lt;code&gt;SIGSEGV&lt;/code&gt;, &lt;code&gt;SIGTERM&lt;/code&gt;, or &lt;code&gt;SIGBREAK&lt;/code&gt;. A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised in any other case. Note that not all systems define the same set of signal names; an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; will be raised if a signal name is not defined as &lt;code&gt;SIG*&lt;/code&gt; module level constant.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal()&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;SIGABRT&lt;/code&gt; , &lt;code&gt;SIGFPE&lt;/code&gt; , &lt;code&gt;SIGILL&lt;/code&gt; , &lt;code&gt;SIGINT&lt;/code&gt; , &lt;code&gt;SIGSEGV&lt;/code&gt; , &lt;code&gt;SIGTERM&lt;/code&gt; 또는 &lt;code&gt;SIGBREAK&lt;/code&gt; 만 사용하여 호출 할 수 있습니다 . &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 다른 경우에 발생합니다. 모든 시스템이 동일한 신호 이름 세트를 정의하는 것은 아닙니다. &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 는&lt;/a&gt; 신호 이름으로 정의되어 있지 않은 경우 발생 될 &lt;code&gt;SIG*&lt;/code&gt; 모듈 레벨 상수.</target>
        </trans-unit>
        <trans-unit id="c63488f33cea6ed67ee2b396df2631f882861591" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code id=&quot;index-4&quot;&gt;USERPROFILE&lt;/code&gt; will be used if set, otherwise a combination of &lt;code id=&quot;index-5&quot;&gt;HOMEPATH&lt;/code&gt; and &lt;code id=&quot;index-6&quot;&gt;HOMEDRIVE&lt;/code&gt; will be used. An initial &lt;code&gt;~user&lt;/code&gt; is handled by stripping the last directory component from the created user path derived above.</source>
          <target state="translated">Windows에서는 &lt;code id=&quot;index-4&quot;&gt;USERPROFILE&lt;/code&gt; 이 설정되면 사용되며 그렇지 않으면 &lt;code id=&quot;index-5&quot;&gt;HOMEPATH&lt;/code&gt; 와 &lt;code id=&quot;index-6&quot;&gt;HOMEDRIVE&lt;/code&gt; 의 조합 이 사용됩니다. 초기 &lt;code&gt;~user&lt;/code&gt; 는 위에서 파생 된 작성된 사용자 경로에서 마지막 디렉토리 구성 요소를 제거하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="78373ba9cc1e658aeb2f4b7766b4619af35de1bd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;%name%&lt;/code&gt; expansions are supported in addition to &lt;code&gt;$name&lt;/code&gt; and &lt;code&gt;${name}&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;$name&lt;/code&gt; 및 &lt;code&gt;${name}&lt;/code&gt; 외에도 &lt;code&gt;%name%&lt;/code&gt; 확장이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9eb07682cf8d7554c89ddc6eb7649bd072a9065" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;SIGTERM&lt;/code&gt; is an alias for &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;CTRL_C_EVENT&lt;/code&gt; and &lt;code&gt;CTRL_BREAK_EVENT&lt;/code&gt; can be sent to processes started with a &lt;em&gt;creationflags&lt;/em&gt; parameter which includes &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;code&gt;SIGTERM&lt;/code&gt; 은 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 . &lt;code&gt;CTRL_C_EVENT&lt;/code&gt; 및 &lt;code&gt;CTRL_BREAK_EVENT&lt;/code&gt; 는 &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt; 을 포함 하는 &lt;em&gt;creationflags&lt;/em&gt; 매개 변수로 시작된 프로세스로 전송 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b164d50e56bce46e5b506000cebb450ea480b3ac" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt;, &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; appear if run-time Windows supports.</source>
          <target state="translated">Windows에서 런타임 Windows가 지원하는 경우 &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt; , &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; 이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ae142dbc5c5a17511c3df2343dcf4473e9997091" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;find_library()&lt;/code&gt; searches along the system search path, and returns the full pathname, but since there is no predefined naming scheme a call like &lt;code&gt;find_library(&quot;c&quot;)&lt;/code&gt; will fail and return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;code&gt;find_library()&lt;/code&gt; 는 시스템 검색 경로를 따라 검색하고 전체 경로 이름을 리턴하지만 사전 정의 된 이름 지정 체계가 없으므로 &lt;code&gt;find_library(&quot;c&quot;)&lt;/code&gt; 와 같은 호출 이 실패하고 &lt;code&gt;None&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="5c65155288185d4a2495f910b1a07cb130b3e4d7" translate="yes" xml:space="preserve">
          <source>On Windows, SIGTERM is an alias for &lt;a href=&quot;#subprocess.Popen.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;. CTRL_C_EVENT and CTRL_BREAK_EVENT can be sent to processes started with a &lt;em&gt;creationflags&lt;/em&gt; parameter which includes &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt;.</source>
          <target state="translated">Windows에서 SIGTERM은 &lt;a href=&quot;#subprocess.Popen.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 . CTRL_C_EVENT 및 CTRL_BREAK_EVENT 는 &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt; 을 포함 하는 &lt;em&gt;creationflags&lt;/em&gt; 매개 변수로 시작된 프로세스로 전송 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f3b8e43dba078c733dd83c201ede25e60d579e5" translate="yes" xml:space="preserve">
          <source>On Windows, UTF-8 is used for the console device. Non-character devices such as disk files and pipes use the system locale encoding (i.e. the ANSI codepage). Non-console character devices such as NUL (i.e. where &lt;code&gt;isatty()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;) use the value of the console input and output codepages at startup, respectively for stdin and stdout/stderr. This defaults to the system locale encoding if the process is not initially attached to a console.</source>
          <target state="translated">Windows에서는 콘솔 장치에 UTF-8이 사용됩니다. 디스크 파일 및 파이프와 같은 문자가 아닌 장치는 시스템 로캘 인코딩 (즉, ANSI 코드 페이지)을 사용합니다. NUL과 같은 콘솔 이외의 문자 장치 (예 : &lt;code&gt;isatty()&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 를 반환 하는 경우 ) 는 stdin 및 stdout / stderr에 대해 각각 시작시 콘솔 입력 및 출력 코드 페이지의 값을 사용합니다. 프로세스가 처음 콘솔에 연결되지 않은 경우 시스템 로케일 인코딩이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b01b208cf55586de3c3689ead1e3a6f10f966e03" translate="yes" xml:space="preserve">
          <source>On Windows, a symlink represents either a file or a directory, and does not morph to the target dynamically. If the target is present, the type of the symlink will be created to match. Otherwise, the symlink will be created as a directory if &lt;em&gt;target_is_directory&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; or a file symlink (the default) otherwise. On non-Windows platforms, &lt;em&gt;target_is_directory&lt;/em&gt; is ignored.</source>
          <target state="translated">Windows에서 심볼릭 링크는 파일 또는 디렉토리를 나타내며 대상으로 동적으로 변경되지 않습니다. 대상이 존재하면 심볼릭 링크 유형이 일치하도록 작성됩니다. 그렇지 않으면 &lt;em&gt;target_is_directory&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 이면 심볼릭 링크가 디렉토리로 작성되고 그렇지 않으면 파일 심볼릭 링크 (기본값)가 작성됩니다. Windows 이외의 플랫폼에서는 &lt;em&gt;target_is_directory&lt;/em&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2d9aee7b296b4bb607ee17ff222cfff0af15e2d" translate="yes" xml:space="preserve">
          <source>On Windows, an &lt;em&gt;args&lt;/em&gt; sequence is converted to a string that can be parsed using the following rules (which correspond to the rules used by the MS C runtime):</source>
          <target state="translated">Windows에서 &lt;em&gt;args&lt;/em&gt; 시퀀스는 다음 규칙을 사용하여 구문 분석 할 수있는 문자열로 변환됩니다 (MS C 런타임에서 사용하는 규칙에 해당).</target>
        </trans-unit>
        <trans-unit id="afd63b6fc8ddc6f6804a57f1784ecec5567ec0b8" translate="yes" xml:space="preserve">
          <source>On Windows, attempting to remove a file that is in use causes an exception to be raised; on Unix, the directory entry is removed but the storage allocated to the file is not made available until the original file is no longer in use.</source>
          <target state="translated">Windows에서 사용중인 파일을 제거하려고하면 예외가 발생합니다. Unix에서는 디렉토리 항목이 제거되지만 원본 파일을 더 이상 사용하지 않을 때까지 파일에 할당 된 스토리지를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="324c0800a7c7e804335674d04ffb5659d07d9331" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;em&gt;args&lt;/em&gt; is a sequence, it will be converted to a string in a manner described in &lt;a href=&quot;#converting-argument-sequence&quot;&gt;Converting an argument sequence to a string on Windows&lt;/a&gt;. This is because the underlying &lt;code&gt;CreateProcess()&lt;/code&gt; operates on strings.</source>
          <target state="translated">Windows에서 &lt;em&gt;args&lt;/em&gt; 가 시퀀스 이면 Windows에서 &lt;a href=&quot;#converting-argument-sequence&quot;&gt;인수 시퀀스를 문자열&lt;/a&gt; 로 변환에 설명 된 방식으로 문자열로 변환됩니다 . 기본 &lt;code&gt;CreateProcess()&lt;/code&gt; 가 문자열에서 작동 하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="1ca0b135ebc47d0ae31593b807a8b41656a98f18" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;em&gt;close_fds&lt;/em&gt; is true then no handles will be inherited by the child process unless explicitly passed in the &lt;code&gt;handle_list&lt;/code&gt; element of &lt;a href=&quot;#subprocess.STARTUPINFO.lpAttributeList&quot;&gt;&lt;code&gt;STARTUPINFO.lpAttributeList&lt;/code&gt;&lt;/a&gt;, or by standard handle redirection.</source>
          <target state="translated">Windows에서 &lt;em&gt;close_fds&lt;/em&gt; 가 true이면 &lt;a href=&quot;#subprocess.STARTUPINFO.lpAttributeList&quot;&gt; &lt;code&gt;STARTUPINFO.lpAttributeList&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;handle_list&lt;/code&gt; 요소에 명시 적으로 전달 되거나 표준 핸들 리디렉션에 의해 명시 적으로 전달되지 않는 한 하위 프로세스가 핸들을 상속하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="58cdff6f38e8a2fc1c45a1396be1d9e11b5516bf" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;em&gt;dst&lt;/em&gt; exists a &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is always raised.</source>
          <target state="translated">Windows에서 &lt;em&gt;dst&lt;/em&gt; 가 존재하면 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 가 항상 발생합니다.</target>
        </trans-unit>
        <trans-unit id="151772e095fb4521d0d15c163d22479ec518b344" translate="yes" xml:space="preserve">
          <source>On Windows, invoke the &lt;code&gt;venv&lt;/code&gt; command as follows:</source>
          <target state="translated">Windows에서 다음과 같이 &lt;code&gt;venv&lt;/code&gt; 명령을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f8dcef9d943b988c3e3efd4a7635b6a0452bcf9" translate="yes" xml:space="preserve">
          <source>On Windows, it disables Windows Error Reporting dialogs using &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx&quot;&gt;SetErrorMode&lt;/a&gt;.</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx&quot;&gt;SetErrorMode를&lt;/a&gt; 사용하여 Windows 오류보고 대화 상자를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="80f74d4a0cc9c87f486e6c7e5dfa2600066b3d59" translate="yes" xml:space="preserve">
          <source>On Windows, it will use &lt;code&gt;CryptGenRandom()&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;CryptGenRandom()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5fdaa8220ca2781471b1bc92ae5261ce25d132d2" translate="yes" xml:space="preserve">
          <source>On Windows, non-inheritable handles and file descriptors are closed in child processes, except for standard streams (file descriptors 0, 1 and 2: stdin, stdout and stderr), which are always inherited. Using &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; functions, all inheritable handles and all inheritable file descriptors are inherited. Using the &lt;a href=&quot;subprocess#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module, all file descriptors except standard streams are closed, and inheritable handles are only inherited if the &lt;em&gt;close_fds&lt;/em&gt; parameter is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Windows에서 상속 할 수없는 핸들 및 파일 디스크립터는 항상 상속되는 표준 스트림 (파일 디스크립터 0, 1 및 2 : stdin, stdout 및 stderr)을 제외하고 하위 프로세스에서 닫힙니다. &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수를 사용하면 상속 가능한 모든 핸들과 모든 상속 가능한 파일 설명자가 상속됩니다. &lt;a href=&quot;subprocess#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈을 사용 하면 표준 스트림을 제외한 모든 파일 디스크립터가 닫히고 상속 가능한 핸들은 &lt;em&gt;close_fds&lt;/em&gt; 매개 변수가 &lt;code&gt;False&lt;/code&gt; 인 경우에만 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9dbbca27b5bff454495040c1d717be7efc3364e" translate="yes" xml:space="preserve">
          <source>On Windows, opening a console buffer may return a subclass of &lt;a href=&quot;io#io.RawIOBase&quot;&gt;&lt;code&gt;io.RawIOBase&lt;/code&gt;&lt;/a&gt; other than &lt;a href=&quot;io#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서 콘솔 버퍼를 열면의 서브 클래스 반환 할 수 있습니다 &lt;a href=&quot;io#io.RawIOBase&quot;&gt; &lt;code&gt;io.RawIOBase&lt;/code&gt; &lt;/a&gt; 이외의 &lt;a href=&quot;io#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfe81378442524ce067312e393681abdbd697179" translate="yes" xml:space="preserve">
          <source>On Windows, passing &lt;code&gt;follow_symlinks=False&lt;/code&gt; will disable following all name-surrogate reparse points, which includes symlinks and directory junctions. Other types of reparse points that do not resemble links or that the operating system is unable to follow will be opened directly. When following a chain of multiple links, this may result in the original link being returned instead of the non-link that prevented full traversal. To obtain stat results for the final path in this case, use the &lt;a href=&quot;os.path#os.path.realpath&quot;&gt;&lt;code&gt;os.path.realpath()&lt;/code&gt;&lt;/a&gt; function to resolve the path name as far as possible and call &lt;a href=&quot;#os.lstat&quot;&gt;&lt;code&gt;lstat()&lt;/code&gt;&lt;/a&gt; on the result. This does not apply to dangling symlinks or junction points, which will raise the usual exceptions.</source>
          <target state="translated">Windows에서 &lt;code&gt;follow_symlinks=False&lt;/code&gt; 를 전달 하면 이름 링크 재분석 지점 ( 심볼 링크 및 디렉토리 정션 포함)을 따르는 것이 비활성화됩니다. 링크와 유사하지 않거나 운영 체제에서 추적 할 수없는 다른 유형의 재분석 지점이 직접 열립니다. 여러 링크 체인을 따라갈 때 전체 순회를 방해하는 비 링크 대신 원래 링크가 리턴 될 수 있습니다. 이 경우 최종 경로에 대한 통계 결과를 얻으려면 &lt;a href=&quot;os.path#os.path.realpath&quot;&gt; &lt;code&gt;os.path.realpath()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 가능한 한 경로 이름 을 확인하고 결과에서 &lt;a href=&quot;#os.lstat&quot;&gt; &lt;code&gt;lstat()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오. 매달린 심볼릭 링크 또는 접합점에는 적용되지 않으므로 일반적인 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6205a30ddac655e92925086962c3c5fcb701b9b" translate="yes" xml:space="preserve">
          <source>On Windows, registration of the &lt;code&gt;.pyz&lt;/code&gt; extension is optional, and furthermore, there are certain places that don&amp;rsquo;t recognise registered extensions &amp;ldquo;transparently&amp;rdquo; (the simplest example is that &lt;code&gt;subprocess.run(['myapp'])&lt;/code&gt; won&amp;rsquo;t find your application - you need to explicitly specify the extension).</source>
          <target state="translated">Windows에서 &lt;code&gt;.pyz&lt;/code&gt; 확장명 등록 은 선택 사항이며 등록 된 확장명을 &quot;투명하게&quot;인식하지 못하는 특정 장소가 있습니다 (가장 간단한 예는 &lt;code&gt;subprocess.run(['myapp'])&lt;/code&gt; 가 응용 프로그램-확장명을 명시 적으로 지정해야합니다).</target>
        </trans-unit>
        <trans-unit id="e03e9ab7254bf5d9f3bb216b7f00876ce2b424a1" translate="yes" xml:space="preserve">
          <source>On Windows, some dlls export functions not by name but by ordinal. These functions can be accessed by indexing the dll object with the ordinal number:</source>
          <target state="translated">Windows에서 일부 dll은 이름이 아니라 서수로 함수를 내 보냅니다. 이러한 함수는 서수로 dll 객체를 인덱싱하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf783f34ae011486fa108e118d4bbe59763b0114" translate="yes" xml:space="preserve">
          <source>On Windows, splits a pathname into drive/UNC sharepoint and relative path.</source>
          <target state="translated">Windows에서는 경로 이름을 드라이브 / UNC 공유 지점과 상대 경로로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="68fb8e7f05cf4a3d74f2fa5903e1bafcce342f6e" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;st_ino&lt;/code&gt;, &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_nlink&lt;/code&gt; attributes of the &lt;a href=&quot;#os.stat_result&quot;&gt;&lt;code&gt;stat_result&lt;/code&gt;&lt;/a&gt; are always set to zero. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; to get these attributes.</source>
          <target state="translated">Windows 에서 &lt;a href=&quot;#os.stat_result&quot;&gt; &lt;code&gt;stat_result&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;st_ino&lt;/code&gt; , &lt;code&gt;st_dev&lt;/code&gt; 및 &lt;code&gt;st_nlink&lt;/code&gt; 속성 은 항상 0으로 설정됩니다. 이러한 속성을 얻으려면 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="66761d013cd2216b1b7b3cd2e296f227d596f61c" translate="yes" xml:space="preserve">
          <source>On Windows, the current directory is always prepended to the &lt;em&gt;path&lt;/em&gt; whether or not you use the default or provide your own, which is the behavior the command shell uses when finding executables. Additionally, when finding the &lt;em&gt;cmd&lt;/em&gt; in the &lt;em&gt;path&lt;/em&gt;, the &lt;code&gt;PATHEXT&lt;/code&gt; environment variable is checked. For example, if you call &lt;code&gt;shutil.which(&quot;python&quot;)&lt;/code&gt;, &lt;a href=&quot;#shutil.which&quot;&gt;&lt;code&gt;which()&lt;/code&gt;&lt;/a&gt; will search &lt;code&gt;PATHEXT&lt;/code&gt; to know that it should look for &lt;code&gt;python.exe&lt;/code&gt; within the &lt;em&gt;path&lt;/em&gt; directories. For example, on Windows:</source>
          <target state="translated">Windows에서 현재 디렉토리는 기본값 사용 여부에 관계없이 항상 &lt;em&gt;경로&lt;/em&gt; 앞에 추가됩니다. 이는 실행 파일을 찾을 때 명령 쉘이 사용하는 동작입니다. 발견 할 때 또한 &lt;em&gt;cmd를&lt;/em&gt; 의 &lt;em&gt;경로&lt;/em&gt; 는 &lt;code&gt;PATHEXT&lt;/code&gt; 의 환경 변수를 확인합니다. 예를 들어, 호출하는 경우 &lt;code&gt;shutil.which(&quot;python&quot;)&lt;/code&gt; , &lt;a href=&quot;#shutil.which&quot;&gt; &lt;code&gt;which()&lt;/code&gt; &lt;/a&gt; 를 검색합니다 &lt;code&gt;PATHEXT&lt;/code&gt; 을 그것을 찾아야 알고 &lt;code&gt;python.exe&lt;/code&gt; 를 내에서 &lt;em&gt;경로&lt;/em&gt; 디렉토리. 예를 들어, Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="983f7bfa681a3a9d17b8f9ddb50e0f8c76511264" translate="yes" xml:space="preserve">
          <source>On Windows, the default event loop &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; supports subprocesses, whereas &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; does not.</source>
          <target state="translated">Windows에서 기본 이벤트 루프 &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 는 하위 프로세스를 지원하지만 &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 는 지원 하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
