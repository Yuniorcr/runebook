<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy; 2013&amp;ndash; 현재 Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="503a7ef34e5694be261272081a6d34cc44e0d368" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVAXAngBwKZgCCAxhgJZwB2YAvGKmGAD5gDe2+AXGAOSE8AaMDgCGWeCIAm3AM4YATmUoBzAL6MGzNhzzceAIUHCxE6WEoBXALYAjPPNUBudMGBgA8gGlUxKnLBQAIy0YAAUIqQUlNwk5FQAlLQAfGyaMghkGMQAFmERcZQAdDqJrJqMxCIyBHw83PJ4GBby1PlRhaLicFKFMHgqGNnOjBVVNYb1jc2tkVQdJt2SYADUYIEADMNgqqg7Lm4AcnAYHp5gFpS+Vlb9J1Bw8mD28g8yAISorr6U-lAATCFQuxcHghJ1TKoYrNKIkaCkyq5GOlMjkwiVUoiRpVqrx+JMmi1jF0en0BkNPm4sWNeBMwA0CdRwYsVmtNhTGDtEaogA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVAXAngBwKZgCCAxhgJZwB2YAvGKmGAD5gDe2+AXGAOSE8AaMDgCGWeCIAm3AM4YATmUoBzAL6MGzNhzzceAIUHCxE6WEoBXALYAjPPNUBudMGBgA8gGlUxKnLBQAIy0YAAUIqQUlNwk5FQAlLQAfGyaMghkGMQAFmERcZQAdDqJrJqMxCIyBHw83PJ4GBby1PlRhaLicFKFMHgqGNnOjBVVNYb1jc2tkVQdJt2SYADUYIEADMNgqqg7Lm4AcnAYHp5gFpS+Vlb9J1Bw8mD28g8yAISorr6U-lAATCFQuxcHghJ1TKoYrNKIkaCkyq5GOlMjkwiVUoiRpVqrx+JMmi1jF0en0BkNPm4sWNeBMwA0CdRwYsVmtNhTGDtEaogA&quot;&gt;https://flow.org/try&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="eabf0a1897fda94c2e7ebc351cec25f06658c93f" translate="yes" xml:space="preserve">
          <source>(Example adapted from the &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;&lt;code&gt;react-router&lt;/code&gt; documentation&lt;/a&gt;.)</source>
          <target state="translated">(예는 &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt; &lt;code&gt;react-router&lt;/code&gt; 설명서&lt;/a&gt; 에서 수정되었습니다 .)</target>
        </trans-unit>
        <trans-unit id="42553dcf511140edb9c7fe5b095d179ad3d34209" translate="yes" xml:space="preserve">
          <source>.flowconfig</source>
          <target state="translated">.flowconfig</target>
        </trans-unit>
        <trans-unit id="2a0c7002997e311437a0c70c2313661b929d09ce" translate="yes" xml:space="preserve">
          <source>.flowconfig [declarations]</source>
          <target state="translated">.flowconfig [선언]</target>
        </trans-unit>
        <trans-unit id="d3dd6ba8743bbd7b4542e5b7d98c01e397699462" translate="yes" xml:space="preserve">
          <source>.flowconfig [ignore]</source>
          <target state="translated">.flowconfig [무시]</target>
        </trans-unit>
        <trans-unit id="4cd3ed66f9dc2ea1ae8c5970c30160743de16d59" translate="yes" xml:space="preserve">
          <source>.flowconfig [include]</source>
          <target state="translated">.flowconfig [포함]</target>
        </trans-unit>
        <trans-unit id="3ea7d542265be35c8d390fac59fd3922fa10029f" translate="yes" xml:space="preserve">
          <source>.flowconfig [libs]</source>
          <target state="translated">.flowconfig [libs]</target>
        </trans-unit>
        <trans-unit id="c19cd00744af8fb6b750b055353a165de408ef34" translate="yes" xml:space="preserve">
          <source>.flowconfig [lints]</source>
          <target state="translated">.flowconfig [린트]</target>
        </trans-unit>
        <trans-unit id="2be99164d570a360166709ab948593a53e747ee5" translate="yes" xml:space="preserve">
          <source>.flowconfig [options]</source>
          <target state="translated">.flowconfig [옵션]</target>
        </trans-unit>
        <trans-unit id="84e57eb03e551cd373c767c8c1b1d4e0b233bd32" translate="yes" xml:space="preserve">
          <source>.flowconfig [untyped]</source>
          <target state="translated">.flowconfig [형식화되지 않음]</target>
        </trans-unit>
        <trans-unit id="6e95572239f9d638c63d382400d10b3a21062e5b" translate="yes" xml:space="preserve">
          <source>.flowconfig [version]</source>
          <target state="translated">.flowconfig [버전]</target>
        </trans-unit>
        <trans-unit id="f75dc1d3fd7cae440d82a0aa033937f60c951c83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-check-your-code&quot;&gt;Check your code&lt;/a&gt; for type errors.</source>
          <target state="translated">&lt;a href=&quot;#toc-check-your-code&quot;&gt;코드&lt;/a&gt; 에 유형 오류가 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8bab6e4eae9423dd12abe68c046f07b864298440" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-initialize-your-project&quot;&gt;Initialize your project&lt;/a&gt; with &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-initialize-your-project&quot;&gt;&lt;/a&gt; &lt;code&gt;flow init&lt;/code&gt; 로프로젝트 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d9e05645c42f52a6d394efa517892368a0d28c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Determine&lt;/a&gt; which files Flow will monitor with &lt;code&gt;// @flow&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;&lt;/a&gt; &lt;code&gt;// @flow&lt;/code&gt; Flow가 모니터링 할 파일을 결정 합니다 .</target>
        </trans-unit>
        <trans-unit id="336448ab183f9e44d80f92a10e044c594b5d94a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#toc-write-flow-code&quot;&gt;Write Flow code&lt;/a&gt; for your project.</source>
          <target state="translated">&lt;a href=&quot;#toc-write-flow-code&quot;&gt;&lt;/a&gt;프로젝트의 흐름 코드 를 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="34cd8914987eabdf3008fb9dec6130b2e2a3a08a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is a type that models React nested array data structure for children. &lt;code&gt;ReactNodeWithoutStrings&lt;/code&gt; uses &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; to be an arbitrarily nested array of null, boolean, or React elements.</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 자식에 대한 React 중첩 배열 데이터 구조를 모델링하는 유형입니다. &lt;code&gt;ReactNodeWithoutStrings&lt;/code&gt; 는&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를사용하여 임의로 중첩 된 null, boolean 또는 React 요소의 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="e273fef233f652d4764944c36bc8e7d44f3499a9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; is the type of a React element like &lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;MyComponent/&amp;gt;&lt;/code&gt;. Notably elements are not the same as components!</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;MyComponent/&amp;gt;&lt;/code&gt; 와 같은 React 요소의 유형입니다. 특히 요소는 구성 요소와 동일하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="0f4966d59ad6be431d4d59785410831a89f983b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; is the general type for children, but sometimes you might want to use &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; while excluding some primitives like strings and numbers. &lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;The React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; component&lt;/a&gt; does this, for example.</source>
          <target state="translated">&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 는 하위 유형의 일반적인 유형이지만문자열 및 숫자와 같은 기본 요소를 제외하고&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 를 사용하려는 경우가 있습니다. 예를 들어&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt; React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 컴포넌트&lt;/a&gt; 가이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7cf7f34d3e52f3dec53af2db9a70edf0af8a23b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES modules&lt;/a&gt; have two kinds of exports: A &lt;strong&gt;named&lt;/strong&gt; export and a &lt;strong&gt;default&lt;/strong&gt; export. Flow supports the ability to declare either or both of these kinds of exports within a &lt;code&gt;declare module&lt;/code&gt; body as follows:</source>
          <target state="translated">&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES 모듈&lt;/a&gt; 에는 &lt;strong&gt;이름 지정된&lt;/strong&gt; 내보내기와 &lt;strong&gt;기본&lt;/strong&gt; 내보내기 의 두 가지 내보내기가 있습니다. Flow는 다음과 같이 &lt;code&gt;declare module&lt;/code&gt; 본문 내에서 이러한 종류의 내보내기 중 하나 또는 둘 모두를 선언하는 기능을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="17c120254fa9c516a881da71a463bb260e63bcd7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react-native/docs/tabbarios.html&quot;&gt;React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component&lt;/a&gt; only allows React element children and those elements &lt;em&gt;must&lt;/em&gt; have a component type of &lt;code&gt;&amp;lt;TabBarIOS.Item&amp;gt;&lt;/code&gt;. You are expected to use &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; like:</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react-native/docs/tabbarios.html&quot;&gt;React Native의 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 컴포넌트&lt;/a&gt; 는 React 요소 하위 만 허용하며 해당 요소 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;&amp;lt;TabBarIOS.Item&amp;gt;&lt;/code&gt; 의 컴포넌트 유형을 가져야합니다 . &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 를 다음 과 같이 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf8957393a72df26897385761d8aa21a45d75df4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;The React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; component&lt;/a&gt; will allow any primitive value or any React element as its children. However, &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; does not allow strings or numbers as children! You could use &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; as the children type for &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt;, however &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; includes strings which we don&amp;rsquo;t want for &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt;. So we need to create our own type.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react-native/docs/view.html&quot;&gt;React Native &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 컴포넌트&lt;/a&gt; 는 프리미티브 값이나 React 요소를 자식으로 허용합니다. 그러나 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 에서는 문자열이나 숫자를 자식으로 사용할 수 없습니다! &lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 의 하위 유형으로 사용할 수 있지만 &lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 에 원하지 않는 문자열이 포함됩니다 . 따라서 우리는 우리 자신의 유형을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="ad2498aaf0a179d73775581b93f384fe069a1601" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://frantic.im/using-redux-with-flow&quot;&gt;Using Redux with Flow&lt;/a&gt; - Alex Kotliarskyi</source>
          <target state="translated">&lt;a href=&quot;http://frantic.im/using-redux-with-flow&quot;&gt;흐름과 함께 Redux 사용&lt;/a&gt; -Alex Kotliarskyi</target>
        </trans-unit>
        <trans-unit id="8449c031ca7fc8f782a895f5de5db0cd2312f7ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://redux.js.org&quot;&gt;Redux&lt;/a&gt; has three major parts that should be typed:</source>
          <target state="translated">&lt;a href=&quot;http://redux.js.org&quot;&gt;Redux&lt;/a&gt; 에는 세 가지 주요 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d778c6db4ed26b14b4bcc87859b7232d009a05a6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://redux.js.org/docs/basics/Reducers.html&quot;&gt;Reducers&lt;/a&gt; take the state and actions that we&amp;rsquo;ve typed and pulls them together for one method.</source>
          <target state="translated">&lt;a href=&quot;http://redux.js.org/docs/basics/Reducers.html&quot;&gt;감속기&lt;/a&gt; 는 우리가 입력 한 상태와 동작을 취하여 하나의 방법으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="1e1a716310cc261310c0720a3defabf948f65c71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/autocomplete-flow&quot;&gt;autocomplete-flow&lt;/a&gt; is another purpose-built tool that only does one thing. This package, as the name suggests, will give your flow enabled code autocomplete suggestions and nothing else.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/autocomplete-flow&quot;&gt;자동 완성 흐름&lt;/a&gt; 은 한 가지 작업 만 수행하는 또 다른 특수 목적 도구입니다. 이 패키지는 이름에서 알 수 있듯이 흐름 가능 코드 자동 완성 제안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70aa1aa8e107ff621d1e0476ca9e4b0d1b64169e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/flow-ide&quot;&gt;Flow-IDE&lt;/a&gt; is a smaller package that only provides you with a linter and autocomplete functionality. It, too, currently lacks support for on-the-fly linting.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/flow-ide&quot;&gt;Flow-IDE&lt;/a&gt; 는 소형 및 자동 완성 기능 만 제공하는 작은 패키지입니다. 또한 현재 보푸라기가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ef7fc7d336d051de3c6fc08efe1aa750a6c3fd1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://atom.io/packages/ide-flowtype&quot;&gt;Flow for Atom IDE&lt;/a&gt; is extracted from Nuclide, and works with the &lt;a href=&quot;https://ide.atom.io/&quot;&gt;Atom IDE&lt;/a&gt; UI. It brings the core features you expect in a full-featured IDE into Atom, such as language-aware autocomplete, diagnostics, go-to-definition, type hints, and symbol outlines.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io/packages/ide-flowtype&quot;&gt;Atom IDE 용 Flow&lt;/a&gt; 는 Nuclide에서 추출되며 &lt;a href=&quot;https://ide.atom.io/&quot;&gt;Atom IDE&lt;/a&gt; UI 와 함께 작동합니다 . 또한 언어 인식 자동 완성, 진단, 정의로 이동, 유형 힌트 및 기호 개요와 같이 모든 기능을 갖춘 IDE에서 예상되는 핵심 기능을 Atom에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f392cb41c6c533748c908f516d743440fc3fc957" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt; has several editor integrations for using Flow.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt; 에는 Flow 사용을위한 여러 편집기 통합이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f30e103a4115c80055634733b0aa13e5b344c45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;Watchman&lt;/a&gt; must be installed and the &lt;code&gt;watchman&lt;/code&gt; binary must be in the PATH.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;워치가&lt;/a&gt; 설치되어 있어야하고, &lt;code&gt;watchman&lt;/code&gt; 바이너리는 PATH에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f963c3075e23bb3cf6001267bae91bbb9c401ba6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-nonstrict-import&quot;&gt;&lt;code&gt;nonstrict-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing from a module which is not also &lt;code&gt;@flow strict&lt;/code&gt;. This is very important, because it means that when a file is marked as strict, all of its dependencies are strict as well.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-nonstrict-import&quot;&gt; &lt;code&gt;nonstrict-import&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;@flow strict&lt;/code&gt; 가 아닌 모듈에서 가져올 때 오류를 트리거합니다. 이는 파일이 엄격한 것으로 표시 될 때 모든 종속 항목도 엄격하다는 것을 의미하므로 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="23dc038c2ecb0a3dd5d8efa5dc006412b7663f59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-sketchy-null&quot;&gt;&lt;code&gt;sketchy-null&lt;/code&gt;&lt;/a&gt;: Triggers an error when doing an existence check on a value that could be null/undefined or falsey.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-sketchy-null&quot;&gt; &lt;code&gt;sketchy-null&lt;/code&gt; &lt;/a&gt; : null / 정의되지 않거나 false 일 수있는 값에 대한 존재 확인을 수행 할 때 오류를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="56b2dc1b2d6f50b7b575c022bf5062e97e364ce7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unclear-type&quot;&gt;&lt;code&gt;unclear-type&lt;/code&gt;&lt;/a&gt;: Triggers an error when using &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, or &lt;code&gt;any&lt;/code&gt; in a type annotation.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unclear-type&quot;&gt; &lt;code&gt;unclear-type&lt;/code&gt; &lt;/a&gt; : 트리거 오류 사용하여 &lt;code&gt;Object&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; , 또는 &lt;code&gt;any&lt;/code&gt; 유형의 주석에.</target>
        </trans-unit>
        <trans-unit id="acccc45b43c76d68c5b6f5a5cb4efb4873e9f331" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unsafe-getters-setters&quot;&gt;&lt;code&gt;unsafe-getters-setters&lt;/code&gt;&lt;/a&gt;: Triggers an error when using getters and setters, which can be unsafe.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-unsafe-getters-setters&quot;&gt; &lt;code&gt;unsafe-getters-setters&lt;/code&gt; &lt;/a&gt; : getter 및 setter를 사용할 때 안전하지 않은 오류를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="50e62738926445ab80ca91b62a51deef77f07c6d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-import&quot;&gt;&lt;code&gt;untyped-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing from an untyped module.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-import&quot;&gt; &lt;code&gt;untyped-import&lt;/code&gt; &lt;/a&gt; : 형식화되지 않은 모듈에서 가져올 때 오류를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="d428c85916fe38ed4c6c020088009c38838b5b26" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-type-import&quot;&gt;&lt;code&gt;untyped-type-import&lt;/code&gt;&lt;/a&gt;: Triggers an error when importing a type from an untyped module.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-untyped-type-import&quot;&gt; &lt;code&gt;untyped-type-import&lt;/code&gt; &lt;/a&gt; : 형식화되지 않은 모듈에서 형식을 가져올 때 오류를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="8f07b8879f1946951cbf77557ef11a9915432823" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;Exact object types&lt;/a&gt; disable width subtyping, and do not allow additional properties to exist.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;정확한 개체 유형은&lt;/a&gt; 너비 하위 입력을 비활성화하고 추가 속성이 존재하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="7bb6540eba761465bf65a5ccdd99346953e691d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; already supports Flow by default. All you need to do is &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;install Flow&lt;/a&gt; and create a &lt;code&gt;.flowconfig&lt;/code&gt; file by running &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;React 앱 생성&lt;/a&gt; 은 기본적으로 흐름을 이미 지원합니다. 당신이 할 필요가있다 &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;흐름을 설치&lt;/a&gt; 하고 만들 &lt;code&gt;.flowconfig&lt;/code&gt; 를 실행하여 파일 &lt;code&gt;flow init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5375300eb5712965cf5fc5cb3cf56433133be9cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;&lt;code&gt;flow-remove-types&lt;/code&gt;&lt;/a&gt; is a small CLI tool for stripping Flow type annotations from files. It&amp;rsquo;s a lighter-weight alternative to Babel for projects that don&amp;rsquo;t need everything Babel provides.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt; &lt;code&gt;flow-remove-types&lt;/code&gt; &lt;/a&gt; 는 파일에서 흐름 유형 주석을 제거하기위한 작은 CLI 도구입니다. Babel이 제공하는 모든 것을 필요로하지 않는 프로젝트의 경우 Babel을 경량으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="518c67db26b37e0a41e20d16b7df11d4b116b8cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot;&gt;Coc&lt;/a&gt; is an intellisense engine for vim8 &amp;amp; neovim.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot;&gt;Coc&lt;/a&gt; 는 vim8 및 neovim을위한 인텔리전스 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="79e9310832926dd892f262feeb40312198e89414" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode&quot;&gt;Flow Language Support&lt;/a&gt; provides all the functionality you would expect &amp;mdash; linting, intellisense, type tooltips and click-to-definition. It&amp;rsquo;s stable and under active development.</source>
          <target state="translated">&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode&quot;&gt;Flow Language Support&lt;/a&gt; 는 린팅, 인텔리전스, 타이핑 툴팁 및 클릭 투 정의와 같은 모든 기능을 제공합니다. 안정적이고 적극적으로 개발 중입니다.</target>
        </trans-unit>
        <trans-unit id="7c85b0e7dccf1df1c9799d9517b8f07ae7d48726" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@cdebotton/redux-and-flowtype-69ff1dd09036#.fsrm1amlk&quot;&gt;Redux and Flowtype&lt;/a&gt; - Christian de Botton</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@cdebotton/redux-and-flowtype-69ff1dd09036#.fsrm1amlk&quot;&gt;리덕스와 플로우 타입-Christian&lt;/a&gt; de Botton</target>
        </trans-unit>
        <trans-unit id="b2bbb899b8c317c50fa7f4bf67ae90e51c42f496" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://nuclide.io&quot;&gt;Nuclide&lt;/a&gt; is a full IDE created by people at Facebook that has support for Flow built-in. It provides a linter, autocomplete and type coverage support, click-to-definition and type description on hover.</source>
          <target state="translated">&lt;a href=&quot;https://nuclide.io&quot;&gt;Nuclide&lt;/a&gt; 는 Flow 내장 기능을 지원하는 Facebook 사용자가 만든 전체 IDE입니다. 호버에 대한 정보, 자동 완성 및 유형 적용 범위 지원, 클릭 투 정의 및 유형 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9706104248435c91942f7078e78f2cbaa21d2931" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt; can be integrated with Flow by using &lt;a href=&quot;https://packagecontrol.io&quot;&gt;Package Control&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://packagecontrol.io&quot;&gt;패키지 제어&lt;/a&gt; 를 사용하여 Sublime Text 를 Flow와 통합 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="832311cb20bd2c6c6484e62e8e290372fda23e34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tools/babel&quot;&gt; &lt;h3&gt; Babel &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with Babel &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/flow-remove-types&quot;&gt; &lt;h3&gt; flow-remove-types &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with flow-remove-types &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/create-react-app&quot;&gt; &lt;h3&gt; Create React App &lt;/h3&gt; &lt;p&gt; Learn how to use Flow with Create React App &lt;/p&gt; &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;tools/babel&quot;&gt; &lt;h3&gt; 바벨 &lt;/h3&gt; &lt;p&gt; Babel에서 Flow를 사용하는 방법 알아보기 &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/flow-remove-types&quot;&gt; &lt;h3&gt; 흐름 제거 유형 &lt;/h3&gt; &lt;p&gt; 흐름 제거 유형으로 흐름을 사용하는 방법 알아보기 &lt;/p&gt; &lt;/a&gt;&lt;a href=&quot;tools/create-react-app&quot;&gt; &lt;h3&gt; 리 액트 앱 만들기 &lt;/h3&gt; &lt;p&gt; Create React App에서 Flow를 사용하는 방법 알아보기 &lt;/p&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d3edbcd8340616b98a8bb730d5f2bfb4883db8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Call&amp;lt;F, T...&amp;gt;&lt;/code&gt; is a type that represents the result of calling the given &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt; with 0 or more arguments &lt;code&gt;T...&lt;/code&gt;. This is analogous to calling a function at runtime (or more specifically, it&amp;rsquo;s analogous to calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;&lt;code&gt;Function.prototype.call&lt;/code&gt;&lt;/a&gt;), but at the type level; this means that function type calls happens statically, i.e. not at runtime.</source>
          <target state="translated">&lt;code&gt;$Call&amp;lt;F, T...&amp;gt;&lt;/code&gt; 는 0 개 이상의 인수 &lt;code&gt;T...&lt;/code&gt; 주어진 &lt;a href=&quot;../functions&quot;&gt;함수 유형 &lt;/a&gt; &lt;code&gt;F&lt;/code&gt; 를 호출 한 결과를 나타내는 유형입니다 . 이것은 런타임에 함수를 호출하는 것과 유사하지만 (보다 구체적으로는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt; &lt;code&gt;Function.prototype.call&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 유사 하지만) 유형 레벨입니다. 즉, 함수 유형 호출은 정적으로 수행됩니다 (즉, 런타임이 아님).</target>
        </trans-unit>
        <trans-unit id="f2241c9b7c945bd4d93f1e03d981bbd35f587e2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Call&lt;/code&gt; can be very powerful because it allows you to make calls in type-land that you would otherwise have to do at runtime. The type-land calls happen statically and will be erased at runtime.</source>
          <target state="translated">&lt;code&gt;$Call&lt;/code&gt; 은 런타임에 다른 유형의 전화를 걸 수 있기 때문에 매우 강력 할 수 있습니다. 타입 랜드 호출은 정적으로 발생하며 런타임에 지워집니다.</target>
        </trans-unit>
        <trans-unit id="9c25dd66acf1845fd7317530f17f429c5d475619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; is the type that represents the type of every element inside an &lt;a href=&quot;../arrays&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;../tuples&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;../objects&quot;&gt;object&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt;, that matches the given &lt;em&gt;key&lt;/em&gt; type &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 는 주어진 &lt;em&gt;키&lt;/em&gt; 유형 &lt;code&gt;K&lt;/code&gt; 와 일치 하는 &lt;a href=&quot;../arrays&quot;&gt;배열&lt;/a&gt; , &lt;a href=&quot;../tuples&quot;&gt;튜플&lt;/a&gt; 또는 &lt;a href=&quot;../objects&quot;&gt;객체&lt;/a&gt; 유형 &lt;code&gt;T&lt;/code&gt; 내의 모든 요소의 유형을 나타내는 유형입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="508e7e8d64ef136cbb4051692a66a33f7f03d8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Exact&amp;lt;{name: string}&amp;gt;&lt;/code&gt; is a synonym for &lt;code&gt;{|name:string|}&lt;/code&gt; as in the &lt;a href=&quot;../objects#toc-exact-object-types&quot;&gt;Object documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$Exact&amp;lt;{name: string}&amp;gt;&lt;/code&gt; 은 &lt;a href=&quot;../objects#toc-exact-object-types&quot;&gt;Object documentation&lt;/a&gt; 에서와 같이 &lt;code&gt;{|name:string|}&lt;/code&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="1f560c59c278bbced6c01735997cd392ca4dcce5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; converts a type &lt;code&gt;T&lt;/code&gt; to a non-maybe type. In other words, the values of &lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; are the values of &lt;code&gt;T&lt;/code&gt; except for &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; 는 유형 &lt;code&gt;T&lt;/code&gt; 를 가능하지 않은 유형으로 변환합니다 . 즉, &lt;code&gt;$NonMaybeType&amp;lt;T&amp;gt;&lt;/code&gt; 의 값은 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 제외하고 &lt;code&gt;T&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="af15b84204f891abb40fd24979cfba73a49edad8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; is a type that represents the read-only version of a given &lt;a href=&quot;../objects&quot;&gt;object type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;. A read-only object type is an object type whose keys are all &lt;a href=&quot;../interfaces#toc-interface-property-variance-read-only-and-write-only&quot;&gt;read-only&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; 는 주어진 &lt;a href=&quot;../objects&quot;&gt;객체 유형 &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 의 읽기 전용 버전을 나타내는 유형입니다 . 읽기 전용 객체 유형은 키가 모두 &lt;a href=&quot;../interfaces#toc-interface-property-variance-read-only-and-write-only&quot;&gt;읽기 전용&lt;/a&gt; 인 객체 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="98b234ef2ba7237b91129403279d8a12d8b8a498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; is the type that represents the runtime object rest operation, e.g.: &lt;code&gt;const {foo, ...rest} = obj&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both &lt;a href=&quot;../objects&quot;&gt;object types&lt;/a&gt;. The resulting type from this operation will be an object type containing &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s &lt;em&gt;own&lt;/em&gt; properties that are not &lt;em&gt;own&lt;/em&gt; properties in &lt;code&gt;B&lt;/code&gt;. In flow, we treat all properties on &lt;a href=&quot;(../objects#toc-exact-object-types)&quot;&gt;exact object types&lt;/a&gt; as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;own&lt;/a&gt;. In in-exact objects, a property may or may not be own.</source>
          <target state="translated">&lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; 는 런타임 객체 정지 작업을 나타내는 유형입니다 (예 : &lt;code&gt;const {foo, ...rest} = obj&lt;/code&gt; ). 여기서 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 모두 &lt;a href=&quot;../objects&quot;&gt;객체 유형&lt;/a&gt; 입니다. 이 작업의 결과 유형은 &lt;code&gt;B&lt;/code&gt; &lt;em&gt;의 자체&lt;/em&gt; 속성 이 아닌 &lt;code&gt;A&lt;/code&gt; 의 &lt;em&gt;자체&lt;/em&gt; 속성을 포함하는 객체 유형 입니다. 흐름에서는 &lt;a href=&quot;(../objects#toc-exact-object-types)&quot;&gt;정확한 객체 유형의&lt;/a&gt; 모든 속성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;own&lt;/a&gt; 로 취급합니다 . 정확하지 않은 객체에서 속성은 소유하거나 소유하지 않을 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d802f2267a06e1a2022c679c8bde31819cb03ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$TupleMap&amp;lt;T, F&amp;gt;&lt;/code&gt; takes an iterable type &lt;code&gt;T&lt;/code&gt; (e.g.: &lt;a href=&quot;../tuples&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;), and a &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt;, and returns the iterable type obtained by mapping the type of each value in the iterable with the provided function type &lt;code&gt;F&lt;/code&gt;. This is analogous to the Javascript function &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$TupleMap&amp;lt;T, F&amp;gt;&lt;/code&gt; 는 iterable 유형 &lt;code&gt;T&lt;/code&gt; (예 : &lt;a href=&quot;../tuples&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../arrays&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; ) 및 &lt;a href=&quot;../functions&quot;&gt;함수 유형 &lt;/a&gt; &lt;code&gt;F&lt;/code&gt; 를 가져오고 iterable의 각 값 유형을 제공된 함수 유형 &lt;code&gt;F&lt;/code&gt; 와 함께 iterable에 맵핑하여 얻은 반복 가능한 유형을 리턴합니다 . 이것은 Javascript 함수 &lt;code&gt;map&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1f76db9419791028b16c53d50170a640dded7f72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$Values&amp;lt;T&amp;gt;&lt;/code&gt; represents the union type of all the value types (not the values, but their &lt;em&gt;types&lt;/em&gt;!) of the enumerable properties in an &lt;a href=&quot;../objects&quot;&gt;Object Type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$Values&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;a href=&quot;../objects&quot;&gt;Object Type &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 에서 열거 가능한 속성 의 모든 값 유형 (값이 아니라 &lt;em&gt;유형&lt;/em&gt; !)의 공용체 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2594799d46ec0811bd7e6e9354b8cae3d1f1d6a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.flowconfig&lt;/code&gt; format</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 형식</target>
        </trans-unit>
        <trans-unit id="2f61adc534681a552a76146f3a893058257fd34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/path/to/root/&lt;/code&gt; (automatically included)</source>
          <target state="translated">&lt;code&gt;/path/to/root/&lt;/code&gt; (자동으로 포함)</target>
        </trans-unit>
        <trans-unit id="4eb684af2fc8a1193252507702d321d75c5eef22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@flow strict-local&lt;/code&gt; is the same as &lt;code&gt;@flow strict&lt;/code&gt;, except it does not require its dependencies to also be strict (i.e. it is &amp;ldquo;locally&amp;rdquo; strict). It does not have a separate configuration: it uses the same configuration as Flow Strict, just without the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">&lt;code&gt;@flow strict-local&lt;/code&gt; 은 &lt;code&gt;@flow strict&lt;/code&gt; 와 동일하지만 종속 항목도 엄격 할 필요가 없다는 점을 제외하고 (즉, &quot;로컬&quot; 로 엄격함 ). 별도의 구성이 없습니다 . &lt;code&gt;nonstrict-import&lt;/code&gt; 규칙 없이 Flow Strict와 동일한 구성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8f9cde7197917421c3115f9339175348c4255a20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="a803aafb511370111befd33436b887e6bb708e91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array&lt;/code&gt; Type Shorthand Syntax</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 유형 속기 구문</target>
        </trans-unit>
        <trans-unit id="3331a137b8616e6d3a4d9711f6d95d677a4a97c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Function&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Function&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="2cbf7e5430db7626ac9af791d16644934975cb21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; takes an &lt;a href=&quot;../objects&quot;&gt;object type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, and a &lt;a href=&quot;../functions&quot;&gt;function type&lt;/a&gt;&lt;code&gt;F&lt;/code&gt;, and returns the object type obtained by mapping the type of each value in the object with the provided function type &lt;code&gt;F&lt;/code&gt;. In other words, &lt;code&gt;$ObjMap&lt;/code&gt; will &lt;a href=&quot;#toc-call&quot;&gt;call&lt;/a&gt; (at the type level) the given function type &lt;code&gt;F&lt;/code&gt; for every property value type in &lt;code&gt;T&lt;/code&gt;, and return the resulting object type from those calls.</source>
          <target state="translated">&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; 는 &lt;a href=&quot;../objects&quot;&gt;객체 유형 &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 와 &lt;a href=&quot;../functions&quot;&gt;함수 유형 &lt;/a&gt; &lt;code&gt;F&lt;/code&gt; 를 가져오고 제공된 함수 유형 &lt;code&gt;F&lt;/code&gt; 와 함께 객체의 각 값 유형을 매핑하여 얻은 객체 유형을 반환합니다 . 즉, &lt;code&gt;$ObjMap&lt;/code&gt; 것입니다 &lt;a href=&quot;#toc-call&quot;&gt;전화&lt;/a&gt; 주어진 함수 타입 (타입 수준에서) &lt;code&gt;F&lt;/code&gt; 의 모든 속성 값 유형 &lt;code&gt;T&lt;/code&gt; , 그 통화에서 결과 개체 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="681cf2b1552373c6dcf1f86ee33a93ff337de143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ObjMapi&amp;lt;T, F&amp;gt;&lt;/code&gt; is similar to &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt;&lt;/a&gt;. The difference is that function type &lt;code&gt;F&lt;/code&gt; will be &lt;a href=&quot;#toc-call&quot;&gt;called&lt;/a&gt; with both the key and value types of the elements of the object type &lt;code&gt;T&lt;/code&gt;, instead of just the value types. For example:</source>
          <target state="translated">&lt;code&gt;ObjMapi&amp;lt;T, F&amp;gt;&lt;/code&gt; 비슷 &lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; &lt;/a&gt; . 차이점은 함수 유형 &lt;code&gt;F&lt;/code&gt; 가 값 유형 대신 객체 유형 &lt;code&gt;T&lt;/code&gt; 의 요소의 키 및 값 유형 으로 &lt;a href=&quot;#toc-call&quot;&gt;호출&lt;/a&gt; 된다는 것 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="767b77f7a41bfeed131973627af17f7e6faa58cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object&lt;/code&gt; Type</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="1544818dc3132ba28560d73844cabcd76ae68cc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.AbstractComponent&amp;lt;Config, Instance&amp;gt;&lt;/code&gt; (v0.89.0+) represents a component with a config of type Config and instance of type Instance.</source>
          <target state="translated">&lt;code&gt;React.AbstractComponent&amp;lt;Config, Instance&amp;gt;&lt;/code&gt; (v0.89.0 +)는 Config 유형의 구성과 Instance 유형의 인스턴스가있는 구성 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7a05b510244008460c777eeffe9a1d99b0b3f433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Component&amp;lt;Props, State&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;https://flow.org/en/types/generics/&quot;&gt;generic type&lt;/a&gt; that takes two type arguments. Props and state. The second type argument, &lt;code&gt;State&lt;/code&gt;, is optional. By default it is undefined so you can see in the example above we did not include &lt;code&gt;State&lt;/code&gt;. We will learn more about state in the next section&amp;hellip;</source>
          <target state="translated">&lt;code&gt;React.Component&amp;lt;Props, State&amp;gt;&lt;/code&gt; 는 두 가지 형식 인수를 취하는 &lt;a href=&quot;https://flow.org/en/types/generics/&quot;&gt;일반 형식&lt;/a&gt; 입니다. 소품과 주. 두 번째 유형 인수 &lt;code&gt;State&lt;/code&gt; 는 선택 사항입니다. 기본적으로 정의되어 있지 않으므로 위 예제에서 &lt;code&gt;State&lt;/code&gt; 를 포함하지 않았습니다 . 다음 섹션에서 상태에 대해 더 배울 것입니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9230540e79b96189b0ea859004424e54a1e6f63f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; does not include intrinsic JSX element types like &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt;. See &lt;a href=&quot;#toc-react-elementtype&quot;&gt;&lt;code&gt;React.ElementType&lt;/code&gt;&lt;/a&gt; if you also want to include JSX intrinsics.</source>
          <target state="translated">&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; 에는 &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;span&lt;/code&gt; 과 같은 고유 JSX 요소 유형이 포함되어 있지 않습니다 . JSX 내장 함수도 포함하려면 &lt;a href=&quot;#toc-react-elementtype&quot;&gt; &lt;code&gt;React.ElementType&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58f1f75b8bcd9618953c69318f7620eb7b4295c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is also the return type of &lt;code&gt;React.createElement()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 또한 &lt;code&gt;React.createElement()&lt;/code&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="adc63cd1289ababfe9d45f2979b42f2a3e435bb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticAnimationEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt;AnimationEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticAnimationEvent&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent&quot;&gt;AnimationEvent에&lt;/a&gt; 대한 SyntheticAnimationEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7c5e5304c53ff7a14b0db24ef11da3dbb99b2b14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticCompositionEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent&quot;&gt;CompositionEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticCompositionEvent&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent&quot;&gt;CompositionEvent에&lt;/a&gt; 대한 SyntheticCompositionEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c96f9ac107f248ffac9f8626b279676bd8718958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticDragEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DragEvent&quot;&gt;DragEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticDragEvent&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DragEvent&quot;&gt;있는 DragEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa52bea770e564d49631a007def85a111217c029" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;Event&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;이벤트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96c79f952aac07c545dc47e57d9d9cd7d49c791f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticFocusEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent&quot;&gt;FocusEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticFocusEvent&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent&quot;&gt;의해 FocusEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5996e654c7c893a828a52a8b60b3799f8e789a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticInputEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/InputEvent&quot;&gt;InputEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticInputEvent&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/InputEvent&quot;&gt;InputEvent에&lt;/a&gt; 대한 SyntheticInputEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2026e5307092d1d6c43fff4a1ac451cb1d8596f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent&quot;&gt;KeyboardEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent&quot;&gt;KeyboardEvent입니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4fc35b5921c09e6284b8b4d64655b2075c7403d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;된 MouseEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8f969c201611aa63546668fd0d4a5fb4be56f6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent&quot;&gt;TouchEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent&quot;&gt;TouchEvent&lt;/a&gt; 용 SyntheticTouchEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5392d56e034e56ed7cf9f986f6a8e54736cf46cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticTransitionEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent&quot;&gt;TransitionEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticTransitionEvent&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent&quot;&gt;TransitionEvent에&lt;/a&gt; 대한 SyntheticTransitionEvent &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="693da3b475fb277ea5f089a6fe5960e4093a8bf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticUIEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticUIEvent&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;의 UIEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75c836ef8f10b19801a470eac5c6ed743d951e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SyntheticWheelEvent&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent&quot;&gt;WheelEvent&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;SyntheticWheelEvent&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent&quot;&gt;WheelEvent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd8d3fb84c2e2653143777ce2230d40aeb161b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[untyped]&lt;/code&gt; instead causes a file to be ignored by the typechecker as if it had &lt;code&gt;noflow&lt;/code&gt; in it, resolve modules as &lt;code&gt;any&lt;/code&gt; typ, but allow them to NOT be ignored by the module resolver. Any matching file is skipped by Flow (not even parsed, like other &lt;code&gt;noflow&lt;/code&gt; files!), but can still be &lt;code&gt;require()&lt;/code&gt;&amp;lsquo;d.</source>
          <target state="translated">&lt;code&gt;[untyped]&lt;/code&gt; 는 대신 파일이 &lt;code&gt;noflow&lt;/code&gt; 에없는 것처럼 형식 검사기 에 의해 파일이 무시되도록하고 , 모듈을 &lt;code&gt;any&lt;/code&gt; 해석 하지만 모듈 해석기에 의해 무시되지 않도록합니다. 일치하는 파일은 Flow에 의해 건너 뛰지 만 (다른 &lt;code&gt;noflow&lt;/code&gt; 파일 과 마찬가지로 파싱되지는 않습니다 !) 여전히 &lt;code&gt;require()&lt;/code&gt; 'd 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4734a96ab71cb9256e40d7ef655d0b7aec2769d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9980c61e3e10b0171dab78805e509842f78d6bfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;babel_loose_array_spread&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;babel_loose_array_spread&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9328c95d646b4ac7120c78217d7dabde5057c2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - declares a block-scoped variable, assigning a value that cannot be re-assigned. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; - 재 할당 할 수없는 값을 지정하여 블록 범위 변수를 선언합니다. ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&quot;&gt;MDN&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c35bdf03258530159bd15512b8348c3d41d5a19d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - variables that &lt;strong&gt;cannot&lt;/strong&gt; be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; - 재 할당 &lt;strong&gt;할 수없는&lt;/strong&gt; 변수</target>
        </trans-unit>
        <trans-unit id="ec86decd5f7af51264833626096e4ddd7664c147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;emoji&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;emoji&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96920174b4323d8c30fdb2a3ec074673a3d14b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.class_instance_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.class_instance_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="171137be6be377f3d07f41d4691b38066b388d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.class_static_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.class_static_fields&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9f45cd53162169474b7a6388eccd7f001dfae9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.decorators&lt;/code&gt;&lt;em&gt;&lt;code&gt;(ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.decorators&lt;/code&gt;&lt;em&gt;&lt;code&gt;(ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="972a4a3dbe0f7550710ef309f72472fb16297ecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.export_star_as&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.export_star_as&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="638056fd7e6c68417a3a146dfca7047b22c08d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.nullish_coalescing&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.nullish_coalescing&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e869212f0b8e102de1941c727fdebe6d2a890181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;esproposal.optional_chaining&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;esproposal.optional_chaining&lt;/code&gt;&lt;em&gt;&lt;code&gt;(enable|ignore|warn)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93d7450678ff784f4a91b7939b3f1d2d0f196f78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exact_by_default&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;exact_by_default&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0b3658b2908fca30f69af8b284b05c29e2e0d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental.const_params&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;experimental.const_params&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42e3942bab511fa03988ce07bb75a9d0d7c74847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f1&lt;/code&gt; can return a value that &lt;code&gt;FuncType&lt;/code&gt; never does, so code that relies on &lt;code&gt;FuncType&lt;/code&gt; might not be safe if &lt;code&gt;f1&lt;/code&gt; is used. Its type is not a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f1&lt;/code&gt; 은 &lt;code&gt;FuncType&lt;/code&gt; 이 절대로하지 않는 값을 반환 할 수 있으므로 &lt;code&gt;f1&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;FuncType&lt;/code&gt; 에 의존하는 코드는 안전하지 않을 수 있습니다 . 유형은 &lt;code&gt;FuncType&lt;/code&gt; 의 하위 유형이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="726638e0c45c973078425c1f460e13663c6df9ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f2&lt;/code&gt; can&amp;rsquo;t handle all the argument values that &lt;code&gt;FuncType&lt;/code&gt; does, so code that relies on &lt;code&gt;FuncType&lt;/code&gt; can&amp;rsquo;t safely use &lt;code&gt;f2&lt;/code&gt;. Its type is also not a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f2&lt;/code&gt; 하는 모든 인수 값 처리 할 수 &lt;code&gt;FuncType&lt;/code&gt; 가 에 의존하는 코드 있도록, 수행을 &lt;code&gt;FuncType&lt;/code&gt; 가 안전하게 사용할 수 없습니다 &lt;code&gt;f2&lt;/code&gt; . 그것의 타입은 또한 &lt;code&gt;FuncType&lt;/code&gt; 의 서브 타입이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5400ddcebeeba38d292672ea4e21ae521f4c3c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f3&lt;/code&gt; can accept all the argument values that &lt;code&gt;FuncType&lt;/code&gt; does, and only returns values that &lt;code&gt;FuncType&lt;/code&gt; does, so its type is a subtype of &lt;code&gt;FuncType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f3&lt;/code&gt; 모든 것을 인수 값 받아 들일 수 &lt;code&gt;FuncType&lt;/code&gt; 가 수행하고 만 반환 값 &lt;code&gt;FuncType&lt;/code&gt; 은 그 유형의 하위 유형입니다, 그래서 수행을 &lt;code&gt;FuncType&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="0aae29a82fc10cee61f896dcf30eeebb3766c146" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flowlint-next-line&lt;/code&gt; works the same as &lt;code&gt;flowlint-line&lt;/code&gt;, except it applies its settings to the next line instead of the current line:</source>
          <target state="translated">&lt;code&gt;flowlint-next-line&lt;/code&gt; 은 &lt;code&gt;flowlint-line&lt;/code&gt; 과 동일하게 작동 하지만 현재 행 대신 다음 행에 설정을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a48e34cc7b299416a8e2b7ea16e6d555b35b2019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include_warnings&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;include_warnings&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d8ddac7ae75b7a8f7db9fd921f2cf55bd4b2c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazy_mode&lt;/code&gt;&lt;em&gt;&lt;code&gt;(fs|ide|watchman|none)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;lazy_mode&lt;/code&gt;&lt;em&gt;&lt;code&gt;(fs|ide|watchman|none)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="336c7ba3afe701528a0e2b671be4925b95c96b3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; - declares a block-scoped variable, optionally assigning a value. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; - 선택적으로 값을 할당, 블록 범위의 변수를 선언합니다. ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="447b3a2dddaad4f848e312d7d33f3c96c59892d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; - variables that &lt;strong&gt;can&lt;/strong&gt; be reassigned.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; - 재 할당 &lt;strong&gt;할 수&lt;/strong&gt; 있는 변수 .</target>
        </trans-unit>
        <trans-unit id="da67888b6c142ef501bff7964e43c869c753300c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log.file&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;log.file&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10b72cfa901df08cc8fe7be85a5ce76b92d3830e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_header_tokens&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;max_header_tokens&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7127e551c98174c6634c2da74d89fefc7432f7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixed&lt;/code&gt; will accept any type of value. Strings, numbers, objects, functions&amp;ndash; anything will work.</source>
          <target state="translated">&lt;code&gt;mixed&lt;/code&gt; 는 모든 유형의 값을 허용합니다. 문자열, 숫자, 객체, 함수 등 모든 것이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="51164f8b8016f0d8abcae69123c2523293287daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.file_ext&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.file_ext&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8bd5bc2f73b98906fb7419179328c69ef4d9e356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.ignore_non_literal_requires&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.ignore_non_literal_requires&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa5897539c2a2f8f6f118e08172c4bc433245c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.name_mapper.extension&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string -&amp;gt; string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.name_mapper.extension&lt;/code&gt; &lt;em&gt; &lt;code&gt;(string -&amp;gt; string)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="695be517c6a87b361f0a94a84ee335146ea99233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.name_mapper&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex -&amp;gt; string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.name_mapper&lt;/code&gt; &lt;em&gt; &lt;code&gt;(regex -&amp;gt; string)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f6d453a4f39af3bbcc8e866a62bb026e067f3ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system.node.main_field&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system.node.main_field&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2b55b3985b54cfcb20f350998122314d8f82eca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3917f0b66e443088994451f0883b66faaf5a2a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.system&lt;/code&gt;&lt;em&gt;&lt;code&gt;(node|haste)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.system&lt;/code&gt;&lt;em&gt;&lt;code&gt;(node|haste)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac108e4226f0003b79c994c5e9872aae99cf04e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module.use_strict&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;module.use_strict&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3c7cf33182d09b184a1acd84332f6a07f1a0cdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;munge_underscores&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;munge_underscores&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee2c2db77365d69cc88bb148e9b038199c9e52b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_flowlib&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;no_flowlib&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aec71172404443d710062cd2dbcdb5a433b974cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;void&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59ea58ab1aea5c130c466795049be1f9aaf0803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; also appear in other types.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;void&lt;/code&gt; 는 다른 유형에도 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e8c9111ee40b4a3593b8970efac417f8ac70f84d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-router&lt;/code&gt; version 4 asks for a &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt;function as the children to its &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; component&lt;/a&gt;. You would provide a function as the children to &lt;code&gt;react-router&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;react-router&lt;/code&gt; 버전 4는 &lt;a href=&quot;https://reacttraining.com/react-router/core/api/Route/children-func&quot;&gt; &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; &lt;/a&gt; component 의 하위 기능을 요청합니다 . 다음 과 같이 &lt;code&gt;react-router&lt;/code&gt; 대한 하위 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0094d54f0f90d0220f6da062cdc9c6ae6eae5fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server.max_workers&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;server.max_workers&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f189fba493378458484495c789f0c1fe55185671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57b914d6e4aade39e538cecd6f22441853012d68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.hash_table_pow&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.hash_table_pow&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e5bb5de55179a3c1994c86e08d6ba8959cf26035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.heap_size&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.heap_size&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb32a4afd21311d7f593b3de1374f83ef370676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.log_level&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.log_level&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5afdf22d252e5f159714f331f56a1183c8db4629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedmemory.minimum_available&lt;/code&gt;&lt;em&gt;&lt;code&gt;(unsigned integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sharedmemory.minimum_available&lt;/code&gt; &lt;em&gt; &lt;code&gt;(unsigned integer)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6af14e5c0d4307ffde1e14ef7590be5942e679aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strip_root&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;le;0.48</source>
          <target state="translated">&lt;code&gt;strip_root&lt;/code&gt;&lt;em&gt;&lt;code&gt;(boolean)&lt;/code&gt;&lt;/em&gt;&amp;le;0.48</target>
        </trans-unit>
        <trans-unit id="b7056b5cc505c600e004961cb933f9821121eb2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;suppress_comment&lt;/code&gt;&lt;em&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72b91edcfd78ab9e6e183d55d0e45a396ff7018c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress_type&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;suppress_type&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8ad04f97245289d4e39fc158bdfbcdf56d0bf99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;temp_dir&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;temp_dir&lt;/code&gt;&lt;em&gt;&lt;code&gt;(string)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0eca817f39a368fc9aa5bd8f12866ffd32eaa21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;traces&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;traces&lt;/code&gt;&lt;em&gt;&lt;code&gt;(integer)&lt;/code&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c75e6afcf9d83a43fbddc117b5707c6525bca25f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof Component&lt;/code&gt; can also be your React class component or stateless functional component.</source>
          <target state="translated">&lt;code&gt;typeof Component&lt;/code&gt; 는 React 클래스 컴포넌트 또는 상태 비 저장 기능 컴포넌트 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e11876a8dc567e2d922f662f5f89f99f143a6ebc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; inherits behaviors of inference</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 는 추론 동작을 상속</target>
        </trans-unit>
        <trans-unit id="eb1cf1f4297c1b2ae089f4080f05438696aa41b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; inherits behaviors of other types</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 는 다른 유형의 동작을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="8bc3bf8b12c02f9c49ba612a2afbc618a8714ac2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type syntax</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 유형 구문</target>
        </trans-unit>
        <trans-unit id="e9340dc40167bf2df1900dd5ff09de7ee451b582" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; (&lt;code&gt;void&lt;/code&gt; in Flow types)</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; ( 흐름 유형에서 &lt;code&gt;void&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e10bde5813a41a4b1af5888a4a46a6bbc121f9a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; - declares a variable, optionally assigning a value. (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; - 변수를 선언하고 선택적으로 값을 지정합니다. ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3849f1997a58ce69bfb01dd3b43d461870cc5bea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="618a581b65ff5f5e5889511d3cd080ab05886f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;exports.js&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;exports.js&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b33f07a5ba2608771292c96cae619e974a5fb21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;imports.js&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;imports.js&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2656931fc434aca0157a011d0d37c9e6f677adfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f4be936250abf866d7156093839a04de7c1cd2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Don&amp;rsquo;t forget to mention &lt;code&gt;@flow&lt;/code&gt; on top of file, otherwise flow won&amp;rsquo;t report errors&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;파일 위에 &lt;code&gt;@flow&lt;/code&gt; 를 언급하는 것을 잊지 마십시오 . 그렇지 않으면 flow가 오류를보고하지 않습니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4284c426f28b28ecfd869ea4f96a80f7f8690134" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Interfaces&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Interfaces&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f17253c245d87ac973fc5293b5a15ab24ab8bdc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Type Aliases&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;유형 별명&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbe8982c76a4cc7f7e9adfc12449f681674cbb61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;You should follow &lt;a href=&quot;../any&quot;&gt;all the same rules&lt;/a&gt; as &lt;code&gt;any&lt;/code&gt; when using &lt;code&gt;Function&lt;/code&gt;.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;Function&lt;/code&gt; 을 &lt;code&gt;any&lt;/code&gt; 때 &lt;a href=&quot;../any&quot;&gt;와 동일한 규칙&lt;/a&gt; 을 따라야 합니다 .&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2811438566c8ce65b8a6941e70fbece78eceaa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A group of different possible types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가능한 다른 유형의 그룹 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae678a78ebebf05c595f0cdf9e9e80e85d991358" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A single type:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;단일 유형 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e53a0237f152f0b316bc97b2fc063f3efa825e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A type based on another type:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 유형에 기반한 유형 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d99a25c652d8cfb74b77ae022021f7dccc449527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An arbitrary type that could be anything:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;임의의 유형이 될 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="17486ec505dad1463a8b0dc8465986bb70f1e04b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency files&lt;/strong&gt;. These are the files which are needed in order to typecheck the focused or dependent files.</source>
          <target state="translated">&lt;strong&gt;종속성 파일&lt;/strong&gt; . 이들은 집중 또는 종속 파일을 유형 검사하는 데 필요한 파일입니다.</target>
        </trans-unit>
        <trans-unit id="348b0bbf82732cfba30377f2a246a2d29c935065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependent files&lt;/strong&gt;. These are the files which depend on the focused files. Changes to the focused files might cause type errors in the dependent files.</source>
          <target state="translated">&lt;strong&gt;종속 파일&lt;/strong&gt; . 이들은 집중된 파일에 의존하는 파일입니다. 포커스가있는 파일을 변경하면 종속 파일에서 유형 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2881ee068ac6090c9feffed65593bbb03cba2056" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Filesystem lazy mode&lt;/strong&gt;. Flow treats any file which has changed on the filesystem as focused. This mode is easier to use from the commandline, but a rebase can make every file appear focused.</source>
          <target state="translated">&lt;strong&gt;파일 시스템 게으른 모드&lt;/strong&gt; . Flow는 파일 시스템에서 변경된 모든 파일을 포커스 된 것으로 간주합니다. 이 모드는 명령 줄에서 사용하기가 쉽지만 리베이스는 모든 파일이 집중된 것처럼 보이게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1871c2ba972fbc1e0adeb69045b60c7b76dcb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Focused files&lt;/strong&gt;. These are the files which the user cares about.</source>
          <target state="translated">&lt;strong&gt;집중된 파일&lt;/strong&gt; . 이들은 사용자가 관심을 갖는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="4c72412e2b545e519f06a9eb3fbf56d6fbd15299" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IDE lazy mode&lt;/strong&gt;. The IDE tells Flow which files have been opened and closed via &lt;code&gt;flow lsp&lt;/code&gt;. Flow treats any file which has ever been opened since the Flow server started as focused.</source>
          <target state="translated">&lt;strong&gt;IDE 게으른 모드&lt;/strong&gt; . IDE는 &lt;code&gt;flow lsp&lt;/code&gt; 를 통해 어떤 파일이 열리고 닫혔는지 Flow에 알려줍니다 . Flow는 Flow 서버가 시작된 이후로 열린 파일을 포커스 된 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="4a2bb6782e12dafbea5a42ed08ba22dd8335a4a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Arrays are also sometimes used as tuples in JavaScript, these are annotated differently in Flow. See the Tuple docs for more information.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 배열은 JavaScript에서 튜플로 사용되는 경우도 있으며 흐름에서 다르게 주석이 추가됩니다. 자세한 내용은 Tuple 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0c839a0690df63ac56fe1bed5a7b464ba8c43db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Because &lt;a href=&quot;#toc-react-elementprops&quot;&gt;&lt;code&gt;React.ElementProps&lt;/code&gt;&lt;/a&gt; does not preserve the optionality of &lt;code&gt;defaultProps&lt;/code&gt;, &lt;a href=&quot;#toc-react-elementconfig&quot;&gt;&lt;code&gt;React.ElementConfig&lt;/code&gt;&lt;/a&gt; (which does) is more often the right choice, especially for simple props pass-through as with &lt;a href=&quot;../hoc#toc-supporting-defaultprops-with-react-elementconfig&quot;&gt;higher-order components&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 때문에 &lt;a href=&quot;#toc-react-elementprops&quot;&gt; &lt;code&gt;React.ElementProps&lt;/code&gt; 가&lt;/a&gt; 의 선택성 보존하지 않습니다 &lt;code&gt;defaultProps&lt;/code&gt; 을 , &lt;a href=&quot;#toc-react-elementconfig&quot;&gt; &lt;code&gt;React.ElementConfig&lt;/code&gt; &lt;/a&gt; (하지) 간단한 소품 통과 특수와 같이, 더 자주 올바른 선택입니다 &lt;a href=&quot;../hoc#toc-supporting-defaultprops-with-react-elementconfig&quot;&gt;고차 구성 요소&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fab5833ac1b21ea7a10d50df5d9bc2a182d5de9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you don&amp;rsquo;t need to use the &lt;code&gt;Props&lt;/code&gt; type again you could also define it inline: &lt;code&gt;extends React.Component&amp;lt;{ foo: number, bar?: string }&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;Props&lt;/code&gt; 유형을 다시 사용할 필요가 없으면 인라인으로 정의 할 수도 있습니다. &lt;code&gt;extends React.Component&amp;lt;{ foo: number, bar?: string }&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d95a1829d723b06d07fce08d5fc4c83da0c5b2f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you don&amp;rsquo;t need to use the &lt;code&gt;State&lt;/code&gt; type again you could also define it inline: &lt;code&gt;extends React.Component&amp;lt;{}, { count: number }&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;State&lt;/code&gt; 유형을 다시 사용할 필요가없는 경우 인라인으로 정의 할 수도 있습니다. &lt;code&gt;extends React.Component&amp;lt;{}, { count: number }&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45fe059278697f2928479023e38c3ab10a142464" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want methods like &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;forEach()&lt;/code&gt; or to handle a &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as a normal JavaScript array then React provides the &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children&quot;&gt;&lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt; to do just this. It has functions like &lt;code&gt;React.Children.toArray(props.children)&lt;/code&gt; that you can use to treat your &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as a flat array.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;map()&lt;/code&gt; 및 &lt;code&gt;forEach()&lt;/code&gt; () 와 같은 메소드를 원 하거나 &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 일반 JavaScript 배열로 처리하려는 경우 React는이 를 수행하기 위해 &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children&quot;&gt; &lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt; 를 제공합니다 . &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 플랫 배열로 취급하는 데 사용할 수있는 &lt;code&gt;React.Children.toArray(props.children)&lt;/code&gt; 와 같은 기능 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="981e303e077480a1b13e37cfcb658e9d478c6764" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you want to use optional function parameters you&amp;rsquo;ll need to use the include comment form.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 선택적 기능 매개 변수를 사용하려면 주석 포함 양식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d43ad66341153296b7a88ebc68288f393965e36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In 0.89.0+, React.ComponentType</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 0.89.0 이상에서 React.ComponentType</target>
        </trans-unit>
        <trans-unit id="7417850e8b9171bcdaf44485d8c88475bdf0d461" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Previously object types used semicolons &lt;code&gt;;&lt;/code&gt; for splitting name-value pairs. While the syntax is still valid, you should use commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이전에는 객체 유형에 세미콜론이 사용되었습니다 &lt;code&gt;;&lt;/code&gt; 이름-값 쌍을 분할합니다. 구문이 여전히 유효하지만, 당신은 쉼표를 사용한다 &lt;code&gt;,&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87767fc2be8bc1d1db6ace0faafec6c1caffc4b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; React uses its own event system so it is important to use the &lt;code&gt;SyntheticEvent&lt;/code&gt; types instead of the DOM types such as &lt;code&gt;Event&lt;/code&gt;, &lt;code&gt;KeyboardEvent&lt;/code&gt;, and &lt;code&gt;MouseEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; React는 자체 이벤트 시스템을 사용 하므로 &lt;code&gt;Event&lt;/code&gt; , &lt;code&gt;KeyboardEvent&lt;/code&gt; 및 &lt;code&gt;MouseEvent&lt;/code&gt; 와 같은 DOM 유형 대신 &lt;code&gt;SyntheticEvent&lt;/code&gt; 유형 을 사용하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="8f2bf27d4821a0d74e94cf2b6f04fa28b458b80e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;*variantOf&lt;/code&gt; types below are not a part of Flow, they are being used to explain variance.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 아래 의 &lt;code&gt;*variantOf&lt;/code&gt; 유형은 Flow의 일부가 아니며 분산을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="102f82e83d1493ee86dfa63526c074eb08db5191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The parentheses are necessary to avoid ambiguity with other syntax.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 괄호는 다른 구문의 모호성을 피하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7f324099a923e249d53f34a12f3516e9e72c0142" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is because of &lt;a href=&quot;https://flow.org/en/lang/width-subtyping/&quot;&gt;&amp;ldquo;width subtyping&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 &lt;a href=&quot;https://flow.org/en/lang/width-subtyping/&quot;&gt;&quot;width subtyping&quot;&lt;/a&gt; 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="50be581c452b3e6bead6ab798ba2bb803100f906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is just shorthand for &lt;code&gt;module.name_mapper='^\(.*\)\.EXTENSION$' -&amp;gt; 'TEMPLATE'&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 &lt;code&gt;module.name_mapper='^\(.*\)\.EXTENSION$' -&amp;gt; 'TEMPLATE'&lt;/code&gt; 약어입니다 . )</target>
        </trans-unit>
        <trans-unit id="beb96f00dcbfc7e17127978d7b2257796cddaa5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not the proper solution to the above problem, it was being used for demonstration only. The correct solution is annotating the function like this:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 위의 문제에 대한 적절한 해결책이 아니며 데모 용으로 만 사용되었습니다. 올바른 해결책은 다음과 같이 함수에 주석을 달고 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaf59b7f203d1ba63f5e98b4e246170ccb103da4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; To get the element instance, like &lt;code&gt;HTMLButtonElement&lt;/code&gt; in the example above, it is a common mistake to use &lt;code&gt;event.target&lt;/code&gt; instead of &lt;code&gt;event.currentTarget&lt;/code&gt;. The reason why you want to use &lt;code&gt;event.currentTarget&lt;/code&gt; is that &lt;code&gt;event.target&lt;/code&gt; may be the wrong element due to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation&quot;&gt;event propagation&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 위 예제의 &lt;code&gt;HTMLButtonElement&lt;/code&gt; 와 같은 요소 인스턴스를 얻으려면 &lt;code&gt;event.currentTarget&lt;/code&gt; 대신 &lt;code&gt;event.target&lt;/code&gt; 을 사용하는 것이 일반적 입니다. &lt;code&gt;event.currentTarget&lt;/code&gt; 을 사용하려는 이유 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation&quot;&gt;event 전파&lt;/a&gt; 로 인해 &lt;code&gt;event.target&lt;/code&gt; 이 잘못된 요소 일 수 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="51bb4c125cd4418ed706f35e265efaf1c78dea88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Typing context values requires Flow 0.70 or later.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 컨텍스트 값을 입력하려면 Flow 0.70 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0963a4d340e3fcd46ba3fd94010ce7b45a5555b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Watch out for comments! Take the following:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 의견을 조심 &lt;strong&gt;하십시오&lt;/strong&gt; ! 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c19727e7a33fbaf5adc662298c963e80689873d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Watch out for whitespace! Take the following:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 공백을 조심 &lt;strong&gt;하십시오&lt;/strong&gt; ! 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cdf1510cc13fa0938c540a829729b695b1f7fe47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We import &lt;code&gt;React&lt;/code&gt; as a namespace here with &lt;code&gt;import * as React from 'react'&lt;/code&gt; instead of as a default with &lt;code&gt;import React from 'react'&lt;/code&gt;. When importing React as an ES module you may use either style, but importing as a namespace gives you access to React&amp;rsquo;s &lt;a href=&quot;../types&quot;&gt;utility types&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 우리는 가져 &lt;code&gt;React&lt;/code&gt; 여기있는 네임 스페이스 &lt;code&gt;import * as React from 'react'&lt;/code&gt; 대신에 기본값으로의 &lt;code&gt;import React from 'react'&lt;/code&gt; . React를 ES 모듈로 가져올 때 두 가지 스타일 중 하나를 사용할 수 있지만 네임 스페이스로 가져 오면 React의 &lt;a href=&quot;../types&quot;&gt;유틸리티 유형에&lt;/a&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ec9e52dafaf04b0fca35e642b34088ae3ccf8ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We&amp;rsquo;re going to go through a stripped down example for demonstrating how to make use of type cast expressions. This example is not solved well in practice.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 유형 캐스트 ​​표현식을 사용하는 방법을 보여주기 위해 제거 된 예제를 살펴 보겠습니다. 이 예제는 실제로 잘 해결되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="13714a09cafc3db44b0f21e686d8c767ffcc7bcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; While importing React with a default import works:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 가져 오는 동안 기본 가져 오기로 React를 작동합니다.</target>
        </trans-unit>
        <trans-unit id="66a1c90af7e35b36d5177b1f056c71e3827448ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;module.name_mapper.extension&lt;/code&gt; multiple times for different extensions.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다른 확장자에 대해 &lt;code&gt;module.name_mapper.extension&lt;/code&gt; 을 여러 번 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e953a25a8164a088aa27a99871bd1034fa4f7aa5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;sharedmemory.dirs&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;sharedmemory.dirs&lt;/code&gt; 를 여러 번 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cad40a5701acf5649fe5798b08c924b1a91443a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;suppress_comment&lt;/code&gt; multiple times. If you do define any &lt;code&gt;suppress_comment&lt;/code&gt;s, the built-in &lt;code&gt;$FlowFixMe&lt;/code&gt; suppression will be erased in favor of the regexps you specify. If you wish to use &lt;code&gt;$FlowFixMe&lt;/code&gt; with some additional custom suppression comments, you must manually specify &lt;code&gt;\\(.\\|\n\\)*\\$FlowFixMe&lt;/code&gt; in your custom list of suppressions.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;suppress_comment&lt;/code&gt; 를 여러 번 지정할 수 있습니다 . &lt;code&gt;suppress_comment&lt;/code&gt; 를 정의하면 &lt;code&gt;$FlowFixMe&lt;/code&gt; 위해 내장 $ FlowFixMe 억제가 지워집니다. 추가 사용자 정의 억제 주석과 함께 &lt;code&gt;$FlowFixMe&lt;/code&gt; 를 사용하려면 사용자 정의 억제 목록에서 &lt;code&gt;\\(.\\|\n\\)*\\$FlowFixMe&lt;/code&gt; 를 수동으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b3ef30213691916dbfdadddd670829ca29768fca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can specify &lt;code&gt;suppress_type&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;suppress_type&lt;/code&gt; 을 여러 번 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="229ab2d563e326e0866c16c2ecaf54037d4f3e62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You don&amp;rsquo;t need to make &lt;code&gt;foo&lt;/code&gt; nullable in your &lt;code&gt;Props&lt;/code&gt; type. Flow will make sure that &lt;code&gt;foo&lt;/code&gt; is optional if you have a default prop for &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;Props&lt;/code&gt; 유형 에서 &lt;code&gt;foo&lt;/code&gt; 를 nullable 로 만들 필요는 없습니다 . 흐름이 있는지 확인합니다 &lt;code&gt;foo&lt;/code&gt; 는이 당신에 대한 기본 소품이있는 경우 선택 사항입니다 &lt;code&gt;foo&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="a8dbdf0ca4a737e620de55f8736bb8082cbf733a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You need to use &lt;code&gt;import * as React from 'react'&lt;/code&gt; here instead of &lt;code&gt;import React from 'react'&lt;/code&gt; to get access to the &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; type. We explain why that is in the &lt;a href=&quot;../types&quot;&gt;React Type Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 유형에 액세스하려면 &lt;code&gt;import React from 'react'&lt;/code&gt; 대신 &lt;code&gt;import * as React from 'react'&lt;/code&gt; 를 사용해야 합니다. 우리는 그것이 &lt;a href=&quot;../types&quot;&gt;React Type Reference&lt;/a&gt; 에있는 이유를 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="e4e73965c0849c76958d2605758705535cf6dda6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You&amp;rsquo;ll probably want to add a &lt;code&gt;prepublish&lt;/code&gt; script that runs this transform as well, so that it runs before you publish your code to the npm registry.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 당신은 아마 추가 할 수 있습니다 &lt;code&gt;prepublish&lt;/code&gt; 당신이 NPM 레지스트리에 코드를 게시하기 전에 실행 그래서,이뿐만 아니라 변환 실행 스크립트를.</target>
        </trans-unit>
        <trans-unit id="d0d8dc4eae5a24d3928bd38400456f9cbe5313d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.file_ext&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;module.file_ext&lt;/code&gt; 를 여러 번 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="277f1b76997cbec25e723aaaf5fe3c78b6b009ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.name_mapper&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;module.name_mapper&lt;/code&gt; 를 여러 번 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0cf4d9235824eed02c46e2f1d98a8ce97a15b5b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can specify &lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt; multiple times</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;module.system.node.resolve_dirname&lt;/code&gt; 을 여러 번 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fd3867675ccb5b52461008d6e03fb348c8a53b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Special thanks to&lt;/strong&gt;: &lt;a href=&quot;https://github.com/jareware&quot;&gt;Jarno Rantanen&lt;/a&gt; for building &lt;a href=&quot;https://github.com/jareware/flotate&quot;&gt;flotate&lt;/a&gt; and supporting us merging his syntax upstream into Flow.</source>
          <target state="translated">&lt;strong&gt;특별 감사&lt;/strong&gt; : &lt;a href=&quot;https://github.com/jareware&quot;&gt;르노 Rantanen&lt;/a&gt; 구축을위한 &lt;a href=&quot;https://github.com/jareware/flotate&quot;&gt;flotate을&lt;/a&gt; 우리가 흐름에 자신의 구문 상류를 통합 지원.</target>
        </trans-unit>
        <trans-unit id="01a48fcac72977e1bf1c5fb03ed59c9380790e6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Try to provide a libdef for each third-party library your project uses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로젝트에서 사용하는 각 타사 라이브러리에 대해 libdef를 제공하십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f43a1aec0402c2b241ef1d914c61cefd59f011c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unchecked files&lt;/strong&gt;. All other files.</source>
          <target state="translated">&lt;strong&gt;확인되지 않은 파일&lt;/strong&gt; . 다른 모든 파일.</target>
        </trans-unit>
        <trans-unit id="a874bf28f6bc203a4ab83ee91607e029bb99dfcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do not mistake &lt;code&gt;any&lt;/code&gt; with &lt;code&gt;mixed&lt;/code&gt;. &lt;a href=&quot;../mixed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 오해하지 마십시오 &lt;code&gt;any&lt;/code&gt; 함께 &lt;code&gt;mixed&lt;/code&gt; . &lt;a href=&quot;../mixed&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cc4bce83d85500a6f45865d989cce18fc4a43ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Flow does not infer generic types. If you want something to have a generic type, &lt;strong&gt;annotate it&lt;/strong&gt;. Otherwise, Flow may infer a type that is less polymorphic than you expect.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 흐름은 일반 유형을 유추하지 않습니다. 무언가가 제네릭 형식을 가지려면 &lt;strong&gt;주석을 달 수&lt;/strong&gt; 있습니다. 그렇지 않으면 흐름이 예상보다 다형성이 적은 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a280dc6a74b332873e229283e81f56eb6ccce4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; For performance purposes, we always recommend you annotate with concrete arguments when you can. &lt;code&gt;_&lt;/code&gt; is not unsafe, but it is slower than explicitly specifying the type arguments.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 성능을 위해 가능한 한 구체적 인수로 주석을 달 것을 권장합니다. &lt;code&gt;_&lt;/code&gt; 는 안전하지 않지만 명시 적으로 형식 인수를 지정하는 것보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="31f870561ad37a87582f2c7ee2fa8398d4fae0b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Watchman lazy mode&lt;/strong&gt;. When starting up, Flow treats any file as focused if it has changed since the mergebase with master (the common ancestor of the current commit and the master branch). Any subsequent file that changes is also focused. After a rebase which changes the mergebase, Flow may restart the server if it estimates that a restart is faster than a recheck.</source>
          <target state="translated">&lt;strong&gt;경비원 게으른 모드&lt;/strong&gt; . 시작할 때 Flow는 master (현재 커밋 및 마스터 브랜치의 공통 조상)와의 병합베이스 이후에 변경된 파일을 포커스 된 것으로 간주합니다. 이후에 변경되는 모든 파일에도 초점이 맞춰집니다. 병합베이스를 변경하는 리베이스 후 재시작이 재확인보다 빠르다고 판단되면 Flow가 서버를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b4924a0b182cfffbd184b94a6565475c510c1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;error:&lt;/strong&gt; Lints with severity &lt;code&gt;error&lt;/code&gt; are treated exactly the same as any other Flow error.</source>
          <target state="translated">&lt;strong&gt;error :&lt;/strong&gt; 심각도 &lt;code&gt;error&lt;/code&gt; 가있는 보풀은 다른 흐름 오류와 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="1a03a729136b36f5838887b635904e593801ed41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/myLibDef.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/myLibDef.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e33c8943ab39266d98f3fccd3a3499ba35474f73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/some-commonjs-module.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/some-commonjs-module.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bddb02bd60e0167f1a6757b72ddc9ab8cccab64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flow-typed/some-es-module.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flow-typed/some-es-module.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f98671d24b241f481d2118b0f7963a30771b5ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;off:&lt;/strong&gt; The lint is ignored. Setting a lint to &lt;code&gt;off&lt;/code&gt; is similar to suppressing a type error with a suppression comment, except with much more granularity.</source>
          <target state="translated">&lt;strong&gt;꺼짐 :&lt;/strong&gt; 보풀이 무시됩니다. 보푸라기를 &lt;code&gt;off&lt;/code&gt; 것은 훨씬 세분화 된 점을 제외하고는 억제 주석으로 유형 오류를 억제하는 것과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d023c19a616c35ca9826c7a2ffac16870361f13d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over a block of code:&lt;/strong&gt; A pair of &lt;code&gt;flowlint&lt;/code&gt; comments can be used to apply a certain setting over a block of code. For example, to disabling the untyped-type-import lint over a block of type imports would look like this:</source>
          <target state="translated">&lt;strong&gt;코드 블록에 대한 설정 : &lt;/strong&gt; &lt;code&gt;flowlint&lt;/code&gt; 주석 쌍을 사용하여 코드 블록에 특정 설정을 적용 할 수 있습니다. 예를 들어, 유형 가져 오기 블록에서 유형이 지정되지 않은 가져 오기 보푸라기를 비활성화하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31146238339ea53d1542596a43e6ef00dc10cce7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over a file:&lt;/strong&gt; A &lt;code&gt;flowlint&lt;/code&gt; comment doesn&amp;rsquo;t have to have a matching comment to form a block. An unmatched comment simply applies its settings to the rest of the file. You could use this, for example, to suppress all sketchy-null-check lints in a particular file:</source>
          <target state="translated">&lt;strong&gt;파일을 통해 설정 :&lt;/strong&gt; 의 &lt;code&gt;flowlint&lt;/code&gt; 의 코멘트는 블록을 형성하기 위해 일치하는 코멘트를 할 필요가 없습니다. 일치하지 않는 주석은 설정을 파일의 나머지 부분에 적용합니다. 예를 들어, 특정 파일에서 모든 스케치 널 체크 보푸라기를 억제하기 위해 이것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa2579b9e2d9cbad84fbd5f31d89ceb484a456f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;settings over part of a line:&lt;/strong&gt; The settings applied by &lt;code&gt;flowlint&lt;/code&gt; start and end right at the comment itself. This means that you can do things like</source>
          <target state="translated">&lt;strong&gt;행의 일부에 대한&lt;/strong&gt; 설정 &lt;strong&gt;: &lt;/strong&gt; &lt;code&gt;flowlint&lt;/code&gt; 에 의해 적용된 설정 은 주석 자체에서 바로 시작하고 끝납니다. 이것은 당신이 같은 일을 할 수 있음을 의미합니다</target>
        </trans-unit>
        <trans-unit id="feb7c9b56545cc3391e09e0d2b8bd5709fa97489" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;warn:&lt;/strong&gt; Warnings are a new severity level introduced by the linting framework. They are treated differently than errors in a couple of ways:</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 경고는 linting 프레임 워크에서 도입 된 새로운 심각도 수준입니다. 그것들은 몇 가지 방식으로 오류와 다르게 취급됩니다 :</target>
        </trans-unit>
        <trans-unit id="8f637424e74ed1ebcadcdbadc0c7f23a162bdc46" translate="yes" xml:space="preserve">
          <source>@flow - Parse this file with Flow syntax allowed and typecheck it.</source>
          <target state="translated">@flow-흐름 구문이 허용 된 상태로이 파일을 구문 분석하고 유형을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dab817ff7a654e90ff5dd7173e93ea494624263b" translate="yes" xml:space="preserve">
          <source>@noflow - Parse this file with Flow syntax allowed and do not typecheck it. This is meant as an escape hatch to suppress Flow in a file without having to delete all the Flow-specific syntax.</source>
          <target state="translated">@noflow-흐름 구문이 허용 된 상태에서이 파일을 구문 분석하고 유형을 점검하지 마십시오. 이는 흐름 특정 구문을 모두 삭제하지 않고도 파일에서 흐름을 억제하는 이스케이프 해치입니다.</target>
        </trans-unit>
        <trans-unit id="d5517ef60c8c970054ed9b5ae5d4d8803202583f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; is the type at a given key &lt;code&gt;k&lt;/code&gt;. As of Flow v0.36.0, &lt;code&gt;k&lt;/code&gt; must be a literal string.</source>
          <target state="translated">&lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; 주어진 키의 타입 &lt;code&gt;k&lt;/code&gt; . Flow v0.36.0부터 &lt;code&gt;k&lt;/code&gt; 는 리터럴 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e7f5ef7659179e8cb5f3ac39ecffed44e573698" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Boolean&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new Boolean(x)&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 전역에 의해 생성 된 래퍼 객체이다 &lt;code&gt;new Boolean(x)&lt;/code&gt; 생성자.</target>
        </trans-unit>
        <trans-unit id="f4b4c1e23604a85feb14553cd867329fa18edcb9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Number&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new Number(x)&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; 전역에 의해 생성 된 래퍼 객체이다 &lt;code&gt;new Number(x)&lt;/code&gt; 생성자.</target>
        </trans-unit>
        <trans-unit id="7ff4f95a14f0f15fb91feaff17eb578d01d42954" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; takes a single type argument, &lt;code&gt;typeof Component&lt;/code&gt;. &lt;code&gt;typeof Component&lt;/code&gt; is the component type of the React element. For an intrinsic element, &lt;code&gt;typeof Component&lt;/code&gt; will be the string literal for the intrinsic you used. Here are a few examples with DOM intrinsics:</source>
          <target state="translated">&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; , 단일 유형의 인수를 &lt;code&gt;typeof Component&lt;/code&gt; . &lt;code&gt;typeof Component&lt;/code&gt; 는 React 요소의 구성 요소 유형입니다. 내장 요소의 경우 &lt;code&gt;typeof Component&lt;/code&gt; 는 사용한 내장 함수의 문자열 리터럴입니다. 다음은 DOM 내장 함수를 사용한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="3cc9f3a301444a49c02a8ccdf90391c3099669bb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper object created by the global &lt;code&gt;new String(x)&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 글로벌에 의해 생성 된 래퍼 객체 인 &lt;code&gt;new String(x)&lt;/code&gt; 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="1aa87ca478a9e8203d1f48b664ee80f4bde77cca" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;boolean&lt;/code&gt; is a literal value like &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; or the result of an expression like &lt;code&gt;a === b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 같은 리터럴 값 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 또는 같은 식의 결과 &lt;code&gt;a === b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eae9db4713f41ce51d4836cd52cd83cf66fe6bba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;flowlint-line&lt;/code&gt; comment works similarly to a &lt;code&gt;flowlint&lt;/code&gt; comment, except it only applies its settings to the current line instead of applying them for the rest of the file. The primary use for &lt;code&gt;flowlint-line&lt;/code&gt; comments is to suppress a lint on a particular line:</source>
          <target state="translated">&lt;code&gt;flowlint-line&lt;/code&gt; 코멘트는 비슷하게 작동 &lt;code&gt;flowlint&lt;/code&gt; 의 그것은 단지 파일의 나머지를 적용하는 대신 현재 행에 해당 설정을 적용 제외 코멘트. &lt;code&gt;flowlint-line&lt;/code&gt; 주석 의 주요 용도 는 특정 행에서 보푸라기를 억제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3dbdddd5ad4de5b2edfb46887933757af099bccf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;number&lt;/code&gt; is a literal value like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt; or the result of an expression like &lt;code&gt;parseFloat(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 등 리터럴 값 &lt;code&gt;42&lt;/code&gt; 또는 &lt;code&gt;3.14&lt;/code&gt; 또는 같은 식의 결과 &lt;code&gt;parseFloat(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="810376c88abf15447cb20ec803309eab84ccf149" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;string&lt;/code&gt; is a literal value like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or the result of an expression like &lt;code&gt;&quot;&quot; + 42&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 등 리터럴 값 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 또는 같은 식의 결과 &lt;code&gt;&quot;&quot; + 42&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a442d2c56258fa63e09bdf1e3922431ce6755c" translate="yes" xml:space="preserve">
          <source>A React children array can be a single value or an array nested to any level. It is designed to be used with the &lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactchildren&quot;&gt;&lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt;.</source>
          <target state="translated">React children 배열은 단일 값이거나 모든 레벨에 중첩 된 배열 일 수 있습니다. &lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactchildren&quot;&gt; &lt;code&gt;React.Children&lt;/code&gt; API&lt;/a&gt; 와 함께 사용하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1ac20284b90912b5ee342718a932002c471e7063" translate="yes" xml:space="preserve">
          <source>A React element is the type for the value of a JSX element:</source>
          <target state="translated">React 요소는 JSX 요소 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5d4c2e7721c9d46456be0ebe1e112134378df4c1" translate="yes" xml:space="preserve">
          <source>A class or function component with config &lt;code&gt;Config&lt;/code&gt; may be used in places that expect &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">config &lt;code&gt;Config&lt;/code&gt; 가있는 클래스 또는 함수 구성 요소는 &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; 위치에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c97c303f1555df5edf4bfe277f9d6c3317ef0a7" translate="yes" xml:space="preserve">
          <source>A common use case for higher-order components is to inject a prop. The HOC automatically sets a prop and returns a component which no longer requires that prop. For example, consider a navigation prop, or in the case of &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;react-redux&lt;/code&gt; a &lt;code&gt;store&lt;/code&gt; prop&lt;/a&gt;. How would one type this?</source>
          <target state="translated">고차 부품의 일반적인 사용 사례는 소품을 주입하는 것입니다. HOC는 자동으로 소품을 설정하고 해당 소품이 더 이상 필요없는 구성 요소를 반환합니다. 예를 들어, 내비게이션 소품 또는 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;react-redux&lt;/code&gt; 의 경우 &lt;code&gt;store&lt;/code&gt; 소품을 고려하십시오&lt;/a&gt; . 어떻게 이것을 입력합니까?</target>
        </trans-unit>
        <trans-unit id="30dbf123853c4a0e8c3631a140f89f123c49780e" translate="yes" xml:space="preserve">
          <source>A libdef is a special file that informs Flow about the type signature of some specific third-party module or package of modules that your application uses. If you&amp;rsquo;re familiar with languages that have header files (like &lt;code&gt;C++&lt;/code&gt;), you can think of libdefs as a similar concept.</source>
          <target state="translated">libdef는 응용 프로그램에서 사용하는 특정 타사 모듈 또는 모듈 패키지의 형식 서명에 대해 Flow에 알리는 특수 파일입니다. &lt;code&gt;C++&lt;/code&gt; 과 같은 헤더 파일이있는 언어에 익숙하다면 libdef를 비슷한 개념으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca822c818a1e02043f7fd8c1f3e2121e587ff173" translate="yes" xml:space="preserve">
          <source>A popular pattern in React is the &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;higher-order component pattern&lt;/a&gt;, so it&amp;rsquo;s important that we can provide effective types for higher-order components in Flow. If you don&amp;rsquo;t already know what a higher-order component is then make sure to read the &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;React documentation on higher-order components&lt;/a&gt; before continuing.</source>
          <target state="translated">React에서 많이 사용되는 패턴은 &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;고차 컴포넌트 패턴&lt;/a&gt; 이므로 Flow에서 고차 컴포넌트에 효과적인 유형을 제공 할 수 있어야합니다. 상위 컴포넌트가 무엇인지 모르는 경우 계속하기 전에 &lt;a href=&quot;https://facebook.github.io/react/docs/higher-order-components.html&quot;&gt;상위 컴포넌트에&lt;/a&gt; 대한 React 문서 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2f8e9dfe25e3835aaff6cc6ecae3f02d157188cb" translate="yes" xml:space="preserve">
          <source>A static type checker uses either the names or the structure of the types in order to compare them against other types. Checking against the name is nominal typing and checking against the structure is structural typing.</source>
          <target state="translated">정적 형식 검사기는 다른 형식과 비교하기 위해 형식의 이름 또는 구조를 사용합니다. 이름을 확인하는 것은 명목상의 타이핑이고 구조를 확인하는 것은 구조적 타이핑입니다.</target>
        </trans-unit>
        <trans-unit id="671a4ff4e804eebb070be2fc14388832f1511e9d" translate="yes" xml:space="preserve">
          <source>A type is something like a string, a boolean, an object, or a class. They have names and they have structures. Primitives like strings or booleans have a very simple structure and only go by one name.</source>
          <target state="translated">유형은 문자열, 부울, 객체 또는 클래스와 같은 것입니다. 그들은 이름과 구조를 가지고 있습니다. 문자열 또는 부울과 같은 기본 요소는 매우 간단한 구조를 가지며 하나의 이름 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="41848119547f63e0f0117b445db59a03ebf4ba0e" translate="yes" xml:space="preserve">
          <source>A type like &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt; describes a set of possible values. A &lt;code&gt;number&lt;/code&gt; describes every possible number, so a single number (such as &lt;code&gt;42&lt;/code&gt;) would be a &lt;em&gt;subtype&lt;/em&gt; of the &lt;code&gt;number&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 과 같은 유형 은 가능한 값 세트를 설명합니다. &lt;code&gt;number&lt;/code&gt; (예컨대 단수 있도록 모든 가능한 수를 나타낸다 &lt;code&gt;42&lt;/code&gt; )가 될 것이다 &lt;em&gt;아형&lt;/em&gt; 의 &lt;code&gt;number&lt;/code&gt; 타입.</target>
        </trans-unit>
        <trans-unit id="084f378a5689bc62abec28cce79f808d15cc2701" translate="yes" xml:space="preserve">
          <source>A variable of type &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is some object type, can be assigned objects &lt;code&gt;o&lt;/code&gt; that contain a subset of the properties included in &lt;code&gt;T&lt;/code&gt;. For each property &lt;code&gt;p: S&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the type of a potential binding of &lt;code&gt;p&lt;/code&gt; in &lt;code&gt;o&lt;/code&gt; must be compatible with &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">타입의 변수 &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;T&lt;/code&gt; 는 어떤 오브젝트 타입, 할당 할 수있는 개체는 &lt;code&gt;o&lt;/code&gt; 그 내에 포함 된 속성의 부분 집합 포함 &lt;code&gt;T&lt;/code&gt; 를 . 각 속성의 경우 &lt;code&gt;p: S&lt;/code&gt; 의 &lt;code&gt;T&lt;/code&gt; , 결합 전위의 타입 &lt;code&gt;p&lt;/code&gt; 에 &lt;code&gt;o&lt;/code&gt; 와 호환되어야 &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2271b14edc45904cc47bb0f92baf4a74500757a6" translate="yes" xml:space="preserve">
          <source>ALE</source>
          <target state="translated">ALE</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="c2c9357e2d1358b4ed63794b3bdbb571d911a366" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;@flow strict&lt;/code&gt; to a file and fix all errors that appear. Because Flow Strict requires dependencies to also be strict (if the &lt;code&gt;nonstrict-import&lt;/code&gt; rule is enabled), start at the leaves of the dependency tree and work up from there. Do not add &lt;code&gt;$FlowFixMe&lt;/code&gt; to suppress the new errors as they appear; just add &lt;code&gt;@flow strict&lt;/code&gt; once all issues have been resolved. Since the most common reasons for using &lt;code&gt;$FlowFixMe&lt;/code&gt; stem from reliance on untyped dependencies or behavior, future issues should be greatly reduced once Flow Strict is enabled.</source>
          <target state="translated">&lt;code&gt;@flow strict&lt;/code&gt; 를 파일에 추가 하고 나타나는 모든 오류를 수정하십시오. Flow Strict를 사용하려면 종속성도 엄격해야합니다 ( &lt;code&gt;nonstrict-import&lt;/code&gt; 규칙이 활성화 된 경우). 종속성 트리의 잎에서 시작하여 거기서부터 작업하십시오. 새 오류가 표시 될 때 &lt;code&gt;$FlowFixMe&lt;/code&gt; 를 추가하지 마십시오 . 모든 문제가 해결되면 &lt;code&gt;@flow strict&lt;/code&gt; 를 추가하십시오 . &lt;code&gt;$FlowFixMe&lt;/code&gt; 를 사용하는 가장 일반적인 이유는 유형이 지정되지 않은 종속성이나 동작에 의존하기 때문에 Flow Strict를 사용하도록 설정하면 향후 문제를 크게 줄여야합니다.</target>
        </trans-unit>
        <trans-unit id="348f08f4c30937769280d29589632be81dce564d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;[strict]&lt;/code&gt; section to the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[strict]&lt;/code&gt; 섹션을 &lt;code&gt;.flowconfig&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="debff0c0e31df0c3b54bd63967abba908318fd7b" translate="yes" xml:space="preserve">
          <source>Add this to your ~/.vimrc</source>
          <target state="translated">이것을 ~ / .vimrc에 추가하십시오</target>
        </trans-unit>
        <trans-unit id="ef87c5c8a2b16d4c56ca61522bd746bf5ccd2856" translate="yes" xml:space="preserve">
          <source>Adding Flow types to your React components is incredibly powerful. After typing your component, Flow will statically ensure that you are using the component in the way it was designed to be used.</source>
          <target state="translated">React 컴포넌트에 플로우 유형을 추가하는 것은 매우 강력합니다. 구성 요소를 입력하면 Flow는 구성 요소를 사용하도록 설계된 방식으로 정적으로 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ce3f0d181c2f06a4552c99e371dfc2c79d5925f9" translate="yes" xml:space="preserve">
          <source>Adding State</source>
          <target state="translated">상태 추가</target>
        </trans-unit>
        <trans-unit id="3bfb8073e6bb1f0689467760321027edeffeb0e7" translate="yes" xml:space="preserve">
          <source>Adding defaults to parameterized generics</source>
          <target state="translated">매개 변수화 된 제네릭에 기본값 추가</target>
        </trans-unit>
        <trans-unit id="24102cd54654562a4cca3094ba42e1695bfc0400" translate="yes" xml:space="preserve">
          <source>Adding type annotations is an important part of your interaction with Flow.</source>
          <target state="translated">유형 주석 추가는 Flow와의 상호 작용에서 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="dd4b16fc77256848662e64369cda76926181fdf0" translate="yes" xml:space="preserve">
          <source>Adding types to generics</source>
          <target state="translated">제네릭에 형식 추가</target>
        </trans-unit>
        <trans-unit id="c46c2e1f44bf89eeaca616b1006a75c2f1f9f078" translate="yes" xml:space="preserve">
          <source>Additionally, note that function parameters are considered const (i.e., treated as if they were declared with &lt;code&gt;const&lt;/code&gt; rather than &lt;code&gt;let&lt;/code&gt;). This feature is not yet configurable in Flow Strict; it is always on.</source>
          <target state="translated">또한 함수 매개 변수는 const로 간주됩니다 (즉, &lt;code&gt;let&lt;/code&gt; 대신 &lt;code&gt;const&lt;/code&gt; 로 선언 된 것처럼 처리됨 ). Flow Strict에서는이 기능을 아직 구성 할 수 없습니다. 항상 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="084523950d9700bad04af812baabda38d1775c92" translate="yes" xml:space="preserve">
          <source>Additionally, one of the things that also makes &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; more powerful than &lt;a href=&quot;#toc-propertytype&quot;&gt;&lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt;&lt;/a&gt; is that you can use it with generics. For example:</source>
          <target state="translated">또한 &lt;a href=&quot;#toc-propertytype&quot;&gt; &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; &lt;/a&gt; 보다 $ &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 더 강력 하게 만드는 것 중 하나는 제네릭과 함께 사용할 수 있다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9a588006a751b6eac3899c1c33719e0d1f574b8" translate="yes" xml:space="preserve">
          <source>Additionally, other utility types, such as &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, may strip any read/write annotations, so &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; is a handy way to quickly make the object read-only again after operating on it:</source>
          <target state="translated">또한 &lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 같은 다른 유틸리티 유형 은 모든 읽기 / 쓰기 주석을 제거 할 수 있으므로 &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; 는 오브젝트를 조작 한 후 오브젝트를 다시 읽기 전용으로 빠르게 만들 수있는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9165abaadf3796191a41d4c4e2ff7bee612bceba" translate="yes" xml:space="preserve">
          <source>Adds completions to omnifunc</source>
          <target state="translated">omnifunc에 완성을 추가합니다</target>
        </trans-unit>
        <trans-unit id="9d9855d155abfb00319d620ad3008e951f075bcb" translate="yes" xml:space="preserve">
          <source>Adoption</source>
          <target state="translated">Adoption</target>
        </trans-unit>
        <trans-unit id="7823f6ab865766bbd1127e26841e44993df0966b" translate="yes" xml:space="preserve">
          <source>Again, if you import React with: &lt;code&gt;import React from 'react'&lt;/code&gt; you will be able to access &lt;code&gt;React.Component&lt;/code&gt;, &lt;code&gt;React.createElement()&lt;/code&gt;, &lt;code&gt;React.Children&lt;/code&gt;, and other JavaScript &lt;em&gt;values&lt;/em&gt;. However, you will not be able to access &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&lt;/code&gt;&lt;/a&gt; or other Flow &lt;em&gt;types&lt;/em&gt;. You will need to use a named type import like: &lt;code&gt;import type {Node} from 'react'&lt;/code&gt; in addition to your default import.</source>
          <target state="translated">다시 React를 가져 오면 &lt;code&gt;import React from 'react'&lt;/code&gt; 하면 &lt;code&gt;React.Component&lt;/code&gt; , &lt;code&gt;React.createElement()&lt;/code&gt; , &lt;code&gt;React.Children&lt;/code&gt; 및 기타 JavaScript &lt;em&gt;값&lt;/em&gt; 에 액세스 할 수 &lt;em&gt;있습니다&lt;/em&gt; . 그러나 &lt;a href=&quot;#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&lt;/code&gt; &lt;/a&gt; 또는 기타 플로우 &lt;em&gt;유형&lt;/em&gt; 에는 액세스 할 수 없습니다 . 기본 가져 오기 외에도 &lt;code&gt;import type {Node} from 'react'&lt;/code&gt; 에서 import type {Node} 와 같은 이름 지정된 유형 가져 오기를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6960f0d48dae2ed291e229a0c18667430af5ad7c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;react-dom&lt;/code&gt; JSX intrinsics have &lt;code&gt;React.Node&lt;/code&gt; as their children type. &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;, and all the rest.</source>
          <target state="translated">모든 &lt;code&gt;react-dom&lt;/code&gt; JSX 내장 함수는 자식 유형으로 &lt;code&gt;React.Node&lt;/code&gt; 를 갖 습니다 . &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 및 나머지는 모두</target>
        </trans-unit>
        <trans-unit id="ca3d3759b20a58e23b6e490416571783c4b57d09" translate="yes" xml:space="preserve">
          <source>All of these different expressions create a new type which is a result of the types of values and the operations run on them.</source>
          <target state="translated">이러한 모든 다른 표현식은 값 유형과 그에 대한 연산의 결과 인 새로운 유형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0f113e33ce14591dd70d6193beb553131d41f5f0" translate="yes" xml:space="preserve">
          <source>All of this is why Flow has contravariant inputs (accepts less specific types to be passed in), and covariant outputs (allows more specific types to be returned).</source>
          <target state="translated">이 모든 것이 Flow에 반 변형 입력 (더 적은 특정 유형을 전달할 수 있음)과 공변량 출력 (더 구체적인 유형을 리턴 할 수 있음)이있는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="f47b935eb4737e5a19c994e524b19f17133d6b8b" translate="yes" xml:space="preserve">
          <source>Also a tuple type cannot be passed into to an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type, since then you could mutate the tuple in an unsafe way.</source>
          <target state="translated">또한 튜플 유형을 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 유형 으로 전달할 수 없습니다. 그 때문에 안전하지 않은 방법으로 튜플을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e224fe065210d7ea5bc4ecdfb975d62ba96cb27" translate="yes" xml:space="preserve">
          <source>Also recommended, but optional as it may be too noisy in some codebases: &lt;code&gt;sketchy-null&lt;/code&gt;</source>
          <target state="translated">또한 권장하지만, 일부 코드베이스에서 너무 시끄러울 수 있으므로 선택 사항입니다 : &lt;code&gt;sketchy-null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6650e3d7dff1ebe1979e6edf742206dcb5d30b21" translate="yes" xml:space="preserve">
          <source>Also, a longer tuple can&amp;rsquo;t be used in place of a shorter one.</source>
          <target state="translated">또한 짧은 튜플 대신 더 긴 튜플을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed76d08a5750c0ac19262fa4c88e1912b27bd2c6" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;../config/options#toc-lazy-mode-fs-ide-watchman-none&quot;&gt;you can set the lazy mode from the &lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;../config/options#toc-lazy-mode-fs-ide-watchman-none&quot;&gt; &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt; 에서 지연 모드를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c66bd79d3d4ffdc185a7185952761a2c8c3f10" translate="yes" xml:space="preserve">
          <source>Alternatively, the legacy &lt;a href=&quot;#toc-vim-flow&quot;&gt;vim-flow&lt;/a&gt; extension is Flow-specific, and provides fewer features.</source>
          <target state="translated">또는 레거시 &lt;a href=&quot;#toc-vim-flow&quot;&gt;vim-flow&lt;/a&gt; 확장은 흐름에 따라 다르며 더 적은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05c96e450e44289cd41c687e74cce15c9214f0aa" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[declarations]&lt;/code&gt; section might look like:</source>
          <target state="translated">예제 &lt;code&gt;[declarations]&lt;/code&gt; 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90be5ce7c515603e4e6a07b492b34ad2c170d26e" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[ignore]&lt;/code&gt; section might look like:</source>
          <target state="translated">&lt;code&gt;[ignore]&lt;/code&gt; 섹션 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63ef3849ebab36d15f3096be1da4ba961dfdabbb" translate="yes" xml:space="preserve">
          <source>An example &lt;code&gt;[untyped]&lt;/code&gt; section might look like:</source>
          <target state="translated">&lt;code&gt;[untyped]&lt;/code&gt; 섹션 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c58b06aa29f634eb5b80b5c46b1dd5e2a95f3710" translate="yes" xml:space="preserve">
          <source>An important attribute of every type system is whether they are structural or nominal, they can even be mixed within a single type system. So it&amp;rsquo;s important to know the difference.</source>
          <target state="translated">모든 유형 시스템의 중요한 특성은 구조적이든 명 목적이든 단일 유형 시스템 내에서 혼합 될 수 있다는 것입니다. 차이점을 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7534a2c6b02aff918f4734ba9f0cb833213dab75" translate="yes" xml:space="preserve">
          <source>An indexer can be optionally named, for documentation purposes:</source>
          <target state="translated">문서화 목적으로 인덱서를 선택적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f5dca0f3fb11ce7b28ee592bf4f726a45875a4" translate="yes" xml:space="preserve">
          <source>And that is it. Your project is now Flow-enabled.</source>
          <target state="translated">그게 다야. 이제 프로젝트가 흐름 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bc97cb67c24efbdbd68974b88a3db4e9f3a4fc10" translate="yes" xml:space="preserve">
          <source>And use:</source>
          <target state="translated">그리고 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="8b778ae534c485f0d6739866e99f8bc63e2331d8" translate="yes" xml:space="preserve">
          <source>Another way to add support for Flow in Vim is to use &lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt;.</source>
          <target state="translated">Vim에서 Flow에 대한 지원을 추가하는 또 다른 방법은 &lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c37c50bfab9118a52fdf0a7f80769cc4ab540351" translate="yes" xml:space="preserve">
          <source>Another way to add support for Flow in Vim is to use &lt;a href=&quot;https://github.com/flowtype/vim-flow&quot;&gt;vim-flow&lt;/a&gt;.</source>
          <target state="translated">Flow in Vim에 대한 지원을 추가하는 또 다른 방법은 &lt;a href=&quot;https://github.com/flowtype/vim-flow&quot;&gt;vim-flow&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="92210bddb4211d0e6c83515a4f9b3f1b1a7a39c8" translate="yes" xml:space="preserve">
          <source>Any Types</source>
          <target state="translated">모든 유형</target>
        </trans-unit>
        <trans-unit id="d75e5f7ff95f6863097f6d1ec2a9d80aba28a579" translate="yes" xml:space="preserve">
          <source>Any directory under &lt;code&gt;/path/to/otherProject&lt;/code&gt; named &lt;code&gt;coolStuff/&lt;/code&gt;</source>
          <target state="translated">아래의 디렉토리 &lt;code&gt;/path/to/otherProject&lt;/code&gt; 이름 &lt;code&gt;coolStuff/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e3d4ca42d4885ee40721656532f3228027ab154" translate="yes" xml:space="preserve">
          <source>Any file in &lt;code&gt;/path/to/otherProject/&lt;/code&gt; that ends in &lt;code&gt;.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 로 끝나는 &lt;code&gt;/path/to/otherProject/&lt;/code&gt; 모든 파일</target>
        </trans-unit>
        <trans-unit id="ff45287734d6e5c2d42e27a8403e84e9cdd43925" translate="yes" xml:space="preserve">
          <source>Any file or directory under &lt;code&gt;.*/src/foo&lt;/code&gt; or under &lt;code&gt;.*/src/bar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.*/src/foo&lt;/code&gt; 또는 &lt;code&gt;.*/src/bar&lt;/code&gt; 아래에있는 파일 또는 디렉토리</target>
        </trans-unit>
        <trans-unit id="619cdeb72fa14a27c15ad77831a5eef22d615f19" translate="yes" xml:space="preserve">
          <source>Any file or directory under a directory named &lt;code&gt;__tests__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__tests__&lt;/code&gt; 라는 디렉토리에있는 모든 파일 또는 디렉토리</target>
        </trans-unit>
        <trans-unit id="0c3253b58f788b30811429ab97032f8e98a1859d" translate="yes" xml:space="preserve">
          <source>Any file or directory under a directory named &lt;code&gt;third_party&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;third_party&lt;/code&gt; 라는 디렉토리에있는 모든 파일 또는 디렉토리</target>
        </trans-unit>
        <trans-unit id="7cc44198b1e6e1b795a7e8aa32c3da295d676830" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.decl.js&lt;/code&gt;</source>
          <target state="translated">확장자가 &lt;code&gt;.decl.js&lt;/code&gt; 로 끝나는 모든 파일</target>
        </trans-unit>
        <trans-unit id="1bffc382d25466b833b5b2837da78952a00737fd" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.ignore.js&lt;/code&gt;</source>
          <target state="translated">확장자가 &lt;code&gt;.ignore.js&lt;/code&gt; 로 끝나는 모든 파일</target>
        </trans-unit>
        <trans-unit id="f72b4d45c679b8fd5b66d19514cb30c2b70941fd" translate="yes" xml:space="preserve">
          <source>Any file that ends with the extension &lt;code&gt;.untype.js&lt;/code&gt;</source>
          <target state="translated">확장자가 &lt;code&gt;.untype.js&lt;/code&gt; 로 끝나는 모든 파일</target>
        </trans-unit>
        <trans-unit id="d8058d8ae00a7724bf520d87b91a727d4fba9de4" translate="yes" xml:space="preserve">
          <source>Any options that are omitted will use their default values. Some options can be overridden with command line flags.</source>
          <target state="translated">생략 된 옵션은 기본값을 사용합니다. 명령 행 플래그로 일부 옵션을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="158d7a05937714067b015b61e36e2e34b536b32d" translate="yes" xml:space="preserve">
          <source>Any type can appear as the super type or type of an opaque type alias.</source>
          <target state="translated">모든 유형은 수퍼 유형 또는 불투명 유형 별명의 유형으로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b9550f4f85978cbf264304833e5597e61caa6b" translate="yes" xml:space="preserve">
          <source>Any type can appear inside a type alias.</source>
          <target state="translated">모든 유형은 유형 별칭 안에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8269fc02f1c810c6ff4db59298ada4596018447" translate="yes" xml:space="preserve">
          <source>Anything goes in, Nothing comes out</source>
          <target state="translated">아무것도 들어 가지 않아요, 아무것도 나오지 않습니다</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="83c584ea41caf5a381449f3d3b97037f78283560" translate="yes" xml:space="preserve">
          <source>Array access is unsafe</source>
          <target state="translated">배열 액세스가 안전하지 않습니다</target>
        </trans-unit>
        <trans-unit id="3170d1b3f6bc73372a7270faffd2e78add925812" translate="yes" xml:space="preserve">
          <source>Arrays are a special list-like type of object in JavaScript. You can create arrays a couple different ways.</source>
          <target state="translated">배열은 JavaScript에서 목록과 같은 특수한 유형의 객체입니다. 몇 가지 다른 방법으로 배열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eff12655bfd37e8aba34fc4ce9e8a7b43bbf939" translate="yes" xml:space="preserve">
          <source>Arrow Functions</source>
          <target state="translated">화살표 기능</target>
        </trans-unit>
        <trans-unit id="9deec36383ee4f0d0aa3b179bc68ebbe9f7b8c48" translate="yes" xml:space="preserve">
          <source>As Flow gets smarter and smarter, it will figure out the types of properties in more scenarios.</source>
          <target state="translated">Flow가 더욱 스마트 해지고 스마트 해짐에 따라 더 많은 시나리오에서 속성 유형을 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ce04ebbe35f0d095625abc02e93781430c8c957" translate="yes" xml:space="preserve">
          <source>As Flow gets smarter and smarter, there should be fewer instances of these scenarios.</source>
          <target state="translated">Flow가 더욱 스마트 해지고 스마트 해짐에 따라 이러한 시나리오의 인스턴스는 더 적어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc029ffe889a5bffa6b1132bfb40c2eb845b9647" translate="yes" xml:space="preserve">
          <source>As Flow is made to be smarter it may be possible in the future to fix this problem, but for now you should be aware of it.</source>
          <target state="translated">Flow가 더 똑똑 해짐에 따라 앞으로이 문제를 해결하는 것이 가능할 수도 있지만 현재로서는이를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="afba3e48afe0dd342bba029cc69e818d6ff61285" translate="yes" xml:space="preserve">
          <source>As a motivating example, consider this common idiom in React:</source>
          <target state="translated">동기 부여 사례로 React에서이 일반적인 관용구를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d994c8247e9b514f90a5e611ee46421248799ee9" translate="yes" xml:space="preserve">
          <source>As a result of having weak dynamic typing, JavaScript doesn&amp;rsquo;t have any of these, you can use any type at any time.</source>
          <target state="translated">동적 타이핑이 약하기 때문에 JavaScript에는 이러한 유형이 없으므로 언제든지 모든 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede9cdf7589df1689a4530c061cb9167ab6ff6e9" translate="yes" xml:space="preserve">
          <source>As a workaround, you can specify the property not present in &lt;code&gt;A&lt;/code&gt; as optional. For example:</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;A&lt;/code&gt; 에 없는 속성 을 선택 사항으로 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="668bad0a3b1e2602a10cbca6af8ca3251f27e688" translate="yes" xml:space="preserve">
          <source>As an example, this would not work:</source>
          <target state="translated">예를 들어, 이것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b11d09cc159c523df3005c0738393c9419eb41da" translate="yes" xml:space="preserve">
          <source>As explained in the &lt;a href=&quot;options&quot;&gt;&lt;code&gt;sharedmemory.dirs&lt;/code&gt;&lt;/a&gt; option&amp;rsquo;s description, Flow needs to create a file on a filesystem for older kernels. &lt;code&gt;sharedmemory.dirs&lt;/code&gt; specifies a list of locations where the shared memory file can be created. For each location, Flow will check to make sure the filesystem has enough space for the shared memory file. If Flow will likely run out of space, it skips that location and tries the next. This option lets you configure the minimum amount of space needed on a filesystem for shared memory.</source>
          <target state="translated">&lt;a href=&quot;options&quot;&gt; &lt;code&gt;sharedmemory.dirs&lt;/code&gt; &lt;/a&gt; 옵션 설명에 설명 된대로 Flow는 이전 커널의 파일 시스템에 파일을 작성해야합니다. &lt;code&gt;sharedmemory.dirs&lt;/code&gt; 는 공유 메모리 파일을 작성할 수있는 위치 목록을 지정합니다. 각 위치에 대해 Flow는 파일 시스템에 공유 메모리 파일을위한 충분한 공간이 있는지 확인합니다. 흐름에 공간이 부족한 경우 해당 위치를 건너 뛰고 다음 위치를 시도합니다. 이 옵션을 사용하면 파일 시스템에서 공유 메모리를 위해 필요한 최소 공간을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2073dcd9de74f00e347d42b3bc3960e160aea0a5" translate="yes" xml:space="preserve">
          <source>As the name hints, &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; is the type representing the set difference of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, i.e. &lt;code&gt;A \ B&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both &lt;a href=&quot;../objects&quot;&gt;object types&lt;/a&gt;. Here&amp;rsquo;s an example:</source>
          <target state="translated">이름에서 알 수 있듯이 &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 세트 차이를 나타내는 유형입니다 ( 예 : &lt;code&gt;A \ B&lt;/code&gt; ). 여기서 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 는 모두 &lt;a href=&quot;../objects&quot;&gt;객체 유형&lt;/a&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d3ad0d71f6c8ca89c8bf0a20c87797e4687d205" translate="yes" xml:space="preserve">
          <source>As this example shows, declaration files must be written with care: it is up to the programmer to ensure they are correct, otherwise they may hide type errors.</source>
          <target state="translated">이 예제에서 알 수 있듯이 선언 파일은주의해서 작성해야합니다. 올바른지 확인하는 것은 프로그래머의 책임입니다. 그렇지 않으면 형식 오류가 숨겨 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="462ea53149f64cdf8d1c87506946781343ce500f" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the example is not a random one. &lt;code&gt;$Diff&lt;/code&gt; is exactly what the React definition file uses to define the type of the props accepted by a React Component.</source>
          <target state="translated">알다시피, 예제는 무작위가 아닙니다. &lt;code&gt;$Diff&lt;/code&gt; 는 정확히 React 정의 파일이 React 구성 요소가 승인 한 props의 유형을 정의하는 데 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="75050d15c413d5f7a029e56def34919e7565c848" translate="yes" xml:space="preserve">
          <source>Asserting types in this way works the same as types do anywhere else.</source>
          <target state="translated">이런 식으로 형식을 지정하면 다른 곳에서와 마찬가지로 형식이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b7d56c19c3e1b18d86bf5280c85cef8d6ab8b6c5" translate="yes" xml:space="preserve">
          <source>Assume we have two classes, which have a subtype relationship:</source>
          <target state="translated">하위 유형 관계가있는 두 개의 클래스가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="65b9fcb33e463a779d0c4da859a5125301fe7b6c" translate="yes" xml:space="preserve">
          <source>Async functions implicitly return a promise, so the return type must always be a &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">비동기 함수는 암시 적으로 약속을 반환하므로 반환 유형은 항상 &lt;code&gt;Promise&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="9f01eb47108bfcd61bcd85d17fd5db43d8fe4fc5" translate="yes" xml:space="preserve">
          <source>Autocomplete-Flow</source>
          <target state="translated">Autocomplete-Flow</target>
        </trans-unit>
        <trans-unit id="7e6cbee16a2c2ad4b26fab2aa6ec8127618ef362" translate="yes" xml:space="preserve">
          <source>Available Lint Rules</source>
          <target state="translated">사용 가능한 린트 규칙</target>
        </trans-unit>
        <trans-unit id="48315d4da6f457296128d582ea2ac7a8107a6caa" translate="yes" xml:space="preserve">
          <source>Available options</source>
          <target state="translated">사용 가능한 옵션</target>
        </trans-unit>
        <trans-unit id="5701e01de65130c0af0004b67af666b5f9d12faa" translate="yes" xml:space="preserve">
          <source>Avoid leaking &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">누출 피 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="cc9d9ae632880006314a40c1e1b1e575e801e3d5" translate="yes" xml:space="preserve">
          <source>Babel also &lt;a href=&quot;https://flow.org/en/tools/create-react-app/&quot;&gt;works out of the box with Create React App&lt;/a&gt;, just install Flow and create a &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">Babel은 &lt;a href=&quot;https://flow.org/en/tools/create-react-app/&quot;&gt;React App 만들기와 함께 즉시 작동합니다&lt;/a&gt; . Flow를 설치하고 &lt;code&gt;.flowconfig&lt;/code&gt; 를 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="1d82284dd6071c5a7679a0d983aaaae31a00b7b5" translate="yes" xml:space="preserve">
          <source>Be liberal with enabling Flow Strict. Unlike adding or removing &lt;code&gt;@flow&lt;/code&gt;, adding or removing &lt;code&gt;@flow strict&lt;/code&gt; (by itself) does not change Flow coverage. It only prevents or allows certain new unsafe behavior from being added in the future. Even if in the future Flow Strict has to be disabled for the file, at least unsafe behavior was prevented from being added in the meantime.</source>
          <target state="translated">Flow Strict를 활성화하면 자유 로워집니다. &lt;code&gt;@flow&lt;/code&gt; 추가 또는 제거와 달리 &lt;code&gt;@flow strict&lt;/code&gt; 자체를 추가하거나 제거해도 Flow 적용 범위는 변경되지 않습니다. 나중에 안전하지 않은 특정 동작이 추가되는 것을 방지하거나 허용합니다. 나중에 파일에 대해 Flow Strict를 비활성화해야하더라도 그 동안 최소한 안전하지 않은 동작이 추가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1680d3465c06ca53c16148fde39b55e52752431c" translate="yes" xml:space="preserve">
          <source>Because Flow understands JavaScript so well, it doesn&amp;rsquo;t need many of these types. You should only ever have to do a minimal amount of work to describe your code to Flow and it will &lt;em&gt;infer&lt;/em&gt; the rest. A lot of the time, Flow can understand your code without any types at all.</source>
          <target state="translated">Flow는 JavaScript를 잘 이해하기 때문에 이러한 유형이 많이 필요하지 않습니다. Flow에 코드를 설명하기 위해 최소한의 작업 &lt;em&gt;만하면&lt;/em&gt; 나머지 가 &lt;em&gt;유추&lt;/em&gt; 됩니다 . 많은 시간 동안 Flow는 어떤 유형도없이 코드를 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="404fd91c9a9d241d6c9be8858eb9756bb6b4582e" translate="yes" xml:space="preserve">
          <source>Because of how contravariance works, contravariant properties also become write-only when used. Which can be useful over normal properties.</source>
          <target state="translated">반동이 작동하는 방식으로 인해 반 변형 속성도 사용될 때 쓰기 전용이됩니다. 일반 속성보다 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c880f74f55ee33062612978400cf2ed6b594d1f2" translate="yes" xml:space="preserve">
          <source>Because of how covariance works, covariant properties also become read-only when used. Which can be useful over normal properties.</source>
          <target state="translated">공분산 작동 방식으로 인해 공분산 속성도 사용시 읽기 전용이됩니다. 일반 속성보다 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d81cf8083f23d6f8c59a3bff90779ac704e0cb6" translate="yes" xml:space="preserve">
          <source>Because of the &lt;code&gt;typeof value === 'string'&lt;/code&gt; check, Flow knows the &lt;code&gt;value&lt;/code&gt; can only be a &lt;code&gt;string&lt;/code&gt; inside of the &lt;code&gt;if&lt;/code&gt; statement. This is known as a &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinement&lt;/a&gt;.</source>
          <target state="translated">때문에의 &lt;code&gt;typeof value === 'string'&lt;/code&gt; 검사, 흐름은 알고 &lt;code&gt;value&lt;/code&gt; 만 할 수 있습니다 &lt;code&gt;string&lt;/code&gt; 의 내부 &lt;code&gt;if&lt;/code&gt; 문. 이를 &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;정제라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6f57fb076b23f64a15463c71736ac7493ef61f03" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it is a best practice to find or write libdefs for as many of the third-party libraries that you use as you can. We recommend checking out the &lt;code&gt;flow-typed&lt;/code&gt;&lt;a href=&quot;https://github.com/flowtype/flow-typed/blob/master/README.md&quot;&gt;tool and repository&lt;/a&gt; , which helps you quickly find and install pre-existing libdefs for your third-party dependencies.</source>
          <target state="translated">이 동작으로 인해 가능한 많은 타사 라이브러리에 대한 libdef를 찾거나 작성하는 것이 가장 좋습니다. 우리는 체크 아웃하는 것이 좋습니다 &lt;code&gt;flow-typed&lt;/code&gt; &lt;a href=&quot;https://github.com/flowtype/flow-typed/blob/master/README.md&quot;&gt;도구 저장소&lt;/a&gt; 빠르게 찾아 타사 종속성을 기존 libdefs를 설치하는 데 도움이.</target>
        </trans-unit>
        <trans-unit id="839f87b3fae494fd4e8b9480d1e5f45008a0dc7e" translate="yes" xml:space="preserve">
          <source>Because type casts work the same as all other type annotations, you can only cast values to less specific types. You cannot change the type or make it something more specific.</source>
          <target state="translated">유형 캐스트는 다른 모든 유형 주석과 동일하게 작동하므로 값을 덜 특정 유형으로 만 캐스트 할 수 있습니다. 유형을 변경하거나 더 구체적으로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c07a19a41d787635a8e85b3b78306e9c1d7ff5d9" translate="yes" xml:space="preserve">
          <source>Before spending the time to write your own libdef, we recommend that you look to see if there is already a libdef for the third-party code that you&amp;rsquo;re addressing. &lt;code&gt;flow-typed&lt;/code&gt; is a &lt;a href=&quot;https://github.com/flowtype/flow-typed/&quot;&gt;tool and repository&lt;/a&gt; for sharing common libdefs within the Flow community &amp;ndash; so it&amp;rsquo;s a good way to knock out a good chunk of any public libdefs you might need for your project.</source>
          <target state="translated">자체 libdef를 작성하는 데 시간을 보내기 전에 이미 해결중인 타사 코드에 대한 libdef가 있는지 확인하는 것이 좋습니다. &lt;code&gt;flow-typed&lt;/code&gt; 는 Flow 커뮤니티 내에서 일반적인 libdef를 공유하기위한 &lt;a href=&quot;https://github.com/flowtype/flow-typed/&quot;&gt;도구 및 저장소&lt;/a&gt; 이므로 프로젝트에 필요할 수있는 모든 공용 libdef를 제거 할 수있는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ffd8520b4ea61ae236ddd4d1f4143845bd5bc375" translate="yes" xml:space="preserve">
          <source>Before we show how to type a React class component with Flow, let us first show how you would write a React class component &lt;em&gt;without&lt;/em&gt; Flow but with React&amp;rsquo;s prop types. You would extend &lt;code&gt;React.Component&lt;/code&gt; and add a static &lt;code&gt;propTypes&lt;/code&gt; property.</source>
          <target state="translated">Flow를 사용하여 React 클래스 컴포넌트를 입력하는 방법을 보여주기 전에 먼저 Flow가 없지만 React의 prop 유형을 사용 하여 React 클래스 컴포넌트 &lt;em&gt;를&lt;/em&gt; 작성하는 방법을 보여 드리겠습니다 . &lt;code&gt;React.Component&lt;/code&gt; 를 확장 하고 정적 &lt;code&gt;propTypes&lt;/code&gt; 속성을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="2b1e005429a327929c485a9cce3808a1145b8aa0" translate="yes" xml:space="preserve">
          <source>Behavior of generics</source>
          <target state="translated">제네릭의 동작</target>
        </trans-unit>
        <trans-unit id="e82cf40f53265657d5832c1308bdb8b249dbe424" translate="yes" xml:space="preserve">
          <source>Bivariance</source>
          <target state="translated">Bivariance</target>
        </trans-unit>
        <trans-unit id="408adf1c6e528212e5ff5ec2ce7d7e888977db8a" translate="yes" xml:space="preserve">
          <source>Bivariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">이 분산 &lt;em&gt;은 &lt;/em&gt;&lt;strong&gt;하위 유형을&lt;/strong&gt; 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="bf56a8499cffbc9b99a5c626b8e4f47f74fb6f88" translate="yes" xml:space="preserve">
          <source>Bivariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">이 분산 &lt;em&gt;은 &lt;/em&gt;&lt;strong&gt;수퍼 타입을&lt;/strong&gt; 허용 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd9e69ceceba4abeefdd82a9dfed379a6547be2" translate="yes" xml:space="preserve">
          <source>Boolean types need you to be explicit by converting non-booleans. You can do that with &lt;code&gt;Boolean(x)&lt;/code&gt; or &lt;code&gt;!!x&lt;/code&gt;.</source>
          <target state="translated">부울 유형은 부울이 아닌 값을 변환하여 명시 적이어야합니다. &lt;code&gt;Boolean(x)&lt;/code&gt; 또는 &lt;code&gt;!!x&lt;/code&gt; 로이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="aeaf4741c43124d50887c3856fa57da08ef729d3" translate="yes" xml:space="preserve">
          <source>Booleans are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values in JavaScript. The &lt;code&gt;boolean&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="translated">부울은 JavaScript에서 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 값입니다. Flow 의 &lt;code&gt;boolean&lt;/code&gt; 유형은 이러한 값을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="1845c94e71026f36d7237c0f0214aa3d8c3ce37d" translate="yes" xml:space="preserve">
          <source>Booleans: like &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">부울 : &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7494e6ec8cd7b2eb5a14c1e063217659a8a1ed3a" translate="yes" xml:space="preserve">
          <source>Broken example:</source>
          <target state="translated">깨진 예 :</target>
        </trans-unit>
        <trans-unit id="f031d4d730e754281da3ddefefd685153cc7e2c0" translate="yes" xml:space="preserve">
          <source>But Flow should understand that this function cannot invalidate this refinement, right?</source>
          <target state="translated">그러나 Flow는이 함수가이 세분화를 무효화 할 수 없다는 것을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="421430d7200437b9bff784aea6c385eb54e83ace" translate="yes" xml:space="preserve">
          <source>But JavaScript ignores these comments, so all it has is the valid syntax.</source>
          <target state="translated">그러나 JavaScript는 이러한 주석을 무시하므로 유효한 구문 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="9bcf9a6dad7d351fd124803ac3fa5511232e6ff7" translate="yes" xml:space="preserve">
          <source>But as soon as you change the shape it will start to cause errors.</source>
          <target state="translated">그러나 모양을 변경하자마자 오류가 발생하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="961b391c2d9d40cf6976473efc025458ffadca5a" translate="yes" xml:space="preserve">
          <source>But now we have a problem. Our &lt;code&gt;typeof obj&lt;/code&gt; annotation also gets this new annotation which defeats the entire purpose.</source>
          <target state="translated">그러나 지금 우리는 문제가 있습니다. 우리의 &lt;code&gt;typeof obj&lt;/code&gt; 주석은 또한 새로운 목적을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0a7b7f1f4fc53f9d61a2d8e4846e79d6d5218c5c" translate="yes" xml:space="preserve">
          <source>But suppose you only want to allow strings in your function. For that you can add types.</source>
          <target state="translated">그러나 함수에 문자열 만 허용하려고한다고 가정하십시오. 이를 위해 유형을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeada9e2d3835e3320e9297e7d171eb9198c4546" translate="yes" xml:space="preserve">
          <source>But we also need to compare the types of the values. If both objects had a key &lt;code&gt;foo&lt;/code&gt; but one was a &lt;code&gt;number&lt;/code&gt; and the other was a &lt;code&gt;string&lt;/code&gt;, then one would not be the subtype of the other.</source>
          <target state="translated">그러나 값의 유형을 비교해야합니다. 두 객체에 키 &lt;code&gt;foo&lt;/code&gt; 가 있지만 하나는 &lt;code&gt;number&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;string&lt;/code&gt; 인 경우 하나는 다른 하나의 하위 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0b1dae6be8224d27747e5314d54153e505cce8cb" translate="yes" xml:space="preserve">
          <source>But when objects are sealed, Flow will not allow you to add new properties to them.</source>
          <target state="translated">그러나 객체가 봉인되면 Flow를 사용하여 객체에 새 속성을 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66ff1b2d0fd5745355740b15ee2b612dc315d816" translate="yes" xml:space="preserve">
          <source>But when you have properties that overlap by having the same name, it creates an intersection of the property type as well.</source>
          <target state="translated">그러나 동일한 이름을 사용하여 겹치는 속성이 있으면 속성 유형의 교집합도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="30753facf6dcd87d6a5e7d8483dce119cb47531c" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re taking the results of Flow&amp;rsquo;s inference and asserting it as a type. While this can be very useful, it can also lead to some unexpected results.</source>
          <target state="translated">그러나 &lt;code&gt;typeof&lt;/code&gt; 를 사용 하면 Flow의 유추 결과를 가져 와서 유형으로 주장합니다. 이 기능은 매우 유용하지만 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="402c1e1505aa711e14641f9e0cbdd3c126cb8608" translate="yes" xml:space="preserve">
          <source>But you can use any to cast to whatever type you want.</source>
          <target state="translated">그러나 any를 사용하여 원하는 유형으로 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="380728668d9cfaeeebed3b2bcfa77a400e52a7a2" translate="yes" xml:space="preserve">
          <source>But you can&amp;rsquo;t possibly create a value which is both a &lt;em&gt;number and a string&lt;/em&gt;, but you can create a type for it. There&amp;rsquo;s no practical use for creating types like this, but it&amp;rsquo;s a side effect of how intersection types work.</source>
          <target state="translated">그러나 &lt;em&gt;숫자와 문자열&lt;/em&gt; 모두 값을 만들 수는 없지만 유형을 만들 수는 있습니다. 이와 같은 유형을 만드는 데 실용적이지는 않지만 교차로 유형의 작동 방식에 따른 부작용입니다.</target>
        </trans-unit>
        <trans-unit id="a559e18c54711bce2c3c1b5537b218d29bf4a48b" translate="yes" xml:space="preserve">
          <source>But you&amp;rsquo;ll want to use more specific types for your actions using disjoint unions and each individual type of action.</source>
          <target state="translated">그러나 분리 된 공용체와 각 개별 작업 유형을 사용하여 작업에보다 구체적인 유형을 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="75d7327a8eec333652ce1fe3a29a224e1b4e6477" translate="yes" xml:space="preserve">
          <source>By casting the value to any, you can then cast to whatever you want.</source>
          <target state="translated">값을 임의의 값으로 캐스트하면 원하는대로 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea11ddf576cb4458685c2b63ba3622020aced4f3" translate="yes" xml:space="preserve">
          <source>By checking every possible value, Flow might catch errors that will not actually occur when the code is run. Flow does this in order to be &lt;em&gt;&amp;ldquo;sound&amp;rdquo;&lt;/em&gt;.</source>
          <target state="translated">가능한 모든 값을 확인하면 코드를 실행할 때 실제로 발생하지 않는 오류가 발생할 수 있습니다. 흐름은 &lt;em&gt;&quot;소리&quot;&lt;/em&gt; 가되기 위해 이것을 합니다.</target>
        </trans-unit>
        <trans-unit id="888a90a8461cf1dcf2dfa9475b824abf2a140082" translate="yes" xml:space="preserve">
          <source>By checking the typeof our value and testing to see if it is a number, Flow knows that inside of that block it is only a number. We can then write code which treats our value as a number inside of that block.</source>
          <target state="translated">값의 유형을 확인하고 숫자인지 테스트하여 Flow는 해당 블록 내부의 숫자 만 알 수 있습니다. 그런 다음 값을 해당 블록 내부의 숫자로 취급하는 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e166bbfa292c608c082d1714c483c0896b791e" translate="yes" xml:space="preserve">
          <source>By default it is 536870912 (2^29 bytes, which is half a gigabyte).</source>
          <target state="translated">기본적으로 536870912 (2 ^ 29 바이트, 반기가 바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="50633f3514931f4fa2e84559a298e46e3f897949" translate="yes" xml:space="preserve">
          <source>By default this is 0.</source>
          <target state="translated">기본적으로 이것은 0입니다.</target>
        </trans-unit>
        <trans-unit id="15c3b3f03676e9fef47c839d9f3979c86d9e53d7" translate="yes" xml:space="preserve">
          <source>By default this is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본적으로 이것은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="53bf9ecbf110fc31e84ab1d4ed08e51aaa3096ed" translate="yes" xml:space="preserve">
          <source>By default this option is set to &lt;code&gt;/dev/shm&lt;/code&gt; and &lt;code&gt;/tmp&lt;/code&gt;</source>
          <target state="translated">기본적으로이 옵션은 &lt;code&gt;/dev/shm&lt;/code&gt; 및 &lt;code&gt;/tmp&lt;/code&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9574b97e4aad17c08cdb93e1e1659dc17a8a5d" translate="yes" xml:space="preserve">
          <source>By default when you re-assign a variable, Flow will give it the type of all possible assignments.</source>
          <target state="translated">변수를 다시 할당 할 때 기본적으로 Flow는 가능한 모든 할당 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="134864792720213ebc4bc0075f47cc4f80136ea2" translate="yes" xml:space="preserve">
          <source>By default, Flow will look for files with the extensions &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.mjs&lt;/code&gt; and &lt;code&gt;.json&lt;/code&gt;. You can override this behavior with this option.</source>
          <target state="translated">기본적으로 Flow는 확장명이 &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.jsx&lt;/code&gt; , &lt;code&gt;.mjs&lt;/code&gt; 및 &lt;code&gt;.json&lt;/code&gt; 인 파일 을 찾습니다 . 이 옵션으로이 동작을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c01f8c4e09478deb33d4af8e9963cfec032edd46" translate="yes" xml:space="preserve">
          <source>By default, Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; for node modules. You can configure this behavior with this option.</source>
          <target state="translated">기본적으로 Flow는 &lt;code&gt;node_modules&lt;/code&gt; 라는 디렉토리 에서 노드 모듈을 찾습니다 . 이 옵션으로이 동작을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09b5075116fd3869d9cadd377bad839d72504028" translate="yes" xml:space="preserve">
          <source>By default, the Flow server will typecheck all your code. This way it can answer questions like &amp;ldquo;are there any Flow errors anywhere in my code&amp;rdquo;. This is very useful for tooling, like a continuous integration hook which prevents code changes which introduce Flow errors.</source>
          <target state="translated">기본적으로 플로우 서버는 모든 코드를 유형 검사합니다. 이런 식으로 &quot;내 코드에 플로우 오류가 있습니까?&quot;와 같은 질문에 답변 할 수 있습니다. 이는 흐름 오류를 유발하는 코드 변경을 방지하는 지속적인 통합 후크와 같은 툴링에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fd76a70149a54159a0fc3b1090cb3ea08262b1cc" translate="yes" xml:space="preserve">
          <source>By default, this is set to 19 (Table size is 2^19, which is 8 megabytes)</source>
          <target state="translated">기본적으로이 값은 19로 설정되어 있습니다 (테이블 크기는 2 ^ 19, 8MB).</target>
        </trans-unit>
        <trans-unit id="7ff7ddf4cc91afce590edc441693a3db98fd3736" translate="yes" xml:space="preserve">
          <source>By default, this is set to 26843545600 (25 * 2^30 bytes, which is 25GiB)</source>
          <target state="translated">기본적으로이 값은 26843545600 (25 * 2 ^ 30 바이트, 25GiB)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acbb4b73f95bada54b37ed5bbd4fe52f109cb99a" translate="yes" xml:space="preserve">
          <source>CLI Commands</source>
          <target state="translated">CLI 명령</target>
        </trans-unit>
        <trans-unit id="6d43703db2da8bdf8468b95d1594c5dba316eb10" translate="yes" xml:space="preserve">
          <source>Calculates a config object from props and default props. This is most useful for annotating HOCs that are abstracted over configs. See our &lt;a href=&quot;../hoc&quot;&gt;docs on writing HOCs&lt;/a&gt; for more information.</source>
          <target state="translated">소품과 기본 소품에서 구성 객체를 계산합니다. 이것은 구성을 통해 추상화 된 HOC에 주석을 달 때 가장 유용합니다. 자세한 내용은 &lt;a href=&quot;../hoc&quot;&gt;HOC 작성에 관한 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97da5c1835399f071d43358b9774ddca050daf60" translate="yes" xml:space="preserve">
          <source>Callable Objects</source>
          <target state="translated">호출 가능한 객체</target>
        </trans-unit>
        <trans-unit id="3a313789e66d78fc3c3729e779158ab414b6007d" translate="yes" xml:space="preserve">
          <source>Callable objects can be typed, for example:</source>
          <target state="translated">호출 가능한 객체는 다음과 같이 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c139cc9f6d79ac3a638f7ccf61f2b9637d567c2a" translate="yes" xml:space="preserve">
          <source>Cannot use mutating array methods on tuples</source>
          <target state="translated">튜플에서 변형 배열 메서드를 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="ee70a9dd51b9b3a375656ccfb82a0044b5db1ef2" translate="yes" xml:space="preserve">
          <source>Caret ranges, which allow changes that do not modify the left-most non-zero digit (e.g. &lt;code&gt;^0.13.0&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt;, and &lt;code&gt;^0.13.1&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=0.13.1 &amp;lt;0.14.0&lt;/code&gt;, whereas &lt;code&gt;^1.2.3&lt;/code&gt; expands into &lt;code&gt;&amp;gt;=1.2.3 &amp;lt;2.0.0&lt;/code&gt;).</source>
          <target state="translated">가장 왼쪽의 영이 아닌 숫자를 수정하지 않는 변화를 허용 범위 캐럿 (예 &lt;code&gt;^0.13.0&lt;/code&gt; 팽창에 &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt; 및 &lt;code&gt;^0.13.1&lt;/code&gt; 로 확장 &lt;code&gt;&amp;gt;=0.13.1 &amp;lt;0.14.0&lt;/code&gt; 이지만 &lt;code&gt;^1.2.3&lt;/code&gt; 은 &lt;code&gt;&amp;gt;=1.2.3 &amp;lt;2.0.0&lt;/code&gt; 으로 확장됩니다 ).</target>
        </trans-unit>
        <trans-unit id="6fe0f312fa3428aa6c4fdee3743c37967749d48e" translate="yes" xml:space="preserve">
          <source>Check Your Code</source>
          <target state="translated">코드 확인</target>
        </trans-unit>
        <trans-unit id="b73433b77514508ea8a1cefa58845c9ce4425fe1" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://flow.org/en/linting&quot;&gt;linting docs&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://flow.org/en/linting&quot;&gt;보푸라기 문서&lt;/a&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="18c18b8a20dbe7477ce5e5b3ea1624b99b154cdc" translate="yes" xml:space="preserve">
          <source>Checks JavaScript files for type errors on save</source>
          <target state="translated">저장시 JavaScript 파일에서 유형 오류 확인</target>
        </trans-unit>
        <trans-unit id="dcf75191c585bfb6059ad203f7ce5630a589a405" translate="yes" xml:space="preserve">
          <source>Children</source>
          <target state="translated">Children</target>
        </trans-unit>
        <trans-unit id="ea7d82eca3471176f477c2cedc92c146814951f8" translate="yes" xml:space="preserve">
          <source>Choosing Focused Files</source>
          <target state="translated">집중된 파일 선택</target>
        </trans-unit>
        <trans-unit id="dd9e83c06b2948588c35a377c68a9e504e82cd53" translate="yes" xml:space="preserve">
          <source>Class Components</source>
          <target state="translated">클래스 구성 요소</target>
        </trans-unit>
        <trans-unit id="a292b9b612431489a82ca75b9a01310364d94fec" translate="yes" xml:space="preserve">
          <source>Class Fields (Properties)</source>
          <target state="translated">수업 분야 (재산)</target>
        </trans-unit>
        <trans-unit id="c29b94bc81534772a515451e3a6176277b7a484c" translate="yes" xml:space="preserve">
          <source>Class Generics</source>
          <target state="translated">클래스 제네릭</target>
        </trans-unit>
        <trans-unit id="3d9f77136533c6ff7b7e86c9e68a8e0e99ad867e" translate="yes" xml:space="preserve">
          <source>Class Methods</source>
          <target state="translated">수업 방법</target>
        </trans-unit>
        <trans-unit id="00da90a4700b284083533dbd6e4a5418d77ae7c4" translate="yes" xml:space="preserve">
          <source>Class Syntax</source>
          <target state="translated">클래스 구문</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">수업 종류</target>
        </trans-unit>
        <trans-unit id="7ef245513b7358326754969c6ff56632c31d10bb" translate="yes" xml:space="preserve">
          <source>Class generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a class as a type you need to pass parameters for each of its generics.</source>
          <target state="translated">클래스 제네릭은 &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;매개 변수화&lt;/a&gt; 됩니다. 클래스를 유형으로 사용하는 경우 각 제네릭에 대한 매개 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ac68839be9322d234cbe8b1175e8660eac2c1db" translate="yes" xml:space="preserve">
          <source>Classes (when being used as a type), type aliases, and interfaces all require that you pass type arguments. Functions and function types do not have parameterized generics.</source>
          <target state="translated">클래스 (유형으로 사용되는 경우), 유형 별명 및 인터페이스는 모두 유형 인수를 전달해야합니다. 함수 및 함수 유형에는 매개 변수화 된 제네릭이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3164faf12698fd9d5a1ee175d4e32c8f3b28733b" translate="yes" xml:space="preserve">
          <source>Classes are nominally typed</source>
          <target state="translated">클래스는 명목상으로 타이핑됩니다</target>
        </trans-unit>
        <trans-unit id="09580fd8cc5532206f6976398f34d1aa760f93c6" translate="yes" xml:space="preserve">
          <source>Classes can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">클래스는 또한 &lt;a href=&quot;../generics&quot;&gt;제네릭을&lt;/a&gt; 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fda3adeadc4a4501aa999874c1179a4ba1c688c" translate="yes" xml:space="preserve">
          <source>Classes can create generics by placing the type parameter list before the body of the class.</source>
          <target state="translated">클래스는 형식 매개 변수 목록을 클래스 본문 앞에 배치하여 제네릭을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b808e1e4ae68ed6db8b6f4a3b08980e0757a73a" translate="yes" xml:space="preserve">
          <source>Classes in Flow are identical to normal JavaScript classes, but with added types.</source>
          <target state="translated">Flow의 클래스는 일반 JavaScript 클래스와 동일하지만 유형이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="452b035012ae20e8fba0cecbb4575853da83a21c" translate="yes" xml:space="preserve">
          <source>Classes in Flow are nominally typed. This means that when you have two separate classes you cannot use one in place of the other even when they have the same exact properties and methods.</source>
          <target state="translated">Flow의 클래스는 명목상 유형이 있습니다. 즉, 두 개의 별도 클래스가 있으면 동일한 속성과 메서드가 동일한 경우에도 다른 클래스 대신 하나를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c07a614cc79da75bb9b47692238ba51e242a3c47" translate="yes" xml:space="preserve">
          <source>Classes with generics</source>
          <target state="translated">제네릭이있는 클래스</target>
        </trans-unit>
        <trans-unit id="a3966ac02425c85de4503912eef3010180d093f6" translate="yes" xml:space="preserve">
          <source>Classifying Files</source>
          <target state="translated">파일 분류</target>
        </trans-unit>
        <trans-unit id="4060649bc0fbf1a753996c990ce6ff425ec633c7" translate="yes" xml:space="preserve">
          <source>Comment Types</source>
          <target state="translated">댓글 유형</target>
        </trans-unit>
        <trans-unit id="e20aa320a16fc33b19be9bd963333288cc2fbcd3" translate="yes" xml:space="preserve">
          <source>Comment support was added in v0.23.0. Lines beginning with zero or more spaces followed by an &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;💩&lt;/code&gt; are ignored. For example:</source>
          <target state="translated">주석 지원은 v0.23.0에서 추가되었습니다. 0 개 이상의 공백으로 시작하고 그 뒤에 &lt;code&gt;#&lt;/code&gt; 또는 &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;💩&lt;/code&gt; 는 무시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a3c18b9e3a38eaea2ce3317736de762da172d50" translate="yes" xml:space="preserve">
          <source>Comment type annotation</source>
          <target state="translated">주석 유형 주석</target>
        </trans-unit>
        <trans-unit id="3fdb12dbd0fc63c594f614d2015983c4d8a7cc47" translate="yes" xml:space="preserve">
          <source>Comment type include</source>
          <target state="translated">댓글 유형 포함</target>
        </trans-unit>
        <trans-unit id="2a30d59a808479157403fbf163a7b1b950362562" translate="yes" xml:space="preserve">
          <source>Comment types syntax</source>
          <target state="translated">주석 유형 구문</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="77cd370c5563644ed24d98dbd212c70fede32f4e" translate="yes" xml:space="preserve">
          <source>CommonJS modules have a single value that is exported (the &lt;code&gt;module.exports&lt;/code&gt; value). To describe the type of this single value within a &lt;code&gt;declare module&lt;/code&gt; body, you&amp;rsquo;ll use the &lt;code&gt;declare module.exports&lt;/code&gt; syntax:</source>
          <target state="translated">CommonJS 모듈에는 단일 값이 내보내집니다 ( &lt;code&gt;module.exports&lt;/code&gt; 값). &lt;code&gt;declare module&lt;/code&gt; 본문 내에서이 단일 값의 유형을 설명하기 위해 다음과 같이 &lt;code&gt;declare module.exports&lt;/code&gt; 구문을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="357ded9bfca85d8cbd26f40a3524ddda69561b80" translate="yes" xml:space="preserve">
          <source>Conceptually one can think of declaration mode as if Flow still typechecks the files but acts as if there is a comment that matches &lt;code&gt;suppress_comment&lt;/code&gt; on every line.</source>
          <target state="translated">개념적으로 선언 모드는 Flow가 여전히 파일을 타입 검사하는 것처럼 생각할 수 있지만 모든 행에서 &lt;code&gt;suppress_comment&lt;/code&gt; 와 일치하는 주석이있는 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="17e8e4decf7d96f7f04f6c0aaf456c37aae4e8a7" translate="yes" xml:space="preserve">
          <source>Configure ALE to use the &lt;code&gt;flow-language-server&lt;/code&gt; linter for JavaScript files:</source>
          <target state="translated">JavaScript 파일에 &lt;code&gt;flow-language-server&lt;/code&gt; linter 를 사용하도록 ALE을 구성 하십시오.</target>
        </trans-unit>
        <trans-unit id="b41a81e0d51029fe68417fdfc1818a6ce70ba9c2" translate="yes" xml:space="preserve">
          <source>Configuring Lints from the CLI</source>
          <target state="translated">CLI에서 보푸라기 구성</target>
        </trans-unit>
        <trans-unit id="8e2382fbc54df1efc6f7e32e65cd9c5d7c95a4c6" translate="yes" xml:space="preserve">
          <source>Configuring Lints in the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="translated">에 Lints 구성 &lt;code&gt;.flowconfig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="100fcd8a929b3ce3c89e968bb90a967ea5146ece" translate="yes" xml:space="preserve">
          <source>Configuring Lints with Comments</source>
          <target state="translated">주석으로 보풀 구성</target>
        </trans-unit>
        <trans-unit id="ea1be7edf59f5de51b594f9fbae2368f8449e70c" translate="yes" xml:space="preserve">
          <source>Configuring lint settings with &lt;code&gt;flowlint&lt;/code&gt; comments allows you to specify different settings within a file and different settings to different regions of different files. These comments come in three forms:</source>
          <target state="translated">&lt;code&gt;flowlint&lt;/code&gt; 주석으로 보푸라기 설정을 구성 하면 파일 내에서 다른 설정을 지정하고 다른 파일의 다른 영역에 다른 설정을 지정할 수 있습니다. 이러한 의견은 세 가지 형태로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5459dd4dd0d0aff9d4c5e0bb04ffd680814c6d9f" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;TypeLetters&lt;/code&gt; which described the strings: &amp;ldquo;A&amp;rdquo;, &amp;ldquo;B&amp;rdquo;, &amp;ldquo;C&amp;rdquo;, and a &lt;code&gt;TypeNumbers&lt;/code&gt; which described the numbers: 1, 2, 3. Neither of them would be a subtype of the other, as they each contain a completely different set of values.</source>
          <target state="translated">문자열을 설명 하는 &lt;code&gt;TypeLetters&lt;/code&gt; ( &amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;)와 숫자를 설명 하는 &lt;code&gt;TypeNumbers&lt;/code&gt; ( 1, 2, 3)를 고려하십시오. 완전히 다른 값 집합.</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="bd6cc06a58d88fe388d82365f6c350095732e612" translate="yes" xml:space="preserve">
          <source>Contravariance</source>
          <target state="translated">Contravariance</target>
        </trans-unit>
        <trans-unit id="cb180a0b2985d8db3f02bd050b0c5682ab094c05" translate="yes" xml:space="preserve">
          <source>Contravariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">불균형 &lt;em&gt;은 &lt;/em&gt;&lt;strong&gt;하위 유형을&lt;/strong&gt; 허용 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c1af28bd0de937b51db3bbee9579b53603a2e45c" translate="yes" xml:space="preserve">
          <source>Contravariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">다 분산 &lt;em&gt;은 &lt;/em&gt;&lt;strong&gt;수퍼 타입을&lt;/strong&gt; 허용 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f1840a661bb88bcb72aa63857962824a747fab2e" translate="yes" xml:space="preserve">
          <source>Contravariant (write-only) properties on interfaces</source>
          <target state="translated">인터페이스의 반 변형 (쓰기 전용) 속성</target>
        </trans-unit>
        <trans-unit id="d37d133ea5c1b52753b3893f902c233ee8442bb5" translate="yes" xml:space="preserve">
          <source>Covariance</source>
          <target state="translated">Covariance</target>
        </trans-unit>
        <trans-unit id="2f10ee60c3d51dffb8e99aab19b27d99124ad7c4" translate="yes" xml:space="preserve">
          <source>Covariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">공분산 &lt;em&gt;에는 &lt;/em&gt;&lt;strong&gt;수퍼 타입이&lt;/strong&gt; 허용 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a1fa2bb1d0052e924cece0736a3a2248a64883bc" translate="yes" xml:space="preserve">
          <source>Covariance &lt;em&gt;does&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">공분산 &lt;em&gt;은 &lt;/em&gt;&lt;strong&gt;하위 유형을&lt;/strong&gt; 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="6a3e204ca6009adaaa624087ce1b64b315a8aef0" translate="yes" xml:space="preserve">
          <source>Covariant (read-only) properties on interfaces</source>
          <target state="translated">인터페이스의 공변량 (읽기 전용) 속성</target>
        </trans-unit>
        <trans-unit id="a1d8b1686c9450f38df6ec567189c88fa8e65f62" translate="yes" xml:space="preserve">
          <source>Create React App</source>
          <target state="translated">리 액트 앱 만들기</target>
        </trans-unit>
        <trans-unit id="0bf0dd44b7766be1f57889796955a258d3203142" translate="yes" xml:space="preserve">
          <source>Create as many generics as you need</source>
          <target state="translated">필요한만큼 많은 제네릭 생성</target>
        </trans-unit>
        <trans-unit id="03ce361cea65e5018df3a6c27de3a6593ce0f4ed" translate="yes" xml:space="preserve">
          <source>Creating Library Definitions</source>
          <target state="translated">라이브러리 정의 작성</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">선언 파일</target>
        </trans-unit>
        <trans-unit id="6c41a0185a4a9cfa2f6df6a748ac7876baa85cb0" translate="yes" xml:space="preserve">
          <source>Declaration mode should only be used for existing third-party code. You should never use this for code under your control.</source>
          <target state="translated">선언 모드는 기존 타사 코드에만 사용해야합니다. 제어하는 코드에는 절대로 이것을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7377158aaae022f9ae166beb589c5befa8f2034b" translate="yes" xml:space="preserve">
          <source>Declaring A CommonJS Module</source>
          <target state="translated">CommonJS 모듈 선언</target>
        </trans-unit>
        <trans-unit id="e7912896131236a8a65370bdd893e2009c32c266" translate="yes" xml:space="preserve">
          <source>Declaring A Global Class</source>
          <target state="translated">글로벌 클래스 선언</target>
        </trans-unit>
        <trans-unit id="cf300a0c751ae6bb5689acc80a14bec33cc3173d" translate="yes" xml:space="preserve">
          <source>Declaring A Global Function</source>
          <target state="translated">전역 함수 선언</target>
        </trans-unit>
        <trans-unit id="fa2144a7e4ab0959082b21d1945383339a3043f8" translate="yes" xml:space="preserve">
          <source>Declaring A Global Type</source>
          <target state="translated">글로벌 타입 선언</target>
        </trans-unit>
        <trans-unit id="f140a982a9c52716db37b4e9e5e30630eacfa6f6" translate="yes" xml:space="preserve">
          <source>Declaring A Global Variable</source>
          <target state="translated">전역 변수 선언</target>
        </trans-unit>
        <trans-unit id="cf71778c169e234024b86addcbe9ddb1f9d5a9b2" translate="yes" xml:space="preserve">
          <source>Declaring A Module</source>
          <target state="translated">모듈 선언</target>
        </trans-unit>
        <trans-unit id="e4ce9329aeac94bfdbc95574fafe7358b946c293" translate="yes" xml:space="preserve">
          <source>Declaring An ES Module</source>
          <target state="translated">ES 모듈 선언</target>
        </trans-unit>
        <trans-unit id="af087002f31d0ea4e967c16e89ad0e158cdeb097" translate="yes" xml:space="preserve">
          <source>Default Exports</source>
          <target state="translated">기본 수출</target>
        </trans-unit>
        <trans-unit id="7f3b8d79c1988be2a2ba2d6f29be574f525f239e" translate="yes" xml:space="preserve">
          <source>Defines a magical comment that suppresses any Flow errors on the following line. For example:</source>
          <target state="translated">다음 줄의 흐름 오류를 억제하는 마법의 설명을 정의합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4e96ce5110d5704ac6b16c56748c7a82fa4b290" translate="yes" xml:space="preserve">
          <source>Depth Subtyping</source>
          <target state="translated">심도 서브 타이핑</target>
        </trans-unit>
        <trans-unit id="bb3a537f6961c44f6476a0cf4c7c5e6d20651cc7" translate="yes" xml:space="preserve">
          <source>Detailed guides, tips, and resources on how to integrate Flow with different JavaScript tools.</source>
          <target state="translated">Flow를 다른 JavaScript 도구와 통합하는 방법에 대한 자세한 가이드, 팁 및 리소스</target>
        </trans-unit>
        <trans-unit id="5397d84bf20e2c90a75c1c0e9296db893360d2d5" translate="yes" xml:space="preserve">
          <source>Detailed guides, tips, and resources on how to integrate Flow with different code editors.</source>
          <target state="translated">Flow를 다른 코드 편집기와 통합하는 방법에 대한 자세한 가이드, 팁 및 리소스</target>
        </trans-unit>
        <trans-unit id="07b29e4715401afbf688a87a35ce231b8ef245ab" translate="yes" xml:space="preserve">
          <source>Developers like coding in JavaScript because it helps them move fast. The language facilitates fast prototyping of ideas via dynamic typing. The runtime provides the means for fast iteration on those ideas via dynamic compilation. This fuels a fast edit-refresh cycle, which promises an immersive coding experience that is quite appealing to creative developers.</source>
          <target state="translated">JavaScript로 코딩하는 것을 좋아하는 개발자는 빠르게 움직일 수 있도록 도와줍니다. 이 언어는 동적 타이핑을 통해 아이디어를 빠르게 프로토 타이핑 할 수 있습니다. 런타임은 동적 컴파일을 통해 이러한 아이디어를 빠르게 반복 할 수있는 수단을 제공합니다. 이로 인해 빠른 편집 새로 고침주기가 시작되어 창의적인 개발자에게 매력적인 몰입 형 코딩 경험이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="d112a1cd5683bcc108f9cd368dc51e0007d4b649" translate="yes" xml:space="preserve">
          <source>Developers will often use Flow and React together, so it is important that Flow can effectively type both common and advanced React patterns. This guide will teach you how to use Flow to create safer React applications.</source>
          <target state="translated">개발자는 종종 Flow와 React를 함께 사용하기 때문에 Flow가 일반 및 고급 React 패턴을 효과적으로 입력 할 수 있어야합니다. 이 안내서는 Flow를 사용하여보다 안전한 React 애플리케이션을 작성하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="1e6b556971ea4a33002387413d405d2f43ba4f6b" translate="yes" xml:space="preserve">
          <source>Different sections are available to specify different behaviours, and by combining them most use cases are expected to be met.</source>
          <target state="translated">각기 다른 동작을 지정하기 위해 다른 섹션을 사용할 수 있으며 이들을 결합하여 대부분의 사용 사례가 충족 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="13f50eb9f26820d014db96a7378f60b1d9165a9e" translate="yes" xml:space="preserve">
          <source>Disjoint Unions</source>
          <target state="translated">분리 된 연합</target>
        </trans-unit>
        <trans-unit id="1a7f91bafa50063f1996b902994e106982ff9d56" translate="yes" xml:space="preserve">
          <source>Disjoint unions require you to use a single property to distinguish each object type. You cannot distinguish two different objects by different properties.</source>
          <target state="translated">분리 결합에서는 단일 특성을 사용하여 각 오브젝트 유형을 구별해야합니다. 서로 다른 속성으로 두 개의 서로 다른 객체를 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9068ebe4e81ef4f2881aa16d8729d7d6e800dff" translate="yes" xml:space="preserve">
          <source>Disjoint unions with exact types</source>
          <target state="translated">정확한 유형의 분리 된 연합</target>
        </trans-unit>
        <trans-unit id="aa4adede3310c0d7e145943b47a01ec740a946a3" translate="yes" xml:space="preserve">
          <source>Each line in the &lt;code&gt;[libs]&lt;/code&gt; section is a path to the library file or directory which you would like to include. These paths can be relative to the project root directory or absolute. Including a directory recursively includes all the files under that directory as library files.</source>
          <target state="translated">&lt;code&gt;[libs]&lt;/code&gt; 섹션 의 각 줄은 포함 시키려는 라이브러리 파일 또는 디렉토리의 경로입니다. 이 경로는 프로젝트 루트 디렉토리에 상대적이거나 절대적 일 수 있습니다. 디렉토리를 재귀 적으로 포함하면 해당 디렉토리 아래의 모든 파일이 라이브러리 파일로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="099f5c6226bea98d0b45888f6a9ff773168bded9" translate="yes" xml:space="preserve">
          <source>Each of the members of a intersection type can be any type, even another intersection type.</source>
          <target state="translated">교차 유형의 각 구성원은 모든 유형이 될 수 있으며 다른 교차 유형도 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e5ead45d63220a36e13146ef22daf86e2c2fcea" translate="yes" xml:space="preserve">
          <source>Each of the members of a union type can be any type, even another union type.</source>
          <target state="translated">공용체 유형의 각 멤버는 다른 유형일 수있는 모든 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04062df0a5ebcde8394ccd8dfdb3632bb2dce1a6" translate="yes" xml:space="preserve">
          <source>Early in React&amp;rsquo;s history the library provided &lt;a href=&quot;https://facebook.github.io/react/docs/typechecking-with-proptypes.html&quot;&gt;&lt;code&gt;PropTypes&lt;/code&gt;&lt;/a&gt; which performed basic runtime checks. Flow is much more powerful as it can tell you when you are misusing a component without running your code.</source>
          <target state="translated">React의 역사 초기에 라이브러리 는 기본 런타임 검사를 수행 하는 &lt;a href=&quot;https://facebook.github.io/react/docs/typechecking-with-proptypes.html&quot;&gt; &lt;code&gt;PropTypes&lt;/code&gt; &lt;/a&gt; 을 제공 했습니다. 코드를 실행하지 않고 구성 요소를 잘못 사용하는 경우 흐름이 훨씬 강력 해집니다.</target>
        </trans-unit>
        <trans-unit id="d8fbeb27c5847478b31ce446787b9e3281657271" translate="yes" xml:space="preserve">
          <source>Editor plugins are provided and maintained by the community. If you have trouble configuring or using a specific plugin for your IDE, please visit the project&amp;rsquo;s repo or search for a community provided answer.</source>
          <target state="translated">편집기 플러그인은 커뮤니티에서 제공하고 유지 보수합니다. IDE에 특정 플러그인을 구성하거나 사용하는 데 문제가있는 경우 프로젝트 저장소를 방문하거나 커뮤니티 제공 답변을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="ed63036d8730b34c2af3aa53fe984d9883388a1c" translate="yes" xml:space="preserve">
          <source>Editors</source>
          <target state="translated">Editors</target>
        </trans-unit>
        <trans-unit id="d89a5ec1140ce5dd978c2baf15972fdf48b8b61f" translate="yes" xml:space="preserve">
          <source>Emacs</source>
          <target state="translated">Emacs</target>
        </trans-unit>
        <trans-unit id="cf46938375da84aa280715be40f3710755292d16" translate="yes" xml:space="preserve">
          <source>Enables traces on all error output (showing additional details about the flow of types through the system), to the depth specified. This can be very expensive, so is disabled by default.</source>
          <target state="translated">지정된 깊이까지 모든 오류 출력 (시스템을 통한 유형의 흐름에 대한 추가 세부 정보 표시)에서 추적을 활성화합니다. 이것은 매우 비쌀 수 있으므로 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2dcc58367a1736e48cc9750d5d4e0f214c570ef" translate="yes" xml:space="preserve">
          <source>Enabling Flow Strict for a file means that several previously-allowed patterns will now trigger a Flow error. Each disallowed pattern has a corresponding &lt;a href=&quot;https://flow.org/en/linting/&quot;&gt;Flow Lint&lt;/a&gt; rule which triggers the error. The list of rules enabled for &lt;code&gt;@flow strict&lt;/code&gt; is configured in each &lt;code&gt;.flowconfig&lt;/code&gt;. Here are the recommended rules:</source>
          <target state="translated">파일에 대해 Flow Strict를 활성화하면 이전에 허용 된 여러 패턴이 이제 Flow 오류를 트리거합니다. 허용되지 않는 각 패턴에는 해당 &lt;a href=&quot;https://flow.org/en/linting/&quot;&gt;흐름 린트&lt;/a&gt; 규칙이있어 오류를 트리거합니다. &lt;code&gt;@flow strict&lt;/code&gt; 에 사용 가능한 규칙 목록은 각 &lt;code&gt;.flowconfig&lt;/code&gt; 에서 구성됩니다 . 권장 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9362e9d124ec7b068004f2f5d44579aee1193e70" translate="yes" xml:space="preserve">
          <source>Enabling Flow Strict in a .flowconfig</source>
          <target state="translated">.flowconfig에서 엄격한 흐름 활성화</target>
        </trans-unit>
        <trans-unit id="0fe43e985b9f3cede92eed08e9cb385d404eea59" translate="yes" xml:space="preserve">
          <source>Enforcing that a component only gets a single child.</source>
          <target state="translated">구성 요소를 적용하면 한 명의 자식 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="af6da05f12e48d3f287a21a34dc14f0f0b6d9b9d" translate="yes" xml:space="preserve">
          <source>Equally specific inputs and outputs &amp;mdash; Good</source>
          <target state="translated">동일하게 특정 입력 및 출력 &amp;mdash; 양호</target>
        </trans-unit>
        <trans-unit id="1c01289049ee253c54bfc3dcb7ad87f71ff8dc18" translate="yes" xml:space="preserve">
          <source>Even as we treat our value as just one of the types, we do not get an error because it satisfies all of them.</source>
          <target state="translated">우리는 우리의 가치를 하나의 유형 중 하나로 취급하더라도 모든 것을 만족시키기 때문에 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe29fc3f9fec6b884383a4b8a8698b488827777d" translate="yes" xml:space="preserve">
          <source>Even code that will cause runtime errors will not be caught by Flow:</source>
          <target state="translated">런타임 오류를 발생시키는 코드조차도 Flow에 의해 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47439ca5ded64f9ae2fef50d130387798195a012" translate="yes" xml:space="preserve">
          <source>Event Handling</source>
          <target state="translated">이벤트 처리</target>
        </trans-unit>
        <trans-unit id="9c18bb5b6450b86bbb2ec82c62983e3decf5661e" translate="yes" xml:space="preserve">
          <source>Eventually, some features of Flow Strict could become the default behavior of Flow, if those features prove successful and achieve widespread adoption.</source>
          <target state="translated">결국 Flow Strict의 일부 기능은 이러한 기능이 성공하고 널리 채택되면 Flow의 기본 동작이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79794fb5666aa8f0653b4ce2e5a3fce9b026918b" translate="yes" xml:space="preserve">
          <source>Every Flow project contains a &lt;code&gt;.flowconfig&lt;/code&gt; file. You can configure Flow by modifying &lt;code&gt;.flowconfig&lt;/code&gt;. New projects or projects that are starting to use Flow can generate a default &lt;code&gt;.flowconfig&lt;/code&gt; by running &lt;code&gt;flow init&lt;/code&gt;.</source>
          <target state="translated">모든 Flow 프로젝트에는 &lt;code&gt;.flowconfig&lt;/code&gt; 파일이 포함되어 있습니다. &lt;code&gt;.flowconfig&lt;/code&gt; 를 수정하여 흐름을 구성 할 수 있습니다 . Flow를 사용하기 시작한 새 프로젝트 또는 프로젝트는 &lt;code&gt;flow init&lt;/code&gt; 를 실행 하여 기본 &lt;code&gt;.flowconfig&lt;/code&gt; 를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fcb8d8758ed57d0a770a341b51dba1c53659f15" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript can be called with a special context named &lt;code&gt;this&lt;/code&gt;. You can call a function with any context that you want.</source>
          <target state="translated">JavaScript의 모든 함수는 &lt;code&gt;this&lt;/code&gt; 라는 특수 컨텍스트를 사용하여 호출 할 수 있습니다 . 원하는 컨텍스트로 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68197336316b778965bfb2950ace8adb822267f0" translate="yes" xml:space="preserve">
          <source>Exact object types</source>
          <target state="translated">정확한 객체 유형</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="dc536fab9433d34f6445a813d5f0c31792e7fa5f" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0C4TwDgpgBACghgJzgWygXigbwFBSgI0QC4oB+AZ2AQEsA7AcwBpsBfbAMwFdaBjYagPa0oyEADFuPABTsBAkvCTIAlCUo0GWXFGrsoMuQDpCCZVrx4eQ8gIA2EQ7YH0pAIh4ALCDwDWEACYAhK7KANzaAJAIEMCcCMKyAsaIoVAA9GlQ7E4A7lAQCAgCCOSGUACSeiACnFBWyMgQtMBQwF511nYOTkw6LTnFPuTabHja0bHxUK7+EOxwnLYt6nT0ruEsQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0C4TwDgpgBACghgJzgWygXigbwFBSgI0QC4oB+AZ2AQEsA7AcwBpsBfbAMwFdaBjYagPa0oyEADFuPABTsBAkvCTIAlCUo0GWXFGrsoMuQDpCCZVrx4eQ8gIA2EQ7YH0pAIh4ALCDwDWEACYAhK7KANzaAJAIEMCcCMKyAsaIoVAA9GlQ7E4A7lAQCAgCCOSGUACSeiACnFBWyMgQtMBQwF511nYOTkw6LTnFPuTabHja0bHxUK7+EOxwnLYt6nT0ruEsQA&quot;&gt;https://flow.org/try&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="e72839950b0f419947ce4f283294a67029092005" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTU4iAFJgAAsmAGsIXhgoAE8AByoQTAVlF3cvHypUFDQAcnZDEulsLPQrWw5cR2VObkQEJqV6ACZOCSA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTU4iAFJgAAsmAGsIXhgoAE8AByoQTAVlF3cvHypUFDQAcnZDEulsLPQrWw5cR2VObkQEJqV6ACZOCSA&quot;&gt;https://flow.org/try&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="894360e5088d7910eaab73bfa4ad7d6cf97c6f8c" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTW4UPigATwAHKhBMBWUXdy8fKlQUNABydkMs6WwE9CtbDlxHZU5uRAQKpXoAJk4JIA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTW4UPigATwAHKhBMBWUXdy8fKlQUNABydkMs6WwE9CtbDlxHZU5uRAQKpXoAJk4JIA&quot;&gt;https://flow.org/try&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d65710bb9e0679950b0a2fa1e6f5d7c468d7acd2" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQUGESUVBtClAoj1J4hhtUiSlMWMhYfABRGkEAC3CsVy8APmTU1PTiaVi4OnCAAwAVeuxmz1BgwlAAEioJgu0+LJJHUGQx3KdckmxpuZ8+QYTi0D4ExD4gA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQUGESUVBtClAoj1J4hhtUiSlMWMhYfABRGkEAC3CsVy8APmTU1PTiaVi4OnCAAwAVeuxmz1BgwlAAEioJgu0+LJJHUGQx3KdckmxpuZ8+QYTi0D4ExD4gA&quot;&gt;https://flow.org/try&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="80f15d97ffae3b57327c19c2c3876da3f190b457" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQcUxJaVjIWHwAURpBAAtwrFcvAD5k1NThEmJMuDpwgAMAFULsUs9QYMJQABIqLtJ4hj5QGhJHUGQO0Cj5kmxegaoojxHtPmaEm1S+BMQ+IA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQcUxJaVjIWHwAURpBAAtwrFcvAD5k1NThEmJMuDpwgAMAFULsUs9QYMJQABIqLtJ4hj5QGhJHUGQO0Cj5kmxegaoojxHtPmaEm1S+BMQ+IA&quot;&gt;https://flow.org/try&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="322dc85522b6f01f651a645f66ddad7a2d200735" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRo3UmRxKRlk0Bz4zDzJaUwa0DJkABUlAFtMWG5kMLCk1PSaedA6-FgAvLhVMIADABIGLpkNUABGTYTejVEjgAYbhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRo3UmRxKRlk0Bz4zDzJaUwa0DJkABUlAFtMWG5kMLCk1PSaedA6-FgAvLhVMIADABIGLpkNUABGTYTejVEjgAYbhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="d33740834b3eef6ebff52fd563f9384fd43212e0" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRoyZAAVJQBbTFhuZDCwpNT0mj7QN1JYALy4VTCAAwASBhz4zDzJaUwNUABGCYSazVE1gAYDhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRoyZAAVJQBbTFhuZDCwpNT0mj7QN1JYALy4VTCAAwASBhz4zDzJaUwNUABGCYSazVE1gAYDhOcaLQ1HIA&quot;&gt;https://flow.org/try&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="17498ea196f44dae076810df274fc7a54473ddb1" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKABTkBcoRArgLYBGyWAlHQB8ocqADUoAIwBuIA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKABTkBcoRArgLYBGyWAlHQB8ocqADUoAIwBuIA&quot;&gt;https://flow.org/try&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="190c678983df25c000784ac0118a1c78a00727f4" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QAClgAjAFaNQAbwA+oclM7EMNAOahZAApr4AtqNLEtsgL4BKAQD4ZiAJCox4gHTkBoHgCYAzKBAA5AHkAFQBRAEIZbUVQZVUNM1AAB3J2dlJKUFUFGkzySCwjUFwMdiyieAJoTMNQXQMijEgFaDh4DPsyLHxiGlAnAG5EU1YOIidSFiweKTktGLj1TVN3aRiAcmV10FMhlDBuHhEJSenzAb8wAB4AWjvQfBo2PT1SGiJsyFhiUCNib-Y4XCyFQdzB4IhkKh0JhILAACUKNQ6PQbgA3IzsDC0ZiINg0TigbiedzHSRRUAAagWWBUS209UMPzMln4NmkiFAoAcYCcrncXl8ARCEVAAGVVCxSKB6AQFGQHlilmw0eQVOR3lEtNSlLT4podPomcsADQyuUsDXrIh6QjkQrlTqkbq9foSIYjPFjN3iU6eWbyGl0hIrQTSBRSTa07a7ZDEsl+85AA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QAClgAjAFaNQAbwA+oclM7EMNAOahZAApr4AtqNLEtsgL4BKAQD4ZiAJCox4gHTkBoHgCYAzKBAA5AHkAFQBRAEIZbUVQZVUNM1AAB3J2dlJKUFUFGkzySCwjUFwMdiyieAJoTMNQXQMijEgFaDh4DPsyLHxiGlAnAG5EU1YOIidSFiweKTktGLj1TVN3aRiAcmV10FMhlDBuHhEJSenzAb8wAB4AWjvQfBo2PT1SGiJsyFhiUCNib-Y4XCyFQdzB4IhkKh0JhILAACUKNQ6PQbgA3IzsDC0ZiINg0TigbiedzHSRRUAAagWWBUS209UMPzMln4NmkiFAoAcYCcrncXl8ARCEVAAGVVCxSKB6AQFGQHlilmw0eQVOR3lEtNSlLT4podPomcsADQyuUsDXrIh6QjkQrlTqkbq9foSIYjPFjN3iU6eWbyGl0hIrQTSBRSTa07a7ZDEsl+85AA&quot;&gt;https://flow.org/try&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f3309c09c3ccaba2a2970b1e441c41e351e404c8" translate="yes" xml:space="preserve">
          <source>Example (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QACnLFijUAEEx5egB5OxDDQDmoAD4ACmvgC2AI1LEAfAEoBx0AG9EASFSjiAOgAO+djiE8ATAGZzqAByAPIAKgCiAIRSMvKKyiqWLuTs7KSUoMqg5DQZ5JBYRqC4GOyZRPAE0HnQ7LCZNCzQ+JSkoDoGRmUYkNnQcPDpdmRY+MQ02WIA3IgAvqwcRI48EtLEsgpYSqqWggDaAOTk+iwHALozKGDcPCJiplOgqHIAtG+g+I2wurqkNFywYigIzEQHsSKRZCoN4w2Fw+EIxFIqFgABKFGodHoLwAbl0MLRmIg2DROKBuN4BMJHBIACToqjBLFrDbxVQabR6Qwmcz8Sw2UCCp5gRyudyeXzeHgBMAhCLRADKyhYbXoBEmbXcCVA9IxTIYLPkTmNljV+FALByNFgRDcHmyNHoJXZWHq2GGpFG40mxDmC1JSzE3lWsU220SVMOx1OF2QFLuxG8DyAA&quot;&gt;https://flow.org/try&lt;/a&gt;)</source>
          <target state="translated">예 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QACnLFijUAEEx5egB5OxDDQDmoAD4ACmvgC2AI1LEAfAEoBx0AG9EASFSjiAOgAO+djiE8ATAGZzqAByAPIAKgCiAIRSMvKKyiqWLuTs7KSUoMqg5DQZ5JBYRqC4GOyZRPAE0HnQ7LCZNCzQ+JSkoDoGRmUYkNnQcPDpdmRY+MQ02WIA3IgAvqwcRI48EtLEsgpYSqqWggDaAOTk+iwHALozKGDcPCJiplOgqHIAtG+g+I2wurqkNFywYigIzEQHsSKRZCoN4w2Fw+EIxFIqFgABKFGodHoLwAbl0MLRmIg2DROKBuN4BMJHBIACToqjBLFrDbxVQabR6Qwmcz8Sw2UCCp5gRyudyeXzeHgBMAhCLRADKyhYbXoBEmbXcCVA9IxTIYLPkTmNljV+FALByNFgRDcHmyNHoJXZWHq2GGpFG40mxDmC1JSzE3lWsU220SVMOx1OF2QFLuxG8DyAA&quot;&gt;https://flow.org/try&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="5a53b2289397b07076fab02c5763eb1c53631c66" translate="yes" xml:space="preserve">
          <source>Example with custom project root:</source>
          <target state="translated">사용자 정의 프로젝트 루트가있는 예 :</target>
        </trans-unit>
        <trans-unit id="8be9eff630c8880ea37c3c71e5c9f1754569ead1" translate="yes" xml:space="preserve">
          <source>Existential Type (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">존재 유형 ( &lt;code&gt;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7b6e2ec966477f28252b7545083426821a4c2c4e" translate="yes" xml:space="preserve">
          <source>Explicit versions, (e.g. &lt;code&gt;0.22.0&lt;/code&gt;, which only matches &lt;code&gt;0.22.0&lt;/code&gt;).</source>
          <target state="translated">명시 적 버전 (예 : &lt;code&gt;0.22.0&lt;/code&gt; 에만 일치하는 &lt;code&gt;0.22.0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2e0e14ad5753e9c7b526a0cc660e1f093709bbc2" translate="yes" xml:space="preserve">
          <source>Exporting Wrapped Components</source>
          <target state="translated">랩핑 된 컴포넌트 내보내기</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="2113c9e9296853fb527db9a13ccff3f1ceb1a1d8" translate="yes" xml:space="preserve">
          <source>Fields added outside of the class definition need to be annotated within the body of the class.</source>
          <target state="translated">클래스 정의 외부에 추가 된 필드는 클래스 본문에 주석을 달아야합니다.</target>
        </trans-unit>
        <trans-unit id="4a066fa7f532f77d0e18961512951af8ba154e40" translate="yes" xml:space="preserve">
          <source>Fields are annotated within the body of the class with the field name followed by a colon &lt;code&gt;:&lt;/code&gt; and the type.</source>
          <target state="translated">필드는 필드 이름 뒤에 콜론 &lt;code&gt;:&lt;/code&gt; 및 유형으로 클래스 본문에 주석이 달립니다 .</target>
        </trans-unit>
        <trans-unit id="64f266c0fe1d54849f0f9ed285666ffc97ff5171" translate="yes" xml:space="preserve">
          <source>Figuring out types statically</source>
          <target state="translated">정적으로 유형 파악</target>
        </trans-unit>
        <trans-unit id="4530df8ca3479183e9a0b8b7820de3c8dd0aa307" translate="yes" xml:space="preserve">
          <source>Finally, if we had a &lt;code&gt;TypeA&lt;/code&gt; which described the numbers 1 through 3, and a &lt;code&gt;TypeB&lt;/code&gt; which described the numbers 3 through 5. Neither of them would be a subtype of the other. Even though they both have 3 and describe numbers, they each have some unique items.</source>
          <target state="translated">마지막으로, 1에서 3까지의 숫자를 설명 하는 &lt;code&gt;TypeA&lt;/code&gt; 와 3에서 5까지의 숫자를 설명 하는 &lt;code&gt;TypeB&lt;/code&gt; 가 있다면 둘 중 어느 것도 다른 유형의 하위 유형이 아닙니다. 비록 숫자가 3이고 설명 번호가 있지만 각각 고유 한 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0087380702d2e1d3b16fa67500a178f79cae05f8" translate="yes" xml:space="preserve">
          <source>Finally, precision enables useful developer tools to be built. In particular, the quality of results reported by Flow when the developer asks for the type of an expression, the definition reaching a reference, or the set of possible completions at a point through an IDE is correlated with the precision of Flow&amp;rsquo;s analysis.</source>
          <target state="translated">마지막으로 정밀도는 유용한 개발자 도구를 구축 할 수있게합니다. 특히 개발자가 식의 유형, 참조에 도달 한 정의 또는 IDE를 통한 지점에서 가능한 완성 세트를 요청할 때 Flow가보고 한 결과의 품질은 Flow의 분석 정밀도와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c5cf005d2302c6d3946a6acb658df51d720297" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ll have yet another &lt;code&gt;SubClass&lt;/code&gt; that accepts a value of a more specific type.</source>
          <target state="translated">마지막으로, 보다 구체적인 유형의 값을 허용하는 또 다른 &lt;code&gt;SubClass&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dac3b0962e00de97e4f2ee26698e83fa3a80f1ef" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;flow-remove-types&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;flow-remove-types&lt;/code&gt; 을 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; 또는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm으로 설치하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2eea5de09d8e90691b2d177dd08996669f26aa" translate="yes" xml:space="preserve">
          <source>First we&amp;rsquo;ll setup a couple of classes that extend one another.</source>
          <target state="translated">먼저 서로 확장되는 몇 가지 클래스를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="456cf8a255eb59ebf894cb52911a86af4e0bff54" translate="yes" xml:space="preserve">
          <source>Fixed example:</source>
          <target state="translated">고정 된 예 :</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="5f486e379bef52ad99c92a90171eb0881d4b0d3f" translate="yes" xml:space="preserve">
          <source>Flow + Redux resources</source>
          <target state="translated">흐름 + Redux 리소스</target>
        </trans-unit>
        <trans-unit id="55ec9aab6133cd88e4cf42e5ab878820aef8afea" translate="yes" xml:space="preserve">
          <source>Flow CLI</source>
          <target state="translated">흐름 CLI</target>
        </trans-unit>
        <trans-unit id="8b609ab9406ce02a4ce30abc841ff2dba941e173" translate="yes" xml:space="preserve">
          <source>Flow For Sublime Text 2 and 3</source>
          <target state="translated">숭고한 텍스트 2와 3의 흐름</target>
        </trans-unit>
        <trans-unit id="aa235a6660a8f1b9aa16724f3a8222516b8f655e" translate="yes" xml:space="preserve">
          <source>Flow Strict</source>
          <target state="translated">흐름 엄격한</target>
        </trans-unit>
        <trans-unit id="f2ec6e6dfc95e327edb4e1795150f27d42969c4f" translate="yes" xml:space="preserve">
          <source>Flow Strict is configured in each &lt;code&gt;.flowconfig&lt;/code&gt;. To enable:</source>
          <target state="translated">Flow Strict는 각 &lt;code&gt;.flowconfig&lt;/code&gt; 에서 구성됩니다 . 사용하려면:</target>
        </trans-unit>
        <trans-unit id="8095395f626e2f4759824d2de551bb30bbe955c2" translate="yes" xml:space="preserve">
          <source>Flow also supports importing the type of values exported by other modules using &lt;a href=&quot;../typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Flow는 &lt;a href=&quot;../typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; 를&lt;/a&gt; 사용하여 다른 모듈에서 내 보낸 값 유형 가져 오기도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="b5565b1d0068dc56bcf908f48c68d08d32bae353" translate="yes" xml:space="preserve">
          <source>Flow also supports using the &lt;a href=&quot;https://tc39.github.io/proposal-class-public-fields/&quot;&gt;class properties syntax&lt;/a&gt;.</source>
          <target state="translated">Flow는 &lt;a href=&quot;https://tc39.github.io/proposal-class-public-fields/&quot;&gt;클래스 속성 구문&lt;/a&gt; 사용을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="e84982c22a83ff1714857618c803fc295ca0cb49" translate="yes" xml:space="preserve">
          <source>Flow and &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; are designed to work great together. It takes just a few steps to set them up together.</source>
          <target state="translated">Flow와 &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 은 함께 작동하도록 설계되었습니다. 함께 설정하려면 몇 단계 만 거치면됩니다.</target>
        </trans-unit>
        <trans-unit id="5ccb8cfec36d4d1243e598e54059dcef046eb1fd" translate="yes" xml:space="preserve">
          <source>Flow and Babel work well together, so it doesn&amp;rsquo;t take much to adopt Flow as a React user who already uses Babel. If you need to setup Babel with Flow, you can follow &lt;a href=&quot;https://flow.org/en/tools/babel/&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">Flow와 Babel은 함께 작동하므로 Flow를 이미 Babel을 사용하는 React 사용자로 채택하는 데 많은 시간이 걸리지 않습니다. Babel을 Flow로 설정해야하는 &lt;a href=&quot;https://flow.org/en/tools/babel/&quot;&gt;경우이 안내서를&lt;/a&gt; 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="12bd6e3068284e323e6e5441c7cbe62cfa2eaa15" translate="yes" xml:space="preserve">
          <source>Flow can either infer the type from the value you are assigning to it or you can provide it with a type.</source>
          <target state="translated">흐름은 할당 한 값에서 유형을 유추하거나 유형을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72ce261a07a9b54acdbe6ade8c25b4096bc1b01e" translate="yes" xml:space="preserve">
          <source>Flow can handle both CommonJS and ES modules, but there are some relevant differences between the two that need to be considered when using &lt;code&gt;declare module&lt;/code&gt;.</source>
          <target state="translated">Flow는 CommonJS와 ES 모듈을 모두 처리 할 수 ​​있지만, &lt;code&gt;declare module&lt;/code&gt; 을 사용할 때 고려해야 할 두 가지 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4fd2a75a67392ac133c52fa3dfe6c46849561bc" translate="yes" xml:space="preserve">
          <source>Flow can infer the type of object literals in two different ways depending on how they are used.</source>
          <target state="translated">흐름은 사용 방법에 따라 두 가지 방식으로 객체 리터럴 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98d85338f7ba2bc3651bb2436f50fc5aeb15f4f6" translate="yes" xml:space="preserve">
          <source>Flow can typecheck your React components that use the &lt;a href=&quot;https://reactjs.org/docs/context.html&quot;&gt;context API&lt;/a&gt; introduced in React 16.3.</source>
          <target state="translated">Flow는 React 16.3에 도입 된 &lt;a href=&quot;https://reactjs.org/docs/context.html&quot;&gt;컨텍스트 API&lt;/a&gt; 를 사용하는 React 컴포넌트를 유형 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6944ed8c8b4918d2dec469bbf6c3dc20723ec0d8" translate="yes" xml:space="preserve">
          <source>Flow cannot understand the types of my higher order React component, how can I help it?</source>
          <target state="translated">Flow에서 상위 React 구성 요소의 유형을 이해할 수 없습니다. 어떻게 도와 드릴까요?</target>
        </trans-unit>
        <trans-unit id="183d1f29f5ed63eb14ac2b0f3910cf9d83903afb" translate="yes" xml:space="preserve">
          <source>Flow checks your code for errors through &lt;strong&gt;static type annotations&lt;/strong&gt;. These &lt;em&gt;types&lt;/em&gt; allow you to tell Flow how you want your code to work, and Flow will make sure it does work that way.</source>
          <target state="translated">Flow는 &lt;strong&gt;정적 형식 주석을&lt;/strong&gt; 통해 코드 오류를 검사합니다 . 이러한 &lt;em&gt;유형을&lt;/em&gt; 사용하면 Flow가 코드 작동 방식을 알 수 있으며 Flow는 해당 방식으로 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="04032a68a1402eaf71bab9646202a4ad15b6268c" translate="yes" xml:space="preserve">
          <source>Flow chooses what is natural for JavaScript, and should behave the way you expect it to.</source>
          <target state="translated">Flow는 JavaScript에 자연스러운 것을 선택하고 예상 한대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="032ca5c444d8fb1a1677e49ec7f5f65de9cb839b" translate="yes" xml:space="preserve">
          <source>Flow contains a linting framework that can tell you about more than just type errors. This framework is highly configurable in order to show you the information you want and hide the information you don&amp;rsquo;t.</source>
          <target state="translated">Flow에는 단순한 형식 오류 이상의 정보를 제공하는 린트 프레임 워크가 포함되어 있습니다. 이 프레임 워크는 원하는 정보를 표시하고 원하지 않는 정보를 숨기기 위해 고도로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a9a662da9d9494227dfb8c32f7a3a00aa8eb74d" translate="yes" xml:space="preserve">
          <source>Flow does all sorts of type inference on your code so that you don&amp;rsquo;t have to type annotate anything. Generally, inference avoids getting in your way while still preventing you from introducing bugs.</source>
          <target state="translated">Flow는 코드에 대해 모든 유형의 유추를 수행하므로 주석을 달지 않아도됩니다. 일반적으로 추론은 방해가되지 않으면서도 버그가 발생하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c4a7493c100b0d7186e5d7a811ec01b5c49ff79d" translate="yes" xml:space="preserve">
          <source>Flow does not do this because it would be extremely inconvenient to use. You would be forced to refine the type of every value you get when accessing an array.</source>
          <target state="translated">플로우는 사용하기가 매우 불편하므로이 작업을 수행하지 않습니다. 배열에 액세스 할 때 얻는 모든 값의 유형을 세분화해야합니다.</target>
        </trans-unit>
        <trans-unit id="25bf8feebd194c6ea5f28b8c0c675bd8e2749e24" translate="yes" xml:space="preserve">
          <source>Flow does not keep track of side effects, so any function call may potentially nullify your check. This is called &lt;a href=&quot;lang/refinements#toc-refinement-invalidations&quot;&gt;refinement invalidation&lt;/a&gt;.</source>
          <target state="translated">흐름은 부작용을 추적하지 않으므로 함수 호출로 인해 검사가 무효화 될 수 있습니다. 이를 &lt;a href=&quot;lang/refinements#toc-refinement-invalidations&quot;&gt;정제 무효화&lt;/a&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="f3f46e4e936a3e8537064c3745c26d7fd98211da" translate="yes" xml:space="preserve">
          <source>Flow doesn&amp;rsquo;t track refinements made in separated function calls.</source>
          <target state="translated">Flow는 분리 된 함수 호출에서 작성된 세분화를 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59a4ef57b455273cbb11be7412569d3ac42e4710" translate="yes" xml:space="preserve">
          <source>Flow for Atom IDE</source>
          <target state="translated">아톰 IDE의 흐름</target>
        </trans-unit>
        <trans-unit id="44fdaae0716bb1f8df6934754643b2d31169e8f0" translate="yes" xml:space="preserve">
          <source>Flow has &lt;a href=&quot;../primitives&quot;&gt;primitive types&lt;/a&gt; for literal values, but can also use literal values as types.</source>
          <target state="translated">흐름에는 리터럴 값에 대한 &lt;a href=&quot;../primitives&quot;&gt;기본 유형&lt;/a&gt; 이 있지만 리터럴 값을 유형으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="46a176a435a62da90c46dd0328bea203b7bb04be" translate="yes" xml:space="preserve">
          <source>Flow has a powerful ability to infer the types of your programs. The majority of your code can rely on it. Still, there are places where you&amp;rsquo;ll want to add types.</source>
          <target state="translated">Flow에는 프로그램 유형을 유추 할 수있는 강력한 기능이 있습니다. 대부분의 코드가이 코드에 의존 할 수 있습니다. 여전히 유형을 추가하려는 곳이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91780aa64a146a3b1363ded13b2a26ff2a5703d2" translate="yes" xml:space="preserve">
          <source>Flow has builtin library definitions. Setting this to &lt;code&gt;true&lt;/code&gt; will tell Flow to ignore the builtin library definitions.</source>
          <target state="translated">Flow에는 내장 라이브러리 정의가 있습니다. 이것을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Flow가 내장 라이브러리 정의를 무시하도록합니다.</target>
        </trans-unit>
        <trans-unit id="825a2af8b1f4018e85d11b13cda08105f2561dfc" translate="yes" xml:space="preserve">
          <source>Flow has worked with Nuclide directly on adding support for the new warning severity level. Certain features are likely to be in other editors, but others might not yet be implemented.</source>
          <target state="translated">Flow는 새로운 경고 심각도 수준에 대한 지원을 추가하기 위해 Nuclide와 직접 협력했습니다. 특정 기능은 다른 편집기에있을 수 있지만 다른 기능은 아직 구현되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f749e30856c0772a3eb06d3b18fcad17982d0c5" translate="yes" xml:space="preserve">
          <source>Flow is a static type checker for JavaScript that we built at Facebook. The overall mission of Flow is to deliver an immersive coding experience for JavaScript developers&amp;mdash;a fast edit-refresh cycle&amp;mdash;even as the codebase evolves and grows. In engineering terms, we identify two concrete goals that are important to this mission: &lt;em&gt;precision&lt;/em&gt; and &lt;em&gt;speed&lt;/em&gt;. These goals pervasively drive the design and implementation.</source>
          <target state="translated">Flow는 Facebook에서 빌드 한 JavaScript의 정적 유형 검사기입니다. Flow의 전반적인 임무는 코드베이스가 발전하고 성장하더라도 JavaScript 편집자에게 빠른 편집-새로 고침주기를위한 몰입 형 코딩 환경을 제공하는 것입니다. 엔지니어링 용어로 우리는이 임무에 중요한 두 가지 구체적인 목표, 즉 &lt;em&gt;정밀도&lt;/em&gt; 와 &lt;em&gt;속도를&lt;/em&gt; 식별 합니다. 이러한 목표는 설계 및 구현을 광범위하게 주도합니다.</target>
        </trans-unit>
        <trans-unit id="e37ba63533b865ecc3dbf31c3bc219eae3775a54" translate="yes" xml:space="preserve">
          <source>Flow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale.</source>
          <target state="translated">Flow는 JavaScript 코드의 정적 유형 검사기입니다. 생산성을 높이기 위해 많은 작업을 수행합니다. 더 빠르고 똑똑하고 자신감 있고 더 큰 규모로 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eccc6e8d7aae412ab111e4ae2e8f9d87e9acb8a6" translate="yes" xml:space="preserve">
          <source>Flow is not &lt;a href=&quot;https://flow.org/en/lang/types-and-expressions/#soundness-and-completeness&quot;&gt;complete&lt;/a&gt;, so it cannot check all code perfectly. Instead, Flow will make conservative assumptions to try to be sound.</source>
          <target state="translated">흐름이 &lt;a href=&quot;https://flow.org/en/lang/types-and-expressions/#soundness-and-completeness&quot;&gt;완료&lt;/a&gt; 되지 않았 으므로 모든 코드를 완벽하게 확인할 수 없습니다. 대신 Flow는 건전한 노력을하기 위해 보수적 인 가정을합니다.</target>
        </trans-unit>
        <trans-unit id="f5a3fb20b94174faf688a6da7dfab78f503bda2d" translate="yes" xml:space="preserve">
          <source>Flow needs a way to be able to figure out the type of every expression. But it can&amp;rsquo;t just run your code to figure it out, if it did it would be affected by any issues that your code has. For example, if you created an infinite loop Flow would wait for it to finish forever.</source>
          <target state="translated">흐름은 모든 표현의 유형을 알아낼 수있는 방법이 필요합니다. 그러나 코드에 문제가 있으면 코드를 실행하여 코드를 파악할 수는 없습니다. 예를 들어, 무한 루프를 만들면 Flow는 영원히 끝날 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="c320f7d736c792bfa9520f9145672090f7b71c98" translate="yes" xml:space="preserve">
          <source>Flow needs to compare more than just sets of primitive values, it also needs to be able to compare objects, functions, and every other type that appears in the language.</source>
          <target state="translated">흐름은 단순한 기본 값 집합 이상을 비교해야하며 언어로 나타나는 객체, 함수 및 기타 모든 유형을 비교할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="197f7b0842bf7c4d39085530e1c9d6e1647ccda5" translate="yes" xml:space="preserve">
          <source>Flow needs to know which files to parse and of those how to handle any Flow types within them. For third party libraries you may wish to not parse, parse but not preserve types, or parse but not raise errors, depending on the quality and compatibility of their Flow implementation.</source>
          <target state="translated">Flow는 구문 분석 할 파일과 파일 내에서 Flow 유형을 처리하는 방법을 알아야합니다. 타사 라이브러리의 경우 흐름 구현의 품질과 호환성에 따라 형식을 구문 분석, 구문 분석하지만 보존하지 않거나 구문 분석하지만 오류를 발생시키지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa11ea1401156a6f5d8e119dec34779c7787d52c" translate="yes" xml:space="preserve">
          <source>Flow needs to know which files to read and watch for changes. This set of files is determined by taking all included files and excluding all the ignored files.</source>
          <target state="translated">Flow는 어떤 파일을 읽고 변경을 감시해야하는지 알아야합니다. 이 파일 세트는 포함 된 모든 파일을 가져와 무시 된 모든 파일을 제외하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e74d4f194fac00619d8f08bc6cfdf7a46e8a3401" translate="yes" xml:space="preserve">
          <source>Flow provides a set of utility types to operate on other types, and can be useful for different scenarios.</source>
          <target state="translated">Flow는 다른 유형에서 작동하는 유틸리티 유형 세트를 제공하며 다른 시나리오에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1431a76ac3b525222744b6e84e9e4ddfb3690671" translate="yes" xml:space="preserve">
          <source>Flow reads &lt;code&gt;package.json&lt;/code&gt; files for the &lt;code&gt;&quot;name&quot;&lt;/code&gt; and &lt;code&gt;&quot;main&quot;&lt;/code&gt; fields to figure out the name of the module and which file should be used to provide that module.</source>
          <target state="translated">Flow 는 &lt;code&gt;&quot;name&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 필드에 대한 &lt;code&gt;package.json&lt;/code&gt; 파일을 읽어 모듈 이름과 해당 모듈을 제공하는 데 사용해야하는 파일을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="e11220e33346b1bf7474cc77bed10da16b3fdb63" translate="yes" xml:space="preserve">
          <source>Flow requires type annotations at module boundaries to make sure it can scale. To read more about that, check out our &lt;a href=&quot;https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8&quot;&gt;blog post&lt;/a&gt; about that.</source>
          <target state="translated">Flow는 확장이 가능하도록 모듈 경계에 유형 주석이 필요합니다. 이에 대한 자세한 내용을 보려면 &lt;a href=&quot;https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8&quot;&gt;블로그 게시물을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="84d0f858caf5dd7487404da9c0e086ed565c074e" translate="yes" xml:space="preserve">
          <source>Flow supports a comment-based syntax, which makes it possible to use Flow without having to compile your files.</source>
          <target state="translated">Flow는 주석 기반 구문을 지원하므로 파일을 컴파일하지 않고도 Flow를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25dce24924ffe50d06ea3c27504223de08877a30" translate="yes" xml:space="preserve">
          <source>Flow tracks the specific type of the value you pass through a generic, letting you use it later.</source>
          <target state="translated">흐름은 제네릭을 통과 한 특정 유형의 값을 추적하여 나중에 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4543e6960bdd40f7fd529d611087695f4d5149d5" translate="yes" xml:space="preserve">
          <source>Flow tries to avoid parsing non-flow files. This means Flow needs to start lexing a file to see if it has &lt;code&gt;@flow&lt;/code&gt; or &lt;code&gt;@noflow&lt;/code&gt; in it. This option lets you configure how much of the file Flow lexes before it decides there is no relevant docblock.</source>
          <target state="translated">흐름은 비 흐름 파일의 구문 분석을 피하려고합니다. 즉, Flow에 파일을 렉싱하여 &lt;code&gt;@flow&lt;/code&gt; 또는 &lt;code&gt;@noflow&lt;/code&gt; 가 있는지 확인해야 합니다. 이 옵션을 사용하면 관련 docblock이없는 것으로 결정하기 전에 Flow lexe 파일의 양을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52553dd61330137688c84a4912b70f866c01b523" translate="yes" xml:space="preserve">
          <source>Flow tries to be as sound and complete as possible. But because JavaScript was not designed around a type system, Flow sometimes has to make a tradeoff. When this happens Flow tends to favor soundness over completeness, ensuring that code doesn&amp;rsquo;t have any bugs.</source>
          <target state="translated">흐름은 가능한 한 건전하고 완벽 해 지려고합니다. 그러나 JavaScript는 유형 시스템을 중심으로 설계되지 않았기 때문에 Flow는 때때로 트레이드 오프를해야합니다. 이런 일이 발생하면 Flow는 완전성보다 건전성을 선호하여 코드에 버그가 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7d011e99cc7dbd500d87676f164a01cb49e80345" translate="yes" xml:space="preserve">
          <source>Flow tries to work out of the box as much as possible, but can be configured to work with any codebase.</source>
          <target state="translated">Flow는 가능한 한 많은 작업을 시도하지만 모든 코드베이스에서 작동하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb7d367d74212ddc0e35250289a131174450c8b9" translate="yes" xml:space="preserve">
          <source>Flow understands these conversions and will allow any of them as part of an &lt;code&gt;if&lt;/code&gt; statement and other types of expressions.</source>
          <target state="translated">Flow는 이러한 변환을 이해하고 &lt;code&gt;if&lt;/code&gt; 문 및 다른 유형의 표현식의 일부로 이들 변환을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="5bea5ed86f8a457903d5905c971362464ec56214" translate="yes" xml:space="preserve">
          <source>Flow was designed for easy adoption, so it allows you opt-out of type checking in certain situations, permitting unsafe behaviors. But since many codebases now have a high adoption of Flow types, this trade-off can be flipped. You can use &lt;em&gt;Flow Strict&lt;/em&gt; to disallow previously-allowed unsafe patterns. This gives you improved safety guarantees that catch more bugs and make refactoring easier. And you can implement these stronger guarantees incrementally, on a file-by-file basis.</source>
          <target state="translated">Flow는 쉽게 채택 할 수 있도록 설계되었으므로 특정 상황에서 유형 검사를 거부하여 안전하지 않은 동작을 허용합니다. 그러나 현재 많은 코드베이스가 Flow 유형을 많이 채택하고 있으므로이 절충안을 뒤집을 수 있습니다. &lt;em&gt;Flow Strict&lt;/em&gt; 를 사용 하여 이전에 허용되지 않은 안전하지 않은 패턴을 허용하지 않을 수 있습니다. 이를 통해 더 많은 버그를 포착하고 리팩토링을보다 쉽게 ​​수행 할 수있는 향상된 안전성을 보장합니다. 또한 파일 단위로 이러한 강력한 보증을 점진적으로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1595a2bf188fc4b7ef46616052b38b6e681bb494" translate="yes" xml:space="preserve">
          <source>Flow will be run as part of create-react-app&amp;rsquo;s scripts.</source>
          <target state="translated">흐름은 create-react-app 스크립트의 일부로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="338d618c9a13ce96682c1d7e15f73ae7f8964da4" translate="yes" xml:space="preserve">
          <source>Flow will infer the type of your default props from &lt;code&gt;static defaultProps&lt;/code&gt; so you don&amp;rsquo;t have to add any type annotations to use default props.</source>
          <target state="translated">Flow는 &lt;code&gt;static defaultProps&lt;/code&gt; 에서 기본 소품의 유형을 유추 하므로 기본 소품을 사용하기 위해 유형 주석을 추가하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="9184e4b7870b602025b0689241850daf93e22df5" translate="yes" xml:space="preserve">
          <source>Flow will infer types from the way you use a context&amp;rsquo;s &lt;code&gt;{Provider,Consumer}&lt;/code&gt; pair:</source>
          <target state="translated">흐름은 컨텍스트의 &lt;code&gt;{Provider,Consumer}&lt;/code&gt; 쌍 을 사용하는 방식에서 유형을 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="3e54a4925e33a70ee19276a34ddf5663b9fa39c5" translate="yes" xml:space="preserve">
          <source>Flow will only accept strings and number when concatenating them to strings.</source>
          <target state="translated">흐름은 문자열과 숫자를 문자열로 연결할 때만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5eab08add042bdc755cadabf5fe2a07bc373a954" translate="yes" xml:space="preserve">
          <source>Flow will unsoundly allow this last cast to succeed. If this behavior is not wanted, then this utility type should be avoided.</source>
          <target state="translated">흐름으로 인해이 마지막 캐스트가 성공할 수 있습니다. 이 동작을 원하지 않으면이 유틸리티 유형을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fb359e7b8aa5962ece67701ffa1a8439b019086" translate="yes" xml:space="preserve">
          <source>Flow will use &lt;code&gt;bar.js&lt;/code&gt; to provide the &lt;code&gt;&quot;kittens&quot;&lt;/code&gt; module.</source>
          <target state="translated">Flow는 &lt;code&gt;bar.js&lt;/code&gt; 를 사용하여 &lt;code&gt;&quot;kittens&quot;&lt;/code&gt; 모듈 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="db39464b47c1acee0eb7fa411eeb1a89946c2d9f" translate="yes" xml:space="preserve">
          <source>Flow&amp;rsquo;s editor integration is primarily via the &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server Protocol&lt;/a&gt;. There are &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/implementors/tools/&quot;&gt;many vim LSP clients&lt;/a&gt; to choose from, such as &lt;a href=&quot;#toc-ale&quot;&gt;ALE&lt;/a&gt;.</source>
          <target state="translated">Flow의 편집기 통합은 주로 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;언어 서버 프로토콜을&lt;/a&gt; 통해 이루어 집니다. 있습니다 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/implementors/tools/&quot;&gt;많은 정력의 LSP 클라이언트&lt;/a&gt; 와 같은 선택, &lt;a href=&quot;#toc-ale&quot;&gt;ALE은&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35e134c2f20bf81b3b896daf47c04ac35fee3088" translate="yes" xml:space="preserve">
          <source>Flow&amp;rsquo;s shared memory lives in a memory mapped file. On more modern versions of Linux (3.17+), there is a system call &lt;code&gt;memfd_create&lt;/code&gt; which allows Flow to create the file anonymously and only in memory. However, in older kernels, Flow needs to create a file on the file system. Ideally this file lives on a memory-backed tmpfs. This option lets you decide where that file is created.</source>
          <target state="translated">Flow의 공유 메모리는 메모리 매핑 된 파일에 있습니다. 최신 버전의 Linux (3.17+)에는 시스템 호출 &lt;code&gt;memfd_create&lt;/code&gt; 가있어 Flow가 파일을 익명으로 만 메모리에 만들 수 있습니다. 그러나 이전 커널에서는 Flow가 파일 시스템에서 파일을 작성해야합니다. 이상적으로이 파일은 메모리 지원 tmpfs에 있습니다. 이 옵션을 사용하면 파일이 생성되는 위치를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a151dc47e59f85e9ca3816a57d33d5371e099290" translate="yes" xml:space="preserve">
          <source>Flow-IDE</source>
          <target state="translated">Flow-IDE</target>
        </trans-unit>
        <trans-unit id="4dbea89f685901895c4ece7a62f739b66b6c8c38" translate="yes" xml:space="preserve">
          <source>Flow-Language-Support</source>
          <target state="translated">Flow-Language-Support</target>
        </trans-unit>
        <trans-unit id="52981c30a079c03c2816af01a0b63be9bf496116" translate="yes" xml:space="preserve">
          <source>Flow: Goals</source>
          <target state="translated">흐름 : 목표</target>
        </trans-unit>
        <trans-unit id="193cbf05588eacbb65a1c0ac7089a698e31d43b1" translate="yes" xml:space="preserve">
          <source>Flowlint Comments</source>
          <target state="translated">Flowlint 코멘트</target>
        </trans-unit>
        <trans-unit id="189ce1cc1d3d009f899bc0f0bdf7826fa8c95970" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://github.com/w0rp/ale#3-installation&quot;&gt;instructions&lt;/a&gt; in the ALE README.</source>
          <target state="translated">ALE README 의 &lt;a href=&quot;https://github.com/w0rp/ale#3-installation&quot;&gt;지침&lt;/a&gt; 을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="6a6549a69a2a1d5be1e060e92d176ddae49cb2f2" translate="yes" xml:space="preserve">
          <source>Following our example from &lt;a href=&quot;#toc-objmap&quot;&gt;&lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, let&amp;rsquo;s assume that &lt;code&gt;run&lt;/code&gt; takes an array of functions, instead of an object, and maps over them returning an array of the function call results. We could annotate its return type like this:</source>
          <target state="translated">&lt;a href=&quot;#toc-objmap&quot;&gt; &lt;code&gt;$ObjMap&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 예제에 따라 &lt;code&gt;run&lt;/code&gt; 이 객체 대신 함수의 배열을 가져 와서 함수 호출 결과의 배열을 반환하는 함수를 매핑 한다고 가정합니다 . 다음과 같이 반환 유형에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4d289d3b1dd5ba9aa2a66d282cd434d4d6eef2" translate="yes" xml:space="preserve">
          <source>For a full list of available lint rules, see the &lt;a href=&quot;https://flow.org/en/linting/rule-reference/&quot;&gt;Lint Rule Reference&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 린트 규칙의 전체 목록은 &lt;a href=&quot;https://flow.org/en/linting/rule-reference/&quot;&gt;Lint Rule Reference를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b22a41ca2285196cb7b3e9c1ec2990d2a5b7b1" translate="yes" xml:space="preserve">
          <source>For cases like this where it&amp;rsquo;s useful to assert the absence of a property, Flow provides a special syntax for &lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;&amp;ldquo;exact&amp;rdquo; object types&lt;/a&gt;.</source>
          <target state="translated">속성이 없다고 주장하는 것이 유용한 경우와 같이 Flow는 &lt;a href=&quot;https://flow.org/en/types/objects/#toc-exact-object-types&quot;&gt;&amp;ldquo;정확한&amp;rdquo;객체 유형에&lt;/a&gt; 대한 특별한 구문을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2ea9b94790107e111f7ed5653f532123efce19c9" translate="yes" xml:space="preserve">
          <source>For classes that take type parameters, you must also provide the parameter. For example:</source>
          <target state="translated">유형 매개 변수를 사용하는 클래스의 경우 매개 변수도 제공해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="c6f67e406326ac835e3cac37e1771059c44a2f4c" translate="yes" xml:space="preserve">
          <source>For example if you want to get a normal JavaScript array from a &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; see the following example:</source>
          <target state="translated">예를 들어 &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; 에서 일반 JavaScript 배열을 가져 오려면 다음 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="eb4d70e0d036fa1748a5b85d77f3bc5e2328c134" translate="yes" xml:space="preserve">
          <source>For example, Flow uses structural typing for objects and functions, but nominal typing for classes.</source>
          <target state="translated">예를 들어 Flow는 객체와 함수에 구조적 타이핑을 사용하지만 클래스에는 공칭 타이핑을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7349dc404f299437995005ad91a4e45b836943bc" translate="yes" xml:space="preserve">
          <source>For example, a type alias with a generic is parameterized. When you go to use it you will have to provide a type argument.</source>
          <target state="translated">예를 들어, 제네릭이있는 유형 별칭이 매개 변수화됩니다. 당신이 그것을 사용하려고하면 형식 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="019f85d55639d616f40bcfd5b84f65f5245b2f0d" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;/path/to/root/.flowconfig&lt;/code&gt; contains the following &lt;code&gt;[include]&lt;/code&gt; section:</source>
          <target state="translated">예를 들어, &lt;code&gt;/path/to/root/.flowconfig&lt;/code&gt; 에 다음 &lt;code&gt;[include]&lt;/code&gt; 섹션이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="8308d7d3a3b1e0a7a0c7ff7fe6095b8469e2ca83" translate="yes" xml:space="preserve">
          <source>For example, if we had a &lt;code&gt;TypeA&lt;/code&gt; which described the numbers 1 through 3, and a &lt;code&gt;TypeB&lt;/code&gt; which described the numbers 1 through 5: &lt;code&gt;TypeA&lt;/code&gt; would be considered a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;TypeB&lt;/code&gt;, because &lt;code&gt;TypeA&lt;/code&gt; is a subset of &lt;code&gt;TypeB&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 우리는이 있다면 &lt;code&gt;TypeA&lt;/code&gt; 3까지의 숫자 1을 설명하고, &lt;code&gt;TypeB&lt;/code&gt; 5까지의 숫자 1을 설명 : &lt;code&gt;TypeA&lt;/code&gt; 고려되는 것 &lt;em&gt;하위 유형&lt;/em&gt; 의 &lt;code&gt;TypeB&lt;/code&gt; 하기 때문에, &lt;code&gt;TypeA&lt;/code&gt; 의 하위 집합입니다 &lt;code&gt;TypeB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1f46c1686b7fc66c7fe476a788c1c2f746e357" translate="yes" xml:space="preserve">
          <source>For example, if we had an &lt;code&gt;ObjectA&lt;/code&gt; which contained the key &lt;code&gt;foo&lt;/code&gt;, and an &lt;code&gt;ObjectB&lt;/code&gt; which contained the keys &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. Then it&amp;rsquo;s possible that &lt;code&gt;ObjectB&lt;/code&gt; is a subtype of &lt;code&gt;ObjectA&lt;/code&gt;.</source>
          <target state="translated">우리가 가지고 예를 들어, &lt;code&gt;ObjectA&lt;/code&gt; 키 포함 &lt;code&gt;foo&lt;/code&gt; 는 및 &lt;code&gt;ObjectB&lt;/code&gt; 포함되는 키는 &lt;code&gt;foo&lt;/code&gt; 는 과 &lt;code&gt;bar&lt;/code&gt; . 그러면 &lt;code&gt;ObjectB&lt;/code&gt; 가 ObjectA 의 하위 &lt;code&gt;ObjectA&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d2a83693c74cdf1216f4c41606ab3b6344cfb1" translate="yes" xml:space="preserve">
          <source>For example, if we have a value with a union type that is a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;boolean&lt;/code&gt;, or a &lt;code&gt;string&lt;/code&gt;, we can treat the number case separately by using JavaScript&amp;rsquo;s &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">예를 들어, &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 인 공용체 유형의 값이 있으면 JavaScript의 &lt;code&gt;typeof&lt;/code&gt; 연산자를 사용하여 숫자를 개별적으로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f0bba8ae13a9f5893bc26e1914082a5b9531069" translate="yes" xml:space="preserve">
          <source>For example, if you do:</source>
          <target state="translated">예를 들어, 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="65cad2079cddef1c7f55821c6579030cdb56abc4" translate="yes" xml:space="preserve">
          <source>For example, if you get a property on an object typed &lt;code&gt;any&lt;/code&gt;, the resulting value will also have the type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;any&lt;/code&gt; 유형의 객체에서 속성을 얻는 경우 결과 값의 유형은 &lt;code&gt;any&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d2c0eb517854e42dedcf683011bb1eed6441385" translate="yes" xml:space="preserve">
          <source>For example, if you merge two objects with a property named prop, one with a type of number and another with a type of boolean, the resulting object will have an intersection of number and boolean.</source>
          <target state="translated">예를 들어, 이름이 prop 인 특성 (하나는 숫자 유형이고 다른 하나는 부울 유형)으로 두 오브젝트를 병합하는 경우 결과 오브젝트는 숫자와 부울의 교차점을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0ff184d53e398a510529293cf769afe6beb5de53" translate="yes" xml:space="preserve">
          <source>For example, if you use &lt;code&gt;typeof&lt;/code&gt; with a class you need to remember that classes are &lt;em&gt;nominally&lt;/em&gt; typed instead of &lt;em&gt;structurally&lt;/em&gt; typed. So that two classes with the same exact shape are not considered equivalent.</source>
          <target state="translated">예를 들어, 클래스와 함께 &lt;code&gt;typeof&lt;/code&gt; 를 사용하는 경우 클래스는 &lt;em&gt;구조적으로&lt;/em&gt; 형식화되지 않고 &lt;em&gt;명목상&lt;/em&gt; 형식화 된다는 것을 기억해야합니다 . 따라서 정확한 모양이 동일한 두 클래스는 동등한 것으로 간주되지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="725f953bd64b3a92b317e1b1004670c00e1cbdb9" translate="yes" xml:space="preserve">
          <source>For example, imagine we have a function for handling a response from a server after we&amp;rsquo;ve sent it a request. When the request is successful, we&amp;rsquo;ll get back an object with a &lt;code&gt;success&lt;/code&gt; property which is &lt;code&gt;true&lt;/code&gt; and a &lt;code&gt;value&lt;/code&gt; that we&amp;rsquo;ve updated.</source>
          <target state="translated">예를 들어 요청을 보낸 후 서버의 응답을 처리하는 기능이 있다고 가정합니다. 요청이 성공하면, 우리는 가진 개체 다시 얻을 것이다 &lt;code&gt;success&lt;/code&gt; 이다 재산 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;value&lt;/code&gt; 우리가 업데이트했는지를.</target>
        </trans-unit>
        <trans-unit id="3102783616c1fb2ad801701f0f1fe894f5a7f3c4" translate="yes" xml:space="preserve">
          <source>For example, in order to know if you are calling a function correctly, Flow needs to compare the arguments you are passing with the parameters the function expects.</source>
          <target state="translated">예를 들어, 함수를 올바르게 호출하고 있는지 확인하려면 Flow는 전달할 인수와 함수가 기대하는 매개 변수를 비교해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4c3b99484dfdd0c8d74a80cfc7020381cb7fd5b" translate="yes" xml:space="preserve">
          <source>For example, instead of accepting &lt;code&gt;number&lt;/code&gt; type, we could accept only the literal value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;number&lt;/code&gt; 유형 을 허용하는 대신 리터럴 값 &lt;code&gt;2&lt;/code&gt; 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d7e7c460bdc5abc1277e2c78f9349f50b395124" translate="yes" xml:space="preserve">
          <source>For example, the following code will not report any errors:</source>
          <target state="translated">예를 들어 다음 코드는 오류를보고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be2868a9fb7a2e636970247ed66a6e565dcb7b90" translate="yes" xml:space="preserve">
          <source>For example, the following function for cloning an object.</source>
          <target state="translated">예를 들어, 객체 복제를위한 다음 기능.</target>
        </trans-unit>
        <trans-unit id="c57d353ecaa5b9ae469153e8bd0494c2759cfd0e" translate="yes" xml:space="preserve">
          <source>For example, to figure out the result of the following expression, Flow needs to figure out what its values are first.</source>
          <target state="translated">예를 들어, 다음 표현식의 결과를 파악하려면 Flow에서 해당 값이 무엇인지 먼저 파악해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6c8a9ac1f5c16025ef387a60063c1bc2ea40cd1" translate="yes" xml:space="preserve">
          <source>For example, when you create an intersection of two objects with different sets of properties, it will result in an object with all of the properties.</source>
          <target state="translated">예를 들어, 속성 집합이 다른 두 개체의 교차를 만들면 모든 속성이있는 개체가됩니다.</target>
        </trans-unit>
        <trans-unit id="be0defaf069697775abe92858214aa6eab2ca76b" translate="yes" xml:space="preserve">
          <source>For example, when you use literal values in Flow, their inferred type is the primitive that it belongs to. Thus, the number 42 has the inferred type of &lt;code&gt;number&lt;/code&gt;. You can see this when you use &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Flow에서 리터럴 값을 사용하는 경우 유추 된 유형은 해당 유형이 속하는 기본 유형입니다. 따라서 숫자 42는 유추 된 &lt;code&gt;number&lt;/code&gt; 유형을 갖습니다 . &lt;code&gt;typeof&lt;/code&gt; 를 사용할 때 이것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a78f29fa972df73a82d620ebcbf55256b542d21" translate="yes" xml:space="preserve">
          <source>For example, you can create an intersection of a number and a string.</source>
          <target state="translated">예를 들어 숫자와 문자열의 교집합을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6bf9aa556ae7aa47497704d8a136318cf4656ef" translate="yes" xml:space="preserve">
          <source>For example, you can write:</source>
          <target state="translated">예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41cd59ae29edba6c60d70a4800b3539e40d937dc" translate="yes" xml:space="preserve">
          <source>For example, you could be accessing an element that is out of the bounds of the array.</source>
          <target state="translated">예를 들어, 배열 범위를 벗어난 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e7b3364aed4ab54bcb5fbf0be1c986544a80686" translate="yes" xml:space="preserve">
          <source>For files in your project without this flag, the Flow background process skips and ignores the code (unless you call &lt;code&gt;flow check --all&lt;/code&gt;, which is beyond the scope of basic usage).</source>
          <target state="translated">이 플래그가없는 프로젝트의 파일의 경우 흐름 백그라운드 프로세스는 코드를 건너 뛰고 무시합니다 ( 기본 사용 범위를 벗어난 &lt;code&gt;flow check --all&lt;/code&gt; 을 호출하지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="6adf72d1444fb7909aee272ad9e96f51f02d4b69" translate="yes" xml:space="preserve">
          <source>For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0sDciiNsAOxJ4SlHABUAnukqgAvKABCpSgGEmmAZQF45APlDpG6MvtAAeZaPUZB2vAG8AdC6OwTAX1A5plOQCIAIwBXHBxBf1BgPR5+ITwAcW1KLGQaRVDwgXlQAAoHHxkAGlAaAAtkaAATdgEPAEp5A3MQsMFvXzkC3y9BVWg0gGsu3MazOJJYaEonOABzXJYaAZpByiqWeo89B3LKmu0Pc2BWrJjeCbwMtoEALgoOHCcbTXspGXNdiura+6paJ4AOVgVUo2xyogkvlySS0qXSmUE9S4QA&quot;&gt;example&lt;/a&gt;, we don&amp;rsquo;t type the HOC (setType), but the component created with it, &lt;code&gt;Button&lt;/code&gt;. To do so, we use the type &lt;code&gt;React.ComponentType&lt;/code&gt;.</source>
          <target state="translated">예를 들어,이 &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0sDciiNsAOxJ4SlHABUAnukqgAvKABCpSgGEmmAZQF45APlDpG6MvtAAeZaPUZB2vAG8AdC6OwTAX1A5plOQCIAIwBXHBxBf1BgPR5+ITwAcW1KLGQaRVDwgXlQAAoHHxkAGlAaAAtkaAATdgEPAEp5A3MQsMFvXzkC3y9BVWg0gGsu3MazOJJYaEonOABzXJYaAZpByiqWeo89B3LKmu0Pc2BWrJjeCbwMtoEALgoOHCcbTXspGXNdiura+6paJ4AOVgVUo2xyogkvlySS0qXSmUE9S4QA&quot;&gt;예&lt;/a&gt; 에서는 HOC (setType)를 입력하지 않고이를 사용하여 구성 요소 &lt;code&gt;Button&lt;/code&gt; 을 입력 합니다. 이를 위해 &lt;code&gt;React.ComponentType&lt;/code&gt; 유형을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fdce77763d38af3a8b71abca1c0293dafa227070" translate="yes" xml:space="preserve">
          <source>For more on lazy modes, see the &lt;a href=&quot;../lang/lazy-modes&quot;&gt;lazy modes docs&lt;/a&gt;.</source>
          <target state="translated">지연 모드에 대한 자세한 내용은 &lt;a href=&quot;../lang/lazy-modes&quot;&gt;지연 모드 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c03eb76d06156d9151d583bf5017b60d060c9e8f" translate="yes" xml:space="preserve">
          <source>For objects like these, Flow provides a special kind of property, called an &amp;ldquo;indexer property.&amp;rdquo; An indexer property allows reads and writes using any key that matches the indexer key type.</source>
          <target state="translated">이와 같은 객체의 경우 Flow는 &quot;인덱서 속성&quot;이라는 특별한 종류의 속성을 제공합니다. 인덱서 속성은 인덱서 키 유형과 일치하는 키를 사용하여 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab0510537ce0eb4731a9b80070bc58fde2f4090" translate="yes" xml:space="preserve">
          <source>For that reason (and others), it&amp;rsquo;s useful to write types for important functions.</source>
          <target state="translated">이런 이유로 (그리고 다른 것들), 중요한 함수를위한 타입을 작성하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bdccfdba2af4464ab5f05d14e93c225840b2b001" translate="yes" xml:space="preserve">
          <source>For the &lt;a href=&quot;#toc-write-flow-code&quot;&gt;code above&lt;/a&gt;, running &lt;code&gt;flow&lt;/code&gt; will yield:</source>
          <target state="translated">를 들어 &lt;a href=&quot;#toc-write-flow-code&quot;&gt;위의 코드&lt;/a&gt; , 실행 &lt;code&gt;flow&lt;/code&gt; 얻을 것이다 :</target>
        </trans-unit>
        <trans-unit id="0fff3409e13cd93e88e21ac5285c632cc985eaba" translate="yes" xml:space="preserve">
          <source>Forcing Flow to Treat a File as Focused</source>
          <target state="translated">흐름을 강제로 파일을 초점으로 처리</target>
        </trans-unit>
        <trans-unit id="cc51c13e52ce8d73c0bb48b450274afb9f82073c" translate="yes" xml:space="preserve">
          <source>Fortunately, JavaScript is already written using files as modules, so we modularize our analysis simply by asking that modules have explicitly typed signatures. (We still infer types for the vast majority of code &amp;ldquo;local&amp;rdquo; to modules.) Coincidentally, developers consider this good software engineering practice anyway.</source>
          <target state="translated">다행히도 JavaScript는 파일을 모듈로 사용하여 이미 작성되었으므로 모듈에 명시 적으로 형식화 된 서명을 요청하여 분석을 모듈화합니다. (우리는 여전히 대부분의 코드 &quot;로컬&quot;에 대한 유형을 모듈에 유추합니다.) 우연히도 개발자는 이러한 훌륭한 소프트웨어 엔지니어링 사례를 고려합니다.</target>
        </trans-unit>
        <trans-unit id="1c86bf0b4a5d6b8fe12a31c428cd9618f1707a5a" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">기능 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751924331feba79685bd7ca453e7d70d1ee39798" translate="yes" xml:space="preserve">
          <source>Function Declarations</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">기능 매개 변수</target>
        </trans-unit>
        <trans-unit id="8b80c6d0c0eb90a4193c11e2b8f639ce9765572d" translate="yes" xml:space="preserve">
          <source>Function Returns</source>
          <target state="translated">함수 반환</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">기능 유형</target>
        </trans-unit>
        <trans-unit id="7cc900b0e76620e1c35c363651461063a5b2d0d3" translate="yes" xml:space="preserve">
          <source>Function parameters can also have defaults. This is a feature of ECMAScript 2015.</source>
          <target state="translated">기능 매개 변수도 기본값을 가질 수 있습니다. 이것은 ECMAScript 2015의 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e686426824459378af5e98ab82feb0bfc1faa0e2" translate="yes" xml:space="preserve">
          <source>Function parameters can have types by adding a colon &lt;code&gt;:&lt;/code&gt; followed by the type after the name of the parameter.</source>
          <target state="translated">함수 파라미터 콜론 가하여 유형을 가질 수있다 &lt;code&gt;:&lt;/code&gt; 매개 변수의 이름 후의 형태를 하였다.</target>
        </trans-unit>
        <trans-unit id="e20f19430f4406d7d479bb1219578533f21581f6" translate="yes" xml:space="preserve">
          <source>Function parameters with defaults</source>
          <target state="translated">기본 기능 파라미터</target>
        </trans-unit>
        <trans-unit id="e628cf6d4cf7f3f60c7c92cf5e2c6d4764b18a50" translate="yes" xml:space="preserve">
          <source>Function returns can also add a type using a colon &lt;code&gt;:&lt;/code&gt; followed by the type after the list of parameters.</source>
          <target state="translated">함수 리턴은 콜론 &lt;code&gt;:&lt;/code&gt; 을 사용하여 유형을 추가 할 수 있으며 매개 변수 목록 뒤에 유형이옵니다.</target>
        </trans-unit>
        <trans-unit id="31bf38f4775fc5c5a798a785e09ec45b75300cf9" translate="yes" xml:space="preserve">
          <source>Function types can create generics in the same way as normal functions, by adding the type parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; before the function type parameter list.</source>
          <target state="translated">함수 유형은 함수 유형 매개 변수 목록 앞에 유형 매개 변수 목록 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 를 추가하여 일반 함수와 동일한 방식으로 제네릭을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1696fa363249b910e5a51ac92f7e2be6cd65b5b4" translate="yes" xml:space="preserve">
          <source>Function types with generics</source>
          <target state="translated">제네릭이있는 함수 유형</target>
        </trans-unit>
        <trans-unit id="3f7381fb33fff215013d059733e6eb1073506aa9" translate="yes" xml:space="preserve">
          <source>Functions are structurally typed</source>
          <target state="translated">함수는 구조적으로 형식화됩니다</target>
        </trans-unit>
        <trans-unit id="7a2f0bb1d54ff79eaaada0c3765d727c899bb522" translate="yes" xml:space="preserve">
          <source>Functions can create generics by adding the type parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; before the function parameter list.</source>
          <target state="translated">함수는 함수 매개 변수 목록 앞에 유형 매개 변수 목록 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 를 추가하여 제네릭을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d02cbcdf0a2a69aa715691fa238dfa6ccdc16a05" translate="yes" xml:space="preserve">
          <source>Functions can have optional parameters where a question mark &lt;code&gt;?&lt;/code&gt; comes after the parameter name.</source>
          <target state="translated">함수는 물음표가있는 선택적 매개 변수를 가질 수 있습니다 &lt;code&gt;?&lt;/code&gt; 매개 변수 이름 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="cf63b2e1b9aafbb240f7e1deca5b67f9988ef437" translate="yes" xml:space="preserve">
          <source>Functions have two places where types are applied: Parameters (input) and the return value (output).</source>
          <target state="translated">함수에는 유형이 적용되는 두 가지 위치가 있습니다 : 매개 변수 (입력) 및 반환 값 (출력).</target>
        </trans-unit>
        <trans-unit id="3c12be471a4e96534a926aacb0df7453eb2cbcca" translate="yes" xml:space="preserve">
          <source>Functions with generics</source>
          <target state="translated">제네릭이있는 함수</target>
        </trans-unit>
        <trans-unit id="0c9ce2261f9d73896e79a1421f34d061659a9e49" translate="yes" xml:space="preserve">
          <source>General Best Practices</source>
          <target state="translated">일반적인 모범 사례</target>
        </trans-unit>
        <trans-unit id="67ac7fcb0777deb807997c9f4b924988984d0fbd" translate="yes" xml:space="preserve">
          <source>Generally, the type you should first try when adding a type for the children of your React component is &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 React 컴포넌트의 하위에 대한 유형을 추가 할 때 먼저 시도해야하는 유형은 &lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">제네릭 형식</target>
        </trans-unit>
        <trans-unit id="f9d7e3ac4698ff4fedd01cf6807aee7a9efac823" translate="yes" xml:space="preserve">
          <source>Generic types act as bounds</source>
          <target state="translated">제네릭 형식은 범위로 작동</target>
        </trans-unit>
        <trans-unit id="f8c73c016669e4acd2b923bc11fc67ea9ad59c62" translate="yes" xml:space="preserve">
          <source>Generic types work a lot like variables or function parameters except that they are used for types. You can use them whenever they are in scope.</source>
          <target state="translated">제네릭 형식은 형식에 사용된다는 점을 제외하고 변수 또는 함수 매개 변수와 비슷하게 작동합니다. 범위 내에있을 때마다 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="1b3bd820ca45310f82d504b4fd55b7117cc37547" translate="yes" xml:space="preserve">
          <source>Generics (sometimes referred to as polymorphic types) are a way of abstracting a type away.</source>
          <target state="translated">제네릭 (종종 다형성 유형이라고도 함)은 유형을 추상화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a6fd94560566e4986674c54d1df1a19a7110e683" translate="yes" xml:space="preserve">
          <source>Generics act like variables</source>
          <target state="translated">제네릭은 변수처럼 작동</target>
        </trans-unit>
        <trans-unit id="ef394c1226958fc727e62243c4cb43ac0e4cd5cf" translate="yes" xml:space="preserve">
          <source>Generics allow you to hold onto the more specific type while adding a constraint. In this way types on generics act as &amp;ldquo;bounds&amp;rdquo;.</source>
          <target state="translated">제네릭을 사용하면 제약 조건을 추가하면서보다 구체적인 유형을 유지할 수 있습니다. 이런 식으로 제네릭의 유형은 &quot;바운드&quot;로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4aadf67c9db3328742fd5a86fc24b21a1a76c43e" translate="yes" xml:space="preserve">
          <source>Generics can be used within functions, function types, classes, type aliases, and interfaces.</source>
          <target state="translated">제네릭은 함수, 함수 형식, 클래스, 형식 별칭 및 인터페이스 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7faae52c2d4462ab2eaff369392d43e6c1364b8c" translate="yes" xml:space="preserve">
          <source>Generics sometimes allow you to pass types in like arguments to a function. These are known as parameterized generics (or parametric polymorphism).</source>
          <target state="translated">제네릭을 사용하면 같은 인수 형식의 함수에 함수를 전달할 수 있습니다. 이를 매개 변수화 된 제네릭 (또는 파라 메트릭 다형성)이라고합니다.</target>
        </trans-unit>
        <trans-unit id="0d8ccea6ce861b3356a8a1401bc73a5e10e8c648" translate="yes" xml:space="preserve">
          <source>Generics track values around</source>
          <target state="translated">제네릭은 값을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="cfcb0c850227d5c43ba836a3ca78b5b97f74a944" translate="yes" xml:space="preserve">
          <source>Gets the instance type for a React element. The instance will be different for various component types:</source>
          <target state="translated">React 요소의 인스턴스 유형을 가져옵니다. 인스턴스는 다양한 구성 요소 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="236e116424d14004e90c27673c86a646ef19fa8e" translate="yes" xml:space="preserve">
          <source>Gets the props for a React element type, &lt;em&gt;without&lt;/em&gt; preserving the optionality of &lt;code&gt;defaultProps&lt;/code&gt;. &lt;code&gt;typeof Component&lt;/code&gt; could be the type of a React class component, a stateless functional component, or a JSX intrinsic string. This type is used for the &lt;code&gt;props&lt;/code&gt; property on &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 옵션을 유지 &lt;em&gt;하지 않고&lt;/em&gt; React 요소 유형의 props를 가져옵니다 . &lt;code&gt;typeof Component&lt;/code&gt; 는 React 클래스 구성 요소, 상태 비 저장 기능 구성 요소 또는 JSX 내장 문자열의 유형일 수 있습니다. 이 유형은 &lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;props&lt;/code&gt; 특성에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="0ea124ff781dabd2f0647eac33da1b5dda4dac00" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt; representing instances of a class &lt;code&gt;C&lt;/code&gt;, the type &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; is the type of the class &lt;code&gt;C&lt;/code&gt;. For example:</source>
          <target state="translated">타입을 감안할 때 &lt;code&gt;T&lt;/code&gt; 클래스의 인스턴스를 나타내는 &lt;code&gt;C&lt;/code&gt; 를 , 유형 &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; 클래스의 타입 &lt;code&gt;C&lt;/code&gt; 는 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="851df84ffecc429e99c3dd230d56812d1b5b6739" translate="yes" xml:space="preserve">
          <source>Have a question about using Flow? Check here first!</source>
          <target state="translated">Flow 사용에 대해 궁금한 점이 있습니까? 먼저 여기를 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="2ddc501d850ae3a0f6c0d81b4cee3f2a7263c9d2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;props.children&lt;/code&gt; will be an array of arrays. Specifically &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[[1, 2], [3, 4]]&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;props.children&lt;/code&gt; 은 배열의 배열입니다. 구체적으로 &lt;code&gt;props.children&lt;/code&gt; 은 &lt;code&gt;[[1, 2], [3, 4]]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3827f0f684068e8b08cda57d14ca02f9de4d36d2" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;React.Node&lt;/code&gt; as the prop type for children:</source>
          <target state="translated">다음은 자식 용 prop 유형 으로 &lt;code&gt;React.Node&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c801032aa18d6a477cf713f1624762e4f08d3af9" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;code&gt;React.Node&lt;/code&gt; being used as the return type to &lt;code&gt;render()&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;render()&lt;/code&gt; 의 반환 유형으로 사용되는 &lt;code&gt;React.Node&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="bdd7a2f9607a075cf7fd0924bbed317c0eec84d4" translate="yes" xml:space="preserve">
          <source>Here is an example of how you could use the &lt;code&gt;.flowconfig&lt;/code&gt; directives.</source>
          <target state="translated">다음은 &lt;code&gt;.flowconfig&lt;/code&gt; 지시문을 사용하는 방법의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="aa528d54a7d8103f41c0bfd3b9b8fae4b3e30c90" translate="yes" xml:space="preserve">
          <source>Here is how you may use &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; with &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; to construct a component with a specific set of props:</source>
          <target state="translated">다음은 &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; 를 &lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 함께 사용하여 특정 소품 세트로 구성 요소를 구성하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="535fabe7a4cb455852726d03b7da421c7856e385" translate="yes" xml:space="preserve">
          <source>Here is how you would type the &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; component in Flow:</source>
          <target state="translated">흐름에 &lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt; 구성 요소를 입력하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="af8389a6ecc318bb6ebf315d56db66ecc756233e" translate="yes" xml:space="preserve">
          <source>Here the input value can only be a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">여기서 입력 값은 &lt;code&gt;number&lt;/code&gt; 만 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="25234e5462d0d0721c9abf9cb778d69feaeba093" translate="yes" xml:space="preserve">
          <source>Here the input value could be either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">여기서 입력 값은 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;number&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="87b8649ae5d0883f7fd9dfda5cfcf802e8591bd6" translate="yes" xml:space="preserve">
          <source>Here the passed in value is an unknown type, it could be any type and the function would still work.</source>
          <target state="translated">여기서 전달 된 값은 알 수없는 유형이며 모든 유형일 수 있으며 함수는 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="17a73674e1d8aaed9bcfe2a7bd9df88099e17a9f" translate="yes" xml:space="preserve">
          <source>Here the return type will be the same as the type of whatever value is passed into the function.</source>
          <target state="translated">여기서 반환 유형은 함수에 전달되는 모든 값의 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="13bad31d551f7ce53902bee6f5b588e74599b66e" translate="yes" xml:space="preserve">
          <source>Here you can see a pseudo-example of a nominal type system erroring out when you&amp;rsquo;re trying to put a &lt;code&gt;Bar&lt;/code&gt; where a &lt;code&gt;Foo&lt;/code&gt; is required because they have different names.</source>
          <target state="translated">여기 에는 이름이 다르기 때문에 &lt;code&gt;Foo&lt;/code&gt; 가 필요한 곳에 &lt;code&gt;Bar&lt;/code&gt; 를 배치하려고 할 때 공칭 유형 시스템의 의사 예제가 오류가 발생하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098e77f7a550b2cf510ca26c4aeb1fba8e8580b9" translate="yes" xml:space="preserve">
          <source>Here you can see a pseudo-example of a structural type system passing when you&amp;rsquo;re trying to put a Bar where a &lt;code&gt;Foo&lt;/code&gt; is required because their structure is exactly the same.</source>
          <target state="translated">여기서 구조가 정확히 동일하기 때문에 &lt;code&gt;Foo&lt;/code&gt; 가 필요한 곳에 Bar를 배치하려고 할 때 구조 유형 시스템의 의사 예제가 전달되는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d42546ad988361114be19ba4faa6ffd09713b98" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for arrow functions with and without types added.</source>
          <target state="translated">여기에는 유형이 추가되거나 추가되지 않은 화살표 함수의 구문이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d3699f0333712613b9e8dd3485f37fca22346ed0" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for function declarations with and without types added.</source>
          <target state="translated">여기에는 유형이 추가되거나 포함되지 않은 함수 선언에 대한 구문이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="56b22036dfc0a76c4f96b2794020b9590adaecf9" translate="yes" xml:space="preserve">
          <source>Here you can see the syntax for writing types that are functions.</source>
          <target state="translated">여기서 함수 인 타입을 작성하는 구문을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fac12a07532dfa0ddfc895f9ad228b8e092de33" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a possible declaration of this function, which is very similar to our first example:</source>
          <target state="translated">이 함수의 가능한 선언은 다음과 같습니다. 첫 번째 예와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="fbf28fb6962ce31b4060a59b6e700daf856a84f6" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;showFoo&lt;/code&gt; is a boolean which controls whether or not to display the &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; element. If &lt;code&gt;showFoo&lt;/code&gt; is true, then this evaluates to &lt;code&gt;{&amp;lt;Foo/&amp;gt;}&lt;/code&gt;. If &lt;code&gt;showFoo&lt;/code&gt; is false, then this evaluates to &lt;code&gt;{false}&lt;/code&gt;, which doesn&amp;rsquo;t display anything.</source>
          <target state="translated">여기서 &lt;code&gt;showFoo&lt;/code&gt; 는 &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; 요소 를 표시할지 여부를 제어하는 ​​부울입니다 . 경우 &lt;code&gt;showFoo&lt;/code&gt; 는 사실, 다음이 평가됩니다 &lt;code&gt;{&amp;lt;Foo/&amp;gt;}&lt;/code&gt; . 경우 &lt;code&gt;showFoo&lt;/code&gt; 은 거짓, 그 다음이 평가됩니다 &lt;code&gt;{false}&lt;/code&gt; 아무것도 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9f4df1640a61e73a368f05d84051cfbe689fd43" translate="yes" xml:space="preserve">
          <source>Here, Flow will complain on the &lt;code&gt;export&lt;/code&gt;, asking for a type annotation. Flow wants you to annotate exports returned by a generic function. The type of &lt;code&gt;Array.prototype.map&lt;/code&gt; is &lt;code&gt;map&amp;lt;U&amp;gt;(callbackfn: (value: T, index: number, array: Array&amp;lt;T&amp;gt;) =&amp;gt; U, thisArg?: any): Array&amp;lt;U&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; corresponds to what is called a &lt;a href=&quot;types/generics&quot;&gt;generic&lt;/a&gt;, to express the fact that the type of the function passed to map is linked to the type of the array.</source>
          <target state="translated">여기에서 Flow는 &lt;code&gt;export&lt;/code&gt; 에 대해 불만을 제기 하고 형식 주석을 요청합니다. Flow에서는 일반 함수에서 반환 한 내보내기에 주석을 달기를 원합니다. &lt;code&gt;Array.prototype.map&lt;/code&gt; 의 유형 은 &lt;code&gt;map&amp;lt;U&amp;gt;(callbackfn: (value: T, index: number, array: Array&amp;lt;T&amp;gt;) =&amp;gt; U, thisArg?: any): Array&amp;lt;U&amp;gt;&lt;/code&gt; 입니다. &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 불리는 무엇에 해당하는 &lt;a href=&quot;types/generics&quot;&gt;일반적인를&lt;/a&gt; 지도에 전달 된 함수의 유형이 배열의 형태로 연결되어 있다는 사실을 표현.</target>
        </trans-unit>
        <trans-unit id="ee8ceb048fbb5cd5fd5303e935623ce260603c2b" translate="yes" xml:space="preserve">
          <source>Here, a work around would be to extract the part of the value you&amp;rsquo;re interested in, or to move the if check inside the &lt;code&gt;setTimeout&lt;/code&gt; call:</source>
          <target state="translated">여기서 해결 방법은 관심있는 값의 일부를 추출하거나 &lt;code&gt;setTimeout&lt;/code&gt; 호출 내에서 if 검사를 이동하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="cc00b92fae87138445b8db76c9ab4f421cd563cb" translate="yes" xml:space="preserve">
          <source>Higher-order Components</source>
          <target state="translated">고차 부품</target>
        </trans-unit>
        <trans-unit id="9afcd5258af293b3e8dd22ec752eba0c2f251483" translate="yes" xml:space="preserve">
          <source>How to use Flow from the command line. Including how to manage the Flow background process.</source>
          <target state="translated">명령 행에서 플로우를 사용하는 방법 흐름 백그라운드 프로세스를 관리하는 방법을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c6b59c452c954d9defbf04ad89b295d7369263a0" translate="yes" xml:space="preserve">
          <source>However it is limited in that this string only describes so much about the type.</source>
          <target state="translated">그러나이 문자열은 유형에 대해서만 설명하기 때문에 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="a35ae847b7dbe7d8fd62853289ce430ad193bce8" translate="yes" xml:space="preserve">
          <source>However sometimes there isn&amp;rsquo;t a pre-existing libdef or you have third-party code that isn&amp;rsquo;t public and/or you really just need to write a libdef yourself. To do this you&amp;rsquo;ll start by creating a &lt;code&gt;.js&lt;/code&gt; file for each libdef you&amp;rsquo;re going to write and put them in the &lt;code&gt;/flow-typed&lt;/code&gt; directory at the root of your project. In these libdef file(s) you&amp;rsquo;ll use a special set of Flow syntax (explained below) to describe the interfaces of the relevant third-party code.</source>
          <target state="translated">그러나 때로는 기존 libdef가 없거나 공개되지 않은 타사 코드가 있거나 libdef를 직접 작성해야합니다. 이를 위해서는 먼저 작성하려는 각 libdef에 대해 &lt;code&gt;.js&lt;/code&gt; 파일을 작성 하여 프로젝트 루트의 &lt;code&gt;/flow-typed&lt;/code&gt; 디렉토리에 저장하십시오. 이 libdef 파일에서는 특수한 흐름 구문 세트 (아래 설명)를 사용하여 관련 타사 코드의 인터페이스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1dabc8a9daa16baa576a945117465517c0ab5c57" translate="yes" xml:space="preserve">
          <source>However, Flow has &lt;a href=&quot;types/functions#toc-predicate-functions&quot;&gt;predicates functions&lt;/a&gt; that can do these checks via &lt;code&gt;%checks&lt;/code&gt;.</source>
          <target state="translated">그러나 Flow에는 &lt;code&gt;%checks&lt;/code&gt; 를 통해 이러한 검사를 수행 할 수있는 &lt;a href=&quot;types/functions#toc-predicate-functions&quot;&gt;함수&lt;/a&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27bb39d29e968deb761d41de85ea44344a3e8143" translate="yes" xml:space="preserve">
          <source>However, Flow will flag an error in the code below:</source>
          <target state="translated">그러나 Flow는 아래 코드에서 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="067267fea785830c12b74c19441557fb234dc53a" translate="yes" xml:space="preserve">
          <source>However, evolving and growing a JavaScript codebase is notoriously challenging. Developers cannot move fast when they break stuff. They hit frequent interruptions, spending a lot of time debugging silly mistakes, unraveling assumptions and guarantees made by libraries written by others, etc.</source>
          <target state="translated">그러나 JavaScript 코드베이스를 발전시키고 성장시키는 것은 매우 어려운 일입니다. 개발자는 물건을 깰 때 빠르게 움직일 수 없습니다. 그들은 자주 방해를 받아 바보 같은 실수를 디버깅하는 데 많은 시간을 소비하고 다른 사람들이 작성한 라이브러리에 의해 만들어진 가정과 보증을 풀고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3b394df7ec3cd961692cc5e230a54570e64cb9" translate="yes" xml:space="preserve">
          <source>However, if you need to opt-out of the type checker, and don&amp;rsquo;t want to go all the way to &lt;code&gt;any&lt;/code&gt;, you can instead use &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt;. (Note that &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; is unsafe and should be avoided). For historical reasons, the &lt;code&gt;Function&lt;/code&gt; keyword is still available.</source>
          <target state="translated">그러나 유형 검사기를 옵트 아웃해야하고 &lt;code&gt;any&lt;/code&gt; 로 가고 싶지 않으면 대신 &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt; 있습니다. (참고 &lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 안전하지 피해야한다). 역사적 이유로 &lt;code&gt;Function&lt;/code&gt; 키워드는 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d77a143534e87e9a163d3e3ce0aca8c4103e016" translate="yes" xml:space="preserve">
          <source>However, if you need to opt-out of the type checker, and don&amp;rsquo;t want to go all the way to &lt;code&gt;any&lt;/code&gt;, you could use &lt;code&gt;{[key:string]:any}&lt;/code&gt;. (Note that &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; is unsafe and should be avoided). For historical reasons, the &lt;code&gt;Object&lt;/code&gt; keyword is still available. In previous versions of Flow, &lt;code&gt;Object&lt;/code&gt; was the same as &lt;code&gt;{[key:string]:any}&lt;/code&gt;.</source>
          <target state="translated">그러나 유형 검사기를 선택 해제해야하고 &lt;code&gt;any&lt;/code&gt; 로 가고 싶지 않은 경우 &lt;code&gt;{[key:string]:any}&lt;/code&gt; 를 사용할 수 있습니다 . (참고 &lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 안전하지 피해야한다). 역사적 이유로 &lt;code&gt;Object&lt;/code&gt; 키워드는 계속 사용할 수 있습니다. 이전 버전의 Flow에서 &lt;code&gt;Object&lt;/code&gt; 는 &lt;code&gt;{[key:string]:any}&lt;/code&gt; 와 동일했습니다 .</target>
        </trans-unit>
        <trans-unit id="f1e2c14006b12ab5491178ce01f3a9550f02756c" translate="yes" xml:space="preserve">
          <source>However, if you want to do anything more powerful with the React children API then you will need a strong intuition of how React handles children. Let us look at a couple of cases before continuing to help build that intuition.</source>
          <target state="translated">그러나 React children API를 사용하여 더 강력한 작업을 수행하려면 React가 자식을 처리하는 방법에 대한 강력한 직관이 필요합니다. 직관을 구축하는 데 도움이되기 전에 몇 가지 사례를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f5931dcbe633762171ccee54a6f7889d2181ea61" translate="yes" xml:space="preserve">
          <source>However, it currently lacks support for on-the-fly type-checking (showing your type errors before you save your file).</source>
          <target state="translated">그러나 현재 온더 플라이 형식 검사 (파일을 저장하기 전에 형식 오류 표시)가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec4e47a3799d3abd4efe1fc37df16b029a38bb9" translate="yes" xml:space="preserve">
          <source>However, it is not valid to use an object containing an &lt;code&gt;Person&lt;/code&gt; instance where an object containing a &lt;code&gt;Employee&lt;/code&gt; instance is expected.</source>
          <target state="translated">그러나 &lt;code&gt;Employee&lt;/code&gt; 인스턴스가 포함 된 개체가 필요한 &lt;code&gt;Person&lt;/code&gt; 인스턴스가 포함 된 개체를 사용하는 것은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d215123d1e8037cb7806bba06a88351e172e211e" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s often useful to know that a property is definitely absent.</source>
          <target state="translated">그러나 속성이 확실히 없다는 것을 아는 것이 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9313de9dcdc57923e98881e802d0f7c94f24fa15" translate="yes" xml:space="preserve">
          <source>However, sometimes a Flow user might not care about all the code. If they are editing a file &lt;code&gt;foo.js&lt;/code&gt;, they might only want Flow to typecheck the subset of the repository needed to answer questions about &lt;code&gt;foo.js&lt;/code&gt;. Since Flow would only check a smaller number of files, this would be faster. This is the motivation behind Flow&amp;rsquo;s lazy modes.</source>
          <target state="translated">그러나 때때로 Flow 사용자가 모든 코드를 신경 쓰지 않을 수 있습니다. &lt;code&gt;foo.js&lt;/code&gt; 파일을 편집하는 경우 Flow가 &lt;code&gt;foo.js&lt;/code&gt; 에 대한 질문에 답변하는 데 필요한 리포지토리의 하위 집합 만 유형 검사하기를 원할 수 있습니다 . Flow는 적은 수의 파일 만 확인하므로 더 빠릅니다. 이것이 Flow의 게으른 모드의 동기입니다.</target>
        </trans-unit>
        <trans-unit id="0388504fdb624bb29d41874d436a861dd6df6661" translate="yes" xml:space="preserve">
          <source>However, there is also a fourth category.</source>
          <target state="translated">그러나 네 번째 범주도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfac9f3c31434613c3dc25580cc54920b60f8937" translate="yes" xml:space="preserve">
          <source>However, this only happens with the inferred type. If you specify the literal type, it will be used in &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">그러나 이것은 유추 된 유형에서만 발생합니다. 리터럴 유형을 지정하면 &lt;code&gt;typeof&lt;/code&gt; 에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="60d9e12a6689ca1896d012bac4c1760061cf255c" translate="yes" xml:space="preserve">
          <source>However, to get around this you could use &lt;strong&gt;exact object types&lt;/strong&gt;.</source>
          <target state="translated">그러나이 문제를 해결하려면 &lt;strong&gt;정확한 객체 유형을&lt;/strong&gt; 사용할 수 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bf88ecdb532f0e02d70968558133c0d7b18ba5f0" translate="yes" xml:space="preserve">
          <source>However, type refinements can be lost. For instance, calling a function after refining the type of an object&amp;rsquo;s property will invalidate this refinement. Consult the &lt;a href=&quot;https://flow.org/en/lang/refinements/#toc-refinement-invalidations&quot;&gt;Refinement Invalidations&lt;/a&gt; docs for more details, to understand why Flow works this way, and how you can avoid this common pitfall.</source>
          <target state="translated">그러나 형식 세분화가 손실 될 수 있습니다. 예를 들어 객체 속성 유형을 수정 한 후 함수를 호출하면이 세분화가 무효화됩니다. 문의를 &lt;a href=&quot;https://flow.org/en/lang/refinements/#toc-refinement-invalidations&quot;&gt;정교화 무효화의&lt;/a&gt; 흐름이 방식으로 작동 이유를 이해하기 위해, 자세한 내용은 문서를, 그리고 당신이 일반적인 함정을 피할 수있는 방법.</target>
        </trans-unit>
        <trans-unit id="5fd3ba2f001a6fd526870acba3decc8fde5c658e" translate="yes" xml:space="preserve">
          <source>However, you can use the &lt;code&gt;+&lt;/code&gt; operator on strings or numbers, so this would also be valid.</source>
          <target state="translated">그러나 문자열이나 숫자에 &lt;code&gt;+&lt;/code&gt; 연산자를 사용할 수 있으므로 이것도 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e35f724efeda49c47595a6cc2bbf2976ebcaafa9" translate="yes" xml:space="preserve">
          <source>I checked that &lt;code&gt;foo.bar&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, but Flow still thinks it is. Why does this happen and how can I fix it?</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 아닌지 확인 했지만 Flow는 여전히 그렇다고 생각합니다. 왜 이런 일이 발생하며 어떻게 해결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="6081ec65c275b7812a118a8d9487bec229a111d3" translate="yes" xml:space="preserve">
          <source>I checked that my object is of type A, so why does Flow still believe it&amp;rsquo;s A | B?</source>
          <target state="translated">객체의 유형이 A인지 확인했는데 왜 Flow가 여전히 객체를 A | 비?</target>
        </trans-unit>
        <trans-unit id="ab8ec6fa322ac3cb67fd8d12de1df1c19353b3b3" translate="yes" xml:space="preserve">
          <source>I got a &amp;ldquo;Missing type annotation&amp;rdquo; error. Where does it come from?</source>
          <target state="translated">&amp;ldquo;Missing type annotation&amp;rdquo;오류가 발생했습니다. 그거 어디서 났어?</target>
        </trans-unit>
        <trans-unit id="547872d29b34bba7a1f46637da9812595a6bd96e" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m in a closure and Flow ignores the if check that asserts that &lt;code&gt;foo.bar&lt;/code&gt; is defined. Why?</source>
          <target state="translated">폐쇄 &lt;code&gt;foo.bar&lt;/code&gt; Flow는 foo.bar 가 정의 되었다고 주장하는 if 검사를 무시합니다 . 왜?</target>
        </trans-unit>
        <trans-unit id="1edc681e64e9bedc4b73a1b622b1bcd9c0221235" translate="yes" xml:space="preserve">
          <source>IDE Integration</source>
          <target state="translated">IDE 통합</target>
        </trans-unit>
        <trans-unit id="fa469552ea8a6956e0d85bd15a5b32e813e35a32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is, say, &lt;code&gt;5&lt;/code&gt;, then this displays &amp;ldquo;[5 comments]&amp;rdquo;. However, if &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then this displays &amp;ldquo;0&amp;rdquo; instead of displaying nothing. (This problem is unique to &lt;code&gt;number&lt;/code&gt; because &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; are the only falsy values which React renders with a visible result.) This could be subtly dangerous: if this immediately follows another numerical value, it might appear to the user that we have multiplied that value by 10! Instead, we should do a proper conditional check:</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 있다, 말 &lt;code&gt;5&lt;/code&gt; , 다음이 표시 &quot;[5 개의 코멘트]&quot;. 그러나 &lt;code&gt;count&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이면 아무것도 표시하지 않고&amp;ldquo;0&amp;rdquo;이 표시됩니다. (이 문제는 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;NaN&lt;/code&gt; 이 React가 눈에 띄는 결과로 렌더링하는 유일한 잘못된 값 이기 때문에 &lt;code&gt;number&lt;/code&gt; 고유합니다 .) 미묘하게 위험 할 수 있습니다.이 값이 다른 숫자 값 바로 뒤에 오는 경우 사용자에게 곱한 것으로 나타날 수 있습니다. 10만큼 가치! 대신 적절한 조건부 검사를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="39ad3382b221945428b6a2b474dff72bfb56707e" translate="yes" xml:space="preserve">
          <source>If Flow doesn&amp;rsquo;t know which index you are trying to access it will return all possible types.</source>
          <target state="translated">Flow가 액세스하려는 인덱스를 모르는 경우 가능한 모든 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c9c0dec7bafe53d2bbdf7d9959ddffbd2d70581" translate="yes" xml:space="preserve">
          <source>If Flow is unable to figure out what the exact type is for each value, Flow must figure out what every possible value is and check to make sure that the code around it will still work with all of the possible types.</source>
          <target state="translated">Flow가 각 값에 대한 정확한 유형이 무엇인지 파악할 수없는 경우 Flow는 가능한 모든 값이 무엇인지 파악하고 주위의 코드가 여전히 모든 가능한 유형에서 작동하는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="5acb8edfcd1e9dfddc6d2572d420f5b201ed318e" translate="yes" xml:space="preserve">
          <source>If a third-party library that has no type information is used by your project, Flow will treat it like any other untyped dependency and mark all of its exports as &lt;code&gt;any&lt;/code&gt;. Interestingly, this is the only place that Flow will implicitly inject &lt;code&gt;any&lt;/code&gt; into your program.</source>
          <target state="translated">유형 정보가없는 타사 라이브러리를 프로젝트에서 사용하는 경우 Flow는이를 유형이 지정되지 않은 다른 종속성으로 취급하고 모든 내보내기를 &lt;code&gt;any&lt;/code&gt; 로 표시 합니다 . 흥미롭게도, Flow가 프로그램에 암시 적으로 주입 &lt;code&gt;any&lt;/code&gt; 있는 유일한 곳입니다 .</target>
        </trans-unit>
        <trans-unit id="3eab7b55f7ee09f03bc495ed43d0061345e8a4e3" translate="yes" xml:space="preserve">
          <source>If no suppression comments are specified in your config, Flow will apply one default: &lt;code&gt;// $FlowFixMe&lt;/code&gt;.</source>
          <target state="translated">구성에 억제 설명이 지정되어 있지 않으면 Flow는 하나의 기본값을 적용합니다 : &lt;code&gt;// $FlowFixMe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ab896379f8da8ccf06ebdb7660f6a676591eb88" translate="yes" xml:space="preserve">
          <source>If statements, functions, and other conditionally run code can all prevent Flow from being able to figure out precisely what a type will be.</source>
          <target state="translated">if 문, 함수 및 기타 조건부로 실행되는 코드는 모두 Flow가 형식이 무엇인지 정확하게 파악하지 못하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c36449a1266a96a5edfbb603756422dc5a110c" translate="yes" xml:space="preserve">
          <source>If the values are numbers, then the expression results in a number. If the values are strings, then the expression results in a string. There are a number of different possibilities here, so Flow must look up what the values are.</source>
          <target state="translated">값이 숫자이면 표현식은 숫자가됩니다. 값이 문자열이면 표현식은 문자열이됩니다. 여기에는 여러 가지 가능성이 있으므로 Flow는 값이 무엇인지 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="5f9ff1c70b75813f87b337ccc40269423119c893" translate="yes" xml:space="preserve">
          <source>If these values on the object happen to be other objects, we would have to compare those against one another. We need to compare every value recursively until we can decide if we have a subtype or not.</source>
          <target state="translated">객체의 이러한 값이 다른 객체 인 경우 서로 비교해야합니다. 하위 유형이 있는지 여부를 결정할 수있을 때까지 모든 값을 재귀 적으로 비교해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd58caf9f3de4a63117623155b1513d6eb2999e3" translate="yes" xml:space="preserve">
          <source>If this option is unspecified, Flow will always use the &lt;code&gt;&quot;main&quot;&lt;/code&gt; field.</source>
          <target state="translated">이 옵션을 지정하지 않으면 Flow는 항상 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 필드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="76fac6bacf9983c96845e23339cd8c3466f2c7a7" translate="yes" xml:space="preserve">
          <source>If we cast through any, we can return a type which is more useful.</source>
          <target state="translated">우리가 어떤 것을 캐스트하면, 더 유용한 타입을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d8ac03b1e20b9356423c837abe3ce7a0f6c016" translate="yes" xml:space="preserve">
          <source>If we now create a declaration file &lt;code&gt;src/Misc.js.flow&lt;/code&gt;, the declarations in it will be used instead of the code in &lt;code&gt;src/Misc.js&lt;/code&gt;. Let&amp;rsquo;s say we have the following declarations in &lt;code&gt;src/Misc.js.flow&lt;/code&gt;.</source>
          <target state="translated">우리가 지금 선언 파일을 작성하는 경우 &lt;code&gt;src/Misc.js.flow&lt;/code&gt; , 그 안에 선언 대신에 코드의 사용됩니다 &lt;code&gt;src/Misc.js&lt;/code&gt; . &lt;code&gt;src/Misc.js.flow&lt;/code&gt; 에 다음과 같은 선언이 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="fff93b7378aeb2b38b2090807b263b7014c5548e" translate="yes" xml:space="preserve">
          <source>If we prevented any code from ever writing a new value to the object through the &lt;code&gt;person&lt;/code&gt; variable, it would be safe to use the &lt;code&gt;employee&lt;/code&gt; variable. Flow provides a syntax for this:</source>
          <target state="translated">코드가 &lt;code&gt;person&lt;/code&gt; 변수를 통해 객체에 새 값을 쓰지 못하게하는 경우 &lt;code&gt;employee&lt;/code&gt; 변수 를 사용하는 것이 안전 합니다. Flow는 이에 대한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89439f8728f3f378c6012b648cca5749466a7c15" translate="yes" xml:space="preserve">
          <source>If we want to know whether one type is the subtype of another, we need to look at all the possible values for both types and figure out if the other has a &lt;em&gt;subset&lt;/em&gt; of the values.</source>
          <target state="translated">한 유형이 다른 유형의 하위 유형인지 확인하려면 두 유형에 대해 가능한 모든 값을보고 다른 유형에 값의 &lt;em&gt;하위 집합&lt;/em&gt; 이 있는지 확인 해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa5a5ea5efd7aef02382e7722a00a675b7afec3" translate="yes" xml:space="preserve">
          <source>If we want to validate what kinds of types are coming into our &lt;code&gt;cloneObject&lt;/code&gt; method from before, we could write the following annotation:</source>
          <target state="translated">이전부터 &lt;code&gt;cloneObject&lt;/code&gt; 메소드에 어떤 유형의 유형이 들어오는 지 확인 하려면 다음 주석을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9caf10c12ea9af18781cd6eef9ed4499bd31209" translate="yes" xml:space="preserve">
          <source>If we write into the &lt;code&gt;who&lt;/code&gt; property of the &lt;code&gt;person&lt;/code&gt; object, we&amp;rsquo;ve also changed the value of &lt;code&gt;employee.who&lt;/code&gt;, which is explicitly annotated to be an &lt;code&gt;Employee&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 객체 의 &lt;code&gt;who&lt;/code&gt; 속성에 쓰면 &lt;code&gt;employee.who&lt;/code&gt; 의 값도 변경되었습니다 . &lt;code&gt;Employee&lt;/code&gt; .who 는 직원 인스턴스로 명시 적으로 주석이 달렸습니다 .</target>
        </trans-unit>
        <trans-unit id="c0385bbba6e8a638e5b435911862d68f61aa402d" translate="yes" xml:space="preserve">
          <source>If you add the following to your configuration:</source>
          <target state="translated">구성에 다음을 추가하는 경우 :</target>
        </trans-unit>
        <trans-unit id="2f6349a666bc7969b6c4063795a6da2f8498120d" translate="yes" xml:space="preserve">
          <source>If you already have a strong intuition about how React children work then feel free to &lt;a href=&quot;#examples&quot;&gt;skip to our examples demonstrating how to type various children patterns that commonly show up in React components&lt;/a&gt;.</source>
          <target state="translated">React 하위의 작동 방식에 대한 강한 직관이 있다면 &lt;a href=&quot;#examples&quot;&gt;React 컴포넌트에 일반적으로 나타나는 다양한 하위 패턴을 입력하는 방법을 보여주는 예제&lt;/a&gt; 로 넘어가십시오 .</target>
        </trans-unit>
        <trans-unit id="de34b40fb825239268317ed36dbb1e00f0c6608b" translate="yes" xml:space="preserve">
          <source>If you are using CommonJS you can also require React:</source>
          <target state="translated">CommonJS를 사용하는 경우 React가 필요할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ad5bd918b70efe676da28a844513e673fd63f9" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Babel setup already, you can do that by following &lt;a href=&quot;http://babeljs.io/docs/setup/&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">Babel을 아직 설정하지 않은 &lt;a href=&quot;http://babeljs.io/docs/setup/&quot;&gt;경우이 안내서&lt;/a&gt; 에 따라 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a69f0a892b7706fd7d381a10e9090d3be16821d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to add the type of your element instance you can also use &lt;code&gt;SyntheticEvent&lt;/code&gt; with &lt;em&gt;no&lt;/em&gt; type arguments like so: &lt;code&gt;SyntheticEvent&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">당신은 또한 사용할 수있는 요소 인스턴스의 유형을 추가하지 않으려면 &lt;code&gt;SyntheticEvent&lt;/code&gt; 를 함께 &lt;em&gt;어떤&lt;/em&gt; 형태 인수를 너무 좋아 : &lt;code&gt;SyntheticEvent&amp;lt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d32713b2839dd2173444b2f9b4d7dcc4fe36ce" translate="yes" xml:space="preserve">
          <source>If you enable the &lt;code&gt;nonstrict-import&lt;/code&gt; rule in your Flow Strict configuration (recommended), then all dependencies of a strict file must also be strict. While this the optimal goal, for large pre-existing codebases it may be beneficial to allow some of the benefits of Flow Strict to be put in use before all dependencies are strict.</source>
          <target state="translated">Flow Strict 구성에서 &lt;code&gt;nonstrict-import&lt;/code&gt; 규칙 을 사용하는 경우 (권장), 엄격한 파일의 모든 종속성도 엄격해야합니다. 이것이 최적의 목표이지만 기존의 대규모 코드베이스의 경우 모든 종속성이 엄격 해지기 전에 Flow Strict의 이점 중 일부를 사용하는 것이 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7868511a9d06a4f8edf5d7a840c67f28e5c7774f" translate="yes" xml:space="preserve">
          <source>If you have an object that sometimes does not have a property you can make it an &lt;em&gt;optional property&lt;/em&gt; by adding a question mark &lt;code&gt;?&lt;/code&gt; after the property name in the object type.</source>
          <target state="translated">속성이없는 개체가있는 경우 물음표를 추가 하여 &lt;em&gt;선택적 속성&lt;/em&gt; 으로 만들 수 있습니다 &lt;code&gt;?&lt;/code&gt; 객체 유형에서 속성 이름 뒤에.</target>
        </trans-unit>
        <trans-unit id="4f24b7927c9085b7c250ed90664e78d83cbf1e68" translate="yes" xml:space="preserve">
          <source>If you need a return type for your component &lt;code&gt;render()&lt;/code&gt; methods then you should use &lt;code&gt;React.Node&lt;/code&gt;. However, if you need a generic type for a children prop, use &lt;code&gt;?React.Node&lt;/code&gt;; children can be undefined, when &lt;code&gt;render()&lt;/code&gt; can&amp;rsquo;t return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">컴포넌트 &lt;code&gt;render()&lt;/code&gt; 메소드에 리턴 유형이 필요한 경우 &lt;code&gt;React.Node&lt;/code&gt; 를 사용해야합니다 . 그러나 하위 소품에 일반 유형이 필요한 경우 &lt;code&gt;?React.Node&lt;/code&gt; 사용 하십시오 . &lt;code&gt;render()&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 를 반환 할 수없는 경우 자식을 정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="abe11ee943e5dc689dcff158386be0fb8f22ac39" translate="yes" xml:space="preserve">
          <source>If you only want to specify some of the type arguments, you can use &lt;code&gt;_&lt;/code&gt; to let flow infer a type for you:</source>
          <target state="translated">유형 인수 중 일부만 지정하려는 경우 &lt;code&gt;_&lt;/code&gt; 를 사용 하여 플로우가 유형을 유추하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9a33f8497f3a49e54f6d651972b743d6f34b7b8" translate="yes" xml:space="preserve">
          <source>If you pass in a single value then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that single value. Here &lt;code&gt;props.children&lt;/code&gt; will be the number 42. Importantly, &lt;code&gt;props.children&lt;/code&gt; will not be an array! It will be &lt;em&gt;exactly&lt;/em&gt; the number 42.</source>
          <target state="translated">단일 값을 전달 경우 &lt;code&gt;props.children&lt;/code&gt; 이 될 것입니다 &lt;em&gt;정확히&lt;/em&gt; 하나의 값이. 여기 &lt;code&gt;props.children&lt;/code&gt; 이 수 (42)가 중요한 것, &lt;code&gt;props.children&lt;/code&gt; 는 배열되지 않습니다! 그것은 될 것입니다 &lt;em&gt;정확히&lt;/em&gt; 수 (42).</target>
        </trans-unit>
        <trans-unit id="0ccc08faa8b174c05c639636e1b782f03a991965" translate="yes" xml:space="preserve">
          <source>If you pass in no children when creating an element of &lt;code&gt;MyComponent&lt;/code&gt; then &lt;code&gt;props.children&lt;/code&gt; will not be set. If you try to access &lt;code&gt;props.children&lt;/code&gt;, it will be undefined.</source>
          <target state="translated">의 요소를 만들 때 어떤 어린이에 전달하는 경우 &lt;code&gt;MyComponent&lt;/code&gt; 다음 &lt;code&gt;props.children&lt;/code&gt; 가 설정되지 않습니다. &lt;code&gt;props.children&lt;/code&gt; 에 액세스하려고하면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34ece29e3b89f75f011bf7528980bbd49fd066fa" translate="yes" xml:space="preserve">
          <source>If you then put all your source files in a &lt;code&gt;src&lt;/code&gt; directory you can compile them to another directory by running:</source>
          <target state="translated">모든 소스 파일을 &lt;code&gt;src&lt;/code&gt; 디렉토리 에 넣으면 다음 을 실행하여 다른 디렉토리로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="062faa0de803caab920638881f00d7513c947ac6" translate="yes" xml:space="preserve">
          <source>If you try to export a wrapped component, chances are that you&amp;rsquo;ll run into a missing annotation error:</source>
          <target state="translated">래핑 된 구성 요소를 내보내려고하면 누락 된 주석 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="309fcc8f3cc112f1e5bcf47ecdb839392b2659c4" translate="yes" xml:space="preserve">
          <source>If you want a way to opt-out of using the type checker, &lt;code&gt;any&lt;/code&gt; is the way to do it. &lt;strong&gt;Using &lt;code&gt;any&lt;/code&gt; is completely unsafe, and should be avoided whenever possible.&lt;/strong&gt;</source>
          <target state="translated">이 유형 검사기를 사용하는 옵트 아웃 할 수있는 방법을 원하는 경우에, &lt;code&gt;any&lt;/code&gt; 그것을 할 수있는 방법입니다. &lt;strong&gt;사용 &lt;code&gt;any&lt;/code&gt; 것은 완전히 안전하지 않으므로 가능할 때마다 피해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b005b1abd0cefd6c2751db329291eac30a6cd45" translate="yes" xml:space="preserve">
          <source>If you want to allow missing properties, use &lt;a href=&quot;../objects#toc-optional-object-type-properties&quot;&gt;optional property&lt;/a&gt; syntax, where the &lt;code&gt;?&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt; the colon. It is also possible to combine both syntaxes for an optional maybe type, for example &lt;code&gt;{value?:?number}&lt;/code&gt;.</source>
          <target state="translated">누락 된 속성을 허용하려면 &lt;a href=&quot;../objects#toc-optional-object-type-properties&quot;&gt;선택적 속성&lt;/a&gt; 구문을 사용 하십시오 &lt;code&gt;?&lt;/code&gt; 콜론 &lt;em&gt;앞에&lt;/em&gt; 배치됩니다 . &lt;code&gt;{value?:?number}&lt;/code&gt; 와 같은 선택적 어쩌면 유형에 대해 두 구문을 결합 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f07f6bae6a75d430c4180eacf06f3bed1b73ebfb" translate="yes" xml:space="preserve">
          <source>If you want to have Flow treat a comment as if it were normal syntax, you can do so by adding a double colon &lt;code&gt;::&lt;/code&gt; to the start of the comment.</source>
          <target state="translated">Flow가 주석을 일반 구문처럼 처리하도록 하려면 주석 시작에 이중 콜론 &lt;code&gt;::&lt;/code&gt; 을 추가하여 주석을 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b5ea02b142df74d92e6a6f721434f19c8193978" translate="yes" xml:space="preserve">
          <source>If you want to make it &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; you can use parenthesis like: &lt;code&gt;(?Type)[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; 로 만들려면 다음 과 같이 괄호를 사용할 수 있습니다. &lt;code&gt;(?Type)[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="483317a13682411d8f1235de07f55cf867ba1719" translate="yes" xml:space="preserve">
          <source>If you wanted to use a class structurally you could do that by mixing them with objects as interfaces:</source>
          <target state="translated">클래스를 구조적으로 사용하려면 인터페이스와 객체를 혼합하여 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14412dd9ea135c9d1850cdc133b518a3da76d23" translate="yes" xml:space="preserve">
          <source>If you would like to add a type annotation to &lt;code&gt;defaultProps&lt;/code&gt; you can define the type as</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 에 유형 주석을 추가하려는 경우 유형을 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bd6e77a91375cf371a7745722382dbe962d5dda" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://atom.io&quot;&gt;Atom&lt;/a&gt; you have a bunch of options to integrate Flow into your code base.</source>
          <target state="translated">&lt;a href=&quot;https://atom.io&quot;&gt;Atom&lt;/a&gt; 을 사용하는 경우 Flow를 코드베이스에 통합 할 수있는 다양한 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="67b20f92754a07891c76908aee9f1c454fc3a6ad" translate="yes" xml:space="preserve">
          <source>If your component does have &lt;code&gt;defaultProps&lt;/code&gt;, you don&amp;rsquo;t want to just add &lt;code&gt;Props&lt;/code&gt; as a type argument to &lt;code&gt;trivialHOC&lt;/code&gt; because that will get rid of the &lt;code&gt;defaultProps&lt;/code&gt; information that flow has about your component.</source>
          <target state="translated">컴포넌트에 &lt;code&gt;defaultProps&lt;/code&gt; 가있는 경우 , &lt;code&gt;trivialHOC&lt;/code&gt; 에 대한 유형 인수로 &lt;code&gt;Props&lt;/code&gt; 를 추가하기를 원하지 않습니다. 이는 컴포넌트에 대해 플로우가 갖는 &lt;code&gt;defaultProps&lt;/code&gt; 정보를 제거하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="780a6023120264ade0b9dac9868692f3f30232eb" translate="yes" xml:space="preserve">
          <source>If your component has no &lt;code&gt;defaultProps&lt;/code&gt;, you can use &lt;code&gt;Props&lt;/code&gt; as a type argument for &lt;code&gt;Config&lt;/code&gt;.</source>
          <target state="translated">구성 요소에 &lt;code&gt;defaultProps&lt;/code&gt; 가 없으면 &lt;code&gt;Props&lt;/code&gt; 를 &lt;code&gt;Config&lt;/code&gt; 의 유형 인수로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df8b42d3edaced78a9cf76e1330bae86b8d96c3b" translate="yes" xml:space="preserve">
          <source>If your context has a default value, Flow will type your consumer component accordingly:</source>
          <target state="translated">컨텍스트에 기본값이있는 경우 흐름에 따라 소비자 구성 요소가 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="ae552724b48e29ed087f56eabc416631aed983c9" translate="yes" xml:space="preserve">
          <source>Ignores are processed AFTER includes. If you both include and ignore a file it will be ignored.</source>
          <target state="translated">포함 후 처리됩니다. 파일을 모두 포함하고 무시하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="90a346f6dee87e3209abc8b71fd3cfad11fc7766" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;concat&lt;/code&gt; function for concatenating two strings together.</source>
          <target state="translated">두 문자열을 연결하기위한 다음 &lt;code&gt;concat&lt;/code&gt; 함수를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="07e019c33eb53f751e20f583889e44cde2c245d3" translate="yes" xml:space="preserve">
          <source>Imagine we have the type &lt;code&gt;?number&lt;/code&gt;, if we want to use that value as a &lt;code&gt;number&lt;/code&gt; we&amp;rsquo;ll need to first check that it is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">우리가 &lt;code&gt;?number&lt;/code&gt; 유형을 가지고 있다고 상상해 봅시다. 그 값을 &lt;code&gt;number&lt;/code&gt; 로 사용 하려면 먼저 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 아닌지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6798e3c1aa807d4333e350015401a7abc70e80e3" translate="yes" xml:space="preserve">
          <source>Imagine writing the following &lt;code&gt;identity&lt;/code&gt; function which returns whatever value was passed.</source>
          <target state="translated">전달 된 값을 반환 하는 다음 &lt;code&gt;identity&lt;/code&gt; 함수를 작성한다고 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="ff623f8a9cd9b8f5349b3bb1da56c38d35cc87a1" translate="yes" xml:space="preserve">
          <source>Importing and exporting types</source>
          <target state="translated">유형 가져 오기 및 내보내기</target>
        </trans-unit>
        <trans-unit id="8b69719d369c12ce9cd0e7524c2b8530f01cb19f" translate="yes" xml:space="preserve">
          <source>Importing and exporting values</source>
          <target state="translated">값 가져 오기 및 내보내기</target>
        </trans-unit>
        <trans-unit id="13534d9f1d5e200c3a0748880d5480a40ed54ff0" translate="yes" xml:space="preserve">
          <source>Impossible intersection types</source>
          <target state="translated">불가능한 교차로 유형</target>
        </trans-unit>
        <trans-unit id="36f5825f27a921e30d7ea8251d8987b448c8e07c" translate="yes" xml:space="preserve">
          <source>In 0.89.0, we introduced &lt;a href=&quot;../types#toc-react-abstractcomponent&quot;&gt;&lt;code&gt;React.AbstractComponent&lt;/code&gt;&lt;/a&gt;, which gives you more expressive power when writing HOCs and library definitions.</source>
          <target state="translated">0.89.0에서는 HOC 및 라이브러리 정의를 작성할 때 더욱 표현력을 제공하는 &lt;a href=&quot;../types#toc-react-abstractcomponent&quot;&gt; &lt;code&gt;React.AbstractComponent&lt;/code&gt; &lt;/a&gt; 를 도입 했습니다 .</target>
        </trans-unit>
        <trans-unit id="d23cd461e61670be17a5cbf84c124cd9f286a1b6" translate="yes" xml:space="preserve">
          <source>In Flow every value and expression has a type.</source>
          <target state="translated">흐름에서 모든 값과 표현식에는 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b86cc8dc870697405ea856ce5507108777717a2" translate="yes" xml:space="preserve">
          <source>In Flow these fall into two groups:</source>
          <target state="translated">흐름에서 이들은 두 그룹으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="18a40bb39b26a81dd8b90a84e6fcc2a7aa9f4ec7" translate="yes" xml:space="preserve">
          <source>In Flow this will cause an error because if you are expecting to get a return value of a &lt;code&gt;City&lt;/code&gt;, you may be using something that doesn&amp;rsquo;t exist on &lt;code&gt;Noun&lt;/code&gt;, which could easily cause an error at runtime.</source>
          <target state="translated">Flow에서 &lt;code&gt;City&lt;/code&gt; 의 반환 값을 얻을 것으로 예상되는 경우 &lt;code&gt;Noun&lt;/code&gt; 에 존재하지 않는 것을 사용하고 있기 때문에 런타임에 쉽게 오류를 일으킬 수 있기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="878790a54a5224ef661b3530ee00eb752ab21af0" translate="yes" xml:space="preserve">
          <source>In Flow you can &lt;a href=&quot;../literals&quot;&gt;use union types similar to enums&lt;/a&gt;:</source>
          <target state="translated">Flow에서는 &lt;a href=&quot;../literals&quot;&gt;열거 형과 비슷한 공용체 유형을 사용할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7fb60b92b4e843cc692009677f907537c735a2b" translate="yes" xml:space="preserve">
          <source>In Flow you can create tuples using the &lt;code&gt;[type, type, type]&lt;/code&gt; syntax.</source>
          <target state="translated">Flow에서는 &lt;code&gt;[type, type, type]&lt;/code&gt; 구문을 사용하여 튜플을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1aed1690eff4b4d2b58bb1fcd12c1d5c6f001410" translate="yes" xml:space="preserve">
          <source>In Flow you don&amp;rsquo;t type annotate &lt;code&gt;this&lt;/code&gt; and Flow will check whatever context you call the function with.</source>
          <target state="translated">흐름에서는 주석을 입력하지 않는 &lt;code&gt;this&lt;/code&gt; 와 흐름은 당신이 함수를 호출 어떤 컨텍스트 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1866b0c88cce2b9c6a8fee29c5128f64a2f80305" translate="yes" xml:space="preserve">
          <source>In Flow, it is considered safe to pass an object with extra properties where a normal object type is expected.</source>
          <target state="translated">Flow에서는 일반 객체 유형이 필요한 추가 속성을 가진 객체를 전달하는 것이 안전하다고 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ce986f956cc22b12a2a6bfffc8a5a0edb258999c" translate="yes" xml:space="preserve">
          <source>In Flow, most of the time when you pass one type into another you lose the original type. So that when you pass a specific type into a less specific one Flow &amp;ldquo;forgets&amp;rdquo; it was once something more specific.</source>
          <target state="translated">Flow에서 한 유형을 다른 유형으로 전달하면 대부분 원래 유형이 손실됩니다. 따라서 특정 유형을 덜 구체적인 유형으로 전달할 때 Flow는 &quot;잊어 버렸습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="9a9bbf724831d747e94152055fbfe4af4a218e78" translate="yes" xml:space="preserve">
          <source>In Flow, there is a similar &lt;code&gt;typeof&lt;/code&gt; operator, but it&amp;rsquo;s much more powerful.</source>
          <target state="translated">흐름, 거기에 유사합니다 &lt;code&gt;typeof&lt;/code&gt; 연산자,하지만 훨씬 더 강력합니다.</target>
        </trans-unit>
        <trans-unit id="41f1a84e9859f569ee928b713503208cbf3bc5fb" translate="yes" xml:space="preserve">
          <source>In JavaScript there are many types of values: numbers, strings, booleans, functions, objects, and more.</source>
          <target state="translated">JavaScript에는 숫자, 문자열, 부울, 함수, 객체 등 여러 유형의 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e94f6f8db81e235b729c1d11091229874c69e47d" translate="yes" xml:space="preserve">
          <source>In JavaScript, accessing a property that doesn&amp;rsquo;t exist evaluates to &lt;code&gt;undefined&lt;/code&gt;. This is a common source of errors in JavaScript programs, so Flow turns these into type errors.</source>
          <target state="translated">JavaScript에서 존재하지 않는 속성에 액세스하면 &lt;code&gt;undefined&lt;/code&gt; 로 평가됩니다 . 이것은 JavaScript 프로그램의 일반적인 오류 소스이므로 Flow는 이러한 오류를 유형 오류로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="607c3a17b963c6542847246278eb0d806eb5228c" translate="yes" xml:space="preserve">
          <source>In Nuclide, Flow warnings are distinct from Flow errors and rendered in a different color.</source>
          <target state="translated">Nuclide에서 흐름 경고는 흐름 오류와 다르며 다른 색으로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="8602c23e7637c0b355d504e31ab6ce9a57961195" translate="yes" xml:space="preserve">
          <source>In addition to classes, React also supports stateless functional components. You type these components like you would type a function:</source>
          <target state="translated">클래스 외에도 React는 상태 비 저장 기능 구성 요소를 지원합니다. 함수를 입력하는 것처럼 다음 구성 요소를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="5c3523d972cffa078864d6aecc1b5016808eb504" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;type&lt;/code&gt; in &lt;code&gt;?type&lt;/code&gt;, maybe types can also be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?type&lt;/code&gt; 의 &lt;code&gt;type&lt;/code&gt; 외에도 type 은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;void&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2ee11de69f40000610dfec7ac07ec5df1cfe68c" translate="yes" xml:space="preserve">
          <source>In addition to their set type, default parameters can also be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">설정 유형 외에도 기본 매개 변수는 모두 &lt;code&gt;void&lt;/code&gt; 되거나 생략 될 수 있습니다 . 그러나 &lt;code&gt;null&lt;/code&gt; 은 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="76f3ea7a16fcff8d257f8c2b1bf73e609afb8ca9" translate="yes" xml:space="preserve">
          <source>In addition to their set type, these optional parameters can either be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">설정 유형 외에도 이러한 선택적 매개 변수는 모두 &lt;code&gt;void&lt;/code&gt; 이거나 생략 될 수 있습니다 . 그러나 &lt;code&gt;null&lt;/code&gt; 은 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="05442271873e7bd4801123e6c257336f2ff42022" translate="yes" xml:space="preserve">
          <source>In addition to their set value type, these optional properties can either be &lt;code&gt;void&lt;/code&gt; or omitted altogether. However, they cannot be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">설정 값 유형 외에도 이러한 선택적 속성은 모두 &lt;code&gt;void&lt;/code&gt; 이거나 생략 될 수 있습니다 . 그러나 &lt;code&gt;null&lt;/code&gt; 은 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eee0e3df17d7390f34a9ec9aa8fb61edb49a05a1" translate="yes" xml:space="preserve">
          <source>In all forms, whitespace and asterisks between words are ignored, allowing for flexible formatting.</source>
          <target state="translated">모든 형식에서 단어 사이의 공백과 별표는 무시되므로 유연한 서식이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fc7fa03e8c32cc9ea9869eea330877a166bc87da" translate="yes" xml:space="preserve">
          <source>In an ideal world, every type checker would be both sound &lt;em&gt;and&lt;/em&gt; complete so that it catches &lt;em&gt;every&lt;/em&gt; error that &lt;em&gt;will&lt;/em&gt; happen at runtime.</source>
          <target state="translated">이상적인 세계에서는 모든 유형 검사는 사운드 모두 것 &lt;em&gt;과&lt;/em&gt; 는 연결되는지 완전한 그래서 &lt;em&gt;모든&lt;/em&gt; 오류 &lt;em&gt;합니다&lt;/em&gt; 런타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e980406b01916b102c664aa8bc420ac8164cdd8" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re looking for something even more minimal, &lt;a href=&quot;https://atom.io/packages/linter-flow&quot;&gt;linter-flow&lt;/a&gt; may be worth your attention. It only lints your code and provides no other features, but it does support on-the-fly linting.</source>
          <target state="translated">더 작은 것을 찾고 있다면 &lt;a href=&quot;https://atom.io/packages/linter-flow&quot;&gt;linter-flow 가주&lt;/a&gt; 의를 기울일 가치가 있습니다. 코드를 보푸라기 만하고 다른 기능은 제공하지 않지만 즉시 보푸라기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9bffcd7b9f6bc8c106a178e285d7f231f68f3d4e" translate="yes" xml:space="preserve">
          <source>In general, programs have several different categories of types:</source>
          <target state="translated">일반적으로 프로그램에는 여러 유형의 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd7f4f3ed72057427360f7865505bb3424508d31" translate="yes" xml:space="preserve">
          <source>In general, the function subtyping rule is this: A function type &lt;code&gt;B&lt;/code&gt; is a subtype of a function type &lt;code&gt;A&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s inputs are a superset of &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s, and &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s outputs are a subset of &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s. The subtype must accept &lt;em&gt;at least&lt;/em&gt; the same inputs as its parent, and must return &lt;em&gt;at most&lt;/em&gt; the same outputs.</source>
          <target state="translated">일반적으로 함수 하위 입력 규칙은 다음과 같습니다. 함수 유형 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;B&lt;/code&gt; 입력이 &lt;code&gt;A&lt;/code&gt; 의 상위 집합 이고 &lt;code&gt;B&lt;/code&gt; 출력이 &lt;code&gt;A&lt;/code&gt; 의 하위 집합 인 경우에만 함수 유형 &lt;code&gt;A&lt;/code&gt; 의 하위 유형입니다. . 부속 유형은 &lt;em&gt;최소한&lt;/em&gt; 상위와 동일한 입력을 허용 해야 &lt;em&gt;하며 최대&lt;/em&gt; 동일한 출력을 리턴해야합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a36883ee8e26a0df06cf9d297126b7d9d0279d23" translate="yes" xml:space="preserve">
          <source>In most editors, Flow warnings are likely to be rendered the same way as other warnings are rendered by that editor.</source>
          <target state="translated">대부분의 편집기에서 흐름 경고는 해당 편집기에서 다른 경고를 렌더링하는 것과 같은 방식으로 렌더링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3519b95ac1b03c724bc36beb2d830f52032a8ec0" translate="yes" xml:space="preserve">
          <source>In order to create a type cast expression around a &lt;code&gt;value&lt;/code&gt;, add a colon &lt;code&gt;:&lt;/code&gt; with the &lt;code&gt;Type&lt;/code&gt; and wrap the expression with parentheses &lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">전세계 거의 타입 캐스트 표현 만들려면 &lt;code&gt;value&lt;/code&gt; 콜론을 추가 &lt;code&gt;:&lt;/code&gt; 와 &lt;code&gt;Type&lt;/code&gt; 및 괄호 식을 래핑 &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a95a2762627991309d591271ba0f2cb553d8347" translate="yes" xml:space="preserve">
          <source>In order to make this safe, Flow would have to mark every single array access as &amp;ldquo;&lt;em&gt;possibly undefined&amp;rdquo;&lt;/em&gt;.</source>
          <target state="translated">이를 안전하게 유지하기 위해 Flow는 모든 단일 어레이 액세스를 &quot; &lt;em&gt;가능하지 않은&quot;것으로&lt;/em&gt; 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf1c4a34bb0b2870f57375eef532ff3033ee975a" translate="yes" xml:space="preserve">
          <source>In order to type your Redux &lt;a href=&quot;http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators&quot;&gt;thunk actions&lt;/a&gt;, you&amp;rsquo;ll add types for &lt;code&gt;ThunkAction&lt;/code&gt; as a function &lt;code&gt;Dispatch&lt;/code&gt;, and &lt;code&gt;GetState&lt;/code&gt;. &lt;code&gt;GetState&lt;/code&gt; is a function that returns an &lt;code&gt;Object&lt;/code&gt;. &lt;code&gt;Dispatch&lt;/code&gt; accepts a disjoint union of &lt;code&gt;Action&lt;/code&gt;, &lt;code&gt;ThunkAction&lt;/code&gt;, &lt;code&gt;PromiseAction&lt;/code&gt; and &lt;code&gt;Array&amp;lt;Action&amp;gt;&lt;/code&gt; and can return &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Redux &lt;a href=&quot;http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators&quot;&gt;썽크 작업&lt;/a&gt; 을 입력하기 위해 &lt;code&gt;ThunkAction&lt;/code&gt; 에 대한 유형을 함수 &lt;code&gt;Dispatch&lt;/code&gt; 및 &lt;code&gt;GetState&lt;/code&gt; 로 추가 합니다. &lt;code&gt;GetState&lt;/code&gt; 는 &lt;code&gt;Object&lt;/code&gt; 를 반환하는 함수입니다 . &lt;code&gt;Dispatch&lt;/code&gt; 는 &lt;code&gt;Action&lt;/code&gt; , &lt;code&gt;ThunkAction&lt;/code&gt; , &lt;code&gt;PromiseAction&lt;/code&gt; 및 &lt;code&gt;Array&amp;lt;Action&amp;gt;&lt;/code&gt; 의 분리 된 결합을 허용하며 &lt;code&gt;any&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="463948e140100316fb05c0438cb2fb9b2c50f529" translate="yes" xml:space="preserve">
          <source>In order to type your Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html#action-creators&quot;&gt;action creators&lt;/a&gt;, you&amp;rsquo;ll want to split up your &lt;code&gt;Action&lt;/code&gt; disjoint union into separate action types.</source>
          <target state="translated">Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html#action-creators&quot;&gt;액션 생성자&lt;/a&gt; 를 입력하려면 &lt;code&gt;Action&lt;/code&gt; 분리 조합을 별도의 액션 유형으로 분할해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a6ed0c1cedb4575cb7b5ef3b66fc0929b6243133" translate="yes" xml:space="preserve">
          <source>In other words, we must engineer Flow&amp;rsquo;s analysis to be extremely fast&amp;mdash;it must respond to code changes without noticeable delay, while still being precise enough in practice.</source>
          <target state="translated">다시 말해, Flow의 분석이 매우 빠르도록 엔지니어링해야합니다. 실제로 실제로는 정확하면서도 지연없이 코드 변경에 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ed3794afb3687160903becf6fab09177a6b9c44" translate="yes" xml:space="preserve">
          <source>In other words, we want Flow&amp;rsquo;s analysis to be precise in practice&amp;mdash;it must model essential characteristics of the language accurately enough to understand the difference between idiomatic code and unintentional mistakes.</source>
          <target state="translated">다시 말해, Flow의 분석이 실제로 정확 해지기를 원합니다. 관용적 코드와 의도하지 않은 실수의 차이를 이해할 수있을 정도로 언어의 필수 특성을 정확하게 모델링해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fb052ce5832a38b07cfb4b3b186920962dddf8c" translate="yes" xml:space="preserve">
          <source>In principle, this overhead can be mitigated by adding a layer of types to the codebase, and building tools that use type information to solve the above problems. For example, types can be used to identify bugs, to document interfaces of libraries, and so on.</source>
          <target state="translated">원칙적으로이 오버 헤드는 코드베이스에 유형 레이어를 추가하고 유형 정보를 사용하여 위의 문제를 해결하는 도구를 빌드함으로써 완화 할 수 있습니다. 예를 들어, 유형을 사용하여 버그를 식별하고 라이브러리의 인터페이스를 문서화하는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46c0c160ff60aaa1954f2f13af37869b4cd1f894" translate="yes" xml:space="preserve">
          <source>In situations like this one, you can leverage the &lt;code&gt;$Keys&amp;lt;T&amp;gt;&lt;/code&gt; operator. Let&amp;rsquo;s see another example, this time using &lt;code&gt;$Keys&lt;/code&gt;:</source>
          <target state="translated">이와 같은 상황에서는 &lt;code&gt;$Keys&amp;lt;T&amp;gt;&lt;/code&gt; 연산자를 활용할 수 있습니다 . 이번에는 &lt;code&gt;$Keys&lt;/code&gt; 사용하는 또 다른 예를 보자 .</target>
        </trans-unit>
        <trans-unit id="07ca63a4c55eeea9fee508bfce14ba359d037e35" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://facebook.github.io/react/docs/handling-events.html&quot;&gt;React docs &amp;ldquo;Handling Events&amp;rdquo; section&lt;/a&gt; a few different recommendations are provided on how to define event handlers. If you are using Flow we recommend that you use &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;property initializer syntax&lt;/a&gt; as it is the easiest to statically type. Property initializer syntax looks like this:</source>
          <target state="translated">(가)에서 &lt;a href=&quot;https://facebook.github.io/react/docs/handling-events.html&quot;&gt;문서 &quot;이벤트 처리&quot;섹션 반응&lt;/a&gt; 몇 가지 권장 사항은 이벤트 핸들러를 정의하는 방법에 제공됩니다. Flow를 사용 하는 경우 정적으로 입력하는 것이 가장 쉬운 &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;속성 초기화 구문&lt;/a&gt; 을 사용하는 것이 좋습니다 . 속성 초기화 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="045b4893ca1ae9c77490fd71764ad7b6d77ffa63" translate="yes" xml:space="preserve">
          <source>In the above case, we&amp;rsquo;re using literal values as &lt;code&gt;K&lt;/code&gt;, similarly to &lt;a href=&quot;#toc-propertytype&quot;&gt;&lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt;&lt;/a&gt;. However, when using &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, &lt;code&gt;K&lt;/code&gt; is allowed to be any type, as long as that type exists on the keys of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">위의 경우 &lt;a href=&quot;#toc-propertytype&quot;&gt; &lt;code&gt;$PropertyType&amp;lt;T, k&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 리터럴 값을 &lt;code&gt;K&lt;/code&gt; 로 사용합니다 . 그러나 &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 경우 &lt;code&gt;K&lt;/code&gt; 의 유형이 &lt;code&gt;T&lt;/code&gt; 의 키에 존재하는 한 K 는 모든 유형이 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f5298183f55322a9608c40096489e4fbda648b8" translate="yes" xml:space="preserve">
          <source>In the case of objects, a &lt;strong&gt;missing&lt;/strong&gt; property is not the same thing as an explicitly &lt;code&gt;undefined&lt;/code&gt; property.</source>
          <target state="translated">객체의 경우 &lt;strong&gt;누락 된&lt;/strong&gt; 속성은 명시 적으로 &lt;code&gt;undefined&lt;/code&gt; 속성 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="4dd1fcffc78ce1a79e176af9465300a76e634c4a" translate="yes" xml:space="preserve">
          <source>In the code below, value can either be &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;B&quot;&lt;/code&gt;.</source>
          <target state="translated">아래 코드에서 value는 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de4288f8d4aaa876255c7f68bbbad7dd659c5cbb" translate="yes" xml:space="preserve">
          <source>In the example above we are using a &lt;a href=&quot;https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous&quot;&gt;React &lt;code&gt;setState()&lt;/code&gt; updater function&lt;/a&gt; but you could also pass a partial state object to &lt;code&gt;setState()&lt;/code&gt;.</source>
          <target state="translated">위 예제에서 &lt;a href=&quot;https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous&quot;&gt;React &lt;code&gt;setState()&lt;/code&gt; 업데이터 함수를 사용하고&lt;/a&gt; 있지만 부분 상태 객체를 &lt;code&gt;setState()&lt;/code&gt; 로 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78c833515da3868b1bb8e2586fa68f8aa20ca1b3" translate="yes" xml:space="preserve">
          <source>In the example above, the type of &lt;code&gt;Country&lt;/code&gt; is equivalent to &lt;code&gt;type Country = 'US' | 'IT' | 'FR'&lt;/code&gt;, but Flow was able to extract it from the keys of &lt;code&gt;countries&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;Country&lt;/code&gt; 유형은 &lt;code&gt;type Country = 'US' | 'IT' | 'FR'&lt;/code&gt; 과 같습니다. | 'IT'| 'FR' 이지만 Flow는 &lt;code&gt;countries&lt;/code&gt; 의 키에서 추출 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="937e9cdc3d741999bdf658703ba5d2d9ee3fef52" translate="yes" xml:space="preserve">
          <source>In the first case, the exported types of a module are declared in a &lt;em&gt;declaration file&lt;/em&gt;&lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt;, that is located in the same directory as the corresponding &lt;em&gt;implementation file&lt;/em&gt;&lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt;. The declaration file completely shadows the colocated implementation. In other words, Flow will completely ignore &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; and just read &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; instead.</source>
          <target state="translated">첫 번째 경우, 내 보낸 모듈 유형은 &lt;em&gt;선언 파일 &lt;/em&gt; &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; 에&lt;em&gt;선언&lt;/em&gt; 되며, 해당 &lt;em&gt;구현 파일 &lt;/em&gt; &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; 과 동일한 디렉토리에 있습니다. 선언 파일은 배치 된 구현을 완전히 음영 처리합니다. 다시 말해 Flow는 &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; 을 완전히 무시하고 대신 &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="0f92740913668ddf1132fafd30e60ebce2409efa" translate="yes" xml:space="preserve">
          <source>In the following example, say you want to finish writing the function &lt;code&gt;fooList&lt;/code&gt; without bothering to mock up its dependencies first: a function &lt;code&gt;foo&lt;/code&gt; that takes a &lt;code&gt;number&lt;/code&gt; and returns a &lt;code&gt;string&lt;/code&gt;, and a class &lt;code&gt;List&lt;/code&gt; that has a &lt;code&gt;map&lt;/code&gt; method. You can do this by including declarations for &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서, 먼저 의존성을 조롱하지 않고 &lt;code&gt;fooList&lt;/code&gt; 함수 작성을 마치 려고 합니다. &lt;code&gt;number&lt;/code&gt; 를 가져 와서 &lt;code&gt;string&lt;/code&gt; 리턴하는 함수 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;map&lt;/code&gt; 메소드 가있는 클래스 &lt;code&gt;List&lt;/code&gt; 입니다 . &lt;code&gt;List&lt;/code&gt; 와 &lt;code&gt;foo&lt;/code&gt; 에 대한 선언을 포함하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2326d39f5c6c0c33efe4e847e245df6cca55d45" translate="yes" xml:space="preserve">
          <source>In the following example, we forget to properly annotate &lt;code&gt;identity&lt;/code&gt; with a generic type, so we run into trouble when we try to assign it to &lt;code&gt;func&lt;/code&gt;. On the other hand, &lt;code&gt;genericIdentity&lt;/code&gt; is properly typed, and we are able to use it as expected.</source>
          <target state="translated">다음 예제에서는 일반 유형으로 &lt;code&gt;identity&lt;/code&gt; 에 주석을 올바르게 달지 않는 것을 잊어 버렸습니다 . 따라서 &lt;code&gt;func&lt;/code&gt; 에 할당하려고 할 때 문제가 발생합니다 . 반면에 &lt;code&gt;genericIdentity&lt;/code&gt; 가 올바르게 입력 되었으므로 예상대로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f9d0bf254d010bdd633b1f172693e7ad6fbe077" translate="yes" xml:space="preserve">
          <source>In the previous section we showed how refinement is lost after a function call. The exact same thing happens within closures, since Flow does not track how your value might change before the closure is called.</source>
          <target state="translated">이전 섹션에서는 함수 호출 후 구체화가 손실되는 방법을 보여주었습니다. Flow는 클로저가 호출되기 전에 값이 어떻게 변하는 지 추적하지 않기 때문에 클로저 내에서도 똑같은 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="26926ea42a5a5143965f679a788052c45d4b2dee" translate="yes" xml:space="preserve">
          <source>In the second case, the implementation file is missing entirely. &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; is treated as if it is named &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">두 번째 경우, 구현 파일이 완전히 누락되었습니다. &lt;code&gt;&amp;lt;FILENAME&amp;gt;.flow&lt;/code&gt; 는 마치 &lt;code&gt;&amp;lt;FILENAME&amp;gt;&lt;/code&gt; 이름 인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="b39b2010529d0c2ccb12cf90571d17f75bb0be7e" translate="yes" xml:space="preserve">
          <source>In the second example, the first use of &lt;code&gt;?.&lt;/code&gt; is valid, since &lt;code&gt;foo&lt;/code&gt; is potentially nullish, but the second use of &lt;code&gt;?.&lt;/code&gt; is unnecessary. The left-hand-side of the second &lt;code&gt;?.&lt;/code&gt; (&lt;code&gt;foo?.bar&lt;/code&gt;) can only be nullish as a result of &lt;code&gt;foo&lt;/code&gt; being nullish, and when &lt;code&gt;foo&lt;/code&gt; is nullish, short-circuiting lets us avoid the second &lt;code&gt;?.&lt;/code&gt; altogether!</source>
          <target state="translated">두 번째 예에서는 &lt;code&gt;?.&lt;/code&gt; 처음 사용 합니다. &lt;code&gt;foo&lt;/code&gt; 는 잠재적으로 nullish이지만 &lt;code&gt;?.&lt;/code&gt; 의 두 번째 사용 이므로 유효합니다 . 불필요합니다. 두 번째의 왼쪽 &lt;code&gt;?.&lt;/code&gt; ( &lt;code&gt;foo?.bar&lt;/code&gt; )는 &lt;code&gt;foo&lt;/code&gt; 가 nullish 인 결과 로만 nullish 일 수 있으며 &lt;code&gt;foo&lt;/code&gt; 가 nullish 인 경우 단락으로 인해 두 번째 &lt;code&gt;?.&lt;/code&gt; 피할 수 있습니다 . 전부!</target>
        </trans-unit>
        <trans-unit id="fe1405a89cd32b054392c7923e187f575819c2aa" translate="yes" xml:space="preserve">
          <source>In this guide we will assume you know &lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot;&gt;the React basics&lt;/a&gt; and focus on adding types for patterns you are already familiar with. We will be using examples based on &lt;code&gt;react-dom&lt;/code&gt;, but all of these patterns work in other environments like &lt;code&gt;react-native&lt;/code&gt; as well.</source>
          <target state="translated">이 안내서에서는 &lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot;&gt;React 기본 사항&lt;/a&gt; 을 알고 있다고 가정 하고 이미 익숙한 패턴 유형을 추가하는 데 중점을 둡니다. 우리는 &lt;code&gt;react-dom&lt;/code&gt; 에 기반한 예제를 사용할 것이지만,이 패턴들 모두는 &lt;code&gt;react-native&lt;/code&gt; 와 같은 다른 환경에서도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="1725f004837e7311155dfaefd968a330b6660337" translate="yes" xml:space="preserve">
          <source>In type systems, &lt;strong&gt;&lt;em&gt;soundness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to catch every single error that &lt;em&gt;might&lt;/em&gt; happen at runtime. This comes at the cost of sometimes catching errors that will not actually happen at runtime.</source>
          <target state="translated">유형 시스템에서 &lt;strong&gt;&lt;em&gt;건전성&lt;/em&gt;&lt;/strong&gt; 은 유형 검사기가 런타임시 발생할 &lt;em&gt;수&lt;/em&gt; 있는 모든 단일 오류를 포착 할 수있는 기능입니다 . 런타임에 실제로 발생하지 않는 오류를 잡아내는 데 비용이 듭니다.</target>
        </trans-unit>
        <trans-unit id="0c22f8d1c20f6a2e728f54e6d0eb1c49eaf70b92" translate="yes" xml:space="preserve">
          <source>In which &lt;code&gt;props.children&lt;/code&gt; would be the array &lt;code&gt;['hello', ' ', &amp;lt;strong&amp;gt;world&amp;lt;/strong&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">된 &lt;code&gt;props.children&lt;/code&gt; 가 배열 될 것이다 &lt;code&gt;['hello', ' ', &amp;lt;strong&amp;gt;world&amp;lt;/strong&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ace6df33f153a56a5ba7bd262d1c9b70a75f2081" translate="yes" xml:space="preserve">
          <source>In which &lt;code&gt;props.children&lt;/code&gt; would be the array &lt;code&gt;['hello', ' world']&lt;/code&gt;.</source>
          <target state="translated">된 &lt;code&gt;props.children&lt;/code&gt; 가 배열 될 것이다 &lt;code&gt;['hello', ' world']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="379e9d202df0a82bef07b8db10eab0a058f9a77e" translate="yes" xml:space="preserve">
          <source>Indexer properties can be mixed with named properties:</source>
          <target state="translated">인덱서 속성은 명명 된 속성과 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bdd61bb5045aa0f67014c84f13de75c521599ec" translate="yes" xml:space="preserve">
          <source>Initialize Your Project</source>
          <target state="translated">프로젝트 초기화</target>
        </trans-unit>
        <trans-unit id="8f1c0c5725c5ba0a7b766ec69cb3fb2725c240c3" translate="yes" xml:space="preserve">
          <source>Injecting Props</source>
          <target state="translated">소품 주입</target>
        </trans-unit>
        <trans-unit id="830945c41eb45cbd674fe46b49ac731ee56e9c2d" translate="yes" xml:space="preserve">
          <source>Inlining declarations in regular code</source>
          <target state="translated">일반 코드에서 선언 인라인</target>
        </trans-unit>
        <trans-unit id="9f834cdcbee4998ebcf13d92d61227888d432240" translate="yes" xml:space="preserve">
          <source>Inside of &lt;code&gt;otherMethod()&lt;/code&gt; we sometimes remove &lt;code&gt;prop&lt;/code&gt;. Flow doesn&amp;rsquo;t know if the &lt;code&gt;if (value.prop)&lt;/code&gt; check is still true, so it invalidates the refinement.</source>
          <target state="translated">&lt;code&gt;otherMethod()&lt;/code&gt; 내부에서 가끔 &lt;code&gt;prop&lt;/code&gt; 을 제거 합니다. 흐름은 &lt;code&gt;if (value.prop)&lt;/code&gt; 검사가 여전히 참 인지 알지 못 하므로 구체화가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="59233b6f1516ac12e9141c55c7ddd0c26f41e51e" translate="yes" xml:space="preserve">
          <source>Inside of the else block we know that value must be &lt;code&gt;&quot;B&quot;&lt;/code&gt; because it can only be &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;B&quot;&lt;/code&gt; and we&amp;rsquo;ve removed &lt;code&gt;&quot;A&quot;&lt;/code&gt; from the possibilities.</source>
          <target state="translated">else 블록 안에서 값은 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 일 수 있고 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 는 가능성에서 제거 되었기 때문에 값은 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1d0007e9fb3d8a6684762ca326d9d60b18283cd" translate="yes" xml:space="preserve">
          <source>Inside of the if block we know that value must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; because that&amp;rsquo;s the only time the if-statement will be truthy.</source>
          <target state="translated">if 블록 안에서 우리는 값이 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 여야한다는 것을 알고 있습니다. 왜냐하면 if 문이 진실한 시간이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4d19f21faddc0369982f34fb998d7a87e3e3ab91" translate="yes" xml:space="preserve">
          <source>Install the Package Control plugin if you don&amp;rsquo;t have it</source>
          <target state="translated">패키지 컨트롤 플러그인이 없으면 설치하십시오</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="287044f73b2dcfe1503bb32ec13af489f09a4131" translate="yes" xml:space="preserve">
          <source>Instance is optional and is mixed by default.</source>
          <target state="translated">인스턴스는 선택 사항이며 기본적으로 혼합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="42265abaed207a8433bf897fbee94fabb9b7efc6" translate="yes" xml:space="preserve">
          <source>Instead of typing out a full include every time, you can also use the type annotation shorthand with a single colon &lt;code&gt;:&lt;/code&gt; at the start of the comment.</source>
          <target state="translated">대신 전체 모든 시간을 포함 밖으로 입력, 당신은 또한 단일 콜론 유형 주석 속기를 사용할 수 있습니다 &lt;code&gt;:&lt;/code&gt; 주석의 시작.</target>
        </trans-unit>
        <trans-unit id="4f9d52dffb6f20d8a91f95ec202f836667e53109" translate="yes" xml:space="preserve">
          <source>Instead we can assert the type within the function using a type assertion and now we&amp;rsquo;re validating our inputs.</source>
          <target state="translated">대신에 우리는 타입 주장을 사용하여 함수 내에서 타입을 주장 할 수 있으며 이제 입력을 검증하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a0cda6edccbb3f27daf363a3f9e17bc75002fbb" translate="yes" xml:space="preserve">
          <source>Instead we can create a generic (or polymorphic type) in our function and use it in place of other types.</source>
          <target state="translated">대신 함수에서 제네릭 (또는 다형성 유형)을 만들어 다른 유형 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18d4d0b561fd6c9ad913387087267f2acae3ec97" translate="yes" xml:space="preserve">
          <source>Instead you must ensure the value is a certain type by refining it.</source>
          <target state="translated">대신 값을 수정하여 특정 유형인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc437265bdc77498fe50689b8604c4782c5d0c38" translate="yes" xml:space="preserve">
          <source>Instead, Flow needs to be able to figure out the type of a value by analyzing it without running it (static analysis). It works its way through every known type and starts to figure out what all the expressions around them result in.</source>
          <target state="translated">대신 Flow는 값을 실행하지 않고 분석하여 값의 유형을 파악할 수 있어야합니다 (정적 분석). 알려진 모든 유형을 통해 작동하며 주변의 모든 표현이 어떤 결과를 낳는 지 파악하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="cc0d73bb17ba9a6bc2ab84e4aeee29d97f21d5f9" translate="yes" xml:space="preserve">
          <source>Instead, if we create a union type of both object types, Flow will be able to know which object we&amp;rsquo;re using based on the success property.</source>
          <target state="translated">대신 두 객체 유형의 통합 유형을 만들면 Flow는 success 속성을 기반으로 사용중인 객체를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09971a8657fbf9e085d4cbb5f761ac73cf61af5d" translate="yes" xml:space="preserve">
          <source>Instead, you can use &lt;code&gt;interface&lt;/code&gt; in order to declare the structure of the class that you are expecting.</source>
          <target state="translated">대신 &lt;code&gt;interface&lt;/code&gt; 를 사용 하여 기대하는 클래스의 구조를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c9832840de0bf07db6e7e769199b00197d92be2" translate="yes" xml:space="preserve">
          <source>Instead, you could add a type to your generic like you would with a function parameter.</source>
          <target state="translated">대신 함수 매개 변수를 사용하는 것처럼 제네릭에 형식을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7f5be1f3824ca58b2047493f6f9764ebebd43f" translate="yes" xml:space="preserve">
          <source>Interface Generics</source>
          <target state="translated">인터페이스 제네릭</target>
        </trans-unit>
        <trans-unit id="5c9516afee7b643e69c589c7e2bd6bb8f850ec3e" translate="yes" xml:space="preserve">
          <source>Interface Methods</source>
          <target state="translated">인터페이스 방법</target>
        </trans-unit>
        <trans-unit id="8e3d0bc70c93775ccb76349f5bd2dd104013f378" translate="yes" xml:space="preserve">
          <source>Interface Properties</source>
          <target state="translated">인터페이스 속성</target>
        </trans-unit>
        <trans-unit id="21a1595cfcababf257ea39c1df3d595d9106d56e" translate="yes" xml:space="preserve">
          <source>Interface Syntax</source>
          <target state="translated">인터페이스 구문</target>
        </trans-unit>
        <trans-unit id="70f73f412d22faa3833d1fbb1c9b469c337baa08" translate="yes" xml:space="preserve">
          <source>Interface Types</source>
          <target state="translated">인터페이스 유형</target>
        </trans-unit>
        <trans-unit id="74724adee3fa147f0cfea79a04b9867eafea6d0a" translate="yes" xml:space="preserve">
          <source>Interface generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use an interface you need to pass parameters for each of its generics.</source>
          <target state="translated">인터페이스 제네릭은 &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;매개 변수화&lt;/a&gt; 됩니다. 인터페이스를 사용할 때 각 제네릭에 대한 매개 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff0e2f95a23bc1a0a798148519f6dbf839797446" translate="yes" xml:space="preserve">
          <source>Interface properties are &lt;a href=&quot;https://flow.org/en/lang/variance/&quot;&gt;invariant&lt;/a&gt; by default. But you can add modifiers to make them covariant (read-only) or contravariant (write-only).</source>
          <target state="translated">인터페이스 속성은 기본적으로 &lt;a href=&quot;https://flow.org/en/lang/variance/&quot;&gt;변하지 않습니다&lt;/a&gt; . 그러나 수정자를 추가하여 공변량 (읽기 전용) 또는 반 변형 (쓰기 전용)으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3b1f8821225ec65ee0716fe750fde20ad499768" translate="yes" xml:space="preserve">
          <source>Interface properties can be optional as well.</source>
          <target state="translated">인터페이스 속성도 선택 사항이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eda7a98fcca8f4914f0766acaea5b5c31ce76c1" translate="yes" xml:space="preserve">
          <source>Interface property variance (read-only and write-only)</source>
          <target state="translated">인터페이스 속성 차이 (읽기 전용 및 쓰기 전용)</target>
        </trans-unit>
        <trans-unit id="8d1aa740c66ddff084a50256d6d5d30cf43e7c72" translate="yes" xml:space="preserve">
          <source>Interfaces are created using the keyword &lt;code&gt;interface&lt;/code&gt; followed by its name and a block which contains the body of the type definition.</source>
          <target state="translated">인터페이스는 키워드 &lt;code&gt;interface&lt;/code&gt; 와 이름 및 유형 정의 본문을 포함하는 블록을 사용하여 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="402c6f12d8378d77232d585fd7b337e32915eab4" translate="yes" xml:space="preserve">
          <source>Interfaces as maps</source>
          <target state="translated">맵으로서의 인터페이스</target>
        </trans-unit>
        <trans-unit id="1a13b883b189e50bf8951cacdf198f7feb8f80b6" translate="yes" xml:space="preserve">
          <source>Interfaces can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">인터페이스는 또한 &lt;a href=&quot;../generics&quot;&gt;제네릭을&lt;/a&gt; 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b5667cb6fa2d471880ebd263d10231bc9b5599a" translate="yes" xml:space="preserve">
          <source>Interfaces with generics</source>
          <target state="translated">제네릭과의 인터페이스</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">교차로 유형</target>
        </trans-unit>
        <trans-unit id="9a31764a6d7e0f5c4582676c60aee1f2a34282cc" translate="yes" xml:space="preserve">
          <source>Intersection ranges, which are ANDed together, (e.g. &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt;, which matches &lt;code&gt;0.13.0&lt;/code&gt; and &lt;code&gt;0.13.5&lt;/code&gt; but not &lt;code&gt;0.14.0&lt;/code&gt;).</source>
          <target state="translated">AND로 연결되는 교차 범위 (예 : &lt;code&gt;&amp;gt;=0.13.0 &amp;lt;0.14.0&lt;/code&gt; , &lt;code&gt;0.13.0&lt;/code&gt; 및 &lt;code&gt;0.13.5&lt;/code&gt; 와 일치 하지만 &lt;code&gt;0.14.0&lt;/code&gt; 과는 일치 하지 않음 )</target>
        </trans-unit>
        <trans-unit id="5f08815e0988cf77077de263c1ad9e7aa5845e9e" translate="yes" xml:space="preserve">
          <source>Intersection type syntax</source>
          <target state="translated">교차점 유형 구문</target>
        </trans-unit>
        <trans-unit id="626a19ac04f2c67f93200f15583f19cead27a82f" translate="yes" xml:space="preserve">
          <source>Intersection types are any number of types which are joined by an ampersand &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">교차 유형은 앰퍼샌드 ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) 로 결합 된 여러 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="8f7c84eb5f66c165a2d5dcc86fb36cae890387ee" translate="yes" xml:space="preserve">
          <source>Intersection types are the opposite of union types. When calling a function that accepts an intersection type, we must pass in &lt;strong&gt;&lt;em&gt;all of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we only have to treat it as &lt;strong&gt;&lt;em&gt;any one of those types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">교차점 유형은 공용체 유형과 반대입니다. 교차 유형을 허용하는 함수를 호출 할 때 &lt;strong&gt;&lt;em&gt;모든 유형을&lt;/em&gt;&lt;/strong&gt; 전달해야합니다 . 그러나 우리의 기능 안에서 우리는 그것을 &lt;strong&gt;&lt;em&gt;그 유형 중 하나로&lt;/em&gt;&lt;/strong&gt; 취급해야 &lt;strong&gt;&lt;em&gt;합니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="05fd5c57befbf7fcd9f20936b84629f69018650a" translate="yes" xml:space="preserve">
          <source>Intersection types require all in, but one out</source>
          <target state="translated">교차로 유형에는 모두 하나만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b7a19c5413699eccc99e2d547ef6d10a7c3d1bef" translate="yes" xml:space="preserve">
          <source>Intersections of exact object types may not work as you expect. If you need to combine exact object types, use object type spread:</source>
          <target state="translated">정확한 객체 유형의 교차가 예상대로 작동하지 않을 수 있습니다. 정확한 객체 유형을 결합해야하는 경우 객체 유형 스프레드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef1118f07f2f0b37c8e805eac5ac7941bb61730b" translate="yes" xml:space="preserve">
          <source>Intersections of object types</source>
          <target state="translated">객체 유형의 교차점</target>
        </trans-unit>
        <trans-unit id="2abe56a8a00ed911e647b0d623cffa17d4460d9d" translate="yes" xml:space="preserve">
          <source>Invariance</source>
          <target state="translated">Invariance</target>
        </trans-unit>
        <trans-unit id="da76716b09b6ac18a389bcf77588eef885895f86" translate="yes" xml:space="preserve">
          <source>Invariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;subtypes&lt;/strong&gt;.</source>
          <target state="translated">불일치 &lt;em&gt;는 &lt;/em&gt;&lt;strong&gt;하위 유형을&lt;/strong&gt; 허용 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6653bcb7fefb5beca9669e196871c6f423594c47" translate="yes" xml:space="preserve">
          <source>Invariance &lt;em&gt;does not&lt;/em&gt; accept &lt;strong&gt;supertypes&lt;/strong&gt;.</source>
          <target state="translated">불일치 &lt;em&gt;는 &lt;/em&gt;&lt;strong&gt;수퍼 타입을&lt;/strong&gt; 허용 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c6b07258a9d2edf9a12dc279bf478a7591587b4c" translate="yes" xml:space="preserve">
          <source>It can get a little bit more complicated than this.</source>
          <target state="translated">이것보다 조금 더 복잡해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1057c3d1333719898e827a2ee41fb627a60e7f29" translate="yes" xml:space="preserve">
          <source>It is also different from the &lt;code&gt;[declarations]&lt;/code&gt; section. This also does not typecheck the file contents, but &lt;code&gt;[declarations]&lt;/code&gt; does extract and use the signatures of functions, classes, etc, when checking other code.</source>
          <target state="translated">또한 &lt;code&gt;[declarations]&lt;/code&gt; 섹션 과 다릅니다 . 이것은 또한 파일 내용을 형식 검사하지 않지만 &lt;code&gt;[declarations]&lt;/code&gt; 은 다른 코드를 확인할 때 함수, 클래스 등의 서명을 추출하여 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3fbd12c64d612ad1b02084fd80cefee8a6288b8" translate="yes" xml:space="preserve">
          <source>It is also possible to declare both &lt;strong&gt;named&lt;/strong&gt; and &lt;strong&gt;default&lt;/strong&gt; exports in the same &lt;code&gt;declare module&lt;/code&gt; body.</source>
          <target state="translated">동일한 &lt;code&gt;declare module&lt;/code&gt; 본문 에서 &lt;strong&gt;명명 된&lt;/strong&gt; 내보내기 와 &lt;strong&gt;기본&lt;/strong&gt; 내보내기를 모두 선언 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0d57b0ea07b126bc6a1382dc48f77a187c015b2" translate="yes" xml:space="preserve">
          <source>It is also possible to invalidate refinements, for example:</source>
          <target state="translated">예를 들어, 구체화를 무효화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9db640a0ff9ca2d2098c8cf12f7a5222f3c36e9" translate="yes" xml:space="preserve">
          <source>It is common to have an empty &lt;code&gt;.flowconfig&lt;/code&gt; file for your project. However, you can &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;configure and customize Flow&lt;/a&gt; in many ways through options available to be added to &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">프로젝트에 빈 &lt;code&gt;.flowconfig&lt;/code&gt; 파일 이있는 것이 일반적 입니다. 그러나 &lt;code&gt;.flowconfig&lt;/code&gt; 에 추가 할 수있는 옵션을 통해 여러 가지 방법으로 &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;흐름&lt;/a&gt; 을 구성하고 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d64a8b56c9d350143c6c4049c479ee66c6fad872" translate="yes" xml:space="preserve">
          <source>It is often useful to share types in between modules (files). In Flow, you can export type aliases, interfaces, and classes from one file and import them in another.</source>
          <target state="translated">모듈 (파일)간에 유형을 공유하는 것이 유용한 경우가 많습니다. Flow에서는 한 파일에서 유형 별칭, 인터페이스 및 클래스를 내보내고 다른 파일로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="793822e10b49e7269fcbd5028ab19a2d3c9de56e" translate="yes" xml:space="preserve">
          <source>It may also be used as the return type of a stateless functional component:</source>
          <target state="translated">상태 비 저장 기능 구성 요소의 반환 유형으로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="75369e827759c9f54ba9a23edbe8b02d79a3c6c7" translate="yes" xml:space="preserve">
          <source>It will compile to what you would expect: &lt;code&gt;React.createElement(MyComponent, {}, 42)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.createElement(MyComponent, {}, 42)&lt;/code&gt; 예상대로 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="083c10e6c6edff28e6273ebb5cfbc6a9d5dd4768" translate="yes" xml:space="preserve">
          <source>It would be hard to create a type for this because we&amp;rsquo;re creating a new object based on another object.</source>
          <target state="translated">다른 객체를 기반으로 새 객체를 작성하기 때문에 유형을 작성하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="87f8da49eb8c969a18ca82d9274232c071921f87" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for JavaScript code to introduce &amp;ldquo;optional&amp;rdquo; values so that you have the option of leaving out the value or passing &lt;code&gt;null&lt;/code&gt; instead.</source>
          <target state="translated">JavaScript 코드는 일반적으로 &quot;선택적&quot;값을 도입하여 값을 생략하거나 &lt;code&gt;null&lt;/code&gt; 을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d032ed6e922fe662f519234b7d555a3d8f5ecb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s safe to use an object with &amp;ldquo;extra&amp;rdquo; properties in a position that is annotated with a specific set of properties.</source>
          <target state="translated">특정 속성 집합으로 주석이 달린 위치에 &quot;추가&quot;속성이있는 개체를 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="64245667942d0f59a4c76fbe92eaa77e04d0970f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s valid to use an &lt;code&gt;Employee&lt;/code&gt; instance where a &lt;code&gt;Person&lt;/code&gt; instance is expected.</source>
          <target state="translated">&lt;code&gt;Person&lt;/code&gt; 인스턴스가 예상 되는 &lt;code&gt;Employee&lt;/code&gt; 인스턴스 를 사용하는 것이 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="62185bdbfa583ea0a944a6564348a7230248cc32" translate="yes" xml:space="preserve">
          <source>JSX intrinsics like &lt;code&gt;div&lt;/code&gt; will give you their DOM instance. For &lt;code&gt;React.ElementRef&amp;lt;'div'&amp;gt;&lt;/code&gt; that would be &lt;code&gt;HTMLDivElement&lt;/code&gt;. For &lt;code&gt;React.ElementRef&amp;lt;'input'&amp;gt;&lt;/code&gt; that would be &lt;code&gt;HTMLInputElement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; 와 같은 JSX 내장 함수 는 DOM 인스턴스를 제공합니다. 들어 &lt;code&gt;React.ElementRef&amp;lt;'div'&amp;gt;&lt;/code&gt; 그 것이다 &lt;code&gt;HTMLDivElement&lt;/code&gt; 와를 . 들어 &lt;code&gt;React.ElementRef&amp;lt;'input'&amp;gt;&lt;/code&gt; 그 것이다 &lt;code&gt;HTMLInputElement&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="314a8a9290ad5ef0b2052cf134783f7c4c08b7c9" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;classes&lt;/a&gt; in Flow operate both as a value and a type.</source>
          <target state="translated">Flow의 JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;클래스&lt;/a&gt; 는 값과 유형 모두로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ff96432cd6c0749abc586d23ed4761948a7d9261" translate="yes" xml:space="preserve">
          <source>JavaScript also supports having rest parameters or parameters that collect an array of arguments at the end of a list of parameters. These have an ellipsis &lt;code&gt;...&lt;/code&gt; before them.</source>
          <target state="translated">JavaScript는 매개 변수 목록 끝에 인수 배열을 수집하는 나머지 매개 변수 또는 매개 변수를 지원합니다. 이것들은 앞에 줄임표가 있습니다 &lt;code&gt;...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33492c4de9d1778195557bc2a689c8efa4fb169f" translate="yes" xml:space="preserve">
          <source>JavaScript bugs can have significant impact at Facebook. Developers want to find and fix as many bugs as they can by the time their code rolls out into production. So we must care about soundness. At the same time, we must also care about not reporting too many spurious errors, because a low signal/noise ratio implies a low fix rate.</source>
          <target state="translated">JavaScript 버그는 Facebook에 큰 영향을 줄 수 있습니다. 개발자는 코드가 프로덕션에 출시 될 때까지 가능한 한 많은 버그를 찾아 수정하려고합니다. 따라서 우리는 건전성에 관심을 가져야합니다. 동시에 신호 / 노이즈 비율이 낮 으면 고정 률이 낮기 때문에 너무 많은 스퓨리어스 오류를보고하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d19af2dce65e63655c2e776d25a142cbd6199eba" translate="yes" xml:space="preserve">
          <source>JavaScript can also implicitly convert other types of values into booleans.</source>
          <target state="translated">JavaScript는 다른 유형의 값을 내재적으로 부울로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="485f1f2852599072f08415fb5cfd6b061d9a0dd4" translate="yes" xml:space="preserve">
          <source>JavaScript has a &lt;code&gt;typeof&lt;/code&gt; operator which returns a string describing a value.</source>
          <target state="translated">JavaScript에는 값을 설명하는 문자열을 반환 하는 &lt;code&gt;typeof&lt;/code&gt; 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eecc786af80843327406bcc95d93039f0b604da8" translate="yes" xml:space="preserve">
          <source>JavaScript has a number of different primitive types (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&quot;&gt;MDN&lt;/a&gt;):</source>
          <target state="translated">JavaScript에는 여러 가지 다른 기본 유형 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures&quot;&gt;MDN&lt;/a&gt; )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0fe7a86fd9b14d2fbe082506c653d7a9eeb404" translate="yes" xml:space="preserve">
          <source>JavaScript has both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;. Flow treats these as separate types: &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; (for &lt;code&gt;undefined&lt;/code&gt;).</source>
          <target state="translated">JavaScript에는 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;undefined&lt;/code&gt; 가 모두 있습니다. Flow는 이러한 유형을 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;void&lt;/code&gt; ( &lt;code&gt;undefined&lt;/code&gt; )의 개별 유형으로 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="40359189cd32fdb5d25cf14079d2c89de3d26e61" translate="yes" xml:space="preserve">
          <source>JavaScript has three ways of declaring local variables:</source>
          <target state="translated">JavaScript에는 지역 변수를 선언하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="377373e4c9e318e17a21d159b16d98d2f2d7a8f4" translate="yes" xml:space="preserve">
          <source>JavaScript implicitly converts other types of values into strings by concatenating them.</source>
          <target state="translated">JavaScript는 다른 유형의 값을 문자열로 연결하여 암시 적으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="db1d2f70ca60dcb812c319504dfac9c408dad07e" translate="yes" xml:space="preserve">
          <source>JavaScript: The Good and the Bad</source>
          <target state="translated">자바 스크립트 : 선과 악</target>
        </trans-unit>
        <trans-unit id="1baa7d034b3c654fd892b56488a2e2906ca22f77" translate="yes" xml:space="preserve">
          <source>Just don&amp;rsquo;t forget to replace the declarations with proper implementations.</source>
          <target state="translated">선언을 적절한 구현으로 바꾸는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="03cc07a06695efabc9bb1deed8b72855cef54594" translate="yes" xml:space="preserve">
          <source>Just like in functions, class methods can have annotations for both parameters (input) and returns (output).</source>
          <target state="translated">함수와 마찬가지로 클래스 메서드는 매개 변수 (입력)와 반환 (출력) 모두에 대한 주석을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0796f6608e21ddf9f9cee05b46aec16a2404747" translate="yes" xml:space="preserve">
          <source>Just like other type imports, this code will be stripped away by a compiler and will not add a dependency on the other module.</source>
          <target state="translated">다른 유형의 가져 오기와 마찬가지로이 코드는 컴파일러에 의해 제거되며 다른 모듈에 대한 종속성을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cfd51b40ca6ae71ea4ad94dee1f137fd72e5baa" translate="yes" xml:space="preserve">
          <source>Just note that &lt;code&gt;?Type[]&lt;/code&gt; is the equivalent of &lt;code&gt;?Array&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">것을 그냥 참고 &lt;code&gt;?Type[]&lt;/code&gt; 것과 같습니다 &lt;code&gt;?Array&amp;lt;T&amp;gt;&lt;/code&gt; 가 아닌 &lt;code&gt;Array&amp;lt;?T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4434db270fc0025e6dbf7944b0a7129f670d0468" translate="yes" xml:space="preserve">
          <source>LanguageClient-neovim</source>
          <target state="translated">LanguageClient-neovim</target>
        </trans-unit>
        <trans-unit id="95281a82e78ce2087d1012bf40625523f8488a7d" translate="yes" xml:space="preserve">
          <source>Languages like C++, Java, and Swift have primarily nominal type systems.</source>
          <target state="translated">C ++, Java 및 Swift와 같은 언어에는 주로 공칭 유형 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c792712a7965712fd189272a6613d98437d6180b" translate="yes" xml:space="preserve">
          <source>Languages like OCaml, Haskell, and Elm have primarily structural type systems.</source>
          <target state="translated">OCaml, Haskell 및 Elm과 같은 언어에는 주로 구조적 유형 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a1053bb6874133e95b37afbe211c7a892a815e" translate="yes" xml:space="preserve">
          <source>Lazy Modes</source>
          <target state="translated">게으른 모드</target>
        </trans-unit>
        <trans-unit id="dfdfa63658de426609e22c38f88280bb9b75116d" translate="yes" xml:space="preserve">
          <source>Lazy mode tries to classify your code into four categories.</source>
          <target state="translated">지연 모드는 코드를 네 가지 범주로 분류하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3dbc910e4fff9344f64869a8a5fc5c3d4355ac06" translate="yes" xml:space="preserve">
          <source>Lazy mode will still find all the JavaScript files and parse them. But it won&amp;rsquo;t typecheck the unchecked files.</source>
          <target state="translated">지연 모드는 여전히 모든 JavaScript 파일을 찾아서 구문 분석합니다. 그러나 확인되지 않은 파일은 유형 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad97b5eba3e92f8085f952420bce8e282a6f3f53" translate="yes" xml:space="preserve">
          <source>Learn how the type system in Flow works: Subtyping, Variance, Refinements, and more.</source>
          <target state="translated">하위 유형 지정, 변형, 구체화 등 Flow의 유형 시스템 작동 방식에 대해 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="17c6582762d51b971201160cc102c9a657f98c40" translate="yes" xml:space="preserve">
          <source>Learn how to add Flow type annotations to your code: Primitives, Objects, Functions, Classes, and more.</source>
          <target state="translated">프리미티브, 객체, 함수, 클래스 등 플로우 유형 주석을 코드에 추가하는 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="9061150cf645a8a07d4e182bd88b83043c6adeca" translate="yes" xml:space="preserve">
          <source>Learn how to configure Flow's linter to find potentially harmful code.</source>
          <target state="translated">잠재적으로 유해한 코드를 찾기 위해 Flow의 린터를 구성하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="ec546a6d98494e29fb29baba819e9036753ffc1c" translate="yes" xml:space="preserve">
          <source>Learn how to create and use library definitions for the third-party code your code depends on.</source>
          <target state="translated">코드가 의존하는 타사 코드에 대한 라이브러리 정의를 작성하고 사용하는 방법에 대해 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="81f0dff59c9c62d6cf866bb76b77e359a044ee03" translate="yes" xml:space="preserve">
          <source>Learn how to enable stricter type checking on a file-by-file basis.</source>
          <target state="translated">파일 단위로보다 엄격한 유형 검사를 활성화하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="6b22d7b7814e7097977052e60714138c723c00f5" translate="yes" xml:space="preserve">
          <source>Learn how to use Flow to effectively type common and advanced React patterns.</source>
          <target state="translated">Flow를 사용하여 일반 및 고급 React 패턴을 효과적으로 입력하는 방법에 대해 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="2b9e35721f161da639af3e629c43a749a10c8d13" translate="yes" xml:space="preserve">
          <source>Learn how to write types in .flow files.</source>
          <target state="translated">.flow 파일에서 유형을 작성하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="89668dad1cc2803bc9a05873362cf34088114329" translate="yes" xml:space="preserve">
          <source>Less specific inputs &amp;mdash; Good</source>
          <target state="translated">덜 구체적인 입력 &amp;mdash; 양호</target>
        </trans-unit>
        <trans-unit id="923403997632248e58e2bb70246889bdff43c52c" translate="yes" xml:space="preserve">
          <source>Less specific outputs &amp;mdash; Bad</source>
          <target state="translated">덜 구체적인 출력 &amp;mdash; 불량</target>
        </trans-unit>
        <trans-unit id="56b22fadb66ce39178decbc7081dadaa222b6580" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a couple of more advanced examples:</source>
          <target state="translated">몇 가지 고급 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4d2a79c6b93594188cbf9b55c1481295a10f9571" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a more general, and sometimes more convenient way to declare types for modules: &lt;code&gt;.flow&lt;/code&gt; files.</source>
          <target state="translated">모듈의 유형을 선언하는보다 일반적이고 편리한 방법 인 &lt;code&gt;.flow&lt;/code&gt; 파일을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e86757a83ce64508253852d9564cd9fe0caffc8b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite our function to handle each type individually.</source>
          <target state="translated">각 유형을 개별적으로 처리하는 함수를 다시 작성하겠습니다.</target>
        </trans-unit>
        <trans-unit id="9f80216838aa529f22c630c26f5b236d726d206d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a function type and a few functions. Which of the functions can be used safely in code that expects the given function type?</source>
          <target state="translated">함수 유형과 몇 가지 함수가 있다고 가정 해 봅시다. 주어진 함수 유형을 예상하는 코드에서 안전하게 사용할 수있는 함수는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="19a72503865e9c4d4dbb4e6b8d83e9c6bb555f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see a couple of examples:</source>
          <target state="translated">몇 가지 예를 보자.</target>
        </trans-unit>
        <trans-unit id="3f378a2d680120a037a23d1a877c71075aaafcf4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see an example. Suppose you have a function called &lt;code&gt;run&lt;/code&gt; that takes an object of thunks (functions in the form &lt;code&gt;() =&amp;gt; A&lt;/code&gt;) as input:</source>
          <target state="translated">예를 보자. 썽크의 오브젝트 (형식 &lt;code&gt;() =&amp;gt; A&lt;/code&gt; 형식의 함수 )를 입력으로 사용 하는 &lt;code&gt;run&lt;/code&gt; 이라는 함수가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="32b252980a12fe72e87f2a649ca85e8a29abefd4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the simplest HOC:</source>
          <target state="translated">가장 간단한 HOC부터 시작하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="ffff4663a687b3c96978f5c3f0d326215fa1908f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at how you can type some example HOCs.</source>
          <target state="translated">HOC의 예를 어떻게 입력 할 수 있는지 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="f9b942f0b29382ee9e16a650bf2bb4ee6a83a2ac" translate="yes" xml:space="preserve">
          <source>Library Definitions</source>
          <target state="translated">라이브러리 정의</target>
        </trans-unit>
        <trans-unit id="de6d8b01f166fb75ee7809437032a5304f395753" translate="yes" xml:space="preserve">
          <source>Library definitions are considered strict (as they can be included in many different projects with contradicting strict configurations).</source>
          <target state="translated">라이브러리 정의는 엄격한 구성으로 모순되는 다양한 프로젝트에 포함될 수 있으므로 엄격한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="1f94a87973cd7d8f6f84a5de26376923c65809ef" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-implicit-inexact-object&quot;&gt;&lt;code&gt;implicit-inexact-object&lt;/code&gt;&lt;/a&gt;, except triggers even when the &lt;code&gt;exact_by_default&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#toc-implicit-inexact-object&quot;&gt; &lt;code&gt;implicit-inexact-object&lt;/code&gt; &lt;/a&gt; , 트리거를 제외한 경우에도 &lt;code&gt;exact_by_default&lt;/code&gt; 의 옵션이 설정되어 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99631d72797c2b4f916d1968332cece8d677359f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.ElementProps&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;typeof Component&lt;/code&gt; 유형이어야 &lt;em&gt;의&lt;/em&gt; 당신이 사용할 필요가 있도록 구성 요소 반작용 &lt;code&gt;typeof&lt;/code&gt; 같이 &lt;code&gt;React.ElementProps&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afdeb072663138fc0c7eb121d5d1c44b8ac851c2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.ElementRef&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;typeof Component&lt;/code&gt; 유형이어야 &lt;em&gt;의&lt;/em&gt; 당신이 사용할 필요가 있도록 구성 요소 반작용 &lt;code&gt;typeof&lt;/code&gt; 같이 &lt;code&gt;React.ElementRef&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bfdd355019fb00dad0f94f122a17cd4e371ba06" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;typeof Component&lt;/code&gt; must be the type &lt;em&gt;of&lt;/em&gt; a React component so you need to use &lt;code&gt;typeof&lt;/code&gt; as in &lt;code&gt;React.Ref&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;typeof Component&lt;/code&gt; 유형이어야 &lt;em&gt;의&lt;/em&gt; 당신이 사용할 필요가 있도록 구성 요소 반작용 &lt;code&gt;typeof&lt;/code&gt; 같이 &lt;code&gt;React.Ref&amp;lt;typeof MyComponent&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbecb30c8c5786dd14c47738d4071ca6c0260abd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;React.ElementProps&amp;lt;typeof Component&amp;gt;&lt;/code&gt; this utility gets the type of a component&amp;rsquo;s props but &lt;em&gt;preserves&lt;/em&gt; the optionality of &lt;code&gt;defaultProps&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;React.ElementProps&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 와 마찬가지로이 유틸리티는 컴포넌트의 props 타입을 가져 오지만 &lt;code&gt;defaultProps&lt;/code&gt; 의 옵션은 &lt;em&gt;유지&lt;/em&gt; 합니다 !</target>
        </trans-unit>
        <trans-unit id="d041aadefbd6307d2b548663eef27b76cecb7788" translate="yes" xml:space="preserve">
          <source>Like precision, speed also has other significant effects. When bugs are reported as the developer makes changes to code, they become part of the editing process&amp;mdash;the developer doesn&amp;rsquo;t need to run the code to detect bugs, and tracing bugs back to the code becomes simpler. Similarly, when the IDE can show the type of an expression, the definition reaching a reference, etc. as the developer is coding, we have observed that productivity can improve dramatically.</source>
          <target state="translated">정밀도와 마찬가지로 속도도 다른 중요한 영향을 미칩니다. 개발자가 코드를 변경할 때 버그가보고되면 버그는 편집 프로세스의 일부가됩니다. 개발자는 버그를 감지하기 위해 코드를 실행할 필요가 없으며 코드에 대한 버그 추적이 더 간단 해집니다. 마찬가지로, 개발자가 코딩 할 때 IDE가 표현식의 유형, 참조에 도달하는 정의 등을 표시 할 수있는 경우 생산성이 크게 향상 될 수 있음을 관찰했습니다.</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">이처럼 :</target>
        </trans-unit>
        <trans-unit id="8f316525461e2a4c6c2b89d883cfb34c624544ab" translate="yes" xml:space="preserve">
          <source>Lint Rule Reference</source>
          <target state="translated">보풀이 규칙 참조</target>
        </trans-unit>
        <trans-unit id="d1bf3e3c86e73b07580c5c816b1b04837ea95e8f" translate="yes" xml:space="preserve">
          <source>Lint Settings Precedence</source>
          <target state="translated">보풀 설정 우선 순위</target>
        </trans-unit>
        <trans-unit id="4dbc74e7618b9b038882a1a26b628723a0e3e49a" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified in the &lt;code&gt;.flowconfig&lt;/code&gt; [lints] section as a list of &lt;code&gt;rule=severity&lt;/code&gt; pairs. These settings apply globally to the entire project.</source>
          <target state="translated">린트 설정은 &lt;code&gt;.flowconfig&lt;/code&gt; [lints] 섹션에서 &lt;code&gt;rule=severity&lt;/code&gt; 쌍 의 목록 으로 지정할 수 있습니다 . 이 설정은 전체 프로젝트에 전체적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e24c1254981afd7ee28d2270b93ccfb59eae399a" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified inside a file using &lt;code&gt;flowlint&lt;/code&gt; comments. These settings apply to a region of a file, or a single line, or part of a line. For more details see &lt;a href=&quot;flowlint-comments&quot;&gt;Flowlint Comments&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;flowlint&lt;/code&gt; 설정은 flowlint 주석을 사용하여 파일 내에서 지정할 수 있습니다 . 이러한 설정은 파일 영역, 한 줄 또는 줄의 일부에 적용됩니다. 자세한 내용은 &lt;a href=&quot;flowlint-comments&quot;&gt;Flowlint 설명을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5d62735922d047192446d6cc3f42ad67aea4c2d" translate="yes" xml:space="preserve">
          <source>Lint settings can be specified using the &lt;code&gt;--lints&lt;/code&gt; flag of a Flow server command as a comma-delimited list of &lt;code&gt;rule=severity&lt;/code&gt; pairs. These settings apply globally to the entire project.</source>
          <target state="translated">린트 설정은 플로우 서버 명령 의 &lt;code&gt;--lints&lt;/code&gt; 플래그를 쉼표로 구분 된 &lt;code&gt;rule=severity&lt;/code&gt; 쌍으로 사용하여 지정할 수 있습니다 . 이 설정은 전체 프로젝트에 전체적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="24b2695bce6ad369789c8095fc314893c4855226" translate="yes" xml:space="preserve">
          <source>Lint settings in &lt;code&gt;flowlint&lt;/code&gt; comments have the highest priority, followed by lint rules in the &lt;code&gt;--lints&lt;/code&gt; flag, followed by the &lt;code&gt;.flowconfig&lt;/code&gt;. This order allows you to use &lt;code&gt;flowlint&lt;/code&gt; comments for fine-grained linting control, the &lt;code&gt;--lints&lt;/code&gt; flag for trying out new lint settings, and the &lt;code&gt;.flowconfig&lt;/code&gt; for stable project-wide settings.</source>
          <target state="translated">&lt;code&gt;flowlint&lt;/code&gt; 주석의 보푸라기 설정은 우선 순위가 가장 높으며 &lt;code&gt;--lints&lt;/code&gt; 플래그의 보푸라기 규칙과 .flowconfig가 차례로 나타 &lt;code&gt;.flowconfig&lt;/code&gt; . 이 순서를 사용하면 미세 보푸라기 제어 를 위해 &lt;code&gt;flowlint&lt;/code&gt; 주석, 새 보푸라기 설정을 시도하기위한 &lt;code&gt;--lints&lt;/code&gt; 플래그 및 안정적인 프로젝트 전체 설정을위한 &lt;code&gt;.flowconfig&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5dc277b08ab0a076088a55936d6bb1b36b56986" translate="yes" xml:space="preserve">
          <source>Linter-Flow</source>
          <target state="translated">Linter-Flow</target>
        </trans-unit>
        <trans-unit id="8740f6b1646315b108f5a7b7630739c109bdee42" translate="yes" xml:space="preserve">
          <source>Linting</source>
          <target state="translated">Linting</target>
        </trans-unit>
        <trans-unit id="0dad7bd175f8f98714812632da5a78ae6486cb98" translate="yes" xml:space="preserve">
          <source>Linting Overview</source>
          <target state="translated">린팅 개요</target>
        </trans-unit>
        <trans-unit id="013e2bb1e1c48cce810f0e9392c090ca8d741740" translate="yes" xml:space="preserve">
          <source>List the lint rules to enable . These are strongly recommended:</source>
          <target state="translated">활성화 할 보푸라기 규칙을 나열합니다. 다음을 적극 권장합니다.</target>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="translated">리터럴 타입</target>
        </trans-unit>
        <trans-unit id="fd4663b897abbd9f63aa1fb029df28511b239e0f" translate="yes" xml:space="preserve">
          <source>Look up types under cursor</source>
          <target state="translated">커서 아래에서 유형 조회</target>
        </trans-unit>
        <trans-unit id="e8ed77b7f356c09433025e5f0c172332bccb8b7b" translate="yes" xml:space="preserve">
          <source>Makes Flow treat &lt;code&gt;require('foo.css')&lt;/code&gt; as if it were &lt;code&gt;require(PROJECT_ROOT + '/CSSFlowStub')&lt;/code&gt;.</source>
          <target state="translated">Flow가 &lt;code&gt;require('foo.css')&lt;/code&gt; 를 &lt;code&gt;require(PROJECT_ROOT + '/CSSFlowStub')&lt;/code&gt; 처럼 처리 하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="883a53b7e28c18b0803206061049c59ce3306d06" translate="yes" xml:space="preserve">
          <source>Maybe Types</source>
          <target state="translated">아마도 유형</target>
        </trans-unit>
        <trans-unit id="78d444312215f80221ea8f50dcd6255ebd40e280" translate="yes" xml:space="preserve">
          <source>Maybe types</source>
          <target state="translated">아마도 유형</target>
        </trans-unit>
        <trans-unit id="eeab6b1b5730d5897be20e8832d631c14302d02b" translate="yes" xml:space="preserve">
          <source>Maybe types accept the provided type as well as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. So &lt;code&gt;?number&lt;/code&gt; would mean &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">유형은 제공된 유형뿐만 아니라 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 허용 합니다. 따라서 &lt;code&gt;?number&lt;/code&gt; 는 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="a099b97988d9786a09585297079102b85e29a055" translate="yes" xml:space="preserve">
          <source>Maybe types are for places where a value is optional and you can create them by adding a question mark in front of the type such as &lt;code&gt;?string&lt;/code&gt; or &lt;code&gt;?number&lt;/code&gt;.</source>
          <target state="translated">유형은 값이 선택적인 위치에 대한 것일 수 있으며 &lt;code&gt;?string&lt;/code&gt; 또는 &lt;code&gt;?number&lt;/code&gt; 와 같은 유형 앞에 물음표를 추가하여 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dc501bb2c0dd681d66351ee6c10f4bea3fa6bb6" translate="yes" xml:space="preserve">
          <source>Mixed Types</source>
          <target state="translated">혼합 유형</target>
        </trans-unit>
        <trans-unit id="38694f679fee1c9873abb6f0b39d8682bb35437c" translate="yes" xml:space="preserve">
          <source>Mixing nominal and structural typing</source>
          <target state="translated">공칭 및 구조적 타이핑 혼합</target>
        </trans-unit>
        <trans-unit id="a152ec7cc4a239412b5ec07e59dc705597177c82" translate="yes" xml:space="preserve">
          <source>Module Types</source>
          <target state="translated">모듈 유형</target>
        </trans-unit>
        <trans-unit id="b2b4f329c4371fad34d57ca2c5ac16707d12ff70" translate="yes" xml:space="preserve">
          <source>More complex types like object or classes have more complex structures. They each get their own name even if they sometimes have the same structure overall.</source>
          <target state="translated">객체 또는 클래스와 같은 더 복잡한 유형에는 더 복잡한 구조가 있습니다. 그들은 때때로 전체적으로 같은 구조를 가지고 있더라도 각자의 이름을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="778013c00f70ed72cb3d9f3f32da1db73e971c69" translate="yes" xml:space="preserve">
          <source>More specific inputs &amp;mdash; Bad</source>
          <target state="translated">보다 구체적인 입력 &amp;mdash; 나쁜</target>
        </trans-unit>
        <trans-unit id="5ce86c0f6222882e371b81384532e8ef38f27254" translate="yes" xml:space="preserve">
          <source>More specific outputs &amp;mdash; Good</source>
          <target state="translated">보다 구체적인 출력 &amp;mdash; 양호</target>
        </trans-unit>
        <trans-unit id="d01518022ba66aff4ed5b2b63c6552251faa6c8d" translate="yes" xml:space="preserve">
          <source>Most editors will likely display all Flow warnings, which is fine for small- to medium-scale projects, or projects with fewer unsuppressed warnings.</source>
          <target state="translated">대부분의 편집자는 중소 규모 프로젝트 또는 억제되지 않은 경고가 적은 프로젝트에 적합한 모든 흐름 경고를 표시 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b059f68400dbd84675bceaefa0fc9dee97bfc09" translate="yes" xml:space="preserve">
          <source>Most of the work that Flow does is comparing types against one another.</source>
          <target state="translated">Flow가하는 대부분의 작업은 유형을 서로 비교하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="865bd2fa28dfb2500c9d6ee7c2537c59e6ebb20a" translate="yes" xml:space="preserve">
          <source>Most people put the &lt;code&gt;.flowconfig&lt;/code&gt; in the root of their project (i.e. next to the &lt;code&gt;package.json&lt;/code&gt;). Some people put all their code in a &lt;code&gt;src/&lt;/code&gt; directory and therefore put the &lt;code&gt;.flowconfig&lt;/code&gt; at &lt;code&gt;src/.flowconfig&lt;/code&gt;.</source>
          <target state="translated">대부분의 사람들은 &lt;code&gt;.flowconfig&lt;/code&gt; 를 프로젝트의 루트 (예 : &lt;code&gt;package.json&lt;/code&gt; 옆)에 둡니다 . 어떤 사람들은 모든 코드를 &lt;code&gt;src/&lt;/code&gt; 디렉토리에 넣고 &lt;code&gt;.flowconfig&lt;/code&gt; 를 &lt;code&gt;src/.flowconfig&lt;/code&gt; 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="24fb36600e4f5f9c4147c6aae34b2eb550d7c78f" translate="yes" xml:space="preserve">
          <source>Most real JavaScript programs depend on third-party code and not just code immediately under the control of the project. That means a project using Flow may need to reference outside code that either doesn&amp;rsquo;t have type information or doesn&amp;rsquo;t have accurate and/or precise type information. In order to handle this, Flow supports the concept of a &amp;ldquo;library definition&amp;rdquo; (AKA &amp;ldquo;libdef&amp;rdquo;).</source>
          <target state="translated">대부분의 실제 JavaScript 프로그램은 프로젝트가 직접 제어하는 ​​코드 만이 아니라 타사 코드에 의존합니다. 즉, Flow를 사용하는 프로젝트는 형식 정보가 없거나 정확하거나 정확한 형식 정보가없는 외부 코드를 참조해야 할 수도 있습니다. 이를 처리하기 위해 Flow는 &quot;라이브러리 정의&quot;(일명 &quot;libdef&quot;)의 개념을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3e58f860a0fe4e5d6b003e3170a2f45595516a83" translate="yes" xml:space="preserve">
          <source>Moving on to the next case. What happens if we have a single child, but that child is an array?</source>
          <target state="translated">다음 사건으로 넘어갑니다. 자녀가 하나이지만 그 자녀가 배열 인 경우 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="0eaa6c704d21cdabb114c1eed0d1b20d3c99200e" translate="yes" xml:space="preserve">
          <source>Multiple children may also look like:</source>
          <target state="translated">여러 자녀가 ​​다음과 같이 보일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df45cc95bf1aa33f0579b3915c74bbc29792fe71" translate="yes" xml:space="preserve">
          <source>NOTE: Because a given module cannot be both an ES module and a CommonJS module, it is an error to mix &lt;code&gt;declare export [...]&lt;/code&gt; with &lt;code&gt;declare module.exports: ...&lt;/code&gt; in the same &lt;code&gt;declare module&lt;/code&gt; body.</source>
          <target state="translated">참고 : 주어진 모듈이 ES 모듈과 CommonJS 모듈이 될 수 없으므로 동일한 &lt;code&gt;declare module&lt;/code&gt; 본문 에서 &lt;code&gt;declare export [...]&lt;/code&gt; 와 &lt;code&gt;declare module.exports: ...&lt;/code&gt; 를 혼합하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="8fc9d5db4bce8ff6003105d5b34b50810aab147d" translate="yes" xml:space="preserve">
          <source>NOTE: For new code prefer &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt;. &lt;code&gt;Function&lt;/code&gt; has become an alias to &lt;code&gt;any&lt;/code&gt; and will be deprecated and removed in a future version of Flow.</source>
          <target state="translated">참고 : 새 코드의 &lt;code&gt;any&lt;/code&gt; 또는 &lt;code&gt;(...args: Array&amp;lt;any&amp;gt;) =&amp;gt; any&lt;/code&gt; 선호 하십시오 . &lt;code&gt;Function&lt;/code&gt; 는 &lt;code&gt;any&lt;/code&gt; 별칭이되었으며 향후 버전의 Flow에서는 더 이상 사용되지 않으며 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="a4fc17a7e6e5fe579f60ff1988706b047d7ddb6f" translate="yes" xml:space="preserve">
          <source>NOTE: For new code, prefer &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;{[key:string]:any}&lt;/code&gt;. &lt;code&gt;Object&lt;/code&gt; is an alias to &lt;a href=&quot;../any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; and will be deprecated and removed in a future version of Flow.</source>
          <target state="translated">참고 : 새 코드의 경우 &lt;code&gt;any&lt;/code&gt; 또는 &lt;code&gt;{[key:string]:any}&lt;/code&gt; 를 선호 하십시오 . &lt;code&gt;Object&lt;/code&gt; 는 &lt;a href=&quot;../any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 개체 의 별칭 이며 향후 버전의 Flow에서는 더 이상 사용되지 않으며 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9bcc1eb8d16a0354aa6793057eb9ea662ddca8a2" translate="yes" xml:space="preserve">
          <source>NOTE: The syntax for declarations in a declaration file is the same as we&amp;rsquo;ve seen in &lt;a href=&quot;https://flow.org/en/libdefs/creation&quot;&gt;Creating Library Definitions section&lt;/a&gt;.</source>
          <target state="translated">참고 : 선언 파일의 선언 구문은 &lt;a href=&quot;https://flow.org/en/libdefs/creation&quot;&gt;라이브러리 정의 만들기 섹션&lt;/a&gt; 에서 본 것과 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="eee4834f57293f261d87c33868be5aa7425351c9" translate="yes" xml:space="preserve">
          <source>NOTE: Using the &lt;code&gt;/flow-typed&lt;/code&gt; directory for libdefs is a convention that enables Flow to JustWork&amp;trade; out of the box and encourages consistency across projects that use Flow, but it is also possible to explicitly configure Flow to look elsewhere for libdefs using the &lt;a href=&quot;https://flow.org/en/config/libs&quot;&gt;&lt;code&gt;[libs]&lt;/code&gt; section of your &lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : libdefs에 &lt;code&gt;/flow-typed&lt;/code&gt; 디렉토리를 사용하는 것은 Flow to JustWork &amp;trade;를 즉시 사용 가능하게하고 Flow를 사용하는 프로젝트간에 일관성을 권장하는 규칙이지만, &lt;a href=&quot;https://flow.org/en/config/libs&quot;&gt; &lt;code&gt;[libs]&lt;/code&gt; &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt; 사용하여 다른 위치에서 libdef를 찾도록 Flow를 명시 적으로 구성 할 수도 있습니다 . .flowconfig 의 libs] 섹션 .</target>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="translated">명명 된 수출</target>
        </trans-unit>
        <trans-unit id="e2dffcc7cffb0debfc5f8d1550386d2bb5e3bffe" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;@flow&lt;/code&gt; nor &lt;code&gt;@noflow&lt;/code&gt; - Parse this file with Flow syntax disallowed and do not typecheck it.</source>
          <target state="translated">&lt;code&gt;@flow&lt;/code&gt; 또는 &lt;code&gt;@noflow&lt;/code&gt; 둘 다 아님-Flow 구문을 허용 하지 않고이 파일을 구문 분석하고 형식을 확인하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9ed4452c065a3327032cb7f9b68de94c78e6bf1c" translate="yes" xml:space="preserve">
          <source>Neither will this:</source>
          <target state="translated">이것도 마찬가지입니다 :</target>
        </trans-unit>
        <trans-unit id="17e8fc5ffc9a8aadcb69cdfea49a7be7e3e01369" translate="yes" xml:space="preserve">
          <source>NeoBundle</source>
          <target state="translated">NeoBundle</target>
        </trans-unit>
        <trans-unit id="cb0c7f1b829e145b81d56e667505ff6ca3313917" translate="yes" xml:space="preserve">
          <source>Never used a type system before or just new to Flow? Let's get you up and running in a few minutes.</source>
          <target state="translated">Flow 이전에 새로운 타입 시스템을 사용하지 않았습니까? 몇 분 안에 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="4fa6d9c66b7b5cb1445a7a7985bc5a4c02e4f274" translate="yes" xml:space="preserve">
          <source>Newer versions of the JavaScript standard include a &lt;code&gt;Map&lt;/code&gt; class, but it is still very common to use objects as maps as well. In this use case, an object will likely have properties added to it and retrieved throughout its lifecycle. Furthermore, the property keys may not even be known statically, so writing out a type annotation would not be possible.</source>
          <target state="translated">최신 버전의 JavaScript 표준에는 &lt;code&gt;Map&lt;/code&gt; 클래스가 포함되어 있지만 객체를 맵으로 사용하는 것이 여전히 일반적입니다. 이 사용 사례에서는 객체에 속성이 추가되고 수명주기 동안 검색 될 수 있습니다. 또한 속성 키를 정적으로 알 수도 없으므로 형식 주석을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="994a4af6c767d6bce3da94575735bc38736de599" translate="yes" xml:space="preserve">
          <source>Newlines and indentation after newlines are stripped, but watch out for whitespace when using a component with strict types around what children may be.</source>
          <target state="translated">줄 바꿈 후 줄 바꿈 및 들여 쓰기는 제거되지만 어린이가 될 수있는 주위에 엄격한 유형의 구성 요소를 사용할 때 공백을주의하십시오.</target>
        </trans-unit>
        <trans-unit id="c8b440e127a10dc6c8416450eb227c5047c30c36" translate="yes" xml:space="preserve">
          <source>Next we&amp;rsquo;ll add an else block to our if statement.</source>
          <target state="translated">다음으로 if 문에 else 블록을 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b08049f81dbbff0f0b72d5c90f11c3c94dbe857a" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have a different &lt;code&gt;SubClass&lt;/code&gt; that returns a less specific type:</source>
          <target state="translated">다음 으로 덜 구체적인 유형을 반환하는 다른 &lt;code&gt;SubClass&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e898df75dae72ea5a3d9d46d76532d7a85a2015f" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have a different &lt;code&gt;SubClass&lt;/code&gt; that returns a more specific type:</source>
          <target state="translated">다음 으로보다 구체적인 유형을 반환하는 다른 &lt;code&gt;SubClass&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7fad484146f11e6827ddde38d9848a5842febd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll have another SubClass that accepts a value of a less specific type.</source>
          <target state="translated">다음으로, 덜 구체적인 유형의 값을 허용하는 또 다른 하위 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="03fcc5e78375c539a4046df66cd614afc3b96f5d" translate="yes" xml:space="preserve">
          <source>Nominal &amp;amp; Structural Typing</source>
          <target state="translated">공칭 및 구조적 타이핑</target>
        </trans-unit>
        <trans-unit id="e8d7ae8d2ca23e63934856a596b9968693856079" translate="yes" xml:space="preserve">
          <source>Nominal typing</source>
          <target state="translated">공칭 타이핑</target>
        </trans-unit>
        <trans-unit id="7b7e96032e3f1e6663bd1bdc30dc00a06098260e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; will error if the object you are removing properties from does not have the property being removed, i.e. if &lt;code&gt;B&lt;/code&gt; has a key that doesn&amp;rsquo;t exist in &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; 경우에서 속성을 제거 할 객체의 속성이 제거되는 즉이없는 경우 오류가 발생하지 &lt;code&gt;B&lt;/code&gt; 는 존재하지 않는 키가 &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3333e700ed17ae336d1331038ab7c3ede13160e7" translate="yes" xml:space="preserve">
          <source>Note that an array of type &lt;code&gt;$ReadOnlyArray&amp;lt;T&amp;gt;&lt;/code&gt; can still have mutable &lt;em&gt;elements&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;$ReadOnlyArray&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 배열에는 여전히 변경 가능한 &lt;em&gt;요소&lt;/em&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d8fdec593b4fbb6674593ce345b2fc98b244bc1" translate="yes" xml:space="preserve">
          <source>Note that if you annotate your generic with variance sigils then Flow will check to make sure those types only appear in positions that make sense for that variance sigil. For example, you cannot declare a generic type parameter to behave covariantly and use it in a contravariant position:</source>
          <target state="translated">일반에 분산시길로 주석을 달면 Flow는 해당 유형이 해당 분산시길에 적합한 위치에만 표시되는지 확인합니다. 예를 들어, 공변량으로 동작하도록 일반 유형 매개 변수를 선언하고이를 반역 위치에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1ee3faa3af2380d9898eaa494128a6edeb62a34" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;.flow&lt;/code&gt; extension applies both to &lt;code&gt;.js&lt;/code&gt; files as well as &lt;code&gt;.json&lt;/code&gt; ones. The corresponding declaration files have extensions &lt;code&gt;.js.flow&lt;/code&gt; and &lt;code&gt;.json.flow&lt;/code&gt;, respectively.</source>
          <target state="translated">참고 것을 &lt;code&gt;.flow&lt;/code&gt; 확장에 모두 적용 &lt;code&gt;.js&lt;/code&gt; 파일뿐만 아니라 &lt;code&gt;.json&lt;/code&gt; 것. 해당 선언 파일의 확장자 는 각각 &lt;code&gt;.js.flow&lt;/code&gt; 및 &lt;code&gt;.json.flow&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="815e2ec516671c1e95e246519c4812a2e63caff8" translate="yes" xml:space="preserve">
          <source>Note that this lint does not trigger when we know a condition is always &lt;code&gt;false&lt;/code&gt;. It is a common idiom to use &lt;code&gt;invariant()&lt;/code&gt; or &lt;code&gt;invariant(false, ...)&lt;/code&gt; to throw in code that should be unreachable.</source>
          <target state="translated">이 린트는 조건이 항상 &lt;code&gt;false&lt;/code&gt; 알 때 트리거되지 않습니다 . 도달 할 수없는 코드를 던지기 위해 &lt;code&gt;invariant()&lt;/code&gt; 또는 &lt;code&gt;invariant(false, ...)&lt;/code&gt; 를 사용하는 것이 일반적 관용구 입니다.</target>
        </trans-unit>
        <trans-unit id="97abdd3aca893857a9659b8d5dc58e61b924f0e2" translate="yes" xml:space="preserve">
          <source>Note that when you have a value with a bound generic type, you can&amp;rsquo;t use it as if it were a more specific type.</source>
          <target state="translated">바인딩 된 제네릭 형식의 값이 있으면보다 구체적인 형식 인 것처럼 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3fa26fe5509b9dafc96225032b57c997a328ed0e" translate="yes" xml:space="preserve">
          <source>Note that you can also declare other things inside the body of the &lt;code&gt;declare module&lt;/code&gt;, and those things will be scoped to the body of the &lt;code&gt;declare module&lt;/code&gt; &amp;ndash; &lt;strong&gt;but they will not be exported from the module&lt;/strong&gt;:</source>
          <target state="translated">당신은 또한 본체 내부에 다른 일을 선언 할 수 있습니다 &lt;code&gt;declare module&lt;/code&gt; , 그리고 그 일이의 몸에 범위됩니다 &lt;code&gt;declare module&lt;/code&gt; - &lt;strong&gt;하지만이 모듈에서 내 보내지 않습니다&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="54bffd8f0bade33130c198fcfbb3d3928227fba5" translate="yes" xml:space="preserve">
          <source>Note that you can also declare other things inside the body of the &lt;code&gt;declare module&lt;/code&gt;, and those things will be scoped to the body of the &lt;code&gt;declare module&lt;/code&gt;, &lt;strong&gt;but they will not be exported from the module&lt;/strong&gt;:</source>
          <target state="translated">또한 선언 &lt;code&gt;declare module&lt;/code&gt; 의 본문 안에 다른 것을 선언 할 수 있으며, 선언 모듈 의 본문으로 범위가 지정 &lt;strong&gt;되지만 &lt;/strong&gt; &lt;code&gt;declare module&lt;/code&gt; 에서 &lt;strong&gt;내보내지는 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c3611dae21abf03408abc2acf059be7215eea834" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;$ReadOnly&lt;/code&gt; is only for making read-only &lt;em&gt;object&lt;/em&gt; types. See the Array docs for how to &lt;a href=&quot;../arrays#toc-readonlyarray&quot;&gt;type read-only arrays with &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;$ReadOnly&lt;/code&gt; 는 읽기 전용 &lt;em&gt;개체&lt;/em&gt; 유형 을 만들기위한 것 입니다. &lt;a href=&quot;../arrays#toc-readonlyarray&quot;&gt; &lt;code&gt;$ReadOnlyArray&lt;/code&gt; &lt;/a&gt; 하여 읽기 전용 배열 을 입력 하는 방법은 배열 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6be40aaa6de71f620ef0689323825354900d1e8" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; equivalent to &lt;code&gt;T&lt;/code&gt; with all its fields marked as optional. In particular, Flow unsoundly allows &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; to be used as a &lt;code&gt;T&lt;/code&gt; in several contexts. For example in</source>
          <target state="translated">참고 : &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; 는 모든 필드가 선택 사항으로 표시된 &lt;code&gt;T&lt;/code&gt; 와 동일 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 특히, 흐름 unsoundly 수 있습니다 &lt;code&gt;$Shape&amp;lt;T&amp;gt;&lt;/code&gt; A와 사용되는 &lt;code&gt;T&lt;/code&gt; 여러 상황에서합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="910cb2c37e2ad8674f98e665bc56e5aeb4d5a554" translate="yes" xml:space="preserve">
          <source>Note: If you add a type annotation to a rest parameter, it must always explicitly be an &lt;code&gt;Array&lt;/code&gt; type.</source>
          <target state="translated">참고 : 나머지 매개 변수에 형식 주석을 추가하면 항상 명시 적으로 &lt;code&gt;Array&lt;/code&gt; 형식 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bc76abb2875c7659b6d7f4f248528d58f58a9924" translate="yes" xml:space="preserve">
          <source>Notice the types added to the parameter of the function along with a return type at the end of the function. You might be able to tell from looking at this code that there is an error in the return type since the function can also return an &lt;code&gt;int&lt;/code&gt;. However, you do not need to visually inspect the code since the Flow background process will be able to catch this error for you when you &lt;a href=&quot;#toc-check-your-code&quot;&gt;check your code&lt;/a&gt;.</source>
          <target state="translated">함수의 끝에 리턴 유형과 함께 함수 매개 변수에 추가 된 유형을 확인하십시오. 이 코드를 보면 함수가 &lt;code&gt;int&lt;/code&gt; 를 반환 할 수 있기 때문에 반환 유형에 오류가 있음을 알 수 있습니다 . 그러나 흐름 백그라운드 프로세스가 &lt;a href=&quot;#toc-check-your-code&quot;&gt;코드&lt;/a&gt; 를 확인할 때이 오류를 포착 할 수 있으므로 코드를 육안으로 검사 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c0d7a1a5c5c6adb2044345b94128cb7b17d10e58" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;flow&lt;/code&gt; will include a directory outside the &lt;code&gt;.flowconfig&lt;/code&gt; path in its check, ignore the &lt;code&gt;build&lt;/code&gt; directory and use the declarations in &lt;code&gt;lib&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;flow&lt;/code&gt; 는 검사에서 &lt;code&gt;.flowconfig&lt;/code&gt; 경로 외부의 디렉토리를 포함 하고 &lt;code&gt;build&lt;/code&gt; 디렉토리를 무시하고 &lt;code&gt;lib&lt;/code&gt; 의 선언을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a044c31320a1c390eff0c847424350f19070f44e" translate="yes" xml:space="preserve">
          <source>Now Flow will complain when you try to write to any of these properties.</source>
          <target state="translated">이제 이러한 속성 중 하나에 쓰려고 할 때 흐름이 불평합니다.</target>
        </trans-unit>
        <trans-unit id="7b7f5bac6c35b92b712c9bf97b054fa867c2ca01" translate="yes" xml:space="preserve">
          <source>Now if you try to use &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; with a string for &lt;code&gt;foo&lt;/code&gt; instead of a number you will get an error.</source>
          <target state="translated">이제 숫자 대신 &lt;code&gt;foo&lt;/code&gt; 의 문자열과 함께 &lt;code&gt;&amp;lt;MyComponent&amp;gt;&lt;/code&gt; 를 사용하려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b61c8302b29c6822902031839e12485c087afa1" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see an example of the first case documented above. Suppose we have the following code in a file &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt;:</source>
          <target state="translated">이제 위에서 설명한 첫 번째 사례의 예를 보도록하겠습니다. &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; 파일에 다음 코드가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb52c53f4f22a6c6d90afe94da1c5cde383f8510" translate="yes" xml:space="preserve">
          <source>Now let's see how you would take this intuition and type the children of various React components.</source>
          <target state="translated">이제이 직관을 취하고 다양한 React 컴포넌트의 자식을 어떻게 입력하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="c47667d674268b42d8bc54bea9304a308b2c873f" translate="yes" xml:space="preserve">
          <source>Now suppose that instead of a boolean, we have a numerical value representing, say, the number of comments on a post. We want to display a count of the comments, unless there are no comments. We might naively try to do something similar to the boolean case:</source>
          <target state="translated">이제 부울 대신 게시물의 댓글 수를 나타내는 숫자 값이 있다고 가정합니다. 의견이 없으면 의견 수를 표시하려고합니다. 부울 경우와 비슷한 일을 순진하게 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="130ecc6b759fae2f2cbba2aade21537572c9ebf2" translate="yes" xml:space="preserve">
          <source>Now that all the setup and initialization is complete, you are ready to write actual Flow code. For each file that you have flagged with &lt;code&gt;// @flow&lt;/code&gt;, you now have the full power of Flow and its type-checking available to you. Here is an example Flow file:</source>
          <target state="translated">모든 설정 및 초기화가 완료되었으므로 실제 플로우 코드를 작성할 준비가되었습니다. &lt;code&gt;// @flow&lt;/code&gt; 플래그 지정된 각 파일에 대해 이제 Flow의 모든 기능과 유형 검사를 사용할 수 있습니다. 플로우 파일의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a0aa492d72ba5e5ee4e490208cd56c9c6fd8b5b" translate="yes" xml:space="preserve">
          <source>Now type inference can keep working for &lt;code&gt;typeof obj&lt;/code&gt; which returns the expected shape of the object.</source>
          <target state="translated">이제 타입 추론은 &lt;code&gt;typeof obj&lt;/code&gt; 에서 계속 작동 하여 객체의 예상 모양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18e7605734b62fc321cd934a156de7bc5fd3f54f" translate="yes" xml:space="preserve">
          <source>Now wherever we use &lt;code&gt;this.props&lt;/code&gt; in our React component Flow will treat it as the &lt;code&gt;Props&lt;/code&gt; type we defined.</source>
          <target state="translated">이제 React 컴포넌트 플로우에서 &lt;code&gt;this.props&lt;/code&gt; 를 사용하는 곳마다 이를 정의한 &lt;code&gt;Props&lt;/code&gt; 유형 으로 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="cba47b2f9c45e1dcfda8b52779b4d36ece5cf6c4" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ll get a warning from Flow if you try to use numbers.</source>
          <target state="translated">숫자를 사용하려고하면 Flow에서 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="abd74ca854ddc164ed4dd85269784a3b28f553e8" translate="yes" xml:space="preserve">
          <source>Now your code will not leak &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">이제 코드가 누출되지 않습니다 &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d733ad521afc4421b4a66b432128c9bcdc2b5eec" translate="yes" xml:space="preserve">
          <source>Now, if you pass two values then &lt;code&gt;props.children&lt;/code&gt; will be an array. Specifically in this case &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[1, 2]&lt;/code&gt;.</source>
          <target state="translated">이제 두 값을 전달하면 &lt;code&gt;props.children&lt;/code&gt; 이 배열이됩니다. 이 경우 &lt;code&gt;props.children&lt;/code&gt; 은 &lt;code&gt;[1, 2]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be6e2a0e2bd898f29d9210b231319127fd00f218" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s Flowify the component we just wrote:</source>
          <target state="translated">이제 방금 작성한 구성 요소를 Flowify로 봅시다.</target>
        </trans-unit>
        <trans-unit id="c7db6f471fb8404ecff0960ed4244da4532a2c7e" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s walk through different definitions of &lt;code&gt;method()&lt;/code&gt; in a couple different &lt;em&gt;subclasses&lt;/em&gt;.</source>
          <target state="translated">자, 서로 다른 &lt;em&gt;서브 클래스&lt;/em&gt; 에서 &lt;code&gt;method()&lt;/code&gt; 의 다른 정의를 살펴 보자 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fe7f794fc68b1034d0e3f564bf32dd7ffd089d7" translate="yes" xml:space="preserve">
          <source>Nuclide</source>
          <target state="translated">Nuclide</target>
        </trans-unit>
        <trans-unit id="63c0e833d1f670a8069d40968493548f0265ef94" translate="yes" xml:space="preserve">
          <source>Nuclide also comes with many other features including support for remote projects, hack, mercurial etc.</source>
          <target state="translated">Nuclide는 원격 프로젝트, 해킹, 머큐리얼 등을 포함한 많은 다른 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9e0b7a63508302d9d09c38742d062288dc1823d2" translate="yes" xml:space="preserve">
          <source>Nuclide v0.243.0 onward has support for working with Flow to limit the reported warnings to the working fileset. This allows Nuclide and Flow to work efficiently on large codebases with tens of thousands of unsuppressed warnings.</source>
          <target state="translated">Nuclide v0.243.0 이상에서는보고 된 경고를 작업 파일 세트로 제한하기 위해 Flow 작업을 지원합니다. 이를 통해 Nuclide와 Flow는 수만 건의 억제되지 않은 경고가있는 대형 코드베이스에서 효율적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="335e5e44a812438f93ba78ec1988eb2972404cb9" translate="yes" xml:space="preserve">
          <source>Numbers: like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;</source>
          <target state="translated">숫자 : &lt;code&gt;42&lt;/code&gt; 또는 &lt;code&gt;3.14&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="9ed92c18b4e477381c353e8136dbc9d058b63386" translate="yes" xml:space="preserve">
          <source>Object type inference</source>
          <target state="translated">객체 유형 추론</target>
        </trans-unit>
        <trans-unit id="0b9a72ed85754757a03a424a4f413c85cc295a74" translate="yes" xml:space="preserve">
          <source>Object type syntax</source>
          <target state="translated">객체 유형 구문</target>
        </trans-unit>
        <trans-unit id="cdea7c16abb43506671d0750b87a9ae17eb2398a" translate="yes" xml:space="preserve">
          <source>Object types can have optional properties where a question mark &lt;code&gt;?&lt;/code&gt; comes after the property name.</source>
          <target state="translated">객체 유형은 물음표가있는 선택적 속성을 가질 수 있습니다 &lt;code&gt;?&lt;/code&gt; 속성 이름 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="f85c54a239ca0dd9865eaee3f09163bc064e2fde" translate="yes" xml:space="preserve">
          <source>Object types try to match the syntax for objects in JavaScript as much as possible. Using curly braces &lt;code&gt;{}&lt;/code&gt; and name-value pairs using a colon &lt;code&gt;:&lt;/code&gt; split by commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">객체 유형은 JavaScript에서 객체의 구문을 가능한 많이 일치 시키려고합니다. 중괄호 사용 &lt;code&gt;{}&lt;/code&gt; 와 콜론을 사용하여 이름 - 값 쌍 &lt;code&gt;:&lt;/code&gt; 쉼표로 분할 &lt;code&gt;,&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1354578aed5c555826e657109cf8e1a80a7db3d0" translate="yes" xml:space="preserve">
          <source>Objects are structurally typed</source>
          <target state="translated">객체는 구조적으로 타이핑됩니다</target>
        </trans-unit>
        <trans-unit id="9ab5bd450c651a40acb31c6d2173d2d8a317f03b" translate="yes" xml:space="preserve">
          <source>Objects as maps</source>
          <target state="translated">맵으로서의 객체</target>
        </trans-unit>
        <trans-unit id="01a1617fcbeab1f400211a1e0e3d5541707fdd66" translate="yes" xml:space="preserve">
          <source>Objects can be used in many different ways in JavaScript. There are a number of different ways to type them in order to support all the different use cases.</source>
          <target state="translated">JavaScript에서는 객체를 다양한 방법으로 사용할 수 있습니다. 서로 다른 모든 사용 사례를 지원하기 위해 여러 가지 방법으로 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4eb44d5d295882356db532a105f60a76be3916a" translate="yes" xml:space="preserve">
          <source>Obsolete. Set this to &lt;code&gt;true&lt;/code&gt; to always strip the root directory from file paths in error messages when using &lt;code&gt;--json&lt;/code&gt;, &lt;code&gt;--from emacs&lt;/code&gt;, and &lt;code&gt;--from vim&lt;/code&gt;. Do not use this option. Instead, pass the command line flag &lt;code&gt;--strip-root&lt;/code&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;--json&lt;/code&gt; , &lt;code&gt;--from emacs&lt;/code&gt; 및 &lt;code&gt;--from vim&lt;/code&gt; 을 사용할 때 오류 메시지의 파일 경로에서 항상 루트 디렉토리를 제거하려면 이것을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 이 옵션을 사용하지 마십시오. 대신 명령 행 플래그 &lt;code&gt;--strip-root&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd9b17a8cc9cfeab14950ff409781477ba7078b9" translate="yes" xml:space="preserve">
          <source>Often third-party libraries have broken type definitions or have type definitions only compatible with a certain version of Flow. In those cases it may be useful to use type information from the third-party libraries without typechecking their contents.</source>
          <target state="translated">타사 라이브러리에서 형식 정의가 깨지거나 특정 버전의 Flow 와만 호환되는 형식 정의가있는 경우가 종종 있습니다. 이러한 경우 내용을 확인하지 않고 타사 라이브러리의 유형 정보를 사용하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adacc74ca82788d5eac49de1a84a330f45c46c00" translate="yes" xml:space="preserve">
          <source>Often, third-party code is organized in terms of modules rather than globals. To write a libdef that declares the presence of a module you&amp;rsquo;ll want to use the &lt;code&gt;declare module&lt;/code&gt; syntax:</source>
          <target state="translated">종종 타사 코드는 전역이 아닌 모듈 측면에서 구성됩니다. 모듈의 존재를 선언하는 libdef를 작성하려면 다음과 같이 &lt;code&gt;declare module&lt;/code&gt; 구문 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b24bbeccf5137f66b11ed50187cc6eafef3213fa" translate="yes" xml:space="preserve">
          <source>On the flip-side, &lt;strong&gt;&lt;em&gt;completeness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to only ever catch errors that &lt;em&gt;would&lt;/em&gt; happen at runtime. This comes at the cost of sometimes missing errors that will happen at runtime.</source>
          <target state="translated">플립 측면에서, &lt;strong&gt;&lt;em&gt;완전성은&lt;/em&gt;&lt;/strong&gt; 오직 오류 잡기에 유형 검사를위한 기능입니다 &lt;em&gt;것입니다&lt;/em&gt; 실행시 발생은. 런타임에 발생할 수있는 오류가 간혹 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d37f56efe0e6015ca80498e8ea761c659a342927" translate="yes" xml:space="preserve">
          <source>Once all the dependencies of a &lt;code&gt;@flow strict-local&lt;/code&gt; file are strict, the file can be upgraded to a &lt;code&gt;@flow strict&lt;/code&gt; file. A &lt;code&gt;@flow strict&lt;/code&gt; file cannot depend on a &lt;code&gt;@flow strict-local&lt;/code&gt; file as this would break the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">&lt;code&gt;@flow strict-local&lt;/code&gt; 파일 의 모든 종속성 이 엄격하면 파일을 &lt;code&gt;@flow strict&lt;/code&gt; 파일 로 업그레이드 할 수 있습니다 . &lt;code&gt;@flow strict&lt;/code&gt; 파일은에 의존 할 수 &lt;code&gt;@flow strict-local&lt;/code&gt; 이 휴식하는 것처럼 파일 &lt;code&gt;nonstrict-import&lt;/code&gt; 규칙을.</target>
        </trans-unit>
        <trans-unit id="2e418e3cfbf0c00ec225eae651536e321fd3bd30" translate="yes" xml:space="preserve">
          <source>Once you have &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;installed&lt;/a&gt; Flow, you will want to get a feel of how to use Flow at the most basic level. For most new Flow projects, you will follow this general pattern:</source>
          <target state="translated">Flow를 &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;설치 한&lt;/a&gt; 후에 는 가장 기본적인 수준에서 Flow를 사용하는 방법에 대한 느낌을 원할 것입니다. 대부분의 새로운 Flow 프로젝트의 경우 다음과 같은 일반적인 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="6ccb0b14eaa9c14dee4efd8a3cd89afe87b6ccb4" translate="yes" xml:space="preserve">
          <source>Once you have Babel setup, install &lt;code&gt;@babel/preset-flow&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">Babel을 설정 한 후에 는 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; 또는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 과 함께 &lt;code&gt;@babel/preset-flow&lt;/code&gt; 를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5fea1da9e23ea1d202b2729a702a3f535801fdd" translate="yes" xml:space="preserve">
          <source>One of the main contributors of Flow&amp;rsquo;s precision is path-sensitivity: the way types interact with runtime tests. The essence of many JavaScript idioms is to put together ad hoc sets of runtime values and to take them apart with shallow, structural (in)equality checks. In Flow, the set of runtime values that a variable may contain is described by its type, and a runtime test on that variable refines the type to a smaller set. This ability turns out to be quite powerful and general in practice.</source>
          <target state="translated">Flow의 정밀도를 높이는 주요 요인 중 하나는 경로 민감도입니다. 즉, 유형이 런타임 테스트와 상호 작용하는 방식입니다. 많은 JavaScript 관용구의 본질은 임시 런타임 값 세트를 구성하고 얕고 구조적인 (평등 한) 평등 검사와 분리하는 것입니다. 흐름에서 변수에 포함될 수있는 런타임 값 세트는 해당 유형으로 설명되며 해당 변수에 대한 런타임 테스트는 유형을 더 작은 세트로 세분화합니다. 이 능력은 실제로 매우 강력하고 일반적인 것으로 판명되었습니다.</target>
        </trans-unit>
        <trans-unit id="c922fe63b25cd49cec8888b01a561a5582a84a58" translate="yes" xml:space="preserve">
          <source>Only allowing a specific element type as children.</source>
          <target state="translated">특정 요소 유형 만 하위로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="552faaf2aafbe53d107876ccee0f0634f915c3e5" translate="yes" xml:space="preserve">
          <source>Only one background process will be running at any given time, so if you run &lt;code&gt;flow status&lt;/code&gt; multiple times, it will use the same process.</source>
          <target state="translated">주어진 시간에 하나의 백그라운드 프로세스 만 실행되므로 &lt;code&gt;flow status&lt;/code&gt; 여러 번 실행 하면 동일한 프로세스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4a45cacdd8d7e9f0ebca1ec7bc3fb1f33c78855" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Syntax</source>
          <target state="translated">불투명 한 유형 별명 구문</target>
        </trans-unit>
        <trans-unit id="65ea8514201b92749598f548009f0a4afe84c188" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Type Checking</source>
          <target state="translated">불투명 한 유형 별명 유형 확인</target>
        </trans-unit>
        <trans-unit id="961bf1b4717073b1bc912e5a6e9062ea360301f6" translate="yes" xml:space="preserve">
          <source>Opaque Type Aliases</source>
          <target state="translated">불투명 한 유형 별명</target>
        </trans-unit>
        <trans-unit id="6077a6482ea571ceaa9f7539cf7e9cbf318e56ce" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are created using the words &lt;code&gt;opaque type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">불투명 유형 별명은 &lt;code&gt;opaque type&lt;/code&gt; 단어 와 그 이름, 등호 &lt;code&gt;=&lt;/code&gt; 및 유형 정의를 사용하여 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9ac0643d45dfbbd750de612f57c1963700d825" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are type aliases that do not allow access to their underlying type outside of the file in which they are defined.</source>
          <target state="translated">불투명 한 유형 별명은 정의 된 파일 외부의 기본 유형에 대한 액세스를 허용하지 않는 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="5f911be9170f1811fca0f4efce9cc2904081c303" translate="yes" xml:space="preserve">
          <source>Opaque type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;, and they work exactly as generics do in regular &lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;type aliases&lt;/a&gt;</source>
          <target state="translated">불투명 한 유형 별칭에는 고유 한 &lt;a href=&quot;../generics&quot;&gt;제네릭&lt;/a&gt; 이있을 수 있으며 일반 &lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;형식 별칭&lt;/a&gt; 의 제네릭 과 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a9f3700878b30b619fa2c5143a86c38508c7ca4b" translate="yes" xml:space="preserve">
          <source>Opaque type aliases, like regular type aliases, may be used anywhere a type can be used.</source>
          <target state="translated">일반 유형 별명과 같이 불투명 유형 별명은 유형을 사용할 수있는 모든 곳에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="translated">선택적 매개 변수</target>
        </trans-unit>
        <trans-unit id="6eb1e4ba2d4c68b05e65e2f8b787201061244dd0" translate="yes" xml:space="preserve">
          <source>Optional function parameters</source>
          <target state="translated">선택적 기능 매개 변수</target>
        </trans-unit>
        <trans-unit id="b20d0cae17674ab970acb532453aaf71edae6a61" translate="yes" xml:space="preserve">
          <source>Optional object properties</source>
          <target state="translated">선택적 객체 속성</target>
        </trans-unit>
        <trans-unit id="2d932cfadb898020aa3d7c79ba0029b42cc035ac" translate="yes" xml:space="preserve">
          <source>Optional object type properties</source>
          <target state="translated">선택적 객체 유형 속성</target>
        </trans-unit>
        <trans-unit id="7d05768bc14089a0cc0ad2e54b12a94fab4dbaf6" translate="yes" xml:space="preserve">
          <source>Optional parameters will accept missing, &lt;code&gt;undefined&lt;/code&gt;, or matching types. But they will not accept &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">선택적 매개 변수는 누락, &lt;code&gt;undefined&lt;/code&gt; 또는 일치하는 유형을 허용합니다. 그러나 그들은 &lt;code&gt;null&lt;/code&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5037e7b0dd30d22a12232b46317dc9e63f9ba600" translate="yes" xml:space="preserve">
          <source>Or as constructed wrapper objects.</source>
          <target state="translated">또는 구성된 래퍼 객체로.</target>
        </trans-unit>
        <trans-unit id="f26ec27bdcca139b8bc25d769f1290e1e51a3bf0" translate="yes" xml:space="preserve">
          <source>Or you could be accessing an element that does not exist if it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">또는 &quot;스파 스 배열&quot;인 경우 존재하지 않는 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e404be6e42270a506b9fda4079e3cbb1faf93ee5" translate="yes" xml:space="preserve">
          <source>Or you could refine on the shape of objects.</source>
          <target state="translated">또는 물체의 모양을 다듬을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36ccd6fa5b54b074d48b3c318b7724049b209ff5" translate="yes" xml:space="preserve">
          <source>Other Editors</source>
          <target state="translated">다른 편집자</target>
        </trans-unit>
        <trans-unit id="b01d9e5fc57d8be7b4d4cfaf9d867219b88b9c98" translate="yes" xml:space="preserve">
          <source>Other extensions that you may try are:</source>
          <target state="translated">시도 할 수있는 다른 확장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55d5eb5f68ae162a0c0275477fbf7fd7aa314ea9" translate="yes" xml:space="preserve">
          <source>Other type systems will favor completeness instead, only reporting real errors in favor of possibly missing errors. Unit/Integration testing is an extreme form of this approach. Often this comes at the cost of missing the errors that are the most complicated to find, leaving that part up to the developer.</source>
          <target state="translated">다른 유형 시스템은 완전성을 선호하며, 오류가 없을 가능성이있는 실제 오류 만보고합니다. 단위 / 통합 테스트는이 방식의 극단적 인 형태입니다. 가장 복잡한 오류를 찾아서 개발자에게 맡기는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="d10a332d2514aa48380a681c92c805bab5fc2c39" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;../types&quot;&gt;types reference&lt;/a&gt; has more information about both &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">우리의 &lt;a href=&quot;../types&quot;&gt;형식 참조&lt;/a&gt; 에는 &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; 대한 자세한 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7ec91907688dba7293db664f96aa7520dd5050d" translate="yes" xml:space="preserve">
          <source>Our first case is an element with no children:</source>
          <target state="translated">첫 번째 사례는 자녀가없는 요소입니다.</target>
        </trans-unit>
        <trans-unit id="3e4d85a254d099e6caabb9070a8f1a5835e74184" translate="yes" xml:space="preserve">
          <source>Outside the Defining File</source>
          <target state="translated">정의 파일 외부</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="2bfd0b733d61ec42886bc0c31e24e1f1a0d24fdf" translate="yes" xml:space="preserve">
          <source>Parameterized generics</source>
          <target state="translated">매개 변수화 된 제네릭</target>
        </trans-unit>
        <trans-unit id="6aa250c187d7bae549c808c9085514424d802eea" translate="yes" xml:space="preserve">
          <source>Pathogen</source>
          <target state="translated">Pathogen</target>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="8a51f97f15da4dd4d5a94fab1a4108cee0b5e1d4" translate="yes" xml:space="preserve">
          <source>Precision also has other desirable consequences. When types are trustworthy, developers tend to rely on them to structure their code and reason about it, leading to cleaner and more efficient code with fewer dynamic checks. When type errors are trustworthy, developers can focus on what their code does rather than thinking about how to rewrite their code to satisfy (or work around) the type system.</source>
          <target state="translated">정밀도는 또한 다른 바람직한 결과를 초래합니다. 유형이 신뢰할 수있는 경우 개발자는 코드와 그에 대한 이유를 구조화하기 위해 해당 유형에 의존하는 경향이 있으므로 동적 검사가 적고 깨끗하고 효율적인 코드가 생성됩니다. 형식 오류를 신뢰할 수있는 경우 개발자는 형식 시스템을 만족 시키거나 해결하기 위해 코드를 다시 작성하는 방법을 생각하지 않고 코드의 기능에 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83590fe5defcf4d8a2747e7bff66e91f7879b09e" translate="yes" xml:space="preserve">
          <source>Precision usually comes at the cost of speed. But while a precise analysis is desirable, most of the appeal of JavaScript is lost if we slow down the edit-refresh cycle by making developers wait as we compile.</source>
          <target state="translated">정밀도는 일반적으로 속도가 빠릅니다. 그러나 정확한 분석이 바람직하지만 개발자가 컴파일 할 때까지 기다리게하여 편집 새로 고침주기를 느리게하면 JavaScript의 매력이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="257e6b97ae8767ca7162ae0be418d790074caf9b" translate="yes" xml:space="preserve">
          <source>Predicate Functions</source>
          <target state="translated">술어 함수</target>
        </trans-unit>
        <trans-unit id="8fcc548a63302b124fd2a2a6ebe6d394e16cc696" translate="yes" xml:space="preserve">
          <source>Prepare Your Code for Flow</source>
          <target state="translated">흐름을위한 코드 준비</target>
        </trans-unit>
        <trans-unit id="80015c28ef31d8e37f60f4672f12166e4717f624" translate="yes" xml:space="preserve">
          <source>Preparing a project for Flow requires only one command:</source>
          <target state="translated">플로우를위한 프로젝트 준비에는 하나의 명령 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0334ecb0491c1c96b75c2abb7a0dde8caad5c58f" translate="yes" xml:space="preserve">
          <source>Preserving the Instance Type of a Component</source>
          <target state="translated">구성 요소의 인스턴스 유형 유지</target>
        </trans-unit>
        <trans-unit id="f6675da1b1e3eb27ea3b95e0125a3fc19547c62c" translate="yes" xml:space="preserve">
          <source>Press Ctrl+Shift+P to bring up the Command Palette (or use Tools &amp;gt; Command Palette menu)</source>
          <target state="translated">Ctrl + Shift + P를 눌러 명령 팔레트를 불러 오십시오 (또는 도구&amp;gt; 명령 팔레트 메뉴 사용).</target>
        </trans-unit>
        <trans-unit id="4e34606590cc14f76b8a62ab4f8ca344fd2d5ed8" translate="yes" xml:space="preserve">
          <source>Prevent this from happening by cutting &lt;code&gt;any&lt;/code&gt; off as soon as possible by casting it to another type.</source>
          <target state="translated">방지이 절단에 의해 일어나는 &lt;code&gt;any&lt;/code&gt; 다른 유형으로 변환하여 가능한 한 빨리 끕니다.</target>
        </trans-unit>
        <trans-unit id="d8f0896601269b7c415369db5197a7aa8c4bfad4" translate="yes" xml:space="preserve">
          <source>Primitive Types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="498f09c9f4966796c2534e5801feef8ccd4eed84" translate="yes" xml:space="preserve">
          <source>React allows you to grab the instance of an element or component with &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt; functions&lt;/a&gt;. To use a ref function add a &lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;maybe instance type&lt;/a&gt; to your class and assign your instance to that property in your ref function.</source>
          <target state="translated">React를 사용하면 &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 함수&lt;/a&gt; 를 사용하여 요소 또는 구성 요소의 인스턴스를 가져올 수 있습니다 . ref 함수를 사용하려면 클래스에 &lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;어쩌면 인스턴스 유형&lt;/a&gt; 을 추가하고 ref 함수의 해당 속성에 인스턴스를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="ce33237a4802f75e813a38036292316d4ce2343b" translate="yes" xml:space="preserve">
          <source>React allows you to pass &lt;em&gt;any&lt;/em&gt; value as the children of a React component. There are some creative uses of this capability such as using a function for children which could look like this:</source>
          <target state="translated">React를 사용하면 React 구성 요소의 자식으로 &lt;em&gt;모든&lt;/em&gt; 값 을 전달할 수 있습니다 . 다음과 같은 하위 기능을 사용하는 등이 기능을 창의적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="177c1e000dc1d0316d4c2c3d73adf88cdc7bde20" translate="yes" xml:space="preserve">
          <source>React also supports default props on stateless functional components. Similarly to class components, default props for stateless functional components will work without any extra type annotations.</source>
          <target state="translated">React는 상태 비 저장 기능 구성 요소에 대한 기본 소품도 지원합니다. 클래스 구성 요소와 마찬가지로 상태 비 저장 기능 구성 요소의 기본 소품은 추가 유형 주석없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b4a8bc5b355decd0225ee33bd0badaf612842a37" translate="yes" xml:space="preserve">
          <source>React class components will be the class instance. So if you had &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; and used &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; then the type would be the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">반응 클래스 컴포넌트는 클래스 인스턴스가됩니다. 따라서 &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; 하고 &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; 를 사용하면 유형은 &lt;code&gt;Foo&lt;/code&gt; 의 인스턴스가 됩니다.</target>
        </trans-unit>
        <trans-unit id="c111454a8a259a2534472c017a3802fd7ccb4ddd" translate="yes" xml:space="preserve">
          <source>React elements can have zero, one, or many children. Being able to type these children with Flow allows you to build expressive APIs with React children.</source>
          <target state="translated">반응 요소는 0, 1 또는 많은 자식을 가질 수 있습니다. 이러한 하위 항목을 Flow로 입력 할 수 있으면 React 하위를 사용하여 표현형 API를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="007c7fdccd509ac94dc704a539b8aed206e42677" translate="yes" xml:space="preserve">
          <source>React exports a handful of utility types that may be useful to you when typing advanced React patterns. In previous sections we have seen a few of them. The following is a complete reference for each of these types along with some examples for how/where to use them.</source>
          <target state="translated">React는 고급 React 패턴을 입력 할 때 유용 할 수있는 몇 가지 유틸리티 유형을 내 보냅니다. 이전 섹션에서 우리는 그중 몇 가지를 보았습니다. 다음은 이러한 각 유형에 대한 완전한 참조 및 사용 방법 / 위치에 대한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="83f2828960b3b5c2589074d8fb5ec48d203a2618" translate="yes" xml:space="preserve">
          <source>React stateless functional components do not have a backing instance and so &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; (when &lt;code&gt;Bar&lt;/code&gt; is &lt;code&gt;function Bar() {}&lt;/code&gt;) will give you the undefined type.</source>
          <target state="translated">React Stateless 기능 구성 요소에는 지원 인스턴스가 없으므로 &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; ( &lt;code&gt;Bar&lt;/code&gt; 가 &lt;code&gt;function Bar() {}&lt;/code&gt; )는 정의되지 않은 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="29ed07e15fc66a324459b85d24416800bceafaa3" translate="yes" xml:space="preserve">
          <source>React supports the notion of &lt;code&gt;defaultProps&lt;/code&gt; which you can think of as default function arguments. When you create an element and you did not include a prop with a default then React will substitute that prop with its corresponding value from &lt;code&gt;defaultProps&lt;/code&gt;. Flow supports this notion as well. To type default props add a &lt;code&gt;static defaultProps&lt;/code&gt; property to your class.</source>
          <target state="translated">React는 기본 함수 인수로 생각할 수있는 &lt;code&gt;defaultProps&lt;/code&gt; 개념을 지원합니다 . 요소를 만들 때 기본값으로 소품을 포함하지 않으면 React는 해당 소품을 &lt;code&gt;defaultProps&lt;/code&gt; 의 해당 값으로 대체합니다 . Flow도이 개념을 지원합니다. 기본 소품을 입력하려면 &lt;code&gt;static defaultProps&lt;/code&gt; 속성을 클래스에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="70287cb5f65a904f3e064a37b30a5a631627d2e6" translate="yes" xml:space="preserve">
          <source>Read more about &lt;a href=&quot;variance&quot;&gt;property variance&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;variance&quot;&gt;특성 분산&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="61910c412c7b58b226db5d6ed180b312f69dc750" translate="yes" xml:space="preserve">
          <source>Reassigning unsealed object properties</source>
          <target state="translated">봉인되지 않은 객체 속성 재 지정</target>
        </trans-unit>
        <trans-unit id="1bf2749de445e45162652ccf38c834bf918ba1b2" translate="yes" xml:space="preserve">
          <source>Reassigning variables</source>
          <target state="translated">변수 재 할당</target>
        </trans-unit>
        <trans-unit id="d6101a7583b060dcae14c84065094e42d98e9a54" translate="yes" xml:space="preserve">
          <source>Recall that the instance type of a function component is &lt;code&gt;void&lt;/code&gt;. Our example above wraps a component in a function, so the returned component has the instance type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">함수 구성 요소의 인스턴스 유형이 &lt;code&gt;void&lt;/code&gt; 임을 기억하십시오 . 위의 예제는 함수에 컴포넌트를 래핑하므로 반환 된 컴포넌트는 인스턴스 유형이 &lt;code&gt;void&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="7c12d3319cfff8593c41d6d684faf2f999524cf3" translate="yes" xml:space="preserve">
          <source>Redux state &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;is meant to be immutable&lt;/a&gt;: creating a new state object instead of changing properties on a single object.</source>
          <target state="translated">Redux 상태 &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;는 변경할 수 없습니다&lt;/a&gt; . 단일 객체의 속성을 변경하는 대신 새 상태 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ed05f5c415303abb0d8305ee74bd6d2e8ce7eda3" translate="yes" xml:space="preserve">
          <source>Refinement Invalidations</source>
          <target state="translated">세분화 무효화</target>
        </trans-unit>
        <trans-unit id="43586e5f8885df744af66a163f9bd504927049f7" translate="yes" xml:space="preserve">
          <source>Refinement invalidation can also happen with &lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;disjoint unions&lt;/a&gt;. Any function call will invalidate any refinement.</source>
          <target state="translated">&lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;분리&lt;/a&gt; 무효화는 비 연합 조합 에서도 발생할 수 있습니다 . 모든 함수 호출은 구체화를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="a02ef029699599da7905088f0dc103f214ced944" translate="yes" xml:space="preserve">
          <source>Refinements are a frequently used aspect of many type systems. They are so ingrained in the way that we program and even the way that we think you might not even notice them.</source>
          <target state="translated">구체화는 많은 유형 시스템에서 자주 사용되는 측면입니다. 그것들은 우리가 프로그래밍하는 방식과 심지어 당신이 그것들을 눈치 채지 못할 것이라고 생각하는 방식에 깊이 뿌리 박혀 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b89cb145cee7a8457a6e4dd2a97e9f0caac7219" translate="yes" xml:space="preserve">
          <source>Refinements can also come in other forms other than testing for equality:</source>
          <target state="translated">개선은 평등을 테스트하는 것 이외의 다른 형태로 나올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="698e6391f48381c22849ea4013ae0a7dff98a9af" translate="yes" xml:space="preserve">
          <source>Refining Maybe types</source>
          <target state="translated">정제 유형</target>
        </trans-unit>
        <trans-unit id="9452f08c2e094961ce428c428ee0585501ce1d09" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt; are different types.</source>
          <target state="translated">그 기억 &lt;code&gt;boolean&lt;/code&gt; 및 &lt;code&gt;Boolean&lt;/code&gt; 다른 유형입니다.</target>
        </trans-unit>
        <trans-unit id="11f6d4fee5ab698ed0a3047ac64f1d9637774150" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; are different types.</source>
          <target state="translated">그 기억 &lt;code&gt;number&lt;/code&gt; 와 &lt;code&gt;Number&lt;/code&gt; 서로 다른 유형입니다.</target>
        </trans-unit>
        <trans-unit id="55b41046e32661a87f2a8fd34325d7734f4d4cd1" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are different types.</source>
          <target state="translated">그 기억 &lt;code&gt;string&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 다른 유형입니다.</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3d6f80999c0c50a74e8acebc121f44bdbef82ae3" translate="yes" xml:space="preserve">
          <source>Requires Flow to be installed and available on your path.</source>
          <target state="translated">경로에 Flow를 설치하고 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="33b4e56519b4614c59e8b72375bac3a885fdacaa" translate="yes" xml:space="preserve">
          <source>Requires JavaScript files to be marked with /* @flow */ at the top.</source>
          <target state="translated">JavaScript 파일이 맨 위에 / * @flow * /로 표시되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a7c549205648d46b232d0e6177754a236939fcb" translate="yes" xml:space="preserve">
          <source>Requires projects containing JavaScript files to be initialised with flow init.</source>
          <target state="translated">flow init로 JavaScript 파일을 포함하는 프로젝트를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">나머지 매개 변수</target>
        </trans-unit>
        <trans-unit id="7af6341ba4a77c200422ad48589bc5fcb0b569c3" translate="yes" xml:space="preserve">
          <source>Return types ensure that every branch of your function returns the same type. This prevents you from accidentally not returning a value under certain conditions.</source>
          <target state="translated">리턴 유형은 함수의 모든 분기가 동일한 유형을 리턴하도록합니다. 따라서 특정 조건에서 실수로 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="686039dfdbe08da5125ed6c00f4c1399d48dfd9b" translate="yes" xml:space="preserve">
          <source>Right, the &lt;code&gt;isLeapYear&lt;/code&gt; call in &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; will typecheck, since the &lt;code&gt;year&lt;/code&gt; parameter expects a &lt;code&gt;string&lt;/code&gt; in the declaration file.</source>
          <target state="translated">&lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; 의 &lt;code&gt;isLeapYear&lt;/code&gt; 호출 은 &lt;code&gt;year&lt;/code&gt; 매개 변수 가 선언 파일 의 &lt;code&gt;string&lt;/code&gt; 을 기대하기 때문에 typecheck 합니다.</target>
        </trans-unit>
        <trans-unit id="67d0f5e7710e2e8d6a977594f3101bc9772e4d34" translate="yes" xml:space="preserve">
          <source>Run the Flow Background Process</source>
          <target state="translated">흐름 백그라운드 프로세스 실행</target>
        </trans-unit>
        <trans-unit id="61ba9e06d750a8c11a8c53dbe4b159704d49a040" translate="yes" xml:space="preserve">
          <source>Run this command at the top level of your project to create one, empty file called &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;&lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;. At its most basic level, &lt;code&gt;.flowconfig&lt;/code&gt; tells the Flow background process the root of where to begin checking Flow code for errors.</source>
          <target state="translated">프로젝트의 최상위 레벨에서이 명령을 실행하여 &lt;a href=&quot;https://flow.org/en/config/&quot;&gt; &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt; 라는 빈 파일 하나를 작성하십시오 . 가장 기본적인 수준에서 &lt;code&gt;.flowconfig&lt;/code&gt; 는 흐름 백그라운드 프로세스에 흐름 코드 검사 오류의 시작 위치를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6e373532fbaa792fe51ef4bf5789af3104a5d987" translate="yes" xml:space="preserve">
          <source>Say you have the following directory structure, with your &lt;code&gt;.flowconfig&lt;/code&gt; in &lt;code&gt;mydir&lt;/code&gt;:</source>
          <target state="translated">당신이 당신과 함께, 다음 디렉토리 구조를 가지고 말 &lt;code&gt;.flowconfig&lt;/code&gt; 에서 &lt;code&gt;mydir&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3bfb431a612a3027c31b75652ccf295595fa76b2" translate="yes" xml:space="preserve">
          <source>Sealed objects</source>
          <target state="translated">밀폐 된 물체</target>
        </trans-unit>
        <trans-unit id="554e5e25f0d86fc7d48da5b753f3b192e04d6a22" translate="yes" xml:space="preserve">
          <source>Second example:</source>
          <target state="translated">두 번째 예 :</target>
        </trans-unit>
        <trans-unit id="5437018c74686a42995bf3c86f110c73dfb010d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;this GitHub issue for the original motivation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;원래 동기 부여에&lt;/a&gt; 대해서는 이 GitHub 문제를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="e6fc3fca1eed93ff9d9a6c2799720ebdd64e3698" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;[untyped]&lt;/code&gt;(untyped) for not typechecking files, and instead using &lt;code&gt;any&lt;/code&gt; for all contents.</source>
          <target state="translated">참조 &lt;code&gt;[untyped]&lt;/code&gt; 없는 파일 유형 검사, 대신 사용 (지정되지 않은) &lt;code&gt;any&lt;/code&gt; 모든 내용에 대한합니다.</target>
        </trans-unit>
        <trans-unit id="d10cc1add2564282fb8d240521737d52d850d2d5" translate="yes" xml:space="preserve">
          <source>See how we added &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; as children to &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;? This is not allowed and &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; will throw an error. How do we make sure Flow does not allow this pattern?</source>
          <target state="translated">우리는 추가하는 방법을 참조하십시오 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; 등 어린이들에게 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; ? 이것은 허용되지 않으며 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 는 오류를 발생시킵니다. Flow가이 패턴을 허용하지 않도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="f741f4c166b4ccd4d41f13a13dece778f73df85a" translate="yes" xml:space="preserve">
          <source>Select &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo; to install</source>
          <target state="translated">설치하려면 'Sublime Text 2 및 3의 흐름'을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="e6b4c56f97df36a6ecd6ed02f0d6868208b5ab27" translate="yes" xml:space="preserve">
          <source>Select Package Control: Install Package</source>
          <target state="translated">패키지 제어 선택 : 패키지 설치</target>
        </trans-unit>
        <trans-unit id="5a51c55e03c6fe62b671bf2a091c73c068704caf" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the &lt;code&gt;export * as&lt;/code&gt; syntax from &lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyron&amp;rsquo;s proposal&lt;/a&gt;.</source>
          <target state="translated">이 설정 &lt;code&gt;enable&lt;/code&gt; 흐름을 지원해야 함을 표시하기 &lt;code&gt;export * as&lt;/code&gt; 에서 구문 &lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyron의 제안&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f2f8212166435e1e26351a8d0075e389cfc197" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;nullish coalescing&lt;/a&gt; per the pending spec.</source>
          <target state="translated">이 설정 &lt;code&gt;enable&lt;/code&gt; 흐름의 사용을 지원해야 함을 표시하기 위해 &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;병합 nullish&lt;/a&gt; 보류중인 사양 당합니다.</target>
        </trans-unit>
        <trans-unit id="5ffd0d476596e4beacfa43c710cc9eca05a02fef" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;optional chaining&lt;/a&gt; per the pending spec.</source>
          <target state="translated">이 설정 &lt;code&gt;enable&lt;/code&gt; 흐름의 사용을 지원해야 함을 표시하는 &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;옵션 체인&lt;/a&gt; 보류중인 사양 당합니다.</target>
        </trans-unit>
        <trans-unit id="a791224e1e0c6173296867136f2701fa594c4db9" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should ignore decorators.</source>
          <target state="translated">Flow가 데코레이터 를 &lt;code&gt;ignore&lt;/code&gt; 해야 함을 나타내 려면 무시 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7252ab4a3a45b3b2cf1e24f49aebbbc8df2bea70" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; and Flow will no longer complain when you use &lt;code&gt;require()&lt;/code&gt; with something other than a string literal.</source>
          <target state="translated">이것을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 문자열 리터럴이 아닌 &lt;code&gt;require()&lt;/code&gt; 를 사용할 때 Flow가 더 이상 불평하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="17b19723fab321f07b8d03e9886bc4fd290afff7" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; if you use a transpiler that adds &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the top of every module.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 을 추가하는 변환기를 사용하는 경우 이를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 모든 모듈의 상단에.</target>
        </trans-unit>
        <trans-unit id="8f7810533f5b1afdbd99345ceeeb8bb80fe383b5" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to add emoji to the status messages that Flow outputs when it&amp;rsquo;s busy checking your project.</source>
          <target state="translated">흐름이 프로젝트 확인 중일 때 출력되는 상태 메시지에 그림 이모티콘을 추가 하려면이 값을 &lt;code&gt;true&lt;/code&gt; 로 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="0a9e20b6f9ef8f6259569858fa3254651f50988f" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check all files, not just those with &lt;code&gt;@flow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@flow&lt;/code&gt; 파일뿐만 아니라 모든 파일을 확인하려면 이것을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2763696664697d56a9bd55ceed56c975dbfc607" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check that array spread syntax is only used with arrays, not arbitrary iterables (such as &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;Set&lt;/code&gt;). This is useful if you transform your code with Babel in &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;loose mode&lt;/a&gt; which makes this non-spec-compliant assumption at runtime.</source>
          <target state="translated">배열 확산 구문이 임의의 반복 가능 항목 (예 : &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;Set&lt;/code&gt; )이 아닌 배열에만 사용되는지 확인하려면 이것을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 이것은 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;느슨한 모드&lt;/a&gt; 에서 Babel을 사용하여 코드를 변환하여 런타임시 사양을 준수하지 않는 가정을 만드는 경우에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="632e3852195a2720cf86c3695ec9f34205f83f66" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to have Flow treat underscore-prefixed class properties and methods as private. This should be used in conjunction with &lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt;&lt;code&gt;jstransform&lt;/code&gt;&amp;rsquo;s ES6 class transform&lt;/a&gt;, which enforces the same privacy at runtime.</source>
          <target state="translated">Flow에서 밑줄이 붙은 클래스 속성 및 메서드를 전용으로 처리하도록하려면 이 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 이것은 런타임시 동일한 개인 정보 보호를 시행하는 &lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt; &lt;code&gt;jstransform&lt;/code&gt; 의 ES6 클래스 변환&lt;/a&gt; 과 함께 사용해야 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
