<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="c35c47e5290b31d5376f35f006e7cd6e182798e4" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to indicate that Flow should interpret object types as exact by default. When this flag is &lt;code&gt;false&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">Flow가 기본적으로 객체 유형을 정확하게 해석해야 함을 나타내 려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 이 플래그가 &lt;code&gt;false&lt;/code&gt; 인 경우 Flow는 다음과 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="0b6026d788e6990fc2b88f5d97a8a7e72d548d84" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of instance &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">플로우가 보류중인 스펙에 따라 인스턴스 &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;클래스 필드&lt;/a&gt; 사용에 대해 경고해야 함을 표시 하려면 &lt;code&gt;warn&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a95e4b769085b845d2cd025dba547c259b83a10" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of static &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">Flow가 보류중인 스펙에 따라 정적 &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;클래스 필드&lt;/a&gt; 사용에 대해 경고해야 함을 표시 하려면 &lt;code&gt;warn&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3723576f1e23f9a6be80dfc2da353444ecba4fa5" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;lazy_mode&lt;/code&gt; in the &lt;code&gt;.flowconfig&lt;/code&gt; will cause new Flow servers for that root to use that lazy mode (or no lazy mode if set to &lt;code&gt;none&lt;/code&gt;). This option can be overridden from the CLI using the &lt;code&gt;--lazy-mode&lt;/code&gt; flag.</source>
          <target state="translated">설정 &lt;code&gt;lazy_mode&lt;/code&gt; 을 에 &lt;code&gt;.flowconfig&lt;/code&gt; 것은 그 게으른 모드 (또는 게으른 모드로 설정하면 사용할 수있는 그 루트에 대한 새로운 흐름 서버가 발생할 수 &lt;code&gt;none&lt;/code&gt; ). 이 옵션은 &lt;code&gt;--lazy-mode&lt;/code&gt; 플래그를 사용하여 CLI에서 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8742e5ede9ca0ab99281256cb0a8da2b2abf5c7" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sketchy-null&lt;/code&gt; sets the level for all sketchy null checks, but there are more granular rules for particular types. These are:</source>
          <target state="translated">설정 &lt;code&gt;sketchy-null&lt;/code&gt; 모든 스케치 널 (null) 검사에 대한 수준을 설정하지만 특정 유형에 대한보다 세부적인 규칙이 있습니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="4dbac04babde4f94fd1324574fc30f6647291c38" translate="yes" xml:space="preserve">
          <source>Setting this option to X means the table will support up to 2^X elements, which is 16*2^X bytes.</source>
          <target state="translated">이 옵션을 X로 설정하면 테이블이 최대 2 ^ X 요소 (16 * 2 ^ X 바이트)를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6f8b6166467119123c34cb8d2a8307f8f72ae96e" translate="yes" xml:space="preserve">
          <source>Setting this to 1 will cause Flow to output some stats about the data that is serialized into and deserialized out of shared memory.</source>
          <target state="translated">이 값을 1로 설정하면 Flow가 공유 메모리로 직렬화 및 직렬화 해제 된 데이터에 대한 일부 통계를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="3907024420fe6565a297982966b2459dd6dc6639" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow commands include warnings in the error output. Warnings are hidden by default in the CLI to avoid console spew. (An IDE is a much better interface to show warnings.)</source>
          <target state="translated">이것을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 흐름 명령에 오류 출력에 경고가 포함됩니다. 콘솔 스푸핑을 피하기 위해 CLI에서 기본적으로 경고가 숨겨져 있습니다. (IDE는 경고를 표시하기에 훨씬 좋은 인터페이스입니다.)</target>
        </trans-unit>
        <trans-unit id="a78591e430fc75d428e63794ccb099ae8c20961b" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow treat all function parameters as const bindings. Reassigning a param is an error which lets Flow be less conservative with refinements.</source>
          <target state="translated">이를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 Flow가 모든 함수 매개 변수를 const 바인딩으로 처리합니다. 매개 변수를 다시 할당하면 오류가 구체화에 덜 보수적입니다.</target>
        </trans-unit>
        <trans-unit id="c2da3d4ed1af623cc4e8b8d52d8edb981c85d346" translate="yes" xml:space="preserve">
          <source>Setting up &amp;ldquo;boundaries&amp;rdquo; with your types means you can tell Flow your intent on top of the inference it already does.</source>
          <target state="translated">유형으로 &quot;경계&quot;를 설정하면 Flow가 이미 수행 한 추론 위에 의도를 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="7133d91a35c40bcb71979c3896fc1deb038a8a20" translate="yes" xml:space="preserve">
          <source>Setup Flow with React</source>
          <target state="translated">반응이있는 설정 흐름</target>
        </trans-unit>
        <trans-unit id="7330bdb6aab9d47b6f4302ca23a0b1d1a997ea7d" translate="yes" xml:space="preserve">
          <source>Severity Levels and Meanings</source>
          <target state="translated">심각도 수준 및 의미</target>
        </trans-unit>
        <trans-unit id="9ef912b88879662392f8c53fad059d3c74586282" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#toc-react-componenttype&quot;&gt;&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt;&lt;/a&gt; except it also includes JSX intrinsics (strings).</source>
          <target state="translated">JSX 내장 함수 (문자열)도 포함한다는 점을 제외하고 &lt;a href=&quot;#toc-react-componenttype&quot;&gt; &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ad9df7675219090b45a68675090f8c88c2996d47" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../utilities#toc-readonly&quot;&gt;&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, it is the supertype of all arrays and all tuples and represents a read-only view of an array. It does not contain any methods that will allow an object of this type to be mutated (no &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, etc.).</source>
          <target state="translated">&lt;a href=&quot;../utilities#toc-readonly&quot;&gt; &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 와 유사하게 모든 배열과 모든 튜플의 수퍼 타입이며 배열의 읽기 전용보기를 나타냅니다. 이 유형의 객체를 변경할 수있는 메소드는 없습니다 ( &lt;code&gt;push()&lt;/code&gt; , &lt;code&gt;pop()&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="7e25832c7fbfc04c711346a40af98680a99ba4e4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; variables&lt;/a&gt; if you reassign a property of an unsealed object, by default Flow will give it the type of all possible assignments.</source>
          <target state="translated">봉인되지 않은 객체의 속성을 다시 할당하면 &lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt; &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 변수 와&lt;/a&gt; 유사하게 기본적으로 Flow는 가능한 모든 할당 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ccc6ec56ed0f7579fe7c1219285baf1e414f25d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;const&lt;/code&gt;, Flow can either infer the type from the value you are assigning to it or you can provide it with a type:</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 와 유사하게 Flow는 할당 한 값에서 유형을 유추하거나 유형을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31cdc6274e2048217641f19c7436522e7c83902e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;mixed&lt;/code&gt;, generics have an &amp;ldquo;unknown&amp;rdquo; type. You&amp;rsquo;re not allowed to use a generic as if it were a specific type.</source>
          <target state="translated">&lt;code&gt;mixed&lt;/code&gt; 와 유사하게 제네릭에는 &quot;알 수없는&quot;유형이 있습니다. 제네릭을 특정 유형 인 것처럼 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f53a1bfd2499be63c34f7067d2986e44abdec95" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; can be re-assigned, there&amp;rsquo;s a few more rules you&amp;rsquo;ll need to know about.</source>
          <target state="translated">이후 &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 재 할당, 당신에 대해 알아야 할 몇 가지 더 규칙이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="339082925233909f355d06179fa3b6b26ccf7865" translate="yes" xml:space="preserve">
          <source>Since Flow does not know the length of an array, an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type cannot be passed into a tuple.</source>
          <target state="translated">Flow는 배열의 길이를 모르기 때문에 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 유형을 튜플에 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="decf7e18c6fe06fc86a8a5bc89a669829d507c85" translate="yes" xml:space="preserve">
          <source>Since a &lt;code&gt;const&lt;/code&gt; variable cannot be re-assigned at a later time it is fairly simple.</source>
          <target state="translated">때문에 &lt;code&gt;const&lt;/code&gt; 변수가 나중에 재 할당 할 수없는 것이 상당히 간단하다.</target>
        </trans-unit>
        <trans-unit id="8c614b00ece097ea225988eb96c38c1dc27bdcf2" translate="yes" xml:space="preserve">
          <source>Since the parameter &lt;code&gt;arr&lt;/code&gt; of the &lt;code&gt;someOperation&lt;/code&gt; function is typed as a mutable &lt;code&gt;Array&lt;/code&gt;, pushing a string into it would be possible inside that scope, which would then break the type contract of the outside &lt;code&gt;array&lt;/code&gt; variable. By annotating the parameter as &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead in this case, Flow can be sure this won&amp;rsquo;t happen and no errors will occur:</source>
          <target state="translated">파라미터 이후 &lt;code&gt;arr&lt;/code&gt; 의 &lt;code&gt;someOperation&lt;/code&gt; 의 기능은 가변으로 입력되는 &lt;code&gt;Array&lt;/code&gt; 된 문자열을 추진하는 것이 가능 내부 것이 다음에 외부의 종류 계약 끊을 범위, 그 &lt;code&gt;array&lt;/code&gt; 변수. 이 경우 대신 매개 변수에 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 로 주석을 달면 Flow는 이러한 상황이 발생하지 않고 오류가 발생하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1785a5e0b243285a1963526da42f273c5dc42f7" translate="yes" xml:space="preserve">
          <source>So a single array child is left alone, but what happens if we have multiple children that are arrays?</source>
          <target state="translated">따라서 단일 배열 자식은 그대로 남아 있지만 배열 인 자식이 여러 개인 경우 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="a70bd7a3ca7dbd388181ff69fc1a9d9059244ca3" translate="yes" xml:space="preserve">
          <source>So far, we support the following ways to specify supported versions</source>
          <target state="translated">지금까지 지원되는 버전을 지정하는 다음 방법을 지원합니다</target>
        </trans-unit>
        <trans-unit id="64c91e3d58f11315a8f98d01485d70281a6c3678" translate="yes" xml:space="preserve">
          <source>So if Flow sees this in the &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">Flow가 &lt;code&gt;.flowconfig&lt;/code&gt; 에서 이것을 본다면 :</target>
        </trans-unit>
        <trans-unit id="9eb921ba09ace5711e414821fe52adee56f0c3ff" translate="yes" xml:space="preserve">
          <source>So if I write a function that expects the numbers 1 through 5, any subtype of that set will be acceptable.</source>
          <target state="translated">따라서 1에서 5까지의 숫자를 기대하는 함수를 작성하면 해당 세트의 하위 유형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e8b161db695089b318d824534a1f60ea4c81045" translate="yes" xml:space="preserve">
          <source>So if you have the following in your &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">따라서 &lt;code&gt;.flowconfig&lt;/code&gt; 에 다음이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="85f50aa3f8aa1b205c54f2530dfd25375a26cc15" translate="yes" xml:space="preserve">
          <source>So in the following example, &lt;code&gt;obj2&lt;/code&gt; is a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;obj1&lt;/code&gt;.</source>
          <target state="translated">따라서 다음 예제에서 &lt;code&gt;obj2&lt;/code&gt; 는 &lt;code&gt;obj1&lt;/code&gt; 의 &lt;em&gt;하위 유형&lt;/em&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="bd21dd92e8bb38520c7aed585ce5c138a49e1e9e" translate="yes" xml:space="preserve">
          <source>So, for example, if you want to know more about how the autocomplete works, you can use this command:</source>
          <target state="translated">예를 들어, 자동 완성 기능에 대한 자세한 내용을 보려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a5040bb6c58acac2d87c681ffa0099ee5ad8294" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a property after reassignment. In that case, Flow will give it the known type.</source>
          <target state="translated">때때로 흐름은 재 할당 후 속성 유형을 확실하게 파악할 수 있습니다. 이 경우 Flow는 알려진 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8cbd2e30f0fd2935872139edbe248c42b74f633b" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a variable after re-assignment. In that case, Flow will give it the known type.</source>
          <target state="translated">때때로 흐름은 재 할당 후 변수 유형을 확실하게 파악할 수 있습니다. 이 경우 Flow는 알려진 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="190aedcaebf30683452cc18021384bd29eb893ec" translate="yes" xml:space="preserve">
          <source>Sometimes Flow&amp;rsquo;s inference will create types that are more permissive than you want them to be.</source>
          <target state="translated">때때로 Flow의 추론은 원하는 것보다 더 관대 한 유형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bf2bc69b7d682ca6d088a661a2cccdb41226e95b" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to assert a type without using something like a function or a variable to do so. For this Flow supports an inline type cast expression syntax which can be used in a number of different ways.</source>
          <target state="translated">함수 나 변수와 같은 것을 사용하지 않고 형식을 지정하는 것이 유용한 경우도 있습니다. 이를 위해 Flow는 다양한 방식으로 사용될 수있는 인라인 유형 캐스트 ​​표현식 구문을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="05acde073f433e3ebdb05840c280af6194f4f161" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to create a type which is &lt;strong&gt;&lt;em&gt;all of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts an object which is the combination of other object types. For this, Flow supports &lt;strong&gt;intersection types&lt;/strong&gt;.</source>
          <target state="translated">때로는 다른 &lt;strong&gt;&lt;em&gt;모든&lt;/em&gt;&lt;/strong&gt; 유형의 유형 인 유형을 작성하는 것이 유용합니다 . 예를 들어, 다른 객체 유형의 조합 인 객체를 허용하는 함수를 작성하려고 할 수 있습니다. 이를 위해 Flow는 &lt;strong&gt;교차 유형을&lt;/strong&gt; 지원 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="508d0f1b6949c54ce48ed8515843765f74b1ff2c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to disable this behavior and only allow a specific set of properties. For this, Flow supports &amp;ldquo;exact&amp;rdquo; object types.</source>
          <target state="translated">때때로이 동작을 비활성화하고 특정 속성 집합 만 허용하는 것이 유용합니다. 이를 위해 Flow는 &quot;정확한&quot;객체 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7e197db0c5e7c34ea4bc888687f7a0d82f7f2217" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to make declarations inline, as part of the source of an implementation file.</source>
          <target state="translated">때로는 구현 파일 소스의 일부로 선언을 인라인으로 만드는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4b7f2e42ec427dfe19e7546bbfa4cb1df144aec0" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary functions, for those you should write &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; like this:</source>
          <target state="translated">때로는 다음 과 같이 &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; 해야하는 함수에 대해 임의의 함수를 허용하는 형식을 작성하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="0d699df94c70d270a74922c6dd7a75522ca1022c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary objects, for those you should write &lt;code&gt;{}&lt;/code&gt; like this:</source>
          <target state="translated">다음 과 같이 &lt;code&gt;{}&lt;/code&gt; 을 작성해야하는 경우 임의의 객체를 허용하는 유형을 작성하는 것이 유용한 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48c4be69fd7d7e116bfe9fff8287e72150b14b65" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to create a type which is &lt;strong&gt;&lt;em&gt;one of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts a set of primitive value types. For this Flow supports &lt;strong&gt;union types&lt;/strong&gt;.</source>
          <target state="translated">때로는 다른 유형의 집합 &lt;strong&gt;&lt;em&gt;중 하나 인&lt;/em&gt;&lt;/strong&gt; 유형을 만드는 것이 유용합니다 . 예를 들어, 기본 값 유형 세트를 허용하는 함수를 작성하려고 할 수 있습니다. 이를 위해 Flow는 &lt;strong&gt;공용체 유형을&lt;/strong&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="079287524f7de17d8166e352d620ee09cbcee756" translate="yes" xml:space="preserve">
          <source>Sometimes you only want a specific component as the children to your React component. This often happens when you are building a table component which needs specific column children components, or a tab bar which needs specific configuration for each tab. One such tab bar component that uses this pattern is React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">때로는 React 구성 요소의 하위 항목으로 특정 구성 요소 만 필요합니다. 특정 열 하위 구성 요소가 필요한 테이블 구성 요소 또는 각 탭에 대해 특정 구성이 필요한 탭 표시 줄을 빌드 할 때 종종 발생합니다. 이 패턴을 사용하는 이러한 탭 표시 줄 구성 요소 중 하나는 React Native의 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="0ca3345128fc09227a3fc76aff4497f80cecc7db" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this you would not wrap the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Like so:</source>
          <target state="translated">때로는 구성 요소가 하나의 자식 &lt;em&gt;만&lt;/em&gt; 받도록 강제하고 싶을 때가 있습니다 . 당신은 사용할 수 &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt; &lt;code&gt;React.Children.only()&lt;/code&gt; 기능&lt;/a&gt; 이 제약을 적용,하지만 당신은 흐름이 시행 할 수있다. 이를 위해 &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 자녀 유형을 래핑하지 않습니다 . 이렇게 :</target>
        </trans-unit>
        <trans-unit id="0204e6779dafad940b69a188f3ba177a640b8f57" translate="yes" xml:space="preserve">
          <source>Sometimes you will want to move the condition from an &lt;code&gt;if&lt;/code&gt; statement into a function:</source>
          <target state="translated">때로는 조건을 &lt;code&gt;if&lt;/code&gt; 문에서 함수로 옮기고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54a11047f43ee69df389e7749159027d890696d" translate="yes" xml:space="preserve">
          <source>Soundness and Completeness</source>
          <target state="translated">건전성과 완전성</target>
        </trans-unit>
        <trans-unit id="746df4e9e7a562d767f5e24a05664f4a720c7f81" translate="yes" xml:space="preserve">
          <source>Soundness is fine as long as Flow isn&amp;rsquo;t being too noisy and preventing you from being productive. Sometimes when soundness would get in your way too much, Flow will favor completeness instead. There&amp;rsquo;s only a handful of cases where Flow does this.</source>
          <target state="translated">Flow가 너무 시끄럽지 않고 생산성을 방해하지 않는 한 견고성은 좋습니다. 때로는 건전성이 지나치게 길어질 때 흐름이 완전성을 선호합니다. Flow가이를 수행하는 경우는 소수입니다.</target>
        </trans-unit>
        <trans-unit id="0490059ec84f1bbf6b567a4e9c26b3a680460a91" translate="yes" xml:space="preserve">
          <source>Specify a file extension to match, and a replacement module name, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">일치시킬 파일 확장자와 대체 모듈 이름을 &lt;code&gt;-&amp;gt;&lt;/code&gt; 로 구분하여 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c23f789b3f6c7eff8cfdc73ee793e9e6cd434ab2" translate="yes" xml:space="preserve">
          <source>Specify a regular expression to match against module names, and a replacement pattern, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">모듈 이름과 일치시킬 정규식을 지정하고 대체 패턴을 &lt;code&gt;-&amp;gt;&lt;/code&gt; 로 구분하여 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="3b2886d5473db8f2728b89b52d94f9b866760285" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; with &lt;code&gt;flow&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;flow 백그라운드 프로세스&lt;/a&gt; 를 &lt;code&gt;flow&lt;/code&gt; 로 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="33040dda5793f74572e67f14abdfb073ecb04f28" translate="yes" xml:space="preserve">
          <source>Starting with Flow v0.23.0, you may use the &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project&amp;rsquo;s root directory. This is useful for writing regular expressions that are relative rather than absolute.</source>
          <target state="translated">Flow v0.23.0부터는 정규식에 &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; 자리 표시자를 사용할 수 있습니다 . 런타임시 Flow는 자리 표시자를 프로젝트의 루트 디렉토리에 대한 절대 경로 인 것처럼 처리합니다. 이것은 절대 값이 아닌 상대적인 정규식을 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="62b1fce124c3fa807ff7f42885010e1fc39fe39d" translate="yes" xml:space="preserve">
          <source>Stateless Functional Components</source>
          <target state="translated">상태 비 저장 기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="8ab6b0ce50387fe5c38a665805e317164318c6cd" translate="yes" xml:space="preserve">
          <source>Strict Local</source>
          <target state="translated">엄격한 지역</target>
        </trans-unit>
        <trans-unit id="984e1a2ea44698c9bc621d3cc2a46a2ebbfcffdb" translate="yes" xml:space="preserve">
          <source>Strictly enforced tuple length (arity)</source>
          <target state="translated">엄격하게 시행되는 튜플 길이 (arity)</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="b5c84f808b85754e46cef96360cc97ceca30a211" translate="yes" xml:space="preserve">
          <source>Strings are &lt;code&gt;&quot;foo&quot;&lt;/code&gt; values in JavaScript. The &lt;code&gt;string&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="translated">문자열은 JavaScript에서 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 값입니다. Flow 의 &lt;code&gt;string&lt;/code&gt; 유형은 이러한 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="371de9693f4209b3d6baabc8cf5aa9bd9123f714" translate="yes" xml:space="preserve">
          <source>Strings: like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</source>
          <target state="translated">문자열 : &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="translated">구조적 타이핑</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">숭고한 텍스트</target>
        </trans-unit>
        <trans-unit id="d14ac23dd85e9a8386862e11638c030009ce4084" translate="yes" xml:space="preserve">
          <source>SublimeLinter-flow</source>
          <target state="translated">SublimeLinter-flow</target>
        </trans-unit>
        <trans-unit id="3f018ae5c81afd7ff03157c258e75546aee33dc2" translate="yes" xml:space="preserve">
          <source>Subsets &amp;amp; Subtypes</source>
          <target state="translated">서브 세트 및 서브 타입</target>
        </trans-unit>
        <trans-unit id="6cdd77a39c406add3dd649d12b90f08405e31a63" translate="yes" xml:space="preserve">
          <source>Subtypes of complex types</source>
          <target state="translated">복합 유형의 하위 유형</target>
        </trans-unit>
        <trans-unit id="9d06116efdf07868027a1561d8d0339ecc6e6c45" translate="yes" xml:space="preserve">
          <source>Subtypes of functions</source>
          <target state="translated">함수의 서브 타입</target>
        </trans-unit>
        <trans-unit id="476bb4d588f74c233bb6c1ee03fd986be62e7cea" translate="yes" xml:space="preserve">
          <source>Subtypes of objects</source>
          <target state="translated">객체의 하위 유형</target>
        </trans-unit>
        <trans-unit id="0be5fa8c6c74f697319a9589425f3a2612939e3d" translate="yes" xml:space="preserve">
          <source>Subtyping Constraints</source>
          <target state="translated">서브 타이핑 제약</target>
        </trans-unit>
        <trans-unit id="f17dd2152e8dc1f949523edeb4f3e8b48630834f" translate="yes" xml:space="preserve">
          <source>Subtyping rules for functions are more complicated. So far, we&amp;rsquo;ve seen that &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;B&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; contains all possible values for &lt;code&gt;A&lt;/code&gt;. For functions, it&amp;rsquo;s not clear how this relationship would apply. To simplify things, you can think of a function type &lt;code&gt;A&lt;/code&gt; as being a subtype of a function type &lt;code&gt;B&lt;/code&gt; if functions of type &lt;code&gt;A&lt;/code&gt; can be used wherever a function of type &lt;code&gt;B&lt;/code&gt; is expected.</source>
          <target state="translated">함수의 서브 타이핑 규칙은 더 복잡합니다. 지금까지, 우리는 것을 본 적이 &lt;code&gt;A&lt;/code&gt; 가 의 하위 유형 인 &lt;code&gt;B&lt;/code&gt; 경우 &lt;code&gt;B&lt;/code&gt; 는 가능한 모든 값이 포함되어 &lt;code&gt;A&lt;/code&gt; . 함수의 경우이 관계가 어떻게 적용되는지 명확하지 않습니다. 단순화 일에, 당신은 기능 형 생각할 수 함수 유형의 하위 유형 인 것으로 &lt;code&gt;B&lt;/code&gt; 형의 기능이 경우 &lt;code&gt;A&lt;/code&gt; 는 형의 기능을 어디든지 사용할 수 있습니다 &lt;code&gt;B&lt;/code&gt; 가 예상된다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78102c720eccd1810b8e560681ce6685d79fff31" translate="yes" xml:space="preserve">
          <source>Suports vim 8 and neovim</source>
          <target state="translated">vim 8 및 neovim 지원</target>
        </trans-unit>
        <trans-unit id="3ea46343abafb30794aea626700e565b309f371e" translate="yes" xml:space="preserve">
          <source>Supplying Type Arguments to Callables</source>
          <target state="translated">콜 러블에 타입 인자 제공</target>
        </trans-unit>
        <trans-unit id="e4426aae8665ecf03f0c5957ef62701c977ed33b" translate="yes" xml:space="preserve">
          <source>Suppose for example that you want to associate a value to each suit of the previous example.</source>
          <target state="translated">예를 들어 값을 이전 예의 각 수트에 연관 시키려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="4045032ea32b290b2df4209d32c0f98371142465" translate="yes" xml:space="preserve">
          <source>Suppressing one type of sketchy null check only suppresses that type, so, for example</source>
          <target state="translated">한 유형의 스케치 null 검사를 억제하면 해당 유형 만 억제되므로 예를 들어</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="5388b4e54e46d7ce88e2e324bb0464dd484b2048" translate="yes" xml:space="preserve">
          <source>Symbols (new in ECMAScript 2015)</source>
          <target state="translated">기호 (ECMAScript 2015의 새로운 기능)</target>
        </trans-unit>
        <trans-unit id="b6410af0c2d3799d510fea0f3019deaa0a7626b1" translate="yes" xml:space="preserve">
          <source>Symbols are created with &lt;code&gt;Symbol()&lt;/code&gt; in JavaScript. Flow has basic support for symbols, using the &lt;code&gt;symbol&lt;/code&gt; type.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;Symbol()&lt;/code&gt; 을 사용 하여 심볼을 만듭니다. Flow는 &lt;code&gt;symbol&lt;/code&gt; 유형을 사용하여 심볼 을 기본적으로 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="a6251b774c7c6606be961a6810aa903791863a16" translate="yes" xml:space="preserve">
          <source>Syntax of functions</source>
          <target state="translated">함수의 구문</target>
        </trans-unit>
        <trans-unit id="38f70f0698cfc1eb1310e93dc39ca20595f7e95e" translate="yes" xml:space="preserve">
          <source>Syntax of generics</source>
          <target state="translated">제네릭의 구문</target>
        </trans-unit>
        <trans-unit id="bae14ee1fff7b2a05299ec56ecdba3f6a62d2c5f" translate="yes" xml:space="preserve">
          <source>Table of contents:</source>
          <target state="translated">목차 :</target>
        </trans-unit>
        <trans-unit id="47b04edd80b66ddca98050f09adbdab0598b38a9" translate="yes" xml:space="preserve">
          <source>Take note of the &lt;code&gt;typeof&lt;/code&gt;, it is required! &lt;code&gt;Foo&lt;/code&gt; without &lt;code&gt;typeof&lt;/code&gt; would be the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(new Foo(): Foo)&lt;/code&gt;. We want the type &lt;em&gt;of&lt;/em&gt;&lt;code&gt;Foo&lt;/code&gt; not the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt;. &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; would also work here, but we prefer &lt;code&gt;typeof&lt;/code&gt; for consistency with stateless functional components.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 를 기록해 두십시오. 필수입니다! &lt;code&gt;typeof&lt;/code&gt; 가 없는 &lt;code&gt;Foo&lt;/code&gt; 는 &lt;code&gt;Foo&lt;/code&gt; 인스턴스의 유형입니다 . 그래서 : &lt;code&gt;(new Foo(): Foo)&lt;/code&gt; . 우리는 유형 원하는 &lt;em&gt;의 &lt;/em&gt; &lt;code&gt;Foo&lt;/code&gt; 하지의 인스턴스의 유형 &lt;code&gt;Foo&lt;/code&gt; . 그래서 : &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt; . &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; 도 여기서 작동하지만 상태 비 저장 기능 구성 요소와의 일관성을 위해 &lt;code&gt;typeof&lt;/code&gt; 를 선호 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="143158f8e0d23bcab4c6519c800370955610ba03" translate="yes" xml:space="preserve">
          <source>Tell Flow which directory to use as a temp directory. Can be overridden with the command line flag &lt;code&gt;--temp-dir&lt;/code&gt;.</source>
          <target state="translated">임시 디렉토리로 사용할 디렉토리를 Flow에 알려주십시오. 명령 행 플래그 &lt;code&gt;--temp-dir&lt;/code&gt; 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5ea6782ec2acdb66109615aa3170a3b9e5c7b0" translate="yes" xml:space="preserve">
          <source>The 3 largest parts of the shared memory are a dependency table, a hash table, and a heap. While the heap grows and shrinks, the two tables are allocated in full. This option lets you change the size of the hash table.</source>
          <target state="translated">공유 메모리의 가장 큰 세 부분은 종속성 테이블, 해시 테이블 및 힙입니다. 힙이 커지거나 줄어드는 동안 두 테이블이 모두 할당됩니다. 이 옵션을 사용하면 해시 테이블의 크기를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0934dcae4f0cd7ddb495aeab8057d00242e3e126" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; consists of 7 sections:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 은 7 개 섹션으로 구성</target>
        </trans-unit>
        <trans-unit id="b2e7419e93c6bb39d11632417b0da8c56509fd33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; uses a custom format that vaguely resembles INI files. We are not proud of our custom format and plan to support a better format in the future. &lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub issue #153&lt;/a&gt; tracks this.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 는 막연하게 INI 파일과 유사한 사용자 정의 형식을 사용합니다. 우리는 사용자 정의 형식을 자랑스럽게 생각하지 않으며 앞으로 더 나은 형식을 지원할 계획입니다. &lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub 이슈 # 153&lt;/a&gt; 이이를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="1aa5025da02d927676c9cd482376361a167bd517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; in &lt;code&gt;?HTMLButtonElement&lt;/code&gt; is important. In the example above the first argument to &lt;code&gt;ref&lt;/code&gt; will be &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; as React will &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;call your &lt;code&gt;ref&lt;/code&gt; callback with null&lt;/a&gt; when the component unmounts. Also, the &lt;code&gt;button&lt;/code&gt; property on &lt;code&gt;MyComponent&lt;/code&gt; will not be set until React has finished rendering. Until then your &lt;code&gt;button&lt;/code&gt; ref will be undefined. Protect yourself against these cases and use a &lt;code&gt;?&lt;/code&gt; (like in &lt;code&gt;?HTMLButtonElement&lt;/code&gt;) to protect yourself from bugs.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 에 &lt;code&gt;?HTMLButtonElement&lt;/code&gt; 중요하다. 위의 예에서 &lt;code&gt;ref&lt;/code&gt; 의 첫 번째 인수 는 &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; 컴포넌트가 마운트 해제되면 React가 널 을 &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;호출하여 &lt;code&gt;ref&lt;/code&gt; 콜백을 호출합니다&lt;/a&gt; . 또한 React가 렌더링을 완료 할 때까지 &lt;code&gt;MyComponent&lt;/code&gt; 의 &lt;code&gt;button&lt;/code&gt; 속성 이 설정되지 않습니다. 그때까지는 &lt;code&gt;button&lt;/code&gt; 참조가 정의되지 않습니다. 이러한 경우로부터 자신을 보호하고 &lt;code&gt;?&lt;/code&gt; ( &lt;code&gt;?HTMLButtonElement&lt;/code&gt; 와 같이 ) 버그로부터 자신을 보호하십시오.</target>
        </trans-unit>
        <trans-unit id="719a6a4c0e07c1dc9a47466bbab725e9662338ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types that React provides and the DOM events they are related to are:</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 반작용 유형이 제공하고 그들이에 관련되는 DOM 이벤트는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="653be0e1cd193d42d4fa78964cd56de69b5da2cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[declarations]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to parse files matching the specified regular expressions in &lt;em&gt;declaration mode&lt;/em&gt;. In declaration mode the code is not typechecked. However, the signatures of functions, classes, etc are extracted and used by the typechecker when checking other code.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 파일 의 &lt;code&gt;[declarations]&lt;/code&gt; 섹션 은 Flow가 지정된 정규 표현식과 일치하는 파일을 &lt;em&gt;선언 모드&lt;/em&gt; 로 구문 분석하도록 지시 &lt;em&gt;합니다&lt;/em&gt; . 선언 모드에서 코드는 유형 검사되지 않습니다. 그러나 함수, 클래스 등의 서명은 다른 코드를 확인할 때 유형 검사기에 의해 추출되어 사용됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df21474ae6954ba751628a9d46d6c9512fa40f07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[ignore]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to ignore files matching the specified regular expressions when type checking your code. By default, nothing is ignored.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 파일 의 &lt;code&gt;[ignore]&lt;/code&gt; 섹션은 코드에서 형식을 확인할 때 지정된 정규식과 일치하는 파일을 무시하도록 Flow에 지시합니다. 기본적으로 아무것도 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89a1fffc651c11cf6e66838e0172e44593fd9d49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[include]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified files or directories. Including a directory recursively includes all the files under that directory. Symlinks are followed as long as they lead to a file or directory that is also included. Each line in the include section is a path to include. These paths can be relative to the root directory or absolute, and support both single and double star wildcards.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 파일 의 &lt;code&gt;[include]&lt;/code&gt; 섹션 은 지정된 파일 또는 디렉토리를 포함하도록 Flow에 지시합니다. 디렉토리를 재귀 적으로 포함하면 해당 디렉토리 아래의 모든 파일이 포함됩니다. 포함 된 파일이나 디렉토리로 연결되는 한 심볼릭 링크가 수행됩니다. 포함 섹션의 각 줄은 포함 할 경로입니다. 이 경로는 루트 디렉토리에 상대적인 경로이거나 절대 경로 일 수 있으며 단일 및 이중 별 와일드 카드를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f33fef6875ad046a3f7a76b86437d56196d9c414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[libs]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified &lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;library definitions&lt;/a&gt; when type checking your code. Multiple libraries can be specified. By default, the &lt;code&gt;flow-typed&lt;/code&gt; folder in your project root directory is included as a library directory. This default allows you to use &lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt;&lt;code&gt;flow-typed&lt;/code&gt;&lt;/a&gt; to install library definitions without additional configuration.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 파일 의 &lt;code&gt;[libs]&lt;/code&gt; 섹션은 코드에서 형식을 확인할 때 지정된 &lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;라이브러리 정의&lt;/a&gt; 를 포함하도록 Flow에 지시 합니다. 여러 라이브러리를 지정할 수 있습니다. 기본적으로 프로젝트 루트 디렉토리 의 &lt;code&gt;flow-typed&lt;/code&gt; 폴더는 라이브러리 디렉토리로 포함됩니다. 이 기본값을 사용하면 추가 구성없이 &lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt; &lt;code&gt;flow-typed&lt;/code&gt; &lt;/a&gt; 을 사용하여 라이브러리 정의를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93975a8a26491b29c7786a7d20f47e387cfa3514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[lints]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 파일 의 &lt;code&gt;[lints]&lt;/code&gt; 섹션 에는 다음과 같은 형식의 여러 키-값 쌍이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="263df81c3f42c9c4c0096bb79a58e2dee22d2326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[options]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 파일 의 &lt;code&gt;[options]&lt;/code&gt; 섹션 에는 다음과 같은 형식의 여러 키-값 쌍이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ba04249ba83fffa732ce0d0760f8ad3472a183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[untyped]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to not typecheck files matching the specified regular expressions and instead throw away types and treat modules as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 파일 의 &lt;code&gt;[untyped]&lt;/code&gt; 섹션 은 Flow에 지정된 정규식과 일치하는 파일을 검사하지 말고 대신 형식을 버리고 모듈을 &lt;code&gt;any&lt;/code&gt; 로 취급하도록 지시 합니다 .</target>
        </trans-unit>
        <trans-unit id="924f7192ca7f7c407e938ed0acd12668b4d33fbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; operator returns the Flow type of a given value to be used as a type.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 연산자는 주어진 값의 흐름 형태가 형태로 사용될 수로 복귀한다.</target>
        </trans-unit>
        <trans-unit id="67966e36f904c5d8958d761e6cb9127537aff7ef" translate="yes" xml:space="preserve">
          <source>The Asynchronous Lint Engine (ALE) plugin for Vim 8+ and NeoVim, &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt;, is a generalized linting engine with support for Flow and many other tools.</source>
          <target state="translated">Vim 8+ 및 NeoVim 용 ALE (Asynchronous Lint Engine) 플러그인 인 &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt; 은 Flow 및 기타 여러 도구를 지원하는 일반화 된 린팅 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="5183c3b41bf0492de80698dc738a05d76568f6ad" translate="yes" xml:space="preserve">
          <source>The CLI tool also provides several other options and commands that allow you to control the server and build tools that integrate with Flow. For example, this is how the &lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt; editor integrates with Flow to provide autocompletion, type errors, etc. in its UI.</source>
          <target state="translated">CLI 도구는 서버를 제어하고 Flow와 통합되는 도구를 빌드 할 수있는 몇 가지 다른 옵션과 명령도 제공합니다. 예를 들어 &lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt; 편집기가 Flow와 통합되어 UI에 자동 완성, 유형 오류 등을 제공 하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="0b12391516f21ae19dfcef64eb8647ae6924887e" translate="yes" xml:space="preserve">
          <source>The Flow background process monitors all Flow files. However, how does it know which files are Flow files and, thus, should be checked? Placing the following &lt;strong&gt;before any code&lt;/strong&gt; in a JavaScript file is the flag the process uses to answer that question.</source>
          <target state="translated">흐름 백그라운드 프로세스는 모든 흐름 파일을 모니터링합니다. 그러나 어떤 파일이 Flow 파일인지 어떻게 알 수 있으므로 확인해야합니까? JavaScript 파일에서 &lt;strong&gt;코드 앞에&lt;/strong&gt; 다음을 두는 것은 프로세스가 해당 질문에 대답하는 데 사용하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="3ea8fcfb745f317d30dab0afe405550d9490a0f7" translate="yes" xml:space="preserve">
          <source>The Flow root must be within a &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; repository.</source>
          <target state="translated">플로우 루트는 &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; 저장소 내에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="eb9d9e2a123153d996537b64730290848876d71f" translate="yes" xml:space="preserve">
          <source>The IDE needs to integrate with &lt;code&gt;flow lsp&lt;/code&gt; to tell Flow which files are open.</source>
          <target state="translated">어떤 파일이 열려 있는지 Flow에 알리 려면 IDE가 &lt;code&gt;flow lsp&lt;/code&gt; 와 통합되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="e36e3ea40dbe1430b59533dc1b80fc6036bba9ee" translate="yes" xml:space="preserve">
          <source>The JavaScript language is a bunch of object-oriented ideas and functional ideas mixed together. Developer&amp;rsquo;s usage of JavaScript tends to be mixed as well. Classes (or constructor functions) being the more object-oriented side and functions (as lambdas) and objects tend to be more on the functional side, developers use both simultaneously.</source>
          <target state="translated">JavaScript 언어는 많은 객체 지향 아이디어와 기능적 아이디어가 혼합되어 있습니다. 개발자의 JavaScript 사용도 혼합되는 경향이 있습니다. 더 객체 지향적 인 클래스 (또는 생성자 함수)와 함수 (람다) 및 객체는 기능적 측면에 더 많은 경향이 있으므로 개발자는 둘 다 동시에 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7bd394e3f7c77eaabbe75ef337cf434e120de82b" translate="yes" xml:space="preserve">
          <source>The Trivial HOC</source>
          <target state="translated">사소한 HOC</target>
        </trans-unit>
        <trans-unit id="025b59ea409d457aec020e335d2f4bc894d68ede" translate="yes" xml:space="preserve">
          <source>The ability for a static type checker to be able to tell that the value inside the if statement must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; is known as a refinement.</source>
          <target state="translated">정적 유형 검사기가 if 문의 내부 값이 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 여야 함을 알 수있는 기능을 구체화라고합니다.</target>
        </trans-unit>
        <trans-unit id="fec021ecaeba3a8ee38ad356d77c56a0bb6f13a4" translate="yes" xml:space="preserve">
          <source>The above code has a type error because Flow would also allow the call expression &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt;, because &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; is a subtype of &lt;code&gt;{bar:number}&lt;/code&gt;, one of the members of the parameter&amp;rsquo;s union type.</source>
          <target state="translated">흐름 또한 전화 발현 할 수 때문에 위의 코드는 타입 오류가 있습니다 &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt; , 때문에 &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; 의 하위 유형입니다 &lt;code&gt;{bar:number}&lt;/code&gt; , 하나의 파라미터의 결합 형의 멤버</target>
        </trans-unit>
        <trans-unit id="fe2ac4fdbea23fe269b2df48740a8fe5b6447c33" translate="yes" xml:space="preserve">
          <source>The advantage of the &lt;code&gt;$Exports&lt;/code&gt; syntax is that you can &lt;code&gt;export&lt;/code&gt; the type on the same line</source>
          <target state="translated">&lt;code&gt;$Exports&lt;/code&gt; 구문 의 장점은 동일한 행에서 유형을 &lt;code&gt;export&lt;/code&gt; 수 있다는 것입니다</target>
        </trans-unit>
        <trans-unit id="eba2348e4056127995e90c22bf6c18e156a3d1c5" translate="yes" xml:space="preserve">
          <source>The base type for Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;actions&lt;/a&gt; is an object with a &lt;code&gt;type&lt;/code&gt; property.</source>
          <target state="translated">Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;작업&lt;/a&gt; 의 기본 유형 은 &lt;code&gt;type&lt;/code&gt; 속성 이있는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="8af3b40968bb4f75f70768133b814cdf17d5d2ec" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;flowlint&lt;/code&gt; comment takes a comma-delimited list of &lt;code&gt;rule:severity&lt;/code&gt; pairs and applies those settings for the rest of the source file until overridden. This has three primary purposes: applying settings over a block, applying settings over a file, and applying settings over part of a line.</source>
          <target state="translated">기본 &lt;code&gt;flowlint&lt;/code&gt; 주석은 쉼표로 구분 된 &lt;code&gt;rule:severity&lt;/code&gt; 쌍 목록 을 사용하여 재정의 될 때까지 나머지 소스 파일에 해당 설정을 적용합니다. 이것은 블록에 설정을 적용하고, 파일에 설정을 적용하고, 라인의 일부에 설정을 적용하는 세 가지 주요 목적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f167409d5ec197b4871f95c5db2fcf7f6bbd5cd2" translate="yes" xml:space="preserve">
          <source>The body of these predicate functions need to be expressions (i.e. local variable declarations are not supported). But it&amp;rsquo;s possible to call other predicate functions inside a predicate function. For example:</source>
          <target state="translated">이 술어 함수의 본문은 표현식이어야합니다 (즉, 지역 변수 선언은 지원되지 않습니다). 그러나 술어 함수 내에서 다른 술어 함수를 호출 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="182510f68d230df9a3e633ed8ee2db47f5bc405d" translate="yes" xml:space="preserve">
          <source>The core benefit to Flow is its ability to quickly check your code for errors. Once you have enabled your project for Flow, you can start the process that allows Flow to check your code incrementally and with great speed.</source>
          <target state="translated">Flow의 주요 이점은 코드에서 오류를 신속하게 확인할 수 있다는 것입니다. Flow에 대해 프로젝트를 활성화하면 Flow가 코드를 점진적으로 빠른 속도로 확인할 수있는 프로세스를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7197940d208092be8c8d13b858faffa50044428" translate="yes" xml:space="preserve">
          <source>The decision of which direction to apply the subtyping rule on inputs and outputs is governed by variance, which is the topic of the next section.</source>
          <target state="translated">입력 및 출력에 서브 타이핑 규칙을 적용 할 방향 결정은 다음 섹션의 주제 인 분산에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff505957015ad603cc74c9be6c56afdb90f26dc" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;node&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="684bf3ea595241d58aa0cbec92715b88590f0f96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; 의 기본값 은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dcc51d57d4a016ea1192824513bdb37f918f5d3a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;babel_loose_array_spread&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel_loose_array_spread&lt;/code&gt; 의 기본값 은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3320966c1ed05d8e92be8263eb0872986cd5b9d" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;emoji&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emoji&lt;/code&gt; 의 기본값 은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4b4c401e7d77aa94ed0f3d78556a2ab12605661" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;/tmp/flow&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;/tmp/flow&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d1dcc6b3a394539acf783a764b41f856bcb2ec9" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a6f3086f6053ea99056f8787ec9e3c7714223a" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="385f9197e267dca024cc7c5ee266ab77c07dd86b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;max_header_tokens&lt;/code&gt; is 10.</source>
          <target state="translated">&lt;code&gt;max_header_tokens&lt;/code&gt; 의 기본값 은 10입니다.</target>
        </trans-unit>
        <trans-unit id="4afe27211cbc9af6d345271f3bd53dcd4c074b64" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;enable&lt;/code&gt;, which allows use of this proposed syntax.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;enable&lt;/code&gt; 이며 제안 된 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a26010ceb723197e0f6ed4ccf098b594327ee9" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;warn&lt;/code&gt; 이며,이 제안은 아직 초기 단계이므로 사용에 대한 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4804a2b774fe8e16ad5ee7fbc61053dc05f70f20" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; 의 정의 는 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3087bc731ef3517a427cf5c4e5203623cadca99" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ElementType&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.ElementType&lt;/code&gt; 의 정의 는 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e617c1ee84ca2ef49a14a0c500b7bf9f6b27172" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 의 정의 는 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2c72eeedacf538eae7405dbd87fe7965700eed1" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; 의 정의 는 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67931b95c973afece9e67ea2abaeb942c4811eaf" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;React.Node&lt;/code&gt; can be roughly approximated with a &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;React.Node&lt;/code&gt; 의 정의는 React.ChildrenArray &lt;a href=&quot;#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 로 대략적으로 추정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65be16845f607fa6de2868121655dbf19d303167" translate="yes" xml:space="preserve">
          <source>The design decision in Flow around mixing nominal and structural typing was chosen based on how objects, functions, and classes are already used in JavaScript.</source>
          <target state="translated">공칭 및 구조적 타이핑을 혼합하는 Flow에서의 디자인 결정은 객체, 함수 및 클래스가 JavaScript에서 이미 사용되는 방식에 따라 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="29d2d625710fa5cd0abd9e50046510b51fb847f2" translate="yes" xml:space="preserve">
          <source>The example above could not be accomplished without the &lt;code&gt;+&lt;/code&gt; variance sigil:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 분산시길 이 없으면 위의 예제를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="569e13c9d22dc97266745256891834efe9cb254b" translate="yes" xml:space="preserve">
          <source>The first time this is run, the &lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; will be spawned and all of your Flow files will be checked. Then, as you continue to iterate on your project, the background process will continuously monitor your code such that when you run &lt;code&gt;flow&lt;/code&gt; again, the updated result will be near instantaneous.</source>
          <target state="translated">처음 실행하면 &lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;플로우 백그라운드 프로세스&lt;/a&gt; 가 생성되고 모든 플로우 파일이 확인됩니다. 그런 다음 프로젝트에서 계속 반복하면 백그라운드 프로세스가 &lt;code&gt;flow&lt;/code&gt; 다시 실행할 때 업데이트 된 결과가 거의 즉각적으로 되도록 코드를 지속적으로 모니터링합니다 .</target>
        </trans-unit>
        <trans-unit id="f48e199f3e1c2873fac5e329e515e0affa5734d6" translate="yes" xml:space="preserve">
          <source>The fix here is to add types to the parameters of &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">여기서 수정은 add 매개 변수에 유형을 &lt;code&gt;add&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="decaa6f4bcdc1dd98facfb522a07ee0290e90e6a" translate="yes" xml:space="preserve">
          <source>The flow command line tool is made to be easy-to-use for simple cases.</source>
          <target state="translated">흐름 명령 줄 도구는 간단한 경우에 사용하기 쉽게 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="568d41ac14b4b2796ccd853ff99f7c7a730490f8" translate="yes" xml:space="preserve">
          <source>The following are functionally equivalent</source>
          <target state="translated">다음은 기능적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="10e5012640308970d1812cdfc15f495ee3f6ea82" translate="yes" xml:space="preserve">
          <source>The function argument allows &lt;code&gt;string&lt;/code&gt; values in its field, but in this case Flow prevents the original object from having a &lt;code&gt;number&lt;/code&gt; written to it. Within the body of the function you would be able to mutate the object so that the property &lt;code&gt;a&lt;/code&gt; would receive a &lt;code&gt;number&lt;/code&gt;, causing the type of the original object to no longer be accurate. You can fix this error by making the property covariant (read-only): &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt;. This prevents the function body from writing to the property, making it safe to pass more restricted types to the function.</source>
          <target state="translated">함수 인수는 필드에 &lt;code&gt;string&lt;/code&gt; 값을 허용 하지만이 경우 흐름은 원래 객체에 &lt;code&gt;number&lt;/code&gt; 기록되지 않도록합니다. 함수 본문 내에서 객체 a를 변경하여 속성 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;number&lt;/code&gt; 받도록 하여 원래 객체의 유형이 더 이상 정확하지 않게 할 수 있습니다. 속성을 공변량 (읽기 전용)으로 만들어이 오류를 해결할 수 있습니다. &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt; 입니다. 이렇게하면 함수 본문이 속성에 쓰지 못하게되어 더 제한된 형식을 함수에 안전하게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2155dfc51f926d913a644cc3de06c804ab01b2ad" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s argument allows &lt;code&gt;string&lt;/code&gt; values in its array, but in this case Flow prevents the original array from receiving a &lt;code&gt;number&lt;/code&gt;. Inside the function, you would be able to push a &lt;code&gt;number&lt;/code&gt; to the argument array, causing the type of the original array to no longer be accurate. You can fix this error by changing the type of the argument to &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;. This prevents the function body from pushing anything to the array, allowing it to accept narrower types.</source>
          <target state="translated">이 함수의 인수는 배열에 &lt;code&gt;string&lt;/code&gt; 값을 허용 하지만이 경우 Flow는 원래 배열이 &lt;code&gt;number&lt;/code&gt; 를받지 못하게합니다 . 함수 내에서 &lt;code&gt;number&lt;/code&gt; 를 인수 배열 로 푸시 하여 원래 배열의 유형이 더 이상 정확하지 않게 할 수 있습니다. 인수 유형을 &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt; 으로 변경하여이 오류를 해결할 수 있습니다. 숫자&amp;gt; . 이것은 함수 몸체가 어떤 것을 배열로 밀지 못하게하여 더 좁은 유형을 수용 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="63f89c1777909f20b429c72e0ff7ec4f5852765d" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s purpose is to run all the thunks and return an object made of values. What&amp;rsquo;s the return type of this function?</source>
          <target state="translated">이 함수의 목적은 모든 썽크를 실행하고 값으로 구성된 객체를 반환하는 것입니다. 이 함수의 반환 유형은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c023f83d766bac37fd8c93749ac0588a01c18d3d" translate="yes" xml:space="preserve">
          <source>The great thing about Flow is that you can get near real-time feedback on the state of your code. At any point that you want to check for errors, just run:</source>
          <target state="translated">Flow의 가장 큰 장점은 코드 상태에 대한 거의 실시간 피드백을 얻을 수 있다는 것입니다. 오류를 확인하려는 경우 언제든지 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1d3a896ebf3c8fbb9102531fb367809a43a70216" translate="yes" xml:space="preserve">
          <source>The idea of using types to manage code evolution and growth in JavaScript (and related languages) is not new. In fact, several useful type systems have been built for JavaScript in recent years. However, type systems differ in their goals. On one end of the spectrum are permissive type systems that provide some degree of linting against likely errors, without regard for correctness. On the other end of the spectrum are restrictive type systems that can guarantee the correctness of static code optimizations, at the cost of interoperability. Another area that has not seen a lot of focus is the performance of type checking itself.</source>
          <target state="translated">JavaScript (및 관련 언어)에서 코드 진화 및 성장을 관리하기 위해 유형을 사용한다는 아이디어는 새로운 것이 아닙니다. 실제로, 최근 몇 년 동안 JavaScript를 위해 몇 가지 유용한 유형 시스템이 구축되었습니다. 그러나 유형 시스템의 목표는 다릅니다. 스펙트럼의 한쪽 끝에는 정확성에 관계없이 오류 가능성에 대해 어느 정도의 보풀을 제공하는 허용 유형 시스템이 있습니다. 스펙트럼의 다른 쪽 끝에는 상호 운용성 비용으로 정적 코드 최적화의 정확성을 보장 할 수있는 제한적 유형 시스템이 있습니다. 집중하지 않은 또 다른 영역은 유형 검사 자체의 성능입니다.</target>
        </trans-unit>
        <trans-unit id="895222166e3067cff8bd88b8a774d6ab00fde9e2" translate="yes" xml:space="preserve">
          <source>The inferred type of the property becomes what you set it to.</source>
          <target state="translated">유추 된 속성 유형이 설정 한 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="e551fea41cfe91f78e0d3bfde3174c0c4fa76ec7" translate="yes" xml:space="preserve">
          <source>The key to Flow&amp;rsquo;s speed is modularity: the ability to break the analysis into file-sized chunks that can be assembled later.</source>
          <target state="translated">Flow 속도의 핵심은 모듈화입니다. 분석을 파일 크기의 덩어리로 나눌 수있어 나중에 조립할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef6ba2b0cdf8e98a8b5dce1cdbd0afc335063144" translate="yes" xml:space="preserve">
          <source>The keys are the same, but the values have a different type, namely the return type of each function. At a value level (the implementation of the function) we&amp;rsquo;re essentially mapping over the object to produce new values for the keys. How to express this at a type level?</source>
          <target state="translated">키는 동일하지만 값의 유형이 다릅니다. 즉 각 기능의 반환 유형입니다. 값 수준 (함수 구현)에서 본질적으로 객체에 매핑하여 키의 새로운 값을 생성합니다. 이것을 타입 레벨로 표현하는 방법?</target>
        </trans-unit>
        <trans-unit id="92ccbfce1a4e920f5d1758fbdebfc31032b257d4" translate="yes" xml:space="preserve">
          <source>The length of the tuple is known as the &amp;ldquo;arity&amp;rdquo;. The length of a tuple is strictly enforced in Flow.</source>
          <target state="translated">튜플의 길이는 &quot;arity&quot;로 알려져 있습니다. 튜플의 길이는 Flow에서 엄격하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="647cfb5d0aaa8b82192bbb83417ad5b3177c198f" translate="yes" xml:space="preserve">
          <source>The lint settings parser is fairly intelligent and will stop you if you write a redundant rule, a rule that gets completely overwritten, or an unused suppression. This should prevent most accidental misconfigurations of lint rules.</source>
          <target state="translated">보푸라기 설정 파서는 상당히 지능적이며 중복 규칙, 완전히 덮어 쓰는 규칙 또는 사용되지 않은 억제를 작성하면 중지됩니다. 이렇게하면 대부분의 실수로 보푸라기 규칙을 잘못 구성하는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f02d9fd7d48002b88a676cb504a249985d85238a" translate="yes" xml:space="preserve">
          <source>The location of the &lt;code&gt;.flowconfig&lt;/code&gt; is significant. Flow treats the directory that contains the &lt;code&gt;.flowconfig&lt;/code&gt; as the &lt;em&gt;project root&lt;/em&gt;. By default Flow includes all the source code under the project root. The paths in the &lt;a href=&quot;include&quot;&gt;[include] section&lt;/a&gt; are relative to the project root. Some other configuration also lets you reference the project root via the macro &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 의 위치 가 중요합니다. Flow는 &lt;code&gt;.flowconfig&lt;/code&gt; 를 포함하는 디렉토리를 &lt;em&gt;프로젝트 루트&lt;/em&gt; 로 취급합니다 . 기본적으로 Flow에는 프로젝트 루트 아래의 모든 소스 코드가 포함됩니다. &lt;a href=&quot;include&quot;&gt;[include] 섹션&lt;/a&gt; 의 경로 는 프로젝트 루트를 기준으로합니다. 다른 일부 구성에서는 매크로 &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; 를 통해 프로젝트 루트를 참조 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88b94dfde96af7809cecaa352baf181b5eb93f8e" translate="yes" xml:space="preserve">
          <source>The main advantage to using &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead of &lt;code&gt;Array&lt;/code&gt; is that &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;covariant&lt;/em&gt; while &lt;code&gt;Array&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;invariant&lt;/em&gt;. That means that &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; is a subtype of &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; while &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; is NOT a subtype of &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt;. So it&amp;rsquo;s often useful to use &lt;code&gt;$ReadOnlyArray&lt;/code&gt; in type annotations for arrays of various types of elements. Take, for instance, the following scenario:</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 대신 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 를 사용하는 주요 이점 은 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 의 유형 매개 변수는 &lt;em&gt;공변량&lt;/em&gt; 이고 &lt;code&gt;Array&lt;/code&gt; 의 유형 매개 변수는 &lt;em&gt;변하지 않는다는 것&lt;/em&gt; 입니다. 이는 &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; 가 &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; 의 하위 유형 임을 의미합니다. string&amp;gt; 동안 &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; 는 Array &amp;lt;number 의 하위 유형이 아닙니다 &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt; . 따라서 다양한 유형의 요소 배열에 대한 유형 주석에 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 를 사용하는 것이 종종 유용합니다 . 예를 들어 다음 시나리오를 보자.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="641f626a5da92cffb82099b03123b4b7495ce303" translate="yes" xml:space="preserve">
          <source>The main difference with &lt;a href=&quot;#toc-diff&quot;&gt;&lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt;&lt;/a&gt;, is that &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; aims to represent the true runtime rest operation, which implies that exact object types are treated differently in &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n?:number|}&lt;/code&gt; because an in-exact empty object may have an &lt;code&gt;n&lt;/code&gt; property, while &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n:number|}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-diff&quot;&gt; &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; &lt;/a&gt; 와의 주요 차이점 은 &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; 는 실제 런타임 휴식 작업을 나타 내기위한 것입니다. 이는 정확한 객체 유형이 &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; 에서 다르게 취급됨을 의미합니다 . 예를 들어 &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; 는 정확하지 않은 빈 객체에 &lt;code&gt;n&lt;/code&gt; 속성 이있을 수 있고 &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; 있기 때문에 &lt;code&gt;{|n?:number|}&lt;/code&gt; 가됩니다 . |}, {}&amp;gt; 는 &lt;code&gt;{|n:number|}&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7bbdc2ea29d0148a224653e3dc437fe724818563" translate="yes" xml:space="preserve">
          <source>The maximum number of workers the Flow server can start. By default, the server will use all available cores.</source>
          <target state="translated">플로우 서버가 시작할 수있는 최대 작업자 수입니다. 기본적으로 서버는 사용 가능한 모든 코어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2288b72b1f95feec127ed704e5e991f5ea4c03bb" translate="yes" xml:space="preserve">
          <source>The module system to use to resolve &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt;. &lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;Haste&lt;/a&gt; is used in React Native.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 를 &lt;code&gt;require&lt;/code&gt; 하고 요구 하는 데 사용할 모듈 시스템 . &lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;가속&lt;/a&gt; 은 React Native에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ccdab5f7410661918848aa1e2e6bf4bba7ef93d" translate="yes" xml:space="preserve">
          <source>The most common case you&amp;rsquo;ll encounter is when exporting a function or React component. Flow requires you to annotate inputs. For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;example&lt;/a&gt;, flow will complain:</source>
          <target state="translated">가장 일반적인 경우는 함수 또는 React 컴포넌트를 내보낼 때입니다. 흐름에는 입력에 주석을 달아야합니다. 예를 들어이 &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;예&lt;/a&gt; 에서 흐름은 다음과 같이 불평합니다.</target>
        </trans-unit>
        <trans-unit id="1d256527f1fd7c67fd36002480923ad5cedc2e90" translate="yes" xml:space="preserve">
          <source>The name specified in quotes after &lt;code&gt;declare module&lt;/code&gt; can be any string, but it should correspond to the same string you&amp;rsquo;d use to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the third-party module into your project. For defining modules that are accessed via a relative &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt; path, please see the docs on the &lt;a href=&quot;https://flow.org/en/declarations&quot;&gt;&lt;code&gt;.flow&lt;/code&gt; files&lt;/a&gt;</source>
          <target state="translated">후 따옴표에 지정된 이름을 &lt;code&gt;declare module&lt;/code&gt; 임의의 문자열이 될 수 있지만, 그것은 당신이하는 데 사용하는 것과 동일한 문자열 일치해야합니다 &lt;code&gt;require&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 프로젝트에 타사 모듈을. 상대 &lt;code&gt;require&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; 경로 를 통해 액세스되는 모듈을 정의 하려면 &lt;a href=&quot;https://flow.org/en/declarations&quot;&gt; &lt;code&gt;.flow&lt;/code&gt; &lt;/a&gt; 파일 의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fee97a1aa5d0e2a829b605bdbaea327f2fcfbd4f" translate="yes" xml:space="preserve">
          <source>The path to the log file (defaults to &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt;).</source>
          <target state="translated">로그 파일의 경로 (기본값은 &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="6028aa8c33369bd6d14f531cdbe045d2ca494cce" translate="yes" xml:space="preserve">
          <source>The plus sign indicates that the &lt;code&gt;who&lt;/code&gt; property is &amp;ldquo;covariant.&amp;rdquo; Using a covariant property allows us to use objects which have subtype-compatible values for that property. By default, object properties are invariant, which allow both reads and writes, but are more restrictive in the values they accept.</source>
          <target state="translated">더하기 부호는 &lt;code&gt;who&lt;/code&gt; 속성이 &quot;공변량&quot; 임을 나타냅니다 . 공변량 속성을 사용하면 해당 속성에 대해 하위 유형 호환 값을 가진 개체를 사용할 수 있습니다. 기본적으로 객체 속성은 변하지 않으므로 읽기와 쓰기가 모두 가능하지만 허용되는 값이 더 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="8b6e43a14a66d8e57ad3388723dad2315e2002cc" translate="yes" xml:space="preserve">
          <source>The primitive types appear in the language as either literal values.</source>
          <target state="translated">기본 유형은 언어에서 리터럴 값으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fbcdf34cda6e03181b88966618eea724fde6c716" translate="yes" xml:space="preserve">
          <source>The project root directory (where your &lt;code&gt;.flowconfig&lt;/code&gt; lives) is automatically included.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 가 있는 프로젝트 루트 디렉토리 가 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="28bebee27e53966722fe139f706cf86a64136098" translate="yes" xml:space="preserve">
          <source>The reason for this is that we don&amp;rsquo;t know that &lt;code&gt;otherMethod()&lt;/code&gt; hasn&amp;rsquo;t done something to our value. Imagine the following scenario:</source>
          <target state="translated">그 이유는 &lt;code&gt;otherMethod()&lt;/code&gt; 가 우리의 가치에 무언가를 하지 않았다는 것을 모르기 때문 입니다. 다음 시나리오를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="dcdaec4a5e807c4478cc1b0eb9fd497d6c728c78" translate="yes" xml:space="preserve">
          <source>The ref function will take one and only argument which will be the element instance which is retrieved using &lt;a href=&quot;#toc-react-elementref&quot;&gt;&lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; or null since &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;React will pass null into a ref function when unmounting&lt;/a&gt;.</source>
          <target state="translated">ref 함수는 &lt;a href=&quot;#toc-react-elementref&quot;&gt; &lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt; 사용하여 검색되는 요소 인스턴스가 될 유일한 인수를 취 하거나 &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;마운트 해제 할 때 React가 ref 함수에 null을 전달&lt;/a&gt; 하므로 null 입니다.</target>
        </trans-unit>
        <trans-unit id="5ec9470d19e8edaa8b9faed31b8b1054cafb7447" translate="yes" xml:space="preserve">
          <source>The rule to remember with React children is that if you have no children then &lt;code&gt;props.children&lt;/code&gt; will not be set, if you have one single child then &lt;code&gt;props.children&lt;/code&gt; will be set to exactly that value, and if you have two or more children then &lt;code&gt;props.children&lt;/code&gt; will be a new array of those values.</source>
          <target state="translated">React 자녀와 함께 기억해야 할 규칙은 자녀가 없으면 &lt;code&gt;props.children&lt;/code&gt; 이 설정되지 않고 하나의 자녀가있는 경우 &lt;code&gt;props.children&lt;/code&gt; 이 정확히 그 값으로 설정되며 둘 이상의 자녀가있는 경우 &lt;code&gt;props.children&lt;/code&gt; 은 이러한 값의 새로운 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6cae9d717814c0ee942c2f77703ca8ec47aca7" translate="yes" xml:space="preserve">
          <source>The second is when the left-hand-side could be nullish, but the short-circuiting behavior of &lt;code&gt;?.&lt;/code&gt; is sufficient to handle it anyway:</source>
          <target state="translated">두 번째는 왼쪽이 무효가 될 수 있지만 단락 동작은 &lt;code&gt;?.&lt;/code&gt; 어쨌든 그것을 처리하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="dd5b733400ddf864761d4b603d7eedbf4fe23de9" translate="yes" xml:space="preserve">
          <source>The solution here is to move the if check in the &lt;code&gt;forEach&lt;/code&gt;, or to assign the &lt;code&gt;age&lt;/code&gt; to an intermediate variable.</source>
          <target state="translated">여기에 해결책은에 있는지 확인을 이동하는 것입니다 &lt;code&gt;forEach&lt;/code&gt; , 또는 할당 &lt;code&gt;age&lt;/code&gt; 중간 변수.</target>
        </trans-unit>
        <trans-unit id="793214c4162efec809460a089d3515988a580153" translate="yes" xml:space="preserve">
          <source>The syntax of the block matches the syntax of object types and has all of the same features.</source>
          <target state="translated">블록의 구문은 객체 유형의 구문과 일치하며 동일한 기능을 모두 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cfb3fe3a8ca2679172f7460529c617ce30b2448" translate="yes" xml:space="preserve">
          <source>The type for &lt;code&gt;children&lt;/code&gt; is a function that takes in some object type and returns a &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; which is the type for any value that can be rendered by React. A &lt;code&gt;children&lt;/code&gt; function does not need to return &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;. It could return any type, but in this case &lt;code&gt;react-router&lt;/code&gt; wants to render the result returned by the &lt;code&gt;children&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; 유형 은 일부 객체 유형을 가져 와서 React에서 렌더링 할 수있는 모든 값의 유형 인 &lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 를 반환하는 함수 입니다. &lt;code&gt;children&lt;/code&gt; 기능은 반환 할 필요가 없다 &lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; 을&lt;/a&gt; . 모든 유형을 리턴 할 수 있지만이 경우 &lt;code&gt;react-router&lt;/code&gt; 는 &lt;code&gt;children&lt;/code&gt; 함수가 리턴 한 결과를 렌더링하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="e26f0c3b68e62adaf93121b472c68d0c8f76d159" translate="yes" xml:space="preserve">
          <source>The type of the &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;ref prop on React elements&lt;/a&gt;. &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; could be a string or a ref function.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;React 요소&lt;/a&gt; 의 참조 소품 유형입니다 . &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; 는 문자열 또는 ref 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4218f62d2ad5c72e63a98ec879dc92c04a46ac00" translate="yes" xml:space="preserve">
          <source>The type of the key prop on React elements. It is a union of strings and numbers defined as:</source>
          <target state="translated">React 요소의 주요 소품 유형입니다. 다음과 같이 정의 된 문자열과 숫자의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="9d3cd96ca03492da9df4ce4513f536c1b74f86f6" translate="yes" xml:space="preserve">
          <source>The type-specific variants are useful for specifying that some types of sketchy null checks are acceptable while others should be errors/warnings. For example, if you want to allow boolean sketchy null checks (for the pattern of treating undefined optional booleans as false) but forbid other types of sketchy null checks, you can do so with this &lt;code&gt;.flowconfig&lt;/code&gt;&lt;code&gt;[lints]&lt;/code&gt; section:</source>
          <target state="translated">유형별 변형은 일부 유형의 스케치 null 검사가 허용되는 반면 다른 유형은 오류 / 경고가되도록 지정하는 데 유용합니다. 예를 들어, 정의되지 않은 선택적 부울을 false로 처리하는 패턴에 대해 부울 스케치 널 검사를 허용하지만 다른 유형의 스케치 널 검사를 금지하려면이 &lt;code&gt;.flowconfig&lt;/code&gt; &lt;code&gt;[lints]&lt;/code&gt; 섹션을 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6e42194738022b79f11b671ad7ae0139eab4cfde" translate="yes" xml:space="preserve">
          <source>The value itself can also be an expression:</source>
          <target state="translated">값 자체는 표현식 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9386266d754633b2348817655aa4135672d2a80" translate="yes" xml:space="preserve">
          <source>The workaround here might be to turn your object into an &lt;em&gt;unsealed object&lt;/em&gt;.</source>
          <target state="translated">여기서 해결 방법은 객체를 &lt;em&gt;봉인되지 않은 객체&lt;/em&gt; 로 바꾸는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6ba1aa455c617f9487799c55083af5aee022c88f" translate="yes" xml:space="preserve">
          <source>Then Flow will instead look for the file extensions &lt;code&gt;.foo&lt;/code&gt; and &lt;code&gt;.bar&lt;/code&gt;.</source>
          <target state="translated">그런 다음 Flow는 대신 파일 확장자 &lt;code&gt;.foo&lt;/code&gt; 및 &lt;code&gt;.bar&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="16315533799a2def071bace787cce1d7a9a11029" translate="yes" xml:space="preserve">
          <source>Then Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; or &lt;code&gt;custom_node_modules&lt;/code&gt;.</source>
          <target state="translated">그런 다음 Flow는 &lt;code&gt;node_modules&lt;/code&gt; 또는 &lt;code&gt;custom_node_modules&lt;/code&gt; 디렉토리를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="5a695f40c07e9301bce62dd550ff93b6b48cf54b" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;flow&lt;/code&gt; to your Babel presets config.</source>
          <target state="translated">그런 다음 Babel 사전 설정 구성 에 &lt;code&gt;flow&lt;/code&gt; 을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="bbfbb8a4c24c2122ec36dde61b7e1b8b853e31ea" translate="yes" xml:space="preserve">
          <source>Then to type a thunk action creator, add a return type of a &lt;code&gt;ThunkAction&lt;/code&gt; to your action creator.</source>
          <target state="translated">그런 다음 thunk action creator를 입력하려면 &lt;code&gt;ThunkAction&lt;/code&gt; 의 리턴 유형을 action creator에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="2d95f939b9b75dc6ef39e9b74bf9e89365c8618f" translate="yes" xml:space="preserve">
          <source>Then to type the action creator, just add a return type of the appropriate action.</source>
          <target state="translated">그런 다음 액션 생성자를 입력하려면 적절한 액션의 반환 유형을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8d0d1639f463f57d4ca23faf1c9cada63360b1c0" translate="yes" xml:space="preserve">
          <source>Then when Flow checks the project in &lt;code&gt;/path/to/root&lt;/code&gt;, it will read and watch</source>
          <target state="translated">그런 다음 Flow가 &lt;code&gt;/path/to/root&lt;/code&gt; 에서 프로젝트를 확인할 때 읽고 감시합니다.</target>
        </trans-unit>
        <trans-unit id="5d4c41383342278b4baf1bc8936c93b77b60516b" translate="yes" xml:space="preserve">
          <source>There are a number of different places where generic types appear in syntax.</source>
          <target state="translated">제네릭 형식이 구문에 나타나는 여러 다른 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="416eb69d14d7c0984bf388d12cfb15f4c4cb73f0" translate="yes" xml:space="preserve">
          <source>There are also more specific synthetic event types like &lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types all take a single type argument. The type of the HTML element the event handler was placed on.</source>
          <target state="translated">&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은보다 구체적인 합성 이벤트 유형도 있습니다. &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 모든 단일 유형의 인수를. 이벤트 핸들러가있는 HTML 요소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1787b085e796793d008332b01f6a6da8bb5275b0" translate="yes" xml:space="preserve">
          <source>There are many different types in Flow, some of these types behave differently than others. These differences make sense for that particular type but not for others.</source>
          <target state="translated">Flow에는 여러 유형이 있으며 이러한 유형 중 일부는 다른 유형과 다르게 작동합니다. 이러한 차이점은 특정 유형에는 적합하지만 다른 유형에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf3db35b680beed72ddb758d9747774831b6fb79" translate="yes" xml:space="preserve">
          <source>There are only a couple of scenarios where you might consider using &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">다음 중 하나를 사용 &lt;code&gt;any&lt;/code&gt; 것을 고려할 수있는 몇 가지 시나리오가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6aaa00344637c45d30679cf3abd801a1db746b96" translate="yes" xml:space="preserve">
          <source>There are other cases where this happens, and they might be harder to understand. You&amp;rsquo;ll get an error like &lt;code&gt;Missing type annotation for U&lt;/code&gt; For instance, you wrote this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;code&lt;/a&gt;:</source>
          <target state="translated">다른 경우가 있으며 이해하기 어려울 수 있습니다. &lt;code&gt;Missing type annotation for U&lt;/code&gt; 대한 형식 주석 누락 과 같은 오류가 발생합니다. 예를 들어 다음 &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;코드&lt;/a&gt; 를 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="d4e04cbaf68e5bad49ef31cbab0ae229a010af35" translate="yes" xml:space="preserve">
          <source>There are some Babel plugins which will generate &lt;code&gt;PropTypes&lt;/code&gt; from Flow types such as &lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt;&lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt;&lt;/a&gt; if you want both static and runtime checks.</source>
          <target state="translated">정적 및 런타임 검사를 모두 원할 경우 &lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt; &lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt; &lt;/a&gt; 와 같은 Flow 유형에서 &lt;code&gt;PropTypes&lt;/code&gt; 을 생성하는 일부 Babel 플러그인이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05f1bf8a574169e2b0cbcee1bdb8f70d3d1115e5" translate="yes" xml:space="preserve">
          <source>There are three forms of functions that each have their own slightly different syntax.</source>
          <target state="translated">각각 고유 한 구문이 다른 세 가지 형태의 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e2987ad3c65445a4b5f525f040f6b2d00300b6c" translate="yes" xml:space="preserve">
          <source>There are two possible use cases, depending on whether an implementation file exists or not.</source>
          <target state="translated">구현 파일의 존재 여부에 따라 두 가지 가능한 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc6225a3f37590ec533fb885e85a5169bfedf04f" translate="yes" xml:space="preserve">
          <source>There are two potential reasons:</source>
          <target state="translated">두 가지 잠재적 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc65a65476288080ee29ba1be6fd72bb6d6711c0" translate="yes" xml:space="preserve">
          <source>There are two primary pieces of the syntax: type includes and type annotations.</source>
          <target state="translated">구문에는 두 가지 기본 구문이 있습니다 : 유형 포함 및 유형 주석.</target>
        </trans-unit>
        <trans-unit id="dcd202d61a19f5fccfdf0c23e9bd5cbafd620669" translate="yes" xml:space="preserve">
          <source>There are two ways which Flow can use to tell which files the user cares about.</source>
          <target state="translated">Flow가 사용자가 관심있는 파일을 알려주는 데 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5471e40283f41215cba92d35f5766a72606428" translate="yes" xml:space="preserve">
          <source>There is a little bit more to the definition of &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; for context and props.</source>
          <target state="translated">문맥과 소품에 대한 &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; 의 정의에는 조금 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1108b33f08694a9173b9d3961f8db88797e3f6" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special type of union in Flow known as a &amp;ldquo;disjoint union&amp;rdquo; which can be used in &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinements&lt;/a&gt;. These disjoint unions are made up of any number of object types which are each tagged by a single property.</source>
          <target state="translated">Flow에는 &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;구체화에&lt;/a&gt; 사용할 수있는 &quot;disjoint union&quot;이라고하는 특별한 유형의 공용체가 있습니다 . 이 분리 된 공용체는 각각 단일 속성으로 태그가 지정된 여러 개체 유형으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b519d9ef0909b18ff9e1aa56c6579a08789cbdf3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a straightforward way to get around this. Store the value before calling another method and use the stored value instead. This way you can prevent the refinement from invalidating.</source>
          <target state="translated">이 문제를 해결하는 간단한 방법이 있습니다. 다른 메소드를 호출하기 전에 값을 저장하고 대신 저장된 값을 사용하십시오. 이렇게하면 구체화가 무효화되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5932b1e94eef91ff83b30936f3c0165f2887a0a9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a slightly shorter form of this syntax: &lt;code&gt;Type[]&lt;/code&gt;.</source>
          <target state="translated">이 구문에는 약간 더 짧은 형식도 있습니다 : &lt;code&gt;Type[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33c60a371f4bbf35c4a6734c388e9cc2e847eac" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;.</source>
          <target state="translated">이것들은 &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml 정규식&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf1350e4fbb26ae0f7f95072f456f487f37767ce" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;. Use &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; (slashes required!) to create a capturing group, which you can refer to in the replacement pattern as &lt;code&gt;\1&lt;/code&gt; (up to &lt;code&gt;\9&lt;/code&gt;).</source>
          <target state="translated">이것들은 &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml 정규식&lt;/a&gt; 입니다. 사용 &lt;code&gt;\(&lt;/code&gt; 와 &lt;code&gt;\)&lt;/code&gt; (슬래시 필요!) 당신 같은 대체 패턴을 참조 할 수 있습니다 캡처 그룹, 생성하는 &lt;code&gt;\1&lt;/code&gt; (최대 &lt;code&gt;\9&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="973bfa9d37cd36bbc104342639ed6decfd34c64c" translate="yes" xml:space="preserve">
          <source>These comments allow Flow to work in plain JavaScript files without any additional work.</source>
          <target state="translated">이러한 주석을 통해 Flow는 추가 작업없이 일반 JavaScript 파일로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d93265fc7d47ba2359b8e8723579e2877162a149" translate="yes" xml:space="preserve">
          <source>These regular expressions match against absolute paths. They probably should start with &lt;code&gt;.*&lt;/code&gt;</source>
          <target state="translated">이 정규식은 절대 경로와 일치합니다. 아마도 &lt;code&gt;.*&lt;/code&gt; 로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e82167070fabc30781330eea12f26f96e5cc3459" translate="yes" xml:space="preserve">
          <source>These special files use the same &lt;code&gt;.js&lt;/code&gt; extension as normal JS code, but they are placed in a directory called &lt;code&gt;flow-typed&lt;/code&gt; in the root directory of your project. Placement in this directory tells Flow to interpret them as libdefs rather than normal JS files.</source>
          <target state="translated">이 특수 파일 은 일반 JS 코드 와 동일한 &lt;code&gt;.js&lt;/code&gt; 확장자를 사용 하지만 프로젝트의 루트 디렉토리에 &lt;code&gt;flow-typed&lt;/code&gt; 디렉토리에 있습니다. 이 디렉토리에 배치하면 일반적인 JS 파일이 아닌 libdef로 해석하도록 Flow에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="420387e05d0ef5c191c2b528df67882573697852" translate="yes" xml:space="preserve">
          <source>These three are the most common categories of types. They will make up the majority of the types you&amp;rsquo;ll be writing.</source>
          <target state="translated">이 세 가지 유형이 가장 일반적인 범주입니다. 그들은 당신이 쓸 유형의 대부분을 구성 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="521ca96243c563b5695a0817345b1aaac530fbea" translate="yes" xml:space="preserve">
          <source>These type aliases can be used anywhere a type can be used.</source>
          <target state="translated">이러한 유형 별명은 유형을 사용할 수있는 모든 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c735f166579e7b6a2b1df8b0b57996603576f1" translate="yes" xml:space="preserve">
          <source>These types are all exported as named type exports from the &lt;code&gt;react&lt;/code&gt; module. If you want to access them as members on the &lt;code&gt;React&lt;/code&gt; object (e.g. &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt;&lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt;&lt;/a&gt;) and you are importing React as an ES module then you should import &lt;code&gt;React&lt;/code&gt; as a namespace:</source>
          <target state="translated">이러한 유형은 모두 &lt;code&gt;react&lt;/code&gt; 모듈 에서 명명 된 유형 내보내기로 내보내집니다 . &lt;code&gt;React&lt;/code&gt; 객체 (예 : &lt;a href=&quot;#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt; &lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt; &lt;/a&gt; ) 에서 멤버로 액세스하고 React를 ES 모듈로 가져 오려면 &lt;code&gt;React&lt;/code&gt; 를 네임 스페이스로 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="38dbce068fe67847b4312ef7a49844b1a3730edb" translate="yes" xml:space="preserve">
          <source>These unknown types are less common, but are still useful at times.</source>
          <target state="translated">이 알려지지 않은 유형은 덜 일반적이지만 여전히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="630fbbe3db84f8cd1f22f033444bd46fd4f788d9" translate="yes" xml:space="preserve">
          <source>These values can be used in many different ways:</source>
          <target state="translated">이 값들은 다양한 방법으로 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="acee363f8ecdca8ebcbfe3c36617f3a858f460fa" translate="yes" xml:space="preserve">
          <source>These wrapper objects are rarely used.</source>
          <target state="translated">이 래퍼 객체는 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ecb01f38d4891f3ba605fe10abbc133a33eebcb" translate="yes" xml:space="preserve">
          <source>Things to keep in mind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25df2f7528015bf66ff8cb5856b46ca9f89a989e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[declarations]&lt;/code&gt; section will parse in declaration mode:</source>
          <target state="translated">이 &lt;code&gt;[declarations]&lt;/code&gt; 섹션은 선언 모드에서 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="633b00a02de45953dce9e17ff82080b18f32ddce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[ignore]&lt;/code&gt; section will ignore:</source>
          <target state="translated">이 &lt;code&gt;[ignore]&lt;/code&gt; 섹션은 다음을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="881b9060a283396b0ef0fc92c8d4d847c624170a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[untyped]&lt;/code&gt; section will parse:</source>
          <target state="translated">이 &lt;code&gt;[untyped]&lt;/code&gt; 섹션은 다음을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6523434d73a5cea939dbb47f88e915c46aa3c5df" translate="yes" xml:space="preserve">
          <source>This affects Linux only.</source>
          <target state="translated">이것은 Linux에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="543aa46e91339d316364681d2b7a939cdad920b8" translate="yes" xml:space="preserve">
          <source>This allows you to pass a less specific type in place of that property.</source>
          <target state="translated">이를 통해 해당 속성 대신 덜 구체적인 유형을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1766dd7d0a89406504a02b5ace1d77e4b69c5963" translate="yes" xml:space="preserve">
          <source>This allows you to pass a more specific type in place of that property.</source>
          <target state="translated">이를 통해 해당 속성 대신보다 구체적인 유형을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd174f439abda4ebf248fb0e156219e91c6b759" translate="yes" xml:space="preserve">
          <source>This can be especially useful for referring to the type of React props, or, even the entire &lt;code&gt;props&lt;/code&gt; type itself.</source>
          <target state="translated">이것은 React 소품의 유형 또는 전체 &lt;code&gt;props&lt;/code&gt; 유형 자체 를 참조 할 때 특히 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b5bf94cd27d17a08f16ee047fe0e258d2090c51" translate="yes" xml:space="preserve">
          <source>This case happens often when you use &lt;code&gt;array.map()&lt;/code&gt; such as in:</source>
          <target state="translated">이 경우 는 다음과 같이 &lt;code&gt;array.map()&lt;/code&gt; 을 사용할 때 자주 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f0b87f03b6d241cb8b45f84bd4bf0506c5abe6b1" translate="yes" xml:space="preserve">
          <source>This command first starts a background process that will check all &lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Flow files&lt;/a&gt; for errors. The background process continues running, monitoring changes to your code and checking those changes incrementally for errors.</source>
          <target state="translated">이 명령은 먼저 모든 &lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;플로우 파일&lt;/a&gt; 에 오류 가 있는지 확인하는 백그라운드 프로세스를 시작 합니다. 백그라운드 프로세스가 계속 실행되어 코드 변경 사항을 모니터링하고 해당 변경 사항을 점진적으로 확인하여 오류가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3d875274c3b689e4f7ad033af88961c28bd2f54a" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt;. See how the comment is included in the element&amp;rsquo;s children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;['// some comment...', 42]&lt;/code&gt; which includes the comment. To write comments in JSX use the following syntax:</source>
          <target state="translated">&lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt; 컴파일됩니다 . 주석이 요소의 자식에 어떻게 포함되는지 확인하십시오. 이 경우 &lt;code&gt;props.children&lt;/code&gt; 은 &lt;code&gt;['// some comment...', 42]&lt;/code&gt; 이 포함 된 [ '// some comment ...', 42] 입니다. JSX로 주석을 작성하려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1981415185918a76b00cd452a5e0eb6fd87253c8" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, 42, '  ')&lt;/code&gt;. (With the spaces!) See how the spaces show up as part of the children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;[42, '  ']&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; the number 42. However, the following is fine:</source>
          <target state="translated">&lt;code&gt;React.createElement(MyComponent, {}, 42, ' ')&lt;/code&gt; 컴파일됩니다 . (공백과 함께!) 어린이의 일부로 공간이 어떻게 나타나는지보십시오. 이 경우 &lt;code&gt;props.children&lt;/code&gt; 는 것 &lt;code&gt;[42, ' ']&lt;/code&gt; 와 &lt;em&gt;없는&lt;/em&gt; 숫자 (42) 그러나, 다음 미세이다 :</target>
        </trans-unit>
        <trans-unit id="734dbfe930904c1dff5464c3868a3c58b214bbf9" translate="yes" xml:space="preserve">
          <source>This flag is in the form of a normal JavaScript comment annotated with &lt;code&gt;@flow&lt;/code&gt;. The Flow background process gathers all the files with this flag and uses the type information available from all of these files to ensure consistency and error free programming.</source>
          <target state="translated">이 플래그는 &lt;code&gt;@flow&lt;/code&gt; 로 주석이 달린 일반적인 JavaScript 주석 형태입니다 . 플로우 백그라운드 프로세스는이 플래그를 사용하여 모든 파일을 수집하고 모든 파일에서 사용 가능한 유형 정보를 사용하여 일관성 및 오류없는 프로그래밍을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="e8107dcd86e50a45fb0aff78e434d3e405ffe634" translate="yes" xml:space="preserve">
          <source>This follows the same rule that when you pass in a single child then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. Even though &lt;code&gt;[1, 2]&lt;/code&gt; is an array it is a single value and so &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. That is to say &lt;code&gt;props.children&lt;/code&gt; will be the array &lt;code&gt;[1, 2]&lt;/code&gt; and not an array of arrays.</source>
          <target state="translated">이것은 하나의 자식을 전달할 때 &lt;code&gt;props.children&lt;/code&gt; 이 &lt;em&gt;정확히&lt;/em&gt; 그 값 이 된다는 동일한 규칙을 따릅니다 . 비록 &lt;code&gt;[1, 2]&lt;/code&gt; 배열 그래서 단일 값이고 &lt;code&gt;props.children&lt;/code&gt; 는 것 &lt;em&gt;정확히&lt;/em&gt; 그 값. 즉, &lt;code&gt;props.children&lt;/code&gt; 은 배열의 배열이 아니라 배열 &lt;code&gt;[1, 2]&lt;/code&gt; 가됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ef0baedb6b23a6e6c0bc9c81182d27e5e3dc1d" translate="yes" xml:space="preserve">
          <source>This guide will teach you the syntax and semantics of all the different types you can have in Flow.</source>
          <target state="translated">이 가이드는 Flow에서 사용할 수있는 모든 다른 유형의 구문과 의미를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="096c3c9fc415cf70866aa9adcd243f084dfc276d" translate="yes" xml:space="preserve">
          <source>This includes the code into the syntax that Flow sees.</source>
          <target state="translated">Flow에 표시되는 구문에 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d9fb28a17538a9106a3ad6a6bed152242ff6e4d8" translate="yes" xml:space="preserve">
          <source>This is Flow&amp;rsquo;s most abstract representation of a React component, and is most useful for writing HOCs and library definitions.</source>
          <target state="translated">Flow의 React 컴포넌트를 가장 추상적으로 표현한 것으로 HOC 및 라이브러리 정의를 작성하는 데 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9af90c0ecae6766788f603b8275d9514e3979ca9" translate="yes" xml:space="preserve">
          <source>This is a basic template for what your HOCs might look like. At runtime, this HOC doesn&amp;rsquo;t do anything at all. Let&amp;rsquo;s take a look at some more complex examples.</source>
          <target state="translated">HOC의 모양에 대한 기본 템플릿입니다. 런타임시이 HOC는 전혀 수행하지 않습니다. 좀 더 복잡한 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c365f2918438c7a6e1888b46e0b930bd53745fff" translate="yes" xml:space="preserve">
          <source>This is a kind of subtyping commonly referred to as &amp;ldquo;width subtyping&amp;rdquo; because a type that is &amp;ldquo;wider&amp;rdquo; (i.e., has more properties) is a subtype of a narrower type.</source>
          <target state="translated">&quot;더 넓은&quot;유형 (즉, 더 많은 속성을 가짐)이 더 좁은 유형의 하위 유형이기 때문에 이것은 일반적으로 &quot;폭 하위 유형 지정&quot;이라고하는 일종의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="75b065150ca9eda7d9b645bb02ec9b648bf937bd" translate="yes" xml:space="preserve">
          <source>This is a union of a class component or a stateless functional component. This is the type you want to use for functions that receive or return React components such as higher-order components or other utilities.</source>
          <target state="translated">이것은 클래스 컴포넌트 또는 상태 비 저장 기능 컴포넌트의 결합입니다. 상위 컴포넌트 또는 기타 유틸리티와 같은 React 컴포넌트를 수신하거나 리턴하는 함수에 사용하려는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="eb111ed813f5032a53f03d0b631da3f19b265167" translate="yes" xml:space="preserve">
          <source>This is also okay because if something is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt; they would still have access to the same interface as before because &lt;code&gt;SanFrancisco&lt;/code&gt; is just a &lt;code&gt;City&lt;/code&gt; with a little more information.</source>
          <target state="translated">무언가가 &lt;code&gt;BaseClass&lt;/code&gt; 인 것처럼 &lt;code&gt;SubClass&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;SanFrancisco&lt;/code&gt; 는 조금 더 많은 정보가 있는 &lt;code&gt;City&lt;/code&gt; 이기 때문에 이전과 동일한 인터페이스에 계속 액세스 할 수 있기 때문에 괜찮 습니다 .</target>
        </trans-unit>
        <trans-unit id="ed9084ae2d3a6d3909814247a0a9d2fe5955a81d" translate="yes" xml:space="preserve">
          <source>This is an error because objects are mutable. The value referenced by the &lt;code&gt;employee&lt;/code&gt; variable is the same as the value referenced by the &lt;code&gt;person&lt;/code&gt; variable.</source>
          <target state="translated">객체가 변경 가능하기 때문에 오류입니다. 에 의해 참조되는 값 &lt;code&gt;employee&lt;/code&gt; 변수로 참조되는 값과 동일한 &lt;code&gt;person&lt;/code&gt; 가변.</target>
        </trans-unit>
        <trans-unit id="5b9e89f0566afa9b997d9c3c388578a1bf739bfd" translate="yes" xml:space="preserve">
          <source>This is an error in Flow because if you are expecting a &lt;code&gt;SanFrancisco&lt;/code&gt; and you get a &lt;code&gt;City&lt;/code&gt; you could be using something that only exists on &lt;code&gt;SanFrancisco&lt;/code&gt; which would cause an error at runtime.</source>
          <target state="translated">&lt;code&gt;SanFrancisco&lt;/code&gt; 를 기대하고 &lt;code&gt;City&lt;/code&gt; 를 얻는 경우 &lt;code&gt;SanFrancisco&lt;/code&gt; 에만 존재하는 무언가를 사용하여 런타임시 오류를 일으킬 수 있기 때문에 Flow 의 오류입니다.</target>
        </trans-unit>
        <trans-unit id="56976d17f40e185b38c5c6efa84d2af088f0b974" translate="yes" xml:space="preserve">
          <source>This is because classes in Flow are &lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;nominally typed&lt;/a&gt;.</source>
          <target state="translated">Flow의 클래스는 &lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;명목상 형식&lt;/a&gt; 이 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="127badd88c854dba7d3f79ae45c90e45e0bab65a" translate="yes" xml:space="preserve">
          <source>This is because in Flow it is okay to pass an object value with more properties than the object type expects (because of width subtyping).</source>
          <target state="translated">Flow에서는 개체 유형이 예상하는 것보다 더 많은 속성을 가진 개체 값을 전달하는 것이 좋습니다 (너비 하위 입력으로 인해).</target>
        </trans-unit>
        <trans-unit id="a696e7fa8715b1a73c06f5c45c3a6a89c88aadac" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;code&gt;[ignore]&lt;/code&gt; config section that causes matching files to be ignored by the module resolver, which inherently makes them un-typechecked, and also unresolvable by &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;. When ignored &lt;code&gt;[libs]&lt;/code&gt; must then be specified for each &lt;code&gt;import&lt;/code&gt; using &lt;code&gt;flow-typed&lt;/code&gt;, which may not always be desired.</source>
          <target state="translated">이것은 모듈 리졸버가 일치하는 파일을 무시하게하는 &lt;code&gt;[ignore]&lt;/code&gt; config 섹션과 는 다르며, 이로 인해 기본적으로 파일 형식을 검사하지 &lt;code&gt;require&lt;/code&gt; &lt;code&gt;import&lt;/code&gt; 또는 요구로 해결할 수 없습니다 . 무시할 경우 &lt;code&gt;flow-typed&lt;/code&gt; 를 사용하여 각 &lt;code&gt;import&lt;/code&gt; 에 대해 &lt;code&gt;[libs]&lt;/code&gt; 를 지정해야합니다 . 항상 바람직하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3e3b48d7024605ecf73a60b4a059e305833ff81" translate="yes" xml:space="preserve">
          <source>This is extremely useful for expressing the return type of functions that manipulate objects values. You could use a similar approach (for instance) to provide the return type of bluebird&amp;rsquo;s &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt;&lt;code&gt;Promise.props&lt;/code&gt;&lt;/a&gt; function, which is like &lt;code&gt;Promise.all&lt;/code&gt; but takes an object as input.</source>
          <target state="translated">이것은 객체 값을 조작하는 반환 유형의 함수를 표현하는 데 매우 유용합니다. 비슷한 접근 방식 (예를 들어)을 사용하여 블루 버드의 &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt; &lt;code&gt;Promise.props&lt;/code&gt; &lt;/a&gt; 함수 의 반환 유형을 제공 할 수 있습니다. Promise.all 과 &lt;code&gt;Promise.all&lt;/code&gt; 하지만 객체를 입력으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="60dfb0118bc43aa84388f7d66bc4c2be8af7089f" translate="yes" xml:space="preserve">
          <source>This is okay because if something else in your program is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt;, it would still be using a &lt;code&gt;City&lt;/code&gt; and wouldn&amp;rsquo;t cause any issues.</source>
          <target state="translated">프로그램의 다른 것이 &lt;code&gt;SubClass&lt;/code&gt; 를 &lt;code&gt;BaseClass&lt;/code&gt; 인 것처럼 SubClass 를 사용 하는 경우 여전히 &lt;code&gt;City&lt;/code&gt; 를 사용하고 문제를 일으키지 않기 때문에 괜찮 습니다 .</target>
        </trans-unit>
        <trans-unit id="def5148d9c559d37a047e98dc2513022553f61be" translate="yes" xml:space="preserve">
          <source>This is perfectly fine because if we pass in a more specific type we&amp;rsquo;ll still have all the information we need to be compatible with &lt;code&gt;Noun&lt;/code&gt;.</source>
          <target state="translated">좀 더 구체적인 유형을 전달하면 &lt;code&gt;Noun&lt;/code&gt; 과 호환되는 데 필요한 모든 정보가 여전히 남아 있기 때문에 이것은 완벽하게 좋습니다.</target>
        </trans-unit>
        <trans-unit id="424b976babef7901da66b2db61ee539c2a0be62a" translate="yes" xml:space="preserve">
          <source>This is the type of a React stateless functional component.</source>
          <target state="translated">이것이 React Stateless 기능 구성 요소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b2b862b3fcdd9450bc624dc8b8cf55e1f701d1ad" translate="yes" xml:space="preserve">
          <source>This is unsafe and not recommended. But it&amp;rsquo;s sometimes useful when you are doing something with a value which is very difficult or impossible to type and want to make sure that the result has the desired type.</source>
          <target state="translated">이것은 안전하지 않으므로 권장하지 않습니다. 그러나 입력하기가 매우 어렵거나 불가능한 값을 사용하여 결과에 원하는 유형이 있는지 확인하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="35aa78e533f2578f7e162a36de338a1f47f6c0b2" translate="yes" xml:space="preserve">
          <source>This is useful when you need to use a read-only version of an object type you&amp;rsquo;ve already defined, without manually having to re-define and annotate each key as read-only. For example:</source>
          <target state="translated">이 기능은 각 키를 읽기 전용으로 수동으로 재정의하고 주석을 달지 않고 이미 정의한 객체 유형의 읽기 전용 버전을 사용해야 할 때 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4cb01bc5bdd818c1407e6cedc026d2b0b09c1ad" translate="yes" xml:space="preserve">
          <source>This is very handy, but sometimes you need to access the enum definition at runtime (i.e. at a value level).</source>
          <target state="translated">이것은 매우 편리하지만 때로는 런타임에 (즉, 값 수준에서) 열거 정의에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="54f3db6a2015884e8473b3172c31c08a869daab0" translate="yes" xml:space="preserve">
          <source>This is where &lt;a href=&quot;../types#toc-react-config&quot;&gt;&lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt;&lt;/a&gt; comes in handy! We can use the type for Props and DefaultProps to calculate the &lt;code&gt;Config&lt;/code&gt; type for our component.</source>
          <target state="translated">곳이다 &lt;a href=&quot;../types#toc-react-config&quot;&gt; &lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt; &lt;/a&gt; 편리! Props 및 DefaultProps 유형을 사용하여 컴포넌트 의 &lt;code&gt;Config&lt;/code&gt; 유형 을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21ae5e6ce6468f7ff3f32ccfa0dd3f8fb2f7bcea" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; comes in handy.</source>
          <target state="translated">이것은 &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; 가 유용한 곳입니다.</target>
        </trans-unit>
        <trans-unit id="ee856278c549261688abdbd19d4ddec7e5efdc46" translate="yes" xml:space="preserve">
          <source>This lint setting is ignored when &lt;code&gt;exact_by_default&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;exact_by_default&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면이 보푸라기 설정이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a70889c6b7d22baa7cf64ab4c9b4c3c93d6d9191" translate="yes" xml:space="preserve">
          <source>This makes Flow treat &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; as if it were &lt;code&gt;require('ImageStub')&lt;/code&gt;.</source>
          <target state="translated">따라서 Flow는 &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; 를 &lt;code&gt;require('ImageStub')&lt;/code&gt; 처럼 취급 합니다 .</target>
        </trans-unit>
        <trans-unit id="e23feb9278c999088a311838ae5b7031bb5b5bf1" translate="yes" xml:space="preserve">
          <source>This makes it clear to the reader that &lt;code&gt;bar&lt;/code&gt; is not a potentially nullish property.</source>
          <target state="translated">이것은 &lt;code&gt;bar&lt;/code&gt; 잠재적으로 nullish 속성이 아니라는 것을 독자에게 분명히합니다.</target>
        </trans-unit>
        <trans-unit id="76437fdbf44079b1c571bd4124ab2ff68199ec3a" translate="yes" xml:space="preserve">
          <source>This means that a shorter tuple can&amp;rsquo;t be used in place of a longer one.</source>
          <target state="translated">이것은 더 긴 튜플 대신 더 짧은 튜플을 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ebff5f8c600e3fd9834aa943d918c1bfbd8d2dbe" translate="yes" xml:space="preserve">
          <source>This means that reads from unsealed objects with no matching writes are never checked. This is an unsafe behavior of Flow which may be improved in the future.</source>
          <target state="translated">이는 일치하는 쓰기가없는 봉인되지 않은 개체의 읽기는 확인되지 않음을 의미합니다. 이것은 향후 개선 될 수있는 Flow의 안전하지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="3bf9058b929ae73030823387d719318f0032a9fd" translate="yes" xml:space="preserve">
          <source>This means that the following 2 types are equivalent:</source>
          <target state="translated">이는 다음 두 유형이 동일 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6784af09c850d7330fc9ffa9c72f9fa8a86cc84a" translate="yes" xml:space="preserve">
          <source>This often means figuring out if the value you are passing in is a subtype of the value you are expecting.</source>
          <target state="translated">이것은 종종 전달하는 값이 기대하는 값의 하위 유형인지 알아내는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2cd8bc2873ab259581a052bdf16376541801c36c" translate="yes" xml:space="preserve">
          <source>This option configures the maximum possible size for the shared heap. You should most likely not need to configure this, as it doesn&amp;rsquo;t really affect how much RSS Flow uses. However, if you are working on a massive codebase you might see the following error after init: &amp;ldquo;Heap init size is too close to max heap size; GC will never get triggered!&amp;rdquo; In this case, you may need to increase the size of the heap.</source>
          <target state="translated">이 옵션은 공유 힙에 가능한 최대 크기를 구성합니다. RSS Flow 사용량에 실제로 영향을 미치지 않으므로이를 구성하지 않아도됩니다. 그러나 대규모 코드베이스에서 작업하는 경우 init 후에 다음 오류가 표시 될 수 있습니다.&amp;ldquo;힙 init 크기가 최대 힙 크기에 너무 가깝습니다. GC는 절대 트리거되지 않습니다!&amp;rdquo; 이 경우 힙 크기를 늘려야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9586cb7b0444ddcbaf378ece59924e71eed799e4" translate="yes" xml:space="preserve">
          <source>This option lets you alias &lt;code&gt;any&lt;/code&gt; with a given string. This is useful for explaining why you&amp;rsquo;re using &lt;code&gt;any&lt;/code&gt;. For example, let&amp;rsquo;s say you sometimes want to sometimes use &lt;code&gt;any&lt;/code&gt; to suppress an error and sometimes to mark a TODO. Your code might look like</source>
          <target state="translated">이 옵션은 별명을 다음을 수행 할 수 있습니다 &lt;code&gt;any&lt;/code&gt; 주어진 문자열. 이것은 왜 &lt;code&gt;any&lt;/code&gt; 를 사용하는지 설명하는 데 유용 합니다 . 예를 들어, 때때로 오류를 억제하고 TODO를 표시하기 위해 때로는 &lt;code&gt;any&lt;/code&gt; 를 사용한다고 가정 해 봅시다 . 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="36407b4a8671f76cf48e67ecd38443356cf43c1d" translate="yes" xml:space="preserve">
          <source>This pattern is also not limited to function children. You could also pass in arbitrary object or class types.</source>
          <target state="translated">이 패턴은 또한 기능적인 자식으로 제한되지 않습니다. 임의의 객체 또는 클래스 유형을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8daebbe8ae6fc42b982d8e4fe22459a7a10cd94c" translate="yes" xml:space="preserve">
          <source>This represents any node that can be rendered in a React application. &lt;code&gt;React.Node&lt;/code&gt; can be null, a boolean, a number, a string, a React element, or an array of any of those types recursively.</source>
          <target state="translated">이는 React 애플리케이션에서 렌더링 될 수있는 모든 노드를 나타냅니다. &lt;code&gt;React.Node&lt;/code&gt; 는 null, 부울, 숫자, 문자열, React 요소 또는 이러한 유형의 배열을 재귀 적으로 배열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752249d3acac833c3c21ce430f38863e1937ed27" translate="yes" xml:space="preserve">
          <source>This syntax is also available in a &lt;code&gt;flow-include&lt;/code&gt; form.</source>
          <target state="translated">이 구문은 &lt;code&gt;flow-include&lt;/code&gt; 형식으로 도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b31f92efc0a4da4dd28fb6304800cf7cd7fbb9c" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;PI&lt;/code&gt; global variable &amp;ndash; which, in this case, is a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">이를 통해 프로젝트 내의 모든 코드가 &lt;code&gt;PI&lt;/code&gt; 전역 변수 (이 경우 &lt;code&gt;number&lt;/code&gt; )를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f16bca30984be4eadbc92268c71095b6f69d5a4" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;URL&lt;/code&gt; global class. Note that this class definition does not have any implementation details &amp;ndash; it exclusively defines the interface of the class.</source>
          <target state="translated">이는 프로젝트 내의 모든 코드가 &lt;code&gt;URL&lt;/code&gt; 글로벌 클래스를 참조 할 수 있음을 Flow에 알려줍니다 . 이 클래스 정의에는 구현 세부 정보가 없으며 클래스의 인터페이스를 독점적으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fe10f9e40b8844cde008f22e6f7e27a41dd5807d" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;UserID&lt;/code&gt; global type &amp;ndash; which, in this case, is just an alias for &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">이는 프로젝트 내의 모든 코드가 &lt;code&gt;UserID&lt;/code&gt; 전역 유형을 참조 할 수 있음을 Flow에 알려줍니다.이 경우이 유형은 &lt;code&gt;number&lt;/code&gt; 의 별칭 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="b06e9eb45a05735715e1d1b65c57610ee02c78b2" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;foo&lt;/code&gt; global function, and that the function takes one argument (a &lt;code&gt;number&lt;/code&gt;) and it returns a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">이것은 프로젝트 내의 모든 코드가 &lt;code&gt;foo&lt;/code&gt; 전역 함수를 참조 할 수 있고 함수가 하나의 인수 ( &lt;code&gt;number&lt;/code&gt; )를 취하고 &lt;code&gt;string&lt;/code&gt; 을 리턴 한다는 것을 Flow에 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="e6bab6dcb6b25f93bc93c3ef139cb0898176b837" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">이 유틸리티는 더 이상 사용되지 않으므로 피해야합니다. 자세한 내용은 &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b74c252b0eeaacbb897eb419ddf06e190d869384" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">이 유틸리티는 더 이상 사용되지 않으므로 피해야합니다. 자세한 내용은 &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cabd9148684b1aa762ff2b690b8f720e71dd5acb" translate="yes" xml:space="preserve">
          <source>This way you avoid duplicating the properties that happen to have a default value.</source>
          <target state="translated">이렇게하면 기본값이있는 속성을 복제하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="22fe37b0969c2ab3810a8157bfb87e3e61565f27" translate="yes" xml:space="preserve">
          <source>This way you can keep the behavior of generics while only allowing certain types to be used.</source>
          <target state="translated">이런 식으로 특정 유형 만 사용하도록 허용하면서 제네릭의 동작을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d06c742de148aa21dfa2ce9950e849bcb9ab4c64" translate="yes" xml:space="preserve">
          <source>This will give you information about everything that flow can do. Running this command should print something like this:</source>
          <target state="translated">흐름이 할 수있는 모든 것에 대한 정보를 제공합니다. 이 명령을 실행하면 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c5358194d5e312667901904699178d180ad0d876" translate="yes" xml:space="preserve">
          <source>This would be the same as including a type annotation inside an include comment.</source>
          <target state="translated">이것은 include 주석 안에 타입 주석을 포함하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80babb7d0ff0eda4573ad401ec556fbf50e83b89" translate="yes" xml:space="preserve">
          <source>To add a type for state to your React class component then create a new object type, in the example below we name it &lt;code&gt;State&lt;/code&gt;, and pass it as the second type argument to &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="translated">상태에 대한 유형을 React 클래스 컴포넌트에 추가하려면 새 오브젝트 유형을 작성하십시오. 아래 예에서는 이름을 &lt;code&gt;State&lt;/code&gt; 로 지정하고 두 번째 유형 인수로 &lt;code&gt;React.Component&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="46cc112d13261a13154b6cfac4e2d48bf5063881" translate="yes" xml:space="preserve">
          <source>To create an array type you can use &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; type where &lt;code&gt;Type&lt;/code&gt; is the type of elements in the array. For example, to create a type for an array of numbers you use &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">배열 유형을 만들려면 &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; type을 사용할 수 있습니다. 여기서 &lt;code&gt;Type&lt;/code&gt; 은 배열의 요소 유형입니다. 예를 들어 숫자 배열의 유형을 만들려면 &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8dd0d93865b9bfacde3e4affb1eb92fd379b6bf0" translate="yes" xml:space="preserve">
          <source>To declare a global class that should be accessible throughout your project, use the &lt;code&gt;declare class&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">프로젝트 전체에서 액세스 할 수있는 글로벌 클래스를 선언하려면 libdef 파일에서 &lt;code&gt;declare class&lt;/code&gt; 구문을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="2c05553bc81af5c0b4f02184bd805aba0fa865c0" translate="yes" xml:space="preserve">
          <source>To declare a global function that should be accessible throughout your project, use the &lt;code&gt;declare function&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">프로젝트 전체에서 액세스 할 수있는 전역 함수를 선언하려면 libdef 파일에서 &lt;code&gt;declare function&lt;/code&gt; 구문을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="3d8d4cb10458061c2bc75c04590a96a2ed068bd5" translate="yes" xml:space="preserve">
          <source>To declare a global type that should be accessible throughout your project, use the &lt;code&gt;declare type&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">프로젝트 전체에서 액세스 할 수있는 글로벌 유형을 선언하려면 libdef 파일에서 &lt;code&gt;declare type&lt;/code&gt; 구문을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="d38d878e01cad40728f252774b0c25def7d4cb78" translate="yes" xml:space="preserve">
          <source>To declare a global variable that should be accessible throughout your project, use the &lt;code&gt;declare var&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">프로젝트 전체에서 액세스 할 수있는 전역 변수를 선언하려면 libdef 파일에서 &lt;code&gt;declare var&lt;/code&gt; 구문을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="f1875d662019d803a3d158d296ddb77c1752c55d" translate="yes" xml:space="preserve">
          <source>To explicitly specify the type of a context value, pass a type parameter to &lt;code&gt;createContext&lt;/code&gt;:</source>
          <target state="translated">컨텍스트 값의 유형을 명시 적으로 지정하려면 유형 매개 변수를 &lt;code&gt;createContext&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc65e5d43387ac143a42fd49169c9f382ad9e6e7" translate="yes" xml:space="preserve">
          <source>To find out more about the CLI just type:</source>
          <target state="translated">CLI에 대한 자세한 내용을 보려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d062574c0bbb40aba96339ff0dbe5323fbfe73f8" translate="yes" xml:space="preserve">
          <source>To get a sense of when and why the different kinds of variance matters, let&amp;rsquo;s talk about methods of subclasses and how they get type checked.</source>
          <target state="translated">다양한 종류의 차이가 언제, 왜 중요한지 이해하기 위해 서브 클래스의 메소드와 유형 확인 방법에 대해 이야기합시다.</target>
        </trans-unit>
        <trans-unit id="e8ca9700f4d5ea2116113c0a357e597df59a1d6a" translate="yes" xml:space="preserve">
          <source>To remove a prop from the config, we can take a component that includes the prop and return a component that does not. It&amp;rsquo;s best to construct these types using object type spread.</source>
          <target state="translated">구성에서 소품을 제거하기 위해 소품이 포함 된 구성 요소를 가져 와서 포함하지 않는 구성 요소를 반환 할 수 있습니다. 객체 유형 스프레드를 사용하여 이러한 유형을 구성하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8da5a47f9a8fbbb9d2efd234b56f09b304fb7f98" translate="yes" xml:space="preserve">
          <source>To see how you can annotate exported React components, check out our docs on &lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOCs&lt;/a&gt;.</source>
          <target state="translated">내 보낸 React 구성 요소에 주석을 달 수있는 방법을 보려면 &lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOC에&lt;/a&gt; 대한 문서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="38d849d799ad5dab7240320680d5c36bc5f7e6a7" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Filesystem lazy mode, you run</source>
          <target state="translated">파일 시스템 지연 모드에서 플로우 서버를 시작하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2cf8bbf7b6d19d0001e46d5b57c96b778d96ae37" translate="yes" xml:space="preserve">
          <source>To start a Flow server in IDE lazy mode, you run</source>
          <target state="translated">IDE 지연 모드에서 플로우 서버를 시작하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6e9bdac3d6d4ba3e13640e1b5c7a6fd976aa5a44" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Watchman lazy mode, you run</source>
          <target state="translated">Watchman 지연 모드에서 플로우 서버를 시작하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3978fe345012186156eab3faa3a6473c8b81612a" translate="yes" xml:space="preserve">
          <source>To start, we can define a SubClass that extends our BaseClass. Here you can see that the value and the return type are both City just like in BaseClass:</source>
          <target state="translated">시작하기 위해 BaseClass를 확장하는 SubClass를 정의 할 수 있습니다. 여기에서 BaseClass에서와 같이 값과 반환 유형이 모두 City임을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cfed2a3a8f7e86b967cf2cb173010c65146aff8" translate="yes" xml:space="preserve">
          <source>To stop the background process, run &lt;code&gt;flow stop&lt;/code&gt;.</source>
          <target state="translated">백그라운드 프로세스를 중지하려면 &lt;code&gt;flow stop&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="338950985d59d6b6ee99128178aad62509b70476" translate="yes" xml:space="preserve">
          <source>To type event handlers you may use the &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types like this:</source>
          <target state="translated">이벤트 핸들러를 입력하려면 다음과 같이 &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 유형을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="624f97de4950b92b803c5cac29be65a9f2a26ac4" translate="yes" xml:space="preserve">
          <source>Triggers when a &lt;code&gt;number&lt;/code&gt; is used in a manner which may lead to unexpected results if the value is falsy. Currently, this lint triggers if a &lt;code&gt;number&lt;/code&gt; appears in:</source>
          <target state="translated">값이 잘못된 경우 예기치 않은 결과를 초래할 수있는 방식으로 &lt;code&gt;number&lt;/code&gt; 를 사용할 때 트리거됩니다 . 현재이 린트는 &lt;code&gt;number&lt;/code&gt; 가 다음과 같은 경우 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="8244aa53a1217dc629b3a687638e12f7a3825a89" translate="yes" xml:space="preserve">
          <source>Triggers when a dynamic type (usually &lt;code&gt;any&lt;/code&gt;) appears in a position exported from a file. Note that this is a very noisy lint, and can be triggered even when exporting types that are defined in our library definitions to include &lt;code&gt;any&lt;/code&gt; types. For this reason we recommend turning it on on a per-file or even per-line basis using &lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;flowlint comments&lt;/a&gt; rather than for your whole repository in the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">파일에서 내 보낸 위치에 동적 유형 (보통 &lt;code&gt;any&lt;/code&gt; )이 나타날 때 트리거됩니다 . 이것은 시끄러운 보푸라기이며 라이브러리 정의에 정의 된 유형을 내 보내서 &lt;code&gt;any&lt;/code&gt; 유형 을 포함 하는 경우에도 트리거 될 수 있습니다 . 이러한 이유로 &lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;.flowconfig&lt;/a&gt; 의 전체 리포지토리 대신 flowlint 주석을 사용하여 파일 단위 또는 라인 단위로 설정하는 것이 &lt;code&gt;.flowconfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47ddc8ed6cfa00004f5b18730edf70132171135b" translate="yes" xml:space="preserve">
          <source>Triggers when you do an existence check on a value that can be either null/undefined or falsey.</source>
          <target state="translated">널 / 정의되지 않거나 거짓 일 수있는 값에 대한 존재 점검을 수행 할 때 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="4ce10e302a6e69d26761a0ef32f11a1014584bb6" translate="yes" xml:space="preserve">
          <source>Triggers when you import a type from an untyped file. Importing a type from an untyped file results in an &lt;code&gt;any&lt;/code&gt; alias, which is typically not the intended behavior. Enabling this lint brings extra attention to this case and can help improve Flow coverage of typed files by limiting the spread of implicit &lt;code&gt;any&lt;/code&gt; types.</source>
          <target state="translated">형식화되지 않은 파일에서 형식을 가져올 때 트리거됩니다. 에 지정되지 않은 파일 결과에서 유형을 가져 오기 &lt;code&gt;any&lt;/code&gt; 일반적으로 의도 된 행동하지 않습니다 별명. 이 보풀을 사용하면이 경우에 특별한주의를 가져오고 암시의 확산 제한하여 입력 파일의 유량 범위를 향상시킬 수 &lt;code&gt;any&lt;/code&gt; 유형.</target>
        </trans-unit>
        <trans-unit id="40e312343bc5d66e00ad8f9190f3b8d256cb21f3" translate="yes" xml:space="preserve">
          <source>Triggers when you import from an untyped file. Importing from an untyped file results in those imports being typed as &lt;code&gt;any&lt;/code&gt;, which is unsafe.</source>
          <target state="translated">형식화되지 않은 파일에서 가져올 때 트리거됩니다. 형식화되지 않은 파일에서 가져 오면 해당 형식의 가져 오기가 &lt;code&gt;any&lt;/code&gt; 로 입력되므로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39095841a2d5b46ef9de672a2165376705e39be2" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;?.&lt;/code&gt; where it isn&amp;rsquo;t needed. This comes in two main flavors. The first is when the left-hand-side cannot be nullish:</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; 를 사용할 때 트리거됩니다 . 필요하지 않은 곳. 이것은 두 가지 주요 맛이 있습니다. 첫 번째는 왼쪽이 널이 될 수없는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="7a041463679a6c0a8cd599df21a504646bc4568e" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, or &lt;code&gt;Function&lt;/code&gt; as type annotations. These types are unsafe.</source>
          <target state="translated">당신이 사용하는 트리거 &lt;code&gt;any&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; , 또는 &lt;code&gt;Function&lt;/code&gt; 유형 약어로합니다. 이러한 유형은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19e0b14f57c0eae8e32ecfbe46dbafa0b69613db" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;invariant&lt;/code&gt; to check a condition which we know must be truthy based on the available type information. This is quite conservative: for example, if all we know about the condition is that it is a &lt;code&gt;boolean&lt;/code&gt;, then the lint will not fire even if the condition must be &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">당신이 사용하는 트리거 &lt;code&gt;invariant&lt;/code&gt; 우리가 사용할 수있는 유형의 정보를 기반으로 truthy해야합니다 알고있는 상태를 확인합니다. 예를 들어 조건에 대해 우리가 아는 전부가 &lt;code&gt;boolean&lt;/code&gt; 인 경우 보풀은 조건이 런타임에 &lt;code&gt;true&lt;/code&gt; 여야하더라도 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="88f0c0e34ae8ddb6395ee1c9617fdf1fcbad8760" translate="yes" xml:space="preserve">
          <source>Triggers when you use getters or setters. Getters and setters can have side effects and are unsafe.</source>
          <target state="translated">게터 또는 세터를 사용할 때 트리거됩니다. 게터와 세터는 부작용이있을 수 있으며 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffe944ad5706f41a9277209e96a262e3b635f27d" translate="yes" xml:space="preserve">
          <source>Triggers when you use object type syntax without explicitly specifying exactness or inexactness.</source>
          <target state="translated">정확성 또는 부정확성을 명시 적으로 지정하지 않고 객체 유형 구문을 사용할 때 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="53aef4ae56fa920050fd71a2e06d45055d43a802" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;$Supertype&lt;/code&gt; or &lt;code&gt;$Subtype&lt;/code&gt; utility types, as these types are unsafe and equivalent to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$Supertype&lt;/code&gt; 또는 &lt;code&gt;$Subtype&lt;/code&gt; 유틸리티 유형 을 사용할 때 트리거됩니다. 이러한 유형은 안전하지 &lt;code&gt;any&lt;/code&gt; 와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="5d53a0bb8e4d9ee63e0c2e172befa01db4dc5e57" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;*&lt;/code&gt; (existential) type, as this type is unsafe and usually just equivalent to &lt;code&gt;any&lt;/code&gt;. The effect of &lt;code&gt;*&lt;/code&gt; can generally be achieved by simply not providing a type annotation.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; (기존) 유형 을 사용할 때 트리거됩니다. 이 유형은 안전하지 않으며 일반적으로 &lt;code&gt;any&lt;/code&gt; 와 동일 합니다 . &lt;code&gt;*&lt;/code&gt; 의 효과 는 일반적으로 단순히 유형 주석을 제공하지 않음으로써 달성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cddc0a96f7b4bc576c5197edc188b6a0fc13138" translate="yes" xml:space="preserve">
          <source>Trying to access an index that does not exist results in an index-out-of-bounds error.</source>
          <target state="translated">존재하지 않는 인덱스에 액세스하려고하면 범위를 벗어난 인덱스 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cded0e3b203109683ae6b9ee54b86c57e5dee4ad" translate="yes" xml:space="preserve">
          <source>Trying to combine these two separate types into a single one will only cause us trouble.</source>
          <target state="translated">이 두 가지 유형을 하나의 유형으로 결합하려고하면 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="translated">튜플 유형</target>
        </trans-unit>
        <trans-unit id="61fc0a89e720d49271749ab98f1e68ad73b11567" translate="yes" xml:space="preserve">
          <source>Tuples are a sort of list but with a limited set of items. In JavaScript, tuples are created using arrays.</source>
          <target state="translated">튜플은 일종의 목록이지만 제한된 항목 집합이 있습니다. JavaScript에서 튜플은 배열을 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="73e71c95d22953ac62aab7556972e23a84de8572" translate="yes" xml:space="preserve">
          <source>Tuples don&amp;rsquo;t match array types</source>
          <target state="translated">튜플이 배열 유형과 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="8228214d660934e2f3e63e0eebd31592280771e2" translate="yes" xml:space="preserve">
          <source>Tuples only match tuples with same length</source>
          <target state="translated">튜플은 길이가 같은 튜플과 만 일치합니다</target>
        </trans-unit>
        <trans-unit id="ebd8267f01d325be2d1360510829d925406c4930" translate="yes" xml:space="preserve">
          <source>Type &amp;lsquo;Flow&amp;rsquo; to find &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo;</source>
          <target state="translated">'Flow'를 입력하여 'Sublime Text 2 및 3의 흐름'을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="706d45898c47974656ad0920b31f4684a46f295c" translate="yes" xml:space="preserve">
          <source>Type Alias Generics</source>
          <target state="translated">별칭 별칭 제네릭</target>
        </trans-unit>
        <trans-unit id="967c606ccee3e18535dabb6a9b4bb749abac062f" translate="yes" xml:space="preserve">
          <source>Type Alias Syntax</source>
          <target state="translated">유형 별명 구문</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">유형 별명</target>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77177e460aea3473402f5aaa44a506ee91144641" translate="yes" xml:space="preserve">
          <source>Type Assertions</source>
          <target state="translated">유형 어설 션</target>
        </trans-unit>
        <trans-unit id="679d10a7debbdc2089b71c9b81e4e219e305c114" translate="yes" xml:space="preserve">
          <source>Type Cast Expression Syntax</source>
          <target state="translated">유형 캐스트 ​​표현식 구문</target>
        </trans-unit>
        <trans-unit id="7f7ae61fc4d52305e688b8380ee480f65e186212" translate="yes" xml:space="preserve">
          <source>Type Casting</source>
          <target state="translated">주조</target>
        </trans-unit>
        <trans-unit id="622cca8db4f4ef9c127d2e4b8f7ee4a1c6c56924" translate="yes" xml:space="preserve">
          <source>Type Casting Expressions</source>
          <target state="translated">타입 캐스팅 표현식</target>
        </trans-unit>
        <trans-unit id="242837be86dac228098509d8b1d22d367cdf4559" translate="yes" xml:space="preserve">
          <source>Type Casting through any</source>
          <target state="translated">모든 유형의 주조</target>
        </trans-unit>
        <trans-unit id="5ad392a89ee608a47c6212c75337d50433a48220" translate="yes" xml:space="preserve">
          <source>Type Reference</source>
          <target state="translated">타입 레퍼런스</target>
        </trans-unit>
        <trans-unit id="ce57a9b5c9b93e38d173ed05c80dc328e2cdfdfc" translate="yes" xml:space="preserve">
          <source>Type Refinements</source>
          <target state="translated">타입 개선</target>
        </trans-unit>
        <trans-unit id="7433446286e8e2d16c8a5d667b180309a3d0c3b1" translate="yes" xml:space="preserve">
          <source>Type System</source>
          <target state="translated">타입 시스템</target>
        </trans-unit>
        <trans-unit id="472d5c5df27f757dd28ba1d382ee583d4a9c6081" translate="yes" xml:space="preserve">
          <source>Type Variance</source>
          <target state="translated">유형 차이</target>
        </trans-unit>
        <trans-unit id="7081fc7a1f2c1115eff37592f8d91d2655e0035b" translate="yes" xml:space="preserve">
          <source>Type alias generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a type alias you need to pass parameters for each of its generics.</source>
          <target state="translated">유형 별칭 제네릭이 &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;매개 변수화&lt;/a&gt; 됩니다. 유형 별명을 사용하는 경우 각 제네릭에 대한 매개 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed6584609a640d5af10378fda6649aaa9963a745" translate="yes" xml:space="preserve">
          <source>Type aliases are created using the keyword &lt;code&gt;type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">유형 별명은 키워드 &lt;code&gt;type&lt;/code&gt; , 이름, 등호 &lt;code&gt;=&lt;/code&gt; 및 유형 정의를 사용하여 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e43ef93cfc8bf99af97c7220813d7732015c36" translate="yes" xml:space="preserve">
          <source>Type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">타입 별칭은 또한 &lt;a href=&quot;../generics&quot;&gt;제네릭을&lt;/a&gt; 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="094f893f7105ba5dce34064ff2a962e9a5dea0a2" translate="yes" xml:space="preserve">
          <source>Type aliases with generics</source>
          <target state="translated">제네릭이있는 유형 별칭</target>
        </trans-unit>
        <trans-unit id="856da198c41cb55e6e7b7e17d220f7f074929070" translate="yes" xml:space="preserve">
          <source>Type cast expressions can appear anywhere an expression can appear.</source>
          <target state="translated">유형 캐스트 ​​표현식은 표현식이 나타날 수있는 모든 곳에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52a7383784e25f833d11d59af803f7d6f5fb1c80" translate="yes" xml:space="preserve">
          <source>Type checking through type assertions</source>
          <target state="translated">형식 어설 션을 통한 형식 검사</target>
        </trans-unit>
        <trans-unit id="b0b25b95faf957cfa80952cbe05fe4b40c3ff732" translate="yes" xml:space="preserve">
          <source>Typeof Types</source>
          <target state="translated">유형 유형</target>
        </trans-unit>
        <trans-unit id="e96900534c313f15c2044eb007fe55d438980bfc" translate="yes" xml:space="preserve">
          <source>Types &amp;amp; Expressions</source>
          <target state="translated">타입과 표현</target>
        </trans-unit>
        <trans-unit id="c71bc629994455a4ae2c2c56b3468d4335892413" translate="yes" xml:space="preserve">
          <source>Types for literal values are lowercase.</source>
          <target state="translated">리터럴 값의 유형은 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="580c5ee4989e8d41e98c7cbde35a3b6779ea36bd" translate="yes" xml:space="preserve">
          <source>Types for the wrapper objects are capitalized (the same as their constructor).</source>
          <target state="translated">랩퍼 오브젝트의 유형은 대문자로 표시됩니다 (생성자와 동일).</target>
        </trans-unit>
        <trans-unit id="7b4e1425babb83699dcc06797b8fc4bf14a2ecce" translate="yes" xml:space="preserve">
          <source>Typing Redux action creators</source>
          <target state="translated">Redux 액션 제작자 입력</target>
        </trans-unit>
        <trans-unit id="5dfff1352be5ea6c7148bf3b4ca1615b03fabc81" translate="yes" xml:space="preserve">
          <source>Typing Redux actions</source>
          <target state="translated">Redux 작업 입력</target>
        </trans-unit>
        <trans-unit id="6ac33fe488507408b1948fb67be46790295ab295" translate="yes" xml:space="preserve">
          <source>Typing Redux reducers</source>
          <target state="translated">Redux 감속기 입력</target>
        </trans-unit>
        <trans-unit id="1133cd18fcd897fc2f5bb525485b9229e6071672" translate="yes" xml:space="preserve">
          <source>Typing Redux state</source>
          <target state="translated">Redux 상태 입력</target>
        </trans-unit>
        <trans-unit id="0640a2bc7ae817374f47547199fbe5f3a1a3b619" translate="yes" xml:space="preserve">
          <source>Typing Redux state immutability</source>
          <target state="translated">Redux 상태 불변성을 입력</target>
        </trans-unit>
        <trans-unit id="5122ba530622fd5f4a0332eb09fb6325c4305df1" translate="yes" xml:space="preserve">
          <source>Typing Redux thunk actions</source>
          <target state="translated">Redux 썽크 동작 입력</target>
        </trans-unit>
        <trans-unit id="8f00b09a4880f70aa5139aa250a7d8b335930e96" translate="yes" xml:space="preserve">
          <source>Typing function children or other exotic children types.</source>
          <target state="translated">입력 기능 어린이 또는 기타 이국적인 어린이 유형.</target>
        </trans-unit>
        <trans-unit id="ee1f5ee4decdbb0b21342950c2b6f1f39fa45f3a" translate="yes" xml:space="preserve">
          <source>Typing your &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;state&lt;/a&gt; object, works the same as typing any other object in Flow.</source>
          <target state="translated">귀하의 입력 &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;상태&lt;/a&gt; 객체를 흐름에 다른 개체를 입력 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eaeff57d46868fd923495803e50c88004276ec83" translate="yes" xml:space="preserve">
          <source>Typings HOCs can be complicated. While you can follow the &lt;a href=&quot;react/hoc&quot;&gt;docs about it&lt;/a&gt;, sometimes it can be easier to type the returned component.</source>
          <target state="translated">타이핑 HOC는 복잡 할 수 있습니다. &lt;a href=&quot;react/hoc&quot;&gt;그것에&lt;/a&gt; 대한 문서를 따를 수는 있지만 때로는 반환 된 구성 요소를 입력하는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e0451237256965294e54fd3ed734d927e133c0" translate="yes" xml:space="preserve">
          <source>Under the hood, Flow relies on a high-throughput low-latency systems infrastructure that enables distribution of tasks among parallel workers, and communication of results in parallel via shared memory. Combined with an architecture where the analysis of a codebase is updated automatically in the background on file system changes, Flow delivers near-instantaneous feedback as the developer edits and rebases code, even in a large repository.</source>
          <target state="translated">흐름 아래에서 Flow는 병렬 작업자간에 작업을 분배하고 공유 메모리를 통해 결과를 병렬로 전달할 수있는 처리량이 많은 저 지연 시스템 인프라를 사용합니다. 파일 시스템 변경시 백그라운드에서 코드베이스 분석이 자동으로 업데이트되는 아키텍처와 결합 된 Flow는 개발자가 대규모 저장소에서도 코드를 편집하고 리베이스 할 때 거의 즉각적인 피드백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="667d6f69fc6e6557c1fd07a997502ffbb6fea4b6" translate="yes" xml:space="preserve">
          <source>Understanding the logic behind generics might be useful, but what you really need to know to make your typings valid is that you need to help Flow to understand the type of &lt;code&gt;genericArray&lt;/code&gt;.</source>
          <target state="translated">제네릭 뒤에있는 논리를 이해하는 것이 유용 할 수 있지만 입력을 유효하게하려면 실제로 알아야하는 것은 Flow가 &lt;code&gt;genericArray&lt;/code&gt; 유형을 이해하도록 도와야한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">연합 유형</target>
        </trans-unit>
        <trans-unit id="5997dfe0e231fc3d5039a0ce77e27fc997c50e93" translate="yes" xml:space="preserve">
          <source>Union type syntax</source>
          <target state="translated">유니언 타입 문법</target>
        </trans-unit>
        <trans-unit id="5772a5be68b2acc1748e16bd31117c9dcf779b80" translate="yes" xml:space="preserve">
          <source>Union types are any number of types which are joined by a vertical bar &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">연합 유형은 수직 막대에 의해 결합 된 유형의 수입니다 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4fcae8ac4735463f8391bdf76cd83a6272aa90b" translate="yes" xml:space="preserve">
          <source>Union types requires one in, but all out</source>
          <target state="translated">유니온 유형은 하나만 필요하지만 모두</target>
        </trans-unit>
        <trans-unit id="40ebabc3d3f621503bd72ccc4402a11bbf25a8ef" translate="yes" xml:space="preserve">
          <source>Unions &amp;amp; Refinements</source>
          <target state="translated">연합 및 개선</target>
        </trans-unit>
        <trans-unit id="38ed70ea0b1d89e63badbd5bea1ce73346a2e36d" translate="yes" xml:space="preserve">
          <source>Unknown property lookup on unsealed objects is unsafe</source>
          <target state="translated">봉인되지 않은 개체의 알 수없는 속성 조회는 안전하지 않습니다</target>
        </trans-unit>
        <trans-unit id="703d1ae54d78dc2791b520eb4ed986a6d9a34e11" translate="yes" xml:space="preserve">
          <source>Unless the objects somehow conflict with one another there is no way to distinguish them.</source>
          <target state="translated">객체가 어떻게 든 서로 충돌하지 않는 한 객체를 구별 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef3248cdccf6c3a032dec37be3fbfe52ccc8052c" translate="yes" xml:space="preserve">
          <source>Unlike many other languages, JavaScript only has one type of number. These values may appear as &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;. JavaScript also considers &lt;code&gt;Infinity&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; to be numbers. The &lt;code&gt;number&lt;/code&gt; type captures everything JavaScript considers a number.</source>
          <target state="translated">다른 많은 언어와 달리 JavaScript에는 한 가지 유형의 숫자 ​​만 있습니다. 이 값은 &lt;code&gt;42&lt;/code&gt; 또는 &lt;code&gt;3.14&lt;/code&gt; 로 나타날 수 있습니다 . JavaScript는 또한 &lt;code&gt;Infinity&lt;/code&gt; 와 &lt;code&gt;NaN&lt;/code&gt; 을 숫자로 간주합니다. &lt;code&gt;number&lt;/code&gt; 를 입력 캡처의 모든 자바 스크립트 숫자를 고려합니다.</target>
        </trans-unit>
        <trans-unit id="3af13bbea775e8595b01bcfbe26e08a735507b74" translate="yes" xml:space="preserve">
          <source>Unlike regular object types, it is not valid to pass an object with &amp;ldquo;extra&amp;rdquo; properties to an exact object type.</source>
          <target state="translated">일반 객체 유형과 달리 &quot;추가&quot;속성을 가진 객체를 정확한 객체 유형으로 전달하는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07ef2b2dcd96f0dd48fe2da326d94f53363ed4ce" translate="yes" xml:space="preserve">
          <source>Unsealed objects</source>
          <target state="translated">봉인되지 않은 개체</target>
        </trans-unit>
        <trans-unit id="25c6b6f53e08c0606a31166d8b9a877dcfc420f6" translate="yes" xml:space="preserve">
          <source>Unsealed objects allow new properties to be written at any time. Flow ensures that reads are compatible with writes, but does not ensure that writes happen before reads (in the order of execution).</source>
          <target state="translated">봉인되지 않은 개체를 사용하면 언제든지 새로운 속성을 작성할 수 있습니다. Flow는 읽기가 쓰기와 호환되도록하지만 읽기 전에 (실행 순서대로) 쓰기가 수행되는 것을 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="a37aa700a25d2f5c26f5844b90cdc3158398c792" translate="yes" xml:space="preserve">
          <source>Used in conjuction with &lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt;. Triggers when importing a non &lt;code&gt;@flow strict&lt;/code&gt; module. When enabled, dependencies of a &lt;code&gt;@flow strict&lt;/code&gt; module must also be &lt;code&gt;@flow strict&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt; 와 함께 사용됩니다 . &lt;code&gt;@flow strict&lt;/code&gt; 하지 않은 모듈을 가져올 때 트리거됩니다 . 사용 가능한 경우 &lt;code&gt;@flow strict&lt;/code&gt; 모듈의 종속성 도 &lt;code&gt;@flow strict&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="37435b49f34aed7ea4a10106bbcc3330cbcab593" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.Node&lt;/code&gt; but without some primitive types like strings.</source>
          <target state="translated">&lt;code&gt;React.Node&lt;/code&gt; 사용 하지만 문자열과 같은 기본 유형은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a55e66a75946c4c072cc420e4c3ed94f6780a7c2" translate="yes" xml:space="preserve">
          <source>Using Default Props</source>
          <target state="translated">기본 소품 사용하기</target>
        </trans-unit>
        <trans-unit id="08b120d1bbe1cac9b101fd75ecc8814d5b08ec58" translate="yes" xml:space="preserve">
          <source>Using Default Props for Functional Components</source>
          <target state="translated">기능적 구성 요소에 기본 소품 사용</target>
        </trans-unit>
        <trans-unit id="3c58620d569e6a2825f19e911cd8c7f8b356ab31" translate="yes" xml:space="preserve">
          <source>Using Filesystem Lazy Mode</source>
          <target state="translated">파일 시스템 지연 모드 사용</target>
        </trans-unit>
        <trans-unit id="0eca84f8818d70549fd226298ab6a5af63ae5ddc" translate="yes" xml:space="preserve">
          <source>Using Flow you can use Maybe types for these values. Maybe types work with any other type by simply prefixing it with a question mark &lt;code&gt;?&lt;/code&gt; such as &lt;code&gt;?number&lt;/code&gt; as a sort of modifier.</source>
          <target state="translated">Flow를 사용하면 이러한 값에 Maybe 유형을 사용할 수 있습니다. 어쩌면 타입은 단순히 물음표로 접두사를 붙여 다른 유형과도 작동 할 수 있습니다 &lt;code&gt;?&lt;/code&gt; 일종의 수정자인 &lt;code&gt;?number&lt;/code&gt; 와 같은</target>
        </trans-unit>
        <trans-unit id="ba7902faac97670dd0cee466cfc7b1872b6191c6" translate="yes" xml:space="preserve">
          <source>Using IDE Lazy Mode</source>
          <target state="translated">IDE Lazy Mode 사용</target>
        </trans-unit>
        <trans-unit id="dcb8b5c22a81a676bc4f6e0097672681d67ad964" translate="yes" xml:space="preserve">
          <source>Using Watchman Lazy Mode</source>
          <target state="translated">워치 만 지연 모드 사용</target>
        </trans-unit>
        <trans-unit id="4acbbdc6b766f0f60a0b004c91a169d2b83a940e" translate="yes" xml:space="preserve">
          <source>Using disjoint unions, Flow will be able to understand your reducers much better.</source>
          <target state="translated">비 연합 조합을 사용하면 Flow가 감속기를 훨씬 잘 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6ba24474eb6d1b00633e337c8dace730b98eb30" translate="yes" xml:space="preserve">
          <source>Using exact object types lets Flow know that no extra properties will exist at runtime, which allows &lt;a href=&quot;../refinements&quot;&gt;refinements&lt;/a&gt; to get more specific.</source>
          <target state="translated">정확한 객체 유형을 사용하면 Flow에 런타임시 추가 속성이 존재하지 않으므로 &lt;a href=&quot;../refinements&quot;&gt;구체화&lt;/a&gt; 를보다 구체적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ade4f79788cce4dea297a9d609f90e95de4261" translate="yes" xml:space="preserve">
          <source>Using inference, these types are often optional:</source>
          <target state="translated">추론을 사용하여 이러한 유형은 종종 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="638d500275968b8c62e284497de3a8262dc86007" translate="yes" xml:space="preserve">
          <source>Using intersection types, it is possible to create types which are impossible to create at runtime. Intersection types will allow you to combine any set of types, even ones that conflict with one another.</source>
          <target state="translated">교차 유형을 사용하면 런타임에 만들 수없는 유형을 만들 수 있습니다. 교차 유형을 사용하면 충돌하는 유형을 포함하여 모든 유형의 집합을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86509a1d00de10c9136938cbdfb1d9850e246f6e" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;flow&lt;/code&gt; will type-check your current directory if the &lt;code&gt;.flowconfig&lt;/code&gt; file is present. A flow server will automatically be started if needed.</source>
          <target state="translated">명령 사용 &lt;code&gt;flow&lt;/code&gt; 경우 현재 디렉토리를 입력-확인합니다 &lt;code&gt;.flowconfig&lt;/code&gt; 의 파일이 존재합니다. 필요한 경우 플로우 서버가 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="b4fce26a90d1ee7b21142442ea9f330e4afede8c" translate="yes" xml:space="preserve">
          <source>Using these with &lt;a href=&quot;../unions&quot;&gt;union types&lt;/a&gt; is powerful:</source>
          <target state="translated">&lt;a href=&quot;../unions&quot;&gt;공용체 유형&lt;/a&gt; 과 함께 사용하면 강력합니다.</target>
        </trans-unit>
        <trans-unit id="58f37430c61b5ea396ac215dd6bf35547ff8b510" translate="yes" xml:space="preserve">
          <source>Using type cast expressions</source>
          <target state="translated">타입 캐스트 표현식 사용</target>
        </trans-unit>
        <trans-unit id="4e74c3c3dbc90177ee7906987795cb4e37db9635" translate="yes" xml:space="preserve">
          <source>Using type cast expressions you can assert that values are certain types.</source>
          <target state="translated">유형 캐스트 ​​표현식을 사용하면 값이 특정 유형이라고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">유틸리티 유형</target>
        </trans-unit>
        <trans-unit id="d981987c61afbbc64d7655e2b4cdb6bf5b85cbce" translate="yes" xml:space="preserve">
          <source>Variable Types</source>
          <target state="translated">변수 유형</target>
        </trans-unit>
        <trans-unit id="3c555fe12c9dd11facd9128e236d5c42157a806e" translate="yes" xml:space="preserve">
          <source>Variance Sigils</source>
          <target state="translated">분산시길</target>
        </trans-unit>
        <trans-unit id="12e8ee8b0b460ae1489f8fa70aa448077ad5be60" translate="yes" xml:space="preserve">
          <source>Variance in Classes</source>
          <target state="translated">클래스의 차이</target>
        </trans-unit>
        <trans-unit id="661548cc8ae30e106f079ae71da4e22fdee3f0a3" translate="yes" xml:space="preserve">
          <source>Variance is a topic that comes up fairly often in type systems and can be a bit confusing the first time you hear it. Let&amp;rsquo;s walk through each form of variance.</source>
          <target state="translated">분산은 유형 시스템에서 상당히 자주 나타나는 주제이며 처음들을 때 약간 혼란 스러울 수 있습니다. 각 형태의 분산을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4f27c48fa3564f7410e0121a7646d154ac051a32" translate="yes" xml:space="preserve">
          <source>Variance sigils allow you to be more specific about how you intend to use your generics, giving Flow the power to do more precise type checking. For example, you may want this relationship to hold:</source>
          <target state="translated">Variance sigils를 사용하면 제네릭을 사용하려는 방식을보다 구체적으로 지정할 수 있으므로 Flow에서보다 정확한 유형 검사를 수행 할 수 있습니다. 예를 들어,이 관계를 유지하고자 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78ad277616170813560c5fab7aabae8ac9cfb23" translate="yes" xml:space="preserve">
          <source>Vim</source>
          <target state="translated">Vim</target>
        </trans-unit>
        <trans-unit id="afbd00670e2a500077ed926aedfb070c71244c15" translate="yes" xml:space="preserve">
          <source>VimPlug</source>
          <target state="translated">VimPlug</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">비주얼 스튜디오 코드</target>
        </trans-unit>
        <trans-unit id="b8fd2f3a8255adad646ca5327eba0b8786744dbe" translate="yes" xml:space="preserve">
          <source>Warnings aren&amp;rsquo;t shown on the CLI by default, to avoid spew. CLI warnings can be enabled by passing the &amp;ndash;include-warnings flag to the Flow server or the Flow client, or by setting &amp;ldquo;include_warnings=true&amp;rdquo; in the &lt;code&gt;.flowconfig&lt;/code&gt;. This is good for smaller projects that want to see all project warnings at once.</source>
          <target state="translated">토출을 피하기 위해 경고는 기본적으로 CLI에 표시되지 않습니다. &amp;ndash;include-warnings 플래그를 플로우 서버 또는 플로우 클라이언트에 전달하거나 &lt;code&gt;.flowconfig&lt;/code&gt; 에서&amp;ldquo;include_warnings = true&amp;rdquo;를 설정하여 CLI 경고를 사용할 수 있습니다 . 모든 프로젝트 경고를 한 번에보고 싶은 소규모 프로젝트에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fe8d40071f5a559a669afec325304551bb16aba4" translate="yes" xml:space="preserve">
          <source>Warnings don&amp;rsquo;t affect the exit code of Flow. If Flow finds warnings but no errors, it still returns 0.</source>
          <target state="translated">경고는 Flow 종료 코드에 영향을 미치지 않습니다. Flow가 경고를 찾지 만 오류가없는 경우에도 여전히 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81f9219fd8a874b03e97d8fac13dedd6210a919b" translate="yes" xml:space="preserve">
          <source>Warnings have special &lt;a href=&quot;ide-integration&quot;&gt;IDE Integration&lt;/a&gt;.</source>
          <target state="translated">경고에는 특별한 &lt;a href=&quot;ide-integration&quot;&gt;IDE 통합이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb2debe559facf651a601f9c7527b8296d8b9624" translate="yes" xml:space="preserve">
          <source>Watchman lazy mode has a few additional requirements.</source>
          <target state="translated">경비원 게으른 모드에는 몇 가지 추가 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78080fc13eb28909de716d744a8a47810b22cd61" translate="yes" xml:space="preserve">
          <source>We also need &lt;code&gt;typeof&lt;/code&gt; for &lt;code&gt;Bar&lt;/code&gt; because &lt;code&gt;Bar&lt;/code&gt; is a value. So we want to get the type &lt;em&gt;of&lt;/em&gt; the value &lt;code&gt;Bar&lt;/code&gt;. &lt;code&gt;(Bar: Bar)&lt;/code&gt; is an error because &lt;code&gt;Bar&lt;/code&gt; cannot be used as a type, so the following is correct: &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt;.</source>
          <target state="translated">우리는 또한 필요 &lt;code&gt;typeof&lt;/code&gt; 를 위해 &lt;code&gt;Bar&lt;/code&gt; 있기 때문에 &lt;code&gt;Bar&lt;/code&gt; 의 값입니다. 그래서 우리는 유형 싶어 &lt;em&gt;의&lt;/em&gt; 값 &lt;code&gt;Bar&lt;/code&gt; . &lt;code&gt;(Bar: Bar)&lt;/code&gt; 오류로 인해입니다 &lt;code&gt;Bar&lt;/code&gt; : 유형으로 사용할 수 없습니다 다음이 올바른지 때문에, &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="565a855b54dc5d4e5feb1c24229c3c37a0aa82ca" translate="yes" xml:space="preserve">
          <source>We can try to express both of these objects in a single object type. However, we&amp;rsquo;ll quickly run into issues where we know a property exists based on the success property but Flow does not.</source>
          <target state="translated">이 두 객체를 모두 단일 객체 유형으로 표현할 수 있습니다. 그러나 우리는 성공 속성을 기반으로 속성이 존재하지만 흐름은 그렇지 않다는 문제에 빠르게 부딪 칠 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb681ad5a4120e328dc7b7df6b9ecb5757df66ef" translate="yes" xml:space="preserve">
          <source>We can use this type alias to make sure reducers work correctly.</source>
          <target state="translated">이 유형 별명을 사용하여 감속기가 올바르게 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eb5411b6ed2d064b0d0e833606639f58a6b2b5f" translate="yes" xml:space="preserve">
          <source>We get this error message because &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t set the &lt;code&gt;Instance&lt;/code&gt; type parameter, so it is automatically set to &lt;code&gt;mixed&lt;/code&gt;. If we wanted to preserve the instance type of the component, we can use &lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Instance&lt;/code&gt; 유형 매개 변수를 설정하지 않으므로이 오류 메시지가 표시되므로 자동으로 &lt;code&gt;mixed&lt;/code&gt; 로 설정됩니다 . 컴포넌트의 인스턴스 유형을 유지하려면 &lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt; &lt;code&gt;React.forwardRef&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14c408c67aca29a7fa863fd2f5d381f5c8273e88" translate="yes" xml:space="preserve">
          <source>We recommend you enable all your desired rules from the beginning, then adopt Flow Strict file-by-file. This works better than enabling a single rule, adding &lt;code&gt;@flow strict&lt;/code&gt; to many files, and then adding more rules to the config.</source>
          <target state="translated">처음부터 원하는 모든 규칙을 사용하도록 설정 한 다음 파일 단위로 흐름 엄격한을 채택하는 것이 좋습니다. 단일 규칙을 활성화하고 &lt;code&gt;@flow strict&lt;/code&gt; 를 많은 파일에 추가 한 다음 구성에 규칙을 더 추가하는 것보다 효과적 입니다.</target>
        </trans-unit>
        <trans-unit id="34abdcf44b0093985cf9e1d46481109cab9f85f9" translate="yes" xml:space="preserve">
          <source>We removed our dependency on &lt;code&gt;prop-types&lt;/code&gt; and added a Flow object type named &lt;code&gt;Props&lt;/code&gt; with the same shape as the prop types but using Flow&amp;rsquo;s static type syntax. Then we passed our new &lt;code&gt;Props&lt;/code&gt; type into &lt;code&gt;React.Component&lt;/code&gt; as a type argument.</source>
          <target state="translated">&lt;code&gt;prop-types&lt;/code&gt; 에 대한 의존성을 제거하고 prop 유형 과 모양은 동일하지만 Flow의 정적 유형 구문을 사용하여 &lt;code&gt;Props&lt;/code&gt; 라는 Flow 객체 유형을 추가했습니다 . 그런 다음 새로운 &lt;code&gt;Props&lt;/code&gt; 유형을 &lt;code&gt;React.Component&lt;/code&gt; 에 유형 인수로 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="fdbcb95f6a23f42e50318e1968770b634c1e41d0" translate="yes" xml:space="preserve">
          <source>We set the type of props to &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; which will guarantee that &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; must only have children that are &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React elements.</source>
          <target state="translated">소품 유형을 &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; 로 설정하면 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 에 &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React 요소 인 하위 만 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="91fdfa76ed94bd3897d04cec5f4134f4e7bc035e" translate="yes" xml:space="preserve">
          <source>We will refer to all the types in the following reference as if we imported them with:</source>
          <target state="translated">다음 참조에서 모든 유형을 가져온 것처럼 참조합니다.</target>
        </trans-unit>
        <trans-unit id="d0deed72cfe69559a9e7c7724e402ecb7a9ed446" translate="yes" xml:space="preserve">
          <source>We would have a lot of trouble trying to write specific types for this function since it could be anything.</source>
          <target state="translated">이 함수에 대해 특정 유형을 작성하는 데 많은 어려움이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54c34be58b1366378d47ad4ba8a861a9a07fe8d5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll quickly set up our &lt;code&gt;BaseClass&lt;/code&gt; which will define just one method that accepts an input value with the type &lt;code&gt;City&lt;/code&gt; and an returned output also with the type &lt;code&gt;City&lt;/code&gt;.</source>
          <target state="translated">우리는 신속하게 설정할 수 있습니다 &lt;code&gt;BaseClass&lt;/code&gt; 로 유형과 입력 값을 받아 하나의 방법을 정의하고 &lt;code&gt;City&lt;/code&gt; 와 유형도 반환 출력 &lt;code&gt;City&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f20c7e2164e3a5acb3717c0236d43d3267a9c8ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use these classes to write a method that has each kind of variance.</source>
          <target state="translated">이 클래스를 사용하여 각 종류의 분산이있는 메소드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="04c0bd1c623d23997ff99f3caa7042e13039a782" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve demonstrated both nominal and structure typing of classes, but there are also other complex types like objects and functions which can also be either nominal or structural. Even further, they can be different within the same type system (most of the languages listed before has features of both).</source>
          <target state="translated">우리는 클래스의 명목 및 구조 타이핑을 모두 시연했지만 명목 또는 구조적 일 수있는 객체 및 함수와 같은 다른 복잡한 유형도 있습니다. 또한 동일한 유형 시스템 내에서 다를 수 있습니다 (이전에 나열된 대부분의 언어에는 두 가지 기능이 모두 있습니다).</target>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="d40a79cfe25e4cc102f0a57e8b44e1c01d37bcbb" translate="yes" xml:space="preserve">
          <source>WebStorm 2016.3</source>
          <target state="translated">WebStorm 2016.3</target>
        </trans-unit>
        <trans-unit id="6c3e64366f1d6fbef0a5c75ba4449cc79038d05d" translate="yes" xml:space="preserve">
          <source>WebStorm 2017.1</source>
          <target state="translated">WebStorm 2017.1</target>
        </trans-unit>
        <trans-unit id="8f14c5dae174ee34d208589e220dbdb169f943d4" translate="yes" xml:space="preserve">
          <source>Webstorm installation instructions can be found here:</source>
          <target state="translated">웹 스톰 설치 지침은 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f3ba4fbbef59c08df191dcbed16fa19c8defe9" translate="yes" xml:space="preserve">
          <source>What do you think will happen?</source>
          <target state="translated">당신은 어떻게 될 것이라고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="4b5eba71e139ed73ff2a0e9b6ced493bb2e4087c" translate="yes" xml:space="preserve">
          <source>What happens when you have a single child?</source>
          <target state="translated">자녀가 한 명인 경우 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="6966f9bf72c264264a3efaf8dc5ecfa61beb1bb2" translate="yes" xml:space="preserve">
          <source>What happens when you have multiple children?</source>
          <target state="translated">자녀가 여러 명이면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="12b550ae1d285f33798a42afbb386fd6afdc67f5" translate="yes" xml:space="preserve">
          <source>What is a subtype?</source>
          <target state="translated">하위 유형이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ac4ecfb3127c03f684e91c1f130988581c874a06" translate="yes" xml:space="preserve">
          <source>What makes Flow fast?</source>
          <target state="translated">흐름이 빠른 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="db33814c5657c00a949fba0af9d59dbafa3fcb1a" translate="yes" xml:space="preserve">
          <source>What makes Flow precise?</source>
          <target state="translated">흐름이 정확한 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0fd65380fb716403292b7d92faef2766c527f8ab" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s Ahead</source>
          <target state="translated">앞서 무엇입니까</target>
        </trans-unit>
        <trans-unit id="c5e189be8dd7a5933934ab2b958e415933a6e5ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a &amp;ldquo;Library Definition&amp;rdquo;?</source>
          <target state="translated">&quot;라이브러리 정의&quot;란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="40731c621de61ed4b398992215b3e1a3b5986f84" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Declaration File?</source>
          <target state="translated">선언 파일이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b9efc85fa229daf00790235bc1d272e8bf51c10c" translate="yes" xml:space="preserve">
          <source>When an object type has an indexer property, property accesses are assumed to have the annotated type, even if the object does not have a value in that slot at runtime. It is the programmer&amp;rsquo;s responsibility to ensure the access is safe, as with arrays.</source>
          <target state="translated">객체 유형에 인덱서 속성이있는 경우 객체에 런타임시 해당 슬롯에 값이없는 경우에도 속성 액세스에 주석이 달린 유형이있는 것으로 가정합니다. 배열과 마찬가지로 액세스를 안전하게 유지하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="f8b96e1aead97a6dccb4198de5ff7a26c459a398" translate="yes" xml:space="preserve">
          <source>When are subtypes used?</source>
          <target state="translated">하위 유형은 언제 사용됩니까?</target>
        </trans-unit>
        <trans-unit id="1f4a3bdc8dfbb9e08a8423a54448b12d02bbd84f" translate="yes" xml:space="preserve">
          <source>When calling our function that accepts a union type we must pass in &lt;strong&gt;&lt;em&gt;one of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we are required to handle &lt;strong&gt;&lt;em&gt;all of the possible types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">공용체 타입을 받아들이는 함수를 호출 할 때 우리는 &lt;strong&gt;&lt;em&gt;그 타입 중 하나를&lt;/em&gt;&lt;/strong&gt; 전달해야합니다 . 그러나 함수 내 &lt;strong&gt;&lt;em&gt;에서 가능한 모든 유형&lt;/em&gt;&lt;/strong&gt; 을 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="302b36e230abf6c143e3b19fe2499d796c35aef9" translate="yes" xml:space="preserve">
          <source>When comparing a function type with a function it must have the same structure in order to be considered valid.</source>
          <target state="translated">함수 유형을 함수와 비교할 때 유효한 것으로 간주 되려면 동일한 구조를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="64ef3ae0ab9bcb0e4ab1d4e8a1404fcbb0a3607c" translate="yes" xml:space="preserve">
          <source>When comparing an object type with an object it must have the same structure in order to be considered valid.</source>
          <target state="translated">객체 유형을 객체와 비교할 때 유효한 것으로 간주 되려면 동일한 구조를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="8396399d85dff5129d383218ce52eac55a623a9e" translate="yes" xml:space="preserve">
          <source>When importing an opaque type alias, it behaves like a &lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;nominal type&lt;/a&gt;, hiding its underlying type.</source>
          <target state="translated">불투명 한 유형 별명을 가져올 때 기본 유형을 숨기고 &lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;공칭 유형&lt;/a&gt; 처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="d2485de3e0573347cabc863911d04dfca31e158c" translate="yes" xml:space="preserve">
          <source>When in the same file the alias is defined, opaque type aliases behave exactly as regular &lt;a href=&quot;../aliases&quot;&gt;type aliases&lt;/a&gt; do.</source>
          <target state="translated">동일한 파일에서 별명이 정의되면 불투명 한 유형 별명은 일반 &lt;a href=&quot;../aliases&quot;&gt;유형 별명&lt;/a&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="fcb175c445847655877f1db30e472a996195f098" translate="yes" xml:space="preserve">
          <source>When setting a new value inside a tuple, the new value must match the type at that index.</source>
          <target state="translated">튜플 내에서 새 값을 설정할 때 새 값은 해당 인덱스의 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7517a9e192b4a198ec7b3f51067f670add7135eb" translate="yes" xml:space="preserve">
          <source>When someone writes a class, they are declaring a &lt;em&gt;thing&lt;/em&gt;. This thing might have the same structure as something else but they still serve different purposes. Imagine two component classes that both have &lt;code&gt;render()&lt;/code&gt; methods, these components could still have totally different purposes, but in a structural type system they&amp;rsquo;d be considered exactly the same.</source>
          <target state="translated">누군가 수업을 쓰면 &lt;em&gt;무언가를&lt;/em&gt; 선언하는 &lt;em&gt;것&lt;/em&gt; 입니다. 이 것은 다른 것과 같은 구조를 가질 수 있지만 여전히 다른 목적으로 사용됩니다. &lt;code&gt;render()&lt;/code&gt; 메소드를 가진 두 개의 컴포넌트 클래스를 상상해보십시오 .이 컴포넌트들은 여전히 ​​완전히 다른 목적을 가질 수 있지만 구조적 유형 시스템에서는 정확히 같은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="95d1e8cda45984711f6710361a85006d8bcb3ff6" translate="yes" xml:space="preserve">
          <source>When the request fails, we&amp;rsquo;ll get back an object with &lt;code&gt;success&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and an &lt;code&gt;error&lt;/code&gt; property describing the error.</source>
          <target state="translated">요청이 실패하면 &lt;code&gt;success&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정 하고 &lt;code&gt;error&lt;/code&gt; 설명 하는 error 속성 을 가진 개체를 다시 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b94abdda8ce69397406ef44dd82ee02693dedecd" translate="yes" xml:space="preserve">
          <source>When this flag is &lt;code&gt;true&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">이 플래그가 &lt;code&gt;true&lt;/code&gt; 이면 Flow는 다음과 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="1be3aebbba7f2ab96d8a1da1d160dd3a2c2cfa21" translate="yes" xml:space="preserve">
          <source>When using a generic type for a value, Flow will track the value and make sure that you aren&amp;rsquo;t replacing it with something else.</source>
          <target state="translated">값에 일반 유형을 사용하는 경우 Flow는 값을 추적하여 다른 것으로 대체하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="967200160ca1f6e61c2f31daca12d9063b3bdc5b" translate="yes" xml:space="preserve">
          <source>When using this syntax, you are not required to give it a type annotation. But you still can if you need to.</source>
          <target state="translated">이 구문을 사용할 때는 형식 주석을 지정할 필요가 없습니다. 그러나 필요한 경우 여전히 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5028ae04135e00456a2a9a3d217b11e267ea9467" translate="yes" xml:space="preserve">
          <source>When you add a subtyping constraint to an opaque type alias, we allow the opaque type to be used as the super type when outside of the defining file.</source>
          <target state="translated">불투명 유형 별명에 하위 입력 제한 조건을 추가하면, 정의 파일 외부에서 불투명 유형을 수퍼 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f4548b3e8ef7180dc3aa259a4fafbe13e9785c6" translate="yes" xml:space="preserve">
          <source>When you are certain your code works and for some reason Flow is unable to type check it correctly. There are a (decreasing) number of idioms in JavaScript that Flow is unable to statically type.</source>
          <target state="translated">코드가 확실하고 어떤 이유로 플로우가 올바르게 입력을 확인할 수없는 경우. Flow에 정적으로 입력 할 수없는 JavaScript에는 (감소하는) 숙어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0640e9c67a5446e2d096da264d95ec5c0854ffcf" translate="yes" xml:space="preserve">
          <source>When you are declaring a new variable, you may optionally declare its type.</source>
          <target state="translated">새 변수를 선언 할 때 선택적으로 해당 유형을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4a50c3c1cd36ed94156b1a9f3ca046b8801870" translate="yes" xml:space="preserve">
          <source>When you are getting a value from a tuple at a specific index, it will return the type at that index.</source>
          <target state="translated">특정 인덱스의 튜플에서 값을 가져 오면 해당 인덱스의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01a3af0d6ce8b90608026581625e6d89d89308d5" translate="yes" xml:space="preserve">
          <source>When you are in the process of converting existing code to using Flow types and you are currently blocked on having the code type checked (maybe other code needs to be converted first).</source>
          <target state="translated">기존 코드를 플로우 유형을 사용하도록 변환하는 중이고 현재 코드 유형을 확인하지 못하도록 차단 된 경우 (다른 코드를 먼저 변환해야 할 수도 있음).</target>
        </trans-unit>
        <trans-unit id="e1e90957894730cc07cfd478f29c1f4e5b53f0ac" translate="yes" xml:space="preserve">
          <source>When you create an intersection of object types, you merge all of their properties together.</source>
          <target state="translated">객체 유형의 교차를 만들면 모든 속성이 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b45384d6cd9faea2b667285789acfc51eefb58" translate="yes" xml:space="preserve">
          <source>When you create an object with its properties, you create a &lt;em&gt;sealed&lt;/em&gt; object type in Flow. These sealed objects will know all of the properties you declared them with and the types of their values.</source>
          <target state="translated">해당 속성으로 객체를 만들면 Flow에서 &lt;em&gt;봉인 된&lt;/em&gt; 객체 유형 을 만듭니다 . 이 봉인 된 객체는 선언 한 모든 속성과 해당 값의 유형을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41115243f1e2d1d0a4ea4f2efbfe55245e33a0c" translate="yes" xml:space="preserve">
          <source>When you create an object without any properties, you create an &lt;em&gt;unsealed&lt;/em&gt; object type in Flow. These unsealed objects will not know all of their properties and will allow you to add new ones.</source>
          <target state="translated">속성이없는 개체를 만들면 흐름에서 &lt;em&gt;봉인되지 않은&lt;/em&gt; 개체 유형 을 만듭니다 . 이 봉인되지 않은 개체는 모든 속성을 알지 못하므로 새 개체를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2796a6c82e1741b853aad01a67eda238fc96c9eb" translate="yes" xml:space="preserve">
          <source>When you create an opaque type alias with a subtyping constraint, the type in the type position must be a subtype of the type in the super type position.</source>
          <target state="translated">하위 입력 제한 조건을 사용하여 불투명 한 유형 별명을 작성할 때 유형 위치의 유형은 수퍼 유형 위치의 유형의 하위 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="49218e622c26dc57b5c913ea8900e0123789162a" translate="yes" xml:space="preserve">
          <source>When you do not provide a type, the inferred type will do one of two things if you re-assign it.</source>
          <target state="translated">유형을 제공하지 않으면 유추 유형은 다시 할당하면 두 가지 중 하나를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dad7818449b82b15d065d9c37e04d1727c40f683" translate="yes" xml:space="preserve">
          <source>When you have a value which is a union type it&amp;rsquo;s often useful to break it apart and handle each individual type separately. With union types in Flow you can &amp;ldquo;refine&amp;rdquo; the value down to a single type.</source>
          <target state="translated">공용체 유형 인 값이있는 경우 값을 분리하여 각 개별 유형을 개별적으로 처리하는 것이 종종 유용합니다. Flow의 공용체 유형을 사용하면 단일 유형으로 값을 &quot;정의&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb229dc9cf4f41267624f023e36cd675a57c24d6" translate="yes" xml:space="preserve">
          <source>When you have a value with the type &lt;code&gt;any&lt;/code&gt;, you can cause Flow to infer &lt;code&gt;any&lt;/code&gt; for the results of all of the operations you perform.</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 유형의 값이 있으면 Flow가 수행하는 &lt;code&gt;any&lt;/code&gt; 작업의 결과에 대해 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4eeac5c8af6e744b935a9344a38a377561163682" translate="yes" xml:space="preserve">
          <source>When you have complicated types that you want to reuse in multiple places, you can alias them in Flow using a &lt;strong&gt;type alias&lt;/strong&gt;.</source>
          <target state="translated">여러 장소에서 재사용하려는 복잡한 유형이있는 경우 &lt;strong&gt;유형 alias를&lt;/strong&gt; 사용하여 Flow에서 해당 &lt;strong&gt;유형을 별칭으로 지정할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ca6b3bbee47f3932b78bb3624b2a8e13ee5660b" translate="yes" xml:space="preserve">
          <source>When you have two classes with the same structure, they still are not considered equivalent because Flow uses nominal typing for classes.</source>
          <target state="translated">구조가 동일한 두 개의 클래스가있는 경우 Flow는 클래스에 공칭 입력을 사용하기 때문에 여전히 동등한 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10b1b571956caaa58b630e76dcdcbd496c248766" translate="yes" xml:space="preserve">
          <source>When you provide a type, you will be able to re-assign the value, but it must always be of a compatible type.</source>
          <target state="translated">유형을 제공하면 값을 다시 할당 할 수 있지만 항상 호환 가능한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="73cb2287de1c6f15cf8167e43a3d3d87043228a3" translate="yes" xml:space="preserve">
          <source>When you retrieve an element from an array there is always a possibility that it is &lt;code&gt;undefined&lt;/code&gt;. You could have either accessed an index which is out of the bounds of the array, or the element could not exist because it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">배열에서 요소를 검색 할 때 항상 &lt;code&gt;undefined&lt;/code&gt; 가능성이 있습니다 . 배열의 범위를 벗어난 인덱스에 액세스했거나 &quot;스파 스 배열&quot;이므로 요소가 존재할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="996a2595f6a66f040b899960922e9f1e015492aa" translate="yes" xml:space="preserve">
          <source>When you run your code, a single expression will only be run with a limited set of values. But still Flow checks &lt;em&gt;every&lt;/em&gt; possible value. In this way Flow is checking too many things or &lt;em&gt;over-approximating&lt;/em&gt; what will be valid code.</source>
          <target state="translated">코드를 실행할 때 단일 표현식은 제한된 값 세트로만 실행됩니다. 그러나 여전히 흐름은 가능한 &lt;em&gt;모든&lt;/em&gt; 값을 확인 합니다. 이런 식으로 Flow는 너무 많은 것들을 확인하거나 유효한 코드가 무엇인지 &lt;em&gt;과대 평가&lt;/em&gt; 하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfdf2c27394909eba3b1ac9709368e9e60c92c6c" translate="yes" xml:space="preserve">
          <source>When you strip the types all that is left is the value.</source>
          <target state="translated">유형을 제거하면 남은 모든 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="16d02930754982f643818365c9eb65e4b4b501a2" translate="yes" xml:space="preserve">
          <source>When you try to use a value of a &lt;code&gt;mixed&lt;/code&gt; type you must first figure out what the actual type is or you&amp;rsquo;ll end up with an error.</source>
          <target state="translated">&lt;code&gt;mixed&lt;/code&gt; 유형 의 값을 사용하려고 할 때 먼저 실제 유형이 무엇인지 파악해야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a280997d975deface44a674ffdcce743182e95b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re inserting another type with all of its behaviors. This can make &lt;code&gt;typeof&lt;/code&gt; seem inconsistent where it is not.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 를 사용하면 모든 비헤이비어와 함께 다른 유형을 삽입합니다. 이렇게하면 &lt;code&gt;typeof&lt;/code&gt; 가 일치하지 않는 것처럼 보일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06a3b2f1c8635c3489f18114c859485b4887b6c9" translate="yes" xml:space="preserve">
          <source>When you use this function, Flow knows exactly what is going on.</source>
          <target state="translated">이 기능을 사용하면 Flow는 현재 진행중인 작업을 정확히 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b433fb4be7e2c12ca3f57f9ed0a23cad0b0d75ad" translate="yes" xml:space="preserve">
          <source>When you write a type cast expression, the result of that expression is the value with the provided type. If you hold onto the resulting value, it will have the new type.</source>
          <target state="translated">유형 캐스트 ​​표현식을 작성할 때 해당 표현식의 결과는 제공된 유형의 값입니다. 결과 값을 유지하면 새로운 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f053b01bbe2e5493eb03b59a33406b2934f8f5" translate="yes" xml:space="preserve">
          <source>Whenever you want to use a class field in Flow you must first give it an annotation.</source>
          <target state="translated">Flow에서 클래스 필드를 사용할 때마다 먼저 주석을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="007c9142c650370d910eaa325adeac0c9f34bd33" translate="yes" xml:space="preserve">
          <source>Where to put the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 를 넣을 위치</target>
        </trans-unit>
        <trans-unit id="f9cd9b92722317ed472575adad6561c4aaa8a0c9" translate="yes" xml:space="preserve">
          <source>Which also applies to nested types within objects.</source>
          <target state="translated">이는 객체 내 중첩 형식에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d77dcbc51b2f3900b8512f7fcc4c2e9f1910a53" translate="yes" xml:space="preserve">
          <source>Which then gets used as its own type.</source>
          <target state="translated">그런 다음 자체 유형으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a80fced10ab4b19389a445b9f4af05de4c583bb" translate="yes" xml:space="preserve">
          <source>Which would ignore any file or directory under the directory named &lt;code&gt;__tests__/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/__tests__/.*&lt;/code&gt;, it would NOT ignore files or directories under other directories named &lt;code&gt;__tests__/&lt;/code&gt;, like &lt;code&gt;src/__tests__/&lt;/code&gt;.</source>
          <target state="translated">프로젝트 루트 내의 &lt;code&gt;__tests__/&lt;/code&gt; 디렉토리 아래의 파일이나 디렉토리는 무시합니다 . 그러나 이전 예제의 &lt;code&gt;.*/__tests__/.*&lt;/code&gt; 와 달리 &lt;code&gt;src/__tests__/&lt;/code&gt; 와 같이 &lt;code&gt;__tests__/&lt;/code&gt; 라는 다른 디렉토리에있는 파일이나 디렉토리는 무시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c59a762c09f756bb3fe009f558e38099bc0a51a6" translate="yes" xml:space="preserve">
          <source>Which would parse in declaration mode any file or directory under the directory named &lt;code&gt;third_party/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/third_party/.*&lt;/code&gt;, it would NOT parse files or directories under directories named &lt;code&gt;third_party/&lt;/code&gt;, like &lt;code&gt;src/third_party/&lt;/code&gt;.</source>
          <target state="translated">선언 모드 에서 프로젝트 루트 내의 &lt;code&gt;third_party/&lt;/code&gt; 디렉토리 아래에있는 파일 또는 디렉토리를 구문 분석 합니다. 그러나 이전 예제의 &lt;code&gt;.*/third_party/.*&lt;/code&gt; 와는 달리 &lt;code&gt;src/third_party/&lt;/code&gt; 와 같이 &lt;code&gt;third_party/&lt;/code&gt; 라는 디렉토리에서 파일 또는 디렉토리를 구문 분석하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6bbea4304dd73554152ad23aedd562115dbd9129" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;all&lt;/code&gt; isn&amp;rsquo;t technically a lint rule, it&amp;rsquo;s worth mentioning here. &lt;code&gt;all&lt;/code&gt; sets the default level for lint rules that don&amp;rsquo;t have a level set explicitly. &lt;code&gt;all&lt;/code&gt; can only occur as the first entry in a &lt;code&gt;.flowconfig&lt;/code&gt; or as the first rule in a &lt;code&gt;--lints&lt;/code&gt; flag. It&amp;rsquo;s not allowed in comments at all because it would have different semantics than would be expected.</source>
          <target state="translated">하지만 &lt;code&gt;all&lt;/code&gt; 기술적으로 보풀이 규칙 아니라, 그것의 가치는 여기에 언급. &lt;code&gt;all&lt;/code&gt; 레벨이 명시 적으로 설정되지 않은 보푸라기 규칙의 기본 레벨을 설정합니다. &lt;code&gt;all&lt;/code&gt; &lt;code&gt;.flowconfig&lt;/code&gt; 의 첫 번째 항목 또는 &lt;code&gt;--lints&lt;/code&gt; 플래그 의 첫 번째 규칙으로 만 발생할 수 있습니다 . 예상과 다른 의미를 갖기 때문에 주석에는 전혀 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52ea1ea47df53d1cf736a6d4890e67395ca8b9c4" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass &lt;code&gt;{a:string}&lt;/code&gt; to a function that takes &lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt; 을 사용하는 함수에 &lt;code&gt;{a:string}&lt;/code&gt; 을 전달할 수없는 이유는 무엇입니까? 번호}</target>
        </trans-unit>
        <trans-unit id="fe6cefc353f86770ed15c2136f41c2eff2427e68" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass an &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; to a function that takes an &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</source>
          <target state="translated">왜이 통과 할 수 &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; 받는 함수에 &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c5c443e0f5b7e99e95365f6c4edd88369864cd" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I refine a union of objects?</source>
          <target state="translated">객체 통합을 구체화 할 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6e3de66a2c90224644ba944e2aa7479606459060" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I use a function in my if-clause to check the type of a property?</source>
          <target state="translated">if-clause에서 함수를 사용하여 속성 유형을 확인할 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="30ff0da03e55358af58809fea89afe7aa72356c6" translate="yes" xml:space="preserve">
          <source>Width Subtyping</source>
          <target state="translated">폭 서브 타이핑</target>
        </trans-unit>
        <trans-unit id="c4a257d9d182ebc37abf03c9319df6d8959cf5db" translate="yes" xml:space="preserve">
          <source>With Flow build step, using flow-bin</source>
          <target state="translated">플로우 빌드 단계를 사용하여 플로우 빈 사용</target>
        </trans-unit>
        <trans-unit id="2995c53166bcc91b45280d17fe04fd71848fc06d" translate="yes" xml:space="preserve">
          <source>With exact object types, we cannot have additional properties, so the objects conflict with one another and we are able to distinguish which is which.</source>
          <target state="translated">정확한 객체 유형을 사용하면 추가 속성을 가질 수 없으므로 객체가 서로 충돌하여 어느 것을 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6943265cff3d8a72357d6db4963743033fc9d4b" translate="yes" xml:space="preserve">
          <source>With modularity, we can aggressively parallelize our analysis. Furthermore, when files change, we can incrementally analyze only those files that depend on the changed files. Together, these choices have helped scale the analysis to millions of lines of code.</source>
          <target state="translated">모듈성을 통해 분석을 적극적으로 병렬화 할 수 있습니다. 또한 파일이 변경되면 변경된 파일에 의존하는 파일 만 증분 분석 할 수 있습니다. 이러한 선택을 통해 수백만 줄의 코드로 분석을 확장 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="3574433dfccbc2cdc3e7d09b6a827e56cbb69b39" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;method&lt;/code&gt;, we know that &lt;code&gt;obj&lt;/code&gt; has at least a property &lt;code&gt;foo&lt;/code&gt; and the property access expression &lt;code&gt;obj.foo&lt;/code&gt; will have type &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; 내에서 , 우리는 &lt;code&gt;obj&lt;/code&gt; 가 최소한 &lt;code&gt;foo&lt;/code&gt; 라는 속성 을 가지고 있고 속성 액세스 표현식 &lt;code&gt;obj.foo&lt;/code&gt; 는 유형 &lt;code&gt;string&lt;/code&gt; 가짐을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f4fbc91308a94a65821208a1c024c9c0775a04d" translate="yes" xml:space="preserve">
          <source>Within the -lints flag and the flowconfig, rules lower down override rules higher up, allowing you to write things like</source>
          <target state="translated">-lints 플래그와 flowconfig 내에서 규칙 아래로 규칙을 재정 의하여 규칙 아래로 다시 작성하여 다음과 같은 내용을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c37d919a96ee4ea89b463c060f82bc0a6e402a8f" translate="yes" xml:space="preserve">
          <source>Within the Defining File</source>
          <target state="translated">정의 파일 내</target>
        </trans-unit>
        <trans-unit id="d68dc31f474400f6b50bf4dad60cd35f6668b0b3" translate="yes" xml:space="preserve">
          <source>Within the body of a &lt;code&gt;declare module&lt;/code&gt; block, you can specify the set of exports for that module. However, before we start talking about exports we have to talk about the two kinds of modules that Flow supports: CommonJS and ES modules.</source>
          <target state="translated">&lt;code&gt;declare module&lt;/code&gt; 블록 의 본문 내에서 해당 모듈의 내보내기 세트를 지정할 수 있습니다. 그러나 내보내기에 대해 이야기하기 전에 Flow가 지원하는 두 가지 종류의 모듈 인 CommonJS 및 ES 모듈에 대해 이야기해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3933bb581c579641e65e780ba1a7fc018cbb1e5" translate="yes" xml:space="preserve">
          <source>Write Flow Code</source>
          <target state="translated">흐름 코드 작성</target>
        </trans-unit>
        <trans-unit id="0d42dc7f273412358b6af025e21835f6b2b59f3c" translate="yes" xml:space="preserve">
          <source>You are destructuring the object. When destructuring, Flow loses track of object properties.</source>
          <target state="translated">객체를 파괴하고 있습니다. 구조를 제거 할 때 Flow는 객체 속성을 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a1fd67e5d3bc9809749035f19782f6067817cf6" translate="yes" xml:space="preserve">
          <source>You are not allowed to do the following when using &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; 사용시 다음을 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cb97175b80248d75078c2d56240c55e682afdb8b" translate="yes" xml:space="preserve">
          <source>You are using inexact objects.</source>
          <target state="translated">정확하지 않은 개체를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="545f113ee57613cf761d4e16a9296f0dddf18ea1" translate="yes" xml:space="preserve">
          <source>You can add methods to interfaces following the same syntax as object methods.</source>
          <target state="translated">객체 메소드와 동일한 구문에 따라 인터페이스에 메소드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f13b654915322571d79f9d2209ebb3f541cb4c01" translate="yes" xml:space="preserve">
          <source>You can add properties to interfaces following the same syntax as object properties.</source>
          <target state="translated">객체 속성과 동일한 구문에 따라 인터페이스에 속성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ff142ce9ee3fec9b4cc52b1ba40b05d9245d3f7" translate="yes" xml:space="preserve">
          <source>You can add support for Flow in Emacs by using &lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs를&lt;/a&gt; 사용하여 Emacs에서 Flow에 대한 지원을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f60bece6a43fa1f4f89bb550305ddcf7599cfe4f" translate="yes" xml:space="preserve">
          <source>You can add this to your &lt;code&gt;package.json&lt;/code&gt; scripts easily.</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 스크립트에 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c722675694802907c5488d3f01827234fdbd4367" translate="yes" xml:space="preserve">
          <source>You can also add type annotations for rest parameters using the same syntax but with an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">동일한 구문을 사용하지만 &lt;code&gt;Array&lt;/code&gt; 를 사용하여 나머지 매개 변수에 대한 유형 주석을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e71d63fcbe7402ef7a02851894adf81dac971541" translate="yes" xml:space="preserve">
          <source>You can also adopt Flow incrementally and easily remove it at anytime, so you can try Flow out on any codebase and see how you like it.</source>
          <target state="translated">Flow를 점진적으로 채택하고 언제든지 쉽게 제거 할 수 있으므로 모든 코드베이스에서 Flow out을 시도하여 원하는 방식을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="699187814f44354c9d5904df70d1d9ddacb546d5" translate="yes" xml:space="preserve">
          <source>You can also create arrays and add values to them later on:</source>
          <target state="translated">배열을 만들고 나중에 값을 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c646f56329a9cb5b56e87a03fe5b8a2719eb6c74" translate="yes" xml:space="preserve">
          <source>You can also declare opaque type aliases in &lt;a href=&quot;../libdefs&quot;&gt;libdefs&lt;/a&gt;. There, you omit the underlying type, but may still optionally include a super type.</source>
          <target state="translated">&lt;a href=&quot;../libdefs&quot;&gt;libdefs&lt;/a&gt; 에서 불투명 한 유형 별칭을 선언 할 수도 있습니다 . 기본 유형은 생략하지만 선택적으로 수퍼 유형을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd17629705a4d950906c4a4641c7cec10003dd5" translate="yes" xml:space="preserve">
          <source>You can also give generic classes type arguments directly in the &lt;code&gt;new&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 표현식 에서 일반 클래스 유형 인수를 직접 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0940d878e3d44c8bd9c7d98cbd45fecf2f71a13" translate="yes" xml:space="preserve">
          <source>You can also have optional parameters by adding a question mark &lt;code&gt;?&lt;/code&gt; after the name of the parameter and before the colon &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">물음표를 추가하여 선택적 매개 변수를 가질 수도 있습니다 &lt;code&gt;?&lt;/code&gt; 매개 변수의 이름 뒤에 콜론 전에 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cbe3e05438e8030d576dbde48b1eceb1121d9a3" translate="yes" xml:space="preserve">
          <source>You can also nest calls to &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, which is useful when you need to access the types inside nested structures:</source>
          <target state="translated">&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; 호출을 중첩 할 수도 있습니다 . 이는 중첩 구조 내의 유형에 액세스해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="815ff0c60624ac9094cf1c49f665f71a3473e58d" translate="yes" xml:space="preserve">
          <source>You can also provide defaults for parameterized generics just like parameters of a function.</source>
          <target state="translated">함수의 매개 변수와 마찬가지로 매개 변수화 된 제네릭에 대한 기본값을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="719a9a50e459a2a6ce7e2c56e63ed6b525dc0279" translate="yes" xml:space="preserve">
          <source>You can also specify the subtyping behavior of a generic via variance sigils. By default, generics behave invariantly, but you may add a &lt;code&gt;+&lt;/code&gt; to their declaration to make them behave covariantly, or a &lt;code&gt;-&lt;/code&gt; to their declaration to make them behave contravariantly. See &lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;our docs on variance&lt;/a&gt; for a more information on variance in Flow.</source>
          <target state="translated">분산 비아 분산시길의 일반 입력 동작을 지정할 수도 있습니다. 기본적으로 제네릭은 변하지 않게 동작하지만 선언에 &lt;code&gt;+&lt;/code&gt; 를 추가하여 동일 하게 동작하도록하거나 선언에 &lt;code&gt;-&lt;/code&gt; 를 추가하여 반 변적으로 동작하도록 할 수 있습니다. Flow의 &lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;분산&lt;/a&gt; 에 대한 자세한 내용은 분산에 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9363b7818b6e43e3422f3ad1d7ee6efa7ab8e46" translate="yes" xml:space="preserve">
          <source>You can also type &lt;code&gt;flow&lt;/code&gt; to accomplish the same effect as &lt;code&gt;status&lt;/code&gt; is the default flag to the &lt;code&gt;flow&lt;/code&gt; binary.</source>
          <target state="translated">또한 입력 할 수 있습니다 &lt;code&gt;flow&lt;/code&gt; 과 동일한 효과를 달성하기 위해 &lt;code&gt;status&lt;/code&gt; 받는 기본 플래그입니다 &lt;code&gt;flow&lt;/code&gt; 이진.</target>
        </trans-unit>
        <trans-unit id="b68e51da33b5e539af5dbf6e3dcc5a59c33fe6c7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; to tell Flow that you want the class to match an interface. This prevents you from making incompatible changes when editing the class.</source>
          <target state="translated">또한 클래스를 인터페이스와 일치 시키려면 Flow를 알리기 위해 &lt;code&gt;implements&lt;/code&gt; 을 사용할 수 있습니다 . 이렇게하면 클래스를 편집 할 때 호환되지 않는 변경을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3a1292b81cf7cdb77a98439b57cf0147e0f8f3b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; with multiple interfaces.</source>
          <target state="translated">여러 인터페이스가있는 &lt;code&gt;implements&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48dd13ac8774ad647e286bd9947352ec269d5800" translate="yes" xml:space="preserve">
          <source>You can also use named type imports in either an ES module environment or a CommonJS environment:</source>
          <target state="translated">ES 모듈 환경 또는 CommonJS 환경에서 명명 된 유형 가져 오기를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a88daebe91d272da9a7e038c3583dda16175e43" translate="yes" xml:space="preserve">
          <source>You can also use the form &lt;code&gt;/* @flow */&lt;/code&gt; for the flag as well.</source>
          <target state="translated">플래그에 &lt;code&gt;/* @flow */&lt;/code&gt; 형식을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01c4697a441a0d2aa3c1b9f07e0ceb2ffc32acec" translate="yes" xml:space="preserve">
          <source>You can also validate that you have handled every single type of action by using the &lt;code&gt;empty&lt;/code&gt; type in your &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 사례 에서 &lt;code&gt;empty&lt;/code&gt; 유형 을 사용하여 모든 단일 유형의 작업을 처리했는지 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d608633d54b23080262b0d07f6cb7d3dc534564" translate="yes" xml:space="preserve">
          <source>You can benefit from having Flow run as you develop by integrating into your editor.</source>
          <target state="translated">편집기에 통합하여 개발할 때 Flow를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dcc931397145e4c230e84b33d5d8a5720c03798" translate="yes" xml:space="preserve">
          <source>You can create &lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&amp;ldquo;indexer properties&amp;rdquo;&lt;/a&gt; the same way as with objects.</source>
          <target state="translated">개체와 같은 방식으로 &lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&quot;인덱서 속성&quot;을&lt;/a&gt; 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7946b65fbac98e9648cd5f68e306b48534b1a74" translate="yes" xml:space="preserve">
          <source>You can do that by adding an explicit type argument:</source>
          <target state="translated">명시 적 유형 인수를 추가하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7fff0a703433e91168cd9bf5a21b4d5e3872e70" translate="yes" xml:space="preserve">
          <source>You can enable stronger safety guarantees in Flow (such as banning &lt;code&gt;any&lt;/code&gt;/&lt;code&gt;Object&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt; types and requiring all dependencies to be typed) by adding &lt;strong&gt;&lt;code&gt;@flow strict&lt;/code&gt;&lt;/strong&gt; to your files.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;@flow strict&lt;/code&gt; &lt;/strong&gt; 를 파일 에 추가하여 Flow에서 (예 : &lt;code&gt;any&lt;/code&gt; / &lt;code&gt;Object&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; 유형 금지 및 모든 종속성 입력 요구 와 같은)보다 강력한 안전성을 보장 할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa5fe932d239a06fd9575f03866b957b8981092" translate="yes" xml:space="preserve">
          <source>You can enforce this in Flow by making every property effectively &amp;ldquo;read-only&amp;rdquo; using &amp;ldquo;covariant&amp;rdquo; properties throughout your state object.</source>
          <target state="translated">상태 개체 전체의 &quot;공변량&quot;속성을 사용하여 모든 속성을 효과적으로 &quot;읽기 전용&quot;으로 만들어 흐름에서이를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba6431d84c3e47b98b215406e4d6e813fefabd22" translate="yes" xml:space="preserve">
          <source>You can even nest lookups:</source>
          <target state="translated">조회를 중첩 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ccb58e74c71e2de2b124e20c360c5995e2ecd92" translate="yes" xml:space="preserve">
          <source>You can expand this even further and keep refining possibilities away:</source>
          <target state="translated">이를 더욱 확장하고 정제 가능성을 멀리 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2afe0e2209309fcca1d0d4c82e4b42131180ea4" translate="yes" xml:space="preserve">
          <source>You can fix this by making &lt;code&gt;truthy&lt;/code&gt; a &lt;em&gt;predicate function&lt;/em&gt;, by using the &lt;code&gt;%checks&lt;/code&gt; annotation like so:</source>
          <target state="translated">당신함으로써이 문제를 해결할 수 &lt;code&gt;truthy&lt;/code&gt; &lt;em&gt;술어 기능을&lt;/em&gt; 사용하여 &lt;code&gt;%checks&lt;/code&gt; 때문에 같은 주석 :</target>
        </trans-unit>
        <trans-unit id="1300bdbd711a74807a169ed243bc8221cc1ddb60" translate="yes" xml:space="preserve">
          <source>You can force Flow to treat one or more files as focused from the CLI.</source>
          <target state="translated">Flow가 하나 이상의 파일을 CLI에서 포커스 된 것으로 처리하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="235ba8a2cc1e9c6fd298a395322859ee23a447be" translate="yes" xml:space="preserve">
          <source>You can get around this by storing your checked values in local variables:</source>
          <target state="translated">확인 된 값을 로컬 변수에 저장 하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fd44f437add0d9e133a8562afc12f273306434" translate="yes" xml:space="preserve">
          <source>You can give callable entities type arguments for their generics directly in the call:</source>
          <target state="translated">호출 가능한 엔티티에 호출에 대한 제네릭에 대한 인수를 직접 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ade9cad1bbc6b49fbea6fdd6de913340f01abe2" translate="yes" xml:space="preserve">
          <source>You can have as many of these generics as you need in the type parameter list, naming them whatever you want:</source>
          <target state="translated">type 매개 변수 목록에 필요한만큼 많은 제네릭을 가질 수 있으며 원하는 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf2172f11dbbcc47d7a009c576faeb7aa356654" translate="yes" xml:space="preserve">
          <source>You can make a property contravariant by adding a minus symbol - in front of the property name.</source>
          <target state="translated">속성 이름 앞에 빼기 기호를 추가하여 속성을 반 변형으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bdca1788706e2fc8e4a9c9a6e2d01cd32f92dcf" translate="yes" xml:space="preserve">
          <source>You can make a property covariant by adding a plus symbol &lt;code&gt;+&lt;/code&gt; in front of the property name.</source>
          <target state="translated">속성 이름 앞에 더하기 기호 &lt;code&gt;+&lt;/code&gt; 를 추가하여 속성을 공변량으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b010851670e4ca7a130bea951f459af8dca6a36b" translate="yes" xml:space="preserve">
          <source>You can optionally add a subtyping constraint to an opaque type alias by adding a colon &lt;code&gt;:&lt;/code&gt; and a type after the name.</source>
          <target state="translated">선택적으로 이름 뒤에 콜론 &lt;code&gt;:&lt;/code&gt; 및 유형 을 추가하여 불투명 한 유형 별명에 하위 유형 제한 조건을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd2496b164e62d7e0f41690b9f5e9552b1b451b8" translate="yes" xml:space="preserve">
          <source>You can pass as many arguments as you want into a rest parameter.</source>
          <target state="translated">rest 매개 변수에 원하는만큼의 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bd5c0ce38f5afd67d2acbbfbe61b90c3c48db4" translate="yes" xml:space="preserve">
          <source>You can put any type within &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; 내에 모든 유형을 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="732207deaac1dc0f323e2c9b02fc147f8f812da1" translate="yes" xml:space="preserve">
          <source>You can simplify the two checks against &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; using a single &lt;code&gt;!= null&lt;/code&gt; check which will do both.</source>
          <target state="translated">하나의 &lt;code&gt;!= null&lt;/code&gt; 검사를 사용하여 &lt;code&gt;null&lt;/code&gt; 검사 와 &lt;code&gt;undefined&lt;/code&gt; 에 대해 두 검사를 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9afabef0657e245fef1b9b2930123308edd5afac" translate="yes" xml:space="preserve">
          <source>You can specify in the &lt;code&gt;.flowconfig&lt;/code&gt; which version of Flow you expect to use. You do this with the &lt;code&gt;[version]&lt;/code&gt; section. If this section is omitted or left blank, then any version is allowed. If a version is specified and not matched, then Flow will immediately error and exit.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; 에서 사용할 Flow 버전을 지정할 수 있습니다 . &lt;code&gt;[version]&lt;/code&gt; 섹션 에서이 작업을 수행 하십시오. 이 섹션을 생략하거나 비워두면 모든 버전이 허용됩니다. 버전이 지정되어 있고 일치하지 않으면 Flow는 즉시 오류가 발생하고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e03b894ceec87547a288939cd8aaf30ae007c81b" translate="yes" xml:space="preserve">
          <source>You can start to compare two objects by their keys. If one object contains all the keys of another object, then it may be a subtype.</source>
          <target state="translated">두 객체를 키로 비교할 수 있습니다. 한 객체에 다른 객체의 모든 키가 포함 된 경우 하위 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d28e07b9c51e5ffadf873da6f7a3f54bbf76f2f9" translate="yes" xml:space="preserve">
          <source>You can then, further dig into particular COMMANDs by adding the &lt;code&gt;--help&lt;/code&gt; flag.</source>
          <target state="translated">그런 다음 &lt;code&gt;--help&lt;/code&gt; 플래그 를 추가하여 특정 명령을 추가로 파헤칠 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd1e8c4360056b71335ea367a6b3e679639d25f3" translate="yes" xml:space="preserve">
          <source>You can think of this like passing arguments to a function, only the return value is a type that you can use.</source>
          <target state="translated">이것을 인자를 함수에 전달하는 것처럼 생각할 수 있습니다. 반환 값만 사용할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="77a6915e052949d36dbc7c36f8a0ffc2fd6eea09" translate="yes" xml:space="preserve">
          <source>You can update your code to the more readable:</source>
          <target state="translated">코드를보다 읽기 쉽게 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebd1cddf8c517151cd84a6cfd9b8b49383f2e6c4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; to refine to a symbol.</source>
          <target state="translated">&lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; 를 사용하여 기호를 구체화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b81520be069e0fa0c9db8cbcabf710cfccf37e42" translate="yes" xml:space="preserve">
          <source>You can use any value with &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 와 함께 모든 값을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5eb1e9ebfd9c95be03ab9be04d025560b3074e1c" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a class (property types and method parameter/return types).</source>
          <target state="translated">클래스에 다른 유형을 추가 할 때와 동일한 위치 (속성 유형 및 메소드 매개 변수 / 반환 유형)에서 제네릭을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4aa0e86d6f17a2f8d19918819c102cbd6c3820e" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function (parameter or return types).</source>
          <target state="translated">함수에 다른 유형 (파라미터 또는 리턴 유형)을 추가 할 곳과 동일한 위치에서 제네릭을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de2ccca92b2b43ac3dc44c63b7e55c6b432c76a" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function type (parameter or return types).</source>
          <target state="translated">함수 유형 (매개 변수 또는 리턴 유형)에 다른 유형을 추가 할 곳과 동일한 위치에서 제네릭을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d107b2ef0635398f316220ce167c042b23a92d8" translate="yes" xml:space="preserve">
          <source>You can use primitive values for these types:</source>
          <target state="translated">다음 유형에 기본 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1997334cf38d8070cc18855e7eb4a51b9f7aa599" translate="yes" xml:space="preserve">
          <source>You can use this in combination with &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; to get static props:</source>
          <target state="translated">정적 소품을 얻기 위해 이것을 &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b38b57891c6a590d35857959678efd3a7cbc9edf" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;Array.prototype&lt;/code&gt; methods that mutate the tuple, only ones that do not.</source>
          <target state="translated">튜플을 변경하는 &lt;code&gt;Array.prototype&lt;/code&gt; 메소드는 사용할 수없고 그렇지 않은 메소드 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34cdb6dbd42effcc5eee6814751e14333d7ad7b4" translate="yes" xml:space="preserve">
          <source>You could also flip it around, and check to make sure that the value has a type of &lt;code&gt;number&lt;/code&gt; before using it.</source>
          <target state="translated">뒤집을 수도 있고 사용하기 전에 값에 &lt;code&gt;number&lt;/code&gt; 유형이 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d54fcc4baacde621798558cd944fe72a2272653e" translate="yes" xml:space="preserve">
          <source>You could continue this process until &lt;code&gt;any&lt;/code&gt; has leaked all over your code.</source>
          <target state="translated">때까지이 과정을 계속 할 수 &lt;code&gt;any&lt;/code&gt; 코드를 통해 모두를 유출했다.</target>
        </trans-unit>
        <trans-unit id="a5ccb2330f2aef610502456380da1cc91e063a81" translate="yes" xml:space="preserve">
          <source>You could do</source>
          <target state="translated">넌 할 수있어</target>
        </trans-unit>
        <trans-unit id="a96c3e789576bc7f92cd0b34129750d6ad259391" translate="yes" xml:space="preserve">
          <source>You could refine the type, but the generic will still allow any type to be passed in.</source>
          <target state="translated">유형을 구체화 할 수 있지만 제네릭에서는 여전히 모든 유형을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce625c160012e98036189d91961fd70764c6f12" translate="yes" xml:space="preserve">
          <source>You could then use the resulting value in another operation, such as adding it as if it were a number and the result will also be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">그런 다음 결과를 숫자처럼 추가하고 결과도 &lt;code&gt;any&lt;/code&gt; 가되는 것과 같은 다른 연산에서 결과 값을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d0c0f6b4e6d2338d922e76b590f2d36d1904032" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to annotate the return type of either your &lt;code&gt;render()&lt;/code&gt; method or a stateless functional component. However, if you want to annotate the return type then &lt;code&gt;React.Node&lt;/code&gt; is the generic to use.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; 메소드 또는 상태 비 저장 기능 구성 요소 의 리턴 유형에 주석을 달지 않아도됩니다 . 그러나 반환 유형에 주석을 &lt;code&gt;React.Node&lt;/code&gt; 가 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="2f9c2c80449347f7166dc305529f30c45a9e9eed" translate="yes" xml:space="preserve">
          <source>You may also add a leading ampersand which is useful when breaking intersection types onto multiple lines.</source>
          <target state="translated">교차점 유형을 여러 줄로 나눌 때 유용한 선행 앰퍼샌드를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa909f29db190474cf723005ff4008d9b7598e9" translate="yes" xml:space="preserve">
          <source>You may also add a leading vertical bar which is useful when breaking union types onto multiple lines.</source>
          <target state="translated">공용체 유형을 여러 줄로 나눌 때 유용한 선행 세로 막대를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9fdbe0651aa0dcc77f656e366ff86ea773ba26" translate="yes" xml:space="preserve">
          <source>You may also optionally leave out the parameter names.</source>
          <target state="translated">선택적으로 매개 변수 이름을 생략 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8369235f7cc951c26ca572a5f0d1089b25b9b0f4" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a property on instances of the class).</source>
          <target state="translated">Flow가 단순히 구문을 무시해야 함을 나타내 도록 &lt;code&gt;ignore&lt;/code&gt; 하도록 설정할 수도 있습니다 (예 : Flow는이 구문을 사용하여 클래스 인스턴스에 속성이 있음을 나타냅니다).</target>
        </trans-unit>
        <trans-unit id="12abc47c0cac769438a2a10d53130bb5088f3b42" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a static property on the class).</source>
          <target state="translated">Flow가 단순히 구문을 무시해야 함을 나타내 도록 &lt;code&gt;ignore&lt;/code&gt; 하도록 설정할 수도 있습니다 (예 : Flow는이 구문을 사용하여 클래스에 정적 속성이 있음을 나타냅니다).</target>
        </trans-unit>
        <trans-unit id="bfbbefdd992a4649126e811e71f05644039bb6d5" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax.</source>
          <target state="translated">흐름이 단순히 구문을 무시해야 함을 나타내 도록 &lt;code&gt;ignore&lt;/code&gt; 하도록 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43a0ac12f9014a2da637bcb44bcbb4fbf90a6924" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax. The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">흐름이 단순히 구문을 무시해야 함을 나타내 도록 &lt;code&gt;ignore&lt;/code&gt; 하도록 설정할 수도 있습니다 . 이 옵션의 기본값은 &lt;code&gt;warn&lt;/code&gt; 이며,이 제안은 아직 초기 단계이므로 사용에 대한 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="aa76b5b2c71934a0d36af87656f7165b00582a43" translate="yes" xml:space="preserve">
          <source>You may also wish to install a popular SublimeLinter plugin for Flow like &lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt; 와 같은 인기있는 SublimeLinter 플러그인을 설치하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bd52a5c29c3e64a83bb0f62e994bfb74ab453fe3" translate="yes" xml:space="preserve">
          <source>You might use these functions types for something like a callback.</source>
          <target state="translated">콜백과 같은 기능에 이러한 함수 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ed4bf60715e28afa28e2fa5a72f5002c15618be" translate="yes" xml:space="preserve">
          <source>You must always include the brackets &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; when using the type (just like parentheses for a function call).</source>
          <target state="translated">유형을 사용할 때는 항상 괄호 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 를 포함해야합니다 (함수 호출의 괄호처럼).</target>
        </trans-unit>
        <trans-unit id="99f73949e10ba9c21b14d2d45c52b596aa157461" translate="yes" xml:space="preserve">
          <source>You must be explicit and convert other types into strings. You can do this by using the String method or using another method for stringifying values.</source>
          <target state="translated">명시 적이어야하며 다른 유형을 문자열로 변환해야합니다. String 메소드를 사용하거나 값을 문자열 화하는 다른 메소드를 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01b16b93eebbf6cd3d2d130c4da4b067de2c5876" translate="yes" xml:space="preserve">
          <source>You should represent these values with &lt;code&gt;mixed&lt;/code&gt;.</source>
          <target state="translated">이 값을 &lt;code&gt;mixed&lt;/code&gt; 로 나타내야합니다 .</target>
        </trans-unit>
        <trans-unit id="e73e4c01718490bcf4d4cc882d49967190833cfe" translate="yes" xml:space="preserve">
          <source>You will have access to all of the values that React exports, but you will &lt;strong&gt;not&lt;/strong&gt; have access to the types documented below! This is because Flow will not add types to a default export since the default export could be any value (like a number). Flow will add exported named types to an ES namespace object which you can get with &lt;code&gt;import * as React from 'react'&lt;/code&gt; since Flow knows if you export a value with the same name as an exported type.</source>
          <target state="translated">React가 내보내는 모든 값에 액세스 할 수 있지만 아래에 설명 된 유형에는 액세스 할 수 &lt;strong&gt;없습니다&lt;/strong&gt; ! 기본 내보내기는 임의의 값 (예 : 숫자) 일 수 있으므로 Flow는 기본 내보내기에 유형을 추가하지 않기 때문입니다. Flow는 내 보낸 명명 된 유형을 ES 네임 스페이스 객체에 추가 합니다.이 이름은 내 보낸 유형과 동일한 이름을 가진 값을 내보내는 지 알고 있으므로 &lt;code&gt;import * as React from 'react'&lt;/code&gt; 로 import *로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c23f9cce0d3c2c8df25b9ff8cf278ae227f7bad" translate="yes" xml:space="preserve">
          <source>You write classes the same way you would without Flow, but then you can use the name of the class as a type.</source>
          <target state="translated">Flow를 사용하지 않는 방식으로 클래스를 작성하지만 클래스 이름을 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="654c5e74e5e546451d0e1429c2931cddd203538d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if we do not handle each possible type of our value, Flow will give us an error.</source>
          <target state="translated">가능한 모든 유형의 값을 처리하지 않으면 흐름에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="75e6e89e1f9c5b889605448ec75232836809ed76" translate="yes" xml:space="preserve">
          <source>[declarations]</source>
          <target state="translated">[declarations]</target>
        </trans-unit>
        <trans-unit id="8efeedea6584d5d0f6aa150fe286ea3d383ef4a5" translate="yes" xml:space="preserve">
          <source>[ignore]</source>
          <target state="translated">[ignore]</target>
        </trans-unit>
        <trans-unit id="6c51495394c6e6372e62ee5ec85bb9eaef21cce5" translate="yes" xml:space="preserve">
          <source>[include]</source>
          <target state="translated">[include]</target>
        </trans-unit>
        <trans-unit id="7afbe53dfddbe7c93f7de3dd43aba3228ee7b934" translate="yes" xml:space="preserve">
          <source>[libs]</source>
          <target state="translated">[libs]</target>
        </trans-unit>
        <trans-unit id="0a5387e3c9cf9ab97fc0bf23e3269594e185c36d" translate="yes" xml:space="preserve">
          <source>[lints]</source>
          <target state="translated">[lints]</target>
        </trans-unit>
        <trans-unit id="83f3a6281fb9adf03bf77c91402ae0e931ccb966" translate="yes" xml:space="preserve">
          <source>[options]</source>
          <target state="translated">[options]</target>
        </trans-unit>
        <trans-unit id="5342d8199f9eb9d08f90a284e8dd1dc7804a74f9" translate="yes" xml:space="preserve">
          <source>[untyped]</source>
          <target state="translated">[untyped]</target>
        </trans-unit>
        <trans-unit id="82269fe5787de6e7ec27fcc12d83c2cbb09336c3" translate="yes" xml:space="preserve">
          <source>[version]</source>
          <target state="translated">[version]</target>
        </trans-unit>
        <trans-unit id="a1024232bfedfebb6aacd740ffd636d6f41a840a" translate="yes" xml:space="preserve">
          <source>and now</source>
          <target state="translated">그리고 지금</target>
        </trans-unit>
        <trans-unit id="48e7db6313c704fbd26e0ba32bef954b2e977a24" translate="yes" xml:space="preserve">
          <source>and spread that into the &lt;code&gt;Props&lt;/code&gt; type:</source>
          <target state="translated">그리고 그것을 &lt;code&gt;Props&lt;/code&gt; 타입 으로 펼치십시오 :</target>
        </trans-unit>
        <trans-unit id="2cc9aa7176523739af8846ebf98bde04cafdfc07" translate="yes" xml:space="preserve">
          <source>and suppose that &lt;code&gt;src/Misc.js&lt;/code&gt; has an incompatible implementation of &lt;code&gt;isLeapYear&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src/Misc.js&lt;/code&gt; 에 호환되지 않는 &lt;code&gt;isLeapYear&lt;/code&gt; 구현이 있다고 가정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec2d7bdbbbacb178e39b0b7c79bfc355baf6b95f" translate="yes" xml:space="preserve">
          <source>and suppress the error. If there is no error on the next line (the suppression is unnecessary), an &amp;ldquo;Unused suppression&amp;rdquo; warning will be shown instead.</source>
          <target state="translated">오류를 억제하십시오. 다음 줄에 오류가 없으면 (억제 불필요)&amp;ldquo;사용하지 않은 억제&amp;rdquo;경고가 대신 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a9745abbdcf92eab56732a7d35f17f430c1336bf" translate="yes" xml:space="preserve">
          <source>and then it comes across a &lt;code&gt;package.json&lt;/code&gt; with</source>
          <target state="translated">그런 다음 &lt;code&gt;package.json&lt;/code&gt; 과 함께 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0768098259f562a18299b5c17e4ddd6a8b9d9b5b" translate="yes" xml:space="preserve">
          <source>and you try to use Flow v0.21.0, then Flow will immediately error with the message</source>
          <target state="translated">Flow v0.21.0을 사용하려고하면 Flow에 메시지가 즉시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fca2dbc7b2ac4e20f39f9f3ef522d55252c79cbb" translate="yes" xml:space="preserve">
          <source>broken: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">깨진 : &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https://flow.org/try&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="774e51ee6ebca6e8cb9d7f4d3fe9750f2b9256ae" translate="yes" xml:space="preserve">
          <source>but this doesn&amp;rsquo;t feel very DRY, as we had to explicitly define the suit names twice.</source>
          <target state="translated">그러나 정장 이름을 두 번 명시 적으로 정의해야했기 때문에 이것은 매우 건조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e45777a3dd462c6a840e9e356a7099b6982bc19" translate="yes" xml:space="preserve">
          <source>but with &lt;code&gt;$ReadOnlyArray&lt;/code&gt; you can achieve what you were looking for:</source>
          <target state="translated">그러나 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; 하면 원하는 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46438caefd12a0fd432aedcd449aa37d123fa4c1" translate="yes" xml:space="preserve">
          <source>but with a covariant property you can achieve what you were looking for:</source>
          <target state="translated">그러나 공변량 속성을 사용하면 원하는 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccd55bda6574570ee546195840fdf67842826f24" translate="yes" xml:space="preserve">
          <source>coc.nvim-neovim</source>
          <target state="translated">coc.nvim-neovim</target>
        </trans-unit>
        <trans-unit id="eca0bd3451749c34200b52876c4df81d84e1e7cd" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t report a warning.</source>
          <target state="translated">경고를보고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecb70bca541e08251da88aa6114a01ea186dc721" translate="yes" xml:space="preserve">
          <source>fixed: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">고정 : &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https://flow.org/try&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="406a50ab8f418267ad4cb79f7ec8af3c757e5d1a" translate="yes" xml:space="preserve">
          <source>flow-for-emacs</source>
          <target state="translated">flow-for-emacs</target>
        </trans-unit>
        <trans-unit id="b31ed27db0f3f06537ccbd7e0612af0839145d27" translate="yes" xml:space="preserve">
          <source>flow-remove-types</source>
          <target state="translated">flow-remove-types</target>
        </trans-unit>
        <trans-unit id="bb6bd705fa5bbecd686c0aa80112ee7f1ec636a5" translate="yes" xml:space="preserve">
          <source>flowlint</source>
          <target state="translated">flowlint</target>
        </trans-unit>
        <trans-unit id="1ae5604c6b19edcfc16e8a0c46ddf12d0f3961dd" translate="yes" xml:space="preserve">
          <source>flowlint-line</source>
          <target state="translated">flowlint-line</target>
        </trans-unit>
        <trans-unit id="d424129af5ff1e8c17f038e5baf6afdeaa7378ab" translate="yes" xml:space="preserve">
          <source>flowlint-next-line</source>
          <target state="translated">flowlint-next-line</target>
        </trans-unit>
        <trans-unit id="9523c342f10c383dc3724202de645481a80652c5" translate="yes" xml:space="preserve">
          <source>if you want control at an even finer level than you get from the line-based comments.</source>
          <target state="translated">라인 기반 주석에서 얻는 것보다 더 미세한 수준에서 제어하려는 경우.</target>
        </trans-unit>
        <trans-unit id="ec606816757167e05f48d162279dba3e8be72530" translate="yes" xml:space="preserve">
          <source>is an alias for React.AbstractComponent&amp;lt;Config, any&amp;gt;, which represents a component with config type Config and any instance type.</source>
          <target state="translated">React.AbstractComponent &amp;lt;Config, any&amp;gt;의 별명이며 구성 유형이 Config이고 모든 인스턴스 유형이있는 구성 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e56b448d5548cfe9ad70cc70da30a02c7890ea87" translate="yes" xml:space="preserve">
          <source>or by annotating the exported constant (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">또는 내 보낸 상수에 주석을 달아 ( &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7a4bfa85ec41023a2a32b1cdf3f48b7562fdb4a7" translate="yes" xml:space="preserve">
          <source>ref functions</source>
          <target state="translated">심판 기능</target>
        </trans-unit>
        <trans-unit id="293bf85b0e8555f44772dd43c5b8cdf5ff5c89b9" translate="yes" xml:space="preserve">
          <source>the left-hand side of an &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 표현식 의 왼쪽 .</target>
        </trans-unit>
        <trans-unit id="1470003cc6f898cdf238607c6ab34328b293da93" translate="yes" xml:space="preserve">
          <source>vim-flow</source>
          <target state="translated">vim-flow</target>
        </trans-unit>
        <trans-unit id="2ad74a5e0937034a00b7730362af6b184bbbc385" translate="yes" xml:space="preserve">
          <source>vscode-flow-ide</source>
          <target state="translated">vscode-flow-ide</target>
        </trans-unit>
        <trans-unit id="0cbdfb85ff349a0802c41f318988e156dfbc0529" translate="yes" xml:space="preserve">
          <source>where as you would otherwise need to export an alias in the &lt;code&gt;import typeof&lt;/code&gt; case</source>
          <target state="translated">&lt;code&gt;import typeof&lt;/code&gt; 경우 별칭을 내 보내야하는 경우</target>
        </trans-unit>
        <trans-unit id="bd186b6002ab463466be199db517792bf8202dbe" translate="yes" xml:space="preserve">
          <source>will match a comment like this:</source>
          <target state="translated">다음과 같은 주석과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cba826f3eaa4834a5baad670fcedb5ee1f1e012b" translate="yes" xml:space="preserve">
          <source>would still have a sketchy-null-number warning on line 3.</source>
          <target state="translated">행 3에 여전히 스케치 널 번호 경고가 표시됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
