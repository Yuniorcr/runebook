<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="30b4e85b5e57a5e2350b1dc089bac21b6bb3bef1" translate="yes" xml:space="preserve">
          <source>F.9.3.13 The scalbn functions (p: 460)</source>
          <target state="translated">F.9.3.13 스 칼븐 함수 (p : 460)</target>
        </trans-unit>
        <trans-unit id="823c8200c7b53ce2ccd8c3288a0a3a49fad5c22c" translate="yes" xml:space="preserve">
          <source>F.9.3.2 The exp2 functions (p: 458)</source>
          <target state="translated">F.9.3.2 exp2 기능 (p : 458)</target>
        </trans-unit>
        <trans-unit id="5d366ad2627dd4333d06e173d585adb24b52f19a" translate="yes" xml:space="preserve">
          <source>F.9.3.3 The expm1 functions (p: 458)</source>
          <target state="translated">F.9.3.3 expm1 기능 (p : 458)</target>
        </trans-unit>
        <trans-unit id="9993bc3ba1519eec52259e286419159d469fe90d" translate="yes" xml:space="preserve">
          <source>F.9.3.4 The frexp functions (p: 458)</source>
          <target state="translated">F.9.3.4 frexp 기능 (p : 458)</target>
        </trans-unit>
        <trans-unit id="b9e61e62cb68745b75b0ed3ce171a6a9e5162df8" translate="yes" xml:space="preserve">
          <source>F.9.3.5 The ilogb functions (p: 458)</source>
          <target state="translated">F.9.3.5 ilogb 기능 (p : 458)</target>
        </trans-unit>
        <trans-unit id="d4726c76fee2a471a2931693701495170c5d8163" translate="yes" xml:space="preserve">
          <source>F.9.3.6 The ldexp functions (p: 459)</source>
          <target state="translated">F.9.3.6 ldexp 기능 (p : 459)</target>
        </trans-unit>
        <trans-unit id="6092518ebd2f95991e460724ebab3f88acec5168" translate="yes" xml:space="preserve">
          <source>F.9.3.7 The log functions (p: 459)</source>
          <target state="translated">F.9.3.7 로그 기능 (p : 459)</target>
        </trans-unit>
        <trans-unit id="2c0b8c3a7302a2e8487ec23c4264320fa6a1efbe" translate="yes" xml:space="preserve">
          <source>F.9.3.8 The log10 functions (p: 459)</source>
          <target state="translated">F.9.3.8 log10 기능 (p : 459)</target>
        </trans-unit>
        <trans-unit id="18b53619814f88666c327ab91b69281ea797e78f" translate="yes" xml:space="preserve">
          <source>F.9.3.9 The log1p functions (p: 459)</source>
          <target state="translated">F.9.3.9 log1p 기능 (p : 459)</target>
        </trans-unit>
        <trans-unit id="dbd538d32f5d9018cd3832c0cbc80455793a7355" translate="yes" xml:space="preserve">
          <source>F.9.4.1 The cbrt functions (p: 460)</source>
          <target state="translated">F.9.4.1 cbrt 기능 (p : 460)</target>
        </trans-unit>
        <trans-unit id="c0cc25736dc89057cfdb7af63fd9fd70852b7e3f" translate="yes" xml:space="preserve">
          <source>F.9.4.3 The hypot functions (p: 461)</source>
          <target state="translated">F.9.4.3 hypot 함수 (p : 461)</target>
        </trans-unit>
        <trans-unit id="9972873a11b4a3f3db9e100bb220f6102dbac9da" translate="yes" xml:space="preserve">
          <source>F.9.4.4 The pow functions (p: 461)</source>
          <target state="translated">F.9.4.4 pow 기능 (p : 461)</target>
        </trans-unit>
        <trans-unit id="38a093976c4b1a21fdfcc5a1efbc81ca4cf9fcd1" translate="yes" xml:space="preserve">
          <source>F.9.4.5 The sqrt functions (p: 462)</source>
          <target state="translated">F.9.4.5 sqrt 함수 (p : 462)</target>
        </trans-unit>
        <trans-unit id="b1c90503cb107f559d8240f46591b669f6510753" translate="yes" xml:space="preserve">
          <source>F.9.5.1 The erf functions (p: 462)</source>
          <target state="translated">F.9.5.1 erf 기능 (p : 462)</target>
        </trans-unit>
        <trans-unit id="d2df3873ca6b99a5a39094498e253092b49188f4" translate="yes" xml:space="preserve">
          <source>F.9.5.2 The erfc functions (p: 462)</source>
          <target state="translated">F.9.5.2 erfc 함수 (p : 462)</target>
        </trans-unit>
        <trans-unit id="8cea05cad5774c2508871da587382f5db7d720a3" translate="yes" xml:space="preserve">
          <source>F.9.5.3 The lgamma functions (p: 462)</source>
          <target state="translated">F.9.5.3 lgamma 기능 (p : 462)</target>
        </trans-unit>
        <trans-unit id="0b0a22ab47007053f34baaa081ba36dae847052b" translate="yes" xml:space="preserve">
          <source>F.9.5.4 The tgamma functions (p: 462)</source>
          <target state="translated">F.9.5.4 감마 함수 (p : 462)</target>
        </trans-unit>
        <trans-unit id="934d552354a34e2b8673e4eb4339546c60ae6dd8" translate="yes" xml:space="preserve">
          <source>F.9.6.1 The ceil functions (p: 462-463)</source>
          <target state="translated">F.9.6.1 ceil 기능 (p : 462-463)</target>
        </trans-unit>
        <trans-unit id="e5b93daaadda04a0163cf636e455a8bd1dff63ae" translate="yes" xml:space="preserve">
          <source>F.9.6.2 The floor functions (p: 463)</source>
          <target state="translated">F.9.6.2 바닥 기능 (p : 463)</target>
        </trans-unit>
        <trans-unit id="57ffbbecbe61484e26935ad7f144629bd00f8d53" translate="yes" xml:space="preserve">
          <source>F.9.6.3 The nearbyint functions (p: 463)</source>
          <target state="translated">F.9.6.3 nearint 기능 (p : 463)</target>
        </trans-unit>
        <trans-unit id="34e0626ef8f9a6bbac018a9e206f3071affd5bc0" translate="yes" xml:space="preserve">
          <source>F.9.6.4 The rint functions (p: 463)</source>
          <target state="translated">F.9.6.4 린트 기능 (p : 463)</target>
        </trans-unit>
        <trans-unit id="c2e2f1d0870aa390943575793ec108e425c96385" translate="yes" xml:space="preserve">
          <source>F.9.6.5 The lrint and llrint functions (p: 463)</source>
          <target state="translated">F.9.6.5 lrint 및 llrint 기능 (p : 463)</target>
        </trans-unit>
        <trans-unit id="0342b704124b697670da2d3c1f79734dea851992" translate="yes" xml:space="preserve">
          <source>F.9.6.6 The round functions (p: 464)</source>
          <target state="translated">F.9.6.6 라운드 기능 (p : 464)</target>
        </trans-unit>
        <trans-unit id="7cb6f5767de3d5739b9c33a7634dcdfe44990115" translate="yes" xml:space="preserve">
          <source>F.9.6.7 The lround and llround functions (p: 464)</source>
          <target state="translated">F.9.6.7 lround 및 llround 함수 (p : 464)</target>
        </trans-unit>
        <trans-unit id="9c3fd1541169517fa1d4961b9344e08aa532fa7e" translate="yes" xml:space="preserve">
          <source>F.9.6.8 The trunc functions (p: 464)</source>
          <target state="translated">F.9.6.8 잘림 기능 (p : 464)</target>
        </trans-unit>
        <trans-unit id="064b3111988ac7df6eecb785faed345d9297dfab" translate="yes" xml:space="preserve">
          <source>F.9.7.1 The fmod functions (p: 465)</source>
          <target state="translated">F.9.7.1 fmod 기능 (p : 465)</target>
        </trans-unit>
        <trans-unit id="cc9103dded7338c4021b51c548c533e322ab900e" translate="yes" xml:space="preserve">
          <source>F.9.7.2 The remainder functions (p: 465)</source>
          <target state="translated">F.9.7.2 나머지 기능들 (p : 465)</target>
        </trans-unit>
        <trans-unit id="39bef4f56a96498b3da50bdb7c35031638849d6f" translate="yes" xml:space="preserve">
          <source>F.9.7.3 The remquo functions (p: 465)</source>
          <target state="translated">F.9.7.3 원격 기능 (p : 465)</target>
        </trans-unit>
        <trans-unit id="e56cc91507b7efd53ba57b94c982642c7f60363e" translate="yes" xml:space="preserve">
          <source>F.9.8.1 The copysign functions (p: 465)</source>
          <target state="translated">F.9.8.1 카피 사인 기능 (p : 465)</target>
        </trans-unit>
        <trans-unit id="ef3323270c431d43becee3540920bfc7eeedaff7" translate="yes" xml:space="preserve">
          <source>F.9.8.3 The nextafter functions (p: 466)</source>
          <target state="translated">F.9.8.3 다음 기능 (p : 466)</target>
        </trans-unit>
        <trans-unit id="0631e56775b8a532eaeb5137b6f22ed4997abbe6" translate="yes" xml:space="preserve">
          <source>F.9.8.4 The nexttoward functions (p: 466)</source>
          <target state="translated">F.9.8.4 다음 기능 (p : 466)</target>
        </trans-unit>
        <trans-unit id="1ddb4e2e3c5c7d60866cef35561923279073eee3" translate="yes" xml:space="preserve">
          <source>F.9.9.1 The fdim functions (p: 466)</source>
          <target state="translated">F.9.9.1 fdim 기능 (p : 466)</target>
        </trans-unit>
        <trans-unit id="c525d7d0c4839cf25cbfd016306a740d2d9d279e" translate="yes" xml:space="preserve">
          <source>F.9.9.2 The fmax functions (p: 466)</source>
          <target state="translated">F.9.9.2 fmax 기능 (p : 466)</target>
        </trans-unit>
        <trans-unit id="fc6bba334be6df0602bebd86ae84aeb7c0f91030" translate="yes" xml:space="preserve">
          <source>F.9.9.3 The fmin functions (p: 466)</source>
          <target state="translated">F.9.9.3 fmin 기능 (p : 466)</target>
        </trans-unit>
        <trans-unit id="95554e5d8706eb3f7b6807f8f074535fb13990c9" translate="yes" xml:space="preserve">
          <source>F.9/11/13 NAN (p: 455)</source>
          <target state="translated">F.9 / 11 / 13 NAN (p : 455)</target>
        </trans-unit>
        <trans-unit id="58e99712449f37bee19b236a76781708e1c1501e" translate="yes" xml:space="preserve">
          <source>F.9/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 454)</source>
          <target state="translated">F.9 / 2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p : 454)</target>
        </trans-unit>
        <trans-unit id="29ea08511bd74c4f3ae31a09c3ec12f4f35a942e" translate="yes" xml:space="preserve">
          <source>F.9/4 MATH_ERREXCEPT, math_errhandling&amp;gt; (p: 454)</source>
          <target state="translated">F.9 / 4 MATH_ERREXCEPT, math_errhandling&amp;gt; (p : 454)</target>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="0d4216abe2ddd91a8caf8ec8f946faac3d09cdb4" translate="yes" xml:space="preserve">
          <source>FInally, the &lt;code&gt;thrd_exit&lt;/code&gt; function terminates execution of the calling thread and sets its result code to &lt;code&gt;res&lt;/code&gt;.</source>
          <target state="translated">마지막 &lt;code&gt;thrd_exit&lt;/code&gt; 의 함수 호출 스레드의 실행을 종료하고 그 결과 코드를 설정 &lt;code&gt;res&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="a5566821049b545a4daaafb3ffc216f6475d4a02" translate="yes" xml:space="preserve">
          <source>FP_FAST_FMAFFP_FAST_FMAFP_FAST_FMAL</source>
          <target state="translated">FP_FAST_FMAFFP_FAST_FMAFP_FAST_FMAL</target>
        </trans-unit>
        <trans-unit id="7813d7fff2e30597969481d9be57e5c18202cb8d" translate="yes" xml:space="preserve">
          <source>FP_ILOGB0FP_ILOGBNAN</source>
          <target state="translated">FP_ILOGB0FP_ILOGBNAN</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="translated">FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</target>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="translated">파일 접근</target>
        </trans-unit>
        <trans-unit id="d794a847bb4e5ceadb9c12ac7ab0786d739025aa" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="translated">파일 액세스 모드 플래그 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 를 선택적으로 지정하여 파일을 이진 모드로 열 수 있습니다. 이 플래그는 POSIX 시스템에는 영향을 미치지 않지만 Windows에서는 &lt;code&gt;'\n'&lt;/code&gt; 및 &lt;code&gt;'\x1A'&lt;/code&gt; 특수 처리를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="6849f814ac623848f85944a7a942fbf7e9bcb81e" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11)</source>
          <target state="translated">파일 액세스 모드 플래그 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 는 선택적으로 &quot;w&quot;또는 &quot;w +&quot;지정자에 추가 될 수 있습니다. 이 플래그는 파일을 덮어 쓰는 대신 파일이 존재하면 함수가 실패하도록합니다. (C11)</target>
        </trans-unit>
        <trans-unit id="f30e2ebee0e504d4fec6132b2058150d91b77510" translate="yes" xml:space="preserve">
          <source>File input/output</source>
          <target state="translated">파일 입출력</target>
        </trans-unit>
        <trans-unit id="d853d71d751d53b2d709b880a89265afee92eb91" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if failure occurs.</source>
          <target state="translated">성공시 파일 위치 표시기 또는 실패한 경우 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="translated">파일 위치</target>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="translated">파일 범위</target>
        </trans-unit>
        <trans-unit id="3a9cdc70afa5e782250a989c51574a43f1d0f25b" translate="yes" xml:space="preserve">
          <source>File scope restricted pointers are useful in providing access to dynamically allocated global arrays; the restrict semantics make it possible to optimize references through this pointer as effectively as references to a static array through its declared name:</source>
          <target state="translated">파일 범위 제한 포인터는 동적으로 할당 된 전역 배열에 대한 액세스를 제공하는 데 유용합니다. 제한 의미론을 통해 선언 된 이름을 통해 정적 배열에 대한 참조만큼 효과적으로이 포인터를 통한 참조를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc8284a593a8a291982c4c67910dd38a5e502924" translate="yes" xml:space="preserve">
          <source>File-scope identifiers have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;static storage duration&lt;/a&gt; by default.</source>
          <target state="translated">파일 범위 식별자에는 기본적으로 &lt;a href=&quot;storage_duration&quot;&gt;외부 연결&lt;/a&gt; 및 &lt;a href=&quot;storage_duration&quot;&gt;정적 저장 기간&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="translated">파일 이름 및 줄 정보</target>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 가 가리키는 넓은 문자열에서 첫 번째 문자를 찾습니다. 또한 &lt;code&gt;str&lt;/code&gt; 이 가리키는 넓은 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="c6fd83627e8c7b32c0144a6c435a8efcc4874610" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt; as if by &lt;code&gt;(char)ch&lt;/code&gt;) in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt; (each character interpreted as &lt;code&gt;unsigned char&lt;/code&gt;). The terminating null character is considered to be a part of the string and can be found when searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">처음 나타나는 찾아 &lt;code&gt;ch&lt;/code&gt; (로 변환 후 &lt;code&gt;char&lt;/code&gt; 의해 마치 &lt;code&gt;(char)ch&lt;/code&gt; 가리키는 널 종료 문자열에서 바이트) &lt;code&gt;str&lt;/code&gt; (각 문자로서 해석 &lt;code&gt;unsigned char&lt;/code&gt; ). 종료 널 문자는 문자열의 일부로 간주되며 &lt;code&gt;'\0'&lt;/code&gt; 검색 할 때 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="156983c4936a90f64d8bde0b4e792911d718b0b0" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;unsigned char&lt;/code&gt; as if by &lt;code&gt;(unsigned char)ch&lt;/code&gt;) in the initial &lt;code&gt;count&lt;/code&gt; characters (each interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) of the object pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">처음 나타나는 찾아 &lt;code&gt;ch&lt;/code&gt; (행 변환 후의 &lt;code&gt;unsigned char&lt;/code&gt; 에 의해 마치 &lt;code&gt;(unsigned char)ch&lt;/code&gt; 초기의) &lt;code&gt;count&lt;/code&gt; (각각 해석 문자 &lt;code&gt;unsigned char&lt;/code&gt; 객체가 가리키는의) &lt;code&gt;ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f073bd8d629a1976216a0fa2bb49ebd6dc19c4b" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the null-terminated byte string pointed to by &lt;code&gt;substr&lt;/code&gt; in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 널 종료 바이트 문자열에서 &lt;code&gt;substr&lt;/code&gt; 이 가리키는 널 종료 바이트 문자열의 첫 항목을 찾습니다 . 종료 널 문자는 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 와이드 문자열에서 와이드 문자 &lt;code&gt;ch&lt;/code&gt; 가 처음 나타나는 것을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 가 가리키는 넓은 문자열에서 첫 번째 넓은 문자열 &lt;code&gt;src&lt;/code&gt; 를 찾습니다 . 종료 널 문자는 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4df137c6700e2d26ec6d629f5fa312ab93f754d7" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt; as if by &lt;code&gt;(char)ch&lt;/code&gt;) in the null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt; (each character interpreted as &lt;code&gt;unsigned char&lt;/code&gt;). The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">마지막 발생 찾아 &lt;code&gt;ch&lt;/code&gt; (로 변환 후 &lt;code&gt;char&lt;/code&gt; 의해 마치 &lt;code&gt;(char)ch&lt;/code&gt; 가리키는 널 종료 문자열에서 바이트) &lt;code&gt;str&lt;/code&gt; (각 문자로서 해석 &lt;code&gt;unsigned char&lt;/code&gt; ). 종료 널 문자는 문자열의 일부로 간주되며 &lt;code&gt;'\0'&lt;/code&gt; 검색하면 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 와이드 문자열에서 와이드 문자 &lt;code&gt;ch&lt;/code&gt; 의 마지막 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="cd043634a6f2aac8236e977d8fdb5f1580bfb40c" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;conversion&quot;&gt;integer promotions&lt;/a&gt; are performed, individually, on each operand (Note: this is unlike other binary arithmetic operators, which all perform usual arithmetic conversions). The type of the result is the type of lhs after promotion.</source>
          <target state="translated">먼저 &lt;a href=&quot;conversion&quot;&gt;정수 승격&lt;/a&gt; 이 각 피연산자에 대해 개별적으로 수행됩니다 (참고 : 이는 모든 일반 산술 변환을 수행하는 다른 이진 산술 연산자와 다릅니다). 결과 유형은 승격 후 lhs 유형입니다.</target>
        </trans-unit>
        <trans-unit id="010a9580b64f6a29762d659e4b63ee2c420030ea" translate="yes" xml:space="preserve">
          <source>First, at &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt; (after macro expansion), the adjacent string literals (that is, string literals separated by whitespace only) are concatenated.</source>
          <target state="translated">먼저, &lt;a href=&quot;translation_phases&quot;&gt;변환 단계 6&lt;/a&gt; (매크로 확장 후)에서 인접한 문자열 리터럴 (즉, 공백으로 만 구분 된 문자열 리터럴)이 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="e3c3d2f054364788d43e5a8d2b30730a8de2382a" translate="yes" xml:space="preserve">
          <source>First, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;thrd_exit&lt;/code&gt; sets the value associated with the key to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and then invokes the destructor with the previous value of the key. The order in which the destructors are invoked is unspecified.</source>
          <target state="translated">먼저 널이 아닌 소멸자로 작성되고 연관된 값이 널이 아닌 모든 스레드 특정 스토리지 키에 대해 ( &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; 참조 ) &lt;code&gt;thrd_exit&lt;/code&gt; 는 키와 연관된 값을 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 설정 한 다음 소멸자를 호출하여 소멸자를 호출합니다. 키의 이전 값. 소멸자가 호출되는 순서는 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24650e9936b440df3b35e77cd0d75063b1ba7c02" translate="yes" xml:space="preserve">
          <source>First, operators &amp;amp;, ^, and | perform &lt;a href=&quot;conversion#Usual_arithmetic_conversions&quot;&gt;usual arithmetic conversions&lt;/a&gt; on both operands and the operator ~ performs &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;integer promotions&lt;/a&gt; on its only operand.</source>
          <target state="translated">먼저 연산자 &amp;amp;, ^ 및 | 수행 &lt;a href=&quot;conversion#Usual_arithmetic_conversions&quot;&gt;일반적인 산술 전환&lt;/a&gt; 피연산자 오퍼레이터 ~ 행한다 모두 &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;프로모션 정수&lt;/a&gt; 유일한 피연산자에.</target>
        </trans-unit>
        <trans-unit id="e3892a9441dac662eadf3bbde79b34566a2a5b8a" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="translated">먼저 현재 발생한 부동 소수점 예외를 기억 한 다음 &lt;code&gt;envp&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt; 와 유사)가 가리키는 객체에서 부동 소수점 환경을 복원 한 다음 저장된 부동 소수점 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5af17ffdb58456bdb2dce4da5ffca99076cb7ee3" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">먼저 현재 부동 소수점 환경을 &lt;code&gt;envp&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fegetenv&lt;/a&gt;&lt;/code&gt; 와 유사)가 가리키는 객체에 저장 한 다음 모든 부동 소수점 상태 플래그를 지우고 논스톱 모드를 설치합니다. 향후 부동 소수점 예외는 실행을 중단하지 않습니다 ( &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;fesetenv&lt;/a&gt;&lt;/code&gt; 에 의해 부동 소수점 환경이 복원 될 때까지 트랩되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5a0d1a196542aeb51294a3761ccccdf5a2185f41" translate="yes" xml:space="preserve">
          <source>First, the left operand, lhs, is evaluated and its result value is discarded.</source>
          <target state="translated">먼저 왼쪽 피연산자 lhs가 평가되고 결과 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="7f7c8db9e6faaf3d94c8b437cf0d16523b93fd3b" translate="yes" xml:space="preserve">
          <source>First, the type of controlling-expression undergoes &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue conversions&lt;/a&gt;. The conversion is performed in type domain only: it discards the top-level cvr-qualifiers and atomicity and applies array-to-pointer/function-to-pointer transformations to the type of the controlling expression, without initiating any side-effects or calculating any values.</source>
          <target state="translated">먼저, 제어식의 유형은 &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue 변환을&lt;/a&gt; 거칩니다 . 변환은 유형 도메인에서만 수행됩니다. 최상위 cvr 한정자 및 원 자성을 버리고 부작용을 일으키거나 계산하지 않고 제어식의 유형에 배열 간 포인터 / 함수 간 포인터 변환을 적용합니다. 모든 값.</target>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="translated">고정 너비 정수 유형</target>
        </trans-unit>
        <trans-unit id="76a08caa99c505ae8032d07c4012057a86cf1d36" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C99)</source>
          <target state="translated">고정 폭 정수 유형 (C99 이후)</target>
        </trans-unit>
        <trans-unit id="840ee99ab9aff1bac4213d391ce03692c895404a" translate="yes" xml:space="preserve">
          <source>Fixed-width integer types</source>
          <target state="translated">고정 폭 정수 타입</target>
        </trans-unit>
        <trans-unit id="663059496ccabb871dffdce9e54cfe1c54e105ee" translate="yes" xml:space="preserve">
          <source>Floating constants</source>
          <target state="translated">부동 상수</target>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 부동 소수점 값 . 변환 된 값이 해당 반환 유형의 범위를 벗어나면 범위 오류가 발생하고 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; 이 반환됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc58d2a49355b39280fe2f52213175ca7b8fd25a" translate="yes" xml:space="preserve">
          <source>Floating-point constant expressions</source>
          <target state="translated">부동 소수점 상수 표현식</target>
        </trans-unit>
        <trans-unit id="187a207ab4dc1668e42fee15564f93f815a577ae" translate="yes" xml:space="preserve">
          <source>Floating-point constants may convert to more range and precision than is indicated by their type, if indicated by &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. For example, the constant &lt;code&gt;0.1f&lt;/code&gt; may act as if it were &lt;code&gt;0.1L&lt;/code&gt; in an expression.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 로 표시되는 경우 부동 소수점 상수는 유형으로 표시되는 것보다 더 많은 범위와 정밀도로 변환 될 수 있습니다 . 예를 들어, 상수 &lt;code&gt;0.1f&lt;/code&gt; 는 식에서 &lt;code&gt;0.1L&lt;/code&gt; 인 것처럼 작용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="translated">부동 소수점 수축</target>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="translated">부동 소수점 환경</target>
        </trans-unit>
        <trans-unit id="ac15e30a03ce45c5cd8e83acd0b5ab29417f912b" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may also be</source>
          <target state="translated">부동 소수점 표현식도</target>
        </trans-unit>
        <trans-unit id="c833758c552d43ff6fc0b2c2a0891b29187adbbf" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. &lt;a href=&quot;operator_assignment&quot;&gt;Assignment&lt;/a&gt;, &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;, and &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; force the range and precision to the one associated with the declared type.</source>
          <target state="translated">부동 소수점 표현식은 유형으로 표시된 것보다 더 큰 범위와 정밀도를 가질 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조) . &lt;a href=&quot;operator_assignment&quot;&gt;Assignment&lt;/a&gt; , &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; 및 &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; 는 선언 된 유형과 관련된 범위 및 정밀도에 범위와 정밀도를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="2b332b36c83932ce6597945ab99c760510235ccb" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may raise exceptions and report errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;</source>
          <target state="translated">부동 소수점 식은 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling에&lt;/a&gt; 지정된대로 예외를 발생시키고 오류를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab903d16590f471723cce0610a9cdcd6209bde69" translate="yes" xml:space="preserve">
          <source>Floating-point manipulation functions</source>
          <target state="translated">부동 소수점 조작 기능</target>
        </trans-unit>
        <trans-unit id="9e9ec2743b8311d312a967d346f2be786a835e07" translate="yes" xml:space="preserve">
          <source>Floating-point types may support special values:</source>
          <target state="translated">부동 소수점 유형은 특수 값을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06aab856bd9476c0b4dbb7ee054ad78329c4c1ec" translate="yes" xml:space="preserve">
          <source>Floating-point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 부동 소수점 값 . 변환 된 값이 해당 반환 유형의 범위를 벗어나면 범위 오류가 발생하고 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; 이 반환됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">들어 &lt;a href=&quot;do&quot;&gt;할-동안&lt;/a&gt; 루프, 그것의 역할 :</target>
        </trans-unit>
        <trans-unit id="0a82766f871cb4b85056c582e325e120d94af630" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">위해 &lt;a href=&quot;for&quot;&gt;에 대한&lt;/a&gt; 루프, 그것의 역할 :</target>
        </trans-unit>
        <trans-unit id="25aa007ea092cdda566de6d64234cfa5cc3924d2" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;struct&quot;&gt;structs&lt;/a&gt; and &lt;a href=&quot;union&quot;&gt;unions&lt;/a&gt;, declarations that specify the list of members are definitions:</source>
          <target state="translated">대한 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 와 &lt;a href=&quot;union&quot;&gt;노동 조합&lt;/a&gt; 구성원이 정의입니다 목록을 지정, 선언 :</target>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="translated">들면 &lt;a href=&quot;while&quot;&gt;하면서&lt;/a&gt; 루프는 역할을한다.</target>
        </trans-unit>
        <trans-unit id="10084651562c27997fbdae459a7c23083c2c8a43" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;lrint&lt;/code&gt; and &lt;code&gt;llrint&lt;/code&gt; functions:</source>
          <target state="translated">대한 &lt;code&gt;lrint&lt;/code&gt; 및 &lt;code&gt;llrint&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="a21e404fbb1009207c801f3014228685c0a1839d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;lround&lt;/code&gt; and &lt;code&gt;llround&lt;/code&gt; families of functions:</source>
          <target state="translated">대한 &lt;code&gt;lround&lt;/code&gt; 및 &lt;code&gt;llround&lt;/code&gt; 기능의 가족 :</target>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="translated">IEEE 호환 유형 &lt;code&gt;double&lt;/code&gt; 의 경우 &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; 또는 &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt; 경우 오버플로가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="translated">IEEE 호환 유형 &lt;code&gt;double&lt;/code&gt; 의 경우 709.8 &amp;lt;arg이면 오버플로가 보장되고 arg &amp;lt;-708.4이면 언더 플로가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="translated">IEEE 호환 유형 &lt;code&gt;double&lt;/code&gt; 의 경우 709.8 &amp;lt;arg 인 경우 오버플로가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="translated">대한</target>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="translated">A와 B라는 M의 원자 수정 쌍에 대해, B는 M의 수정 순서에서 A 다음에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e336f737f267c22ea911366e2522a1b5935e0af" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="translated">원 동작들의 쌍에 대한 M 및 B가 A를 기록하고있는 경우 두 B는 M의 값을 판독하는 경우, 호출 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 의 X 및 Y, 및이면</target>
        </trans-unit>
        <trans-unit id="1d3977eef880647bc052245b337d4dbacc336a33" translate="yes" xml:space="preserve">
          <source>For all complex number functions that do not have real counterparts, a type-generic macro &lt;code&gt;cXXX&lt;/code&gt; exists, which calls either of the variants of a complex function:</source>
          <target state="translated">실제 대응 물이없는 모든 복소수 함수에 대해, 유형-일반 매크로 &lt;code&gt;cXXX&lt;/code&gt; 가 존재하며, 이는 복잡한 함수의 변형 중 하나를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6730f4960c4b4de31dd3c96b5509a3c383272937" translate="yes" xml:space="preserve">
          <source>For all functions that do not have complex counterparts, with the exception of &lt;code&gt;modf&lt;/code&gt;, a type-generic macro &lt;code&gt;XXX&lt;/code&gt; exists, which calls either of the variants of a real function:</source>
          <target state="translated">&lt;code&gt;modf&lt;/code&gt; 를 제외하고 복잡한 대응 물을 갖지 않는 모든 함수의 경우 , 일반적인 함수의 변형 중 하나를 호출 하는 유형-일반 매크로 &lt;code&gt;XXX&lt;/code&gt; 가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="04997ae64209c733be2a01335fce8eadf79cc061" translate="yes" xml:space="preserve">
          <source>For all functions that have both real and complex counterparts, a type-generic macro &lt;code&gt;XXX&lt;/code&gt; exists, which calls either of:</source>
          <target state="translated">실수와 복잡한 함수를 모두 갖는 모든 함수에 대해 다음 중 하나를 호출 하는 형식 일반 매크로 &lt;code&gt;XXX&lt;/code&gt; 가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="55501a14e5efa2511e7fc929d66bd9f716e4906e" translate="yes" xml:space="preserve">
          <source>For an identifier with internal or external &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.</source>
          <target state="translated">해당 식별자 의 사전 선언이 보이는 범위에서 선언 된 내부 또는 외부 &lt;a href=&quot;storage_duration&quot;&gt;링크&lt;/a&gt; 가있는 식별자의 경우, 사전 선언이 내부 또는 외부 링크를 지정하면 나중에 선언시 식별자 유형이 복합 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="b64b2293698ec3d176c65a39c39ccccae3114de3" translate="yes" xml:space="preserve">
          <source>For any complex variable &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;z == &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z) + I*cimag(z)&lt;/code&gt;.</source>
          <target state="translated">복소수 변수 &lt;code&gt;z&lt;/code&gt; 의 경우 &lt;code&gt;z == &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z) + I*cimag(z)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a924e7dda6f158c58b3ecd7cd7208221fc267986" translate="yes" xml:space="preserve">
          <source>For any complex variable &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;z == creal(z) + I*&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">복소수 변수 &lt;code&gt;z&lt;/code&gt; 의 경우 &lt;code&gt;z == creal(z) + I*&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a543b26c60ebb052f7bcd4171fdf90efeeb5fc1c" translate="yes" xml:space="preserve">
          <source>For any struct or union declared with a storage-class specifier, the storage duration (but not linkage) applies to their members, recursively.</source>
          <target state="translated">스토리지 클래스 지정자로 선언 된 구조체 또는 공용체의 경우 스토리지 기간 (연결은 아님)이 멤버에 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="translated">모든 z에 대해 acos (z) = &amp;pi;-acos (-z).</target>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="translated">모든 z에 대해 atanh (z) =</target>
        </trans-unit>
        <trans-unit id="688d572612ce95b5162d08e797cd89fdb4d407c3" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;intptr_t&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; 보다 짧은 char 배열의 경우 , &lt;code&gt;ptrdiff_t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; 의 부호있는 대응 물로 작동합니다 . 모든 유형의 배열의 크기를 저장할 수 있으며 대부분의 플랫폼에서 &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;intptr_t&lt;/a&gt;&lt;/code&gt; 와 동의어입니다 ).</target>
        </trans-unit>
        <trans-unit id="42dd9f0ffdcfcdcd8c3a5d50abb1358aac15a314" translate="yes" xml:space="preserve">
          <source>For decimal floating constants, the exponent part is optional. If it is omitted, the period is not optional, and either the whole-number or the fraction must be present.</source>
          <target state="translated">십진 부동 상수의 경우 지수 부분은 선택 사항입니다. 생략하면 기간은 선택 사항이 아니며 정수 또는 분수가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f184cc4c10f89fe313321f740ea02baedf5fc6c" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, the initializer, if not omitted, may be one of the following:</source>
          <target state="translated">각 &lt;a href=&quot;declarations&quot;&gt;선언 자마다&lt;/a&gt; 이니셜 라이저가 생략되지 않은 경우 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfeeb8ceed62e73a2f3bd0d30fa50cfae0463352" translate="yes" xml:space="preserve">
          <source>For each macro, the parameters whose corresponding real type in the unsuffixed math.h function is &lt;code&gt;double&lt;/code&gt; are known as</source>
          <target state="translated">각각의 매크로의 unsuffixed math.h 함수 실수 형에 대응하는 파라미터가되고, 그 &lt;code&gt;double&lt;/code&gt; 라고도</target>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 이외의 모든 변환 지정자에 대해 , 지정된 필드 너비를 초과하지 않고 변환 지정자가 기대하는 것 또는 예상되는 순서의 접두사 인 입력 문자의 가장 긴 시퀀스는 스트림에서 소비되는 것입니다. 이 소비 된 시퀀스 이후의 첫 번째 문자 (있는 경우)는 읽지 않은 상태로 유지됩니다. 소비 된 시퀀스의 길이가 0이거나 소비 된 시퀀스를 위에서 지정한대로 변환 할 수없는 경우 스트림 끝, 인코딩 오류 또는 읽기 오류로 인해 스트림에서 입력이 금지되지 않으면 일치 실패가 발생합니다. 입력 실패.</target>
        </trans-unit>
        <trans-unit id="83d7a4b53e554acfb54c7ee5d69c5549aa81f75b" translate="yes" xml:space="preserve">
          <source>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers (where allowed by the qualifier's semantics).</source>
          <target state="translated">위에 나열된 모든 유형에 대해 &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; 및 &lt;a href=&quot;restrict&quot;&gt;limit&lt;/a&gt; 한정자 (한정자의 의미론에 의해 허용되는 경우) 중 하나, 둘 또는 세 가지 모두의 조합에 해당하는 여러 유형의 규정 된 버전이 존재할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">예를 들어 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 처음에 0 인 경우</target>
        </trans-unit>
        <trans-unit id="3af091a84c4312052c5526d63f3a9497407d3111" translate="yes" xml:space="preserve">
          <source>For functions, a declaration that includes the function body is a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;:</source>
          <target state="translated">함수의 경우 함수 본문을 포함하는 선언은 &lt;a href=&quot;function_definition&quot;&gt;함수 정의입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75995ccba23b0db3ef2d567077ba1d25c7f8d7cd" translate="yes" xml:space="preserve">
          <source>For hexadecimal floating constants, the exponent is not optional to avoid ambiguity resulting from an f suffix being mistaken as a hexadecimal digit.</source>
          <target state="translated">16 진 부동 상수의 경우, f 접미 부가 16 진 숫자로 오인되어 생기는 모호성을 피하기 위해 지수는 선택 사항이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="translated">입력 스트림 및 마지막 작업이 입력 된 업데이트 스트림의 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="translated">정수 &lt;code&gt;arg&lt;/code&gt; 의 경우, 이진 로그는 입력에서 최상위 1 비트의 0부터 시작하는 인덱스로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="560ed07ef6832b220e08d54f59f5d6efc3edfa88" translate="yes" xml:space="preserve">
          <source>For integer atomic types, the compound assignment &lt;code&gt;@=&lt;/code&gt; is equivalent to:</source>
          <target state="translated">정수 원자 유형의 경우 복합 할당 &lt;code&gt;@=&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="536dc8c314b296f6f261eb306e04e8cffb32d705" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;cproj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;INFINITY+0.0*I&lt;/code&gt; or &lt;code&gt;INFINITY-0.0*I&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">대부분의 &lt;code&gt;z&lt;/code&gt; 의 경우 &lt;code&gt;cproj(z)==z&lt;/code&gt; 이지만, 한 구성 요소가 무한하고 다른 구성 요소가 NaN 인 숫자까지도 모든 복잡한 무한대는 양의 실수로 무한대가됩니다 ( &lt;code&gt;INFINITY+0.0*I&lt;/code&gt; 또는 &lt;code&gt;INFINITY-0.0*I&lt;/code&gt; ) . 허수 (제로) 성분의 부호는 &lt;code&gt;&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z)&lt;/code&gt; 의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="69a061f40ae84751c0047ebb6b42628283ef685f" translate="yes" xml:space="preserve">
          <source>For objects, a declaration that allocates storage (&lt;a href=&quot;storage_duration&quot;&gt;automatic or static&lt;/a&gt;, but not extern) is a definition, while a declaration that does not allocate storage (&lt;a href=&quot;extern&quot;&gt;external declaration&lt;/a&gt;) is not.</source>
          <target state="translated">객체의 경우 스토리지를 할당하는 선언 ( &lt;a href=&quot;storage_duration&quot;&gt;auto 또는 static&lt;/a&gt; 이지만 extern은 제외)이 정의 인 반면 스토리지를 할당하지 않는 &lt;a href=&quot;extern&quot;&gt;선언&lt;/a&gt; ( external declaration )은 정의가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="translated">출력 스트림 (및 마지막 작업이 출력 된 업데이트 스트림)의 경우 &lt;code&gt;stream&lt;/code&gt; 버퍼 에서 기록되지 않은 데이터를 관련 출력 장치에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="68c6725395fe6fb1de1c0a20e8316ae564ff30cb" translate="yes" xml:space="preserve">
          <source>For relational = and &amp;ne; respectively</source>
          <target state="translated">관계형 = 및 &amp;ne;</target>
        </trans-unit>
        <trans-unit id="ef442ef93a7d1fa17196f13ed58dd573c463f6d6" translate="yes" xml:space="preserve">
          <source>For relational operators &amp;gt; and &amp;ge; respectively</source>
          <target state="translated">관계 연산자&amp;gt; 및 &amp;ge; 각각</target>
        </trans-unit>
        <trans-unit id="0b60290890a2917bb2e0cc3c4c8b8aa425f9bd30" translate="yes" xml:space="preserve">
          <source>For relational operators &amp;lt; and &amp;le; respectively</source>
          <target state="translated">관계 연산자 &amp;lt;및 &amp;le; 각각</target>
        </trans-unit>
        <trans-unit id="879eb9efaaa4654c8cf8c35b00408e67b8bf1832" translate="yes" xml:space="preserve">
          <source>For signed integer types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.</source>
          <target state="translated">부호있는 정수 유형의 경우 2의 보수 표현을 사용하도록 산술이 정의됩니다. 정의되지 않은 결과가 없습니다. 포인터 유형의 경우 결과는 정의되지 않은 주소 일 수 있지만 조작에는 정의되지 않은 동작이 없습니다.</target>
        </trans-unit>
        <trans-unit id="80e4c346fe02c1a18878d7d91ddce96980e8a1f4" translate="yes" xml:space="preserve">
          <source>For text streams, the only valid values of &lt;code&gt;offset&lt;/code&gt; are &lt;code&gt;​0​&lt;/code&gt; (applicable to any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; (only applicable to &lt;code&gt;SEEK_SET&lt;/code&gt;).</source>
          <target state="translated">텍스트 스트림의 유효한 값 &lt;code&gt;offset&lt;/code&gt; 되어 &lt;code&gt;​0​&lt;/code&gt; (어떤 적용 &lt;code&gt;origin&lt;/code&gt; )하고 이전 호출에 의해 리턴 된 값 &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; 은 (에만 적용 &lt;code&gt;SEEK_SET&lt;/code&gt; 는 ).</target>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="translated">에 대한 &lt;code&gt;A&lt;/code&gt; 변환 스타일</target>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="translated">를 들어 &lt;code&gt;E&lt;/code&gt; 의 변환 스타일</target>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="translated">를 들어 &lt;code&gt;G&lt;/code&gt; 스타일로 변환 스타일 변환 &lt;code&gt;E&lt;/code&gt; 또는 &lt;code&gt;F&lt;/code&gt; 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="translated">를 들어 &lt;code&gt;X&lt;/code&gt; 의 변환 문자 &lt;code&gt;ABCDEF&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="translated">에 대한 &lt;code&gt;a&lt;/code&gt; 변환 스타일</target>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="translated">를 들어 &lt;code&gt;e&lt;/code&gt; 변환 스타일</target>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="translated">들어 &lt;code&gt;g&lt;/code&gt; 의 스타일로 변환 스타일 변환 &lt;code&gt;e&lt;/code&gt; 또는 &lt;code&gt;f&lt;/code&gt; 를 수행한다.</target>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="translated">에 대한 &lt;code&gt;x&lt;/code&gt; 변환 문자 &lt;code&gt;abcdef&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="translated">IEEE 호환 유형 &lt;code&gt;double&lt;/code&gt; 의 경우 | arg | &amp;gt; 710.5이면 &lt;code&gt;cosh(arg)&lt;/code&gt; 오버플로됩니다.</target>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="translated">IEEE 호환 유형 &lt;code&gt;double&lt;/code&gt; 의 경우 &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55 인 경우 언더 플로가 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a1e05ff972bb1fabc13e5a58a87f80191cc1553" translate="yes" xml:space="preserve">
          <source>For the objects of type char, signed char, and unsigned char, every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="translated">char, signed char 및 unsigned char 유형의 객체의 경우 객체 표현의 모든 비트가 값 표현에 참여해야하며 가능한 모든 비트 패턴은 고유 한 값을 나타냅니다 (패딩, 트랩 비트 또는 다중 표현은 허용되지 않음).</target>
        </trans-unit>
        <trans-unit id="73df8e10bbeffa07fc22138e0b70d965b3e4a35b" translate="yes" xml:space="preserve">
          <source>For the objects that are declared with automatic, static, and thread storage duration, lifetime equals their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; (note the difference between non-VLA and VLA automatic storage duration).</source>
          <target state="translated">자동 정지 및 스레드 저장 기간 선언 된 개체의 경우 수명은 동일 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; (비 VLA와 VLA 자동 저장 기간의 차이에 유의).</target>
        </trans-unit>
        <trans-unit id="cc128730b3badfe5698c4b1f3a2f185e2ed4fea5" translate="yes" xml:space="preserve">
          <source>For the objects with allocated storage duration, the lifetime begins when the allocation function returns (including the return from &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;) and ends when the &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; or deallocation function is called. Note that since allocated objects have no &lt;a href=&quot;object&quot;&gt;declared type&lt;/a&gt;, the type of the lvalue expression first used to access this object becomes its &lt;a href=&quot;object&quot;&gt;effective type&lt;/a&gt;.</source>
          <target state="translated">할당 된 저장 기간이있는 객체의 경우 할당 기능이 반환 될 때 ( &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 로부터의 반환 포함) 수명이 시작 되고 &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 또는 할당 해제 기능이 호출 되면 종료됩니다 . 할당 된 객체에는 &lt;a href=&quot;object&quot;&gt;선언 된 유형&lt;/a&gt; 이 없으므로이 객체에 액세스하는 데 처음으로 사용 된 lvalue 표현식의 유형이 &lt;a href=&quot;object&quot;&gt;유효한 유형이&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="85282601413e96349836f3981d64d53720f214c0" translate="yes" xml:space="preserve">
          <source>For the purpose of pointer arithmetic, a pointer to an object that is not an element of any array is treated as a pointer to the first element of an array of size 1.</source>
          <target state="translated">포인터 산술을 위해 배열의 요소가 아닌 객체에 대한 포인터는 크기가 1 인 배열의 첫 번째 요소에 대한 포인터로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e385562c47760adbc54c3ba96ba6ba291ce3d32e" translate="yes" xml:space="preserve">
          <source>For unsigned lhs and for signed lhs with nonnegative values, the value of &lt;code&gt;LHS &amp;gt;&amp;gt; RHS&lt;/code&gt; is the integer part of LHS / 2RHS</source>
          <target state="translated">부호없는 lh 및 음수가 아닌 부호있는 lh 의 경우 &lt;code&gt;LHS &amp;gt;&amp;gt; RHS&lt;/code&gt; 의 값 은 LHS / 2RHS의 정수 부분입니다</target>
        </trans-unit>
        <trans-unit id="b78e8d26fc84b75eb18e29ba68eb6707882c4aea" translate="yes" xml:space="preserve">
          <source>For unsigned lhs, the value of &lt;code&gt;LHS &amp;lt;&amp;lt; RHS&lt;/code&gt; is the value of LHS * 2RHS</source>
          <target state="translated">부호없는 lh 의 경우 &lt;code&gt;LHS &amp;lt;&amp;lt; RHS&lt;/code&gt; 값은 LHS * 2RHS 값입니다.</target>
        </trans-unit>
        <trans-unit id="bccf9c84234fd9e53ce6ea6772d91da3ac9147fd" translate="yes" xml:space="preserve">
          <source>For use of bytes to representation values of other fundamental types (including big-endian and little-endian memory layouts), see &lt;a href=&quot;object#Object_representation&quot;&gt;object representation&lt;/a&gt;.</source>
          <target state="translated">바이트를 사용하여 다른 기본 유형 (빅 엔디안 및 리틀 엔디안 메모리 레이아웃 포함)의 값을 표시하려면 &lt;a href=&quot;object#Object_representation&quot;&gt;객체 표현을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="translated">공식적으로 편견없는 지수는 로그의 필수 부분입니다</target>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="translated">공식적으로, 편견 지수는 로그의 부호있는 필수 부분입니다</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="375f5594c659e5ff8bd611de411cc215c9d6fb94" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt; 함수 계열의 형식 상수</target>
        </trans-unit>
        <trans-unit id="46ffb8548d52b3ad3fbe1f297d1fca34ee39282c" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt; 함수 계열의 형식 상수</target>
        </trans-unit>
        <trans-unit id="a28652e2e23cf314a85ef17df4e8261414955885" translate="yes" xml:space="preserve">
          <source>Format conversion of integer types</source>
          <target state="translated">정수 유형의 형식 변환</target>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="translated">형식 변환</target>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="translated">매크로 상수 포맷</target>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="translated">형식화 된 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="translated">전달 선언</target>
        </trans-unit>
        <trans-unit id="1f91dbf7a513677af10fb3592a515c7e6904306f" translate="yes" xml:space="preserve">
          <source>Full type name</source>
          <target state="translated">전체 유형 이름</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="e6bcd818ad8d35fa4ac158274d99b7201a135a1f" translate="yes" xml:space="preserve">
          <source>Function declarations at block scope can use &lt;code&gt;extern&lt;/code&gt; or none at all. Function declarations at file scope can use &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">블록 범위에서 함수 선언은 &lt;code&gt;extern&lt;/code&gt; 을 사용 하거나 전혀 사용 하지 않을 수 있습니다 . 파일 범위에서 함수 선언은 &lt;code&gt;extern&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e44d37020289cf4e22446e56d29f9f3a5cb0dd6" translate="yes" xml:space="preserve">
          <source>Function declarators can be combined with other declarators as long as they can share their type specifiers and qualifiers.</source>
          <target state="translated">함수 선언자는 유형 지정자와 규정자를 공유 할 수있는 한 다른 선언자와 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="translated">기능 정의</target>
        </trans-unit>
        <trans-unit id="b6845f6242d31b642f35208f093f8e9aba102be9" translate="yes" xml:space="preserve">
          <source>Function definitions</source>
          <target state="translated">기능 정의</target>
        </trans-unit>
        <trans-unit id="0004b660206eedce99e85c5907656101eed2ba97" translate="yes" xml:space="preserve">
          <source>Function designator expression</source>
          <target state="translated">함수 지정자 표현</target>
        </trans-unit>
        <trans-unit id="56247e3ce0cb2812a9cd7b40705c577d342f4d79" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">함수는 공백이 아닌 첫 번째 문자가 발견 될 때까지 공백 문자 ( &lt;code&gt;std::&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;()&lt;/code&gt; 의해 결정됨)를 버립니다 . 그런 다음 유효한 부동 소수점 표현을 형성하기 위해 가능한 한 많은 문자를 사용하여 부동 소수점 값으로 변환합니다. 유효한 부동 소수점 값은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac61bae440a3f41b35363be03410015a24d97cd" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::&lt;a href=&quot;iswspace&quot;&gt;iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">함수는 공백이 아닌 첫 번째 문자가 발견 될 때까지 공백 문자 ( &lt;code&gt;std::&lt;a href=&quot;iswspace&quot;&gt;iswspace&lt;/a&gt;()&lt;/code&gt; 의해 결정됨)를 버립니다 . 그런 다음 유효한 부동 소수점 표현을 형성하기 위해 가능한 한 많은 문자를 사용하여 부동 소수점 값으로 변환합니다. 유효한 부동 소수점 값은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="translated">최소 너비 정수 상수에 대한 함수 매크로</target>
        </trans-unit>
        <trans-unit id="8611a2a8a66243d802deec0150be8ab29d36d93c" translate="yes" xml:space="preserve">
          <source>Function names, type names, and enumeration constants that begin with either &lt;code&gt;cnd_&lt;/code&gt;, &lt;code&gt;mtx_&lt;/code&gt;, &lt;code&gt;thrd_&lt;/code&gt;, or &lt;code&gt;tss_&lt;/code&gt;, and a lowercase letter may be added to the declarations in the &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; header in future revisions of the C standard, and portable programs should not use those identifiers.</source>
          <target state="translated">&lt;code&gt;cnd_&lt;/code&gt; , &lt;code&gt;mtx_&lt;/code&gt; , &lt;code&gt;thrd_&lt;/code&gt; 또는 &lt;code&gt;tss_&lt;/code&gt; 로 시작하는 함수 이름, 유형 이름 및 열거 상수 및 소문자 는 향후 C 표준 개정판의 &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; 헤더에 있는 선언에 추가 될 수 있습니다 . 프로그램은 이러한 식별자를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5d302435048821cd6e2c77c400cdc613a006798f" translate="yes" xml:space="preserve">
          <source>Function parameter</source>
          <target state="translated">기능 매개 변수</target>
        </trans-unit>
        <trans-unit id="897bc01f0c788bf99ba1e506b918d0c6dc003db3" translate="yes" xml:space="preserve">
          <source>Function parameters cannot use any storage-class specifiers other than &lt;code&gt;register&lt;/code&gt;. Note that &lt;code&gt;static&lt;/code&gt; has special meaning in function parameters of array type.</source>
          <target state="translated">함수 매개 변수는 &lt;code&gt;register&lt;/code&gt; 이외의 스토리지 클래스 지정자를 사용할 수 없습니다 . 하는 것으로 &lt;code&gt;static&lt;/code&gt; 배열 유형의 함수 매개 변수에 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="65b1ee7db3df5d96f4d481571269021a7e58f345" translate="yes" xml:space="preserve">
          <source>Function prototype scope</source>
          <target state="translated">함수 프로토 타입 범위</target>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="translated">기능 범위</target>
        </trans-unit>
        <trans-unit id="cc0c3a9a39538ad721a8a34b1652f79fa1c98697" translate="yes" xml:space="preserve">
          <source>Function to pointer conversion</source>
          <target state="translated">포인터를 함수로 변환</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">함수형 매크로</target>
        </trans-unit>
        <trans-unit id="1db43149fb17967937b95803eca5c9dd022b9456" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of a defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="translated">함수와 유사한 매크로는 정의 된 식별자의 각 항목을 교체 목록으로 대체하고, 추가로 여러 인수를 취한 다음 대체 목록에서 매개 변수의 해당 항목을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b739266e3c6aeb113a3693680f16c996224db99c" translate="yes" xml:space="preserve">
          <source>Functions may accept zero or more</source>
          <target state="translated">함수는 0 이상을 받아 들일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1788789dd164ce9b4d0f6beaa43826240bc2b04a" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; are not called. Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; 전달 된 함수는 호출되지 않습니다. 기록되지 않은 버퍼링 된 데이터가있는 열린 스트림이 플러시되는지, 열린 스트림이 닫히는 지 또는 임시 파일이 제거되는지는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="093b58a5c37c2b165378562c2473a310e08a10ac" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; 에 전달 된 함수는 등록 순서와 반대로 호출됩니다. 등록 된 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;_Exit&lt;/a&gt;(exit_code)&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eaa62088da9f4aaace239ef18473787adba2624" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; are not called. Whether open resources such as files are closed is implementation defined. An implementation defined status is returned to the host environment that indicates unsuccessful execution.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit()&lt;/a&gt;&lt;/code&gt; 전달 된 함수는 호출되지 않습니다. 파일과 같은 열린 리소스가 닫히는 지 여부는 구현 정의입니다. 구현 정의 상태가 실패한 실행을 나타내는 호스트 환경으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c38cb46c4c3dc86adeece732ff02d4d810f5334b" translate="yes" xml:space="preserve">
          <source>Functions that ignore unused arguments, such as &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, must be called with a prototype in scope (the prototype of such functions necessarily uses the &lt;a href=&quot;variadic&quot;&gt;trailing ellipsis&lt;/a&gt; parameter) to avoid invoking undefined behavior.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 와 같이 사용하지 않는 인수를 무시 하는 함수는 정의되지 않은 동작이 발생하지 않도록 범위 내 프로토 타입 (이러한 함수의 프로토 타입은 반드시 &lt;a href=&quot;variadic&quot;&gt;후행 줄임표&lt;/a&gt; 매개 변수를 사용해야 함 )으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="translated">문자 데이터에 포함 된 유형을 결정하는 함수</target>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="translated">와이드 문자 데이터에 포함 된 유형을 결정하는 함수</target>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="translated">언어로 정의 된 기본 유형</target>
        </trans-unit>
        <trans-unit id="b40e0801f27d530d95fd36fa896a9bc2b6b5bae8" translate="yes" xml:space="preserve">
          <source>G.1/1 __STDC_IEC_559_COMPLEX__ (p: 467)</source>
          <target state="translated">G.1 / 1 __STDC_IEC_559_COMPLEX__ (p : 467)</target>
        </trans-unit>
        <trans-unit id="26bf5fe88c328fbc6e45a59d6ad8c3338b8f81d3" translate="yes" xml:space="preserve">
          <source>G.1/1 __STDC_IEC_559_COMPLEX__ (p: 532)</source>
          <target state="translated">G.1 / 1 __STDC_IEC_559_COMPLEX__ (p : 532)</target>
        </trans-unit>
        <trans-unit id="95c12bcd2220cd7ce08b8f2049d3ec8c11b89bc0" translate="yes" xml:space="preserve">
          <source>G.5 Common extensions</source>
          <target state="translated">G.5 공통 확장</target>
        </trans-unit>
        <trans-unit id="6cfe6dbfae9b4bae4ad5072108c7d017fc8beae5" translate="yes" xml:space="preserve">
          <source>G.6.1.1 The cacos functions (p: 474)</source>
          <target state="translated">G.6.1.1 cacos 기능 (p : 474)</target>
        </trans-unit>
        <trans-unit id="28cd3a62fe8f1c7d66de5b67bae415419d002420" translate="yes" xml:space="preserve">
          <source>G.6.1.1 The cacos functions (p: 539)</source>
          <target state="translated">G.6.1.1 cacos 기능 (p : 539)</target>
        </trans-unit>
        <trans-unit id="0d6828ca5fb97ca1d1f2d7c68567b2a005ebd2dc" translate="yes" xml:space="preserve">
          <source>G.6.2.1 The cacosh functions (p: 474-475)</source>
          <target state="translated">G.6.2.1 cacosh 함수 (p : 474-475)</target>
        </trans-unit>
        <trans-unit id="5563291e3a61ef1c53c5a28c3172a343b28df495" translate="yes" xml:space="preserve">
          <source>G.6.2.1 The cacosh functions (p: 539-540)</source>
          <target state="translated">G.6.2.1 cacosh 함수 (p : 539-540)</target>
        </trans-unit>
        <trans-unit id="15c4239db1623508b82ef247489b388de1f145aa" translate="yes" xml:space="preserve">
          <source>G.6.2.2 The casinh functions (p: 475)</source>
          <target state="translated">G.6.2.2 casinh 함수 (p : 475)</target>
        </trans-unit>
        <trans-unit id="d95db88fd7fa78e9816bf9ac2e9ac27bc72cdaef" translate="yes" xml:space="preserve">
          <source>G.6.2.2 The casinh functions (p: 540)</source>
          <target state="translated">G.6.2.2 casinh 함수 (p : 540)</target>
        </trans-unit>
        <trans-unit id="d126febe0f09e9c82a643bf277ca8d4fe4e04945" translate="yes" xml:space="preserve">
          <source>G.6.2.3 The catanh functions (p: 475-476)</source>
          <target state="translated">G.6.2.3 카탄 함수 (p : 475-476)</target>
        </trans-unit>
        <trans-unit id="e9df4d1c541d6a2988fd893d1e22aa72d9155e65" translate="yes" xml:space="preserve">
          <source>G.6.2.3 The catanh functions (p: 540-541)</source>
          <target state="translated">G.6.2.3 카탄 기능 (p : 540-541)</target>
        </trans-unit>
        <trans-unit id="151135301ba799fb81ac54ff917a64f55b3d87b2" translate="yes" xml:space="preserve">
          <source>G.6.2.4 The ccosh functions (p: 476)</source>
          <target state="translated">G.6.2.4 ccosh 기능 (p : 476)</target>
        </trans-unit>
        <trans-unit id="efb2b4b5712cfe1e5839fb21e5627757b0aab87b" translate="yes" xml:space="preserve">
          <source>G.6.2.4 The ccosh functions (p: 541)</source>
          <target state="translated">G.6.2.4 ccosh 기능 (p : 541)</target>
        </trans-unit>
        <trans-unit id="694daeb728fce58d77bf0d8e64905eea2b21ad5f" translate="yes" xml:space="preserve">
          <source>G.6.2.5 The csinh functions (p: 476-477)</source>
          <target state="translated">G.6.2.5 csinh 함수 (p : 476-477)</target>
        </trans-unit>
        <trans-unit id="59eab894944e803c504dd7168fa4266717e78383" translate="yes" xml:space="preserve">
          <source>G.6.2.5 The csinh functions (p: 541-542)</source>
          <target state="translated">G.6.2.5 csinh 함수 (p : 541-542)</target>
        </trans-unit>
        <trans-unit id="f2df7c85c1d43e348f139a6b045dc1d5b8012c06" translate="yes" xml:space="preserve">
          <source>G.6.2.6 The ctanh functions (p: 477)</source>
          <target state="translated">G.6.2.6 ctanh 함수 (p : 477)</target>
        </trans-unit>
        <trans-unit id="d9eb1944f14793485c1748feed122919547f89b9" translate="yes" xml:space="preserve">
          <source>G.6.2.6 The ctanh functions (p: 542)</source>
          <target state="translated">G.6.2.6 ctanh 함수 (p : 542)</target>
        </trans-unit>
        <trans-unit id="11bf1336a1baab07ae8854d62d4f99e7b6ec203d" translate="yes" xml:space="preserve">
          <source>G.6.3.1 The cexp functions (p: 478)</source>
          <target state="translated">G.6.3.1 cexp 함수 (p : 478)</target>
        </trans-unit>
        <trans-unit id="e149ca4beb9e25b6bda49409bda5f10206e086b7" translate="yes" xml:space="preserve">
          <source>G.6.3.1 The cexp functions (p: 543)</source>
          <target state="translated">G.6.3.1 cexp 함수 (p : 543)</target>
        </trans-unit>
        <trans-unit id="e9c93804224051a50630d62c4ed8220690a9bfa6" translate="yes" xml:space="preserve">
          <source>G.6.3.2 The clog functions (p: 478-479)</source>
          <target state="translated">G.6.3.2 막힘 기능 (p : 478-479)</target>
        </trans-unit>
        <trans-unit id="b973293eede2ecb3bd41d6f371cc4d1697571cd1" translate="yes" xml:space="preserve">
          <source>G.6.3.2 The clog functions (p: 543-544)</source>
          <target state="translated">G.6.3.2 막힘 기능 (p : 543-544)</target>
        </trans-unit>
        <trans-unit id="c92214d3d5a8fbcf280afad86e034a21ce259174" translate="yes" xml:space="preserve">
          <source>G.6.4.1 The cpow functions (p: 479)</source>
          <target state="translated">G.6.4.1 cpow 함수 (p : 479)</target>
        </trans-unit>
        <trans-unit id="de2003697457272aa833f7982055194cc6b7115f" translate="yes" xml:space="preserve">
          <source>G.6.4.1 The cpow functions (p: 544)</source>
          <target state="translated">G.6.4.1 cpow 함수 (p : 544)</target>
        </trans-unit>
        <trans-unit id="e40ff81ce8c3267d1bf703062d6a64cc98b1f38c" translate="yes" xml:space="preserve">
          <source>G.6.4.2 The csqrt functions (p: 479)</source>
          <target state="translated">G.6.4.2 csqrt 함수 (p : 479)</target>
        </trans-unit>
        <trans-unit id="05f7734e308beb0fedfb7893ef3fa7e54af7b545" translate="yes" xml:space="preserve">
          <source>G.6.4.2 The csqrt functions (p: 544)</source>
          <target state="translated">G.6.4.2 csqrt 함수 (p : 544)</target>
        </trans-unit>
        <trans-unit id="c20fd542256174a6393b0316152fcef6e7b39622" translate="yes" xml:space="preserve">
          <source>G.6/1 I (p: 472)</source>
          <target state="translated">G.6 / 1 I (p : 472)</target>
        </trans-unit>
        <trans-unit id="e76143abbf8e87829cf91c7d518a52e7300d298b" translate="yes" xml:space="preserve">
          <source>G.6/1 I (p: 537)</source>
          <target state="translated">G.6 / 1 I (p : 537)</target>
        </trans-unit>
        <trans-unit id="a2e6820b346f1cb99f63ee321c682a377db511b9" translate="yes" xml:space="preserve">
          <source>G.6/1 _Imaginary_I (p: 472)</source>
          <target state="translated">G.6 / 1 _Imaginary_I (p : 472)</target>
        </trans-unit>
        <trans-unit id="0ccf37492c7533141e934c40b558afd151233311" translate="yes" xml:space="preserve">
          <source>G.6/1 _Imaginary_I (p: 537)</source>
          <target state="translated">G.6 / 1 _Imaginary_I (p : 537)</target>
        </trans-unit>
        <trans-unit id="208724c83318d0110acbd3f15de4edddbcd6efdf" translate="yes" xml:space="preserve">
          <source>G.6/1 imaginary (p: 472)</source>
          <target state="translated">G.6 / 1 가상 (p : 472)</target>
        </trans-unit>
        <trans-unit id="cf45a995bfaea360a6835fd54d30380487b0f7e5" translate="yes" xml:space="preserve">
          <source>G.6/1 imaginary (p: 537)</source>
          <target state="translated">G.6 / 1 가상 (p : 537)</target>
        </trans-unit>
        <trans-unit id="50662b8108e397a8cf830e58874d9ce4fe937eaf" translate="yes" xml:space="preserve">
          <source>G.7 Type-generic math &amp;lt;tgmath.h&amp;gt; (p: 480)</source>
          <target state="translated">G.7 유형 일반 수학 &amp;lt;tgmath.h&amp;gt; (p : 480)</target>
        </trans-unit>
        <trans-unit id="4f44e0122fc6c4e13b2e4136b84f00a56924a452" translate="yes" xml:space="preserve">
          <source>G.7 Type-generic math &amp;lt;tgmath.h&amp;gt; (p: 545)</source>
          <target state="translated">G.7 유형 일반 수학 &amp;lt;tgmath.h&amp;gt; (p : 545)</target>
        </trans-unit>
        <trans-unit id="ac2bfb22c6d1b00526db5c04d7d3f16f7a772c12" translate="yes" xml:space="preserve">
          <source>GCC provides a non-portable extension that allows imaginary constants to be specified with the suffix &lt;code&gt;i&lt;/code&gt; on integer literals: &lt;code&gt;1.0fi&lt;/code&gt;, &lt;code&gt;1.0i&lt;/code&gt;, and &lt;code&gt;1.0li&lt;/code&gt; are imaginary units in GNU C. A similar approach is part of standard C++ as of C++14 (&lt;code&gt;1.0if&lt;/code&gt;, &lt;code&gt;1.0i&lt;/code&gt;, and &lt;code&gt;1.0il&lt;/code&gt; are the imaginary units in C++).</source>
          <target state="translated">GCC 상상 상수 접미사로 지정 될 수있는 비 - 휴대용 연장 제공 &lt;code&gt;i&lt;/code&gt; 정수 리터럴 : &lt;code&gt;1.0fi&lt;/code&gt; , &lt;code&gt;1.0i&lt;/code&gt; 를 하고 &lt;code&gt;1.0li&lt;/code&gt; 는 GNU C. 유사한 접근법 허수 단위 인 C +의 표준 C ++의 일부 +14 ( &lt;code&gt;1.0if&lt;/code&gt; , &lt;code&gt;1.0i&lt;/code&gt; 및 &lt;code&gt;1.0il&lt;/code&gt; 은 ++ C의 허수 단위 임).</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="10dd377e783f3967d6438e53ce8a2f7f5022cc8a" translate="yes" xml:space="preserve">
          <source>General utilities: &lt;a href=&quot;memory&quot;&gt;memory management&lt;/a&gt;, &lt;a href=&quot;program&quot;&gt;program utilities&lt;/a&gt;, &lt;a href=&quot;string&quot;&gt;string conversions&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt;random numbers&lt;/a&gt;</source>
          <target state="translated">일반 유틸리티 : &lt;a href=&quot;memory&quot;&gt;메모리 관리&lt;/a&gt; , &lt;a href=&quot;program&quot;&gt;프로그램 유틸리티&lt;/a&gt; , &lt;a href=&quot;string&quot;&gt;문자열 변환&lt;/a&gt; , &lt;a href=&quot;numeric/random&quot;&gt;난수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e408e1f43fa73d535c56f0c1a60024c29bed6a6f" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, and the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="translated">일반적으로 의사 난수 생성기는 &lt;code&gt;rand()&lt;/code&gt; 호출 및 프로그램 시작 전에 한 번만 시드되어야합니다 . 새로운 의사 난수의 새로운 배치를 생성 할 때마다 반복적으로 시드되거나 시드 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="12eb72d3243c15b2d7666b7ae7d45ad3f7dad95a" translate="yes" xml:space="preserve">
          <source>Generic selection</source>
          <target state="translated">일반 선택</target>
        </trans-unit>
        <trans-unit id="f4f8b78ea64ed83627d292f81c40574ae35f827f" translate="yes" xml:space="preserve">
          <source>Generic selection is similar to overloading in C++ (where one of several functions is chosen at compile time based on the types of the arguments), except that it makes the selection between arbitrary expressions.</source>
          <target state="translated">일반 선택은 임의의 식 사이에서 선택한다는 점을 제외하고 C ++에서의 오버로드와 비슷합니다 (여러 함수 중 하나가 인수 유형에 따라 컴파일 타임에 선택됨).</target>
        </trans-unit>
        <trans-unit id="f82dd9e5af6da2aa72552c81bdb59e03bf15b8e1" translate="yes" xml:space="preserve">
          <source>Given an object with</source>
          <target state="translated">와 함께 주어진 개체</target>
        </trans-unit>
        <trans-unit id="c10602e998b8cfe65e56c43becd8d2b538c79d91" translate="yes" xml:space="preserve">
          <source>HP aCC compiler pragmas</source>
          <target state="translated">HP ACC 컴파일러 실용</target>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="translated">HUGE_VALF, HUGE_VAL, HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="f786495fe9ea368b774d5544cbb82c7ec30035c0" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive and in implementation-defined locations within a &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">헤더 이름 사전 처리 토큰은 &lt;code&gt;#include&lt;/code&gt; 지시문 및 &lt;code&gt;#pragma&lt;/code&gt; 지시문 내의 구현 정의 위치 에만 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8559345b43a025d30613b072a1f7f0d697cc5027" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal or character constant (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">16 진 이스케이프 시퀀스에는 길이 제한이 없으며 유효한 16 진수가 아닌 첫 번째 문자에서 종료됩니다. 단일 16 진 이스케이프 시퀀스로 표시되는 값이이 문자열 리터럴 또는 문자 상수 ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; )에 사용 된 문자 유형으로 표시되는 값 범위에 맞지 않으면 결과가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9323be5c110b5aa5f2d228930349fa184bfe2fd" translate="yes" xml:space="preserve">
          <source>History of C</source>
          <target state="translated">C의 역사</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">시, 분, 초</target>
        </trans-unit>
        <trans-unit id="f15adf7bfe70ef5a75b3b7c3331bdfc66a4acaf1" translate="yes" xml:space="preserve">
          <source>However, when an initializer begins with a left open brace, its</source>
          <target state="translated">그러나 이니셜 라이저가 왼쪽 열린 괄호로 시작하면</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">쌍곡 코사인은 복잡한 평면에서 전체 기능이며 분기 컷이 없습니다. 가상 성분에 대해서는주기가 2&amp;pi;i 인주기입니다.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">쌍곡선 함수</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">쌍곡 사인은 복잡한 평면에서 전체 기능이며 브랜치 컷이 없습니다. 가상 성분에 대해서는주기가 2&amp;pi;i 인주기입니다.</target>
        </trans-unit>
        <trans-unit id="413dc47c587aa42c078941a669410916c5e97bcf" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">쌍곡 탄젠트는 복잡한 평면에서 분석 함수이며 분기 절단이 없습니다. 그것은 &amp;pi;i의 가상 성분에 대하여 주기적이며, 좌표 (0, &amp;pi; (1/2 + n))에서 가상의 선을 따라 1 차 극을 갖는다. 그러나 일반적인 부동 소수점 표현은 &amp;pi; / 2를 정확하게 표현할 수 없으므로 극 오차가 발생하는 인수의 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="b35c4b7a4582b768650003b92551d670cc72067a" translate="yes" xml:space="preserve">
          <source>I/O streams are objects of type &lt;code&gt;FILE&lt;/code&gt; that can only be accessed and manipulated through pointers of type &lt;code&gt;FILE*&lt;/code&gt; (Note: while it may be possible to create a local object of type &lt;code&gt;FILE&lt;/code&gt; by dereferencing and copying a valid &lt;code&gt;FILE*&lt;/code&gt;, using the address of such copy in the I/O functions is undefined behavior). Each stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</source>
          <target state="translated">I / O 스트림은 &lt;code&gt;FILE*&lt;/code&gt; 유형의 포인터를 통해서만 액세스하고 조작 할 수있는 &lt;code&gt;FILE&lt;/code&gt; 유형의 객체입니다 (참고 : 주소를 사용하여 유효한 &lt;code&gt;FILE*&lt;/code&gt; 를 역 참조하고 복사하여 &lt;code&gt;FILE&lt;/code&gt; 유형의 로컬 객체를 생성 할 수 있습니다) I / O 함수에서 이러한 사본의 정의는 정의되지 않은 동작입니다). 각 스트림은 외부 물리적 장치 (파일, 표준 입력 스트림, 프린터, 직렬 포트 등)와 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="c237a26303d9ce6c44278fc659b5347852badd06" translate="yes" xml:space="preserve">
          <source>I/O streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. All streams access the same locale object: the one most recently installed with &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">I / O 스트림은 형식화되지 않은 형식의 입력 및 출력에 모두 사용할 수 있습니다. 로케일에 민감하며 필요에 따라 와이드 / 멀티 바이트 변환을 수행 할 수 있습니다. 모든 스트림은 동일한 로케일 오브젝트 ( &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; 로 가장 최근에 설치된 것)에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="03c599d26b9f4c8b751cead1f324b345be4d7ceb" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559는 것이 좋습니다 &lt;code&gt;from&lt;/code&gt; 때마다 반환 &lt;code&gt;from==to&lt;/code&gt; . 이러한 함수 &lt;code&gt;to&lt;/code&gt; 대신 0으로 돌아가 동작을 일관되게 만듭니다. &lt;code&gt;nextafter(-0.0, +0.0)&lt;/code&gt; 은 &lt;code&gt;+0.0&lt;/code&gt; 을 반환 하고 &lt;code&gt;nextafter(+0.0, -0.0)&lt;/code&gt; 은 &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">ISO 30112는 POSIX 제어 문자를 유니 코드 문자 U + 0000..U + 001F, U + 007F..U + 009F, U + 2028 및 U + 2029 (유니 코드 클래스 Cc, Zl 및 Zp)로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112는 POSIX 공백 문자를 유니 코드 문자 U + 0009..U + 000D, U + 0020, U + 1680, U + 180E, U + 2000..U + 2006, U + 2008..U + 200A, U +로 정의합니다. 2028, U + 2029, U + 205F 및 U + 3000.</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="5df5db83d291a84e8693ec1784228be5a9d8a9a4" translate="yes" xml:space="preserve">
          <source>Identifiers a, b, f, and g have file scope.</source>
          <target state="translated">식별자 a, b, f 및 g는 파일 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2672ebe977d252cfae360252c5fb4f4f69527b64" translate="yes" xml:space="preserve">
          <source>Identifiers can denote the following types of entities:</source>
          <target state="translated">식별자는 다음 유형의 엔티티를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a53835700ea021acf4e404661a96971fd56c8741" translate="yes" xml:space="preserve">
          <source>Identifiers for thread states and errors.</source>
          <target state="translated">스레드 상태 및 오류의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="012e30d5ff7b0eca7096ca0ef0422f1cf1ad5ef5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우 모든 부동 소수점 산술 연산자는 현재 부동 소수점 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;반올림 방향&lt;/a&gt; 을 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;initialization&quot;&gt; 정적 초기화 프로그램의&lt;/a&gt; 일부가 아닌 경우 부동 소수점 예외가있는 경우가 아니라면 math_errhandling에 지정된대로 부동 소수점 산술 오류를보고합니다 올림이없고 반올림 모드가 가장 가깝습니다).</target>
        </trans-unit>
        <trans-unit id="e0287f0c686ba01cad63a0be3dc59fccc6064694" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 는 2 (또는 2의 거듭 제곱)이며, 반환 값은 정확 &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드는&lt;/a&gt; 무시됩니다</target>
        </trans-unit>
        <trans-unit id="31d86a702dd47847a66399b1dc80f0da0b7cfa5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; 가 적절한 버퍼 크기가 아닌 경우 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt; 를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b79b5672025a2dcd4c160d18058bb72dde7976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="translated">경우 &lt;code&gt;NDEBUG&lt;/code&gt; 가 소스 코드의 시점에서 매크로 이름으로 정의되어 &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; 포함되어, 다음 &lt;code&gt;assert&lt;/code&gt; 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb4be0b9f283d05e7e78bb3a582406ff9af784e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort&lt;/a&gt;()&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the &lt;a href=&quot;../preprocessor/replace&quot;&gt;standard macros&lt;/a&gt;&lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the &lt;a href=&quot;../language/function_definition&quot;&gt;predefined variable&lt;/a&gt;&lt;code&gt;__func__&lt;/code&gt;.(since C99).</source>
          <target state="translated">경우 &lt;code&gt;NDEBUG&lt;/code&gt; 가 정의되어 있지 않은 경우, &lt;code&gt;assert&lt;/code&gt; 검사 인수 (스칼라 형을 가져야한다)이 제로인 경우와 비교. 만약 그렇다면, &lt;code&gt;assert&lt;/code&gt; 출력 구현 고유의 진단 표준 오류 출력에 대한 정보와 통화 &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort&lt;/a&gt;()&lt;/code&gt; . 진단 정보의 텍스트를 포함 할 필요가 &lt;code&gt;expression&lt;/code&gt; 뿐만 아니라 값 &lt;a href=&quot;../preprocessor/replace&quot;&gt;표준 매크로 &lt;/a&gt; &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;__LINE__&lt;/code&gt; 및 &lt;a href=&quot;../language/function_definition&quot;&gt;소정 변수 &lt;/a&gt; &lt;code&gt;__func__&lt;/code&gt; . (C99) 이후.</target>
        </trans-unit>
        <trans-unit id="a3db10378a1cc105c0a22a4f2c0f99f5d34c39bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn;이다 &amp;infin;, &amp;plusmn; 0이 반환되고, &amp;plusmn; &amp;infin;에 저장됩니다 &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 있습니다 &amp;plusmn; &amp;infin;, + &amp;infin;가 반환된다</target>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 있다 &amp;plusmn; &amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 이 제기되고 구현 정의 된 값을 반환</target>
        </trans-unit>
        <trans-unit id="b2c40c9472f7e29a79351555cd2feb2e0f4bf69b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 있다 &amp;plusmn; &amp;infin;, 그것을 반환되고, 불특정 값이 저장된다 &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; &amp;infin;이며, 그것은 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, &amp;plusmn; &amp;infin;, 또는 NaN의 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52141cb14b3833d9514aee0d11bc6396482017af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0 인 &amp;plusmn; 0이 반환되고, &amp;plusmn; 0에 저장됩니다 &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, -&amp;infin; 반환 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, 그것은 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="5dc17fdaf08e8797e56099a677398b82af4d0180" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, 그것은이 수정되지 않은 반환되고, &lt;code&gt;0&lt;/code&gt; 에 저장됩니다 &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 인, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생하고 구현 정의 값이 반환된다</target>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 NaN이 반환된다</target>
        </trans-unit>
        <trans-unit id="ae52bceff3b02f7b3ee9b3972972ded1fb86990a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 NaN이 반환되고, NaN이은에 저장됩니다 &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1cb41b693b54309d8cd057ea727f5c2a44b70a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 NaN이 반환되고, 불특정 값이 저장된다 &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의이다, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="85329a9a82100a9c1a2cd29c7eed89e508e44736" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 자연수 인 경우 &lt;code&gt;lgamma(arg)&lt;/code&gt; 는 &lt;code&gt;arg-1&lt;/code&gt; 의 계승에 대한 로그입니다 .</target>
        </trans-unit>
        <trans-unit id="fbec8bd424bd1d802c57ea8f26b821ec16976114" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 자연수, &lt;code&gt;tgamma(arg)&lt;/code&gt; 의 계승 인 &lt;code&gt;arg-1&lt;/code&gt; . 인수가 충분히 작은 정수인 경우 많은 구현에서 정확한 정수 도메인 계승을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b16a546b06c9d95257ded195bd4035d23e04e06b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 무한대, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 부동 소수점 숫자가 아닌 경우 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32ff62b6889ca3482df7c46498edc6f6674221b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;(int)&lt;a href=&quot;logb&quot;&gt;logb&lt;/a&gt;(arg)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 0, 무한 또는 NaN이 아닌 경우 반환되는 값은 &lt;code&gt;(int)&lt;a href=&quot;logb&quot;&gt;logb&lt;/a&gt;(arg)&lt;/code&gt; 와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 0이거나 정수 0 미만이며, 기둥 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 0이거나 정수 0 미만이며, 기둥 오류나 도메인 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 제로, &lt;code&gt;FP_ILOGB0&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 제로, 0을 반환하고 매장에서 제로 &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;TIME_UTC&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="88b08a2ca4f793bfaeabfcb3e0137c1037ec815c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exponent&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="translated">경우 &lt;code&gt;base&lt;/code&gt; 유한과 음극과 &lt;code&gt;exponent&lt;/code&gt; 한정이 아닌 정수이고, 도메인 오류가 발생하여 다양한 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="bc0d6604e049ef0469b7407b8700ef87f4c2b1cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exponent&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="translated">경우 &lt;code&gt;base&lt;/code&gt; 0이고 &lt;code&gt;exponent&lt;/code&gt; 음수 도메인 오류 또는 극 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="fe1f81b4cf62dfd261b43cdf1631e95df10c22e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exponent&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="translated">경우 &lt;code&gt;base&lt;/code&gt; 0이고 &lt;code&gt;exponent&lt;/code&gt; 제로 도메인 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 널 포인터에 내부 버퍼 크기를 조절 &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a41f3aeda56216d76a85bf549142c566dd8345e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;fclose&lt;/a&gt;&lt;/code&gt;) before the &lt;a href=&quot;../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; NULL 포인터 아니라, 크기의 사용자 제공 버퍼 사용하도록 지시 스트림 &lt;code&gt;size&lt;/code&gt; 에서 시작 &lt;code&gt;buffer&lt;/code&gt; . &lt;code&gt;buffer&lt;/code&gt; 가 가리키는 배열 의 &lt;a href=&quot;../language/lifetime&quot;&gt;수명&lt;/a&gt; 이 끝나기 전에 스트림을 닫아야합니다 ( &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;fclose&lt;/a&gt;&lt;/code&gt; 사용 ) . &lt;code&gt;setvbuf&lt;/code&gt; 를 성공적으로 호출 한 후 배열의 내용 은 불확실하며이를 사용하려는 시도는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="8933681edb25a289169d034aa0994de4b7ca1688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../io&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 가 null이 아닌 경우 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../io&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bace9448279b193681afb8262a65ef1da2317ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 가 null의 경우 , &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../io&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt; 와 동등 해 버퍼링을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">&lt;code&gt;c16&lt;/code&gt; 이 와이드 문자의 16 비트 표현에서 최종 코드 단위가 아닌 경우 &lt;code&gt;s&lt;/code&gt; 가 가리키는 배열에 쓰지 않고 &lt;code&gt;*ps&lt;/code&gt; 만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="5cd0616388c6486a36bee07efdbd316f0b1b2c96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">경우 &lt;code&gt;c16&lt;/code&gt; 널 와이드 문자는 &lt;code&gt;u'\0'&lt;/code&gt; , 널 (null) 바이트가 초기 변속 상태 전환 상태 파라미터 복원하는데 필요한 임의의 시프트가 앞에, 저장된 &lt;code&gt;*ps&lt;/code&gt; 초기 이동의 상태를 나타내도록 업데이트된다.</target>
        </trans-unit>
        <trans-unit id="cee38660c6cd74cd32407f813278c336fe952e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c32&lt;/code&gt; is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">경우 &lt;code&gt;c32&lt;/code&gt; 널 와이드 문자 &lt;code&gt;U'\0'&lt;/code&gt; 널 바이트는 초기 변속 상태 전환 상태 파라미터를 복원하는데 필요한 임의의 시프트가 앞에, 저장 &lt;code&gt;*ps&lt;/code&gt; 초기 변속 상태를 나타 내기 위해 갱신된다.</target>
        </trans-unit>
        <trans-unit id="b61b6f5b84317e677153362beb836a78c61619c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner that subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="translated">경우 &lt;code&gt;ch&lt;/code&gt; 동일하지 않는 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 를 , 문자 푸시 &lt;code&gt;ch&lt;/code&gt; (로 재 해석 &lt;code&gt;unsigned char&lt;/code&gt; 스트림과 연관된 입력 버퍼) &lt;code&gt;stream&lt;/code&gt; 같은 방식으로 후속 판독 동작이 &lt;code&gt;stream&lt;/code&gt; 해당 문자를 검색하는 것이다. 스트림과 관련된 외부 장치는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a57c34ec42bd9be0ad89adc1a923520e0077144a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner that subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="translated">경우 &lt;code&gt;ch&lt;/code&gt; 동일하지 않는 &lt;code&gt;WEOF&lt;/code&gt; 를 상기 와이드 문자 푸시 &lt;code&gt;ch&lt;/code&gt; 스트림과 관련된 버퍼에 입력을 &lt;code&gt;stream&lt;/code&gt; 같은 방식으로 그 다음의 판독 동작 &lt;code&gt;stream&lt;/code&gt; 이 넓은 문자를 검색한다. 스트림과 관련된 외부 장치는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c14f42bfaf455713c73850a9b738e4d8564279fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 와 같은 경우 작업이 실패하고 스트림은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">경우 &lt;code&gt;ch&lt;/code&gt; 동일 &lt;code&gt;WEOF&lt;/code&gt; 을 작업이 실패하고 스트림은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b6ed2df20ac94130f4229b9b625f3c25374a619" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order in the resulting sorted array is unspecified.</source>
          <target state="translated">&lt;code&gt;comp&lt;/code&gt; 가 두 요소를 동등한 것으로 표시 하면 정렬 된 결과 배열에서 순서가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 있다 &lt;code&gt;​0​&lt;/code&gt; , 다음 &lt;code&gt;dest&lt;/code&gt; 널 포인터로 할 수있다.</target>
        </trans-unit>
        <trans-unit id="7c4f638ff595d6b56790ce243921af64efe6390b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire array &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 전체 배열에 도달하기 전에 &lt;code&gt;src&lt;/code&gt; 복사 된, 결과 문자 배열이 null 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="translated">전체 문자열 &lt;code&gt;src&lt;/code&gt; 전에 &lt;code&gt;count&lt;/code&gt; 에 도달 하면 복사 된, 결과 와이드 문자 배열이 null 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 제로,이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 제로, 함수는 널 포인터를 반환한다.</target>
        </trans-unit>
        <trans-unit id="0a5b5a3d18a2f383eebd17f1e0c87ef7de0762b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destructor&lt;/code&gt; is not a null pointer, then also associates the destructor which is called when the storage is released by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; (but not by &lt;code&gt;&lt;a href=&quot;tss_delete&quot;&gt;tss_delete&lt;/a&gt;&lt;/code&gt; and not at program termination by &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;destructor&lt;/code&gt; 널 포인터가 아닌, 다음 또한 스토리지가 발표 될 때 호출되는 소멸자 연관 &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; 하지 않음으로써 (그러나 &lt;code&gt;&lt;a href=&quot;tss_delete&quot;&gt;tss_delete&lt;/a&gt;&lt;/code&gt; 및하지 않음으로써 프로그램 종료에 &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="translated">경우 &lt;code&gt;exit_code&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; , 성공적인 종료를 나타내는 구현 정의 상태는 호스트 환경에 반환됩니다. &lt;code&gt;exit_code&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; 인 경우 나타내는 구현 정의 상태,</target>
        </trans-unit>
        <trans-unit id="dd356ac95b78ee8d3316f54756261230b7ae7603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;arg&lt;/code&gt; is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;exp&lt;/code&gt; 0, 다음 &lt;code&gt;arg&lt;/code&gt; , 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="aa8dc7735d619a4734d97c476943c7b150c788b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;goto&lt;/code&gt; leaves the scope of a VLA, it is deallocated (and may be reallocated if its initialization is executed again):</source>
          <target state="translated">만약 &lt;code&gt;goto&lt;/code&gt; VLA의 범위, 그것은 할당 해제됩니다 (그 초기화가 다시 실행되면 재 할당 할 수있다) 잎 :</target>
        </trans-unit>
        <trans-unit id="7f139378ae3c47e672c41f256a64675e51a89c67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignore_handler_s&lt;/code&gt; is used as a the runtime constraints handler, the violations may be detected by examining the results of the bounds-checked function calls, which may be different for different functions (non-zero &lt;code&gt;errno_t&lt;/code&gt;, null character written to the first byte of the output string, etc).</source>
          <target state="translated">&lt;code&gt;ignore_handler_s&lt;/code&gt; 가 런타임 제한 조건 핸들러로 사용되는 경우 , 경계 확인 된 함수 호출의 결과를 검사하여 위반을 발견 할 수 있습니다. 이는 함수마다 다를 수 있습니다 (0이 아닌 &lt;code&gt;errno_t&lt;/code&gt; , 널 문자는 첫 번째 바이트에 기록됨) 출력 문자열 등).</target>
        </trans-unit>
        <trans-unit id="8220b5231500449270383f2d363e2887e1748889" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;int&lt;/code&gt; can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type &lt;code&gt;int&lt;/code&gt;. Otherwise the value is converted to &lt;code&gt;unsigned int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 가 원래 유형의 전체 값 범위 (또는 원래 비트 필드의 값 범위)를 나타낼 수 있으면 값은 &lt;code&gt;int&lt;/code&gt; 유형으로 변환됩니다 . 그렇지 않으면 값은 &lt;code&gt;unsigned int&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d1622661fe017f321ee25a4e9cf6aa32ff070ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt; for the same character in the same C locale.</source>
          <target state="translated">&lt;code&gt;islower&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 , 동일한 C 로케일의 동일한 문자에 대해 &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 것이 보장 됩니다.</target>
        </trans-unit>
        <trans-unit id="228f41e20ec18c0190146297fd816d5d17c54d3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, it is guaranteed that &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt; for the same character in the same C locale.</source>
          <target state="translated">경우 &lt;code&gt;isupper&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 그것은 보장된다 &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt; 에 , &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt; 와의 리턴 &lt;code&gt;false&lt;/code&gt; 같은 C 로케일에서 동일한 문자에 대해가.</target>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="translated">&lt;code&gt;mode &amp;gt; 0&lt;/code&gt; 인 경우 &lt;code&gt;stream&lt;/code&gt; 넓은 방향 으로 만들려고 시도합니다 . &lt;code&gt;mode &amp;lt; 0&lt;/code&gt; 인 경우 &lt;code&gt;stream&lt;/code&gt; 지향 바이트 를 만들려고 시도합니다 . 경우 &lt;code&gt;mode==0&lt;/code&gt; 만 스트림의 현재 방향을 조회합니다.</target>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="translated">경우 &lt;code&gt;new_filename&lt;/code&gt; 존재 동작은 구현 정의이다.</target>
        </trans-unit>
        <trans-unit id="1b3b81128b53cdb9103f95cb1f65dbf81829d30a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">경우 &lt;code&gt;new_size&lt;/code&gt; 가 제로 동작이 구현 정의 (NULL 포인터 (이 경우 기존 메모리 블록 또는 해제되지 않을 수있다)이 반환 될 수 있으며, 또는 몇몇 비 - 널 포인터 액세스 저장하는 데 사용되지 않을 수 복귀 될 수있다)이며 .</target>
        </trans-unit>
        <trans-unit id="c2592ff70a55671e630f52a0701fe807ca7a4a63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parmN&lt;/code&gt; is declared with &lt;code&gt;register&lt;/code&gt; storage class specifier, with an array type, with a function type, or with a type not compatible with the type that results from default argument promotions, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;parmN&lt;/code&gt; 가 선언되는 &lt;code&gt;register&lt;/code&gt; 기능 형과 함께 배열 형 스토리지 클래스 지정자, 또는 기본 인수 프로모션의 결과는, 동작이 정의되는 유형과 호환하지 않는 유형.</target>
        </trans-unit>
        <trans-unit id="44d20c46f9c198ea9c123c08f055544cf1af5b22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="translated">&lt;code&gt;ps&lt;/code&gt; 가 널 포인터가 아닌 경우 &lt;code&gt;mbsinit&lt;/code&gt; 함수는 지정된 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 오브젝트가 초기 변환 상태를 설명 하는지 여부를 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="3e4c54f508180ce2bca52d72bedefa0048c957d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;ptr&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이 동작은 호출과 동일 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;new_size&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="translated">경우 &lt;code&gt;ptr&lt;/code&gt; 널 포인터이며,이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rand()&lt;/code&gt; 를 호출하기 전에 사용 &lt;code&gt;srand()&lt;/code&gt; , &lt;code&gt;rand()&lt;/code&gt; 동작합니다는 것처럼는 글로리 &lt;code&gt;srand(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16def2206ddfe3e5010ae4e26c38ffb1e3b7ca4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;res&lt;/code&gt; is not a null pointer, the result code of the thread is put to the location pointed to by &lt;code&gt;res&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;res&lt;/code&gt; 가 널 포인터가 아닌 경우 스레드의 결과 코드는 &lt;code&gt;res&lt;/code&gt; 가 가리키는 위치에 놓 입니다.</target>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터는 초기 변속 상태로 복귀 표현하는데 내부 변환 상태를 리셋 &lt;code&gt;​0​&lt;/code&gt; 현재 멀티 인코딩 상태 의존성 (시프트 시퀀스를 사용하지 않는다) 또는 비 - 제로 값은 현재 멀티가 아닌 경우이면 인코딩은 상태에 따라 다릅니다 (시프트 시퀀스 사용).</target>
        </trans-unit>
        <trans-unit id="8491ba73b16514468214be4e5a74445c09461000" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determined whether shift sequences are used.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터 글로벌 변환 상태를 리셋하고, 시프트 시퀀스들이 사용되는지 결정.</target>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터 글로벌 변환 상태를 리셋하고, 시프트 시퀀스들이 사용되는지 여부를 판정한다.</target>
        </trans-unit>
        <trans-unit id="22997fcdc6a5389460254717d711c2bcf3fcf982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터가 호출은 동일하다 &lt;code&gt;c16rtomb(buf, u'\0', ps)&lt;/code&gt; 일부 내부 버퍼 용 &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b392d0883d44d42834c77d825af0cdb02a8bba76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터가 호출은 동일하다 &lt;code&gt;c32rtomb(buf, U'\0', ps)&lt;/code&gt; 일부 내부 버퍼 용 &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9936b790fa012acb444bd08bba8ed35bc9704d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터가 호출은 동일하다 &lt;code&gt;wcrtomb(buf, L'\0', ps)&lt;/code&gt; 일부 내부 버퍼 용 &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581dbdb5a92a86f454eccb897e8676bace822faa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터의 값 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;pc16&lt;/code&gt; 는 무시 호출에 해당된다 &lt;code&gt;mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3107e31c74f5584cf473c16caa6df8b08a9926d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터의 값 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;pc32&lt;/code&gt; 무시 호출에 해당된다 &lt;code&gt;mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eebec10c747613d7bb1cfc16cb61d08d39558b92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터는, 값 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;pwc&lt;/code&gt; 무시 호출에 해당된다 &lt;code&gt;mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c87ab8512786d6dbdf059aba7190daa196aa4acb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, this function resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터는,이 함수는 글로벌 변환 상태를 리셋하고, 시프트 시퀀스들이 사용되는지 여부를 판정한다.</target>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터 아니고 &lt;code&gt;c16&lt;/code&gt; 코드 포인트의 유효 가변 길이 부호화의 마지막 16 비트 부호 부, 함수는 모든 포함하는 코드 포인트의 멀티 바이트 문자 표현을 저장하는데 필요한 바이트의 수를 (결정 시프트 시퀀스를 수행하고 현재 멀티 바이트 변환 상태 ( &lt;code&gt;*ps&lt;/code&gt; ) 를 고려하여 멀티 바이트 문자 표현을 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열에 저장하고 필요에 따라 &lt;code&gt;*ps&lt;/code&gt; 를 업데이트 합니다. 이 함수는 최대 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16a04e8a10e56b364fb1a793bc4d4d83c9dcfc50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit wide character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아니라, 대부분의 검사 &lt;code&gt;n&lt;/code&gt; 바이트가 가리키는로 시작, 멀티 바이트 문자열의 바이트 &lt;code&gt;s&lt;/code&gt; 어떤 변화 시퀀스를 포함하여 다음 멀티 바이트 문자 (완료하는 데 필요한 바이트 수를 결정하고, 고려 현재 멀티 바이트 변환 상태 &lt;code&gt;*ps&lt;/code&gt; ). 함수가 &lt;code&gt;s&lt;/code&gt; 의 다음 멀티 바이트 문자 가 완전하고 유효한 것으로 판별 하면 해당 16 비트 와이드 문자로 변환하여 &lt;code&gt;*pc16&lt;/code&gt; 에 저장합니다 ( &lt;code&gt;pc16&lt;/code&gt; 이 널이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="b0aea06044e65d8d79268c25c358b2052ee0b773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit wide character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아니라, 대부분의 검사 &lt;code&gt;n&lt;/code&gt; 바이트가 가리키는로 시작, 멀티 바이트 문자열의 바이트 &lt;code&gt;s&lt;/code&gt; 어떤 변화 시퀀스를 포함하여 다음 멀티 바이트 문자 (완료하는 데 필요한 바이트 수를 결정하고, 고려 현재 멀티 바이트 변환 상태 &lt;code&gt;*ps&lt;/code&gt; ). 함수가 &lt;code&gt;s&lt;/code&gt; 의 다음 멀티 바이트 문자 가 완전하고 유효하다고 판별하면 해당 문자를 해당 32 비트 와이드 문자로 변환하여 &lt;code&gt;*pc32&lt;/code&gt; 에 저장합니다 ( &lt;code&gt;pc32&lt;/code&gt; 가 널이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="00b1537658058f473db5bc680537ac6616352ddf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아니라, 대부분의 검사 &lt;code&gt;n&lt;/code&gt; 바이트가 가리키는로 시작, 멀티 바이트 문자열의 바이트 &lt;code&gt;s&lt;/code&gt; 어떤 변화 시퀀스를 포함하여 다음 멀티 바이트 문자 (완료하는 데 필요한 바이트 수를 결정하고, 고려 현재 멀티 바이트 변환 상태 &lt;code&gt;*ps&lt;/code&gt; ). 함수가 &lt;code&gt;s&lt;/code&gt; 의 다음 멀티 바이트 문자 가 완전하고 유효한 것으로 판별 하면 해당 와이드 문자로 변환하여 &lt;code&gt;*pwc&lt;/code&gt; 에 저장합니다 ( &lt;code&gt;pwc&lt;/code&gt; 가 널이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아닌, 다중 바이트 문자에 포함 또는 바이트 수 반환 &lt;code&gt;-1&lt;/code&gt; 첫 번째 바이트가 가리키는 경우 &lt;code&gt;s&lt;/code&gt; 유효한 멀티 바이트 문자 또는 형성하지 않는 &lt;code&gt;​0​&lt;/code&gt; 경우 &lt;code&gt;s&lt;/code&gt; 널 뜯 가리키는된다 &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 널 포인터가 아닌 경우 , 함수는 &lt;code&gt;c32&lt;/code&gt; 의 멀티 바이트 문자 표현을 저장하는 데 필요한 바이트 수 (모든 시프트 시퀀스 포함 및 현재 멀티 바이트 변환 상태 &lt;code&gt;*ps&lt;/code&gt; 고려 )를 결정하고 멀티 바이트 문자 표현을 &lt;code&gt;s&lt;/code&gt; 로 첫 번째 요소를 가리키는 문자 배열로 , 필요에 따라 &lt;code&gt;*ps&lt;/code&gt; 가 업데이트 됩니다. 이 함수는 최대 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2906f9cd10055ce52ea5a2e8f571a7dfc437ffba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_constraint_handler_s&lt;/code&gt; is never called, the default handler is implementation-defined: it may be &lt;code&gt;abort_handler_s&lt;/code&gt;, &lt;code&gt;ignore_handler_s&lt;/code&gt;, or some other implementation-defined handler.</source>
          <target state="translated">&lt;code&gt;set_constraint_handler_s&lt;/code&gt; 를 호출하지 않으면 기본 핸들러는 구현 정의됩니다. &lt;code&gt;abort_handler_s&lt;/code&gt; , &lt;code&gt;ignore_handler_s&lt;/code&gt; 또는 기타 구현 정의 핸들러 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97df7a8676e7983f9c071569882f22876fa4078d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_constraint_handler_s&lt;/code&gt; is never called, the default handler is implementation-defined: it may be &lt;code&gt;abort_handler_s&lt;/code&gt;, &lt;code&gt;ignore_handler_s&lt;/code&gt;, or some other implementation-defined handler.  As with all bounds-checked functions, &lt;code&gt;set_constraint_handler_s&lt;/code&gt; and &lt;code&gt;constraint_handler_t&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_constraint_handler_s&lt;/code&gt; 를 호출하지 않으면 기본 핸들러는 구현 정의됩니다. &lt;code&gt;abort_handler_s&lt;/code&gt; , &lt;code&gt;ignore_handler_s&lt;/code&gt; 또는 기타 구현 정의 핸들러 일 수 있습니다. 모든 경계 검사 함수와 &lt;code&gt;set_constraint_handler_s&lt;/code&gt; 및 &lt;code&gt;constraint_handler_t&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;setjmp&lt;/code&gt; 는이 다른 상황에서 나타납니다, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 제로인, 행동 정의가 구현 (NULL 포인터가 리턴되거나, 일부 비 - 널 포인터 액세스 저장하는 데 사용되지 않을 수 복귀 될 수있다).</target>
        </trans-unit>
        <trans-unit id="1fe40c255f79e2b4f905649c83c54e72b4fe88db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 제로, 행동은 정의 구현입니다 (널 포인터가 반환 될 수 있습니다, 또는 null이 아닌 포인터 액세스 저장에 사용되지 않을 수 있지만, 전달되어야한다는 반환 될 수 있습니다 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 나 &lt;code&gt;count&lt;/code&gt; 제로, &lt;code&gt;fread&lt;/code&gt; 0을 반환하고 수행하는 다른 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 나 &lt;code&gt;count&lt;/code&gt; 제로, &lt;code&gt;fwrite&lt;/code&gt; 0을 반환하고 수행하는 다른 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a9e1e400de47a1ed0b5cd2d6e227768319577ed9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; overlap, the behavior is undefined</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dst&lt;/code&gt; 중복, 행동은 정의되지 않는다</target>
        </trans-unit>
        <trans-unit id="d273f0263e60be8e604763a8afeb86df4bc79e3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; overlap, the behavior is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dst&lt;/code&gt; 중복, 동작은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="translated">경우 &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 통화가 처음 호출로 처리됩니다 &lt;code&gt;strtok&lt;/code&gt; 를 이 특정 문자열. 이 함수는 첫 번째 문자를 검색합니다</target>
        </trans-unit>
        <trans-unit id="452491e0b2ce1dbe11298bd37bb75407d3d3ddf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="translated">경우 &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 통화가 처음 호출로 처리됩니다 &lt;code&gt;wcstok&lt;/code&gt; 이 특정 넓은 문자열. 이 함수는 첫 번째 넓은 문자 인</target>
        </trans-unit>
        <trans-unit id="95b4b4bb5cc3b17be9977eef6a95107d1dfe2f33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent call to &lt;code&gt;wcstok&lt;/code&gt;: the function continues from where it left in the previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 호출은 호출에 대한 후속으로 처리되는 &lt;code&gt;wcstok&lt;/code&gt; : 함수가 동일한 함께 이전 호출에서 부분부터 계속 &lt;code&gt;*ptr&lt;/code&gt; . 동작은 마지막으로 감지 된 토큰 다음에 나오는 넓은 문자에 대한 포인터가 &lt;code&gt;str&lt;/code&gt; 로 전달되는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 호출이하는 후속 호출로 처리됩니다 &lt;code&gt;strtok&lt;/code&gt; 를 : 함수는 이전 호출에 남아있는 곳에서 계속됩니다. 동작은 이전에 저장된 포인터가 &lt;code&gt;str&lt;/code&gt; 로 전달되는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="translated">경우 &lt;code&gt;stream&lt;/code&gt; 널 포인터, 열려있는 모든 출력 스트림은 사람 라이브러리 패키지 내에서 조작하거나 프로그램에, 그렇지 않으면 직접 액세스 할 수 없습니다 포함, 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="eaa4ac73f07ef7f30a93d67313ff9cb94c76ac34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tss_delete&lt;/code&gt; is called while another thread is executing destructors for &lt;code&gt;tss_id&lt;/code&gt;, it's unspecified whether this changes the number of invocations to the associated destructor.</source>
          <target state="translated">경우 &lt;code&gt;tss_delete&lt;/code&gt; 가 다른 스레드가 소멸자를 실행하는 동안이라고 &lt;code&gt;tss_id&lt;/code&gt; , 이것이 관련 소멸자에 대한 호출의 수를 변경할지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="399122524172ec8fa3e995c00fbab797727aa863" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tss_delete&lt;/code&gt; is called while the calling thread is executing destructors, then the destructor associated with &lt;code&gt;tss_id&lt;/code&gt; will not be executed again on this thread.</source>
          <target state="translated">경우 &lt;code&gt;tss_delete&lt;/code&gt; 이 호출 스레드가 소멸자를 실행하는 동안라고하며, 다음과 관련된 소멸자 &lt;code&gt;tss_id&lt;/code&gt; 는 이 스레드에서 다시 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ungetc&lt;/code&gt; 가 더 개재 판독이나 재배치없이 여러 번 호출 때문에 실패 할 수있다 (즉, 하나의 크기의 푸시 백 버퍼가 보장되지만, 어떤 큰 버퍼는 구현 정의 됨). 여러 개의 성공적인 &lt;code&gt;ungetc&lt;/code&gt; 가 수행 된 경우 읽기 조작은 &lt;code&gt;ungetc&lt;/code&gt; 의 역순으로 푸시 백 된 문자를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ungetwc&lt;/code&gt; 가 더 개재 판독이나 재배치없이 여러 번 호출 때문에 실패 할 수있다 (즉, 하나의 크기의 푸시 백 버퍼가 보장되지만, 어떤 큰 버퍼는 구현 정의 됨). 여러 개의 성공적인 &lt;code&gt;ungetwc&lt;/code&gt; 가 수행 된 경우 읽기 조작은 &lt;code&gt;ungetwc&lt;/code&gt; 와 역순으로 푸시 백 된 와이드 문자를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;va_arg&lt;/code&gt; 를가 에서 더 이상 인수가없는 경우라고 &lt;code&gt;ap&lt;/code&gt; , 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="translated">경우 &lt;code&gt;wc&lt;/code&gt; 널 문자, 널 바이트에 기록 &lt;code&gt;s&lt;/code&gt; 초기 변화의 상태를 복원하는 데 필요한 모든 시프트 시퀀스 앞에.</target>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 모두 제로인 도메인 오류</target>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 모두 제로인 범위 오차 중 발생하지</target>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">만약 &lt;code&gt;x&lt;/code&gt; IS &amp;plusmn; &amp;infin;와 &lt;code&gt;y&lt;/code&gt; NaN이는 NaN이 반환되지 않고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다</target>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; &amp;plusmn; 0이고 &lt;code&gt;y&lt;/code&gt; 0이 반환되고, &amp;plusmn; 0이 아닌</target>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 음수, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 양의, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된과 음수, &lt;code&gt;-0&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된 긍정적이고, &lt;code&gt;+0&lt;/code&gt; 은 리턴</target>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된과 음수, &lt;code&gt;-&amp;pi;&lt;/code&gt; 는 리턴</target>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된 긍정적이고, &lt;code&gt;+&amp;pi;&lt;/code&gt; 가 반환</target>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 의 기호 NaN의 다음 NaN이 인 &lt;code&gt;y&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; &amp;plusmn; &amp;infin;이고 &lt;code&gt;x&lt;/code&gt; IS 유한, &lt;code&gt;x&lt;/code&gt; 는 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; &amp;plusmn; 0이고, &lt;code&gt;x&lt;/code&gt; NaN이는 NaN이 반환되지 않고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승</target>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 것입니다 구현 산술 연산에서 지속적으로 서명 제로를 지원하는 경우 -0, 결과는 부정적이다.</target>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; IS &lt;code&gt;+&amp;infin;&lt;/code&gt; 는 , &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; IS &lt;code&gt;-&amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 유한이다 &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 네거티브 또는 &lt;code&gt;-0&lt;/code&gt; , &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 과 &lt;code&gt;x&lt;/code&gt; 가 양수 또는 &lt;code&gt;+0&lt;/code&gt; , &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 제로이지만, 도메인 오류가 발생하지 않습니다, 0을 반환한다.</target>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 제로, 극 오류가 발생하지 않습니다</target>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 제로에 저장된 값 &lt;code&gt;*quo&lt;/code&gt; 지정된다.</target>
        </trans-unit>
        <trans-unit id="625acef687f1e557bbb80eaf5f5e753fb2ddb33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; 결과이다 &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e776bd162170c11d73af44ef8772342340ecd190" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; , 결과는 &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (허수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="9d3e426e20516e7376a050aee0403fe0d2b10ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/2-0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; , 결과는 &lt;code&gt;&amp;pi;/2-0i&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="0f825bdeaf14c7f605beb396872b9bf8796ebfd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; 결과는 &lt;code&gt;+0+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6b60f1baa934eced059da43d7d291e2febe8bd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; 결과는 &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59a945b0d7d5f0cbeadecb2c1a035dcb5ca27324" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt;, the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;&amp;plusmn;0+0i&lt;/code&gt; , 그 결과는 &lt;code&gt;1+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="999d915d02ed97295faafb81922e3c2b06d67050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/2+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt; , 결과는 &lt;code&gt;&amp;pi;/2+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c56b753fbf612891e276ecb3035b809c59bf33a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;pi;/4-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; 결과가 &lt;code&gt;&amp;pi;/4-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deb39fe3ef692828d5403bc4bf6425bc5dff8537" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; 결과는 &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (실수 부분의 부호 미지정)과 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승</target>
        </trans-unit>
        <trans-unit id="1cd5723428b77280491731f17b9a43dcf568e7ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; , 결과가 &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 이 상승된다 (실수 부분의 부호가 지정되어 있지 않은)</target>
        </trans-unit>
        <trans-unit id="af6cc33ffa514f0fb416ba084c782fa9d65fe603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+&amp;pi;i/4&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; 결과는 &lt;code&gt;+&amp;infin;+&amp;pi;i/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdd17d4f5bc34ca9a9f286bf72b81e05e7ec8b82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+i&amp;pi;/4&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; 결과는 &lt;code&gt;+&amp;infin;+i&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58b7336602437e7b3e1e2fd464b50015fba38ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; 결과는 &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fb5e54ed45d0a2da9d34fcf5eebc061ed69ef3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; 결과는 &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (허수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="bbc9947aa4794f3a678fa9974f0b8face529b478" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+0i&lt;/code&gt; 결과가 &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57d2b3b7c507184bec2b467227a5ef3e66fb09dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt; 결과이다 &lt;code&gt;+&amp;infin;+NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="074653f1bcfd78e2c6b8261d6288ce30b3f409ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; 결과는 &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (실수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="36a15e9914952a3e127c1857dfb1656f43e91982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; 결과이다 &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b8208a3b53853e24adab139e12b16bb55e09c49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;+0+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; 결과는 &lt;code&gt;+0+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7d8ce12350273a97cbf0883260795a1b23dea52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt; 결과는 &lt;code&gt;1&amp;plusmn;0i&lt;/code&gt; (허수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="d4e8cef24833eac8da6eb2c3e75a7fe324ade08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (모든 유한 비제위한 Y)는, 결과는 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bdf7c1f65251420ffa8f16429794ca31be5b14e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (임의의 제로가 아닌 유한 Y의 경우), 결과가 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7910e66fb37842a583e14d09b105ade30be68803" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (어떤 유한 한 양의 Y의 경우), 결과가 &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6768e1ec6df6a95e6a4c726fc892acad121e7985" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (어떤 한정된 양의 Y의 경우), 결과는 &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f62e4cdc201996da16b1502058a6c1e9023d551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (어떤 유한 한 양의 Y의 경우), 결과는 &lt;code&gt;1+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ce2d0c3f9d0861e47b4abf10a45e3583833a5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (한정된 양의 Y에 대한)는, 결과가 &lt;code&gt;+&amp;infin;+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="832b62b259002df797cd0148545bc70005eba32b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; (양의 한정을위한 Y)의 결과이다 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20a620da3de056d824da46c1301b06a1653505bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+&amp;infin;+yi&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i)&lt;/code&gt; for finite positive y</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;+yi&lt;/code&gt; 결과이다 &lt;code&gt;+&amp;infin;+0i)&lt;/code&gt; 한정된 양의 Y에 대한</target>
        </trans-unit>
        <trans-unit id="796b4ff0d96367997b18b6f7414bc04e2ed54548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; , 결과가 &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt; (실수 부분의 부호 미지정)과 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승</target>
        </trans-unit>
        <trans-unit id="5309daa1a2a52ddd69bab7388c31c22811693301" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; , 결과는 &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (허수 부분의 부호가 지정되어 있지 않은)과 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="5377d46789b608eb83cab1fd971c8e1fdc08ef07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;+0+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+0+0i&lt;/code&gt; 결과는 &lt;code&gt;+0+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9921811f368934b33ab588a74bfc469573b9542" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;-&amp;infin;+0i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+0+0i&lt;/code&gt; 결과가된다 &lt;code&gt;-&amp;infin;+0i&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="30d6b4e4a6916b3f5bf139a7a8056a1e67f1365b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+0i&lt;/code&gt;, the result is &lt;code&gt;1+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+0+0i&lt;/code&gt; , 그 결과는 &lt;code&gt;1+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a93099e5fafc600b431649dde73f501ee2c62f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;+0+NaNi&lt;/code&gt; 결과는 &lt;code&gt;&amp;plusmn;0+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="babb8188b54877f4defa5fdcad7f2801cb860adf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;+0+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;+0+NaNi&lt;/code&gt; 결과는 &lt;code&gt;+0+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05f532d9487bdac748e6ace19ea8e53c7305f1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+0+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+0+NaNi&lt;/code&gt; , 결과는 &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (허수 부분의 부호가 지정되어 있지 않은)</target>
        </trans-unit>
        <trans-unit id="cf4db554760a0604e00615063e66764d7bf313aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+1+0i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+0i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;+1+0i&lt;/code&gt; 결과이다 &lt;code&gt;+&amp;infin;+0i&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="38d56aaf8eaff18904a766fcf455f56b6ddac179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;+&amp;infin;+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;+x+&amp;infin;i&lt;/code&gt; (어떤 한정된 x에 대한) 결과가 &lt;code&gt;+&amp;infin;+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89bbfd524374559a9938d77e51791857f87d786c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;+x+NaNi&lt;/code&gt; (for non-zero finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;+x+NaNi&lt;/code&gt; 결과는 (비 - 제로의 유한 X 용) &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="f1aede927aad834a1785eca9ec8164efbce2fd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; 결과는 &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (부호 미지정이다)</target>
        </trans-unit>
        <trans-unit id="11925823f1f8e4ae67f97e30d8d10beacc784a6a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+3&amp;pi;i/4&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; 결과이다 &lt;code&gt;+&amp;infin;+3&amp;pi;i/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5629437abcfb214e3e73d687e87c0bbfd484294d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+3i&amp;pi;/4&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; 결과이다 &lt;code&gt;+&amp;infin;+3i&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b23078b80b2d0a20adc1047ee85085ec345a4c08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;3&amp;pi;/4-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+&amp;infin;i&lt;/code&gt; 결과는 &lt;code&gt;3&amp;pi;/4-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0916960961bb0b2dad526b5d8175c9cde4d8b004" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt; 결과는 &lt;code&gt;&amp;plusmn;0&amp;plusmn;0i&lt;/code&gt; (부호 미지정이다)</target>
        </trans-unit>
        <trans-unit id="d23cff457c96232415905ac78b0b18a88e49ee49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+NaNi&lt;/code&gt; , 결과는 &lt;code&gt;NaN&amp;plusmn;&amp;infin;i&lt;/code&gt; (허수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="588e8fab7757a98088b599ad32219a88f43e15b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;+&amp;infin;+&amp;pi;i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (어떤 유한 한 양의 Y에 대한)는, 결과가 &lt;code&gt;+&amp;infin;+&amp;pi;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed0586d452079c8db876de069dd932b883bdbc41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (어떤 유한 한 Y 용)의 결과이다 &lt;code&gt;+0cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97bb419bd6dda05c2487d6ebabe98e61e56454e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;&amp;pi;-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (양의 한정이 Y에 대한) 결과는 &lt;code&gt;&amp;pi;-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73be861cb7403dc831de7a0eb3583bbe00513c7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;+i&amp;pi;&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (양의 한정이 Y에 대한) 결과가 &lt;code&gt;+&amp;infin;+i&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e9a39eb36afdfaf9c77e1b226686fcfff50f0ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+0-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; (양의 한정을위한 Y)는, 그 결과는 &lt;code&gt;+0-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="851d57b9d8335c6dfc8e20c92f1e808393d81024" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-&amp;infin;+yi&lt;/code&gt;, the result is &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; for finite positive y</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;+yi&lt;/code&gt; 결과는 &lt;code&gt;+0+&amp;infin;i&lt;/code&gt; 한정된 양의 Y에 대한</target>
        </trans-unit>
        <trans-unit id="e0896ff44ed61681eeb9cda5e2db468c4dcb7345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;-0+0i&lt;/code&gt;, the result is &lt;code&gt;-&amp;infin;+&amp;pi;i&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;-0+0i&lt;/code&gt; 결과는 &lt;code&gt;-&amp;infin;+&amp;pi;i&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="da9605b8e9e71096e7d152ca980d6f5c93bba805" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;0+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;i&amp;pi;/2&lt;/code&gt;, where the sign of the imaginary part is unspecified</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;0+NaNi&lt;/code&gt; , 결과는 &lt;code&gt;NaN&amp;plusmn;i&amp;pi;/2&lt;/code&gt; 허수 부분의 부호가 지정되어 있지 않은,</target>
        </trans-unit>
        <trans-unit id="98b8e6ca75c33aacc22f25140d2d52982edd58fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , 결과는 &lt;code&gt;&amp;plusmn;&amp;infin;+NaNi&lt;/code&gt; (실수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="04e920d0768c071b159f8cf0ccb4766fc1f81e20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;&amp;plusmn;0+i&amp;pi;/2&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , 결과는 &lt;code&gt;&amp;plusmn;0+i&amp;pi;/2&lt;/code&gt; (실수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="638dd3af4879e274f2753dd13affb32f54d0c427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , 결과는 &lt;code&gt;+&amp;infin;+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="daba330e5a0bc591c3819affe8ac2668be2332bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;NaN-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+&amp;infin;i&lt;/code&gt; , 결과는 &lt;code&gt;NaN-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="93fd1cf9bded1c643f4be838021974ff52d04574" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+0i&lt;/code&gt;, the result is &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+0i&lt;/code&gt; , 결과는 &lt;code&gt;NaN&amp;plusmn;0i&lt;/code&gt; (허수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="be162870b1adbbfcdab4d44246254add068c4d3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+0i&lt;/code&gt;, the result is &lt;code&gt;NaN+0i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+0i&lt;/code&gt; , 결과는 &lt;code&gt;NaN+0i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed140ac051f22ec49ba422cfe0adb820c792ce97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+NaNi&lt;/code&gt; , 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0832a5cb369dc40bbf17d380253648fec2eafd26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+yi&lt;/code&gt; (모든 유한 비제위한 Y)는, 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="237a9a25ce4abe535bbf2f26c139e1578e0f57db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+yi&lt;/code&gt; (모든 유한 제로 Y의 경우), 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="9bd4c1293771f3563ff364c43498200c3c13cb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+yi&lt;/code&gt; (어떤 유한 Y의 경우), 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="543c12f39bc3f311b75307271197b544025035ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any finite y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+yi&lt;/code&gt; (어떤 유한 Y의 경우), 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d493aac97dda0447051a4e0d2c6f5ec9e2060421" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+yi&lt;/code&gt; (0이 아닌 Y에 대한)는, 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="fc20f772fb2e9b1f8a5f485718315fa6f70c07b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+yi&lt;/code&gt; (제로가 아닌 Y에 대한)는, 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="7d3bec2c00936b0677791908a2e4bac6c5da3a16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;NaN+yi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;NaN+yi&lt;/code&gt; , 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="a37c90aa215aa60d649f207f9c5229f362419dc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (모든 유한 비제 X의 경우), 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 상승</target>
        </trans-unit>
        <trans-unit id="1bb3d1a016313313a6b48c627b3a72353646af38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (모든 유한 한 양의 x에 대한) 결과가 &lt;code&gt;+0+i&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b73c524a1f7cdc97af1ed115b7f7b4545582b048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;&amp;pi;/2-&amp;infin;i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (어떤 한정된 X의 경우), 결과는 &lt;code&gt;&amp;pi;/2-&amp;infin;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="387a32ebb5732e31a734be8cc4d5825b907d56f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;+&amp;infin;+&amp;pi;i/2&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (어떤 한정된 x에 대한) 결과가 &lt;code&gt;+&amp;infin;+&amp;pi;i/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e21f01f7c3c4ba8563c2060a845c0a391233d504" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; 결과이다 (어떤 한정된 X 용) &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승된다.</target>
        </trans-unit>
        <trans-unit id="656ce31f57bb568a13e9ac94e493eeccd6c0fa10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;+&amp;infin;+&amp;pi;/2&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (한정된 양의 x에 대한) 결과가 &lt;code&gt;+&amp;infin;+&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b18b6f6cea921f44fce092288d49e81492a7d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; 결과이다 (양의 x에 대한 유한) &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 상승</target>
        </trans-unit>
        <trans-unit id="460b063ec1b13ac13ca6654ed1024e7cd0950fc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;ctanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; (모든 대 &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;ctanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 한정된 X)는, 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="63489bf316b1d8539e0fca94a25ca124b0a8a98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+&amp;infin;i&lt;/code&gt;, the result is &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; even if x is NaN</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+&amp;infin;i&lt;/code&gt; 결과가 &lt;code&gt;+&amp;infin;+&amp;infin;i&lt;/code&gt; x는 NaN이 있더라도</target>
        </trans-unit>
        <trans-unit id="f69761b498632a762c370417fd0122db567041cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaN&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;ctanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaN&lt;/code&gt; (임의 대해 &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;ctanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; 의 유한 X)의 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="54c6ea5aaa627daf3c1ae805242b58ce8d207848" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaNi&lt;/code&gt; (모든 유한 비제 X의 경우), 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="b93caab68fa73ccda5d1b17498c4229840dbee54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaNi&lt;/code&gt; (위한 임의의 제로가 아닌 유한 x)의 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="2f565c2557a5ee30de01f8e30a13b63363ded1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaNi&lt;/code&gt; (어떤 한정된 X의 경우), 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="5dfecd44688d670800ff223095156659b894fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaNi&lt;/code&gt; (어떤 한정된 X의 경우), 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="73d6ef277884ef031696f2e39fb8437e61e455ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaNi&lt;/code&gt; (대한 제로의 유한 X)를, 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="06474f38558e726376291b2fee6434dae49fb720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaNi&lt;/code&gt; (한정된 양의 x에 대한)은 상기 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="f5b921b4a4b89a2b78c2d734ce1603b4cd5809c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;x+NaNi&lt;/code&gt;, the result is &lt;code&gt;NaN+NaNi&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;x+NaNi&lt;/code&gt; , 결과는 &lt;code&gt;NaN+NaNi&lt;/code&gt; (않는 X는 &amp;plusmn; &amp;infin;)와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="494c7fa954556372ffde67c8fcd8b5c440f15d85" translate="yes" xml:space="preserve">
          <source>If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:</source>
          <target state="translated">A가 B보다 먼저 시퀀싱되지 않고 B가 A보다 먼저 시퀀싱되지 않으면 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e909e2416c8dd4d8004abde79eee57ee706ae1a0" translate="yes" xml:space="preserve">
          <source>If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins.</source>
          <target state="translated">A가 B보다 먼저 시퀀싱되지 않고 B가 A보다 먼저 시퀀싱되면 A의 평가가 시작되기 전에 B의 평가가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="5b3dcdb9c0e0e848fd114ab741ff0ec9dafbada5" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; uses &lt;code&gt;typedef&lt;/code&gt; as storage-class specifier, every declarator in it defines an identifier as an alias to the type specified. Since only one storage-class specifier is permitted in a declaration, typedef declaration cannot be &lt;a href=&quot;storage_duration&quot;&gt;static or extern&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 이 &lt;code&gt;typedef&lt;/code&gt; 를 스토리지 클래스 지정자로 사용 하는 경우 , 모든 선언자는 지정된 유형의 별명으로 식별자를 정의합니다. 선언에는 스토리지 클래스 지정자가 하나만 허용되므로 typedef 선언은 &lt;a href=&quot;storage_duration&quot;&gt;정적이거나 extern 일&lt;/a&gt; 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="28f44931b69cf3f9c6318eccefe0feba2cd026ec" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;i&gt;sequence point&lt;/i&gt;&lt;/a&gt; is present between the subexpressions E1 and E2, then both value computation and side effects of E1 are</source>
          <target state="translated">경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot;&gt;&lt;i&gt;시퀀스 지점&lt;/i&gt;&lt;/a&gt; 하위 표현식 E1과 E2 사이에 존재하고 E1의 값을 계산하고 양면 효과가있다</target>
        </trans-unit>
        <trans-unit id="54d68e95d2eaee0fc5d16e87451670896b8f13a1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;va_arg&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;va_end&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;va_list&lt;/code&gt; 인스턴스가 생성되고, 다른 함수로 전달하고, 사용을 통해 &lt;code&gt;va_arg&lt;/code&gt; 를 다음 호출 기능의 후속 사용이 호출에 의해 선행되어야한다는 기능에 &lt;code&gt;va_end&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="41728f960e83107e165631fae30f77c98f34499a" translate="yes" xml:space="preserve">
          <source>If a VLA or another identifier with variably-modified type has a &lt;code&gt;case:&lt;/code&gt; or a &lt;code&gt;default:&lt;/code&gt; label within its scope, the entire switch statement must be in its scope (in other words, a VLA must be declared either before the entire switch or after the last label):</source>
          <target state="translated">VLA 또는 가변적으로 수정 된 유형의 다른 식별자에 해당 범위 내에 &lt;code&gt;case:&lt;/code&gt; 또는 &lt;code&gt;default:&lt;/code&gt; 레이블 이있는 경우 전체 스위치 명령문은 해당 범위 내에 있어야합니다 (즉, VLA는 전체 스위치 앞이나 뒤에 선언되어야합니다) 마지막 라벨) :</target>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="translated">변환 스펙이 유효하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5790fe10d0a55b84da0323b97076fc148d33b344" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.  (in particular, &lt;code&gt;&lt;a href=&quot;../thread/mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">데이터 레이스가 발생하면 프로그램의 동작은 정의되지 않습니다. (특히, &lt;code&gt;&lt;a href=&quot;../thread/mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; 은입니다.</target>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="translated">도메인 오류가 발생하면 구현 정의 값 (지원되는 경우 NaN)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="translated">도메인 오류가 발생하면 구현 정의 값이 반환됩니다 (지원되는 경우 NaN).</target>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="translated">도메인 오류가 발생하면 구현 정의 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2882768bd45c3b2d9f2505ac60769f87322f2c3b" translate="yes" xml:space="preserve">
          <source>If a function declaration appears outside of any function, the identifier it introduces has &lt;a href=&quot;scope&quot;&gt;file scope&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, unless &lt;code&gt;static&lt;/code&gt; is used or an earlier static declaration is visible. If the declaration occurs inside another function, the identifier has block scope (and also either internal or external linkage).</source>
          <target state="translated">함수 선언이 함수 외부에 나타나는 경우 , &lt;code&gt;static&lt;/code&gt; 아닌 경우, 함수가 도입 한 식별자에 &lt;a href=&quot;scope&quot;&gt;파일 범위&lt;/a&gt; 와 &lt;a href=&quot;storage_duration&quot;&gt;외부 링크가 있습니다&lt;/a&gt; . 이 사용되거나 이전 정적 선언이 표시 가 있습니다. 선언이 다른 함수 내에서 발생하면 식별자에는 블록 범위 (및 내부 또는 외부 링크)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f3d7d32f7511db7ae1b5863171bfef6106dcf6d" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;inline&lt;/code&gt; in some translation units, it does not need to be declared inline everywhere: at most one translation unit may also provide a regular, non-inline non-static function, or a function declared &lt;code&gt;extern inline&lt;/code&gt;. This one translation unit is said to provide the</source>
          <target state="translated">함수가 선언 된 경우 &lt;code&gt;inline&lt;/code&gt; 최대 하나 개의 번역 단위에서 또한 정기적, 비 인라인 비 정적 기능을 제공하거나 함수 선언 : 일부 번역 단위로, 그것은 인라인 모든 곳에서 선언 할 필요가 없습니다 &lt;code&gt;extern inline&lt;/code&gt; . 이 하나의 번역 단위는</target>
        </trans-unit>
        <trans-unit id="55e8d6db1875ea64570ead516bceb34179f77c5b" translate="yes" xml:space="preserve">
          <source>If a non-static function is declared &lt;code&gt;inline&lt;/code&gt;, then it must be defined in the same translation unit. The inline definition that does not use &lt;code&gt;extern&lt;/code&gt; is not externally visible and does not prevent other translation units from defining the same function. This makes the &lt;code&gt;inline&lt;/code&gt; keyword an alternative to &lt;code&gt;static&lt;/code&gt; for defining functions inside header files, which may be included in multiple translation units of the same program.</source>
          <target state="translated">비 정적 함수가 &lt;code&gt;inline&lt;/code&gt; 으로 선언 되면 동일한 변환 단위로 정의해야합니다. &lt;code&gt;extern&lt;/code&gt; 을 사용하지 않는 인라인 정의 는 외부에 표시되지 않으며 다른 변환 단위가 동일한 기능을 정의하지 못하게합니다. 이것은 &lt;code&gt;inline&lt;/code&gt; 키워드를 헤더 파일 내부의 함수를 정의 하기 위한 &lt;code&gt;static&lt;/code&gt; 의 대안으로 만듭니다. 이는 동일한 프로그램의 여러 변환 단위에 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2baf22c2e3d7ee45e7b76a25868e011a385fd4" translate="yes" xml:space="preserve">
          <source>If a pointer to object is converted to a pointer to void and back, its value compares equal to the original pointer.</source>
          <target state="translated">객체에 대한 포인터가 void 및 back에 대한 포인터로 변환되면 해당 값은 원래 포인터와 같습니다.</target>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다 (올바른 부호 포함).</target>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;+HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;-HUGE_VAL&lt;/code&gt; , &lt;code&gt;-HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;-HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">오버플로로 인한 폴 오류 또는 범위 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="translated">오버플로 인하여 범위 에러가 발생하는 경우, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (와 같은 부호를 반환 &lt;code&gt;from&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">오버플로로 인한 범위 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">오버플로로 인한 범위 오류가 발생하면 &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;+HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="translated">언더 플로로 인한 범위 오류가 발생하면 올림 후 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="translated">언더 플로로 인한 범위 오류가 발생하면 올림 후 올바른 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="translated">언더 플로로 인해 범위 오류가 발생하면 올림 후 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="translated">언더 플로로 인해 범위 오류가 발생하는 경우, 비정규가 지원되면 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="translated">언더 플로로 인해 범위 오류가 발생하면 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce932a742aa1c52c8241cbf55e0ac1bce6e8b12" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt;) for the stream is set.</source>
          <target state="translated">읽기 또는 쓰기 오류가 발생 하면 스트림 의 오류 표시기 ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; )가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="324e8a46a69b9f9f1395e3fb9228dc24af457e88" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="translated">읽기 또는 쓰기 오류가 발생하면 스트림의 오류 표시기 ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; )가 설정되고 파일 위치에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f0552ab1ad9171053eb62c701cf4a288607a3e9" translate="yes" xml:space="preserve">
          <source>If a struct defines at least one named member, it is allowed to additionally declare its last member with incomplete array type. When an element of the flexible array member is accessed (in an expression that uses operator &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;-&amp;gt;&lt;/code&gt; with the flexible array member's name as the right-hand-side operand), then the struct behaves as if the array member had the longest size fitting in the memory allocated for this object. If no additional storage was allocated, it behaves as if an array with 1 element, except that the behavior is undefined if that element is accessed or a pointer one past that element is produced. Initialization, &lt;code&gt;sizeof&lt;/code&gt;, and the assignment operator ignore the flexible array member. Structures with flexible array members (or unions who have a recursive-possibly structure member with flexible array member) cannot appear as array elements or as members of other structures.</source>
          <target state="translated">구조체가 하나 이상의 명명 된 멤버를 정의하는 경우 불완전한 배열 유형으로 마지막 멤버를 추가로 선언 할 수 있습니다. 유연한 배열 멤버의 요소에 액세스 할 때 (연산자 배열 멤버의 이름을 오른쪽 피연산자로 operator &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;&lt;/code&gt; 를 사용하는 표현식에서 ), 구조체는 배열 멤버가 가장 긴 크기 인 것처럼 동작합니다. 이 객체에 할당 된 메모리에 적합합니다. 추가 스토리지가 할당되지 않은 경우 해당 요소에 액세스하거나 해당 요소 이후의 포인터가 생성되는 경우 동작이 정의되지 않는 한 1 개의 요소가있는 배열처럼 동작합니다. 초기화, &lt;code&gt;sizeof&lt;/code&gt; 연산자대입 연산자는 가변 배열 멤버를 무시합니다. 유연한 배열 멤버가있는 구조 (또는 유연한 배열 멤버가있는 재귀 적 구조 멤버가있는 공용체)는 배열 요소 또는 다른 구조의 멤버로 표시 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eed39e59199bcc4446f53b7637371743e6a55284" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence, but string concatenation can be used as a workaround:</source>
          <target state="translated">유효한 16 진 숫자가 문자열 리터럴에서 16 진 이스케이프 뒤에 오는 경우, 유효하지 않은 이스케이프 시퀀스로 컴파일되지 않지만 문자열 연결을 임시 해결책으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="translated">너비 지정자를 사용하면 정확히 일치</target>
        </trans-unit>
        <trans-unit id="5226fd58b879032cf6f8d13e08547a5ed7497ff7" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type with &lt;a href=&quot;../language/object#Alignment&quot;&gt;fundamental alignment&lt;/a&gt;.</source>
          <target state="translated">할당이 성공하면 할당 된 메모리 블록에서 &lt;a href=&quot;../language/object#Alignment&quot;&gt;기본 정렬로&lt;/a&gt; 모든 객체 유형에 적합하게 정렬 된 가장 낮은 (첫 번째) 바이트에 대한 포인터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="translated">할당이 성공하면 할당 된 메모리 블록에서 객체 유형에 맞게 정렬 된 가장 낮은 (첫 번째) 바이트에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55b167df42e8335a72f97731fb365e554992c1c1" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="translated">배열이 너무 커서 ( &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; 요소 보다 크지 만 &lt;code&gt;&lt;a href=&quot;limits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; 바이트 미만 ), 두 포인터 사이의 차이가 &lt;code&gt;ptrdiff_t&lt;/code&gt; 로 표현되지 않을 수 있는 경우, 그러한 두 포인터를 뺀 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9beeb85ee5a960fd0d5fcc0adf11aa6910156337" translate="yes" xml:space="preserve">
          <source>If an array type is declared with a &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;(since C99), or &lt;a href=&quot;atomic&quot;&gt;_Atomic&lt;/a&gt;(since C11) qualifier (which is possible through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not qualified, but its element type is:</source>
          <target state="translated">배열 유형이 선언된다면 &lt;a href=&quot;const&quot;&gt;CONST&lt;/a&gt; , &lt;a href=&quot;volatile&quot;&gt;휘발성&lt;/a&gt; , &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; (보낸 C99) 또는 &lt;a href=&quot;atomic&quot;&gt;_Atomic&lt;/a&gt; (의 사용을 통해 가능하다 한정자 (C11 때문에) &lt;a href=&quot;typedef&quot;&gt;타입 정의는&lt;/a&gt; ), 어레이 형이 규정되지 않지만, 그 요소 유형이다 :</target>
        </trans-unit>
        <trans-unit id="efcc6d70fe043c8b98938e05a3396705b54776f5" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the const type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not const-qualified, but its element type is. If a function type is declared with the const type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the behavior is undefined.</source>
          <target state="translated">배열 유형이 const type 한정자를 사용하여 선언 된 경우 ( &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 사용 ) 배열 유형은 const 한정되지 않지만 요소 유형입니다. const type 한정자를 사용하여 ( &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 사용 ) 함수 유형을 선언 하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55e10804f659caae0ae85fbc681a3dc12898bf81" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the restrict type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not restrict-qualified, but its element type is:</source>
          <target state="translated">배열 유형이 제한 유형 규정 자로 선언 된 경우 ( &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 사용 ) 배열 유형은 제한되지 않지만 요소 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05be40a7233aa73625c4b48d04ab3ca25d2b7f9f" translate="yes" xml:space="preserve">
          <source>If an array type is declared with the volatile type qualifier (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the array type is not volatile-qualified, but its element type is. If a function type is declared with the volatile type qualified (through the use of &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;), the behavior is undefined.</source>
          <target state="translated">배열 유형이 volatile type 한정자를 사용하여 선언 된 경우 ( &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 사용 ) 배열 유형은 휘발성이 아닌 요소 유형입니다. 함수 유형이 volatile 유형으로 규정 된 경우 ( &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 사용 ) 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="translated">스레드 A의 원자 저장소에 &lt;code&gt;memory_order_release&lt;/code&gt; 태그가 지정 되고 동일한 변수에서 스레드 B의 원자로드에 &lt;code&gt;memory_order_acquire&lt;/code&gt; 태그가 지정 되면 모든 메모리 쓰기 (비 원자 및 완화 원자)</target>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="translated">스레드 A의 원자 저장소에 &lt;code&gt;memory_order_release&lt;/code&gt; 태그가 지정 되고 동일한 변수에서 스레드 B의 원자로드에 &lt;code&gt;memory_order_consume&lt;/code&gt; 태그가 지정된 경우 , 모든 메모리 쓰기 (비 원자 및 완화 원자)</target>
        </trans-unit>
        <trans-unit id="2795e8b6307a4d1e54bc6184732434401b4ea962" translate="yes" xml:space="preserve">
          <source>If an encoding error occurred, additionally sets &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">인코딩 오류가 발생하면 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;EILSEQ&lt;/code&gt; 로 추가로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="translated">오류가 발생하면 스트림에 대한 파일 위치 표시기의 결과 값이 결정되지 않습니다. 부분 요소를 읽으면 해당 값이 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc208d62518be5c688131bdd43fff494483d3612" translate="yes" xml:space="preserve">
          <source>If an expression evaluates to a value that is not representable by its type, it cannot be used as a constant expression.</source>
          <target state="translated">표현식이 해당 유형으로 표현할 수없는 값으로 평가되면 상수 표현식으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19ed04f0c056df4f3d246b0a488a18fc4f9a7010" translate="yes" xml:space="preserve">
          <source>If an identifier with external linkage is used in any expression other than a non-VLA(since C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, or &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;(since C11), there must be one and only one external definition for that identifier somewhere in the entire program.</source>
          <target state="translated">외부 연결이있는 식별자가 비 VLA (C99 이후), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; 또는 &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt; (C11 이후 ) 이외의 표현식에 사용되는 경우 전체 프로그램 어딘가에 해당 식별자에 대한 외부 정의가 하나만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="61c715d29fbc4afeba0153113b895f922bbc534a" translate="yes" xml:space="preserve">
          <source>If an identifier with internal linkage is used in any expression other than a non-VLA(since C99), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, or &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;(since C11), there must be one and only one external definition for that identifier in the translation unit.</source>
          <target state="translated">내부 연결이있는 식별자가 비 VLA (C99 이후), &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; 또는 &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt; (C11 이후 ) 이외의 다른 표현식에 사용되는 경우 변환 단위에 해당 식별자에 대한 외부 정의가 하나만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b7f9754da6fc6b81f29f5b6d3b428b27d61fc3ed" translate="yes" xml:space="preserve">
          <source>If an indeterminate value is used as an argument to any standard library call, the behavior is undefined. Otherwise, the result of any expression involving indeterminate values is an indeterminate value (e.g. &lt;code&gt;int n;&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; may not compare equal to itself and it may appear to change its value on subsequent reads).</source>
          <target state="translated">결정되지 않은 값이 표준 라이브러리 호출에 대한 인수로 사용되면 동작이 정의되지 않습니다. (예를 들어 그렇지 않으면 부정 값을 포함하는 임의의 표현의 결과는 부정 값이고 &lt;code&gt;int n;&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; 월 자체에 동등한 비교하지 그것을 후속의 판독 값을 변경 나타나는).</target>
        </trans-unit>
        <trans-unit id="2595c0e9c8f0a0375a7da8475c597d0f3be5bd12" translate="yes" xml:space="preserve">
          <source>If an initializer is not provided:</source>
          <target state="translated">이니셜 라이저가 제공되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="12e7ba75c8d971362a518ba45e96ae10c7050f8c" translate="yes" xml:space="preserve">
          <source>If an initializer is provided, see.</source>
          <target state="translated">초기화 장치가 제공되는 경우를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="737ef6d3c730778e5c94a6b40c35f5020e3cd40a" translate="yes" xml:space="preserve">
          <source>If an lvalue expression is used in any context other than &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;, or the operators listed above, non-array lvalues of any complete type undergo &lt;a href=&quot;conversion&quot;&gt;lvalue conversion&lt;/a&gt;, which models the memory load of the value of the object from its location. Similarly, array lvalues undergo &lt;a href=&quot;conversion&quot;&gt;array-to-pointer conversion&lt;/a&gt; when used in any context other than &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;_Alignof&lt;/code&gt;, address-of operator, or array initialization from a string literal.</source>
          <target state="translated">&lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt; , &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; 또는 위에 나열된 연산자 이외의 컨텍스트에서 lvalue 표현식을 사용하는 경우, 완전한 유형의 비 배열 lvalue는 &lt;a href=&quot;conversion&quot;&gt;lvalue 변환을&lt;/a&gt; 수행 하여 해당 위치에서 오브젝트 값의 메모리로드를 모델링합니다. 마찬가지로 배열 lvalue는 &lt;code&gt;sizeof&lt;/code&gt; , &lt;code&gt;_Alignof&lt;/code&gt; , address-of operator 또는 문자열 리터럴에서 배열 초기화 이외의 컨텍스트에서 사용될 경우 &lt;a href=&quot;conversion&quot;&gt;배열에서 포인터로 변환&lt;/a&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d8c9bcb6d816c1a8ecd0a37069f05536bd2ec31" translate="yes" xml:space="preserve">
          <source>If an object representation does not represent any value of the object type, it is known as</source>
          <target state="translated">객체 표현이 객체 유형의 값을 나타내지 않으면</target>
        </trans-unit>
        <trans-unit id="c820dc8c26d3db1ef814640861c6f3807e6c1ba5" translate="yes" xml:space="preserve">
          <source>If an object's alignment is made stricter (larger) than &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; using &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;, it has</source>
          <target state="translated">객체의 배치는보다 엄격한 (이상)이 이루어지면 &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt; 을 사용 &lt;a href=&quot;alignas&quot;&gt;alignas를&lt;/a&gt; , 그 보유</target>
        </trans-unit>
        <trans-unit id="acd0f2effed8427de550d8d6b990c3718b9b3c16" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is &lt;code&gt;long double&lt;/code&gt;, then the &lt;code&gt;long double&lt;/code&gt; variant is called. Otherwise, if any of the arguments for the generic parameters is &lt;code&gt;double&lt;/code&gt;, then the &lt;code&gt;double&lt;/code&gt; variant is called. Otherwise, &lt;code&gt;float&lt;/code&gt; variant is called.</source>
          <target state="translated">일반 매개 변수에 대한 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 &lt;code&gt;long double&lt;/code&gt; 변형이 호출됩니다. 그렇지 않으면, 일반 매개 변수에 대한 인수가 &lt;code&gt;double&lt;/code&gt; 인 경우 &lt;code&gt;double&lt;/code&gt; 변형이 호출됩니다. 그렇지 않으면 &lt;code&gt;float&lt;/code&gt; 변형이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="562e239709bc35b2b379032b89448978ab95efc0" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is &lt;code&gt;long double&lt;/code&gt;, then the &lt;code&gt;long double&lt;/code&gt; variant is called. Otherwise, if any of the parameters is &lt;code&gt;double&lt;/code&gt; or integer, then the &lt;code&gt;double&lt;/code&gt; variant is called. Otherwise, &lt;code&gt;float&lt;/code&gt; variant is called.</source>
          <target state="translated">일반 매개 변수에 대한 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 &lt;code&gt;long double&lt;/code&gt; 변형이 호출됩니다. 그렇지 않으면, 매개 변수 중 하나가 &lt;code&gt;double&lt;/code&gt; 또는 integer 인 경우 &lt;code&gt;double&lt;/code&gt; variant가 호출됩니다. 그렇지 않으면 &lt;code&gt;float&lt;/code&gt; 변형이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec78132e6099d16c4819b148849342ed77f805bd" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is complex, then the complex function is called, otherwise the real function is called.</source>
          <target state="translated">일반 매개 변수에 대한 인수가 복잡한 경우 복잡한 함수가 호출되고 그렇지 않으면 실제 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="79b55232ba96a3bd42fd8dd7103363973985e2a1" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is imaginary, the behavior is specified on each function reference page individually (in particular, sin, cos, tag, cosh, sinh, tanh, asin, atan, asinh, and atanh call</source>
          <target state="translated">일반 매개 변수에 대한 인수가 허구 인 경우, 각 함수 참조 페이지에서 동작이 개별적으로 지정됩니다 (특히 sin, cos, tag, cosh, sinh, tanh, asin, atan, asinh 및 atanh call</target>
        </trans-unit>
        <trans-unit id="7f56fd154648f3d8467222c29490c068976fd45a" translate="yes" xml:space="preserve">
          <source>If any of the arguments for the generic parameters is real, complex, or imaginary, then the appropriate complex function is called.</source>
          <target state="translated">일반 매개 변수에 대한 인수가 실수, 복소수 또는 허수 인 경우 적절한 복합 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9059699e445e938e899ba841bbdc2815187e8516" translate="yes" xml:space="preserve">
          <source>If any part of a declarator is a &lt;a href=&quot;array&quot;&gt;VLA array&lt;/a&gt; declarator, the entire declarator's type is known as &quot;variably-modified type&quot;. Types defined from variably-modified types are also variably modified (VM).</source>
          <target state="translated">선언자의 일부가 &lt;a href=&quot;array&quot;&gt;VLA 배열&lt;/a&gt; 선언 자인 경우 전체 선언자의 유형을 &quot;가변 식 유형&quot;이라고합니다. 가변 수정 유형에서 정의 된 유형도 가변 수정 (VM)입니다.</target>
        </trans-unit>
        <trans-unit id="41cd76f0d575b7b9cd5e0fd684bb28b73c4dd854" translate="yes" xml:space="preserve">
          <source>If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated):</source>
          <target state="translated">하위 오브젝트가 명시 적으로 두 번 초기화 된 경우 (지정자가 사용될 때 발생할 수 있음), 목록의 후반부에 나타나는 이니셜 라이저가 사용 된 것입니다 (이전 이니셜 라이저는 평가되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="translated">arg가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9d7eda972ce3fcd7bac7edeebd6987d2d5448884" translate="yes" xml:space="preserve">
          <source>If both operands have &lt;a href=&quot;arithmetic_types&quot;&gt;arithmetic types&lt;/a&gt;, then.</source>
          <target state="translated">두 피연산자에 &lt;a href=&quot;arithmetic_types&quot;&gt;산술 유형&lt;/a&gt; 이 있으면 .</target>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="translated">변환 된 값과 정밀도 둘 경우 &lt;code&gt;​0​&lt;/code&gt; 아무 문자의 변환 결과는.</target>
        </trans-unit>
        <trans-unit id="aa56eddeecaa652e74ddca2ef43579a7b00a26ad" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;div_t&lt;/code&gt;, &lt;code&gt;ldiv_t&lt;/code&gt;, &lt;code&gt;lldiv_t&lt;/code&gt;, &lt;code&gt;imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="translated">나머지 및 몫이 해당 유형의 객체 (각각 int, long, long long, imaxdiv_t)로 &lt;code&gt;imaxdiv_t&lt;/code&gt; 될 수있는 경우 다음과 같이 정의 된 &lt;code&gt;div_t&lt;/code&gt; , &lt;code&gt;ldiv_t&lt;/code&gt; , &lt;code&gt;lldiv_t&lt;/code&gt; , imaxdiv_t 유형의 객체로 둘 다를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="504c354c4217916940c16491f303887d6d786f1c" translate="yes" xml:space="preserve">
          <source>If both types are array types, the following rules are applied:</source>
          <target state="translated">두 유형이 모두 배열 유형 인 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9300681f14311ef1308fff428de5207f181878fe" translate="yes" xml:space="preserve">
          <source>If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.</source>
          <target state="translated">두 유형이 모두 매개 변수 유형 목록이있는 함수 유형 인 경우 복합 매개 변수 유형 목록의 각 매개 변수 유형은 해당 매개 변수의 복합 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0a9f1e1eed77a46edb55388fc632deb4ed555ebd" translate="yes" xml:space="preserve">
          <source>If command is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">command가 널 포인터 인 경우 호스트 환경에 명령 프로세서가 있는지 확인하고 명령 프로세서가 존재하는 경우에만 0이 아닌 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="28cefa0e9741f616b6f6233c4b91926613432287" translate="yes" xml:space="preserve">
          <source>If control over &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is needed in floating-to-integer conversions, &lt;code&gt;&lt;a href=&quot;../numeric/math/rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../numeric/math/nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">부동 소수점 정수 변환에서 &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 에 대한 제어 가 필요한 경우 &lt;code&gt;&lt;a href=&quot;../numeric/math/rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../numeric/math/nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">두 경우 &lt;code&gt;x&lt;/code&gt; 가 NaN의 또는 &lt;code&gt;y&lt;/code&gt; 는 NaN의 NaN이 반환된다</target>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">어느 경우 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; NaN의 NaN이 반환된다</target>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="translated">인수 중 하나가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="translated">나머지 또는 몫을 표현할 수없는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdb29cf682870c157ecc255b61896ebcf0dd8877" translate="yes" xml:space="preserve">
          <source>If enumerator is followed by = constant-expression, its value is the value of that constant expression. If enumerator is not followed by = constant-expression, its value is the value one greater than the value of the previous enumerator in the same enumeration. The value of the first enumerator (if it does not use = constant-expression) is zero.</source>
          <target state="translated">열거 자 다음에 = constant-expression이 있으면 해당 값은 해당 상수 표현식의 값입니다. 열거 자 다음에 = constant-expression이 없으면 값은 동일한 열거에서 이전 열거 자의 값보다 하나 큰 값입니다. 첫 번째 열거 자 (= constant-expression을 사용하지 않는 경우)의 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c1a30ffdb8b054f4f5efa04e804183bab7b8f87d" translate="yes" xml:space="preserve">
          <source>If evaluation A is sequenced before evaluation B, then evaluation of A will be complete before evaluation of B begins.</source>
          <target state="translated">평가 A가 평가 B보다 먼저 시퀀싱되면 B 평가가 시작되기 전에 A의 평가가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="360528c544120ebe32f7b7cd67e035fb9e4b4a51" translate="yes" xml:space="preserve">
          <source>If expression compares not equal to the integer zero, statement_true is executed.</source>
          <target state="translated">expression이 정수 0과 같지 않으면 statement_true가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb388918567059a7ef91b0bac2e600518001881" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is not present, none of the switch body is executed.</source>
          <target state="translated">expression이 &lt;code&gt;case:&lt;/code&gt; labels 와 일치하지 않는 값으로 평가되고 &lt;code&gt;default:&lt;/code&gt; label이 없으면 스위치 본문이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa83991d8493cfe779ea779356df33a31e5bb405" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="translated">expression이 &lt;code&gt;case:&lt;/code&gt; labels 와 일치하지 않는 값으로 평가되고 &lt;code&gt;default:&lt;/code&gt; label이 있으면 control은 &lt;code&gt;default:&lt;/code&gt; label로 표시된 명령문으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="6faa6fc85532e8604df80b963c664490b88079fd" translate="yes" xml:space="preserve">
          <source>If expression evaluates to the value that is equal to the value of one of constant_expressions after conversion to the promoted type of expression, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="translated">승격 된 표현식 유형으로 변환 한 후 expression이 constant_expressions 중 하나의 값과 동일한 값으로 평가되면 해당 constant_expression으로 레이블이 지정된 명령문으로 제어가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="334783c8d779e32d80f5e33d41aa548e3861ef1e" translate="yes" xml:space="preserve">
          <source>If expression evaluates to zero, this specifier has no effect.</source>
          <target state="translated">expression이 0으로 평가되면이 지정자는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="812257c713ec48ffa717a1e22cfeb0579763c024" translate="yes" xml:space="preserve">
          <source>If expression in an array declarator is an &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt; with a value greater than zero and the element type is a type with a known constant size (that is, elements are not VLA)(since C99), then the declarator declares an array of constant known size:</source>
          <target state="translated">배열 선언자의 &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;표현식&lt;/a&gt; 이 0보다 큰 값을 갖는 정수 상수 표현식 이고 요소 유형이 알려진 상수 크기를 가진 유형 (즉, 요소가 VLA가 아님) 인 경우 (C99 이후) 선언자는 다음의 배열을 선언합니다. 알려진 일정한 크기 :</target>
        </trans-unit>
        <trans-unit id="8ba6da87ee9a243a839b16d19baf884836288808" translate="yes" xml:space="preserve">
          <source>If expression in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an &lt;a href=&quot;array_initialization&quot;&gt;initializer&lt;/a&gt; is available, such type is an &lt;a href=&quot;compatible_type#Incomplete_types&quot;&gt;incomplete type&lt;/a&gt; (note that VLA of unspecified size, declared with &lt;code&gt;*&lt;/code&gt; as the size, is a complete type)(since C99):</source>
          <target state="translated">배열 선언자의 표현식이 생략되면 알 수없는 크기의 배열을 선언합니다. 함수 매개 변수 목록 (이러한 배열이 포인터로 변환되는 경우)을 제외하고 &lt;a href=&quot;array_initialization&quot;&gt;이니셜 라이저&lt;/a&gt; 를 사용할 수있는 경우 이러한 유형은 &lt;a href=&quot;compatible_type#Incomplete_types&quot;&gt;불완전한 유형입니다&lt;/a&gt; (크기로 &lt;code&gt;*&lt;/code&gt; 로 선언 된 지정되지 않은 크기의 VLA 는 완전한 유형 임) (C99부터) ) :</target>
        </trans-unit>
        <trans-unit id="fdf07733d3563d8385b8f445a3649648c5f3b8c5" translate="yes" xml:space="preserve">
          <source>If expression is not an &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt;, the declarator is for an array of variable size.</source>
          <target state="translated">expression이 &lt;a href=&quot;constant_expression#Integer_constant_expression&quot;&gt;정수 상수&lt;/a&gt; expression이 아닌 경우 선언자는 가변 크기의 배열에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2a210c65a0f6c3811043fd43a33ea0aeafeba4c" translate="yes" xml:space="preserve">
          <source>If it is an expression, it is evaluated once, before the first evaluation of cond_expression and its result is discarded.</source>
          <target state="translated">표현식 인 경우 cond_expression의 첫 번째 평가 전에 한 번 평가되고 결과가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a1527a6f74ffff1d191859da84a0b12635390d9d" translate="yes" xml:space="preserve">
          <source>If lhs and rhs are expressions of any &lt;a href=&quot;types&quot;&gt;real type&lt;/a&gt;, then.</source>
          <target state="translated">lhs 및 rhs가 &lt;a href=&quot;types&quot;&gt;실제 유형의&lt;/a&gt; 표현식 이면.</target>
        </trans-unit>
        <trans-unit id="dab84ea7417a8449e8e53aefe0bfd270462902ff" translate="yes" xml:space="preserve">
          <source>If lhs and rhs are expressions of pointer type, they must be both pointers to objects of &lt;a href=&quot;types#Compatible_types&quot;&gt;compatible types&lt;/a&gt;, except that qualifications of the pointed-to objects are ignored.</source>
          <target state="translated">lhs 및 rhs가 포인터 유형의 표현식 인 경우 , 지정된 오브젝트의 규정이 무시되는 것을 제외하고 는 &lt;a href=&quot;types#Compatible_types&quot;&gt;호환 가능한 유형의&lt;/a&gt; 오브젝트에 대한 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7bb0fe233a8db1c5731305199a741e53a04ba01b" translate="yes" xml:space="preserve">
          <source>If lhs has &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; type, the operation behaves as a single atomic read-modify-write operation with memory order &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">lhs가 &lt;a href=&quot;atomic&quot;&gt;원자&lt;/a&gt; 유형 인 경우 조작은 메모리 순서가 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 인 단일 원자 읽기-수정-쓰기 조작으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="bc7031518acd1f816f49dabf6745ea7fa65d3428" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C99)2147483647(since C99), the behavior is undefined.</source>
          <target state="translated">lineno가 0이거나 32767보다 큰 경우 (C99까지) 2147483647 (C99 이후) 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="translated">오류가 발생하지 않으면 earg</target>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="translated">오류가 발생하지 않으면 ln (1 + arg)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="translated">오류가 발생하지 않으면</target>
        </trans-unit>
        <trans-unit id="602f32de7c64c4861f4c15f4a272e41e4cf03cae" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;arg&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (arg&amp;times;2exp</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 에 &lt;code&gt;exp&lt;/code&gt; 의 거듭 제곱 (arg &amp;times; 2exp) 에 2를 곱한 값</target>
        </trans-unit>
        <trans-unit id="fd6ab22732d33f90243d40ac0149ac1bffd11661" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;arg&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;exp&lt;/code&gt; (arg&amp;times;FLT_RADIXexp</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;exp&lt;/code&gt; 의 거듭 제곱으로 곱한 값 (arg &amp;times; FLT_RADIXexp</target>
        </trans-unit>
        <trans-unit id="05313ea76fba59eae28768bcd1ded7d73640a2b9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exponent&lt;/code&gt; (baseexponent</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;base&lt;/code&gt; 를 &lt;code&gt;exponent&lt;/code&gt; 의 거듭 제곱 (baseexponent)으로 올립니다.</target>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="translated">에러가 발생하지 않으면, &lt;code&gt;z&lt;/code&gt; 의 복소 아크 코사인이 [0; &amp;infin;) 실제 축을 따라 [-</target>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">오류가 발생하지 않으면, 복잡한 아크 사인 &lt;code&gt;z&lt;/code&gt; 허수 축과 -&amp;pi; / 2 구간 [바운드 스트립의 범위에 반환되고 실제 축을 따라 + &amp;pi; / 2].</target>
        </trans-unit>
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">오류가 발생하지 않으면, 복잡한 탄젠트 &lt;code&gt;z&lt;/code&gt; 허수 축과 -&amp;pi; / 2 구간 [바운드 스트립의 범위에 반환되고 실제 축을 따라 + &amp;pi; / 2].</target>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;z&lt;/code&gt; 의 복잡한 쌍곡 코사인 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;z&lt;/code&gt; 의 복잡한 쌍곡 사인 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;z&lt;/code&gt; 의 복잡한 쌍곡 탄젠트 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e6bbf046061401d16d535bc081cfe13e7549ef1e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (norm, magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;z&lt;/code&gt; 의 절대 값 (표준, 크기)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하지 않으면,의 소수 부분 반환 &lt;code&gt;x&lt;/code&gt; 와 같은 기호 &lt;code&gt;x&lt;/code&gt; . 적분 부분은 &lt;code&gt;iptr&lt;/code&gt; 이 가리키는 값에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="translated">오류가 발생하지 않으면, 위상 각 리턴 &lt;code&gt;z&lt;/code&gt; 간격 [-&amp;pi;하여; &amp;pi;].</target>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="translated">오류가 발생하지 않으면 실수 축을 따라 허수 축 ([0; + &amp;infin;) 및 허수 축을 따라 (&amp;minus;&amp;infin;; + &amp;infin;)을 포함하여 오른쪽 반 평면의 범위에서 &lt;code&gt;z&lt;/code&gt; 의 제곱근을 반환합니다 . ).</target>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg)의 제곱근 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9c8867b079f9f036564e75c55c95fbeddad36f" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 ; &amp;pi;], is returned.</source>
          <target state="translated">오류가 발생하지 않으면의 아크 코사인 &lt;code&gt;arg&lt;/code&gt; 0 내지 [IN (ARCCOS (ARG)); &amp;pi;]가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="translated">오류가 발생하지 않는 경우의 아크 사인 &lt;code&gt;arg&lt;/code&gt; 범위 (다 arcsin (ARG)) -</target>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="translated">오류가 발생하지 않으면의 아크 탄젠트 &lt;code&gt;arg&lt;/code&gt; 범위 (아크 탄젠트 (ARG)) -</target>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;y/x&lt;/code&gt; 의 아크 탄젠트 (arctan (</target>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="translated">오류가 발생하지 않으면 기본</target>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="translated">오류가 발생하지 않으면 공통 (base-</target>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">에러가 발생하지 않으면, &lt;code&gt;z&lt;/code&gt; 의 복소 아크 쌍곡 사인은 실제 축을 따라 수학적으로 바운드되지 않은 스트립 범위와 간격 [-i&amp;pi; / 2; 가상 축을 따라 + i&amp;pi; / 2].</target>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">에러가 발생하지 않으면, &lt;code&gt;z&lt;/code&gt; 의 복소 곡선 쌍곡 탄젠트가 실제 축을 따라 그리고 구간 [-i&amp;pi; / 2; 가상 축을 따라 + i&amp;pi; / 2].</target>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;z&lt;/code&gt; 의 복합 코사인 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="translated">오류가 발생하지 않으면 가상 축을 따라 [-i&amp;pi;, + i&amp;pi;] 간격의 스트립 범위에서 &lt;code&gt;z&lt;/code&gt; 의 복소수 자연 로그 가 반환되고 실수 축을 따라 수학적으로 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="translated">오류가 발생하지 않으면 복소수 xy</target>
        </trans-unit>
        <trans-unit id="5a78d2dc104a241c9b7f8248a90bd60175e723dc" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;z&lt;/code&gt; 의 복잡한 사인입니다 .</target>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;z&lt;/code&gt; 의 복소 탄젠트 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">오류가 코사인 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 범위 (COS (ARG))을 [-1; +1]이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg)의 세제곱근이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;x&lt;/code&gt; 의 크기 와 &lt;code&gt;y&lt;/code&gt; 의 부호가 있는 부동 소수점 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 코사인 (cosh (arg) 또는</target>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 사인 (sinh (arg) 또는</target>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 탄젠트 (tanh (arg) 또는</target>
        </trans-unit>
        <trans-unit id="146d272bae4916411520863aa03f483db24f1cd9" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hypotenuse of a right-angled triangle, &amp;radic;x2</source>
          <target state="translated">오류가 발생하지 않으면 직각 삼각형의 빗변, &amp;radic;x2</target>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 의 역 쌍곡 코사인 (cosh-1)</target>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 의 역 쌍곡 사인 (sinh-1)</target>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 의 역 쌍곡 탄젠트 (tanh-1)</target>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 보다 크지 않은 가장 큰 정수 값 , 즉 &amp;lfloor;arg&amp;rfloor;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="translated">오류가 발생하지 않으면 자연 (기본</target>
        </trans-unit>
        <trans-unit id="f127780bac10fbde3e943c6286123dc5c825a17d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero), is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 보다 크지 않은 가장 가까운 정수 값 (즉, &lt;code&gt;arg&lt;/code&gt; 는 0으로 반올림 됨)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드&lt;/a&gt; 에 따라 &lt;code&gt;arg&lt;/code&gt; 에 가장 가까운 정수 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="translated">에러가 발생하지 않으면 , 반건의 경우 0에서 반올림 하여 &lt;code&gt;arg&lt;/code&gt; 에 가장 가까운 정수 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="695de1cc17da5f42bb05163df84a4d86f843cb06" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned, converted to the type of the function.</source>
          <target state="translated">오류가 발생하지 않으면 다음으로 표시 할 수있는 값 &lt;code&gt;from&lt;/code&gt; &lt;code&gt;to&lt;/code&gt; 방향입니다 . 반환됩니다. 경우 &lt;code&gt;from&lt;/code&gt; 같음 &lt;code&gt;to&lt;/code&gt; , 다음 &lt;code&gt;to&lt;/code&gt; 반환되고, 함수의 형식으로 변환.</target>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">오류가 발생하지 않으면 [-1; 범위 의 &lt;code&gt;arg&lt;/code&gt; 사인 (sin (arg))입니다. +1]이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 이상인 가장 작은 정수 값 ( arg )이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; (tan (arg)) 의 탄젠트 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="translated">오류가 발생하지 않으면,의 편견 지수 &lt;code&gt;arg&lt;/code&gt; 서명 된 부동 소수점 값으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="translated">오류가 발생하지 않으면,의 편견 지수 &lt;code&gt;arg&lt;/code&gt; 서명 된 INT 값으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ea26e0ca3f1790b6251b6744a4aeb9155a7a728" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is &amp;int;&amp;infin;</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 의 감마 함수 값 , 즉 &amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;arg&lt;/code&gt; 감마 함수의 로그 값 , 즉 log</target>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">오류가 발생하지 않으면,의 상보 오차 함수 값의 &lt;code&gt;arg&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">오류가 발생하지 않으면,의 오차 함수의 값 &lt;code&gt;arg&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="f33a26f2411f41973ee89bb92c9912299b6bf3fb" translate="yes" xml:space="preserve">
          <source>If no side effects are produced by an expression and the compiler can determine that the value is not used, the expression &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as-if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;may not be evaluated&lt;/a&gt;.</source>
          <target state="translated">표현식에서 부작용이 발생하지 않고 컴파일러에서 값이 사용되지 않는다고 판단 할 수 있으면 표현식 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as-if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;이 평가되지 않을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24607f8eda85840327155f9c5dd479383c4c0709" translate="yes" xml:space="preserve">
          <source>If no storage-class specifier is provided, the defaults are:</source>
          <target state="translated">스토리지 클래스 지정자가 제공되지 않은 경우 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4dfeb978fa33ed93ba2c224367f2086d951f30e" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">그러한 문자가 발견되지 않으면 &lt;code&gt;str&lt;/code&gt; 은 하나의 토큰 만 가지고 있으며 앞으로 &lt;code&gt;strtok&lt;/code&gt; 을 호출 하면 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">그러한 문자를 찾지 못하면 &lt;code&gt;str&lt;/code&gt; 에 토큰이 없으며 함수는 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1a104ff8f617c8217bce63f3debd82c29c77289d" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">그러한 넓은 문자를 찾지 못하면 &lt;code&gt;str&lt;/code&gt; 은 하나의 토큰 만 가지고, &lt;code&gt;wcstok&lt;/code&gt; 에 대한 향후 호출 은 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">그러한 넓은 문자를 찾지 못하면 &lt;code&gt;str&lt;/code&gt; 에 토큰이 전혀 없으며 함수는 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e40d2715cf1b46b20775d0bb380629a3585cd758" translate="yes" xml:space="preserve">
          <source>If none of the type-names are compatible with the type of the controlling-expression, and the &lt;code&gt;default&lt;/code&gt; association is provided, then the type, value, and value category of the generic selection are the type, value, and value category of the expression after the &lt;code&gt;default&amp;nbsp;:&lt;/code&gt; label.</source>
          <target state="translated">type-names가 control-expression의 유형과 호환되지 않고 &lt;code&gt;default&lt;/code&gt; 연관이 제공되는 경우, 일반 선택의 유형, 값 및 값 카테고리는 표현식의 유형, 값 및 값 카테고리입니다. 애프터 &lt;code&gt;default&amp;nbsp;:&lt;/code&gt; 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="c9c017ecb96c59470d6de6c8da38e2d13318a236" translate="yes" xml:space="preserve">
          <source>If one literal is unprefixed, the resulting string literal has the width/encoding specified by the prefixed literal. If the two string literals have different encoding prefixes, concatenation is implementation-defined.</source>
          <target state="translated">하나의 리터럴이 접두사가 아닌 경우 결과 문자열 리터럴에는 접두사 리터럴로 지정된 너비 / 인코딩이 있습니다. 두 문자열 리터럴의 인코딩 접두사가 다른 경우 연결이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="translated">두 인수 중 하나가 NaN이면 다른 인수의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="deb9997a39b957e2b1d0f67225814173635bd3be" translate="yes" xml:space="preserve">
          <source>If one type is an array of known constant size, the composite type is an array of that size.</source>
          <target state="translated">한 유형이 알려진 상수 크기의 배열 인 경우 복합 유형은 해당 크기의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ff00bc804bf5de0ca28e5fa9b87c6ef3300ee482" translate="yes" xml:space="preserve">
          <source>If only one type is a function type with a parameter type list (a function prototype), the composite type is a function prototype with the parameter type list.</source>
          <target state="translated">하나의 유형 만 매개 변수 유형 목록 (함수 프로토 타입)이있는 함수 유형 인 경우 복합 유형은 매개 변수 유형 목록이있는 함수 프로토 타입입니다.</target>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="translated">오버플로가 발생하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90421d9a10ca2ecc53b3233d830634266328f1bb" translate="yes" xml:space="preserve">
          <source>If pointer-expression is a pointer to function, the result of the dereference operator is a function designator for that function.</source>
          <target state="translated">pointer-expression이 함수에 대한 포인터 인 경우 역 참조 연산자의 결과는 해당 함수의 함수 지정자입니다.</target>
        </trans-unit>
        <trans-unit id="fabe0dc46a4e415f07e60b3d1fe73b90609b5485" translate="yes" xml:space="preserve">
          <source>If pointer-expression is a pointer to object, the result is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; that designates the pointed-to object.</source>
          <target state="translated">pointer-expression이 오브젝트에 대한 포인터 인 경우 결과는 지정된 오브젝트를 지정 하는 &lt;a href=&quot;value_category&quot;&gt;lvalue 표현식&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd3c561c327326fa9c43dffa8ca731c59ab3fba8" translate="yes" xml:space="preserve">
          <source>If qualifiers are present, they qualify the pointer type to which the array parameter type is transformed:</source>
          <target state="translated">한정자가있는 경우 배열 매개 변수 유형이 변환되는 포인터 유형을 한정합니다.</target>
        </trans-unit>
        <trans-unit id="086dd4d618100274bfcb461ebcb6308c19d4ae3c" translate="yes" xml:space="preserve">
          <source>If rhs and lhs overlap in memory (e.g. they are members of the same union), the behavior is undefined unless the overlap is exact and the types are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt;.</source>
          <target state="translated">rhs 및 lhs가 메모리에서 겹치는 경우 (예 : 동일한 공용체의 구성원 인 경우) 겹침이 정확하고 형식이 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 되지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4c28f503fd3f5fe3462baacb1c7312e58c942c2f" translate="yes" xml:space="preserve">
          <source>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a &quot;release sequence&quot; is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no &lt;code&gt;memory_order_release&lt;/code&gt; semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.</source>
          <target state="translated">일부 원자가 저장 해제되고 다른 여러 스레드가 해당 원자에 대해 읽기-수정-쓰기 작업을 수행하는 경우 &quot;해제 시퀀스&quot;가 형성됩니다. 동일한 원자에 대해 읽기-수정-쓰기를 수행하는 모든 스레드는 첫 번째 스레드와 동기화되고 &lt;code&gt;memory_order_release&lt;/code&gt; 의미 가없는 경우에도 서로 . 따라서 개별 소비자 스레드간에 불필요한 동기화를 수행하지 않고도 단일 생산자-여러 소비자 상황이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e82df7dfa926848bf252cb2decabe5aa7f78e1a2" translate="yes" xml:space="preserve">
          <source>If statement_true is entered through a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, statement_false is not executed.</source>
          <target state="translated">&lt;a href=&quot;goto&quot;&gt;goto를&lt;/a&gt; 통해 statement_true를 입력하면 statement_false가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">성공하면 위에서 정의한대로 &lt;code&gt;x/y&lt;/code&gt; 나누기의 IEEE 부동 소수점 나머지를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">성공하면 &lt;code&gt;arg&lt;/code&gt; ( &lt;code&gt;|arg|&lt;/code&gt; ) 의 절대 값을 반환합니다 . 반환 된 값은 정확하며 반올림 모드에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">성공하면 위에서 정의한 바와 같이 나누기 &lt;code&gt;x/y&lt;/code&gt; 의 부동 소수점 나머지를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dbd29a9c437f2e9ad0ed1aab2d3cb7e1e77881c8" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="translated">성공하면, 나눗셈 부동 소수점 나머지 반환 &lt;code&gt;x/y&lt;/code&gt; 항에 &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;remainder&lt;/a&gt;&lt;/code&gt; 한 점포에서, &lt;code&gt;*quo&lt;/code&gt; , 기호 및 최하위 비트의 적어도 세 개의 &lt;code&gt;x/y&lt;/code&gt; 정식 (점포 그 부호 값을 &lt;code&gt;x/y&lt;/code&gt; 의 부호 이고 크기가 합동 인 모듈로 2n</target>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">성공하면 두 개의 부동 소수점 값 중 더 큰 값을 반환합니다. 반환 된 값은 정확하며 반올림 모드에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="translated">성공하면 x와 y의 양의 차이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">성공하면 두 개의 부동 소수점 값 중 작은 값을 반환합니다. 반환 된 값은 정확하며 반올림 모드에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="translated">성공하면 &lt;code&gt;(x*y) + z&lt;/code&gt; 값을 무한 정밀도로 계산하고 결과 유형에 맞게 한 번 반올림 (또는 단일 삼항 부동 소수점 연산으로 계산) 한 것처럼 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="950601c730121915fb8df6b19b5705a6edc03c0a" translate="yes" xml:space="preserve">
          <source>If successful, the object pointed to by &lt;code&gt;thr&lt;/code&gt; is set to the identifier of the new thread.</source>
          <target state="translated">성공하면 &lt;code&gt;thr&lt;/code&gt; 가 가리키는 오브젝트 가 새 스레드의 식별자로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="translated">그러한 캐릭터가 발견되면</target>
        </trans-unit>
        <trans-unit id="3d422a20479abe70ce78b9c52445ed1bd990bbc6" translate="yes" xml:space="preserve">
          <source>If such character was found, it is the</source>
          <target state="translated">그러한 캐릭터가 발견되면</target>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="translated">그러한 넓은 성격이 발견되면</target>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="translated">그러한 넓은 성격이 발견되면</target>
        </trans-unit>
        <trans-unit id="a8d2bb8f6756f60946f65b57441b2965955c0d87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; object was obtained from POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; or equivalent function, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="translated">상기 중간 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; 개체의 POSIX로부터 얻은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; 또는 이와 동등한 기능의 값 &lt;code&gt;tm_isdst&lt;/code&gt; 는 불확정이고, 요구가 호출하기 전에 명시 적으로 설정 될 &lt;code&gt;mktime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;nptr&lt;/code&gt; 가 비어 있거나 예상되는 형태가없는 (경우에는 변환이 수행되지되고 &lt;code&gt;enptr&lt;/code&gt; 이 아닌 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 가 )의 값 &lt;code&gt;nptr&lt;/code&gt; 가 가리키는 객체에 저장됩니다 &lt;code&gt;endptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 비어 있거나 예상되는 형태가없는 (경우에는 변환이 수행되지되고 &lt;code&gt;str_end&lt;/code&gt; 이 아닌 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 가 )의 값 &lt;code&gt;str&lt;/code&gt; 가리키는 객체에 저장됩니다 &lt;code&gt;str_end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee4a33ed19255d1a25cca13eefd41adeef44b2e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="translated">는 IF &lt;code&gt;stream&lt;/code&gt; 바이너리 모드에서 열려, 새로운 위치는 정확히 &lt;code&gt;offset&lt;/code&gt; 경우 파일의 시작 부분에서 측정 바이트 &lt;code&gt;origin&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; 이 경우 현재 파일 위치에서 &lt;code&gt;origin&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt; , 파일의 끝에서 경우 &lt;code&gt;origin&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; 를 . 이진 스트림은 특히 추가 널 바이트가 출력되는 경우 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; 를 지원할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6116bff33763f686cb5185e7645c348dd0166f73" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">는 IF &lt;code&gt;stream&lt;/code&gt; 텍스트 모드에서 열려에 대한 유일한 값을 지원 &lt;code&gt;offset&lt;/code&gt; 가 제로 (모든 작동하는 &lt;code&gt;origin&lt;/code&gt; ) 및 이전 호출에 의해 반환 된 값은하는 &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; 은 단지와 함께 작동 (동일한 파일과 관련된 스트림에 &lt;code&gt;origin&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c9015050df160ef6325c9f3da2b730ab6368bcf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 이 넓은 경우 텍스트 및 이진 스트림의 제한이 적용됩니다 ( SEEK_SET 에서는 &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;ftell&lt;/a&gt;&lt;/code&gt; 의 결과 가 허용되고 SEEK_END에서는 SEEK_SET 및 SEEK_CUR에서는 0 오프셋이 허용됨).</target>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="translated">인수가 &amp;plusmn; &amp;infin;이면 &amp;plusmn; 1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">인수가 &amp;plusmn; &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">인수가 &amp;plusmn; &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 &amp;plusmn; &amp;infin;이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 &amp;plusmn; 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 + &amp;infin;이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 +0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 -&amp;infin;이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">인수가 &amp;plusmn; 0이면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="translated">인수가 &amp;plusmn; 1이면 폴 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="translated">인수가 + &amp;infin; 또는 &amp;plusmn; 0이면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">인수가 + &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">인수가 + &amp;infin;이면 + &amp;infin;이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="translated">인수가 + &amp;infin;이면 + &amp;pi; / 2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="translated">인수가 + &amp;infin;이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 +1이면 &lt;code&gt;+0&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 -&amp;pi; / 2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 -1이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="translated">인수가 -&amp;infin;이면 2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 -&amp;infin;이면 NaN이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 -1이면 -&amp;infin;이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="translated">인수가 1이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="translated">인수가 2이면 +0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="translated">인수가 NaN이면 NaN이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 음의 정수이면 + &amp;infin;이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">인수가 음의 정수이면 NaN이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="translated">인수가 -0보다 작은 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생하고 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 -1보다 작은 경우 NaN이 리턴되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="translated">인수가 1보다 작은 경우 도메인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">인수가 음수이면 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="translated">인수가 구간 [-1, +1]에 없으면 범위 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="translated">어레이는 여러 요소가 포함되어 있으면 &lt;code&gt;comp&lt;/code&gt; 소자 같음 검색으로 나타내는 것을, 다음 함수가 결과로서 반환하는 요소 지정한다.</target>
        </trans-unit>
        <trans-unit id="e7a938d361647e59fdfb270dd850072137c9ecac" translate="yes" xml:space="preserve">
          <source>If the array was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">배열이 &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; 로 선언 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c828d39720091190e6dcd291852f42239651509b" translate="yes" xml:space="preserve">
          <source>If the array was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;, the behavior of the program that attempts such conversion is undefined.</source>
          <target state="translated">배열이 &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; 로 선언 된 경우 , 그러한 변환을 시도하는 프로그램의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6074bc08a4061ed8b2bf04b357ba914834dcf0c1" translate="yes" xml:space="preserve">
          <source>If the comma operator has to be used in such context, it must be parenthesized:</source>
          <target state="translated">이러한 상황에서 쉼표 연산자를 사용해야하는 경우 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="36aec2ae635c40cb65f7125374328a3bd9489d46" translate="yes" xml:space="preserve">
          <source>If the compiler defines the macro constant &lt;code&gt;__STDC_NO_VLA__&lt;/code&gt; to integer constant &lt;code&gt;1&lt;/code&gt;, then VLA and VM types are not supported.</source>
          <target state="translated">컴파일러가 매크로 상수 &lt;code&gt;__STDC_NO_VLA__&lt;/code&gt; 을 정수 상수 &lt;code&gt;1&lt;/code&gt; 로 정의하면 VLA 및 VM 유형이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0102b5739cc3bf6169af43e213ce8f4a4202795a" translate="yes" xml:space="preserve">
          <source>If the compiler performs function inlining, it replaces a call of that function with its body, avoiding the overhead of a function call (placing data on stack and retrieving the result), which may result in a larger executable as the code for the function has to be repeated multiple times. The result is similar to &lt;a href=&quot;../preprocessor/replace&quot;&gt;function-like macros&lt;/a&gt;, except that identifiers and macros used in the function refer to the definitions visible at the point of definition, not at the point of call.</source>
          <target state="translated">컴파일러가 함수 인라인을 수행하는 경우 함수 호출의 오버 헤드를 피하고 (스택에 데이터 배치 및 결과 검색) 해당 함수의 호출을 본문으로 대체하여 함수에 대한 코드가 가지고있는 것처럼 실행 파일이 더 커질 수 있습니다. 여러 번 반복해야합니다. &lt;a href=&quot;../preprocessor/replace&quot;&gt;함수에&lt;/a&gt; 사용 된 식별자와 매크로는 호출 시점이 아니라 정의 시점에서 볼 수있는 정의를 참조한다는 점을 제외하면 결과는 함수와 유사한 매크로 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="d89aa9b9998e409f83a89bb9d2cdac3e91f09898" translate="yes" xml:space="preserve">
          <source>If the compiler supports analyzability, any language or library construct whose behavior is undefined is further classified between</source>
          <target state="translated">컴파일러가 분석 기능을 지원하는 경우 동작이 정의되지 않은 언어 또는 라이브러리 구성은 다음과 같이 더 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="59ee7a8220ba62d01c495a46ec65cf3fc585bffb" translate="yes" xml:space="preserve">
          <source>If the conversion to &lt;code&gt;time_t&lt;/code&gt; is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="translated">&lt;code&gt;time_t&lt;/code&gt; 로의 변환 이 성공하면 &lt;code&gt;time&lt;/code&gt; 오브젝트가 수정됩니다. 모든 &lt;code&gt;time&lt;/code&gt; 필드가 적절한 범위에 맞게 업데이트됩니다. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; 및 &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; 는 다른 필드에서 사용 가능한 정보를 사용하여 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate.</source>
          <target state="translated">변환 된 값이 반환 유형의 대응 범위를 벗어나게되면, 레인지 에러가 발생 (설정 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;​0​&lt;/code&gt; 적절하게 복귀된다.</target>
        </trans-unit>
        <trans-unit id="63ccc0cb218c965f911fab62a19044ef04c5af35" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">변환 된 값이 해당 리턴 유형의 범위를 벗어나면 범위 오류가 발생하고 ( &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; 로 설정 ) &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ca46624d6b0c110c8fee9d6430d211ff036c4ba4" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">정확한 결과가보다 크면 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 또는보다 작은 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="0c7f3d1a2ebc058a3464f5e25a82d02e716648fa" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="translated">올바른 결과가 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 보다 크 거나 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 보다 작은 경우 도메인 오류 또는 범위 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="191fa266d736718757385767dd6a59cc886d46d0" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified and a domain error or range error may occur.</source>
          <target state="translated">올바른 결과가 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 보다 크 거나 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 보다 작 으면 리턴 값이 지정되지 않고 도메인 오류 또는 범위 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a6cae9283a2623af917462111836ee3e70aa764" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt;, but unlike &lt;code&gt;&lt;a href=&quot;round&quot;&gt;round&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">현재 반올림 모드가 &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt; 이면이 함수 는 반음의 경우에도 반올림합니다 ( &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; 와 같지만 &lt;code&gt;&lt;a href=&quot;round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 와는 다름 ).</target>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="translated">현재 반올림 모드가 ...</target>
        </trans-unit>
        <trans-unit id="97a0aa7f8fe1a9bd6dbbecffec65b2ca11d005be" translate="yes" xml:space="preserve">
          <source>If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.</source>
          <target state="translated">식별자를 선언하는 선언자 또는 형식 지정자가 블록 또는 매개 변수 목록 외부에 나타나는 경우 식별자에는 파일 범위가 있으며 변환 단위의 끝에서 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="253bb460db1572bc8ca06ca717632f07e694bb79" translate="yes" xml:space="preserve">
          <source>If the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:</source>
          <target state="translated">배열의 요소가 배열, 구조체 또는 공용체 인 경우 중괄호로 묶인 이니셜 라이저 목록의 해당 이니셜 라이저는 다음과 같이 중괄호를 생략 할 수 있다는 점을 제외하고 해당 멤버에 유효한 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="cc06f1d466f19d96e2bb2f450cc3e5f9c16ffbc6" translate="yes" xml:space="preserve">
          <source>If the environment macro &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; is defined, the values of type &lt;code&gt;wchar_t&lt;/code&gt; are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">환경 매크로 &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; 이 정의 된 경우 &lt;code&gt;wchar_t&lt;/code&gt; 유형의 값은 유니 코드 필수 세트 (일반적으로 UTF-32 인코딩)에있는 문자의 짧은 식별자와 동일합니다. 그렇지 않으면 구현 정의입니다. 어쨌든이 함수가 사용하는 멀티 바이트 문자 인코딩은 현재 활성화 된 C 로케일에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="1127060a7a07a58c7bb8e11a04aa886b4480ab05" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as a shortcut.</source>
          <target state="translated">루프 본문 끝에서 루프 실행을 계속해야하는 경우 &lt;a href=&quot;continue&quot;&gt;continue 문&lt;/a&gt; 을 바로 가기로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee3147a9a7672459eeee8081c98eac6e3e82425" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as a terminating statement.</source>
          <target state="translated">루프 실행을 어느 시점에서 종료해야하는 경우 &lt;a href=&quot;break&quot;&gt;break 문&lt;/a&gt; 을 종료 문으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">루프 실행을 어느 시점에서 종료해야하는 경우 &lt;a href=&quot;break&quot;&gt;break 문&lt;/a&gt; 을 종료 문으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82682fec524d889a1cf2cfe1b3e0b122ffe26584" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used anywhere within the loop_statement.</source>
          <target state="translated">루프 실행을 어느 시점에서 종료 해야하는 경우, loop_statement 내에서 &lt;a href=&quot;break&quot;&gt;break 문을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bb904e3ab541e5036d8b9cca126affda663bc33" translate="yes" xml:space="preserve">
          <source>If the exponent is present and fractional part is not used, the decimal separator may be omitted:</source>
          <target state="translated">지수가 존재하고 소수 부분이 사용되지 않으면 소수점 구분 기호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a165ff8440c9b7e05a409264009f6217873d188b" translate="yes" xml:space="preserve">
          <source>If the external definition exists in the program, the address of the function is always the address of the external function, but when this address is used to make a function call, it's unspecified whether the</source>
          <target state="translated">프로그램에 외부 정의가 존재하면 함수의 주소는 항상 외부 함수의 주소이지만이 주소를 사용하여 함수를 호출 할 때는</target>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="translated">파일 종료 조건으로 인해 실패한 경우 추가로</target>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="translated">파일 끝 조건으로 인해 오류가 발생한 경우 추가로</target>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="translated">다른 오류로 인해 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="830435d4a1387d881331880059f8a2aaf6456533" translate="yes" xml:space="preserve">
          <source>If the file is currently open by this or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name although the file system space is not reclaimed until the last running process closes the file; Windows does not allow the file to be deleted).</source>
          <target state="translated">파일이 현재이 프로세스 나 다른 프로세스에 의해 열려있는 경우,이 기능의 동작은 구현에 따라 정의됩니다 (특히, POSIX 시스템은 마지막 실행 프로세스가 파일을 닫을 때까지 파일 시스템 공간을 확보하지 않아도 파일 이름을 링크 해제합니다. 파일을 삭제할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="translated">세트의 첫 번째 문자가 &lt;code&gt;^&lt;/code&gt; 인 경우 세트에없는 모든 문자가 일치합니다. 세트가 &lt;code&gt;]&lt;/code&gt; 또는 &lt;code&gt;^]&lt;/code&gt; 로 시작 하면 &lt;code&gt;]&lt;/code&gt; 문자도 세트에 포함됩니다. 이 구현 정의 문자 여부 &lt;code&gt;-&lt;/code&gt; scanset의 비는 초기 위치에서와 같이 범위가 표시 될 수있다 &lt;code&gt;[0-9]&lt;/code&gt; . 너비 지정자를 사용하는 경우 최대</target>
        </trans-unit>
        <trans-unit id="d64e081a56bac75f7eaed846b2b99e805513c5d7" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited (whether by return or by a different &lt;code&gt;longjmp&lt;/code&gt; higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 를 호출 한 함수가 리턴되거나 스택 의 다른 &lt;code&gt;longjmp&lt;/code&gt; 에 의해 종료 된 경우 동작은 정의되지 않습니다. 즉, 콜 스택 위로 길게 점프하는 것만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1269621bdc65581d6c1d260b7209ad814afbd640" translate="yes" xml:space="preserve">
          <source>If the host environment cannot supply both lowercase and uppercase letters, the command line arguments are converted to lowercase.</source>
          <target state="translated">호스트 환경이 소문자와 대문자를 모두 제공 할 수없는 경우 명령 행 인수가 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="translated">구현이 부동 소수점 무한대를 지원하지 않는 경우 매크로 &lt;code&gt;INFINITY&lt;/code&gt; 는 양수 값으로 확장되어 컴파일시 &lt;code&gt;float&lt;/code&gt; 을 오버 플로우하도록 보장 하며이 매크로를 사용하면 컴파일러 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술을 지원하는 경우 (IEC 60559)</target>
        </trans-unit>
        <trans-unit id="699c67e4aaf9791f00393d5529c1c7e718fbd3d8" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;rint&lt;/code&gt; function:</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술 (IEC 60559)을 지원하는 경우 &lt;code&gt;rint&lt;/code&gt; 함수의 경우 :</target>
        </trans-unit>
        <trans-unit id="fe61740055acdc39bc5f3b3cf183ae13ff9c59a6" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, and &lt;code&gt;roundl&lt;/code&gt; function:</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술 (IEC 60559)을 지원하는 경우 &lt;code&gt;round&lt;/code&gt; , &lt;code&gt;roundf&lt;/code&gt; 및 &lt;code&gt;roundl&lt;/code&gt; 함수의 경우 :</target>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술을 지원하는 경우 (IEC 60559) &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; 는 0이 아니 어야 합니다.</target>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="translated">구현이 IEEE 부동 소수점 산술을 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="translated">구현이 부동 소수점 무한대를 지원하는 경우 매크로 &lt;code&gt;INFINITY&lt;/code&gt; 는 양수 또는 부호없는 무한대로 평가되는 &lt;code&gt;float&lt;/code&gt; 유형의 상수 표현식으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="translated">입력이 주어진 문자까지 전처리 토큰으로 구문 분석 된 경우 다음 전처리 토큰은 일반적으로 후속 분석이 실패하더라도 전처리 토큰을 구성 할 수있는 가장 긴 문자 시퀀스로 간주됩니다. 이것은 일반적으로 알려진</target>
        </trans-unit>
        <trans-unit id="1b0cfd9b08932b3884431c92475183560f1d46ce" translate="yes" xml:space="preserve">
          <source>If the last thread in the program is terminated with &lt;code&gt;thrd_exit&lt;/code&gt;, the entire program terminates as if by calling &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; as the argument (so the functions registered by &lt;code&gt;&lt;a href=&quot;../program/atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt; are executed in the context of that last thread).</source>
          <target state="translated">프로그램의 마지막 스레드가 종료되면 &lt;code&gt;thrd_exit&lt;/code&gt; 호출하여 마치 전체 프로그램이 종료 &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; 를 인수 (등록 기능도록 &lt;code&gt;&lt;a href=&quot;../program/atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt; 가 마지막 스레드의 컨텍스트에서 실행된다).</target>
        </trans-unit>
        <trans-unit id="f0092ff30ced4b5b7eeebddab8461805c98ccc03" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified, the result is also qualified. If the left operand is &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">왼쪽 피연산자가 &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; 이거나 &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; Qualified 인 경우 결과도 규정됩니다. 왼쪽 피연산자가 &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc3d85ef243667631214a89b35ad48243e455197" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">길이 지정자 &lt;code&gt;l&lt;/code&gt; 을 사용하지 않으면 변환 지정자 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;[&lt;/code&gt; 는 첫 번째 문자가 변환되기 전에 &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt; 오브젝트를 0으로 초기화하여 &lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt; &lt;code&gt;wcrtomb()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 와이드 바이트에서 멀티 바이트 문자로 변환을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="eca68afe6b8894fe105ba600b6be6acbcaded6f7" translate="yes" xml:space="preserve">
          <source>If the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.</source>
          <target state="translated">lvalue가 주소를 가져 가지 않은 자동 저장 기간의 오브젝트를 지정하고 해당 오브젝트가 초기화되지 않은 경우 (초기화 프로그램으로 선언되지 않고 사용 전에 지정되지 않은 경우), 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6c5c610adf8c7fe59ee2c1e9abdf35cbc323127" translate="yes" xml:space="preserve">
          <source>If the lvalue has incomplete type, the behavior is undefined.</source>
          <target state="translated">lvalue의 유형이 불완전한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01cf236a859f8973431548739aa1a2bd6773cac2" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">매크로 &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; 이 정의 된 경우이 함수에서 사용하는 16 비트 인코딩은 UTF-16입니다. 그렇지 않으면 구현 정의입니다. 어쨌든이 함수가 사용하는 멀티 바이트 문자 인코딩은 현재 활성화 된 C 로케일에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9aa2e0435d88c88dcdb4fbdbb133c8a127f19150" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">매크로 &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; 가 정의 된 경우이 함수에서 사용하는 32 비트 인코딩은 UTF-32입니다. 그렇지 않으면 구현 정의입니다. 어쨌든이 함수가 사용하는 멀티 바이트 문자 인코딩은 현재 활성화 된 C 로케일에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="651db3f0d9f9ede3dcfc008c0798405a073761da" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt;(C11) is defined by the compiler, the header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, the keyword &lt;code&gt;_Atomic&lt;/code&gt;, and all of the names listed here are not provided.</source>
          <target state="translated">매크로 상수 &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt; (C11)가 컴파일러에 의해 정의되면 헤더 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; , 키워드 &lt;code&gt;_Atomic&lt;/code&gt; 및 여기에 나열된 모든 이름이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="549a81d60d09906925c9492d7b11e76f4c974fe0" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt;(C11) is defined by the compiler, the keyword &lt;code&gt;_Atomic&lt;/code&gt; as well as the header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, is not provided.</source>
          <target state="translated">매크로 상수 &lt;code&gt;__STDC_NO_ATOMICS__&lt;/code&gt; (C11)가 컴파일러에 의해 정의되면 키워드 &lt;code&gt;_Atomic&lt;/code&gt; 및 헤더 &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; 가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54c6fb244ea5ef05e85ae5bec7afb39dca30e410" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt; is defined by the implementation, the complex types, the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and all of the names listed here are not provided.</source>
          <target state="translated">매크로 상수 &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt; 가 구현에 의해 정의되면 복합 유형, 헤더 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 및 여기에 나열된 모든 이름이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3b81b34a2269058d8e0301809518279ee9143b0" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt;(C11) is defined by the implementation, the complex types (as well as the library header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;) are not provided.</source>
          <target state="translated">매크로 상수 &lt;code&gt;__STDC_NO_COMPLEX__&lt;/code&gt; (C11)이 구현에 의해 정의되면 복합 유형 (및 라이브러리 헤더 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; )이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1231e4ddd7fa2aa6ee9ba3a4d709933bfbf0374c" translate="yes" xml:space="preserve">
          <source>If the macro constant &lt;code&gt;__STDC_NO_THREADS__&lt;/code&gt;(C11) is defined by the compiler, the header &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; and all of the names listed here are not provided.</source>
          <target state="translated">매크로 상수 &lt;code&gt;__STDC_NO_THREADS__&lt;/code&gt; (C11)가 컴파일러에 의해 정의되면 &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; 헤더 와 여기에 나열된 모든 이름이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51f37b450edb52b954b68e62d69c5c0202f834d2" translate="yes" xml:space="preserve">
          <source>If the main function executes a &lt;code&gt;return&lt;/code&gt; that specifies no value or, which is the same, reaches the terminating &lt;code&gt;}&lt;/code&gt; without executing a &lt;code&gt;return&lt;/code&gt;, the termination status returned to the host environment is undefined.</source>
          <target state="translated">주된 기능은 실행하면 &lt;code&gt;return&lt;/code&gt; 동일한 값을 지정하거나, 종단에 도달 없음 &lt;code&gt;}&lt;/code&gt; 실행하지 않고 &lt;code&gt;return&lt;/code&gt; , 호스트 환경으로 돌아 종료 상태가 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="9dd09fa95e725157b1639c229069abbb48976b07" translate="yes" xml:space="preserve">
          <source>If the member used to access the contents of a union is not the same as the member last used to store a value, the object representation of the value that was stored is reinterpreted as an object representation of the new type (this is known as</source>
          <target state="translated">공용체의 내용에 액세스하는 데 사용 된 멤버가 마지막으로 값을 저장하는 데 사용한 멤버와 동일하지 않은 경우 저장된 값의 오브젝트 표시는 새 유형의 오브젝트 표시로 해석됩니다 (이것은</target>
        </trans-unit>
        <trans-unit id="8b562f8affe8bf1ade0fe85a6dfe88e871afc3d0" translate="yes" xml:space="preserve">
          <source>If the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:</source>
          <target state="translated">구조체 또는 공용체의 멤버가 배열, 구조체 또는 공용체 인 경우, 중괄호로 묶인 이니셜 라이저 목록의 해당 이니셜 라이저는 다음과 같이 중괄호를 생략 할 수 있다는 점을 제외하고 해당 멤버에 유효한 모든 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="df9b6d81c45a06a726423ecec58eacc4756ca95f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="translated">빼기 부호가 입력 시퀀스의 일부인 경우 자릿수 시퀀스에서 계산 된 숫자 값 은 결과 유형의 &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;단항 빼기 인&lt;/a&gt; 것처럼 무시 되며 부호없는 정수 랩 어라운드 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d8c026dab9455903edcd7b942a6e7d2b308ef69" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="translated">빼기 부호가 입력 시퀀스의 일부인 경우 , 결과 시퀀스에서 &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic&quot;&gt;단항 빼기&lt;/a&gt; 만큼 자릿수 시퀀스에서 계산 된 숫자 값이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*s&lt;/code&gt; 의 멀티 바이트 문자 가 multi-char16_t 시퀀스 (예 : UTF-16의 서로 게이트 쌍)에 해당하는 경우이 함수에 대한 첫 번째 호출 후 &lt;code&gt;*ps&lt;/code&gt; 는 &lt;code&gt;mbrtoc16&lt;/code&gt; 에 대한 다음 호출 이 작성 되는 방식으로 업데이트됩니다. &lt;code&gt;*s&lt;/code&gt; 를 고려하지 않고 추가 char16_t를 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*s&lt;/code&gt; 의 멀티 바이트 문자 가 multi-char32_t 시퀀스 (UTF-32에서는 불가능)에 해당하는 경우이 함수에 대한 첫 번째 호출 후 &lt;code&gt;*ps&lt;/code&gt; 는 다음 &lt;code&gt;mbrtoc32&lt;/code&gt; 호출 이 &lt;code&gt;*s&lt;/code&gt; 를 고려하지 않고 추가 char32_t .</target>
        </trans-unit>
        <trans-unit id="304955bf3a45b6b20b8586f86759d6a1a4e81f15" translate="yes" xml:space="preserve">
          <source>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:</source>
          <target state="translated">중첩 이니셜 라이저가 여는 중괄호로 시작하는 경우 중첩 중괄호까지 중첩 된 이니셜 라이저 전체가 해당 배열 요소를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="933c4fa6a66cfd77beaa3fe517c80ce5e0abfbb6" translate="yes" xml:space="preserve">
          <source>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new</source>
          <target state="translated">중첩 이니셜 라이저가 여는 중괄호로 시작하는 경우 중첩 중괄호까지 중첩 된 이니셜 라이저 전체가 해당 멤버 오브젝트를 초기화합니다. 각각의 왼쪽 오프닝 브레이스는 새로운</target>
        </trans-unit>
        <trans-unit id="151921afc39167d8205cd587ad8ad524dd37f8ab" translate="yes" xml:space="preserve">
          <source>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:</source>
          <target state="translated">중첩 된 이니셜 라이저가 여는 중괄호로 시작하지 않으면 목록에서 충분한 이니셜 라이저 만 사용하여 멤버 배열, 구조체 또는 공용체의 요소 또는 멤버를 고려합니다. 나머지 구조체는 다음 구조체 멤버를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="1d36da4c4053cda43da536fac84e436ea42130de" translate="yes" xml:space="preserve">
          <source>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:</source>
          <target state="translated">중첩 된 이니셜 라이저가 여는 중괄호로 시작하지 않으면 하위 배열, 구조체 또는 공용체의 요소 또는 멤버를 설명하기 위해 목록에서 충분한 이니셜 라이저 만 가져옵니다. 나머지 배열은 다음 배열 요소를 초기화하기 위해 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="80732b9a6ea0bd32db8b85caa6c27f1714c901e0" translate="yes" xml:space="preserve">
          <source>If the object is never modified, it may be aliased and accessed through different restrict-qualified pointers (note that if the objects pointed to by aliased restrict-qualified pointers are, in turn, pointers, this aliasing can inhibit optimization).</source>
          <target state="translated">객체가 수정되지 않은 경우 다른 제한 한정 포인터를 통해 별칭이 지정되고 액세스 될 수 있습니다 (별칭 제한 한정 포인터가 가리키는 객체가 포인터 인 경우이 별칭이 최적화를 방해 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="e99470df4e3d3e9a6241b3fc568484134bda99cc" translate="yes" xml:space="preserve">
          <source>If the object was created by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, the declared type of that object is the object's</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언에&lt;/a&gt; 의해 객체가 생성 된 경우 해당 객체 의 선언 된 유형은 객체의</target>
        </trans-unit>
        <trans-unit id="21dde2db6c5eec120e8008d864b1ea6006fc747f" translate="yes" xml:space="preserve">
          <source>If the object was created by an &lt;a href=&quot;../memory&quot;&gt;allocation function&lt;/a&gt; (including &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;), it has no declared type. Such object acquires an effective type as follows:</source>
          <target state="translated">&lt;a href=&quot;../memory&quot;&gt;할당 함수&lt;/a&gt; ( &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 포함 )로 객체를 만든 경우 선언 된 유형이 없습니다. 이러한 객체는 다음과 같은 효과적인 유형을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="07637ee8af1e302a0a5a769400ebcb2f44a92f13" translate="yes" xml:space="preserve">
          <source>If the operand is an array index expression, no action is taken other than the array-to-pointer conversion and the addition, so &amp;amp;a[N] is valid for an array of size N (obtaining a pointer one past the end is okay, dereferencing it is not, but dereference cancels out in this expression).</source>
          <target state="translated">피연산자가 배열 인덱스 표현식 인 경우 배열에서 포인터로의 변환 및 추가 외에 다른 조치가 수행되지 않으므로 &amp;amp; a [N]은 크기가 N 인 배열에 유효합니다 (끝을 지나서 포인터를 가져 오는 것은 괜찮습니다. 참조 해제는 아니지만이 참조에서 역 참조는 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="880e10035a2f45d57c976bf239aeb18adfa8e76c" translate="yes" xml:space="preserve">
          <source>If the operand is the dereference operator, no action is taken (so it's okay to apply &amp;amp;* to a null pointer), except that the result is not an lvalue.</source>
          <target state="translated">피연산자가 역 참조 연산자 인 경우 결과가 lvalue가 아닌 것을 제외하고는 아무 조치도 수행되지 않습니다 (널 포인터에 &amp;amp; *를 적용해도됩니다).</target>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="translated">스트림의 방향이 이미 결정된 경우 (출력을 실행하거나 fwide에 대한 이전 호출을 통해)이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d599043942f481f6b0419f90b76a322525485e59" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P1&lt;/code&gt; points at an element of an array with index &lt;code&gt;I&lt;/code&gt; (or one past the end) and &lt;code&gt;P2&lt;/code&gt; points at an element of the same array with index &lt;code&gt;J&lt;/code&gt; (or one past the end), then</source>
          <target state="translated">포인터 &lt;code&gt;P1&lt;/code&gt; 이 인덱스 &lt;code&gt;I&lt;/code&gt; (또는 끝을 지나서 하나)을 가진 배열의 요소를 가리키고 &lt;code&gt;P2&lt;/code&gt; 가 인덱스 &lt;code&gt;J&lt;/code&gt; (또는 끝을 지나서지나)를 가진 같은 배열의 요소를 가리키는 경우</target>
        </trans-unit>
        <trans-unit id="cdb9c5ce8b4b941a74dbd485a5daa17a5fa7a8b0" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points at an element of an array with index &lt;code&gt;I&lt;/code&gt;, then</source>
          <target state="translated">포인터 &lt;code&gt;P&lt;/code&gt; 가 인덱스 &lt;code&gt;I&lt;/code&gt; 인 배열의 요소를 가리키는 경우</target>
        </trans-unit>
        <trans-unit id="6c7b266d1b59c8d3597834929777fbdb4b7e7282" translate="yes" xml:space="preserve">
          <source>If the quotient &lt;code&gt;a/b&lt;/code&gt; is not representable in the result type, the behavior of both &lt;code&gt;a/b&lt;/code&gt; and &lt;code&gt;a%b&lt;/code&gt; is undefined (that means &lt;code&gt;INT_MIN%-1&lt;/code&gt; is undefined on 2's complement systems).</source>
          <target state="translated">몫 &lt;code&gt;a/b&lt;/code&gt; 가 결과 유형에서 표현할 수없는 경우 &lt;code&gt;a/b&lt;/code&gt; 및 &lt;code&gt;a%b&lt;/code&gt; 이 정의되지 않습니다 (즉 , 2의 보수 시스템에서 &lt;code&gt;INT_MIN%-1&lt;/code&gt; 이 정의되지 않음).</target>
        </trans-unit>
        <trans-unit id="7ffc31d0b868412a85aac63a2d15275575b7998d" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;lrint&lt;/code&gt; or &lt;code&gt;llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">&lt;code&gt;lrint&lt;/code&gt; 또는 &lt;code&gt;llrint&lt;/code&gt; 의 결과가 반환 유형으로 표시 할 수있는 범위를 벗어난 경우 도메인 오류 또는 범위 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="622ba0546ebe6337384487d2c74de396ef013e92" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;lround&lt;/code&gt; or &lt;code&gt;llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">&lt;code&gt;lround&lt;/code&gt; 또는 &lt;code&gt;llround&lt;/code&gt; 의 결과가 리턴 유형으로 표시 할 수있는 범위를 벗어나면 도메인 오류 또는 범위 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">반올림 결과가 리턴 유형의 범위를 벗어나면 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생하고 구현 정의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="028eee91596148e2d553d9c0585e4796bc1e1860" translate="yes" xml:space="preserve">
          <source>If the resulting value can be represented by the target type, that value is used</source>
          <target state="translated">결과 값을 대상 유형으로 표시 할 수 있으면 해당 값이 사용됩니다</target>
        </trans-unit>
        <trans-unit id="e979bc95923b9d4b1835c4ad27806c96fcb36b2c" translate="yes" xml:space="preserve">
          <source>If the return statement is used, the return value is used as the argument to the implicit call to &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (see below for details). The values zero and &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; indicate successful termination, the value &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; indicates unsuccessful termination.</source>
          <target state="translated">return 문을 사용하는 경우 return 값은 &lt;code&gt;&lt;a href=&quot;../program/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 에 대한 암시 적 호출에 대한 인수로 사용됩니다 (자세한 내용은 아래 참조). 값은 제로와 &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; 가 성공적으로 종료를 표시, 값 &lt;code&gt;&lt;a href=&quot;../program/exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; 는 실패 종료를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e166793b1a3e247cb1aa8707ba705ca2a49e53a0" translate="yes" xml:space="preserve">
          <source>If the return type is a real floating type, the result may be represented in &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;greater range and precision&lt;/a&gt; than implied by the new type.</source>
          <target state="translated">반환 유형이 실수 부동 유형 인 경우 결과는 새 유형에 의해 암시 된 것보다 &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;더 큰 범위와 정밀도&lt;/a&gt; 로 표현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc834aece2679899b19365c0e96b6a9287c774b2" translate="yes" xml:space="preserve">
          <source>If the return type of the main function is not &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with &lt;code&gt;int&lt;/code&gt; (e.g. &lt;code&gt;void main(void)&lt;/code&gt;), the value returned to the host environment is unspecified. If the returned type is compatible with int and control reaches the terminating &lt;code&gt;}&lt;/code&gt;, the value returned to the environment is the same as if executing &lt;code&gt;return 0;&lt;/code&gt;</source>
          <target state="translated">main 함수의 리턴 유형이 &lt;code&gt;int&lt;/code&gt; 와 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 되지 않는 경우 (예 : &lt;code&gt;void main(void)&lt;/code&gt; ) 호스트 환경으로 리턴되는 값은 지정되지 않습니다. 반환 된 형식이 int와 호환되고 제어가 종료 &lt;code&gt;}&lt;/code&gt; 에 도달 하면 환경에 반환 된 값은 &lt;code&gt;return 0;&lt;/code&gt; 실행하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">반환 값이 &lt;code&gt;0&lt;/code&gt; 의 경우 , &lt;code&gt;x&lt;/code&gt; 와 같은 부호를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7c0d5f1db5857afe2a215a274d4b5151e584e7b1" translate="yes" xml:space="preserve">
          <source>If the same identifier appears with both internal and external linkage in the same translation unit, the behavior is undefined. This is possible when &lt;a href=&quot;extern&quot;&gt;tentative definitions&lt;/a&gt; are used.</source>
          <target state="translated">동일한 변환 단위에서 내부 및 외부 연결과 동일한 식별자가 나타나는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;extern&quot;&gt;임시 정의&lt;/a&gt; 가 사용될 때 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="a404b81bd183a04af684a1dd83adbe457b397df0" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if the IEEE floating-point arithmetic is supported, and the floating-point division is taking place, then.</source>
          <target state="translated">두 번째 피연산자가 0이면 IEEE 부동 소수점 산술이 지원되고 부동 소수점 나누기가 수행되는 경우를 제외하고 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87cda6e927c8b4be84e09f295f15129ed6308632" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined.</source>
          <target state="translated">두 번째 피연산자가 0이면 동작이 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="bfc275cb73a90eef9664528239ab4998157ab970" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; (in other words, the signal handler is</source>
          <target state="translated">신호 처리기가 &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; 의 결과로 NOT이라고하는 경우 (즉, 신호 처리기는</target>
        </trans-unit>
        <trans-unit id="88071f1c5c0e1b4839dab6e032d8012686be4323" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt;, the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상기 신호 처리기의 결과로서 호출 될 경우 &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; 신호 처리기가 호출하는 경우, 동작이 정의되어 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;raise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da5426c0f7f65abd2bcb02b6bd8cb6318ab19838" translate="yes" xml:space="preserve">
          <source>If the significand begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating constant is a</source>
          <target state="translated">significand가 문자 시퀀스 &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 로 시작하면 부동 상수는</target>
        </trans-unit>
        <trans-unit id="a7d0de34374ff61db0aaf9670764de6bb336cc95" translate="yes" xml:space="preserve">
          <source>If the size expression of a VLA has side effects, they are guaranteed to be produced except when it is a part of a sizeof expression whose result doesn't depend on it:</source>
          <target state="translated">VLA의 크기 표현에 부작용이있는 경우 결과가 VLA에 의존하지 않는 표현식의 일부인 경우를 제외하고 VLA가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f5d5fbe264df8096d3f2dc04126bdd49bd7491ca" translate="yes" xml:space="preserve">
          <source>If the size is &lt;code&gt;*&lt;/code&gt;, the declaration is for a VLA of unspecified size. Such declaration may only appear in a function prototype scope, and declares an array of a complete type. In fact, all VLA declarators in function prototype scope are treated as if expression were replaced by &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">크기가 &lt;code&gt;*&lt;/code&gt; 이면 선언은 지정되지 않은 크기의 VLA에 대한 것입니다. 이러한 선언은 함수 프로토 타입 범위에만 나타날 수 있으며 완전한 유형의 배열을 선언합니다. 실제로 함수 프로토 타입 범위의 모든 VLA 선언자는 표현식이 &lt;code&gt;*&lt;/code&gt; 로 대체 된 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5177cdc4e2a0570675a3bb78ff34b15988072e1" translate="yes" xml:space="preserve">
          <source>If the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:</source>
          <target state="translated">배열의 크기를 알면 문자열 리터럴의 크기보다 작을 수 있으며,이 경우 종료 널 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="translated">스트림이 이진 모드로 열린 경우이 함수로 얻은 값은 파일 시작 부분의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="fcf8e63ecc85a80b64f92483949ed9fe9401f63f" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스트림이 텍스트 모드에서 열려있는 경우이 함수가 리턴 한 값은 지정되지 않으며 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek()&lt;/a&gt;&lt;/code&gt; 의 입력으로 만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="translated">문자열이 겹치면 동작이 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="3737cc31b2abcb3a56ec3dc6ed19f293aa85246e" translate="yes" xml:space="preserve">
          <source>If the type is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with the type-name of one of the associations, then the type, value, and &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the generic selection are the type, value, and value category of the expression that appears after the colon for that type-name.</source>
          <target state="translated">유형 인 경우 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 협회, 다음, 유형, 가치, 그리고 하나의 유형 이름 &lt;a href=&quot;value_category&quot;&gt;값 카테고리&lt;/a&gt; 일반 선택되는 식의 유형, 가치, 가치 부문이 그 유형 -에 대한 콜론 뒤 나타납니다 이름.</target>
        </trans-unit>
        <trans-unit id="1bc5654858ffa7d0d01ecee82edcb9b073576512" translate="yes" xml:space="preserve">
          <source>If the type of expression is a &lt;a href=&quot;array&quot;&gt;variable-length array&lt;/a&gt; type, expression is evaluated and the size of the array it evaluates to is calculated at run time.</source>
          <target state="translated">표현식 유형이 &lt;a href=&quot;array&quot;&gt;가변 길이 배열&lt;/a&gt; 유형 인 경우 표현식이 평가되고 평가되는 배열의 크기는 런타임에 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="12f6e191f6df5a1a3c1898e9217cac07ed6c3fc9" translate="yes" xml:space="preserve">
          <source>If the type of the expression is different from the return type of the function, its value is &lt;a href=&quot;conversion&quot;&gt;converted&lt;/a&gt; as if by assignment to an object whose type is the return type of the function, except that overlap between object representations is permitted:</source>
          <target state="translated">표현식의 유형이 함수의 리턴 유형과 다른 경우, 오브젝트 표현 간의 겹침이 허용되는 경우를 제외하고는 유형이 함수의 리턴 유형 인 오브젝트에 지정하는 것처럼 값이 &lt;a href=&quot;conversion&quot;&gt;변환&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="translated">&lt;code&gt;ap&lt;/code&gt; (프로모션 후) 의 다음 인수 유형이 &lt;code&gt;T&lt;/code&gt; 와 호환 되지 않으면 다음과 같은 경우를 제외하고 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bd916ae26104ecdafe1a0e5b920d8734a873e18" translate="yes" xml:space="preserve">
          <source>If the type pointed to by the left operand is &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified, the result is also qualified. If the type pointed to by the left operand is &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">왼쪽 피연산자가 가리키는 유형이 &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; 또는 &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; Qualified 인 경우 결과도 규정됩니다. 왼쪽 피연산자가 가리키는 유형이 &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e5a8e1c4de47df9c049e89509b9c8c93ba2202d" translate="yes" xml:space="preserve">
          <source>If the types after promotion are the same, that type is the common type</source>
          <target state="translated">승격 후 유형이 동일하면 해당 유형이 공통 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9c7f76fec0807385297b756f7fec7a2af0fab97f" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; 를 처리 할 때 사용자 정의 함수가 반환되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a38ca87a09a320d9b2a80a0bbdbced081dc9f136" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="translated">사용자 정의 신호 처리 전략이 아직 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt; 사용하여 설정되지 않은 경우 신호가 무시되는지 또는 기본 처리기가 호출되는지 여부는 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ec13f6251a6825cdac88c61231a28276817e1093" translate="yes" xml:space="preserve">
          <source>If the value can be represented by the target type exactly, it is unchanged</source>
          <target state="translated">대상 유형으로 값을 정확하게 표현할 수 있으면 변경되지 않습니다</target>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;​0​&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="translated">염기의 값인 경우 &lt;code&gt;​0​&lt;/code&gt; , 숫자베이스는 자동으로 탐지 : 접두어 인 경우 &lt;code&gt;0&lt;/code&gt; 접두어 인 경우, 기지국은 진수이다 &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; ,베이스 16 진수이고, 그렇지 않으면베이스 소수점이다.</target>
        </trans-unit>
        <trans-unit id="7334be53a3a6aead6e653493f846debd16efe6cb" translate="yes" xml:space="preserve">
          <source>If the value of the integer constant is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;), the constant may be given the extended integer type; otherwise, the program is ill-formed.</source>
          <target state="translated">정수 상수의 값이 접미사 / 기본 조합에 의해 허용되는 유형에 맞지 않을 정도로 너무 크고 컴파일러가 확장 정수 유형 (예 : &lt;code&gt;__int128&lt;/code&gt; )을 지원하는 경우 상수에 확장 정수 유형이 제공 될 수 있습니다. 그렇지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="translated">&lt;code&gt;*exp&lt;/code&gt; 에 저장 될 값 이 &lt;code&gt;int&lt;/code&gt; 범위를 벗어나 면 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">생성 된 와이드 문자가 널 문자 인 경우 변환 상태 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="translated">생성 된 와이드 문자가 널 문자 인 경우 &lt;code&gt;*ps&lt;/code&gt; 에 저장된 변환 상태 는 초기 시프트 상태입니다.</target>
        </trans-unit>
        <trans-unit id="ed6eb838a4bf569f0ac9d8a6b0442beca067eff8" translate="yes" xml:space="preserve">
          <source>If there are no definitions in the same translation unit, then the tentative definition acts as an actual definition with the initializer &lt;code&gt;= 0&lt;/code&gt; (or, for array, structure, and union types, &lt;code&gt;= {0}&lt;/code&gt;).</source>
          <target state="translated">동일한 변환 단위에 정의가없는 경우 임시 정의는 initializer &lt;code&gt;= 0&lt;/code&gt; (또는 배열, 구조 및 공용체 유형의 경우 &lt;code&gt;= {0}&lt;/code&gt; ) 을 사용하여 실제 정의로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5ad5bb4cb8a4c8fd94ac2c60706e21c574d83a99" translate="yes" xml:space="preserve">
          <source>If there are threads waiting on &lt;code&gt;cond&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 대기중인 스레드가 있으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88ca6553aa1a0106ab7a752d78d47abe8b72c1f7" translate="yes" xml:space="preserve">
          <source>If there are threads waiting on &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;mutex&lt;/code&gt; 대기중인 스레드가 있으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61d2beb5e2bdfe94bb416348038a9626b5e9e8b4" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="translated">에 해당하는 전화가없는 경우 &lt;code&gt;va_start&lt;/code&gt; 를 또는 &lt;code&gt;va_copy&lt;/code&gt; 가 있는 경우, 또는 &lt;code&gt;va_end&lt;/code&gt; 의이 통화가 기능하기 전에 호출되지 않습니다 &lt;code&gt;va_start&lt;/code&gt; 를 또는 &lt;code&gt;va_copy&lt;/code&gt; 반환, 동작은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="translated">메모리가 충분하지 않으면 이전 메모리 블록이 해제되지 않고 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7516e91d5c31a3de2564cfd0a851bd2bacc6e3" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 작업 이있는 경우 X</target>
        </trans-unit>
        <trans-unit id="841f871b77e90b3c2ebee1d6abab2424892ee08b" translate="yes" xml:space="preserve">
          <source>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.</source>
          <target state="translated">두 개의 선언이 동일한 객체 또는 함수를 참조하고 호환 가능한 유형을 사용하지 않으면 프로그램의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="223e129549fa6e80a770c99896328737e1358c03" translate="yes" xml:space="preserve">
          <source>If two different entities named by the same identifier are in scope at the same time, and they belong to the same &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, the scopes are nested (no other form of scope overlap is allowed), and the declaration that appears in the inner scope hides the declaration that appears in the outer scope:</source>
          <target state="translated">동일한 식별자로 이름이 지정된 두 개의 다른 엔티티가 동시에 범위에 있고 동일한 &lt;a href=&quot;name_space&quot;&gt;이름 공간&lt;/a&gt; 에 속하는 경우 범위가 중첩되고 (다른 범위의 범위 중첩은 허용되지 않음) 내부 범위에 나타나는 선언 외부 범위에 나타나는 선언을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="9555605dc10e8d1cfa1ba2ec453aef90da3623dc" translate="yes" xml:space="preserve">
          <source>If two objects have the same object representation, they compare equal (except if they are floating-point NaNs). The opposite is not true: two objects that compare equal may have different object representations because not every bit of the object representation needs to participate in the value. Such bits may be used for padding to satisfy alignment requirement, for parity checks, to indicate trap representations, etc.</source>
          <target state="translated">두 객체의 객체 표현이 동일한 경우 부동 소수점 NaN 인 경우를 제외하고 동일하게 비교됩니다. 반대의 경우는 사실이 아닙니다. 동일하게 비교하는 두 객체는 ​​객체 표현의 모든 비트가 값에 참여할 필요가 없기 때문에 다른 객체 표현을 가질 수 있습니다. 이러한 비트는 패딩을 위해 정렬 요구 사항을 충족시키기 위해 패딩, 패리티 검사, 트랩 표현 등을 나타내는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98ae7c89c9a1f0579125868580a2c5d0580d1b22" translate="yes" xml:space="preserve">
          <source>If type is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; type and changing the value of its size expression would not affect the result of sizeof, it is unspecified whether or not the size expression is evaluated.</source>
          <target state="translated">type이 &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; 유형이고 size 표현식의 값을 변경해도 sizeof의 결과에 영향을 미치지 않으면 size 표현식의 평가 여부는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="daf8fb6ff7350d1f9d6d831812256477f230a799" translate="yes" xml:space="preserve">
          <source>If type is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; type, its size expression is not evaluated.</source>
          <target state="translated">type이 &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; 유형 인 경우 크기 표현식이 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45544c60e34e062c2ebe20cb821c8b11c8086f96" translate="yes" xml:space="preserve">
          <source>If type-name is &lt;code&gt;void&lt;/code&gt;, then expression is evaluated for its side-effects and its returned value is discarded, same as when expression is used on its own, as an &lt;a href=&quot;statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt;.</source>
          <target state="translated">type-name이 &lt;code&gt;void&lt;/code&gt; 인 경우 expression은 부작용에 대해 평가되며 expression이 자체적으로 &lt;a href=&quot;statements#Expression_statements&quot;&gt;표현식 명령문&lt;/a&gt; 으로 사용될 때와 같이 리턴 값이 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">wc가 널 와이드 문자 &lt;code&gt;L'\0'&lt;/code&gt; 인 경우, 초기 시프트 상태를 복원하는 데 필요한 시프트 시퀀스가 ​​앞에 오는 널 바이트가 저장되고 변환 상태 매개 변수 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타내도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="5d7984b921742f401d05ed8114115076c505fbda" translate="yes" xml:space="preserve">
          <source>If when &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; was called, a &lt;a href=&quot;../language/array&quot;&gt;VLA&lt;/a&gt; or another &lt;a href=&quot;../language/declarations&quot;&gt;variably-modified type&lt;/a&gt; variable was in scope and control left that scope, &lt;code&gt;longjmp&lt;/code&gt; to that &lt;code&gt;setjmp&lt;/code&gt; invokes undefined behavior even if control remained within the function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 가 호출 될 때 &lt;a href=&quot;../language/array&quot;&gt;VLA&lt;/a&gt; 또는 &lt;a href=&quot;../language/declarations&quot;&gt;가변적으로 수정 된&lt;/a&gt; 다른 유형 변수가 범위 내에 있고 제어가 해당 범위를 &lt;code&gt;longjmp&lt;/code&gt; 해당 &lt;code&gt;setjmp&lt;/code&gt; 에 대한longjmp 는 제어가 함수 내에 남아 있어도 정의되지 않은 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="translated">너비 지정자를 사용하는 경우 최대</target>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">x가 0이고 y가 무한하거나 x가 무한하고 y가 0이고 z가 NaN이면 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">x가 0이고 y가 무한하거나 x가 무한하고 y가 0이고 z가 NaN이 아닌 경우 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="translated">x 또는 y가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">x * y가 정확한 무한대이고 z가 반대 부호의 무한대이면 NaN이 반환되고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="translated">z가 NaN이고 x * y가 0 * ​​Inf 또는 Inf * 0이 아닌 경우 NaN이 반환됩니다 (FE_INVALID없이).</target>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="translated">| arg | 인 경우 &amp;gt; 1이면 도메인 오류가 발생하고 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">,에서 종료 널 문자를 복사 한 후 경우 &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 에 도달하지 못한 추가 널 문자에 기록됩니다 &lt;code&gt;dest&lt;/code&gt; 의 총까지 &lt;code&gt;count&lt;/code&gt; 문자가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">,에서 종료 널 (null) 와이드 문자 복사 한 후 경우 &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 에 도달하지 못한 추가 널 (null) 넓은 문자가 기록됩니다 &lt;code&gt;dest&lt;/code&gt; 의 총까지 &lt;code&gt;count&lt;/code&gt; 문자가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="80a00e268ece0e7d2466a182844868cebe8b45a3" translate="yes" xml:space="preserve">
          <source>If, after this, there remain keys with both non-null destructors and values (e.g. if a destructor executed &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;), the process is repeated up to &lt;code&gt;&lt;a href=&quot;tss_dtor_iterations&quot;&gt;TSS_DTOR_ITERATIONS&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="translated">이 후에도 널이 아닌 소멸자와 값이 모두있는 키가 남아 있으면 (예 : 소멸자가 &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; 을 실행 한 경우 ) 프로세스가 최대 &lt;code&gt;&lt;a href=&quot;tss_dtor_iterations&quot;&gt;TSS_DTOR_ITERATIONS&lt;/a&gt;&lt;/code&gt; 번 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">잘못된 바이트 시퀀스</target>
        </trans-unit>
        <trans-unit id="cbd90c1ef775b6befeb73f8b124d85864e006bb9" translate="yes" xml:space="preserve">
          <source>Imaginary floating types</source>
          <target state="translated">허수 부동 유형</target>
        </trans-unit>
        <trans-unit id="1d30ec43fa429c9d0766e648d3f7f8e3ad1d4ed4" translate="yes" xml:space="preserve">
          <source>Imaginary floating types model the mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary numbers&lt;/a&gt;, that is numbers that can be written as a real number multiplied by the imaginary unit: bi The three imaginary types are.</source>
          <target state="translated">허수 부동 유형은 수학 &lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;허수를&lt;/a&gt; 모델링합니다 . 즉, 허수로 곱할 수있는 실수로 쓸 수있는 숫자입니다. bi 세 허수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b1d3e8b209c294bf41ce4e3c74295f5bddf2df6e" translate="yes" xml:space="preserve">
          <source>Imaginary numbers are supported if &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; 가 정의 된 경우 허수가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ac24adafbd8260df30bab34514422a754478f65" translate="yes" xml:space="preserve">
          <source>Imaginary numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - * and /, possibly mixed with complex and real numbers. There are many mathematical functions defined for imaginary numbers in &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">허수는 &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자&lt;/a&gt; +-* 및 / 와 함께 사용될 수 있으며 , 가능하면 복소수와 실수로 혼합 될 수 있습니다. &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h의&lt;/a&gt; 허수에 대해 정의 된 많은 수학적 함수가 있습니다 . 내장 연산자와 라이브러리 함수 모두 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; 에&lt;/a&gt; 설명 된대로 부동 소수점 예외를 발생시키고 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071df3b35cc3962c55cc856d63ca45738b9079cf" translate="yes" xml:space="preserve">
          <source>Imaginary type conversions</source>
          <target state="translated">허수 변환</target>
        </trans-unit>
        <trans-unit id="c1671e6d41c5fac09c8aefb864f138445a7d1a21" translate="yes" xml:space="preserve">
          <source>Imaginary types also simplify implementations; multiplication of an imaginary by a complex can be implemented straightforwardly with two multiplications if the imaginary types are supported, instead of four multiplications and two additions.</source>
          <target state="translated">가상 유형은 구현을 단순화합니다. 허수의 곱셈과 두 개의 덧셈 대신 허수 유형이 지원되는 경우 허수에 의한 허수의 곱셈은 두 개의 곱셈으로 간단하게 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="translated">구현 정의 행동 제어</target>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">구현 정의 동작은 &lt;code&gt;#pragma&lt;/code&gt; 지시문에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">구현 정의 값. 경우 &lt;code&gt;command&lt;/code&gt; 널 포인터이며, 명령 프로세서가 존재하는 경우에만 경우, 제로가 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45a8270c1f150f433969e0be81b809f633b9a469" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text%2Fplain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="translated">구현은 일반적으로 &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt; , &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text%2Fplain&quot;&gt;BSD&lt;/a&gt; , &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt; 와 같은 1ulp ( 마지막 위치의 단위) 미만의 정밀도를 보장 합니다.</target>
        </trans-unit>
        <trans-unit id="0f38913e8ddeb1738019c4e8b2862059b04b95a9" translate="yes" xml:space="preserve">
          <source>Implicit conversion semantics</source>
          <target state="translated">암시 적 변환 의미론</target>
        </trans-unit>
        <trans-unit id="4f8e035635a982fad59fd7e5400a816066289eb5" translate="yes" xml:space="preserve">
          <source>Implicit conversion, whether</source>
          <target state="translated">암시 적 변환 여부</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">암시 적 변환</target>
        </trans-unit>
        <trans-unit id="bfcc4d9c93f1e4e027da44f6460a88f24fa14bab" translate="yes" xml:space="preserve">
          <source>Implicit initialization</source>
          <target state="translated">암시 적 초기화</target>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="translated">2의 보수 시스템에서 가장 음의 값의 절대 값이 범위를 벗어났습니다 (예 : 32 비트 2의 보수 유형 int의 경우 INT_MIN은 -2147483648이지만 결과는 2147483648은 INT_MAX보다 큽니다)는 2147483647입니다.</target>
        </trans-unit>
        <trans-unit id="00e7a8610b1ed817d9eb7670aae30608024360a9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;scalar_initialization&quot;&gt;scalar initialization&lt;/a&gt;, the value of the initializer expression is converted to the unqualified type of the object being initialized</source>
          <target state="translated">에서는 &lt;a href=&quot;scalar_initialization&quot;&gt;스칼라 초기화&lt;/a&gt; 는 초기화 식의 값이 초기화되는 객체의 규정되지 않은 형식으로 변환되고</target>
        </trans-unit>
        <trans-unit id="07197e53e1c1900f95e26e0b0ed8484511ced3aa" translate="yes" xml:space="preserve">
          <source>In C++, assignment operators are lvalue expressions, not so in C.</source>
          <target state="translated">C ++에서 대입 연산자는 C가 아닌 lvalue 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="6e1eee7ba9e6a0e28c2ac33889b5015519c15749" translate="yes" xml:space="preserve">
          <source>In C++, ordinary character constants have type &lt;code&gt;char&lt;/code&gt;, rather than &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">C ++에서 일반 문자 상수는 &lt;code&gt;int&lt;/code&gt; 가 아닌 &lt;code&gt;char&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f90570f1ba0f2c22b611733a6dce8d3bfd3291e7" translate="yes" xml:space="preserve">
          <source>In C++, the &lt;code&gt;alignas&lt;/code&gt; specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using alignas in a member declaration (as of DR 444).</source>
          <target state="translated">C ++에서 &lt;code&gt;alignas&lt;/code&gt; 지정자는 클래스 / struct / union 유형 및 열거의 선언에도 적용될 수 있습니다. C에서는 지원되지 않지만 struct 유형의 정렬은 멤버 선언에서 alignas를 사용하여 제어 할 수 있습니다 (DR 444 기준).</target>
        </trans-unit>
        <trans-unit id="16b073c98afd277d979d0d1b7c6ad0620c603d70" translate="yes" xml:space="preserve">
          <source>In C++, the conditional operator has the same precedence as assignment operators, and prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; and assignment operators don't have the restrictions about their operands.</source>
          <target state="translated">C ++에서 조건부 연산자는 대입 연산자와 우선 순위가 동일하며 접두사 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 와 대입 연산자에는 피연산자에 대한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="be29bb247378721617bd09a6c37e9883befb6d2c" translate="yes" xml:space="preserve">
          <source>In C++, unary operator + can also be used with other built-in types such as arrays and functions, not so in C.</source>
          <target state="translated">C ++에서 단항 연산자 +는 C가 아닌 배열 및 함수와 같은 다른 내장 유형과 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="888861ed244a4e6c1b00d2e50051a54c4e1bec80" translate="yes" xml:space="preserve">
          <source>In C, the braced list of an initializer cannot be empty. C++ allows empty list:</source>
          <target state="translated">C에서 이니셜 라이저의 중괄호로 묶인 목록은 비워 둘 수 없습니다. C ++에서는 빈 목록을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="753a99a5b8f4f54ed3b2aae026243d00a9149dad" translate="yes" xml:space="preserve">
          <source>In C, the braced list of initializers cannot be empty (note that C++ allows empty lists, and also note that a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; in C cannot be empty):</source>
          <target state="translated">C에서 괄호로 묶은 이니셜 라이저 목록은 비워 둘 수 없습니다 (C ++에서는 빈 목록을 허용하고 C의 &lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 는 비워 둘 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="4df80b3a143adc8cece1ace5ccec2ef9426cb010" translate="yes" xml:space="preserve">
          <source>In C11 as published, unlike &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt;, which converts variable-width multibyte (such as UTF-8) to variable-width 16-bit (such as UTF-16) encoding, this function can only convert single-unit 16-bit encoding, meaning it cannot convert UTF-16 to UTF-8 despite that being the original intent of this function. This was corrected by the post-C11 defect report &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/WG14/www/docs/summary.htm#dr_488&quot;&gt;DR488&lt;/a&gt;.</source>
          <target state="translated">C11에서 게시 된 &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;mbrtoc16&lt;/a&gt;&lt;/code&gt; , UTF-8과 같은 가변 너비 멀티 바이트를 UTF-16과 같은 가변 너비 16 비트로 변환하는 mbrtoc16 과 달리이 함수는 단일 단위 16 비트 인코딩 만 변환 할 수 있습니다. 즉,이 기능의 원래 의도에도 불구하고 UTF-16을 UTF-8로 변환 할 수 없습니다. 이것은 C11 이후 결함 보고서 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/WG14/www/docs/summary.htm#dr_488&quot;&gt;DR488에&lt;/a&gt; 의해 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bfa2fd46abee60000979a7c0d0195215fe83ddb7" translate="yes" xml:space="preserve">
          <source>In C89, declarations within any &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (block scope) must appear in the beginning of the block, before any &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt;.</source>
          <target state="translated">C89에서 &lt;a href=&quot;statements#Compound_statements&quot;&gt;복합 명령문&lt;/a&gt; (블록 범위) 내의 선언은 명령문 앞에 블록의 시작 부분에 나타나야 &lt;a href=&quot;statements&quot;&gt;합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5afc6f0bbafec1d95aa424d9ab7eafe8f8a41cd" translate="yes" xml:space="preserve">
          <source>In C89, specifiers-and-qualifiers was optional, and if omitted, the return type of the function defaulted to &lt;code&gt;int&lt;/code&gt; (possibly amended by the declarator).</source>
          <target state="translated">C89에서 지정자 및 한정자는 선택 사항이며 생략하면 함수의 반환 유형은 기본적으로 &lt;code&gt;int&lt;/code&gt; 로 설정되었습니다 (선언자가 수정했을 수 있음).</target>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">IS0에서 8601주는 월요일부터 시작하여 일년의 첫주는 다음 요구 사항을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5f53a8b39a3373273d1bd5448850b45c7282a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;operator_other&quot;&gt;function-call expression&lt;/a&gt;, to a function that has a prototype, the value of each argument expression is converted to the type of the unqualified declared types of the corresponding parameter</source>
          <target state="translated">(A)에 &lt;a href=&quot;operator_other&quot;&gt;기능 호출 식&lt;/a&gt; 프로토 타입을 가지는 함수로, 각 인수 식의 값은 해당 변수의 선언 규정되지 않은 형태의 형식으로 변환되고</target>
        </trans-unit>
        <trans-unit id="e543016c2da1dbc421ea862e63a18dfd16a6409d" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call expression&lt;/a&gt; when the call is made to.</source>
          <target state="translated">A의 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출 식&lt;/a&gt; 통화가 이루어질 때까지.</target>
        </trans-unit>
        <trans-unit id="b3db14f2b46d8b0aa95c66919fa6a6c2e01549c3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, the value of the operand of &lt;code&gt;return&lt;/code&gt; is converted to an object having the return type of the function</source>
          <target state="translated">A의 &lt;a href=&quot;return&quot;&gt;리턴 명령문&lt;/a&gt; 의 피연산자의 값 &lt;code&gt;return&lt;/code&gt; 함수의 리턴 형을 갖는 오브젝트로 변환되고</target>
        </trans-unit>
        <trans-unit id="f1afbd501ff06c0957f44b840912fccdb54dcc9f" translate="yes" xml:space="preserve">
          <source>In a C program, the declarations referring to the same object or function in</source>
          <target state="translated">C 프로그램에서 동일한 객체 또는 함수를 참조하는 선언</target>
        </trans-unit>
        <trans-unit id="dcb8b0b9734c917ca0765e9a7a94eaa46af9b402" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;const&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</source>
          <target state="translated">함수 선언에서 키워드 &lt;code&gt;const&lt;/code&gt; 는 함수 매개 변수의 배열 유형을 선언하는 데 사용되는 대괄호 안에 나타날 수 있습니다. 배열 유형이 변환되는 포인터 유형을 규정합니다.</target>
        </trans-unit>
        <trans-unit id="9b54013284053a729eab7abaa9d5a083da83f62f" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;restrict&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed:</source>
          <target state="translated">함수 선언에서 키워드 &lt;code&gt;restrict&lt;/code&gt; 는 함수 매개 변수의 배열 유형을 선언하는 데 사용되는 대괄호 안에 나타날 수 있습니다. 배열 유형이 변환되는 포인터 유형을 규정합니다.</target>
        </trans-unit>
        <trans-unit id="91f77fb9039b1b47cdb217206e779839523dbb48" translate="yes" xml:space="preserve">
          <source>In a function declaration, the keyword &lt;code&gt;volatile&lt;/code&gt; may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</source>
          <target state="translated">함수 선언에서 &lt;code&gt;volatile&lt;/code&gt; 키워드 는 함수 매개 변수의 배열 유형을 선언하는 데 사용되는 대괄호 안에 나타날 수 있습니다. 배열 유형이 변환되는 포인터 유형을 규정합니다.</target>
        </trans-unit>
        <trans-unit id="661f71b2988adf25d44185c62a4b846d68c48b5c" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="translated">파일 위치 표시기를 변경하는 것 외에도 &lt;code&gt;fseek&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; 의 효과를 취소하고 적용 가능한 경우 파일 끝 상태를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="b35dbcc1e0f0f5cd4a002df2770d4491982f6eca" translate="yes" xml:space="preserve">
          <source>In addition to the complex types, the three imaginary types may be supported: &lt;code&gt;double _Imaginary&lt;/code&gt;, &lt;code&gt;float _Imaginary&lt;/code&gt;, and &lt;code&gt;long double _Imaginary&lt;/code&gt; (see &lt;a href=&quot;../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt;). When the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; is included, the three imaginary types are also accessible as &lt;code&gt;double imaginary&lt;/code&gt;, &lt;code&gt;float imaginary&lt;/code&gt;, and &lt;code&gt;long double imaginary&lt;/code&gt;.</source>
          <target state="translated">복소수 유형 외에도 &lt;code&gt;double _Imaginary&lt;/code&gt; , &lt;code&gt;float _Imaginary&lt;/code&gt; 및 &lt;code&gt;long double _Imaginary&lt;/code&gt; ( &lt;a href=&quot;../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt; 참조 ) 의 세 가지 가상 유형이 지원 될 수 있습니다 . 헤더 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 가 포함되면 3 개의 허수 유형은 &lt;code&gt;double imaginary&lt;/code&gt; , &lt;code&gt;float imaginary&lt;/code&gt; 및 &lt;code&gt;long double imaginary&lt;/code&gt; 로도 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96d044a1b0cd5e52efeec3c718c75e91fa8170ae" translate="yes" xml:space="preserve">
          <source>In addition to the implicit conversions, the following conversions are allowed:</source>
          <target state="translated">암시 적 변환 외에도 다음과 같은 변환이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="55f680af8a4672d6d70c077e3b55562b152fd0d3" translate="yes" xml:space="preserve">
          <source>In addition, old-style definition didn't require a declaration for every parameter in declaration-list. Any parameter whose declaration was missing had type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">또한 구식 정의에는 선언 목록의 모든 매개 변수에 대한 선언이 필요하지 않았습니다. 선언이 누락 된 모든 매개 변수의 유형은 &lt;code&gt;int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="translated">또한, 휘발성 액세스는 원자 적이 지 않으며 (동시 읽기 및 쓰기는 &lt;a href=&quot;../language/memory_model&quot;&gt;데이터 경쟁입니다&lt;/a&gt; ) 메모리를 정렬하지 않습니다 (비 휘발성 메모리 액세스는 휘발성 액세스를 중심으로 자유롭게 재정렬 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">다른 모든 경우에는 결과가 정확하고 ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 는 절대 발생하지 않음) &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드&lt;/a&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2caa1bc25941d7d072a18d3a94ff53e51be29ee7" translate="yes" xml:space="preserve">
          <source>In any case (both when executing an implicit conversion and in the same-type cast), if expression and type-name are floating types and expression is represented with greater range and precision than its type indicates (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;, the range and precision are stripped off to match the target type.</source>
          <target state="translated">어쨌든 (암시 적 변환을 실행하고 동일한 유형의 캐스트로 수행 할 때) expression 및 type-name이 부동 유형이고 expression이 유형이 나타내는 것보다 더 큰 범위 및 정밀도로 표현되는 경우 ( &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조 , 범위 및 정밀도는 대상 유형에 맞게 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="922077a331c0fe9a078f343032d119067ea97aa1" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;gets_s&lt;/code&gt; first finishes reading and discarding the characters from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; until new-line character, end-of-file condition, or read error before calling the constraint handler.</source>
          <target state="translated">어떤 경우에는, &lt;code&gt;gets_s&lt;/code&gt; 첫째 마감은 읽기에서 문자를 폐기 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 을 제약 핸들러를 호출하기 전에 개행 문자, 파일 끝 조건, 또는 읽기 오류까지.</target>
        </trans-unit>
        <trans-unit id="c1fd722202cbcd28513d3d1f6696d6cc82e484b7" translate="yes" xml:space="preserve">
          <source>In any case, the behavior is undefined if rhs is negative or is greater or equal the number of bits in the promoted lhs.</source>
          <target state="translated">어쨌든 rhs가 음수이거나 승격 된 lhs의 비트 수보다 크거나 같은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d317d4e7fe2ec42ae19ec71757d499c2504a3bd1" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">대조적 &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;fmod()&lt;/a&gt;&lt;/code&gt; , 리턴 값은 같은 부호가 보장되지 않고 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7448c71f37984dda228a612a7fe2cff9d0abde9" translate="yes" xml:space="preserve">
          <source>In each &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt; to a function where a parameter of array type uses the keyword &lt;code&gt;static&lt;/code&gt; between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by expression:</source>
          <target state="translated">배열 유형의 매개 변수가 &lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt; 사이에 &lt;code&gt;static&lt;/code&gt; 키워드를 사용하는 함수에 대한 각 &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출&lt;/a&gt; 에서 실제 매개 변수의 값은 표현식에 지정된 수 이상의 요소를 가진 배열의 첫 번째 요소에 대한 유효한 포인터 여야합니다. :</target>
        </trans-unit>
        <trans-unit id="9c2dc65fa3365dda17e8625d8d61e8a47bb9b9f7" translate="yes" xml:space="preserve">
          <source>In function parameter lists, additional syntax elements are allowed within the array declarators: the keyword &lt;code&gt;static&lt;/code&gt; and qualifiers, which may appear in any order before the size expression (they may also appear even when the size expression is omitted).</source>
          <target state="translated">함수 매개 변수 목록에서 배열 선언자 내에 추가 구문 요소를 사용할 수 있습니다. 키워드 &lt;code&gt;static&lt;/code&gt; 및 한정자는 크기 표현식 이전에 임의의 순서로 나타날 수 있습니다 (크기 표현식이 생략 된 경우에도 나타날 수 있음).</target>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="translated">함수형 매크로 에서 교체 목록의 식별자 앞에 있는 &lt;code&gt;#&lt;/code&gt; 연산자는 매개 변수 교체를 통해 식별자를 실행하고 결과를 따옴표로 묶어 문자열 리터럴을 효과적으로 만듭니다. 또한 프리 프로세서는 백 슬래시를 추가하여 임베드 된 문자열 리터럴을 둘러싼 따옴표를 이스케이프하고 필요한 경우 문자열 내 백 슬래시를 두 배로 늘립니다. 모든 선행 및 후행 공백이 제거되고 텍스트 중간에 포함 된 문자열 리터럴은 포함되지 않지만 일련의 공백은 단일 공백으로 축소됩니다. 이 작업을 &quot;문자열&quot;이라고합니다. 문자열 화 결과가 유효한 문자열 리터럴이 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dfc6aa82ba3fea48c1670a0af39cb7ef3825072" translate="yes" xml:space="preserve">
          <source>In general, it is best to explicitly annotate all non-aliasing pointers in a function's prototype with &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="translated">일반적으로, 명시 적으로 함수의 프로토 타입이 아닌 모든 앨리어싱 포인터를 주석하는 것이 가장 좋습니다 &lt;code&gt;restrict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62ceb0117e9441fc64ed53290699d0b67f04e8ec" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;&lt;a href=&quot;isupper&quot;&gt;isupper()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;islower&quot;&gt;islower()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; or any other character considered alphabetic by the locale. In any case, &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace()&lt;/a&gt;&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; for this character.</source>
          <target state="translated">&lt;code&gt;&quot;C&quot;&lt;/code&gt; 이외의 로케일 에서 알파벳 문자는 &lt;code&gt;&lt;a href=&quot;isupper&quot;&gt;isupper()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;islower&quot;&gt;islower()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 또는 로케일에 의해 알파벳으로 간주되는 다른 문자를 리턴 하는 문자입니다. 어쨌든 &lt;code&gt;&lt;a href=&quot;iscntrl&quot;&gt;iscntrl()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;isdigit&quot;&gt;isdigit()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ispunct&quot;&gt;ispunct()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;isspace&quot;&gt;isspace()&lt;/a&gt;&lt;/code&gt; 는 이 문자에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="21197e17c12cb14335ae7b60ed08fcc011dd80c7" translate="yes" xml:space="preserve">
          <source>In most implementations, &lt;code&gt;mbstowcs&lt;/code&gt; updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">대부분의 구현에서 &lt;code&gt;mbstowcs&lt;/code&gt; 는 문자열을 통해 처리 할 때 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 전역 정적 객체를 업데이트하며 두 스레드에서 동시에 호출 할 수 없으므로 이러한 경우 &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa210a80b121c6a39599abbc8fbfc9c320d9bc24" translate="yes" xml:space="preserve">
          <source>In most implementations, &lt;code&gt;wcstombs&lt;/code&gt; updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;wcstombs_s&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">대부분의 구현에서 &lt;code&gt;wcstombs&lt;/code&gt; 는 문자열을 통해 처리 할 때 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; 유형의 글로벌 정적 오브젝트를 업데이트하며 두 개의 스레드에 의해 동시에 호출 될 수 없으며, 이러한 경우 &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;wcstombs_s&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cfb207d137efe07d54c5a87d7de6e2d7e3aeedc" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all members of a struct, padding may be inserted after some of its members.</source>
          <target state="translated">구조체의 모든 멤버의 정렬 요구 사항을 충족시키기 위해 일부 멤버 뒤에 패딩이 삽입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9475e6740d71cf18882ad4ded3421afd3ec16ba4" translate="yes" xml:space="preserve">
          <source>In order to support the one-infinity model of complex number arithmetic, C regards any complex value with at least one infinite part as an infinity even if its other part is a NaN, guarantees that all operators and functions honor basic properties of inifinities and provides &lt;code&gt;&lt;a href=&quot;../numeric/complex/cproj&quot;&gt;cproj&lt;/a&gt;&lt;/code&gt; to map all infinities to the canonical one (see &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; for the exact rules).</source>
          <target state="translated">복소수 산술의 1- 무한 모델을 지원하기 위해 C는 다른 부분이 NaN 인 경우에도 적어도 하나의 무한 부분을 갖는 복소수 값을 무한대로 간주하고 모든 연산자와 함수가 inifinity의 기본 속성을 존중하며 &lt;code&gt;&lt;a href=&quot;../numeric/complex/cproj&quot;&gt;cproj&lt;/a&gt;&lt;/code&gt; 는 모든 무한대를 정식으로 매핑합니다 ( 정확한 규칙 은 &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="76e64f99329b8a6a167edfe1e65c3955c2a72145" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="translated">일부 멀티 바이트 인코딩에서, 임의의 주어진 멀티 바이트 문자 시퀀스는 &quot;시프트 시퀀스&quot;로 알려진 이전 바이트 시퀀스에 따라 다른 문자를 나타낼 수있다. 이러한 인코딩은 상태에 따라 다릅니다. 각 문자를 해석하려면 현재 이동 상태에 대한 지식이 필요합니다. NTMBS는 초기 시프트 상태에서 시작하고 끝나는 경우에만 유효합니다. 시프트 시퀀스가 ​​사용 된 경우 해당 언 시프트 시퀀스가 ​​종료 널 문자 앞에 있어야합니다. 이러한 인코딩의 예는 BOCU-1 및 &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="923c56b33566854301ad01db35301650d917bde7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of a function declaration, the</source>
          <target state="translated">함수 선언 의 &lt;a href=&quot;declarations&quot;&gt;선언 문법&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="8c6915549e0ea7f2ed3d86650796bfe49408367b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of a pointer declaration, the</source>
          <target state="translated">포인터 선언 의 &lt;a href=&quot;declarations&quot;&gt;선언 문법&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="5208b652452c725f5ac915c0c967fc1e2b74e39b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt; of an array declaration, the</source>
          <target state="translated">배열 선언 의 &lt;a href=&quot;declarations&quot;&gt;선언 문법&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="113533a0b69ca7bb102b7ddcf07a25f608ef6a71" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt; operator, the value of the right-hand operand is converted to the unqualified type of the left-hand operand.</source>
          <target state="translated">에 &lt;a href=&quot;operator_assignment&quot;&gt;할당&lt;/a&gt; 연산자 오른쪽의 값이 피연산자 좌측 피연산자의 규정되지 않은 형식으로 변환된다.</target>
        </trans-unit>
        <trans-unit id="f26b71cad718a75aa0f6d4d4ddf1273333394594" translate="yes" xml:space="preserve">
          <source>In the C++ programming language, the width of a bit field can exceed the width of the underlying type.</source>
          <target state="translated">C ++ 프로그래밍 언어에서 비트 필드의 너비는 기본 유형의 너비를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="975e4fe6f239aebda10cf0cf1e080b0c6fa23395" translate="yes" xml:space="preserve">
          <source>In the case the file is not found, the program is ill-formed.</source>
          <target state="translated">파일을 찾을 수없는 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="translated">기본 &quot;C&quot;로케일에서 다음 소문자 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 는 각각의 대문자 &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="translated">기본 &quot;C&quot;로케일에서 다음 대문자 &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 는 각각의 소문자 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="69d5da7e7c8f4ddf2ba06176a0324f7f725a9426" translate="yes" xml:space="preserve">
          <source>In the following contexts, the comma operator cannot appear at the top level of an expression because the comma has a different meaning:</source>
          <target state="translated">다음 컨텍스트에서 쉼표는 다른 의미로 인해 쉼표 연산자가 표현식의 최상위 레벨에 나타날 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc33863a538f837ccafd624f0573864c0519ef07" translate="yes" xml:space="preserve">
          <source>In the following example, the compiler may infer that there is no aliasing of modified objects, and so optimize the loop aggressively. Upon entry to f, the restricted pointer a must provide exclusive access to its associated array. In particular, within f neither b nor c may point into the array associated with a, because neither is assigned a pointer value based on a. For b, this is evident from the const-qualifier in its declaration, but for c, an inspection of the body of f is required:</source>
          <target state="translated">다음 예제에서 컴파일러는 수정 된 객체의 앨리어싱이 없음을 유추하여 루프를 적극적으로 최적화 할 수 있습니다. f에 진입하면, 제한된 포인터 a는 관련 배열에 배타적 액세스를 제공해야합니다. 특히, f 내에서 b 또는 c는 a에 기초한 포인터 값이 할당되지 않기 때문에 a와 연관된 어레이를 가리킬 수 없다. b의 경우 선언에서 const 한정자에서 분명하지만 c의 경우 f 본문을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="d658bebea04040340fda6a99bf9ac52ca6b05755" translate="yes" xml:space="preserve">
          <source>In the form (2), if expression compares equal to the integer zero, statement_false is executed.</source>
          <target state="translated">(2) 형식에서 expression이 정수 0과 같으면 statement_false가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="044aceb384f674b4556f403f792d0db3bee99f91" translate="yes" xml:space="preserve">
          <source>In this example there is a system call of the unix command &lt;b&gt;date +%A&lt;/b&gt;:</source>
          <target state="translated">이 예에서는 unix 명령 &lt;b&gt;날짜 + % A&lt;/b&gt; 의 시스템 호출이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0d690c603a9d7a62cca51dfee4caa9018dac758" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the number of elements in the destination array.</source>
          <target state="translated">일반적인 사용법에서 &lt;code&gt;count&lt;/code&gt; 는 대상 배열의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="666e665b91e221551332cdb922f39d26d34652a4" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="translated">일반적인 사용법에서 입력 스트림 처리는 오류가 발생하면 중지됩니다. 그런 다음 &lt;code&gt;feof&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;ferror&lt;/a&gt;&lt;/code&gt; 는 서로 다른 오류 조건을 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7499c4ef48e0f11187d8d33c914d276969727d9" translate="yes" xml:space="preserve">
          <source>In update mode ('+'), both input and output may be performed, but output cannot be followed by input without an intervening call to &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt;, and input cannot be followed by output without an intervening call to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt;, unless the input operation encountered end of file. In update mode, implementations are permitted to use binary mode even when text mode is specified.</source>
          <target state="translated">업데이트 모드 ( '+')에서는 입력과 출력을 모두 수행 할 수 있지만 &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; 에 대한 중간 호출없이 출력 뒤에 입력을 수행 할 수 없으며 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt; 에 대한 중간 호출없이 입력 뒤에 출력을 수행 할 수 없습니다 입력 조작이 파일 끝을 발견하지 않는 한 , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; 업데이트 모드에서는 구현시 텍스트 모드가 지정된 경우에도 이진 모드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="translated">1 월 4 일 포함</target>
        </trans-unit>
        <trans-unit id="363fb406f419e21cfcda27deb409f2bd35c7c245" translate="yes" xml:space="preserve">
          <source>Includes another source file into the current source file at the line immediately after the directive.</source>
          <target state="translated">지시문 바로 다음 줄에서 다른 소스 파일을 현재 소스 파일에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="translated">연중 첫 번째 목요일 포함</target>
        </trans-unit>
        <trans-unit id="d416e56359c061d5140399f02320d85b725a461e" translate="yes" xml:space="preserve">
          <source>Includes source file, identified by filename, into the current source file at the line immediately after the directive.</source>
          <target state="translated">파일 이름으로 식별 된 소스 파일을 지시문 바로 다음 줄의 현재 소스 파일에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="49c0d7b0937da9c9ff367feeb084c4412b31121a" translate="yes" xml:space="preserve">
          <source>Incomplete types</source>
          <target state="translated">불완전한 유형</target>
        </trans-unit>
        <trans-unit id="a9f510244f4c40d947308a6a3b552dcfe82f8745" translate="yes" xml:space="preserve">
          <source>Increment and Decrement</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="5bc342f191d90350a10c27aa563d30c6fa0efd4e" translate="yes" xml:space="preserve">
          <source>Increment and decrement are not defined for complex types.</source>
          <target state="translated">복합 유형에 대해서는 증가 및 감소가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d451f27858a586b045ef8704174c2c47a9677b6d" translate="yes" xml:space="preserve">
          <source>Increment and decrement are not defined for imaginary types  &lt;a href=&quot;conversion&quot;&gt;Implicit conversions&lt;/a&gt; are defined between imaginary types and other arithmetic types.</source>
          <target state="translated">허수형에 대해서는 증가 및 감소가 정의되지 않습니다. &lt;a href=&quot;conversion&quot;&gt;허수형 변환&lt;/a&gt; 은 허수형 과 다른 산술 형식간에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4cab5961dc19e11a59ed503482594c2617dde8e5" translate="yes" xml:space="preserve">
          <source>Increment operators initiate the side-effect of adding the value &lt;code&gt;1&lt;/code&gt; of appropriate type to the operand. Decrement operators initiate the side-effect of subtracting the value &lt;code&gt;1&lt;/code&gt; of appropriate type from the operand. As with any other side-effects, these operations complete at or before the next &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;. &lt;code&gt;int a = 1; int b = a++; // stores 1+a (which is 2) to a // returns the value of a (which is 1) // After this line, b == 1 and a == 2 a = 1; int c = ++a; // stores 1+a (which is 2) to a // returns 1+a (which is 2) // after this line, c == 2 and a == 2&lt;/code&gt;.</source>
          <target state="translated">증분 연산자 는 적절한 유형 의 값 &lt;code&gt;1&lt;/code&gt; 을 피연산자 에 추가하는 부작용을 시작합니다 . 감소 연산자 는 피연산자에서 적절한 유형 의 값 &lt;code&gt;1&lt;/code&gt; 을 빼는 부작용을 시작합니다 . 다른 부작용과 마찬가지로 이러한 작업은 다음 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 지점&lt;/a&gt; 또는 그 이전에 완료 됩니다 . &lt;code&gt;int a = 1; int b = a++; // stores 1+a (which is 2) to a // returns the value of a (which is 1) // After this line, b == 1 and a == 2 a = 1; int c = ++a; // stores 1+a (which is 2) to a // returns 1+a (which is 2) // after this line, c == 2 and a == 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="translated">증감 연산자</target>
        </trans-unit>
        <trans-unit id="40b0713cd16ef48a40d29fc9dad27332939e997e" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators are not defined for complex or imaginary types: the usual definition of adding/subtracting the real number 1 would have no effect on imaginary types, and making it add/subtract &lt;code&gt;i&lt;/code&gt; for imaginaries but &lt;code&gt;1&lt;/code&gt; for complex numbers would have made it handle &lt;code&gt;0+yi&lt;/code&gt; different from &lt;code&gt;yi&lt;/code&gt;.</source>
          <target state="translated">증분 / 감소 연산자는 복소수 또는 허수 유형에 대해 정의되지 않습니다. 실수 1을 더하거나 빼는 일반적인 정의는 허수 유형에 영향을 미치지 않으며 허수에 대해서는 &lt;code&gt;i&lt;/code&gt; 를 더하거나 빼지 만 복소수에 대해서는 &lt;code&gt;1&lt;/code&gt; 을 만들었습니다. 처리 &lt;code&gt;0+yi&lt;/code&gt; 다른 &lt;code&gt;yi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56e7713f236304a71ab92bc24bb388cf6138cc73" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators are unary operators that increment/decrement the value of a variable by 1.</source>
          <target state="translated">증감 연산자는 변수 값을 1 씩 증가 / 감소시키는 단항 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="1df30318ddb5ee41156f6bf21f1a90f429ea6a75" translate="yes" xml:space="preserve">
          <source>Indirection (dereference)</source>
          <target state="translated">간접 지정 (역 참조)</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="translated">부정확 한 결과</target>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="translated">부작용없는 무한 루프</target>
        </trans-unit>
        <trans-unit id="f3b3d9c9386379e588661aaa74e30dea9732f4b8" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt; 원자로드 조작으로 시작된 종속성 트리 가 &lt;code&gt;kill_dependency&lt;/code&gt; 의 리턴 값을지나 확장되지 않음을 컴파일러에 알립니다 . 즉, 인수는 리턴 값에 종속성을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="bda194cf9cabbb80afe8fa11968d57f4d61e8056" translate="yes" xml:space="preserve">
          <source>Initialization from brace-enclosed lists</source>
          <target state="translated">중괄호로 묶은 목록에서 초기화</target>
        </trans-unit>
        <trans-unit id="809dbf840669bbee858fa37fe2063537d8ea1dc8" translate="yes" xml:space="preserve">
          <source>Initialization from strings</source>
          <target state="translated">문자열에서 초기화</target>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="translated">모든 비트를 0으로 초기화한다고해서 부동 소수점 또는 포인터가 각각 0.0과 널 포인터 값으로 초기화되는 것은 아닙니다 (모든 공통 플랫폼에서 적용됨).</target>
        </trans-unit>
        <trans-unit id="dcd64bec39ad6d832e7fd656dfbaa3b5fb1da8e8" translate="yes" xml:space="preserve">
          <source>Initializers cannot be used in declarations of objects of incomplete type, VLAs, and block-scope objects with linkage.</source>
          <target state="translated">이니셜 라이저는 불완전한 유형의 객체, VLA 및 링크가있는 블록 범위 객체의 선언에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af07b8353132a535b78017dad8822a72315ba75e" translate="yes" xml:space="preserve">
          <source>Initializes new condition variable. The object pointed to by &lt;code&gt;cond&lt;/code&gt; will be set to value that identifies the condition variable.</source>
          <target state="translated">새로운 조건 변수를 초기화합니다. &lt;code&gt;cond&lt;/code&gt; 가 가리키는 오브젝트 는 조건 변수를 식별하는 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="translated">기본 구성된 원자 객체 &lt;code&gt;obj&lt;/code&gt; 를 &lt;code&gt;desired&lt;/code&gt; 값 으로 초기화합니다 . 이 기능은 원 자성이 아닙니다. 원자 연산을 통해 다른 스레드에서 동시 액세스하는 것은 데이터 경쟁입니다.</target>
        </trans-unit>
        <trans-unit id="7bb9ce0cdba5a821d492b917cf5fb720a0f90bd9" translate="yes" xml:space="preserve">
          <source>Inline assembly</source>
          <target state="translated">인라인 어셈블리</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="3b91932c5604be98b02beecc9f3294548420aed4" translate="yes" xml:space="preserve">
          <source>Integer arithmetic in &lt;code&gt;#if&lt;/code&gt;-expressions is performed using the semantics of &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; for signed types and &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt; for unsigned types.</source>
          <target state="translated"># &lt;code&gt;#if&lt;/code&gt; 표현식의 정수 산술은 부호있는 유형 의 경우 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; 및 부호없는 유형의 경우 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt; 의 의미를 사용하여 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="00fca0cb45c563b4aca1c728dcaf7bb27ee388bc" translate="yes" xml:space="preserve">
          <source>Integer constant expression</source>
          <target state="translated">정수 상수 표현식</target>
        </trans-unit>
        <trans-unit id="bac8890b103516222490d7d9d18bdba5cbf90f36" translate="yes" xml:space="preserve">
          <source>Integer constant expressions are evaluated at compile time. The following contexts require expressions that are known as</source>
          <target state="translated">정수 상수 표현식은 컴파일 타임에 평가됩니다. 다음 컨텍스트에는 다음과 같은 표현식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0d17a9e0dc1e0be7fcf770a93ca094014147b164" translate="yes" xml:space="preserve">
          <source>Integer constants</source>
          <target state="translated">정수 상수</target>
        </trans-unit>
        <trans-unit id="eb8a7869f4f02b2ddb556d447ca9969842e11b2b" translate="yes" xml:space="preserve">
          <source>Integer constants may be used in &lt;a href=&quot;constant_expression&quot;&gt;integer constant expressions&lt;/a&gt;.</source>
          <target state="translated">정수 상수는 &lt;a href=&quot;constant_expression&quot;&gt;정수 상수 표현식에&lt;/a&gt; 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f01db8c35bcc24ed074568092a7ec4baacf74ca" translate="yes" xml:space="preserve">
          <source>Integer conversions</source>
          <target state="translated">정수 변환</target>
        </trans-unit>
        <trans-unit id="566c223f31851f66caf3368111c90cc6e99a86cf" translate="yes" xml:space="preserve">
          <source>Integer promotion is the implicit conversion of a value of any integer type with</source>
          <target state="translated">정수 승격은 다음과 같이 정수 유형의 값을 암시 적으로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b32622daf07fbe0a8ed0fe3f161a8d872f055bce" translate="yes" xml:space="preserve">
          <source>Integer promotions</source>
          <target state="translated">정수 프로모션</target>
        </trans-unit>
        <trans-unit id="14fa9d849ba5cc455c138e12e0153e7279624dff" translate="yes" xml:space="preserve">
          <source>Integer promotions preserve the value, including the sign:</source>
          <target state="translated">정수 승격은 부호를 포함하여 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4d364bae64d134436bc38477b2370e7d602b048e" translate="yes" xml:space="preserve">
          <source>Integer to pointer implicit &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt;.</source>
          <target state="translated">포인터 암시 적 &lt;a href=&quot;conversion&quot;&gt;변환에 대한&lt;/a&gt; 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="6c8b2db07fe3fe6b10f79300cc2e4c847fac9fa0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs (&lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ERANGE&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 해당 리턴 유형의 범위를 벗어나면 범위 오류가 발생하고 ( &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;ERANGE&lt;/code&gt; 로 설정 됨 ) &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52e4539e8037f8f852f5856d00606b776679d442" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 반환 유형의 대응 범위를 벗어나게되면 범위 에러가 발생하고 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;​0​&lt;/code&gt; 적절하게 복귀된다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="037211edd9f543a6e3e5973c9289bff663b3846a" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 해당 리턴 유형의 범위를 벗어나면 범위 오류가 발생하고 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; 이 리턴됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="30a62fa780cc981f83f6721bd337ae1c720db4eb" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 해당 리턴 유형의 범위를 벗어나면 범위 오류가 발생하고 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21098bb738833ee0f4f792151a59d559da8ec6b0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 해당 반환 유형의 범위를 벗어나면 반환 값이 정의되지 않습니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="94bb86dba8d80a53634463b836c1b46d98acd2a7" translate="yes" xml:space="preserve">
          <source>Intel C++ compiler pragmas</source>
          <target state="translated">인텔 C ++ 컴파일러 실용</target>
        </trans-unit>
        <trans-unit id="9dac1e92729539ac11d8cad38e7bddd13ef84d39" translate="yes" xml:space="preserve">
          <source>Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">내부적으로 문자는 쓰기 직전 에 &lt;code&gt;unsigned char&lt;/code&gt; 문자로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4000ac517f025eca6a922c089403bb09186f8d96" translate="yes" xml:space="preserve">
          <source>International monetary numeric formatting parameters</source>
          <target state="translated">국제 통화 숫자 형식화 매개 변수</target>
        </trans-unit>
        <trans-unit id="bc48cbadb6a84efbed23317d93156122ffd8c740" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 넓은 문자열에서 부동 소수점 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="cd73986f45b4bdd6cb8af7f9c50d2ce721e60cf8" translate="yes" xml:space="preserve">
          <source>Interprets a floating-point value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열에서 부동 소수점 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="9a608036eb59f94001912ca3733a0c15c944b183" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nptr&lt;/code&gt; 이 가리키는 바이트 문자열의 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="566cf8ed0ac571b4f2aa3ca75d488875487baeb4" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열의 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="cc2bd5d023e90da3e1640fc0f66845e22f6c8508" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 넓은 문자열의 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="042a224facaad3cdf57ba7458290bd20ddbab9ab" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열에서 부호없는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="65b433c8b60cb3b8c5443581467dc0f6ae5b6523" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nptr&lt;/code&gt; 이 가리키는 넓은 문자열에서 부호없는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="148c33b3cec53bcad46f4795046e389f68465431" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 넓은 문자열에서 부호없는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="86c96ba7411037b346432868bfdb3e867290952c" translate="yes" xml:space="preserve">
          <source>Invalid scalar</source>
          <target state="translated">잘못된 스칼라</target>
        </trans-unit>
        <trans-unit id="bccd99d2661a6df322f59fa784d4f94059ba4e6f" translate="yes" xml:space="preserve">
          <source>Inverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventially placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.  The mathematical definition of the principal value of arc cosine is acos z =</source>
          <target state="translated">역 코사인 (또는 아크 코사인)은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 분기 컷은 실제 축의 선분 (-&amp;infin;, -1) 및 (1, &amp;infin;)에 확실하게 배치됩니다. 아크 코사인의 주요 값의 수학적 정의는 acos z =</target>
        </trans-unit>
        <trans-unit id="92db73712a1ea6cdea29021a66a4e0d10b6b003b" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-&amp;infin;,+1) of the real axis.</source>
          <target state="translated">역 쌍곡 코사인은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 실제 축의 선분 (-&amp;infin;, + 1)에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="3ff0648a78636309b1cc12a67a5c7841a27e8966" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-</source>
          <target state="translated">역 쌍곡 사인은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 선 세그먼트에 배치됩니다 (-</target>
        </trans-unit>
        <trans-unit id="60cf8f72dc186c6f4b4743734e8e8ed4cb1bd30a" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-&amp;infin;,-1] and [+1,+&amp;infin;) of the real axis.  The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =</source>
          <target state="translated">역 쌍곡 탄젠트는 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 실제 축의 세그먼트 (-&amp;infin;, -1] 및 [+ 1, + &amp;infin;)에 배치됩니다. 역 쌍곡 탄젠트의 주요 값의 수학적 정의는 atanh z =</target>
        </trans-unit>
        <trans-unit id="ff28b3449f26b28c2a2ed73fffb64ba03b0e2959" translate="yes" xml:space="preserve">
          <source>Inverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.</source>
          <target state="translated">역 사인 (또는 아크 사인)은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 실제 축의 선 세그먼트 (-&amp;infin;, -1) 및 (1, &amp;infin;)에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="8a394149a1f48f15fcf530168253dbecfeb4322f" translate="yes" xml:space="preserve">
          <source>Inverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;i,-i) and (+i,+&amp;infin;i) of the imaginary axis.  The mathematical definition of the principal value of inverse tangent is atan z = -</source>
          <target state="translated">역 탄젠트 (또는 아크 탄젠트)는 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 가상 축의 선분 (-&amp;infin;i, -i) 및 (+ i, + &amp;infin;i)에 배치됩니다. 역 탄젠트의 주요 값의 수학적 정의는 atan z =-</target>
        </trans-unit>
        <trans-unit id="9d2f6d91d5420dae435a1c0f90119203f0e61055" translate="yes" xml:space="preserve">
          <source>It is common practice to inject struct/union/enum names into the name space of the ordinary identifiers using a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration:</source>
          <target state="translated">&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 선언을 사용하여 일반 식별자의 네임 스페이스에 struct / union / enum 이름을 삽입하는 것이 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="7405702ee0f652067444964a064505a6d91ce3db" translate="yes" xml:space="preserve">
          <source>It is implementation-defined if raw (not escaped) Unicode characters are allowed in identifiers:</source>
          <target state="translated">식별자에 원시 (이스케이프되지 않은) 유니 코드 문자가 허용되는 경우 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="e89c6edc67ab990f4dbf2f94411a54a2785ae48a" translate="yes" xml:space="preserve">
          <source>It is legal to pass a pointer to a &lt;code&gt;va_list&lt;/code&gt; object to another function and then use that object after the function returns.</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; 객체에 대한 포인터를 다른 함수 에 전달한 다음 함수가 반환 된 후 해당 객체를 사용하는 것이 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="7926a28072d957347e3960952bdef8d080b0e6ed" translate="yes" xml:space="preserve">
          <source>It is neither required nor forbidden for identical string literals to refer to the same location in memory. Moreover, overlapping string literals or string literals that are substrings of other string literals may be combined.</source>
          <target state="translated">동일한 문자열 리터럴이 메모리에서 동일한 위치를 참조 할 필요는 없습니다. 또한, 다른 문자열 리터럴의 하위 문자열 인 겹치는 문자열 리터럴 또는 문자열 리터럴을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9123df49710433ab83af6575b94f8d3abd5f45a3" translate="yes" xml:space="preserve">
          <source>It is possible to enter the body of a loop using &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;. In this case, init_clause and cond_expression are not executed.</source>
          <target state="translated">&lt;a href=&quot;goto&quot;&gt;goto를&lt;/a&gt; 사용하여 루프 본문에 들어갈 수 있습니다 . 이 경우 init_clause 및 cond_expression이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08e37acb4a8f5bf8f0ffdb9adceda2446f63dbb9" translate="yes" xml:space="preserve">
          <source>It is possible to indicate to a function that accesses objects through pointers that those pointers do not alias. See &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; for details.</source>
          <target state="translated">포인터를 통해 객체에 액세스하는 함수에 해당 포인터의 별칭이 지정되지 않음을 표시 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;restrict&quot;&gt;제한&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e55a74fe870b5dea0eb9ccaa43f967ab9bc4994" translate="yes" xml:space="preserve">
          <source>It's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).</source>
          <target state="translated">알려진 크기의 배열을 초기화 할 때 요소보다 많은 이니셜 라이저를 제공하는 것은 오류입니다 (문자열 리터럴에서 문자 배열을 초기화하는 경우 제외).</target>
        </trans-unit>
        <trans-unit id="cbb15437c0942623655a62fecca4d13fffedba42" translate="yes" xml:space="preserve">
          <source>It's an error to provide more initializers than members.</source>
          <target state="translated">멤버보다 많은 이니셜 라이저를 제공하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="eaad30c6c7239ee4988afc79198142d6357df99b" translate="yes" xml:space="preserve">
          <source>Iteration statements</source>
          <target state="translated">반복문</target>
        </trans-unit>
        <trans-unit id="61862142943cd7265805fbc767319ff613c724a6" translate="yes" xml:space="preserve">
          <source>J.5 Common extensions (p: 511-513)</source>
          <target state="translated">J.5 공통 확장 (p : 511-513)</target>
        </trans-unit>
        <trans-unit id="a9953eaba16e228c2e6d58120372e40175bf2ca4" translate="yes" xml:space="preserve">
          <source>J.5 Common extensions (p: 579-581)</source>
          <target state="translated">J.5 공통 확장 (p : 579-581)</target>
        </trans-unit>
        <trans-unit id="bdfb777e0387993e2e3d113ac36512201456491d" translate="yes" xml:space="preserve">
          <source>Jump statements</source>
          <target state="translated">점프 진술</target>
        </trans-unit>
        <trans-unit id="dab4841e25b37627c71f4a9a4019a02fa5866eef" translate="yes" xml:space="preserve">
          <source>Jumping across threads (if the function that called &lt;code&gt;setjmp&lt;/code&gt; was executed by another thread) is also undefined behavior.</source>
          <target state="translated">스레드 간 점프 ( &lt;code&gt;setjmp&lt;/code&gt; 라는 함수가 다른 스레드에 의해 실행 된 경우)도 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="0cb0c0046b3f02e116b5c2149dc3ab7668bc12b6" translate="yes" xml:space="preserve">
          <source>K.3.1.2 Reserved identifiers (p: 584)</source>
          <target state="translated">K.3.1.2 예약 식별자 (p : 584)</target>
        </trans-unit>
        <trans-unit id="6864fef737e995e1d1cd295e0023b9e2ebe3a4c4" translate="yes" xml:space="preserve">
          <source>K.3.1.3 Use of errno (p: 584)</source>
          <target state="translated">K.3.1.3 errno 사용 (p : 584)</target>
        </trans-unit>
        <trans-unit id="27a66ec6494371162942d093a56fa8a2e184d943" translate="yes" xml:space="preserve">
          <source>K.3.2 Errors &amp;lt;errno.h&amp;gt; (p: 585)</source>
          <target state="translated">K.3.2 오류 &amp;lt;errno.h&amp;gt; (p : 585)</target>
        </trans-unit>
        <trans-unit id="708d246a6ea637ca582a2667b7221a12320e5a98" translate="yes" xml:space="preserve">
          <source>K.3.2/2 errno_t (p: 585)</source>
          <target state="translated">K.3.2 / 2 errno_t (p : 585)</target>
        </trans-unit>
        <trans-unit id="6e58be13bd900d0cee367c094a9ec614488caeee" translate="yes" xml:space="preserve">
          <source>K.3.3 Common definitions &amp;lt;stddef.h&amp;gt; (p: 585)</source>
          <target state="translated">K.3.3 공통 정의 &amp;lt;stddef.h&amp;gt; (p : 585)</target>
        </trans-unit>
        <trans-unit id="f138276c2fee1981c3ae61a15d64e3a9856c9815" translate="yes" xml:space="preserve">
          <source>K.3.3/2 rsize_t (p: 585)</source>
          <target state="translated">K.3.3 / 2 rsize_t (p : 585)</target>
        </trans-unit>
        <trans-unit id="b4c50e76ee617672247b3a8d01a8c4ec472aa6f7" translate="yes" xml:space="preserve">
          <source>K.3.4/2 RSIZE_MAX (p: 585)</source>
          <target state="translated">K.3.4 / 2 RSIZE_MAX (p : 585)</target>
        </trans-unit>
        <trans-unit id="6a80d328f4964ca1bf3e74f6f2ccc8b333f67c7e" translate="yes" xml:space="preserve">
          <source>K.3.5 Input/output &amp;lt;stdio.h&amp;gt; (p: 586-603)</source>
          <target state="translated">K.3.5 입출력 &amp;lt;stdio.h&amp;gt; (p : 586-603)</target>
        </trans-unit>
        <trans-unit id="369c2239cc2d2c85678b66dc84de6c39138dad3f" translate="yes" xml:space="preserve">
          <source>K.3.5.1.1 The tmpfile_s function (p: 586-587)</source>
          <target state="translated">K.3.5.1.1 tmpfile_s 함수 (p : 586-587)</target>
        </trans-unit>
        <trans-unit id="50d2ab4ca7b8cc8a1730d227f9641def28a24680" translate="yes" xml:space="preserve">
          <source>K.3.5.1.2 The tmpnam_s function (p: 587-588)</source>
          <target state="translated">K.3.5.1.2 tmpnam_s 함수 (p : 587-588)</target>
        </trans-unit>
        <trans-unit id="5a485d9c7022335c9e640bfc39b6d728070f42cd" translate="yes" xml:space="preserve">
          <source>K.3.5.2.1 The fopen_s function (p: 588-590)</source>
          <target state="translated">K.3.5.2.1 fopen_s 함수 (p : 588-590)</target>
        </trans-unit>
        <trans-unit id="ab2a574649a5da149b2aad34fd3642efffe3e957" translate="yes" xml:space="preserve">
          <source>K.3.5.2.2 The freopen_s function (p: 590)</source>
          <target state="translated">K.3.5.2.2 freopen_s 함수 (p : 590)</target>
        </trans-unit>
        <trans-unit id="9150e311f698b9b2d0020a5314030a25443c9953" translate="yes" xml:space="preserve">
          <source>K.3.5.3.1 The fprintf_s function (p: 591)</source>
          <target state="translated">K.3.5.3.1 fprintf_s 함수 (p : 591)</target>
        </trans-unit>
        <trans-unit id="23d19bd7432258b33166d9a55544eb85969c4f0b" translate="yes" xml:space="preserve">
          <source>K.3.5.3.10 The vprintf_s function (p: 598-599)</source>
          <target state="translated">K.3.5.3.10 vprintf_s 함수 (p : 598-599)</target>
        </trans-unit>
        <trans-unit id="d9041652eb11ab1a0d7ccbc42db6d18962320c4d" translate="yes" xml:space="preserve">
          <source>K.3.5.3.11 The vscanf_s function (p: 599)</source>
          <target state="translated">K.3.5.3.11 vscanf_s 함수 (p : 599)</target>
        </trans-unit>
        <trans-unit id="b661ee960e7f0fae6141e96c9cc1b4fd57185d64" translate="yes" xml:space="preserve">
          <source>K.3.5.3.12 The vsnprintf_s function (p: 600)</source>
          <target state="translated">K.3.5.3.12 vsnprintf_s 함수 (p : 600)</target>
        </trans-unit>
        <trans-unit id="f9a1acd40ff4721c31e464bdc74e240db45f114e" translate="yes" xml:space="preserve">
          <source>K.3.5.3.13 The vsprintf_s function (p: 601)</source>
          <target state="translated">K.3.5.3.13 vsprintf_s 함수 (p : 601)</target>
        </trans-unit>
        <trans-unit id="013f52d5fe2e678b389f07e69c114c6413950586" translate="yes" xml:space="preserve">
          <source>K.3.5.3.14 The vsscanf_s function (p: 602)</source>
          <target state="translated">K.3.5.3.14 vsscanf_s 함수 (p : 602)</target>
        </trans-unit>
        <trans-unit id="684c3b4d0155dab92ccb5157d61e57be7187e268" translate="yes" xml:space="preserve">
          <source>K.3.5.3.2 The fscanf_s function (p: 592-593)</source>
          <target state="translated">K.3.5.3.2 fscanf_s 함수 (p : 592-593)</target>
        </trans-unit>
        <trans-unit id="85e026b41cb6fb14b9397ba5d5c295a20b084a8c" translate="yes" xml:space="preserve">
          <source>K.3.5.3.3 The printf_s function (p: 593-594)</source>
          <target state="translated">K.3.5.3.3 printf_s 기능 (p : 593-594)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
