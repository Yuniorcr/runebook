<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="6e87f450714558ddb50d4bdf7e4d02acfacfb264" translate="yes" xml:space="preserve">
          <source>K.3.5.3.4 The scanf_s function (p: 594)</source>
          <target state="translated">K.3.5.3.4 scanf_s 기능 (p : 594)</target>
        </trans-unit>
        <trans-unit id="789e700cdb056e52650a78ffa7fdcd4d711d4c90" translate="yes" xml:space="preserve">
          <source>K.3.5.3.5 The snprintf_s function (p: 594-595)</source>
          <target state="translated">K.3.5.3.5 snprintf_s 기능 (p : 594-595)</target>
        </trans-unit>
        <trans-unit id="ec459a09b0d7bf62927a3c6c03058ef3c475490d" translate="yes" xml:space="preserve">
          <source>K.3.5.3.6 The sprintf_s function (p: 595-596)</source>
          <target state="translated">K.3.5.3.6 sprintf_s 함수 (p : 595-596)</target>
        </trans-unit>
        <trans-unit id="ca68bafb6cc05e813c7f39b2f6b9b895c7d94f70" translate="yes" xml:space="preserve">
          <source>K.3.5.3.7 The sscanf_s function (p: 596)</source>
          <target state="translated">K.3.5.3.7 sscanf_s 함수 (p : 596)</target>
        </trans-unit>
        <trans-unit id="ce73aed86cc95200661f9dc87486af047adc7f7a" translate="yes" xml:space="preserve">
          <source>K.3.5.3.8 The vfprintf_s function (p: 597)</source>
          <target state="translated">K.3.5.3.8 vfprintf_s 함수 (p : 597)</target>
        </trans-unit>
        <trans-unit id="ff8183f464d0e63241e650e285fcfd517d76535f" translate="yes" xml:space="preserve">
          <source>K.3.5.3.9 The vfscanf_s function (p: 597-598)</source>
          <target state="translated">K.3.5.3.9 vfscanf_s 함수 (p : 597-598)</target>
        </trans-unit>
        <trans-unit id="e6f175b171b13547422ef67d14d58ff0f4d5c1b8" translate="yes" xml:space="preserve">
          <source>K.3.5.4.1 The gets_s function (p: 602-603)</source>
          <target state="translated">K.3.5.4.1 gets_s 함수 (p : 602-603)</target>
        </trans-unit>
        <trans-unit id="7c71637fd1d2fa3723fc4985f8e03b0fc94cfb62" translate="yes" xml:space="preserve">
          <source>K.3.6 General utilities &amp;lt;stdlib.h&amp;gt; (p: 604-614)</source>
          <target state="translated">K.3.6 일반 유틸리티 &amp;lt;stdlib.h&amp;gt; (p : 604-614)</target>
        </trans-unit>
        <trans-unit id="1853d466f01670eef0dc9469c32e91913106f8ca" translate="yes" xml:space="preserve">
          <source>K.3.6 General utilities &amp;lt;stdlib.h&amp;gt; (p: 604=613)</source>
          <target state="translated">K.3.6 일반 유틸리티 &amp;lt;stdlib.h&amp;gt; (p : 604 = 613)</target>
        </trans-unit>
        <trans-unit id="2d4a32cc691240ce6a364732f86d836d6c4813f2" translate="yes" xml:space="preserve">
          <source>K.3.6.1.1 The set_constraint_handler_s function (p: 604-605)</source>
          <target state="translated">K.3.6.1.1 set_constraint_handler_s 함수 (p : 604-605)</target>
        </trans-unit>
        <trans-unit id="7dc3e9b4cbb40ceb3c08abdf4c641b24ce637bfb" translate="yes" xml:space="preserve">
          <source>K.3.6.1.2 The abort_handler_s function (p: 605)</source>
          <target state="translated">K.3.6.1.2 abort_handler_s 함수 (p : 605)</target>
        </trans-unit>
        <trans-unit id="ac51d467d3fe5b75925e89230eac9afbcb4b7a41" translate="yes" xml:space="preserve">
          <source>K.3.6.1.3 The ignore_handler_s function (p: 606)</source>
          <target state="translated">K.3.6.1.3 ignore_handler_s 함수 (p : 606)</target>
        </trans-unit>
        <trans-unit id="b7a153aa31649e584fa3aa0cdd1870196b2aac34" translate="yes" xml:space="preserve">
          <source>K.3.6.2.1 The getenv_s function (p: 606-607)</source>
          <target state="translated">K.3.6.2.1 getenv_s 함수 (p : 606-607)</target>
        </trans-unit>
        <trans-unit id="27eb68853eda78c54e6d2165678c810a61fbc5bd" translate="yes" xml:space="preserve">
          <source>K.3.6.3 Searching and sorting utilities (p: 607-609)</source>
          <target state="translated">K.3.6.3 검색 및 정렬 유틸리티 (p : 607-609)</target>
        </trans-unit>
        <trans-unit id="ac2447eeafadd707728e3ec0fc997a1d5e02f947" translate="yes" xml:space="preserve">
          <source>K.3.6.3.1 The bsearch_s function (p: 608-609)</source>
          <target state="translated">K.3.6.3.1 bsearch_s 함수 (p : 608-609)</target>
        </trans-unit>
        <trans-unit id="071def6c5848242d761260e18c66053308fb0ffd" translate="yes" xml:space="preserve">
          <source>K.3.6.3.2 The qsort_s function (p: 609)</source>
          <target state="translated">K.3.6.3.2 qsort_s 함수 (p : 609)</target>
        </trans-unit>
        <trans-unit id="b4ec3a9d7c22b9e6186fe1c31ed92f75c98cbbe2" translate="yes" xml:space="preserve">
          <source>K.3.6.4.1 The wctomb_s function (p: 610-611)</source>
          <target state="translated">K.3.6.4.1 wctomb_s 함수 (p : 610-611)</target>
        </trans-unit>
        <trans-unit id="2ddac74181aa6be43c6ccf7928937489b9d50b89" translate="yes" xml:space="preserve">
          <source>K.3.6.5.1 The mbstowcs_s function (p: 611-612)</source>
          <target state="translated">K.3.6.5.1 mbstowcs_s 함수 (p : 611-612)</target>
        </trans-unit>
        <trans-unit id="f91c1ce1c61b8a7a232f5183c909039e8572e046" translate="yes" xml:space="preserve">
          <source>K.3.6.5.2 The wcstombs_s function (p: 612-614)</source>
          <target state="translated">K.3.6.5.2 wcstombs_s 함수 (p : 612-614)</target>
        </trans-unit>
        <trans-unit id="0df68d8d1c1e1666360bf066c633dce5fc1a0439" translate="yes" xml:space="preserve">
          <source>K.3.6/2 constraint_handler_t (p: 604)</source>
          <target state="translated">K.3.6 / 2 constraint_handler_t (p : 604)</target>
        </trans-unit>
        <trans-unit id="0b6aa26de3d10f8bf918d65cf027777f510ceb7c" translate="yes" xml:space="preserve">
          <source>K.3.7 String handling &amp;lt;string.h&amp;gt; (p: 614-623)</source>
          <target state="translated">K.3.7 문자열 처리 &amp;lt;string.h&amp;gt; (p : 614-623)</target>
        </trans-unit>
        <trans-unit id="fcb9450a0c112fff38151036c92a1a03833cb268" translate="yes" xml:space="preserve">
          <source>K.3.7.1.1 The memcpy_s function (p: 614)</source>
          <target state="translated">K.3.7.1.1 memcpy_s 함수 (p : 614)</target>
        </trans-unit>
        <trans-unit id="f20a7f113cd1f6cc8e8aae831f18046426eb292a" translate="yes" xml:space="preserve">
          <source>K.3.7.1.2 The memmove_s function (p: 615)</source>
          <target state="translated">K.3.7.1.2 memmove_s 기능 (p : 615)</target>
        </trans-unit>
        <trans-unit id="026d625555e2107877cd1d5f55ad0eed51ce8a68" translate="yes" xml:space="preserve">
          <source>K.3.7.1.3 The strcpy_s function (p: 615-616)</source>
          <target state="translated">K.3.7.1.3 strcpy_s 함수 (p : 615-616)</target>
        </trans-unit>
        <trans-unit id="2251ec9549ddc8252970829d07a0d8c310083f83" translate="yes" xml:space="preserve">
          <source>K.3.7.1.4 The strncpy_s function (p: 616-617)</source>
          <target state="translated">K.3.7.1.4 strncpy_s 함수 (p : 616-617)</target>
        </trans-unit>
        <trans-unit id="b694533bcfa6d5497ab90b2276cd602e2a1648fd" translate="yes" xml:space="preserve">
          <source>K.3.7.2.1 The strcat_s function (p: 617-618)</source>
          <target state="translated">K.3.7.2.1 strcat_s 함수 (p : 617-618)</target>
        </trans-unit>
        <trans-unit id="8cdd8ef2d792e316ba8b77ea6ae4a2d3c896450e" translate="yes" xml:space="preserve">
          <source>K.3.7.2.2 The strncat_s function (p: 618-620)</source>
          <target state="translated">K.3.7.2.2 strncat_s 함수 (p : 618-620)</target>
        </trans-unit>
        <trans-unit id="66f9dbdb888b7bd78da3a33e5f6aa7667c065573" translate="yes" xml:space="preserve">
          <source>K.3.7.3.1 The strtok_s function (p: 620-621)</source>
          <target state="translated">K.3.7.3.1 strtok_s 함수 (p : 620-621)</target>
        </trans-unit>
        <trans-unit id="226e29c2e9550018adeac86096597bdb626096a4" translate="yes" xml:space="preserve">
          <source>K.3.7.4.1 The memset_s function (p: 621-622)</source>
          <target state="translated">K.3.7.4.1 memset_s 함수 (p : 621-622)</target>
        </trans-unit>
        <trans-unit id="88064689249d73b1be81a192ec57cb2df4443c65" translate="yes" xml:space="preserve">
          <source>K.3.7.4.2 The strerror_s function (p: 622)</source>
          <target state="translated">K.3.7.4.2 strerror_s 함수 (p : 622)</target>
        </trans-unit>
        <trans-unit id="f1f6895eac3cdc318252f73cfac0e3a3a2a9cc23" translate="yes" xml:space="preserve">
          <source>K.3.7.4.3 The strerrorlen_s function (p: 623)</source>
          <target state="translated">K.3.7.4.3 strerrorlen_s 함수 (p : 623)</target>
        </trans-unit>
        <trans-unit id="928af0362633d94d337208d234fda61b3518bb57" translate="yes" xml:space="preserve">
          <source>K.3.7.4.4 The strnlen_s function (p: 623)</source>
          <target state="translated">K.3.7.4.4 strnlen_s 함수 (p : 623)</target>
        </trans-unit>
        <trans-unit id="8c4e424b9344dca1b563535a7ace77afd12944e9" translate="yes" xml:space="preserve">
          <source>K.3.8.2.1 The asctime_s function (p: 624-625)</source>
          <target state="translated">K.3.8.2.1 asctime_s 함수 (p : 624-625)</target>
        </trans-unit>
        <trans-unit id="e8abf30b7c4be7fe8bffde7b550daab381bc2c75" translate="yes" xml:space="preserve">
          <source>K.3.8.2.2 The ctime_s function (p: 626)</source>
          <target state="translated">K.3.8.2.2 ctime_s 함수 (p : 626)</target>
        </trans-unit>
        <trans-unit id="34f3d062cbb348873b72323b698104245b6ff38f" translate="yes" xml:space="preserve">
          <source>K.3.8.2.3 The gmtime_s function (p: 626-627)</source>
          <target state="translated">K.3.8.2.3 gmtime_s 함수 (p : 626-627)</target>
        </trans-unit>
        <trans-unit id="d7ed769dca80ad59951c175492ffaea07e0233d8" translate="yes" xml:space="preserve">
          <source>K.3.8.2.4 The localtime_s function (p: 627)</source>
          <target state="translated">K.3.8.2.4 localtime_s 함수 (p : 627)</target>
        </trans-unit>
        <trans-unit id="4b7d157f04de69b27b90922ed1097b87d5c8bb3d" translate="yes" xml:space="preserve">
          <source>K.3.9 Extended multibyte and wide character utilities &amp;lt;wchar.h&amp;gt; (p: 627-651)</source>
          <target state="translated">K.3.9 확장 멀티 바이트 및 와이드 문자 유틸리티 &amp;lt;wchar.h&amp;gt; (p : 627-651)</target>
        </trans-unit>
        <trans-unit id="cf4f9e3cf15aee80375f906c0dabed65db13bd45" translate="yes" xml:space="preserve">
          <source>K.3.9.1.1 The fwprintf_s function (p: 628)</source>
          <target state="translated">K.3.9.1.1 fwprintf_s 함수 (p : 628)</target>
        </trans-unit>
        <trans-unit id="9fe744ef500ce54120466e37c6ae2cc5ab29e82c" translate="yes" xml:space="preserve">
          <source>K.3.9.1.10 The vswscanf_s function (p: 635-636)</source>
          <target state="translated">K.3.9.1.10 vswscanf_s 함수 (p : 635-636)</target>
        </trans-unit>
        <trans-unit id="502880aa89a6a0785946780412fcd03fd17c2051" translate="yes" xml:space="preserve">
          <source>K.3.9.1.11 The vwprintf_s function (p: 636)</source>
          <target state="translated">K.3.9.1.11 vwprintf_s 함수 (p : 636)</target>
        </trans-unit>
        <trans-unit id="53007710566eada762e452a854841fdb8357f580" translate="yes" xml:space="preserve">
          <source>K.3.9.1.12 The vwscanf_s function (p: 637)</source>
          <target state="translated">K.3.9.1.12 vwscanf_s 함수 (p : 637)</target>
        </trans-unit>
        <trans-unit id="3d1230d58e12da08f4567feadb742924e5021dce" translate="yes" xml:space="preserve">
          <source>K.3.9.1.13 The wprintf_s function (p: 637-638)</source>
          <target state="translated">K.3.9.1.13 wprintf_s 함수 (p : 637-638)</target>
        </trans-unit>
        <trans-unit id="273b2411e3d65a8f5f205295c6d177937af70a63" translate="yes" xml:space="preserve">
          <source>K.3.9.1.14 The wscanf_s function (p: 638)</source>
          <target state="translated">K.3.9.1.14 wscanf_s 함수 (p : 638)</target>
        </trans-unit>
        <trans-unit id="ea2b3ba5b243bbae4fe51b1dd2b5a202269738ed" translate="yes" xml:space="preserve">
          <source>K.3.9.1.2 The fwscanf_s function (p: 628-629)</source>
          <target state="translated">K.3.9.1.2 fwscanf_s 함수 (p : 628-629)</target>
        </trans-unit>
        <trans-unit id="137994004c1a46c74c679ef5575866ed172dacc1" translate="yes" xml:space="preserve">
          <source>K.3.9.1.4 The swprintf_s function (p: 630-631)</source>
          <target state="translated">K.3.9.1.4 swprintf_s 함수 (p : 630-631)</target>
        </trans-unit>
        <trans-unit id="769eca55c93de86903dbcd6f4cfb2e1b5c689c15" translate="yes" xml:space="preserve">
          <source>K.3.9.1.5 The swscanf_s function (p: 631)</source>
          <target state="translated">K.3.9.1.5 swscanf_s 함수 (p : 631)</target>
        </trans-unit>
        <trans-unit id="a2de648711deea69cabe54f013b996cfc22e72c4" translate="yes" xml:space="preserve">
          <source>K.3.9.1.6 The vfwprintf_s function (p: 632)</source>
          <target state="translated">K.3.9.1.6 vfwprintf_s 함수 (p : 632)</target>
        </trans-unit>
        <trans-unit id="98bdf25171791eaccda96f73b779a24856e10a2c" translate="yes" xml:space="preserve">
          <source>K.3.9.1.7 The vfwscanf_s function (p: 632-633)</source>
          <target state="translated">K.3.9.1.7 vfwscanf_s 함수 (p : 632-633)</target>
        </trans-unit>
        <trans-unit id="615aa61e42f7a2a8514a38517a0f968377c47558" translate="yes" xml:space="preserve">
          <source>K.3.9.1.8 The vsnwprintf_s function (p: 633-634)</source>
          <target state="translated">K.3.9.1.8 vsnwprintf_s 함수 (p : 633-634)</target>
        </trans-unit>
        <trans-unit id="aed426e860459b960d0c72d2ca62ac34a360b610" translate="yes" xml:space="preserve">
          <source>K.3.9.1.9 The vswprintf_s function (p: 634-635)</source>
          <target state="translated">K.3.9.1.9 vswprintf_s 함수 (p : 634-635)</target>
        </trans-unit>
        <trans-unit id="912f92fd26cea409882d5e7bd131cfba6200b2dc" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.1 The wcscpy_s function (p: 639)</source>
          <target state="translated">K.3.9.2.1.1 wcscpy_s 함수 (p : 639)</target>
        </trans-unit>
        <trans-unit id="a3798088857cd174819276ae6461939fbe78cbb8" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.2 The wcsncpy_s function (p: 640-641)</source>
          <target state="translated">K.3.9.2.1.2 wcsncpy_s 함수 (p : 640-641)</target>
        </trans-unit>
        <trans-unit id="95835affd293c9f755435a3c77b71d7a41747145" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.3 The wmemcpy_s function (p: 641)</source>
          <target state="translated">K.3.9.2.1.3 wmemcpy_s 함수 (p : 641)</target>
        </trans-unit>
        <trans-unit id="e5079151e71b60b5eaad760afca1e4a4a984131a" translate="yes" xml:space="preserve">
          <source>K.3.9.2.1.4 The wmemmove_s function (p: 642)</source>
          <target state="translated">K.3.9.2.1.4 wmemmove_s 함수 (p : 642)</target>
        </trans-unit>
        <trans-unit id="c1cab8b141a42c1ac62a4acd1980c718490ef960" translate="yes" xml:space="preserve">
          <source>K.3.9.2.2.1 The wcscat_s function (p: 642-643)</source>
          <target state="translated">K.3.9.2.2.1 wcscat_s 함수 (p : 642-643)</target>
        </trans-unit>
        <trans-unit id="4c29ddef322945428621d4992268500a0e16b3e3" translate="yes" xml:space="preserve">
          <source>K.3.9.2.2.2 The wcsncat_s function (p: 643-644)</source>
          <target state="translated">K.3.9.2.2.2 wcsncat_s 함수 (p : 643-644)</target>
        </trans-unit>
        <trans-unit id="c14fe494f924665909672135ac7e7ee2d4437e21" translate="yes" xml:space="preserve">
          <source>K.3.9.2.3.1 The wcstok_s function (p: 645-646)</source>
          <target state="translated">K.3.9.2.3.1 wcstok_s 함수 (p : 645-646)</target>
        </trans-unit>
        <trans-unit id="946346a0b8853aefe1afe2d8268c33d063bba612" translate="yes" xml:space="preserve">
          <source>K.3.9.2.4.1 The wcsnlen_s function (p: 646-647)</source>
          <target state="translated">K.3.9.2.4.1 wcsnlen_s 함수 (p : 646-647)</target>
        </trans-unit>
        <trans-unit id="e1414308b8b3e8d11cd6e5001748296bf8efee0b" translate="yes" xml:space="preserve">
          <source>K.3.9.3.1.1 The wcrtomb_s function (p: 647-648)</source>
          <target state="translated">K.3.9.3.1.1 wcrtomb_s 함수 (p : 647-648)</target>
        </trans-unit>
        <trans-unit id="cb5669cb4eba38db5e11d7e288f5dd15db05e824" translate="yes" xml:space="preserve">
          <source>K.3.9.3.2.1 The mbsrtowcs_s function (p: 648-649)</source>
          <target state="translated">K.3.9.3.2.1 mbsrtowcs_s 함수 (p : 648-649)</target>
        </trans-unit>
        <trans-unit id="2ae163d88834e13877175d6520c8d15a0f6c1324" translate="yes" xml:space="preserve">
          <source>K.3.9.3.2.2 The wcsrtombs_s function (p: 649-651)</source>
          <target state="translated">K.3.9.3.2.2 wcsrtombs_s 함수 (p : 649-651)</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="05261e150dc9a967a52c20f567ceb3e59975f528" translate="yes" xml:space="preserve">
          <source>L-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">L 접두사 와이드 문자열 리터럴을 사용하여 (cv-qualifications 무시) &lt;code&gt;wchar_t&lt;/code&gt; 와 호환되는 모든 유형의 배열을 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4da84710b41fc09dd78f93b82fe6010bab5fd27" translate="yes" xml:space="preserve">
          <source>LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</source>
          <target state="translated">LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="65a740810ab447ffb984bd6fdf5448611bcca5d2" translate="yes" xml:space="preserve">
          <source>LLP64</source>
          <target state="translated">LLP64</target>
        </trans-unit>
        <trans-unit id="bee2cfeb49f65a60be1386935bbd919b5ec97964" translate="yes" xml:space="preserve">
          <source>LP32</source>
          <target state="translated">LP32</target>
        </trans-unit>
        <trans-unit id="6cb8b2a9a5c6dacaca21f4343040021510d35c97" translate="yes" xml:space="preserve">
          <source>LP64</source>
          <target state="translated">LP64</target>
        </trans-unit>
        <trans-unit id="c02a7203aab12b1608aee47e686511f73e6b3f20" translate="yes" xml:space="preserve">
          <source>L_tmpnamL_tmpnam_s</source>
          <target state="translated">L_tmpnamL_tmpnam_s</target>
        </trans-unit>
        <trans-unit id="bb5a8d6c683cb878ad30ae74289c4617f9c766d3" translate="yes" xml:space="preserve">
          <source>Label declaration has no effect on its own, does not alter the flow of control, or modify the behavior of the statement that follows in any way.</source>
          <target state="translated">레이블 선언은 그 자체로는 영향을 미치지 않으며 제어 흐름을 변경하지 않으며 어떤 식 으로든 명령문의 동작을 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="bdffb77ae44e48c63c181cf7541184b7bfe75b59" translate="yes" xml:space="preserve">
          <source>Left-to-right</source>
          <target state="translated">Left-to-right</target>
        </trans-unit>
        <trans-unit id="12941d0eb9ed4aeacc52d5f00426e066fee74e7d" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;P&lt;/code&gt; equal the precision if nonzero, &lt;code&gt;6&lt;/code&gt; if the precision is not specified, or &lt;code&gt;1&lt;/code&gt; if the precision is &lt;code&gt;​0​&lt;/code&gt;. Then, if a conversion with style &lt;code&gt;E&lt;/code&gt; would have an exponent of &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">하자 &lt;code&gt;P&lt;/code&gt; 가 0이 아닌 경우, 동일 정밀도 &lt;code&gt;6&lt;/code&gt; 정밀도 지정이 아닌 경우, 또는 &lt;code&gt;1&lt;/code&gt; 정밀도 인 경우 &lt;code&gt;​0​&lt;/code&gt; . 그런 다음 스타일 &lt;code&gt;E&lt;/code&gt; 를 사용한 변환 의 지수가 &lt;code&gt;X&lt;/code&gt; 인 경우 :</target>
        </trans-unit>
        <trans-unit id="ab517382cbd282770e322d606f13389dcbdf3466" translate="yes" xml:space="preserve">
          <source>Letters in the floating constants are case-insensitive: &lt;code&gt;0x1.ep+3&lt;/code&gt; and &lt;code&gt;0X1.EP+3&lt;/code&gt; represent the same floating-point value 15.0.</source>
          <target state="translated">부동 상수의 문자는 대소 문자를 구분하지 않습니다. &lt;code&gt;0x1.ep+3&lt;/code&gt; 및 &lt;code&gt;0X1.EP+3&lt;/code&gt; 은 동일한 부동 소수점 값 15.0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d356e16a814f46abee48f7e57ea39a420ad47b27" translate="yes" xml:space="preserve">
          <source>Letters in the integer constants are case-insensitive: &lt;code&gt;0xDeAdBaBeU&lt;/code&gt; and &lt;code&gt;0XdeadBABEu&lt;/code&gt; represent the same number (one exception is the long-long-suffix, which is either &lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;, never &lt;code&gt;lL&lt;/code&gt; or &lt;code&gt;Ll&lt;/code&gt;).</source>
          <target state="translated">정수 상수의 문자는 대소 문자를 구분하지 않습니다. &lt;code&gt;0xDeAdBaBeU&lt;/code&gt; 및 &lt;code&gt;0XdeadBABEu&lt;/code&gt; 는 같은 숫자를 나타냅니다 (한 예외는 &lt;code&gt;ll&lt;/code&gt; 또는 &lt;code&gt;LL&lt;/code&gt; , 절대 &lt;code&gt;lL&lt;/code&gt; 또는 &lt;code&gt;Ll&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd574f10b612abb6aa6363ae6df12c662bce8552" translate="yes" xml:space="preserve">
          <source>Libraries often expose system-dependent or configuration-dependent types as typedef names, to present a consistent interface to the users or to other library components:</source>
          <target state="translated">라이브러리는 종종 시스템 종속 또는 구성 종속 유형을 typedef 이름으로 노출하여 사용자 또는 다른 라이브러리 구성 요소에 일관된 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ffd31a82199f3f82e503f243280cb3a9f1494489" translate="yes" xml:space="preserve">
          <source>Library functions &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; can be used to obtain textual descriptions of the error conditions that correspond to the current &lt;code&gt;errno&lt;/code&gt; value.</source>
          <target state="translated">라이브러리 함수 &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 &lt;code&gt;errno&lt;/code&gt; 값에 해당하는 오류 조건에 대한 텍스트 설명을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5389e5e41e9f62464b70b3f701dadbe975b06a27" translate="yes" xml:space="preserve">
          <source>Library implementation:</source>
          <target state="translated">라이브러리 구현 :</target>
        </trans-unit>
        <trans-unit id="b4d4e990c7c024f82a53c553c156bc6a7bc23cbf" translate="yes" xml:space="preserve">
          <source>Library interface:</source>
          <target state="translated">라이브러리 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="8d05a85e0ee31a873e2f15997f3ffa7b057cefff" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.</source>
          <target state="translated">Creative Commons Attribution-ShareAlike Unported License v3.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="7ffbe27d06c2711b64360b6cc0af54313ac75e7f" translate="yes" xml:space="preserve">
          <source>Limits of float types</source>
          <target state="translated">플로트 타입의 한계</target>
        </trans-unit>
        <trans-unit id="9d8bc984a49e87697786db72d2563a91679f73c6" translate="yes" xml:space="preserve">
          <source>Limits of floating point types</source>
          <target state="translated">부동 소수점 유형의 한계</target>
        </trans-unit>
        <trans-unit id="68c715c0e0c866487981ad26eed257940f23ee03" translate="yes" xml:space="preserve">
          <source>Limits of integer types</source>
          <target state="translated">정수 유형의 한계</target>
        </trans-unit>
        <trans-unit id="134491813a15a70cbab566dc7eb0c3a2ec60c077" translate="yes" xml:space="preserve">
          <source>Limits of library types</source>
          <target state="translated">라이브러리 유형의 한계</target>
        </trans-unit>
        <trans-unit id="b27dc31140950c016978fcb4c144b7b2d3cbc47c" translate="yes" xml:space="preserve">
          <source>Linkage</source>
          <target state="translated">Linkage</target>
        </trans-unit>
        <trans-unit id="593cb87e6afd7236782ce8a8a54f462eeca0ab07" translate="yes" xml:space="preserve">
          <source>Linkage and libraries</source>
          <target state="translated">연계 및 라이브러리</target>
        </trans-unit>
        <trans-unit id="dae789f2aa7564105d4b6d3e1d9bc4ed98eca017" translate="yes" xml:space="preserve">
          <source>Linkage refers to the ability of an identifier (variable or function) to be referred to in other scopes. If a variable or function with the same identifier is declared in several scopes, but cannot be referred to from all of them, then several instances of the variable are generated. The following linkages are recognized:</source>
          <target state="translated">연결은 다른 범위에서 참조 할 수있는 식별자 (변수 또는 기능)의 기능을 나타냅니다. 동일한 식별자를 가진 변수 또는 함수가 여러 범위에서 선언되었지만 모든 범위에서 참조 할 수없는 경우 변수의 여러 인스턴스가 생성됩니다. 다음과 같은 연계가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="5ece15c35c34a025f6be9bbdbfa6cc77ba902760" translate="yes" xml:space="preserve">
          <source>Linking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).</source>
          <target state="translated">연결이 발생합니다. 외부 참조를 충족시키는 데 필요한 변환 단위 및 라이브러리 구성 요소는 실행 환경 (OS)에서 실행하는 데 필요한 정보가 포함 된 프로그램 이미지로 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="ac8928ef8834eb7e685d440c092e0ed8717e2bf4" translate="yes" xml:space="preserve">
          <source>Loads the data from locations, defined by &lt;code&gt;vlist&lt;/code&gt;, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">&lt;code&gt;vlist&lt;/code&gt; 에 의해 정의 된 위치에서 데이터를로드하고 이를 동등한 문자열로 변환하고 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="306845665660271f5edceb9cf305119d107a9b6d" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">주어진 위치에서 데이터를로드하고 해당 문자열로 변환하여 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="b98547f12140b861f02fc92da40524e3b426e7b6" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">주어진 위치에서 데이터를로드하고이를 넓은 문자열로 변환 한 다음 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7bea89bc2ce48c930dc7395bbdbef3f7216a1506" translate="yes" xml:space="preserve">
          <source>Loads the data from the locations, defined by &lt;code&gt;vlist&lt;/code&gt;, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">&lt;code&gt;vlist&lt;/code&gt; 에 의해 정의 된 위치에서 데이터를로드하고 이를 동등한 문자열로 변환 한 후 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="3efe7e57b877b99e83abee299be618072a6caad5" translate="yes" xml:space="preserve">
          <source>Loads the execution context &lt;code&gt;env&lt;/code&gt; saved by a previous call to &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt;. This function does not return. Control is transferred to the call site of the macro &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; that set up &lt;code&gt;env&lt;/code&gt;. That &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; then returns the value, passed as the &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출로 저장된 실행 컨텍스트 &lt;code&gt;env&lt;/code&gt; 를 로드합니다 . 이 함수는 반환되지 않습니다. 제어는 &lt;code&gt;env&lt;/code&gt; 를 설정 한 매크로 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 의 호출 사이트로 전송됩니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;status&lt;/code&gt; 로 전달 된 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0b64c37e179f49fcbc2cadc0fb2d42cd79c4fdd9" translate="yes" xml:space="preserve">
          <source>Local monetary numeric formatting parameters</source>
          <target state="translated">현지 통화 숫자 형식화 매개 변수</target>
        </trans-unit>
        <trans-unit id="9581b06704233639536079ebbf71f9ce8dd59501" translate="yes" xml:space="preserve">
          <source>Local variables within a loop body can hide variables declared in the init clause of a &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; loop in C (their scope is nested), but cannot do that in C++.</source>
          <target state="translated">루프 본문 내의 로컬 변수 는 C에서 &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; 루프 의 init 절에 선언 된 변수를 숨길 수 있지만 (범위가 중첩 됨) C ++에서는이를 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd96a752e4d0a667d960bbb03aaebef6e74b78fd" translate="yes" xml:space="preserve">
          <source>Locale categories</source>
          <target state="translated">로케일 범주</target>
        </trans-unit>
        <trans-unit id="c05b84ddd9396cd687847e09cfc17da5a0c633d6" translate="yes" xml:space="preserve">
          <source>Localization support</source>
          <target state="translated">현지화 지원</target>
        </trans-unit>
        <trans-unit id="c07f512f68e601c83a418f3dad591a2645430943" translate="yes" xml:space="preserve">
          <source>Localization utilities</source>
          <target state="translated">현지화 유틸리티</target>
        </trans-unit>
        <trans-unit id="4da3037f457bddb5f51efa198af1cd2aac353e26" translate="yes" xml:space="preserve">
          <source>Locates the first occurrence of wide character &lt;code&gt;ch&lt;/code&gt; in the initial &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array or integer array of compatible type, pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 로 가리키는 와이드 문자 배열 또는 호환 가능한 유형의 정수 배열의 초기 &lt;code&gt;count&lt;/code&gt; 와이드 문자 에서 와이드 문자 &lt;code&gt;ch&lt;/code&gt; 의 첫 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">논리 AND</target>
        </trans-unit>
        <trans-unit id="e7e803ba6df9ebf5f542bc2b7ce91db2dc559f7e" translate="yes" xml:space="preserve">
          <source>Logical NOT</source>
          <target state="translated">논리 NOT</target>
        </trans-unit>
        <trans-unit id="91b0d4f6d432f44c251e4f26e3648660c648da8e" translate="yes" xml:space="preserve">
          <source>Logical NOT and bitwise NOT</source>
          <target state="translated">논리 NOT 및 비트 NOT</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">논리 OR</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="1f46abd6bf4991635a01cfeaf83140bc77bef5fe" translate="yes" xml:space="preserve">
          <source>Logical operators apply standard boolean algebra operations to their operands.</source>
          <target state="translated">논리 연산자는 표준 부울 대수 연산을 피연산자에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="9c6b5688fee032f7c152783707dfef40897f3389" translate="yes" xml:space="preserve">
          <source>Lookup and Name Spaces</source>
          <target state="translated">조회 및 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="00ddfc980de5898f0de50c86f7a81aabd47c6d87" translate="yes" xml:space="preserve">
          <source>Lookup and name spaces</source>
          <target state="translated">조회 및 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="3769a18de297ff08768c9476ca9be5fa9f7cb3ea" translate="yes" xml:space="preserve">
          <source>Lowercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no lowercase version is listed in the current C locale.</source>
          <target state="translated">의 소문자 버전 &lt;code&gt;ch&lt;/code&gt; 또는 수정되지 않은 &lt;code&gt;ch&lt;/code&gt; 더 소문자 버전은 현재 C 로케일에 표시되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="b664af18997be219e282a2e63c462404e091a65e" translate="yes" xml:space="preserve">
          <source>Lowercase version of &lt;code&gt;wc&lt;/code&gt; or unmodified &lt;code&gt;wc&lt;/code&gt; if no lowercase version is listed in the current C locale.</source>
          <target state="translated">현재 C 로케일에 소문자 버전이 없으면 소문자 버전의 &lt;code&gt;wc&lt;/code&gt; 또는 수정되지 않은 &lt;code&gt;wc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e25b81442907162aaed9c76cdae20e99101d3c89" translate="yes" xml:space="preserve">
          <source>Lvalue conversion</source>
          <target state="translated">L 값 변환</target>
        </trans-unit>
        <trans-unit id="012efee4bd10b361cdf0f6d26ced01f343831244" translate="yes" xml:space="preserve">
          <source>Lvalue expression is any expression with &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;object type&lt;/a&gt; other than the type &lt;code&gt;void&lt;/code&gt;, which potentially designates an &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; (the behavior is undefined if an lvalue does not actually designate an object when it is evaluated). In other words, lvalue expression evaluates to the</source>
          <target state="translated">Lvalue 표현식은 잠재적으로 &lt;a href=&quot;object&quot;&gt;객체를&lt;/a&gt; 지정하는 &lt;code&gt;void&lt;/code&gt; 유형 이외의 &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;객체 유형을&lt;/a&gt; 가진 표현식입니다 (lvalue가 실제로 객체를 평가할 때 lvalue가 객체를 지정하지 않으면 동작이 정의되지 않음). 다시 말해, lvalue 표현식은</target>
        </trans-unit>
        <trans-unit id="7be434e8731c552a88d17d1a8a1c5e732a91ef99" translate="yes" xml:space="preserve">
          <source>Lvalue expressions</source>
          <target state="translated">L 값 표현식</target>
        </trans-unit>
        <trans-unit id="ff201b988073267d106686cac6aa02d10f555bec" translate="yes" xml:space="preserve">
          <source>Lvalue expressions can be used in the following</source>
          <target state="translated">Lvalue 표현식은 다음에서 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="850947f3d010de98ad370f2f73bc49ca69c2b7c5" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO</source>
          <target state="translated">MATH_ERRNO</target>
        </trans-unit>
        <trans-unit id="74b7d4ceae8b4d3f14a2b48ce0dd4a45027ad623" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO, MATH_ERREXCEPT, math_errhandling</source>
          <target state="translated">MATH_ERRNO, MATH_ERREXCEPT, math_errhandling</target>
        </trans-unit>
        <trans-unit id="0b26b4988457eebaa5d41abd9af85e69645b9b63" translate="yes" xml:space="preserve">
          <source>MB_CUR_MAX</source>
          <target state="translated">MB_CUR_MAX</target>
        </trans-unit>
        <trans-unit id="6bfcb6f4e22f270971b8066d4c18f2a3c153409a" translate="yes" xml:space="preserve">
          <source>MB_LEN_MAX</source>
          <target state="translated">MB_LEN_MAX</target>
        </trans-unit>
        <trans-unit id="0beb871a186f42594bcfbcc8916c8146ec93832e" translate="yes" xml:space="preserve">
          <source>MOESI protocol</source>
          <target state="translated">MOESI 프로토콜</target>
        </trans-unit>
        <trans-unit id="fc1086b9f1dd6c6f26d36bd306a911dfb2aafce8" translate="yes" xml:space="preserve">
          <source>Macro constants</source>
          <target state="translated">매크로 상수</target>
        </trans-unit>
        <trans-unit id="5b3a11a44726526a8271fd69a51140ab465210aa" translate="yes" xml:space="preserve">
          <source>Macro name</source>
          <target state="translated">매크로 이름</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="f314f8acf113225093359e0691186dc638458d3f" translate="yes" xml:space="preserve">
          <source>Macros for data types</source>
          <target state="translated">데이터 타입을위한 매크로</target>
        </trans-unit>
        <trans-unit id="ba899554a515d485fa28c53abcd1d69078a0360c" translate="yes" xml:space="preserve">
          <source>Macros reporting error conditions</source>
          <target state="translated">오류보고 매크로</target>
        </trans-unit>
        <trans-unit id="e4ac70ee360a262794e6e975e302e13279210903" translate="yes" xml:space="preserve">
          <source>Main function</source>
          <target state="translated">주요 기능</target>
        </trans-unit>
        <trans-unit id="02c62a0130255054719e58a94558825165817b75" translate="yes" xml:space="preserve">
          <source>Manipulation</source>
          <target state="translated">Manipulation</target>
        </trans-unit>
        <trans-unit id="448d8cbb56aa359da0ecf466971d54b6d58517dd" translate="yes" xml:space="preserve">
          <source>Many additional errno constants are &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html&quot;&gt;defined by POSIX&lt;/a&gt; and by the &lt;a href=&quot;http://en.cppreference.com/w/cpp/error/errno_macros.html&quot;&gt;C++ standard library&lt;/a&gt;, and individual implementations may define even more, e.g. &lt;code&gt;errno(3)&lt;/code&gt; on Linux or &lt;code&gt;intro(2)&lt;/code&gt; on BSD and OS X.</source>
          <target state="translated">많은 추가 errno 상수는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html&quot;&gt;POSIX&lt;/a&gt; 및 &lt;a href=&quot;http://en.cppreference.com/w/cpp/error/errno_macros.html&quot;&gt;C ++ 표준 라이브러리에&lt;/a&gt; 의해 정의되며 개별 구현은 더 많은 것을 정의 할 수 있습니다 (예 : Linux의 경우 &lt;code&gt;errno(3)&lt;/code&gt; &lt;code&gt;intro(2)&lt;/code&gt; , BSD 및 OS X의 경우 intro (2)) .</target>
        </trans-unit>
        <trans-unit id="6931c181d5bfb62e03fac75baee4578598fdff18" translate="yes" xml:space="preserve">
          <source>Many compilers provide, as a language extension, the opposite of &lt;code&gt;restrict&lt;/code&gt;: an attribute indicating that pointers may alias even if their types differ: &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Common-Type-Attributes.html#index-g_t_0040code_007bmay_005falias_007d-type-attribute-3667&quot;&gt;may_alias (gcc)&lt;/a&gt;,</source>
          <target state="translated">많은 컴파일러는 언어 확장으로서 &lt;code&gt;restrict&lt;/code&gt; 의 반대를 제공합니다 . 유형이 다른 경우에도 포인터의 별칭이 지정 될 수 있음을 나타내는 속성 : &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Common-Type-Attributes.html#index-g_t_0040code_007bmay_005falias_007d-type-attribute-3667&quot;&gt;may_alias (gcc)&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="e739ce5fcc5f3f4b42ffb007f279ffff437b04aa" translate="yes" xml:space="preserve">
          <source>Many implementations also provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers of random origin, e.g. if they are implemented as addresses within continuous (&quot;flat&quot;) virtual address space.</source>
          <target state="translated">많은 구현들은 또한 , 예를 들어 연속 ( &quot;플랫 (flat)&quot;) 가상 주소 공간 내에서 주소로 구현되는 경우, 임의의 기원의 포인터의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;엄격한 총 순서&lt;/a&gt; 를 제공 한다.</target>
        </trans-unit>
        <trans-unit id="afe6902aeefe49078fe8050bd00528c238507028" translate="yes" xml:space="preserve">
          <source>Maps the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE mapping category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;desc&lt;/code&gt; 로 식별 된 현재 C 로케일의 LC_CTYPE 맵핑 범주를 사용하여 와이드 문자 &lt;code&gt;wc&lt;/code&gt; 를 맵핑 합니다.</target>
        </trans-unit>
        <trans-unit id="20eb57cf8e0dada9d1ba105b859145de9af95dd7" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic cosine is cosh z =</source>
          <target state="translated">쌍곡 코사인의 수학적 정의는 cosh z =</target>
        </trans-unit>
        <trans-unit id="26750d755fd0345482bcbffe431aa399db954d60" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic sine is sinh z =</source>
          <target state="translated">쌍곡 사인의 수학적 정의는 sinh z =</target>
        </trans-unit>
        <trans-unit id="e84aec3fc0130942848a9f7d933b06ea09b78dbd" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic tangent is tanh z =</source>
          <target state="translated">쌍곡 탄젠트의 수학적 정의는 tanh z =</target>
        </trans-unit>
        <trans-unit id="5d307dd0d56fc9ce2efcd46807c5cc26c88385c1" translate="yes" xml:space="preserve">
          <source>Mathematics argument out of domain of function</source>
          <target state="translated">기능 영역에서 벗어난 수학 인수</target>
        </trans-unit>
        <trans-unit id="95535f5fff56fffd3265c38e515a7ce818f8ca34" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://gcc.godbolt.org/z/JGG6uI&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;https://gcc.godbolt.org/z/JGG6uI&quot;&gt;demo&lt;/a&gt; ) 로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9d91c4e0e5a561cc8bcd98fba8637034e652ffe" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/qoD2uP&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;https://godbolt.org/z/qoD2uP&quot;&gt;demo&lt;/a&gt; ) 로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0cc72619aac7a4cf0bcebd68e5add9be2ee96a0" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/u9lBlY&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;https://godbolt.org/z/u9lBlY&quot;&gt;demo&lt;/a&gt; ) 로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4a3f6dac60ae11f5101c8d958bc4cdaa80179b" translate="yes" xml:space="preserve">
          <source>May produce the following output (observed with an older version of gcc):</source>
          <target state="translated">다음과 같은 출력을 생성 할 수 있습니다 (이전 버전의 gcc에서 관찰 됨).</target>
        </trans-unit>
        <trans-unit id="9ab548f533a5dfb3713984e2e04a561874b83b35" translate="yes" xml:space="preserve">
          <source>May result in several characters.</source>
          <target state="translated">여러 문자가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="d880b0db33396f09e94ad458e37bf499710140d0" translate="yes" xml:space="preserve">
          <source>Member access</source>
          <target state="translated">회원 액세스</target>
        </trans-unit>
        <trans-unit id="b6f75affe1ded2ede961bf4f202b991666893f21" translate="yes" xml:space="preserve">
          <source>Member access and indirection</source>
          <target state="translated">회원 액세스 및 간접</target>
        </trans-unit>
        <trans-unit id="cf9ba14f65379b3cac2135b4415ee8ccd2ae4dbf" translate="yes" xml:space="preserve">
          <source>Member access operators</source>
          <target state="translated">회원 액세스 운영자</target>
        </trans-unit>
        <trans-unit id="c3746cba5e08f53ae8a220d752c07da9da06400d" translate="yes" xml:space="preserve">
          <source>Member access operators allow access to the members of their operands.</source>
          <target state="translated">멤버 액세스 연산자는 피연산자 멤버에 대한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9c7e8ffcea9d076b657afb05ac63f6cdb3840618" translate="yes" xml:space="preserve">
          <source>Member access through pointer</source>
          <target state="translated">포인터를 통한 회원 액세스</target>
        </trans-unit>
        <trans-unit id="d4037494affff8e1187b4614057e3d3856936fa0" translate="yes" xml:space="preserve">
          <source>Member objects</source>
          <target state="translated">멤버 객체</target>
        </trans-unit>
        <trans-unit id="f8b9af79a08c4c809a8587ce76e5d96c65e611a2" translate="yes" xml:space="preserve">
          <source>Memory location</source>
          <target state="translated">메모리 위치</target>
        </trans-unit>
        <trans-unit id="ab97ff6f2dba5d3f1cd5aeb9b43d517c7ff39baa" translate="yes" xml:space="preserve">
          <source>Memory model</source>
          <target state="translated">메모리 모델</target>
        </trans-unit>
        <trans-unit id="32fe20c2f36eda870198c7a491e5b2f8a3403333" translate="yes" xml:space="preserve">
          <source>Memory model and Data races</source>
          <target state="translated">메모리 모델 및 데이터 레이스</target>
        </trans-unit>
        <trans-unit id="6b03cc66f3ec38d27d0315d16067b31e093e9aea" translate="yes" xml:space="preserve">
          <source>Memory order</source>
          <target state="translated">메모리 순서</target>
        </trans-unit>
        <trans-unit id="47dddb5186287e21994356577aa0866b4c1d8ea3" translate="yes" xml:space="preserve">
          <source>Microsoft also extends the specification of fflush by defining its effects on an input stream: in Visual Studio 2013 and prior, it &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;discarded the input buffer&lt;/a&gt;, in Visual Studio 2015 and newer, it &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;has no effect, buffers are retained&lt;/a&gt;.</source>
          <target state="translated">Microsoft는 또한 입력 스트림에 대한 효과를 정의하여 fflush의 사양을 확장합니다. Visual Studio 2013 및 이전 버전에서는 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;입력 버퍼를 버리고&lt;/a&gt; Visual Studio 2015 이상 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;에서는 버퍼가 유지되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="3ce8b4533320109cd04f4470828d9c5df9d7e9f9" translate="yes" xml:space="preserve">
          <source>Modifiable lvalue expressions</source>
          <target state="translated">수정 가능한 lvalue 표현식</target>
        </trans-unit>
        <trans-unit id="2b3cc44d73da07886ee8baef1ee867321f0ada02" translate="yes" xml:space="preserve">
          <source>Modifying the object references through the returned pointer is undefined behavior.</source>
          <target state="translated">반환 된 포인터를 통해 객체 참조를 수정하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ebfc8aea76355cffda7dc26e5f6ffed8b15e2998" translate="yes" xml:space="preserve">
          <source>Modifying the string returned by &lt;code&gt;getenv&lt;/code&gt; invokes undefined behavior.</source>
          <target state="translated">&lt;code&gt;getenv&lt;/code&gt; 가 리턴 한 문자열을 수정 하면 정의되지 않은 동작이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ba486ce8a0bc9ff868847c4d17e3966a68af4067" translate="yes" xml:space="preserve">
          <source>Monetary numeric formatting parameters</source>
          <target state="translated">통화 숫자 형식화 매개 변수</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="e62a8c15144afd6bef7aa39651c138fe6e1aae25" translate="yes" xml:space="preserve">
          <source>Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">대부분의 멀티 바이트 문자 인코딩은 단일 바이트 코드를 사용하여 ASCII 문자 세트의 문자를 나타냅니다. 이 함수는 이러한 문자를 &lt;code&gt;wchar_t&lt;/code&gt; 로 변환하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f8d7e56567813ec670a96434271711fd5ba5ee" translate="yes" xml:space="preserve">
          <source>Most statements in a typical C program are expression statements, such as assignments or function calls.</source>
          <target state="translated">일반적인 C 프로그램에서 대부분의 명령문은 할당 또는 함수 호출과 같은 표현식 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="e55336fdb98f11cedfd0e48efbdbb786db1d30e0" translate="yes" xml:space="preserve">
          <source>Moves the file position indicator to the beginning of the given file stream.</source>
          <target state="translated">파일 위치 표시기를 지정된 파일 스트림의 시작 부분으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="737f5043d52ad9a5bf99e386e8ced8ff5c737ec0" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversions</source>
          <target state="translated">멀티 바이트 / 와이드 문자 변환</target>
        </trans-unit>
        <trans-unit id="32c9d2fed20c35b9815e377cad73f06efe9e5a37" translate="yes" xml:space="preserve">
          <source>Multicharacter constants were inherited by C from the B programming language. Although not specified by the C standard, compilers implement multicharacter constants as specified in B: the values of each char in the constant initialize successive bytes of the resulting integer, in big-endian zero-padded right-adjusted order, e.g. the value of &lt;code&gt;'\1'&lt;/code&gt; is &lt;code&gt;0x00000001&lt;/code&gt; and the value of &lt;code&gt;'\1\2\3\4'&lt;/code&gt; is &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">다중 문자 상수는 B 프로그래밍 언어에서 C로 상속되었습니다. C 표준에 의해 지정되지는 않았지만 컴파일러는 B에 지정된대로 다중 문자 상수를 구현합니다. 상수의 각 문자 값은 결과 정수의 연속 바이트를 빅 엔디안이 0으로 채워진 오른쪽 조정 순서로 초기화합니다 (예 : &lt;code&gt;'\1'&lt;/code&gt; 은 &lt;code&gt;0x00000001&lt;/code&gt; 이고 &lt;code&gt;'\1\2\3\4'&lt;/code&gt; 은 &lt;code&gt;0x01020304&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00762e90f2d0e1fc656e0809cb403c7716fbb355" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays</source>
          <target state="translated">다차원 배열</target>
        </trans-unit>
        <trans-unit id="5aab5fbc4c12aae804f94ed1d461c1801fe8cbc3" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays may be variably modified in every dimension:</source>
          <target state="translated">다차원 배열은 모든 차원에서 다양하게 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="454f13662bebbfb41c67ae8683c94844b3620fc0" translate="yes" xml:space="preserve">
          <source>Multiple adjacent bit fields are permitted to be (and usually are) packed together:</source>
          <target state="translated">여러 개의 인접한 비트 필드는 함께 포장 될 수 있습니다 (보통).</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="3385a32109aa5346add0ca1e71e6f6b9c5a102b4" translate="yes" xml:space="preserve">
          <source>Multiplication, division, and remainder</source>
          <target state="translated">곱셈, 나눗셈 및 나머지</target>
        </trans-unit>
        <trans-unit id="2e1863d77d06e578e88a57a55375c7c7a23d1f8f" translate="yes" xml:space="preserve">
          <source>Multiplicative operators</source>
          <target state="translated">곱하기 연산자</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">상호 배제</target>
        </trans-unit>
        <trans-unit id="b0363fa62bd61d022ffc95530b594214943aa388" translate="yes" xml:space="preserve">
          <source>Mutual exclusion locks, such as &lt;a href=&quot;../thread#Mutual_exclusion&quot;&gt;mutexes&lt;/a&gt; or &lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;atomic spinlocks&lt;/a&gt;, are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.</source>
          <target state="translated">&lt;a href=&quot;../thread#Mutual_exclusion&quot;&gt;뮤텍스&lt;/a&gt; 또는 &lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;원자 스핀 록&lt;/a&gt; 과 같은 상호 배제 잠금 은 릴리스 획득 동기화의 예입니다. 잠금이 스레드 A에 의해 해제되고 스레드 B에 의해 획득 될 때 컨텍스트의 중요 섹션 (릴리스 이전)에서 발생한 모든 것 스레드 A의 스레드는 동일한 임계 섹션을 실행하는 스레드 B (수집 후)에 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d82a19a46f2f7da0f84cb56740a41e0148eda5c1" translate="yes" xml:space="preserve">
          <source>NAN</source>
          <target state="translated">NAN</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="c3fd46dfa19a7c79969c89f9ce44fe302c2a8a35" translate="yes" xml:space="preserve">
          <source>NaN values never compare equal to themselves or to other NaN values. Copying a NaN may change its bit pattern.</source>
          <target state="translated">NaN 값은 자신이나 다른 NaN 값과 같지 않습니다. NaN을 복사하면 비트 패턴이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f58f34ad9177ffaac728689bdd4d10c1855a024" translate="yes" xml:space="preserve">
          <source>Names at file scope that are &lt;code&gt;const&lt;/code&gt; and not &lt;code&gt;extern&lt;/code&gt; have external linkage in C (as the default for all file-scope declarations), but internal linkage in C++.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 가 아닌 &lt;code&gt;extern&lt;/code&gt; 이 아닌 파일 범위의 이름은 C에서 외부 연결을 갖지만 (모든 파일 범위 선언의 기본값) C ++에서 내부 연결을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8655490bdfd99b50e55540721bde65050a10ca66" translate="yes" xml:space="preserve">
          <source>Narrow and wide orientation</source>
          <target state="translated">좁고 넓은 방향</target>
        </trans-unit>
        <trans-unit id="d6f5cbdcb5ba2c44829f73b263418c7c018a552d" translate="yes" xml:space="preserve">
          <source>Narrow character</source>
          <target state="translated">좁은 캐릭터</target>
        </trans-unit>
        <trans-unit id="6a4742e8a9730fb2d9ea65a3e7a57cdd49ba4360" translate="yes" xml:space="preserve">
          <source>Narrows a wide character &lt;code&gt;c&lt;/code&gt; if its multibyte character equivalent in the initial shift state is a single byte.</source>
          <target state="translated">초기 시프트 상태에서 동등한 멀티 바이트 문자가 단일 바이트 인 경우 와이드 문자 &lt;code&gt;c&lt;/code&gt; 를 좁 힙니다 .</target>
        </trans-unit>
        <trans-unit id="04f16ffe8ceea800ccba7f7bd10fa080ec5a0a67" translate="yes" xml:space="preserve">
          <source>Nearest integer floating-point operations</source>
          <target state="translated">가장 가까운 정수 부동 소수점 연산</target>
        </trans-unit>
        <trans-unit id="dfaab505f47d58982ff129c9d7d12a74d6eb3cc8" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; appears before &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">사전에 &lt;code&gt;rhs&lt;/code&gt; 앞에 &lt;code&gt;lhs&lt;/code&gt; 가 나타나는 경우 음수 값 입니다.</target>
        </trans-unit>
        <trans-unit id="87491531316873a8136087161a4d5513bf956b22" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 가 음수 인 경우 음수</target>
        </trans-unit>
        <trans-unit id="282e0a77a7206269a1ec03af267a85cf22416793" translate="yes" xml:space="preserve">
          <source>Negative value if the value of the first differing wide character in &lt;code&gt;lhs&lt;/code&gt; is less than the value of the corresponding wide character in &lt;code&gt;rhs&lt;/code&gt;: &lt;code&gt;lhs&lt;/code&gt; precedes &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 에서 첫 번째로 다른 넓은 문자 의 값이 &lt;code&gt;rhs&lt;/code&gt; 에서 해당하는 넓은 문자의 값보다 작은 경우 음의 값 : &lt;code&gt;lhs&lt;/code&gt; 는 사전 순서대로 &lt;code&gt;rhs&lt;/code&gt; 앞에옵니다 .</target>
        </trans-unit>
        <trans-unit id="4e8f16b0eb3587cc0715dedcfccca0caab77a9f2" translate="yes" xml:space="preserve">
          <source>Nested arrays</source>
          <target state="translated">중첩 배열</target>
        </trans-unit>
        <trans-unit id="2b5ce0ad5f2d33fb3c44feeea906ae1d01efd7ba" translate="yes" xml:space="preserve">
          <source>Nested initialization</source>
          <target state="translated">중첩 초기화</target>
        </trans-unit>
        <trans-unit id="65fdd1c5c202bebe38d3641541a2e30d93452185" translate="yes" xml:space="preserve">
          <source>Nested scopes</source>
          <target state="translated">중첩 된 범위</target>
        </trans-unit>
        <trans-unit id="01117481b3d9ae41aba5fe6ef84e04f5a4c5d0b0" translate="yes" xml:space="preserve">
          <source>No floating-point exceptions are raised.</source>
          <target state="translated">부동 소수점 예외는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16941a37d8867c9031785f74d58aab34ae39bbe3" translate="yes" xml:space="preserve">
          <source>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.</source>
          <target state="translated">입력이 소비되지 않습니다. 할당 횟수를 늘리지 않습니다. 지정자가 지정 억제 연산자를 정의한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a57a8139ba5f8ff1aec908ab19000c109132ce91" translate="yes" xml:space="preserve">
          <source>No other guarantees are offered</source>
          <target state="translated">다른 보증은 제공되지 않습니다</target>
        </trans-unit>
        <trans-unit id="98ec929c8a01c87825d8f15fd43b7f0878d5d529" translate="yes" xml:space="preserve">
          <source>No two type-names in the association-list may specify &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible types&lt;/a&gt;. There may be only one association that uses the keyword &lt;code&gt;default&lt;/code&gt;. If &lt;code&gt;default&lt;/code&gt; is not used and none of the type-names are compatible with the type of the controlling expression, the program will not compile.</source>
          <target state="translated">연관리스트의 두 유형 이름은 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환 가능한 유형을&lt;/a&gt; 지정할 수 없습니다 . 키워드 &lt;code&gt;default&lt;/code&gt; 를 사용하는 연관은 하나만있을 수 있습니다 . 경우 &lt;code&gt;default&lt;/code&gt; 사용 유형 - 이름의 아무도 제어 식의 유형과 호환되지 않습니다되지 않으며, 프로그램이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="411e6d0559351d7469db7694555ed7a0f5389c12" translate="yes" xml:space="preserve">
          <source>Non-VLA &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; can be repeated as long as it names the same type:</source>
          <target state="translated">VLA가 아닌 &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 는 동일한 유형의 이름을 갖는 한 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="193bc621c98ae221eaef288f8d181a1b34a9f35d" translate="yes" xml:space="preserve">
          <source>Non-local jumps</source>
          <target state="translated">로컬이 아닌 점프</target>
        </trans-unit>
        <trans-unit id="dfa36cd478bb4344736c7959a40d7f343ded79e2" translate="yes" xml:space="preserve">
          <source>Non-lvalue object expressions</source>
          <target state="translated">비 가치 객체 표현식</target>
        </trans-unit>
        <trans-unit id="28af95d5aac585ab47289daeae8748e967982758" translate="yes" xml:space="preserve">
          <source>Non-monetary numeric formatting parameters</source>
          <target state="translated">비 금전적 숫자 형식화 매개 변수</target>
        </trans-unit>
        <trans-unit id="56bf8a2db4b645a79c4849be1f959268b928c0e2" translate="yes" xml:space="preserve">
          <source>Non-negative value representing the number of arguments passed to the program from the environment in which the program is run.</source>
          <target state="translated">프로그램이 실행되는 환경에서 프로그램에 전달 된 인수 수를 나타내는 음이 아닌 값.</target>
        </trans-unit>
        <trans-unit id="72624912ab07ac9814916ad08bbf7c1a7f1d9b97" translate="yes" xml:space="preserve">
          <source>Non-standard pragmas</source>
          <target state="translated">비표준 pragma</target>
        </trans-unit>
        <trans-unit id="5da7e44ba455476d241318f01d6d22076a05a3c6" translate="yes" xml:space="preserve">
          <source>Non-zero if the character &lt;code&gt;wc&lt;/code&gt; has the property identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale, zero otherwise.</source>
          <target state="translated">문자 &lt;code&gt;wc&lt;/code&gt; 에 현재 C 로케일의 LC_CTYPE 패싯에서 &lt;code&gt;desc&lt;/code&gt; 로 식별 된 특성이 있으면 0이 아닌 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="65eeb598af710e2098a61e3ed6c93e3c8ce594b9" translate="yes" xml:space="preserve">
          <source>Non-zero value if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same value, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">영이 아닌 값 경우 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 동일한 값을 참조 &lt;code&gt;​0​&lt;/code&gt; 그렇지에게.</target>
        </trans-unit>
        <trans-unit id="cac3d852cb68231a437ace85c2c4a8c49a18a927" translate="yes" xml:space="preserve">
          <source>Non-zero value if a non-local jump was just performed. The return value is the same as passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬이 아닌 점프가 수행 된 경우 0이 아닌 값. 리턴 값은 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 에 전달 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="900ee6797efd5e52fdc75d73717ea25ebb3e309c" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character can be printed, zero otherwise.</source>
          <target state="translated">문자를 인쇄 할 수 있으면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="00f11f572546e4bec188a078d2a9e68b51039891" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character has a graphical representation character, zero otherwise.</source>
          <target state="translated">문자에 그래픽 표현 문자가 있으면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="f0a7dd58e4b2983a42eee0bbc242681d141522e1" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a blank character, zero otherwise.</source>
          <target state="translated">문자가 공백 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="573c2f1c1338c5749b009db6f886cc21167460ad" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a control character, zero otherwise.</source>
          <target state="translated">문자가 제어 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="645b6766f8a577c38101f8fb20cfb58a2045c32e" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a lowercase letter, zero otherwise.</source>
          <target state="translated">문자가 소문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="5f0261c6f4c85b95254a513c02aebf02ec699cc6" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a numeric character, zero otherwise.</source>
          <target state="translated">문자가 숫자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="f91aea7f894e54ec23e392ad63a4306e917989bd" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a punctuation character, zero otherwise.</source>
          <target state="translated">문자가 문장 부호 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="e557296858a7842a41ea087ef4dc7cb9964a42bf" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is a whitespace character, zero otherwise.</source>
          <target state="translated">문자가 공백 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="739526fe168a72c3c1f6dcbbb361462f93f70e5d" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an alphabetic character, zero otherwise.</source>
          <target state="translated">문자가 알파벳 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="4e542ca374323f362fab4f69485d18e59e7d40ec" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an alphanumeric character, &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">문자가 영숫자 문자이면 &lt;code&gt;0&lt;/code&gt; 이 아닌 값이고, 그렇지 않으면 0 입니다.</target>
        </trans-unit>
        <trans-unit id="d4c4a5067b4fe1c0dcec7c0fdd14829018a9fafe" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an hexadecimal numeric character, zero otherwise.</source>
          <target state="translated">문자가 16 진수 인 경우 0이 아닌 값, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="eb103ab4ed106f58e123123deeaecdec23cd1314" translate="yes" xml:space="preserve">
          <source>Non-zero value if the character is an uppercase letter, zero otherwise.</source>
          <target state="translated">문자가 대문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="01bce746578de779ccced60e366fe7c795db125a" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character can be printed, zero otherwise.</source>
          <target state="translated">넓은 문자를 인쇄 할 수 있으면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="812d84021000de30e2a91876134da9368a351dc2" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character has a graphical representation character, zero otherwise.</source>
          <target state="translated">넓은 문자에 그래픽 표현 문자가 있으면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="545ec9f1b51fd7624d595a810214fcee5cc4ade5" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a alphabetic character, zero otherwise.</source>
          <target state="translated">넓은 문자가 알파벳 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="6061e0221ac50001f9c505509407314da40799b9" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a alphanumeric character, zero otherwise.</source>
          <target state="translated">넓은 문자가 영숫자 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="c1ee7958639648ee011e8faa7e9ae18330b62fbb" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a blank character, zero otherwise.</source>
          <target state="translated">넓은 문자가 공백 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="fc06c5d778a941c31c4589906a0d0c89c4244147" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a control character, zero otherwise.</source>
          <target state="translated">넓은 문자가 제어 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="764367d8a927867322e0b363e253e0c2282b8d92" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a hexadecimal numeric character, zero otherwise.</source>
          <target state="translated">넓은 문자가 16 진 숫자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="cf5849ae23f0e34f5e3d8fde24b1da25b1eb7db3" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a punctuation character, zero otherwise.</source>
          <target state="translated">넓은 문자가 문장 부호 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="b9704dceccf4f8acbf2dca35e962fbe869f3c4c3" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is a whitespace character, zero otherwise.</source>
          <target state="translated">넓은 문자가 공백 문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="bd6da9a6888802869d6bd527adae2e52402fbd0a" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is an lowercase letter, zero otherwise.</source>
          <target state="translated">넓은 문자가 소문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="c907aa58db4cbc21247085765be4eb83901ffdcd" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is an numeric character, zero otherwise.</source>
          <target state="translated">넓은 문자가 숫자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="3326d07c04286a9aab352ed3d2e8d2c4220c3858" translate="yes" xml:space="preserve">
          <source>Non-zero value if the wide character is an uppercase letter, zero otherwise.</source>
          <target state="translated">넓은 문자가 대문자이면 0이 아닌 값이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="3519f25b9bca3cbf93a434f74b038988d38b8e81" translate="yes" xml:space="preserve">
          <source>Nonlocal jumps</source>
          <target state="translated">비 로컬 점프</target>
        </trans-unit>
        <trans-unit id="4d16e4909a855dfacd2e348d51095c22d8bb698f" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; has an infinite value, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">제로가 아닌 경우에 적분 값이 &lt;code&gt;arg&lt;/code&gt; 무한 값을 갖는 &lt;code&gt;​0​&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="f83f615f202b09eda83fd6ba33d8c844ea324845" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; has finite value, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">제로가 아닌 정수 값이 경우 &lt;code&gt;arg&lt;/code&gt; 유한 값이 &lt;code&gt;​0​&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="ac09c0914c09c76af0c3a8e33bdfa6f66790b329" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">제로가 아닌 정수 값 경우 &lt;code&gt;arg&lt;/code&gt; NaN인지한다 &lt;code&gt;​0​&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="5100fccd71cf98586e448e0183b50c098a585490" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; is negative, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">제로가 아닌 정수 값 &lt;code&gt;arg&lt;/code&gt; 음수 인 &lt;code&gt;​0​&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="997efa8f5cb082b923297ca535f7828db07ffae3" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;arg&lt;/code&gt; is normal, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">제로가 아닌 경우에 적분 값이 &lt;code&gt;arg&lt;/code&gt; , 정상 &lt;code&gt;​0​&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="786a61ba2a7fce5ee3e48a622963070d5717764a" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">적분 값이 0이 아니면 &lt;code&gt;x &amp;gt; y&lt;/code&gt; , &lt;code&gt;​0​&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="afa9e79a7a436cc1b8582355921944221cf323a2" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;gt;= y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">적분 값이 0이 아니면 &lt;code&gt;x &amp;gt;= y&lt;/code&gt; , &lt;code&gt;​0​&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="3536a068fcc62c3c7ca3479a475715f9b5a76784" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt; 경우 0이 아닌 정수 값 x&amp;gt; Y , &lt;code&gt;​0​&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="a4fd0a4307c1864cd327f9b7321b93655d347dbc" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">적분 값이 0이 아니면 &lt;code&gt;x &amp;lt; y&lt;/code&gt; , &lt;code&gt;​0​&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="899df7f07b5332bae826ae9835de0e6583359def" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if &lt;code&gt;x &amp;lt;= y&lt;/code&gt;, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">적분 값이 0이 아니면 &lt;code&gt;x &amp;lt;= y&lt;/code&gt; , &lt;code&gt;​0​&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="d37cb3687139ff48af89d9b130a861b9adcda7b9" translate="yes" xml:space="preserve">
          <source>Nonzero integral value if either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">적분 값이 제로가 아닌 경우, 어느 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; NaN의 &lt;code&gt;​0​&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="d2a9098a34d521b830e5b13b1b8cab6cf947a729" translate="yes" xml:space="preserve">
          <source>Nonzero value if the file stream has errors occurred, &lt;code&gt;​0​&lt;/code&gt; otherwise.</source>
          <target state="translated">파일 스트림에 오류가있는 경우이 아닌 값은 발생 &lt;code&gt;​0​&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="7a995d52089af1ca1c3e17ca5083742ff6c6d197" translate="yes" xml:space="preserve">
          <source>Not all &lt;code&gt;size&lt;/code&gt; bytes will necessarily be used for buffering: the actual buffer size is usually rounded down to a multiple of 2, a multiple of page size, etc.</source>
          <target state="translated">모든 &lt;code&gt;size&lt;/code&gt; 바이트가 반드시 버퍼링에 사용되는 것은 아닙니다 . 실제 버퍼 크기는 일반적으로 2의 배수, 페이지 크기의 배수 등으로 내림됩니다.</target>
        </trans-unit>
        <trans-unit id="463ea1aceb837fc90a032c7ce4723b9fe8359f01" translate="yes" xml:space="preserve">
          <source>Not-a-number is converted to &lt;code&gt;nan&lt;/code&gt; or &lt;code&gt;nan(&lt;i&gt;char_sequence&lt;/i&gt;)&lt;/code&gt;. Which one is used is implementation defined.</source>
          <target state="translated">비 숫자는 &lt;code&gt;nan&lt;/code&gt; 또는 &lt;code&gt;nan(&lt;i&gt;char_sequence&lt;/i&gt;)&lt;/code&gt; 로 변환됩니다 . 사용되는 것은 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4dae11725fccb85cb2075cf06771887f92e991d7" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt; to _Bool does not work the same as conversion to other integer types: &lt;code&gt;(bool)0.5&lt;/code&gt; evaluates to &lt;code&gt;1&lt;/code&gt;, whereas &lt;code&gt;(int)0.5&lt;/code&gt; evaluates to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;conversion&quot;&gt;변환&lt;/a&gt; : _Bool에 다른 종류의 정수 변환과 같은 동작을하지 않는다 &lt;code&gt;(bool)0.5&lt;/code&gt; 로 평가 &lt;code&gt;1&lt;/code&gt; 반면, &lt;code&gt;(int)0.5&lt;/code&gt; 로 평가를 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bfff64c74e2709b14e6d6fc437e2a178f5ae171" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;restrict&quot;&gt;restrict qualifier&lt;/a&gt; can be used to indicate that two pointers do not alias even if the rules above permit them to be.</source>
          <target state="translated">참고 &lt;a href=&quot;restrict&quot;&gt;한정자를 제한은&lt;/a&gt; 두 개의 포인터가 허용 위의 규칙들이 될 경우에도 별칭을하지 않는 것을 나타 내기 위해서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62ffe676e9f8865c76efc456731aec7949383f5f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;float &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; are not promoted to &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; in this context.</source>
          <target state="translated">참고 &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;float &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 승격되지 않은 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; 이런 맥락이다.</target>
        </trans-unit>
        <trans-unit id="c07c8b6bfea785e0db5f4ccd4474b2a63a1f16b3" translate="yes" xml:space="preserve">
          <source>Note that a new struct name may also be introduced just by using a struct tag within another declaration, but if a previously declared struct with the same name exists in the tag &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, the tag would refer to that name.</source>
          <target state="translated">다른 선언 내에서 struct 태그를 사용하여 새 struct 이름을 도입 할 수도 있지만, 같은 이름을 가진 이전에 선언 된 struct가 태그 &lt;a href=&quot;name_space&quot;&gt;네임 스페이스에&lt;/a&gt; 존재 하면 태그는 해당 이름을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="f930f4eef330093e341733bd4324d01868d5ef8c" translate="yes" xml:space="preserve">
          <source>Note that a struct/union rvalue that has a member (possibly nested) of array type does in fact designate an object with &lt;a href=&quot;lifetime&quot;&gt;temporary lifetime&lt;/a&gt;. This object can be accessed through lvalue expressions that form by indexing the array member or by indirection through the pointer obtained by array-to-pointer conversion of the array member.</source>
          <target state="translated">배열 유형의 멤버 (중첩 될 수 있음)가있는 struct / union rvalue는 실제로 &lt;a href=&quot;lifetime&quot;&gt;임시 수명이&lt;/a&gt; 있는 오브젝트를 지정합니다 . 이 객체는 배열 멤버를 인덱싱하거나 배열 멤버의 포인터를 포인터로 변환하여 얻은 포인터를 통해 간접적으로 생성되는 lvalue 식을 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd60bc97c60d5c03e64584095b4acd185f943b90" translate="yes" xml:space="preserve">
          <source>Note that actual assignment, in addition to the conversion, also removes extra range and precision from floating-point types and prohibits overlaps; those characteristics do not apply to conversion as if by assignment.</source>
          <target state="translated">변환 외에도 실제 할당은 부동 소수점 유형에서 추가 범위와 정밀도를 제거하고 겹침을 방지합니다. 이러한 특성은 할당에 의한 것처럼 변환에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b01d44e3ef167461171814957b8c751bd69c9afc" translate="yes" xml:space="preserve">
          <source>Note that although each atomic object has its own modification order, it is not a total order; different threads may observe modifications to different atomic objects in different orders.</source>
          <target state="translated">각 원자 객체에는 고유 한 수정 순서가 있지만 전체 순서는 아닙니다. 다른 스레드는 다른 순서로 다른 원자 객체에 대한 수정을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="277df4ee826d3c674927bd5ba9abb77722d7d23a" translate="yes" xml:space="preserve">
          <source>Note that complex and imaginary numbers cannot be compared with these operators.</source>
          <target state="translated">복소수와 허수는이 연산자와 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e419ce8ad7d59785de3678604706b11b55c334c" translate="yes" xml:space="preserve">
          <source>Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.</source>
          <target state="translated">현재 (2/2015) 알려진 프로덕션 컴파일러는 종속성 체인을 추적하지 않습니다. 작업을 획득하기 위해 소비 작업이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f71e9d53dd33e221623d7abb59913618429102cb" translate="yes" xml:space="preserve">
          <source>Note that digraphs &lt;code&gt;&amp;lt;%&lt;/code&gt;, &lt;code&gt;%&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;:&lt;/code&gt;, &lt;code&gt;:&amp;gt;&lt;/code&gt;, &lt;code&gt;%:&lt;/code&gt;, and &lt;code&gt;%:%:&lt;/code&gt; provide an &lt;a href=&quot;language/operator_alternative&quot;&gt;alternative way to represent standard tokens&lt;/a&gt;.</source>
          <target state="translated">참고 이중 음자 &lt;code&gt;&amp;lt;%&lt;/code&gt; , &lt;code&gt;%&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;:&lt;/code&gt; , &lt;code&gt;:&amp;gt;&lt;/code&gt; , &lt;code&gt;%:&lt;/code&gt; 및 &lt;code&gt;%:%:&lt;/code&gt; 제공하는 &lt;a href=&quot;language/operator_alternative&quot;&gt;표준 토큰을 표현하는 다른 방법을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6aa7d9380a3127548e23d156a232aa2b98f7dde7" translate="yes" xml:space="preserve">
          <source>Note that exact-width integer types are available in &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;stdint.h&amp;gt;&lt;/a&gt; since C99.</source>
          <target state="translated">정확한 너비 정수 유형은 C99 이후 &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;stdint.h&amp;gt;&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="050cbe6bb8f2ecec5680c9688cca8a67a8af6dcc" translate="yes" xml:space="preserve">
          <source>Note that if there are multiple or nested declarators in the declaration, the scope ends at the end of the nearest enclosing function declarator:</source>
          <target state="translated">선언에 선언자가 여러 개이거나 중첩 된 경우 범위는 가장 가까운 둘러싸는 함수 선언자 끝에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="3646902728c68bd16b2c1d2a55d86e6f212f0955" translate="yes" xml:space="preserve">
          <source>Note that in C++, it may be an lvalue expression.</source>
          <target state="translated">C ++에서는 lvalue 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b596689d61367604b043d07793cc89c0d3cc0cc1" translate="yes" xml:space="preserve">
          <source>Note that in the example above, the compiler can infer that a and b do not alias because b's constness guarantees that it cannot become dependent on a in the body of the function. Equivalently, the programmer could write &lt;code&gt;void f(int n, float * a, float const * restrict b)&lt;/code&gt;, in which case the compiler can reason that objects referenced through b cannot be modified, and so no modified object can be referenced using both b and a. If the programmer were to write &lt;code&gt;void f(int n, float * restrict a, float * b)&lt;/code&gt;, the compiler would be unable to infer non-aliasing of a and b without examining the body of the function.</source>
          <target state="translated">위의 예에서 컴파일러는 b의 constness가 함수 본문에서 a에 종속 될 수 없음을 보장하기 때문에 a와 b가 별칭을 지정하지 않는다고 유추 할 수 있습니다. 마찬가지로 프로그래머는 &lt;code&gt;void f(int n, float * a, float const * restrict b)&lt;/code&gt; 쓸 수 있습니다.이 경우 컴파일러는 b를 통해 참조 된 객체를 수정할 수 없다고 추론 할 수 있으므로 b를 사용하여 수정 된 객체를 참조 할 수 없습니다 그리고 a. 프로그래머가 &lt;code&gt;void f(int n, float * restrict a, float * b)&lt;/code&gt; 을 작성하는 경우 컴파일러는 함수 본문을 검사하지 않고 a 및 b의 앨리어싱 제거를 유추 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eaafe49e51286eb8b5cfca9bc7d1c5b44fb7fcf6" translate="yes" xml:space="preserve">
          <source>Note that it is permitted for c to point into the array associated with b. Note also that, for these purposes, the &quot;array&quot; associated with a particular pointer means only that portion of an array object which is actually referenced through that pointer.</source>
          <target state="translated">c가 b와 연관된 배열을 가리킬 수 있습니다. 또한 이러한 목적으로 특정 포인터와 관련된 &quot;배열&quot;은 실제로 해당 포인터를 통해 참조되는 배열 객체의 해당 부분 만 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a7b852cea839a1b80599bd0edd7be9cf7efce4da" translate="yes" xml:space="preserve">
          <source>Note that pointer to pointer to &lt;code&gt;T&lt;/code&gt; is not convertible to pointer to pointer to &lt;code&gt;const T&lt;/code&gt;; for two types to be compatible, their qualifications must be identical.</source>
          <target state="translated">포인터 포인터 것을 참고 &lt;code&gt;T&lt;/code&gt; 는 포인터 포인터로 변환되지 않습니다 &lt;code&gt;const T&lt;/code&gt; ; 두 유형이 호환 되려면 해당 자격이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ed914c55a7126dc453874f1a9b4149e50132aa" translate="yes" xml:space="preserve">
          <source>Note that pointer to pointer to &lt;code&gt;T&lt;/code&gt; is not convertible to pointer to pointer to &lt;code&gt;volatile T&lt;/code&gt;; for two types to be compatible, their qualifications must be identical:</source>
          <target state="translated">에 포인터에 그 포인터를 참고 &lt;code&gt;T&lt;/code&gt; 는 포인터 포인터로 변환되지 않습니다 &lt;code&gt;volatile T&lt;/code&gt; ; 두 유형이 호환 되려면 해당 자격이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="304781606b6f8eeefe2f140ee18862708a266ab6" translate="yes" xml:space="preserve">
          <source>Note that the contents of such array are modifiable, unlike when accessing a string literal directly with &lt;code&gt;char* str = &quot;abc&quot;;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char* str = &quot;abc&quot;;&lt;/code&gt; 직접 문자열 리터럴에 액세스 할 때와 달리 이러한 배열의 내용은 수정할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="417346c937dfa81f169a04d968f4db2fc8fe6333" translate="yes" xml:space="preserve">
          <source>Note that the standard library also defines &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; names &lt;a href=&quot;../string/wide&quot;&gt;wchar_t&lt;/a&gt;, &lt;a href=&quot;../string/multibyte&quot;&gt;char16_t&lt;/a&gt;, and &lt;a href=&quot;../string/multibyte&quot;&gt;char32_t&lt;/a&gt;(since C11) to represent wide characters.</source>
          <target state="translated">표준 라이브러리는 또한 와이드 문자를 나타 내기 위해 &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 이름 &lt;a href=&quot;../string/wide&quot;&gt;wchar_t&lt;/a&gt; , &lt;a href=&quot;../string/multibyte&quot;&gt;char16_t&lt;/a&gt; 및 &lt;a href=&quot;../string/multibyte&quot;&gt;char32_t&lt;/a&gt; (C11부터)를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="724173281ae1d1521f2609a2c1a14d6bf54b76fc" translate="yes" xml:space="preserve">
          <source>Note that this means that:</source>
          <target state="translated">이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4c6a22f454209a070f818f1ea2da7aab6744c121" translate="yes" xml:space="preserve">
          <source>Note that type-punning may also be performed through the inactive member of a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;.</source>
          <target state="translated">유형 제거는 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 의 비활성 멤버를 통해 수행 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="272825862d0d9765b3754c8f08a0652223d11df8" translate="yes" xml:space="preserve">
          <source>Note that volatile variables are not suitable for communication between threads; they do not offer atomicity, synchronization, or memory ordering. A read from a volatile variable that is modified by another thread without synchronization or concurrent modification from two unsynchronized threads is undefined behavior due to a data race.</source>
          <target state="translated">휘발성 변수는 스레드 간의 통신에 적합하지 않습니다. 원 자성, 동기화 또는 메모리 순서를 제공하지 않습니다. 동기화되지 않은 두 스레드의 동기화 또는 동시 수정없이 다른 스레드에 의해 수정 된 휘발성 변수의 읽기는 데이터 경쟁으로 인해 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="7ca90d82823999bf34354e86f9433c4064c7150b" translate="yes" xml:space="preserve">
          <source>Note that when array-to-pointer conversion is applied, a multidimensional array is converted to a pointer to its first element, e.g., pointer to the first row:</source>
          <target state="translated">배열에서 포인터로의 변환이 적용되면 다차원 배열은 첫 번째 요소에 대한 포인터 (예 : 첫 번째 행에 대한 포인터)로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5166123be3426460855c992d1da6919d6a02ca19" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#elif cond2&lt;/code&gt; is different from &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#else&lt;/code&gt; followed by &lt;code&gt;#if cond3&lt;/code&gt; because if &lt;code&gt;cond1&lt;/code&gt; is true, the second &lt;code&gt;#if&lt;/code&gt; is skipped and &lt;code&gt;cond3&lt;/code&gt; does not need to be well-formed, while #elif's &lt;code&gt;cond2&lt;/code&gt; must be a valid expression.</source>
          <target state="translated">참고 : &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#elif cond2&lt;/code&gt; 가 &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#else&lt;/code&gt; 다음에 &lt;code&gt;#if cond3&lt;/code&gt; 과 다른 경우 &lt;code&gt;cond1&lt;/code&gt; 이 true이면 두 번째 &lt;code&gt;#if&lt;/code&gt; 를 건너 뛰고 &lt;code&gt;cond3&lt;/code&gt; 을 올바르게 구성 할 필요가 없으므로 &lt;code&gt;cond2&lt;/code&gt; 의 cond2 는 유효한 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9ca7ee7ab9924b43dc53d9b7f8ccf0ae16496091" translate="yes" xml:space="preserve">
          <source>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.</source>
          <target state="translated">참고 : C ++에는 호환되는 유형의 개념이 없습니다. 호환 가능하지만 다른 변환 단위에서 동일하지 않은 두 가지 유형을 선언하는 AC 프로그램은 유효한 C ++ 프로그램이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="17b6534f42776f23d640b14fa30e953bf2bc1b64" translate="yes" xml:space="preserve">
          <source>Note: Some compilers offer an extension that allows ## to appear after a comma and before __VA_ARGS__, in which case the ## does nothing when __VA_ARGS__ is non-empty, but removes the comma when __VA_ARGS__ is empty: this makes it possible to define macros such as &lt;code&gt;fprintf (stderr, format, ##__VA_ARGS__)&lt;/code&gt;.</source>
          <target state="translated">참고 : 일부 컴파일러는 ##을 쉼표와 __VA_ARGS__ 앞에 표시 할 수있는 확장명을 제공합니다.이 경우 __VA_ARGS__가 비어 있지 않으면 ##이 아무 것도 수행하지 않지만 __VA_ARGS__가 비어 있으면 쉼표가 제거됩니다. 같은 매크로 &lt;code&gt;fprintf (stderr, format, ##__VA_ARGS__)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d231be462c294806918af9e22c37b9971c1d8b74" translate="yes" xml:space="preserve">
          <source>Note: actual (as opposed to guaranteed minimal) ranges are available in the library headers &lt;a href=&quot;../types/limits&quot;&gt;&amp;lt;limits.h&amp;gt; and &amp;lt;float.h&amp;gt;&lt;/a&gt;</source>
          <target state="translated">참고 : 실제 범위 (최소 보장되는 것과 달리)는 라이브러리 헤더 &lt;a href=&quot;../types/limits&quot;&gt;&amp;lt;limits.h&amp;gt; 및 &amp;lt;float.h&amp;gt;&lt;/a&gt; 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c92dc308476060211154a0baf7bae96183bba65" translate="yes" xml:space="preserve">
          <source>Note: additional functions whose names begin with either &lt;code&gt;to&lt;/code&gt; or &lt;code&gt;is&lt;/code&gt;, followed by a lowercase letter, may be added to the header &lt;code&gt;ctype.h&lt;/code&gt; in future and should not be defined by programs that include that header.</source>
          <target state="translated">참고 : 이름이 &lt;code&gt;to&lt;/code&gt; 또는 &lt;code&gt;is&lt;/code&gt; 로 시작하고 그 뒤에 소문자가 오는 추가 &lt;code&gt;ctype.h&lt;/code&gt; 는 나중에 ctype.h 헤더에 추가 될 수 있으며 해당 헤더를 포함하는 프로그램에 의해 정의되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="926a7e324c567bbf83cd5f49fda69e0a32e1eb6e" translate="yes" xml:space="preserve">
          <source>Note: as with all type specifiers, any order is permitted: &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt; long double&lt;/code&gt;, and even &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt; long&lt;/code&gt; name the same type.</source>
          <target state="translated">참고 : 모든 유형 지정자와 마찬가지로 &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt; long double&lt;/code&gt; 및 심지어 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt; long&lt;/code&gt; 이름과 동일한 유형의 순서가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="589f92f64734a58912f07f2dac91d32f1c36f85e" translate="yes" xml:space="preserve">
          <source>Note: as with all type specifiers, any order is permitted: &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt; long double&lt;/code&gt;, and even &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt; long&lt;/code&gt; name the same type.</source>
          <target state="translated">참고 : 모든 유형 지정자와 마찬가지로 &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt; long double&lt;/code&gt; , 심지어 &lt;code&gt;double &lt;a href=&quot;../numeric/complex/imaginary&quot;&gt;imaginary&lt;/a&gt; long&lt;/code&gt; name과 같은 모든 순서가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd92ba3582f1b92874cad067dae19867ad7796a3" translate="yes" xml:space="preserve">
          <source>Note: as with all type specifiers, any order is permitted: &lt;code&gt;unsigned long long int&lt;/code&gt; and &lt;code&gt;long int unsigned long&lt;/code&gt; name the same type.</source>
          <target state="translated">참고 : 모든 유형 지정자와 마찬가지로 모든 순서가 허용됩니다. &lt;code&gt;unsigned long long int&lt;/code&gt; 및 &lt;code&gt;long int unsigned long&lt;/code&gt; name은 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1fd1622c785b61daa41df5a69c20ba3e7bfde746" translate="yes" xml:space="preserve">
          <source>Note: besides identifiers that name objects of struct or union type, the following expressions may have struct or union types: &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt;, &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;, &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;conditional operator&lt;/a&gt;, and &lt;a href=&quot;compound_literal&quot;&gt;compound literal&lt;/a&gt;.</source>
          <target state="translated">참고 : 구조체 또는 공용체 유형의 객체를 명명하는 식별자 외에도 다음 표현식에는 구조체 또는 공용체 유형이있을 수 있습니다 : &lt;a href=&quot;operator_assignment&quot;&gt;할당&lt;/a&gt; , &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출&lt;/a&gt; , &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표 연산자&lt;/a&gt; , &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;조건부 연산자&lt;/a&gt; 및 &lt;a href=&quot;compound_literal&quot;&gt;복합 리터럴&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dca76e38dc760fa729353052e71a1192b1a1490" translate="yes" xml:space="preserve">
          <source>Note: besides initializers, brace-enclosed initializer-list may appear in &lt;a href=&quot;compound_literal&quot;&gt;compound literals&lt;/a&gt;, which are expressions of the form:</source>
          <target state="translated">참고 : 이니셜 라이저 외에도 중괄호로 묶인 이니셜 라이저 목록은 &lt;a href=&quot;compound_literal&quot;&gt;복합 리터럴로&lt;/a&gt; 나타날 수 있으며 이는 다음 형식의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="bfd0a9d1f8d4e684125f4debf7e7f5433e62ff46" translate="yes" xml:space="preserve">
          <source>Note: bitwise operators are commonly used to manipulate bit sets and bit masks.</source>
          <target state="translated">참고 : 비트 연산자는 일반적으로 비트 세트 및 비트 마스크를 조작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c13c8466c8ce25f60aa85ce07edd1bf30bff1ea5" translate="yes" xml:space="preserve">
          <source>Note: compilers that do not support these pragmas may provide equivalent compile-time options, such as gcc's &lt;code&gt;-fcx-limited-range&lt;/code&gt; and &lt;code&gt;-ffp-contract&lt;/code&gt;.</source>
          <target state="translated">참고 : 이러한 pragma를 지원하지 않는 컴파일러는 gcc의 &lt;code&gt;-fcx-limited-range&lt;/code&gt; 및 &lt;code&gt;-ffp-contract&lt;/code&gt; 와 같은 컴파일 타임 옵션을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39fc6a0060bd483695677ce701ffb0cb3626cc76" translate="yes" xml:space="preserve">
          <source>Note: despite that, imaginary types are distinct and &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;not compatible&lt;/a&gt; with their corresponding real types, which prohibits aliasing.</source>
          <target state="translated">참고 : 그럼에도 불구하고 허수 유형은 고유하고 해당 실제 유형과 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환되지 않으므로&lt;/a&gt; 앨리어싱이 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="df687f33e33fab93be5f7bb11d3398add8728aa2" translate="yes" xml:space="preserve">
          <source>Note: for unsigned types (after promotion), the expression ~E is equivalent to the maximum value representable by the result type minus the original value of E.</source>
          <target state="translated">참고 : 부호없는 유형 (프로모션 후)의 경우 ~ E 표현식은 결과 유형으로 표시 할 수있는 최대 값에서 원래 값 E를 뺀 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef15aa2f5e33223b513a33e4149b80cb3a815a0e" translate="yes" xml:space="preserve">
          <source>Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (such as &lt;code&gt;macro(array[x = y, x + 1])&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../atomic/atomic_store&quot;&gt;atomic_store&lt;/a&gt; (p, (struct S){ a, b });&lt;/code&gt;), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.</source>
          <target state="translated">참고 : 함수형 매크로의 인수에 일치하는 왼쪽 및 오른쪽 괄호 쌍 (예 : &lt;code&gt;macro(array[x = y, x + 1])&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../atomic/atomic_store&quot;&gt;atomic_store&lt;/a&gt; (p, (struct S){ a, b });&lt;/code&gt; 보호되지 않는 쉼표가 포함 된 경우 {a, b}); ), 쉼표는 매크로 인수 구분 기호로 해석되어 인수 개수 불일치로 인해 컴파일이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="421adc1b62de6ce817db839aa0b4d3305034e9df" translate="yes" xml:space="preserve">
          <source>Note: implementations of bounds-checked functions are available as open-source libraries &lt;a href=&quot;https://github.com/rurban/safeclib/&quot;&gt;Safe C&lt;/a&gt; and &lt;a href=&quot;https://code.google.com/archive/p/slibc/&quot;&gt;Slibc&lt;/a&gt;, and as part of Watcom C. There is also an incompatible set of bounds-checked functions available in Visual Studio.</source>
          <target state="translated">참고 : 경계 검사 함수의 구현은 오픈 소스 라이브러리 &lt;a href=&quot;https://github.com/rurban/safeclib/&quot;&gt;Safe C&lt;/a&gt; 및 &lt;a href=&quot;https://code.google.com/archive/p/slibc/&quot;&gt;Slibc&lt;/a&gt; 및 Watcom C의 일부로 사용할 수 있습니다. Visual Studio에는 호환되지 않는 경계 검사 함수 세트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="50933a8d1b61e11b3841762e3c140d8092ad0792" translate="yes" xml:space="preserve">
          <source>Note: in C++, identifiers with a double underscore anywhere are reserved everywhere; in C, only the ones that begin with a double underscore are reserved.</source>
          <target state="translated">참고 : C ++에서 두 개의 밑줄이있는 식별자는 어디에나 예약되어 있습니다. C에서는 이중 밑줄로 시작하는 문자 만 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="570f5c242f1a5f12b3ad8de85028df03f68cbc8a" translate="yes" xml:space="preserve">
          <source>Note: in Unicode, the ASCII character block is known as &lt;a href=&quot;http://www.unicode.org/charts/PDF/U0000.pdf&quot;&gt;&lt;code&gt;U+0000..U+007F&lt;/code&gt; Basic Latin&lt;/a&gt;.</source>
          <target state="translated">참고 : 유니 코드에서 ASCII 문자 블록은 &lt;a href=&quot;http://www.unicode.org/charts/PDF/U0000.pdf&quot;&gt; &lt;code&gt;U+0000..U+007F&lt;/code&gt; 기본 라틴어&lt;/a&gt; 로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fb6e600b6afadfe5340dc5afe3b0d261da33e62" translate="yes" xml:space="preserve">
          <source>Note: in complex-to-real conversion, a NaN in the imaginary part will not propagate to the real result.</source>
          <target state="translated">참고 : 복소수 변환에서 허수 부분의 NaN은 실제 결과에 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef53134c3cebcaaafdb4136521b343492974fcab" translate="yes" xml:space="preserve">
          <source>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt;, in particular &lt;a href=&quot;operator_arithmetic#Overflows&quot;&gt;integer overflows&lt;/a&gt;.</source>
          <target state="translated">참고 : 정수 산술은 부호있는 정수 유형과 부호없는 정수 유형에 대해 다르게 정의됩니다. &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자&lt;/a&gt; , 특히 &lt;a href=&quot;operator_arithmetic#Overflows&quot;&gt;정수 오버플로를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eeb10617a2c1ff022c4b25bfccfb70bd51bf019" translate="yes" xml:space="preserve">
          <source>Note: integer promotions are applied only.</source>
          <target state="translated">참고 : 정수 승격 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d59e3724c61dc0f71eb6e96b133ae25c8b0787a" translate="yes" xml:space="preserve">
          <source>Note: real and imaginary operands are not implicitly converted to complex because doing so would require extra computation, while producing undesirable results in certain cases involving infinities, NaNs and signed zeros. For example, if reals were converted to complex, 2.0&amp;times;(3.0+i&amp;infin;) would evaluate as (2.0+i0.0)&amp;times;(3.0+i&amp;infin;) &amp;rArr; (2.0&amp;times;3.0&amp;ndash;0.0&amp;times;&amp;infin;) + i(2.0&amp;times;&amp;infin;+0.0&amp;times;3.0) &amp;rArr; NaN+i&amp;infin; rather than the correct 6.0+i&amp;infin;. If imaginaries were converted to complex, i2.0&amp;times;(&amp;infin;+i3.0) would evaluate as (0.0+i2.0) &amp;times; (&amp;infin;+i3.0) &amp;rArr; (0.0&amp;times;&amp;infin; &amp;ndash; 2.0&amp;times;3.0) + i(0.0&amp;times;3.0 + 2.0&amp;times;&amp;infin;) &amp;rArr; NaN + i&amp;infin; instead of &amp;ndash;6.0 + i&amp;infin;.</source>
          <target state="translated">참고 : 실수 및 허수 피연산자는 암시 적으로 복소수로 변환되지 않으므로 추가 계산이 필요하고 무한대, NaN 및 부호있는 0과 관련된 특정 경우 바람직하지 않은 결과가 생성되기 때문입니다. 예를 들어, 실수가 복소수로 변환 된 경우 2.0 &amp;times; (3.0 + i&amp;infin;)는 (2.0 + i0.0) &amp;times; (3.0 + i&amp;infin;) &amp;rArr; (2.0 &amp;times; 3.0&amp;ndash;0.0 &amp;times; &amp;infin;) + i (2.0 &amp;times; &amp;infin; + 0.0 &amp;times; 3.0) &amp;rArr; 올바른 6.0 + i&amp;infin; 대신 NaN + i&amp;infin;. 허수를 복소수로 변환하면 i2.0 &amp;times; (&amp;infin; + i3.0)은 (0.0 + i2.0) &amp;times; (&amp;infin; + i3.0) &amp;rArr; (0.0 &amp;times; &amp;infin; &amp;ndash; 2.0 &amp;times; 3.0) + i (0.0 &amp;times; 3.0 + 2.0 &amp;times; &amp;infin;) &amp;rArr; &amp;ndash;6.0 + i&amp;infin; 대신 NaN + i&amp;infin;.</target>
        </trans-unit>
        <trans-unit id="3c6901600afbe537ad0f0d081c7fde500ddbcb33" translate="yes" xml:space="preserve">
          <source>Note: regardless of usual arithmetic conversions, the calculation may always be performed in a narrower type than specifier by these rules under the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;as-if rule&lt;/a&gt;.</source>
          <target state="translated">참고 : 일반적인 산술 변환에 관계없이 계산은 항상 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;as-if&lt;/a&gt; 규칙 아래 이러한 규칙에 의해 지정자보다 좁은 유형으로 수행 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b41cc846e4a608f128d6ff06686f2a937f04801" translate="yes" xml:space="preserve">
          <source>Note: see &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; for the details on multidimensional arrays.</source>
          <target state="translated">참고 : 다차원 &lt;a href=&quot;array&quot;&gt;배열&lt;/a&gt; 에 대한 자세한 내용 은 배열 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e60474a8a10595bf2fec57f2fb7e2711ea1189b3" translate="yes" xml:space="preserve">
          <source>Note: the conversion performed at this stage can be controlled by command line options in some implementations: gcc and clang use &lt;code&gt;-finput-charset&lt;/code&gt; to specify the encoding of the source character set, &lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt; to specify the encodings of the execution character set in the string literals and character constants that don't have an encoding prefix(since C11).</source>
          <target state="translated">참고 :이 단계에서 수행되는 변환은 일부 구현에서 명령 행 옵션으로 제어 할 수 있습니다. gcc 및 clang은 &lt;code&gt;-finput-charset&lt;/code&gt; 을 사용하여 소스 문자 세트의 인코딩을 지정하고 &lt;code&gt;-fexec-charset&lt;/code&gt; 및 &lt;code&gt;-fwide-exec-charset&lt;/code&gt; 을 지정합니다. 인코딩 리터럴이없는 문자열 리터럴 및 문자 상수에있는 실행 문자 세트의 인코딩 (C11부터).</target>
        </trans-unit>
        <trans-unit id="6b8092de48b423ebf2bb55c1e6ffcb436a80744e" translate="yes" xml:space="preserve">
          <source>Note: the remainder operator does not work on floating-point types, the library function &lt;code&gt;&lt;a href=&quot;../numeric/math/fmod&quot;&gt;fmod&lt;/a&gt;&lt;/code&gt; provides that functionality.</source>
          <target state="translated">참고 : 나머지 연산자는 부동 소수점 유형에서 작동하지 않으며 라이브러리 함수 &lt;code&gt;&lt;a href=&quot;../numeric/math/fmod&quot;&gt;fmod&lt;/a&gt;&lt;/code&gt; 는 해당 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45e53fd79bfcb21f431df2933e62abc3d8109fc8" translate="yes" xml:space="preserve">
          <source>Note: this allows the extreme case in which &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;bytes&lt;/a&gt; are sized 64 bits, all types (including &lt;code&gt;char&lt;/code&gt;) are 64 bits wide, and &lt;code&gt;sizeof&lt;/code&gt; returns 1 for every type.</source>
          <target state="translated">참고 : 이것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;바이트&lt;/a&gt; 의 크기가 64 비트이고 모든 유형 ( &lt;code&gt;char&lt;/code&gt; 포함 )의 너비가 64 비트이며 &lt;code&gt;sizeof&lt;/code&gt; 가 모든 유형에 대해 1을 반환 하는 극단적 인 경우를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="54d0bb27ce9ac9378f78496610c1e1579fd2ed42" translate="yes" xml:space="preserve">
          <source>Note: this example assumes the fix for the defect report 488 is applied.</source>
          <target state="translated">참고 :이 예에서는 결함 보고서 488에 대한 수정 사항이 적용되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c436bc9bf6e01d60ea1f44d5bf1dc2b2853ddb54" translate="yes" xml:space="preserve">
          <source>Note: type-generic macros were implemented in implementation-defined manner in C99, but C11 keyword &lt;a href=&quot;../keyword/_generic&quot;&gt;_Generic&lt;/a&gt; makes it possible to implement these macros in portable manner.</source>
          <target state="translated">참고 : 유형-일반 매크로는 C99에서 구현 정의 방식으로 구현되었지만 C11 키워드 &lt;a href=&quot;../keyword/_generic&quot;&gt;_Generic을&lt;/a&gt; 사용하면 이러한 매크로를 이식 가능한 방식으로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b1f9ecf4738c61169a1ccdb4d8f106c3c4c226a9" translate="yes" xml:space="preserve">
          <source>Null pointer dereference</source>
          <target state="translated">널 포인터 역 참조</target>
        </trans-unit>
        <trans-unit id="74a6c19154380d505a46ba69085260f6a4e75ee8" translate="yes" xml:space="preserve">
          <source>Null pointers</source>
          <target state="translated">널 포인터</target>
        </trans-unit>
        <trans-unit id="849ec1c6477c10e2f8570a4141fbf7cd8c8c0c3a" translate="yes" xml:space="preserve">
          <source>Null pointers can indicate the absence of an object or can be used to indicate other types of error conditions. In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, &lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; does nothing when a null pointer is passed).</source>
          <target state="translated">널 포인터는 객체가 없음을 나타내거나 다른 유형의 오류 조건을 나타내는 데 사용될 수 있습니다. 일반적으로 포인터 인수를받는 함수는 거의 항상 값이 null인지 확인하고 해당 경우를 다르게 처리해야합니다 (예를 들어, null 포인터가 전달되면 &lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 는 아무 것도 수행하지 않음).</target>
        </trans-unit>
        <trans-unit id="87666d8a93d39bce8a0fcd554a9b474be3904024" translate="yes" xml:space="preserve">
          <source>Null-terminated byte string management</source>
          <target state="translated">널 종료 바이트 문자열 관리</target>
        </trans-unit>
        <trans-unit id="e3441a1d943445ee578773b9d59cdc4079e90e21" translate="yes" xml:space="preserve">
          <source>Null-terminated byte strings</source>
          <target state="translated">널 종료 바이트 문자열</target>
        </trans-unit>
        <trans-unit id="43d16c943af2368f7e7b7123893affbacda8cc1e" translate="yes" xml:space="preserve">
          <source>Null-terminated multibyte string management</source>
          <target state="translated">널 종료 멀티 바이트 문자열 관리</target>
        </trans-unit>
        <trans-unit id="c161ff436191775822824d9815e2d14bf3d5ef2c" translate="yes" xml:space="preserve">
          <source>Null-terminated multibyte strings</source>
          <target state="translated">널 종료 멀티 바이트 문자열</target>
        </trans-unit>
        <trans-unit id="92ded827466195b2612fb3d97ec0708621b5721e" translate="yes" xml:space="preserve">
          <source>Null-terminated wide string management</source>
          <target state="translated">널 종료 와이드 문자열 관리</target>
        </trans-unit>
        <trans-unit id="276d3b63150e3a49b557ab66f5dd4439a42688b3" translate="yes" xml:space="preserve">
          <source>Null-terminated wide strings</source>
          <target state="translated">널로 끝나는 넓은 줄</target>
        </trans-unit>
        <trans-unit id="7cb8aeceec221f4be1d4fb52e961aa048b321072" translate="yes" xml:space="preserve">
          <source>Number of elements in any &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt;&lt;code&gt;a&lt;/code&gt;including VLA(since C99) may be determined with the expression &lt;code&gt;sizeof a / sizeof a[0]&lt;/code&gt;. Note that if &lt;code&gt;a&lt;/code&gt; has pointer type (such as after array-to-pointer conversion of function parameter type adjustment), this expression would simply divide the number of bytes in a pointer type by the number of bytes in the pointed type.</source>
          <target state="translated">VLA (C99 이후)를 포함 &lt;code&gt;a&lt;/code&gt; 임의의 &lt;a href=&quot;array&quot;&gt;어레이&lt;/a&gt; 의 요소의 수는 &lt;code&gt;sizeof a / sizeof a[0]&lt;/code&gt; 의 크기를 표현하여 결정될 수있다 . 만약 그 상태 &lt;code&gt;a&lt;/code&gt; (예 함수 파라미터 타입 조정 어레이 간 포인터 변환 후의 같은) 포인터 타입을 가지며,이 표현은 단순히 뾰족 형의 바이트 수에 의해 포인터 타입 바이트 수를 나누는 것이다.</target>
        </trans-unit>
        <trans-unit id="eb2d7b79228be3f57fe401384b037bf13631d1bd" translate="yes" xml:space="preserve">
          <source>Number of objects read successfully, which may be less than &lt;code&gt;count&lt;/code&gt; if an error or end-of-file condition occurs.</source>
          <target state="translated">성공적으로 읽은 개체 &lt;code&gt;count&lt;/code&gt; , 오류 또는 파일 끝 조건이 발생하는 경우 개수 보다 적을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cebed1a5c0cf52f77e684fdd8dd009684c0c9849" translate="yes" xml:space="preserve">
          <source>Numeric limits</source>
          <target state="translated">숫자 제한</target>
        </trans-unit>
        <trans-unit id="d591b3b3904bb2a1b443dad3db0e4ae55b2fa358" translate="yes" xml:space="preserve">
          <source>Numerics</source>
          <target state="translated">Numerics</target>
        </trans-unit>
        <trans-unit id="d107581a862db99867575e3f41f325fc4140ee10" translate="yes" xml:space="preserve">
          <source>ONCE_FLAG_INIT</source>
          <target state="translated">ONCE_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="9250b2677adf3b8e25990eff290a25954d1357f4" translate="yes" xml:space="preserve">
          <source>OR, if there was such an A, B may observe the result of some modification on M that is not &lt;code&gt;memory_order_seq_cst&lt;/code&gt; and does not</source>
          <target state="translated">예는 A가 있다면 OR, B가 아닌 M의 일부 변형의 결과 관찰 할 수 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 하지 않으며을</target>
        </trans-unit>
        <trans-unit id="38678aa96a7a3d61835226ca06fa7805d88fab6b" translate="yes" xml:space="preserve">
          <source>OR, if there wasn't such an A, B may observe the result of some unrelated modification of M that is not &lt;code&gt;memory_order_seq_cst&lt;/code&gt;</source>
          <target state="translated">또는 A가없는 경우 B는 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 가 아닌 M의 관련되지 않은 일부 수정 결과를 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ec0b50948d6623513dcb6dc5fd07405ba5e129" translate="yes" xml:space="preserve">
          <source>Object representation</source>
          <target state="translated">객체 표현</target>
        </trans-unit>
        <trans-unit id="cd546c805dfba801ad9bca8f668ba26c4e9d94df" translate="yes" xml:space="preserve">
          <source>Object-like macros</source>
          <target state="translated">객체와 유사한 매크로</target>
        </trans-unit>
        <trans-unit id="cdfc5f703ebd40ea35da590a8ca011ac237834ec" translate="yes" xml:space="preserve">
          <source>Object-like macros replace every occurrence of a defined identifier with replacement-list. Version (1) of the &lt;code&gt;#define&lt;/code&gt; directive behaves exactly like that.</source>
          <target state="translated">객체와 유사한 매크로는 모든 정의 된 식별자를 교체 목록으로 대체합니다. &lt;code&gt;#define&lt;/code&gt; 지시문 의 버전 (1) 은 정확히 그렇게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="10ef0bcacbf69dd868b4efa2b4ad1a1cfd8c5096" translate="yes" xml:space="preserve">
          <source>Objects &lt;a href=&quot;declarations&quot;&gt;declared&lt;/a&gt; with const-qualified types may be placed in read-only memory by the compiler, and if the address of a const object is never taken in a program, it may not be stored at all.</source>
          <target state="translated">const 한정 유형으로 &lt;a href=&quot;declarations&quot;&gt;선언 된&lt;/a&gt; 객체 는 컴파일러에 의해 읽기 전용 메모리에 배치 될 수 있으며, const 객체의 주소가 프로그램에서 절대 사용되지 않으면 전혀 저장되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5099cf20d1b82fb2c2137499652f1f1031f14841" translate="yes" xml:space="preserve">
          <source>Objects and Alignment</source>
          <target state="translated">객체와 정렬</target>
        </trans-unit>
        <trans-unit id="6897600ca1b5deb944cea78eba4834175965ad0f" translate="yes" xml:space="preserve">
          <source>Objects and alignment</source>
          <target state="translated">객체와 정렬</target>
        </trans-unit>
        <trans-unit id="e3e6de102563ef1f886a23d43fdd1616b4a15ba2" translate="yes" xml:space="preserve">
          <source>Objects are created by &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, &lt;a href=&quot;../memory&quot;&gt;allocation functions&lt;/a&gt;, &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt;, &lt;a href=&quot;compound_literal&quot;&gt;compound literals&lt;/a&gt;, and by non-lvalue expressions that return &lt;a href=&quot;lifetime&quot;&gt;structures or unions with array members&lt;/a&gt;.</source>
          <target state="translated">객체는 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; , &lt;a href=&quot;../memory&quot;&gt;할당 함수&lt;/a&gt; , &lt;a href=&quot;string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; , &lt;a href=&quot;compound_literal&quot;&gt;복합 리터럴&lt;/a&gt; 및 &lt;a href=&quot;lifetime&quot;&gt;배열 구성원과의 구조 또는 공용체&lt;/a&gt; 를 반환하는 비 가치 식으로 만들어 집니다.</target>
        </trans-unit>
        <trans-unit id="78fc3d56e7b8dcfb4545c57f0e90ce464f35deb8" translate="yes" xml:space="preserve">
          <source>Objects declared with an external declaration have static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, and as such cannot use &lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;register&lt;/code&gt; specifiers. The identifiers introduced by external declarations have &lt;a href=&quot;scope&quot;&gt;file scope&lt;/a&gt;.</source>
          <target state="translated">외부 선언으로 선언 된 객체는 정적 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 을 가지므로 &lt;code&gt;auto&lt;/code&gt; 또는 &lt;code&gt;register&lt;/code&gt; 지정자를 사용할 수 없습니다 . 외부 선언에 의해 도입 된 식별자는 &lt;a href=&quot;scope&quot;&gt;파일 범위를&lt;/a&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7883efd83a4faf633e6a8fe8d16f096fbb6600b9" translate="yes" xml:space="preserve">
          <source>Objects of array type are not &lt;a href=&quot;value_category&quot;&gt;modifiable lvalues&lt;/a&gt;, and although their address may be taken, they cannot appear on the left hand side of an assignment operator. However, structs with array members are modifiable lvalues and can be assigned:</source>
          <target state="translated">배열 유형의 객체는 &lt;a href=&quot;value_category&quot;&gt;수정 가능한 lvalue&lt;/a&gt; 가 아니며 주소를 가져도 할당 연산자의 왼쪽에는 표시되지 않습니다. 그러나 배열 멤버가있는 구조체는 수정 가능한 lvalue이며 다음과 같이 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93722ae3adb22a6f7e2d4b9abfdd1c6d36e6963a" translate="yes" xml:space="preserve">
          <source>Objects of atomic types are the only objects that are free from &lt;a href=&quot;memory_model&quot;&gt;data races&lt;/a&gt;, that is, they may be modified by two threads concurrently or modified by one and read by another.</source>
          <target state="translated">원자 유형의 객체는 &lt;a href=&quot;memory_model&quot;&gt;데이터 레이스&lt;/a&gt; 가없는 유일한 객체입니다 . 즉, 두 스레드에 의해 동시에 수정되거나 하나씩 수정되어 다른 스레드가 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4870394540a93ee5f98cbc8d1dd7b064d314d3e3" translate="yes" xml:space="preserve">
          <source>Objects of struct type do not compare equal automatically, and comparing them with &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;memcmp&lt;/a&gt;&lt;/code&gt; is not reliable because the padding bytes may have any values.</source>
          <target state="translated">구조체 유형의 객체는 자동으로 동일하게 비교 되지 않으며 패딩 바이트에 값이있을 수 있으므로 &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;memcmp&lt;/a&gt;&lt;/code&gt; 와 비교하는 것은 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7af23398ade253364ac33f6e391bd6693462a59e" translate="yes" xml:space="preserve">
          <source>Obtains the file position indicator and the current parse state (if any) for the file stream &lt;code&gt;stream&lt;/code&gt; and stores them in the object pointed to by &lt;code&gt;pos&lt;/code&gt;. The value stored is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일 스트림 &lt;code&gt;stream&lt;/code&gt; 의 파일 위치 지시자 및 현재의 구문 분석 상태 (존재하는 경우)를 취득 해 &lt;code&gt;pos&lt;/code&gt; 에 의해 지정된 객체에 저장합니다 . 저장된 값은 &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; 의 입력으로 만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf2f85ccf0846712f89c782e940eac919f85518a" translate="yes" xml:space="preserve">
          <source>Octal escape sequences have a length limit of three octal digits but terminate at the first character that is not a valid octal digit if encountered sooner.</source>
          <target state="translated">8 진 이스케이프 시퀀스의 길이 제한은 3 진수 8 자리이지만 더 빨리 발견되면 유효한 8 진수가 아닌 첫 번째 문자에서 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="466ab7e2e07a7d7b2048c50a7c31c4a5b1cdc233" translate="yes" xml:space="preserve">
          <source>Of the octal escape sequences, &lt;code&gt;\0&lt;/code&gt; is the most useful because it represents the terminating null character in null-terminated strings.</source>
          <target state="translated">8 진 이스케이프 시퀀스 중 &lt;code&gt;\0&lt;/code&gt; 은 null로 끝나는 문자열로 끝나는 null 문자를 나타내므로 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="45a0cf2ed682fb364e5cf8db06f8b7c8f807ebc5" translate="yes" xml:space="preserve">
          <source>On C99 implementations that do not implement &lt;code&gt;I&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt; may be used to obtain complex numbers with negative zero imaginary part. In C11, the macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; is used for that purpose.</source>
          <target state="translated">&lt;code&gt;I&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; 로 구현하지 않는 C99 구현 에서 &lt;code&gt;conj&lt;/code&gt; 는 음의 0의 허수 부분을 갖는 복소수를 얻기 위해 사용될 수 있습니다. C11에서는 매크로 &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; 가 해당 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc9a1e3742f12c5fc4d68c4f1799698f7b87481c" translate="yes" xml:space="preserve">
          <source>On POSIX systems, &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is measured in seconds, and &lt;code&gt;difftime&lt;/code&gt; is equivalent to arithmetic subtraction, but C and C++ allow fractional units for &lt;code&gt;time_t&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템에서 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 는 초 단위로 측정되며 &lt;code&gt;difftime&lt;/code&gt; 은 산술 뺄셈과 동일하지만 C 및 C ++는 &lt;code&gt;time_t&lt;/code&gt; 에 대해 분수 단위를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="ce115d98fd1a5e35dda62b8d49f45a8573ea6e22" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08&quot;&gt;environment variables&lt;/a&gt; are also accessible through the global variable &lt;code&gt;environ&lt;/code&gt;, declared as &lt;code&gt;extern char **environ;&lt;/code&gt; in &lt;code&gt;&amp;lt;unistd.h&amp;gt;&lt;/code&gt;, and through the optional third argument, &lt;code&gt;envp&lt;/code&gt;, of &lt;a href=&quot;../language/main_function&quot;&gt;the main function&lt;/a&gt;.</source>
          <target state="translated">POSIX 시스템에서 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08&quot;&gt;환경 변수&lt;/a&gt; 는 전역 변수 &lt;code&gt;environ&lt;/code&gt; 을 통해 액세스 할 수 있으며 &lt;code&gt;extern char **environ;&lt;/code&gt; 으로 선언됩니다 . 에서 &lt;code&gt;&amp;lt;unistd.h&amp;gt;&lt;/code&gt; 와 세번째 인수 통해 &lt;code&gt;envp&lt;/code&gt; 는 의 &lt;a href=&quot;../language/main_function&quot;&gt;주요 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c15eedd26e0a4296a1da805d0e3e7c292000d81" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the return value can be decomposed using &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html&quot;&gt;WEXITSTATUS and WSTOPSIG&lt;/a&gt;.</source>
          <target state="translated">POSIX 시스템에서 리턴 값은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html&quot;&gt;WEXITSTATUS 및 WSTOPSIG를&lt;/a&gt; 사용하여 분해 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98b83dd9352b620facc9e27430b33eed43bac0b0" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible systems, &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime&lt;/a&gt;&lt;/code&gt; with clock id &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt; offers better resolution.</source>
          <target state="translated">POSIX 호환 시스템에서 클럭 ID가 &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt; 인 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime&lt;/a&gt;&lt;/code&gt; 은 더 나은 해상도를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8cdd32f54ebc59a583e521091168ac838894bb8d" translate="yes" xml:space="preserve">
          <source>On a binary system (where &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;frexp&lt;/code&gt; may be implemented as.</source>
          <target state="translated">이진 시스템 ( &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 인 경우 )에서 &lt;code&gt;frexp&lt;/code&gt; 는 다음과 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feccd585446b4f56b9ce4cd68a4fbb77a174bb13" translate="yes" xml:space="preserve">
          <source>On a runtime constraint violation, it is called with the following arguments:</source>
          <target state="translated">런타임 제약 조건 위반시 다음 인수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ce877e2c542fd9b52cb204b343fc97d8d48dd27c" translate="yes" xml:space="preserve">
          <source>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain).</source>
          <target state="translated">DEC Alpha 이외의 모든 주류 CPU에서 종속성 순서는 자동이며이 동기화 모드에 대해 추가 CPU 명령이 발행되지 않으며 특정 컴파일러 최적화 만 영향을받습니다 (예 : 컴파일러는 종속성과 관련된 객체에 대해 추론로드를 수행 할 수 없음) 체인).</target>
        </trans-unit>
        <trans-unit id="109d9d8a239fad3c18cdb8e2722da494ab0114a2" translate="yes" xml:space="preserve">
          <source>On any given platform, the width of type &lt;code&gt;char16_t&lt;/code&gt; can be greater than 16 bits, but the actual values stored in an object of type &lt;code&gt;char16_t&lt;/code&gt; will always have a width of 16 bits.</source>
          <target state="translated">특정 플랫폼에서 &lt;code&gt;char16_t&lt;/code&gt; 유형의 너비는 16 비트보다 클 수 있지만 &lt;code&gt;char16_t&lt;/code&gt; 유형의 객체에 저장된 실제 값 의 너비는 항상 16 비트입니다.</target>
        </trans-unit>
        <trans-unit id="51b6e8c2a5af3c4767eb6e30ca739f50e4862a4f" translate="yes" xml:space="preserve">
          <source>On any given platform, the width of type &lt;code&gt;char32_t&lt;/code&gt; can be greater than 32 bits, but the actual values stored in an object of type &lt;code&gt;char32_t&lt;/code&gt; will always have a width of 32 bits.</source>
          <target state="translated">특정 플랫폼에서 &lt;code&gt;char32_t&lt;/code&gt; 유형의 너비는 32 비트보다 클 수 있지만 &lt;code&gt;char32_t&lt;/code&gt; 유형의 객체에 저장된 실제 값 의 너비는 항상 32 비트입니다.</target>
        </trans-unit>
        <trans-unit id="7601ac6abb5fa0c3f055c6b3ad57cb808021d0f1" translate="yes" xml:space="preserve">
          <source>On binary systems (where &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;ldexp&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;scalbn&quot;&gt;scalbn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(단 이진 시스템 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 이 있다 &lt;code&gt;2&lt;/code&gt; ) &lt;code&gt;ldexp&lt;/code&gt; 는 동등 &lt;code&gt;&lt;a href=&quot;scalbn&quot;&gt;scalbn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7811a9fc573d545f5f23c802e3d6aa2dbbacd655" translate="yes" xml:space="preserve">
          <source>On binary systems (where &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;scalbn&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(단 이진 시스템 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 이 있다 &lt;code&gt;2&lt;/code&gt; ) &lt;code&gt;scalbn&lt;/code&gt; 는 동등 &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d996bcb21d063a3ac297cd094f055a12b5180729" translate="yes" xml:space="preserve">
          <source>On entry to the signal handler, the state of the floating-point environment and the values of all objects is unspecified, except for.</source>
          <target state="translated">신호 처리기에 진입하면 부동 소수점 환경의 상태와 모든 객체의 값을 제외하고 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1054713c9d53c3a28707cf8e527af1dac108b0f" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;errno&lt;/code&gt; variable is set to implementation-defined positive value.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;errno&lt;/code&gt; 변수가 구현 정의 양수 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="21e174f6d770fb4beeb3cd8a25511f843e0cde8e" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;c16&lt;/code&gt; is not a valid 16-bit code unit), returns &lt;code&gt;-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="translated">실패시 ( &lt;code&gt;c16&lt;/code&gt; 이 유효한 16 비트 코드 단위가 아닌 경우 ) &lt;code&gt;-1&lt;/code&gt; 을 리턴하고 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 저장 하고 &lt;code&gt;*ps&lt;/code&gt; 를 지정되지 않은 상태로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="3b654d6228256087914cf81392b2cab324f4ec80" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;c32&lt;/code&gt; is not a valid 32-bit wide character), returns &lt;code&gt;-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="translated">실패시 ( &lt;code&gt;c32&lt;/code&gt; 가 유효한 32 비트 문자가 아닌 경우 ) &lt;code&gt;-1&lt;/code&gt; 을 리턴하고 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 저장 하고 &lt;code&gt;*ps&lt;/code&gt; 를 지정되지 않은 상태로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="d5a268f876a2012546ea2d4db6b6fb087311b2d7" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;wc&lt;/code&gt; is not a valid wide character), returns &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="translated">실패시 ( &lt;code&gt;wc&lt;/code&gt; 가 유효한 와이드 문자가 아닌 경우 ), &lt;code&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;size_t&lt;/a&gt;)-1&lt;/code&gt; 을 리턴하고 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 저장 하고 &lt;code&gt;*ps&lt;/code&gt; 를 지정되지 않은 상태로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="ace1968875e711eb68499fe2c40ffcf411eb2bd8" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned and the given stream remains unchanged.</source>
          <target state="translated">실패시 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 가 리턴되고 주어진 스트림은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b59034111d1fe69518d421a29472104cf3b1d3e3" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;WEOF&lt;/code&gt; is returned and the given stream remains unchanged.</source>
          <target state="translated">실패하면 &lt;code&gt;WEOF&lt;/code&gt; 가 리턴되고 주어진 스트림은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b861da9d1352751519afe0557d5add29d003824b" translate="yes" xml:space="preserve">
          <source>On failure, returns &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; and sets the</source>
          <target state="translated">실패하면 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 를 반환 하고</target>
        </trans-unit>
        <trans-unit id="314b860381766f5828a38837bf58fe936c2ad191" translate="yes" xml:space="preserve">
          <source>On failure, returns &lt;code&gt;WEOF&lt;/code&gt; and sets the</source>
          <target state="translated">실패하면 &lt;code&gt;WEOF&lt;/code&gt; 를 반환 하고</target>
        </trans-unit>
        <trans-unit id="bcd79a4ce724e0f85bbc5af6b0ba614e86f4c729" translate="yes" xml:space="preserve">
          <source>On failure, returns a null pointer.</source>
          <target state="translated">실패하면 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="208512240a47af38827f26924ebcc80cb2c37ad5" translate="yes" xml:space="preserve">
          <source>On failure, returns a null pointer. The original pointer &lt;code&gt;ptr&lt;/code&gt; remains valid and may need to be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="translated">실패하면 널 포인터를 리턴합니다. 원래 포인터 &lt;code&gt;ptr&lt;/code&gt; 은 여전히 ​​유효하며 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;realloc()&lt;/code&gt; 으로 할당 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f1bf711404d47b14c3829dbfe5bbf1b29d1b2ee4" translate="yes" xml:space="preserve">
          <source>On implementations that support floating-point infinities, these macros always expand to the positive infinities of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, respectively.</source>
          <target state="translated">부동 소수점 무한대를 지원하는 구현에서 이러한 매크로는 항상 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 의 양의 무한대로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8621dd430c2c00cf7cac763e8409cf66e119c807" translate="yes" xml:space="preserve">
          <source>On many implementations, &lt;code&gt;ldexp&lt;/code&gt; is less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">많은 구현에서, &lt;code&gt;ldexp&lt;/code&gt; 는 산술 연산자를 사용하여 2의 거듭 제곱에 의한 곱셈 또는 나눗셈보다 덜 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="13a6ebd0b3f331800ebab3eb88281db31bb09676" translate="yes" xml:space="preserve">
          <source>On many implementations, line buffering is only available for terminal input streams.</source>
          <target state="translated">많은 구현에서, 라인 버퍼링은 터미널 입력 스트림에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="dae6cfb19aec260bc05f2964584fe1ea9c86a969" translate="yes" xml:space="preserve">
          <source>On many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby / and % where suitable.</source>
          <target state="translated">많은 플랫폼에서 단일 CPU 명령어는 몫과 나머지를 모두 얻습니다.이 기능은 컴파일러가 일반적으로 적합한 경우 근처와 %를 병합 할 수 있지만이를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55a72fd9a6bd6f0514568737340536f59b85bddb" translate="yes" xml:space="preserve">
          <source>On return from a signal handler, the value of any object modified by the signal handler that is not &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; or lock-free atomic(since C11) is undefined.</source>
          <target state="translated">신호 처리기에서 반환 될 때 &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; 또는 잠금없는 원자 (C11 이후)가 아닌 신호 처리기에 의해 수정 된 객체의 값 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bc9c28e074a73d2c245f0186a4c8a7d68bca3b8" translate="yes" xml:space="preserve">
          <source>On some implementations (e.g. Linux), this function actually creates, opens, and immediately deletes the file from the file system: as long as an open file descriptor to a deleted file is held by a program, the file exists, but since it was deleted, its name does not appear in any directory, so that no other process can open it. Once the file descriptor is closed, or once the program terminates (normally or abnormally), the space occupied by the file is reclaimed by the filesystem.</source>
          <target state="translated">일부 구현 (예 : Linux)에서이 함수는 실제로 파일 시스템에서 파일을 작성하고 열고 즉시 삭제합니다. 삭제 된 파일에 대한 열린 파일 디스크립터가 프로그램에 의해 유지되는 한 파일은 존재하지만 삭제되면 해당 이름이 디렉토리에 나타나지 않으므로 다른 프로세스가 해당 디렉토리를 열 수 없습니다. 파일 디스크립터가 닫히거나 프로그램이 종료되면 (정상적으로 또는 비정상적으로) 파일이 차지하는 공간은 파일 시스템에 의해 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="0dd2c2923877872be297b89c9fea77391101b399" translate="yes" xml:space="preserve">
          <source>On some implementations (e.g. Windows), elevated privileges are required as the function may create the temporary file in a system directory.</source>
          <target state="translated">일부 구현 (예 : Windows)에서는 함수가 시스템 디렉토리에 임시 파일을 작성할 수 있으므로 높은 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="90ad61f04001b112d42b39173e55ee98d3ddc34c" translate="yes" xml:space="preserve">
          <source>On some platforms this operation is supported by hardware (and, for example, on Intel CPU, &lt;code&gt;FPREM1&lt;/code&gt; leaves exactly 3 bits of precision in the quotient).</source>
          <target state="translated">일부 플랫폼에서이 작업은 하드웨어에서 지원됩니다 (예 : Intel CPU에서 &lt;code&gt;FPREM1&lt;/code&gt; 은 몫에 정확히 3 비트의 정밀도를 둡니다).</target>
        </trans-unit>
        <trans-unit id="39a8ce59d8dc85c2962717623b86954b6c06d0f6" translate="yes" xml:space="preserve">
          <source>On strongly-ordered systems &amp;mdash; x86, SPARC TSO, IBM mainframe, etc. &amp;mdash; release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode; only certain compiler optimizations are affected (e.g., the compiler is prohibited from moving non-atomic stores past the atomic store-release or performing non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions are used.</source>
          <target state="translated">x86, SPARC TSO, IBM 메인 프레임 등 강력하게 정렬 된 시스템에서 릴리스 획득 순서는 대부분의 작업에서 자동입니다. 이 동기화 모드에 대한 추가 CPU 명령어는 발행되지 않습니다. 특정 컴파일러 최적화 만 영향을받습니다 (예를 들어, 컴파일러는 비 원자 저장소를 원자 저장소 릴리스를지나 이동하거나 원자 부하 획득 이전에 비 원자로드를 수행 할 수 없음). 약하게 정렬 된 시스템 (ARM, Itanium, PowerPC)에서는 특수 CPU로드 또는 메모리 차단 명령어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="77b723cf592ca1c577d1c9cb505cf08a127e9073" translate="yes" xml:space="preserve">
          <source>On success &lt;code&gt;ch&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;ch&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e4761c7a6227f38804881200e2df99d7b35533a7" translate="yes" xml:space="preserve">
          <source>On success, returns a non-negative value.</source>
          <target state="translated">성공하면 음수가 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6cde2f20613d1a86893110aa81a3b21249e01dd4" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. This value may be &lt;code&gt;​0​&lt;/code&gt;, e.g. when processing the leading &lt;code&gt;char16_t&lt;/code&gt; units in a multi-&lt;code&gt;char16_t&lt;/code&gt;-unit sequence (occurs when processing the leading surrogate in a surrogate pair of UTF-16).</source>
          <target state="translated">성공하면 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열에 기록 된 바이트 수 (모든 시프트 시퀀스 포함)를 리턴합니다 . 이 값은 수 &lt;code&gt;​0​&lt;/code&gt; 선두 처리 할 때, 예 &lt;code&gt;char16_t&lt;/code&gt; 에서 의 단위 멀티 &lt;code&gt;char16_t&lt;/code&gt; -unit 시퀀스 (UTF-16의 게이트 쌍의 선도 대리를 처리 할 때 발생한다).</target>
        </trans-unit>
        <trans-unit id="de169c1c0a0fe1521de636ba13f4679f7d63784d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. This value may be &lt;code&gt;​0​&lt;/code&gt;, e.g. when processing the leading &lt;code&gt;char32_t&lt;/code&gt; units in a multi-&lt;code&gt;char32_t&lt;/code&gt;-unit sequence (does not occur in UTF-32).</source>
          <target state="translated">성공하면 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열에 기록 된 바이트 수 (모든 시프트 시퀀스 포함)를 리턴합니다 . 이 값은 수 &lt;code&gt;​0​&lt;/code&gt; 선두 처리 할 때, 예 &lt;code&gt;char32_t&lt;/code&gt; 에서 의 단위 멀티 &lt;code&gt;char32_t&lt;/code&gt; -unit 시퀀스 (UTF-32에서는 발생하지 않는다).</target>
        </trans-unit>
        <trans-unit id="71fea449bddcfd4112273f907f46291dd9fd0bda" translate="yes" xml:space="preserve">
          <source>On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="translated">성공하면 새로 할당 된 메모리의 시작 부분에 대한 포인터를 반환합니다. 메모리 누수를 피하려면 리턴 된 포인터에 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;realloc()&lt;/code&gt; 할당 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="badf0c0d191b6f202c40872f1028bec7676332e1" translate="yes" xml:space="preserve">
          <source>On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt;. The original pointer &lt;code&gt;ptr&lt;/code&gt; is invalidated and any access to it is undefined behavior (even if reallocation was in-place).</source>
          <target state="translated">성공하면 새로 할당 된 메모리의 시작 부분에 대한 포인터를 반환합니다. 메모리 누수를 피하려면 리턴 된 포인터에 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;realloc()&lt;/code&gt; 할당 해제해야합니다 . 원래 포인터 &lt;code&gt;ptr&lt;/code&gt; 이 무효화되고 이에 대한 액세스는 정의되지 않은 동작입니다 (재 할당이 제자리에 있더라도).</target>
        </trans-unit>
        <trans-unit id="d902746b34d07703c051d8b0c20c3a4f074b9dbd" translate="yes" xml:space="preserve">
          <source>On success, returns the written character.</source>
          <target state="translated">성공하면 작성된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="654813a474d7f1feaa5498a158649f23b8e604b2" translate="yes" xml:space="preserve">
          <source>On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.</source>
          <target state="translated">파일 추가 액세스 모드에서는 파일 위치 표시기의 현재 위치에 관계없이 파일 끝에 데이터가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4fc8d97258ef37395359f175535e24d679a58e39" translate="yes" xml:space="preserve">
          <source>On the other hand, although unsigned integer overflow in any arithmetic operator (and in integer conversion) is a well-defined operation and follows the rules of modulo arithmetic, overflowing an unsigned integer in a floating-to-integer conversion is undefined behavior: the values of real floating type that can be converted to unsigned integer are the values from the open interval (-1; Unnn_MAX+1).</source>
          <target state="translated">반면에 모든 산술 연산자 (및 정수 변환)에서 부호없는 정수 오버플로는 잘 정의 된 연산이지만 모듈로 산술 규칙을 따르며 부동 소수점 정수 변환에서 부호없는 정수를 오버플로하는 것은 정의되지 않은 동작입니다. 부호없는 정수로 변환 할 수있는 실수 부동 유형의 값은 열린 간격 (-1; Unnn_MAX + 1)의 값입니다.</target>
        </trans-unit>
        <trans-unit id="c6cc73591c77978d68949f41043e92bd28cf120f" translate="yes" xml:space="preserve">
          <source>On the way up the stack, &lt;code&gt;longjmp&lt;/code&gt; does not deallocate any VLAs, memory leaks may occur if their lifetimes are terminated in this way:</source>
          <target state="translated">스택을 진행하는 동안 &lt;code&gt;longjmp&lt;/code&gt; 는 VLA를 할당 해제하지 않으며 수명이 다음과 같이 종료되면 메모리 누수가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="265fc81eed0f5d614db9f511bddb08d53edda459" translate="yes" xml:space="preserve">
          <source>On thread startup (see &lt;code&gt;&lt;a href=&quot;thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt;), the values associated with all TSS keys are NULL. Different value may be placed in the thread-specific storage with &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드 시작시 ( &lt;code&gt;&lt;a href=&quot;thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; 참조 ) 모든 TSS 키와 연관된 값은 NULL입니다. &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; 을 사용하여 스레드 별 스토리지에 다른 값을 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="143c95c711e6f4ad6cfeb129df6f450c3084425d" translate="yes" xml:space="preserve">
          <source>One definition rule</source>
          <target state="translated">하나의 정의 규칙</target>
        </trans-unit>
        <trans-unit id="94d4f2dc80f2c24729c95ceecb641056847e9ef6" translate="yes" xml:space="preserve">
          <source>One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx&quot;&gt;MSDN&lt;/a&gt;), and thus volatiles may be used for inter-thread synchronization. Standard &lt;code&gt;volatile&lt;/code&gt; semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; handler that runs in the same thread when applied to &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; variables.</source>
          <target state="translated">주목할만한 예외 중 하나는 기본 설정으로 모든 휘발성 쓰기에 릴리스 시맨틱이 있고 모든 휘발성 읽기가 시맨틱 ( &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx&quot;&gt;MS&lt;/a&gt; )을 획득 하므로 스레드 간 동기화에 휘발성이 사용될 수있는 Visual Studio 입니다. 표준 &lt;code&gt;volatile&lt;/code&gt; 시맨틱은 멀티 스레드 프로그래밍에는 적용되지 않지만 &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; 변수에 적용될 때 동일한 스레드에서 실행 되는 &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; 핸들러 와의 통신에는 충분 합니다.</target>
        </trans-unit>
        <trans-unit id="8ec3094c47e164868d67263abee22b8f36e54dde" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_INFINITE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_NAN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_NORMAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_SUBNORMAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_ZERO&lt;/a&gt;&lt;/code&gt; or implementation-defined type, specifying the category of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">하나 &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_INFINITE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_NAN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_NORMAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_SUBNORMAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fp_categories&quot;&gt;FP_ZERO&lt;/a&gt;&lt;/code&gt; 의 종류 또는 특정 구현 정의 타입 &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7e2e730425995bc27c6162e5d7369f2baf1d499" translate="yes" xml:space="preserve">
          <source>One use case for changing buffer size is when a better size is known.</source>
          <target state="translated">버퍼 크기를 변경하는 사용 사례 중 하나는 더 나은 크기를 알고있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="643603d8af84c49b3d031aa1a05216203cedd509" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter '&amp;Sigma;' has two lowercase forms, depending on the position in a word: '&amp;sigma;' and '&amp;sigmaf;'. A call to &lt;code&gt;towlower&lt;/code&gt; cannot be used to obtain the correct lowercase form in this case.</source>
          <target state="translated">이 함수는 1 : 1 문자 매핑 만 수행 할 수 있습니다. 예를 들어, 그리스 대문자 '&amp;Sigma;'는 단어의 위치에 따라 '&amp;sigma;'와 '&amp;sigmaf;'의 두 가지 소문자 형식을 갖습니다. 이 경우 &lt;code&gt;towlower&lt;/code&gt; 호출을 사용하여 올바른 소문자 양식을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8558acb5e44a3b7e7cc83eb1f8384f438a150fd5" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the uppercase form of '&amp;szlig;' is (with some exceptions) the two-character string &quot;SS&quot;, which cannot be obtained by &lt;code&gt;towupper&lt;/code&gt;.</source>
          <target state="translated">이 함수는 1 : 1 문자 매핑 만 수행 할 수 있습니다. 예를 들어 대문자 '&amp;szlig;'는 (일부 예외는 있지만) 두 문자 문자열 &quot;SS&quot;이며 &lt;code&gt;towupper&lt;/code&gt; 로는 얻을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="df7f87f165c312cced9d18c34a873a0ab047c4c9" translate="yes" xml:space="preserve">
          <source>Only if both arguments are NaN, NaN is returned</source>
          <target state="translated">두 인수가 모두 NaN 인 경우에만 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2ee3b411f9ce5a9d0dc1557293a5208ceecead35" translate="yes" xml:space="preserve">
          <source>Only modifiable lvalue expressions may be used as arguments to increment/decrement, and as left-hand arguments of assignment and compound assignment operators.</source>
          <target state="translated">수정 가능한 lvalue 표현식 만 증가 / 감소를위한 인수와 대입 및 복합 대입 연산자의 왼쪽 인수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d343971baedb6cbb3b70f72cc6073ba64f46344b" translate="yes" xml:space="preserve">
          <source>Only new-style (prototyped) &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt; may be variadic. This is indicated by the parameter of the form &lt;code&gt;...&lt;/code&gt; which must appear last in the parameter list and must follow at least one named parameter.</source>
          <target state="translated">새로운 스타일의 프로토 타입 &lt;a href=&quot;function_declaration&quot;&gt;함수 선언&lt;/a&gt; 만 가변적 일 수 있습니다. 이것은 &lt;code&gt;...&lt;/code&gt; 형식 의 매개 변수로 표시되며 매개 변수 목록에서 마지막에 나타나야하며 하나 이상의 명명 된 매개 변수를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="f86c376c389f9f7b37142caaf26ada0ec893ba21" translate="yes" xml:space="preserve">
          <source>Only pointers to &lt;a href=&quot;compatible_type&quot;&gt;object types&lt;/a&gt; may be restrict-qualified (in particular, &lt;code&gt;int restrict *p&lt;/code&gt; and &lt;code&gt;float (* restrict f9)(void)&lt;/code&gt; are errors).</source>
          <target state="translated">&lt;a href=&quot;compatible_type&quot;&gt;객체 유형에&lt;/a&gt; 대한 포인터 만 제한으로 제한 될 수 있습니다 (특히 &lt;code&gt;int restrict *p&lt;/code&gt; 및 &lt;code&gt;float (* restrict f9)(void)&lt;/code&gt; 는 오류 임).</target>
        </trans-unit>
        <trans-unit id="01794fe3947565d881ce29925429530cc7001695" translate="yes" xml:space="preserve">
          <source>Only pointers to elements of the same array (including the pointer one past the end of the array) may be subtracted from each other.</source>
          <target state="translated">동일한 배열의 요소에 대한 포인터 (배열 끝을 지나는 포인터 포함) 만 서로 뺄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="415dfd9db04ea2590afe9bf3ae3000416e96b22e" translate="yes" xml:space="preserve">
          <source>Only the difference between two values returned by different calls to &lt;code&gt;clock&lt;/code&gt; is meaningful, as the beginning of the &lt;code&gt;clock&lt;/code&gt; era does not have to coincide with the start of the program. &lt;code&gt;clock&lt;/code&gt; time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, &lt;code&gt;clock&lt;/code&gt; time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, &lt;code&gt;clock&lt;/code&gt; time may advance faster than wall clock.</source>
          <target state="translated">&lt;code&gt;clock&lt;/code&gt; 시대의 시작이 프로그램의 시작과 일치 할 필요가 없기 때문에 서로 다른 &lt;code&gt;clock&lt;/code&gt; 호출에 의해 반환 된 두 값의 차이 만 의미 가 있습니다. &lt;code&gt;clock&lt;/code&gt; 시간은 운영 체제에서 프로그램에 제공 한 실행 리소스에 따라 월 클럭보다 빠르거나 느려질 수 있습니다. 예를 들어, CPU가 다른 프로세스와 공유되는 경우 &lt;code&gt;clock&lt;/code&gt; 시간이 벽시계보다 느리게 진행될 수 있습니다. 반면에 현재 프로세스가 다중 스레드이고 둘 이상의 실행 코어를 사용할 수있는 경우 &lt;code&gt;clock&lt;/code&gt; 시간이 벽시계보다 빠르게 진행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1042f16a7b75cb3732a2bc82be1aa8b169e69f" translate="yes" xml:space="preserve">
          <source>Only the following expressions are allowed as expression-true and expression-false.</source>
          <target state="translated">다음 표현식 만 expression-true 및 expression-false로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c59eaae4ab6b1ae5533fc854dde2378dc53297f6" translate="yes" xml:space="preserve">
          <source>Only the following undefined behaviors are critical:</source>
          <target state="translated">다음과 같은 정의되지 않은 동작 만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7b1e9ef7c7f2fc9fc1d73df732e8087397ce13c0" translate="yes" xml:space="preserve">
          <source>Only two narrow or two wide string literals may be concatenated.</source>
          <target state="translated">두 개의 좁은 또는 두 개의 넓은 문자열 리터럴 만 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="237cef659815822d78b56d19a7c946bfbf74be1f" translate="yes" xml:space="preserve">
          <source>Open a file for read/write</source>
          <target state="translated">읽기 / 쓰기를위한 파일 열기</target>
        </trans-unit>
        <trans-unit id="3186d8ed0fca34a6a2c7ee13f69f2d2feb00ab05" translate="yes" xml:space="preserve">
          <source>Open a file for reading</source>
          <target state="translated">읽을 파일을 엽니 다</target>
        </trans-unit>
        <trans-unit id="456fb30fb01febdf98b1f26b7ae1bde8ca3ee080" translate="yes" xml:space="preserve">
          <source>Operations on files</source>
          <target state="translated">파일 작업</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="0f3287b1169a638056162b8ea1058227dff7945b" translate="yes" xml:space="preserve">
          <source>Operator macros(C95)</source>
          <target state="translated">연산자 매크로 (C95)</target>
        </trans-unit>
        <trans-unit id="819ccd81b85bc3b38f4cc9446e71367abf393235" translate="yes" xml:space="preserve">
          <source>Operator name</source>
          <target state="translated">운영자 이름</target>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="translated">연산자 우선 순위</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="ca7702ea15a52dc62fa45feb4b8c2a5d108ab264" translate="yes" xml:space="preserve">
          <source>Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression &lt;code&gt;a=b=c&lt;/code&gt; is parsed as &lt;code&gt;a=(b=c)&lt;/code&gt;, and not as &lt;code&gt;(a=b)=c&lt;/code&gt; because of right-to-left associativity.</source>
          <target state="translated">동일한 셀에있는 연산자 (셀에 나열된 여러 행의 연산자가있을 수 있음)는 주어진 방향으로 동일한 우선 순위로 평가됩니다. 예를 들어, 수식 &lt;code&gt;a=b=c&lt;/code&gt; 는 오른쪽에서 왼쪽으로의 연관성 때문에 &lt;code&gt;(a=b)=c&lt;/code&gt; 가 아닌 &lt;code&gt;a=(b=c)&lt;/code&gt; 로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="21ab442b56e6693d449e1b3316a7c72b27f04270" translate="yes" xml:space="preserve">
          <source>Order of evaluation</source>
          <target state="translated">평가 순서</target>
        </trans-unit>
        <trans-unit id="bab90aabfee646e5feefc6f9a898d668b42d74ce" translate="yes" xml:space="preserve">
          <source>Order of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below). The compiler will evaluate them in any order, and may choose another order when the same expression is evaluated again.</source>
          <target state="translated">함수 호출 표현식에서 함수 인수의 평가 순서를 포함하여 모든 C 연산자의 피연산자 평가 순서 및 모든 표현식 내의 하위 표현식 평가 순서는 지정되지 않습니다 (아래에 언급 된 경우 제외). 컴파일러는 순서에 상관없이이를 평가하고 동일한 표현식이 다시 평가 될 때 다른 순서를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="1b3df585822a5aa71af2864093c3784252d8d05a" translate="yes" xml:space="preserve">
          <source>Originally (in C89), support for zero size was added to accommodate code such as.</source>
          <target state="translated">원래 (C89에서)와 같은 코드를 수용하기 위해 0 크기 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="2c0e832aaebdbd2463766c9b11e2e90be9a8a71c" translate="yes" xml:space="preserve">
          <source>Other macro constants beginning with &lt;code&gt;TIME_&lt;/code&gt; may be provided by the implementation to indicate additional time bases.</source>
          <target state="translated">&lt;code&gt;TIME_&lt;/code&gt; 로 시작하는 다른 매크로 상수 는 추가 시간축을 나타 내기 위해 구현에 의해 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22490909ecb721f0620f7d5b993ac0c5478e639a" translate="yes" xml:space="preserve">
          <source>Other models are very rare. For example, &lt;b&gt;ILP64&lt;/b&gt; (&lt;b&gt;8/8/8&lt;/b&gt;: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).</source>
          <target state="translated">다른 모델은 매우 드 rare니다. 예를 들어, &lt;b&gt;ILP64&lt;/b&gt; ( &lt;b&gt;8/8/8&lt;/b&gt; : int, long 및 포인터는 64 비트)는 일부 초기 64 비트 Unix 시스템 (예 : Uniray on Cray)에서만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aecde2c1ff0650ce54e7e724236337f0082c7af4" translate="yes" xml:space="preserve">
          <source>Other operators</source>
          <target state="translated">다른 연산자</target>
        </trans-unit>
        <trans-unit id="6962ff7ae59e4074a7a4c9216963b920264f14d3" translate="yes" xml:space="preserve">
          <source>Otherwise (if &lt;code&gt;arg&lt;/code&gt; is not zero), if no errors occur, returns the value &lt;code&gt;x&lt;/code&gt; in the range &lt;code&gt;(-1;-0.5], [0.5; 1)&lt;/code&gt; and stores an integer value in &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; such that x&amp;times;2(*exp)</source>
          <target state="translated">그렇지 않으면 ( &lt;code&gt;arg&lt;/code&gt; 가 0이 아닌 경우) 오류가 발생하지 않으면 &lt;code&gt;x&lt;/code&gt; 범위 &lt;code&gt;(-1;-0.5], [0.5; 1)&lt;/code&gt; 에서 x 값을 반환하고 xx2 ( &lt;code&gt;*&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 와 같이 * exp에 정수 값을 저장합니다. )</target>
        </trans-unit>
        <trans-unit id="acea718d4290aa47c7e60d4de5b064b3e0d254ed" translate="yes" xml:space="preserve">
          <source>Otherwise, a single invalid preprocessing number token is formed, which causes further analysis to fail.</source>
          <target state="translated">그렇지 않으면, 유효하지 않은 단일 전처리 번호 토큰이 형성되어 추가 분석이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="34d06fa77dd61fad7761e2e90c69e32873116c0b" translate="yes" xml:space="preserve">
          <source>Otherwise, both operands undergo implicit conversion to the unsigned type counterpart of the signed operand's type.</source>
          <target state="translated">그렇지 않으면 두 피연산자가 부호있는 피연산자 유형의 부호없는 유형으로 암시 적으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="513439b9a32e69b4c43715e537ce9a1e6779b0d2" translate="yes" xml:space="preserve">
          <source>Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size.</source>
          <target state="translated">그렇지 않으면 두 유형 모두 알 수없는 크기의 배열이고 복합 유형은 알 수없는 크기의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7dde40dbcdfe2efbe7a10f92f68991f7314d060d" translate="yes" xml:space="preserve">
          <source>Otherwise, if both operands after promotion have the same signedness (both signed or both unsigned), the operand with the lesser</source>
          <target state="translated">그렇지 않으면, 승격 후 두 피연산자가 모두 동일한 부호 (서명 또는 둘 다 부호 없음)를 갖는 경우, 피연산자는</target>
        </trans-unit>
        <trans-unit id="d0234caa7bb771cbb9cfeaa4f48b7d3fa57b9692" translate="yes" xml:space="preserve">
          <source>Otherwise, if expression does not equal zero, nothing happens; no code is emitted.</source>
          <target state="translated">그렇지 않으면 expression이 0이 아니면 아무 일도 일어나지 않습니다. 코드가 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3706c5ce3b3e68ec6995f2343dcf9619c6c9a406" translate="yes" xml:space="preserve">
          <source>Otherwise, if one type is a VLA of unspecified size, the composite type is a VLA of unspecified size.</source>
          <target state="translated">그렇지 않으면 한 유형이 지정되지 않은 크기의 VLA 인 경우 복합 유형은 지정되지 않은 크기의 VLA입니다.</target>
        </trans-unit>
        <trans-unit id="9c46cf482866181f8c389db5b8ba5d006dbef217" translate="yes" xml:space="preserve">
          <source>Otherwise, if one type is a VLA whose size is specified by an expression that is not evaluated, the behavior is undefined.</source>
          <target state="translated">그렇지 않으면 한 유형이 평가되지 않은 표현식에 의해 크기가 지정된 VLA 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64c951e6e86f63cf6df740a2bc39bcac52344647" translate="yes" xml:space="preserve">
          <source>Otherwise, if one type is a VLA whose size is specified, the composite type is a VLA of that size.</source>
          <target state="translated">그렇지 않으면 한 유형이 지정된 크기의 VLA 인 경우 복합 유형은 해당 크기의 VLA입니다.</target>
        </trans-unit>
        <trans-unit id="9e4b77f603fbb12975ab783cf93a88dd4cea1971" translate="yes" xml:space="preserve">
          <source>Otherwise, if type-name is exactly the type of expression, nothing is done (except that if expression has floating type and is represented with greater range and precision than its type indicates -- see below).</source>
          <target state="translated">그렇지 않으면 type-name이 표현식의 유형 인 경우 아무 것도 수행되지 않습니다 (식에 부동 유형이 있고 유형이 나타내는 것보다 더 큰 범위와 정밀도로 표시되는 경우는 제외) (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c7d748298a041a1ef7ff4c527961a3c25f8914c9" translate="yes" xml:space="preserve">
          <source>Otherwise, the signedness is different and the signed operand's rank is greater than unsigned operand's rank. In this case, if the signed type can represent all values of the unsigned type, then the operand with the unsigned type is implicitly converted to the type of the signed operand.</source>
          <target state="translated">그렇지 않으면 부호가 다르고 부호있는 피연산자의 순위가 부호없는 피연산자의 순위보다 큽니다. 이 경우 부호있는 유형이 부호없는 유형의 모든 값을 나타낼 수 있으면 부호없는 유형의 피연산자가 암시 적으로 부호있는 피연산자의 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b84fe8d54f35cea26d6a3dd2d2efb6c41ee1070a" translate="yes" xml:space="preserve">
          <source>Otherwise, the signedness is different: If the operand with the unsigned type has</source>
          <target state="translated">그렇지 않으면 부호가 다릅니다. 부호없는 유형의 피연산자가</target>
        </trans-unit>
        <trans-unit id="c4e8cf5e29bbd01bcc7643f612cca79fe397b689" translate="yes" xml:space="preserve">
          <source>Otherwise, the value of expression is converted to the type named by type-name, as follows:</source>
          <target state="translated">그렇지 않으면 expression의 값은 다음과 같이 type-name으로 명명 된 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="f8d5cf51177cbd61e9ad52eaa044095be31080c7" translate="yes" xml:space="preserve">
          <source>Overflows</source>
          <target state="translated">Overflows</target>
        </trans-unit>
        <trans-unit id="b1a324fa062c9e26e00c18e22544ad0506e15306" translate="yes" xml:space="preserve">
          <source>P &amp;gt; X &amp;ge; &amp;minus;4</source>
          <target state="translated">P&amp;gt; X &amp;ge; -4</target>
        </trans-unit>
        <trans-unit id="83d009599b4e30148a6c333642990ba0b9350d9a" translate="yes" xml:space="preserve">
          <source>P &amp;minus; 1</source>
          <target state="translated">P-1</target>
        </trans-unit>
        <trans-unit id="b0314c3d6e90b3565b95808c2051a435d624960e" translate="yes" xml:space="preserve">
          <source>P &amp;minus; 1 &amp;minus; X</source>
          <target state="translated">P &amp;minus; 1-X</target>
        </trans-unit>
        <trans-unit id="5c0c0a1c20866f175fd10b2aef4d095e149b6f0d" translate="yes" xml:space="preserve">
          <source>POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/abort.html&quot;&gt;specifies&lt;/a&gt; that the abort() function overrides blocking or ignoring the SIGABRT signal.</source>
          <target state="translated">POSIX 는 abort () 함수가 SIGABRT 신호 차단 또는 무시를 무시하도록 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/abort.html&quot;&gt;지정&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d0fe9927eb40a44c14a8416224896d9dc60256b8" translate="yes" xml:space="preserve">
          <source>POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html&quot;&gt;extends the specification of fflush&lt;/a&gt; by defining its effects on an input stream, as long as that stream represents a file or another seekable device: in that case the POSIX file pointer is repositioned to match the C stream pointer (which effectively undoes any read buffering) and the effects of any &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ungetwc&quot;&gt;ungetwc&lt;/a&gt;&lt;/code&gt; that weren't yet read back from the stream are discarded.</source>
          <target state="translated">POSIX 는 입력 스트림이 파일 또는 다른 검색 가능한 장치를 나타내는 한 입력 스트림에 미치는 영향을 정의하여 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html&quot;&gt;fflush의 사양을 확장합니다&lt;/a&gt; .이 경우 POSIX 파일 포인터는 C 스트림 포인터와 일치하도록 재배치되어 (읽기 버퍼링을 효과적으로 취소 함) ) 및 스트림에서 다시 읽지 않은 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ungetwc&quot;&gt;ungetwc&lt;/a&gt;&lt;/code&gt; 의 효과 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="417bd6e66e13b5cf5b7787df74da03ed895b117e" translate="yes" xml:space="preserve">
          <source>POSIX allows seeking beyond the existing end of file. If an output is performed after this seek, any read from the gap will return zero bytes. Where supported by the filesystem, this creates a</source>
          <target state="translated">POSIX를 사용하면 기존 파일 끝을 넘어 탐색 할 수 있습니다. 이 검색 후에 출력이 수행되면 간격에서 읽은 값이 0 바이트를 반환합니다. 파일 시스템이 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="3ca50ebb591b6d07b87a0ee2add3e84ece52f6b7" translate="yes" xml:space="preserve">
          <source>POSIX also defines a locale named &quot;POSIX&quot;, which is always accessible and is exactly equivalent to the default minimal &quot;C&quot; locale.</source>
          <target state="translated">또한 POSIX는 &quot;POSIX&quot;라는 로캘을 정의합니다.이 로캘은 항상 액세스 할 수 있으며 기본 최소 &quot;C&quot;로캘과 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aa946b2d1792a1779559fdf33adf8c5a87699a3a" translate="yes" xml:space="preserve">
          <source>POSIX also requires that fseek first performs &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt; if there are any unwritten data (but whether the shift state is restored is implementation-defined).</source>
          <target state="translated">POSIX 또한 fseek과 제 행한다는 것을 요구 &lt;code&gt;&lt;a href=&quot;fflush&quot;&gt;fflush&lt;/a&gt;&lt;/code&gt; (그러나 복원 변속 상태가 구현 정의인지 여부를) 상관되지 않은 데이터가있는 경우.</target>
        </trans-unit>
        <trans-unit id="31c9c5859eeb4cbf2e537e662ad97d06d3c60914" translate="yes" xml:space="preserve">
          <source>POSIX also requires that, on XSI-conformant systems, the value returned when the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; and the value returned when the correct result is less than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX는 XSI 호환 시스템에서 올바른 결과가 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 보다 클 때 리턴되는 값 이 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 이고 올바른 결과가 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 보다 작을 때 리턴되는 값 이 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="df9013b0fb54c48f8c3398535564a8c9fb6d5c1b" translate="yes" xml:space="preserve">
          <source>POSIX also specifies that in case of underflow, &lt;code&gt;arg&lt;/code&gt; is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.</source>
          <target state="translated">POSIX는 언더 플로의 경우 &lt;code&gt;arg&lt;/code&gt; 가 수정되지 않은 상태로 반환되고, 지원되지 않는 경우 DBL_MIN, FLT_MIN 및 LDBL_MIN보다 크지 않은 구현 정의 값이 반환되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="335c1690cc5b65b3646d4724816b44c455691178" translate="yes" xml:space="preserve">
          <source>POSIX also specifies that the returned pointer, not just the contents of the pointed-to string, may be invalidated by subsequent calls to setlocale.</source>
          <target state="translated">POSIX는 또한 지정된 문자열의 내용뿐만 아니라 반환 된 포인터가 후속 setlocale 호출에 의해 무효화 될 수 있도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="06d1a5ec1fed2c0de948f38e67dee82961de1cee" translate="yes" xml:space="preserve">
          <source>POSIX defines &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; as one million, regardless of the actual precision of &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX는 실제 &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock&lt;/a&gt;&lt;/code&gt; 정밀도에 관계없이 &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; 를 백만으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ae6c8af49b7a4f2c013a891905aeb93eb19a6eba" translate="yes" xml:space="preserve">
          <source>POSIX defines a thread-safe alternative &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/gmtime.html&quot;&gt;gmtime_r&lt;/a&gt;, which is similar to the C11 function &lt;code&gt;gmtime_s&lt;/code&gt;, except that it does not check the validity of its input parameters.</source>
          <target state="translated">POSIX는 스레드 안전 대안 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/gmtime.html&quot;&gt;gmtime_r을&lt;/a&gt; 정의하는데 , 이는 입력 매개 변수의 유효성을 검사하지 않는다는 점을 제외하고 C11 함수 &lt;code&gt;gmtime_s&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e1aad47697533d1cf4d609c8880d8e1a08506a6b" translate="yes" xml:space="preserve">
          <source>POSIX defines a thread-safe alternative &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html&quot;&gt;localtime_r&lt;/a&gt;, which is similar to the C11 function &lt;code&gt;localtime_s&lt;/code&gt;, except that it does not check the validity of its input parameters.</source>
          <target state="translated">POSIX는 스레드 안전 대안 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html&quot;&gt;localtime_r을&lt;/a&gt; 정의하는데 , 이는 입력 매개 변수의 유효성을 검사하지 않는다는 점을 제외하고 C11 함수 &lt;code&gt;localtime_s&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6f9897e2a366ea005d44ffdc34adfd993a15fa8e" translate="yes" xml:space="preserve">
          <source>POSIX implementations do not distinguish between text and binary streams (there is no special mapping for \n or any other characters).</source>
          <target state="translated">POSIX 구현은 텍스트 스트림과 이진 스트림을 구별하지 않습니다 (\ n 또는 다른 문자에 대한 특별한 매핑은 없습니다).</target>
        </trans-unit>
        <trans-unit id="e8856b5eaf0d4bc59c7900e57d597384a95e21ed" translate="yes" xml:space="preserve">
          <source>POSIX limits undefined behaviors only to when the output string would be longer than 25 characters, when &lt;code&gt;timeptr-&amp;gt;tm_wday&lt;/code&gt; or &lt;code&gt;timeptr-&amp;gt;tm_mon&lt;/code&gt; are not within the expected ranges, or when &lt;code&gt;timeptr-&amp;gt;tm_year&lt;/code&gt; exceeds &lt;code&gt;INT_MAX-1990&lt;/code&gt;.</source>
          <target state="translated">POSIX는 출력 문자열이 25자를 초과 할 때, &lt;code&gt;timeptr-&amp;gt;tm_wday&lt;/code&gt; 또는 &lt;code&gt;timeptr-&amp;gt;tm_mon&lt;/code&gt; 이 예상 범위 내에 있지 않거나 &lt;code&gt;timeptr-&amp;gt;tm_year&lt;/code&gt; 가 &lt;code&gt;INT_MAX-1990&lt;/code&gt; 를 초과 하는 경우에만 정의되지 않은 동작을 제한 합니다 .</target>
        </trans-unit>
        <trans-unit id="9f6418fb45609289cd240484b4818996a8aa9857" translate="yes" xml:space="preserve">
          <source>POSIX offered a thread-safe version of rand called rand_r, which is obsolete in favor of the &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/drand48.html&quot;&gt;drand48&lt;/a&gt; family of functions.</source>
          <target state="translated">POSIX는 rand_r이라는 스레드 안전 버전의 랜드를 제공했으며 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/drand48.html&quot;&gt;drand48&lt;/a&gt; 계열의 기능 을 위해 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="32eef0d1950e7650578656de5bd2fcfe9f8d82c9" translate="yes" xml:space="preserve">
          <source>POSIX recommends &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html&quot;&gt;sigaction&lt;/a&gt; instead of &lt;code&gt;signal&lt;/code&gt;, due to its underspecified behavior and significant implementation variations, regarding signal delivery while a signal handler is executed.</source>
          <target state="translated">POSIX 는 신호 처리기가 실행되는 동안 신호 전달과 관련하여 지정되지 않은 동작과 상당한 구현 변형으로 인해 &lt;code&gt;signal&lt;/code&gt; 대신 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html&quot;&gt;sigaction&lt;/a&gt; 을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="c567b9031ff51fb9b1ea5a64cf6d5a57e9f563c1" translate="yes" xml:space="preserve">
          <source>POSIX requires that &lt;code&gt;signal&lt;/code&gt; is thread-safe, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04&quot;&gt;specifies a list of async-signal-safe library functions&lt;/a&gt; that may be called from any signal handler.</source>
          <target state="translated">POSIX는 &lt;code&gt;signal&lt;/code&gt; 가 스레드로부터 안전 해야하며 모든 신호 처리기에서 호출 될 수있는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04&quot;&gt;비동기 신호 안전 라이브러리 함수 목록을 지정&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="27534ecaa17f348b7ed18ae38042351411d5d54a" translate="yes" xml:space="preserve">
          <source>POSIX requires that the LC_CTYPE facet of the currently installed C locale is stored within the stream object the moment its orientation becomes wide, and is used for all future I/O on this stream until the orientation is changed, regardless of any subsequent calls to &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX는 현재 설치된 C 로케일의 LC_CTYPE 패싯이 방향이 넓어지는 순간 스트림 오브젝트 내에 저장되어야하며 &lt;code&gt;&lt;a href=&quot;locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에 관계없이 방향이 변경 될 때까지이 스트림의 모든 미래 I / O에 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="e2824292b7da5f4c3c882e7cd7f442e03c72c117" translate="yes" xml:space="preserve">
          <source>POSIX requires that the period of the pseudo-random number generator used by &lt;code&gt;rand&lt;/code&gt; be at least 232</source>
          <target state="translated">POSIX에서는 &lt;code&gt;rand&lt;/code&gt; 가 사용하는 의사 난수 생성기의 기간이 232 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8315c3400a6c02895638e578d86ada429f817006" translate="yes" xml:space="preserve">
          <source>POSIX requires that this function sets &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../error/errno_macros&quot;&gt;EOVERFLOW&lt;/a&gt;&lt;/code&gt; if it fails because the argument is too large.</source>
          <target state="translated">POSIX에서는 인수가 너무 커서 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../error/errno_macros&quot;&gt;EOVERFLOW&lt;/a&gt;&lt;/code&gt; 로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bdc1accb0a3117418c3d1604ff7f1bd63b14ca7" translate="yes" xml:space="preserve">
          <source>POSIX specifies a common extension: if &lt;code&gt;dst&lt;/code&gt; is a null pointer, this function returns the number of bytes that would be written to &lt;code&gt;dst&lt;/code&gt;, if converted. Similar behavior is standard for &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;wcstombs_s&lt;/code&gt;.</source>
          <target state="translated">POSIX는 공통 확장명을 지정합니다. &lt;code&gt;dst&lt;/code&gt; 가 널 포인터 인 경우이 함수는 변환 된 경우 &lt;code&gt;dst&lt;/code&gt; 에 기록 될 바이트 수를 리턴합니다 . &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;wcstombs_s&lt;/code&gt; 에 대한 유사한 동작이 표준입니다 .</target>
        </trans-unit>
        <trans-unit id="5f3b8de189c2091db808d59bd3105aa30e6f191e" translate="yes" xml:space="preserve">
          <source>POSIX specifies a common extension: if &lt;code&gt;dst&lt;/code&gt; is a null pointer, this function returns the number of wide characters that would be written to &lt;code&gt;dst&lt;/code&gt;, if converted. Similar behavior is standard for &lt;code&gt;mbstowcs_s&lt;/code&gt; and for &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX는 공통 확장명을 지정합니다. &lt;code&gt;dst&lt;/code&gt; 가 널 포인터 인 경우이 함수는 변환시 &lt;code&gt;dst&lt;/code&gt; 에 기록 될 와이드 문자 수를 리턴합니다 . &lt;code&gt;mbstowcs_s&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; 에 대해서도 유사한 동작이 표준입니다 .</target>
        </trans-unit>
        <trans-unit id="f640ef44ff8aceca9d40819362503cdf028c703d" translate="yes" xml:space="preserve">
          <source>POSIX systems additionally define the similarly named function &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tempnam.html&quot;&gt;tempnam()&lt;/a&gt;&lt;/code&gt;, which offers the choice of a directory (which defaults to the optionally defined macro &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html&quot;&gt;P_tmpdir&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템은 비슷한 이름의 함수 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tempnam.html&quot;&gt;tempnam()&lt;/a&gt;&lt;/code&gt; 추가로 정의하여 디렉토리 선택을 제공합니다 (기본적으로 선택적으로 정의 된 매크로 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html&quot;&gt;P_tmpdir&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8f7145f57c3449a8db7e8e0c0eb5442612d6d1a" translate="yes" xml:space="preserve">
          <source>PRIX&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIX&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0a64e120776de9fbefa5418d4d43b3ba89d70837" translate="yes" xml:space="preserve">
          <source>PRIXFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIXFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9ddbba6bf4dafbb2a873648eda5d9098a39a0f38" translate="yes" xml:space="preserve">
          <source>PRIXLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIXLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18e1b5b3da1f5696ee1b5d766902e3bdf9a229ea" translate="yes" xml:space="preserve">
          <source>PRIXMAX</source>
          <target state="translated">PRIXMAX</target>
        </trans-unit>
        <trans-unit id="781c2eb6dafec442ebfc72f8b7ebae2317fe378f" translate="yes" xml:space="preserve">
          <source>PRIXPTR</source>
          <target state="translated">PRIXPTR</target>
        </trans-unit>
        <trans-unit id="b7d33bb5db43e551d35c482fd09131ad46207a8d" translate="yes" xml:space="preserve">
          <source>PRId&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRId&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0b3f9185242ed4fd4aa7fe79711cff60ca67e2f7" translate="yes" xml:space="preserve">
          <source>PRIdFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIdFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f8d0c46ca6bb30380b59f4f101705eefd6490015" translate="yes" xml:space="preserve">
          <source>PRIdLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIdLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc53f81c479d6b89c4ff776e1934d8e02814c41f" translate="yes" xml:space="preserve">
          <source>PRIdMAX</source>
          <target state="translated">PRIdMAX</target>
        </trans-unit>
        <trans-unit id="a17d0b9784580f9889085e64178ec0165b48f47c" translate="yes" xml:space="preserve">
          <source>PRIdPTR</source>
          <target state="translated">PRIdPTR</target>
        </trans-unit>
        <trans-unit id="714fc0bc0af7a9749d04748234fc179ac576a244" translate="yes" xml:space="preserve">
          <source>PRIi&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIi&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ea09c5b25c9c93bc85281625a00cd1a3f3cb84b3" translate="yes" xml:space="preserve">
          <source>PRIiFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIiFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a2bc784563d7725f115131118c7018a222c378c5" translate="yes" xml:space="preserve">
          <source>PRIiLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIiLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6358aee55979a62f99273506f52e4e38200b3ace" translate="yes" xml:space="preserve">
          <source>PRIiMAX</source>
          <target state="translated">PRIiMAX</target>
        </trans-unit>
        <trans-unit id="032e31e8a0c90d21725ebd9b9787dd714fdc2aad" translate="yes" xml:space="preserve">
          <source>PRIiPTR</source>
          <target state="translated">PRIiPTR</target>
        </trans-unit>
        <trans-unit id="d58f3f7ece61a2a7733019776f7e3739fcf290b4" translate="yes" xml:space="preserve">
          <source>PRIo&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIo&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1bb1f0b366d2a11133856c82c60391c095a82cda" translate="yes" xml:space="preserve">
          <source>PRIoFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIoFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8e51125962ffd20d71e1b64e858f7cd2fc64c083" translate="yes" xml:space="preserve">
          <source>PRIoLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIoLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="804d9608ba0996c9a1dbcdbe7dc4ff6089c2c1be" translate="yes" xml:space="preserve">
          <source>PRIoMAX</source>
          <target state="translated">PRIoMAX</target>
        </trans-unit>
        <trans-unit id="c416df2e883d4710bb2459e89d0cecd848a9c16f" translate="yes" xml:space="preserve">
          <source>PRIoPTR</source>
          <target state="translated">PRIoPTR</target>
        </trans-unit>
        <trans-unit id="cef6a59a75eb0c565c5c285d0bd5628314f68c33" translate="yes" xml:space="preserve">
          <source>PRIu&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIu&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="60e1df3d0d76c883177df0c85e11dc9f4782c343" translate="yes" xml:space="preserve">
          <source>PRIuFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIuFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c7de01de7367eabf2a6cbb0005c1ee9b3e0ff536" translate="yes" xml:space="preserve">
          <source>PRIuLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIuLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07d19cc5e39483d2b638c9747d236b9f98cf2ba6" translate="yes" xml:space="preserve">
          <source>PRIuMAX</source>
          <target state="translated">PRIuMAX</target>
        </trans-unit>
        <trans-unit id="a53e86b08e7c119ae3fe44531c7aaf0301532d48" translate="yes" xml:space="preserve">
          <source>PRIuPTR</source>
          <target state="translated">PRIuPTR</target>
        </trans-unit>
        <trans-unit id="2d4d67b6d521f879ad2c3fae70c27987e0b2b365" translate="yes" xml:space="preserve">
          <source>PRIx&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIx&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac79b02c9366823911f81b644baaade6a66b7127" translate="yes" xml:space="preserve">
          <source>PRIxFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIxFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="efcc600b2091877d2742f8fc3653c4b5f63f4a12" translate="yes" xml:space="preserve">
          <source>PRIxLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">PRIxLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cdaafdc9843631b79c26045d58fabfb0fc7c9663" translate="yes" xml:space="preserve">
          <source>PRIxMAX</source>
          <target state="translated">PRIxMAX</target>
        </trans-unit>
        <trans-unit id="29216749819cc7374de90e9b38698676527b3a0a" translate="yes" xml:space="preserve">
          <source>PRIxPTR</source>
          <target state="translated">PRIxPTR</target>
        </trans-unit>
        <trans-unit id="e2d341dab357c92fea1cc61d3e72cb6281d41c97" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MAX</source>
          <target state="translated">PTRDIFF_MAX</target>
        </trans-unit>
        <trans-unit id="68e5106036965c9d086871ec56706e8f44965f32" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MIN</source>
          <target state="translated">PTRDIFF_MIN</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="73a713f006a51b44d7ffe9f8f32e74c81d8db332" translate="yes" xml:space="preserve">
          <source>Passing a &lt;code&gt;size&lt;/code&gt; which is not an integral multiple of &lt;code&gt;alignment&lt;/code&gt; or a &lt;code&gt;alignment&lt;/code&gt; which is not valid or not supported by the implementation causes the function to fail and return a null pointer (C11, as published, specified undefined behavior in this case, this was corrected by DR 460). Removal of size restrictions to make it possible to allocate small objects at restrictive alignment boundaries (similar to &lt;a href=&quot;../language/alignas&quot;&gt;&lt;code&gt;alignas&lt;/code&gt;&lt;/a&gt;) has been proposed by &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2072.htm&quot;&gt;n2072&lt;/a&gt;.</source>
          <target state="translated">지나가는 &lt;code&gt;size&lt;/code&gt; 의 정수 배가 아닌 &lt;code&gt;alignment&lt;/code&gt; 또는 &lt;code&gt;alignment&lt;/code&gt; 이 경우, 지정된 정의되지 않은 동작 공표 NULL 포인터를 실패하고 반환하는 함수를 구현 지원 유효한지없는 원인 (C11는,이 보정 된 DR 460에 의해). 크기 제한의 제거가 가능 (유사 제한 정렬 경계에서 작은 물체 할당 할 수 있도록 &lt;a href=&quot;../language/alignas&quot;&gt; &lt;code&gt;alignas&lt;/code&gt; &lt;/a&gt; 에 의해 제안되었다) &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2072.htm&quot;&gt;n2072을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34dfc8d6cd7478d6828f48721c4f4220b682b54b" translate="yes" xml:space="preserve">
          <source>Performs explicit type conversion.</source>
          <target state="translated">명시 적 유형 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8e086fa3837f92effda2f189c65d872aaf2923d5" translate="yes" xml:space="preserve">
          <source>Phase 1</source>
          <target state="translated">1 단계</target>
        </trans-unit>
        <trans-unit id="330708acff87bb6907139071d5b459ded3e2d04a" translate="yes" xml:space="preserve">
          <source>Phase 2</source>
          <target state="translated">2 단계</target>
        </trans-unit>
        <trans-unit id="681032fd51c92a246ce412b39048b4ee77dca634" translate="yes" xml:space="preserve">
          <source>Phase 3</source>
          <target state="translated">3 단계</target>
        </trans-unit>
        <trans-unit id="78d44d36dd0ef3c8fc841ed57f6811ad23d3444a" translate="yes" xml:space="preserve">
          <source>Phase 4</source>
          <target state="translated">4 단계</target>
        </trans-unit>
        <trans-unit id="53f56e33fd048af3ea5f5836a9ebc4271647e4f2" translate="yes" xml:space="preserve">
          <source>Phase 5</source>
          <target state="translated">5 단계</target>
        </trans-unit>
        <trans-unit id="d95c8c6e048db1b43f633d810e6911867dafdf1a" translate="yes" xml:space="preserve">
          <source>Phase 6</source>
          <target state="translated">6 단계</target>
        </trans-unit>
        <trans-unit id="35a6e111a7e2e8fab957c5ce32c74294af54929f" translate="yes" xml:space="preserve">
          <source>Phase 7</source>
          <target state="translated">7 단계</target>
        </trans-unit>
        <trans-unit id="f992983641f78a8c013798273706bbac409bc020" translate="yes" xml:space="preserve">
          <source>Phase 8</source>
          <target state="translated">8 단계</target>
        </trans-unit>
        <trans-unit id="8dec91782cf447c62f887433fae8bdce01c3fe91" translate="yes" xml:space="preserve">
          <source>Phases of translation</source>
          <target state="translated">번역 단계</target>
        </trans-unit>
        <trans-unit id="be0813d9bb5496f0d5533fee53776e91237df8de" translate="yes" xml:space="preserve">
          <source>Point of declaration</source>
          <target state="translated">선언의 포인트</target>
        </trans-unit>
        <trans-unit id="886d0e716745d04046260e2fd4e01fbcdb9fbe82" translate="yes" xml:space="preserve">
          <source>Pointer arithmetic</source>
          <target state="translated">포인터 산술</target>
        </trans-unit>
        <trans-unit id="1dad7ddcfc4dd1845430d750452929c090145667" translate="yes" xml:space="preserve">
          <source>Pointer conversions</source>
          <target state="translated">포인터 변환</target>
        </trans-unit>
        <trans-unit id="220f1fd327711e96e3028b6709d46b742350f010" translate="yes" xml:space="preserve">
          <source>Pointer declaration</source>
          <target state="translated">포인터 선언</target>
        </trans-unit>
        <trans-unit id="5a55dbea62d8e8531595e04ca705ad7ec6aa187e" translate="yes" xml:space="preserve">
          <source>Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing, which is indicated by the special null pointer value.</source>
          <target state="translated">포인터는 한정자를 추가 할 수있는 함수 또는 다른 유형의 객체를 나타내는 객체의 유형입니다. 포인터는 아무것도 참조하지 않을 수 있으며, 특수 널 포인터 값으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b701fa737c41b8405d3b3f7760d145e2e7f6091" translate="yes" xml:space="preserve">
          <source>Pointer to object of any type can be &lt;a href=&quot;conversion&quot;&gt;implicitly converted&lt;/a&gt; to pointer to &lt;code&gt;void&lt;/code&gt; (optionally &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;-qualified), and vice versa:</source>
          <target state="translated">모든 유형의 객체에 대한 포인터는 &lt;a href=&quot;conversion&quot;&gt;암시 적&lt;/a&gt; 으로 &lt;code&gt;void&lt;/code&gt; (선택적으로 &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; 또는 &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; -qualified)에 대한 포인터로 암시 적으로 변환 할 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cc73e3cdae64ac7123b31602d1b60bce60462fac" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;dest&lt;/code&gt;, that is also in &lt;code&gt;breakset&lt;/code&gt;, or null pointer if no such character exists.</source>
          <target state="translated">의 첫 번째 문자의 포인터 &lt;code&gt;dest&lt;/code&gt; 에 또한, &lt;code&gt;breakset&lt;/code&gt; , 또는 그러한 문자가 존재하지 않는 경우는 null 포인터.</target>
        </trans-unit>
        <trans-unit id="6ebaf2a6a20f7b6c7586e0484fcb32649bd4a5f5" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;dest&lt;/code&gt;, that is also in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character exists.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 의 첫 번째 문자를 가리키는 포인터 는 &lt;code&gt;str&lt;/code&gt; 에 있으며 , 해당 문자가 없으면 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fe9e35434f828d3a11ae11da261d3e71214675f" translate="yes" xml:space="preserve">
          <source>Pointer to the first character of the found substring in &lt;code&gt;dest&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such substring is found. If &lt;code&gt;src&lt;/code&gt; points to an empty string, &lt;code&gt;dest&lt;/code&gt; is returned.</source>
          <target state="translated">의 첫 번째 문자의 포인터에서 하위 문자열을 발견 &lt;code&gt;dest&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이러한 문자열이 발견되지 않는 경우. 경우 &lt;code&gt;src&lt;/code&gt; 빈 문자열 점, &lt;code&gt;dest&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6f47cbf04cda2b8fa15a46ceaeda9392b735c0bd" translate="yes" xml:space="preserve">
          <source>Pointer to the first character of the found substring in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such substring is found. If &lt;code&gt;substr&lt;/code&gt; points to an empty string, &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에서 발견 된 부분 문자열의 첫 번째 문자를 가리키는 포인터 이거나 그러한 부분 문자열이없는 경우 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;substr&lt;/code&gt; 이 빈 문자열을 가리키는 경우 &lt;code&gt;str&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e9f608798db8c021a3eafbdf2c24587c22140695" translate="yes" xml:space="preserve">
          <source>Pointer to the first element of an array of &lt;code&gt;argc + 1&lt;/code&gt; pointers, of which the last one is null and the previous ones, if any, point to strings that represent the arguments passed to the program from the host environment. If &lt;code&gt;argv[0]&lt;/code&gt; is not a null pointer (or, equivalently, if &lt;code&gt;argc&lt;/code&gt; &amp;gt; 0), it points to a string that represents the program name, which is empty if the program name is not available from the host environment.</source>
          <target state="translated">&lt;code&gt;argc + 1&lt;/code&gt; 포인터 배열의 첫 번째 요소를 가리키는 포인터. 마지막 요소는 null이고 이전 요소는있는 경우 호스트 환경에서 프로그램에 전달 된 인수를 나타내는 문자열을 가리 킵니다. 경우 &lt;code&gt;argv[0]&lt;/code&gt; 널 포인터가 아니다 (또는, 경우 동등 &lt;code&gt;argc&lt;/code&gt; , 비어 프로그램 이름을 나타내는 문자열을 가리키는&amp;gt; 0) 프로그램 이름은 호스트 환경에서 사용할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="405e5d4054459c9f481d32fb4025569549fc54c2" translate="yes" xml:space="preserve">
          <source>Pointer to the found character in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="translated">에서 발견 된 문자의 포인터 &lt;code&gt;str&lt;/code&gt; 을 , 또는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이러한 문자가 발견되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="8c4f765e2320d24e28834fd57258bdf60d616f3d" translate="yes" xml:space="preserve">
          <source>Pointer to the found character in &lt;code&gt;str&lt;/code&gt;, or null pointer if no such character is found.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에서 찾은 문자를 가리키는 포인터. 그러한 문자가 없으면 널 포인터.</target>
        </trans-unit>
        <trans-unit id="b1e8c4f8ecb8e493cc67d3b4ab6c8ee17ceb8a9d" translate="yes" xml:space="preserve">
          <source>Pointer to the location of the character, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="translated">문자의 위치를 ​​가리키는 포인터 . 그러한 문자가없는 경우는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21825601c681d15ea8978fbec39c4ef272eee665" translate="yes" xml:space="preserve">
          <source>Pointer to the location of the wide character, or a null pointer if no such character is found.</source>
          <target state="translated">넓은 문자의 위치를 ​​가리키는 포인터. 그러한 문자가 없으면 널 포인터.</target>
        </trans-unit>
        <trans-unit id="b0f4e8e141903b4f0830a9fbf39082e3c0002128" translate="yes" xml:space="preserve">
          <source>Pointers are used for indirection, which is a ubiquitous programming technique; they can be used to implement pass-by-reference semantics, to access objects with dynamic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, to implement &quot;optional&quot; types (using the null pointer value), aggregation relationship between structs, callbacks (using pointers to functions), generic interfaces (using pointers to void), and much more.</source>
          <target state="translated">포인터는 유비쿼터스 프로그래밍 기술인 간접에 사용됩니다. 그것들은 참조에 의한 통과 의미론 을 구현하고, 동적 &lt;a href=&quot;storage_duration&quot;&gt;저장 시간을&lt;/a&gt; 갖는 객체에 접근하고 , &quot;선택적&quot;유형을 구현하기 위해 (널 포인터 값을 사용하여), 구조체 간의 집계 관계, 콜백 (함수에 대한 포인터를 사용하여), 일반 인터페이스에 사용될 수 있습니다. (포인터를 사용하여 무효화) 및 훨씬 더.</target>
        </trans-unit>
        <trans-unit id="36f90edf619ad392e7a9ec083e54442cf600b30c" translate="yes" xml:space="preserve">
          <source>Pointers may appear as operands to the &lt;a href=&quot;operator_member_access#Dereference&quot;&gt;indirection operator&lt;/a&gt; (unary &lt;code&gt;*&lt;/code&gt;), which returns &lt;a href=&quot;value_category&quot;&gt;the lvalue&lt;/a&gt; identifying the pointed-to object:</source>
          <target state="translated">포인터는 지시 된 객체를 식별하는 &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; 를 반환 하는 &lt;a href=&quot;operator_member_access#Dereference&quot;&gt;간접 연산자&lt;/a&gt; (unary &lt;code&gt;*&lt;/code&gt; )에 피연산자로 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7324a9c3bb73a069fd86296c2d3c8eff5bf1e09e" translate="yes" xml:space="preserve">
          <source>Pointers of every type have a special value known as</source>
          <target state="translated">모든 유형의 포인터는</target>
        </trans-unit>
        <trans-unit id="92b1e34071ba74ebd5271bef008fbd99d767fdf6" translate="yes" xml:space="preserve">
          <source>Pointers returned by allocation functions such as &lt;code&gt;&lt;a href=&quot;../memory/malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; are suitably aligned for any object, which means they are aligned at least as strictly as &lt;code&gt;max_align_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 같은 할당 함수에 의해 반환되는 포인터는 모든 객체에 적합하게 정렬됩니다. 즉, &lt;code&gt;max_align_t&lt;/code&gt; 만큼 엄격하게 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bd06e334d5015b6a66d37944bb18db253b12c1c" translate="yes" xml:space="preserve">
          <source>Pointers to char are often &lt;a href=&quot;../string/byte&quot;&gt;used to represent strings&lt;/a&gt;. To represent a valid byte string, a pointer must be pointing at a char that is an element of an array of char, and there must be a char with the value zero at some index greater or equal to the index of the element referenced by the pointer.</source>
          <target state="translated">char에 대한 포인터는 종종 &lt;a href=&quot;../string/byte&quot;&gt;문자열을 나타내는 데 사용됩니다&lt;/a&gt; . 유효한 바이트 문자열을 나타내려면 포인터가 char 배열의 요소 인 char을 가리켜 야하며, 일부 인덱스의 값이 0 인 char이 있어야합니다. 바늘.</target>
        </trans-unit>
        <trans-unit id="b82bc7e72d8d51c0188462e092d842450c228f3d" translate="yes" xml:space="preserve">
          <source>Pointers to functions</source>
          <target state="translated">함수를 가리키는 포인터</target>
        </trans-unit>
        <trans-unit id="00b7228167bc78f725c1aa6170713523c3e87add" translate="yes" xml:space="preserve">
          <source>Pointers to objects</source>
          <target state="translated">객체에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="7f7fc6a0f3c979a244e510b65787995b7a3b6966" translate="yes" xml:space="preserve">
          <source>Pointers to objects of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type may also appear as the left-hand operands of the &lt;a href=&quot;operator_member_access&quot;&gt;member access through pointer&lt;/a&gt; operator &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct&quot;&gt;구조체&lt;/a&gt; 및 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 유형의 객체에 &lt;a href=&quot;operator_member_access&quot;&gt;대한 포인터는 포인터&lt;/a&gt; 연산자 &lt;code&gt;-&amp;gt;&lt;/code&gt; 를통해 멤버 액세스 의 왼쪽 피연산자로 나타날 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee25cfd40679ceda92c701097a34e138aa84fe43" translate="yes" xml:space="preserve">
          <source>Pointers to void</source>
          <target state="translated">무효 포인터</target>
        </trans-unit>
        <trans-unit id="f8a2c64b9ffad4e941a7b6419408254d9b93a70f" translate="yes" xml:space="preserve">
          <source>Pointers to void are used to pass objects of unknown type, which is common in generic interfaces: &lt;code&gt;&lt;a href=&quot;../memory/malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;void*&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;qsort&lt;/a&gt;&lt;/code&gt; expects a user-provided callback that accepts two &lt;code&gt;const void*&lt;/code&gt; arguments. &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html&quot;&gt;pthread_create&lt;/a&gt; expects a user-provided callback that accepts and returns &lt;code&gt;void*&lt;/code&gt;. In all cases, it is the caller's responsibility to convert the pointer to the correct type before use.</source>
          <target state="translated">void에 대한 포인터는 알 수없는 유형의 객체를 전달하는 데 사용되며 일반 인터페이스에서 일반적입니다. &lt;code&gt;&lt;a href=&quot;../memory/malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;void*&lt;/code&gt; 반환 하고 &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;qsort&lt;/a&gt;&lt;/code&gt; 는 두 개의 &lt;code&gt;const void*&lt;/code&gt; 인수 를 허용하는 사용자 제공 콜백을 예상합니다 . &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html&quot;&gt;pthread_create&lt;/a&gt; 는 &lt;code&gt;void*&lt;/code&gt; 를 받아들이고 리턴하는 사용자 제공 콜백을 예상합니다 . 모든 경우에, 사용하기 전에 포인터를 올바른 유형으로 변환하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="f1f8e7db6309cddc0c5732e9a9ba58aaec05d533" translate="yes" xml:space="preserve">
          <source>Pole error</source>
          <target state="translated">극 오차</target>
        </trans-unit>
        <trans-unit id="b0d042fd98c607a113e1de0917255c86503669b3" translate="yes" xml:space="preserve">
          <source>Pole error may occur if &lt;code&gt;arg&lt;/code&gt; is -1.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 -1 이면 폴 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b17e2690e7349805c990c7c5df9303f661668615" translate="yes" xml:space="preserve">
          <source>Pole error may occur if &lt;code&gt;arg&lt;/code&gt; is zero.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 0 이면 폴 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da9ebb96d6456e6e0214a89210dd04cd1b71df2c" translate="yes" xml:space="preserve">
          <source>Positive value if &lt;code&gt;lhs&lt;/code&gt; appears after &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">사전 순으로 &lt;code&gt;rhs&lt;/code&gt; 뒤에 &lt;code&gt;lhs&lt;/code&gt; 가 나타나는 경우 양수 값 입니다.</target>
        </trans-unit>
        <trans-unit id="714e8e0d9935902a6887a396fa6d2f712afabcf0" translate="yes" xml:space="preserve">
          <source>Positive value if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 가 양수인 경우 양수</target>
        </trans-unit>
        <trans-unit id="2c5624e422d114bf4c07e574d33c43264c084cff" translate="yes" xml:space="preserve">
          <source>Positive value if the value of the first differing wide character in &lt;code&gt;lhs&lt;/code&gt; is greater than the value of the corresponding wide character in &lt;code&gt;rhs&lt;/code&gt;: &lt;code&gt;rhs&lt;/code&gt; precedes &lt;code&gt;lhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 에서 첫 번째로 다른 넓은 문자 의 값이 &lt;code&gt;rhs&lt;/code&gt; 에서 해당하는 넓은 문자의 값보다 큰 경우 양수 값 : &lt;code&gt;rhs&lt;/code&gt; 는 사전 순으로 &lt;code&gt;lhs&lt;/code&gt; 앞에옵니다 .</target>
        </trans-unit>
        <trans-unit id="00d014f6e89348741eecc9997521bd010438349e" translate="yes" xml:space="preserve">
          <source>Possible implementation</source>
          <target state="translated">가능한 구현</target>
        </trans-unit>
        <trans-unit id="a78bac5dbecd72e3a2b6b9a7c6387b18bbb07e9b" translate="yes" xml:space="preserve">
          <source>Possible implementation of &lt;code&gt;mbstate_t&lt;/code&gt; is a struct type holding an array representing the incomplete multibyte character, an integer counter indicating the number of bytes in the array that have been processed, and a representation of the current shift state.</source>
          <target state="translated">&lt;code&gt;mbstate_t&lt;/code&gt; 의 가능한 구현은 불완전한 멀티 바이트 문자를 나타내는 배열, 처리 된 배열의 바이트 수를 나타내는 정수 카운터 및 현재 시프트 상태의 표현을 보유하는 구조체 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fef4f19dbc69bc7fa8ed2879ac59a6eb92531a56" translate="yes" xml:space="preserve">
          <source>Possible output:</source>
          <target state="translated">가능한 출력 :</target>
        </trans-unit>
        <trans-unit id="ff9c60d34af113296884c65c8010519328c83df3" translate="yes" xml:space="preserve">
          <source>Post-increment or post-decrement on any &lt;a href=&quot;atomic&quot;&gt;atomic variable&lt;/a&gt; is an atomic read-modify-write operation with memory order &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;atomic&quot;&gt;원자 변수의&lt;/a&gt; 사후 증가 또는 사후 감소 는 메모리 순서가 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 인 원자 적 읽기 수정 쓰기 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="3b3a2228beca8f49314c3fcd02a2b8475fe33e8f" translate="yes" xml:space="preserve">
          <source>Power functions</source>
          <target state="translated">전원 기능</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="b631d34d72f3f492d653422060a77dea90b29f64" translate="yes" xml:space="preserve">
          <source>Precedence and associativity are independent from &lt;a href=&quot;eval_order&quot;&gt;order of evaluation&lt;/a&gt;.</source>
          <target state="translated">우선 순위와 연관성은 &lt;a href=&quot;eval_order&quot;&gt;평가 순서와&lt;/a&gt; 무관 합니다.</target>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="75f2e4344f7133573ec1e2a5657aee298b86d10a" translate="yes" xml:space="preserve">
          <source>Predefined macros</source>
          <target state="translated">사전 정의 된 매크로</target>
        </trans-unit>
        <trans-unit id="8d39c88b86cfe3e69119f388e37457f6bed869ac" translate="yes" xml:space="preserve">
          <source>Prefix increment and decrement&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-1&quot;&gt;[note 1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">접두사 증가 및 감소 &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-1&quot;&gt;[주 1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="690b8706d3e1f79bde61f6dc644048c260a4aafe" translate="yes" xml:space="preserve">
          <source>Preprocessor</source>
          <target state="translated">Preprocessor</target>
        </trans-unit>
        <trans-unit id="ce3857451491e15e8d99cfffd90e6c5e20f4c044" translate="yes" xml:space="preserve">
          <source>Preprocessor constant expression</source>
          <target state="translated">전 처리기 상수 표현식</target>
        </trans-unit>
        <trans-unit id="4f4bbb5e0cb36ae9eddced10ea643518cae66105" translate="yes" xml:space="preserve">
          <source>Previous signal handler on success or &lt;code&gt;&lt;a href=&quot;sig_err&quot;&gt;SIG_ERR&lt;/a&gt;&lt;/code&gt; on failure (setting a signal handler can be disabled on some implementations).</source>
          <target state="translated">성공시 이전 신호 처리기 또는 실패시 &lt;code&gt;&lt;a href=&quot;sig_err&quot;&gt;SIG_ERR&lt;/a&gt;&lt;/code&gt; (신호 처리기 설정은 일부 구현에서 비활성화 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a9a96ec019494d5b8b041c1d2468061ae66e35d5" translate="yes" xml:space="preserve">
          <source>Primary</source>
          <target state="translated">Primary</target>
        </trans-unit>
        <trans-unit id="610cd0ab8c3ab5b15fdfa49aabc7a8429ee0623d" translate="yes" xml:space="preserve">
          <source>Primary expressions</source>
          <target state="translated">기본 표현</target>
        </trans-unit>
        <trans-unit id="a2d83338b8e29ac2309be82d56e0443145d5a534" translate="yes" xml:space="preserve">
          <source>Primary expressions are any of the following:</source>
          <target state="translated">기본 표현식은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ce18cda82bbb1e06990b3ba51b5b40df45c3c20c" translate="yes" xml:space="preserve">
          <source>Print values of different types.</source>
          <target state="translated">다른 유형의 값을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="98e9f4fd305f45da337a63f599fbf41cad195960" translate="yes" xml:space="preserve">
          <source>Prints a textual description of the error code currently stored in the system variable &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시스템 변수 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 현재 저장된 오류 코드의 텍스트 설명 을 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 에 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="71a6c2836b46a115435b7695c9816a4e27a3157a" translate="yes" xml:space="preserve">
          <source>Prior calls to &lt;code&gt;&lt;a href=&quot;mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; on the same mutex</source>
          <target state="translated">동일한 뮤텍스 에서 &lt;code&gt;&lt;a href=&quot;mtx_unlock&quot;&gt;mtx_unlock&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출</target>
        </trans-unit>
        <trans-unit id="e02d18eb0ae73b3f5f87b9eaefbf171bf1d769ca" translate="yes" xml:space="preserve">
          <source>Prior to C89, identifiers with external linkage had file scope even when introduced within a block, and because of that, a C89 compiler is not required to diagnose the use of an extern identifier that has gone out of scope (such use is undefined behavior).</source>
          <target state="translated">C89 이전에는 외부 링키지가있는 식별자가 블록 내에 도입 된 경우에도 파일 범위가 있었으므로 이로 인해 C89 컴파일러는 범위를 벗어난 extern 식별자의 사용을 진단 할 필요가 없습니다 (이러한 용도는 정의되지 않은 동작 임) .</target>
        </trans-unit>
        <trans-unit id="41c91f3ac0bca552bc66a0adc8d50ababbf7f598" translate="yes" xml:space="preserve">
          <source>Prior to calling &lt;code&gt;va_arg&lt;/code&gt;, &lt;code&gt;ap&lt;/code&gt; must be initialized by a call to either &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt;, with no intervening call to &lt;code&gt;va_end&lt;/code&gt;. Each invocation of the &lt;code&gt;va_arg&lt;/code&gt; macro modifies &lt;code&gt;ap&lt;/code&gt; to point to the next variable argument.</source>
          <target state="translated">호출하기 전에 &lt;code&gt;va_arg&lt;/code&gt; 를을 , &lt;code&gt;ap&lt;/code&gt; 하나의 호출에 의해 초기화해야합니다 &lt;code&gt;va_start&lt;/code&gt; 를 또는 &lt;code&gt;va_copy&lt;/code&gt; 없이 중간에 호출, &lt;code&gt;va_end&lt;/code&gt; 의 . &lt;code&gt;va_arg&lt;/code&gt; 매크로를 호출 할 때마다 다음 변수 인수를 가리 키도록 &lt;code&gt;ap&lt;/code&gt; 가 수정 됩니다.</target>
        </trans-unit>
        <trans-unit id="55ad15707a1e4cd404656343899e47440f38d804" translate="yes" xml:space="preserve">
          <source>Processor time used by the program so far or &lt;code&gt;(&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;)(-1)&lt;/code&gt; if that information is unavailable or its value cannot be represented.</source>
          <target state="translated">지금까지 프로그램에서 사용한 프로세서 시간 또는 해당 정보를 사용할 수 없거나 해당 값을 표시 할 수없는 경우 &lt;code&gt;(&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;)(-1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="128779d84202e0cb35769444f642fedc1fdb08eb" translate="yes" xml:space="preserve">
          <source>Program support</source>
          <target state="translated">프로그램 지원</target>
        </trans-unit>
        <trans-unit id="1e8d9313490c82ca81623307ec10d5f0ca9c7e23" translate="yes" xml:space="preserve">
          <source>Program support utilities</source>
          <target state="translated">프로그램 지원 유틸리티</target>
        </trans-unit>
        <trans-unit id="bd74641b834d4b980ea6b99d6f71d4205f5d04af" translate="yes" xml:space="preserve">
          <source>Program termination</source>
          <target state="translated">프로그램 종료</target>
        </trans-unit>
        <trans-unit id="a97dcfa91ab18288057a7525c537ab15fcda3ba9" translate="yes" xml:space="preserve">
          <source>Programs are allowed to undefine and perhaps redefine the &lt;code&gt;imaginary&lt;/code&gt; macro.</source>
          <target state="translated">프로그램은 &lt;code&gt;imaginary&lt;/code&gt; 매크로 를 정의하지 않고 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f47783eb436bfec79c2ae8a4b06844533f9db1" translate="yes" xml:space="preserve">
          <source>Provides a hint to the implementation to reschedule the execution of threads, allowing other threads to run.</source>
          <target state="translated">스레드 실행을 다시 예약하여 다른 스레드를 실행할 수 있도록 구현에 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e7bc81b09fe84b88c2bd0e91a6086f7a1dfafed" translate="yes" xml:space="preserve">
          <source>Provides a way to choose one of several expressions at compile time, based on a type of a controlling expression.</source>
          <target state="translated">제어 표현식의 유형에 따라 컴파일시 여러 표현식 중 하나를 선택하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2bb46876475b9a3c594329ae7d4c2bd309d10edc" translate="yes" xml:space="preserve">
          <source>Pseudo-random integer value between &lt;code&gt;​0​&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rand_max&quot;&gt;RAND_MAX&lt;/a&gt;&lt;/code&gt;, inclusive.</source>
          <target state="translated">사이의 의사 임의의 정수 값 &lt;code&gt;​0​&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;rand_max&quot;&gt;RAND_MAX&lt;/a&gt;&lt;/code&gt; (포함).</target>
        </trans-unit>
        <trans-unit id="ec5a7109434fde15be7042621fb38dd5bd8bc899" translate="yes" xml:space="preserve">
          <source>Pseudo-random number generation</source>
          <target state="translated">의사 난수 생성</target>
        </trans-unit>
        <trans-unit id="2fb1858154779be9095d34bc86481decea9864b5" translate="yes" xml:space="preserve">
          <source>Qualifiers</source>
          <target state="translated">Qualifiers</target>
        </trans-unit>
        <trans-unit id="16bebbd20f166f2a5ea26c1b0af5de0e236903be" translate="yes" xml:space="preserve">
          <source>Queries size of the object or type.</source>
          <target state="translated">객체 또는 유형의 크기를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="6d55ee059891ac401548250f745320d7d227a13e" translate="yes" xml:space="preserve">
          <source>Queries the alignment requirement of its operand type.</source>
          <target state="translated">피연산자 유형의 정렬 요구 사항을 조회합니다.</target>
        </trans-unit>
        <trans-unit id="7cd72c18ecc72527ffc7db119290d9fafdfaada3" translate="yes" xml:space="preserve">
          <source>RAND_MAX</source>
          <target state="translated">RAND_MAX</target>
        </trans-unit>
        <trans-unit id="5bc0e782fee69e248da319d61fadfbdb19817a87" translate="yes" xml:space="preserve">
          <source>RSIZE_MAX</source>
          <target state="translated">RSIZE_MAX</target>
        </trans-unit>
        <trans-unit id="ff0c33f8fb105a6ed44c92c4e5ae8502e2bdba20" translate="yes" xml:space="preserve">
          <source>Range allows for a positive leap second. Two leap seconds in the same minute are not allowed (the C90 range 0..61 was a defect)</source>
          <target state="translated">범위는 양의 도약을 허용합니다. 같은 분에 두 번의 윤초는 허용되지 않습니다 (C90 범위 0..61은 결함 임)</target>
        </trans-unit>
        <trans-unit id="b6a2342a836fe9c8230bf65e4558f0b9e4f68cf9" translate="yes" xml:space="preserve">
          <source>Range error due to overflow</source>
          <target state="translated">오버플로로 인한 범위 오류</target>
        </trans-unit>
        <trans-unit id="de112ad2a3e15627f3e2c881b1c1bf4687ea0fa6" translate="yes" xml:space="preserve">
          <source>Range error due to underflow</source>
          <target state="translated">언더 플로로 인한 범위 오류</target>
        </trans-unit>
        <trans-unit id="f53c2d131febb348823fab8a8a7d0f0c49482130" translate="yes" xml:space="preserve">
          <source>Range of values</source>
          <target state="translated">값의 범위</target>
        </trans-unit>
        <trans-unit id="37101c7690c8bed05343fdcf031f4dd86381216e" translate="yes" xml:space="preserve">
          <source>Reaching the end of a function other than &lt;code&gt;main&lt;/code&gt; is equivalent to &lt;code&gt;return;&lt;/code&gt;. For &lt;code&gt;main&lt;/code&gt;, see &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;. Reaching the end of any other value-returning function is undefined behavior, but only if the result of the function is used in an expression.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 이외의 함수의 끝에 도달 하는 것은 &lt;code&gt;return;&lt;/code&gt; 과 같습니다 . . 대한 &lt;code&gt;main&lt;/code&gt; 참조 &lt;a href=&quot;main_function&quot;&gt;주요 기능을&lt;/a&gt; . 다른 값 반환 함수의 끝에 도달하는 것은 정의되지 않은 동작이지만 함수 결과가 표현식에 사용 된 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1b10874047f0d31d06ba0f678394a1558eb74c90" translate="yes" xml:space="preserve">
          <source>Reads at most &lt;code&gt;count - 1&lt;/code&gt; characters from the given file stream and stores them in the character array pointed to by &lt;code&gt;str&lt;/code&gt;. Parsing stops if end-of-file occurs or a newline character is found, in which case &lt;code&gt;str&lt;/code&gt; will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">주어진 파일 스트림 에서 최대 &lt;code&gt;count - 1&lt;/code&gt; 문자를 읽고 &lt;code&gt;str&lt;/code&gt; 이 가리키는 문자 배열에 저장합니다 . 파일 끝이 발생하거나 줄 바꾸기 문자가 발견되면 구문 분석이 중지됩니다.이 경우 &lt;code&gt;str&lt;/code&gt; 에는 줄 바꾸기 문자가 포함됩니다. 오류가 발생하지 않으면 &lt;code&gt;str&lt;/code&gt; 에 마지막으로 쓴 문자 바로 다음 위치에 널 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a053a84cc889b5d3c92765d188b2591de5606290" translate="yes" xml:space="preserve">
          <source>Reads at most &lt;code&gt;count - 1&lt;/code&gt; wide characters from the given file stream and stores them in &lt;code&gt;str&lt;/code&gt;. The produced wide string is always null-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case &lt;code&gt;str&lt;/code&gt; will contain that wide newline character.</source>
          <target state="translated">주어진 파일 스트림 에서 최대 &lt;code&gt;count - 1&lt;/code&gt; 와이드 문자를 읽고 &lt;code&gt;str&lt;/code&gt; 에 저장합니다 . 생성 된 넓은 문자열은 항상 null로 종료됩니다. 파일 끝이 발생하거나 개행 문자가 발견되면 구문 분석이 중지됩니다.이 경우 &lt;code&gt;str&lt;/code&gt; 은 개행 문자를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="577d417b88723fd8d0664a0440d1fc3c6b1a5869" translate="yes" xml:space="preserve">
          <source>Reads data from the a variety of sources, interprets it according to &lt;code&gt;format&lt;/code&gt; and stores the results into given locations.</source>
          <target state="translated">다양한 소스에서 데이터를 읽고 &lt;code&gt;format&lt;/code&gt; 에 따라 해석 하여 결과를 지정된 위치에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="63c3f38917027942bdf2defee55f33a1a1676ada" translate="yes" xml:space="preserve">
          <source>Reads data from the a variety of sources, interprets it according to &lt;code&gt;format&lt;/code&gt; and stores the results into locations defined by &lt;code&gt;vlist&lt;/code&gt;.</source>
          <target state="translated">다양한 소스에서 데이터를 읽고 &lt;code&gt;format&lt;/code&gt; 에 따라 해석 하고 결과를 &lt;code&gt;vlist&lt;/code&gt; 에 의해 정의 된 위치에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="5aa138f75335cb58d8db30ce0ee0a0de2de7beb5" translate="yes" xml:space="preserve">
          <source>Reads the next character from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 다음 문자를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="4b2040213b573097b00ae3d44f08b595fececd40" translate="yes" xml:space="preserve">
          <source>Reads the next character from the given input stream. &lt;code&gt;getc()&lt;/code&gt; may be implemented as a macro.</source>
          <target state="translated">주어진 입력 스트림에서 다음 문자를 읽습니다. &lt;code&gt;getc()&lt;/code&gt; 는 매크로로 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e72999a3c575875931a086d20314e99d122ec063" translate="yes" xml:space="preserve">
          <source>Reads the next wide character from &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 다음 와이드 문자를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="a84d93c4e41037a71622e042bcd5082f7de2ea49" translate="yes" xml:space="preserve">
          <source>Reads the next wide character from the given input stream. &lt;code&gt;getwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">주어진 입력 스트림에서 다음 와이드 문자를 읽습니다. &lt;code&gt;getwc()&lt;/code&gt; 는 매크로로 구현 될 수 있으며 &lt;code&gt;stream&lt;/code&gt; 두 번 이상 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3a8038f3d0bac711fcdfd004cb5474cff9c4e23" translate="yes" xml:space="preserve">
          <source>Reads up to &lt;code&gt;count&lt;/code&gt; objects into the array &lt;code&gt;buffer&lt;/code&gt; from the given input stream &lt;code&gt;stream&lt;/code&gt; as if by calling &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object, and storing the results, in the order obtained, into the successive positions of &lt;code&gt;buffer&lt;/code&gt;, which is reinterpreted as an array of &lt;code&gt;unsigned char&lt;/code&gt;. The file position indicator for the stream is advanced by the number of characters read.</source>
          <target state="translated">최대 읽어 &lt;code&gt;count&lt;/code&gt; 어레이에 오브젝트 &lt;code&gt;buffer&lt;/code&gt; 지정된 입력 스트림에서 &lt;code&gt;stream&lt;/code&gt; 호출하여 마치 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;size&lt;/code&gt; 순의 연속적인 위치에, 얻어진 각 개체 회, 그 결과를 저장하는 &lt;code&gt;buffer&lt;/code&gt; 의 배열로 재 해석하고, &lt;code&gt;unsigned char&lt;/code&gt; . 스트림의 파일 위치 표시기는 읽은 문자 수만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="9266667148dc51fc79e9429ea568b4ab14d9de2c" translate="yes" xml:space="preserve">
          <source>Real floating point conversions</source>
          <target state="translated">실제 부동 소수점 변환</target>
        </trans-unit>
        <trans-unit id="d1bbe45c6a09f891e695a4039d8a9ca160c174cc" translate="yes" xml:space="preserve">
          <source>Real floating types</source>
          <target state="translated">실제 부동 유형</target>
        </trans-unit>
        <trans-unit id="b665fb83dd46a743ece6ac7788ff25eeb048fd90" translate="yes" xml:space="preserve">
          <source>Real floating-integer conversions</source>
          <target state="translated">실수 부동 정수 변환</target>
        </trans-unit>
        <trans-unit id="1a32b612aa6c59a4802452532b040a4e7a646411" translate="yes" xml:space="preserve">
          <source>Real floating-point numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - / * and various mathematical functions from &lt;a href=&quot;../numeric/math&quot;&gt;math.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">실수 부동 소수점 숫자는 &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자&lt;/a&gt; +-/ * 및 &lt;a href=&quot;../numeric/math&quot;&gt;math.h의&lt;/a&gt; 다양한 수학 함수와 함께 사용할 수 있습니다 . 내장 연산자와 라이브러리 함수 모두 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; 에&lt;/a&gt; 설명 된대로 부동 소수점 예외를 발생시키고 &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92febfb20f305a4d8914c7caffc977ee875c316b" translate="yes" xml:space="preserve">
          <source>Real function</source>
          <target state="translated">실제 기능</target>
        </trans-unit>
        <trans-unit id="e6047f2f13b3af12ce60b06fad6bafa995c0fecd" translate="yes" xml:space="preserve">
          <source>Real-complex conversions</source>
          <target state="translated">실제 복잡한 전환</target>
        </trans-unit>
        <trans-unit id="58b2234d9f5d07a67c20fac09814d91d258d8ed6" translate="yes" xml:space="preserve">
          <source>Real-imaginary conversions</source>
          <target state="translated">실제 변환</target>
        </trans-unit>
        <trans-unit id="cf5716cadec080cabf5f5ba082ba735d204bed3d" translate="yes" xml:space="preserve">
          <source>Real-only functions</source>
          <target state="translated">실제 기능</target>
        </trans-unit>
        <trans-unit id="6d5c7e6d49217d70be43ccd48aabc9abb7c3602d" translate="yes" xml:space="preserve">
          <source>Reallocates the given area of memory. It must be previously allocated by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc()&lt;/code&gt; and not yet freed with a call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt;. Otherwise, the results are undefined.</source>
          <target state="translated">주어진 메모리 영역을 재 할당합니다. 이전에 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;realloc()&lt;/code&gt; 의해 할당 되었지만 아직 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;realloc&lt;/code&gt; 에 대한 호출로 해제되지 않아야 합니다. 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c3e4988d8656dd123e2bdf39a4fa12ece71639a" translate="yes" xml:space="preserve">
          <source>Redeclaration</source>
          <target state="translated">Redeclaration</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="084f870de5376a14cc6b9d5dd50fedb1c1d6123f" translate="yes" xml:space="preserve">
          <source>Regardless of the value of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt;, any floating-point expression may be</source>
          <target state="translated">&lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 값에 관계없이 모든 부동 소수점 표현식은</target>
        </trans-unit>
        <trans-unit id="86b43a841c03f3265698cc1a93eb64dd11cbde0b" translate="yes" xml:space="preserve">
          <source>Regardless of whether inlining takes place, the following semantics of inline functions are guaranteed:</source>
          <target state="translated">인라인 발생 여부에 관계없이 다음과 같은 인라인 함수 시맨틱이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="91af7cb71f0bd495564c453ecaf3465fbea46d68" translate="yes" xml:space="preserve">
          <source>Registers the function pointed to by &lt;code&gt;func&lt;/code&gt; to be called on normal program termination (via &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; or returning from &lt;code&gt;main()&lt;/code&gt;). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.</source>
          <target state="translated">에 의해 함수가 가리키는 레지스터 &lt;code&gt;func&lt;/code&gt; 정상 프로그램 종료에 호출하는 (을 통해 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 또는에서 돌아 오는 &lt;code&gt;main()&lt;/code&gt; ). 등록 된 기능은 역순으로 호출됩니다. 즉, 마지막에 등록 된 기능이 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c363bab80721525fb8f92a805ae0e41c65ed700c" translate="yes" xml:space="preserve">
          <source>Registers the function pointed to by &lt;code&gt;func&lt;/code&gt; to be called on quick program termination (via &lt;code&gt;&lt;a href=&quot;quick_exit&quot;&gt;quick_exit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 가 가리키는 기능 을 빠른 프로그램 종료시 ( &lt;code&gt;&lt;a href=&quot;quick_exit&quot;&gt;quick_exit&lt;/a&gt;&lt;/code&gt; 를 통해 ) 호출 하도록 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="c6715560f0ec6bebb7d9cfaefb747366461ac444" translate="yes" xml:space="preserve">
          <source>Regular &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; aligns memory suitable for any object type (which, in practice, means that it is aligned to &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;)&lt;/code&gt;). This function is useful for over-aligned allocations, such as to SSE, cache line, or VM page boundary.</source>
          <target state="translated">일반 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 은 모든 객체 유형에 적합한 메모리를 정렬합니다 (실제로는 &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;)&lt;/code&gt; 정렬됨을 의미 ). 이 기능은 SSE, 캐시 라인 또는 VM 페이지 경계와 같이 과도하게 정렬 된 할당에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="40fa22a00ce265dc796c706bf3adebe616b0341c" translate="yes" xml:space="preserve">
          <source>Relational operators</source>
          <target state="translated">관계 연산자</target>
        </trans-unit>
        <trans-unit id="810fdc44728dd00b9265817c5479d56e97a6735e" translate="yes" xml:space="preserve">
          <source>Relational operators are not defined for complex types (there is no notion of &quot;less than&quot;)  &lt;a href=&quot;conversion&quot;&gt;Implicit conversions&lt;/a&gt; are defined between complex types and other arithmetic types.</source>
          <target state="translated">관계형 연산자는 복합 유형에 대해 정의되지 않습니다 ( &quot;보다 작음&quot;개념이 없음) &lt;a href=&quot;conversion&quot;&gt;암시 적 변환&lt;/a&gt; 은 복합 유형과 다른 산술 유형간에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4dad4e24547281740bab0b6424d17e8db7bf9901" translate="yes" xml:space="preserve">
          <source>Relationship with volatile</source>
          <target state="translated">휘발성과의 관계</target>
        </trans-unit>
        <trans-unit id="a5c5cb0dd39fd5f8960a126f776dbc3b14c78315" translate="yes" xml:space="preserve">
          <source>Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation's atomicity is guaranteed (see &lt;a href=&quot;memory_order#Relaxed_ordering&quot;&gt;Relaxed ordering&lt;/a&gt; below)</source>
          <target state="translated">완화 된 작업 : 다른 읽기 또는 쓰기에 부과 된 동기화 또는 순서 제한이 없으며이 작업의 원 자성 만 보장됩니다 (아래의 &lt;a href=&quot;memory_order#Relaxed_ordering&quot;&gt;완화 된 순서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="332a6fa800dab748056c239b8ee0efb205f4447c" translate="yes" xml:space="preserve">
          <source>Relaxed ordering</source>
          <target state="translated">편안한 주문</target>
        </trans-unit>
        <trans-unit id="e58453a35482a76c4a6c848eaa246de1ef9209c7" translate="yes" xml:space="preserve">
          <source>Release sequence</source>
          <target state="translated">릴리즈 순서</target>
        </trans-unit>
        <trans-unit id="d1d1207cbd03d1b413657584c3395f5bd0ed2f5e" translate="yes" xml:space="preserve">
          <source>Release-Acquire ordering</source>
          <target state="translated">출시-취득 주문</target>
        </trans-unit>
        <trans-unit id="f39c9974a3cea1d56e06409a4e0aafdeca8e0911" translate="yes" xml:space="preserve">
          <source>Release-Consume ordering</source>
          <target state="translated">출시-소비 주문</target>
        </trans-unit>
        <trans-unit id="c20a1017faea096d3f06199fd35a9c0037bfb227" translate="yes" xml:space="preserve">
          <source>Remainder</source>
          <target state="translated">Remainder</target>
        </trans-unit>
        <trans-unit id="cb03fda356568db4d5e3e86bde6f95f62a88efdc" translate="yes" xml:space="preserve">
          <source>Renormalizes local calendar time expressed as a &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; object and also converts it to time since epoch as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are ignored. The values in &lt;code&gt;time&lt;/code&gt; are not checked for being out of range.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;tm&quot;&gt;struct tm&lt;/a&gt;&lt;/code&gt; 객체 로 표현 된 로컬 달력 시간을 다시 정규화 하고 epoch 이후의 시간으로 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 객체 로 시간을 변환 합니다. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; 및 &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; 는 무시됩니다. &lt;code&gt;time&lt;/code&gt; 값 은 범위를 벗어난 것으로 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d54f3dfed1488935d7c52054cea01eb56aeaf7df" translate="yes" xml:space="preserve">
          <source>Replacing text macros</source>
          <target state="translated">텍스트 매크로 교체</target>
        </trans-unit>
        <trans-unit id="360bc539904b3901915f57b0aead8cb40373f0de" translate="yes" xml:space="preserve">
          <source>Representation</source>
          <target state="translated">Representation</target>
        </trans-unit>
        <trans-unit id="f58188a9fa856b68ed7f26e3ac08aa0d1104663c" translate="yes" xml:space="preserve">
          <source>Reserved identifiers</source>
          <target state="translated">예약 식별자</target>
        </trans-unit>
        <trans-unit id="ed1beabd25888481ef7e7320f042c946ece8ae71" translate="yes" xml:space="preserve">
          <source>Resets the error flags and the &lt;code&gt;EOF&lt;/code&gt; indicator for the given file stream.</source>
          <target state="translated">주어진 파일 스트림에 대한 오류 플래그 및 &lt;code&gt;EOF&lt;/code&gt; 표시기를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c6dde473741ea38e3e837590483812eb679e2c0c" translate="yes" xml:space="preserve">
          <source>Restricted pointers can be assigned to unrestricted pointers freely, the optimization opportunities remain in place as long as the compiler is able to analyze the code:</source>
          <target state="translated">제한된 포인터는 무제한 포인터에 자유롭게 할당 될 수 있으며, 컴파일러가 코드를 분석 할 수있는 한 최적화 기회가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="299a15e6a23badee14ff1ded59c353807a27199b" translate="yes" xml:space="preserve">
          <source>Result too large</source>
          <target state="translated">결과가 너무 큼</target>
        </trans-unit>
        <trans-unit id="c6883e0e7dc8792ea7ee4d1fd3e70a87b3885efd" translate="yes" xml:space="preserve">
          <source>Return from the function &lt;code&gt;func&lt;/code&gt; is equivalent to calling &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; with the argument equal to the return value of &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">함수로부터 복귀 &lt;code&gt;func&lt;/code&gt; 호출하는 것과 &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; 를 반환 값과 동일한 인수로 &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="67e60c61a2cb501fef535f6480a136abd92b092b" translate="yes" xml:space="preserve">
          <source>Returning from the &lt;a href=&quot;../language/main_function&quot;&gt;the main function&lt;/a&gt;, either by a &lt;code&gt;return&lt;/code&gt; statement or by reaching the end of the function, executes &lt;code&gt;exit()&lt;/code&gt;, passing the argument of the return statement (or &lt;code&gt;​0​&lt;/code&gt; if implicit return was used) as &lt;code&gt;exit_code&lt;/code&gt;.</source>
          <target state="translated">로부터 반환 &lt;a href=&quot;../language/main_function&quot;&gt;주요 기능&lt;/a&gt; a로하거나, &lt;code&gt;return&lt;/code&gt; 문 또는 함수의 끝에 도달하여 실행 &lt;code&gt;exit()&lt;/code&gt; (또는 return 문의 인수 전달 &lt;code&gt;​0​&lt;/code&gt; 으로 암시 복귀가 사용 된 경우) &lt;code&gt;exit_code&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b3c6de90b23169d6f174b12ffb8d2aaeca2a0c12" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;y&lt;/code&gt;, no longer a part of a dependency tree.</source>
          <target state="translated">더 이상 종속성 트리의 일부가 아닌 &lt;code&gt;y&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2809a59ee9f0296bb53a75fbb2a47dc36322d0c1" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;ch&lt;/code&gt; on success.</source>
          <target state="translated">성공시 &lt;code&gt;ch&lt;/code&gt; 의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4d0963a3c6426ccf7883b34bb28e1079108f6d44" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="79d34cc53c91cb0ef88db625515c39c82b4e81a1" translate="yes" xml:space="preserve">
          <source>Returns a pseudo-random integer value between &lt;code&gt;​0​&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rand_max&quot;&gt;RAND_MAX&lt;/a&gt;&lt;/code&gt; (0 and &lt;code&gt;RAND_MAX&lt;/code&gt; included).</source>
          <target state="translated">간의 의사 랜덤 정수 값 리턴 &lt;code&gt;​0​&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;rand_max&quot;&gt;RAND_MAX&lt;/a&gt;&lt;/code&gt; (0 &lt;code&gt;RAND_MAX&lt;/code&gt; 가 포함 참조).</target>
        </trans-unit>
        <trans-unit id="3c4030079cb9790be4a62baca1ff6ddcb26790ee" translate="yes" xml:space="preserve">
          <source>Returns pointer to the beginning of the next token or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if there are no more tokens.</source>
          <target state="translated">다음 토큰의 시작에 대한 포인터를 반환하거나 토큰 이 더 없으면 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e65f5a894dd95dc019d600d1dbfddceab4bb9d5" translate="yes" xml:space="preserve">
          <source>Returns pointer to the beginning of the next token or null pointer if there are no more tokens.</source>
          <target state="translated">다음 토큰의 시작 부분에 대한 포인터를 반환하거나 더 이상 토큰이 없으면 null 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71e63a227541857b3a0da5079dc8797dd3c7c831" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of the type &lt;a href=&quot;compatible_type#Type_names&quot;&gt;named&lt;/a&gt; by type-name. If type-name is an array type, the result is the alignment requirement of the array element type. The type-name cannot be function type or an incomplete type.</source>
          <target state="translated">type-name으로 &lt;a href=&quot;compatible_type#Type_names&quot;&gt;명명&lt;/a&gt; 된 유형 의 &lt;a href=&quot;object#Alignment&quot;&gt;정렬 요구 사항&lt;/a&gt; 을 반환합니다 . type-name이 배열 유형 인 경우 결과는 배열 요소 유형의 정렬 요구 사항입니다. type-name은 함수 유형이거나 불완전한 유형일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="663871df15b2f6ee9e26e55a41663284ec4550db" translate="yes" xml:space="preserve">
          <source>Returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds, divide it by &lt;code&gt;&lt;a href=&quot;clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로그램 실행과 관련된 구현 정의 시대가 시작된 이후 프로세스가 사용한 대략적인 프로세서 시간을 반환합니다. 결과 값을 초로 변환하려면 &lt;code&gt;&lt;a href=&quot;clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt; 로 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="a0b17bbf99a58a2143f7c445a6dd4cc3aa96f5b1" translate="yes" xml:space="preserve">
          <source>Returns the current calendar time encoded as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object, and also stores it in the &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;arg&lt;/code&gt; (unless &lt;code&gt;arg&lt;/code&gt; is a null pointer).</source>
          <target state="translated">리턴로 인코딩 현재 달력 시간 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 에서 객체를, 또한 저장을 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 객체가 가리키는 &lt;code&gt;arg&lt;/code&gt; (하지 않는 한 &lt;code&gt;arg&lt;/code&gt; 널 포인터입니다).</target>
        </trans-unit>
        <trans-unit id="6b69ea241d835183fed16fae52dc52cb37b02021" translate="yes" xml:space="preserve">
          <source>Returns the current rounding direction of floating-point arithmetic operations.</source>
          <target state="translated">부동 소수점 산술 연산의 현재 반올림 방향을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df6b322504672a6970700b3e04757f1b29aeb267" translate="yes" xml:space="preserve">
          <source>Returns the file position indicator for the file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">파일 스트림 &lt;code&gt;stream&lt;/code&gt; 의 파일 위치 지시자를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="1a00730c0bc95f0373e8ebb17b29d4645a75f3e2" translate="yes" xml:space="preserve">
          <source>Returns the identifier of the calling thread.</source>
          <target state="translated">호출 스레드의 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d30459c10ad5105d0ab1705279ee5b1a61d5f35d" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment (span) of the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters found in the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 가 가리키는 null로 끝나는 바이트 문자열의 최대 초기 세그먼트 (스팬) 길이를 반환합니다 .이 문자열은 &lt;code&gt;src&lt;/code&gt; 가 가리키는 null로 끝나는 바이트 문자열에서 찾은 문자로만 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e911e9f618600fcec443b1b3eb7fe87250c3b0c6" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment of the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters</source>
          <target state="translated">반환 값은 널 종료 바이트 문자열의 최대 초기 세그먼트의 길이가 가리키는 &lt;code&gt;dest&lt;/code&gt; 문자 만 구성되어 있습니다,</target>
        </trans-unit>
        <trans-unit id="cd874c8f829aec557cab43dde4fea18e303b214e" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 가 가리키는 와이드 문자열의 최대 초기 세그먼트 길이를 리턴하며 문자만으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="84cfb1d10d156ad85db1a941437a837070c48ee2" translate="yes" xml:space="preserve">
          <source>Returns the length of the maximum initial segment of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that consists of only the characters found in wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자열에서 찾은 문자만으로 구성 되는 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 넓은 문자열의 최대 초기 세그먼트 길이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="94aa99483b81e6bfe86ca5ad316ad9be3e71bd24" translate="yes" xml:space="preserve">
          <source>Returns the value held in thread-specific storage for the current thread identified by &lt;code&gt;tss_key&lt;/code&gt;. Different threads may get different values identified by the same key.</source>
          <target state="translated">&lt;code&gt;tss_key&lt;/code&gt; 로 식별 된 현재 스레드에 대한 스레드 특정 스토리지에 보유 된 값을 리턴합니다 . 다른 스레드는 동일한 키로 식별되는 다른 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4a31eb193820e7907fcfa74092de98c9c00c383" translate="yes" xml:space="preserve">
          <source>Returns zero on success. Otherwise &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned and the error indicator of the file stream is set.</source>
          <target state="translated">성공하면 0을 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 가 리턴되고 파일 스트림의 오류 표시기가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3464f71d8a112c06004b412c38cc0c5da3a86307" translate="yes" xml:space="preserve">
          <source>Right-to-Left</source>
          <target state="translated">Right-to-Left</target>
        </trans-unit>
        <trans-unit id="fe82ba6f5d66b495587b08ed97ce387d2c4f2f77" translate="yes" xml:space="preserve">
          <source>Right-to-left</source>
          <target state="translated">Right-to-left</target>
        </trans-unit>
        <trans-unit id="bb11a8e3f8712e36e7cd9d1c615a4e3dbb03336a" translate="yes" xml:space="preserve">
          <source>Rules</source>
          <target state="translated">Rules</target>
        </trans-unit>
        <trans-unit id="e0e1e9bb21dd6bf2ca9e0ec4ae5e68aeafe63a3a" translate="yes" xml:space="preserve">
          <source>SCHAR_MAXSHRT_MAXINT_MAXLONG_MAXLLONG_MAX</source>
          <target state="translated">SCHAR_MAXSHRT_MAXINT_MAXLONG_MAXLLONG_MAX</target>
        </trans-unit>
        <trans-unit id="0c1c4579f2c3ffdd09da47704048a8f99de86d92" translate="yes" xml:space="preserve">
          <source>SCHAR_MINSHRT_MININT_MINLONG_MINLLONG_MIN</source>
          <target state="translated">SCHAR_MINSHRT_MININT_MINLONG_MINLLONG_MIN</target>
        </trans-unit>
        <trans-unit id="6d04b55aadc6ab9c5bbc2aa7259245c75e68b744" translate="yes" xml:space="preserve">
          <source>SCNd&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNd&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3dd91f84d0faf1a7978dad2e71c905da0953b4bb" translate="yes" xml:space="preserve">
          <source>SCNdFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNdFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31c5cc7de51ea969f267e338f9664c295f050b1c" translate="yes" xml:space="preserve">
          <source>SCNdLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNdLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="954af9691203e55c28f455fe350cb91ac544605d" translate="yes" xml:space="preserve">
          <source>SCNdMAX</source>
          <target state="translated">SCNdMAX</target>
        </trans-unit>
        <trans-unit id="130aefc4b4c263044102a86d820fa5fa1b1267bc" translate="yes" xml:space="preserve">
          <source>SCNdPTR</source>
          <target state="translated">SCNdPTR</target>
        </trans-unit>
        <trans-unit id="27443f5d3060bebbc97c2ae3ad46791875b6f35f" translate="yes" xml:space="preserve">
          <source>SCNi&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNi&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3333b86b76b7339b77825f7f7d8a7feabb8e8fb0" translate="yes" xml:space="preserve">
          <source>SCNiFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNiFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ec5adaf2b1bc307dc3d7f5c6e0e39ce1b1461a0" translate="yes" xml:space="preserve">
          <source>SCNiLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNiLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="322b1af9a53c72c177fbf3ea5885fc063c2ee978" translate="yes" xml:space="preserve">
          <source>SCNiMAX</source>
          <target state="translated">SCNiMAX</target>
        </trans-unit>
        <trans-unit id="1bca168cd6b75e54e9556697d1fefb33e9be5462" translate="yes" xml:space="preserve">
          <source>SCNiPTR</source>
          <target state="translated">SCNiPTR</target>
        </trans-unit>
        <trans-unit id="7ec6b9b949b7e74e362fe8e3617e5f1254b8993a" translate="yes" xml:space="preserve">
          <source>SCNo&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNo&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2aa75357781bdcd5db86111157ab4458a8d31f7" translate="yes" xml:space="preserve">
          <source>SCNoFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNoFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48241bcacb32921016825bbe262366c64825ba9f" translate="yes" xml:space="preserve">
          <source>SCNoLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNoLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dd57c71f9af34a05df64b2cb0852af74079c8e77" translate="yes" xml:space="preserve">
          <source>SCNoMAX</source>
          <target state="translated">SCNoMAX</target>
        </trans-unit>
        <trans-unit id="6ee478f14171bc68088d3a2d62f00688c4e93a83" translate="yes" xml:space="preserve">
          <source>SCNoPTR</source>
          <target state="translated">SCNoPTR</target>
        </trans-unit>
        <trans-unit id="82d2cfea406b75d643446d58e315fa444c32a554" translate="yes" xml:space="preserve">
          <source>SCNu&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNu&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9291e6fe3e56533e850c78bc70f169efe028e26" translate="yes" xml:space="preserve">
          <source>SCNuFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNuFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c2482617647b1a07313a59631c1399e21f866b25" translate="yes" xml:space="preserve">
          <source>SCNuLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNuLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="77a1bea67b77d4f2b90e2e18413d19c05eb1afcf" translate="yes" xml:space="preserve">
          <source>SCNuMAX</source>
          <target state="translated">SCNuMAX</target>
        </trans-unit>
        <trans-unit id="66f3921dcb65715e758f659e948b555986f1dc25" translate="yes" xml:space="preserve">
          <source>SCNuPTR</source>
          <target state="translated">SCNuPTR</target>
        </trans-unit>
        <trans-unit id="ff05862f1b9f3256053ef1a0a82cfa0412a700b5" translate="yes" xml:space="preserve">
          <source>SCNx&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNx&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="da030e2b848d9fb4ff0dfef8744f6ff50635067a" translate="yes" xml:space="preserve">
          <source>SCNxFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNxFAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dc927540afddc8460a68daa198c325339d793206" translate="yes" xml:space="preserve">
          <source>SCNxLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="translated">SCNxLEAST&lt;b&gt;x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d951cfaf38ab5146110920c0c300a03b43579d0" translate="yes" xml:space="preserve">
          <source>SCNxMAX</source>
          <target state="translated">SCNxMAX</target>
        </trans-unit>
        <trans-unit id="b28ed0a5c405253f7f22d9a0ed2013840fd1e090" translate="yes" xml:space="preserve">
          <source>SCNxPTR</source>
          <target state="translated">SCNxPTR</target>
        </trans-unit>
        <trans-unit id="cbc7e0a19e1921df2bb4f7d98a66cf6142b0f475" translate="yes" xml:space="preserve">
          <source>SEEK_SETSEEK_CURSEEK_END</source>
          <target state="translated">SEEK_SETSEEK_CURSEEK_END</target>
        </trans-unit>
        <trans-unit id="a4987582417fa8d350d09c41eb8cd2418585e91d" translate="yes" xml:space="preserve">
          <source>SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM</source>
          <target state="translated">SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM</target>
        </trans-unit>
        <trans-unit id="e85f8b5c7eac9f932a93cbf9d03712194c0da0e2" translate="yes" xml:space="preserve">
          <source>SIGTERM</source>
          <target state="translated">SIGTERM</target>
        </trans-unit>
        <trans-unit id="c14418b849b6f44f556b64e716d39aa40f64e3c9" translate="yes" xml:space="preserve">
          <source>SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE</source>
          <target state="translated">SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE</target>
        </trans-unit>
        <trans-unit id="0dc45828951839d51ed09a34e9ec04114252f1c0" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MAX</source>
          <target state="translated">SIG_ATOMIC_MAX</target>
        </trans-unit>
        <trans-unit id="ed5fe11c179ff72e658bdf95049d44be1deebeae" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MIN</source>
          <target state="translated">SIG_ATOMIC_MIN</target>
        </trans-unit>
        <trans-unit id="11ba97d97359684906853156cac74443ad3705c5" translate="yes" xml:space="preserve">
          <source>SIG_DFL, SIG_IGN</source>
          <target state="translated">SIG_DFL, SIG_IGN</target>
        </trans-unit>
        <trans-unit id="6895a2910b6ef7a004e7772ca3f499a19fa27cde" translate="yes" xml:space="preserve">
          <source>SIG_DFLSIG_IGN</source>
          <target state="translated">SIG_DFLSIG_IGN</target>
        </trans-unit>
        <trans-unit id="acd6ee1f7bbae2aab00eb4fc3df100932eee5d46" translate="yes" xml:space="preserve">
          <source>SIG_ERR</source>
          <target state="translated">SIG_ERR</target>
        </trans-unit>
        <trans-unit id="6a03d61729004eed59186d910c6f0d01251b936b" translate="yes" xml:space="preserve">
          <source>SIG_IGN</source>
          <target state="translated">SIG_IGN</target>
        </trans-unit>
        <trans-unit id="256c9f9a067e633db18da0ec81de7b585e074898" translate="yes" xml:space="preserve">
          <source>SIZE_MAX</source>
          <target state="translated">SIZE_MAX</target>
        </trans-unit>
        <trans-unit id="f658d226c6fe78d6a8dff531bcacf40e2b82dbda" translate="yes" xml:space="preserve">
          <source>Saves the current execution context into a variable &lt;code&gt;env&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;jmp_buf&lt;/a&gt;&lt;/code&gt;. This variable can later be used to restore the current execution context by &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; function. That is, when a call to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; function is made, the execution continues at the particular call site that constructed the &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;jmp_buf&lt;/a&gt;&lt;/code&gt; variable passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;. In that case &lt;code&gt;setjmp&lt;/code&gt; returns the value passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 실행 컨텍스트를 &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;jmp_buf&lt;/a&gt;&lt;/code&gt; 유형 의 변수 &lt;code&gt;env&lt;/code&gt; 에 저장합니다 . 이 변수는 나중에 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 함수로 현재 실행 컨텍스트를 복원하는 데 사용될 수 있습니다 . 즉, 전화 할 때 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 를 기능이 수행되면, 실행은 구성된 특정 호출 사이트에서 계속 &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;jmp_buf&lt;/a&gt;&lt;/code&gt; 에 전달 변수 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 를이 . 이 경우 &lt;code&gt;setjmp&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 에 전달 된 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7b8cb9831326bba5b8e845dacab2bf2c27219923" translate="yes" xml:space="preserve">
          <source>Scalar</source>
          <target state="translated">Scalar</target>
        </trans-unit>
        <trans-unit id="a87679692caea6ead71e379f9146a196d7bfddd5" translate="yes" xml:space="preserve">
          <source>Scalar initialization</source>
          <target state="translated">스칼라 초기화</target>
        </trans-unit>
        <trans-unit id="39320a9f36bca32338b46a710d9f674ca8c85e52" translate="yes" xml:space="preserve">
          <source>Scans the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt; for any character from the null-terminated byte string pointed to by &lt;code&gt;breakset&lt;/code&gt;, and returns a pointer to that character.</source>
          <target state="translated">&lt;code&gt;breakset&lt;/code&gt; 이 가리키는 널 종료 바이트 문자열에서 임의의 문자를 &lt;code&gt;dest&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열을 스캔하고 해당 문자에 대한 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="3db912730b0dad4321d1c1f89eb58d808eb4c08d" translate="yes" xml:space="preserve">
          <source>Secondly, at &lt;a href=&quot;translation_phases&quot;&gt;translation phase 7&lt;/a&gt;, a terminating null character is added to each string literal, and then each literal initializes an unnamed array with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and length just enough to contain the contents of the string literal plus one the null terminator.</source>
          <target state="translated">둘째, &lt;a href=&quot;translation_phases&quot;&gt;변환 단계 7&lt;/a&gt; 에서 종료 널 문자가 각 문자열 리터럴에 추가 된 다음 각 리터럴 은 문자열 리터럴의 내용에 하나의 널 종료자를 더하기에 충분한 정적 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간&lt;/a&gt; 및 길이 로 이름이없는 배열을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="e67609798fbc2f2d41baabfcff17da535b38c95d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; for further details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="da4af47f21571f745f8bc1033920738fd1a86f78" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../types/limits#Limits_of_floating_point_types&quot;&gt;Limits of floating point types&lt;/a&gt; and &lt;a href=&quot;../numeric/math&quot;&gt;the math.h library&lt;/a&gt; for additional details, limits, and properties of the floating-point types.</source>
          <target state="translated">참조 &lt;a href=&quot;../types/limits#Limits_of_floating_point_types&quot;&gt;점 유형 부동의 한계&lt;/a&gt; 와 &lt;a href=&quot;../numeric/math&quot;&gt;math.h 라이브러리&lt;/a&gt; 추가 세부 사항, 한계에 대한, 그리고 부동 소수점 형식의 속성을.</target>
        </trans-unit>
        <trans-unit id="6e2a23d9725e4c4c211bef7fda4afecef5d8b573" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;alignof&quot;&gt;_Alignof operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;alignof&quot;&gt;_Alignof 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62757d365bd7c24673f3de3c59fbbed524a89d9f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;cast&quot;&gt;cast operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cast&quot;&gt;캐스트 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae75906653d2fa403026e65c694b5401b8148c28" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;declarations#Definitions&quot;&gt;definitions&lt;/a&gt; for the distinction between declarations and definitions.</source>
          <target state="translated">보다 &lt;a href=&quot;declarations#Definitions&quot;&gt;&lt;/a&gt;선언과 정의의 구별에 정의 를 .</target>
        </trans-unit>
        <trans-unit id="34ff3d4f4d908d809ad3b6c697189968274bfca6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt; for the rules that apply when no initializer is used.</source>
          <target state="translated">보다 &lt;a href=&quot;initialization&quot;&gt;이니셜 라이저&lt;/a&gt; 를 사용하지 않을 때 적용되는 규칙 초기화 를 .</target>
        </trans-unit>
        <trans-unit id="a22e07bda2dfc046f8aeed40779417a19213efb3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; for the details on the inline function definitions.</source>
          <target state="translated">보다 &lt;a href=&quot;inline&quot;&gt;&lt;/a&gt;인라인 함수 정의에 대한 인라인 을 .</target>
        </trans-unit>
        <trans-unit id="85940fba0b167a19873e97d57805ad06ca5d7693" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; for limitations on pointer arithmetic, as well as for implicit conversions applied to the operands.</source>
          <target state="translated">보다 &lt;a href=&quot;operator_arithmetic&quot;&gt;&lt;/a&gt;포인터 산술에 대한 제한 사항과 피연산자에 적용되는 암시 적 변환에 산술 연산자 를 .</target>
        </trans-unit>
        <trans-unit id="9f7a520c9cedd35e00fc92d55ac979ee32a59534" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt; for other details on the mechanics of a function call and &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; for returning from functions.</source>
          <target state="translated">&lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출&lt;/a&gt; 의 메커니즘에 대한 다른 세부 사항 은 함수 호출 연산자 를 참조하십시오.&lt;a href=&quot;return&quot;&gt;&lt;/a&gt; 에서 리턴 하기 위해 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="ba6b5138553cd15e71903a00bd710d67d09bcf8e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operator_precedence&quot;&gt;operator precedence&lt;/a&gt; for the details on the relative precedence of this operator and assignment.</source>
          <target state="translated">보다 &lt;a href=&quot;operator_precedence&quot;&gt;&lt;/a&gt;이 연산자와 할당의 상대적 우선 순위 에 대한 자세한 내용 연산자 우선 순위 를 .</target>
        </trans-unit>
        <trans-unit id="e738ab18c45f344ea0712ae4eecc83588fd51176" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sizeof&quot;&gt;sizeof operator&lt;/a&gt;.</source>
          <target state="translated">보다 &lt;a href=&quot;sizeof&quot;&gt;sizeof 연산자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37908cf859f75e007cff4ce8e59a97477f1164a8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;storage_duration&quot;&gt;storage duration and linkage&lt;/a&gt; for the meaning of the keyword &lt;code&gt;extern&lt;/code&gt; with declarations at file scope.</source>
          <target state="translated">키워드의 의미는 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간 및 연결&lt;/a&gt; 을 참조하십시오 &lt;code&gt;extern&lt;/code&gt; 파일 범위에서 선언 extern .</target>
        </trans-unit>
        <trans-unit id="f464fbea422f7bdf32a4ab54125c7cacbc7faa98" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;struct_initialization&quot;&gt;struct initialization&lt;/a&gt; for the rules about initialization of structs and unions.</source>
          <target state="translated">&lt;a href=&quot;struct_initialization&quot;&gt;구조체 초기화&lt;/a&gt; 참조구조체 및 공용체 에 대한 규칙은 를 .</target>
        </trans-unit>
        <trans-unit id="37a39f25186b95688add0e351acfec65c4480665" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;struct_initialization&quot;&gt;struct initialization&lt;/a&gt; for the rules regarding the initializers for structs.</source>
          <target state="translated">&lt;a href=&quot;struct_initialization&quot;&gt;구조체 초기화&lt;/a&gt; 참조 와 관련된 규칙 를 .</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="c1f65cbb0f97afb41bc0f53b0764e58a00b92b93" translate="yes" xml:space="preserve">
          <source>Seeds the pseudo-random number generator used by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; with the value &lt;code&gt;seed&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 가 사용하는 의사 난수 생성기를 &lt;code&gt;seed&lt;/code&gt; 값으로 시드 합니다.</target>
        </trans-unit>
        <trans-unit id="1e1921a75e80a596c9a940068df630bd1b9feed6" translate="yes" xml:space="preserve">
          <source>Selection statements</source>
          <target state="translated">선택문</target>
        </trans-unit>
        <trans-unit id="d1b86ee2bb16d1ad0e234de6e693444935ff7d48" translate="yes" xml:space="preserve">
          <source>Sends signal sig to the program. The signal handler, specified using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt;, is invoked.</source>
          <target state="translated">신호 sig를 프로그램으로 보냅니다. &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal()&lt;/a&gt;&lt;/code&gt; 사용하여 지정된 신호 핸들러 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="64cf851b8491eff8f5a5c736de201846803398a1" translate="yes" xml:space="preserve">
          <source>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.</source>
          <target state="translated">모든 소비자가 동일한 순서로 발생하는 모든 생산자의 행동을 관찰해야하는 여러 생산자-다중 소비자 상황에 대해서는 순차적 순서가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3c02107bfafa471d5b3be0bbb231a73bba241c" translate="yes" xml:space="preserve">
          <source>Sequentially-consistent ordering</source>
          <target state="translated">순차적으로 일관된 순서</target>
        </trans-unit>
        <trans-unit id="cab164f69a79c1434887771d963b350ec3424a69" translate="yes" xml:space="preserve">
          <source>Sets the error handler for signal &lt;code&gt;sig&lt;/code&gt;. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.</source>
          <target state="translated">signal &lt;code&gt;sig&lt;/code&gt; 에 대한 에러 핸들러를 설정합니다 . 기본 처리가 발생하거나 신호가 무시되거나 사용자 정의 함수가 호출되도록 신호 처리기를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f38e10aa0cf505b2d63a5565466d97ffcb80790e" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator and the multibyte parsing state (if any) for the file stream &lt;code&gt;stream&lt;/code&gt; according to the value pointed to by &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 가 가리키는 값에 따라 파일 스트림 &lt;code&gt;stream&lt;/code&gt; 의 파일 위치 표시기와 멀티 바이트 구문 분석 상태 (있는 경우)를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c7b3106e4fea3b14ec09212e58533017616bc0a5" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator for the file stream &lt;code&gt;stream&lt;/code&gt; to the value pointed to by &lt;code&gt;offset&lt;/code&gt;.</source>
          <target state="translated">파일 스트림 &lt;code&gt;stream&lt;/code&gt; 의 파일 위치 지시자를 &lt;code&gt;offset&lt;/code&gt; 에 의해 지정된 값으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="cb5b6bf739a1d461326235edc3699165eed07554" translate="yes" xml:space="preserve">
          <source>Sets the internal buffer to use for stream operations. It should be at least &lt;code&gt;BUFSIZ&lt;/code&gt; characters long.</source>
          <target state="translated">스트림 작업에 사용할 내부 버퍼를 설정합니다. &lt;code&gt;BUFSIZ&lt;/code&gt; 자 이상이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cac092b9a8bc6f10b53fdabf06fa851cf4ba6610" translate="yes" xml:space="preserve">
          <source>Sets the value of the thread-specific storage identified by &lt;code&gt;tss_id&lt;/code&gt; for the current thread to &lt;code&gt;val&lt;/code&gt;. Different threads may set different values to the same key.</source>
          <target state="translated">현재 스레드에 대해 &lt;code&gt;tss_id&lt;/code&gt; 로 식별 된 스레드 특정 스토리지의 값 을 &lt;code&gt;val&lt;/code&gt; 로 설정합니다. 합니다. 스레드마다 다른 값을 동일한 키로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb85c2a6b05326373aa3e511f26f008dc789209" translate="yes" xml:space="preserve">
          <source>Several C compilers transform suitable memory-copying loops to &lt;code&gt;memcpy&lt;/code&gt; calls.</source>
          <target state="translated">여러 C 컴파일러가 적절한 메모리 복사 루프를 &lt;code&gt;memcpy&lt;/code&gt; 호출로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="c26bd0ea0f59b8ae2c73c9e1a142bd1fcfdbf81d" translate="yes" xml:space="preserve">
          <source>Several cleanup steps are performed:</source>
          <target state="translated">몇 가지 정리 단계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="096f451fac0362d4ca2620596aca61e92e355777" translate="yes" xml:space="preserve">
          <source>Several functions and macro constants for signal management are provided.</source>
          <target state="translated">신호 관리를위한 여러 기능과 매크로 상수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c981f0807d02ebbc26c384c66d0564818dc020b9" translate="yes" xml:space="preserve">
          <source>Several varieties of expressions are known as</source>
          <target state="translated">여러 종류의 표현을</target>
        </trans-unit>
        <trans-unit id="5575c5d9e043f683dd305316e592c565f74bdc3a" translate="yes" xml:space="preserve">
          <source>Shift operators</source>
          <target state="translated">시프트 연산자</target>
        </trans-unit>
        <trans-unit id="52d2b7d5e16389ceda6305019182d49f160f8021" translate="yes" xml:space="preserve">
          <source>Show style used to print a NaN and IEEE format.</source>
          <target state="translated">NaN 및 IEEE 형식을 인쇄하는 데 사용되는 스타일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="71bad6e8d0146ce897984d12435d02c17a86f56b" translate="yes" xml:space="preserve">
          <source>Show style used to print an infinity and IEEE format.</source>
          <target state="translated">무한대 및 IEEE 형식을 인쇄하는 데 사용되는 스타일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0cdf422b3a4d436294c0ed604e530965527b4c41" translate="yes" xml:space="preserve">
          <source>Show the start of calendar time.</source>
          <target state="translated">달력 시간의 시작을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f540f093bfd59e9a1bc4024dc293411a421fcad3" translate="yes" xml:space="preserve">
          <source>Show the start of the epoch.</source>
          <target state="translated">신기원의 시작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0aa2fd65f221fb441668eabd3b7d043130d5f61e" translate="yes" xml:space="preserve">
          <source>Shows the given error message and renders the program ill-formed.</source>
          <target state="translated">주어진 오류 메시지를 표시하고 프로그램을 잘못 작성합니다.</target>
        </trans-unit>
        <trans-unit id="577457386419e49cc011db96f147d3e3e75e3f09" translate="yes" xml:space="preserve">
          <source>Signal handler</source>
          <target state="translated">신호 처리기</target>
        </trans-unit>
        <trans-unit id="dda1c34f3e7ae5e716370d772211709548003ec4" translate="yes" xml:space="preserve">
          <source>Signal handling</source>
          <target state="translated">신호 처리</target>
        </trans-unit>
        <trans-unit id="2d946cd91c48d2465b1861bb4f63d569ff6618d1" translate="yes" xml:space="preserve">
          <source>Signal types</source>
          <target state="translated">신호 유형</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="83cbfd47b41a4ebb43e27ff9728af42d399bbda3" translate="yes" xml:space="preserve">
          <source>Signed integers : maximum value</source>
          <target state="translated">부호있는 정수 : 최대 값</target>
        </trans-unit>
        <trans-unit id="46aa2d10272ed1c7e156088e86d214a184422894" translate="yes" xml:space="preserve">
          <source>Signed integers : minimum value</source>
          <target state="translated">부호있는 정수 : 최소값</target>
        </trans-unit>
        <trans-unit id="7add2e2fdaaac8a1396e22391085b13ed07cb9bd" translate="yes" xml:space="preserve">
          <source>Signed overflow</source>
          <target state="translated">서명 된 오버플로</target>
        </trans-unit>
        <trans-unit id="545d7834dd5b3ef1208d058079bb06e221ffb73e" translate="yes" xml:space="preserve">
          <source>Similar to struct, an unnamed member of a union whose type is a union without name is known as</source>
          <target state="translated">구조체와 유사하게, 이름이없는 공용체 유형의 명명되지 않은 공용체 멤버는</target>
        </trans-unit>
        <trans-unit id="c3c852d4b05ad6891a383f208151dde2146be732" translate="yes" xml:space="preserve">
          <source>Similar to struct, the behavior of the program is undefined if union is defined without any named members (including those obtained via anonymous nested structs or unions).</source>
          <target state="translated">구조체와 유사하게, 익명의 중첩 구조체 또는 공용체를 통해 얻은 멤버를 포함하여 명명 된 멤버없이 공용체를 정의하면 프로그램의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a5468859643416fa0525930a9d474c24454c8fa" translate="yes" xml:space="preserve">
          <source>Similar to union, an unnamed member of a struct whose type is a struct without name is known as</source>
          <target state="translated">공용체와 유사하게, 이름이없는 구조체 유형 인 구조체의 명명되지 않은 멤버는</target>
        </trans-unit>
        <trans-unit id="dcd698e68713f1475dde3342a6ef031b284b2fe4" translate="yes" xml:space="preserve">
          <source>Similar to union, the behavior of the program is undefined if struct is defined without any named members (including those obtained via anonymous nested structs or unions).</source>
          <target state="translated">공용체와 유사하게, 구조체가 익명의 중첩 구조체 또는 공용체를 통해 얻은 멤버를 포함하여 명명 된 멤버없이 정의 된 경우 프로그램의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fdd4fe02838702cd6d96abf35e5bb32e0186abc" translate="yes" xml:space="preserve">
          <source>Simple assignment</source>
          <target state="translated">간단한 할당</target>
        </trans-unit>
        <trans-unit id="84b49109eb327d8d709c75e5626429f1b9dd9338" translate="yes" xml:space="preserve">
          <source>Since its stored value is initialized only once, an object with static storage duration can profile the invocations of a function.</source>
          <target state="translated">저장된 값은 한 번만 초기화되므로 정적 저장 기간을 가진 객체는 함수의 호출을 프로파일 링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01023f649513952abe496b73748117186e5a306e" translate="yes" xml:space="preserve">
          <source>Single character is preceded by a space.</source>
          <target state="translated">단일 문자 앞에 공백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="54f240da1d0f429d9b1906f5ac8b6dd8cc37d07d" translate="yes" xml:space="preserve">
          <source>Single digit is preceded by a space.</source>
          <target state="translated">한 자리 앞에는 공백이옵니다.</target>
        </trans-unit>
        <trans-unit id="1089a09be10396c011527de780e9b49cb3308d4a" translate="yes" xml:space="preserve">
          <source>Size in bits</source>
          <target state="translated">비트 단위의 크기</target>
        </trans-unit>
        <trans-unit id="a653b7c543b492f6dd8c827ee1d1c68606cdc09a" translate="yes" xml:space="preserve">
          <source>Size-of&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-2&quot;&gt;[note 2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">크기 &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-2&quot;&gt;[주 2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="95dfd3d7d9a56268258c71284328df821c466067" translate="yes" xml:space="preserve">
          <source>Sizes of basic types</source>
          <target state="translated">기본 유형의 크기</target>
        </trans-unit>
        <trans-unit id="99d962452bf23cfce358191ab2ce40997d4a7521" translate="yes" xml:space="preserve">
          <source>So that all but the first inclusion of the header in any translation unit are excluded from compilation. All modern compilers record the fact that a header file uses an include guard and do not re-parse the file if it is encountered again, as long as the guard is still defined. (see e.g. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Once-Only-Headers.html&quot;&gt;gcc&lt;/a&gt;).</source>
          <target state="translated">따라서 모든 번역 단위에 첫 번째로 포함 된 헤더를 제외한 모든 것이 컴파일에서 제외됩니다. 모든 최신 컴파일러는 헤더 파일이 포함 가드를 사용하고 가드가 여전히 정의되어있는 한 파일이 다시 발생하면 파일을 다시 구문 분석하지 않는다는 사실을 기록합니다. (예 : &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Once-Only-Headers.html&quot;&gt;gcc&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e6819c0f3ad693fb07ef3b17c21244653c494395" translate="yes" xml:space="preserve">
          <source>So the following complete program is valid C89:</source>
          <target state="translated">따라서 다음과 같은 완전한 프로그램이 유효한 C89입니다.</target>
        </trans-unit>
        <trans-unit id="a1c9d0ae4abd29c89694111dd04361b1e80cda44" translate="yes" xml:space="preserve">
          <source>So, placement of an identifier's declaration (in a declarator or type specifier) outside any block or list of parameters means that the identifier has file scope. File scope of an identifier extends from the declaration to the end of the translation unit in which the declaration appears.</source>
          <target state="translated">따라서 매개 변수 블록 또는 목록 외부에 식별자 선언 (선언자 또는 형식 지정자)을 배치하면 식별자에 파일 범위가 있음을 의미합니다. 식별자의 파일 범위는 선언에서 선언이 나타나는 번역 단위의 끝까지 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="df9df2c45a088ba26a758203f898adda0b9c99e0" translate="yes" xml:space="preserve">
          <source>Some atomic operations are also synchronization operations; they may have additional release semantics, acquire semantics, or sequentially-consistent semantics. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일부 원 자성 작업은 동기화 작업이기도합니다. 이들은 추가 릴리스 의미론을 갖거나 의미론을 획득하거나 순차적으로 일관된 의미론을 가질 수 있습니다. &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba520fb2c503cdc25ec5b9b6f3a0f079c16b72d8" translate="yes" xml:space="preserve">
          <source>Some implementations handle &lt;code&gt;timeptr-&amp;gt;tm_mday==0&lt;/code&gt; as meaning the last day of the preceding month.</source>
          <target state="translated">일부 구현은 &lt;code&gt;timeptr-&amp;gt;tm_mday==0&lt;/code&gt; 의 마지막 날을 의미하는 것으로 timeptr-&amp;gt; tm_mday == 0 을 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="69d9a9a13766d236996c1d2bb4d126a13661dd61" translate="yes" xml:space="preserve">
          <source>Some locales offer additional character classes that detect non-ASCII digits.</source>
          <target state="translated">일부 로케일은 비 ASCII 숫자를 감지하는 추가 문자 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb8327d50eb27e2d33c783ff01dfd4bd720a5528" translate="yes" xml:space="preserve">
          <source>Some operations on floating-point numbers are affected by and modify the state of &lt;a href=&quot;../numeric/fenv&quot;&gt;the floating-point environment&lt;/a&gt; (most notably, the rounding direction).</source>
          <target state="translated">부동 소수점 숫자에 대한 일부 연산은 부동 &lt;a href=&quot;../numeric/fenv&quot;&gt;소수점 환경&lt;/a&gt; 의 상태 (대부분 반올림 방향)의 영향을 받고 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="1062d4ec3477261e4a029a283ebcf5e673c0c76e" translate="yes" xml:space="preserve">
          <source>Source file inclusion</source>
          <target state="translated">소스 파일 포함</target>
        </trans-unit>
        <trans-unit id="6281d436020e1e1aaac5be2a0ebe96a8e81a1643" translate="yes" xml:space="preserve">
          <source>Specifies range and precision of floating-point values obtained from floating-point constants and from all operations (operators, implicit conversions of operands) except assignment, cast, and library function call.</source>
          <target state="translated">부동 소수점 상수 및 할당, 캐스트 및 라이브러리 함수 호출을 제외한 모든 연산 (연산자, 피연산자의 암시 적 변환)에서 얻은 부동 소수점 값의 범위와 정밀도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="bf6d2be3e15b5590b58922d853dd8def45b15e89" translate="yes" xml:space="preserve">
          <source>Specifies that the function does not return to its point of invocation.</source>
          <target state="translated">함수가 호출 시점으로 돌아 가지 않도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a477d8dab7ef5cc90c58a41d06ca3494aeba078f" translate="yes" xml:space="preserve">
          <source>Specify</source>
          <target state="translated">Specify</target>
        </trans-unit>
        <trans-unit id="5328552aac39954649b5d41d7c9d3dceb11e3086" translate="yes" xml:space="preserve">
          <source>Standard approach to preventing multiple inclusion of the same header is by using &lt;a href=&quot;https://en.wikipedia.org/wiki/Include_guard&quot;&gt;include guards&lt;/a&gt;:</source>
          <target state="translated">동일한 헤더가 여러 개 포함되지 않도록하는 표준 방법은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Include_guard&quot;&gt;include guards&lt;/a&gt; 를 사용 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="60fa3463255f2929660b130be625bf2bf442a8eb" translate="yes" xml:space="preserve">
          <source>Standard arithmetic operators &lt;code&gt;+, -, *, /&lt;/code&gt; can be used with real, complex, and imaginary types in any combination.</source>
          <target state="translated">표준 산술 연산자 &lt;code&gt;+, -, *, /&lt;/code&gt; 는 모든 조합에서 실수, 복소수 및 허수 유형과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="6aa6210a01fc681b9801585337a1d40189cc03c1" translate="yes" xml:space="preserve">
          <source>Standard practice is to use the result of a call to &lt;code&gt;&lt;a href=&quot;../../chrono/time&quot;&gt;time&lt;/a&gt;(0)&lt;/code&gt; as the seed. However, &lt;code&gt;time()&lt;/code&gt; returns a &lt;code&gt;&lt;a href=&quot;../../chrono/time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; value, and &lt;code&gt;time_t&lt;/code&gt; is not guaranteed to be an integral type. In practice, though, every major implementation defines &lt;code&gt;time_t&lt;/code&gt; to be an integral type, and this is also what POSIX requires.</source>
          <target state="translated">표준 관행은 호출 &lt;code&gt;&lt;a href=&quot;../../chrono/time&quot;&gt;time&lt;/a&gt;(0)&lt;/code&gt; 의 결과를 시드로 사용하는 것입니다. 그러나, &lt;code&gt;time()&lt;/code&gt; 반환 &lt;code&gt;&lt;a href=&quot;../../chrono/time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 값을, 그리고 &lt;code&gt;time_t&lt;/code&gt; 는 불가분의 유형으로 보장 할 수 없습니다. 그러나 실제로 모든 주요 구현은 &lt;code&gt;time_t&lt;/code&gt; 를 정수 유형으로 정의 하며 이것이 POSIX에 필요한 것이기도합니다.</target>
        </trans-unit>
        <trans-unit id="eaf04f0f0d8ad2fb9946955b63cb23b446e2134b" translate="yes" xml:space="preserve">
          <source>Standard pragmas</source>
          <target state="translated">표준 pragma</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="d49483b8d2a411e4c07e5e138e5500c326175b6d" translate="yes" xml:space="preserve">
          <source>Statements are fragments of the C program that are executed in sequence. The body of any function is a compound statement, which, in turn is a sequence of statements and declarations:</source>
          <target state="translated">명령문은 순서대로 실행되는 C 프로그램의 조각입니다. 모든 함수의 본문은 복합 명령문이며, 차례로 일련의 명령문 및 선언입니다.</target>
        </trans-unit>
        <trans-unit id="5591101f4957e3ec27936a1851a20e9327ccd528" translate="yes" xml:space="preserve">
          <source>Static initializer</source>
          <target state="translated">정적 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="28cd462a941be3973f35bf4451b31c03d2b288c9" translate="yes" xml:space="preserve">
          <source>Static storage duration</source>
          <target state="translated">정적 저장 기간</target>
        </trans-unit>
        <trans-unit id="054b352055da9aba89fd42abb819a5be6e8dda75" translate="yes" xml:space="preserve">
          <source>Storage duration</source>
          <target state="translated">보관 기간</target>
        </trans-unit>
        <trans-unit id="cfda33bc2c68aa23641b6a374ebf0b31534902ce" translate="yes" xml:space="preserve">
          <source>Storage duration and Linkage</source>
          <target state="translated">저장 기간 및 연결</target>
        </trans-unit>
        <trans-unit id="27a6aea0529d546364a8c661d3d4c05e1e722645" translate="yes" xml:space="preserve">
          <source>Storage-class specifiers</source>
          <target state="translated">스토리지 클래스 지정자</target>
        </trans-unit>
        <trans-unit id="f8f29340218ac4df7a30edf8029fb655d93da2f2" translate="yes" xml:space="preserve">
          <source>Storage-class specifiers appear in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;. At most one specifier may be used, except that &lt;code&gt;_Thread_local&lt;/code&gt; may be combined with &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;extern&lt;/code&gt; to adjust linkage(since C11). The storage-class specifiers determine two independent properties of the names they declare:</source>
          <target state="translated">스토리지 클래스 지정자는 &lt;a href=&quot;declarations&quot;&gt;선언에&lt;/a&gt; 나타납니다 . &lt;code&gt;_Thread_local&lt;/code&gt; 을 &lt;code&gt;static&lt;/code&gt; 또는 &lt;code&gt;extern&lt;/code&gt; 과 결합하여 연결을 조정할 수 있다는 점을 제외하고 최대 하나의 지정자를 사용할 수 있습니다 (C11 이후). 스토리지 클래스 지정자는 선언 한 이름의 두 가지 독립적 인 특성을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="22c8de79d80c307a781d904e913db38ce10a7cf2" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">스트림 재배치 작업 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ungetc&lt;/code&gt; 의 영향을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="14f6100e0a3a4d2dd982d5c58873c4de7dc2134d" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">스트림 재배치 작업 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;fsetpos&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;rewind&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;ungetwc&lt;/code&gt; 의 영향을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="f5f5e1a47da510fa4386d462c1aa32523fb29a1e" translate="yes" xml:space="preserve">
          <source>Strict aliasing</source>
          <target state="translated">엄격한 앨리어싱</target>
        </trans-unit>
        <trans-unit id="d26b1bbd9eee2dfd3f5c0a081017d1db1f7dfe02" translate="yes" xml:space="preserve">
          <source>String examination</source>
          <target state="translated">문자열 검사</target>
        </trans-unit>
        <trans-unit id="f72b5d43e5245ea7b69b536ff3f8c988cbabcd7f" translate="yes" xml:space="preserve">
          <source>String handling</source>
          <target state="translated">문자열 처리</target>
        </trans-unit>
        <trans-unit id="5993cb336c6391ee8eea94b873bb797a1c4d4619" translate="yes" xml:space="preserve">
          <source>String literals</source>
          <target state="translated">문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="d094087a6682f2883c0e2a5f324321ae7f6ef95c" translate="yes" xml:space="preserve">
          <source>String literals are &lt;b&gt;not modifiable&lt;/b&gt; (and in fact may be placed in read-only memory such as &lt;code&gt;.rodata&lt;/code&gt;). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.</source>
          <target state="translated">문자열 리터럴은 &lt;b&gt;수정할 수 없습니다&lt;/b&gt; (실제로 &lt;code&gt;.rodata&lt;/code&gt; 와 같은 읽기 전용 메모리에 배치 될 수 있음 ). 프로그램이 문자열 리터럴로 형성된 정적 배열을 수정하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94d113a02479dcd3262a9b7b816910df94ea4083" translate="yes" xml:space="preserve">
          <source>String literals can be used to &lt;a href=&quot;array_initialization&quot;&gt;initialize arrays&lt;/a&gt;, and if the size of the array is one less the size of the string literal, the null terminator is ignored:</source>
          <target state="translated">문자열 리터럴을 사용하여 &lt;a href=&quot;array_initialization&quot;&gt;배열&lt;/a&gt; 을 초기화 할 수 있으며 배열의 크기가 문자열 리터럴의 크기보다 작 으면 null 종결자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="411f94c6ca34e4478bca225615707da562686a1d" translate="yes" xml:space="preserve">
          <source>String manipulation</source>
          <target state="translated">문자열 조작</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="85aec181db33cf00bdd54f1cb9ce01b7d7ff51de" translate="yes" xml:space="preserve">
          <source>Strings library</source>
          <target state="translated">문자열 라이브러리</target>
        </trans-unit>
        <trans-unit id="a50144303ba816c6227872493fae52a6111ce6e9" translate="yes" xml:space="preserve">
          <source>Struct and union initialization</source>
          <target state="translated">구조 및 공용체 초기화</target>
        </trans-unit>
        <trans-unit id="76f5f7c969886addc36643f3c8d0fcf398dacad9" translate="yes" xml:space="preserve">
          <source>Struct and union objects with array members (either direct or members of nested struct/union members) that are designated by &lt;a href=&quot;value_category&quot;&gt;non-lvalue expressions&lt;/a&gt;, have</source>
          <target state="translated">구조체와 연합 어레이 부재 (다이렉트 중첩 구조체 / 조합원 부재)에 의해 지정되는 개체 &lt;a href=&quot;value_category&quot;&gt;비 좌변 식&lt;/a&gt; 가지고</target>
        </trans-unit>
        <trans-unit id="2054b477c350696a3482d27f31c7c82e09f51cdc" translate="yes" xml:space="preserve">
          <source>Struct declaration</source>
          <target state="translated">구조 선언</target>
        </trans-unit>
        <trans-unit id="8de20aa2876654859a7823f0531a18a6b124938c" translate="yes" xml:space="preserve">
          <source>Struct members</source>
          <target state="translated">구조 대원</target>
        </trans-unit>
        <trans-unit id="4926985eb4091c3107b5920cf2b4c09a3d99de88" translate="yes" xml:space="preserve">
          <source>Structure and union member access</source>
          <target state="translated">구조 및 노조원 접근</target>
        </trans-unit>
        <trans-unit id="272728ee96c53fab74b3b727d2572a254ed8e08d" translate="yes" xml:space="preserve">
          <source>Structure and union member access through pointer</source>
          <target state="translated">포인터를 통한 구조 및 공용체 멤버 액세스</target>
        </trans-unit>
        <trans-unit id="7f9dcf8956ae1c0d6f55e5d5d3036df614ef80f7" translate="yes" xml:space="preserve">
          <source>Structure holding a calendar date and time broken down into its components.</source>
          <target state="translated">달력 날짜와 시간을 보유한 구조는 구성 요소로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="6829a88eb9844dcc19a2c6962557c4417821a67d" translate="yes" xml:space="preserve">
          <source>Structure holding an interval broken down into seconds and nanoseconds.</source>
          <target state="translated">간격을 유지하는 구조는 초와 나노초로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="1206016193c83a65cb929069fe8c573d05b83bd9" translate="yes" xml:space="preserve">
          <source>Structure/Union</source>
          <target state="translated">Structure/Union</target>
        </trans-unit>
        <trans-unit id="b1bd6eaaf0ebc0fa2da36cbd85120b995ab0f777" translate="yes" xml:space="preserve">
          <source>Subscript</source>
          <target state="translated">Subscript</target>
        </trans-unit>
        <trans-unit id="f9b527d9bda6aa5482f9a99c0dadede2f93f0385" translate="yes" xml:space="preserve">
          <source>Successive bytes of the string literal or wide characters of the wide string literal, including the terminating null byte/character, initialize the elements of the array:</source>
          <target state="translated">종료 널 바이트 / 문자를 포함하여 문자열 리터럴의 연속 바이트 또는 와이드 문자열 리터럴의 와이드 문자는 배열의 요소를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f3728d9b3ae40693e7dfcd90d79f3156adfcd6ad" translate="yes" xml:space="preserve">
          <source>Suffix/postfix increment and decrement</source>
          <target state="translated">접미사 / 접미사 증가 및 감소</target>
        </trans-unit>
        <trans-unit id="10698a431939209ee6970ff65cfdea1f722da147" translate="yes" xml:space="preserve">
          <source>Support for zero size is deprecated as of C11 DR 400.</source>
          <target state="translated">0 크기 지원은 C11 DR 400에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="e3f57ed7e444bdff9887253d716ac7e573551461" translate="yes" xml:space="preserve">
          <source>T1, using an lvalue expression (typically, dereferencing a pointer) of a different type T2 is undefined behavior, unless:</source>
          <target state="translated">다른 유형 T2의 lvalue 표현식 (일반적으로 포인터 참조)을 사용하는 T1은 다음과 같은 경우를 제외하고 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="4b891eebe5bb2352df82dc8af5d22dfa5983cdbb" translate="yes" xml:space="preserve">
          <source>T2 and T1 are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible types&lt;/a&gt;.</source>
          <target state="translated">T2 및 T1은 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환되는 유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf14ef848bbe7cf30f4f086c03a47a07d50b7c3b" translate="yes" xml:space="preserve">
          <source>T2 is a character type (char, signed char, or unsigned char).</source>
          <target state="translated">T2는 문자 유형 (char, signed char 또는 unsigned char)입니다.</target>
        </trans-unit>
        <trans-unit id="f9acb2dd9854b692972eac6ab63684c3439d4d54" translate="yes" xml:space="preserve">
          <source>T2 is a signed or unsigned version of a type that is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with T1.</source>
          <target state="translated">T2는 T1과 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 되는 유형의 부호있는 버전 또는 부호없는 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="22213a71b43410f67e1bcaf848e74cd92aa863de" translate="yes" xml:space="preserve">
          <source>T2 is an aggregate type or union type type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union).</source>
          <target state="translated">T2는 상기 멤버들 (소 집합 또는 포함 된 유니온의 멤버를 포함하여)을 상기 언급 한 타입 중 하나를 포함하는 집계 타입 또는 유니온 타입 타입이다.</target>
        </trans-unit>
        <trans-unit id="b3222042b89208ab9a488469183bcb236029e898" translate="yes" xml:space="preserve">
          <source>T2 is cvr-qualified version of a type that is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with T1.</source>
          <target state="translated">T2는 T1과 &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;호환&lt;/a&gt; 되는 유형의 cvr 인증 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="aa822a5894e63ba6a65478d203534aaa7258110c" translate="yes" xml:space="preserve">
          <source>TMP_MAXTMP_MAX_S</source>
          <target state="translated">TMP_MAXTMP_MAX_S</target>
        </trans-unit>
        <trans-unit id="82df224f71dc6745757dbb4235c8881c1d18f43f" translate="yes" xml:space="preserve">
          <source>TSS_DTOR_ITERATIONS</source>
          <target state="translated">TSS_DTOR_ITERATIONS</target>
        </trans-unit>
        <trans-unit id="14ae799bf325e27219d4ab3dc8ddcea9a6895d3c" translate="yes" xml:space="preserve">
          <source>Tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period &amp;pi;i, and has poles of the first order along the real line, at coordinates (&amp;pi;(1/2 + n), 0). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.  Mathematical definition of the tangent is tan z =</source>
          <target state="translated">탄젠트는 복잡한 평원에 대한 분석 함수이며 분기 컷이 없습니다. 그것은 &amp;pi;i를 갖는 실수 성분에 대하여 주기적이며, 좌표 (&amp;pi; (1/2 + n), 0)에서, 실선을 따라 1 차 극을 갖는다. 그러나 일반적인 부동 소수점 표현은 &amp;pi; / 2를 정확하게 표현할 수 없으므로 극 오차가 발생하는 인수의 값이 없습니다. 탄젠트의 수학적 정의는 tan z =</target>
        </trans-unit>
        <trans-unit id="985d5a28c86c89a046431264e4a80d7f157a3ec1" translate="yes" xml:space="preserve">
          <source>Temporary lifetime</source>
          <target state="translated">임시 수명</target>
        </trans-unit>
        <trans-unit id="3f1c120671c6b185751a3483c14ffff80c213d47" translate="yes" xml:space="preserve">
          <source>Tentative definitions</source>
          <target state="translated">잠정적 정의</target>
        </trans-unit>
        <trans-unit id="6859d39f71cebf21461938215c02df2587c3222c" translate="yes" xml:space="preserve">
          <source>Tentative definitions were invented to standardize various pre-C89 approaches to forward declaring identifiers with internal linkage.</source>
          <target state="translated">내부 연결로 선언 식별자를 전달하기위한 다양한 C89 이전 접근 방식을 표준화하기 위해 임시 정의가 발명되었습니다.</target>
        </trans-unit>
        <trans-unit id="333aeb3f88a64f1c35827b76c34a5ecfa422bdf4" translate="yes" xml:space="preserve">
          <source>Terminates current function and returns specified value to the caller function.</source>
          <target state="translated">현재 함수를 종료하고 지정된 값을 호출자 함수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="445afbe9b171a445fd57b5067266d572c8745658" translate="yes" xml:space="preserve">
          <source>Ternary conditional&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-3&quot;&gt;[note 3]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">삼항 조건부 &lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;operator_precedence#cite_note-3&quot;&gt;[주 3]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="ae5ac48fe369a69211c19f055bfcf5a33c86967b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../numeric/tgmath&quot;&gt;type-generic math macros&lt;/a&gt; from &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;, introduced in C99, were implemented in compiler-specific manner. Generic selections, introduced in C11, gave the programmers the ability to write similar type-dependent code.</source>
          <target state="translated">&lt;a href=&quot;../numeric/tgmath&quot;&gt;형 제네릭 수학 매크로&lt;/a&gt; 에서 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; C99 도입은, 컴파일러 고유의 방식으로 구현되었다. C11에 도입 된 일반 선택은 프로그래머에게 유사한 유형 종속 코드를 작성할 수있는 기능을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="84abb4fe9ca223ed7f80490baed684f4ff9ad4ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; statement, when encountered anywhere in statement, exits the switch statement:</source>
          <target state="translated">&lt;a href=&quot;break&quot;&gt;휴식&lt;/a&gt; 문, 문 어디서나 발생하는 경우, switch 문을 종료합니다 :</target>
        </trans-unit>
        <trans-unit id="e4e9226ba1bb77688811e391a403b3c92b5c71cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; used anywhere within the loop_statement transfers control to iteration_expression.</source>
          <target state="translated">loop_statement 내에서 사용 된 &lt;a href=&quot;continue&quot;&gt;continue 문은&lt;/a&gt; 제어를 iteration_expression으로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="e2a3e9a3da878c7d9d43e6d58c8263ef19784399" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;declarations&quot;&gt;type specifier&lt;/a&gt; for a struct is identical to the &lt;a href=&quot;union&quot;&gt; &lt;code&gt;union&lt;/code&gt;&lt;/a&gt; type specifier except for the keyword used:</source>
          <target state="translated">구조체 의 &lt;a href=&quot;declarations&quot;&gt;형식 지정자는&lt;/a&gt; 사용 된 키워드를 제외하고 &lt;a href=&quot;union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 형식 지정자와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6a7fea41c467944fca863f8d470daa88608715a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;declarations&quot;&gt;type specifier&lt;/a&gt; for a union is identical to the &lt;a href=&quot;struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; type specifier except for the keyword used:</source>
          <target state="translated">공용체 의 &lt;a href=&quot;declarations&quot;&gt;형식 지정자는&lt;/a&gt; 사용 된 키워드를 제외하고 &lt;a href=&quot;struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 형식 지정자와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ca50bbf10496221d648429763c6c788f42208573" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval_order&quot;&gt;order of evaluation&lt;/a&gt; of subexpressions in an array initializer is indeterminately sequenced in C (but not in C++ since c++11):</source>
          <target state="translated">&lt;a href=&quot;eval_order&quot;&gt;평가 순서&lt;/a&gt; 배열 초기화에서의 표현식은 불확실 C로 시퀀싱 (그러나 C ++에서 보낸 C ++ 11)는 :</target>
        </trans-unit>
        <trans-unit id="76526eba2549f1ba1dbcfaec438e36835c80f656" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval_order&quot;&gt;order of evaluation&lt;/a&gt; of the subexpressions in any initializer is indeterminately sequenced:</source>
          <target state="translated">&lt;a href=&quot;eval_order&quot;&gt;평가하기 위해&lt;/a&gt; 어떤 초기화에 표현식의이 불확실 시퀀스입니다 :</target>
        </trans-unit>
        <trans-unit id="08ddf054b9d98118850acc7743563e5e0b4e9519" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html&quot;&gt;POSIX version of lgamma&lt;/a&gt; is not thread-safe: each execution of the function stores the sign of the gamma function of &lt;code&gt;arg&lt;/code&gt; in the static external variable &lt;code&gt;signgam&lt;/code&gt;. Some implementations provide &lt;code&gt;lgamma_r&lt;/code&gt;, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.</source>
          <target state="translated">&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html&quot;&gt;lgamma&lt;/a&gt; 의 POSIX 버전은 스레드로부터 안전하지 않습니다. 함수를 실행할 때마다 &lt;code&gt;arg&lt;/code&gt; 의 감마 함수 부호가 정적 외부 변수 &lt;code&gt;signgam&lt;/code&gt; 에 저장 됩니다. 일부 구현에서는 &lt;code&gt;lgamma_r&lt;/code&gt; 을 제공 하는데,이 매개 변수는 singgam에 대한 사용자 제공 스토리지에 대한 포인터를 두 번째 매개 변수로 사용하며 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="48d7bc66a49b20e8a34f3db4a41996210816f021" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; specifier is formally listed as a storage-class specifier in the C language grammar, but it is used to declare type names and does not specify storage.</source>
          <target state="translated">&lt;a href=&quot;typedef&quot;&gt;형식 정의의&lt;/a&gt; 지정은 공식적으로 C 언어 문법의 저장소 클래스 지정자로 나열되지만 유형 이름을 선언하는 데 사용되며 저장을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc44a80beef5758e5f19639b3d3e0f4a9b3c9e40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types&quot;&gt;types&lt;/a&gt;&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, and &lt;code&gt;signed char&lt;/code&gt; use one byte for both storage and &lt;a href=&quot;object&quot;&gt;value representation&lt;/a&gt;. The number of bits in a byte is accessible as &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;types&quot;&gt;종류의 &lt;/a&gt; &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; 및 &lt;code&gt;signed char&lt;/code&gt; 저장 및 사용 모두 하나의 바이트 &lt;a href=&quot;object&quot;&gt;값으로 표현&lt;/a&gt; . 바이트의 비트 수는 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5580629e543718292e7f034670f977aad2737a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the cast expression is always non-lvalue.</source>
          <target state="translated">캐스트 표현식 의 &lt;a href=&quot;value_category&quot;&gt;값 범주&lt;/a&gt; 는 항상 lvalue가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f1e7d677d59314533c3183efd27477692b57ab2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; types do not provide inter-thread synchronization, memory ordering, or atomicity.</source>
          <target state="translated">&lt;a href=&quot;volatile&quot;&gt;휘발성&lt;/a&gt; 유형은 스레드 간 동기화, 메모리 주문, 또는 자성을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1dafadbf8ca29d1023c3269e8fbe7224a999675b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#define&lt;/code&gt; directives define the identifier as a macro, that is they instruct the compiler to replace all successive occurrences of identifier with replacement-list, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시자는 임의로 추가 가공 될 수 교체리스트와 식별자의 모든 연속적인 어커런스를 교체하도록 컴파일러에 지시들은 인 매크로로 식별자를 정의한다. 식별자가 이미 모든 유형의 매크로로 정의 된 경우, 정의가 동일하지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="70381beffacc10871e5b37c4ec262605e4cc6a54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#undef&lt;/code&gt; directive undefines the identifier, that is it cancels the previous definition of the identifier by &lt;code&gt;#define&lt;/code&gt; directive. If the identifier does not have an associated macro, the directive is ignored.</source>
          <target state="translated">&lt;code&gt;#undef&lt;/code&gt; 를의 지정은 식별자가 이전 정의를 상쇄되는 식별자 정의를 해제 &lt;code&gt;#define&lt;/code&gt; 지시자. 식별자에 관련 매크로가없는 경우 지시문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="20222cee5dd37e389f85b67fab4f0c2de44ee010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; header provides generic file operation support and supplies functions with narrow character input/output capabilities.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; 헤더 좁은 문자 입력 / 출력 기능을 일반 파일 조작 지원 및 공급 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="63a1a18ed73b3be37e1a913f7ef79ffbc39baeea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; header supplies functions with wide character input/output capabilities.</source>
          <target state="translated">&lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; 다양한 문자 입력 / 출력 기능을 가진 헤더 공급 기능.</target>
        </trans-unit>
        <trans-unit id="0ac2b700ba018b88fda0accdeb14d96e93bc0cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; macros expand into integral expressions that can be used as arguments to the &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; function (and, therefore, as the values to return from the &lt;a href=&quot;../language/main_function&quot;&gt;main function&lt;/a&gt;), and indicate program execution status.</source>
          <target state="translated">&lt;code&gt;EXIT_SUCCESS&lt;/code&gt; 및 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; 매크로는 인수로 사용할 수있는 통합 식으로 확장 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (값이 리턴되는대로, 그리고 따라서, 기능 &lt;a href=&quot;../language/main_function&quot;&gt;주요 기능&lt;/a&gt; ), 및 프로그램 실행 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d5615a09c39393c229b9c18967835ce479d5d69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt;, &lt;code&gt;FP_ZERO&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NAN&lt;/code&gt; macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.</source>
          <target state="translated">&lt;code&gt;FP_NORMAL&lt;/code&gt; 는 , &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; , &lt;code&gt;FP_ZERO&lt;/code&gt; , &lt;code&gt;FP_INFINITE&lt;/code&gt; , &lt;code&gt;FP_NAN&lt;/code&gt; 의 매크로 각 부동 소수점 숫자의 별개의 범주를 나타냅니다. 모두 정수 상수 식으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="200966c346b96b643933a6da4012101e743e905a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HUGE_VALF&lt;/code&gt;, &lt;code&gt;HUGE_VAL&lt;/code&gt; and &lt;code&gt;HUGE_VALL&lt;/code&gt; macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;HUGE_VALF&lt;/code&gt; , &lt;code&gt;HUGE_VAL&lt;/code&gt; 및 &lt;code&gt;HUGE_VALL&lt;/code&gt; 매크로 (참조 플로우의 경우에는 부동 소수점 연산자와 함수에 의해 리턴 된 값과 비교 동등한 양의 부동 소수점 상수 식으로 확장 &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d8ca89171bb30d49ea70bf6004b7252bcefb680f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;I&lt;/code&gt; macro expands to either &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt;. If the implementation does not support imaginary types, then the macro always expands to &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;I&lt;/code&gt; 중 하나에 매크로가 확장 &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; . 구현이 허수 유형을 지원하지 않으면 매크로는 항상 &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; 로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="71ab0f1b6c9b80608c46a2c86f5289d67f530aca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIG_DFL&lt;/code&gt; and &lt;code&gt;SIG_IGN&lt;/code&gt; macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;SIG_DFL&lt;/code&gt; 과 &lt;code&gt;SIG_IGN&lt;/code&gt; 매크로는 함수의 주소와 동일하지 필수적인 표현으로 확장합니다. 매크로는 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;()&lt;/code&gt; 기능을 위한 신호 처리 전략을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="f5dc2deef955b4751fa64fbac9a725409e234d9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Complex_I&lt;/code&gt; macro expands to a value of type &lt;code&gt;const float _Complex&lt;/code&gt; with the value of the imaginary unit.</source>
          <target state="translated">&lt;code&gt;_Complex_I&lt;/code&gt; 타입의 값 매크로 팽창 &lt;code&gt;const float _Complex&lt;/code&gt; 허수 부의 값.</target>
        </trans-unit>
        <trans-unit id="07ba0bf621e8b3660d5038c597e3fa4d89a776c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Imaginary_I&lt;/code&gt; macro expands to a value of type &lt;code&gt;const float _Imaginary&lt;/code&gt; with the value of the imaginary unit.</source>
          <target state="translated">&lt;code&gt;_Imaginary_I&lt;/code&gt; 타입의 값 매크로 팽창 &lt;code&gt;const float _Imaginary&lt;/code&gt; 허수 부의 값.</target>
        </trans-unit>
        <trans-unit id="9b6102e49c22b9639171dd7168842805c8b42deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Noreturn&lt;/code&gt; keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;). If the function declared &lt;code&gt;_Noreturn&lt;/code&gt; returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.</source>
          <target state="translated">&lt;code&gt;_Noreturn&lt;/code&gt; 키워드 함수 선언 나타나고 함수 리턴 명령문을 실행하거나 기능 체의 단부에 도달하여 반환하지 않도록 지정은 (는 실행에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;_Noreturn&lt;/code&gt; 으로 선언 된 함수가 반환하면 동작이 정의되지 않은 것입니다. 이것이 감지 될 수 있으면 컴파일러 진단이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c12a492195d08d7680b31380fcd02cca76d818" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Noreturn&lt;/code&gt; specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.</source>
          <target state="translated">&lt;code&gt;_Noreturn&lt;/code&gt; 의 지정은 동일한 기능 선언, 행동이 한 번 나타난 경우와 동일 번 이상 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b441eccd09a0d3b90efa2fbf5cf4c48ac62ce5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; label of a &lt;a href=&quot;switch&quot;&gt;switch statement&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; (A)의 라벨 &lt;a href=&quot;switch&quot;&gt;스위치 문&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b82034e3bfd61c7426ddb432f33a7f8ce1c6f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; statement causes a jump, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, to the end of the loop body (it may only appear within the loop body of &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, and &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loops).</source>
          <target state="translated">는 &lt;code&gt;continue&lt;/code&gt; 하여 것처럼 문, 점프의 원인 &lt;a href=&quot;goto&quot;&gt;고토&lt;/a&gt; , 루프 본문의 마지막에 (그것은 단지의 루프 본문 내에서 나타날 수 &lt;a href=&quot;for&quot;&gt;에 대한&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;동안&lt;/a&gt; , 그리고 &lt;a href=&quot;do&quot;&gt;할-동안&lt;/a&gt; 루프).</target>
        </trans-unit>
        <trans-unit id="4450351bba8998fd3f9dc09c3bd22850aee0cfaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cproj&lt;/code&gt; function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.</source>
          <target state="translated">&lt;code&gt;cproj&lt;/code&gt; 의 기능이 하나에 모든 무한대를 매핑하여 리만 구 모델 (주고 또는 가상 제로의 부호을)하는 데 도움이, 다른 무한대의에 대한 가짜 결과를 줄 수있는 동작, 특히 비교, 전에 만 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="5731587eb746d1dad2e49fe74c5697f79eced509" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;double&lt;/code&gt; version of &lt;code&gt;round&lt;/code&gt; behaves as if implemented as follows:</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 의 &lt;code&gt;double&lt;/code&gt; 버전은 다음과 같이 구현 된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="24b177cd6cc2404dd925704b969516edf40ab372" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; is always associated with the closest preceding &lt;code&gt;if&lt;/code&gt; (in other words, if statement_true is also an if statement, then that inner if statement must contain an &lt;code&gt;else&lt;/code&gt; part as well):</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 항상 가장 가까운 이전과 관련된 &lt;code&gt;if&lt;/code&gt; (문이 포함해야하는 경우 즉 statement_true 다음, 또한 내부 if 문입니다 경우 &lt;code&gt;else&lt;/code&gt; 뿐만 아니라 일부) :</target>
        </trans-unit>
        <trans-unit id="80eb840778c4247edccecb50773383d04f6d851f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gets()&lt;/code&gt; function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on &lt;code&gt;stdin&lt;/code&gt;). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. &lt;code&gt;&lt;a href=&quot;fgets&quot;&gt;fgets()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;gets_s()&lt;/code&gt; are the recommended replacements.</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; 함수는, 따라서이 기능이 공격 오버 플로우 버퍼에 매우 취약, 범위 검사를 수행하지 않습니다. &lt;code&gt;stdin&lt;/code&gt; 에 나타날 수있는 것을 제한하는 환경에서 프로그램을 실행하지 않으면 안전하게 사용할 수 없습니다 . 이러한 이유로,이 기능은 C99 표준에 대한 세 번째 규칙에서 더 이상 사용되지 않으며 C11 표준에서 완전히 제거되었습니다. &lt;code&gt;&lt;a href=&quot;fgets&quot;&gt;fgets()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;gets_s()&lt;/code&gt; 가 권장되는 대체입니다.</target>
        </trans-unit>
        <trans-unit id="12de6802a92d23201c2059da142ae2e1863d0973" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt; statement causes an unconditional jump (transfer of control) to the statement prefixed by the named label (which must appear in the same function as the goto statement), except when this jump would enter the scope of a &lt;a href=&quot;array&quot;&gt;variable-length array&lt;/a&gt; or another &lt;a href=&quot;declarations&quot;&gt;variably-modified type&lt;/a&gt;.(since C99).</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; 이 점프는의 범위를 입력 할 때, 문 (고토 문 같은 기능에 나타나야) 지정된 라벨 접두어 문에 무조건 점프 (제어의 전달)을 발생 제외한 &lt;a href=&quot;array&quot;&gt;가변 길이 배열&lt;/a&gt; 또는 다른 &lt;a href=&quot;declarations&quot;&gt;가변적으로 변형 된 유형&lt;/a&gt; (C99 이후).</target>
        </trans-unit>
        <trans-unit id="33f985b573ca6ee1aec3cd2f6f2f5e14e4f8be04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; keyword was adopted from C++, but in C++, if a function is declared inline, it must be declared inline in every translation unit, and also every definition of an inline function must be exactly the same (in C, the definitions may be different, as long as the behavior of the program does not depend on the differences). On the other hand, C++ allows non-const function-local statics and all function-local statics from different definitions of an inline function are the same in C++ but distinct in C.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 키워드는 C ++에서 채택되었다, 그러나 함수가 인라인 선언 된 경우 C에서 + +,이 모든 번역 단위에서 인라인으로 선언해야하고, 또한 인라인 함수의 모든 정의가 동일해야합니다 (C에서 정의 될 수있다 프로그램의 동작이 차이점에 의존하지 않는 한 다름). 반면에 C ++은 비 const 함수 로컬 정적을 허용하며 인라인 함수의 다른 정의에서 나온 모든 함수 로컬 정적은 C ++에서는 동일하지만 C에서는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3f74231bbb34168db7edcaa806299c71b6dbaf84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jmp_buf&lt;/code&gt; type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type &lt;code&gt;jmp_buf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jmp_buf&lt;/code&gt; 유형 호출 환경을 복원하기위한 정보를 저장하기에 적합한 배열 형태이다. 저장된 정보는 프로그램의 올바른 블록에서의 실행 및 해당 블록의 호출을 복원하기에 충분합니다. 부동 소수점 상태 플래그, 열린 파일 또는 기타 데이터의 상태는 &lt;code&gt;jmp_buf&lt;/code&gt; 유형의 오브젝트에 저장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dd606079755e7ec046b2b8c9fc11be616e24a10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localeconv&lt;/code&gt; function obtains a pointer to a static object of type &lt;code&gt;&lt;a href=&quot;lconv&quot;&gt;lconv&lt;/a&gt;&lt;/code&gt;, which represents numeric and monetary formatting rules of the current C locale.</source>
          <target state="translated">&lt;code&gt;localeconv&lt;/code&gt; 에의 함수 타입의 정적 오브젝트 포인터 획득 &lt;code&gt;&lt;a href=&quot;lconv&quot;&gt;lconv&lt;/a&gt;&lt;/code&gt; 현재 C 로케일의 숫자 및 통화 포맷 규칙을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="93c7934dd60a79d64a61f1a71e362826f86656fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="7373830865d083f56e567e0e35241e9449625781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function has several special properties:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 기능은 몇 가지 특별한 속성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cbff63dfe1a1c3feb8eb0a4f936a30dc7d837b81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is called at program startup, after all objects with static storage duration are initialized. It is the designated entry point to a program that is executed in</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 정적 저장 기간이있는 모든 개체가 초기화 된 후 기능은 프로그램 시작시 호출된다. 실행되는 프로그램의 지정된 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="3b46a4ac460c3056896a6a86b5876ca421322fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;puts&lt;/code&gt; function appends the newline character to the output, while &lt;code&gt;&lt;a href=&quot;fputs&quot;&gt;fputs&lt;/a&gt;&lt;/code&gt; function does not.</source>
          <target state="translated">&lt;code&gt;puts&lt;/code&gt; 동안 기능, 출력에 개행 문자를 추가 &lt;code&gt;&lt;a href=&quot;fputs&quot;&gt;fputs&lt;/a&gt;&lt;/code&gt; 의 기능을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="337b4f14f91f70ec7af782682bbdfecfe5ad1f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalbln&lt;/code&gt; function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than 32767, the standard-guaranteed &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt;. In particular, for the 80-bit &lt;code&gt;long double&lt;/code&gt;, the factor is 32828.</source>
          <target state="translated">&lt;code&gt;scalbln&lt;/code&gt; 의 계수는 32,767 이상, 표준 보장 될 수있는 가장 큰 하나에 한정된 최소 양의 부동 소수점 값으로부터 스케일을 필요하기 때문에 기능이 제공된다 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; . 특히, 80 비트 &lt;code&gt;long double&lt;/code&gt; 의 경우 계수는 32828입니다.</target>
        </trans-unit>
        <trans-unit id="6b60c9e939da9755686b6ae70e02cdd28175c2b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setlocale&lt;/code&gt; function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to &lt;code&gt;setlocale&lt;/code&gt;. If &lt;code&gt;locale&lt;/code&gt; is a null pointer, &lt;code&gt;setlocale&lt;/code&gt; queries the current C locale without modifying it.</source>
          <target state="translated">&lt;code&gt;setlocale&lt;/code&gt; 에 기능이 지정된 시스템 언어 또는 새로운 C 로켈하는 부분을 설치한다. 수정 사항은 계속 적용되며 다음에 &lt;code&gt;setlocale&lt;/code&gt; 을 호출 할 때까지 모든 로케일 구분 C 라이브러리 함수의 실행에 영향을줍니다 . 경우 &lt;code&gt;locale&lt;/code&gt; 널 포인터이며, &lt;code&gt;setlocale&lt;/code&gt; 에는 수정하지 않고 현재 C 로케일을 조회합니다.</target>
        </trans-unit>
        <trans-unit id="c145771552ff7f32cdea974ba3f62f25963eacf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtok_s&lt;/code&gt; function differs from the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html&quot;&gt;strtok_r&lt;/a&gt; function by guarding against storing outside of the string being tokenized, and by checking runtime constraints.</source>
          <target state="translated">&lt;code&gt;strtok_s&lt;/code&gt; 는 POSIX의 상이한 기능 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html&quot;&gt;strtok_r&lt;/a&gt; , 토큰 화되는 문자열의 외부 기억 대해 지키고 의해 실행 제한 조건을 선택하여 기능.</target>
        </trans-unit>
        <trans-unit id="de369af2c72028e52c81811c4f3e7e9a5b513874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_arg&lt;/code&gt; macro expands to an expression of type &lt;code&gt;T&lt;/code&gt; that corresponds to the next parameter from the &lt;code&gt;va_list&lt;/code&gt;&lt;code&gt;ap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va_arg&lt;/code&gt; 를 형의 식 매크로 팽창 &lt;code&gt;T&lt;/code&gt; 것을에서 다음 파라미터에 대응 &lt;code&gt;va_list&lt;/code&gt; &lt;code&gt;ap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d83c342cc7c3f40c89a420acc1bb2923f355ef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_copy&lt;/code&gt; macro copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va_copy&lt;/code&gt; 매크로 복사 &lt;code&gt;src&lt;/code&gt; 에 &lt;code&gt;dest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8d7607bf53e5be070f8a32b172032dad9d0e31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_end&lt;/code&gt; macro performs cleanup for an &lt;code&gt;ap&lt;/code&gt; object initialized by a call to &lt;code&gt;va_start&lt;/code&gt; or &lt;code&gt;va_copy&lt;/code&gt;. &lt;code&gt;va_end&lt;/code&gt; may modify &lt;code&gt;ap&lt;/code&gt; so that it is no longer usable.</source>
          <target state="translated">&lt;code&gt;va_end&lt;/code&gt; 의 매크로 행한다 정리 &lt;code&gt;ap&lt;/code&gt; 개체를 호출하여 초기화 &lt;code&gt;va_start&lt;/code&gt; 또는 &lt;code&gt;va_copy&lt;/code&gt; . &lt;code&gt;va_end&lt;/code&gt; 는 더 이상 사용할 수 없도록 &lt;code&gt;ap&lt;/code&gt; 를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bf2761b4814114335aeebc1afaaa2a8836f144f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_start&lt;/code&gt; macro enables access to the variable arguments following the named argument &lt;code&gt;parmN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va_start&lt;/code&gt; 를의 매크로는 명명 된 인수 다음 변수 인수에 액세스 할 수 있습니다 &lt;code&gt;parmN&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c178f303930e7ee937bb808b750bf972f0b2a5fc" translate="yes" xml:space="preserve">
          <source>The C language standard precisely specifies the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;observable behavior&lt;/a&gt; of C language programs, except for the ones in the following categories:</source>
          <target state="translated">C 언어 표준 은 다음 범주의 언어를 제외한 C 언어 프로그램 의 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;관찰 가능한 동작&lt;/a&gt; 을 정확하게 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="27f4aadd45c8227a1e5fe1c8762201aa5167faca" translate="yes" xml:space="preserve">
          <source>The C numerics library includes common mathematical functions and types, as well as support for random number generation.</source>
          <target state="translated">C 숫자 라이브러리에는 일반적인 수학적 함수 및 유형과 난수 생성 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e780c2a081b6a90a3aa1a960aa33b566068175d" translate="yes" xml:space="preserve">
          <source>The C programming language, as of C99, supports Boolean arithmetic with the built-in type &lt;code&gt;_Bool&lt;/code&gt; (see &lt;a href=&quot;../keyword/_bool&quot;&gt;_Bool&lt;/a&gt;). When the header &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; is included, the Boolean type is also accessible as &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">C99 기준으로 C 프로그래밍 언어는 내장 유형 &lt;code&gt;_Bool&lt;/code&gt; ( &lt;a href=&quot;../keyword/_bool&quot;&gt;_Bool&lt;/a&gt; 참조 )을 사용하여 부울 산술을 지원합니다 . &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; 헤더 가 포함되면 부울 형식도 &lt;code&gt;bool&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2cf31e6418ffa7bd54cc5caaf9ef7aef1d4f2fc" translate="yes" xml:space="preserve">
          <source>The C programming language, as of C99, supports complex number math with the three built-in types &lt;code&gt;double _Complex&lt;/code&gt;, &lt;code&gt;float _Complex&lt;/code&gt;, and &lt;code&gt;long double _Complex&lt;/code&gt; (see &lt;a href=&quot;../keyword/_complex&quot;&gt;_Complex&lt;/a&gt;). When the header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; is included, the three complex number types are also accessible as &lt;code&gt;double complex&lt;/code&gt;, &lt;code&gt;float complex&lt;/code&gt;, &lt;code&gt;long double complex&lt;/code&gt;.</source>
          <target state="translated">C99 기준으로 C 프로그래밍 언어는 내장 된 유형 &lt;code&gt;double _Complex&lt;/code&gt; , &lt;code&gt;float _Complex&lt;/code&gt; 및 &lt;code&gt;long double _Complex&lt;/code&gt; ( &lt;a href=&quot;../keyword/_complex&quot;&gt;_Complex&lt;/a&gt; 참조 )를 사용하여 복소수 수학을 지원합니다 . 헤더 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 가 포함 된 경우 3 개의 복소수 유형은 &lt;code&gt;double complex&lt;/code&gt; , &lt;code&gt;float complex&lt;/code&gt; , &lt;code&gt;long double complex&lt;/code&gt; 로도 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9206fd8248380fd0f85f54859dca51cdbeca995" translate="yes" xml:space="preserve">
          <source>The C source file is processed by the compiler</source>
          <target state="translated">C 소스 파일은 컴파일러에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0c05c2fc68c4375f5795f99eafaae38d20bf38bf" translate="yes" xml:space="preserve">
          <source>The C standard and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html&quot;&gt;POSIX&lt;/a&gt; specify that the behavior of &lt;code&gt;sprintf&lt;/code&gt; and its variants is undefined when an argument overlaps with the destination buffer. Example:</source>
          <target state="translated">C 표준 및 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html&quot;&gt;POSIX&lt;/a&gt; 는 인수가 대상 버퍼와 겹칠 때 &lt;code&gt;sprintf&lt;/code&gt; 및 해당 변형 의 동작 이 정의되지 않도록 지정합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="72051079cc7c159c96ecf4a92232342192ed7cf8" translate="yes" xml:space="preserve">
          <source>The C type system consists of the following types:</source>
          <target state="translated">C 유형 시스템은 다음 유형으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a8074f7033d870355bda79f918df527e49c8242e" translate="yes" xml:space="preserve">
          <source>The GNU implementation does not set &lt;code&gt;errno&lt;/code&gt; regardless of &lt;code&gt;math_errhandling&lt;/code&gt;.</source>
          <target state="translated">GNU 구현은 &lt;code&gt;math_errhandling&lt;/code&gt; 에 관계없이 &lt;code&gt;errno&lt;/code&gt; 를 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="234938443728dc9d7125d6292e796aa03d968ac4" translate="yes" xml:space="preserve">
          <source>The IEEE floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where the value &lt;code&gt;n&lt;/code&gt; is the integral value nearest the exact value &lt;code&gt;x/y&lt;/code&gt;. When |n-x/y| = &amp;frac12;, the value &lt;code&gt;n&lt;/code&gt; is chosen to be even.</source>
          <target state="translated">이 함수에 의해 계산 된 나누기 연산 &lt;code&gt;x/y&lt;/code&gt; 의 IEEE 부동 소수점 나머지 는 정확히 &lt;code&gt;x - n*y&lt;/code&gt; 값이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 정확한 값 &lt;code&gt;x/y&lt;/code&gt; 에 가장 가까운 적분 값 입니다. | nx / y | = &amp;frac12;이면, 값 &lt;code&gt;n&lt;/code&gt; 은 짝수로 선택된다.</target>
        </trans-unit>
        <trans-unit id="9b803be3dc347d1eccfd895e8d543b98d468b36e" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent for this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_getspecific.html&quot;&gt;pthread_getspecific&lt;/a&gt;.</source>
          <target state="translated">이 함수에 해당하는 POSIX는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_getspecific.html&quot;&gt;pthread_getspecific&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c91ac40d670ed9e92eedac0ca36c0b3bbedb25f3" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/nanosleep.html&quot;&gt;nanosleep&lt;/a&gt;.</source>
          <target state="translated">이 기능과 동등한 POSIX는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/nanosleep.html&quot;&gt;nanosleep&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75bdcc83ffc873a59df67fe1a0a4c21ca59a202f" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html&quot;&gt;pthread_key_create&lt;/a&gt;.</source>
          <target state="translated">이 함수와 동등한 POSIX는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html&quot;&gt;pthread_key_create&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8057c66e8f1a020e1895762b7801c3addb6dd201" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_delete.html&quot;&gt;pthread_key_delete&lt;/a&gt;.</source>
          <target state="translated">이 함수와 동등한 POSIX는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_delete.html&quot;&gt;pthread_key_delete&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a295799725a341b45bc58d7c8960eaf5ce5fec1" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_once.html&quot;&gt;pthread_once&lt;/a&gt;.</source>
          <target state="translated">이 함수와 동등한 POSIX는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_once.html&quot;&gt;pthread_once&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa65f453f8c26d94c2ad562a800ebd758dd6c8f9" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setspecific.html&quot;&gt;pthread_setspecific&lt;/a&gt;.</source>
          <target state="translated">이 함수와 동등한 POSIX는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setspecific.html&quot;&gt;pthread_setspecific&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01db62988e96524ed4b93590032fdc4c530cd1a4" translate="yes" xml:space="preserve">
          <source>The POSIX equivalent of this function is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html&quot;&gt;sched_yield&lt;/a&gt;.</source>
          <target state="translated">이 함수와 동등한 POSIX는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html&quot;&gt;sched_yield&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc82f43c11aee6b47eca6fd2fdfa83714c8150a7" translate="yes" xml:space="preserve">
          <source>The POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime(CLOCK_REALTIME, ts)&lt;/a&gt; may also be used to populate a &lt;code&gt;timespec&lt;/code&gt; with the time since the Epoch.</source>
          <target state="translated">POSIX의 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;위해 clock_gettime (CLOCK_REALTIME, TS)는&lt;/a&gt; 또한 채우는 데 사용될 수있다 &lt;code&gt;timespec&lt;/code&gt; 이 에포크 이후 시간으로한다.</target>
        </trans-unit>
        <trans-unit id="1488e3e1725ba2ff4aa290f686cae3ecf80e21d5" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;n&lt;/code&gt; (i.e. &lt;code&gt;|n|&lt;/code&gt;), if it is representable.</source>
          <target state="translated">표현 가능한 경우 &lt;code&gt;n&lt;/code&gt; 의 절대 값 (예 : &lt;code&gt;|n|&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b870be9a37a18d5d977d3678831f3407339e51cf" translate="yes" xml:space="preserve">
          <source>The actual sleep time may be longer than requested because it is rounded up to the timer granularity and because of scheduling and context switching overhead.</source>
          <target state="translated">실제 수면 시간은 타이머 세분성으로 반올림되고 스케줄링 및 컨텍스트 전환 오버 헤드로 인해 요청 된 것보다 길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dccc6d6e38ae33ba63d77fc8c1bc45b9948ef1cb" translate="yes" xml:space="preserve">
          <source>The address-of expression has the form.</source>
          <target state="translated">표현의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d32b2d5a5486bdd69de221fdc12f25b0be6957e5" translate="yes" xml:space="preserve">
          <source>The address-of operator produces the &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; address of its operand, suitable for initializing a pointer to the type of the operand. If the operand is a function designator ((1)), the result is a pointer to function. If the operand is an object ((2)), the result is a pointer to object.</source>
          <target state="translated">address-of 연산자는 피연산자의 유형이 &lt;a href=&quot;value_category&quot;&gt;아닌&lt;/a&gt; 주소를 생성하여 피연산자 유형에 대한 포인터를 초기화하는 데 적합합니다. 피연산자가 함수 지정자 ((1))이면 결과는 함수에 대한 포인터입니다. 피연산자가 객체 ((2)) 인 경우 결과는 객체에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="bc98c9b63b9736f29b37a9e7b0e581bccc94736d" translate="yes" xml:space="preserve">
          <source>The alignas specifier can only be used when declaring objects that aren't &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;, and don't have the &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.</source>
          <target state="translated">alignas 지정자는 &lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 가 아닌 &lt;a href=&quot;storage_duration&quot;&gt;레지스터&lt;/a&gt; 스토리지 클래스 가없는 오브젝트를 선언 할 때만 사용할 수 있습니다 . 함수 매개 변수 선언에는 사용할 수 없으며 typedef에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f59dc253d6a5bb752ae635b9ca51e2fcb9241e5f" translate="yes" xml:space="preserve">
          <source>The alignment requirement of a type can be queried with &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;.</source>
          <target state="translated">유형의 정렬 요구 사항은 &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt; 로 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="781837e5b78f423a72b4bc7bbfde9fb961de52a5" translate="yes" xml:space="preserve">
          <source>The apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).</source>
          <target state="translated">푸시 백 된 버퍼의 문자 크기가 외부 문자 시퀀스에서 해당 위치에 존재하는 문자와 동일하면 푸시 백 버퍼의 겉보기 크기가 더 클 수 있습니다 (구현물은 단순히 읽기 파일 위치 표시기를 감소시키고 푸시 백 버퍼를 유지하지 않아도 됨).</target>
        </trans-unit>
        <trans-unit id="ed300236670f94b994460867ddba4af778962013" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;unsigned char&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the argument is first converted to a character string as if by &lt;b&gt;%ls&lt;/b&gt; with a &lt;code&gt;wchar_t[2]&lt;/code&gt; argument.</source>
          <target state="translated">인수는 먼저 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환됩니다 . 경우] &lt;b&gt;L의&lt;/b&gt; 개질제가 사용되는 인수 우선하여 마치 문자 스트링으로 변환된다 &lt;b&gt;%의 LS&lt;/b&gt; 로모그래퍼 &lt;code&gt;wchar_t[2]&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="76ee03c9d30db3c49bc902c4761239a61037963b" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt; as if by calling &lt;code&gt;&lt;a href=&quot;../string/multibyte/btowc&quot;&gt;btowc&lt;/a&gt;&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the &lt;code&gt;wint_t&lt;/code&gt; argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../string/multibyte/btowc&quot;&gt;btowc&lt;/a&gt;&lt;/code&gt; 를 호출 하여 인수가 먼저 &lt;code&gt;wchar_t&lt;/code&gt; 로 변환됩니다 . 경우] &lt;b&gt;L의&lt;/b&gt; 개질제가 사용되는 상기 &lt;code&gt;wint_t&lt;/code&gt; 의 인수로 변환되어 제 &lt;code&gt;wchar_t&lt;/code&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8a753299662a50197ee1d3a69bb98a71d11bbe16" translate="yes" xml:space="preserve">
          <source>The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic flags.</source>
          <target state="translated">이 인수는 비 휘발성 및 &lt;a href=&quot;../language/volatile&quot;&gt;휘발성&lt;/a&gt; (예 : 메모리 매핑 된 I / O) 아토믹 플래그의 주소를 허용하는 휘발성 아토믹 플래그를 가리키는 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="3f455787098090bbe7c33c66341af1a7971f3ca1" translate="yes" xml:space="preserve">
          <source>The argument list must be explicitly present in the declarator, it cannot be inherited from a typedef.</source>
          <target state="translated">인수 목록은 선언자에 명시 적으로 있어야하며 typedef에서 상속 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="022dd1e74282e977a770275328ad528abb79d79a" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; with zero-initialized conversion state.</source>
          <target state="translated">인수는 초기 시프트 상태에서 시작하는 멀티 바이트 문자 시퀀스를 포함하는 문자 배열의 초기 요소에 대한 포인터 여야하며, 초기화 상태가 0 인 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; 를 호출하는 것처럼 와이드 문자 배열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a03b5940fa2b2b9a645f3d15e3a9855662e07fb" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of an array of characters.</source>
          <target state="translated">인수는 문자 배열의 초기 요소에 대한 포인터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7b05a6da792283284c41c232a974b5b2326fa339" translate="yes" xml:space="preserve">
          <source>The arguments of the following arithmetic operators undergo implicit conversions for the purpose of obtaining the</source>
          <target state="translated">다음 산술 연산자의 인수는 다음을 얻기 위해 암시적인 변환을 거칩니다.</target>
        </trans-unit>
        <trans-unit id="45daeed08fd1b34a79c05358cadd45843dd504f7" translate="yes" xml:space="preserve">
          <source>The array subscrpt expression has the form.</source>
          <target state="translated">배열 구독 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="355acf6afa9301915d8cd9dac99ab246ee45808d" translate="yes" xml:space="preserve">
          <source>The atomic type is always lock-free</source>
          <target state="translated">원자 유형은 항상 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="536d76525e91daaed4f4bc6b42df12034fa6894d" translate="yes" xml:space="preserve">
          <source>The atomic type is never lock-free</source>
          <target state="translated">원자 유형은 결코 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="38e69c089e66d80032f7e2daa041a7a95fc0d073" translate="yes" xml:space="preserve">
          <source>The atomic type is sometimes lock-free</source>
          <target state="translated">원자 유형은 때때로 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="336ca1df89222546331425468429bcda23c8fd42" translate="yes" xml:space="preserve">
          <source>The behavior is defined only if both the original pointer and the result pointer are pointing at elements of the same array or one past the end of that array. Note that executing p-1 when p points at the first element of an array is undefined behavior and may fail on some platforms.</source>
          <target state="translated">동작은 원래 포인터와 결과 포인터가 동일한 배열의 요소를 가리 키거나 해당 배열의 끝을 지나는 요소를 가리키는 경우에만 정의됩니다. p가 배열의 첫 번째 요소를 가리킬 때 p-1을 실행하는 것은 정의되지 않은 동작이며 일부 플랫폼에서는 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="864d90a43c91a3621584b295cefd86053c305ae4" translate="yes" xml:space="preserve">
          <source>The behavior is defined only if the result fits in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동작이 결과가 &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt; 에 맞는 경우에만 동작이 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec443138fd336406f248f42bf21ac1d7e076e0f5" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;count&lt;/code&gt; is less than 1.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 가 1보다 작 으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e516f8007cc4db73318a3053ef3fe4d2d126e19" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated byte strings.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;rhs&lt;/code&gt; 가 null로 끝나는 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="464b76a8eef218307890a469421e1b605b19821f" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated strings.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;rhs&lt;/code&gt; 가 널 종료 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b44460391a952d80167639892da39becaef08fba" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; are not pointers to null-terminated wide strings.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;rhs&lt;/code&gt; 가 널로 끝나는 넓은 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="030b1e4cf2a993b1e587ef118c94940c56309bb2" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;signal&lt;/code&gt; is used in a multithreaded program. It is not required to be thread-safe.</source>
          <target state="translated">&lt;code&gt;signal&lt;/code&gt; 가 멀티 스레드 프로그램에서 사용되는 경우 동작이 정의되지 않습니다 . 스레드로부터 안전하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="0ceaef11d2a001b1146f5d2f6c38318a06571ed8" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if &lt;code&gt;str&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 null로 끝나는 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69d4e477144a2395707732bc17a24147fe7e896c" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if a program calls &lt;code&gt;exit&lt;/code&gt; more than once, or if it calls &lt;code&gt;exit&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;quick_exit&quot;&gt;quick_exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로그램이 &lt;code&gt;exit&lt;/code&gt; 를 두 번 이상 호출하거나 &lt;code&gt;exit&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;quick_exit&quot;&gt;quick_exit&lt;/a&gt;&lt;/code&gt; 를 호출 하면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f67b69e471b8334cea03a7df26c2882cba3a66f9" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of either object pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The behavior is undefined if either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; is a null pointer.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 가리키는 객체의 끝을 넘어서 액세스가 발생하면 동작은 정의되지 않습니다 . &lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;rhs&lt;/code&gt; 가 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="70e475a2a1f05af2371821b459cc739d41d58ee8" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the array searched. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; is a null pointer.</source>
          <target state="translated">검색된 배열의 끝을 넘어 액세스가 발생하면 동작이 정의되지 않습니다. &lt;code&gt;ptr&lt;/code&gt; 이 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60450559905e4180b5cef68256d2d590f345857e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the dest array. If the objects overlap (which is a violation of the &lt;a href=&quot;../../language/restrict&quot;&gt;&lt;code&gt;restrict&lt;/code&gt;&lt;/a&gt; contract)(since C99), the behavior is undefined. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer.</source>
          <target state="translated">액세스가 dest 배열 끝을 넘어서 발생하는 경우 동작이 정의되지 않습니다. 객체가 겹치면 ( &lt;a href=&quot;../../language/restrict&quot;&gt; &lt;code&gt;restrict&lt;/code&gt; &lt;/a&gt; 계약 위반 ) (C99 이후) 동작이 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;src&lt;/code&gt; 가 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="85b37b54681ba09fd24715f9d29de73e8a5e8418" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if &lt;code&gt;dest&lt;/code&gt; is a null pointer.</source>
          <target state="translated">dest 배열의 끝을 넘어서 액세스가 발생하면 동작은 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 가 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3a2a0a38cb7447232fbdae70ad38ac84b4d28210" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer.</source>
          <target state="translated">dest 배열의 끝을 넘어서 액세스가 발생하면 동작은 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;src&lt;/code&gt; 가 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="efaa775646413dc1eb435407761f438970dafeea" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if after &lt;code&gt;free()&lt;/code&gt; returns, an access is made through the pointer &lt;code&gt;ptr&lt;/code&gt; (unless another allocation function happened to result in a pointer value equal to &lt;code&gt;ptr&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;free()&lt;/code&gt; 반환 된 후 포인터 &lt;code&gt;ptr&lt;/code&gt; 을 통해 액세스가 이루어 지지 않는 경우 (다른 할당 함수가 &lt;code&gt;ptr&lt;/code&gt; 과 같은 포인터 값을 생성하지 않는 한 ) 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c85852f38e8d11e132a731807df08363f7f17a86" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any member of &lt;code&gt;*time_ptr&lt;/code&gt; is outside its normal range</source>
          <target state="translated">&lt;code&gt;*time_ptr&lt;/code&gt; 의 멤버가 정상 범위를 벗어나 면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af17aa3f7eb917ebddf9d38f3434181934549811" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if both &lt;code&gt;str&lt;/code&gt; points to a character array which lacks the null character and &lt;code&gt;strmax&lt;/code&gt; points to a value which is greater than the size of that character array. As with all bounds-checked functions, &lt;code&gt;strtok_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 널 문자가없는 문자 배열을 &lt;code&gt;strmax&lt;/code&gt; 가 해당 문자 배열의 크기보다 큰 값을 가리키는 경우 동작이 정의되지 않습니다 . 모든 경계 검사 함수와 &lt;code&gt;strtok_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="008e4a5353c52dcd24272f648cad15962d104e69" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if both &lt;code&gt;str&lt;/code&gt; points to a character array which lacks the null character and the size of that character array &amp;lt; &lt;code&gt;strsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;strsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strnlen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 널 문자가없고 문자 배열의 크기가없는 문자 배열을 가리키는 경우 동작은 정의되지 않습니다 &amp;lt; &lt;code&gt;strsz&lt;/code&gt; ; 즉, 잘못된 &lt;code&gt;strsz&lt;/code&gt; 값은 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 검사 함수와 &lt;code&gt;strnlen_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee63aeb51a37188d9cff4ebe130f87a96cfb80c5" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if during a call to a function registered with &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt;, the function exits with &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;atexit&lt;/a&gt;&lt;/code&gt; 에 등록 된 함수를 호출하는 동안 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt; 로 함수가 종료 되면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3103509bcd3b3e891e4c0da3613abac99ee6b6b3" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;breakset&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;breakset&lt;/code&gt; 이 null로 끝나는 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34477ca142dfd7d1700ccb91181e2da44fd64c72" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;src&lt;/code&gt; 가 널 종료 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bc5f824746d76b13715d628ae49c18dcc2acb80" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;delim&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 또는 &lt;code&gt;delim&lt;/code&gt; 이 널 종료 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e15e4f68c0b2a3d550a9b7890a88323ed3a7236a" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if either &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;substr&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 또는 &lt;code&gt;substr&lt;/code&gt; 이 널 종료 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a20a9dd22a45ec31e734ddcf820693b4431349ff" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the &lt;code&gt;dest&lt;/code&gt; array is not large enough. The behavior is undefined if &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; overlap.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 배열이 충분히 크지 않은 경우 동작이 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 와 &lt;code&gt;src&lt;/code&gt; 가 겹치면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5c1e07260891d0ab894f95c0b06ac5577fbbab08" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the &lt;code&gt;dest&lt;/code&gt; array is not large enough. The behavior is undefined if the strings overlap. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; is not a pointer to a character array or &lt;code&gt;src&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 배열이 충분히 크지 않은 경우 동작이 정의되지 않습니다. 문자열이 겹치는 경우 동작이 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 가 문자 배열에 대한 포인터가 아니 거나 &lt;code&gt;src&lt;/code&gt; 가 널 종료 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaab6c269f8944718df63cc4ed6bf2f8b08bc9eb" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the calendar year indicated by &lt;code&gt;time_ptr-&amp;gt;tm_year&lt;/code&gt; has more than 4 digits or is less than the year 1000.</source>
          <target state="translated">&lt;code&gt;time_ptr-&amp;gt;tm_year&lt;/code&gt; 로 표시된 달력 연도 가 4 자리를 초과하거나 1000 년보다 작은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38d041d8280012db2104d0eb03dc0684c091737b" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the character arrays overlap, if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is not a pointer to a character array (including if &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer), if the size of the array pointed to by &lt;code&gt;dest&lt;/code&gt; is less than &lt;code&gt;count&lt;/code&gt;, or if the size of the array pointed to by &lt;code&gt;src&lt;/code&gt; is less than &lt;code&gt;count&lt;/code&gt; and it does not contain a null character.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;src&lt;/code&gt; 가 문자 배열에 대한 포인터가 아닌 경우 ( &lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;src&lt;/code&gt; 가 널 포인터 인 경우 포함) 문자 배열이 겹치는 경우 동작이 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 가 가리키는 배열의 크기 가 &lt;code&gt;count&lt;/code&gt; 보다 작은 경우 , 또는 &lt;code&gt;src&lt;/code&gt; 가 가리키는 배열의 크기 가 &lt;code&gt;count&lt;/code&gt; 보다 작고 널 문자를 포함하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="07d2f718c56694cd9534bf4c29b0ab70be38ce63" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.</source>
          <target state="translated">현재 스레드가 이미 뮤텍스를 잠그고 뮤텍스가 재귀 적이 지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="298da5846442305076841ee50dee7b6ae3356104" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array does not have enough space for the contents of both &lt;code&gt;dest&lt;/code&gt; and the first &lt;code&gt;count&lt;/code&gt; characters of &lt;code&gt;src&lt;/code&gt;, plus the terminating null character. The behavior is undefined if the source and destination objects overlap. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; is not a pointer to a null-terminated byte string or &lt;code&gt;src&lt;/code&gt; is not a pointer to a character array,</source>
          <target state="translated">대상 배열에 &lt;code&gt;dest&lt;/code&gt; 및 &lt;code&gt;src&lt;/code&gt; 의 첫 번째 &lt;code&gt;count&lt;/code&gt; 문자 와 종료 null 문자 의 내용을위한 충분한 공간이없는 경우 동작이 정의되지 않습니다 . 소스 및 대상 객체가 겹치는 경우 동작이 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 가 null로 끝나는 바이트 문자열에 대한 포인터가 아니 거나 &lt;code&gt;src&lt;/code&gt; 가 문자 배열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a28cb485893574495bdf940a49f55dbd8d7217ce" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array is not large enough for the contents of both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; and the terminating null character. The behavior is undefined if the strings overlap. The behavior is undefined if either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is not a pointer to a null-terminated byte string.</source>
          <target state="translated">대상 배열이 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dest&lt;/code&gt; 및 종료 null 문자 의 내용에 비해 충분히 크지 않은 경우 동작이 정의되지 않습니다 . 문자열이 겹치는 경우 동작이 정의되지 않습니다. &lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;src&lt;/code&gt; 가 널 종료 바이트 문자열에 대한 포인터가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75927258cde7082c64c027c4137cbfc360391f60" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the destination array is not large enough for the contents of both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; and the terminating null wide character.</source>
          <target state="translated">대상 배열이 &lt;code&gt;str&lt;/code&gt; 및 &lt;code&gt;dest&lt;/code&gt; 의 내용 과 종료 널 와이드 문자에 대해 충분히 크지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a89165e7d0691f8d76d7152c55b7488221f33af2" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the memory area referred to by &lt;code&gt;ptr&lt;/code&gt; has already been deallocated, that is, &lt;code&gt;free()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; has already been called with &lt;code&gt;ptr&lt;/code&gt; as the argument and no calls to &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; resulted in a pointer equal to &lt;code&gt;ptr&lt;/code&gt; afterwards.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 메모리 영역 이 이미 할당 해제 된 경우 즉, &lt;code&gt;free()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; 이 이미 &lt;code&gt;ptr&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; 후에 &lt;code&gt;ptr&lt;/code&gt; 과 동일한 포인터가 생성 되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3b10348058d0a2ba715c0cfc12ae65b467b766d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/yeby3zcb.aspx&quot;&gt;Windows&lt;/a&gt;).</source>
          <target state="translated">모드가 위에 나열된 문자열 중 하나가 아닌 경우 동작이 정의되지 않습니다. 일부 구현은 추가 지원 모드 (예 : &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/yeby3zcb.aspx&quot;&gt;Windows&lt;/a&gt; )를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="e920f35d17562e2f2c62c1d1cb89e0ef3eeaf9fc" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mutex does not support timeout.</source>
          <target state="translated">뮤텍스가 시간 초과를 지원하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9969863afbf60da7e0947d726f32b67bec85c235" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mutex is not already locked by the calling thread.</source>
          <target state="translated">호출하는 스레드가 뮤텍스를 아직 잠그지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec8050092f4075b9f24a7942c1f67f47f42cdc86" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the mutex is not locked by the calling thread.</source>
          <target state="translated">호출하는 스레드가 뮤텍스를 잠그지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="941cde7772bbee68273ed590270aac59a2bc53fd" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;&lt;a href=&quot;strlen&quot;&gt;strlen&lt;/a&gt;(dest)+&lt;a href=&quot;strlen&quot;&gt;strlen&lt;/a&gt;(src)+1&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strcat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;&lt;a href=&quot;strlen&quot;&gt;strlen&lt;/a&gt;(dest)+&lt;a href=&quot;strlen&quot;&gt;strlen&lt;/a&gt;(src)+1&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 문자 배열의 크기 인 경우 동작이 정의되지 않습니다 . 다시 말해, 잘못된 값인 &lt;code&gt;destsz&lt;/code&gt; 는 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 검사 함수와 &lt;code&gt;strcat_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="263f0f4483b4a7bc7d4194e3da7a06121b2ba20c" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;memcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">문자 배열의 크기가 &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 경우 동작이 정의되지 않습니다 . 다시 말해, 잘못된 값인 &lt;code&gt;destsz&lt;/code&gt; 는 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 검사 함수와 &lt;code&gt;memcpy_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed793d65b7434e6b81723078feaa75210ac493c6" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;memmove_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">문자 배열의 크기가 &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 경우 동작이 정의되지 않습니다 . 다시 말해, 잘못된 값인 &lt;code&gt;destsz&lt;/code&gt; 는 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 검사 함수와 &lt;code&gt;memmove_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3b938301c208a4793d708319d12f33de3dfa6cd" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;memset_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">문자 배열의 크기가 &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;count&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 경우 동작이 정의되지 않습니다 . 다시 말해, 잘못된 값인 &lt;code&gt;destsz&lt;/code&gt; 는 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 검사 함수와 &lt;code&gt;memset_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7a1acae375ffdabbc69e06b63682cf50c84ab57" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen(dest,destsz)+strnlen(src,count)+1&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by &lt;code&gt;src&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen(src,count)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;count&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strncat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">문자 배열의 크기가 &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen(dest,destsz)+strnlen(src,count)+1&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 경우 동작이 정의되지 않습니다 . 다시 말해, 잘못된 값인 &lt;code&gt;destsz&lt;/code&gt; 는 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 문자 배열의 크기가 &lt;code&gt;src&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen(src,count)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt; ; 즉, 잘못된 &lt;code&gt;count&lt;/code&gt; 값은 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 - 검사 기능과 마찬가지로, &lt;code&gt;strncat_s&lt;/code&gt; 는 경우에만 사용할 수 보장 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 는 구현에 의해 정의되며 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 사용자 가 정수 상수 1에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정의한 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="4d359b3ad713a42a7d0327609bd82b3064bd7d82" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen_s(src, destsz)&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by &lt;code&gt;src&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen_s(src, count)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;count&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strncpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen_s(src, destsz)&lt;/code&gt; &amp;lt;= &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 문자 배열의 크기 인 경우 동작이 정의되지 않습니다 . 다시 말해, 잘못된 값인 &lt;code&gt;destsz&lt;/code&gt; 는 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 문자 배열의 크기가 &lt;code&gt;src&lt;/code&gt; &amp;lt; &lt;code&gt;strnlen_s(src, count)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 경우 동작이 정의되지 않습니다 . 즉, 잘못된 &lt;code&gt;count&lt;/code&gt; 값은 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 검사 기능과 &lt;code&gt;strncpy_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 정의한 경우에만 사용 가능하도록 보장됩니다 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 __STDC_WANT_LIB_EXT1__ 을 정수 상수 1로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae42ff9c041c331d2deb113dec62bdb1035816b1" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the size of the character array pointed to by &lt;code&gt;dest&lt;/code&gt; &amp;lt;= &lt;code&gt;strnlen_s(src, destsz)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt;; in other words, an erroneous value of &lt;code&gt;destsz&lt;/code&gt; does not expose the impending buffer overflow. As with all bounds-checked functions, &lt;code&gt;strcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;string.h&lt;/code&gt;.</source>
          <target state="translated">문자 배열의 크기가 &lt;code&gt;dest&lt;/code&gt; &amp;lt;= &lt;code&gt;strnlen_s(src, destsz)&lt;/code&gt; &amp;lt; &lt;code&gt;destsz&lt;/code&gt; 로 가리키는 경우 동작이 정의되지 않습니다 . 다시 말해, 잘못된 값인 &lt;code&gt;destsz&lt;/code&gt; 는 임박한 버퍼 오버 플로우를 노출시키지 않습니다. 모든 경계 검사 함수와 마찬가지로 &lt;code&gt;strcpy_s&lt;/code&gt; 는 &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; 이 구현에 의해 정의되고 사용자가 &lt;code&gt;string.h&lt;/code&gt; 를 포함하기 전에 &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; 을 정수 상수 1 로 정의한 경우에만 사용 가능하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="07d8fb77eabde35598fe8c80befa5c3efd1b6afe" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the strings overlap.</source>
          <target state="translated">문자열이 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6a6656344e41c13f8d13ac7fd15d646c6fa9124" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the thread was previously detached or joined by another thread.</source>
          <target state="translated">스레드가 이전에 다른 스레드에 의해 분리되거나 결합 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ed5428768cfa36ac6293011047aff1244867289" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ch&lt;/code&gt; is not representable as &lt;code&gt;unsigned char&lt;/code&gt; and is not equal to &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 의 값이 &lt;code&gt;unsigned char&lt;/code&gt; 로 표현할 수 없고 &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 와 같지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="70f89fd8214ddc7bd79349aaaba1184a91c6c5dd" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ch&lt;/code&gt; is not representable as &lt;code&gt;unsigned char&lt;/code&gt; or is not equal to &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 값이 &lt;code&gt;unsigned char&lt;/code&gt; 로 표시 되지 않거나 &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 와 같지 않은 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b62957e5d410463c4be1ca4d979ecd30927255d8" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of &lt;code&gt;ptr&lt;/code&gt; does not equal a value returned earlier by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;aligned_alloc()&lt;/code&gt;(since C11).</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 의 값이 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;aligned_alloc()&lt;/code&gt; 의해 이전에 반환 된 값과 같지 않으면 동작이 정의 되지 않습니다 (C11 이후).</target>
        </trans-unit>
        <trans-unit id="adacf118e6e6367d1ffb7672550f2db2bee36eb9" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if the value of the pointer &lt;code&gt;stream&lt;/code&gt; is used after &lt;code&gt;fclose&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;fclose&lt;/code&gt; 가 리턴 된 후 포인터 &lt;code&gt;stream&lt;/code&gt; 의 값 이 사용 되면 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="77f347bb381347a2491ac53b9f03f07354d7781e" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if writing to &lt;code&gt;buf&lt;/code&gt; occurs past the end of the array, which can happen when the size of the buffer pointed to by &lt;code&gt;buf&lt;/code&gt; is less than the number of characters in the error message which in turn is less than &lt;code&gt;bufsz&lt;/code&gt;.</source>
          <target state="translated">에 기록하는 경우의 동작은 정의되지 &lt;code&gt;buf&lt;/code&gt; 버퍼의 크기가 가리키는 경우 일어날 수있는 배열의 끝, 과거 발생 &lt;code&gt;buf&lt;/code&gt; 적은 차례로 미만 오류 메시지의 문자 수보다 &lt;code&gt;bufsz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98fbd235d00d2e7ae40b8381a871adbf84afa4db" translate="yes" xml:space="preserve">
          <source>The behavior is undefined when access occurs past the end of either array &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt;. The behavior is undefined when either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; is the null pointer.</source>
          <target state="translated">배열 &lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;rhs&lt;/code&gt; 의 끝을지나 액세스가 발생한 경우 동작은 정의되지 않습니다 . &lt;code&gt;lhs&lt;/code&gt; 또는 &lt;code&gt;rhs&lt;/code&gt; 가 널 포인터 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6aca785b489f09f6c1637e42931dd57a5d5c8595" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;atomic_compare_exchange_strong&lt;/code&gt; is as if the following was executed atomically:</source>
          <target state="translated">&lt;code&gt;atomic_compare_exchange_strong&lt;/code&gt; 의 동작은 다음이 원자 적으로 실행되는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae9a245d62483a4a65fcb760aef3d8efe0051b97" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;ctime&lt;/code&gt; may be undefined for the values of time_t that result in the string longer than 25 characters (e.g. year 10000).</source>
          <target state="translated">&lt;code&gt;ctime&lt;/code&gt; 의 동작은 25자를 초과하는 문자열 (예 : 10000 년)을 초래하는 time_t 값에 대해 정의되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d3d7bae89495ba6eac9a99c281bbee52c30a78" translate="yes" xml:space="preserve">
          <source>The behavior of a function call to a function without a prototype is undefined if.</source>
          <target state="translated">프로토 타입이없는 함수에 대한 함수 호출의 동작은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cb71e9af2c3c638a873dc06af2ae73a07596ef8" translate="yes" xml:space="preserve">
          <source>The behavior of the function call expression depends on whether the prototype of the function being called is &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; at the point of call.</source>
          <target state="translated">함수 호출 표현식의 동작은 호출되는 함수의 프로토 타입 이 호출 시점의 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 에 있는지 여부에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="c08434d32154e6b925a05a299485361cd8506034" translate="yes" xml:space="preserve">
          <source>The binary additive arithmetic operator expressions have the form.</source>
          <target state="translated">이진 추가 산술 연산자 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7176da4edb44fdfb24d715e7d3669be25b36085b" translate="yes" xml:space="preserve">
          <source>The binary multiplicative arithmetic operator expressions have the form.</source>
          <target state="translated">이항 곱셈 산술 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9db240d6b226db38cdd0681f0d0a825ae1eca5f" translate="yes" xml:space="preserve">
          <source>The binary operator % yields the remainder of the division of the first operand by the second (after usual arithmetic conversions).</source>
          <target state="translated">이항 연산자 %는 첫 번째 피연산자를 두 번째 피연산자로 나눈 나머지를 산출합니다 (일반 산술 변환 후).</target>
        </trans-unit>
        <trans-unit id="382ff6ecf838a6a209cbbe60826d1c97f46b4d1f" translate="yes" xml:space="preserve">
          <source>The binary operator * performs multiplication of its operands (after usual arithmetic conversions) following the usual arithmetic definitions, except that.</source>
          <target state="translated">이항 연산자 *는 일반적인 산술 정의에 따라 피연산자의 곱셈을 수행합니다 (일반 산술 변환 후).</target>
        </trans-unit>
        <trans-unit id="2cc810453dd079897ee4b630ce3e654a70d7cfd5" translate="yes" xml:space="preserve">
          <source>The binary operator / divides the first operand by the second (after usual arithmetic conversions) following the usual arithmetics definitions, except that.</source>
          <target state="translated">이항 연산자 /는 첫 번째 피연산자를 일반적인 산술 정의에 따라 두 번째 (일반 산술 변환 후)로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="c9b53aa8540cf3072f1caa4828d4f3227016694d" translate="yes" xml:space="preserve">
          <source>The bitwise arithmetic operator expressions have the form.</source>
          <target state="translated">비트 산술 연산자 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b023ae87ef451cdf626ad0291435d5b825d5fd03" translate="yes" xml:space="preserve">
          <source>The bitwise shift operator expressions have the form.</source>
          <target state="translated">비트 시프트 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f53b6f7139db25eee0ab1b3b913b97aac5e329d" translate="yes" xml:space="preserve">
          <source>The body of a function is provided in a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;. Each function must be defined only once in a program, unless the function is &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;.</source>
          <target state="translated">함수의 본문은 &lt;a href=&quot;function_definition&quot;&gt;함수 정의에&lt;/a&gt; 제공됩니다 . 각 함수는 함수가 &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; 이 아닌 한 프로그램에서 한 번만 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b95d90f3b77a1b8a8d232cc7c475465a557b79bc" translate="yes" xml:space="preserve">
          <source>The body of a switch statement may have an arbitrary number of &lt;code&gt;case:&lt;/code&gt; labels, as long as the values of all constant_expressions are unique (after &lt;a href=&quot;conversion&quot;&gt;conversion&lt;/a&gt; to the &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;promoted type&lt;/a&gt; of expression). At most one &lt;code&gt;default:&lt;/code&gt; label may be present (although nested switch statements may use their own &lt;code&gt;default:&lt;/code&gt; labels or have &lt;code&gt;case:&lt;/code&gt; labels whose constants are identical to the ones used in the enclosing switch).</source>
          <target state="translated">switch 문의 몸은 임의의 수있을 수 있습니다 &lt;code&gt;case:&lt;/code&gt; 라벨을 한 모든 constant_expressions의 값이 (후 고유로 &lt;a href=&quot;conversion&quot;&gt;변환&lt;/a&gt; 받는 &lt;a href=&quot;conversion#Integer_promotions&quot;&gt;승진 유형&lt;/a&gt; 표현). 최대 하나의 &lt;code&gt;default:&lt;/code&gt; 레이블이 존재할 수 있습니다 (중첩 된 스위치 명령문은 고유 한 &lt;code&gt;default:&lt;/code&gt; 레이블을 사용하거나 대 / &lt;code&gt;case:&lt;/code&gt; 를 포함 할 수 있음). 상수는 둘러싸는 스위치에 사용 된 레이블과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ea016ec910e6873dfc79ae24437a3c519704144a" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; for floating-point numbers may set &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자에 대한 내장 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 는 인수 중 하나 또는 둘 다가 NaN 인 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 를 설정할 수 있습니다 . 이 기능은 &quot;자동&quot;버전의 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4bd808c844289be1c901eea1e57131ddc87294a7" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자에 대한 내장 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 는 인수 중 하나 또는 둘 다가 NaN 인 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다 . 이 함수는 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 의 &quot;자동&quot;버전입니다 .</target>
        </trans-unit>
        <trans-unit id="475e90afca51fa257232622941ddac8c0e483026" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of the expression &lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt;. The macro does not evaluate x and y twice.</source>
          <target state="translated">부동 소수점 숫자에 대한 내장 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 는 인수 중 하나 또는 둘 다가 NaN 인 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다 . 이 함수는 표현식 &lt;code&gt;x &amp;lt; y || x &amp;gt; y&lt;/code&gt; 의 &quot;quiet&quot;버전입니다. x&amp;gt; y . 매크로는 x와 y를 두 번 평가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac907543c60c06a9a51c071f27b11749c7308d57" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자에 대한 내장 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 는 인수 중 하나 또는 둘 다가 NaN 인 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다 . 이 함수는 &quot; &lt;code&gt;operator&amp;lt;&lt;/code&gt; quiet&quot;버전의 operator &amp;lt; 입니다.</target>
        </trans-unit>
        <trans-unit id="55246b361f4bd424491e57d0679d399ec77fce75" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; for floating-point numbers may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if one or both of the arguments is NaN. This function is a &quot;quiet&quot; version of &lt;code&gt;operator&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자에 대한 내장 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 는 인수 중 하나 또는 둘 다가 NaN 인 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다 . 이 함수는 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 의 &quot;quiet&quot;버전입니다 .</target>
        </trans-unit>
        <trans-unit id="aa4ee1790c20fb3a8e3bfbcd260344fefc700848" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;nan(&quot;&quot;)&lt;/code&gt; is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN()&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;nan(&quot;&quot;)&lt;/code&gt; 호출하는 것과 같습니다 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN()&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="750d6f52d6633c563f387f35bc618f9f38ab304c" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;nan(&quot;n-char-sequence&quot;)&lt;/code&gt;, where &lt;code&gt;n-char-sequence&lt;/code&gt; is a sequence of digits, Latin letters, and underscores, is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN(n-char-sequence)&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;nan(&quot;n-char-sequence&quot;)&lt;/code&gt; , &lt;code&gt;n-char-sequence&lt;/code&gt; 숫자, 라틴 문자 및 밑줄 시퀀스는이 호에 상당 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN(n-char-sequence)&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd0944bb87ba05c9b4df8e88949d3edad0b9ff6" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;nan(&quot;string&quot;)&lt;/code&gt;, where &lt;code&gt;string&lt;/code&gt; is neither an n-char-sequence nor an empty string, is equivalent to the call &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;nan(&quot;string&quot;)&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; 둘의 n 문자 시퀀스도 빈 문자열 없다가, 호출에 해당 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;(&quot;NAN&quot;, (char**)&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598cc8bc5da5b0fb6d667fdb74683a23070d43fe" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;getenv_s&lt;/code&gt; with a null pointer for &lt;code&gt;value&lt;/code&gt; and zero for &lt;code&gt;valuesz&lt;/code&gt; is used to determine the size of the buffer required to hold the entire result.</source>
          <target state="translated">호출 &lt;code&gt;getenv_s&lt;/code&gt; 위한 널 포인터 &lt;code&gt;value&lt;/code&gt; 과 제로 &lt;code&gt;valuesz&lt;/code&gt; 는 버퍼의 크기를 결정하기 위해 사용 된 전체 결과를 유지하도록 요구된다.</target>
        </trans-unit>
        <trans-unit id="8e0a943ad67969e22cbc79ab2e94f2ba315815da" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="translated">인수가 무한 인 경우 C에서는 도메인 오류로 지정되지 않지만 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html&quot;&gt;POSIX&lt;/a&gt; 에서는 도메인 오류 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="270c05d2c8f07be7812f6368dba8b69f41c5dd8c" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="translated">인수가 무한 인 경우 C에서는 도메인 오류로 지정되지 않지만 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html&quot;&gt;POSIX&lt;/a&gt; 에서는 도메인 오류 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="c893ac9cadbf00f7e9ef1a77d5a304aa079fc5b5" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="translated">인수가 무한 인 경우 C에서는 도메인 오류로 지정되지 않지만 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;POSIX&lt;/a&gt; 에서는 도메인 오류 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b194103418cca6cbbfda4929c3c1041036b43cf0" translate="yes" xml:space="preserve">
          <source>The cast to void is sometimes useful to silence compiler warnings about unused results.</source>
          <target state="translated">무효로 캐스트는 사용되지 않은 결과에 대한 컴파일러 경고를 끄는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cb15aa2e205da76a53c99fdb5dd46d7ca6c8252c" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.</source>
          <target state="translated">문자 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;!&lt;/code&gt; ISO-646에 따라 변하지 않지만 이러한 문자를 사용하는 운영자를 위해 대안이 제공되어 훨씬 더 제한적인 역사적 문자 세트를 수용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4035fa4f0afd21a7666c6150be01fe027d08712b" translate="yes" xml:space="preserve">
          <source>The characters of the C-strings pointed to by &lt;code&gt;grouping&lt;/code&gt; and &lt;code&gt;mon_grouping&lt;/code&gt; are interpreted according to their numeric values. When the terminating &lt;code&gt;'\0'&lt;/code&gt; is encountered, the last value seen is assumed to repeat for the remainder of digits. If &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; is encountered, no further digits are grouped. the typical grouping of three digits at a time is &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;grouping&lt;/code&gt; 및 &lt;code&gt;mon_grouping&lt;/code&gt; 으로 가리키는 C- 문자열의 문자는 숫자 값에 따라 해석됩니다. 종료 &lt;code&gt;'\0'&lt;/code&gt; 이 발생하면 마지막으로 본 값이 나머지 숫자에 대해 반복되는 것으로 가정합니다. 경우 &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; 가 발생, 더 이상의 숫자가 그룹화되지 않습니다. 한 번에 3 자리 숫자의 일반적인 그룹은 &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="389756ed6e9c288a5d7721af8a052706a08051ec" translate="yes" xml:space="preserve">
          <source>The choices made by each implementation about the sizes of the fundamental types are collectively known as</source>
          <target state="translated">기본 유형의 크기에 대해 각 구현에서 선택한 사항을 통칭하여</target>
        </trans-unit>
        <trans-unit id="639291a4f3c29237da353a25b118487f41eb6c93" translate="yes" xml:space="preserve">
          <source>The comma operator expression has the form.</source>
          <target state="translated">쉼표 연산자 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d4d04275fd3986990614e795bf7dee50a7571a4" translate="yes" xml:space="preserve">
          <source>The comma operator may be lvalue in C++, but never in C.</source>
          <target state="translated">쉼표 연산자는 C ++에서는 lvalue 일 수 있지만 C에서는 절대로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d6fc3f2fb9c171bbd01b3b6dc85f4ee9561d08bf" translate="yes" xml:space="preserve">
          <source>The comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator).</source>
          <target state="translated">쉼표 연산자는 구조체를 반환 할 수 있습니다 (구조체를 반환하는 다른 식은 복합 리터럴, 함수 호출, 대입 및 조건 연산자).</target>
        </trans-unit>
        <trans-unit id="b7dee580f11aef5ebe6c5e769d0ef339e265bedd" translate="yes" xml:space="preserve">
          <source>The compiler is free to ignore any or all aliasing implications of uses of &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;restrict&lt;/code&gt; 사용에 대한 앨리어싱 관련 의미를 무시해도 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5b3b0d4b525dd97c5a4869a198616c5154957d5" translate="yes" xml:space="preserve">
          <source>The compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.</source>
          <target state="translated">컴파일러는 C 구문 규칙 또는 시맨틱 제약 조건을 위반하는 프로그램에 대해 동작이 정의되지 않았거나 구현 정의로 지정되었거나 컴파일러에서 언어 확장을 제공하는 경우에도 진단 메시지 (오류 또는 경고)를 발행해야합니다. 그러한 프로그램을 수락합니다. 달리 정의되지 않은 동작에 대한 진단은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="055be4235172d10af24ff6290ec130255293bd45" translate="yes" xml:space="preserve">
          <source>The completion of this function</source>
          <target state="translated">이 기능의 완성</target>
        </trans-unit>
        <trans-unit id="a6dbfec61e3424ffae4ae18efa158e9aeaf2271e" translate="yes" xml:space="preserve">
          <source>The complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; in the interval [0; &amp;infin;) along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="translated">간격 [0;에서 &lt;code&gt;z&lt;/code&gt; 의 복소 아크 쌍곡 코사인 &amp;infin;) 실제 축을 따라 간격 [&amp;minus;i&amp;pi;; 가상 축을 따라 + i&amp;pi;].</target>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 켤레 복소수입니다 .</target>
        </trans-unit>
        <trans-unit id="82c5651398368fa9194c75ad0cd42b27eaccd0a5" translate="yes" xml:space="preserve">
          <source>The complex exponential function ez</source>
          <target state="translated">복잡한 지수 함수 ez</target>
        </trans-unit>
        <trans-unit id="f4a8bb4e0bd6e80ede57c9b2a0ef2ec124631eca" translate="yes" xml:space="preserve">
          <source>The compound assignment operator expressions have the form.</source>
          <target state="translated">복합 할당 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7df263ae0e0ab175c4cedd3b99f705f4c1dd852a" translate="yes" xml:space="preserve">
          <source>The compound literal expression constructs an unnamed object of the type specified by type and initializes it as specified by initializer-list.</source>
          <target state="translated">복합 리터럴 표현식은 type으로 지정된 유형의 이름없는 오브젝트를 구성하고 initializer-list로 지정된대로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="4fbd0a48bc1fb7914fb073b18a7045d1a7fe29e4" translate="yes" xml:space="preserve">
          <source>The compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or an iteration statement):</source>
          <target state="translated">복합 명령문을 사용하면 단일 명령문이 예상되는 모든 위치 (예 : &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; 문 또는 반복문) 에서 사용할 수있는 선언 및 명령문 세트를 하나의 단위로 그룹화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8abc060166b36e799feb998e7f4939e28b8ecdbf" translate="yes" xml:space="preserve">
          <source>The conditional operator expression has the form.</source>
          <target state="translated">조건부 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35c8621167c53476a1a98fe938c3c174cc4134ee" translate="yes" xml:space="preserve">
          <source>The conditional operator is never an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;, although it may return objects of struct/union type. The only other expressions that may return stucts are &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt;, &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma&lt;/a&gt;, &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, and &lt;a href=&quot;compound_literal&quot;&gt;compound literal&lt;/a&gt;.</source>
          <target state="translated">조건부 연산자는 struct / union 유형의 객체를 반환 할 수 있지만 &lt;a href=&quot;value_category&quot;&gt;lvalue 식은&lt;/a&gt; 아닙니다 . stucts를 리턴 할 수있는 다른 표현식은 &lt;a href=&quot;operator_assignment&quot;&gt;할당&lt;/a&gt; , &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표&lt;/a&gt; , &lt;a href=&quot;operator_other#Function_call&quot;&gt;함수 호출&lt;/a&gt; 및 &lt;a href=&quot;compound_literal&quot;&gt;복합 리터럴&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fadd419c227bb685e0a0582aff80f1b5ba7a551d" translate="yes" xml:space="preserve">
          <source>The conditional preprocessing block starts with &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; directive, then optionally includes any number of &lt;code&gt;#elif&lt;/code&gt; directives, then optionally includes at most one &lt;code&gt;#else&lt;/code&gt; directive and is terminated with the &lt;code&gt;#endif&lt;/code&gt; directive. Any inner conditional preprocessing blocks are processed separately.</source>
          <target state="translated">조건부 전처리 블록은 &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; 또는 &lt;code&gt;#ifndef&lt;/code&gt; 지시문으로 시작한 다음 선택적으로 여러 개의 &lt;code&gt;#elif&lt;/code&gt; 지시문을 포함하고 선택적으로 최대 하나의 &lt;code&gt;#else&lt;/code&gt; 지시문을 포함하며 &lt;code&gt;#endif&lt;/code&gt; 지시문으로 종료됩니다 . 내부 조건부 전처리 블록은 개별적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff37d62089a6b5f6e494aef62b9015866607221" translate="yes" xml:space="preserve">
          <source>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message (if provided) as part of the error message (except that characters not in &lt;a href=&quot;translation_phases&quot;&gt;basic source character set&lt;/a&gt; aren't required to be displayed).</source>
          <target state="translated">상수 표현식은 컴파일 타임에 평가되어 0과 비교됩니다. 0과 비교하면 컴파일 타임 오류가 발생하고 컴파일러는 오류 메시지의 일부로 메시지 (제공된 경우)를 표시해야합니다 ( &lt;a href=&quot;translation_phases&quot;&gt;기본 소스 문자 세트&lt;/a&gt; 에없는 문자 는 표시하지 않아도 됨).</target>
        </trans-unit>
        <trans-unit id="7733c072d8eb0d24e0b88f6986f86f0fb8a35998" translate="yes" xml:space="preserve">
          <source>The controlling-expression and the expressions of the selections that are not chosen are never evaluated.</source>
          <target state="translated">선택되지 않은 선택의 제어식 및 표현은 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0eba86b24f08a5313c7cce0d40bb40425a6f3985" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;l[&lt;/code&gt; perform multibyte-to-wide character conversion as if by calling &lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;&lt;code&gt;mbrtowc()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">변환 지정자 &lt;code&gt;lc&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; 및 &lt;code&gt;l[&lt;/code&gt; 은 첫 번째 문자가 변환되기 전에 &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt; 객체가 0으로 초기화 된 &lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt; &lt;code&gt;mbrtowc()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것처럼 멀티 바이트에서 문자 전체로의 문자 변환을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="10d720fad8838ce447569443ee37666195d1db03" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;[&lt;/code&gt; always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%[&lt;/code&gt;, without specifying the destination array size, is as unsafe as &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;gets&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">변환 지정자 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;[&lt;/code&gt; 는 항상 일치하는 문자 외에 널 종료자를 저장합니다. 대상 배열의 크기는 지정된 필드 너비보다 하나 이상 커야합니다. 사용 &lt;code&gt;%s&lt;/code&gt; 또는 &lt;code&gt;%[&lt;/code&gt; 대상 배열 크기를 지정하지 않고,뿐만 불안전 &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;gets&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac471b8f3e3680d0aea88efb3834381526f7e2d3" translate="yes" xml:space="preserve">
          <source>The conversions &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; output &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;INFINITY&lt;/code&gt;, &lt;code&gt;NAN&lt;/code&gt; instead.</source>
          <target state="translated">변환 &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 출력 &lt;code&gt;INF&lt;/code&gt; , &lt;code&gt;INFINITY&lt;/code&gt; , &lt;code&gt;NAN&lt;/code&gt; 대신에.</target>
        </trans-unit>
        <trans-unit id="6d126e7074c1cecdf337f1c334c8340ee765b367" translate="yes" xml:space="preserve">
          <source>The conversions not listed here are not allowed. In particular,</source>
          <target state="translated">여기에 나열되지 않은 변환은 허용되지 않습니다. 특히,</target>
        </trans-unit>
        <trans-unit id="fc8e08acb16e81fb66cf54c1031e76e0b8784b0f" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the &lt;a href=&quot;../types/integer&quot;&gt;fixed-width integer types&lt;/a&gt; (&lt;code&gt;int8_t&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNdMAX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNuMAX&lt;/code&gt;&lt;/a&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">&lt;a href=&quot;../types/integer&quot;&gt;고정 폭 정수 유형&lt;/a&gt; ( &lt;code&gt;int8_t&lt;/code&gt; 등)에 대한 올바른 변환 스펙은 &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; 헤더에 정의되어 있습니다 ( &lt;a href=&quot;../types/integer&quot;&gt; &lt;code&gt;SCNdMAX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../types/integer&quot;&gt; &lt;code&gt;SCNuMAX&lt;/code&gt; &lt;/a&gt; 등은 &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; 등과 동의어 임).</target>
        </trans-unit>
        <trans-unit id="0a0aa617af0af8a4ff0e8b9f43a4c9fad55a2792" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the fixed-width character types (&lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;int8_t&lt;/a&gt;&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">고정 너비 문자 유형 ( &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;int8_t&lt;/a&gt;&lt;/code&gt; 등)에 대한 올바른 변환 스펙은 &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; 헤더에 정의되어 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt; 등은 &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; 등과 동의어 임).</target>
        </trans-unit>
        <trans-unit id="7f9b4026c72463dbf7e53d38e204b4285cee0558" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+strxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="translated">변환 된 전체 문자열을 수신 할 수있는 버퍼의 올바른 길이는 &lt;code&gt;1+strxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a72dc1f2a9cfd3fbe819a915b266b2d90a2d9e5" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="translated">변환 된 전체 문자열을 수신 할 수있는 버퍼의 올바른 길이는 &lt;code&gt;1+wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5a730e98fa4ae44b9e24fcf843d261fd0bdf207" translate="yes" xml:space="preserve">
          <source>The correct result can be represented as &lt;code&gt;int&lt;/code&gt; on all known implementations. For overflow to occur, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; must be less than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; must be greater than &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">모든 알려진 구현에서 올바른 결과를 &lt;code&gt;int&lt;/code&gt; 로 표시 할 수 있습니다 . 발생하는 오버 플로우, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 는 이하이어야 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; 가 보다 커야 &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="942cf9ae9a6d3badc39db24111513090bfb3dd85" translate="yes" xml:space="preserve">
          <source>The cosine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the cosine is cos z =</source>
          <target state="translated">코사인은 복잡한 평면에서 전체 기능이며 분기 컷이 없습니다. 코사인의 수학적 정의는 cos z =</target>
        </trans-unit>
        <trans-unit id="333d83e6dc8a3ed3cddeaf85bad80a985040ae63" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="translated">현재 &lt;a href=&quot;../fenv/fe_round&quot;&gt;반올림 모드&lt;/a&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df76dc533f4832695e4faabdf4a21cf982bfbb46" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/fenv/FE_round.html&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="translated">현재 &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/fenv/FE_round.html&quot;&gt;반올림 모드&lt;/a&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcd990c0fc482fb45b1d3492d0748ec8b63e5c22" translate="yes" xml:space="preserve">
          <source>The current rounding mode affects the following:</source>
          <target state="translated">현재 반올림 모드는 다음에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="430695fef50ce6b9934160789eacb1237ee74fd7" translate="yes" xml:space="preserve">
          <source>The current rounding mode does NOT affect the following:</source>
          <target state="translated">현재 반올림 모드는 다음에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f32fa1d98982e1738b953b2dd2b57c9e693298" translate="yes" xml:space="preserve">
          <source>The current rounding mode, reflecting the effects of the most recent &lt;code&gt;fesetround&lt;/code&gt;, can also be queried with &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가장 최근 &lt;code&gt;fesetround&lt;/code&gt; 의 효과를 반영하는 현재 반올림 모드 도 &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; 로 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="45ddc6fce10286bba6c1f8beb847e588ed427ba1" translate="yes" xml:space="preserve">
          <source>The current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 변수의 현재 값 .</target>
        </trans-unit>
        <trans-unit id="cd998795c1cd4032dd66b9872287706842aa61a2" translate="yes" xml:space="preserve">
          <source>The data storage (memory) available to a C program is one or more contiguous sequences of</source>
          <target state="translated">C 프로그램에 사용 가능한 데이터 스토리지 (메모리)는 다음 중 하나 이상의 연속 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="c8994a846037bbc39e1e65a3a929f7e6a5d07984" translate="yes" xml:space="preserve">
          <source>The decimal point specified by &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; has no effect on the syntax of floating constants: the decimal point character is always the period.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; 로 지정된 소수점 은 부동 상수 구문에 영향을 미치지 않습니다. 소수점 문자는 항상 마침표입니다.</target>
        </trans-unit>
        <trans-unit id="b79072e7b56ba6659da6f87106f63e08064df5b7" translate="yes" xml:space="preserve">
          <source>The declaration of a variadic function uses an ellipsis as the last parameter, e.g. &lt;code&gt;int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;language/variadic&quot;&gt;variadic arguments&lt;/a&gt; for additional detail on the syntax and automatic argument conversions.</source>
          <target state="translated">variadic 함수 선언은 생략을 마지막 매개 변수로 사용합니다 &lt;code&gt;int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;(const char* format, ...);&lt;/code&gt; 예 : int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt; (const char * 형식, ...); . 구문과 자동 인수 변환에 대한 추가 세부 사항 은 &lt;a href=&quot;language/variadic&quot;&gt;가변 인수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51b207b37e6bcac2f107504e9d723a780830b61a" translate="yes" xml:space="preserve">
          <source>The default behavior of all atomic operations in the &lt;a href=&quot;../language/atomic&quot;&gt;language&lt;/a&gt; and the library provides for</source>
          <target state="translated">&lt;a href=&quot;../language/atomic&quot;&gt;언어&lt;/a&gt; 및 라이브러리 에서 모든 원자 연산의 기본 동작 은 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4587bcdbb1b6bc9e3b5e438494b4e72f8dd1c68a" translate="yes" xml:space="preserve">
          <source>The default buffer size &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat&lt;/a&gt; often provides a better estimate.</source>
          <target state="translated">기본 버퍼 크기 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; 는 구현시 파일 I / O에 가장 효율적인 버퍼 크기 일 것으로 예상되지만 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat는&lt;/a&gt; 종종 더 나은 추정치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="627832562bf8dd374b20ff048dfc37aaca313b99" translate="yes" xml:space="preserve">
          <source>The definition of the macro &lt;code&gt;assert&lt;/code&gt; depends on another macro, &lt;code&gt;NDEBUG&lt;/code&gt;, which is not defined by the standard library.</source>
          <target state="translated">매크로 &lt;code&gt;assert&lt;/code&gt; 정의는 표준 라이브러리에 의해 정의되지 않은 다른 매크로 &lt;code&gt;NDEBUG&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="aeb40399c9bd04128464837d331638d1fc355f39" translate="yes" xml:space="preserve">
          <source>The description is formed by concatenating the following components:</source>
          <target state="translated">설명은 다음 구성 요소를 연결하여 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="db81ed6a406de31b6ca65d95bdd037c70cc38728" translate="yes" xml:space="preserve">
          <source>The destructor, if available, is not invoked.</source>
          <target state="translated">사용 가능한 경우 소멸자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb97a7284cd296528abb21877065aef28175aa34" translate="yes" xml:space="preserve">
          <source>The destructor, if one was registered by &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;, is not called (they are only called at thread exit, either by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of &lt;code&gt;tss_id&lt;/code&gt; performed all necessary cleanup, before the call to &lt;code&gt;tss_delete&lt;/code&gt; is made.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; 에 의해 등록 된 소멸자 는 호출되지 않습니다 ( &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; 또는 스레드 함수에서 리턴하여 스레드 종료시 에만 호출 됨 ),이를 인식하는 모든 스레드를 확인하는 것은 프로그래머의 책임입니다. &lt;code&gt;tss_id&lt;/code&gt; 를 호출하기 전에 &lt;code&gt;tss_delete&lt;/code&gt; 가 필요한 정리를 모두 수행했습니다 .</target>
        </trans-unit>
        <trans-unit id="b2599aff3e1997c8bce0ea2079154bc10d116fd7" translate="yes" xml:space="preserve">
          <source>The double version of fmod behaves as if implemented as follows:</source>
          <target state="translated">fmod의 이중 버전은 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d33813bc0fb85e40f1c26903767c91afaf907f09" translate="yes" xml:space="preserve">
          <source>The effect of calling &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; on a bit field</source>
          <target state="translated">비트 필드에서 &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; 를 호출하는 효과</target>
        </trans-unit>
        <trans-unit id="529673770ff976d50ee9f358bf474740d57d7b6c" translate="yes" xml:space="preserve">
          <source>The element type of the composite type is the composite type of the two element types.</source>
          <target state="translated">복합 유형의 요소 유형은 두 요소 유형의 복합 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c50a1fc3f7b297bdcca890f9bac6d5dd553d12f8" translate="yes" xml:space="preserve">
          <source>The encoding of calendar time in &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is unspecified, but most systems conform to &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX specification&lt;/a&gt; and return a value of integral type holding the number of seconds since &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;the Epoch&lt;/a&gt;. Implementations in which &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is a 32-bit signed integer (many historical implementations) fail in the year &lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 의 달력 시간 인코딩 은 지정되지 않았지만 대부분의 시스템은 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX 사양을&lt;/a&gt; 준수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;하며 Epoch&lt;/a&gt; 이후 초 수를 보유한 정수 유형의 값을 리턴합니다 . 구현에 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; 는 32 비트 정수 (많은 과거 구현) 해 실패 인 &lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2,038&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="824493ebacf0d3370672a682b01bf74e21675169" translate="yes" xml:space="preserve">
          <source>The encoding of character string literals (1) and wide string literals (5) is implementation-defined. For example, gcc selects them with the &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;commandline options&lt;/a&gt;&lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt;.</source>
          <target state="translated">문자열 리터럴 (1) 및 넓은 문자열 리터럴 (5)의 인코딩은 구현 정의되어 있습니다. 예를 들어, gcc는 &lt;code&gt;-fexec-charset&lt;/code&gt; 및 &lt;code&gt;-fwide-exec-charset&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;명령 행 옵션을&lt;/a&gt; 사용하여 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="1b539c63cb55edb7e1383ca8e128aa52c2118d3c" translate="yes" xml:space="preserve">
          <source>The end of every declarator that is not part of another declarator is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;.</source>
          <target state="translated">다른 선언자에 속하지 않는 모든 선언자의 끝은 &lt;a href=&quot;eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b400103ba5ae8e95fc269d363832185de644a92" translate="yes" xml:space="preserve">
          <source>The entire program may have zero or one external definition of every identifier (other than an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function)(since C99) with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;.</source>
          <target state="translated">전체 프로그램은 &lt;a href=&quot;storage_duration&quot;&gt;외부 연결을&lt;/a&gt; 가진 ( &lt;a href=&quot;inline&quot;&gt;인라인&lt;/a&gt; 함수 이외의) 모든 식별자의 외부 정의가 없거나 하나 일 수 있습니다 (C99 이후) .</target>
        </trans-unit>
        <trans-unit id="f7a14859a09bf56dbf34fa38ebabd0a0cfc01622" translate="yes" xml:space="preserve">
          <source>The equality operator expressions have the form.</source>
          <target state="translated">항등 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61830cacc4ca90b758c92dfcb68fdc8c2624ac72" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place after each execution of statement (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the &lt;a href=&quot;while&quot;&gt;while loop&lt;/a&gt; or the &lt;a href=&quot;for&quot;&gt;for loop&lt;/a&gt; may be used.</source>
          <target state="translated">표현 평가는 명령문이 실행될 때마다 수행됩니다 (정상적으로 입력 했든 goto에 의해 입력 되었든). 제어식을 루프 본문보다 먼저 평가해야하는 경우 &lt;a href=&quot;while&quot;&gt;while 루프&lt;/a&gt; 또는 &lt;a href=&quot;for&quot;&gt;for 루프를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac201da533f6480e174bf7db981da799dd3201b" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place before each execution of statement (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the &lt;a href=&quot;do&quot;&gt;do-while loop&lt;/a&gt; may be used.</source>
          <target state="translated">표현 평가는 각 명령문 실행 전에 수행됩니다 (goto에 의해 입력되지 않은 경우). 루프 바디 이후에 제어식을 평가해야하는 경우, &lt;a href=&quot;do&quot;&gt;do-while 루프&lt;/a&gt; 가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e4a670e9ee4d8164f867b068f256b475e0334b4" translate="yes" xml:space="preserve">
          <source>The evaluations of expression that designates the function to be called and all arguments are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt; with respect to each other (but there is a sequence point before the body of the function begins executing).</source>
          <target state="translated">호출 할 함수를 지정하는 표현 평가와 모든 인수는 서로에 대해 순서 가 지정 &lt;a href=&quot;eval_order&quot;&gt;되지 않습니다&lt;/a&gt; (그러나 함수 본문이 실행되기 전에 시퀀스 포인트가 있습니다).</target>
        </trans-unit>
        <trans-unit id="88a06ff6d6b5a3ba4276cee42336251cadd1cd73" translate="yes" xml:space="preserve">
          <source>The exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (&lt;code&gt;SCHED_FIFO&lt;/code&gt; in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, &lt;code&gt;yield&lt;/code&gt; has no effect).</source>
          <target state="translated">이 기능의 정확한 동작은 구현, 특히 사용중인 OS 스케줄러의 메커니즘 및 시스템 상태에 따라 다릅니다. 예를 들어, &lt;code&gt;SCHED_FIFO&lt;/code&gt; 선출 실시간 스케줄러 ( Linux의 SCHED_FIFO )는 현재 스레드를 일시 중단하고 실행할 준비가 된 동일한 우선 순위 스레드의 큐 뒷면에 배치합니다 (다른 스레드가없는 경우). 우선 순위가 같은 스레드는 &lt;code&gt;yield&lt;/code&gt; 에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3afa03179e588e1c757bb671479e9343d010308a" translate="yes" xml:space="preserve">
          <source>The exponent contains at least two digits, more digits are used only if necessary. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">지수에는 두 자리 이상의 숫자가 포함되며 필요한 경우에만 더 많은 숫자가 사용됩니다. 값이면 &lt;code&gt;​0​&lt;/code&gt; , 지수는 또한 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bbac353ed3f45f6cc4a964a51c439a96d66dd22" translate="yes" xml:space="preserve">
          <source>The exponent has the form.</source>
          <target state="translated">지수는 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04028f66e9c71c2bd75f830dc82f30f80377d676" translate="yes" xml:space="preserve">
          <source>The exponential function is an</source>
          <target state="translated">지수 함수는</target>
        </trans-unit>
        <trans-unit id="3e9f12f2ca6ab5279914c37234b56437596c602d" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt; (unless parenthesized) because the comma at the top level would be interpreted as the beginning of the next declarator.</source>
          <target state="translated">최상위 수준의 쉼표가 다음 선언자의 시작으로 해석되므로 표현식은 &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;쉼표 연산자&lt;/a&gt; (괄호 안에 있지 않은 경우) 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="25d8b1cc309b61a3a19bc6577131254cb18609f3" translate="yes" xml:space="preserve">
          <source>The expression following &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if or #elif&lt;/a&gt; must expand to.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if 또는 #elif&lt;/a&gt; 뒤에 오는 표현식 은 확장되어야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
