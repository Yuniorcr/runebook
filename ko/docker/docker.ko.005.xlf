<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="docker">
    <body>
      <group id="docker">
        <trans-unit id="7307505bba158128bb25cf3412765f5616f95a44" translate="yes" xml:space="preserve">
          <source>Install and run Docker Machine, and create an account with the cloud provider.</source>
          <target state="translated">Docker Machine을 설치 및 실행하고 클라우드 제공자와 계정을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3e3c4906d982de07025d954b6313c60a4e6bff22" translate="yes" xml:space="preserve">
          <source>Install and run Docker on Mac or Windows</source>
          <target state="translated">Mac 또는 Windows에서 Docker 설치 및 실행</target>
        </trans-unit>
        <trans-unit id="920d15a7b64315557be1656da1c03b0a21459fb2" translate="yes" xml:space="preserve">
          <source>Install as a container</source>
          <target state="translated">컨테이너로 설치</target>
        </trans-unit>
        <trans-unit id="e01195622131cc7b66ed627bb3e348f21aec92cd" translate="yes" xml:space="preserve">
          <source>Install bash completion scripts</source>
          <target state="translated">bash 완성 스크립트 설치</target>
        </trans-unit>
        <trans-unit id="985269bff7deea1c16c709b6e5a38a78131fba4f" translate="yes" xml:space="preserve">
          <source>Install command completion</source>
          <target state="translated">설치 명령 완료</target>
        </trans-unit>
        <trans-unit id="c62b3a5d25daa86f70d1e10b2cdecb7055e521c5" translate="yes" xml:space="preserve">
          <source>Install gcc so Python packages such as MarkupSafe and SQLAlchemy can compile speedups.</source>
          <target state="translated">MarkupSafe 및 SQLAlchemy와 같은 Python 패키지가 속도 향상을 컴파일 할 수 있도록 gcc를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="0d5edcf1519af8ebf157467482f6f70ac7e8f753" translate="yes" xml:space="preserve">
          <source>Install multiple machines on your cloud provider</source>
          <target state="translated">클라우드 제공자에 여러 머신 설치</target>
        </trans-unit>
        <trans-unit id="2ee689495a59c4dbcd174640a4ad79329564c761" translate="yes" xml:space="preserve">
          <source>Install plugins on swarm nodes</source>
          <target state="translated">웜 노드에 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="a0aa0319e27238320c2d2cd9c0155769488706c0" translate="yes" xml:space="preserve">
          <source>Install pre-release builds</source>
          <target state="translated">시험판 빌드 설치</target>
        </trans-unit>
        <trans-unit id="253f580ae57224cf3afc9aacf2fddc9d48a9c3a3" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;ca-certificates&lt;/code&gt; package for your distribution</source>
          <target state="translated">배포 용 &lt;code&gt;ca-certificates&lt;/code&gt; 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="fac24b27dd18bd73f2e0717fb8f9f788fcaf3b60" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;sshfs&lt;/code&gt; plugin.</source>
          <target state="translated">&lt;code&gt;sshfs&lt;/code&gt; 플러그인을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0e677ca9e0decdfa6bb05eae401ed20d23f760f" translate="yes" xml:space="preserve">
          <source>Install using pip</source>
          <target state="translated">pip를 사용하여 설치</target>
        </trans-unit>
        <trans-unit id="4122d343b08318eb1eb379802aeba53f2cef2053" translate="yes" xml:space="preserve">
          <source>Install via Homebrew</source>
          <target state="translated">Homebrew를 통해 설치</target>
        </trans-unit>
        <trans-unit id="57497709172a790f247f334266c83b73fd1f8ad9" translate="yes" xml:space="preserve">
          <source>Install via MacPorts</source>
          <target state="translated">MacPorts를 통해 설치</target>
        </trans-unit>
        <trans-unit id="3f1f3f20c560a55d4c43ecd242029ad0fd932e58" translate="yes" xml:space="preserve">
          <source>Install with &lt;code&gt;brew install bash-completion&lt;/code&gt;.</source>
          <target state="translated">함께 설치 &lt;code&gt;brew install bash-completion&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20f45969ccd3c7ccdd2eda25c277e7e6b0b4a82e" translate="yes" xml:space="preserve">
          <source>Installation guides</source>
          <target state="translated">설치 안내서</target>
        </trans-unit>
        <trans-unit id="ccabf4bf4e0de325e1ee8faa76fd7ef3ed9182e3" translate="yes" xml:space="preserve">
          <source>Installing Compose</source>
          <target state="translated">편지 쓰기 설치</target>
        </trans-unit>
        <trans-unit id="7c207b93b2af1157f5c75bb99e15b47da86e9f24" translate="yes" xml:space="preserve">
          <source>Installing a plugin</source>
          <target state="translated">플러그인 설치</target>
        </trans-unit>
        <trans-unit id="4bc88762dcd338eccd994cf11d81ff8f35a99665" translate="yes" xml:space="preserve">
          <source>Installing and using a plugin</source>
          <target state="translated">플러그인 설치 및 사용</target>
        </trans-unit>
        <trans-unit id="56c5d8012ec8972f75469f2c995ebfd14bb7349f" translate="yes" xml:space="preserve">
          <source>Installs and enables a plugin. Docker looks first for the plugin on your Docker host. If the plugin does not exist locally, then the plugin is pulled from the registry. Note that the minimum required registry version to distribute plugins is 2.3.0</source>
          <target state="translated">플러그인을 설치하고 활성화합니다. Docker는 먼저 Docker 호스트에서 플러그인을 찾습니다. 플러그인이 로컬로 존재하지 않으면 플러그인이 레지스트리에서 가져옵니다. 플러그인을 배포하는 데 필요한 최소 레지스트리 버전은 2.3.0입니다.</target>
        </trans-unit>
        <trans-unit id="11c5c046555a081f52c01b4c53a5149c2251194d" translate="yes" xml:space="preserve">
          <source>Instead of (or as well as) specifying your own networks, you can also change the settings of the app-wide default network by defining an entry under &lt;code&gt;networks&lt;/code&gt; named &lt;code&gt;default&lt;/code&gt;:</source>
          <target state="translated">고유 한 네트워크를 지정하는 것 대신 (또는) &lt;code&gt;networks&lt;/code&gt; 이름 아래에 &lt;code&gt;default&lt;/code&gt; 라는 항목을 정의하여 앱 전체 기본 네트워크의 설정을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="327f6afaad88c8a7eb781cae2c94ececdb88f375" translate="yes" xml:space="preserve">
          <source>Instead of attempting to create a network called &lt;code&gt;[projectname]_default&lt;/code&gt;, Compose looks for a network called &lt;code&gt;my-pre-existing-network&lt;/code&gt; and connect your app&amp;rsquo;s containers to it.</source>
          <target state="translated">Compose는 &lt;code&gt;[projectname]_default&lt;/code&gt; 라는 네트워크를 만들지 않고 &lt;code&gt;my-pre-existing-network&lt;/code&gt; 라는 네트워크를 찾아 앱의 컨테이너를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="ceb73bae5c3ea227ccc859e3e9b8cd2909f5b14e" translate="yes" xml:space="preserve">
          <source>Instead of just using the default app network, you can specify your own networks with the top-level &lt;code&gt;networks&lt;/code&gt; key. This lets you create more complex topologies and specify &lt;a href=&quot;../../engine/extend/plugins_network/index&quot;&gt;custom network drivers&lt;/a&gt; and options. You can also use it to connect services to externally-created networks which aren&amp;rsquo;t managed by Compose.</source>
          <target state="translated">기본 앱 네트워크를 사용하는 대신 최상위 &lt;code&gt;networks&lt;/code&gt; 키를 사용하여 고유 한 네트워크를 지정할 수 있습니다 . 이를 통해보다 복잡한 토폴로지를 만들고 &lt;a href=&quot;../../engine/extend/plugins_network/index&quot;&gt;사용자 지정 네트워크 드라이버&lt;/a&gt; 및 옵션을 지정할 수 있습니다. 또한 Compose에서 관리하지 않는 외부에서 만든 네트워크에 서비스를 연결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1586a5faab679aeb3f3c65bb6aa080fc9a80c9cf" translate="yes" xml:space="preserve">
          <source>Instead of specifying a context, you can pass a single &lt;code&gt;Dockerfile&lt;/code&gt; in the &lt;code&gt;URL&lt;/code&gt; or pipe the file in via &lt;code&gt;STDIN&lt;/code&gt;. To pipe a &lt;code&gt;Dockerfile&lt;/code&gt; from &lt;code&gt;STDIN&lt;/code&gt;:</source>
          <target state="translated">컨텍스트를 지정하는 대신 &lt;code&gt;URL&lt;/code&gt; 에서 단일 &lt;code&gt;Dockerfile&lt;/code&gt; 을 전달 하거나 &lt;code&gt;STDIN&lt;/code&gt; 을 통해 파일을 파이프 할 수 있습니다 . 파이프에 &lt;code&gt;Dockerfile&lt;/code&gt; 에서 &lt;code&gt;STDIN&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7feb792a2137961928c5a8020b743e18ac9e2684" translate="yes" xml:space="preserve">
          <source>Instruct &lt;code&gt;web&lt;/code&gt;&amp;rsquo;s containers to share port 80 via a load-balanced network called &lt;code&gt;webnet&lt;/code&gt;. (Internally, the containers themselves publish to &lt;code&gt;web&lt;/code&gt;&amp;rsquo;s port 80 at an ephemeral port.)</source>
          <target state="translated">&lt;code&gt;web&lt;/code&gt; 의 컨테이너가 &lt;code&gt;webnet&lt;/code&gt; 이라는로드 밸런싱 된 네트워크를 통해 포트 80을 공유하도록 지시 하십시오 . 내부적으로 컨테이너 자체 는 임시 포트에서 &lt;code&gt;web&lt;/code&gt; 포트 80에 게시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cb25351508738c1e72f51dac2adbd26d32df9de" translate="yes" xml:space="preserve">
          <source>Instruct the plugin that the user wants to create a volume, given a user specified volume name. The plugin does not need to actually manifest the volume on the filesystem yet (until &lt;code&gt;Mount&lt;/code&gt; is called). &lt;code&gt;Opts&lt;/code&gt; is a map of driver specific options passed through from the user request.</source>
          <target state="translated">사용자가 지정한 볼륨 이름이 지정된 경우 사용자가 볼륨을 작성하도록 플러그인을 지시하십시오. 플러그인은 실제로 파일 시스템에 볼륨을 표시 할 필요가 없습니다 ( &lt;code&gt;Mount&lt;/code&gt; 가 호출 될 때까지 ). &lt;code&gt;Opts&lt;/code&gt; 는 사용자 요청에서 전달 된 드라이버 특정 옵션의 맵입니다.</target>
        </trans-unit>
        <trans-unit id="4b320627e7e83d71928edb47345e9fddde3f407e" translate="yes" xml:space="preserve">
          <source>Instructs Docker to use the configuration files in your &lt;code&gt;~/testconfigs/&lt;/code&gt; directory when running the &lt;code&gt;ps&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;ps&lt;/code&gt; 명령을 실행할 때 &lt;code&gt;~/testconfigs/&lt;/code&gt; 디렉토리 의 구성 파일을 사용하도록 Docker에 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="57d9dbd5dcbd0c603ce1bf0de8a0af03387cb66c" translate="yes" xml:space="preserve">
          <source>Integrates DigitalOcean&amp;rsquo;s &lt;a href=&quot;https://www.digitalocean.com/products/storage/&quot;&gt;block storage solution&lt;/a&gt; into the Docker ecosystem by automatically attaching a given block storage volume to a DigitalOcean droplet and making the contents of the volume available to Docker containers running on that droplet.</source>
          <target state="translated">주어진 블록 스토리지 볼륨을 DigitalOcean 드롭 릿에 자동으로 연결하고 볼륨의 컨텐츠를 해당 드롭 릿에서 실행되는 Docker 컨테이너에 사용 가능하게하여 DigitalOcean의 &lt;a href=&quot;https://www.digitalocean.com/products/storage/&quot;&gt;블록 스토리지 솔루션&lt;/a&gt; 을 Docker 에코 시스템에 통합합니다.</target>
        </trans-unit>
        <trans-unit id="598b135fbc60de7f56b7050b3c8e1607dfe4369e" translate="yes" xml:space="preserve">
          <source>Interacting with V1 registries</source>
          <target state="translated">V1 레지스트리와 상호 작용</target>
        </trans-unit>
        <trans-unit id="df2378ff796ccc4391d1d98901c08d99e0d94683" translate="yes" xml:space="preserve">
          <source>Interchangeable: You can deploy updates and upgrades on-the-fly.</source>
          <target state="translated">교환 가능 : 업데이트 및 업그레이드를 즉시 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9737649cf66da4e8b5ad0fa79bbb6beb6a05dfc6" translate="yes" xml:space="preserve">
          <source>Intermediate example: Use secrets with a Nginx service</source>
          <target state="translated">중간 예 : Nginx 서비스와 함께 비밀 사용</target>
        </trans-unit>
        <trans-unit id="8ad89b207241a5025e1f29ae7cbbfeeb628b29cc" translate="yes" xml:space="preserve">
          <source>Introduces the following additional parameters:</source>
          <target state="translated">다음과 같은 추가 매개 변수를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3bba5a776b3e7cb238cc21fc35dd6e60be4e6f46" translate="yes" xml:space="preserve">
          <source>Invalid due to appearing twice:</source>
          <target state="translated">두 번 나타나기 때문에 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="8d51fa63074df9f9a50d255a710d0abe98f627b1" translate="yes" xml:space="preserve">
          <source>Invalid due to line continuation:</source>
          <target state="translated">줄 연속으로 인해 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4f1063380b6a3533c8904a8a26985d395de0ed8" translate="yes" xml:space="preserve">
          <source>Is the machine active?</source>
          <target state="translated">기계가 작동합니까?</target>
        </trans-unit>
        <trans-unit id="ff4478fa2b6d4a5cd64aa4e2e8abfa4aa48dc732" translate="yes" xml:space="preserve">
          <source>Is the machine an active non-swarm host?</source>
          <target state="translated">머신이 스웜이 아닌 활성 호스트입니까?</target>
        </trans-unit>
        <trans-unit id="669beb05b49a94f1397d2428a19ed16598646db0" translate="yes" xml:space="preserve">
          <source>Is the machine an active swarm master?</source>
          <target state="translated">머신이 활성 스웜 마스터입니까?</target>
        </trans-unit>
        <trans-unit id="0ea8925b358e4794e62a9fa1de38ac84a43186ca" translate="yes" xml:space="preserve">
          <source>Isolate containers with a user namespace</source>
          <target state="translated">사용자 네임 스페이스를 사용하여 컨테이너 격리</target>
        </trans-unit>
        <trans-unit id="58fcfddf38b8e0d321a7e6e4460da1f3284cbefe" translate="yes" xml:space="preserve">
          <source>It appears alongside &lt;code&gt;build&lt;/code&gt;, not as a sub-option:</source>
          <target state="translated">하위 옵션이 아닌 &lt;code&gt;build&lt;/code&gt; 와 함께 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="9c9a4e988b803a6e718342920f90863200804e58" translate="yes" xml:space="preserve">
          <source>It can also be used in conjunction with the &lt;code&gt;external&lt;/code&gt; property:</source>
          <target state="translated">&lt;code&gt;external&lt;/code&gt; 속성 과 함께 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cfd9b8200a6b654fa715e2dec5735322d030d40" translate="yes" xml:space="preserve">
          <source>It can be useful to commit a container&amp;rsquo;s file changes or settings into a new image. This allows you to debug a container by running an interactive shell, or to export a working dataset to another server. Generally, it is better to use Dockerfiles to manage your images in a documented and maintainable way. &lt;a href=&quot;../tag/index&quot;&gt;Read more about valid image names and tags&lt;/a&gt;.</source>
          <target state="translated">컨테이너의 파일 변경 또는 설정을 새 이미지로 커밋하는 것이 유용 할 수 있습니다. 이를 통해 대화식 쉘을 실행하여 컨테이너를 디버그하거나 작업중인 데이터 세트를 다른 서버로 내보낼 수 있습니다. 일반적으로 Dockerfile을 사용하여 문서화되고 유지 관리 가능한 방식으로 이미지를 관리하는 것이 좋습니다. &lt;a href=&quot;../tag/index&quot;&gt;유효한 이미지 이름 및 태그에 대해 자세히 알아보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="538361963c7660e2eb64a4bb384340a77753ac2e" translate="yes" xml:space="preserve">
          <source>It is also possible to partially override values in extension fields using the &lt;a href=&quot;http://yaml.org/type/merge.html&quot;&gt;YAML merge type&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;http://yaml.org/type/merge.html&quot;&gt;YAML 병합 유형을&lt;/a&gt; 사용하여 확장 필드의 값을 부분적으로 대체 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df078ace6a20c1cd682763b4e3588d1eeeaf6bf9" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a network interface to advertise that interface&amp;rsquo;s address; for example &lt;code&gt;--advertise-addr eth0:2377&lt;/code&gt;.</source>
          <target state="translated">해당 인터페이스의 주소를 알리기 위해 네트워크 인터페이스를 지정할 수도 있습니다. 예를 들어 &lt;code&gt;--advertise-addr eth0:2377&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7a5887bd057baa0e9a3a278333ae9d6e4a833c7" translate="yes" xml:space="preserve">
          <source>It is forbidden to redirect the standard input of a &lt;code&gt;docker attach&lt;/code&gt; command while attaching to a tty-enabled container (i.e.: launched with &lt;code&gt;-t&lt;/code&gt;).</source>
          <target state="translated">tty 가능 컨테이너에 연결하는 동안 &lt;code&gt;docker attach&lt;/code&gt; 명령 의 표준 입력을 리디렉션하는 것은 금지 되어 있습니다 (예 : &lt;code&gt;-t&lt;/code&gt; 로 시작 ).</target>
        </trans-unit>
        <trans-unit id="954570f5d18b55e059d5c1d62b27d940e84ce289" translate="yes" xml:space="preserve">
          <source>It is important to note the distinction between &lt;code&gt;HOST_PORT&lt;/code&gt; and &lt;code&gt;CONTAINER_PORT&lt;/code&gt;. In the above example, for &lt;code&gt;db&lt;/code&gt;, the &lt;code&gt;HOST_PORT&lt;/code&gt; is &lt;code&gt;8001&lt;/code&gt; and the container port is &lt;code&gt;5432&lt;/code&gt; (postgres default). Networked service-to-service communication use the &lt;code&gt;CONTAINER_PORT&lt;/code&gt;. When &lt;code&gt;HOST_PORT&lt;/code&gt; is defined, the service is accessible outside the swarm as well.</source>
          <target state="translated">&lt;code&gt;HOST_PORT&lt;/code&gt; 와 &lt;code&gt;CONTAINER_PORT&lt;/code&gt; 의 차이점에 유의해야합니다 . 위의 예에서 &lt;code&gt;db&lt;/code&gt; 의 경우 &lt;code&gt;HOST_PORT&lt;/code&gt; 는 &lt;code&gt;8001&lt;/code&gt; 이고 컨테이너 포트는 &lt;code&gt;5432&lt;/code&gt; 입니다 ( 포스트그레스 기본값). 네트워크 서비스 간 통신은 &lt;code&gt;CONTAINER_PORT&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;HOST_PORT&lt;/code&gt; 를 정의 하면 웜 외부에서도 서비스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69541379c8dfeadb47fa3ff3e6d08feab423f643" translate="yes" xml:space="preserve">
          <source>It is not possible to copy certain system files such as resources under &lt;code&gt;/proc&lt;/code&gt;, &lt;code&gt;/sys&lt;/code&gt;, &lt;code&gt;/dev&lt;/code&gt;, &lt;a href=&quot;../run/index#mount-tmpfs-tmpfs&quot;&gt;tmpfs&lt;/a&gt;, and mounts created by the user in the container. However, you can still copy such files by manually running &lt;code&gt;tar&lt;/code&gt; in &lt;code&gt;docker exec&lt;/code&gt;. Both of the following examples do the same thing in different ways (consider &lt;code&gt;SRC_PATH&lt;/code&gt; and &lt;code&gt;DEST_PATH&lt;/code&gt; are directories):</source>
          <target state="translated">&lt;code&gt;/proc&lt;/code&gt; , &lt;code&gt;/sys&lt;/code&gt; , &lt;code&gt;/dev&lt;/code&gt; , &lt;a href=&quot;../run/index#mount-tmpfs-tmpfs&quot;&gt;tmpfs&lt;/a&gt; 아래의 자원 및 컨테이너에서 사용자가 작성한 마운트 와 같은 특정 시스템 파일을 복사 할 수 없습니다 . 그러나 &lt;code&gt;docker exec&lt;/code&gt; 에서 &lt;code&gt;tar&lt;/code&gt; 를 수동으로 실행하여 이러한 파일을 계속 복사 할 수 있습니다 . 다음 예제는 서로 다른 방식으로 동일한 작업을 수행합니다 ( &lt;code&gt;SRC_PATH&lt;/code&gt; 및 &lt;code&gt;DEST_PATH&lt;/code&gt; 는 디렉토리 임).</target>
        </trans-unit>
        <trans-unit id="1c11ee0a47ab61bcddee811a4a3c1551f471a651" translate="yes" xml:space="preserve">
          <source>It is often necessary to directly expose devices to a container. The &lt;code&gt;--device&lt;/code&gt; option enables that. For example, a specific block storage device or loop device or audio device can be added to an otherwise unprivileged container (without the &lt;code&gt;--privileged&lt;/code&gt; flag) and have the application directly access it.</source>
          <target state="translated">장치를 컨테이너에 직접 노출해야하는 경우가 종종 있습니다. &lt;code&gt;--device&lt;/code&gt; 옵션이 있습니다. 예를 들어, 특정 블록 저장 장치 또는 루프 장치 또는 오디오 장치를 &lt;code&gt;--privileged&lt;/code&gt; 플래그 없이 권한이없는 컨테이너에 추가 하여 응용 프로그램이 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="137436fa9d11e7cf2b1523743fc24bfa701a5257" translate="yes" xml:space="preserve">
          <source>It is possible to add multiple placement preferences to a service. This establishes a hierarchy of preferences, so that tasks are first divided over one category, and then further divided over additional categories. One example of where this may be useful is dividing tasks fairly between datacenters, and then splitting the tasks within each datacenter over a choice of racks. To add multiple placement preferences, specify the &lt;code&gt;--placement-pref&lt;/code&gt; flag multiple times. The order is significant, and the placement preferences will be applied in the order given when making scheduling decisions.</source>
          <target state="translated">서비스에 여러 게재 위치 환경 설정을 추가 할 수 있습니다. 이를 통해 기본 설정 계층이 설정되므로 작업이 먼저 하나의 범주로 나뉘어 진 다음 추가 범주로 더 나뉩니다. 이것이 유용 할 수있는 한 가지 예는 데이터 센터간에 작업을 공정하게 분할 한 다음 선택한 랙을 통해 각 데이터 센터 내에서 작업을 분할하는 것입니다. 여러 배치 환경 설정을 추가하려면 &lt;code&gt;--placement-pref&lt;/code&gt; 플래그를 여러 번 지정하십시오 . 순서는 중요하며 배치 결정은 순서 결정시 지정된 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1a4a31399fcf6a0ef976d8b6afd92f99ddc9162" translate="yes" xml:space="preserve">
          <source>It is possible to assign multiple subordinate ranges for a given user or group by adding multiple non-overlapping mappings for the same user or group in the &lt;code&gt;/etc/subuid&lt;/code&gt; or &lt;code&gt;/etc/subgid&lt;/code&gt; file. In this case, Docker uses only the first five mappings, in accordance with the kernel&amp;rsquo;s limitation of only five entries in &lt;code&gt;/proc/self/uid_map&lt;/code&gt; and &lt;code&gt;/proc/self/gid_map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/etc/subuid&lt;/code&gt; 또는 &lt;code&gt;/etc/subgid&lt;/code&gt; 파일 에서 동일한 사용자 또는 그룹에 대해 여러 개의 겹치지 않는 매핑을 추가하여 지정된 사용자 또는 그룹에 대해 여러 하위 범위를 할당 할 수 있습니다. 이 경우 Docker는 &lt;code&gt;/proc/self/uid_map&lt;/code&gt; 및 &lt;code&gt;/proc/self/gid_map&lt;/code&gt; 의 5 개 항목에 대한 커널 제한에 따라 처음 5 개의 매핑 만 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="551fd76d387af32f9f893489e03e5a685cceffd5" translate="yes" xml:space="preserve">
          <source>It is possible to re-use configuration fragments using extension fields. Those special fields can be of any format as long as they are located at the root of your Compose file and their name start with the &lt;code&gt;x-&lt;/code&gt; character sequence.</source>
          <target state="translated">확장 필드를 사용하여 구성 조각을 재사용 할 수 있습니다. 이러한 특수 필드는 작성 파일의 루트에 있고 이름이 &lt;code&gt;x-&lt;/code&gt; 문자 시퀀스로 시작하는 한 모든 형식이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68cf732760ff3e36537f7e909dd972b7e0e5d277" translate="yes" xml:space="preserve">
          <source>It is up to the user to choose an appropriate password, and to protect their key from offline brute-force attacks.</source>
          <target state="translated">적절한 암호를 선택하고 오프라인 무차별 대입 공격으로부터 키를 보호하는 것은 사용자의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="d9ecf1faee05f906fccea0d1bdc78e242cd8859e" translate="yes" xml:space="preserve">
          <source>It is verbose and tedious to always provide the &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt; flags manually to most commands. A simple way to create preconfigured versions of the Notary command is via aliases. Add the following to your &lt;code&gt;.bashrc&lt;/code&gt; or equivalent:</source>
          <target state="translated">대부분의 명령 에 항상 &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-d&lt;/code&gt; 플래그를 수동으로 제공하는 것은 장황하고 지루 합니다. Notary 명령의 사전 구성된 버전을 작성하는 간단한 방법은 별명을 사용하는 것입니다. &lt;code&gt;.bashrc&lt;/code&gt; 또는 이와 동등한 항목에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab2ab2b0d4be20a1a682036b18e20547e2eb4abd" translate="yes" xml:space="preserve">
          <source>It is very common for Docker Content Trust to be built into existing automation systems. To allow tools to wrap Docker and push trusted content, there are environment variables that can be passed through to the client.</source>
          <target state="translated">Docker Content Trust가 기존 자동화 시스템에 내장되는 것이 일반적입니다. 도구가 Docker를 래핑하고 신뢰할 수있는 컨텐츠를 푸시 할 수 있도록 클라이언트에 전달할 수있는 환경 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="46f03a17d1d739be3eeef92fe2ab04d21f892ae4" translate="yes" xml:space="preserve">
          <source>It is very important that the ranges not overlap, so that a process cannot gain access in a different namespace. On most Linux distributions, system utilities manage the ranges for you when you add or remove users.</source>
          <target state="translated">프로세스가 다른 네임 스페이스에서 액세스 할 수 없도록 범위가 겹치지 않는 것이 매우 중요합니다. 대부분의 Linux 배포에서 시스템 유틸리티는 사용자를 추가하거나 제거 할 때 범위를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="908d259667bbd0fdef59c321815dc169bc5aeba3" translate="yes" xml:space="preserve">
          <source>It is very important that you back up your keys to a safe, secure location. Loss of the repository key is recoverable; loss of the root key is not.</source>
          <target state="translated">키를 안전하고 안전한 위치에 백업하는 것이 매우 중요합니다. 리포지토리 키 손실은 복구 가능합니다. 루트 키가 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0996e39baf4be9342e25f764757669c04464f5e1" translate="yes" xml:space="preserve">
          <source>It needs access to the &lt;code&gt;host&lt;/code&gt; network.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 네트워크에 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d7eedd4e614c25f9ddc8acc6796003a23d9005f" translate="yes" xml:space="preserve">
          <source>It needs the &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; capability, which allows the plugin to run the &lt;code&gt;mount&lt;/code&gt; command.</source>
          <target state="translated">플러그인이 &lt;code&gt;mount&lt;/code&gt; 명령 을 실행할 수 있도록 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 기능 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="9ff9966fd7633997c32dddad2c3dc6ffa015b7de" translate="yes" xml:space="preserve">
          <source>It takes &lt;strong&gt;retries&lt;/strong&gt; consecutive failures of the health check for the container to be considered &lt;code&gt;unhealthy&lt;/code&gt;.</source>
          <target state="translated">그것은 소요 &lt;strong&gt;시도를&lt;/strong&gt; 고려해야 할 컨테이너의 건강 검진의 연속 실패 &lt;code&gt;unhealthy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb6be6f28fa6b870443eae3570839a4488846c4d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s as easy as that to stand up and scale your app with Docker. You&amp;rsquo;ve taken a huge step towards learning how to run containers in production. Up next, you learn how to run this app as a bonafide swarm on a cluster of Docker machines.</source>
          <target state="translated">Docker로 앱을 세우고 확장하는 것은 쉬운 일입니다. 프로덕션 환경에서 컨테이너를 실행하는 방법을 배우기 위해 큰 걸음을 내딛었습니다. 다음으로 Docker 머신 클러스터에서이 앱을 Bonafide 떼로 실행하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="b76533502d26aed93795ce54b6b76f49c1fc7928" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to add services to our &lt;code&gt;docker-compose.yml&lt;/code&gt; file. First, let&amp;rsquo;s add a free visualizer service that lets us look at how our swarm is scheduling containers.</source>
          <target state="translated">&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일에 서비스를 쉽게 추가 할 수 있습니다 . 먼저, 우리의 떼가 컨테이너를 어떻게 예약하는지 살펴볼 수있는 무료 비주얼 라이저 서비스를 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7f082fb8d4bea15f8889d77377e106a9c22adf29" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s more complicated if you&amp;rsquo;re using particular configuration features:</source>
          <target state="translated">특정 구성 기능을 사용하는 경우 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="88fa82c4d602eb465e03c911efedb365b397a9f4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to use environment variables in your shell to populate values inside a Compose file:</source>
          <target state="translated">쉘에서 환경 변수를 사용하여 작성 파일 내의 값을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1975be0afa476f4590f4ee055de3b736753a6139" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended that you use reverse-DNS notation to prevent your labels from conflicting with those used by other software.</source>
          <target state="translated">레이블이 다른 소프트웨어에서 사용되는 레이블과 충돌하지 않도록 역 DNS 표기법을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d18cbae40de71fdcfbb88d66c4df0313d679687a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s time to begin building an app the Docker way. We start at the bottom of the hierarchy of such app, a container, which this page covers. Above this level is a service, which defines how containers behave in production, covered in &lt;a href=&quot;../part3/index&quot;&gt;Part 3&lt;/a&gt;. Finally, at the top level is the stack, defining the interactions of all the services, covered in &lt;a href=&quot;../part5/index&quot;&gt;Part 5&lt;/a&gt;.</source>
          <target state="translated">이제 Docker 방식으로 앱 빌드를 시작할 차례입니다. 우리는이 페이지가 다루는 컨테이너 인 앱의 계층 구조의 맨 아래부터 시작합니다. 이 레벨 위에는 서비스가 있으며, 이는 컨테이너가 생산 과정에서 작동하는 방식을 정의합니다 ( &lt;a href=&quot;../part3/index&quot;&gt;3 부 참조)&lt;/a&gt; . 마지막으로 최상위 레벨에는 &lt;a href=&quot;../part5/index&quot;&gt;Part 5&lt;/a&gt; 에서 다루는 모든 서비스의 상호 작용을 정의하는 스택이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed9626b5c17e6a3158778059cc2cd1d8afdf0d16" translate="yes" xml:space="preserve">
          <source>Iterating and scaling your app</source>
          <target state="translated">앱 반복 및 확장</target>
        </trans-unit>
        <trans-unit id="227293154ef1fdf91a030290b560e39b9d2559a4" translate="yes" xml:space="preserve">
          <source>Iteration and cleanup</source>
          <target state="translated">반복 및 정리</target>
        </trans-unit>
        <trans-unit id="d8586e1d9d2ce52f2da48ea9c543162fc685898a" translate="yes" xml:space="preserve">
          <source>JSON specification</source>
          <target state="translated">JSON 사양</target>
        </trans-unit>
        <trans-unit id="93d86bc8906bb78510b2ad977d86b22ee7438fe4" translate="yes" xml:space="preserve">
          <source>Join a node to a swarm. The node joins as a manager node or worker node based upon the token you pass with the &lt;code&gt;--token&lt;/code&gt; flag. If you pass a manager token, the node joins as a manager. If you pass a worker token, the node joins as a worker.</source>
          <target state="translated">떼에 노드를 가입시킵니다. 노드는 &lt;code&gt;--token&lt;/code&gt; 플래그 와 함께 전달한 토큰을 기반으로 관리자 노드 또는 작업자 노드로 연결됩니다 . 관리자 토큰을 전달하면 노드가 관리자로 가입합니다. 작업자 토큰을 전달하면 노드가 작업자로 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="cdf346545f85bcd2ac6db7457477379f3dc8ce88" translate="yes" xml:space="preserve">
          <source>Join a node to swarm as a manager</source>
          <target state="translated">관리자로 무리를 짓기 위해 노드에 가입</target>
        </trans-unit>
        <trans-unit id="2fa0bb20b23bfe84cd39b0230b7be38315e7d5ec" translate="yes" xml:space="preserve">
          <source>Join a node to swarm as a worker</source>
          <target state="translated">작업자로 무리를 짓기 위해 노드에 가입</target>
        </trans-unit>
        <trans-unit id="3931d1d98d15f29366e0d7406263139f1aadd5f6" translate="yes" xml:space="preserve">
          <source>Join a swarm as a node and/or manager</source>
          <target state="translated">떼를 노드 및 / 또는 관리자로 가입</target>
        </trans-unit>
        <trans-unit id="af5c636f2c747e60cb0eb3c3c05b8c83dda18ac8" translate="yes" xml:space="preserve">
          <source>Join another (&amp;ldquo;shareable&amp;rdquo;) container&amp;rsquo;s IPC namespace.</source>
          <target state="translated">다른 ( &quot;공유 가능&quot;) 컨테이너의 IPC 네임 스페이스에 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="5510aae81745a900ff6a1d206ddcefde9e0889e5" translate="yes" xml:space="preserve">
          <source>Join as a manager node</source>
          <target state="translated">관리자 노드로 가입</target>
        </trans-unit>
        <trans-unit id="55f67cb6fd9d40fd8a2df610b373d4d52d2cd515" translate="yes" xml:space="preserve">
          <source>Join as a worker node</source>
          <target state="translated">작업자 노드로 가입</target>
        </trans-unit>
        <trans-unit id="c76220bfd1fb7b9f59e2e1fc23873bcdcf8cc1c4" translate="yes" xml:space="preserve">
          <source>Join nodes to a swarm</source>
          <target state="translated">떼에 노드를 결합</target>
        </trans-unit>
        <trans-unit id="3639cacbe072346a35839355fa73730779f710a2" translate="yes" xml:space="preserve">
          <source>Joining another container&amp;rsquo;s pid namespace can be used for debugging that container.</source>
          <target state="translated">다른 컨테이너의 pid 네임 스페이스에 가입하면 해당 컨테이너를 디버깅하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e71ac678a59bc83ece73e440193af7fd503cce30" translate="yes" xml:space="preserve">
          <source>Journald logging driver for Docker. Writes log messages to &lt;code&gt;journald&lt;/code&gt;.</source>
          <target state="translated">Docker 용 저널링 로깅 드라이버. 로그 메시지를 &lt;code&gt;journald&lt;/code&gt; 에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="d03028658a8cf7cb32848154d239e0ac38f439f2" translate="yes" xml:space="preserve">
          <source>Just as with other docker commands that take image names, you can refer to an image with or without a tag, or by digest (e.g. hello-world@sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f).</source>
          <target state="translated">이미지 이름을 사용하는 다른 도커 명령과 마찬가지로 태그가 있거나없는 이미지 또는 다이제스트를 통해 이미지를 참조 할 수 있습니다 (예 : hello-world @ sha256 : f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f).</target>
        </trans-unit>
        <trans-unit id="b01f1f8b458e043c28cc5fe41fbfb19ff7253960" translate="yes" xml:space="preserve">
          <source>Just as you can use third-party tools to augment Docker containers, including special network topologies or shared filesystems, tools exist to harden Docker containers without the need to modify Docker itself.</source>
          <target state="translated">타사 도구를 사용하여 특수 네트워크 토폴로지 또는 공유 파일 시스템을 포함한 Docker 컨테이너를 확장 할 수있는 것처럼 Docker 자체를 수정하지 않고도 Docker 컨테이너를 강화할 수있는 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d438933844f319b751c15e820ef73fbb188fa3d" translate="yes" xml:space="preserve">
          <source>Just like before, run the following command to deploy the app on &lt;code&gt;myvm1&lt;/code&gt;.</source>
          <target state="translated">이전과 마찬가지로 다음 명령을 실행하여 &lt;code&gt;myvm1&lt;/code&gt; 에 앱을 배포하십시오 .</target>
        </trans-unit>
        <trans-unit id="81ff80dadbd4fe6e241f2137d7faf499603979ab" translate="yes" xml:space="preserve">
          <source>Just like how &lt;code&gt;scp&lt;/code&gt; has a &lt;code&gt;-r&lt;/code&gt; flag for copying files recursively, &lt;code&gt;docker-machine&lt;/code&gt; has a &lt;code&gt;-r&lt;/code&gt; flag for this feature.</source>
          <target state="translated">&lt;code&gt;scp&lt;/code&gt; 에 파일을 재귀 적으로 복사하기위한 &lt;code&gt;-r&lt;/code&gt; 플래그 가있는 것처럼 &lt;code&gt;docker-machine&lt;/code&gt; 에는 이 기능에 대한 &lt;code&gt;-r&lt;/code&gt; 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="883faf2f89ef7add648c9777bc1131e09ab63aff" translate="yes" xml:space="preserve">
          <source>Just like with &lt;code&gt;docker run -e&lt;/code&gt;, you can set environment variables on a one-off container with &lt;code&gt;docker-compose run -e&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;docker run -e&lt;/code&gt; 와 마찬가지로 &lt;code&gt;docker-compose run -e&lt;/code&gt; 를 사용 하여 일회용 컨테이너에서 환경 변수를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c16dfdfaa07d58c9003c38d9df7e1cb56fd2fc2" translate="yes" xml:space="preserve">
          <source>Just like with standalone containers, you can specify a command that the service&amp;rsquo;s containers should run, by adding it after the image name. This example starts a service called &lt;code&gt;helloworld&lt;/code&gt; which uses an &lt;code&gt;alpine&lt;/code&gt; image and runs the command &lt;code&gt;ping docker.com&lt;/code&gt;:</source>
          <target state="translated">독립형 컨테이너와 마찬가지로 이미지 이름 뒤에 서비스 컨테이너를 추가하여 서비스 컨테이너가 실행해야하는 명령을 지정할 수 있습니다. 이 예 는 &lt;code&gt;alpine&lt;/code&gt; 이미지 를 사용하고 &lt;code&gt;ping docker.com&lt;/code&gt; 명령을 실행 하는 &lt;code&gt;helloworld&lt;/code&gt; 서비스를 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="532c83cd72eb94d7728dd9be6890048bea72e775" translate="yes" xml:space="preserve">
          <source>KILL</source>
          <target state="translated">KILL</target>
        </trans-unit>
        <trans-unit id="3edc762a6dd4eaf007e8ced210c65e58d4076e7d" translate="yes" xml:space="preserve">
          <source>Keep STDIN open even if not attached</source>
          <target state="translated">STDIN을 부착하지 않아도 열린 상태로 유지</target>
        </trans-unit>
        <trans-unit id="e2946dbcc93cf37aaf8b462033edeb19faf7901e" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;links&lt;/code&gt;, &lt;code&gt;volumes_from&lt;/code&gt;, and &lt;code&gt;depends_on&lt;/code&gt; are never shared between services using &lt;code&gt;extends&lt;/code&gt;. These exceptions exist to avoid implicit dependencies; you always define &lt;code&gt;links&lt;/code&gt; and &lt;code&gt;volumes_from&lt;/code&gt; locally. This ensures dependencies between services are clearly visible when reading the current file. Defining these locally also ensures that changes to the referenced file don&amp;rsquo;t break anything.</source>
          <target state="translated">마음에 계속 &lt;code&gt;links&lt;/code&gt; , &lt;code&gt;volumes_from&lt;/code&gt; 및 &lt;code&gt;depends_on&lt;/code&gt; 가 사용하는 서비스 사이에 공유되지 않습니다 &lt;code&gt;extends&lt;/code&gt; . 이러한 예외는 암시 적 종속성을 피하기 위해 존재합니다. 항상 로컬에서 &lt;code&gt;links&lt;/code&gt; 와 &lt;code&gt;volumes_from&lt;/code&gt; 정의 합니다 . 이를 통해 현재 파일을 읽을 때 서비스 간의 종속성을 명확하게 볼 수 있습니다. 이러한 파일을 로컬로 정의하면 참조 된 파일을 변경해도 아무런 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f1115406bbe1f5a1759e17480c853c28c03bada" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;em&gt;the order of files in the list is significant in determining the value assigned to a variable that shows up more than once&lt;/em&gt;. The files in the list are processed from the top down. For the same variable specified in file &lt;code&gt;a.env&lt;/code&gt; and assigned a different value in file &lt;code&gt;b.env&lt;/code&gt;, if &lt;code&gt;b.env&lt;/code&gt; is listed below (after), then the value from &lt;code&gt;b.env&lt;/code&gt; stands. For example, given the following declaration in &lt;code&gt;docker-compose.yml&lt;/code&gt;:</source>
          <target state="translated">있다는 사실을 숙지 &lt;em&gt;목록에있는 파일의 순서가 쇼까지 한 번 이상 변수에 할당 된 값을 결정하는 데 중요하다&lt;/em&gt; . 목록의 파일은 위에서 아래로 처리됩니다. 파일에 규정 된 동일한 변수 &lt;code&gt;a.env&lt;/code&gt; 및 파일에 다른 값이 할당 &lt;code&gt;b.env&lt;/code&gt; 을 경우 &lt;code&gt;b.env&lt;/code&gt; 가 아래에 나열된다 (후) 다음의 값 &lt;code&gt;b.env&lt;/code&gt; 가 선다. 예를 들어 &lt;code&gt;docker-compose.yml&lt;/code&gt; 에 다음과 같은 선언이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5d006e0f5f0fdb492321b358c4830db6193e4f0" translate="yes" xml:space="preserve">
          <source>Keep in mind that to use the ingress network in the swarm, you need to have the following ports open between the swarm nodes before you enable swarm mode:</source>
          <target state="translated">swarm에서 수신 네트워크를 사용하려면 swarm 모드를 활성화하기 전에 swarm 노드 사이에 다음 포트를 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="fc88f191aba3d8e4c6cb58eed4d8ce6e24cb8f78" translate="yes" xml:space="preserve">
          <source>Keep reading for details about concepts relating to Docker swarm services, including nodes, services, tasks, and load balancing.</source>
          <target state="translated">노드, 서비스, 작업 및로드 밸런싱을 포함하여 Docker swarm 서비스와 관련된 개념에 대한 자세한 내용을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="c051e176f76f78e1ac5b2f45d44479ee599645d5" translate="yes" xml:space="preserve">
          <source>Keep reading for more information and use cases for each of these methods.</source>
          <target state="translated">이러한 각 방법에 대한 자세한 정보와 사용 사례를 보려면 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="8a34eafa0ebcf421dd485c9abf116916491dbd04" translate="yes" xml:space="preserve">
          <source>Keep the following things in mind about volumes in the &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dockerfile&lt;/code&gt; 의 볼륨에 대해 다음 사항을 명심하십시오 .</target>
        </trans-unit>
        <trans-unit id="d261a130a52919c210d7f95561d0c0690d62daac" translate="yes" xml:space="preserve">
          <source>Keep the swarm or remove it?</source>
          <target state="translated">떼를 유지하거나 제거?</target>
        </trans-unit>
        <trans-unit id="021071f2b5e1149a4373f45b77446654a5b8c8dd" translate="yes" xml:space="preserve">
          <source>Keep the unlock key around for a short time after disabling autolocking, in case a manager goes down while it is still configured to lock using the old key.</source>
          <target state="translated">관리자가 이전 키를 사용하여 잠그도록 구성되어있는 동안 관리자가 다운 될 경우 자동 잠금을 비활성화 한 후 잠금 해제 키를 잠시 동안 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="e636c1c192a5d61c1955d55cce82990cbd13a12c" translate="yes" xml:space="preserve">
          <source>Kernel memory constraints</source>
          <target state="translated">커널 메모리 제약</target>
        </trans-unit>
        <trans-unit id="f4fae48265f804d84d60e52dc1217418236f50fd" translate="yes" xml:space="preserve">
          <source>Kernel memory is a subset of the user memory. This setup is useful in deployments where the total amount of memory per-cgroup is overcommitted. Overcommitting kernel memory limits is definitely not recommended, since the box can still run out of non-reclaimable memory. In this case, you can configure K so that the sum of all groups is never greater than the total memory. Then, freely set U at the expense of the system's service quality.</source>
          <target state="translated">커널 메모리는 사용자 메모리의 하위 집합입니다. 이 설정은 cgroup 당 총 메모리 양이 초과 커밋 된 배포에 유용합니다. 상자에 재 확보 할 수없는 메모리가 부족할 수 있으므로 커널 메모리 제한을 초과 커밋하지 않는 것이 좋습니다. 이 경우 모든 그룹의 합이 총 메모리보다 크지 않도록 K를 구성 할 수 있습니다. 그런 다음 시스템의 서비스 품질을 희생하여 U를 자유롭게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="625ee403e60bf922a70a9cc53027a328cb82e400" translate="yes" xml:space="preserve">
          <source>Kernel memory is fundamentally different than user memory as kernel memory can&amp;rsquo;t be swapped out. The inability to swap makes it possible for the container to block system services by consuming too much kernel memory. Kernel memory includes：</source>
          <target state="translated">커널 메모리는 교체 할 수 없으므로 커널 메모리는 기본적으로 사용자 메모리와 다릅니다. 스왑이 불가능하면 컨테이너가 너무 많은 커널 메모리를 소비하여 시스템 서비스를 차단할 수 있습니다. 커널 메모리에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c3161c0722c81ad66454215a48baa52c84eb62d1" translate="yes" xml:space="preserve">
          <source>Kernel memory is never completely independent of user memory. Instead, you limit kernel memory in the context of the user memory limit. Assume &amp;ldquo;U&amp;rdquo; is the user memory limit and &amp;ldquo;K&amp;rdquo; the kernel limit. There are three possible ways to set limits:</source>
          <target state="translated">커널 메모리는 사용자 메모리와 완전히 독립적이지 않습니다. 대신 사용자 메모리 제한의 맥락에서 커널 메모리를 제한합니다. &amp;ldquo;U&amp;rdquo;가 사용자 메모리 한계이고&amp;ldquo;K&amp;rdquo;가 커널 한계라고 가정하십시오. 한계를 설정하는 방법에는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="622da91ebd496ca53f00d65623eb2e7a0b35c8d7" translate="yes" xml:space="preserve">
          <source>Kernel memory limit</source>
          <target state="translated">커널 메모리 제한</target>
        </trans-unit>
        <trans-unit id="99fa080e74c6537742a518ae8e215a46e700f823" translate="yes" xml:space="preserve">
          <source>Kernel memory limit (format: &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt;). Number is a positive integer. Unit can be one of &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt;. Minimum is 4M.</source>
          <target state="translated">커널 메모리 제한 (형식 : &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt; ). 숫자는 양의 정수입니다. 단위는 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 중 하나 일 수 있습니다 . 최소값은 4M입니다.</target>
        </trans-unit>
        <trans-unit id="dd5b7abe9db8c00fa8fa1c95d5d672464d3af952" translate="yes" xml:space="preserve">
          <source>Kernel namespaces</source>
          <target state="translated">커널 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="d3a71e9e90b5758667b7011f33bfcae957b7ece7" translate="yes" xml:space="preserve">
          <source>Kernel parameters to set in the container. You can use either an array or a dictionary.</source>
          <target state="translated">컨테이너에 설정할 커널 매개 변수. 배열이나 사전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a7772cc0d951bb8363df81f7791cb7b0ec04ad" translate="yes" xml:space="preserve">
          <source>Kernel version newer than (include) 4.6 does not have this limitation, you can use &lt;code&gt;--kernel-memory&lt;/code&gt; the same way as other options.</source>
          <target state="translated">(포함) 4.6 이전의 커널 버전에는이 제한이 &lt;code&gt;--kernel-memory&lt;/code&gt; 를 다른 옵션과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="925fa1c20a0c397925a02d36b63d14186e7b48b1" translate="yes" xml:space="preserve">
          <source>Keys compromised</source>
          <target state="translated">키 손상</target>
        </trans-unit>
        <trans-unit id="e2588bc14565b6087a35b3bcaa6b086fa30e602a" translate="yes" xml:space="preserve">
          <source>Keywhiz plugin</source>
          <target state="translated">Keywhiz 플러그인</target>
        </trans-unit>
        <trans-unit id="8ff5564effa5413d6d90c225280c49e51e955168" translate="yes" xml:space="preserve">
          <source>Kill one or more running containers</source>
          <target state="translated">하나 이상의 컨테이너를 죽이십시오</target>
        </trans-unit>
        <trans-unit id="76fdcfeaa1626fed3a98b2a2a2d5045de6256995" translate="yes" xml:space="preserve">
          <source>Killing the &lt;code&gt;docker pull&lt;/code&gt; process, for example by pressing &lt;code&gt;CTRL-c&lt;/code&gt; while it is running in a terminal, will terminate the pull operation.</source>
          <target state="translated">죽이는 &lt;code&gt;docker pull&lt;/code&gt; 누름으로써 예를 들어, 프로세스 &lt;code&gt;CTRL-c&lt;/code&gt; 는 단말에서 실행되는 상태를 당김 동작을 종료한다.</target>
        </trans-unit>
        <trans-unit id="cadb2f192fe25020f03d4b7dcad8d86660f4eac5" translate="yes" xml:space="preserve">
          <source>Killing the &lt;code&gt;docker push&lt;/code&gt; process, for example by pressing &lt;code&gt;CTRL-c&lt;/code&gt; while it is running in a terminal, terminates the push operation.</source>
          <target state="translated">죽이는 &lt;code&gt;docker push&lt;/code&gt; 누름으로써, 예를 들면, 프로세스 &lt;code&gt;CTRL-c&lt;/code&gt; 이 단말기에서 실행되고있는 동안, 푸시 동작을 종료한다.</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f69d063691f8d80817a5f8e91ee85171ee0c6e" translate="yes" xml:space="preserve">
          <source>Known issues (RUN)</source>
          <target state="translated">알려진 문제 (RUN)</target>
        </trans-unit>
        <trans-unit id="b36c6077a62ee3e8bd61bbeb730cb7130516f528" translate="yes" xml:space="preserve">
          <source>Known limitations</source>
          <target state="translated">알려진 제한 사항</target>
        </trans-unit>
        <trans-unit id="bee0cb05f850f53dc7ec012e5b12bbe98948693b" translate="yes" xml:space="preserve">
          <source>Kubernetes</source>
          <target state="translated">Kubernetes</target>
        </trans-unit>
        <trans-unit id="66fed4cbaa3577772e82ac7bc59ecf69e2406d35" translate="yes" xml:space="preserve">
          <source>Kubernetes config file</source>
          <target state="translated">쿠 버네 티스 설정 파일</target>
        </trans-unit>
        <trans-unit id="65014fd4298be69069ae75bd59b771f0ea05a2e5" translate="yes" xml:space="preserve">
          <source>Kubernetes namespace to use</source>
          <target state="translated">사용할 Kubernetes 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="0e61dbda7b04b06f71cdfaf436aadb8072eabe36" translate="yes" xml:space="preserve">
          <source>Kubernetes namespaces to use</source>
          <target state="translated">사용할 Kubernetes 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="21c3ba932a4a7b7154ff817d82650d01e6cfe41c" translate="yes" xml:space="preserve">
          <source>Kubernetes: not supported</source>
          <target state="translated">쿠 버네 티스 : 지원되지 않음</target>
        </trans-unit>
        <trans-unit id="1616e14ec9d4c0a39b19aba74e1eb02899a120b9" translate="yes" xml:space="preserve">
          <source>Kubernetes: supported</source>
          <target state="translated">쿠 버네 티스 : 지원</target>
        </trans-unit>
        <trans-unit id="a286ef73dc47ff9f8e7d5dcede30ce66a0b6c3bf" translate="yes" xml:space="preserve">
          <source>Kuryr Network Plugin</source>
          <target state="translated">Kuryr 네트워크 플러그인</target>
        </trans-unit>
        <trans-unit id="64b8a7e20b4f639e91be58a1c2dfc4878f384e11" translate="yes" xml:space="preserve">
          <source>LABEL</source>
          <target state="translated">LABEL</target>
        </trans-unit>
        <trans-unit id="41175145e3d154aa574b30244895905f6a48a28f" translate="yes" xml:space="preserve">
          <source>LCOW (Linux Containers on Windows) options</source>
          <target state="translated">LCOW (Windows의 Linux 컨테이너) 옵션</target>
        </trans-unit>
        <trans-unit id="0dfc15d2da49d5f09a464bed22da71e16e24aa06" translate="yes" xml:space="preserve">
          <source>LEASE</source>
          <target state="translated">LEASE</target>
        </trans-unit>
        <trans-unit id="e0e86fad8959136b6bbd6054e4a3ca23f4104814" translate="yes" xml:space="preserve">
          <source>LINUX_IMMUTABLE</source>
          <target state="translated">LINUX_IMMUTABLE</target>
        </trans-unit>
        <trans-unit id="f65ef3c405092078ab064a6409413ad0c2b37715" translate="yes" xml:space="preserve">
          <source>LXC built-in exec driver</source>
          <target state="translated">LXC 내장 exec 드라이버</target>
        </trans-unit>
        <trans-unit id="74341e3c271df3c784e595b804b1f90be0f80429" translate="yes" xml:space="preserve">
          <source>Label</source>
          <target state="translated">Label</target>
        </trans-unit>
        <trans-unit id="9f9b411205904fd15a31cac020b5f7ad86f6d927" translate="yes" xml:space="preserve">
          <source>Labeling systems like SELinux require that proper labels are placed on volume content mounted into a container. Without a label, the security system might prevent the processes running inside the container from using the content. By default, Docker does not change the labels set by the OS.</source>
          <target state="translated">SELinux와 같은 레이블 시스템은 컨테이너에 마운트 된 볼륨 컨텐츠에 적절한 레이블을 배치해야합니다. 레이블이 없으면 보안 시스템이 컨테이너 내부에서 실행중인 프로세스가 컨텐츠를 사용하지 못하게 할 수 있습니다. 기본적으로 Docker는 OS에서 설정 한 레이블을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99623225883875fed762367fadcd596048d1ab39" translate="yes" xml:space="preserve">
          <source>Labels &lt;code&gt;map[string]string&lt;/code&gt;</source>
          <target state="translated">라벨지 &lt;code&gt;map[string]string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38a08247f87855b3bb56e8b972ab653a02be99fe" translate="yes" xml:space="preserve">
          <source>Labels included in base or parent images (images in the &lt;code&gt;FROM&lt;/code&gt; line) are inherited by your image. If a label already exists but with a different value, the most-recently-applied value overrides any previously-set value.</source>
          <target state="translated">기본 또는 상위 이미지 ( &lt;code&gt;FROM&lt;/code&gt; 행의 이미지)에 포함 된 레이블은 이미지에서 상속됩니다. 레이블이 이미 있지만 다른 값을 가진 경우 가장 최근에 적용된 값이 이전에 설정된 값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="2139c30d12f32b7036ab09c47f34a712624e576f" translate="yes" xml:space="preserve">
          <source>Labels used for setting meta data on services.</source>
          <target state="translated">서비스에서 메타 데이터를 설정하는 데 사용되는 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="cfa2a3ccd6b50663487ded4a1e77fff64797972c" translate="yes" xml:space="preserve">
          <source>Lastly, if you need to do some extra cleanup (or communicate with other containers) on shutdown, or are co-ordinating more than one executable, you may need to ensure that the &lt;code&gt;ENTRYPOINT&lt;/code&gt; script receives the Unix signals, passes them on, and then does some more work:</source>
          <target state="translated">마지막으로 종료시 추가 정리 (또는 다른 컨테이너와 통신)가 필요하거나 둘 이상의 실행 파일을 조정해야하는 경우 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 스크립트가 Unix 신호를 수신하고 전달한 다음 확인해야합니다. 더 많은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9592ae07ee081cbedb348d2f1fa101285248d879" translate="yes" xml:space="preserve">
          <source>Later the image may be used as a base for a new build, using the &lt;code&gt;FROM&lt;/code&gt; instruction. As part of processing the &lt;code&gt;FROM&lt;/code&gt; instruction, the downstream builder looks for &lt;code&gt;ONBUILD&lt;/code&gt; triggers, and executes them in the same order they were registered. If any of the triggers fail, the &lt;code&gt;FROM&lt;/code&gt; instruction is aborted which in turn causes the build to fail. If all triggers succeed, the &lt;code&gt;FROM&lt;/code&gt; instruction completes and the build continues as usual.</source>
          <target state="translated">나중에 &lt;code&gt;FROM&lt;/code&gt; 명령어를 사용하여 이미지를 새 빌드의 기반으로 사용할 수 있습니다 . &lt;code&gt;FROM&lt;/code&gt; 명령 처리의 일부로 다운 스트림 빌더는 &lt;code&gt;ONBUILD&lt;/code&gt; 트리거 를 찾아서 등록 된 순서대로 실행합니다. 트리거 중 하나라도 실패하면 &lt;code&gt;FROM&lt;/code&gt; 명령이 중단되어 빌드가 실패합니다. 모든 트리거가 성공하면 &lt;code&gt;FROM&lt;/code&gt; 명령이 완료되고 평소대로 빌드가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="1e79d12bc4437cad629aa8f70d788ec07f67f160" translate="yes" xml:space="preserve">
          <source>Launch Hyper-V Manager</source>
          <target state="translated">Hyper-V 관리자 시작</target>
        </trans-unit>
        <trans-unit id="d4d31a66cd8f2de79c4dc403a83a20afb1a8a536" translate="yes" xml:space="preserve">
          <source>Layering &lt;code&gt;RUN&lt;/code&gt; instructions and generating commits conforms to the core concepts of Docker where commits are cheap and containers can be created from any point in an image&amp;rsquo;s history, much like source control.</source>
          <target state="translated">&lt;code&gt;RUN&lt;/code&gt; 명령어를 계층화 하고 커밋을 생성하는 것은 커밋이 저렴하고 소스 제어와 같이 이미지 히스토리의 모든 지점에서 컨테이너를 만들 수있는 Docker의 핵심 개념을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="40af804c302e7ac20b00c30bab41fc8d5c6d3e05" translate="yes" xml:space="preserve">
          <source>Layers can be reused by images. For example, the &lt;code&gt;debian:jessie&lt;/code&gt; image shares both layers with &lt;code&gt;debian:latest&lt;/code&gt;. Pulling the &lt;code&gt;debian:jessie&lt;/code&gt; image therefore only pulls its metadata, but not its layers, because all layers are already present locally:</source>
          <target state="translated">이미지에서 레이어를 재사용 할 수 있습니다. 예를 들어 &lt;code&gt;debian:jessie&lt;/code&gt; 이미지는 두 레이어를 &lt;code&gt;debian:latest&lt;/code&gt; 와 공유합니다 . 인상 &lt;code&gt;debian:jessie&lt;/code&gt; 모든 층 로컬 이미 존재하기 때문에, 해당 층 화상 따라서 만 메타 데이터를 당긴 아니지만 :</target>
        </trans-unit>
        <trans-unit id="378cbbf54cbb2e3f3bd201f02c1b946ec3601eba" translate="yes" xml:space="preserve">
          <source>Learn More</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="4e41542d9ea87e4c7a177ef2813704427f08d1a1" translate="yes" xml:space="preserve">
          <source>Learn how &lt;a href=&quot;../pki/index&quot;&gt;PKI&lt;/a&gt; works in swarm mode.</source>
          <target state="translated">&lt;a href=&quot;../pki/index&quot;&gt;PKI&lt;/a&gt; 가 스웜 모드에서 작동 하는 방법을 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="c6e94171098d02849dc1715b2f6fd541dc455ec4" translate="yes" xml:space="preserve">
          <source>Learn how swarm mode &lt;a href=&quot;../services/index&quot;&gt;services&lt;/a&gt; work.</source>
          <target state="translated">스웜 모드 &lt;a href=&quot;../services/index&quot;&gt;서비스&lt;/a&gt; 작동 방식에 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="380a712cc07085ce1d1329c08893a90d0996261e" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;../../ingress/index&quot;&gt;use a swarm mode routing mesh&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ingress/index&quot;&gt;스웜 모드 라우팅 메쉬&lt;/a&gt; 를 사용하는 방법을 배웁니다 .</target>
        </trans-unit>
        <trans-unit id="d3b0923eff22e50e3513a150c82331f6bb9131d1" translate="yes" xml:space="preserve">
          <source>Learn how to create containers in &lt;a href=&quot;../part2/index&quot;&gt;Part 2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../part2/index&quot;&gt;Part 2&lt;/a&gt; 에서 컨테이너를 작성하는 방법을 배우십시오 .</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="9271e197be4840ef4c9395777dcb8495868583bc" translate="yes" xml:space="preserve">
          <source>Learn swarm mode &lt;a href=&quot;key-concepts/index&quot;&gt;key concepts&lt;/a&gt;.</source>
          <target state="translated">스웜 모드 &lt;a href=&quot;key-concepts/index&quot;&gt;키 개념에&lt;/a&gt; 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="220c633c19194228df884b045e77d2699be377b3" translate="yes" xml:space="preserve">
          <source>Leave the &lt;code&gt;trustsandbox&lt;/code&gt; shell and container running.</source>
          <target state="translated">&lt;code&gt;trustsandbox&lt;/code&gt; 셸 및 컨테이너를 실행 상태로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="d9a68ae1642d7a6e9109ef808c5c4f18c84b0f74" translate="yes" xml:space="preserve">
          <source>Leave the container running after checkpoint</source>
          <target state="translated">체크 포인트 후에 컨테이너를 계속 실행</target>
        </trans-unit>
        <trans-unit id="3d7dcc5f6be64001146f2c5cf968dbdb2aeeb475" translate="yes" xml:space="preserve">
          <source>Leave the swarm</source>
          <target state="translated">떼를 떠나</target>
        </trans-unit>
        <trans-unit id="87424edda45e23481b54dfd85449af2235a1ff48" translate="yes" xml:space="preserve">
          <source>Leaving a swarm</source>
          <target state="translated">떼를 떠나</target>
        </trans-unit>
        <trans-unit id="9c9836b6ddb6fdd38539472714b585cfcc4dc19d" translate="yes" xml:space="preserve">
          <source>Legacy &amp;ldquo;overlay&amp;rdquo; storage driver</source>
          <target state="translated">레거시 &quot;오버레이&quot;스토리지 드라이버</target>
        </trans-unit>
        <trans-unit id="51399109ad60688d95d8415210375d5ca4cb6dc8" translate="yes" xml:space="preserve">
          <source>Legacy Registries</source>
          <target state="translated">레거시 레지스트리</target>
        </trans-unit>
        <trans-unit id="64fb4426792c66b646f4728d069cfea000de79ab" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s deploy the stack created before:</source>
          <target state="translated">이전에 생성 된 스택을 배포하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="daf990bba19131f95b3a8a3c97f7ed96aa4c9e66" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go through the same workflow once more to add a Redis database for storing app data.</source>
          <target state="translated">앱 데이터 저장을위한 Redis 데이터베이스를 추가하기 위해 동일한 워크 플로우를 한 번 더 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="fffaf2eab9d192f03c3dc3efec300e51a4170815" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that you wanted to change the password that is used to create new keys (rotating the passphrase and re-encrypting all the private keys is not supported yet).</source>
          <target state="translated">새 키를 만드는 데 사용되는 암호를 변경하려고한다고 가정합니다 (암호를 회전하고 모든 개인 키를 다시 암호화하는 것은 아직 지원되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="12507f3ac18e59146cb75890d9538c0c6a361957" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at using &lt;code&gt;docker-machine&lt;/code&gt; to create, use and manage a Docker host inside of a local virtual machine.</source>
          <target state="translated">&lt;code&gt;docker-machine&lt;/code&gt; 을 사용하여 로컬 가상 머신 내에서 Docker 호스트를 생성, 사용 및 관리하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b59bc3ab3df4c49c882bcce76cce376a48d4a1ef" translate="yes" xml:space="preserve">
          <source>Lets you mount Microsoft &lt;a href=&quot;https://azure.microsoft.com/blog/azure-file-storage-now-generally-available/&quot;&gt;Azure File Storage&lt;/a&gt; shares to Docker containers as volumes using the SMB 3.0 protocol. &lt;a href=&quot;https://azure.microsoft.com/blog/persistent-docker-volumes-with-azure-file-storage/&quot;&gt;Learn more&lt;/a&gt;.</source>
          <target state="translated">SMB 3.0 프로토콜을 사용하여 Microsoft &lt;a href=&quot;https://azure.microsoft.com/blog/azure-file-storage-now-generally-available/&quot;&gt;Azure File Storage&lt;/a&gt; 공유를 Docker 컨테이너에 볼륨으로 마운트 할 수 있습니다. &lt;a href=&quot;https://azure.microsoft.com/blog/persistent-docker-volumes-with-azure-file-storage/&quot;&gt;자세히 알아보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93d7f130977ce6ebd7f181fb07b97c0898afd023" translate="yes" xml:space="preserve">
          <source>License File</source>
          <target state="translated">라이센스 파일</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="aa636d64869928622347b0ebd93665113e78146c" translate="yes" xml:space="preserve">
          <source>Licensing</source>
          <target state="translated">Licensing</target>
        </trans-unit>
        <trans-unit id="86cbe03ed8f5fc1191085ff37b666f9ae0b75a94" translate="yes" xml:space="preserve">
          <source>Lightweight: Containers leverage and share the host kernel.</source>
          <target state="translated">경량 : 컨테이너는 호스트 커널을 활용하고 공유합니다.</target>
        </trans-unit>
        <trans-unit id="1383eb4efa3f583724f88dc9bd12826b03000da7" translate="yes" xml:space="preserve">
          <source>Limit CPU CFS (Completely Fair Scheduler) period</source>
          <target state="translated">CPU CFS (Completely Fair Scheduler) 기간 제한</target>
        </trans-unit>
        <trans-unit id="b33e601bc58589387c3dbc9da0d76e26087fd087" translate="yes" xml:space="preserve">
          <source>Limit CPU CFS (Completely Fair Scheduler) quota</source>
          <target state="translated">CPU CFS (Completely Fair Scheduler) 할당량 제한</target>
        </trans-unit>
        <trans-unit id="6de6dc3214b3fa418e299b4879681e6c87e13599" translate="yes" xml:space="preserve">
          <source>Limit CPU real-time period in microseconds</source>
          <target state="translated">마이크로 초 단위로 CPU 실시간 제한</target>
        </trans-unit>
        <trans-unit id="74f741ec63541d7093613fcdcf44ef4f7cdc8f83" translate="yes" xml:space="preserve">
          <source>Limit CPU real-time runtime in microseconds</source>
          <target state="translated">마이크로 초 단위로 CPU 실시간 런타임 제한</target>
        </trans-unit>
        <trans-unit id="769da0a9c9458ee4156693ee512f398df99b8d0a" translate="yes" xml:space="preserve">
          <source>Limit CPUs</source>
          <target state="translated">CPU 제한</target>
        </trans-unit>
        <trans-unit id="57b4e0799cf80d8e0a1aff695d78244b22335674" translate="yes" xml:space="preserve">
          <source>Limit Memory</source>
          <target state="translated">메모리 제한</target>
        </trans-unit>
        <trans-unit id="e18f047404cb128f8ca7d270e5bd4b1c6d3eb0c1" translate="yes" xml:space="preserve">
          <source>Limit events by time</source>
          <target state="translated">시간별 이벤트 제한</target>
        </trans-unit>
        <trans-unit id="6be2f00f997ceda220d941077334fed7e0828e56" translate="yes" xml:space="preserve">
          <source>Limit read rate (IO per second) from a device</source>
          <target state="translated">장치에서 읽기 속도 (초당 IO)</target>
        </trans-unit>
        <trans-unit id="553bf251d4b114ecb451bd8bcb986ef78813c8d7" translate="yes" xml:space="preserve">
          <source>Limit read rate (IO per second) from a device (format: &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;&lt;/code&gt;). Number is a positive integer.</source>
          <target state="translated">장치에서 읽기 속도 (초당 IO)를 제한합니다 (형식 : &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;&lt;/code&gt; ). 숫자는 양의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ab472f2529b3fe483d50c5da3bec8b8fb2eded49" translate="yes" xml:space="preserve">
          <source>Limit read rate (bytes per second) from a device</source>
          <target state="translated">장치에서 읽기 속도 (초당 바이트)</target>
        </trans-unit>
        <trans-unit id="2ec23a8fca1fdcadc79858eb146cca4ec57a1c95" translate="yes" xml:space="preserve">
          <source>Limit read rate from a device (format: &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt;). Number is a positive integer. Unit can be one of &lt;code&gt;kb&lt;/code&gt;, &lt;code&gt;mb&lt;/code&gt;, or &lt;code&gt;gb&lt;/code&gt;.</source>
          <target state="translated">장치로부터의 읽기 속도를 제한하십시오 (형식 : &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt; ). 숫자는 양의 정수입니다. 단위는 &lt;code&gt;kb&lt;/code&gt; , &lt;code&gt;mb&lt;/code&gt; 또는 &lt;code&gt;gb&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e639f8c2a895f6f0cd4f52182a42df91e25f695" translate="yes" xml:space="preserve">
          <source>Limit search results (--limit)</source>
          <target state="translated">검색 결과 제한 (--limit)</target>
        </trans-unit>
        <trans-unit id="f7735eed83cdd958730bb0f11474166ad0d18c4b" translate="yes" xml:space="preserve">
          <source>Limit the CPU CFS (Completely Fair Scheduler) period</source>
          <target state="translated">CPU CFS (Completely Fair Scheduler) 기간 제한</target>
        </trans-unit>
        <trans-unit id="6f5ce2bff20a198205464e3774aa7560355d636c" translate="yes" xml:space="preserve">
          <source>Limit the CPU CFS (Completely Fair Scheduler) quota</source>
          <target state="translated">CPU CFS (Completely Fair Scheduler) 할당량 제한</target>
        </trans-unit>
        <trans-unit id="789e84b9433da0dd7efba6cf7f6a1c73fc7e4403" translate="yes" xml:space="preserve">
          <source>Limit the CPU real-time period in microseconds</source>
          <target state="translated">CPU 실시간 기간을 마이크로 초로 제한</target>
        </trans-unit>
        <trans-unit id="c0c4b39e9c7f6b874afde7463ca6c8f25970d13c" translate="yes" xml:space="preserve">
          <source>Limit the CPU real-time period. In microseconds. Requires parent cgroups be set and cannot be higher than parent. Also check rtprio ulimits.</source>
          <target state="translated">CPU 실시간 기간을 제한하십시오. 마이크로 초 상위 cgroup을 설정해야하며 상위보다 높을 수 없습니다. rtprio ulimits도 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="333468a78a2d552c701e18343fe458c15f9906e9" translate="yes" xml:space="preserve">
          <source>Limit the CPU real-time runtime in microseconds</source>
          <target state="translated">마이크로 초 단위로 CPU 실시간 런타임 제한</target>
        </trans-unit>
        <trans-unit id="3cdd3b8a6d509b820e98d743c0e5bb6bf5c010eb" translate="yes" xml:space="preserve">
          <source>Limit the CPU real-time runtime. In microseconds. Requires parent cgroups be set and cannot be higher than parent. Also check rtprio ulimits.</source>
          <target state="translated">CPU 실시간 런타임을 제한하십시오. 마이크로 초 상위 cgroup을 설정해야하며 상위보다 높을 수 없습니다. rtprio ulimits도 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7f2bcc046711665c85da86062a74532aa7a1dc43" translate="yes" xml:space="preserve">
          <source>Limit write rate (IO per second) to a device</source>
          <target state="translated">쓰기 속도 (초당 IO)를 장치로 제한</target>
        </trans-unit>
        <trans-unit id="c9922ee4978e4049ddd400ba67d96efff2171950" translate="yes" xml:space="preserve">
          <source>Limit write rate (IO per second) to a device (format: &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;&lt;/code&gt;). Number is a positive integer.</source>
          <target state="translated">쓰기 속도 (초당 IO)를 장치로 제한합니다 (형식 : &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;&lt;/code&gt; ). 숫자는 양의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4992dc5d324dac7ebda270b77aca5bc6e30bfdd9" translate="yes" xml:space="preserve">
          <source>Limit write rate (bytes per second) to a device</source>
          <target state="translated">쓰기 속도 (초당 바이트)를 장치로 제한</target>
        </trans-unit>
        <trans-unit id="be0fd00e311ad24cbd1bbb3e6eed4f4f57e26ab3" translate="yes" xml:space="preserve">
          <source>Limit write rate to a device (format: &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt;). Number is a positive integer. Unit can be one of &lt;code&gt;kb&lt;/code&gt;, &lt;code&gt;mb&lt;/code&gt;, or &lt;code&gt;gb&lt;/code&gt;.</source>
          <target state="translated">쓰기 속도를 장치로 제한하십시오 (형식 : &lt;code&gt;&amp;lt;device-path&amp;gt;:&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt; ). 숫자는 양의 정수입니다. 단위는 &lt;code&gt;kb&lt;/code&gt; , &lt;code&gt;mb&lt;/code&gt; 또는 &lt;code&gt;gb&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b7596ff1238f8df765b40659c83776be05373a56" translate="yes" xml:space="preserve">
          <source>Limiting, filtering, and formatting the output</source>
          <target state="translated">출력 제한, 필터링 및 서식</target>
        </trans-unit>
        <trans-unit id="ec7b9415694864df137a4389f991b6c947560195" translate="yes" xml:space="preserve">
          <source>Line 3 does not cause a cache miss because the value of &lt;code&gt;CONT_IMG_VER&lt;/code&gt; is a constant (&lt;code&gt;hello&lt;/code&gt;). As a result, the environment variables and values used on the &lt;code&gt;RUN&lt;/code&gt; (line 4) doesn&amp;rsquo;t change between builds.</source>
          <target state="translated">&lt;code&gt;CONT_IMG_VER&lt;/code&gt; 의 값이 상수 ( &lt;code&gt;hello&lt;/code&gt; ) 이므로 3 행은 캐시 누락을 유발하지 않습니다 . 결과적으로 &lt;code&gt;RUN&lt;/code&gt; (라인 4) 에 사용 된 환경 변수 및 값 은 빌드간에 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1869e6febd7924369fbc139ed2fcfc1594840b74" translate="yes" xml:space="preserve">
          <source>Line continuation characters are not supported in comments.</source>
          <target state="translated">주석에서 줄 연속 문자는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efc0cb77f949404327a42f6983fafeef43add97b" translate="yes" xml:space="preserve">
          <source>Lines beginning with &lt;code&gt;#&lt;/code&gt; are processed as comments and ignored.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 주석으로 처리되어 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="29cc00769343477bee1b880ba16556a50636e224" translate="yes" xml:space="preserve">
          <source>Lines starting with &lt;code&gt;!&lt;/code&gt; (exclamation mark) can be used to make exceptions to exclusions. The following is an example &lt;code&gt;.dockerignore&lt;/code&gt; file that uses this mechanism:</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 로 시작하는 줄 (느낌표)를 사용하여 제외를 제외 할 수 있습니다. 다음은 이 메커니즘을 사용하는 &lt;code&gt;.dockerignore&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f97ee74e79e216e226115d1e59d8fc209a21cfb8" translate="yes" xml:space="preserve">
          <source>Link Debian-based containers to the APT proxy container using &lt;code&gt;--link&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--link&lt;/code&gt; 를 사용하여 데비안 기반 컨테이너를 APT 프록시 컨테이너에 연결</target>
        </trans-unit>
        <trans-unit id="c7876b7880f64e23aa3336be2b53e9265816b2df" translate="yes" xml:space="preserve">
          <source>Link environment variables (superseded)</source>
          <target state="translated">링크 환경 변수 (대체 됨)</target>
        </trans-unit>
        <trans-unit id="87c10d61d3bef8e681d492689759c80c1cee9a11" translate="yes" xml:space="preserve">
          <source>Link to containers in another service. Either specify both the service name and a link alias (&lt;code&gt;&quot;SERVICE:ALIAS&quot;&lt;/code&gt;), or just the service name.</source>
          <target state="translated">다른 서비스의 컨테이너에 연결하십시오. 서비스 이름과 링크 별명 ( &lt;code&gt;&quot;SERVICE:ALIAS&quot;&lt;/code&gt; ) 또는 서비스 이름 만 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="86aafc1b11e524eb5c4c12b1e9e277b5545e080d" translate="yes" xml:space="preserve">
          <source>Link to containers in another service. Either specify both the service name and a link alias (&lt;code&gt;SERVICE:ALIAS&lt;/code&gt;), or just the service name.</source>
          <target state="translated">다른 서비스의 컨테이너에 연결하십시오. 서비스 이름과 링크 별명 ( &lt;code&gt;SERVICE:ALIAS&lt;/code&gt; ) 또는 서비스 이름 만 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="484518142f5b4da66527db2b3b38add0a6d45502" translate="yes" xml:space="preserve">
          <source>Link to containers started outside this &lt;code&gt;docker-compose.yml&lt;/code&gt; or even outside of Compose, especially for containers that provide shared or common services. &lt;code&gt;external_links&lt;/code&gt; follow semantics similar to &lt;code&gt;links&lt;/code&gt; when specifying both the container name and the link alias (&lt;code&gt;CONTAINER:ALIAS&lt;/code&gt;).</source>
          <target state="translated">이 &lt;code&gt;docker-compose.yml&lt;/code&gt; 외부 또는 Compose 외부에서 시작된 컨테이너 , 특히 공유 또는 공통 서비스를 제공하는 컨테이너에 대한 링크. &lt;code&gt;external_links&lt;/code&gt; 는 컨테이너 이름과 링크 별명 ( &lt;code&gt;CONTAINER:ALIAS&lt;/code&gt; )을 모두 지정할 때 &lt;code&gt;links&lt;/code&gt; 와 유사한 의미를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="a8397ad390f68b47916c39e529c9d869134015d2" translate="yes" xml:space="preserve">
          <source>Link to containers started outside this &lt;code&gt;docker-compose.yml&lt;/code&gt; or even outside of Compose, especially for containers that provide shared or common services. &lt;code&gt;external_links&lt;/code&gt; follow semantics similar to the legacy option &lt;code&gt;links&lt;/code&gt; when specifying both the container name and the link alias (&lt;code&gt;CONTAINER:ALIAS&lt;/code&gt;).</source>
          <target state="translated">이 &lt;code&gt;docker-compose.yml&lt;/code&gt; 외부 또는 Compose 외부에서 시작된 컨테이너 , 특히 공유 또는 공통 서비스를 제공하는 컨테이너에 대한 링크. &lt;code&gt;external_links&lt;/code&gt; 는 컨테이너 이름과 링크 별명 ( &lt;code&gt;CONTAINER:ALIAS&lt;/code&gt; )을 모두 지정할 때 레거시 옵션 &lt;code&gt;links&lt;/code&gt; 와 유사한 의미를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="e6e881f97b609f76613c3d1f4f3704e894e9286f" translate="yes" xml:space="preserve">
          <source>Links allow you to define extra aliases by which a service is reachable from another service. They are not required to enable services to communicate - by default, any service can reach any other service at that service&amp;rsquo;s name. In the following example, &lt;code&gt;db&lt;/code&gt; is reachable from &lt;code&gt;web&lt;/code&gt; at the hostnames &lt;code&gt;db&lt;/code&gt; and &lt;code&gt;database&lt;/code&gt;:</source>
          <target state="translated">링크를 사용하면 다른 서비스에서 서비스에 도달 할 수있는 추가 별칭을 정의 할 수 있습니다. 서비스가 통신하도록 할 필요는 없습니다. 기본적으로 모든 서비스는 해당 서비스 이름으로 다른 서비스에 도달 할 수 있습니다. 다음 예제에서는 &lt;code&gt;db&lt;/code&gt; 에서 연결할 수있는 &lt;code&gt;web&lt;/code&gt; 호스트 이름이에서 &lt;code&gt;db&lt;/code&gt; 및 &lt;code&gt;database&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2bac2f325f8b4cde931825a71eecf1b69f144f9c" translate="yes" xml:space="preserve">
          <source>Links also express dependency between services in the same way as &lt;a href=&quot;#depends_on&quot;&gt;depends_on&lt;/a&gt;, so they determine the order of service startup.</source>
          <target state="translated">링크는 또한 &lt;a href=&quot;#depends_on&quot;&gt;depend_on&lt;/a&gt; 과 같은 방식으로 서비스 간의 종속성을 표시 하므로 서비스 시작 순서를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="60dbf3750c69e99f351f3bdeed18d7b9e4206360" translate="yes" xml:space="preserve">
          <source>Links are a legacy option. We recommend using &lt;a href=&quot;#networks&quot;&gt;networks&lt;/a&gt; instead.</source>
          <target state="translated">링크는 레거시 옵션입니다. 대신 &lt;a href=&quot;#networks&quot;&gt;네트워크&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5e25946ba1640260fbe1b909c4ceb3bf1af1a235" translate="yes" xml:space="preserve">
          <source>Links are not required to enable services to communicate - by default, any service can reach any other service at that service&amp;rsquo;s name. (See also, the &lt;a href=&quot;../networking/index#links&quot;&gt;Links topic in Networking in Compose&lt;/a&gt;.)</source>
          <target state="translated">서비스가 통신 할 수 있도록하는 링크는 필요하지 않습니다. 기본적으로 모든 서비스는 해당 서비스 이름으로 다른 서비스에 도달 할 수 있습니다. ( &lt;a href=&quot;../networking/index#links&quot;&gt;Compose in Compose&lt;/a&gt; 의 링크 주제 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d82d60ec9a24b5a6f0524c417588ca2580c02065" translate="yes" xml:space="preserve">
          <source>Linode</source>
          <target state="translated">Linode</target>
        </trans-unit>
        <trans-unit id="a2027041fe4263007b370f971253b31310333a1d" translate="yes" xml:space="preserve">
          <source>Linode user accounts (separated by commas) whose Linode SSH keys will be permitted root access to the created node</source>
          <target state="translated">Linode SSH 키가 작성된 노드에 대한 루트 액세스가 허용되는 Linode 사용자 계정 (쉼표로 구분)</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="2c07cfa1b4b3e69a24753c2168f87812146bd633" translate="yes" xml:space="preserve">
          <source>Linux CentOS 7.3 64-bit</source>
          <target state="translated">Linux CentOS 7.3 64 비트</target>
        </trans-unit>
        <trans-unit id="ce13955787a40983390a0ee68bae105a8a5d72ad" translate="yes" xml:space="preserve">
          <source>Linux CoreOS stable 1298 64-bit</source>
          <target state="translated">Linux CoreOS 안정적인 1298 64 비트</target>
        </trans-unit>
        <trans-unit id="9b7d6fcf1d2cc3e82b0e1cca9f3aa07282debce0" translate="yes" xml:space="preserve">
          <source>Linux Debian 8 64-bit</source>
          <target state="translated">리눅스 데비안 8 64 비트</target>
        </trans-unit>
        <trans-unit id="205a061e02ef72db64928de7ffe13d452aa2af97" translate="yes" xml:space="preserve">
          <source>Linux Ubuntu 16.04 LTS 64-bit</source>
          <target state="translated">리눅스 우분투 16.04 LTS 64 비트</target>
        </trans-unit>
        <trans-unit id="8819772a62a544825201c3e9b1135c6d8be1ba45" translate="yes" xml:space="preserve">
          <source>Linux kernel capabilities</source>
          <target state="translated">리눅스 커널 기능</target>
        </trans-unit>
        <trans-unit id="790f67048303a5620d45b68634aff9bc07eaadeb" translate="yes" xml:space="preserve">
          <source>Linux namespaces provide isolation for running processes, limiting their access to system resources without the running process being aware of the limitations. For more information on Linux namespaces, see &lt;a href=&quot;https://www.linux.com/news/understanding-and-securing-linux-namespaces&quot;&gt;Linux namespaces&lt;/a&gt;.</source>
          <target state="translated">Linux 네임 스페이스는 실행중인 프로세스에 대한 격리를 제공하여 실행중인 프로세스가 한계를 인식하지 않고도 시스템 리소스에 대한 액세스를 제한합니다. 리눅스 네임 스페이스에 대한 자세한 내용은 &lt;a href=&quot;https://www.linux.com/news/understanding-and-securing-linux-namespaces&quot;&gt;리눅스 네임 스페이스를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2838af98b4b6c7ef3d6b872be1a873b7dd4b936e" translate="yes" xml:space="preserve">
          <source>List all networks</source>
          <target state="translated">모든 네트워크 나열</target>
        </trans-unit>
        <trans-unit id="40bb7b841c189c1207e8ca5a4b263d8cf1a8e6e5" translate="yes" xml:space="preserve">
          <source>List all port bindings</source>
          <target state="translated">모든 포트 바인딩 나열</target>
        </trans-unit>
        <trans-unit id="d7235aa41cf1aec9166f78f0cd48819d4765c04a" translate="yes" xml:space="preserve">
          <source>List all the volumes known to Docker. You can filter using the &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt; flag. Refer to the &lt;a href=&quot;#filtering&quot;&gt;filtering&lt;/a&gt; section for more information about available filter options.</source>
          <target state="translated">Docker에 알려진 모든 볼륨을 나열하십시오. &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; 플래그를 사용하여 필터링 할 수 있습니다 . 참고하여주십시오 &lt;a href=&quot;#filtering&quot;&gt;필터링&lt;/a&gt; 가능한 필터 옵션에 대한 자세한 내용은 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b88e5db4cc0338756f238d5480460e09b34ea18" translate="yes" xml:space="preserve">
          <source>List available machines again to see your newly minted machine.</source>
          <target state="translated">새로 발행 된 기계를 보려면 사용 가능한 기계를 다시 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="0c327c1b3a27207a9fe6629ef11d8639e3b7035c" translate="yes" xml:space="preserve">
          <source>List checkpoints for a container</source>
          <target state="translated">컨테이너의 체크 포인트 나열</target>
        </trans-unit>
        <trans-unit id="bc5328c6d7d8da3449569ae103330d4a4e02fbe3" translate="yes" xml:space="preserve">
          <source>List configs</source>
          <target state="translated">구성 목록</target>
        </trans-unit>
        <trans-unit id="8bb351fa7e3312da5f08749108a54beb36655c4b" translate="yes" xml:space="preserve">
          <source>List containers</source>
          <target state="translated">컨테이너 목록</target>
        </trans-unit>
        <trans-unit id="8f182980ede90ca9f275b5a71f57b1328cb327f8" translate="yes" xml:space="preserve">
          <source>List contexts</source>
          <target state="translated">컨텍스트 목록</target>
        </trans-unit>
        <trans-unit id="cd8f09bb1dceadc8d9f11cb8667293c21c93ed20" translate="yes" xml:space="preserve">
          <source>List image digests</source>
          <target state="translated">목록 이미지 요약</target>
        </trans-unit>
        <trans-unit id="b13c516aafeacc00d699cb2fcc4d66cb26ecb511" translate="yes" xml:space="preserve">
          <source>List images</source>
          <target state="translated">이미지 목록</target>
        </trans-unit>
        <trans-unit id="76ea469447b4d9367aeb1fbd5d565cfe880f3d00" translate="yes" xml:space="preserve">
          <source>List images by name and tag</source>
          <target state="translated">이름과 태그로 이미지 나열</target>
        </trans-unit>
        <trans-unit id="c9b6d4e65a8f908773085e3302723c630af3d103" translate="yes" xml:space="preserve">
          <source>List images used by the created containers.</source>
          <target state="translated">작성된 컨테이너가 사용하는 이미지를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="0706e32189e936258f5f8e476e1b9500917d3508" translate="yes" xml:space="preserve">
          <source>List networks</source>
          <target state="translated">네트워크 목록</target>
        </trans-unit>
        <trans-unit id="78cc321a062d536414c2c53089104b56cd6786b2" translate="yes" xml:space="preserve">
          <source>List nodes</source>
          <target state="translated">노드 목록</target>
        </trans-unit>
        <trans-unit id="18b6660178827d0f5c4205a62a705cb782317996" translate="yes" xml:space="preserve">
          <source>List nodes in the swarm</source>
          <target state="translated">떼의 노드 목록</target>
        </trans-unit>
        <trans-unit id="caa02be720da1273161fa778f2f5f67326ae56f1" translate="yes" xml:space="preserve">
          <source>List of custom DNS options to be added to the container&amp;rsquo;s &lt;code&gt;resolv.conf&lt;/code&gt; file.</source>
          <target state="translated">컨테이너의 &lt;code&gt;resolv.conf&lt;/code&gt; 파일에 추가 할 사용자 지정 DNS 옵션 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="03ea6b50907f36932282d0cc70f3288755fe45a2" translate="yes" xml:space="preserve">
          <source>List of device mappings. Uses the same format as the &lt;code&gt;--device&lt;/code&gt; docker client create option.</source>
          <target state="translated">장치 매핑 목록 &lt;code&gt;--device&lt;/code&gt; docker client create 옵션 과 동일한 형식을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b51e700970226505ea301d54671633f68040d0e3" translate="yes" xml:space="preserve">
          <source>List plugins</source>
          <target state="translated">플러그인 목록</target>
        </trans-unit>
        <trans-unit id="b3b2bef9ac5bcb664439b922e710bcdf18fab96c" translate="yes" xml:space="preserve">
          <source>List port mappings or a specific mapping for the container</source>
          <target state="translated">컨테이너에 대한 포트 매핑 또는 특정 매핑 나열</target>
        </trans-unit>
        <trans-unit id="68d19609739791f5315f90167b560940cf03d6fe" translate="yes" xml:space="preserve">
          <source>List running containers.</source>
          <target state="translated">실행중인 컨테이너를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="1fcd8854f78e944ea272742ba13ccc8c1045f3df" translate="yes" xml:space="preserve">
          <source>List secrets</source>
          <target state="translated">비밀 목록</target>
        </trans-unit>
        <trans-unit id="d4ecef6101d8ecc6539c9e100e748e7cdcf80083" translate="yes" xml:space="preserve">
          <source>List services</source>
          <target state="translated">서비스 목록</target>
        </trans-unit>
        <trans-unit id="6e806dc602a149f409f1097b774f91e9089331cc" translate="yes" xml:space="preserve">
          <source>List stacks</source>
          <target state="translated">리스트 스택</target>
        </trans-unit>
        <trans-unit id="430adfa4648aa8c61169a2b40d5a716d7724de51" translate="yes" xml:space="preserve">
          <source>List stacks from all Kubernetes namespaces</source>
          <target state="translated">모든 Kubernetes 네임 스페이스의 스택 목록</target>
        </trans-unit>
        <trans-unit id="865dfd4c6b218f100164d373140c6fac4f71cbd6" translate="yes" xml:space="preserve">
          <source>List tasks running on one or more nodes, defaults to current node</source>
          <target state="translated">하나 이상의 노드에서 실행중인 작업을 나열합니다. 기본값은 현재 노드입니다.</target>
        </trans-unit>
        <trans-unit id="49770902aa6d3bc2df13ff4849470290e3e98c86" translate="yes" xml:space="preserve">
          <source>List the &lt;code&gt;hello-world&lt;/code&gt; container (spawned by the image) which exits after displaying its message. If it were still running, you would not need the &lt;code&gt;--all&lt;/code&gt; option:</source>
          <target state="translated">메시지를 표시 한 후 종료되는 &lt;code&gt;hello-world&lt;/code&gt; 컨테이너 (이미지로 생성됨)를 나열하십시오 . 여전히 실행 중이면 &lt;code&gt;--all&lt;/code&gt; 옵션이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3f37c164e1544d1e37b3454c4556f9a77f4ef9c2" translate="yes" xml:space="preserve">
          <source>List the &lt;code&gt;hello-world&lt;/code&gt; image that was downloaded to your machine:</source>
          <target state="translated">컴퓨터에 다운로드 한 &lt;code&gt;hello-world&lt;/code&gt; 이미지를 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="5005f9952c8b357c438ed994f317e744101a15e2" translate="yes" xml:space="preserve">
          <source>List the &lt;code&gt;trusttest&lt;/code&gt; image.</source>
          <target state="translated">&lt;code&gt;trusttest&lt;/code&gt; 이미지를 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce59177e14fc321242b1018a9e43372b4a3e4af5" translate="yes" xml:space="preserve">
          <source>List the VMs and get their IP addresses</source>
          <target state="translated">VM을 나열하고 해당 IP 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e72a8b848ca6ce5991b107c22c169938afc0bbca" translate="yes" xml:space="preserve">
          <source>List the changed files and directories in a container᾿s filesystem since the container was created. Three different types of change are tracked:</source>
          <target state="translated">컨테이너가 작성된 이후 컨테이너의 파일 시스템에서 변경된 파일과 디렉토리를 나열하십시오. 세 가지 유형의 변경 사항이 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="5e47629788ef59615965e0ab987a91779695ed47" translate="yes" xml:space="preserve">
          <source>List the configs:</source>
          <target state="translated">구성을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="16593cd5ca907c12a252dc93b8399209897a9a69" translate="yes" xml:space="preserve">
          <source>List the files.</source>
          <target state="translated">파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="0fc38bb955af9d847c19ab762e511c4de3c6ebb1" translate="yes" xml:space="preserve">
          <source>List the full length image IDs</source>
          <target state="translated">전체 길이 이미지 ID 나열</target>
        </trans-unit>
        <trans-unit id="9d374f51f68ed10c1f49c201a021c5b5138f0004" translate="yes" xml:space="preserve">
          <source>List the layers for the &lt;code&gt;test/trusttest&lt;/code&gt; image you pushed:</source>
          <target state="translated">푸시 한 &lt;code&gt;test/trusttest&lt;/code&gt; 이미지 의 레이어를 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="c47769ec83bd93b7233a0682e68411ace67b89ed" translate="yes" xml:space="preserve">
          <source>List the most recently created images</source>
          <target state="translated">가장 최근에 생성 된 이미지 나열</target>
        </trans-unit>
        <trans-unit id="6629910125e27ed0dc2d17b4f02616921d96d6ac" translate="yes" xml:space="preserve">
          <source>List the secrets managed by Docker using &lt;code&gt;docker secret ls&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;docker secret ls&lt;/code&gt; 를 사용하여 Docker가 관리하는 비밀을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="746760a443c880cdc253b25543feb939d6ae57b9" translate="yes" xml:space="preserve">
          <source>List the services in the stack</source>
          <target state="translated">스택에 서비스 나열</target>
        </trans-unit>
        <trans-unit id="e1b7ee72f6984f5d1b685b067f7177553fcadf2e" translate="yes" xml:space="preserve">
          <source>List the tasks in the stack</source>
          <target state="translated">스택에 작업을 나열</target>
        </trans-unit>
        <trans-unit id="5262554c47a5fb2aa6e20f0a1a505f1f0da376a9" translate="yes" xml:space="preserve">
          <source>List the tasks of one or more services</source>
          <target state="translated">하나 이상의 서비스 작업을 나열합니다</target>
        </trans-unit>
        <trans-unit id="d64607aec9402008dd36f9a57a795a2a3e0384bd" translate="yes" xml:space="preserve">
          <source>List the tasks that are part of a service</source>
          <target state="translated">서비스의 일부인 작업 나열</target>
        </trans-unit>
        <trans-unit id="e8a311051da06229cd61412dc166e82eb44aced8" translate="yes" xml:space="preserve">
          <source>List the tasks that are part of a stack</source>
          <target state="translated">스택의 일부인 작업을 나열합니다</target>
        </trans-unit>
        <trans-unit id="2746c081f46f43691a571d7371c32add210c7124" translate="yes" xml:space="preserve">
          <source>List volumes</source>
          <target state="translated">볼륨 목록</target>
        </trans-unit>
        <trans-unit id="662c6fa833e13fe960bde5ee21766869d06308c1" translate="yes" xml:space="preserve">
          <source>Listen address (format: &amp;lt;ip|interface&amp;gt;[:port])</source>
          <target state="translated">수신 주소 (형식 : &amp;lt;ip | 인터페이스&amp;gt; [: 포트])</target>
        </trans-unit>
        <trans-unit id="07cc28daecd8326008e3448372e96c703d00095b" translate="yes" xml:space="preserve">
          <source>Listing images at this point should return &lt;code&gt;redis&lt;/code&gt; and &lt;code&gt;web&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 이미지를 나열하면 &lt;code&gt;redis&lt;/code&gt; 및 &lt;code&gt;web&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="58971a4ba23dd0cf3b8f451a2d9faaae3bda607b" translate="yes" xml:space="preserve">
          <source>Lists all machines and their status.</source>
          <target state="translated">모든 컴퓨터와 해당 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4f60cd7bd99f8aa7412a08e0648e5e447a283cd3" translate="yes" xml:space="preserve">
          <source>Lists all the networks the Engine &lt;code&gt;daemon&lt;/code&gt; knows about. This includes the networks that span across multiple hosts in a cluster.</source>
          <target state="translated">엔진 &lt;code&gt;daemon&lt;/code&gt; 알고 있는 모든 네트워크를 나열합니다 . 여기에는 클러스터의 여러 호스트에 걸쳐있는 네트워크가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bdec6ccc84c4909ad8a8bbf17aef9101d65e48" translate="yes" xml:space="preserve">
          <source>Lists all the nodes that the Docker Swarm manager knows about. You can filter using the &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt; flag. Refer to the &lt;a href=&quot;#filtering&quot;&gt;filtering&lt;/a&gt; section for more information about available filter options.</source>
          <target state="translated">Docker Swarm 관리자가 알고있는 모든 노드를 나열합니다. &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; 플래그를 사용하여 필터링 할 수 있습니다 . 참고하여주십시오 &lt;a href=&quot;#filtering&quot;&gt;필터링&lt;/a&gt; 가능한 필터 옵션에 대한 자세한 내용은 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2cf1410f712c10b4e82b71c18d0172c27bc29782" translate="yes" xml:space="preserve">
          <source>Lists all the plugins that are currently installed. You can install plugins using the &lt;a href=&quot;../plugin_install/index&quot;&gt;&lt;code&gt;docker plugin install&lt;/code&gt;&lt;/a&gt; command. You can also filter using the &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt; flag. Refer to the &lt;a href=&quot;#filtering&quot;&gt;filtering&lt;/a&gt; section for more information about available filter options.</source>
          <target state="translated">현재 설치된 모든 플러그인을 나열합니다. &lt;a href=&quot;../plugin_install/index&quot;&gt; &lt;code&gt;docker plugin install&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 플러그인을 설치할 수 있습니다 . &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; 플래그를 사용하여 필터링 할 수도 있습니다 . 참고하여주십시오 &lt;a href=&quot;#filtering&quot;&gt;필터링&lt;/a&gt; 가능한 필터 옵션에 대한 자세한 내용은 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e893a1516daf55a8e6ffc8e75fb75168abdb2cca" translate="yes" xml:space="preserve">
          <source>Lists all the tasks on a Node that Docker knows about. You can filter using the &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt; flag. Refer to the &lt;a href=&quot;#filtering&quot;&gt;filtering&lt;/a&gt; section for more information about available filter options.</source>
          <target state="translated">Docker가 알고있는 노드의 모든 작업을 나열합니다. &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; 플래그를 사용하여 필터링 할 수 있습니다 . 참고하여주십시오 &lt;a href=&quot;#filtering&quot;&gt;필터링&lt;/a&gt; 가능한 필터 옵션에 대한 자세한 내용은 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a76d0cc8a8f211bf884194672828fcff07859e2e" translate="yes" xml:space="preserve">
          <source>Lists containers.</source>
          <target state="translated">컨테이너를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="ce43d09e478cac45d874a48b4d6533cdaa8fd60c" translate="yes" xml:space="preserve">
          <source>Lists the services that are running as part of the specified stack. This command has to be run targeting a manager node.</source>
          <target state="translated">지정된 스택의 일부로 실행중인 서비스를 나열합니다. 이 명령은 관리자 노드를 대상으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b30da6ba44aca1fb97e64aaf80cbdb1ec3381042" translate="yes" xml:space="preserve">
          <source>Lists the stacks.</source>
          <target state="translated">스택을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="07f04fb94cc0ac57eab880d85581b8e5c03833df" translate="yes" xml:space="preserve">
          <source>Lists the tasks that are running as part of the specified services. This command has to be run targeting a manager node.</source>
          <target state="translated">지정된 서비스의 일부로 실행중인 작업을 나열합니다. 이 명령은 관리자 노드를 대상으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c621d822c718d7fe1e0ebf7c1fed844f01f9929" translate="yes" xml:space="preserve">
          <source>Lists the tasks that are running as part of the specified stack. This command has to be run targeting a manager node.</source>
          <target state="translated">지정된 스택의 일부로 실행중인 작업을 나열합니다. 이 명령은 관리자 노드를 대상으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2703b349699d206d5ce77d3da54d44d9fac1164a" translate="yes" xml:space="preserve">
          <source>Load a private key file for signing</source>
          <target state="translated">서명을위한 개인 키 파일로드</target>
        </trans-unit>
        <trans-unit id="d32390f64d5a52dad51f085a292fbc4f3ffb1dc9" translate="yes" xml:space="preserve">
          <source>Load an image from a tar archive or STDIN</source>
          <target state="translated">tar 아카이브 또는 STDIN에서 이미지로드</target>
        </trans-unit>
        <trans-unit id="047b84a623801df7b60f0a8b82f56c09d18f25a7" translate="yes" xml:space="preserve">
          <source>Load an image or repository from a tar archive (even if compressed with gzip, bzip2, or xz) from a file or STDIN. It restores both images and tags.</source>
          <target state="translated">파일 또는 STDIN에서 tar 아카이브 (gzip, bzip2 또는 xz로 압축 된 경우에도)에서 이미지 또는 저장소를로드하십시오. 이미지와 태그를 모두 복원합니다.</target>
        </trans-unit>
        <trans-unit id="f7d0f3b665bde02eb354220bdc78d45e667b1f22" translate="yes" xml:space="preserve">
          <source>Load and unload kernel modules.</source>
          <target state="translated">커널 모듈을로드 및 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="aaf1f52c9a2d4feb27bbbb876002c94c6d5cec47" translate="yes" xml:space="preserve">
          <source>Load and unload profiles</source>
          <target state="translated">프로파일로드 및 언로드</target>
        </trans-unit>
        <trans-unit id="6afb192e8876001093b7d61830ada7231e1990f5" translate="yes" xml:space="preserve">
          <source>Load balancing</source>
          <target state="translated">로드 밸런싱</target>
        </trans-unit>
        <trans-unit id="eb7dd0e1f5b6510ea89d8bbe27d4c334c2adcb1e" translate="yes" xml:space="preserve">
          <source>Load the profile.</source>
          <target state="translated">프로파일을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="091ee31687d15dde3475376fd5b229cea63cfd02" translate="yes" xml:space="preserve">
          <source>Local Persist Plugin</source>
          <target state="translated">로컬 지속 플러그인</target>
        </trans-unit>
        <trans-unit id="1136b923a502c5338b5a576817a04209e2327c4b" translate="yes" xml:space="preserve">
          <source>Local VMs (Mac, Linux, Windows 7 and 8)</source>
          <target state="translated">로컬 VM (Mac, Linux, Windows 7 및 8)</target>
        </trans-unit>
        <trans-unit id="f1be9945b24ef43d7c0a28c6b262ff1c9d661c5b" translate="yes" xml:space="preserve">
          <source>Local VMs (Windows 10/Hyper-V)</source>
          <target state="translated">로컬 VM (Windows 10 / Hyper-V)</target>
        </trans-unit>
        <trans-unit id="ad0c8070cfe29a915099cd99fa3849b7e4fbce89" translate="yes" xml:space="preserve">
          <source>Local name for plugin</source>
          <target state="translated">플러그인의 로컬 이름</target>
        </trans-unit>
        <trans-unit id="551878825e1bf75204a6ee2e060d910121100cbe" translate="yes" xml:space="preserve">
          <source>Local registries, whose IP address falls in the 127.0.0.0/8 range, are automatically marked as insecure as of Docker 1.3.2. It is not recommended to rely on this, as it may change in the future.</source>
          <target state="translated">IP 주소가 127.0.0.0/8 범위에있는 로컬 레지스트리는 Docker 1.3.2에서 안전하지 않은 것으로 자동 표시됩니다. 향후 변경 될 수 있으므로이 방법을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f57e9597beada07ee4246d5954338aa928b267c6" translate="yes" xml:space="preserve">
          <source>Local trust service example:</source>
          <target state="translated">로컬 트러스트 서비스 예 :</target>
        </trans-unit>
        <trans-unit id="d758cb891cf8299f0470e63bb5e13d4a830cc110" translate="yes" xml:space="preserve">
          <source>Locate the VPC ID you want from the &lt;em&gt;_VPC_&lt;/em&gt; column.</source>
          <target state="translated">&lt;em&gt;_VPC_&lt;/em&gt; 열 에서 원하는 VPC ID를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="e04c480bbb93d626b524b227016a1e35249c3b62" translate="yes" xml:space="preserve">
          <source>Lock memory (mlock(2), mlockall(2), mmap(2), shmctl(2)).</source>
          <target state="translated">메모리 잠금 (mlock (2), mlockall (2), mmap (2), shmctl (2)).</target>
        </trans-unit>
        <trans-unit id="79a4e7d6bafeb38d6a59ec2582f1494f3513b40a" translate="yes" xml:space="preserve">
          <source>Lock your swarm to protect its encryption key</source>
          <target state="translated">암호화 키를 보호하기 위해 떼를 잠그십시오</target>
        </trans-unit>
        <trans-unit id="08c7b674da323ca6c5f64898ac7aef9591ba113a" translate="yes" xml:space="preserve">
          <source>Log driver options</source>
          <target state="translated">로그 드라이버 옵션</target>
        </trans-unit>
        <trans-unit id="c9bcde476a874df8c92888dcc3bd588f9df7cea4" translate="yes" xml:space="preserve">
          <source>Log in to a Docker registry</source>
          <target state="translated">Docker 레지스트리에 로그인</target>
        </trans-unit>
        <trans-unit id="5439a6d504dea8006d7dfcb64edad0c29261b7e6" translate="yes" xml:space="preserve">
          <source>Log in to the Docker public registry on your local machine.</source>
          <target state="translated">로컬 머신의 Docker 공용 레지스트리에 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="5a41266340791a2fb777c87b9951d4cbb7313be4" translate="yes" xml:space="preserve">
          <source>Log in with your Docker ID</source>
          <target state="translated">Docker ID로 로그인</target>
        </trans-unit>
        <trans-unit id="7beca296e88142c52783383b05edec45bf615b09" translate="yes" xml:space="preserve">
          <source>Log into AWS with your IAM credentials, and navigate to your EC2 Running Instances.</source>
          <target state="translated">IAM 자격 증명으로 AWS에 로그인하고 EC2 Running Instances로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef4c7bc52bacf859c1a7c24985d78c109e85196" translate="yes" xml:space="preserve">
          <source>Log into or run a command on a machine using SSH.</source>
          <target state="translated">SSH를 사용하여 머신에 로그인하거나 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="430926a868ec05a889cccc0acbdb54695d7bb6ae" translate="yes" xml:space="preserve">
          <source>Log off aws-sandbox and unset this machine as active. Then list images again. You should not see hello-world (at least not with the same exited status):</source>
          <target state="translated">aws-sandbox를 로그 오프하고이 시스템을 활성으로 설정 해제하십시오. 그런 다음 이미지를 다시 나열하십시오. hello-world가 보이지 않아야합니다 (적어도 동일한 종료 상태가 아님).</target>
        </trans-unit>
        <trans-unit id="97d5c3ecfdd9a7c1d3cc9cc6529e0cf11675178a" translate="yes" xml:space="preserve">
          <source>Log on to aws-sandbox with ssh and list all containers. You should see hello-world (with a recent exited status):</source>
          <target state="translated">ssh를 사용하여 aws-sandbox에 로그온하고 모든 컨테이너를 나열하십시오. hello-world (최종 종료 상태)가 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="95e1507c064c2164207aa341c733e4a4a33d287c" translate="yes" xml:space="preserve">
          <source>Log out from a Docker registry</source>
          <target state="translated">Docker 레지스트리에서 로그 아웃</target>
        </trans-unit>
        <trans-unit id="1bad184e71db4b7b2c6d7db40597ca1156069695" translate="yes" xml:space="preserve">
          <source>Log tags are now generated in a standard way across different logging drivers. Because of which, the driver specific log tag options &lt;code&gt;syslog-tag&lt;/code&gt;, &lt;code&gt;gelf-tag&lt;/code&gt; and &lt;code&gt;fluentd-tag&lt;/code&gt; have been deprecated in favor of the generic &lt;code&gt;tag&lt;/code&gt; option.</source>
          <target state="translated">이제 로그 태그는 여러 로깅 드라이버에서 표준 방식으로 생성됩니다. 때문에 어떤 드라이버 특정 로그 태그 옵션의 &lt;code&gt;syslog-tag&lt;/code&gt; , &lt;code&gt;gelf-tag&lt;/code&gt; 및 &lt;code&gt;fluentd-tag&lt;/code&gt; 일반에 찬성 사용되지 않습니다 &lt;code&gt;tag&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6311a15cb719e67c88f2ab21e25917e54cfb90a3" translate="yes" xml:space="preserve">
          <source>Logging configuration for the service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3995f4794095f38da456c451e8de607ccb0ddc2e" translate="yes" xml:space="preserve">
          <source>Logging driver for service</source>
          <target state="translated">서비스 용 로깅 드라이버</target>
        </trans-unit>
        <trans-unit id="b707340cec842d91fd39d9ab2d21b97944d61d2e" translate="yes" xml:space="preserve">
          <source>Logging driver for the container</source>
          <target state="translated">컨테이너의 로깅 드라이버</target>
        </trans-unit>
        <trans-unit id="e61f2b47e7b82e0012066d7214e394b8fd0247cd" translate="yes" xml:space="preserve">
          <source>Logging driver options</source>
          <target state="translated">로깅 드라이버 옵션</target>
        </trans-unit>
        <trans-unit id="8af7be6a41432aa0cc26283b2756ea1f67c02c97" translate="yes" xml:space="preserve">
          <source>Logging drivers (--log-driver)</source>
          <target state="translated">로깅 드라이버 (--log-driver)</target>
        </trans-unit>
        <trans-unit id="50093938a8bb1b2c32f5651f3f6d4e878614bca8" translate="yes" xml:space="preserve">
          <source>Logging options are key-value pairs. An example of &lt;code&gt;syslog&lt;/code&gt; options:</source>
          <target state="translated">로깅 옵션은 키-값 쌍입니다. &lt;code&gt;syslog&lt;/code&gt; 옵션 의 예 :</target>
        </trans-unit>
        <trans-unit id="c0a0572405e41f41804d4705577111810b222882" translate="yes" xml:space="preserve">
          <source>Logging options available depend on which logging driver you use</source>
          <target state="translated">사용 가능한 로깅 옵션은 사용하는 로깅 드라이버에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2dc6355727dcecb8cabec8c057c09014af22668d" translate="yes" xml:space="preserve">
          <source>Login to a registry.</source>
          <target state="translated">레지스트리에 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="aa474ece40f3d12ea7394779458269289031690e" translate="yes" xml:space="preserve">
          <source>Login to a self-hosted registry</source>
          <target state="translated">자체 호스팅 레지스트리에 로그인</target>
        </trans-unit>
        <trans-unit id="a279144324bfb8de205b9846b281b828ebe37ec1" translate="yes" xml:space="preserve">
          <source>Login to the AWS console.</source>
          <target state="translated">AWS 콘솔에 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="32a4ec3cd36c42b8850b25ce76e4f8962a0d8bc3" translate="yes" xml:space="preserve">
          <source>Long form syntax of &lt;code&gt;--network&lt;/code&gt; allows to specify list of aliases and driver options:</source>
          <target state="translated">&lt;code&gt;--network&lt;/code&gt; 의 긴 구문 구문을 사용하면 별명 및 드라이버 옵션 목록을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0079be04249bc215276be7ea649f7b310cc5417" translate="yes" xml:space="preserve">
          <source>Long syntax</source>
          <target state="translated">긴 구문</target>
        </trans-unit>
        <trans-unit id="b0b5cc4a3981dbccf4f67cf66a938232195de847" translate="yes" xml:space="preserve">
          <source>Look at another log line:</source>
          <target state="translated">다른 로그 라인을보십시오.</target>
        </trans-unit>
        <trans-unit id="3b9a3019f4ec0693d42b69d68ce61e085d08bfc4" translate="yes" xml:space="preserve">
          <source>Look for output for the &lt;code&gt;web&lt;/code&gt; service, prepended with your app name. If you named it the same as shown in this example, the name is &lt;code&gt;getstartedlab_web&lt;/code&gt;. The service ID is listed as well, along with the number of replicas, image name, and exposed ports.</source>
          <target state="translated">앱 이름 앞에 &lt;code&gt;web&lt;/code&gt; 서비스의 출력을 찾으십시오 . 이 예제와 같이 이름을 지정한 경우 이름은 &lt;code&gt;getstartedlab_web&lt;/code&gt; 입니다. 복제본 수, 이미지 이름 및 노출 된 포트와 함께 서비스 ID도 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="abec19580d901c89957066d47c1a2ed1e01d93bf" translate="yes" xml:space="preserve">
          <source>Looking for more detail on Docker and Compose compatibility?</source>
          <target state="translated">Docker 및 Compose 호환성에 대한 자세한 내용을 찾고 있습니까?</target>
        </trans-unit>
        <trans-unit id="2e3ea4d978a39d5c0cf8de875ed6b3912ce6f703" translate="yes" xml:space="preserve">
          <source>Looking for options to set resources on non swarm mode containers?</source>
          <target state="translated">비웜 모드 컨테이너에서 리소스를 설정하는 옵션을 찾고 있습니까?</target>
        </trans-unit>
        <trans-unit id="f4bea74d65429b644d3feea9a1038222a3b32683" translate="yes" xml:space="preserve">
          <source>Looking for the full list of available drivers?</source>
          <target state="translated">사용 가능한 드라이버의 전체 목록을 찾고 있습니까?</target>
        </trans-unit>
        <trans-unit id="5732d5744b5d38159349a11af62f3e676d72b3c7" translate="yes" xml:space="preserve">
          <source>Lost keys</source>
          <target state="translated">잃어버린 열쇠</target>
        </trans-unit>
        <trans-unit id="885185a9aa4ed2b8438f2b90b756c5a4f9bebb47" translate="yes" xml:space="preserve">
          <source>Luckily it&amp;rsquo;s very easy to define, run, and scale services with the Docker platform -- just write a &lt;code&gt;docker-compose.yml&lt;/code&gt; file.</source>
          <target state="translated">다행히 Docker 플랫폼으로 서비스를 정의, 실행 및 확장하는 것은 매우 쉽습니다 . &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일 만 작성하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="a65d72aa00c2250d3647d3d73656119f7505cd93" translate="yes" xml:space="preserve">
          <source>MAC_ADMIN</source>
          <target state="translated">MAC_ADMIN</target>
        </trans-unit>
        <trans-unit id="ee9aeb4cea3f448dfa4e2864ecc5fb9fbe166cea" translate="yes" xml:space="preserve">
          <source>MAC_OVERRIDE</source>
          <target state="translated">MAC_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="7a389eb4b1d34368319653350b3b40f02c5a2c13" translate="yes" xml:space="preserve">
          <source>MAINTAINER (deprecated)</source>
          <target state="translated">MAINTAINER (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="431aa4bbf4c09724b37b4c525c3af1e8e76e1913" translate="yes" xml:space="preserve">
          <source>MEMs in which to allow execution (0-3, 0,1)</source>
          <target state="translated">실행을 허용하는 MEM (0-3, 0,1)</target>
        </trans-unit>
        <trans-unit id="b2d4b60209f46eeb00795352c06b840a5d1aab81" translate="yes" xml:space="preserve">
          <source>MKNOD</source>
          <target state="translated">MKNOD</target>
        </trans-unit>
        <trans-unit id="08bce2d9a3206bf0d7143d86833197a8534fabc6" translate="yes" xml:space="preserve">
          <source>Mac</source>
          <target state="translated">Mac</target>
        </trans-unit>
        <trans-unit id="7ac790c1388499464df8279c8730726aef37cfb6" translate="yes" xml:space="preserve">
          <source>Mac, Linux</source>
          <target state="translated">맥, 리눅스</target>
        </trans-unit>
        <trans-unit id="65bb1b78be827ba8f92a54c7729f67f1997eb1d6" translate="yes" xml:space="preserve">
          <source>Machine</source>
          <target state="translated">Machine</target>
        </trans-unit>
        <trans-unit id="07be30e87e3efa6d900b240d30cd70e73b41ef27" translate="yes" xml:space="preserve">
          <source>Machine &lt;em&gt;was&lt;/em&gt; the &lt;em&gt;only&lt;/em&gt; way to run Docker on Mac or Windows previous to Docker v1.12. Starting with the beta program and Docker v1.12, &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker Desktop for Mac&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; are available as native apps and the better choice for this use case on newer desktops and laptops. We encourage you to try out these new apps. The installers for Docker Desktop for Mac and Docker Desktop for Windows include Docker Machine, along with Docker Compose.</source>
          <target state="translated">Docker v1.12 이전의 Mac 또는 Windows에서 Docker를 실행 하는 &lt;em&gt;유일한&lt;/em&gt; 방법 &lt;em&gt;은&lt;/em&gt; 시스템 &lt;em&gt;이었습니다&lt;/em&gt; . 베타 프로그램 및 부두 노동자의 v1.12로부터 &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Mac 용 도커 데스크톱&lt;/a&gt; 및 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows 용 도커 데스크탑은&lt;/a&gt; 기본 응용 프로그램 및 최신 데스크톱과 노트북에서이 사용 사례에 대한 더 나은 선택으로 사용할 수 있습니다. 이 새로운 앱을 사용해 보는 것이 좋습니다. Docker Desktop for Mac 및 Windows 용 Docker Desktop의 설치 프로그램에는 Docker Compose와 함께 Docker Machine이 포함되어 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4c03dee5af51924820fc1b9aeee37f4f723d43e9" translate="yes" xml:space="preserve">
          <source>Machine URL</source>
          <target state="translated">기계 URL</target>
        </trans-unit>
        <trans-unit id="4f710f49ebfbc26e3f2cfb931118f8d0db3218b2" translate="yes" xml:space="preserve">
          <source>Machine concepts and getting help</source>
          <target state="translated">기계 개념 및 도움 받기</target>
        </trans-unit>
        <trans-unit id="5a260334638a6a3b280af99fb18a3278b5d47363" translate="yes" xml:space="preserve">
          <source>Machine concepts and help</source>
          <target state="translated">기계 개념 및 도움말</target>
        </trans-unit>
        <trans-unit id="605ac44ca8f01735df8a04d197482734f3d92799" translate="yes" xml:space="preserve">
          <source>Machine drivers</source>
          <target state="translated">기계 드라이버</target>
        </trans-unit>
        <trans-unit id="73453de8707622690245a4cac3f67f1c4d2b5e6e" translate="yes" xml:space="preserve">
          <source>Machine errors</source>
          <target state="translated">기계 오류</target>
        </trans-unit>
        <trans-unit id="d4a15abfc787b19ec249457d293ea47624bed03a" translate="yes" xml:space="preserve">
          <source>Machine name</source>
          <target state="translated">기계 이름</target>
        </trans-unit>
        <trans-unit id="dda046430c84992be720bcb21bbf0649b5ae3f96" translate="yes" xml:space="preserve">
          <source>Machine state (running, stopped...)</source>
          <target state="translated">머신 상태 (실행 중, 중지 중 ...)</target>
        </trans-unit>
        <trans-unit id="b115c7962d2794af3497157fb34c391d8e96475b" translate="yes" xml:space="preserve">
          <source>Machine swarm name</source>
          <target state="translated">기계 떼 이름</target>
        </trans-unit>
        <trans-unit id="068c3d2445abdd16055dba63bd26cbd5eec7f381" translate="yes" xml:space="preserve">
          <source>Maintain the quorum of managers</source>
          <target state="translated">관리자 쿼럼 유지</target>
        </trans-unit>
        <trans-unit id="151b1d56ed2e516d72f5c029177a71763571b7f2" translate="yes" xml:space="preserve">
          <source>Majority</source>
          <target state="translated">Majority</target>
        </trans-unit>
        <trans-unit id="d0a9b15ea28679461248d4bc0247b0879a9d2543" translate="yes" xml:space="preserve">
          <source>Make arbitrary changes to file UIDs and GIDs (see chown(2)).</source>
          <target state="translated">파일 UID 및 GID를 임의로 변경하십시오 (chown (2) 참조).</target>
        </trans-unit>
        <trans-unit id="dbc091743f0ad07f28d5e79dafd08ab876d8a7ac" translate="yes" xml:space="preserve">
          <source>Make arbitrary manipulations of process GIDs and supplementary GID list.</source>
          <target state="translated">프로세스 GID 및 보조 GID 목록을 임의로 조작합니다.</target>
        </trans-unit>
        <trans-unit id="e01488d00a6eeb2062b2dfb7d42e468886182e46" translate="yes" xml:space="preserve">
          <source>Make arbitrary manipulations of process UIDs.</source>
          <target state="translated">프로세스 UID를 임의로 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="a4dba9d2be0a191a1e3160ae4416e889b676b55a" translate="yes" xml:space="preserve">
          <source>Make socket broadcasts, and listen to multicasts.</source>
          <target state="translated">소켓 브로드 캐스트를 만들고 멀티 캐스트를 듣습니다.</target>
        </trans-unit>
        <trans-unit id="8b7638e07d2029e34e3a191f76dffcc9cad24a1b" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;compinit&lt;/code&gt; is loaded or do it by adding in &lt;code&gt;~/.zshrc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~/.zshrc&lt;/code&gt; 에 추가하여 &lt;code&gt;compinit&lt;/code&gt; 가로 드 되었는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="705694b7b7502535d2dcccc182f067dedede3814" translate="yes" xml:space="preserve">
          <source>Make sure all users are using the same implementation to build your Dockerfile</source>
          <target state="translated">Dockerfile을 빌드하기 위해 모든 사용자가 동일한 구현을 사용하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6d44a61ad148d45ef2fa8e39eb502416783e93b1" translate="yes" xml:space="preserve">
          <source>Make sure bash completion is installed.</source>
          <target state="translated">bash 완료가 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="233840b9e17aed38b50ee9974ed9baa0eaffb2c8" translate="yes" xml:space="preserve">
          <source>Make sure that the machines you set up in &lt;a href=&quot;../part4/index&quot;&gt;part 4&lt;/a&gt; are running and ready. Run &lt;code&gt;docker-machine ls&lt;/code&gt; to verify this. If the machines are stopped, run &lt;code&gt;docker-machine start myvm1&lt;/code&gt; to boot the manager, followed by &lt;code&gt;docker-machine start myvm2&lt;/code&gt; to boot the worker.</source>
          <target state="translated">&lt;a href=&quot;../part4/index&quot;&gt;파트 4&lt;/a&gt; 에서 설정 한 머신 이 실행 중이고 준비되어 있는지 확인하십시오 . &lt;code&gt;docker-machine ls&lt;/code&gt; 를 실행 하여이를 확인하십시오. 머신이 중지 된 경우 &lt;code&gt;docker-machine start myvm1&lt;/code&gt; 을 실행 하여 관리자를 부팅 한 다음 &lt;code&gt;docker-machine start myvm2&lt;/code&gt; 를 실행하여 작업자를 부팅하십시오.</target>
        </trans-unit>
        <trans-unit id="b9637dac4dc0ffa59dedb0a8f5f9339cd68b1235" translate="yes" xml:space="preserve">
          <source>Make sure that the nodes to which you are deploying are correctly configured for the gMSA.</source>
          <target state="translated">배포하려는 노드가 gMSA에 대해 올바르게 구성되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a707b73a324a09d05d5ff7e77e92cedf99244233" translate="yes" xml:space="preserve">
          <source>Make sure that your Docker or Notary client trusts Notary Server&amp;rsquo;s certificate before you try to interact with the Notary server.</source>
          <target state="translated">Notary 서버와 상호 작용하기 전에 Docker 또는 Notary 클라이언트가 Notary Server의 인증서를 신뢰하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2f5d3828d514410e6ef3256714e6fef132ede964" translate="yes" xml:space="preserve">
          <source>Make sure you have &lt;a href=&quot;https://ohmyz.sh/&quot;&gt;installed &lt;code&gt;oh-my-zsh&lt;/code&gt;&lt;/a&gt; on your computer.</source>
          <target state="translated">컴퓨터에 &lt;a href=&quot;https://ohmyz.sh/&quot;&gt; &lt;code&gt;oh-my-zsh&lt;/code&gt; &lt;/a&gt; 를 설치 했는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="22da1faf840f31d1d8fda0d6c0bfaefd3ccae50f" translate="yes" xml:space="preserve">
          <source>Make sure you have &lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;the latest VirtualBox&lt;/a&gt; correctly installed on your system (either as part of an earlier Toolbox install, or manual install).</source>
          <target state="translated">시스템에 &lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;최신 VirtualBox가&lt;/a&gt; 올바르게 설치되어 있는지 확인하십시오 (이전 Toolbox 설치 또는 수동 설치의 일부로).</target>
        </trans-unit>
        <trans-unit id="ce61487bec2faf243487b5a3bb8155d7c39cb509" translate="yes" xml:space="preserve">
          <source>Make sure you have &lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;the latest VirtualBox&lt;/a&gt; correctly installed on your system. If you used &lt;a href=&quot;https://www.docker.com/products/docker-toolbox&quot;&gt;Toolbox&lt;/a&gt; or &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker Desktop for Windows&lt;/a&gt; to install Docker Machine, VirtualBox is automatically installed.</source>
          <target state="translated">&lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;최신 VirtualBox가&lt;/a&gt; 시스템에 올바르게 설치되어 있는지 확인하십시오 . &lt;a href=&quot;https://www.docker.com/products/docker-toolbox&quot;&gt;Toolbox&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Windows 용 Docker Desktop을&lt;/a&gt; 사용 하여 Docker Machine을 설치 한 경우 VirtualBox가 자동으로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="704b9f4fbac246cf05033e233f4c26af69a7c239" translate="yes" xml:space="preserve">
          <source>Make sure you have Ethernet connectivity while you are doing this.</source>
          <target state="translated">이 작업을 수행하는 동안 이더넷에 연결되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="461ffd5471dba7fbae9ef186c5e78fbaaa01b5ff" translate="yes" xml:space="preserve">
          <source>Make sure you have already installed both &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;Docker Engine&lt;/a&gt; and &lt;a href=&quot;../install/index&quot;&gt;Docker Compose&lt;/a&gt;. You don&amp;rsquo;t need to install Python or Redis, as both are provided by Docker images.</source>
          <target state="translated">&lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;Docker Engine&lt;/a&gt; 및 &lt;a href=&quot;../install/index&quot;&gt;Docker Compose를&lt;/a&gt; 모두 설치했는지 확인하십시오 . Docker 이미지에서 제공하는 Python 또는 Redis를 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="57b3e22976c9e809c712f206abd6f88267784b38" translate="yes" xml:space="preserve">
          <source>Make sure you have published the &lt;code&gt;friendlyhello&lt;/code&gt; image you created by &lt;a href=&quot;../part2/index#share-your-image&quot;&gt;pushing it to a registry&lt;/a&gt;. We use that shared image here.</source>
          <target state="translated">생성 한 &lt;code&gt;friendlyhello&lt;/code&gt; 이미지를 &lt;a href=&quot;../part2/index#share-your-image&quot;&gt;레지스트리&lt;/a&gt; 로 푸시하여 게시했는지 확인하십시오 . 여기서 공유 이미지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0bda0f339875207091c7544edceb323cfe951d5e" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re using the JSON form of &lt;code&gt;CMD&lt;/code&gt; and &lt;code&gt;ENTRYPOINT&lt;/code&gt; in your Dockerfile.</source>
          <target state="translated">&lt;code&gt;ENTRYPOINT&lt;/code&gt; 에서 JSON 형식의 &lt;code&gt;CMD&lt;/code&gt; 및 ENTRYPOINT 를 사용하고 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9501271b488dec577acb82f33c59b5118b60bd51" translate="yes" xml:space="preserve">
          <source>Make sure your shell is configured to talk to &lt;code&gt;myvm1&lt;/code&gt; (full examples are &lt;a href=&quot;../part4/index#configure-a-docker-machine-shell-to-the-swarm-manager&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">쉘이 &lt;code&gt;myvm1&lt;/code&gt; 과 통신하도록 구성되어 있는지 확인하십시오 (전체 예제는 &lt;a href=&quot;../part4/index#configure-a-docker-machine-shell-to-the-swarm-manager&quot;&gt;여기&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f977de0a41b6e0754e8b04fe8d708b903866fd23" translate="yes" xml:space="preserve">
          <source>Malicious Content</source>
          <target state="translated">악성 콘텐츠</target>
        </trans-unit>
        <trans-unit id="0aed30e53271f1442c01d076ae8ecc452aa9bc62" translate="yes" xml:space="preserve">
          <source>Manage Docker</source>
          <target state="translated">도커 관리</target>
        </trans-unit>
        <trans-unit id="bcbb760a40d4d27ed6dce122e58642ea0d762520" translate="yes" xml:space="preserve">
          <source>Manage Docker configs</source>
          <target state="translated">Docker 구성 관리</target>
        </trans-unit>
        <trans-unit id="17e939346d8036125e03af5fa4590c2aff2f7f7f" translate="yes" xml:space="preserve">
          <source>Manage Docker image manifests and manifest lists</source>
          <target state="translated">Docker 이미지 매니페스트 및 매니페스트 목록 관리</target>
        </trans-unit>
        <trans-unit id="56a6341b02815f9610632a1989d34e5bac126b50" translate="yes" xml:space="preserve">
          <source>Manage Docker secrets</source>
          <target state="translated">도커 비밀 관리</target>
        </trans-unit>
        <trans-unit id="bc33a12960955d423d50900c78fc18845d9571ff" translate="yes" xml:space="preserve">
          <source>Manage Docker stacks</source>
          <target state="translated">도커 스택 관리</target>
        </trans-unit>
        <trans-unit id="cee1ae6ad67f882f65f3946aa6d5983cccdc7d2e" translate="yes" xml:space="preserve">
          <source>Manage Docker.</source>
          <target state="translated">Docker를 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="4b15609405e5ec940d25c47397f86a5cfe053f0a" translate="yes" xml:space="preserve">
          <source>Manage Swarm</source>
          <target state="translated">스웜 관리</target>
        </trans-unit>
        <trans-unit id="f1683aad0cfdfbf2d0b0bbf98840d3993e05d53b" translate="yes" xml:space="preserve">
          <source>Manage Swarm nodes</source>
          <target state="translated">Swarm 노드 관리</target>
        </trans-unit>
        <trans-unit id="9971a524e1dcfc83599d855bf8b44b6a7a426567" translate="yes" xml:space="preserve">
          <source>Manage builds</source>
          <target state="translated">빌드 관리</target>
        </trans-unit>
        <trans-unit id="af9e697b4841239a517b39528247101a9381a00c" translate="yes" xml:space="preserve">
          <source>Manage checkpoints</source>
          <target state="translated">체크 포인트 관리</target>
        </trans-unit>
        <trans-unit id="96cc0a10b76864edc967bb5b8ee4a632103c0601" translate="yes" xml:space="preserve">
          <source>Manage containers</source>
          <target state="translated">컨테이너 관리</target>
        </trans-unit>
        <trans-unit id="bc29b4effee3ed0f46db2ad7d094e62f818c33bd" translate="yes" xml:space="preserve">
          <source>Manage containers.</source>
          <target state="translated">컨테이너를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7a321e19438bb6e3fcf3391726a46dc0a94400fa" translate="yes" xml:space="preserve">
          <source>Manage contexts</source>
          <target state="translated">컨텍스트 관리</target>
        </trans-unit>
        <trans-unit id="153e8da9310447b8bfbaf10f33fe42e84be07fca" translate="yes" xml:space="preserve">
          <source>Manage entities who can sign Docker images</source>
          <target state="translated">Docker 이미지에 서명 할 수있는 엔티티 관리</target>
        </trans-unit>
        <trans-unit id="69f0e7e25d97c19dab1a624fc1083e9fcfa09b2d" translate="yes" xml:space="preserve">
          <source>Manage images</source>
          <target state="translated">이미지 관리</target>
        </trans-unit>
        <trans-unit id="9a6a94acb397526c72b5accbffe4094a7eeade49" translate="yes" xml:space="preserve">
          <source>Manage images.</source>
          <target state="translated">이미지 관리</target>
        </trans-unit>
        <trans-unit id="6aa433092469091efc9353560598d0368d20614c" translate="yes" xml:space="preserve">
          <source>Manage join tokens</source>
          <target state="translated">가입 토큰 관리</target>
        </trans-unit>
        <trans-unit id="007eb7119a33f70ea4736b8d4a7495ae89d8d27a" translate="yes" xml:space="preserve">
          <source>Manage keys</source>
          <target state="translated">키 관리</target>
        </trans-unit>
        <trans-unit id="d833541f337049e4b6010e0dff170ddf08cb8b60" translate="yes" xml:space="preserve">
          <source>Manage keys for content trust</source>
          <target state="translated">컨텐츠 신뢰를위한 키 관리</target>
        </trans-unit>
        <trans-unit id="911e100e3b15f5c68fecd340597c6702308505e3" translate="yes" xml:space="preserve">
          <source>Manage keys for signing Docker images</source>
          <target state="translated">Docker 이미지 서명을위한 키 관리</target>
        </trans-unit>
        <trans-unit id="d6266116214fe2079c3d48e4bba4083b7bc59868" translate="yes" xml:space="preserve">
          <source>Manage networks</source>
          <target state="translated">네트워크 관리</target>
        </trans-unit>
        <trans-unit id="1bd59ff701675d05d207b9abe398a1d084b217b9" translate="yes" xml:space="preserve">
          <source>Manage networks. You can use subcommands to create, inspect, list, remove, prune, connect, and disconnect networks.</source>
          <target state="translated">네트워크를 관리하십시오. 부속 명령을 사용하여 네트워크를 작성, 검사, 나열, 제거, 제거, 연결 및 연결 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="612a2b383606d4791a6c6b6df0147f8a51c3caf5" translate="yes" xml:space="preserve">
          <source>Manage nodes in a swarm</source>
          <target state="translated">떼에서 노드 관리</target>
        </trans-unit>
        <trans-unit id="af96b1747a80ee06953359c79a995ed50a2f4956" translate="yes" xml:space="preserve">
          <source>Manage nodes.</source>
          <target state="translated">노드를 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="9910954a7e7e56c91aaebe1836d50e3b162b663e" translate="yes" xml:space="preserve">
          <source>Manage plugins</source>
          <target state="translated">플러그인 관리</target>
        </trans-unit>
        <trans-unit id="8181ae4cda527c282130ec0b7101b5bde4c41279" translate="yes" xml:space="preserve">
          <source>Manage plugins.</source>
          <target state="translated">플러그인 관리</target>
        </trans-unit>
        <trans-unit id="c9f4a785b96116e180a70609b0ee07bec8713280" translate="yes" xml:space="preserve">
          <source>Manage secrets.</source>
          <target state="translated">비밀을 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="2079ccf1541ccd5ec64fcee3b32f834c8dfb9ea5" translate="yes" xml:space="preserve">
          <source>Manage sensitive data with Docker secrets</source>
          <target state="translated">Docker 비밀로 중요한 데이터 관리</target>
        </trans-unit>
        <trans-unit id="6812ba217b8a3467171d803924a29265245a8032" translate="yes" xml:space="preserve">
          <source>Manage services</source>
          <target state="translated">서비스 관리</target>
        </trans-unit>
        <trans-unit id="504ac790264ade8bf891cd0c3e46e9c3a86327a0" translate="yes" xml:space="preserve">
          <source>Manage services.</source>
          <target state="translated">서비스를 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="22afcf33077ef6916a32a7737dc888c2b9bd6060" translate="yes" xml:space="preserve">
          <source>Manage stacks</source>
          <target state="translated">스택 관리</target>
        </trans-unit>
        <trans-unit id="459b5dd3861d81d78c5d8df728c8521ed711685c" translate="yes" xml:space="preserve">
          <source>Manage stacks.</source>
          <target state="translated">스택 관리</target>
        </trans-unit>
        <trans-unit id="7b5e56be7c1d8955cf5b48313d3250a2366e9ee2" translate="yes" xml:space="preserve">
          <source>Manage swarm security with public key infrastructure (PKI)</source>
          <target state="translated">PKI (공개 키 인프라)를 사용하여 웜 보안 관리</target>
        </trans-unit>
        <trans-unit id="2db78016cf1c6bd648339212e82488ffc4815d02" translate="yes" xml:space="preserve">
          <source>Manage the docker engine</source>
          <target state="translated">도커 엔진 관리</target>
        </trans-unit>
        <trans-unit id="2425d5ac784b7763f191dd77cbff1ea7395f037b" translate="yes" xml:space="preserve">
          <source>Manage the swarm.</source>
          <target state="translated">떼를 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="da5572562e6b0d9d3fa8bc9452d35f9c1d7808d8" translate="yes" xml:space="preserve">
          <source>Manage the unlock key</source>
          <target state="translated">잠금 해제 키 관리</target>
        </trans-unit>
        <trans-unit id="718c90560aae1370a5401b9f791672f85b5db309" translate="yes" xml:space="preserve">
          <source>Manage trust on Docker images</source>
          <target state="translated">Docker 이미지에 대한 신뢰 관리</target>
        </trans-unit>
        <trans-unit id="36f96c2ee0b65a5b7078438a3af7593b746cba13" translate="yes" xml:space="preserve">
          <source>Manage volumes</source>
          <target state="translated">볼륨 관리</target>
        </trans-unit>
        <trans-unit id="c998f5e77a97c350d1dac59e27c21c7e64ee4071" translate="yes" xml:space="preserve">
          <source>Manage volumes. You can use subcommands to create, inspect, list, remove, or prune volumes.</source>
          <target state="translated">볼륨을 관리하십시오. 부속 명령을 사용하여 볼륨을 작성, 검사, 나열, 제거 또는 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="651e6e7b2684f1d43e83282a4ba5d044dbf85a13" translate="yes" xml:space="preserve">
          <source>Manager nodes</source>
          <target state="translated">관리자 노드</target>
        </trans-unit>
        <trans-unit id="2d92c309bcee780a4a65b1669f4387c99cde3c26" translate="yes" xml:space="preserve">
          <source>Manager nodes also perform the orchestration and cluster management functions required to maintain the desired state of the swarm. Manager nodes elect a single leader to conduct orchestration tasks.</source>
          <target state="translated">또한 관리자 노드는 원하는 웜 상태를 유지하는 데 필요한 오케스트레이션 및 클러스터 관리 기능을 수행합니다. 관리자 노드는 오케스트레이션 작업을 수행 할 단일 리더를 선출합니다.</target>
        </trans-unit>
        <trans-unit id="bb17aefff727aeedc1ec5fce2d758d32905fd260" translate="yes" xml:space="preserve">
          <source>Manager nodes handle cluster management tasks:</source>
          <target state="translated">관리자 노드는 클러스터 관리 작업을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7965df2d8940eef51069a39c363b5f5aad9b4836" translate="yes" xml:space="preserve">
          <source>Manager nodes increase fault-tolerance. Manager nodes perform the orchestration and cluster management functions for the swarm. Among manager nodes, a single leader node conducts orchestration tasks. If a leader node goes down, the remaining manager nodes elect a new leader and resume orchestration and maintenance of the swarm state. By default, manager nodes also run tasks.</source>
          <target state="translated">관리자 노드는 내결함성을 높입니다. 관리자 노드는 웜에 대한 오케스트레이션 및 클러스터 관리 기능을 수행합니다. 관리자 노드 중에서 단일 리더 노드가 오케스트레이션 작업을 수행합니다. 리더 노드가 중단되면 나머지 관리자 노드는 새 리더를 선발하고 떼 상태의 조정 및 유지 관리를 재개합니다. 기본적으로 관리자 노드는 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="005dff29e5c23dfba4fdee901a2c9d6ed94019fa" translate="yes" xml:space="preserve">
          <source>Manager nodes use an advertise address to allow other nodes in the swarm access to the Swarmkit API and overlay networking. The other nodes on the swarm must be able to access the manager node on its advertise address.</source>
          <target state="translated">관리자 노드는 광고 주소를 사용하여 떼의 다른 노드가 Swarmkit API 및 오버레이 네트워킹에 액세스 할 수 있도록합니다. swarm의 다른 노드는 광고 주소에서 관리자 노드에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="910fdd0d108caa6a55952caea60ef5141def8a73" translate="yes" xml:space="preserve">
          <source>Manager status of the node</source>
          <target state="translated">노드의 관리자 상태</target>
        </trans-unit>
        <trans-unit id="d2b0410329a3eab90ceb43d48ffbb77412ae2574" translate="yes" xml:space="preserve">
          <source>Managing /etc/hosts</source>
          <target state="translated">/ etc / hosts 관리</target>
        </trans-unit>
        <trans-unit id="bd8c1b2fedcd8758444f2d94bfb6c8eba8eac164" translate="yes" xml:space="preserve">
          <source>Managing Delegations in a Notary Server</source>
          <target state="translated">Notary Server에서 위임 관리</target>
        </trans-unit>
        <trans-unit id="3e4d9bf678d7a35cbe054e7e78691d4126c06e31" translate="yes" xml:space="preserve">
          <source>Managing the thin-pool outside of Engine makes for the most feature-rich method of having Docker utilize device mapper thin provisioning as the backing storage for Docker containers. The highlights of the lvm-based thin-pool management feature include: automatic or interactive thin-pool resize support, dynamically changing thin-pool features, automatic thinp metadata checking when lvm activates the thin-pool, etc.</source>
          <target state="translated">엔진 외부의 씬 풀을 관리하면 Docker가 Docker 컨테이너의 백업 저장소로 장치 매퍼 씬 프로비저닝을 활용하는 가장 풍부한 기능의 방법을 사용할 수 있습니다. lvm 기반 씬 풀 관리 기능의 주요 특징으로는 자동 또는 대화식 씬 풀 크기 조정 지원, 동적으로 변경되는 씬 풀 기능, lvm이 씬 풀을 활성화 할 때 자동 씬 메타 데이터 검사 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="12715780d4d150abbe9e3857ad55e1a613bb8751" translate="yes" xml:space="preserve">
          <source>Mandatory:</source>
          <target state="translated">Mandatory:</target>
        </trans-unit>
        <trans-unit id="241359691c33d5d621cbccc9b88fda8b028a8039" translate="yes" xml:space="preserve">
          <source>Manual scheduling</source>
          <target state="translated">수동 예약</target>
        </trans-unit>
        <trans-unit id="bf042799231be65b3d68a7591be84935f41268d1" translate="yes" xml:space="preserve">
          <source>Manually Generating Keys</source>
          <target state="translated">수동 키 생성</target>
        </trans-unit>
        <trans-unit id="a0da65d72342575cd244ec94009c257136b53215" translate="yes" xml:space="preserve">
          <source>Many drivers require a certain set of conditions to be in place before machines can be created. For instance, VirtualBox needs to be installed before the &lt;code&gt;virtualbox&lt;/code&gt; driver can be used. For this reason, Docker Machine has a &amp;ldquo;pre-create check&amp;rdquo; which is specified at the driver level.</source>
          <target state="translated">대부분의 드라이버는 기계를 생성하기 전에 특정 조건 집합이 있어야합니다. 예를 들어, 버추얼 박스는 전에 설치해야 &lt;code&gt;virtualbox&lt;/code&gt; 드라이버를 사용할 수 있습니다. 이러한 이유로 Docker Machine에는 드라이버 수준에서 지정된 &quot;사전 생성 검사&quot;가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb0d704f9521dbd1d311f115854c59e375e6857" translate="yes" xml:space="preserve">
          <source>Many of the official images in the &lt;a href=&quot;https://github.com/docker-library/&quot;&gt;Docker library&lt;/a&gt;, such as the &lt;a href=&quot;https://github.com/docker-library/wordpress/&quot;&gt;wordpress&lt;/a&gt; image used in the above examples, have been updated in this way.</source>
          <target state="translated">위의 예제에서 사용 된 &lt;a href=&quot;https://github.com/docker-library/wordpress/&quot;&gt;워드 프레스&lt;/a&gt; 이미지 와 같은 &lt;a href=&quot;https://github.com/docker-library/&quot;&gt;Docker 라이브러리&lt;/a&gt; 의 많은 공식 이미지 가이 방식으로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="9cf2ce94e3924a3676408390a211bd30f36fc144" translate="yes" xml:space="preserve">
          <source>Map port 4000 on the host to &lt;code&gt;web&lt;/code&gt;&amp;rsquo;s port 80.</source>
          <target state="translated">호스트의 포트 4000을 &lt;code&gt;web&lt;/code&gt; 의 포트 80 에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="371a6e388eb86c9c5d5ac630ff9bf2c9460b0aec" translate="yes" xml:space="preserve">
          <source>Mapping of GUN prefixes to filepaths containing the root CA file with which to verify the certificates in the root file. This file can contain multiple root certificates, bundled in separate PEM blocks. The path is relative to the directory of the configuration file.</source>
          <target state="translated">루트 파일에서 인증서를 확인하는 데 사용되는 루트 CA 파일이 포함 된 파일 경로에 GUN 접두사를 매핑합니다. 이 파일은 여러 개의 루트 인증서를 포함 할 수 있으며 별도의 PEM 블록에 번들로 제공됩니다. 경로는 구성 파일의 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="54acd4a9cccf9e21cd0e1bc63e73040c32003a5b" translate="yes" xml:space="preserve">
          <source>Mapping of GUN to certificate IDs to pin to. Both are strings in the JSON object.</source>
          <target state="translated">고정 할 인증서 ID에 대한 GUN 맵핑 둘 다 JSON 객체의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="989b2287465a640317819f9bb5b03151d31046a5" translate="yes" xml:space="preserve">
          <source>Match containers based on the &lt;code&gt;ubuntu-c1&lt;/code&gt; image which, in this case, is a child of &lt;code&gt;ubuntu&lt;/code&gt;:</source>
          <target state="translated">이 경우 &lt;code&gt;ubuntu&lt;/code&gt; 의 자식 인 ubuntu &lt;code&gt;ubuntu-c1&lt;/code&gt; 이미지를 기반으로 컨테이너를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="b2749f0242940b71b2b2187d20b39fd3f198d874" translate="yes" xml:space="preserve">
          <source>Match containers based on the &lt;code&gt;ubuntu&lt;/code&gt; version &lt;code&gt;12.04.5&lt;/code&gt; image:</source>
          <target state="translated">&lt;code&gt;ubuntu&lt;/code&gt; 버전 &lt;code&gt;12.04.5&lt;/code&gt; 이미지를 기반으로 컨테이너를 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9e8e126b303a9cc47a8f61427166dbc9bf68e93a" translate="yes" xml:space="preserve">
          <source>Matching is done using Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/path/filepath#Match&quot;&gt;filepath.Match&lt;/a&gt; rules. A preprocessing step removes leading and trailing whitespace and eliminates &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; elements using Go&amp;rsquo;s &lt;a href=&quot;http://golang.org/pkg/path/filepath/#Clean&quot;&gt;filepath.Clean&lt;/a&gt;. Lines that are blank after preprocessing are ignored.</source>
          <target state="translated">일치는 Go의 &lt;a href=&quot;http://golang.org/pkg/path/filepath#Match&quot;&gt;파일 경로를&lt;/a&gt; 사용하여 수행 됩니다. 전처리 단계는 선행 및 후행 공백을 제거하고 제거 &lt;code&gt;.&lt;/code&gt; 와 &lt;code&gt;..&lt;/code&gt; 이동의 사용 요소 &lt;a href=&quot;http://golang.org/pkg/path/filepath/#Clean&quot;&gt;filepath.Clean을&lt;/a&gt; . 전처리 후 빈 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3e0da068fcb2287180011aa444991a3de8f3ed6a" translate="yes" xml:space="preserve">
          <source>Max number of search results</source>
          <target state="translated">최대 검색 결과 수</target>
        </trans-unit>
        <trans-unit id="eb5d4bf6f2281b770d8dc4c2b0020ee3cd57f079" translate="yes" xml:space="preserve">
          <source>Maximum IO bandwidth limit for the system drive (Windows only)</source>
          <target state="translated">시스템 드라이브의 최대 IO 대역폭 제한 (Windows 만 해당)</target>
        </trans-unit>
        <trans-unit id="42b527a7695a6fede3e4b6c2c1b609466e43c3d6" translate="yes" xml:space="preserve">
          <source>Maximum IOps limit for the system drive (Windows only)</source>
          <target state="translated">시스템 드라이브에 대한 최대 IOps 제한 (Windows 만 해당)</target>
        </trans-unit>
        <trans-unit id="dfffc6fb3b3c2a919637ad93325a34acff28f149" translate="yes" xml:space="preserve">
          <source>Maximum number of restarts before giving up</source>
          <target state="translated">포기하기 전에 최대 재시작 횟수</target>
        </trans-unit>
        <trans-unit id="ade9c278c92219ab9e0376c7e40674145f09d97f" translate="yes" xml:space="preserve">
          <source>Maximum number of tasks per node (default 0 = unlimited)</source>
          <target state="translated">노드 당 최대 작업 수 (기본값 0 = 무제한)</target>
        </trans-unit>
        <trans-unit id="2664cfa37954331a3314e960b2e250656baa30e7" translate="yes" xml:space="preserve">
          <source>Maximum number of tasks rolled back simultaneously (0 to roll back all at once)</source>
          <target state="translated">동시에 롤백되는 최대 작업 수 (0에서 한 번에 롤백하는 경우)</target>
        </trans-unit>
        <trans-unit id="87cdbc35cac32c6baaa6a737e3f41cc58a02a276" translate="yes" xml:space="preserve">
          <source>Maximum number of tasks updated simultaneously (0 to update all at once)</source>
          <target state="translated">동시에 업데이트되는 최대 작업 수 (한 번에 모두 업데이트하려면 0)</target>
        </trans-unit>
        <trans-unit id="b5b1950bb9db9fe065877dcdf81532404b1e2668" translate="yes" xml:space="preserve">
          <source>Maximum time to allow one check to run (ms|s|m|h)</source>
          <target state="translated">한 번의 확인을 실행할 수있는 최대 시간 (ms | s | m | h)</target>
        </trans-unit>
        <trans-unit id="7aa948bb95ccc5227d65b6789dcd47611c35f863" translate="yes" xml:space="preserve">
          <source>Maximum time to allow one check to run (ms|s|m|h) (default 0s)</source>
          <target state="translated">한 번의 확인을 실행할 수있는 최대 시간 (ms | s | m | h) (기본값 0)</target>
        </trans-unit>
        <trans-unit id="622a2e56f6d7c0edc29dd1ba6eff3f8fab20db4f" translate="yes" xml:space="preserve">
          <source>Media Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3478f41b305c9341e1ec9d9ca38150f3734196" translate="yes" xml:space="preserve">
          <source>Memory limit</source>
          <target state="translated">메모리 제한</target>
        </trans-unit>
        <trans-unit id="41f87e9a9d3752706de2bdb69e4ca63cbc448970" translate="yes" xml:space="preserve">
          <source>Memory limit (format: &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt;). Number is a positive integer. Unit can be one of &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt;. Minimum is 4M.</source>
          <target state="translated">메모리 제한 (형식 : &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt; ). 숫자는 양의 정수입니다. 단위는 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 중 하나 일 수 있습니다 . 최소값은 4M입니다.</target>
        </trans-unit>
        <trans-unit id="7937d23a97ea39909f9540f0ef9efd72d3b2a729" translate="yes" xml:space="preserve">
          <source>Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.</source>
          <target state="translated">실행을 허용하는 메모리 노드 (MEM) (0-3, 0,1). NUMA 시스템에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3f9b787699efd1ad1f1a46f6ce9637d0566175ac" translate="yes" xml:space="preserve">
          <source>Memory percentage (Not available on Windows)</source>
          <target state="translated">메모리 백분율 (Windows에서는 사용할 수 없음)</target>
        </trans-unit>
        <trans-unit id="139e724e8896bb9e810c36540b971118d2f91261" translate="yes" xml:space="preserve">
          <source>Memory reservation is a kind of memory soft limit that allows for greater sharing of memory. Under normal circumstances, containers can use as much of the memory as needed and are constrained only by the hard limits set with the &lt;code&gt;-m&lt;/code&gt;/&lt;code&gt;--memory&lt;/code&gt; option. When memory reservation is set, Docker detects memory contention or low memory and forces containers to restrict their consumption to a reservation limit.</source>
          <target state="translated">메모리 예약은 메모리를 더 많이 공유 할 수있는 일종의 메모리 소프트 한계입니다. 일반적인 상황에서 컨테이너는 필요한만큼의 메모리를 사용할 수 있으며 &lt;code&gt;-m&lt;/code&gt; / &lt;code&gt;--memory&lt;/code&gt; 옵션으로 설정 한 하드 제한에 의해서만 제한됩니다 . 메모리 예약이 설정되면 Docker는 메모리 경합 또는 메모리 부족을 감지하고 컨테이너가 소비를 예약 제한으로 제한하도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="d90f761f2b955162e7e109b51a9dcd42ff98789c" translate="yes" xml:space="preserve">
          <source>Memory reservation is a soft-limit feature and does not guarantee the limit won&amp;rsquo;t be exceeded. Instead, the feature attempts to ensure that, when memory is heavily contended for, memory is allocated based on the reservation hints/setup.</source>
          <target state="translated">메모리 예약은 소프트 제한 기능이며 제한이 초과되지는 않습니다. 대신이 기능은 메모리가 많이 사용되는 경우 예약 힌트 / 설정을 기반으로 메모리가 할당되도록합니다.</target>
        </trans-unit>
        <trans-unit id="20b15ace296d665a57049a512414d89db4bbe882" translate="yes" xml:space="preserve">
          <source>Memory soft limit</source>
          <target state="translated">메모리 소프트 한계</target>
        </trans-unit>
        <trans-unit id="e8c0f8bc49fd35707f331e523a6b7d4ea8dcfaff" translate="yes" xml:space="preserve">
          <source>Memory soft limit (format: &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt;). Number is a positive integer. Unit can be one of &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">메모리 소프트 한계 (형식 : &lt;code&gt;&amp;lt;number&amp;gt;[&amp;lt;unit&amp;gt;]&lt;/code&gt; ). 숫자는 양의 정수입니다. 단위는 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="530f6ddbe6f5cabf01f18a63d450d84bd827f45b" translate="yes" xml:space="preserve">
          <source>Memory usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b3c4b6995f098b447c02e80adbaec08c11146" translate="yes" xml:space="preserve">
          <source>Methods for doing this vary depending on your cloud provider.</source>
          <target state="translated">이를 수행하는 방법은 클라우드 공급자에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5e0e80e05f6b63306d80d9083140096a863b1af8" translate="yes" xml:space="preserve">
          <source>Microsoft ASP.NET Core on Docker Hub</source>
          <target state="translated">Docker Hub의 Microsoft ASP.NET 코어</target>
        </trans-unit>
        <trans-unit id="ce1b25befca382d0c1fbf760de6ce165ed7a0e08" translate="yes" xml:space="preserve">
          <source>Microsoft Azure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806975ae6c4cab06a55ecd3355837d4a03826904" translate="yes" xml:space="preserve">
          <source>Microsoft Hyper-V</source>
          <target state="translated">Microsoft Hyper-V</target>
        </trans-unit>
        <trans-unit id="84c01655ae0a70b6856f3be9c14ac8e736377c9c" translate="yes" xml:space="preserve">
          <source>Microsoft Windows Credential Manager: https://github.com/docker/docker-credential-helpers/releases</source>
          <target state="translated">Microsoft Windows 자격 증명 관리자 : https://github.com/docker/docker-credential-helpers/releases</target>
        </trans-unit>
        <trans-unit id="4a94b757ab80aad04a2eeb6162194b288cb01fd6" translate="yes" xml:space="preserve">
          <source>Microsoft Windows has no built-in driver for managing RAM disks, so within running Windows containers, secrets &lt;strong&gt;are&lt;/strong&gt; persisted in clear text to the container&amp;rsquo;s root disk. However, the secrets are explicitly removed when a container stops. In addition, Windows does not support persisting a running container as an image using &lt;code&gt;docker commit&lt;/code&gt; or similar commands.</source>
          <target state="translated">Microsoft Windows에는 RAM 디스크 관리를위한 내장 드라이버가 없으므로 Windows 컨테이너를 실행 하는 동안 컨테이너의 루트 디스크에 비밀 &lt;strong&gt;이&lt;/strong&gt; 일반 텍스트로 유지됩니다. 그러나 컨테이너가 중지되면 비밀이 명시 적으로 제거됩니다. 또한 Windows는 &lt;code&gt;docker commit&lt;/code&gt; 또는 유사한 명령을 사용하여 실행중인 컨테이너를 이미지로 유지하는 것을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0b9befd43cd162f84d1c9e28141069060b6733f5" translate="yes" xml:space="preserve">
          <source>Migrate from Boot2Docker to Docker Machine</source>
          <target state="translated">Boot2Docker에서 Docker Machine으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="9cd51733ef265f009afdf9ef40cfa0a4dcdda13f" translate="yes" xml:space="preserve">
          <source>Migrate from Boot2Docker to Machine</source>
          <target state="translated">Boot2Docker에서 컴퓨터로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="0d58caaa07d487e342887e5c89ba6415b53959c3" translate="yes" xml:space="preserve">
          <source>Miscellaneous options</source>
          <target state="translated">기타 옵션</target>
        </trans-unit>
        <trans-unit id="f4c37cfb3abc87fcc85ca3b9293f83f5713d0050" translate="yes" xml:space="preserve">
          <source>Missing or null labels</source>
          <target state="translated">레이블이 없거나 널입니다</target>
        </trans-unit>
        <trans-unit id="f9a95c3f2c990cb184d3294f2cc09b865cda4463" translate="yes" xml:space="preserve">
          <source>Mitigations</source>
          <target state="translated">Mitigations</target>
        </trans-unit>
        <trans-unit id="5e506f287c85c446202f62f0fbcb245e6c11583a" translate="yes" xml:space="preserve">
          <source>Modify process capabilities.</source>
          <target state="translated">프로세스 기능을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="ec5b4ce7a62f243cb5e33bcce21a33f2d1223e99" translate="yes" xml:space="preserve">
          <source>Modify the proportion of bandwidth allocated to this service relative to other services. Takes an integer value between 10 and 1000, with 500 being the default.</source>
          <target state="translated">다른 서비스와 비교하여이 서비스에 할당 된 대역폭의 비율을 수정하십시오. 10에서 1000 사이의 정수 값을 사용하며 기본값은 500입니다.</target>
        </trans-unit>
        <trans-unit id="f3652f98d84a6a36e4a47e62dbf486831b18be5d" translate="yes" xml:space="preserve">
          <source>Modify your Compose file for production</source>
          <target state="translated">프로덕션 용 작성 파일 수정</target>
        </trans-unit>
        <trans-unit id="a0506f4cdc2fa84cf3d6712842fcae780eb93937" translate="yes" xml:space="preserve">
          <source>Modular components with minimal overhead retain flexibility while constructing your solutions</source>
          <target state="translated">오버 헤드를 최소화하는 모듈 식 구성 요소는 솔루션을 구성하는 동안 유연성을 유지합니다</target>
        </trans-unit>
        <trans-unit id="a6f6fcc11cd5a4cda1540411710996127fced19d" translate="yes" xml:space="preserve">
          <source>Monitor swarm health</source>
          <target state="translated">떼 건강 모니터링</target>
        </trans-unit>
        <trans-unit id="75bef888ca25dbbee7e30d2ddeb2c82b94be4f36" translate="yes" xml:space="preserve">
          <source>More Compose documentation</source>
          <target state="translated">더 많은 작성 설명서</target>
        </trans-unit>
        <trans-unit id="96f4aa8b34b9ebefe8f8375ad6df9d0312712ec8" translate="yes" xml:space="preserve">
          <source>More advanced methods of configuration, and additional options, can be found in the &lt;a href=&quot;../reference/index&quot;&gt;configuration doc&lt;/a&gt; and by running &lt;code&gt;notary --help&lt;/code&gt;.</source>
          <target state="translated">보다 고급 구성 방법 및 추가 옵션은 &lt;a href=&quot;../reference/index&quot;&gt;구성 문서&lt;/a&gt; 에서 &lt;code&gt;notary --help&lt;/code&gt; 를 실행 하여 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a2a63942b87fc93b00e75cd732d3fa178b577f6" translate="yes" xml:space="preserve">
          <source>More detailed information on restart policies can be found in the &lt;a href=&quot;../../run/index#restart-policies---restart&quot;&gt;Restart Policies (--restart)&lt;/a&gt; section of the Docker run reference page.</source>
          <target state="translated">재시작 정책에 대한 자세한 정보 는 Docker 실행 참조 페이지 의 &lt;a href=&quot;../../run/index#restart-policies---restart&quot;&gt;재시작 정책 (-다시 시작)&lt;/a&gt; 섹션 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59842d981c57fb9cc87deffb5fe760f6cbaebe00" translate="yes" xml:space="preserve">
          <source>More info</source>
          <target state="translated">더 많은 정보</target>
        </trans-unit>
        <trans-unit id="fb9d9e9b664a0d82776f9d3eebd0701f28348eb6" translate="yes" xml:space="preserve">
          <source>More information on short and long syntax for secrets can be found at &lt;a href=&quot;../../../compose/compose-file/index#secrets&quot;&gt;Compose file version 3 reference&lt;/a&gt;.</source>
          <target state="translated">비밀에 대한 짧고 긴 구문에 대한 자세한 정보는 &lt;a href=&quot;../../../compose/compose-file/index#secrets&quot;&gt;Compose file version 3 reference&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfbebe34ff1ff71906709461d6a7a51dc712ccdf" translate="yes" xml:space="preserve">
          <source>More information on the &lt;code&gt;$ notary witness&lt;/code&gt; command can be found &lt;a href=&quot;https://github.com/theupdateframework/notary/blob/master/docs/advanced_usage/#recovering-a-delegation&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;$ notary witness&lt;/code&gt; 명령 에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/theupdateframework/notary/blob/master/docs/advanced_usage/#recovering-a-delegation&quot;&gt;여기를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22808c5574015f8ad7b133e0c22072e232e2ae10" translate="yes" xml:space="preserve">
          <source>More play in the sandbox</source>
          <target state="translated">샌드 박스에서 더 많은 플레이</target>
        </trans-unit>
        <trans-unit id="80e21a3d26283fe1ec952272f1b272b2e85a14ee" translate="yes" xml:space="preserve">
          <source>More than 8 docker machines?</source>
          <target state="translated">도커 머신이 8 대 이상입니까?</target>
        </trans-unit>
        <trans-unit id="3347345e531540df59edf729568e9d5da848a1cc" translate="yes" xml:space="preserve">
          <source>Moreover, if you want to use &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index&quot;&gt;Docker Swarm&lt;/a&gt;, also add TCP port 2377, UDP/TCP on 7946, and UDP on 4789.</source>
          <target state="translated">또한 &lt;a href=&quot;../../../engine/swarm/swarm-tutorial/index&quot;&gt;Docker Swarm&lt;/a&gt; 을 사용하려면 TCP 포트 2377, UDP / TCP (7946) 및 UDP (4789)를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5620560da848b176cd61a0f05819a71d6560d73d" translate="yes" xml:space="preserve">
          <source>Most importantly, there are a couple of things in the &lt;code&gt;redis&lt;/code&gt; specification that make data persist between deployments of this stack:</source>
          <target state="translated">가장 중요한 것은 &lt;code&gt;redis&lt;/code&gt; 사양에이 스택 배포간에 데이터를 유지 하는 몇 가지 사항 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f519679a9bbc4e2c449fa80ef369987c307f81bd" translate="yes" xml:space="preserve">
          <source>Most of your images will be created on top of a base image from the &lt;a href=&quot;https://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt; registry.</source>
          <target state="translated">대부분의 이미지는 &lt;a href=&quot;https://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt; 레지스트리 의 기본 이미지 위에 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="92cfb4be28376daf94bb60b407727790697d459f" translate="yes" xml:space="preserve">
          <source>Mount a temporary file system inside the container. Can be a single value or a list.</source>
          <target state="translated">컨테이너 안에 임시 파일 시스템을 마운트하십시오. 단일 값 또는 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e48be240d536351df4966946d5bc4570fa13507" translate="yes" xml:space="preserve">
          <source>Mount a temporary file system inside the container. Size parameter specifies the size of the tmpfs mount in bytes. Unlimited by default.</source>
          <target state="translated">컨테이너 안에 임시 파일 시스템을 마운트하십시오. Size 매개 변수는 tmpfs 마운트의 크기를 바이트 단위로 지정합니다. 기본적으로 무제한.</target>
        </trans-unit>
        <trans-unit id="85823aceb0182bea3afb3eaed9c52cd2350e589d" translate="yes" xml:space="preserve">
          <source>Mount a tmpfs directory</source>
          <target state="translated">tmpfs 디렉토리를 마운트하십시오</target>
        </trans-unit>
        <trans-unit id="91f560dd786427c0e0c57b8b2a1d32206b1d9273" translate="yes" xml:space="preserve">
          <source>Mount all of the volumes from another service or container, optionally specifying read-only access (&lt;code&gt;ro&lt;/code&gt;) or read-write (&lt;code&gt;rw&lt;/code&gt;). If no access level is specified, then read-write is used.</source>
          <target state="translated">선택적으로 읽기 전용 액세스 ( &lt;code&gt;ro&lt;/code&gt; ) 또는 읽기 / 쓰기 ( &lt;code&gt;rw&lt;/code&gt; )를 지정하여 다른 서비스 또는 컨테이너에서 모든 볼륨을 마운트하십시오 . 액세스 수준을 지정하지 않으면 읽기 / 쓰기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da0fa830ad355881d94c4807ff1ad650bba47d46" translate="yes" xml:space="preserve">
          <source>Mount directories from a machine to your local host, using &lt;code&gt;sshfs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sshfs&lt;/code&gt; 를 사용하여 머신에서 로컬 호스트로 디렉토리를 마운트하십시오 .</target>
        </trans-unit>
        <trans-unit id="86a353f3b51b8f2d18815b68aaefe20f759faab1" translate="yes" xml:space="preserve">
          <source>Mount host folders or named volumes. Named volumes need to be specified with the &lt;a href=&quot;#volume-configuration-reference&quot;&gt;top-level &lt;code&gt;volumes&lt;/code&gt; key&lt;/a&gt;.</source>
          <target state="translated">호스트 폴더 또는 명명 된 볼륨을 마운트하십시오. 명명 된 볼륨은 &lt;a href=&quot;#volume-configuration-reference&quot;&gt;최상위 &lt;code&gt;volumes&lt;/code&gt; 키로&lt;/a&gt; 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7defaa4ccf5e37510def0937d1dd546d1da7e21e" translate="yes" xml:space="preserve">
          <source>Mount host paths or named volumes, specified as sub-options to a service.</source>
          <target state="translated">서비스에 대한 하위 옵션으로 지정된 호스트 경로 또는 명명 된 볼륨을 마운트하십시오.</target>
        </trans-unit>
        <trans-unit id="b8566c0f05e5f416974cf5434edaf05f302512bd" translate="yes" xml:space="preserve">
          <source>Mount path inside the container, for example</source>
          <target state="translated">컨테이너 내부의 마운트 경로 (예 :</target>
        </trans-unit>
        <trans-unit id="35f9278e8c4a19bf12721b7affad17b358eba677" translate="yes" xml:space="preserve">
          <source>Mount paths or named volumes, optionally specifying a path on the host machine (&lt;code&gt;HOST:CONTAINER&lt;/code&gt;), or an access mode (&lt;code&gt;HOST:CONTAINER:ro&lt;/code&gt;). For &lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;version 2 files&lt;/a&gt;, named volumes need to be specified with the &lt;a href=&quot;../compose-file-v2/index#volume-configuration-reference&quot;&gt;top-level &lt;code&gt;volumes&lt;/code&gt; key&lt;/a&gt;. When using &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;version 1&lt;/a&gt;, the Docker Engine creates the named volume automatically if it doesn&amp;rsquo;t exist.</source>
          <target state="translated">호스트 시스템의 경로 ( &lt;code&gt;HOST:CONTAINER&lt;/code&gt; ) 또는 액세스 모드 ( &lt;code&gt;HOST:CONTAINER:ro&lt;/code&gt; )를 선택적으로 지정하여 경로 또는 명명 된 볼륨을 마운트하십시오 . 들어 &lt;a href=&quot;../compose-versioning/index#version-2&quot;&gt;버전 2 개 파일&lt;/a&gt; , 이름이 볼륨은 지정 될 필요가 &lt;a href=&quot;../compose-file-v2/index#volume-configuration-reference&quot;&gt;최상위 &lt;code&gt;volumes&lt;/code&gt; 키&lt;/a&gt; . &lt;a href=&quot;../compose-versioning/index#version-1&quot;&gt;버전 1을&lt;/a&gt; 사용 하는 경우 Docker 엔진은 이름이 지정된 볼륨이 없으면 자동으로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4a793c31bfb3fbe8d945266cf6982d8e19e2768d" translate="yes" xml:space="preserve">
          <source>Mount the container&amp;rsquo;s root filesystem as read only</source>
          <target state="translated">컨테이너의 루트 파일 시스템을 읽기 전용으로 마운트</target>
        </trans-unit>
        <trans-unit id="c63969ffb9cefc7177f3502cbb895de9305e9149" translate="yes" xml:space="preserve">
          <source>Mount tmpfs (--tmpfs)</source>
          <target state="translated">tmpfs 마운트 (--tmpfs)</target>
        </trans-unit>
        <trans-unit id="dd72e7dc4d2e79077b2337f049558d0c4758d1b5" translate="yes" xml:space="preserve">
          <source>Mount volume (-v, --read-only)</source>
          <target state="translated">마운트 볼륨 (-v, --read-only)</target>
        </trans-unit>
        <trans-unit id="e1d0850660e4571703f18661e2e220d9baaf927a" translate="yes" xml:space="preserve">
          <source>Mount volumes from container (--volumes-from)</source>
          <target state="translated">컨테이너에서 볼륨 마운트 (-볼륨)</target>
        </trans-unit>
        <trans-unit id="89cd494a16e8195c1b444308a8126134da6693e6" translate="yes" xml:space="preserve">
          <source>Mount volumes from the specified container(s)</source>
          <target state="translated">지정된 컨테이너에서 볼륨 마운트</target>
        </trans-unit>
        <trans-unit id="14766b11b99f48495ad4c21d250367a73f20edac" translate="yes" xml:space="preserve">
          <source>Msg</source>
          <target state="translated">Msg</target>
        </trans-unit>
        <trans-unit id="d26a862e80e9980f33f480dfda6ecd6bcb3ca806" translate="yes" xml:space="preserve">
          <source>Multi</source>
          <target state="translated">Multi</target>
        </trans-unit>
        <trans-unit id="519f998c05c9ee7680f1e1f0a99874ac7bf38eca" translate="yes" xml:space="preserve">
          <source>Multi-host networking</source>
          <target state="translated">멀티 호스트 네트워킹</target>
        </trans-unit>
        <trans-unit id="c8e34199b0dc0d9dd49c139b1ef17d1bd104962d" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; resources may be specified but if they are files or directories, their paths are interpreted as relative to the source of the context of the build.</source>
          <target state="translated">여러 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 자원을 지정할 수 있지만 파일 또는 디렉토리 인 경우 해당 경로는 빌드 컨텍스트의 소스를 기준으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="26a11916bb19c0abdb9f19bbe46be8eaebb47961" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; resources may be specified but the paths of files and directories will be interpreted as relative to the source of the context of the build.</source>
          <target state="translated">여러 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 자원을 지정할 수 있지만 파일 및 디렉토리의 경로는 빌드 컨텍스트의 소스를 기준으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fae9ae732e6ec06c7aa85fb6597f6726faceff03" translate="yes" xml:space="preserve">
          <source>Multiple Compose files</source>
          <target state="translated">여러 개의 작성 파일</target>
        </trans-unit>
        <trans-unit id="c709ad37f517d2882f4a480ee7e3ecbae00010e5" translate="yes" xml:space="preserve">
          <source>Multiple containers can use the same volume in the same time period. This is useful if two containers need access to shared data. For example, if one container writes and the other reads the data.</source>
          <target state="translated">여러 컨테이너가 같은 기간에 동일한 볼륨을 사용할 수 있습니다. 두 컨테이너가 공유 데이터에 액세스해야하는 경우에 유용합니다. 예를 들어, 한 컨테이너가 쓰고 다른 컨테이너가 데이터를 읽는 경우.</target>
        </trans-unit>
        <trans-unit id="465b1d063624d1fcd3acbd7f7a3be4db41f5edf8" translate="yes" xml:space="preserve">
          <source>Multiple dependencies</source>
          <target state="translated">다중 의존성</target>
        </trans-unit>
        <trans-unit id="a90b5acfeccb0d35fe87e49d7db585d97cd3c333" translate="yes" xml:space="preserve">
          <source>Multiple isolated environments on a single host</source>
          <target state="translated">단일 호스트에서 여러 격리 된 환경</target>
        </trans-unit>
        <trans-unit id="a9575de0f432dbaff755a2190eee759f8b96abe6" translate="yes" xml:space="preserve">
          <source>Multiple ranges</source>
          <target state="translated">여러 범위</target>
        </trans-unit>
        <trans-unit id="65a8a5ce44d374f82b26ef0009f098065b477d98" translate="yes" xml:space="preserve">
          <source>Must be &lt;code&gt;&quot;mysql&quot;&lt;/code&gt; or &lt;code&gt;&quot;memory&quot;&lt;/code&gt;. If &lt;code&gt;&quot;memory&quot;&lt;/code&gt; is selected, the &lt;code&gt;db_url&lt;/code&gt; is ignored.</source>
          <target state="translated">&lt;code&gt;&quot;mysql&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 여야합니다 . 경우 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 를 선택하면 &lt;code&gt;db_url&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa10ba3abaeacc374bba38673191d9a0285526ae" translate="yes" xml:space="preserve">
          <source>Must be &lt;code&gt;&quot;remote&quot;&lt;/code&gt; or &lt;code&gt;&quot;local&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;remote&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;local&quot;&lt;/code&gt; 이어야합니다</target>
        </trans-unit>
        <trans-unit id="302bab3d237654c9742db4ae6ae04f55c72a7566" translate="yes" xml:space="preserve">
          <source>Must be &lt;code&gt;&quot;token&quot;&lt;/code&gt;; all other values result in no authentication (and the rest of the parameters are ignored)</source>
          <target state="translated">&lt;code&gt;&quot;token&quot;&lt;/code&gt; 이어야합니다 . 다른 모든 값은 인증되지 않으며 나머지 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b5f542945b0612c4c9533b659dba323eb463f843" translate="yes" xml:space="preserve">
          <source>NET_ADMIN</source>
          <target state="translated">NET_ADMIN</target>
        </trans-unit>
        <trans-unit id="7ccbf5888b444d8453990b807f720770732a9767" translate="yes" xml:space="preserve">
          <source>NET_BIND_SERVICE</source>
          <target state="translated">NET_BIND_SERVICE</target>
        </trans-unit>
        <trans-unit id="085a17e851ae0a02928634dc2973a3eb2fa16f4d" translate="yes" xml:space="preserve">
          <source>NET_BROADCAST</source>
          <target state="translated">NET_BROADCAST</target>
        </trans-unit>
        <trans-unit id="829362ba32bb20ec9c53a53f1853516e1e58727d" translate="yes" xml:space="preserve">
          <source>NET_RAW</source>
          <target state="translated">NET_RAW</target>
        </trans-unit>
        <trans-unit id="6282fc57f4e258746ab20715e515c39d5ec6b10b" translate="yes" xml:space="preserve">
          <source>NOTE: initially present devices still need to be explicitly added to the create/run command</source>
          <target state="translated">참고 : 처음에 존재하는 장치는 여전히 create / run 명령에 명시 적으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="18c483d570afdd90f0cbe943ed909635246cc964" translate="yes" xml:space="preserve">
          <source>NWe include a remote trust service and a database storage type to demonstrate how environment variables can override configuration parameters.</source>
          <target state="translated">환경 변수가 구성 매개 변수를 대체 할 수있는 방법을 보여주기 위해 원격 신뢰 서비스 및 데이터베이스 스토리지 유형을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="fa3a18074226cac08a7318659b7d1b9dcb5c2e52" translate="yes" xml:space="preserve">
          <source>Name (--name)</source>
          <target state="translated">이름 (--name)</target>
        </trans-unit>
        <trans-unit id="c0d42a8520549d28bde339998e38fc28a12c8c8b" translate="yes" xml:space="preserve">
          <source>Name and optionally a tag in the &amp;lsquo;name:tag&amp;rsquo; format</source>
          <target state="translated">'name : tag'형식의 이름 및 선택적으로 태그</target>
        </trans-unit>
        <trans-unit id="65f18292226721b5555f684ab68341369abec5e0" translate="yes" xml:space="preserve">
          <source>Name for the loaded key</source>
          <target state="translated">로드 된 키의 이름</target>
        </trans-unit>
        <trans-unit id="f8c33ddbee31340a81a4ad72d323d9cb85ccaaf1" translate="yes" xml:space="preserve">
          <source>Name of the Dockerfile (Default is &amp;lsquo;PATH/Dockerfile&amp;rsquo;)</source>
          <target state="translated">Dockerfile의 이름 (기본값은 'PATH / Dockerfile')</target>
        </trans-unit>
        <trans-unit id="efdb093ed35f4754e1e3f79287162bf5b5f2f2d1" translate="yes" xml:space="preserve">
          <source>Name of the volume-driver plugin to use for the volume. Defaults to</source>
          <target state="translated">볼륨에 사용할 볼륨 드라이버 플러그인의 이름입니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="1fa3d1039f5e7670a5ffdd89b3a73785adb65e56" translate="yes" xml:space="preserve">
          <source>Name, shorthand</source>
          <target state="translated">이름, 속기</target>
        </trans-unit>
        <trans-unit id="8a29a693635ff053d60f13d45c498d4748366dda" translate="yes" xml:space="preserve">
          <source>Named &lt;a href=&quot;../compose-file-v2/index#volume-configuration-reference&quot;&gt;volumes&lt;/a&gt; can be declared under the &lt;code&gt;volumes&lt;/code&gt; key, and &lt;a href=&quot;../compose-file-v2/index#network-configuration-reference&quot;&gt;networks&lt;/a&gt; can be declared under the &lt;code&gt;networks&lt;/code&gt; key.</source>
          <target state="translated">명명 된 &lt;a href=&quot;../compose-file-v2/index#volume-configuration-reference&quot;&gt;볼륨은&lt;/a&gt; 언더 선언 할 수 있습니다 &lt;code&gt;volumes&lt;/code&gt; 키 및 &lt;a href=&quot;../compose-file-v2/index#network-configuration-reference&quot;&gt;네트워크는&lt;/a&gt; 언더 선언 할 수 &lt;code&gt;networks&lt;/code&gt; 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="18968e128cc1700bdb88c59bc81fb9e50422f360" translate="yes" xml:space="preserve">
          <source>Names of the networks attached to this container.</source>
          <target state="translated">이 컨테이너에 연결된 네트워크의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b54976080a8f9f2a48c3af0d58716abaaf956c8b" translate="yes" xml:space="preserve">
          <source>Names of the volumes mounted in this container.</source>
          <target state="translated">이 컨테이너에 마운트 된 볼륨의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="117a667ff0c64e26e679810f1e7a105c8edb7f5d" translate="yes" xml:space="preserve">
          <source>Namespace isolation only.</source>
          <target state="translated">네임 스페이스 격리 만</target>
        </trans-unit>
        <trans-unit id="b5ac620ce518081217aad94247bfffb1b7cea151" translate="yes" xml:space="preserve">
          <source>Netshare plugin</source>
          <target state="translated">넷 셰어 플러그인</target>
        </trans-unit>
        <trans-unit id="53ebc572b4a44802ba114729f07bdaaf5409a9d7" translate="yes" xml:space="preserve">
          <source>Network</source>
          <target state="translated">Network</target>
        </trans-unit>
        <trans-unit id="0a3cc0d3967af3a4a2ce3debb6f49ac54bbc6c70" translate="yes" xml:space="preserve">
          <source>Network ID</source>
          <target state="translated">네트워크 ID</target>
        </trans-unit>
        <trans-unit id="8baad1cbc284c12f56ea33b670eb34325f6b8199" translate="yes" xml:space="preserve">
          <source>Network IO</source>
          <target state="translated">네트워크 IO</target>
        </trans-unit>
        <trans-unit id="96c1204e5bdf557b4758a5c227378af4fd1e4baf" translate="yes" xml:space="preserve">
          <source>Network attachments</source>
          <target state="translated">네트워크 첨부</target>
        </trans-unit>
        <trans-unit id="167bc25bedd90a2e13c74d4d83597339d7fdab34" translate="yes" xml:space="preserve">
          <source>Network configuration reference</source>
          <target state="translated">네트워크 구성 참조</target>
        </trans-unit>
        <trans-unit id="35aa5aad6b0c9ad6328f38fe72b3bd771502da1c" translate="yes" xml:space="preserve">
          <source>Network driver</source>
          <target state="translated">네트워크 드라이버</target>
        </trans-unit>
        <trans-unit id="8cfa0ea99a9b82d6628de987b0deee821e48e566" translate="yes" xml:space="preserve">
          <source>Network implications of stopping, pausing, or restarting containers</source>
          <target state="translated">컨테이너 중지, 일시 중지 또는 다시 시작의 네트워크 영향</target>
        </trans-unit>
        <trans-unit id="6b090a7a0a1f781c60ebe095f4f99630c7c704a9" translate="yes" xml:space="preserve">
          <source>Network ingress mode</source>
          <target state="translated">네트워크 수신 모드</target>
        </trans-unit>
        <trans-unit id="84f8b556b30a3fd21cd79a5f2533917f840f443f" translate="yes" xml:space="preserve">
          <source>Network internal mode</source>
          <target state="translated">네트워크 내부 모드</target>
        </trans-unit>
        <trans-unit id="7aade3cb20bac3d51aa3479095ea9192d988bd33" translate="yes" xml:space="preserve">
          <source>Network mode. Use the same values as the docker client &lt;code&gt;--net&lt;/code&gt; parameter, plus the special form &lt;code&gt;service:[service name]&lt;/code&gt;.</source>
          <target state="translated">네트워크 모드. docker client &lt;code&gt;--net&lt;/code&gt; 매개 변수 와 동일한 값과 특수 양식 &lt;code&gt;service:[service name]&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba58a6be58c603cdd3b1b52d4cef98c772990b3b" translate="yes" xml:space="preserve">
          <source>Network mode. Use the same values as the docker client &lt;code&gt;--net&lt;/code&gt; parameter. The &lt;code&gt;container:...&lt;/code&gt; form can take a service name instead of a container name or id.</source>
          <target state="translated">네트워크 모드. docker client &lt;code&gt;--net&lt;/code&gt; 매개 변수 와 동일한 값을 사용하십시오 . &lt;code&gt;container:...&lt;/code&gt; 형태는 서비스 이름 대신 컨테이너 이름이나 ID를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f368f8e9d0b932c508cca5bb69a0168f28fb6de6" translate="yes" xml:space="preserve">
          <source>Network mode. Use the same values as the docker client &lt;code&gt;--network&lt;/code&gt; parameter, plus the special form &lt;code&gt;service:[service name]&lt;/code&gt;.</source>
          <target state="translated">네트워크 모드. docker client &lt;code&gt;--network&lt;/code&gt; 매개 변수 와 동일한 값과 특수 양식 &lt;code&gt;service:[service name]&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5b4702201b4664d10d25eb8965c93e110a9c62c" translate="yes" xml:space="preserve">
          <source>Network name</source>
          <target state="translated">네트워크 이름</target>
        </trans-unit>
        <trans-unit id="6eb454694b246b6b9c739f45ec44537cc54602d3" translate="yes" xml:space="preserve">
          <source>Network names must be unique. The Docker daemon attempts to identify naming conflicts but this is not guaranteed. It is the user&amp;rsquo;s responsibility to avoid name conflicts.</source>
          <target state="translated">네트워크 이름은 고유해야합니다. Docker 데몬은 이름 충돌을 식별하려고 시도하지만 이것이 보장되지는 않습니다. 이름 충돌을 피하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="fddefdacfa6d4b3cec136db3f8013973e48b973a" translate="yes" xml:space="preserve">
          <source>Network plugin protocol</source>
          <target state="translated">네트워크 플러그인 프로토콜</target>
        </trans-unit>
        <trans-unit id="32916143a353219e82281e4ef7bb794c89001a31" translate="yes" xml:space="preserve">
          <source>Network plugins</source>
          <target state="translated">네트워크 플러그인</target>
        </trans-unit>
        <trans-unit id="0d5a11f0c10edd2b2ab98d3d184edd4f2a778321" translate="yes" xml:space="preserve">
          <source>Network plugins and swarm mode</source>
          <target state="translated">네트워크 플러그인 및 스웜 모드</target>
        </trans-unit>
        <trans-unit id="fcdf1dd47fc0b42ab6625050371361d5046ccc50" translate="yes" xml:space="preserve">
          <source>Network plugins are written by third parties, and are published by those third parties, either on &lt;a href=&quot;https://store.docker.com/search?category=network&amp;amp;q=&amp;amp;type=plugin&quot;&gt;Docker Store&lt;/a&gt; or on the third party&amp;rsquo;s site.</source>
          <target state="translated">네트워크 플러그인은 타사에서 작성하며 &lt;a href=&quot;https://store.docker.com/search?category=network&amp;amp;q=&amp;amp;type=plugin&quot;&gt;Docker Store&lt;/a&gt; 또는 타사 사이트에서 해당 타사에서 게시합니다.</target>
        </trans-unit>
        <trans-unit id="8467c079abae3169326f67640f6bad10aa1e2071" translate="yes" xml:space="preserve">
          <source>Network plugins implement the &lt;a href=&quot;../plugin_api/index&quot;&gt;Docker plugin API&lt;/a&gt; and the network plugin protocol</source>
          <target state="translated">네트워크 플러그인은 &lt;a href=&quot;../plugin_api/index&quot;&gt;Docker 플러그인 API&lt;/a&gt; 및 네트워크 플러그인 프로토콜을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="f6d36e60f925e856446ee20a386b06b76ad9629a" translate="yes" xml:space="preserve">
          <source>Network scope (local, global)</source>
          <target state="translated">네트워크 범위 (로컬, 글로벌)</target>
        </trans-unit>
        <trans-unit id="e5f8b762c250cf3c96a82100eea54a1d276d390a" translate="yes" xml:space="preserve">
          <source>Network settings</source>
          <target state="translated">네트워크 설정</target>
        </trans-unit>
        <trans-unit id="3564e7d4b2accdec337d0880198fce2f38d983f8" translate="yes" xml:space="preserve">
          <source>Network: bridge</source>
          <target state="translated">네트워크 : 다리</target>
        </trans-unit>
        <trans-unit id="5d12cbd392a8a73722dc3e5b2b977a561cb19028" translate="yes" xml:space="preserve">
          <source>Network: container</source>
          <target state="translated">네트워크 : 컨테이너</target>
        </trans-unit>
        <trans-unit id="37c130287db9670ce7398782e5e587d2890fbb9e" translate="yes" xml:space="preserve">
          <source>Network: host</source>
          <target state="translated">네트워크 : 호스트</target>
        </trans-unit>
        <trans-unit id="3efaaf97c6e312648e58b0fe6987ecf924673093" translate="yes" xml:space="preserve">
          <source>Network: none</source>
          <target state="translated">네트워크 : 없음</target>
        </trans-unit>
        <trans-unit id="be484398a70d567ad075797b2899557f4448c1c0" translate="yes" xml:space="preserve">
          <source>Networking in Compose</source>
          <target state="translated">작성 네트워크</target>
        </trans-unit>
        <trans-unit id="e931cb5b030b0b23b76dc4c2cda72c59d8286727" translate="yes" xml:space="preserve">
          <source>Networks</source>
          <target state="translated">Networks</target>
        </trans-unit>
        <trans-unit id="18f84c1c489b7cd21f6dad6352f11fc31d83525c" translate="yes" xml:space="preserve">
          <source>Networks &lt;code&gt;[]string&lt;/code&gt;</source>
          <target state="translated">네트워크 &lt;code&gt;[]string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca73ef28e59159a1eec600baf211c40ee0328de0" translate="yes" xml:space="preserve">
          <source>Networks and volumes defined as &lt;code&gt;external&lt;/code&gt; are never removed.</source>
          <target state="translated">&lt;code&gt;external&lt;/code&gt; 로 정의 된 네트워크 및 볼륨 은 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1488c7592780bc2bddd9bfa66fbb9c8877e6322" translate="yes" xml:space="preserve">
          <source>Networks can also be given a &lt;a href=&quot;../compose-file/index#name-1&quot;&gt;custom name&lt;/a&gt; (since version 3.5):</source>
          <target state="translated">네트워크에는 &lt;a href=&quot;../compose-file/index#name-1&quot;&gt;사용자 지정 이름을&lt;/a&gt; 지정할 수도 있습니다 (버전 3.5부터).</target>
        </trans-unit>
        <trans-unit id="5a9347be96119f963b20d8e4624030bc2cfe50f4" translate="yes" xml:space="preserve">
          <source>Networks can be configured with static IP addresses by setting the &lt;a href=&quot;../compose-file/compose-file-v2/index#ipv4-address-ipv6-address&quot;&gt;ipv4_address and/or ipv6_address&lt;/a&gt; for each attached network.</source>
          <target state="translated">연결된 각 네트워크에 대해 &lt;a href=&quot;../compose-file/compose-file-v2/index#ipv4-address-ipv6-address&quot;&gt;ipv4_address 및 / 또는 ipv6_address&lt;/a&gt; 를 설정하여 고정 IP 주소로 네트워크를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f46dc0e6e735c3a9b30f608ddf276ef327ba8c34" translate="yes" xml:space="preserve">
          <source>Networks defined in the &lt;code&gt;networks&lt;/code&gt; section of the Compose file</source>
          <target state="translated">작성 파일 의 &lt;code&gt;networks&lt;/code&gt; 섹션에 정의 된 네트워크</target>
        </trans-unit>
        <trans-unit id="620542cfb14105c061a649409afc05719d5aa6bf" translate="yes" xml:space="preserve">
          <source>Networks that the service containers should be connected to. An entity deploying a bundle should create networks as needed.</source>
          <target state="translated">서비스 컨테이너가 연결되어야하는 네트워크 번들을 배포하는 엔티티는 필요에 따라 네트워크를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="0bdea07641e36036e56d89fe7614b6bd8eba1aa7" translate="yes" xml:space="preserve">
          <source>Networks to join, referencing entries under the &lt;a href=&quot;#network-configuration-reference&quot;&gt;top-level &lt;code&gt;networks&lt;/code&gt; key&lt;/a&gt;.</source>
          <target state="translated">네트워크는 아래 항목을 참조, 가입 &lt;a href=&quot;#network-configuration-reference&quot;&gt;최상위 &lt;code&gt;networks&lt;/code&gt; 키&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e51ecf0ef706a7e3573a5caadea3c8ad03351e0" translate="yes" xml:space="preserve">
          <source>New collections created by a Docker 1.11 Engine client cause the server manage to the snapshot key by default. To reclaim control of the snapshot key on the client, use the &lt;code&gt;notary key rotate&lt;/code&gt; command without the &lt;code&gt;-r&lt;/code&gt; flag.</source>
          <target state="translated">Docker 1.11 Engine 클라이언트에 의해 생성 된 새로운 컬렉션은 서버가 기본적으로 스냅 샷 키를 관리하게합니다. 클라이언트에서 스냅 샷 키를 제어하려면 &lt;code&gt;-r&lt;/code&gt; 플래그 없이 &lt;code&gt;notary key rotate&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="88f9460cdba223a64badee58be920b07fb4009dc" translate="yes" xml:space="preserve">
          <source>Next we will need to add the delegation public key to the Notary server; this is specific to a particular image repository in Notary known as a Global Unique Name (GUN). If this is the first time you are adding a delegation to that repository, this command will also initiate the repository, using a local Notary canonical root key. To understand more about initiating a repository, and the role of delegations, head to &lt;a href=&quot;../trust_delegation/index#managing-delegations-in-a-notary-server&quot;&gt;delegations for content trust&lt;/a&gt;.</source>
          <target state="translated">다음으로 위임 공개 키를 Notary 서버에 추가해야합니다. 이것은 GUN (Global Unique Name)으로 알려진 Notary의 특정 이미지 저장소에만 해당됩니다. 해당 저장소에 위임을 처음 추가하는 경우이 명령은 로컬 Notary 표준 루트 키를 사용하여 저장소를 시작합니다. 리포지토리 시작 및 위임의 역할에 대한 자세한 내용을 보려면 &lt;a href=&quot;../trust_delegation/index#managing-delegations-in-a-notary-server&quot;&gt;콘텐츠 신뢰 담당 위임으로 이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be0c3a9ca09954ad383f644fe4dbce7914f476be" translate="yes" xml:space="preserve">
          <source>Next, create a bootstrap &lt;code&gt;Gemfile&lt;/code&gt; which just loads Rails. It&amp;rsquo;ll be overwritten in a moment by &lt;code&gt;rails new&lt;/code&gt;.</source>
          <target state="translated">그런 다음 Rails 만로드 하는 부트 스트랩 &lt;code&gt;Gemfile&lt;/code&gt; 을 만듭니다 . &lt;code&gt;rails new&lt;/code&gt; 로 잠시 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d864baa3671c53b36acf459bbaa5bd02cd9f88d2" translate="yes" xml:space="preserve">
          <source>Next, execute a command on the container.</source>
          <target state="translated">그런 다음 컨테이너에서 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c1e9bf67beda1e60e925fd792fbd4cdc38a04db0" translate="yes" xml:space="preserve">
          <source>Next, execute an interactive &lt;code&gt;bash&lt;/code&gt; shell on the container.</source>
          <target state="translated">다음으로 컨테이너에서 대화식 &lt;code&gt;bash&lt;/code&gt; 쉘을 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="d71be7a9fc4d22e943beae9d489b100c2cefb81c" translate="yes" xml:space="preserve">
          <source>Next, learn about how to &lt;a href=&quot;../drain-node/index&quot;&gt;drain a node&lt;/a&gt; in the swarm.</source>
          <target state="translated">다음으로, 떼에서 &lt;a href=&quot;../drain-node/index&quot;&gt;노드&lt;/a&gt; 를 배수하는 방법에 대해 배웁니다 .</target>
        </trans-unit>
        <trans-unit id="df9f3dba9b9a15590801c21bc8508e5b79dff4e6" translate="yes" xml:space="preserve">
          <source>Next, provide an entrypoint script to fix a Rails-specific issue that prevents the server from restarting when a certain &lt;code&gt;server.pid&lt;/code&gt; file pre-exists. This script will be executed every time the container gets started. &lt;code&gt;entrypoint.sh&lt;/code&gt; consists of:</source>
          <target state="translated">다음으로 특정 &lt;code&gt;server.pid&lt;/code&gt; 파일이 존재할 때 서버가 다시 시작되지 않도록하는 Rails 관련 문제를 해결하는 진입 점 스크립트를 제공 하십시오. 이 스크립트는 컨테이너가 시작될 때마다 실행됩니다. &lt;code&gt;entrypoint.sh&lt;/code&gt; 는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f7f34dbc99394babd2ab430691aafe0c48b016ca" translate="yes" xml:space="preserve">
          <source>Next, set an environment variable in the current bash session.</source>
          <target state="translated">다음으로 현재 bash 세션에서 환경 변수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="86392ec1c9e3e6cb524e5d751f4c215c12d606cf" translate="yes" xml:space="preserve">
          <source>Next, try the quick start guide for &lt;a href=&quot;../django/index&quot;&gt;Django&lt;/a&gt;, &lt;a href=&quot;../rails/index&quot;&gt;Rails&lt;/a&gt;, or &lt;a href=&quot;https://docs.docker.com/samples/library/wordpress/&quot;&gt;WordPress&lt;/a&gt;</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../django/index&quot;&gt;Django&lt;/a&gt; , &lt;a href=&quot;../rails/index&quot;&gt;Rails&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.docker.com/samples/library/wordpress/&quot;&gt;WordPress&lt;/a&gt; 의 빠른 시작 안내서를 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="85607956e4c196d071593872cdc088a63ced9728" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;re going to sign the public key with our CA:</source>
          <target state="translated">다음으로 CA와 공개 키에 서명합니다.</target>
        </trans-unit>
        <trans-unit id="d6cb807a024758b7ab671e44846b9b97caa4bfe1" translate="yes" xml:space="preserve">
          <source>Next, you can &lt;a href=&quot;../scale-service/index&quot;&gt;change the scale&lt;/a&gt; for the service running in the swarm.</source>
          <target state="translated">다음으로, swarm에서 실행되는 서비스 &lt;a href=&quot;../scale-service/index&quot;&gt;의 규모&lt;/a&gt; 를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="238be3f8155454f1a1aeb8b9315afe1e30c3c724" translate="yes" xml:space="preserve">
          <source>Nginx example profile</source>
          <target state="translated">Nginx 예제 프로파일</target>
        </trans-unit>
        <trans-unit id="60852cedd43d2d58e10dc1710719289417d70c62" translate="yes" xml:space="preserve">
          <source>Nimble Storage Volume Plugin</source>
          <target state="translated">민첩한 스토리지 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="6399f9053c8784cf12c6ba054ac5c49836b7ca23" translate="yes" xml:space="preserve">
          <source>No ENTRYPOINT</source>
          <target state="translated">진입 점 없음</target>
        </trans-unit>
        <trans-unit id="1fac2d9e8e1390366efe91bb0c10387109ea5e97" translate="yes" xml:space="preserve">
          <source>No markdown files are included in the context except README files other than &lt;code&gt;README-secret.md&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;README-secret.md&lt;/code&gt; 이외의 README 파일을 제외하고 컨텍스트에 마크 다운 파일이 포함되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a38123105e3af48cf78a01e05911f47ef41a8121" translate="yes" xml:space="preserve">
          <source>No matter where &lt;code&gt;docker run&lt;/code&gt; executes, it pulls your image, along with Python and all the dependencies from &lt;code&gt;requirements.txt&lt;/code&gt;, and runs your code. It all travels together in a neat little package, and you don&amp;rsquo;t need to install anything on the host machine for Docker to run it.</source>
          <target state="translated">&lt;code&gt;docker run&lt;/code&gt; 이 실행 되는 위치에 관계없이 Python과 함께 이미지와 &lt;code&gt;requirements.txt&lt;/code&gt; 의 모든 종속성을 가져 와서 코드를 실행합니다. 그것은 모두 깔끔한 작은 패키지로 함께 여행되며 Docker가 실행하기 위해 호스트 시스템에 아무것도 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f6e3d6b7da8a3567b8e29e22a615f119b7ebf97" translate="yes" xml:space="preserve">
          <source>No networking in the container.</source>
          <target state="translated">컨테이너에 네트워킹이 없습니다.</target>
        </trans-unit>
        <trans-unit id="31ef4328a40d9038cfc997a8c36bed85e2e315d4" translate="yes" xml:space="preserve">
          <source>No other keys are needed, since the attacker can just any rotate or all of them to ones that they generate. With these keys, they can set up a mirror to serve malicious data - any malicious data at all, given that they have access to all the keys.</source>
          <target state="translated">다른 키는 필요하지 않습니다. 공격자가 생성 한 키로 회전하거나 전부 회전 할 수 있기 때문입니다. 이러한 키를 사용하면 모든 키에 액세스 할 수있는 악의적 인 데이터 (악의적 인 데이터)를 제공하도록 미러를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f0bbd3d2b33bac92d611cbcb4083565b0d4c06b" translate="yes" xml:space="preserve">
          <source>No path expansion is done if you have also specified a &lt;code&gt;volume_driver&lt;/code&gt;. For example, if you specify a mapping of &lt;code&gt;./foo:/data&lt;/code&gt;, the &lt;code&gt;./foo&lt;/code&gt; part is passed straight to the volume driver without being expanded.</source>
          <target state="translated">&lt;code&gt;volume_driver&lt;/code&gt; 도 지정한 경우 경로 확장이 수행되지 않습니다 . 예를 들어 &lt;code&gt;./foo:/data&lt;/code&gt; 의 매핑을 지정 하면 &lt;code&gt;./foo&lt;/code&gt; 부분이 확장되지 않고 볼륨 드라이버로 바로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d194595d3a38fe9dbfc9ad36f97dbfb397d2f2f4" translate="yes" xml:space="preserve">
          <source>No value indicates a worker node that does not participate in swarm management.</source>
          <target state="translated">값이 없으면 swarm 관리에 참여하지 않는 작업자 노드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="03cd78554aa5d97f60726ab2767d5b03be8344a7" translate="yes" xml:space="preserve">
          <source>Node Generic Resources</source>
          <target state="translated">노드 일반 자원</target>
        </trans-unit>
        <trans-unit id="d9bcd10ae0282fcbf46ad9fd0bf1874a5bd2ef06" translate="yes" xml:space="preserve">
          <source>Node Hostname</source>
          <target state="translated">노드 호스트 이름</target>
        </trans-unit>
        <trans-unit id="30ee552d63e50d10e2c2248120d4a87b66df325c" translate="yes" xml:space="preserve">
          <source>Node ID</source>
          <target state="translated">노드 ID</target>
        </trans-unit>
        <trans-unit id="97a2ed4558a69a0f65845995074fbcf40e4e4881" translate="yes" xml:space="preserve">
          <source>Node availability (&amp;ldquo;active&amp;rdquo;, &amp;ldquo;pause&amp;rdquo;, or &amp;ldquo;drain&amp;rdquo;)</source>
          <target state="translated">노드 가용성 (&amp;ldquo;active&amp;rdquo;,&amp;ldquo;pause&amp;rdquo;또는&amp;ldquo;drain&amp;rdquo;)</target>
        </trans-unit>
        <trans-unit id="0f408cf44c0310e65e30764772e6758f0be5b548" translate="yes" xml:space="preserve">
          <source>Node discovery</source>
          <target state="translated">노드 발견</target>
        </trans-unit>
        <trans-unit id="5de3566e506938021a2d9cdea89a34345ecb95da" translate="yes" xml:space="preserve">
          <source>Node hostname</source>
          <target state="translated">노드 호스트 이름</target>
        </trans-unit>
        <trans-unit id="f1c2ab4a0411bd81a10c2a3bf88ecac10876fb92" translate="yes" xml:space="preserve">
          <source>Node labels provide a flexible method of node organization. You can also use node labels in service constraints. Apply constraints when you create a service to limit the nodes where the scheduler assigns tasks for the service.</source>
          <target state="translated">노드 레이블은 유연한 노드 구성 방법을 제공합니다. 서비스 제약 조건에서 노드 레이블을 사용할 수도 있습니다. 스케줄러가 서비스에 대한 태스크를 지정하는 노드를 제한하기 위해 서비스를 작성할 때 제한 조건을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="33caff309067ff7a3190f207fd4cbfe252c4a208" translate="yes" xml:space="preserve">
          <source>Node of the daemon (&lt;code&gt;true/false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;indicates that the node is the same as current docker daemon)</source>
          <target state="translated">데몬의 노드 ( &lt;code&gt;true/false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 는 노드가 현재 docker 데몬과 동일 함을 나타냅니다)</target>
        </trans-unit>
        <trans-unit id="d23a32c64a3fc2816b9f836b53d4c9c8b7d5aeb1" translate="yes" xml:space="preserve">
          <source>Node role</source>
          <target state="translated">노드 역할</target>
        </trans-unit>
        <trans-unit id="70c248daad57d36ae1df7530a676ad77bcc00952" translate="yes" xml:space="preserve">
          <source>Node status</source>
          <target state="translated">노드 상태</target>
        </trans-unit>
        <trans-unit id="9e325452c6548fc2449564842660d75ef3b1eb73" translate="yes" xml:space="preserve">
          <source>Nodes</source>
          <target state="translated">Nodes</target>
        </trans-unit>
        <trans-unit id="17f74cb809ac518a0c64cd7486e589deeef1ecdb" translate="yes" xml:space="preserve">
          <source>Nodes require a secret token to join the swarm. The token for worker nodes is different from the token for manager nodes. Nodes only use the join-token at the moment they join the swarm. Rotating the join token after a node has already joined a swarm does not affect the node&amp;rsquo;s swarm membership. Token rotation ensures an old token cannot be used by any new nodes attempting to join the swarm.</source>
          <target state="translated">노드는 떼에 가입하기 위해 비밀 토큰이 필요합니다. 작업자 노드 토큰은 관리자 노드 토큰과 다릅니다. 노드는 떼에 합류하는 순간에만 조인 토큰을 사용합니다. 노드가 이미 웜에 가입 한 후 조인 토큰을 회전해도 노드의 웜 멤버쉽에는 영향을 미치지 않습니다. 토큰 회전은 스웜에 참여하려는 새 노드가 이전 토큰을 사용할 수 없도록합니다.</target>
        </trans-unit>
        <trans-unit id="fc9016d789b5baac4302ce4bd3ab6986fa0c1543" translate="yes" xml:space="preserve">
          <source>Nodes which are missing the label used to spread still receive task assignments. As a group, these nodes receive tasks in equal proportion to any of the other groups identified by a specific label value. In a sense, a missing label is the same as having the label with a null value attached to it. If the service should &lt;strong&gt;only&lt;/strong&gt; run on nodes with the label being used for the spread preference, the preference should be combined with a constraint.</source>
          <target state="translated">확산에 사용 된 레이블이없는 노드는 여전히 작업 지정을받습니다. 그룹으로서 이러한 노드는 특정 레이블 값으로 식별 된 다른 그룹과 동일한 비율로 작업을받습니다. 어떤 의미에서, 누락 된 레이블은 널값이 붙은 레이블을 갖는 것과 같습니다. 스프레드 환경 설정에 사용되는 레이블이있는 노드 &lt;strong&gt;에서만&lt;/strong&gt; 서비스를 실행 해야하는 &lt;strong&gt;경우&lt;/strong&gt; 환경 설정을 제한 조건과 결합해야합니다.</target>
        </trans-unit>
        <trans-unit id="44b104392f496c73ef0862d47b81a1a25d2cfa51" translate="yes" xml:space="preserve">
          <source>Non line-breaking whitespace is permitted in a parser directive. Hence, the following lines are all treated identically:</source>
          <target state="translated">파서 지시문에는 줄 바꿈이없는 공백이 허용됩니다. 따라서 다음 줄은 모두 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="48cec5b8c3c36a4eac8509bef7910ad467642df4" translate="yes" xml:space="preserve">
          <source>Normally, updating a service will only cause the service&amp;rsquo;s tasks to be replaced with new ones if a change to the service requires recreating the tasks for it to take effect. For example, only changing the &lt;code&gt;--update-parallelism&lt;/code&gt; setting will not recreate the tasks, because the individual tasks are not affected by this setting. However, the &lt;code&gt;--force&lt;/code&gt; flag will cause the tasks to be recreated anyway. This can be used to perform a rolling restart without any changes to the service parameters.</source>
          <target state="translated">일반적으로 서비스를 업데이트하면 서비스를 변경하기 위해 작업을 다시 작성해야하는 경우 서비스 작업이 새 작업으로 대체됩니다. 예를 들어 개별 작업은이 설정의 영향을받지 않으므로 &lt;code&gt;--update-parallelism&lt;/code&gt; 설정 만 변경하면 작업이 다시 만들어지지 않습니다. 그러나 &lt;code&gt;--force&lt;/code&gt; 플래그를 사용하면 작업이 다시 만들어집니다. 서비스 매개 변수를 변경하지 않고 롤링 재시작을 수행하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a561a666d179ca85f5eca5281a4cc29dc561d4" translate="yes" xml:space="preserve">
          <source>Not applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13d3310c3b9d55f01410d93cb630fd4e6bf4ea9" translate="yes" xml:space="preserve">
          <source>Not possible to set using short syntax.</source>
          <target state="translated">짧은 구문을 사용하여 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe5fd3defe6de12664b502e100fb837128c517d1" translate="yes" xml:space="preserve">
          <source>Not supported for &lt;code&gt;docker stack deploy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;docker stack deploy&lt;/code&gt; 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="5ed79bdaba84564136166caaf0df7f080287e215" translate="yes" xml:space="preserve">
          <source>Not supported for version 2 &lt;code&gt;docker-compose&lt;/code&gt; files. Use &lt;a href=&quot;#network_mode&quot;&gt;network_mode&lt;/a&gt; instead.</source>
          <target state="translated">버전 2 &lt;code&gt;docker-compose&lt;/code&gt; 파일에는 지원되지 않습니다 . 대신 &lt;a href=&quot;#network_mode&quot;&gt;network_mode&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c18043740e10cfe580ee92182ccc51157b710f59" translate="yes" xml:space="preserve">
          <source>Not supported in Compose File version 3</source>
          <target state="translated">Compose File 버전 3에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8425dd90bdc24493968502b375350be12832f07" translate="yes" xml:space="preserve">
          <source>Notary</source>
          <target state="translated">Notary</target>
        </trans-unit>
        <trans-unit id="9f23ac875f928053c24e9643c158d4e7ead9e0dc" translate="yes" xml:space="preserve">
          <source>Notary Canonical Root Key ID (DCT Root Key) is an ID that describes &lt;em&gt;just&lt;/em&gt; the root key used to sign a repository (or rather its respective keys). This is the root key on the host that originally signed the repository (i.e. your workstation). This can be retrieved from the workstation that signed the repository through &lt;code&gt;$ grep -r &quot;root&quot; ~/.docker/trust/private/&lt;/code&gt; (Assuming your trust data is at &lt;code&gt;~/.docker/trust/*&lt;/code&gt;). It is expected that this canonical ID has initiated multiple image repositories (&lt;code&gt;mydtr/user1/image1&lt;/code&gt; and &lt;code&gt;mydtr/user1/image2&lt;/code&gt;).</source>
          <target state="translated">공증인 정식 루트 키 ID (DCT 루트 키)를 설명하는 ID입니다 &lt;em&gt;단지&lt;/em&gt; 저장소 (또는 오히려 각각의 키)에 서명하는 데 사용되는 루트 키를 누릅니다. 이것은 원래 저장소에 서명 한 호스트 (즉, 워크 스테이션)의 루트 키입니다. &lt;code&gt;$ grep -r &quot;root&quot; ~/.docker/trust/private/&lt;/code&gt; 통해 저장소에 서명 한 워크 스테이션에서이를 검색 할 수 있습니다 (신뢰 데이터가 &lt;code&gt;~/.docker/trust/*&lt;/code&gt; 라고 가정 ). 이 표준 ID는 여러 이미지 저장소 ( &lt;code&gt;mydtr/user1/image1&lt;/code&gt; 및 &lt;code&gt;mydtr/user1/image2&lt;/code&gt; )를 시작했을 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e23773d2db943d17d33f1b60837b2b715f0a73" translate="yes" xml:space="preserve">
          <source>Notary Client Configuration File</source>
          <target state="translated">공증인 클라이언트 구성 파일</target>
        </trans-unit>
        <trans-unit id="db4c0f3212971f1e2f9cb9a9452a6575b05a3674" translate="yes" xml:space="preserve">
          <source>Notary Root key ID (DCT Certificate ID) is an ID that describes the same, but the ID is unique per repository. For example, &lt;code&gt;mydtr/user1/image1&lt;/code&gt; and &lt;code&gt;mydtr/usr1/image2&lt;/code&gt; will have unique certificate IDs. A certificate ID can be retrieved through a &lt;code&gt;$ docker trust inspect&lt;/code&gt; command and is labelled as a root-key (referring back to the Notary key name). This is designed for when different users are signing their own repositories, for example, when there is no central signing server. As a cert-id is more granular, it would take priority if a conflict occurs over a root ID.</source>
          <target state="translated">공증인 루트 키 ID (DCT 인증서 ID)는 동일한 것을 설명하는 ID이지만 저장소마다 고유합니다. 예를 들어, &lt;code&gt;mydtr/user1/image1&lt;/code&gt; 및 &lt;code&gt;mydtr/usr1/image2&lt;/code&gt; 에는 고유 한 인증서 ID가 있습니다. 인증서 ID는 &lt;code&gt;$ docker trust inspect&lt;/code&gt; 명령을 통해 검색 할 수 있으며 루트 키로 표시됩니다 (공증인 키 이름 참조). 중앙 서명 서버가없는 경우와 같이 다른 사용자가 자신의 리포지토리에 서명 할 때 사용하도록 설계되었습니다. cert-id가 더 세분화되므로 루트 ID를 통해 충돌이 발생하면 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2353d50d9ad55e59211ddd641d5913ce406c0c1e" translate="yes" xml:space="preserve">
          <source>Notary Server Configuration File</source>
          <target state="translated">공증인 서버 구성 파일</target>
        </trans-unit>
        <trans-unit id="2d324b7b0ff34981b45dcfc57a72c4cb955df56b" translate="yes" xml:space="preserve">
          <source>Notary Signer Configuration File</source>
          <target state="translated">공증인 서명자 구성 파일</target>
        </trans-unit>
        <trans-unit id="03ba794233cbf9d9c89193a8dda6e64a7a401e81" translate="yes" xml:space="preserve">
          <source>Notary can be used with &lt;a href=&quot;https://www.yubico.com/products/yubikey-hardware/yubikey4/&quot;&gt;Yubikey 4&lt;/a&gt; keys, via a PKCS11 interface when the Yubikey has CCID mode enabled. The Yubikey is prioritized to store root keys, and requires user touch-input for signing. Yubikey support is included with the Docker Engine 1.11 client for use with Docker Content Trust.</source>
          <target state="translated">Yubikey에 CCID 모드가 활성화되어 있으면 PKCS11 인터페이스를 통해 공증인을 &lt;a href=&quot;https://www.yubico.com/products/yubikey-hardware/yubikey4/&quot;&gt;Yubikey 4&lt;/a&gt; 키 와 함께 사용할 수 있습니다 . Yubikey는 루트 키를 저장하도록 우선 순위가 지정되며 서명하려면 사용자 터치 입력이 필요합니다. Docker Content Trust와 함께 사용하기 위해 Yubikey 지원이 Docker Engine 1.11 클라이언트에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c141f55a587664a9a3c3435366d68c101c4381" translate="yes" xml:space="preserve">
          <source>Notary can be used with a CDN or other caching system. All GET requests for JSON files may be cached indefinitely &lt;strong&gt;except&lt;/strong&gt; URLs matching:</source>
          <target state="translated">공증인은 CDN 또는 기타 캐싱 시스템과 함께 사용할 수 있습니다. 다음과 일치하는 URL을 &lt;strong&gt;제외하고&lt;/strong&gt; JSON 파일에 대한 모든 GET 요청은 무기한 캐시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49fbaaa6a941137bf2f9c27641f53cc80f208760" translate="yes" xml:space="preserve">
          <source>Notary client configuration file</source>
          <target state="translated">공증인 클라이언트 구성 파일</target>
        </trans-unit>
        <trans-unit id="0f0df0aa3817459ef6e7a5169d055be08fad7156" translate="yes" xml:space="preserve">
          <source>Notary client keys and credentials compromise</source>
          <target state="translated">공증인 클라이언트 키 및 자격 증명 손상</target>
        </trans-unit>
        <trans-unit id="3a11adbb03247e1aa5cc111d8b07cae7b6afe595" translate="yes" xml:space="preserve">
          <source>Notary clients pull metadata from one or more (remote) Notary services. Some Notary clients push metadata to one or more Notary services.</source>
          <target state="translated">공증인 클라이언트는 하나 이상의 (원격) 공증인 서비스에서 메타 데이터를 가져옵니다. 일부 Notary 클라이언트는 메타 데이터를 하나 이상의 Notary 서비스로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="b634ca093b4c6fc7ed47a40adc7a6106a114a461" translate="yes" xml:space="preserve">
          <source>Notary configuration files</source>
          <target state="translated">공증인 구성 파일</target>
        </trans-unit>
        <trans-unit id="2cf969b31cdbe5fe9eec8f3bac2009c26e281f70" translate="yes" xml:space="preserve">
          <source>Notary generates and stores signing keys on the host it&amp;rsquo;s running on. This means that the Docker Hub cannot delete tags from the trust data, they must be deleted using the Notary client. You can do this with the &lt;code&gt;notary remove&lt;/code&gt; command. Again, you must direct it to speak to the correct Notary server. Neither you nor the author has permissions to delete tags from the official &lt;code&gt;alpine&lt;/code&gt; repository, so the output below is for demonstration only:</source>
          <target state="translated">Notary는 실행중인 호스트에서 서명 키를 생성하고 저장합니다. 즉, Docker Hub는 신뢰 데이터에서 태그를 삭제할 수 없으며 Notary 클라이언트를 사용하여 태그를 삭제해야합니다. &lt;code&gt;notary remove&lt;/code&gt; 명령으로 이를 수행 할 수 있습니다 . 다시 한 번 올바른 Notary 서버와 통신하도록 지시해야합니다. 귀하 또는 저자 모두 공식 &lt;code&gt;alpine&lt;/code&gt; 저장소 에서 태그를 삭제할 권한이 없으므로 아래 출력은 데모 용입니다.</target>
        </trans-unit>
        <trans-unit id="bc76fe3c233a265eeed22300549b626aed9c408c" translate="yes" xml:space="preserve">
          <source>Notary is a tool for publishing and managing trusted collections of content. Publishers can digitally sign collections and consumers can verify integrity and origin of content. This ability is built on a straightforward key management and signing interface to create signed collections and configure trusted publishers.</source>
          <target state="translated">Notary는 신뢰할 수있는 콘텐츠 모음을 게시하고 관리하기위한 도구입니다. 게시자는 컬렉션에 디지털 서명을 할 수 있으며 소비자는 콘텐츠의 무결성과 출처를 확인할 수 있습니다. 이 기능은 간단한 키 관리 및 서명 인터페이스를 기반으로 서명 된 컬렉션을 만들고 신뢰할 수있는 게시자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="6e2b899daff0ee1b2e0f219daddb06b87885a7e2" translate="yes" xml:space="preserve">
          <source>Notary is a user/client-based system, and it searches for certificates in the user&amp;rsquo;s home directory, at &lt;code&gt;~/.docker/trust&lt;/code&gt;. To streamline using Notary from the command line, create an alias that maps the user&amp;rsquo;s &lt;code&gt;trust&lt;/code&gt; directory to the system&amp;rsquo;s &lt;code&gt;ca-certificates&lt;/code&gt; directory.</source>
          <target state="translated">Notary는 사용자 / 클라이언트 기반 시스템이며 사용자 홈 디렉토리의 &lt;code&gt;~/.docker/trust&lt;/code&gt; 에서 인증서를 검색합니다 . 명령 행에서 Notary를 사용하여 간소화하려면 사용자의 &lt;code&gt;trust&lt;/code&gt; 디렉토리를 시스템의 &lt;code&gt;ca-certificates&lt;/code&gt; 디렉토리에 맵핑하는 별명을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a490668b5c9ae86a240fbfb02749cfc26bae5b9" translate="yes" xml:space="preserve">
          <source>Notary server</source>
          <target state="translated">공증인 서버</target>
        </trans-unit>
        <trans-unit id="419d3099c046e02344217ab9a003bf2930dcd014" translate="yes" xml:space="preserve">
          <source>Notary server also allows you to &lt;a href=&quot;index#hot-logging-level-reload&quot;&gt;increase/decrease&lt;/a&gt; the logging level without having to restart.</source>
          <target state="translated">Notary server를 사용하면 다시 시작하지 않고도 로깅 수준 을 &lt;a href=&quot;index#hot-logging-level-reload&quot;&gt;높이거나 줄일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eed243f9106eef57047270377aeafe62464ca448" translate="yes" xml:space="preserve">
          <source>Notary server and Notary signer communicate over mutually authenticated TLS (using the self-signed testing certs in the repository), and Notary server listens for HTTPS traffic on port 4443.</source>
          <target state="translated">Notary 서버와 Notary 서명자는 저장소에서 자체 서명 된 테스트 인증서를 사용하여 상호 인증 된 TLS를 통해 통신하고 Notary 서버는 포트 4443에서 HTTPS 트래픽을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="e76600e4af5eea334b2c7d6d9df0872687be9d93" translate="yes" xml:space="preserve">
          <source>Notary server compromise</source>
          <target state="translated">공증인 서버 손상</target>
        </trans-unit>
        <trans-unit id="dc62b9861db8ad276322977c410bea7d5052c886" translate="yes" xml:space="preserve">
          <source>Notary server configuration file</source>
          <target state="translated">공증인 서버 구성 파일</target>
        </trans-unit>
        <trans-unit id="0b2cc101d3a9e6add8984aaed94ead7850635db9" translate="yes" xml:space="preserve">
          <source>Notary server database user: &lt;code&gt;SELECT, INSERT, UPDATE, DELETE&lt;/code&gt;</source>
          <target state="translated">공증인 서버 데이터베이스 사용자 : &lt;code&gt;SELECT, INSERT, UPDATE, DELETE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="edafbfefe994ec424552d598ce63c9652703e14b" translate="yes" xml:space="preserve">
          <source>Notary server is the source of truth for the state of a trusted collection of data, storing both client-uploaded and server-generated metadata in the TUF database. The generated timestamp and snapshot metadata certify that the metadata files the client uploaded are the most recent for that trusted collection.</source>
          <target state="translated">공증 서버는 클라이언트 업로드 및 서버 생성 메타 데이터를 모두 TUF 데이터베이스에 저장하는 신뢰할 수있는 데이터 콜렉션 상태의 진실 소스입니다. 생성 된 타임 스탬프 및 스냅 샷 메타 데이터는 클라이언트가 업로드 한 메타 데이터 파일이 해당 신뢰할 수있는 컬렉션에 대한 최신 파일임을 인증합니다.</target>
        </trans-unit>
        <trans-unit id="ed617c59b678af3b880d4ba9075cb26e752d8c8d" translate="yes" xml:space="preserve">
          <source>Notary server optionally supports authentication from clients using &lt;a href=&quot;http://jwt.io/&quot;&gt;JWT&lt;/a&gt; tokens. This requires an authorization server that manages access controls, and a cert bundle from this authorization server containing the public key it uses to sign tokens.</source>
          <target state="translated">공증 서버는 &lt;a href=&quot;http://jwt.io/&quot;&gt;JWT&lt;/a&gt; 토큰을 사용하는 클라이언트의 인증을 선택적으로 지원합니다 . 액세스 제어를 관리하는 권한 부여 서버와 토큰에 서명하는 데 사용하는 공개 키를 포함하는이 권한 부여 서버의 인증 번들이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="66d0d9142ddb32d4955731c6f1775e7c734ed548" translate="yes" xml:space="preserve">
          <source>Notary service architecture</source>
          <target state="translated">공증인 서비스 아키텍처</target>
        </trans-unit>
        <trans-unit id="1e27a237572dc33330f238785e304387b393895f" translate="yes" xml:space="preserve">
          <source>Notary signer &lt;a href=&quot;index#environment-variables-required-if-using-mysql&quot;&gt;requires environment variables&lt;/a&gt; to encrypt private keys at rest. It also requires a configuration file, the path to which is specified on the command line using the &lt;code&gt;-config&lt;/code&gt; flag.</source>
          <target state="translated">공증인 &lt;a href=&quot;index#environment-variables-required-if-using-mysql&quot;&gt;은&lt;/a&gt; 비공개 키를 암호화하기 위해 환경 변수 가 필요합니다 . &lt;code&gt;-config&lt;/code&gt; 플래그를 사용하여 명령 행에 지정된 경로 인 구성 파일도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="564d933165b32affdce3b7d5ad64c25d21532adb" translate="yes" xml:space="preserve">
          <source>Notary signer compromise</source>
          <target state="translated">공증인 서명자</target>
        </trans-unit>
        <trans-unit id="d68347447c95f7745b04ed1be67901ed02af21de" translate="yes" xml:space="preserve">
          <source>Notary signer configuration file</source>
          <target state="translated">공증인 서명자 구성 파일</target>
        </trans-unit>
        <trans-unit id="d7ceb3eac2527a5d3b4ee27cfd0b395b74aad249" translate="yes" xml:space="preserve">
          <source>Notary signer database user: &lt;code&gt;SELECT, INSERT, DELETE&lt;/code&gt;</source>
          <target state="translated">공증인 서명자 데이터베이스 사용자 : &lt;code&gt;SELECT, INSERT, DELETE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e820fe2768baad3cf1111e411577f14fe166c24" translate="yes" xml:space="preserve">
          <source>Notary signer retrieves the necessary encrypted private keys from its database if available, decrypts the keys, and uses them to sign the metadata. If successful, it sends the signatures back to Notary server.</source>
          <target state="translated">공증인은 데이터베이스에서 필요한 암호화 된 개인 키를 검색하고 키를 해독 한 다음이를 사용하여 메타 데이터에 서명합니다. 성공하면 서명을 공증인 서버로 다시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3080621d53ae4405865c12cad6617e2e2f7dc108" translate="yes" xml:space="preserve">
          <source>Notary signer stores the private keys in encrypted form. The alias of the passphrase used to encrypt the keys is also stored. In order to encrypt the keys for storage and decrypt the keys for signing, the passphrase must be passed in as an environment variable.</source>
          <target state="translated">공증인 서명자는 개인 키를 암호화 된 형식으로 저장합니다. 키를 암호화하는 데 사용 된 암호의 별명도 저장됩니다. 저장을 위해 키를 암호화하고 서명을 위해 키를 해독하려면 암호를 환경 변수로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d1cade0dba287c88c56d5d364a14c9a6ad22539" translate="yes" xml:space="preserve">
          <source>Notary stores state in its &lt;code&gt;trust_dir&lt;/code&gt; directory, which is &lt;code&gt;~/.notary&lt;/code&gt; by default or usually &lt;code&gt;~/.docker/trust&lt;/code&gt; when enabling docker content trust. Within this directory, &lt;code&gt;trusted_certificates&lt;/code&gt; stores certificates for bootstrapping trust in a collection, &lt;code&gt;tuf&lt;/code&gt; stores TUF metadata and changelists to be applied to a GUN, and &lt;code&gt;private&lt;/code&gt; stores private keys.</source>
          <target state="translated">그것의 공증 저장 상태 &lt;code&gt;trust_dir&lt;/code&gt; 의 인 디렉토리 &lt;code&gt;~/.notary&lt;/code&gt; 기본 또는 일반적으로 &lt;code&gt;~/.docker/trust&lt;/code&gt; 고정 표시기 콘텐츠 신뢰를 가능하게한다. 이 디렉토리 내에서 &lt;code&gt;trusted_certificates&lt;/code&gt; 는 부트 스트랩 신뢰를위한 인증서를 콜렉션에 저장 하고 &lt;code&gt;tuf&lt;/code&gt; 는 TUF 메타 데이터 및 GUN에 적용 할 변경 목록을 저장 하며 &lt;code&gt;private&lt;/code&gt; 개인 키를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2081c6513b1275fbf4ac08e18d0db98f18a0c08e" translate="yes" xml:space="preserve">
          <source>Notary uses Globally Unique Names (GUNs) to identify trust collections. To enable Notary to run in a multi-tenant fashion, you must use this format when interacting with Docker Hub through the Notary client. When specifying Docker image names for the Notary client, the GUN format is:</source>
          <target state="translated">공증인은 GUN (Globally Unique Names)을 사용하여 트러스트 모음을 식별합니다. Notary가 다중 테넌트 방식으로 실행되도록하려면 Notary 클라이언트를 통해 Docker Hub와 상호 작용할 때이 형식을 사용해야합니다. Notary 클라이언트의 Docker 이미지 이름을 지정할 때 GUN 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d95e87a063ba792a7a9f3076edd7ccdc8383d626" translate="yes" xml:space="preserve">
          <source>Note how the tag defaulted to &lt;code&gt;latest&lt;/code&gt;. The full syntax for the tag option would be something like &lt;code&gt;--tag=friendlyhello:v0.0.1&lt;/code&gt;.</source>
          <target state="translated">태그의 기본값이 &lt;code&gt;latest&lt;/code&gt; 것에 주목하십시오 . 태그 옵션의 전체 구문은 &lt;code&gt;--tag=friendlyhello:v0.0.1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f7a8cc491170a7a61e1d07096a8f54569160f402" translate="yes" xml:space="preserve">
          <source>Note tags that were signed by the removed delegation will need to be resigned by an active delegation</source>
          <target state="translated">제거 된 위임에 의해 서명 된 태그는 활성 위임에 의해 서명되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fc7da1c9ee8e03c183001b787166338e4f5f79a7" translate="yes" xml:space="preserve">
          <source>Note that each instruction is run independently, and causes a new image to be created - so &lt;code&gt;RUN cd /tmp&lt;/code&gt; will not have any effect on the next instructions.</source>
          <target state="translated">각 명령어는 독립적으로 실행되며 새 이미지가 만들어 지므로 &lt;code&gt;RUN cd /tmp&lt;/code&gt; 는 다음 명령어에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e81a07d720f951ef46d1a6efbb46d185c6538e8e" translate="yes" xml:space="preserve">
          <source>Note that if the container is started with &amp;ldquo;--rm&amp;rdquo; flag, you cannot update the restart policy for it. The &lt;code&gt;AutoRemove&lt;/code&gt; and &lt;code&gt;RestartPolicy&lt;/code&gt; are mutually exclusive for the container.</source>
          <target state="translated">컨테이너가&amp;ldquo;--rm&amp;rdquo;플래그로 시작되면 재시작 정책을 업데이트 할 수 없습니다. &lt;code&gt;AutoRemove&lt;/code&gt; 및 &lt;code&gt;RestartPolicy&lt;/code&gt; 는 컨테이너에 대한 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="69dc2be469b4f00c85a523b4cf1326bf766e3784" translate="yes" xml:space="preserve">
          <source>Note that since the tag name is not specified, the alias is created for an existing local version &lt;code&gt;httpd:latest&lt;/code&gt;.</source>
          <target state="translated">태그 이름이 지정되지 않았으므로 기존 로컬 버전 &lt;code&gt;httpd:latest&lt;/code&gt; 에 대한 별명이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2be3f4864b795395d0cad85f5421fbef40b9ed8a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;--insecure&lt;/code&gt; flag is not required to annotate a manifest list, since annotations are to a locally-stored copy of a manifest list. You may also skip the &lt;code&gt;--insecure&lt;/code&gt; flag if you are performing a &lt;code&gt;docker manifest inspect&lt;/code&gt; on a locally-stored manifest list. Be sure to keep in mind that locally-stored manifest lists are never used by the engine on a &lt;code&gt;docker pull&lt;/code&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;--insecure&lt;/code&gt; 플래그 주석 매니페스트 목록의 로컬에 저장된 사본이기 때문에, 매니페스트 목록에 주석을 필요하지 않습니다. 로컬로 저장된 매니페스트 목록에서 &lt;code&gt;docker manifest inspect&lt;/code&gt; 를 수행하는 경우 &lt;code&gt;--insecure&lt;/code&gt; 플래그를 건너 뛸 수도 있습니다 . 엔진이 &lt;code&gt;docker pull&lt;/code&gt; 에서 로컬로 저장된 매니페스트 목록을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="de4704a1fb295bf83cf6f53277f77024d8e0b6a6" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;sudo&lt;/code&gt; in this example &amp;ndash; you must preserve the ownership of the files (especially root ownership) during the archiving with tar. If you are not root (or the sudo command) when you tar, then the ownerships might not get preserved.</source>
          <target state="translated">이 예 에서 &lt;code&gt;sudo&lt;/code&gt; 를 참고하십시오 . tar를 사용하여 아카이브하는 동안 파일의 소유권 (특히 루트 소유권)을 유지해야합니다. tar 할 때 루트 (또는 sudo 명령)가 아닌 경우 소유권이 유지되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80db4901087496d523f6b8a9d3c9055ad31d3cdf" translate="yes" xml:space="preserve">
          <source>Note the way the &lt;code&gt;get_hit_count&lt;/code&gt; function is written. This basic retry loop lets us attempt our request multiple times if the redis service is not available. This is useful at startup while the application comes online, but also makes our application more resilient if the Redis service needs to be restarted anytime during the app&amp;rsquo;s lifetime. In a cluster, this also helps handling momentary connection drops between nodes.</source>
          <target state="translated">&lt;code&gt;get_hit_count&lt;/code&gt; 함수가 작성 되는 방식에 유의하십시오 . 이 기본 재시도 루프를 사용하면 redis 서비스를 사용할 수없는 경우 요청을 여러 번 시도 할 수 있습니다. 이는 애플리케이션이 온라인 상태 일 때 시작시 유용하지만 앱 수명 동안 언제라도 Redis 서비스를 다시 시작해야하는 경우 애플리케이션의 복원성을 향상시킵니다. 클러스터에서 이는 노드 간 일시적인 연결 끊김 처리에도 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="f4eb7bdb9e067350b554e3246b23193bfab28e84" translate="yes" xml:space="preserve">
          <source>Note this applies to Docker Community Engine 17.12 and newer, and Docker Enterprise Engine 18.03 and newer.</source>
          <target state="translated">이는 Docker Community Engine 17.12 이상 및 Docker Enterprise Engine 18.03 이상에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="358b0703673b277c02c23e4e267b68ebe0cff10a" translate="yes" xml:space="preserve">
          <source>Note this is supported on Docker Community and Enterprise Engines newer than 17.03.</source>
          <target state="translated">이는 17.03 이전의 Docker Community 및 Enterprise Engine에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb1627d0796d7b2850fe3d54d7b8e263a426516" translate="yes" xml:space="preserve">
          <source>Note this only applies to Docker Enterprise Engine 18.09 or newer. This implementation is also separate from the &lt;code&gt;only run signed images&lt;/code&gt; feature of &lt;a href=&quot;https://docs.docker.com/ee/ucp/admin/configure/run-only-the-images-you-trust/&quot;&gt;Universal Control Plane&lt;/a&gt;</source>
          <target state="translated">이는 Docker Enterprise Engine 18.09 이상에만 적용됩니다. 이 구현은 &lt;a href=&quot;https://docs.docker.com/ee/ucp/admin/configure/run-only-the-images-you-trust/&quot;&gt;Universal Control Plane&lt;/a&gt; 의 &lt;code&gt;only run signed images&lt;/code&gt; 기능과 도 별개입니다.</target>
        </trans-unit>
        <trans-unit id="5ddc32e28754d6c09a5dc57d868e592e884a38d6" translate="yes" xml:space="preserve">
          <source>Note you will need the passphrase for the repository key; this would have been configured when you first initiated the repository.</source>
          <target state="translated">리포지토리 키의 암호가 필요합니다. 리포지토리를 처음 시작할 때 구성되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="f2e116b8c748f4d601c3b6102ae6d0df1034d3cd" translate="yes" xml:space="preserve">
          <source>Notes about specifying volumes</source>
          <target state="translated">볼륨 지정에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="863ebb6ad384df28c10cfc4aeab4e5b74edb224f" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;CONTAINER ID&lt;/code&gt; matches what&amp;rsquo;s on &lt;code&gt;http://localhost:4000&lt;/code&gt;.</source>
          <target state="translated">공지 사항은 &lt;code&gt;CONTAINER ID&lt;/code&gt; 에 무엇을 일치 &lt;code&gt;http://localhost:4000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf61bb30b1b650e35f2e7709fbca3962abf7bf1" translate="yes" xml:space="preserve">
          <source>Now consider this example:</source>
          <target state="translated">이제이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ae443e91912f33eb53bbf8b0185cdac21ca4debc" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run it. You need to give your app a name. Here, it is set to &lt;code&gt;getstartedlab&lt;/code&gt;:</source>
          <target state="translated">이제 실행 해 봅시다. 앱 이름을 지정해야합니다. 여기서는 &lt;code&gt;getstartedlab&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff773cc1f2f784ee35782a5457851787ed1874a2" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the app in the background, in detached mode:</source>
          <target state="translated">이제 앱을 백그라운드에서 분리 모드로 실행 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b6e0b8ae8d9e432b7f6ca1768b68337280206378" translate="yes" xml:space="preserve">
          <source>Now roll back the service to its previous version, and confirm it is running a single replica again:</source>
          <target state="translated">이제 서비스를 이전 버전으로 롤백하고 단일 복제본을 다시 실행 중인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1f4dc2793ce511b458789ee5368e79c5a5a2b921" translate="yes" xml:space="preserve">
          <source>Now run the build command. This creates a Docker image, which we&amp;rsquo;re going to name using the &lt;code&gt;--tag&lt;/code&gt; option. Use &lt;code&gt;-t&lt;/code&gt; if you want to use the shorter option.</source>
          <target state="translated">이제 빌드 명령을 실행하십시오. Docker 이미지가 생성되며 &lt;code&gt;--tag&lt;/code&gt; 옵션을 사용하여 이름을 지정합니다 . 더 짧은 옵션을 사용 하려면 &lt;code&gt;-t&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="16ee0e8abcb78866db3097dfa6032720373fade9" translate="yes" xml:space="preserve">
          <source>Now that MySQL is set up, create a WordPress service that connects to the MySQL service. The WordPress service has the following characteristics:</source>
          <target state="translated">이제 MySQL이 설정되었으므로 MySQL 서비스에 연결하는 WordPress 서비스를 작성하십시오. 워드 프레스 서비스는 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="683431649c88002133934df7706386a0654a2fca" translate="yes" xml:space="preserve">
          <source>Now that Ubuntu 14.04 is no longer a supported distro for Docker, and &lt;code&gt;overlay2&lt;/code&gt; is available to all supported distros (as they are either on kernel 4.x, or have support for multiple lowerdirs backported), there is no reason to continue maintenance of the &lt;code&gt;aufs&lt;/code&gt; storage driver.</source>
          <target state="translated">이제 Ubuntu 14.04는 더 이상 Docker에 대해 지원되는 배포판이 아니며 &lt;code&gt;overlay2&lt;/code&gt; 는 지원되는 모든 배포판에 사용할 수 있습니다 (커널 4.x에서 또는 여러 하위 디렉토리가 백 포트되어 있기 때문에). &lt;code&gt;aufs&lt;/code&gt; 스토리지 드라이버.</target>
        </trans-unit>
        <trans-unit id="081640c7dfc2b80a1eedbdf022c4c7052d0863e5" translate="yes" xml:space="preserve">
          <source>Now that everything is setup, you can go into your &lt;code&gt;trustsandbox&lt;/code&gt; container and start testing Docker content trust. From your host machine, obtain a shell in the &lt;code&gt;trustsandbox&lt;/code&gt; container.</source>
          <target state="translated">이제 모든 것이 설정 &lt;code&gt;trustsandbox&lt;/code&gt; 컨테이너 로 이동하여 Docker 컨텐츠 신뢰 테스트를 시작할 수 있습니다 . 호스트 시스템에서 &lt;code&gt;trustsandbox&lt;/code&gt; 컨테이너 의 쉘을 확보하십시오 .</target>
        </trans-unit>
        <trans-unit id="083b487e1f89b839206167be8e219c0a1c52db0e" translate="yes" xml:space="preserve">
          <source>Now that support for &lt;code&gt;overlay2&lt;/code&gt; is added to all supported distros (as they are either on kernel 4.x, or have support for multiple lowerdirs backported), there is no reason to continue maintenance of the &lt;code&gt;devicemapper&lt;/code&gt; storage driver.</source>
          <target state="translated">지금 지원하는 &lt;code&gt;overlay2&lt;/code&gt; (그들은 커널 4.x의에 하나, 또는 백 포트 여러 lowerdirs에 대한 지원을 가지고) 지원되는 모든 배포판에 추가됩니다의 유지 보수를 계속 할 이유가 없다 &lt;code&gt;devicemapper&lt;/code&gt; 의 저장 장치 드라이버가.</target>
        </trans-unit>
        <trans-unit id="d557625e52c7ef4ee7e234e45a4177ec7dc687cc" translate="yes" xml:space="preserve">
          <source>Now that you have &lt;code&gt;myvm1&lt;/code&gt;, you can use its powers as a swarm manager to deploy your app by using the same &lt;code&gt;docker stack deploy&lt;/code&gt; command you used in part 3 to &lt;code&gt;myvm1&lt;/code&gt;, and your local copy of &lt;code&gt;docker-compose.yml&lt;/code&gt;. This command may take a few seconds to complete and the deployment takes some time to be available. Use the &lt;code&gt;docker service ps &amp;lt;service_name&amp;gt;&lt;/code&gt; command on a swarm manager to verify that all services have been redeployed.</source>
          <target state="translated">&lt;code&gt;myvm1&lt;/code&gt; 이 있으므로 , 3 부에서 사용한 것과 동일한 &lt;code&gt;docker stack deploy&lt;/code&gt; 명령 과 &lt;code&gt;myvm1&lt;/code&gt; 및 로컬 &lt;code&gt;docker-compose.yml&lt;/code&gt; 복사본을 사용하여 앱을 배포하기 위해 swarm 관리자로서의 기능을 사용할 수 있습니다 . 이 명령을 완료하는 데 몇 초가 걸릴 수 있으며 배치를 사용하는 데 시간이 걸립니다. swarm manager 에서 &lt;code&gt;docker service ps &amp;lt;service_name&amp;gt;&lt;/code&gt; 명령을 사용하여 모든 서비스가 재배치되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d043d71c7bfbff557b596802c41e02fc94e7bc75" translate="yes" xml:space="preserve">
          <source>Now that you have a CA, you can create a server key and certificate signing request (CSR). Make sure that &amp;ldquo;Common Name&amp;rdquo; matches the hostname you use to connect to Docker:</source>
          <target state="translated">이제 CA가 있으므로 서버 키 및 인증서 서명 요청 (CSR)을 작성할 수 있습니다. &amp;ldquo;공통 이름&amp;rdquo;이 Docker에 연결하는 데 사용하는 호스트 이름과 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5911812cfc292c068facdc414e32bc4a00436c91" translate="yes" xml:space="preserve">
          <source>Now that you&amp;rsquo;ve got a new Gemfile, you need to build the image again. (This, and changes to the &lt;code&gt;Gemfile&lt;/code&gt; or the Dockerfile, should be the only times you&amp;rsquo;ll need to rebuild.)</source>
          <target state="translated">새로운 Gemfile을 얻었으므로 이미지를 다시 빌드해야합니다. ( &lt;code&gt;Gemfile&lt;/code&gt; 또는 Dockerfile의 변경 사항 은 재 빌드해야하는 유일한 시간이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="cc09b76ad01e3d703fb279ec55dc59e0d3608b43" translate="yes" xml:space="preserve">
          <source>Now use &lt;code&gt;docker container stop&lt;/code&gt; to end the process, using the &lt;code&gt;CONTAINER ID&lt;/code&gt;, like so:</source>
          <target state="translated">이제 &lt;code&gt;CONTAINER ID&lt;/code&gt; 를 사용하여 &lt;code&gt;docker container stop&lt;/code&gt; 을 사용하여 프로세스를 종료하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c9d2bdef11774f4144fb3e63d8ec8de4e4a9ace" translate="yes" xml:space="preserve">
          <source>Now we see that &lt;code&gt;pip install -r requirements.txt&lt;/code&gt; installs the Flask and Redis libraries for Python, and the app prints the environment variable &lt;code&gt;NAME&lt;/code&gt;, as well as the output of a call to &lt;code&gt;socket.gethostname()&lt;/code&gt;. Finally, because Redis isn&amp;rsquo;t running (as we&amp;rsquo;ve only installed the Python library, and not Redis itself), we should expect that the attempt to use it here fails and produces the error message.</source>
          <target state="translated">이제 &lt;code&gt;pip install -r requirements.txt&lt;/code&gt; 가 Python 용 Flask 및 Redis 라이브러리를 설치하고 앱이 환경 변수 &lt;code&gt;NAME&lt;/code&gt; 및 &lt;code&gt;socket.gethostname()&lt;/code&gt; 에 대한 호출 출력을 인쇄한다는 것을 알 수 있습니다 . 마지막으로 Redis가 실행 중이 아니기 때문에 (Redis 자체가 아닌 Python 라이브러리 만 설치 했으므로)이 라이브러리를 사용하려는 시도가 실패하고 오류 메시지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bba6a9c72ca597a6c47a46cdbf1ddebad7045d2f" translate="yes" xml:space="preserve">
          <source>Now you can create a service using this credential spec. Specify the &lt;code&gt;--credential-spec&lt;/code&gt; flag with the config name:</source>
          <target state="translated">이제이 자격 증명 사양을 사용하여 서비스를 만들 수 있습니다. 구성 이름으로 &lt;code&gt;--credential-spec&lt;/code&gt; 플래그를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="560f6bd7dd73d810504e0e5288375e45d72e8fcf" translate="yes" xml:space="preserve">
          <source>Now you can make the Docker daemon only accept connections from clients providing a certificate trusted by your CA:</source>
          <target state="translated">이제 Docker 데몬이 CA가 신뢰하는 인증서를 제공하는 클라이언트의 연결 만 허용하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a12978740371ec03823ab206e48c8bbd84fab335" translate="yes" xml:space="preserve">
          <source>Now you can update the container image for &lt;code&gt;redis&lt;/code&gt;. The swarm manager applies the update to nodes according to the &lt;code&gt;UpdateConfig&lt;/code&gt; policy:</source>
          <target state="translated">이제 &lt;code&gt;redis&lt;/code&gt; 의 컨테이너 이미지를 업데이트 할 수 있습니다 . swarm 관리자는 &lt;code&gt;UpdateConfig&lt;/code&gt; 정책 에 따라 노드에 업데이트를 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="c6a134473cc488809f26b7267302255e6a487fc2" translate="yes" xml:space="preserve">
          <source>Now you can use the directory on the machine, for mounting into containers. Any changes done in the local directory, is reflected in the machine too.</source>
          <target state="translated">이제 컨테이너에 마운트하기 위해 머신의 디렉토리를 사용할 수 있습니다. 로컬 디렉토리에서 수행 된 모든 변경 사항은 시스템에도 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="5223a354788aa556a3daf3b2f6837e2418e655f3" translate="yes" xml:space="preserve">
          <source>Now you can use the same &lt;a href=&quot;../part3/index#run-your-new-load-balanced-app&quot;&gt;docker commands you used in part 3&lt;/a&gt;. Only this time notice that the services (and associated containers) have been distributed between both &lt;code&gt;myvm1&lt;/code&gt; and &lt;code&gt;myvm2&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;a href=&quot;../part3/index#run-your-new-load-balanced-app&quot;&gt;3 부에서 사용한&lt;/a&gt; 것과 동일한 docker 명령을 사용할 수 있습니다 . 이번에 만 서비스 (및 관련 컨테이너)가 &lt;code&gt;myvm1&lt;/code&gt; 과 &lt;code&gt;myvm2&lt;/code&gt; 사이에 분배되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b599b99bc8051acfe76d2c22303456a4919925cf" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ve deployed a service to the swarm, you&amp;rsquo;re ready to &lt;a href=&quot;../inspect-service/index&quot;&gt;inspect the service&lt;/a&gt;.</source>
          <target state="translated">이제 웜에 서비스를 배포 했으므로 &lt;a href=&quot;../inspect-service/index&quot;&gt;서비스&lt;/a&gt; 를 검사 할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c16a1ccc9cf7c7d5ea891c7fac3c34ff3dfa13be" translate="yes" xml:space="preserve">
          <source>Now your swarm consists of a manager and two worker nodes. In the next step of the tutorial, you &lt;a href=&quot;../deploy-service/index&quot;&gt;deploy a service&lt;/a&gt; to the swarm.</source>
          <target state="translated">이제 떼는 관리자와 두 개의 작업자 노드로 구성됩니다. 학습서의 다음 단계에서는 &lt;a href=&quot;../deploy-service/index&quot;&gt;서비스&lt;/a&gt; 를 웜에 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="3a323fb2a5b65dc144b50b57d0be1be60d50f2d5" translate="yes" xml:space="preserve">
          <source>Now, after running either of the above commands, this command should return no output.</source>
          <target state="translated">이제 위 명령 중 하나를 실행 한 후이 명령은 출력을 리턴하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="85dfdc89ee84bb829b8095c30e68313b5b92daf0" translate="yes" xml:space="preserve">
          <source>Now, change the MySQL password for the &lt;code&gt;wordpress&lt;/code&gt; user using the &lt;code&gt;mysqladmin&lt;/code&gt; CLI. This command reads the old and new password from the files in &lt;code&gt;/run/secrets&lt;/code&gt; but does not expose them on the command line or save them in the shell history.</source>
          <target state="translated">이제 &lt;code&gt;mysqladmin&lt;/code&gt; CLI를 사용하여 &lt;code&gt;wordpress&lt;/code&gt; 사용자 의 MySQL 비밀번호를 변경하십시오 . 이 명령은 &lt;code&gt;/run/secrets&lt;/code&gt; 의 파일에서 이전 암호와 새 암호를 읽지 만 명령 줄에 표시하거나 셸 기록에 저장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a82fdbe6ef4eaa2e3a539b916a62bd7a95c2b30a" translate="yes" xml:space="preserve">
          <source>Now, create a couple of VMs using &lt;code&gt;docker-machine&lt;/code&gt;, using the VirtualBox driver:</source>
          <target state="translated">이제 VirtualBox 드라이버를 사용 하여 &lt;code&gt;docker-machine&lt;/code&gt; 을 사용 하여 몇 개의 VM을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="cadcf954d7c70f8ad10edb849fe60b7305c4b9ba" translate="yes" xml:space="preserve">
          <source>Now, create a couple of VMs using our node management tool, &lt;code&gt;docker-machine&lt;/code&gt;:</source>
          <target state="translated">이제 노드 관리 도구 인 &lt;code&gt;docker-machine&lt;/code&gt; 을 사용하여 몇 개의 VM을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="050951d485f2d2f57ca9f665570232b10e47f71a" translate="yes" xml:space="preserve">
          <source>Now, generate the signed certificate:</source>
          <target state="translated">이제 서명 된 인증서를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="48084de74ff50e8f7e78821f7010b2e100c6c1d9" translate="yes" xml:space="preserve">
          <source>Now, it would be nice to use this Compose app in a production environment. So, create another override file (which might be stored in a different git repo or managed by a different team).</source>
          <target state="translated">이제 프로덕션 환경에서이 Compose 앱을 사용하는 것이 좋습니다. 따라서 다른 재정의 파일을 만듭니다 (다른 git repo에 저장되거나 다른 팀이 관리 할 수 ​​있음).</target>
        </trans-unit>
        <trans-unit id="7b237b3b8f54ec283d505ee4d3db66dbbccdb820" translate="yes" xml:space="preserve">
          <source>Now, pull some images from within the &lt;code&gt;trustsandbox&lt;/code&gt; container.</source>
          <target state="translated">이제 &lt;code&gt;trustsandbox&lt;/code&gt; 컨테이너 에서 이미지를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f481f01a74d9d9c9c13a7bc17aefb7f335dfc602" translate="yes" xml:space="preserve">
          <source>Now, push the image to the registry using the image ID. In this example the registry is on host named &lt;code&gt;registry-host&lt;/code&gt; and listening on port &lt;code&gt;5000&lt;/code&gt;. To do this, tag the image with the host name or IP address, and the port of the registry:</source>
          <target state="translated">이제 이미지 ID를 사용하여 이미지를 레지스트리로 푸시하십시오. 이 예제에서 레지스트리는 &lt;code&gt;registry-host&lt;/code&gt; 라는 호스트에 있고 포트 &lt;code&gt;5000&lt;/code&gt; 에서 수신 대기합니다 . 이렇게하려면 이미지에 호스트 이름 또는 IP 주소와 레지스트리 포트를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="95e44ff4a4399adb864e5414fde08fe2151e7e36" translate="yes" xml:space="preserve">
          <source>Now, put it all together to tag the image. Run &lt;code&gt;docker tag image&lt;/code&gt; with your username, repository, and tag names so that the image uploads to your desired destination. The syntax of the command is:</source>
          <target state="translated">이제 이미지를 모두 태그로 묶습니다. &lt;code&gt;docker tag image&lt;/code&gt; 가 원하는 대상에 업로드되도록 사용자 이름, 저장소 및 태그 이름으로 docker tag image 를 실행하십시오 . 명령 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d58b713ea11a40480565ab6c80605b6e8b7dc28" translate="yes" xml:space="preserve">
          <source>Now, re-run &lt;code&gt;docker container ls -q&lt;/code&gt; to see the deployed instances reconfigured. If you scaled up the replicas, more tasks, and hence, more containers, are started.</source>
          <target state="translated">이제 &lt;code&gt;docker container ls -q&lt;/code&gt; 를 다시 실행 하여 배치 된 인스턴스가 재구성되었는지 확인하십시오. 복제본을 확장하면 더 많은 작업과 더 많은 컨테이너가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="9c596d7d215aadae620edf397771bd4d0104fc53" translate="yes" xml:space="preserve">
          <source>Now, rebuild and restart the app with &lt;code&gt;docker-compose up --build&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;docker-compose up --build&lt;/code&gt; 를 사용 하여 앱을 다시 빌드하고 다시 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="73ef7293357183866d1f79bbae2680078f42e09e" translate="yes" xml:space="preserve">
          <source>Now, run &lt;code&gt;docker-compose up -d&lt;/code&gt; from your project directory.</source>
          <target state="translated">이제 프로젝트 디렉토리에서 &lt;code&gt;docker-compose up -d&lt;/code&gt; 를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8aafc9a34251817fc924a944fbe60d0bff7814a6" translate="yes" xml:space="preserve">
          <source>Now, you have a full Docker content trust sandbox on your local system, feel free to play with it and see how it behaves. If you find any security issues with Docker, feel free to send us an email at &lt;a href=&quot;mailto:security@docker.com&quot;&gt;security@docker.com&lt;/a&gt;.</source>
          <target state="translated">이제 로컬 시스템에 전체 Docker 컨텐츠 신뢰 샌드 박스가 있으며,이를 사용하여 자유롭게 작동하는 방식을 확인하십시오. 당신은 부두 노동자와 보안 문제를 발견하는 경우에 저희에게 이메일을 보내 주시기 &lt;a href=&quot;mailto:security@docker.com&quot;&gt;security@docker.com&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e83a79c383412bd23c7f848f52ce0bf23c98308c" translate="yes" xml:space="preserve">
          <source>Now, you should have a Docker Config named credspec, and you can create a service using this credential spec. To do so, use the --credential-spec flag with the config name, like this:</source>
          <target state="translated">이제 credspec이라는 Docker 구성이 있어야하며이 자격 증명 사양을 사용하여 서비스를 만들 수 있습니다. 그렇게하려면 다음과 같이 --credential-spec 플래그를 구성 이름과 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a5044180dae2c4d19df18e49a11dd260de78b0b" translate="yes" xml:space="preserve">
          <source>Number of CPUs</source>
          <target state="translated">CPU 수</target>
        </trans-unit>
        <trans-unit id="b2e27a86ebe15438fc126487fe1e129471f0dd98" translate="yes" xml:space="preserve">
          <source>Number of CPUs. Number is a fractional number. 0.000 means no limit.</source>
          <target state="translated">CPU 수 숫자는 소수입니다. 0.000은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b57c13a48b05193802b000868454264cd056e530" translate="yes" xml:space="preserve">
          <source>Number of PIDs (Not available on Windows)</source>
          <target state="translated">PID 수 (Windows에서는 사용할 수 없음)</target>
        </trans-unit>
        <trans-unit id="597a89c3b5bf1ae73f66e47b919b0382b83f0278" translate="yes" xml:space="preserve">
          <source>Number of additional Raft snapshots to retain</source>
          <target state="translated">유지할 추가 Raft 스냅 샷 수</target>
        </trans-unit>
        <trans-unit id="1268baa715e1a2698165d607139219a32e9fca3a" translate="yes" xml:space="preserve">
          <source>Number of lines to show from the end of the logs</source>
          <target state="translated">로그 끝에서 표시 할 줄 수</target>
        </trans-unit>
        <trans-unit id="d5858cd8bd07a74c956b6eb294baed506071a396" translate="yes" xml:space="preserve">
          <source>Number of log entries between Raft snapshots</source>
          <target state="translated">Raft 스냅 샷 사이의 로그 항목 수</target>
        </trans-unit>
        <trans-unit id="7833181000d643b63436596bf28dd9ab6195bb55" translate="yes" xml:space="preserve">
          <source>Number of services</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafb832a616a146bf1f8a0f6e019acfe7b7a9ac3" translate="yes" xml:space="preserve">
          <source>Number of stars for the image</source>
          <target state="translated">이미지의 별 수</target>
        </trans-unit>
        <trans-unit id="114174999297a9b61fc6e315ee54546affc61f5f" translate="yes" xml:space="preserve">
          <source>Number of tasks</source>
          <target state="translated">작업 수</target>
        </trans-unit>
        <trans-unit id="28871d3a2f857b7d00734bb5b9f138e138a0c0cc" translate="yes" xml:space="preserve">
          <source>Numbers are specified as arguments in the form &lt;code&gt;service=num&lt;/code&gt;. For example:</source>
          <target state="translated">숫자는 &lt;code&gt;service=num&lt;/code&gt; 형식의 인수로 지정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c08bc02800f2db95bfd879a26f93f354c1be80e" translate="yes" xml:space="preserve">
          <source>ONBUILD</source>
          <target state="translated">ONBUILD</target>
        </trans-unit>
        <trans-unit id="66c888d10ab6a46198fcec7325df97ad7688050e" translate="yes" xml:space="preserve">
          <source>Object types</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="d881dcc3afbe226a53109706ad79426dbb444350" translate="yes" xml:space="preserve">
          <source>Obsolete syscall.</source>
          <target state="translated">더 이상 사용되지 않는 syscall.</target>
        </trans-unit>
        <trans-unit id="17af2683771ef384131a99cda548f7fe95bf5c27" translate="yes" xml:space="preserve">
          <source>Obsolete, replaced by /proc/sys.</source>
          <target state="translated">더 이상 사용되지 않으며 / proc / sys로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e3367da33b7d6479466d1024e006883ccc94168" translate="yes" xml:space="preserve">
          <source>Official Docker images</source>
          <target state="translated">공식 도커 이미지</target>
        </trans-unit>
        <trans-unit id="7793d4a97bd3df3bc05a4b86fb6f470af0ea0308" translate="yes" xml:space="preserve">
          <source>Official releases</source>
          <target state="translated">공식 출시</target>
        </trans-unit>
        <trans-unit id="4ca8f6a31d4bc912de657e810710b473b92f8edb" translate="yes" xml:space="preserve">
          <source>Old Command Line Options</source>
          <target state="translated">이전 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="49162bfe35908e142ab7c9c7e15c9378f849afc1" translate="yes" xml:space="preserve">
          <source>Older passwords may also be provided as environment variables.</source>
          <target state="translated">이전 비밀번호는 환경 변수로 제공 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6878a0498321e485df2f8e925ad2c53c6beb3252" translate="yes" xml:space="preserve">
          <source>Older syscall related to shared libraries, unused for a long time.</source>
          <target state="translated">오래된 syscall은 오랫동안 공유되지 않은 공유 라이브러리와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3efb2e83ba060c5fa694012b6590ce062483d066" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;Mac or Linux&lt;/strong&gt; the command is:</source>
          <target state="translated">에 &lt;strong&gt;맥 또는 리눅스&lt;/strong&gt; 명령은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="62315d09478dc1fc7114e43a7538a47e959fcd51" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;Windows&lt;/strong&gt; the command is:</source>
          <target state="translated">에 &lt;strong&gt;윈도우&lt;/strong&gt; 명령은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="2295f011a6999b2a2dbdb79f5bca513f3fa75ca8" translate="yes" xml:space="preserve">
          <source>On Docker 17.04 CE Edge and up, including 17.06 CE Edge and Stable, you can configure container-and-host consistency requirements for bind-mounted directories in Compose files to allow for better performance on read/write of volume mounts. These options address issues specific to &lt;code&gt;osxfs&lt;/code&gt; file sharing, and therefore are only applicable on Docker Desktop for Mac.</source>
          <target state="translated">17.06 CE Edge 및 Stable을 포함하여 Docker 17.04 CE Edge 이상에서는 Compose 파일의 바인드 마운트 디렉토리에 대한 컨테이너 및 호스트 일관성 요구 사항을 구성하여 볼륨 마운트의 읽기 / 쓰기 성능을 향상시킬 수 있습니다. 이 옵션은 &lt;code&gt;osxfs&lt;/code&gt; 파일 공유와 관련된 문제를 해결 하므로 Mac 용 Docker Desktop에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="97ca604370c5c41a1c4b387a4675f5729fc3bf97" translate="yes" xml:space="preserve">
          <source>On Docker Desktop for Mac and Docker Desktop for Windows, go to &lt;code&gt;http://localhost:3000&lt;/code&gt; on a web browser to see the Rails Welcome.</source>
          <target state="translated">Mac 용 Docker Desktop 및 Windows 용 Docker Desktop 의 웹 브라우저에서 &lt;code&gt;http://localhost:3000&lt;/code&gt; 으로 이동 하여 Rails Welcome을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="28c796f16d3bc2493357baccd7620e95a9978b4a" translate="yes" xml:space="preserve">
          <source>On Docker Desktop for Windows systems that support Hyper-V, use the &lt;code&gt;hyperv&lt;/code&gt; driver as shown in the &lt;a href=&quot;../drivers/hyper-v/index&quot;&gt;Docker Machine Microsoft Hyper-V driver reference&lt;/a&gt; and follow the &lt;a href=&quot;../drivers/hyper-v/index#example&quot;&gt;example&lt;/a&gt;, which shows how to use an external network switch and provides the flags for the full command. (See &lt;a href=&quot;index#prerequisite-information&quot;&gt;prerequisites&lt;/a&gt; above to learn more.)</source>
          <target state="translated">Hyper-V를 지원하는 Windows 시스템 용 Docker Desktop 에서 &lt;a href=&quot;../drivers/hyper-v/index&quot;&gt;Docker Machine Microsoft Hyper-V 드라이버 참조에&lt;/a&gt; 표시된대로 &lt;code&gt;hyperv&lt;/code&gt; 드라이버를 사용 하고 &lt;a href=&quot;../drivers/hyper-v/index#example&quot;&gt;예를&lt;/a&gt; 따르십시오.이 예제 는 외부 네트워크 스위치를 사용하고 전체 명령에 대한 플래그를 제공합니다. . 자세한 내용은 위의 &lt;a href=&quot;index#prerequisite-information&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="610a7c8308dc534debe195d4c451fb01e8204dc3" translate="yes" xml:space="preserve">
          <source>On Linux</source>
          <target state="translated">리눅스에서</target>
        </trans-unit>
        <trans-unit id="d350b7b788d4d3a51c25ad7f7ba1ff806cc9f10b" translate="yes" xml:space="preserve">
          <source>On Linux systems, first install the &lt;a href=&quot;https://docs.docker.com/install/#server&quot;&gt;Docker&lt;/a&gt; for your OS as described on the Get Docker page, then come back here for instructions on installing Compose on Linux systems.</source>
          <target state="translated">Linux 시스템에서는 먼저 &lt;a href=&quot;https://docs.docker.com/install/#server&quot;&gt;Docker 가져&lt;/a&gt; 오기 페이지에 설명 된대로 OS 용 Docker 를 설치 한 다음 Linux 시스템에 Compose 설치에 대한 지시 사항을 보려면 여기로 돌아 오십시오.</target>
        </trans-unit>
        <trans-unit id="ead05e563bbd5d93408dc2c62204cebd33a0b6d9" translate="yes" xml:space="preserve">
          <source>On Linux, the Docker daemon has support for several different image layer storage drivers: &lt;code&gt;aufs&lt;/code&gt;, &lt;code&gt;devicemapper&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;zfs&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt; and &lt;code&gt;overlay2&lt;/code&gt;.</source>
          <target state="translated">: 리눅스에서 부두 노동자 데몬은 여러 가지 다른 이미지 레이어 저장 장치 드라이버에 대한 지원이 &lt;code&gt;aufs&lt;/code&gt; , &lt;code&gt;devicemapper&lt;/code&gt; , &lt;code&gt;btrfs&lt;/code&gt; 를 , &lt;code&gt;zfs&lt;/code&gt; , &lt;code&gt;overlay&lt;/code&gt; 및 &lt;code&gt;overlay2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d72d2c32104c919ece444f06be7c4c2f3dc734b4" translate="yes" xml:space="preserve">
          <source>On Linux, you can download the Docker Compose binary from the &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;Compose repository release page on GitHub&lt;/a&gt;. Follow the instructions from the link, which involve running the &lt;code&gt;curl&lt;/code&gt; command in your terminal to download the binaries. These step-by-step instructions are also included below.</source>
          <target state="translated">Linux에서는 &lt;a href=&quot;https://github.com/docker/compose/releases&quot;&gt;GitHub&lt;/a&gt; 의 Compose 저장소 릴리스 페이지 에서 Docker Compose 바이너리를 다운로드 할 수 있습니다 . 터미널에서 &lt;code&gt;curl&lt;/code&gt; 명령을 실행 하여 바이너리를 다운로드하는 링크의 지침을 따르십시오 . 이러한 단계별 지침도 아래에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851bcc5548ae4eaa87267e9ebae009299500c1f3" translate="yes" xml:space="preserve">
          <source>On Mac OS or various flavors of Linux you can install the &lt;a href=&quot;http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-quick-configuration&quot;&gt;AWS Command Line Interface&lt;/a&gt; (&lt;code&gt;aws cli&lt;/code&gt;) in the terminal and use the &lt;code&gt;aws configure&lt;/code&gt; command which guides you through the creation of the credentials file.</source>
          <target state="translated">Mac OS 또는 다양한 Linux 버전 에서는 터미널에 &lt;a href=&quot;http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-quick-configuration&quot;&gt;AWS Command Line Interface&lt;/a&gt; ( &lt;code&gt;aws cli&lt;/code&gt; )를 설치 하고 자격 증명 파일 생성을 안내 하는 &lt;code&gt;aws configure&lt;/code&gt; 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="160eab92a471579273aabcee741b1f941837bd15" translate="yes" xml:space="preserve">
          <source>On Mac and Linux, you can use &lt;code&gt;docker-machine scp &amp;lt;file&amp;gt; &amp;lt;machine&amp;gt;:~&lt;/code&gt; to copy files across machines, but Windows users need a Linux terminal emulator like &lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git Bash&lt;/a&gt; for this to work.</source>
          <target state="translated">Mac 및 Linux에서는 &lt;code&gt;docker-machine scp &amp;lt;file&amp;gt; &amp;lt;machine&amp;gt;:~&lt;/code&gt; 를 사용하여 시스템간에 파일을 복사 할 수 있지만 Windows 사용자에게는 &lt;a href=&quot;https://git-for-windows.github.io/&quot;&gt;Git Bash&lt;/a&gt; 와 같은 Linux 터미널 에뮬레이터가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0e7739d54b3bf0b7f66058f938877391b4a8b25b" translate="yes" xml:space="preserve">
          <source>On Systemd based systems, you can communicate with the daemon via &lt;a href=&quot;http://0pointer.de/blog/projects/socket-activation.html&quot;&gt;Systemd socket activation&lt;/a&gt;, use &lt;code&gt;dockerd -H fd://&lt;/code&gt;. Using &lt;code&gt;fd://&lt;/code&gt; will work perfectly for most setups but you can also specify individual sockets: &lt;code&gt;dockerd -H fd://3&lt;/code&gt;. If the specified socket activated files aren&amp;rsquo;t found, then Docker will exit. You can find examples of using Systemd socket activation with Docker and Systemd in the &lt;a href=&quot;https://github.com/docker/docker/tree/master/contrib/init/systemd/&quot;&gt;Docker source tree&lt;/a&gt;.</source>
          <target state="translated">Systemd 기반 시스템에서는 &lt;code&gt;dockerd -H fd://&lt;/code&gt; &lt;a href=&quot;http://0pointer.de/blog/projects/socket-activation.html&quot;&gt;소켓 활성화&lt;/a&gt; 를 통해 디먼과 통신 할 수 있습니다. dockerd -H fd : //를 사용하십시오 . &lt;code&gt;fd://&lt;/code&gt; 를 사용하면 대부분의 설정에서 완벽하게 작동하지만 개별 소켓을 지정할 수도 있습니다 : &lt;code&gt;dockerd -H fd://3&lt;/code&gt; . 지정된 소켓 활성화 파일을 찾을 수 없으면 Docker가 종료됩니다. &lt;a href=&quot;https://github.com/docker/docker/tree/master/contrib/init/systemd/&quot;&gt;Docker 소스 트리&lt;/a&gt; 에서 Docker 및 Systemd와 함께 Systemd 소켓 활성화를 사용하는 예를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08103bc8083664f610de1cd76da40c7342e367bf" translate="yes" xml:space="preserve">
          <source>On Windows</source>
          <target state="translated">Windows에서</target>
        </trans-unit>
        <trans-unit id="a51ebef39bf662027f89ea33d4c9025e3852774a" translate="yes" xml:space="preserve">
          <source>On Windows server, assuming the default configuration, these commands are equivalent and result in &lt;code&gt;process&lt;/code&gt; isolation:</source>
          <target state="translated">Windows 서버에서 기본 구성을 가정하면이 명령은 동일하며 &lt;code&gt;process&lt;/code&gt; 격리를 초래합니다 .</target>
        </trans-unit>
        <trans-unit id="f864f3c57aaf96354973f5c397f859445cf498d5" translate="yes" xml:space="preserve">
          <source>On Windows systems, &lt;code&gt;CTRL+C&lt;/code&gt; does not stop the container. So, first type &lt;code&gt;CTRL+C&lt;/code&gt; to get the prompt back (or open another shell), then type &lt;code&gt;docker container ls&lt;/code&gt; to list the running containers, followed by &lt;code&gt;docker container stop &amp;lt;Container NAME or ID&amp;gt;&lt;/code&gt; to stop the container. Otherwise, you get an error response from the daemon when you try to re-run the container in the next step.</source>
          <target state="translated">Windows 시스템에서 &lt;code&gt;CTRL+C&lt;/code&gt; 는 컨테이너를 중지하지 않습니다. 따라서 먼저 &lt;code&gt;CTRL+C&lt;/code&gt; 를 입력 하여 프롬프트를 다시 받거나 다른 셸을 연 다음 &lt;code&gt;docker container ls&lt;/code&gt; 를 입력 하여 실행중인 컨테이너를 나열한 다음 &lt;code&gt;docker container stop &amp;lt;Container NAME or ID&amp;gt;&lt;/code&gt; 로 컨테이너를 중지하십시오. 그렇지 않으면 다음 단계에서 컨테이너를 다시 실행하려고 할 때 데몬으로부터 오류 응답이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a12fc226e9eb663105368f333ca7573df024e2a" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;--isolation&lt;/code&gt; can take one of these values:</source>
          <target state="translated">Windows에서 &lt;code&gt;--isolation&lt;/code&gt; 은 다음 값 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9249f8494a22ccb9ca8ea47eb5b745a8224d02b6" translate="yes" xml:space="preserve">
          <source>On Windows, create or update a service using &lt;code&gt;--credential-spec&lt;/code&gt; with the &lt;code&gt;config://&amp;lt;config-name&amp;gt;&lt;/code&gt; format. This passes the gMSA credentials file directly to nodes before a container starts. No gMSA credentials are written to disk on worker nodes. For more information, refer to &lt;a href=&quot;../../swarmservices/index&quot;&gt;Deploy services to a swarm&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;code&gt;--credential-spec&lt;/code&gt; 을 사용하여 &lt;code&gt;config://&amp;lt;config-name&amp;gt;&lt;/code&gt; 형식으로 서비스를 작성하거나 업데이트하십시오 . 컨테이너가 시작되기 전에 gMSA 자격 증명 파일을 노드로 직접 전달합니다. gMSA 자격 증명이 작업자 노드의 디스크에 기록되지 않습니다. 자세한 정보 &lt;a href=&quot;../../swarmservices/index&quot;&gt;는 swarm에 서비스 배치를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcaa1b49c54bf92c499ac69437ce1c0046dcff1a" translate="yes" xml:space="preserve">
          <source>On Windows, explicitly stop the container</source>
          <target state="translated">Windows에서 컨테이너를 명시 적으로 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="93804a854b02a2211ab35a60157431ff9028530a" translate="yes" xml:space="preserve">
          <source>On Windows, the Docker daemon supports a single image layer storage driver depending on the image platform: &lt;code&gt;windowsfilter&lt;/code&gt; for Windows images, and &lt;code&gt;lcow&lt;/code&gt; for Linux containers on Windows.</source>
          <target state="translated">: Windows에서 부두 노동자 데몬은 하나의 이미지 레이어 저장 이미지 플랫폼에 따라 드라이버 지원 &lt;code&gt;windowsfilter&lt;/code&gt; Windows 이미지에 대한, 그리고 &lt;code&gt;lcow&lt;/code&gt; Windows에서 리눅스 컨테이너를.</target>
        </trans-unit>
        <trans-unit id="cfb26dd18e2ebeaf592451c803995e5562de3472" translate="yes" xml:space="preserve">
          <source>On Windows, the paths must be specified using Windows-style semantics.</source>
          <target state="translated">Windows에서 경로는 Windows 스타일 시맨틱을 사용하여 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="17ea02ec47937b82ca98eed2c3ffd4303b5388f5" translate="yes" xml:space="preserve">
          <source>On Windows, the user must be created first if it&amp;rsquo;s not a built-in account. This can be done with the &lt;code&gt;net user&lt;/code&gt; command called as part of a Dockerfile.</source>
          <target state="translated">Windows에서 사용자는 기본 제공 계정이 아닌 경우 먼저 작성해야합니다. 이것은 Dockerfile의 일부로 불리는 &lt;code&gt;net user&lt;/code&gt; 명령 으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e99af4aee74dd489a9da0c62db7f41b1900f8942" translate="yes" xml:space="preserve">
          <source>On Windows, this flag can be used to specify the &lt;code&gt;credentialspec&lt;/code&gt; option. The &lt;code&gt;credentialspec&lt;/code&gt; must be in the format &lt;code&gt;file://spec.txt&lt;/code&gt; or &lt;code&gt;registry://keyname&lt;/code&gt;.</source>
          <target state="translated">Windows에서이 플래그를 사용하여 &lt;code&gt;credentialspec&lt;/code&gt; 옵션 을 지정할 수 있습니다 . &lt;code&gt;credentialspec&lt;/code&gt; 는 형식이어야합니다 &lt;code&gt;file://spec.txt&lt;/code&gt; 또는 &lt;code&gt;registry://keyname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff0cd0dd6f64662649e6ba025d96f2751d9812cb" translate="yes" xml:space="preserve">
          <source>On Windows, this will affect containers differently depending on what type of isolation is used.</source>
          <target state="translated">Windows에서는 사용되는 격리 유형에 따라 컨테이너에 다르게 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="e3a7f1db1aeaae9c19c9e00e771e4140a20478bb" translate="yes" xml:space="preserve">
          <source>On Windows, we recommend enabling &lt;a href=&quot;https://technet.microsoft.com/en-us/library/cc732774(v=ws.11).aspx&quot;&gt;BitLocker&lt;/a&gt; on the volume containing the Docker root directory on the host machine to ensure that secrets for running containers are encrypted at rest.</source>
          <target state="translated">Windows에서는 컨테이너를 실행하기위한 비밀이 유휴 상태로 암호화되도록 호스트 시스템의 Docker 루트 디렉토리가 포함 된 볼륨에서 &lt;a href=&quot;https://technet.microsoft.com/en-us/library/cc732774(v=ws.11).aspx&quot;&gt;BitLocker&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="da86036017d8daba957579114829b3cd86adc533" translate="yes" xml:space="preserve">
          <source>On a current Linux OS (in a non-minimal installation), bash completion should be available.</source>
          <target state="translated">현재 Linux OS (최소 설치가 아닌 경우)에서 bash 완료를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="50feda3e764b18a3d4b10e11e466dd34cce35bb8" translate="yes" xml:space="preserve">
          <source>On a manager node:</source>
          <target state="translated">관리자 노드에서 :</target>
        </trans-unit>
        <trans-unit id="4e155d27931b614af33d264a2af2b534e10a3c18" translate="yes" xml:space="preserve">
          <source>On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is limited to less than 100% of CPU time, it can use 100% of each individual CPU core.</source>
          <target state="translated">멀티 코어 시스템에서 CPU 시간의 점유율은 모든 CPU 코어에 분산됩니다. 컨테이너가 CPU 시간의 100 % 미만으로 제한 되더라도 각 개별 CPU 코어의 100 %를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e944d5fb7464fb058f07c3befc40f2587068c87a" translate="yes" xml:space="preserve">
          <source>On certain platforms (Windows 10), you might need to edit &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; inside &lt;code&gt;settings.py&lt;/code&gt; and add your Docker host name or IP address to the list. For demo purposes, you can set the value to:</source>
          <target state="translated">특정 플랫폼 (윈도우 10)에, 당신은 편집해야 할 수도 있습니다 &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; 내부 &lt;code&gt;settings.py&lt;/code&gt; 하고 목록에 부두 노동자의 호스트 이름 또는 IP 주소를 추가합니다. 데모 목적으로 값을 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="575c4ec90bbe7da51a51b795e32ed21481ced090" translate="yes" xml:space="preserve">
          <source>On desktop systems like Docker Desktop for Mac and Windows, Docker Compose is included as part of those desktop installs.</source>
          <target state="translated">Mac 및 Windows 용 Docker Desktop과 같은 데스크탑 시스템에서 Docker Compose는 이러한 데스크탑 설치의 일부로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4d7d21116803faef336b719bf1dfa6910d9eb299" translate="yes" xml:space="preserve">
          <source>On macOS and Windows, Machine is installed along with other Docker products when you install the &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker for Mac&lt;/a&gt;, &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker for Windows&lt;/a&gt;, or &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;Docker Toolbox&lt;/a&gt;.</source>
          <target state="translated">당신이 설치할 때 맥 OS 및 윈도우에, 기계는 다른 도커 제품과 함께 설치되어있는 &lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Mac 용 부두 노동자&lt;/a&gt; , &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;부두 노동자 Windows 용&lt;/a&gt; , 또는 &lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot;&gt;부두 노동자 도구 상자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72a45d6859d0adf02144ca0002e5c0fe9b75f160" translate="yes" xml:space="preserve">
          <source>On the Security of Containers (2014)</source>
          <target state="translated">컨테이너 보안에 관하여 (2014)</target>
        </trans-unit>
        <trans-unit id="9c3e42e98c296af685a79df8f41b6209e9eef0af" translate="yes" xml:space="preserve">
          <source>On this page you build a simple Python web application running on Docker Compose. The application uses the Flask framework and maintains a hit counter in Redis. While the sample uses Python, the concepts demonstrated here should be understandable even if you&amp;rsquo;re not familiar with it.</source>
          <target state="translated">이 페이지에서는 Docker Compose에서 실행되는 간단한 Python 웹 애플리케이션을 빌드합니다. 애플리케이션은 Flask 프레임 워크를 사용하고 Redis에서 적중 카운터를 유지합니다. 샘플은 Python을 사용하지만 여기에 설명 된 개념은 익숙하지 않더라도 이해할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b807fc9347a2d037d0144e5bdab85677416a0c8d" translate="yes" xml:space="preserve">
          <source>On this page, you get an overview of the Notary service architecture.</source>
          <target state="translated">이 페이지에서는 공증인 서비스 아키텍처에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74d910cbfd0aab2723f08ca998900202f12cc836" translate="yes" xml:space="preserve">
          <source>On to &amp;ldquo;Part 4&amp;rdquo; &amp;gt;&amp;gt;</source>
          <target state="translated">&quot;4 부&quot;로 &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="54c4e480c1328e48bc77f242d3cc9c1c938968de" translate="yes" xml:space="preserve">
          <source>On to Part 2 &amp;gt;&amp;gt;</source>
          <target state="translated">2 부로 &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9843d995f490c8520f5b6924cbd4173fc130a03a" translate="yes" xml:space="preserve">
          <source>On to Part 5 &amp;gt;&amp;gt;</source>
          <target state="translated">5 부로 &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="be02dda3f3835cfcb8c70ac71d44e92b8af35642" translate="yes" xml:space="preserve">
          <source>On to Part 6 &amp;gt;&amp;gt;</source>
          <target state="translated">6 부로 &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5b0bb396a922e3c794100d9a776d358eac094609" translate="yes" xml:space="preserve">
          <source>Once a comment, empty line or builder instruction has been processed, Docker no longer looks for parser directives. Instead it treats anything formatted as a parser directive as a comment and does not attempt to validate if it might be a parser directive. Therefore, all parser directives must be at the very top of a &lt;code&gt;Dockerfile&lt;/code&gt;.</source>
          <target state="translated">주석, 빈 줄 또는 빌더 명령이 처리되면 Docker는 더 이상 파서 지시문을 찾지 않습니다. 대신 구문 분석기 지시문으로 형식화 된 모든 것을 주석으로 처리하고 구문 분석기 지시문 일 수 있는지 유효성 검증을 시도하지 않습니다. 따라서 모든 파서 지시문은 &lt;code&gt;Dockerfile&lt;/code&gt; 의 맨 위에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4d1efe14751f47bf322327bc9fde1504b6bb52ae" translate="yes" xml:space="preserve">
          <source>Once a plugin is installed, requests made to the &lt;code&gt;daemon&lt;/code&gt; through the command line or Docker&amp;rsquo;s Engine API are allowed or denied by the plugin. If you have multiple plugins installed, each plugin, in order, must allow the request for it to complete.</source>
          <target state="translated">플러그인이 설치되면 플러그인 에서 명령 행 또는 Docker 's Engine API를 통해 &lt;code&gt;daemon&lt;/code&gt; 대한 요청 을 허용하거나 거부합니다. 여러 개의 플러그인이 설치되어있는 경우, 각 플러그인은 순서대로 요청 완료를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fe9de19505737022fd6b32fc9b0e8fccb803575" translate="yes" xml:space="preserve">
          <source>Once all the tasks are created and &lt;code&gt;RUNNING&lt;/code&gt;, the actual number of tasks is equal to the desired number:</source>
          <target state="translated">모든 작업이 생성되고 &lt;code&gt;RUNNING&lt;/code&gt; 이면 실제 작업 수는 원하는 수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="56942fc77efe5bdc7966eaa3b75a1ae686316851" translate="yes" xml:space="preserve">
          <source>Once all the uploaded metadata has been validated, Notary server generates the timestamp (and maybe snapshot) metadata. It sends this generated metadata to the Notary signer to be signed.</source>
          <target state="translated">업로드 된 모든 메타 데이터의 유효성이 검사되면 Notary 서버는 타임 스탬프 (아마도 스냅 샷) 메타 데이터를 생성합니다. 서명 된이 메타 데이터를 Notary 서명자에게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a0d98c5297f8e33cd69518be48ac156591623851" translate="yes" xml:space="preserve">
          <source>Once attached to a container, users detach from it and leave it running using the using &lt;code&gt;CTRL-p CTRL-q&lt;/code&gt; key sequence. This detach key sequence is customizable using the &lt;code&gt;detachKeys&lt;/code&gt; property. Specify a &lt;code&gt;&amp;lt;sequence&amp;gt;&lt;/code&gt; value for the property. The format of the &lt;code&gt;&amp;lt;sequence&amp;gt;&lt;/code&gt; is a comma-separated list of either a letter [a-Z], or the &lt;code&gt;ctrl-&lt;/code&gt; combined with any of the following:</source>
          <target state="translated">컨테이너에 연결되면 사용자는 &lt;code&gt;CTRL-p CTRL-q&lt;/code&gt; 키 시퀀스를 사용하여 컨테이너에서 분리하고 실행 상태로 둡니다 . 이 분리 키 시퀀스는 &lt;code&gt;detachKeys&lt;/code&gt; 속성을 사용하여 사용자 지정할 수 있습니다. 특성 의 &lt;code&gt;&amp;lt;sequence&amp;gt;&lt;/code&gt; 값을 지정하십시오 . &lt;code&gt;&amp;lt;sequence&amp;gt;&lt;/code&gt; 의 형식은 쉼표로 구분 된 문자 [aZ] 또는 다음 중 하나와 &lt;code&gt;ctrl-&lt;/code&gt; 을 조합 한 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="e90c896fc09f64b766bf35d746822d56cffc04ab" translate="yes" xml:space="preserve">
          <source>Once complete, the results of this upload are publicly available. If you log in to &lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub&lt;/a&gt;, you see the new image there, with its pull command.</source>
          <target state="translated">완료되면이 업로드 결과를 공개적으로 사용할 수 있습니다. &lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub에&lt;/a&gt; 로그인 하면 pull 명령과 함께 새 이미지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d8f7c925db7d01fbb66e5e5405a4d3bb23f3f946" translate="yes" xml:space="preserve">
          <source>Once connected in network, containers can communicate using only another container&amp;rsquo;s IP address or name. For &lt;code&gt;overlay&lt;/code&gt; networks or custom plugins that support multi-host connectivity, containers connected to the same multi-host network but launched from different Engines can also communicate in this way.</source>
          <target state="translated">네트워크에 연결되면 컨테이너는 다른 컨테이너의 IP 주소 또는 이름 만 사용하여 통신 할 수 있습니다. 들어 &lt;code&gt;overlay&lt;/code&gt; 멀티 호스트 접속을 지원하는 네트워크 또는 사용자 플러그인 다른 엔진에서 동일한 멀티 호스트 네트워크에 연결되지만 발사 용기는 또한 이러한 방식으로 통신 할 수있다.</target>
        </trans-unit>
        <trans-unit id="15e8ac44d73c6bc1cfc3fc73665137e6071769e6" translate="yes" xml:space="preserve">
          <source>Once fixed, retry to run the &lt;code&gt;build&lt;/code&gt; command.</source>
          <target state="translated">수정되면 &lt;code&gt;build&lt;/code&gt; 명령을 다시 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="eaaabd5b3500b89a4a6b4867d962747ad3977f96" translate="yes" xml:space="preserve">
          <source>Once running however, network driver plugins are used just like the built-in network drivers: by being mentioned as a driver in network-oriented Docker commands. For example,</source>
          <target state="translated">그러나 일단 실행되면 네트워크 드라이버 플러그인은 내장 네트워크 드라이버와 같이 네트워크 지향 Docker 명령에서 드라이버로 언급됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3dda62cdf72947347d71493f46957a16d8a0f35e" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;web&lt;/code&gt; service image is built, Compose runs it and executes the &lt;code&gt;django-admin startproject&lt;/code&gt; command in the container. This command instructs Django to create a set of files and directories representing a Django project.</source>
          <target state="translated">일단 &lt;code&gt;web&lt;/code&gt; 서비스 이미지가 구축되고, 작성 그것을 실행하고 실행 &lt;code&gt;django-admin startproject&lt;/code&gt; 컨테이너에 명령을. 이 명령은 Django가 Django 프로젝트를 나타내는 파일 및 디렉토리 세트를 작성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="c38c944032eb15d8d5a2eaa143a9a3db348e4ee1" translate="yes" xml:space="preserve">
          <source>Once the image is built, squash the new layers into a new image with a single new layer. Squashing does not destroy any existing image, rather it creates a new image with the content of the squashed layers. This effectively makes it look like all &lt;code&gt;Dockerfile&lt;/code&gt; commands were created with a single layer. The build cache is preserved with this method.</source>
          <target state="translated">이미지가 만들어지면 새 레이어를 하나의 새 레이어로 새 이미지로 스쿼시합니다. 스 쿼싱은 기존 이미지를 파괴하지 않으며, 찌그러진 레이어의 내용으로 새 이미지를 만듭니다. 이렇게하면 모든 &lt;code&gt;Dockerfile&lt;/code&gt; 명령이 단일 레이어로 생성 된 것처럼 보입니다 . 이 방법으로 빌드 캐시가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3896babc6ce8fb1343800222a8b601ca8a17a1" translate="yes" xml:space="preserve">
          <source>Once the machine is created, you can modify &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/virtual-networks-nsg/&quot;&gt;Network Security Group&lt;/a&gt; rules and open ports of the machine from the &lt;a href=&quot;https://portal.azure.com/&quot;&gt;Azure Portal&lt;/a&gt;.</source>
          <target state="translated">컴퓨터가 생성되면 &lt;a href=&quot;https://portal.azure.com/&quot;&gt;Azure Portal&lt;/a&gt; 에서 &lt;a href=&quot;https://azure.microsoft.com/en-us/documentation/articles/virtual-networks-nsg/&quot;&gt;네트워크 보안 그룹&lt;/a&gt; 규칙을 수정 하고 컴퓨터의 포트를 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d163691b6fcdbab63ae51c125da2d8cbd8e30fb" translate="yes" xml:space="preserve">
          <source>Once the rotation os finished (all the progress bars have completed) the now-current CA certificate will be printed:</source>
          <target state="translated">회전 운영 체제가 완료되면 (모든 진행률 표시 줄이 완료 됨) 현재 현재 CA 인증서가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e6a0da935f3387c6cf23ed7dfd3c1abcd6d15eb2" translate="yes" xml:space="preserve">
          <source>Once you create a machine, you can reuse it as often as you like. Like any VirtualBox VM, it maintains its configuration between uses.</source>
          <target state="translated">머신을 생성하면 원하는만큼 자주 재사용 할 수 있습니다. 다른 VirtualBox VM과 마찬가지로 사용간에 구성을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="454015aad37d070d30cca27f23fcf8cfb238ed55" translate="yes" xml:space="preserve">
          <source>Once you have &lt;a href=&quot;../deploy-service/index&quot;&gt;deployed a service&lt;/a&gt; to a swarm, you are ready to use the Docker CLI to scale the number of containers in the service. Containers running in a service are called &amp;ldquo;tasks.&amp;rdquo;</source>
          <target state="translated">웜에 &lt;a href=&quot;../deploy-service/index&quot;&gt;서비스&lt;/a&gt; 를 배포 했으면 Docker CLI를 사용하여 서비스의 컨테이너 수를 조정할 수 있습니다. 서비스에서 실행되는 컨테이너를 &quot;작업&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9bcab9e6b01a5724ea4674f151046a69aeb6d019" translate="yes" xml:space="preserve">
          <source>Once you have authenticated and have a &lt;code&gt;docker =#&lt;/code&gt; prompt, you can create a table and populate it.</source>
          <target state="translated">인증하고 &lt;code&gt;docker =#&lt;/code&gt; 프롬프트가 표시되면 테이블을 생성하고 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5657e872b393a567f71a1814946d96ff6edb7246" translate="yes" xml:space="preserve">
          <source>Once you have prepared the &lt;code&gt;overlay&lt;/code&gt; network prerequisites you simply choose a Docker host in the cluster and issue the following to create the network:</source>
          <target state="translated">&lt;code&gt;overlay&lt;/code&gt; 네트워크 전제 조건을 준비한 후에 는 클러스터에서 Docker 호스트를 선택하고 다음을 발행하여 네트워크를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="1f009904ccff92bba5b6ea6fcc355e42d3ce4c64" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re all set up and Docker Enterprise is running, you can &lt;a href=&quot;https://docs.docker.com/ee/ucp/swarm/deploy-multi-service-app/&quot;&gt;deploy your Compose file from directly within the UI&lt;/a&gt;.</source>
          <target state="translated">모든 설정이 완료되고 Docker Enterprise가 실행되면 &lt;a href=&quot;https://docs.docker.com/ee/ucp/swarm/deploy-multi-service-app/&quot;&gt;UI 내에서 직접 Compose 파일을 배포&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="116656d8ab8df9e7fd835c2eda2bee76bc3980f8" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve &lt;a href=&quot;../create-swarm/index&quot;&gt;created a swarm&lt;/a&gt; with a manager node, you&amp;rsquo;re ready to add worker nodes.</source>
          <target state="translated">당신이하면 &lt;a href=&quot;../create-swarm/index&quot;&gt;떼 만든&lt;/a&gt; 관리자의 노드를, 당신은 작업자 노드를 추가 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="77917b8cb1d222e94bdaf0dd39241770f26e0097" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve acquired the delegate&amp;rsquo;s x509 certificate, you can add a delegation for this user:</source>
          <target state="translated">대리인의 x509 인증서를 획득하면이 사용자에 대한 위임을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2727a7eab8f6eb87a7ebf4ec8b3a1914247b0efd" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve got a second configuration file, tell Compose to use it with the &lt;code&gt;-f&lt;/code&gt; option:</source>
          <target state="translated">두 번째 구성 파일이 있으면 작성에 &lt;code&gt;-f&lt;/code&gt; 옵션 과 함께 사용하도록 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="3778c802be7c428cae96c2a439939a1c8da464b8" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve set up your environment variables, all the normal &lt;code&gt;docker-compose&lt;/code&gt; commands work with no further configuration.</source>
          <target state="translated">환경 변수를 설정하면 모든 일반 &lt;code&gt;docker-compose&lt;/code&gt; 명령이 추가 구성없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="74525fecde5ee28aa0ef8e4beb36249c122bad51" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve shut down the app, you can safely remove the Django project directory (for example, &lt;code&gt;rm -rf django&lt;/code&gt;).</source>
          <target state="translated">앱을 종료하면 Django 프로젝트 디렉토리 (예 : &lt;code&gt;rm -rf django&lt;/code&gt; )를 안전하게 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="051cbdf3c78cb0f6f7669084244f68dd8c47bfe6" translate="yes" xml:space="preserve">
          <source>One example where this can be useful is to balance tasks over a set of data centers together with &lt;code&gt;--placement-pref&lt;/code&gt; and let &lt;code&gt;--replicas-max-per-node&lt;/code&gt; setting make sure that replicas are not migrated to another datacenter during maintenance or datacenter failure.</source>
          <target state="translated">이것이 유용 할 수있는 한 가지 예는 &lt;code&gt;--placement-pref&lt;/code&gt; 및 let &lt;code&gt;--replicas-max-per-node&lt;/code&gt; 설정 과 함께 일련의 데이터 센터에서 작업의 균형 을 유지하는 것입니다. 유지 관리 또는 데이터 센터 중에 복제본이 다른 데이터 센터로 마이그레이션되지 않도록합니다. 실패.</target>
        </trans-unit>
        <trans-unit id="8fa15a8cd6bb999bab428cb61240621e59c0d4b5" translate="yes" xml:space="preserve">
          <source>One node with &lt;code&gt;node.labels.datacenter=west&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;node.labels.datacenter=west&lt;/code&gt; 를 가진 하나의 노드</target>
        </trans-unit>
        <trans-unit id="348eb2becfa41247043a7aed9f62a577b3355fdc" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&quot;debug&quot;&lt;/code&gt;, &lt;code&gt;&quot;info&quot;&lt;/code&gt;, &lt;code&gt;&quot;warning&quot;&lt;/code&gt;, &lt;code&gt;&quot;error&quot;&lt;/code&gt;, &lt;code&gt;&quot;fatal&quot;&lt;/code&gt;, or &lt;code&gt;&quot;panic&quot;&lt;/code&gt;</source>
          <target state="translated">중 하나 &lt;code&gt;&quot;debug&quot;&lt;/code&gt; , &lt;code&gt;&quot;info&quot;&lt;/code&gt; , &lt;code&gt;&quot;warning&quot;&lt;/code&gt; , &lt;code&gt;&quot;error&quot;&lt;/code&gt; , &lt;code&gt;&quot;fatal&quot;&lt;/code&gt; , 또는 &lt;code&gt;&quot;panic&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b97ba5665c47d913f8e537994abc4452d4a0461" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;created&lt;/code&gt;, &lt;code&gt;restarting&lt;/code&gt;, &lt;code&gt;running&lt;/code&gt;, &lt;code&gt;removing&lt;/code&gt;, &lt;code&gt;paused&lt;/code&gt;, &lt;code&gt;exited&lt;/code&gt;, or &lt;code&gt;dead&lt;/code&gt;</source>
          <target state="translated">하나 &lt;code&gt;created&lt;/code&gt; , &lt;code&gt;restarting&lt;/code&gt; , &lt;code&gt;running&lt;/code&gt; , &lt;code&gt;removing&lt;/code&gt; , &lt;code&gt;paused&lt;/code&gt; , &lt;code&gt;exited&lt;/code&gt; , 또는 &lt;code&gt;dead&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e9b643632e1f4fe5313a82eef5d384932ab430b" translate="yes" xml:space="preserve">
          <source>One of the key advantages of swarm services over standalone containers is that you can modify a service&amp;rsquo;s configuration, including the networks and volumes it is connected to, without the need to manually restart the service. Docker will update the configuration, stop the service tasks with the out of date configuration, and create new ones matching the desired configuration.</source>
          <target state="translated">독립형 컨테이너에 비해 스웜 서비스의 주요 장점 중 하나는 서비스를 수동으로 다시 시작할 필요없이 연결된 네트워크 및 볼륨을 포함하여 서비스 구성을 수정할 수 있다는 것입니다. Docker는 구성을 업데이트하고 오래된 구성으로 서비스 작업을 중지하며 원하는 구성과 일치하는 새 구성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bdc48965a7027e7a8943cd2f1cab62e508bb10b0" translate="yes" xml:space="preserve">
          <source>One of the solution is to add a more permissive rule to a container allowing it access to a wider range of devices. For example, supposing our container needs access to a character device with major &lt;code&gt;42&lt;/code&gt; and any number of minor number (added as new devices appear), the following rule would be added:</source>
          <target state="translated">해결책 중 하나는 컨테이너에 더 허용적인 규칙을 추가하여 더 넓은 범위의 장치에 액세스 할 수 있도록하는 것입니다. 예를 들어, 컨테이너에 메이저 &lt;code&gt;42&lt;/code&gt; 와 마이너 번호가 많은 문자 장치에 액세스해야한다고 가정하면 (새 장치가 추가됨에 따라) 다음 규칙이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="84885fc5a91971a3365b54e8a5fe873f3a68b977" translate="yes" xml:space="preserve">
          <source>One of these machines is a manager (called &lt;code&gt;manager1&lt;/code&gt;) and two of them are workers (&lt;code&gt;worker1&lt;/code&gt; and &lt;code&gt;worker2&lt;/code&gt;).</source>
          <target state="translated">이 기계 중 하나는 관리자 (라는 것입니다 &lt;code&gt;manager1&lt;/code&gt; ) 그 중 두 가지 근로자 ( &lt;code&gt;worker1&lt;/code&gt; 에 와 &lt;code&gt;worker2&lt;/code&gt; 에 ).</target>
        </trans-unit>
        <trans-unit id="eaea1d4f625abd92e75da029bbae5df079760d28" translate="yes" xml:space="preserve">
          <source>One or more custom metadata (&quot;labels&quot;) to apply to the volume upon creation. For example,</source>
          <target state="translated">생성시 볼륨에 적용 할 하나 이상의 사용자 지정 메타 데이터 ( &quot;라벨&quot;)입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2a0d703048410736d5373cad1e26fec8963dae74" translate="yes" xml:space="preserve">
          <source>One primary risk with running Docker containers is that the default set of capabilities and mounts given to a container may provide incomplete isolation, either independently, or when used in combination with kernel vulnerabilities.</source>
          <target state="translated">Docker 컨테이너를 실행할 때의 주요 위험 중 하나는 컨테이너에 제공되는 기본 기능 및 마운트 세트가 독립적으로 또는 커널 취약점과 함께 사용될 때 불완전한 격리를 제공 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="da52240c2554be4279062881dbc210df95e113ab" translate="yes" xml:space="preserve">
          <source>One solution to the above would be to use &lt;code&gt;/&lt;/code&gt; as the target of both the &lt;code&gt;COPY&lt;/code&gt; instruction, and &lt;code&gt;dir&lt;/code&gt;. However, this syntax is, at best, confusing as it is not natural for paths on &lt;code&gt;Windows&lt;/code&gt;, and at worst, error prone as not all commands on &lt;code&gt;Windows&lt;/code&gt; support &lt;code&gt;/&lt;/code&gt; as the path separator.</source>
          <target state="translated">위의 한 가지 해결책은 &lt;code&gt;/&lt;/code&gt; 를 &lt;code&gt;COPY&lt;/code&gt; 명령과 &lt;code&gt;dir&lt;/code&gt; 의 대상 으로 사용 하는 것입니다 . 그러나,이 구문은에 경로에 대한 자연 아니므로 혼동 최고의이며, &lt;code&gt;Windows&lt;/code&gt; , 그리고 최악의 경우에 모든 명령으로 발생하기 쉬운 오류 &lt;code&gt;Windows&lt;/code&gt; 지원 &lt;code&gt;/&lt;/code&gt; 경로 구분 기호로.</target>
        </trans-unit>
        <trans-unit id="d503cec36ba3889aa583ab44a017b49867ef70ae" translate="yes" xml:space="preserve">
          <source>One way to configure credentials is to use the standard credential file for Amazon AWS &lt;code&gt;~/.aws/credentials&lt;/code&gt; file, which might look like:</source>
          <target state="translated">자격 증명을 구성하는 한 가지 방법은 Amazon AWS &lt;code&gt;~/.aws/credentials&lt;/code&gt; 파일에 대한 표준 자격 증명 파일을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c837782ce87036a24d5fce05db6fa517e6dad7c" translate="yes" xml:space="preserve">
          <source>One way to do this would be:</source>
          <target state="translated">이를 수행하는 한 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="836cf691d03f65c71ca270a0d1c1e46e99aa0091" translate="yes" xml:space="preserve">
          <source>Only a manager that is running as the leader &lt;strong&gt;and&lt;/strong&gt; running Docker 17.06 or higher tells nodes to renew their TLS certificates.</source>
          <target state="translated">리더 &lt;strong&gt;로&lt;/strong&gt; 실행 중이고 Docker 17.06 이상을 실행 중인 관리자 만 노드에 TLS 인증서를 갱신하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="97662b4ccf0171aec4bb35a43361c5cc033a67b3" translate="yes" xml:space="preserve">
          <source>Only display IDs</source>
          <target state="translated">ID 만 표시</target>
        </trans-unit>
        <trans-unit id="9ab86dcef4c90f8cc1c591f2617ae4b73b5c0d3a" translate="yes" xml:space="preserve">
          <source>Only display available licenses by ID</source>
          <target state="translated">ID별로 사용 ​​가능한 라이센스 만 표시</target>
        </trans-unit>
        <trans-unit id="7e68c0586f0a038388cd4ceca06ffe73eb6aaba4" translate="yes" xml:space="preserve">
          <source>Only display available versions</source>
          <target state="translated">사용 가능한 버전 만 표시</target>
        </trans-unit>
        <trans-unit id="94a1b3e803e0efb4d69c909c9c2970d7e9898bf7" translate="yes" xml:space="preserve">
          <source>Only display network IDs</source>
          <target state="translated">네트워크 ID 만 표시</target>
        </trans-unit>
        <trans-unit id="f9e80298753072b6ed35c687090505f5bbbb1473" translate="yes" xml:space="preserve">
          <source>Only display numeric IDs</source>
          <target state="translated">숫자 ID 만 표시</target>
        </trans-unit>
        <trans-unit id="48d7cbd90c6b618454294145ec7f3554a6930c2a" translate="yes" xml:space="preserve">
          <source>Only display plugin IDs</source>
          <target state="translated">플러그인 ID 만 표시</target>
        </trans-unit>
        <trans-unit id="960e69e3e6df8844a37315d85436cdfa790a36af" translate="yes" xml:space="preserve">
          <source>Only display task IDs</source>
          <target state="translated">작업 ID 만 표시</target>
        </trans-unit>
        <trans-unit id="9f6e222ebe43d7f341e831c0667c50a0fb885a7b" translate="yes" xml:space="preserve">
          <source>Only display token</source>
          <target state="translated">디스플레이 토큰 만</target>
        </trans-unit>
        <trans-unit id="b911d9aa3b899277c67d4cc215df97379ff896b5" translate="yes" xml:space="preserve">
          <source>Only display volume names</source>
          <target state="translated">볼륨 이름 만 표시</target>
        </trans-unit>
        <trans-unit id="6e4b8beb34eb55485ecd1246f53668cf6d84b10d" translate="yes" xml:space="preserve">
          <source>Only displays with at least x stars</source>
          <target state="translated">별 x 개 이상인 디스플레이 만</target>
        </trans-unit>
        <trans-unit id="b0f4b17835d4d9182fd1134b6c14839078b83007" translate="yes" xml:space="preserve">
          <source>Only nodes running Docker 17.06 or higher obey this directive.</source>
          <target state="translated">Docker 17.06 이상을 실행하는 노드 만이 지시문을 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="89bdf6b8c61a8d2421795f315b1bb5daa2f685b1" translate="yes" xml:space="preserve">
          <source>Only one trust pinning option is used to validate a GUN even if multiple sections are specified, and any validation failure results in a failed bootstrapping of the repo.</source>
          <target state="translated">여러 섹션이 지정되어 있어도 하나의 트러스트 피닝 옵션 만 사용하여 GUN의 유효성을 검사하며 유효성 검사에 실패하면 리포지토리의 부트 스트랩이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3deca4e6f5e41ffffaeb699f5775f94b0ba66dee" translate="yes" xml:space="preserve">
          <source>Only reachable by other containers on the &lt;code&gt;mysql_private&lt;/code&gt; network.</source>
          <target state="translated">&lt;code&gt;mysql_private&lt;/code&gt; 네트워크의 다른 컨테이너에서만 접근 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="290007b091dcea10b5cf4c61f4c56991ea6502b0" translate="yes" xml:space="preserve">
          <source>Only recreate containers that have changed</source>
          <target state="translated">변경된 컨테이너 만 재생성</target>
        </trans-unit>
        <trans-unit id="8ab2c05fb1993f387a0820512191c0c7ceddcea7" translate="yes" xml:space="preserve">
          <source>Only show automated builds</source>
          <target state="translated">자동화 된 빌드 만 표시</target>
        </trans-unit>
        <trans-unit id="bb2f3e52e454841d64badb4f91abaf43c9c67ca0" translate="yes" xml:space="preserve">
          <source>Only show context names</source>
          <target state="translated">컨텍스트 이름 만 표시</target>
        </trans-unit>
        <trans-unit id="1006436cb96a095ec0230b3414c15a3ddef19d2e" translate="yes" xml:space="preserve">
          <source>Only show numeric IDs</source>
          <target state="translated">숫자 ID 만 표시</target>
        </trans-unit>
        <trans-unit id="781aa39610d18058a92379b7f9d0ed56dd72ec77" translate="yes" xml:space="preserve">
          <source>Only the last &lt;code&gt;ENTRYPOINT&lt;/code&gt; instruction in the &lt;code&gt;Dockerfile&lt;/code&gt; will have an effect.</source>
          <target state="translated">마지막 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 의 명령 &lt;code&gt;Dockerfile&lt;/code&gt; 은 영향을 미칠 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e61e329a2e0c93f824dc71096e72344a436f1b5" translate="yes" xml:space="preserve">
          <source>Only the operator (the person executing &lt;code&gt;docker run&lt;/code&gt;) can set the following options.</source>
          <target state="translated">운영자 ( &lt;code&gt;docker run&lt;/code&gt; 을 실행하는 사람) 만 다음 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a6b346c16bf1294baeac2410838ec04a1545ea" translate="yes" xml:space="preserve">
          <source>Only the string form (&lt;code&gt;build: .&lt;/code&gt;) is allowed - not the object form that is allowed in Version 2 and up.</source>
          <target state="translated">버전 2 이상에서 허용되는 오브젝트 양식이 아닌 문자열 양식 ( &lt;code&gt;build: .&lt;/code&gt; ) 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="65d25ab9942777b1b0014048bae309a0e743c8f4" translate="yes" xml:space="preserve">
          <source>Only used when the &lt;code&gt;driver&lt;/code&gt; is set to &lt;code&gt;overlay&lt;/code&gt;. If set to &lt;code&gt;true&lt;/code&gt;, then standalone containers can attach to this network, in addition to services. If a standalone container attaches to an overlay network, it can communicate with services and standalone containers that are also attached to the overlay network from other Docker daemons.</source>
          <target state="translated">&lt;code&gt;driver&lt;/code&gt; 가 &lt;code&gt;overlay&lt;/code&gt; 로 설정된 경우에만 사용됩니다 . &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 독립형 컨테이너는 서비스 외에이 네트워크에 연결할 수 있습니다. 독립형 컨테이너가 오버레이 네트워크에 연결된 경우 다른 Docker 데몬에서 오버레이 네트워크에 연결된 서비스 및 독립형 컨테이너와 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20144a2732a327e45c11d44494ba6852d26b907d" translate="yes" xml:space="preserve">
          <source>Open a command prompt and navigate to your project folder.</source>
          <target state="translated">명령 프롬프트를 열고 프로젝트 폴더로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="73821dd0dd9432d69d6529ac10fff014c941b165" translate="yes" xml:space="preserve">
          <source>Open a command shell or terminal window.</source>
          <target state="translated">명령 쉘 또는 터미널 창을여십시오.</target>
        </trans-unit>
        <trans-unit id="f140b48ecb5b38e5dc91bab8531febeef621c8d9" translate="yes" xml:space="preserve">
          <source>Open a new interactive terminal from your host, and obtain a shell into the &lt;code&gt;sandboxregistry&lt;/code&gt; container.</source>
          <target state="translated">호스트에서 새로운 대화식 터미널을 열고 &lt;code&gt;sandboxregistry&lt;/code&gt; 컨테이너에 쉘을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="8ff00a92e81513e496b0ebe9b2bef278874e789e" translate="yes" xml:space="preserve">
          <source>Open a terminal and ssh into the machine where the manager node runs and run the &lt;code&gt;docker node ls&lt;/code&gt; command to see the worker nodes:</source>
          <target state="translated">터미널을 열고 관리자 노드가 실행되는 시스템으로 ssh를 열고 &lt;code&gt;docker node ls&lt;/code&gt; 명령을 실행 하여 작업자 노드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9c12930eb306e8f822bb709dc19dacef127702b4" translate="yes" xml:space="preserve">
          <source>Open a terminal and ssh into the machine where you run your manager node. For example, the tutorial uses a machine named &lt;code&gt;manager1&lt;/code&gt;.</source>
          <target state="translated">터미널을 열고 관리자 노드를 실행하는 시스템으로 ssh하십시오. 예를 들어, 학습서에서는 이름이 &lt;code&gt;manager1&lt;/code&gt; 인 기계를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c986665333a8a1d4d867db05c76bff37d7e42e8e" translate="yes" xml:space="preserve">
          <source>Open a terminal and ssh into the machine where you want to run a second worker node. This tutorial uses the name &lt;code&gt;worker2&lt;/code&gt;.</source>
          <target state="translated">터미널을 열고 두 번째 작업자 노드를 실행하려는 시스템으로 ssh하십시오. 이 학습서는 &lt;code&gt;worker2&lt;/code&gt; 라는 이름을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="cb177fbe8481d03c21d43e751ee8ae3ec64dac99" translate="yes" xml:space="preserve">
          <source>Open a terminal and ssh into the machine where you want to run a worker node. This tutorial uses the name &lt;code&gt;worker1&lt;/code&gt;.</source>
          <target state="translated">터미널을 열고 작업자 노드를 실행하려는 머신으로 ssh하십시오. 이 학습서는 이름 &lt;code&gt;worker1&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="66392c87ae248bacd34a4d1b70b1cb48f706c63c" translate="yes" xml:space="preserve">
          <source>Open a terminal and ssh into the machine where you want to run your manager node. This tutorial uses a machine named &lt;code&gt;manager1&lt;/code&gt;. If you use Docker Machine, you can connect to it via SSH using the following command:</source>
          <target state="translated">터미널을 열고 관리자 노드를 실행하려는 머신으로 ssh하십시오. 이 학습서는 &lt;code&gt;manager1&lt;/code&gt; 이라는 머신을 사용합니다 . Docker Machine을 사용하는 경우 다음 명령을 사용하여 SSH를 통해 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d95d523000f1334d29b28bdfb3f5d9e6fdf46c" translate="yes" xml:space="preserve">
          <source>Open a terminal or the Docker CLI on your system.</source>
          <target state="translated">시스템에서 터미널 또는 Docker CLI를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="fe7789ab4bbfe44daaecfeb6aa74dc555796c33f" translate="yes" xml:space="preserve">
          <source>Open ports to services on cloud provider machines</source>
          <target state="translated">클라우드 제공자 시스템의 서비스에 대한 포트 열기</target>
        </trans-unit>
        <trans-unit id="c2b085241c5d1c3d094ef71abb91763cf44b165c" translate="yes" xml:space="preserve">
          <source>Open protocols and ports between the hosts</source>
          <target state="translated">호스트 간 개방형 프로토콜 및 포트</target>
        </trans-unit>
        <trans-unit id="f0931780652eaa7cd0ab5ad77bf4567f01fd5a6d" translate="yes" xml:space="preserve">
          <source>Open the &lt;strong&gt;Hyper-V Manager&lt;/strong&gt;. (On Windows 10, search for the Hyper-V Manager in the lower left search field.)</source>
          <target state="translated">&lt;strong&gt;Hyper-V 관리자를&lt;/strong&gt; 엽니 다 . (Windows 10의 경우 왼쪽 아래 검색 필드에서 Hyper-V 관리자를 검색하십시오.)</target>
        </trans-unit>
        <trans-unit id="71d18671c4ef09e35eabea9ba29259d586061bc1" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;docker-compose.yml&lt;/code&gt; in an editor and replace its contents with the following. Be sure to replace &lt;code&gt;username/repo:tag&lt;/code&gt; with your image details.</source>
          <target state="translated">편집기에서 &lt;code&gt;docker-compose.yml&lt;/code&gt; 을 열고 내용을 다음 으로 바꿉니다 . &lt;code&gt;username/repo:tag&lt;/code&gt; 를 이미지 세부 사항 으로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="359dbe2983a5e056ff6a9e5eb77bedf941963318" translate="yes" xml:space="preserve">
          <source>Open-source</source>
          <target state="translated">Open-source</target>
        </trans-unit>
        <trans-unit id="3d8bd6f9a145c81ba3f59062586c5cf6108400d0" translate="yes" xml:space="preserve">
          <source>OpenStack</source>
          <target state="translated">OpenStack</target>
        </trans-unit>
        <trans-unit id="9afacaa405964a9f3509bd63e45c0643e9b44bc8" translate="yes" xml:space="preserve">
          <source>OpenStorage Plugin</source>
          <target state="translated">OpenStorage 플러그인</target>
        </trans-unit>
        <trans-unit id="d123520b5a0068be3e31e6f7c3f36e3e5a8612d5" translate="yes" xml:space="preserve">
          <source>Operate manager nodes in a swarm</source>
          <target state="translated">떼에서 관리자 노드 운영</target>
        </trans-unit>
        <trans-unit id="fc9c955d85178cd913bd38c446f912eed92dc41e" translate="yes" xml:space="preserve">
          <source>Operate on machines without specifying the name</source>
          <target state="translated">이름을 지정하지 않고 기계에서 작동</target>
        </trans-unit>
        <trans-unit id="e5ba86326755952233b0543acced2995e5faf457" translate="yes" xml:space="preserve">
          <source>Operating System</source>
          <target state="translated">운영 체제</target>
        </trans-unit>
        <trans-unit id="ef9f46256fd0814f00b707514623ae1a3f1eb5e1" translate="yes" xml:space="preserve">
          <source>Operator exclusive options</source>
          <target state="translated">운영자 독점 옵션</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="61d64dff0785571c6eba5ea81694dab18d784171" translate="yes" xml:space="preserve">
          <source>Option types</source>
          <target state="translated">옵션 유형</target>
        </trans-unit>
        <trans-unit id="968cd00280ec3de7f43254c915aeb523cbc48e86" translate="yes" xml:space="preserve">
          <source>Optional parent cgroup for the container</source>
          <target state="translated">컨테이너의 선택적 상위 cgroup</target>
        </trans-unit>
        <trans-unit id="067a1029f7359b1bec4c546c6c0672c3b9517818" translate="yes" xml:space="preserve">
          <source>Optional security options (--security-opt)</source>
          <target state="translated">선택적 보안 옵션 (--security-opt)</target>
        </trans-unit>
        <trans-unit id="2b19dd7d02f914828409b09a211d46a776fdf662" translate="yes" xml:space="preserve">
          <source>Optional volume driver for the container</source>
          <target state="translated">컨테이너 용 옵션 볼륨 드라이버</target>
        </trans-unit>
        <trans-unit id="166b83695108e689f06f6d8c9503d654c46d0387" translate="yes" xml:space="preserve">
          <source>Optional:</source>
          <target state="translated">Optional:</target>
        </trans-unit>
        <trans-unit id="e19c10f0574eae1f843ee1f8516d026345ba6571" translate="yes" xml:space="preserve">
          <source>Optionally &lt;code&gt;COPY&lt;/code&gt; accepts a flag &lt;code&gt;--from=&amp;lt;name|index&amp;gt;&lt;/code&gt; that can be used to set the source location to a previous build stage (created with &lt;code&gt;FROM .. AS &amp;lt;name&amp;gt;&lt;/code&gt;) that will be used instead of a build context sent by the user. The flag also accepts a numeric index assigned for all previous build stages started with &lt;code&gt;FROM&lt;/code&gt; instruction. In case a build stage with a specified name can&amp;rsquo;t be found an image with the same name is attempted to be used instead.</source>
          <target state="translated">선택적으로 &lt;code&gt;COPY&lt;/code&gt; 는 소스 위치를 이전 빌드 단계 ( &lt;code&gt;FROM .. AS &amp;lt;name&amp;gt;&lt;/code&gt; )로 전송하여 빌드 컨텍스트 대신 전송되는 플래그 &lt;code&gt;--from=&amp;lt;name|index&amp;gt;&lt;/code&gt; 를 허용합니다 . 사용자. 또한 플래그는 &lt;code&gt;FROM&lt;/code&gt; 명령으로 시작된 모든 이전 빌드 단계에 지정된 숫자 인덱스를 승인합니다 . 지정된 이름의 빌드 단계를 찾을 수없는 경우 동일한 이름의 이미지를 대신 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="70a18d4d4d9cff0221fbba3064bff784177f9b09" translate="yes" xml:space="preserve">
          <source>Optionally a name can be given to a new build stage by adding &lt;code&gt;AS name&lt;/code&gt; to the &lt;code&gt;FROM&lt;/code&gt; instruction. The name can be used in subsequent &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;COPY --from=&amp;lt;name|index&amp;gt;&lt;/code&gt; instructions to refer to the image built in this stage.</source>
          <target state="translated">선택적으로 &lt;code&gt;FROM&lt;/code&gt; 명령에 &lt;code&gt;AS name&lt;/code&gt; 을 추가하여 새 빌드 단계에 이름을 지정할 수 있습니다 . 이 이름은 후속 &lt;code&gt;FROM&lt;/code&gt; 및 &lt;code&gt;COPY --from=&amp;lt;name|index&amp;gt;&lt;/code&gt; 명령에서 사용 되어이 단계에서 빌드 된 이미지를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1dff0fd723d5323b4ff25d25090bd7d73c2a34" translate="yes" xml:space="preserve">
          <source>Optionally specify a path on the host machine (&lt;code&gt;HOST:CONTAINER&lt;/code&gt;), or an access mode (&lt;code&gt;HOST:CONTAINER:ro&lt;/code&gt;).</source>
          <target state="translated">선택적으로 호스트 시스템 ( &lt;code&gt;HOST:CONTAINER&lt;/code&gt; ) 또는 액세스 모드 ( &lt;code&gt;HOST:CONTAINER:ro&lt;/code&gt; ) 에서 경로를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="56fcf3735ce385cf68e901ac1dacb6f811093553" translate="yes" xml:space="preserve">
          <source>Optionally, create an AWS credential file.</source>
          <target state="translated">선택적으로 AWS 자격 증명 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e43603d33f432024aed5c582d5d86095fb10f05f" translate="yes" xml:space="preserve">
          <source>Optionally, install &lt;a href=&quot;../completion/index&quot;&gt;command completion&lt;/a&gt; for the &lt;code&gt;bash&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt; shell.</source>
          <target state="translated">선택적으로 &lt;code&gt;bash&lt;/code&gt; 및 &lt;code&gt;zsh&lt;/code&gt; 쉘에 대한 &lt;a href=&quot;../completion/index&quot;&gt;명령 완료&lt;/a&gt; 를 설치 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff6f78b2b732dd50d2bb5b796ceeafb9791c7c1a" translate="yes" xml:space="preserve">
          <source>Optionally, remove the machines you created.</source>
          <target state="translated">선택적으로, 작성한 기계를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="d1f9c65ceed5ac10fc6f610fce7eb34eea64f903" translate="yes" xml:space="preserve">
          <source>Options for Bind Mounts</source>
          <target state="translated">바인드 마운트 옵션</target>
        </trans-unit>
        <trans-unit id="d72d2c2d03d1750c7638123c82b942c95499306e" translate="yes" xml:space="preserve">
          <source>Options for named volumes</source>
          <target state="translated">명명 된 볼륨에 대한 옵션</target>
        </trans-unit>
        <trans-unit id="2e04ea69bd11f5159ab09d902e468334f123a9f1" translate="yes" xml:space="preserve">
          <source>Options for the runtime</source>
          <target state="translated">런타임 옵션</target>
        </trans-unit>
        <trans-unit id="a1cf8fe2d90fce64054ef798ae99d316551b6d5b" translate="yes" xml:space="preserve">
          <source>Options for tmpfs</source>
          <target state="translated">tmpfs 옵션</target>
        </trans-unit>
        <trans-unit id="6f268a80958e1f56daa912f8eec225fec6754f2b" translate="yes" xml:space="preserve">
          <source>Options like &lt;code&gt;--name=&quot;&quot;&lt;/code&gt; expect a string, and they can only be specified once. Options like &lt;code&gt;-c=0&lt;/code&gt; expect an integer, and they can only be specified once.</source>
          <target state="translated">&lt;code&gt;--name=&quot;&quot;&lt;/code&gt; 과 같은 옵션 에는 문자열이 필요하며 한 번만 지정할 수 있습니다. &lt;code&gt;-c=0&lt;/code&gt; 과 같은 옵션 은 정수를 예상하며 한 번만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97d86f82e924af65a4340bf40e3d953394e0c765" translate="yes" xml:space="preserve">
          <source>Options per storage driver</source>
          <target state="translated">스토리지 드라이버 당 옵션</target>
        </trans-unit>
        <trans-unit id="a2194be9af6f0547c10d6dedd8548e5af9de6c7a" translate="yes" xml:space="preserve">
          <source>Options specific to a given volume driver, which will be passed to the driver when creating the volume. Options are provided as a comma-separated list of key/value pairs, for example,</source>
          <target state="translated">주어진 볼륨 드라이버에 특정한 옵션으로, 볼륨을 만들 때 드라이버로 전달됩니다. 옵션은 쉼표로 구분 된 키 / 값 쌍 목록으로 제공됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="2ee54a2902a3f6515377b2b4148d5996f355be54" translate="yes" xml:space="preserve">
          <source>Options which default to &lt;code&gt;true&lt;/code&gt; (e.g., &lt;code&gt;docker build --rm=true&lt;/code&gt;) can only be set to the non-default value by explicitly setting them to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">기본값이 &lt;code&gt;true&lt;/code&gt; 인 옵션 (예 : &lt;code&gt;docker build --rm=true&lt;/code&gt; )은 명시 적으로 &lt;code&gt;false&lt;/code&gt; 로 설정하여 기본값이 아닌 값으로 만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="758dba0595095b1b9bb3efb50538508ec47ab8a6" translate="yes" xml:space="preserve">
          <source>Options with [] may be specified multiple times.</source>
          <target state="translated">[] 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd0d74b6040cff807335c68824ae8280a7f1976" translate="yes" xml:space="preserve">
          <source>Options, Environment Variables, and Defaults</source>
          <target state="translated">옵션, 환경 변수 및 기본값</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="b55c13cfcccc46111b383d467e3af37c5be9c20c" translate="yes" xml:space="preserve">
          <source>Or if you have an existing key:</source>
          <target state="translated">또는 기존 키가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="23e567971464eec55937f48d4f3c8159e2ff3e29" translate="yes" xml:space="preserve">
          <source>Or, as an object with the path specified under &lt;a href=&quot;#context&quot;&gt;context&lt;/a&gt; and optionally &lt;a href=&quot;#dockerfile&quot;&gt;Dockerfile&lt;/a&gt; and &lt;a href=&quot;#args&quot;&gt;args&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;#context&quot;&gt;컨텍스트&lt;/a&gt; 에서 경로가 지정 되고 선택적으로 &lt;a href=&quot;#dockerfile&quot;&gt;Dockerfile&lt;/a&gt; 및 &lt;a href=&quot;#args&quot;&gt;args&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4ffd9aa4653315d01ae6878019c4385211fb4807" translate="yes" xml:space="preserve">
          <source>Or, for a more elegant shutdown, switch to a different shell, and run &lt;a href=&quot;../reference/down/index&quot;&gt;docker-compose down&lt;/a&gt; from the top level of your Django sample project directory.</source>
          <target state="translated">또는 더 우아한 종료를 위해 다른 쉘로 전환하고 Django 샘플 프로젝트 디렉토리의 최상위 레벨에서 &lt;a href=&quot;../reference/down/index&quot;&gt;docker-compose down&lt;/a&gt; 을 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="091c4901b6071de52dffb8bc1ff5ad41977267a6" translate="yes" xml:space="preserve">
          <source>Or, learn how to &lt;a href=&quot;../../machine/examples/ocean/index&quot;&gt;launch your container on your own machine using DigitalOcean&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;../../machine/examples/ocean/index&quot;&gt;DigitalOcean을 사용하여 자신의 컴퓨터에서 컨테이너&lt;/a&gt; 를 시작 하는 방법을 배우 십시오 .</target>
        </trans-unit>
        <trans-unit id="abf31eecd21f3bc9e0c3ab5cbd025122ef95c9bd" translate="yes" xml:space="preserve">
          <source>Or, manually download the credentials.json file to the local, and set the &lt;code&gt;GOOGLE_APPLICATION_CREDENTIALS&lt;/code&gt; environment variable point to its location, such as:</source>
          <target state="translated">또는 credentials.json 파일을 로컬로 수동으로 다운로드하고 &lt;code&gt;GOOGLE_APPLICATION_CREDENTIALS&lt;/code&gt; 환경 변수 지점을 다음과 같은 위치로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9641c10061cb254a472391cd2be37679c83ed4ea" translate="yes" xml:space="preserve">
          <source>Or, to get the last time the container was (re)started;</source>
          <target state="translated">또는 컨테이너가 마지막으로 (재) 시작된 시간을 얻기 위해;</target>
        </trans-unit>
        <trans-unit id="c9595499c4828097288e4ef396cfd9c1c6d3de0e" translate="yes" xml:space="preserve">
          <source>Oracle VirtualBox</source>
          <target state="translated">Oracle VirtualBox</target>
        </trans-unit>
        <trans-unit id="ba09c49c562eb2bd6c5f61c435a4a1315ed16fc3" translate="yes" xml:space="preserve">
          <source>Orchestrator name</source>
          <target state="translated">오케 스트레이터 이름</target>
        </trans-unit>
        <trans-unit id="05605f281fd5f919de8af24fd8953b98ead63400" translate="yes" xml:space="preserve">
          <source>Orchestrator to use (swarm|kubernetes|all)</source>
          <target state="translated">사용할 오케 스트레이터 (swarm | kubernetes | all)</target>
        </trans-unit>
        <trans-unit id="7f8c83a2e9d79061710933f4e2c394956211e327" translate="yes" xml:space="preserve">
          <source>Other extended shell-style features, such as &lt;code&gt;${VARIABLE/foo/bar}&lt;/code&gt;, are not supported.</source>
          <target state="translated">&lt;code&gt;${VARIABLE/foo/bar}&lt;/code&gt; 와 같은 다른 확장 쉘 스타일 기능 은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08285fb71e08e2a83a9aff62be6be95fb97518b0" translate="yes" xml:space="preserve">
          <source>Other important data such as the name of a database or internal server</source>
          <target state="translated">데이터베이스 또는 내부 서버 이름과 같은 기타 중요한 데이터</target>
        </trans-unit>
        <trans-unit id="ff66b4a8e242fa3cf836666e7971d83ff8620b0f" translate="yes" xml:space="preserve">
          <source>Other kernel security features</source>
          <target state="translated">다른 커널 보안 기능</target>
        </trans-unit>
        <trans-unit id="497809d5462818e8f9932c9b38cd77840134f5fe" translate="yes" xml:space="preserve">
          <source>Other modes</source>
          <target state="translated">다른 모드</target>
        </trans-unit>
        <trans-unit id="4615ec3f22c175134637f03b404230709b685a58" translate="yes" xml:space="preserve">
          <source>Other options can be combined with &lt;code&gt;--rollback&lt;/code&gt; as well, for example, &lt;code&gt;--update-delay 0s&lt;/code&gt; to execute the rollback without a delay between tasks:</source>
          <target state="translated">다른 옵션은 &lt;code&gt;--rollback&lt;/code&gt; 과 함께 사용하여 작업 사이의 지연없이 롤백을 실행하기 위해 &lt;code&gt;--update-delay 0s&lt;/code&gt; 과 같이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d12a5098a4c1e254845520e4d685f7713dd6a436" translate="yes" xml:space="preserve">
          <source>Other options can be combined with &lt;code&gt;--rollback&lt;/code&gt;; for example, &lt;code&gt;--update-delay 0s&lt;/code&gt; to execute the rollback without a delay between tasks:</source>
          <target state="translated">다른 옵션은 &lt;code&gt;--rollback&lt;/code&gt; 과 결합 할 수 있습니다 . 예를 들어 &lt;code&gt;--update-delay 0s&lt;/code&gt; 는 작업 간 지연없이 롤백을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="10e45ca399d3f12696b9c46335e90a64bfbb3d42" translate="yes" xml:space="preserve">
          <source>Other types of tags, such as &lt;code&gt;latest&lt;/code&gt; or &lt;code&gt;nightly&lt;/code&gt;, may resolve to a new digest often, depending on how often an image&amp;rsquo;s author updates the tag. It is not recommended to run services using a tag which is updated frequently, to prevent different service replica tasks from using different image versions.</source>
          <target state="translated">&lt;code&gt;latest&lt;/code&gt; 또는 &lt;code&gt;nightly&lt;/code&gt; 와 같은 다른 유형의 태그 는 이미지 작성자가 태그를 업데이트하는 빈도에 따라 새로운 요약으로 자주 해석 될 수 있습니다. 다른 서비스 복제본 작업이 다른 이미지 버전을 사용하지 못하도록 자주 업데이트되는 태그를 사용하여 서비스를 실행하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2d59e70b3050ac8983cf25ce00e8727106cb6f7a" translate="yes" xml:space="preserve">
          <source>Otherwise, download one of the releases from the &lt;a href=&quot;https://github.com/docker/machine/releases/&quot;&gt;docker/machine release page&lt;/a&gt; directly.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;https://github.com/docker/machine/releases/&quot;&gt;docker / machine release 페이지&lt;/a&gt; 에서 릴리스 중 하나를 직접 다운로드 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e09cd7263bb9b4e1ad90beb058278019f4c4ff76" translate="yes" xml:space="preserve">
          <source>Our single service stack is running 5 container instances of our deployed image on one host. Let&amp;rsquo;s investigate.</source>
          <target state="translated">단일 서비스 스택은 하나의 호스트에서 배포 된 이미지의 컨테이너 인스턴스 5 개를 실행 중입니다. 조사합시다.</target>
        </trans-unit>
        <trans-unit id="dd012c12de10c3debb145c0b98a7de5d9f16ef2b" translate="yes" xml:space="preserve">
          <source>Out Of Memory Exceptions (OOME)</source>
          <target state="translated">메모리 부족 예외 (OOME)</target>
        </trans-unit>
        <trans-unit id="a8e827c31f497098a6c727c8c141883d2e51da76" translate="yes" xml:space="preserve">
          <source>Output additional info including layers and platform</source>
          <target state="translated">레이어 및 플랫폼을 포함한 추가 정보 출력</target>
        </trans-unit>
        <trans-unit id="a0203ac3470dd137c38ed56ab6041f10182c2ee3" translate="yes" xml:space="preserve">
          <source>Output destination (format: type=local,dest=path)</source>
          <target state="translated">출력 대상 (형식 : type = local, dest = path)</target>
        </trans-unit>
        <trans-unit id="c6446248abe8acc407055445d2a1f0cb4b69f0f1" translate="yes" xml:space="preserve">
          <source>Overlay network limitations</source>
          <target state="translated">오버레이 네트워크 제한</target>
        </trans-unit>
        <trans-unit id="937cfbc009330ac5c402ca228b80005e7dbc88f7" translate="yes" xml:space="preserve">
          <source>Overlay2 options</source>
          <target state="translated">오버레이 2 옵션</target>
        </trans-unit>
        <trans-unit id="3d1fe7eae5e22fff11fa78015dbe052b1f7062c0" translate="yes" xml:space="preserve">
          <source>Override Mandatory Access Control (MAC). Implemented for the Smack Linux Security Module (LSM).</source>
          <target state="translated">필수 액세스 제어 (MAC)를 무시하십시오. Smack Linux Security Module (LSM)을 위해 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="4bc0c08c87f1f825b709b3544ae2f3731ea2929c" translate="yes" xml:space="preserve">
          <source>Override resource Limits.</source>
          <target state="translated">리소스 제한을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3eb8744fedec986b16750bc8b95ba2ca0188f45a" translate="yes" xml:space="preserve">
          <source>Override the current location where engine images are pulled</source>
          <target state="translated">엔진 이미지를 가져온 현재 위치를 재정의</target>
        </trans-unit>
        <trans-unit id="0473ba965ed5ea3acbab59b4decdf8481e851c01" translate="yes" xml:space="preserve">
          <source>Override the default command.</source>
          <target state="translated">기본 명령을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="1fb7f9877b90787162c56a15a7ec4bc17d5ebd9c" translate="yes" xml:space="preserve">
          <source>Override the default entrypoint.</source>
          <target state="translated">기본 진입 점을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="254bcfade56264dcaa5c2c691900d06910c3b387" translate="yes" xml:space="preserve">
          <source>Override the default labeling scheme for each container.</source>
          <target state="translated">각 컨테이너의 기본 레이블 구성표를 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="761466450c75ee8adcf900f70b40bd12ba032044" translate="yes" xml:space="preserve">
          <source>Override the default location where engine images are pulled</source>
          <target state="translated">엔진 이미지를 가져 오는 기본 위치를 재정의</target>
        </trans-unit>
        <trans-unit id="a251a28b1e7fe3634ba59a330bbf61d5178b125e" translate="yes" xml:space="preserve">
          <source>Override the default ulimits for a container. You can either specify a single limit as an integer or soft/hard limits as a mapping.</source>
          <target state="translated">컨테이너의 기본 ulimits를 재정의하십시오. 단일 제한을 정수로 지정하거나 소프트 / 하드 제한을 매핑으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b8103feac99917fdb17772128b0cecc55692039" translate="yes" xml:space="preserve">
          <source>Override the detach sequence</source>
          <target state="translated">분리 시퀀스 무시</target>
        </trans-unit>
        <trans-unit id="1ab9c189c41d8f16b6f6a150a9b270bfb79d0ce2" translate="yes" xml:space="preserve">
          <source>Override the existing location where engine images are pulled</source>
          <target state="translated">엔진 이미지를 가져온 기존 위치를 재정의</target>
        </trans-unit>
        <trans-unit id="bebaa4f48d6cc6f7b302abbcdd7450e644ed6443" translate="yes" xml:space="preserve">
          <source>Override the key sequence for detaching a container</source>
          <target state="translated">컨테이너 분리를위한 키 시퀀스 재정의</target>
        </trans-unit>
        <trans-unit id="d9f0d7434bb4167992d2eeef041f5525ea9b03cc" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;udev&lt;/code&gt; synchronization checks between &lt;code&gt;devicemapper&lt;/code&gt; and &lt;code&gt;udev&lt;/code&gt;. &lt;code&gt;udev&lt;/code&gt; is the device manager for the Linux kernel.</source>
          <target state="translated">&lt;code&gt;devicemapper&lt;/code&gt; 와 &lt;code&gt;udev&lt;/code&gt; 사이 의 &lt;code&gt;udev&lt;/code&gt; 동기화 검사를 대체합니다 . &lt;code&gt;udev&lt;/code&gt; 는 Linux 커널의 장치 관리자입니다.</target>
        </trans-unit>
        <trans-unit id="9da4ef22baf105c71788c0ce8b6d4921b5d14631" translate="yes" xml:space="preserve">
          <source>Overrides the Linux kernel version check allowing overlay2. Support for specifying multiple lower directories needed by overlay2 was added to the Linux kernel in 4.0.0. However, some older kernel versions may be patched to add multiple lower directory support for OverlayFS. This option should only be used after verifying this support exists in the kernel. Applying this option on a kernel without this support will cause failures on mount.</source>
          <target state="translated">overlay2를 허용하는 Linux 커널 버전 확인을 재정의합니다. overlay2에 필요한 여러 하위 디렉토리 지정에 대한 지원이 4.0.0의 Linux 커널에 추가되었습니다. 그러나 일부 이전 커널 버전은 OverlayFS에 대한 여러 하위 디렉토리 지원을 추가하기 위해 패치 될 수 있습니다. 이 옵션은이 지원이 커널에 존재하는지 확인한 후에 만 ​​사용해야합니다. 이 지원없이 커널에이 옵션을 적용하면 마운트 실패가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b5e732f2fa5b2105b1de3e123ce8199f6f6161e" translate="yes" xml:space="preserve">
          <source>Overriding Dockerfile image defaults</source>
          <target state="translated">Dockerfile 이미지 기본값 재정의</target>
        </trans-unit>
        <trans-unit id="845a0bed924d732a988ae2264dc4d0ed123325f6" translate="yes" xml:space="preserve">
          <source>Overriding configuration file parameters using environment variables</source>
          <target state="translated">환경 변수를 사용하여 구성 파일 매개 변수 대체</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3edf049391ed6e8758a3b3023d46711f7353b3c0" translate="yes" xml:space="preserve">
          <source>Overview of Docker Compose</source>
          <target state="translated">Docker Compose 개요</target>
        </trans-unit>
        <trans-unit id="8287ed1ad32829bd3b5f9f80fd3b7562037ac7ac" translate="yes" xml:space="preserve">
          <source>Overview of docker-compose CLI</source>
          <target state="translated">docker-compose CLI 개요</target>
        </trans-unit>
        <trans-unit id="31f5f03f259ac0cb2e44c1dd7ca0c3398912dadc" translate="yes" xml:space="preserve">
          <source>Overview of the file</source>
          <target state="translated">파일 개요</target>
        </trans-unit>
        <trans-unit id="11f898c301bfb8618ea3088b9b3788c94c15dfef" translate="yes" xml:space="preserve">
          <source>Overwrite the default ENTRYPOINT of the image</source>
          <target state="translated">이미지의 기본 ENTRYPOINT를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="f7a906eb9f003561cf81d980ceaf0edc8a486bbb" translate="yes" xml:space="preserve">
          <source>Own private IPC namespace, with /dev/shm not mounted.</source>
          <target state="translated">/ dev / shm이 마운트되지 않은 자체 개인 IPC 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="897a10837bbfe15a8f76145e73e399107e711091" translate="yes" xml:space="preserve">
          <source>Own private IPC namespace, with a possibility to share it with other containers.</source>
          <target state="translated">다른 컨테이너와 공유 할 수있는 개인 IPC 네임 스페이스를 소유합니다.</target>
        </trans-unit>
        <trans-unit id="e8227d0b2995daeefa9a0f4274fa6594c1346653" translate="yes" xml:space="preserve">
          <source>Own private IPC namespace.</source>
          <target state="translated">개인 IPC 네임 스페이스를 소유합니다.</target>
        </trans-unit>
        <trans-unit id="97191026215e3e01f089f93777a76e24766a62db" translate="yes" xml:space="preserve">
          <source>PID equivalent</source>
          <target state="translated">PID 동등</target>
        </trans-unit>
        <trans-unit id="597ef4a0f67758736d62514f5f1fd5f1f3d0d992" translate="yes" xml:space="preserve">
          <source>PID is the process id of &lt;code&gt;notary-server&lt;/code&gt; and it may not the PID 1 process if you are running the container with some kind of wrapper startup script or something.</source>
          <target state="translated">PID는 &lt;code&gt;notary-server&lt;/code&gt; 의 프로세스 ID이며 어떤 종류의 래퍼 시작 스크립트 또는 다른 것으로 컨테이너를 실행하는 경우 PID 1 프로세스가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6285a5fe67969c91bc578f9f8ba9b45caaaff04d" translate="yes" xml:space="preserve">
          <source>PID namespace provides separation of processes. The PID Namespace removes the view of the system processes, and allows process ids to be reused including pid 1.</source>
          <target state="translated">PID 네임 스페이스는 프로세스 분리를 ​​제공합니다. PID 네임 스페이스는 시스템 프로세스의보기를 제거하고 pid 1을 포함하여 프로세스 ID를 재사용 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="24584fcb52c6d856e140a5f8b30ebecc7ee06e7d" translate="yes" xml:space="preserve">
          <source>PID namespace to use</source>
          <target state="translated">사용할 PID 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="9b210c8c95e4cf65466a49bab1e89bdb4c59ac3b" translate="yes" xml:space="preserve">
          <source>PID settings (--pid)</source>
          <target state="translated">PID 설정 (--pid)</target>
        </trans-unit>
        <trans-unit id="92cca1191c951841138a2665f060c96816b19bca" translate="yes" xml:space="preserve">
          <source>Parallelize building independent build stages</source>
          <target state="translated">독립적 인 구축 단계를 병렬화</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="31ed1f83abf4e051270efb10db7e14a36ddb3909" translate="yes" xml:space="preserve">
          <source>Parent command</source>
          <target state="translated">부모 명령</target>
        </trans-unit>
        <trans-unit id="b80955bea8bd531677e3c955260b4fbe71f1f29a" translate="yes" xml:space="preserve">
          <source>Parser directives</source>
          <target state="translated">파서 지시문</target>
        </trans-unit>
        <trans-unit id="dfc802b986fb4ff69d10de7d3927249648d4c79a" translate="yes" xml:space="preserve">
          <source>Parser directives are not case-sensitive. However, convention is for them to be lowercase. Convention is also to include a blank line following any parser directives. Line continuation characters are not supported in parser directives.</source>
          <target state="translated">파서 지시문은 대소 문자를 구분하지 않습니다. 그러나 관례는 그것들이 소문자 인 것입니다. 협약은 또한 파서 지시문 뒤에 빈 줄을 포함해야합니다. 행 연속 문자는 구문 분석기 지시문에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="387a49832770a1774fa099cfd338d06e12fdff96" translate="yes" xml:space="preserve">
          <source>Parser directives are optional, and affect the way in which subsequent lines in a &lt;code&gt;Dockerfile&lt;/code&gt; are handled. Parser directives do not add layers to the build, and will not be shown as a build step. Parser directives are written as a special type of comment in the form &lt;code&gt;# directive=value&lt;/code&gt;. A single directive may only be used once.</source>
          <target state="translated">파서 지시문은 선택 사항이며 &lt;code&gt;Dockerfile&lt;/code&gt; 의 후속 줄 이 처리 되는 방식에 영향을 미칩니다 . 파서 지시문은 빌드에 레이어를 추가하지 않으며 빌드 단계로 표시되지 않습니다. 파서 지시문은 &lt;code&gt;# directive=value&lt;/code&gt; 형식으로 특수한 유형의 주석으로 작성됩니다 . 단일 지시문은 한 번만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1bce007197e30b5e0c13535d91b1a5c367e5d0" translate="yes" xml:space="preserve">
          <source>Particular storage-driver can be configured with options specified with &lt;code&gt;--storage-opt&lt;/code&gt; flags. Options for &lt;code&gt;devicemapper&lt;/code&gt; are prefixed with &lt;code&gt;dm&lt;/code&gt;, options for &lt;code&gt;zfs&lt;/code&gt; start with &lt;code&gt;zfs&lt;/code&gt;, options for &lt;code&gt;btrfs&lt;/code&gt; start with &lt;code&gt;btrfs&lt;/code&gt; and options for &lt;code&gt;lcow&lt;/code&gt; start with &lt;code&gt;lcow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--storage-opt&lt;/code&gt; 플래그로 지정된 옵션으로 특정 스토리지 드라이버를 구성 할 수 있습니다 . 에 대한 옵션 &lt;code&gt;devicemapper&lt;/code&gt; 가 로 시작하는 &lt;code&gt;dm&lt;/code&gt; , 옵션 &lt;code&gt;zfs&lt;/code&gt; 시작 &lt;code&gt;zfs&lt;/code&gt; , 옵션 &lt;code&gt;btrfs&lt;/code&gt; 를가 시작 &lt;code&gt;btrfs&lt;/code&gt; 를 및 옵션 &lt;code&gt;lcow&lt;/code&gt; 의 시작 &lt;code&gt;lcow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b4b1449c9a0f425ab54b96ccae83262249d5b02" translate="yes" xml:space="preserve">
          <source>Pass a profile for a container</source>
          <target state="translated">컨테이너에 대한 프로파일 전달</target>
        </trans-unit>
        <trans-unit id="e908dff5a253e36632011f59f86b0a6299293c6b" translate="yes" xml:space="preserve">
          <source>Pass environment variables to containers</source>
          <target state="translated">환경 변수를 컨테이너에 전달</target>
        </trans-unit>
        <trans-unit id="534171b485c4823cbc7bad7579ec8d58b9f53e00" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;--label-add&lt;/code&gt; flag once for each node label you want to add:</source>
          <target state="translated">패스 &lt;code&gt;--label-add&lt;/code&gt; 추가 할 각 노드 레이블 일단 플래그 :</target>
        </trans-unit>
        <trans-unit id="e4b058cfca2e72535808381ac3cbb84b36fdb7f7" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;--quiet&lt;/code&gt; flag to print only the token:</source>
          <target state="translated">패스 &lt;code&gt;--quiet&lt;/code&gt; 에만 토큰을 인쇄하는 플래그를 :</target>
        </trans-unit>
        <trans-unit id="ed8fec9fe3a5a64725006200143c76bb739ca11c" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;--rotate&lt;/code&gt; flag (and optionally a &lt;code&gt;--ca-cert&lt;/code&gt;, along with a &lt;code&gt;--ca-key&lt;/code&gt; or &lt;code&gt;--external-ca&lt;/code&gt; parameter flag), in order to rotate the current swarm root CA.</source>
          <target state="translated">패스 &lt;code&gt;--rotate&lt;/code&gt; (및 임의로 플래그 &lt;code&gt;--ca-cert&lt;/code&gt; A를 따라 &lt;code&gt;--ca-key&lt;/code&gt; 또는 &lt;code&gt;--external-ca&lt;/code&gt; 현재 떼 루트 CA를 회전하기 위해, 파라미터 플래그)</target>
        </trans-unit>
        <trans-unit id="c5fb9c9faec8112491a1ca7915bc462a3ff83d02" translate="yes" xml:space="preserve">
          <source>Passing a negative number or a non-integer to &lt;code&gt;--tail&lt;/code&gt; is invalid and the value is set to &lt;code&gt;all&lt;/code&gt; in that case.</source>
          <target state="translated">음수 또는 정수가 아닌 &lt;code&gt;--tail&lt;/code&gt; 을 전달하는 것은 유효하지 않으며이 경우 값은 &lt;code&gt;all&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="90762cc33a299cdb91241d47d7b0ab8185b2f96c" translate="yes" xml:space="preserve">
          <source>Passing an &lt;code&gt;HostConfig&lt;/code&gt; to &lt;code&gt;POST /containers/{name}/start&lt;/code&gt; is deprecated in favor of defining it at container creation (&lt;code&gt;POST /containers/create&lt;/code&gt;).</source>
          <target state="translated">컨테이너 구성 ( &lt;code&gt;POST /containers/create&lt;/code&gt; ) 에서 &lt;code&gt;HostConfig&lt;/code&gt; 을 &lt;code&gt;POST /containers/{name}/start&lt;/code&gt; 전달하는 것은 권장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8be3c943b1609fffbfc51aad666d0a04adf83c9d" translate="yes" xml:space="preserve">
          <source>Password</source>
          <target state="translated">Password</target>
        </trans-unit>
        <trans-unit id="971727446a3e7627ce7f649cdfb169489e9350bb" translate="yes" xml:space="preserve">
          <source>Path to a Compose file, or &amp;ldquo;-&amp;ldquo; to read from stdin</source>
          <target state="translated">작성 파일의 경로 또는 stdin에서 읽을&amp;ldquo;-&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="9d9e6791324b9349fa7664bfee386745e210219d" translate="yes" xml:space="preserve">
          <source>Path to a Distributed Application Bundle file</source>
          <target state="translated">분산 응용 프로그램 번들 파일의 경로</target>
        </trans-unit>
        <trans-unit id="6f0b3f5cfdceda12eb75a14223743358648835b4" translate="yes" xml:space="preserve">
          <source>Path to the PEM-formatted root CA certificate to use for the new cluster</source>
          <target state="translated">새 클러스터에 사용할 PEM 형식의 루트 CA 인증서 경로</target>
        </trans-unit>
        <trans-unit id="6069c61633d84f3aa0aa544eed2c97c82d1d7618" translate="yes" xml:space="preserve">
          <source>Path to the PEM-formatted root CA key to use for the new cluster</source>
          <target state="translated">새 클러스터에 사용할 PEM 형식의 루트 CA 키 경로</target>
        </trans-unit>
        <trans-unit id="93245c49296746a4c679d0454d021efbf89f625e" translate="yes" xml:space="preserve">
          <source>Path to the signer&amp;rsquo;s public key file</source>
          <target state="translated">서명자의 공개 키 파일 경로</target>
        </trans-unit>
        <trans-unit id="19a7d4879989252ab1b28a655bfda46d26bc6195" translate="yes" xml:space="preserve">
          <source>Pause all processes within one or more containers</source>
          <target state="translated">하나 이상의 컨테이너 내에서 모든 프로세스 일시 중지</target>
        </trans-unit>
        <trans-unit id="54c2fa4a2fc554403d0627ace2fc3d910226cc30" translate="yes" xml:space="preserve">
          <source>Pause container during commit</source>
          <target state="translated">커밋 중 컨테이너 일시 중지</target>
        </trans-unit>
        <trans-unit id="8f2e2b2ce2a8cae64328d6d50c37cd74ab0aaa58" translate="yes" xml:space="preserve">
          <source>Pauses running containers of a service. They can be unpaused with &lt;code&gt;docker-compose unpause&lt;/code&gt;.</source>
          <target state="translated">서비스의 컨테이너 실행을 일시 중지합니다. &lt;code&gt;docker-compose unpause&lt;/code&gt; 로 일시 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41f4d6cdfd12f3a300dd7657d6084c74ab33a3fc" translate="yes" xml:space="preserve">
          <source>Pending services</source>
          <target state="translated">보류 서비스</target>
        </trans-unit>
        <trans-unit id="17aadc976d1d1fbd5a80c0291f878a418a003747" translate="yes" xml:space="preserve">
          <source>Perform I/O port operations (iopl(2) and ioperm(2)).</source>
          <target state="translated">I / O 포트 작업을 수행하십시오 (iopl (2) 및 ioperm (2)).</target>
        </trans-unit>
        <trans-unit id="4a1137a9348dfbbcaa3db3d6eda5c91d9d3a52c7" translate="yes" xml:space="preserve">
          <source>Perform a range of system administration operations.</source>
          <target state="translated">다양한 시스템 관리 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3b23332f4443743e1739a2846788df8a75cd7565" translate="yes" xml:space="preserve">
          <source>Perform a rolling restart with no parameter changes</source>
          <target state="translated">매개 변수 변경없이 롤링 재시작을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9887f3d6c196c4bc3fdf4b1070458deac77d5658" translate="yes" xml:space="preserve">
          <source>Perform privileged syslog(2) operations.</source>
          <target state="translated">권한있는 syslog (2) 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="997bb6cf2ced2dbab6b4fc5994f23c9695379b7b" translate="yes" xml:space="preserve">
          <source>Perform various network-related operations.</source>
          <target state="translated">다양한 네트워크 관련 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="53f5f1f3789f0a1bca49324388f61dd4531f2980" translate="yes" xml:space="preserve">
          <source>Persist the data</source>
          <target state="translated">데이터 지속</target>
        </trans-unit>
        <trans-unit id="3b2ff85a578feb9159297fb10a47edbaa81f8410" translate="yes" xml:space="preserve">
          <source>Place the completion script in &lt;code&gt;/etc/bash_completion.d/&lt;/code&gt;.</source>
          <target state="translated">완료 스크립트를 &lt;code&gt;/etc/bash_completion.d/&lt;/code&gt; 에 두십시오 .</target>
        </trans-unit>
        <trans-unit id="c87618444aa3f4a2d24058d5bce42f8c904a8c5d" translate="yes" xml:space="preserve">
          <source>Place the completion script in your &lt;code&gt;/path/to/zsh/completion&lt;/code&gt; (typically &lt;code&gt;~/.zsh/completion/&lt;/code&gt;):</source>
          <target state="translated">완성 스크립트를 &lt;code&gt;/path/to/zsh/completion&lt;/code&gt; (일반적으로 &lt;code&gt;~/.zsh/completion/&lt;/code&gt; )에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="ed212fa164b940b935ec0a25b32878a0917c7268" translate="yes" xml:space="preserve">
          <source>Placeholder</source>
          <target state="translated">Placeholder</target>
        </trans-unit>
        <trans-unit id="5efa4698cc4a2ecef0e36dba8ffe62770feac0a6" translate="yes" xml:space="preserve">
          <source>Placement constraints</source>
          <target state="translated">게재 위치 제약</target>
        </trans-unit>
        <trans-unit id="4e3da24b6b45c64dc492b35972dffce04479c21c" translate="yes" xml:space="preserve">
          <source>Placement preferences</source>
          <target state="translated">게재 위치 환경 설정</target>
        </trans-unit>
        <trans-unit id="e88f819d7eba4eecc1ecf79796677247dfa8c739" translate="yes" xml:space="preserve">
          <source>Placement preferences are ignored for global services.</source>
          <target state="translated">글로벌 서비스의 경우 게재 위치 환경 설정이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d053dbea924adbc9bd2bc3f6837f4b9bf55cc7e4" translate="yes" xml:space="preserve">
          <source>Placement preferences are not strictly enforced. If no node has the label you specify in your preference, the service is deployed as though the preference were not set.</source>
          <target state="translated">게재 위치 환경 설정이 엄격하게 시행되지는 않습니다. 기본 설정에 지정한 레이블이있는 노드가없는 경우 기본 설정이 설정되지 않은 것처럼 서비스가 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="86d9b5e20b9a9ad65414fab59b46f1ed02b06ba0" translate="yes" xml:space="preserve">
          <source>Play in a content trust sandbox</source>
          <target state="translated">콘텐츠 신뢰 샌드 박스에서 재생</target>
        </trans-unit>
        <trans-unit id="98b1d0fa06c86b8807d0abf7ced317733bc874dc" translate="yes" xml:space="preserve">
          <source>Play in the sandbox</source>
          <target state="translated">샌드 박스에서 재생</target>
        </trans-unit>
        <trans-unit id="2026b80b01f24d73ef453daeb710907a374b7d17" translate="yes" xml:space="preserve">
          <source>Please also refer to &lt;a href=&quot;https://github.com/docker/docker/issues/27358&quot;&gt;#27358&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/docker/docker/issues/27358&quot;&gt;# 27358&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6da345e1d29d0f82bf6b73f4e7fa6e79c85db885" translate="yes" xml:space="preserve">
          <source>Please note that this feature is still marked as experimental as metrics and metric names could change while this feature is still in experimental. Please provide feedback on what you would like to see collected in the API.</source>
          <target state="translated">이 기능은 아직 실험 중이지만 측정 항목 및 측정 항목 이름이 변경 될 수 있으므로이 기능은 여전히 ​​실험용으로 표시되어 있습니다. API에서 수집하고자하는 것에 대한 피드백을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="de570bdfa2e520422da550cba38f1d435701c84a" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;../run/index&quot;&gt;run command&lt;/a&gt; section and the &lt;a href=&quot;../../run/index&quot;&gt;Docker run reference&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../run/index&quot;&gt;실행 명령&lt;/a&gt; 섹션과 &lt;a href=&quot;../../run/index&quot;&gt;Docker 실행 참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8dc208f8ebe86aa9ee6a37d49d48058be5364bff" translate="yes" xml:space="preserve">
          <source>Plugin</source>
          <target state="translated">Plugin</target>
        </trans-unit>
        <trans-unit id="b71dffcffbffb137808664aae679caa7c5a21536" translate="yes" xml:space="preserve">
          <source>Plugin -&amp;gt; Daemon</source>
          <target state="translated">플러그인-&amp;gt; 데몬</target>
        </trans-unit>
        <trans-unit id="3e993fb78f6f894c7a2bc0b9bd80d229ec2bb7ec" translate="yes" xml:space="preserve">
          <source>Plugin Config Version 1 of Plugin V2</source>
          <target state="translated">플러그인 V2의 플러그인 구성 버전 1</target>
        </trans-unit>
        <trans-unit id="c6bcefd1b4d77ea43f800d4350893db442b559f2" translate="yes" xml:space="preserve">
          <source>Plugin ID</source>
          <target state="translated">플러그인 ID</target>
        </trans-unit>
        <trans-unit id="50b08f5da49b98e81ee6b91d554e02d6b92b7c81" translate="yes" xml:space="preserve">
          <source>Plugin activation</source>
          <target state="translated">플러그인 활성화</target>
        </trans-unit>
        <trans-unit id="cc8dad0046d72c53deb228f14a0ed8112e94a381" translate="yes" xml:space="preserve">
          <source>Plugin configs describe the various constituents of a docker plugin. Plugin configs can be serialized to JSON format with the following media types:</source>
          <target state="translated">플러그인 구성은 도커 플러그인의 다양한 구성 요소를 설명합니다. 플러그인 구성은 다음 미디어 유형을 사용하여 JSON 형식으로 직렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7639154da8dfdc3de5768f4b00981ccba60aeca5" translate="yes" xml:space="preserve">
          <source>Plugin description</source>
          <target state="translated">플러그인 설명</target>
        </trans-unit>
        <trans-unit id="94f75e286909cfd972aaa8dfe165655a724e0824" translate="yes" xml:space="preserve">
          <source>Plugin discovery</source>
          <target state="translated">플러그인 발견</target>
        </trans-unit>
        <trans-unit id="8dc90cdf79ef04ddef300b3fdb54c67ce30416b2" translate="yes" xml:space="preserve">
          <source>Plugin lifecycle</source>
          <target state="translated">플러그인 라이프 사이클</target>
        </trans-unit>
        <trans-unit id="b229694d8e767055af222791318a9c6fc5fbffbf" translate="yes" xml:space="preserve">
          <source>Plugin name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb433013e222af7cf463f48487a54c69acdf3c41" translate="yes" xml:space="preserve">
          <source>Plugin retries</source>
          <target state="translated">플러그인 재시도</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="cfa6d1a53ba3a4ef942e9f062e2d93196e38199a" translate="yes" xml:space="preserve">
          <source>Plugins are &lt;em&gt;not&lt;/em&gt; activated automatically at Docker daemon startup. Rather, they are activated only lazily, or on-demand, when they are needed.</source>
          <target state="translated">Docker 데몬 시작시 플러그인이 자동으로 활성화 &lt;em&gt;되지 않습니다&lt;/em&gt; . 오히려 필요할 때 게 으르거나 주문형으로 만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="91e22543ab196a98d092894b784203373c899f94" translate="yes" xml:space="preserve">
          <source>Plugins are activated via the following &amp;ldquo;handshake&amp;rdquo; API call.</source>
          <target state="translated">플러그인은 다음 &quot;핸드 셰이크&quot;API 호출을 통해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e64feb815d435a8b3fdfce1bfa403114253b344f" translate="yes" xml:space="preserve">
          <source>Plugins are distributed as Docker images and can be hosted on Docker Hub or on a private registry.</source>
          <target state="translated">플러그인은 Docker 이미지로 배포되며 Docker Hub 또는 개인 레지스트리에서 호스팅 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9f04bf98bed0a130c171c94a05bf9204e0039e" translate="yes" xml:space="preserve">
          <source>Plugins can run inside or outside containers. Currently running them outside containers is recommended.</source>
          <target state="translated">플러그인은 컨테이너 내부 또는 외부에서 실행될 수 있습니다. 현재 컨테이너 외부에서 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="37fbd85ad573061dc266b5276458b28cb095f239" translate="yes" xml:space="preserve">
          <source>Plugins extend Docker&amp;rsquo;s functionality. They come in specific types. For example, a &lt;a href=&quot;../plugins_volume/index&quot;&gt;volume plugin&lt;/a&gt; might enable Docker volumes to persist across multiple Docker hosts and a &lt;a href=&quot;../plugins_network/index&quot;&gt;network plugin&lt;/a&gt; might provide network plumbing.</source>
          <target state="translated">플러그인은 Docker의 기능을 확장합니다. 그들은 특정 유형으로 제공됩니다. 예를 들어, &lt;a href=&quot;../plugins_volume/index&quot;&gt;볼륨 플러그인&lt;/a&gt; 을 사용하면 Docker 볼륨이 여러 Docker 호스트에서 지속될 수 있고 &lt;a href=&quot;../plugins_network/index&quot;&gt;네트워크 플러그인&lt;/a&gt; 이 네트워크 배관을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edf908cfee3def6a053e85cab7d58420a089a602" translate="yes" xml:space="preserve">
          <source>Plugins have human-readable names, which are short, lowercase strings. For example, &lt;code&gt;flocker&lt;/code&gt; or &lt;code&gt;weave&lt;/code&gt;.</source>
          <target state="translated">플러그인에는 사람이 읽을 수있는 이름이 있으며 짧은 소문자 문자열입니다. 예를 들어, &lt;code&gt;flocker&lt;/code&gt; 또는 &lt;code&gt;weave&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7887064441a8eb8da08d39e163f5e591e6d30806" translate="yes" xml:space="preserve">
          <source>Plugins helpers</source>
          <target state="translated">플러그인 헬퍼</target>
        </trans-unit>
        <trans-unit id="e5b16233f1bd3a5a1ba5044d76f708ca87b6ff47" translate="yes" xml:space="preserve">
          <source>Plugins may also be socket activated by &lt;code&gt;systemd&lt;/code&gt;. The official &lt;a href=&quot;https://github.com/docker/go-plugins-helpers&quot;&gt;Plugins helpers&lt;/a&gt; natively supports socket activation. In order for a plugin to be socket activated it needs a &lt;code&gt;service&lt;/code&gt; file and a &lt;code&gt;socket&lt;/code&gt; file.</source>
          <target state="translated">플러그인은 &lt;code&gt;systemd&lt;/code&gt; 에 의해 소켓 활성화 될 수도 있습니다 . 공식 &lt;a href=&quot;https://github.com/docker/go-plugins-helpers&quot;&gt;플러그인 도우미는&lt;/a&gt; 기본적으로 소켓 활성화를 지원합니다. 플러그인을 소켓으로 활성화하려면 &lt;code&gt;service&lt;/code&gt; 파일과 &lt;code&gt;socket&lt;/code&gt; 파일 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="2a6d516295bc1d09b9f89131b5aa5107571bc6c2" translate="yes" xml:space="preserve">
          <source>Plugins should be started before Docker, and stopped after Docker. For example, when packaging a plugin for a platform which supports &lt;code&gt;systemd&lt;/code&gt;, you might use &lt;a href=&quot;http://www.freedesktop.org/software/systemd/man/systemd.unit.html#Before=&quot;&gt;&lt;code&gt;systemd&lt;/code&gt; dependencies&lt;/a&gt; to manage startup and shutdown order.</source>
          <target state="translated">플러그인은 Docker 전에 시작하고 Docker 후에 중지해야합니다. 예를 들어 &lt;code&gt;systemd&lt;/code&gt; 를 지원하는 플랫폼 용 플러그인을 패키징 할 때 &lt;a href=&quot;http://www.freedesktop.org/software/systemd/man/systemd.unit.html#Before=&quot;&gt; &lt;code&gt;systemd&lt;/code&gt; 종속성&lt;/a&gt; 을 사용하여 시작 및 종료 순서를 관리 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44f4d53d6503e7da5e8024b606059822dc1b85d6" translate="yes" xml:space="preserve">
          <source>Plugins with UNIX domain socket files must run on the same docker host, whereas plugins with spec or json files can run on a different host if a remote URL is specified.</source>
          <target state="translated">UNIX 도메인 소켓 파일이있는 플러그인은 동일한 도커 호스트에서 실행해야하지만 spec 또는 json 파일이있는 플러그인은 원격 URL이 지정된 경우 다른 호스트에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7907580d9da808085c46fb9046413bc3bd1592af" translate="yes" xml:space="preserve">
          <source>Point the Machine CLI at a running, managed host, and you can run &lt;code&gt;docker&lt;/code&gt; commands directly on that host. For example, run &lt;code&gt;docker-machine env default&lt;/code&gt; to point to a host called &lt;code&gt;default&lt;/code&gt;, follow on-screen instructions to complete &lt;code&gt;env&lt;/code&gt; setup, and run &lt;code&gt;docker ps&lt;/code&gt;, &lt;code&gt;docker run hello-world&lt;/code&gt;, and so forth.</source>
          <target state="translated">Machine CLI를 실행중인 관리 호스트를 가리키면 해당 호스트에서 &lt;code&gt;docker&lt;/code&gt; 명령을 직접 실행할 수 있습니다 . 예를 들어, &lt;code&gt;docker-machine env default&lt;/code&gt; 를 실행 하여 &lt;code&gt;default&lt;/code&gt; 라는 호스트를 가리키고 화면 지침에 따라 &lt;code&gt;env&lt;/code&gt; 설정 을 완료 하고 &lt;code&gt;docker ps&lt;/code&gt; , &lt;code&gt;docker run hello-world&lt;/code&gt; 등을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb9cf1418089b3356038fdd24fcbdc9d1a7c42a5" translate="yes" xml:space="preserve">
          <source>Policy</source>
          <target state="translated">Policy</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="e2834b914ae6ad9da4d7f7d6b96e5839728c2c90" translate="yes" xml:space="preserve">
          <source>Port 4789 UDP for the container ingress network.</source>
          <target state="translated">컨테이너 수신 네트워크의 포트 4789 UDP.</target>
        </trans-unit>
        <trans-unit id="40e9d60b3088e83ac2856cc8cf5b694380e2f72e" translate="yes" xml:space="preserve">
          <source>Port 7946 TCP/UDP for container network discovery.</source>
          <target state="translated">컨테이너 네트워크 감지를위한 포트 7946 TCP / UDP.</target>
        </trans-unit>
        <trans-unit id="75c7965c32690d1bbfe98557d3bcecab4c5db601" translate="yes" xml:space="preserve">
          <source>Port &lt;code&gt;4789&lt;/code&gt; UDP for the container ingress network.</source>
          <target state="translated">컨테이너 수신 네트워크의 포트 &lt;code&gt;4789&lt;/code&gt; UDP.</target>
        </trans-unit>
        <trans-unit id="b13d947ccc8cb121f51dad844c2a458b5870bbbc" translate="yes" xml:space="preserve">
          <source>Port &lt;code&gt;7946&lt;/code&gt; TCP/UDP for container network discovery.</source>
          <target state="translated">컨테이너 네트워크 감지를위한 포트 &lt;code&gt;7946&lt;/code&gt; TCP / UDP.</target>
        </trans-unit>
        <trans-unit id="df48a1572fba3282821e0031b5821bd8317ccb52" translate="yes" xml:space="preserve">
          <source>Port &lt;code&gt;9323&lt;/code&gt; is the &lt;a href=&quot;https://github.com/prometheus/prometheus/wiki/Default-port-allocations&quot;&gt;default port associated with Docker metrics&lt;/a&gt; to avoid collisions with other prometheus exporters and services.</source>
          <target state="translated">포트 &lt;code&gt;9323&lt;/code&gt; 은 다른 prometheus 수출 업체 및 서비스와의 충돌을 피하기 위해 &lt;a href=&quot;https://github.com/prometheus/prometheus/wiki/Default-port-allocations&quot;&gt;Docker 메트릭과 관련된 기본 포트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2af2113d430bfe2537bd44d9b2908e9d1397cf9f" translate="yes" xml:space="preserve">
          <source>Port number to use for data path traffic (1024 - 49151). If no value is set or is set to 0, the default port (4789) is used.</source>
          <target state="translated">데이터 경로 트래픽에 사용할 포트 번호입니다 (1024-49151). 값을 설정하지 않거나 0으로 설정하면 기본 포트 (4789)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e54f772a9b2f49ef3c6d13b9ad60e8fb609d5c46" translate="yes" xml:space="preserve">
          <source>Portable: You can build locally, deploy to the cloud, and run anywhere.</source>
          <target state="translated">이식성 : 로컬로 구축하고 클라우드에 배포하며 어디에서나 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4cc1e942dd745a70735346c978a329639378251" translate="yes" xml:space="preserve">
          <source>Ports 2377 and 2376</source>
          <target state="translated">포트 2377 및 2376</target>
        </trans-unit>
        <trans-unit id="5bea54f3d577287d26cd10c55ebc0c745ed7ae93" translate="yes" xml:space="preserve">
          <source>Ports &lt;code&gt;[]Port&lt;/code&gt;</source>
          <target state="translated">포트 &lt;code&gt;[]Port&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84c5ae0bbd8024e56c45650ccf16082b90ee0d8b" translate="yes" xml:space="preserve">
          <source>Portworx Volume Plugin</source>
          <target state="translated">Portworx 볼륨 플러그인</target>
        </trans-unit>
        <trans-unit id="126d733d8446c249f670f205a1980b5b1d7aec26" translate="yes" xml:space="preserve">
          <source>Possible attacks given the credentials compromised:</source>
          <target state="translated">자격 증명이 손상된 경우 가능한 공격 :</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="577b0162b58dc91263eefd50cff6bbf2ea494ba1" translate="yes" xml:space="preserve">
          <source>Pre-create check</source>
          <target state="translated">사전 작성 확인</target>
        </trans-unit>
        <trans-unit id="58028731b427df98000072cc5c8a3e07e39a2515" translate="yes" xml:space="preserve">
          <source>Pre-release builds allow you to try out new features before they are released, but may be less stable.</source>
          <target state="translated">시험판 빌드에서는 새로운 기능이 출시되기 전에 시험해 볼 수 있지만 안정성이 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cae006bc50359ea57934aa69d89479751d42acf" translate="yes" xml:space="preserve">
          <source>Pre-releases built from the &amp;ldquo;master&amp;rdquo; branch are also available for download at &lt;a href=&quot;https://dl.bintray.com/docker-compose/master/&quot;&gt;https://dl.bintray.com/docker-compose/master/&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;마스터&amp;rdquo;지점에서 구축 된 시험판은 &lt;a href=&quot;https://dl.bintray.com/docker-compose/master/&quot;&gt;https://dl.bintray.com/docker-compose/master/&lt;/a&gt; 에서 다운로드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03f8e591992a2ce8e066e9197885123ad874f6fa" translate="yes" xml:space="preserve">
          <source>Predefined ARGs</source>
          <target state="translated">사전 정의 된 ARG</target>
        </trans-unit>
        <trans-unit id="3d1d1d8fc2786ebd1ac066593436b63974765e7e" translate="yes" xml:space="preserve">
          <source>Prefix the User-Agent in Linode API calls with some &amp;lsquo;product/version&amp;rsquo;</source>
          <target state="translated">일부 '제품 / 버전'으로 Linode API 호출에서 사용자 에이전트 접두사</target>
        </trans-unit>
        <trans-unit id="f56944df6198ec662e7bc049b12413296e192475" translate="yes" xml:space="preserve">
          <source>Prepare your Docker environment</source>
          <target state="translated">Docker 환경 준비</target>
        </trans-unit>
        <trans-unit id="913e15af4af11782e0856b203b2d34948bce7c44" translate="yes" xml:space="preserve">
          <source>Prerequisite information</source>
          <target state="translated">전제 조건 정보</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="44ad950f753dfba196aa135c51a16fc97ed5570a" translate="yes" xml:space="preserve">
          <source>Preserve volume data when containers are created</source>
          <target state="translated">컨테이너가 생성 될 때 볼륨 데이터 유지</target>
        </trans-unit>
        <trans-unit id="fe798b6700e1007667487ac7cd69a37e777e2d5b" translate="yes" xml:space="preserve">
          <source>Pretty-print configs using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 구성</target>
        </trans-unit>
        <trans-unit id="8a522da4427f8e00da6d3b0f859d8cbf253db181" translate="yes" xml:space="preserve">
          <source>Pretty-print containers using a Go template</source>
          <target state="translated">Go 템플릿을 사용하여 예쁜 프린트 컨테이너</target>
        </trans-unit>
        <trans-unit id="754a0902bc7bfb77dc579c622f479242a9281bef" translate="yes" xml:space="preserve">
          <source>Pretty-print contexts using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 컨텍스트</target>
        </trans-unit>
        <trans-unit id="6e030ca67191e4611f980befa4f91854bb21e109" translate="yes" xml:space="preserve">
          <source>Pretty-print images using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 이미지 인쇄</target>
        </trans-unit>
        <trans-unit id="ab7a8b2db7fe44ae0d32e44bf7df4225c716c9e4" translate="yes" xml:space="preserve">
          <source>Pretty-print licenses using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 라이센스</target>
        </trans-unit>
        <trans-unit id="428344a5b3e079e1554c7db65fd568a27060577e" translate="yes" xml:space="preserve">
          <source>Pretty-print networks using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 네트워크</target>
        </trans-unit>
        <trans-unit id="cbde1b5d55657ff086b8e9a45016a41a38fa2098" translate="yes" xml:space="preserve">
          <source>Pretty-print nodes using a Go template</source>
          <target state="translated">Go 템플릿을 사용하여 예쁜 인쇄 노드</target>
        </trans-unit>
        <trans-unit id="949d8c3219e0429db671c5264e59dcbdc3ef6936" translate="yes" xml:space="preserve">
          <source>Pretty-print plugins using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 플러그인</target>
        </trans-unit>
        <trans-unit id="a6b4b602d685d020e770bf7497c2022220878338" translate="yes" xml:space="preserve">
          <source>Pretty-print search using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 정밀한 인쇄 검색</target>
        </trans-unit>
        <trans-unit id="49772036e49194eb1b8046fdbf5a39d95a1d861f" translate="yes" xml:space="preserve">
          <source>Pretty-print secrets using a Go template</source>
          <target state="translated">Go 템플릿을 사용하여 예쁜 인쇄 비밀</target>
        </trans-unit>
        <trans-unit id="666c884f24f78b50337a35ebc219eaf5babe03a0" translate="yes" xml:space="preserve">
          <source>Pretty-print services using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 서비스</target>
        </trans-unit>
        <trans-unit id="86bb359f69cde38cf55d5604e8139e26d825966f" translate="yes" xml:space="preserve">
          <source>Pretty-print stacks using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 스택</target>
        </trans-unit>
        <trans-unit id="f61b3ff93ba02dd0b478ac5555b4027eae730370" translate="yes" xml:space="preserve">
          <source>Pretty-print tasks using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 작업</target>
        </trans-unit>
        <trans-unit id="68c1487e3726fb54c1efe85f328b307126784e87" translate="yes" xml:space="preserve">
          <source>Pretty-print updates using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 업데이트</target>
        </trans-unit>
        <trans-unit id="39223d19105deef8dd168755351e5eb4bb60ec66" translate="yes" xml:space="preserve">
          <source>Pretty-print volumes using a Go template</source>
          <target state="translated">Go 템플릿을 사용한 멋진 인쇄 볼륨</target>
        </trans-unit>
        <trans-unit id="0595de42b5c72136b2bb1096defe3bc30dca18a1" translate="yes" xml:space="preserve">
          <source>Prevent container from enabling BSD emulation. Not inherently dangerous, but poorly tested, potential for a lot of kernel vulns.</source>
          <target state="translated">컨테이너가 BSD 에뮬레이션을 활성화하지 못하게합니다. 본질적으로 위험하지는 않지만 테스트가 잘 안되어 많은 커널 취약점이 발생할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c6554bcee4610c2972001e75ed770b574c77f8" translate="yes" xml:space="preserve">
          <source>Prevent containers from modifying kernel I/O privilege levels. Already gated by &lt;code&gt;CAP_SYS_RAWIO&lt;/code&gt;.</source>
          <target state="translated">컨테이너가 커널 I / O 권한 수준을 수정하지 못하게합니다. &lt;code&gt;CAP_SYS_RAWIO&lt;/code&gt; 에 의해 이미 게이트되었습니다 .</target>
        </trans-unit>
        <trans-unit id="19416d1135af45b9c308e99573158a832792620d" translate="yes" xml:space="preserve">
          <source>Prevent containers from using the kernel keyring, which is not namespaced.</source>
          <target state="translated">컨테이너가 네임 스페이스가 아닌 커널 키링을 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="3c2f51e62a8f9c187996e5f620033a19527a6d03" translate="yes" xml:space="preserve">
          <source>Prevent truncating output</source>
          <target state="translated">절단 출력 방지</target>
        </trans-unit>
        <trans-unit id="a84d01d5b275ea9d0030dfd274fdcd6c82e4d7af" translate="yes" xml:space="preserve">
          <source>Print sizes and dates in human readable format</source>
          <target state="translated">사람이 읽을 수있는 형식으로 크기 및 날짜 인쇄</target>
        </trans-unit>
        <trans-unit id="3f59f5b92107ad3a1f427ddd0d0049b0d2218ede" translate="yes" xml:space="preserve">
          <source>Print the information in a human friendly format</source>
          <target state="translated">인간 친화적 인 형식으로 정보를 인쇄하십시오</target>
        </trans-unit>
        <trans-unit id="26e1fc5b8021bc711f4ebdb20ac0fcd5671898be" translate="yes" xml:space="preserve">
          <source>Print usage</source>
          <target state="translated">인쇄 사용법</target>
        </trans-unit>
        <trans-unit id="cbbe6bb7beb995f2142dca21518c41d5f6f8aa63" translate="yes" xml:space="preserve">
          <source>Prints machine configuration details.</source>
          <target state="translated">기계 구성 세부 사항을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="feec73470d0734a79004e622c117295120daf19d" translate="yes" xml:space="preserve">
          <source>Prints the public port for a port binding.</source>
          <target state="translated">포트 바인딩을위한 공용 포트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c6df5f0cf30d9ff7bc94e0c7ffb7fd4035fb69bc" translate="yes" xml:space="preserve">
          <source>Prior to Docker Engine 1.11, this feature was only in the experimental branch.</source>
          <target state="translated">Docker Engine 1.11 이전에는이 ​​기능이 실험 브랜치에만있었습니다.</target>
        </trans-unit>
        <trans-unit id="2e27f70e5aaa10827ce1e5c80a0cb82a423669a3" translate="yes" xml:space="preserve">
          <source>Prioritize your build cache for automatic pruning</source>
          <target state="translated">자동 정리를 위해 빌드 캐시 우선 순위 지정</target>
        </trans-unit>
        <trans-unit id="faae17d8a26a29ab73e0fc35e24381d009eaacdb" translate="yes" xml:space="preserve">
          <source>Privileged user requirement</source>
          <target state="translated">권한이있는 사용자 요구 사항</target>
        </trans-unit>
        <trans-unit id="907f6c92f4018615ebbe5892e2dda9e906f8f1a3" translate="yes" xml:space="preserve">
          <source>Produce a bundle</source>
          <target state="translated">번들 제작</target>
        </trans-unit>
        <trans-unit id="8d8b92039adbb55588c1a3f3a5866620fbb0a49d" translate="yes" xml:space="preserve">
          <source>Produce a very basic Nginx configuration that serves static files over HTTPS. The TLS certificate and key are stored as Docker secrets so that they can be rotated easily.</source>
          <target state="translated">HTTPS를 통해 정적 파일을 제공하는 매우 기본적인 Nginx 구성을 생성하십시오. TLS 인증서 및 키는 쉽게 회전 할 수 있도록 Docker 비밀로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7499a8d4c7fb43b25db15b5952a60e426782df78" translate="yes" xml:space="preserve">
          <source>Produces a tarred repository to the standard output stream. Contains all parent layers, and all tags + versions, or specified &lt;code&gt;repo:tag&lt;/code&gt;, for each argument provided.</source>
          <target state="translated">표준 출력 스트림에 Tarred 저장소를 생성합니다. 제공된 각 인수에 대해 모든 상위 계층과 모든 태그 + 버전 또는 지정된 &lt;code&gt;repo:tag&lt;/code&gt; 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1220642cea0d0c90bbd1df159757c28f2cd50248" translate="yes" xml:space="preserve">
          <source>Progress bars are shown during docker push, which show the uncompressed size. The actual amount of data that&amp;rsquo;s pushed will be compressed before sending, so the uploaded size will not be reflected by the progress bar.</source>
          <target state="translated">도커 푸시 중에 진행률 막대가 표시되며 압축되지 않은 크기가 표시됩니다. 푸시 된 실제 데이터 양은 전송하기 전에 압축되므로 업로드 된 크기는 진행률 표시 줄에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41992b8e36073f5197a8edb1164977d2ba1bed29" translate="yes" xml:space="preserve">
          <source>Promote one or more nodes to manager in the swarm</source>
          <target state="translated">떼에서 관리자로 하나 이상의 노드를 승격</target>
        </trans-unit>
        <trans-unit id="e56c12679afc8f6a8bfc60298813d1a14cd77a65" translate="yes" xml:space="preserve">
          <source>Promote or demote a node</source>
          <target state="translated">노드 승격 또는 강등</target>
        </trans-unit>
        <trans-unit id="c6710aebbc524e06fef830bd8fc0568ece59cf02" translate="yes" xml:space="preserve">
          <source>Promotes a node to manager. This command can only be executed on a manager node.</source>
          <target state="translated">관리자에게 노드를 승격시킵니다. 이 명령은 관리자 노드에서만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="407839201484d395b708b2a873b1d747d5e849ca" translate="yes" xml:space="preserve">
          <source>Protect the Docker daemon socket</source>
          <target state="translated">Docker 데몬 소켓 보호</target>
        </trans-unit>
        <trans-unit id="1ed77c3f7ffc41a33eadccef5727dc7c97079235" translate="yes" xml:space="preserve">
          <source>Protocol</source>
          <target state="translated">Protocol</target>
        </trans-unit>
        <trans-unit id="9ea643f84d4be07fb1686b9eca656c971e1f2c5f" translate="yes" xml:space="preserve">
          <source>Protocol (tcp or udp), such as &lt;code&gt;DB_PORT_5432_TCP_PROTO=tcp&lt;/code&gt;</source>
          <target state="translated">프로토콜 (tcp 또는 udp) (예 : &lt;code&gt;DB_PORT_5432_TCP_PROTO=tcp&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ce69723f471a366edcf71d404ce2bd8f1dbc7944" translate="yes" xml:space="preserve">
          <source>Provide a password using STDIN</source>
          <target state="translated">STDIN을 사용하여 비밀번호 제공</target>
        </trans-unit>
        <trans-unit id="0256ed21adc63bb10951fc8d4202ae7c63cc3e3e" translate="yes" xml:space="preserve">
          <source>Provide credential specs for managed service accounts</source>
          <target state="translated">관리 서비스 계정에 대한 자격 증명 사양 제공</target>
        </trans-unit>
        <trans-unit id="6841e977382053501f1c6f54c93fe3d064b50068" translate="yes" xml:space="preserve">
          <source>Provide credential specs for managed service accounts (Windows only)</source>
          <target state="translated">관리 서비스 계정에 대한 자격 증명 사양 제공 (Windows 만 해당)</target>
        </trans-unit>
        <trans-unit id="8b4eccd10d5ab04cfe77d30e317750a9a467a348" translate="yes" xml:space="preserve">
          <source>Provide filter values (e.g. &amp;lsquo;dangling=true&amp;rsquo;)</source>
          <target state="translated">필터 값 제공 (예 : 'dangling = true')</target>
        </trans-unit>
        <trans-unit id="f47eceb4f18f91bdc7d5a2213d74077fe09fe389" translate="yes" xml:space="preserve">
          <source>Provide filter values (e.g. &amp;lsquo;driver=bridge&amp;rsquo;)</source>
          <target state="translated">필터 값 제공 (예 : 'driver = bridge')</target>
        </trans-unit>
        <trans-unit id="b8acbc23ac07d6411f534a7ff1d3d3b8e6e23947" translate="yes" xml:space="preserve">
          <source>Provide filter values (e.g. &amp;lsquo;enabled=true&amp;rsquo;)</source>
          <target state="translated">필터 값 제공 (예 : 'enabled = true')</target>
        </trans-unit>
        <trans-unit id="66737167e69e74ac23ead0e5177643524b6b02c8" translate="yes" xml:space="preserve">
          <source>Provide filter values (e.g. &amp;lsquo;label=</source>
          <target state="translated">필터 값을 제공하십시오 (예 : 'label =</target>
        </trans-unit>
        <trans-unit id="1d096a90df1e81562bb2e3b146ebe2f495995e82" translate="yes" xml:space="preserve">
          <source>Provide filter values (e.g. &amp;lsquo;until=</source>
          <target state="translated">필터 값을 제공하십시오 (예 : 'until =</target>
        </trans-unit>
        <trans-unit id="ae8af9b038076a29d4353adba1d939362320d08b" translate="yes" xml:space="preserve">
          <source>Provide filter values (e.g. &amp;lsquo;unused-for=24h&amp;rsquo;)</source>
          <target state="translated">필터 값 제공 (예 : 'unused-for = 24h')</target>
        </trans-unit>
        <trans-unit id="9a400695bff7285f99290d5046a3b7477437dae7" translate="yes" xml:space="preserve">
          <source>Provision Swarm clusters</source>
          <target state="translated">스웜 클러스터 제공</target>
        </trans-unit>
        <trans-unit id="7ebd7fea22fbebc79217b43ea8d66c5ed7dc36e4" translate="yes" xml:space="preserve">
          <source>Provision a Docker Swarm cluster with Docker Machine</source>
          <target state="translated">Docker Machine을 사용하여 Docker Swarm 클러스터 프로비저닝</target>
        </trans-unit>
        <trans-unit id="b202115f93e71bee0b3d14819fef068d4d208db6" translate="yes" xml:space="preserve">
          <source>Provision and manage multiple remote Docker hosts</source>
          <target state="translated">여러 원격 Docker 호스트 프로비저닝 및 관리</target>
        </trans-unit>
        <trans-unit id="06da911d1a4c05ee006ae9cbfa03109f32ec4c99" translate="yes" xml:space="preserve">
          <source>Provision multiple Docker hosts &lt;a href=&quot;../get-started-cloud/index&quot;&gt;on your cloud provider&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../get-started-cloud/index&quot;&gt;클라우드 제공 업체에서&lt;/a&gt; 여러 Docker 호스트 프로비저닝</target>
        </trans-unit>
        <trans-unit id="1539ecb216aa4f6e8d8b3fcb79c236d5c190f264" translate="yes" xml:space="preserve">
          <source>Provisioning a host is a complex matter that can fail for a lot of reasons. Your workstation may have a wide variety of shell, network configuration, VPN, proxy or firewall issues. There are also reasons from the other end of the chain: your cloud provider or the network in between.</source>
          <target state="translated">호스트 프로비저닝은 여러 가지 이유로 실패 할 수있는 복잡한 문제입니다. 워크 스테이션에는 다양한 셸, 네트워크 구성, VPN, 프록시 또는 방화벽 문제가있을 수 있습니다. 체인의 다른 쪽 끝에서 클라우드 공급자 또는 네트워크 사이의 이유도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f5eaae08983390d8ce4c9882399d9547d42a4fa" translate="yes" xml:space="preserve">
          <source>Proxy all received signals to the process</source>
          <target state="translated">수신 된 모든 신호를 프로세스에 프록시</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
